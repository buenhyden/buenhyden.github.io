<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>기록하고 기억하고 활용하자. 👋</h1></header><div class=entry-content>이 블로그는 인공지능(AI), 백엔드 개발, 클라우드 및 클라우드 네이티브 기술, 컴퓨터 과학 등 다양한 기술 분야에 대한 학습 내용을 정리하는 공간입니다. 각 분야의 기초 개념부터 최신 기술 동향, 실무 적용 사례 그리고 구현 예제까지를 정리하고 이를 지식화하려고 합니다. 기술의 이론적 배경뿐만 아니라 실제 구현 방법, 모범 사례, 문제 해결 접근법 등 실용적인 내용도 같이 다루어 실무에서 활용할 수 있는 능력을 배양하고자 합니다.</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/buenhyden target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/hyunyoun-jo-9ba782164/ target=_blank rel="noopener noreferrer me" title=Linkedin><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=mailto:chochyjj@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Performance vs Scalability</h2></header><div class=entry-content><p>Performance Vs Scalability 성능 (Performance) 과 확장성 (Scalability) 은 시스템 설계에서 핵심적인 두 축이다. 성능은 시스템이 현재 주어진 자원으로 얼마나 빠르게 작업을 수행하는지를 의미하며, 확장성은 시스템이 증가하는 부하나 사용자 수에 따라 성능을 유지하거나 향상시킬 수 있는 능력을 말한다. 각각 단일 요청 처리 효율과 부하 증가 대응 능력을 의미한다. 이 두 개념은 서로 보완적이며, 시스템 설계 시 목적과 상황에 따라 적절히 균형을 맞추는 것이 중요합니다. 2025 년 현재 클라우드 네이티브 아키텍처와 AI 기반 자동화 기술이 이 분야의 핵심 트렌드로 부상하고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-18 05:08:00 +0000 UTC'>February 18, 2025</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Performance vs Scalability" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/quality-attributes/performance-vs-scalability/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>State Representation</h2></header><div class=entry-content><p>상태 표현(State Representation) 상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.
Branch and Bound 알고리즘에서 상태 표현은 다음과 같은 중요한 역할을 한다:
문제 공간 표현: 가능한 모든 해결책(solution space)을 체계적으로 표현한다. 탐색 진행 상황 추적: 알고리즘이 문제 공간을 탐색하는 과정에서 현재 위치를 나타낸다. 한계값(bound) 계산 지원: 각 상태에서 가능한 최적값의 상한 또는 하한을 계산할 수 있게 한다. 가지치기(pruning) 결정 기반: 더 이상 탐색할 가치가 없는 상태를 식별하는 데 사용된다. 상태 표현의 주요 특성 및 고려 사항 상태 표현의 완전성(Completeness)
상태 표현은 문제의 모든 가능한 해결책을 표현할 수 있어야 한다.
불완전한 상태 표현은 최적해를 놓치게 할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Representation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>가지치기(Pruning)</h2></header><div class=entry-content><p>가지치기(Pruning) 가지치기는 백트래킹 과정에서 더 이상 유망하지 않은(promising하지 않은) 경로를 조기에 차단하는 기법이다.
즉, 특정 경로가 해결책으로 이어질 가능성이 없다고 판단되면, 그 경로를 더 이상 탐색하지 않고 바로 다른 경로를 탐색합니다.
가지치기의 중요성 효율성 향상: 불필요한 탐색을 줄여 알고리즘의 실행 시간을 크게 단축한다. 자원 절약: 메모리 사용량을 줄이고 CPU 자원을 효율적으로 사용한다. 실용성 증대: 가지치기 없이는 현실적으로 해결하기 어려운 복잡한 문제도 해결 가능하게 만든다. 가지치기 적용 방법 가지치기를 적용하는 핵심은 ‘유망성 테스트(promising test)‘이다.
각 단계에서 현재 상태가 최종 해결책으로 이어질 가능성이 있는지를 판단하는 함수를 만들어 사용한다.
...</p></div><footer class=entry-footer><span title='2024-12-29 14:00:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가지치기(Pruning)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/pruning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Algorithmic Thinking</h2></header><div class=entry-content><p>Algorithmic Thinking 알고리즘적 사고는 현대 디지털 사회에서 문제 해결의 핵심이 되는 인지적 접근 방식.
이는 단순히 컴퓨터 프로그래밍에만 국한되지 않고, 다양한 분야에서 체계적이고 효율적인 문제 해결을 위한 사고 방식으로 발전해왔다.
정의와 본질 알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.
이는 다음과 같은 핵심 특성을 가진다:
단계적 분해: 복잡한 문제를 작고 관리 가능한 부분들로 나누는 능력 논리적 순서화: 문제 해결 단계를 효율적이고 논리적인 순서로 배열하는 능력 추상화: 문제의 본질을 파악하고 불필요한 세부사항을 제거하는 능력 패턴 인식: 문제들 사이의 공통점을 찾고 일반화하는 능력 효율성 고려: 자원(시간, 공간 등)을 최적화하는 해결책을 모색하는 능력 알고리즘적 사고의 구성 요소 문제 분해(Decomposition)
복잡한 문제를 더 작고 관리 가능한 부분들로 나누는 과정:
...</p></div><footer class=entry-footer><span title='2024-12-27 07:00:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Algorithmic Thinking" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/basic-concepts/algorithmic-thinking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>꼬리 재귀(Tail Recursion)</h2></header><div class=entry-content><p>꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.
꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.
특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.
일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.
각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.
입력값이 크면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 꼬리 재귀(Tail Recursion)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Preorder Traversal</h2></header><div class=entry-content><p>전위 순회(Preorder Traversal) 전위 순회(Preorder Traversal)는 트리 자료구조를 탐색하는 가장 기본적인 방법 중 하나이다.
전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태이다.
이 방법에서는 다음과 같은 순서로 노드를 방문한다:
현재 노드(루트)를 방문합니다. 왼쪽 서브트리를 전위 순회한다. 오른쪽 서브트리를 전위 순회한다. 이 과정은 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 “전위(Pre)“는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Preorder Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ECMAScript</h2></header><div class=entry-content><p>ECMAScript ECMAScript는 자바스크립트의 표준 규격으로, Ecma International이 ECMA-262 기술 규격을 통해 정의한 스크립트 프로그래밍 언어이다.
1997년 처음 표준화되었으며, 자바스크립트의 핵심 문법과 기능을 규정한다.
ECMAScript는 ECMA 인터내셔널(ECMA International)에서 제정한 스크립트 프로그래밍 언어의 표준 사양이다.
이 표준은 다양한 스크립트 언어의 상호 운용성을 보장하기 위해 만들어졌으며, JavaScript, JScript, ActionScript 등이 ECMAScript 표준을 준수한다.
ECMAScript는 1997년에 첫 번째 버전이 발표된 이후 지속적으로 발전해 왔다.
주요 버전으로는 2015년에 발표된 ECMAScript 6(ES6), 2016년의 ECMAScript 2016(ES7), 2017년의 ECMAScript 2017(ES8) 등이 있으며, 각 버전마다 새로운 기능과 개선 사항이 추가되었다.
...</p></div><footer class=entry-footer><span title='2024-12-04 17:43:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ECMAScript" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/es6+/ecmascript/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Semantic Web</h2></header><div class=entry-content><p>Semantic Web 시맨틱 웹(Semantic Web)은 웹 데이터에 의미를 부여해 기계가 이해하고 처리할 수 있도록 하는 차세대 웹 기술이다.
팀 버너스리가 1998년 제안한 개념으로, 데이터 간 의미적 연결과 자동화된 추론을 핵심 목표로 한다.
W3C 표준화가 지속적으로 진행 중이며, 다양한 분야에서 활용되고 있다.
시맨틱 웹의 핵심 개념 정의
웹 자원(문서, 이미지, 서비스) 간의 의미 관계를 기계가 이해할 수 있도록 구조화하는 기술. RDF(Resource Description Framework), 온톨로지(Ontology) 등을 활용해 메타데이터를 부여. 목적
데이터 통합: 분산된 웹 정보를 의미론적으로 연결. 자동 추론: 규칙 기반으로 새로운 정보 유도. 검색 효율화: 키워드가 아닌 의미 기반 검색 가능. 기술 구성 요소 및 계층 구조 1. 핵심 기술 기술 설명 XML 구조화된 데이터 표현을 위한 확장 가능한 마크업 언어. RDF 주어-서술어-목적어(Triple) 형태로 자원 관계 표현. 예: &lt;http://daum.net, 소유, http://kakaocorp.com>. OWL 도메인 지식을 공식적으로 정의하는 온톨로지 언어. SPARQL RDF 데이터 쿼리 언어. 2. 계층 구조 (Layer Cake) URI/Unicode: 자원 식별 XML/RDF: 데이터 구조화 및 관계 정의 RDFS/OWL: 온톨로지 기반 의미 확장 Logic/Proof: 추론 규칙 적용. https://ko.wikipedia.org/wiki/%EC%8B%9C%EB%A7%A8%ED%8B%B1_%EC%9B%B9
...</p></div><footer class=entry-footer><span title='2024-12-04 12:51:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Semantic Web" href=https://buenhyden.github.io/posts/emerging-technologies/blockchain-and-distributed-ledger/blockchain/semantic-web/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터 레이크 vs 데이터 웨어하우스 vs 데이터 레이크하우스</h2></header><div class=entry-content><p>데이터 레이크 vs. 데이터 웨어하우스 vs. 데이터 레이크하우스 데이터 레이크(Data Lake)와 데이터 웨어하우스(Data Warehouse)는 기업의 데이터 관리 및 분석을 위한 중요한 저장소 시스템입니다.
많은 기업들은 데이터 레이크와 데이터 웨어하우스를 함께 사용하여 각각의 장점을 활용하고 있습니다.
데이터 레이크를 통해 대량의 원시 데이터를 저장하고, 필요한 데이터를 추출하여 데이터 웨어하우스에서 분석하는 방식으로 활용합니다.
https://www.databricks.com/kr/glossary/data-lakehouse
데이터 레이크 (Data Lake) 데이터 레이크(Data Lake)는 대규모의 다양한 데이터를 원시 형태로 저장하고 관리하는 중앙 집중식 저장소입니다.
...</p></div><footer class=entry-footer><span title='2024-10-26 05:24:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터 레이크 vs 데이터 웨어하우스 vs 데이터 레이크하우스" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-lake-vs-data-warehouse-vs-data-lakehouse/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCPIP 4 Layers vs. OSI 7 Layers</h2></header><div class=entry-content><p>TCPIP 4 Layers vs. OSI 7 Layers 네트워크 통신을 이해하기 위한 두 가지 주요 참조 모델인 OSI 7계층과 TCP/IP 4계층 모델은 네트워크 통신과 프로토콜에 대한 개념적 프레임워크를 제공한다.
두 모델은 서로 다른 접근 방식과 구조를 가지고 있지만, 궁극적인 목표는 동일하다:
시스템 간의 효율적이고 신뢰할 수 있는 통신을 가능하게 하는 것
OSI 7계층 모델과 TCP/IP 4계층 모델은 각각 고유한 장점과 특성을 가지고 있다.
OSI 모델은 더 세분화되고 개념적인 접근을 제공하여 네트워크 통신의 복잡성을 이해하는 데 유용한 프레임워크를 제공한다. 반면 TCP/IP 모델은 실용적이고 구현 중심적인 접근으로 현대 인터넷의 기반을 형성했다.
...</p></div><footer class=entry-footer><span title='2024-10-19 02:11:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCPIP 4 Layers vs. OSI 7 Layers" href=https://buenhyden.github.io/posts/systems/networking-and-communication/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>