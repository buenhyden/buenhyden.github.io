<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.151.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>기록하고 기억하고 활용하자. 👋</h1></header><div class=entry-content>이 블로그는 인공지능(AI), 백엔드 개발, 클라우드 및 클라우드 네이티브 기술, 컴퓨터 과학 등 다양한 기술 분야에 대한 학습 내용을 정리하는 공간입니다. 각 분야의 기초 개념부터 최신 기술 동향, 실무 적용 사례 그리고 구현 예제까지를 정리하고 이를 지식화하려고 합니다. 기술의 이론적 배경뿐만 아니라 실제 구현 방법, 모범 사례, 문제 해결 접근법 등 실용적인 내용도 같이 다루어 실무에서 활용할 수 있는 능력을 배양하고자 합니다.</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/buenhyden target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/hyunyoun-jo-9ba782164/ target=_blank rel="noopener noreferrer me" title=Linkedin><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=mailto:chochyjj@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design Overview</h2></header><div class=entry-content><p>System Design System Design 은 요구사항을 충족하는 대규모 시스템을 설계하고 구성하는 과정으로, 기능적/비기능적 요구사항을 고려해 컴포넌트 간 관계, 데이터 흐름, 장애 대응, 확장 구조를 정의한다. 이는 클라우드 환경, 분산 시스템, 고가용성 아키텍처 설계 등과 밀접하며, 효율적인 아키텍처 설계를 통해 성능, 확장성, 유지보수성을 극대화하는 것이 목적이다. 실무에서는 설계 원칙과 패턴, 트레이드오프 분석 등이 핵심이다.
등장 배경 및 발전 과정 시스템 디자인은 인터넷과 클라우드 컴퓨팅의 발전과 함께 등장했다.
초기 단일 서버 아키텍처에서 시작하여 웹 2.0 시대의 대용량 트래픽 처리 필요성, 클라우드 컴퓨팅의 보편화, 마이크로서비스 아키텍처의 등장으로 발전해왔다.
...</p></div><footer class=entry-footer><span title='2025-05-27 08:37:00 +0000 UTC'>May 27, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Design Overview" href=https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>꼬리 재귀(Tail Recursion)</h2></header><div class=entry-content><p>꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.
꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.
특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.
일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.
각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.
입력값이 크면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 꼬리 재귀(Tail Recursion)" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ECMAScript</h2></header><div class=entry-content><p>ECMAScript ECMAScript는 자바스크립트의 표준 규격으로, Ecma International이 ECMA-262 기술 규격을 통해 정의한 스크립트 프로그래밍 언어이다.
1997년 처음 표준화되었으며, 자바스크립트의 핵심 문법과 기능을 규정한다.
ECMAScript는 ECMA 인터내셔널(ECMA International)에서 제정한 스크립트 프로그래밍 언어의 표준 사양이다.
이 표준은 다양한 스크립트 언어의 상호 운용성을 보장하기 위해 만들어졌으며, JavaScript, JScript, ActionScript 등이 ECMAScript 표준을 준수한다.
ECMAScript는 1997년에 첫 번째 버전이 발표된 이후 지속적으로 발전해 왔다.
주요 버전으로는 2015년에 발표된 ECMAScript 6(ES6), 2016년의 ECMAScript 2016(ES7), 2017년의 ECMAScript 2017(ES8) 등이 있으며, 각 버전마다 새로운 기능과 개선 사항이 추가되었다.
...</p></div><footer class=entry-footer><span title='2024-12-04 17:43:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ECMAScript" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/es6+-features/ecmascript/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Semantic Web</h2></header><div class=entry-content><p>Semantic Web 시맨틱 웹(Semantic Web)은 웹 데이터에 의미를 부여해 기계가 이해하고 처리할 수 있도록 하는 차세대 웹 기술이다.
팀 버너스리가 1998년 제안한 개념으로, 데이터 간 의미적 연결과 자동화된 추론을 핵심 목표로 한다.
W3C 표준화가 지속적으로 진행 중이며, 다양한 분야에서 활용되고 있다.
시맨틱 웹의 핵심 개념 정의
웹 자원(문서, 이미지, 서비스) 간의 의미 관계를 기계가 이해할 수 있도록 구조화하는 기술. RDF(Resource Description Framework), 온톨로지(Ontology) 등을 활용해 메타데이터를 부여. 목적
데이터 통합: 분산된 웹 정보를 의미론적으로 연결. 자동 추론: 규칙 기반으로 새로운 정보 유도. 검색 효율화: 키워드가 아닌 의미 기반 검색 가능. 기술 구성 요소 및 계층 구조 1. 핵심 기술 기술 설명 XML 구조화된 데이터 표현을 위한 확장 가능한 마크업 언어. RDF 주어-서술어-목적어(Triple) 형태로 자원 관계 표현. 예: &lt;http://daum.net, 소유, http://kakaocorp.com>. OWL 도메인 지식을 공식적으로 정의하는 온톨로지 언어. SPARQL RDF 데이터 쿼리 언어. 2. 계층 구조 (Layer Cake) URI/Unicode: 자원 식별 XML/RDF: 데이터 구조화 및 관계 정의 RDFS/OWL: 온톨로지 기반 의미 확장 Logic/Proof: 추론 규칙 적용. https://ko.wikipedia.org/wiki/%EC%8B%9C%EB%A7%A8%ED%8B%B1_%EC%9B%B9
...</p></div><footer class=entry-footer><span title='2024-12-04 12:51:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Semantic Web" href=https://buenhyden.github.io/posts/emerging-technologies/blockchain-and-distributed-ledger/blockchain/semantic-web/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Lake vs. Data Warehouse vs. Data Lakehouse</h2></header><div class=entry-content><p>Data Lake vs. Data Warehouse vs. Data Lakehouse https://www.databricks.com/kr/glossary/data-lakehouse
1. 태그 Data-Lake, Data-Warehouse, Data-Lakehouse, Data-Architecture
2. 계층 구조 적합성 및 의견 현재 “Data Lake vs. Data Warehouse vs. Data Lakehouse” 비교 주제는 “Software Engineering > Design and Architecture > Architecture Styles and Patterns > Architecture Styles > Data-Centric Architecture” 카테고리에 적합함.
만약 추가 세분화가 필요하다면 아래 구조도 고려할 수 있음.
Computer Science and Engineering
└─ Software Engineering
└─ Design and Architecture
└─ Data Architecture Styles
└─ [Data Lake, Data Warehouse, Data Lakehouse Architecture] 근거:
→ 세 개의 아키텍처는 데이터 중심 구조 (Data-Centric Architecture) 에서 실제로 데이터 저장·분석 관점의 대표적 스타일이므로, 데이터 아키텍처 (Data Architecture) 레벨에서 한 번 더 분류하면 관리 및 설명에 용이함.
...</p></div><footer class=entry-footer><span title='2024-10-26 05:24:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Lake vs. Data Warehouse vs. Data Lakehouse" href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-warehousing/modern-approaches/dl-vs-dwh-vs-dlh/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬은 가장 간단하고 직관적인 정렬 알고리즘 중 하나이다.
이름에서 알 수 있듯이, 마치 물속에서 공기 방울이 떠오르는 것처럼 큰 값들이 배열의 끝으로 ‘부글부글’ 올라가는 모습을 연상시킨다.
이 알고리즘은 단순함 때문에 컴퓨터 과학 입문 과정에서 가장 먼저 배우는 정렬 알고리즘이지만, 실제 응용에서는 비효율성 때문에 잘 사용되지 않는다. 그럼에도 불구하고, 버블 정렬의 작동 방식과 특성을 이해하는 것은 다른 정렬 알고리즘의 기초를 다지는 데 중요하다.
버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 구현이 쉽고 이해하기 직관적이다. 그러나 O(n²)의 시간 복잡도로 인해 대규모 데이터셋에서는 비효율적이며, 실제 응용에서는 퀵 정렬, 병합 정렬, 힙 정렬과 같은 더 효율적인 알고리즘들이 선호된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/bubble-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Native Compiler</h2></header><div class=entry-content><p>Native Compiler Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.
네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler" href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/native-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Flow</h2></header><div class=entry-content><p>Git Flow Git Flow 는 Vincent Driessen 이 2010 년 제안한 Git 브랜치 관리 전략으로, 프로젝트의 개발, 릴리스, 유지보수를 효과적으로 수행할 수 있도록 고안되었다. 각 브랜치의 역할을 명확히 정의하여 협업과 코드 품질을 향상시킨다. 주요 브랜치로는 main, develop, feature, release, hotfix 가 있으며, 각 브랜치는 특정 목적에 따라 생성되고 병합된다.
핵심 개념 브랜치 기반의 워크플로우 모델로, 각 브랜치가 명확한 목적과 생명주기를 가지고 있다. 이를 통해 기능 개발, 릴리즈 준비, 버그 수정 등의 작업을 체계적으로 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Flow" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/branch-strategies/git-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Basic Commands</h2></header><div class=entry-content><p>Git Basic Commands Git Basic Commands는 버전 관리 시스템인 Git을 사용하기 위한 필수 명령어들의 집합입니다. 이 명령어들은 코드의 버전 관리, 협업, 이력 추적을 가능하게 하는 기본 도구이다. init, clone, add, commit, push, pull 등의 핵심 명령어들은 모든 Git 사용자가 일상적으로 사용하는 작업의 기반을 형성한다. 이러한 기본 명령어들을 이해하고 숙달하는 것은 효과적인 소프트웨어 개발과 팀 협업의 필수 요소이다.
핵심 개념 Git Basic Commands는 저장소 초기화, 변경사항 추적, 커밋 생성, 원격 저장소와의 동기화를 수행하는 기본 명령어들의 집합이다. 예를 들어, git add는 변경된 파일을 커밋 대상으로 지정하고, git commit은 실제로 변경 사항을 저장소에 기록한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:12:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Basic Commands" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/git-basic-commands/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Software Engineering Overview</h2></header><div class=entry-content><p>Software Engineering 소프트웨어 공학은 설계 원칙과 프로세스 모델을 기반으로 안정적이고 유지보수 가능한 시스템을 만드는 분야이다. 요구사항 정의 단계에서부터, 구조 설계 (아키텍처), 구현, 검증 (테스트), 배포, 유지보수까지 전 과정을 체계화한다. SOLID, SoC, DRY 등의 설계 원칙과 애자일, DevOps, CI/CD, Secure‑by‑Design 등의 방법론을 통해 품질 및 효율을 높인다. 실무에서는 조직규모, 도메인, 기술스택에 따라 프로젝트 특성에 맞는 전략이 요구된다.
핵심 개념 분류 개념 정확한 유형 설명 및 근거 기초 개념 소프트웨어 생명주기 (SDLC) 모델 / 프로세스 계획 → 폐기의 전 과정 (Waterfall, Agile 등은 모델) 요구사항 엔지니어링 활동 (Activity) 요구사항 분석, 명세, 검증, 관리 과정 소프트웨어 아키텍처 개념 / 설계 산출물 시스템 구조의 상위 수준 표현 품질 보증 (Quality Assurance) 프로세스 / 활동 품질 보장을 위한 테스트 및 검토 활동 심화 개념 모듈화 (Modularity) 설계 기법 / 원리 기능을 독립 모듈로 분리 추상화 (Abstraction) 설계 원리 (Design Principle) 복잡성 관리 기법 캡슐화 (Encapsulation) 객체지향 설계 원칙 정보 은닉을 통한 안정성 확보 의존성 관리 설계 기법 / 원리 모듈 간 결합도 최소화 설계 원칙 SOLID 객체지향 설계 원칙 (OOP Principles) 5 가지 핵심 원칙 (Robert C. Martin) SoC (Separation of Concerns) 설계 원리 (Architectural Principle) 관심사 분리를 통한 유지보수성 향상 KISS 설계 원리 (Heuristic Design Principle) 단순한 설계 지향 DRY 설계 원리 (Heuristic Design Principle) 중복 최소화 Secure-by-Design 보안 설계 전략 설계 단계에서 보안 내재화 생명주기 모델 Waterfall 생명주기 모델 (프로세스) 단계별 순차적 개발, 각 단계가 명확히 구분 [5]. Agile 생명주기 모델/방법론 반복적, 점진적, 협업 강조, 변화에 유연 [5]. DevOps 생명주기 모델/방법론 개발과 운영 통합, 자동화 및 협업 강조 [5]. Spiral 생명주기 모델 (프로세스) 위험 분석과 반복적 개발 결합 [5]. 프로세스 모델 DevOps 문화 + 자동화 프로세스 개발과 운영의 통합 접근 방식 품질 속성 ISO/IEC 25010 품질 속성 모델 (Quality Model) 기능성, 신뢰성, 보안성 등 8 대 속성 아키텍처 스타일 계층형 (Layered) 아키텍처 스타일 (Architecture Style) 표현 구조에 기반한 통신 방식 정의 이벤트 기반 (Event-driven) 아키텍처 스타일 (Architecture Style) 비동기 이벤트 흐름 중심 구조 마이크로서비스 (Microservices) 아키텍처 스타일 (Architecture Style) 독립 배포 가능한 서비스 단위 구성 아키텍처 패턴 클린 아키텍처 (Clean Architecture) 아키텍처 패턴 (Architecture Pattern) 의존성 역전 및 계층 분리 명확 도구 및 자동화 Git, CI/CD, 테스트 자동화, ASE 도구 / 자동화 기술 개발 및 품질 보증 자동화 지원 도구 협업 방법론 애자일 (Scrum, Kanban) 협업 방법론 / 개발 방법론 반복적 개발과 빠른 피드백 중심 방식 DevOps 협업 문화 / 프로세스 통합 프레임워크 자동화 기반의 개발–운영 연계 플랫폼 엔지니어링 운영 전략 / 엔지니어링 접근법 개발자 생산성 향상을 위한 내부 플랫폼 운영 품질 속성 기능성 (Functionality) 품질 속성 요구사항에 맞는 기능 제공 신뢰성 (Reliability) 품질 속성 오류 없이 안정적으로 동작 사용성 (Usability) 품질 속성 사용자가 쉽게 사용할 수 있음 유지보수성 (Maintainability) 품질 속성 변경, 수정, 확장이 용이함 효율성 (Efficiency) 품질 속성 자원 활용 및 성능 최적화 보안 (Security) 품질 속성/설계 원칙 외부 위협으로부터 안전하게 보호 이식성 (Portability) 품질 속성 다양한 환경에서 실행 가능 배경 초기 소프트웨어 개발:
1960 년대 이전까지는 소프트웨어 개발이 비체계적이고, 예산 초과, 일정 지연, 품질 저하 등 문제가 많았음. 소프트웨어 위기:
1960~70 년대, 소프트웨어의 복잡성 증가로 인해 소프트웨어 위기 (Software Crisis) 가 발생. 소프트웨어 공학 등장:
1968 년 NATO 소프트웨어 공학 회의에서 ’ 소프트웨어 공학 ’ 개념이 공식화됨. 현대:
SDLC, Agile, DevOps 등 다양한 방법론과 도구가 발전하며 효율적이고 신뢰성 높은 소프트웨어 개발이 가능해짐. 소프트웨어 위기 (Software Crisis) 란 1960 년대 후반부터 본격적으로 대두된 용어로, 소프트웨어 개발 및 유지보수 과정에서 발생하는 일련의 심각한 관리상 문제를 의미한다. 이는 컴퓨터 하드웨어의 성능이 빠르게 발전하고, 소프트웨어의 규모와 복잡성이 급격히 증가함에 따라 기존의 개발 방법론과 도구들이 부적합해지면서 나타난 현상이다.
소프트웨어 위기의 대표적인 증상은 다음과 같다: - 프로젝트 일정 및 예산 초과: 개발이 예정보다 오래 걸리고, 비용이 증가함. - 소프트웨어 품질 저하: 버그와 결함이 많아지고, 사용자 요구를 충족시키지 못함. - 유지보수의 어려움: 설계가 변경에 유연하지 못해 유지보수 비용이 증가함. - 프로젝트 관리의 어려움: 코드 관리와 프로젝트 통제가 힘들어짐. - 소프트웨어의 미전달: 최종적으로 소프트웨어가 고객에게 전달되지 못하는 경우도 발생
오늘날에는 ‘모던 소프트웨어 위기 (Modern Software Crisis)’ 혹은 ‘소프트웨어 난제 (Software Complexity Problem)’ 이라는 형태로 지속되고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 10:20:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Engineering Overview" href=https://buenhyden.github.io/posts/software-development--engineering/overview/software-engineering/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>