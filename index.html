<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi there 👋</h1></header><div class=entry-content>환영합니다.</div><footer class=entry-footer><div class=social-icons><a href=https://github.com/buenhyden target=_blank rel="noopener noreferrer me" title=Github><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</a><a href=https://www.linkedin.com/in/hyunyoun-jo-9ba782164/ target=_blank rel="noopener noreferrer me" title=Linkedin><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6z"/><rect x="2" y="9" width="4" height="12"/><circle cx="4" cy="4" r="2"/></svg>
</a><a href=mailto:chochyjj@gmail.com target=_blank rel="noopener noreferrer me" title=Email><svg viewBox="0 0 24 21" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></footer></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>State Representation</h2></header><div class=entry-content><p>상태 표현(State Representation) 상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.
Branch and Bound 알고리즘에서 상태 표현은 다음과 같은 중요한 역할을 한다:
문제 공간 표현: 가능한 모든 해결책(solution space)을 체계적으로 표현한다. 탐색 진행 상황 추적: 알고리즘이 문제 공간을 탐색하는 과정에서 현재 위치를 나타낸다. 한계값(bound) 계산 지원: 각 상태에서 가능한 최적값의 상한 또는 하한을 계산할 수 있게 한다. 가지치기(pruning) 결정 기반: 더 이상 탐색할 가치가 없는 상태를 식별하는 데 사용된다. 상태 표현의 주요 특성 및 고려 사항 상태 표현의 완전성(Completeness)
상태 표현은 문제의 모든 가능한 해결책을 표현할 수 있어야 한다.
불완전한 상태 표현은 최적해를 놓치게 할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2611 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Representation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>가지치기(Pruning)</h2></header><div class=entry-content><p>가지치기(Pruning) 가지치기는 백트래킹 과정에서 더 이상 유망하지 않은(promising하지 않은) 경로를 조기에 차단하는 기법이다.
즉, 특정 경로가 해결책으로 이어질 가능성이 없다고 판단되면, 그 경로를 더 이상 탐색하지 않고 바로 다른 경로를 탐색합니다.
가지치기의 중요성 효율성 향상: 불필요한 탐색을 줄여 알고리즘의 실행 시간을 크게 단축한다. 자원 절약: 메모리 사용량을 줄이고 CPU 자원을 효율적으로 사용한다. 실용성 증대: 가지치기 없이는 현실적으로 해결하기 어려운 복잡한 문제도 해결 가능하게 만든다. 가지치기 적용 방법 가지치기를 적용하는 핵심은 ‘유망성 테스트(promising test)‘이다.
각 단계에서 현재 상태가 최종 해결책으로 이어질 가능성이 있는지를 판단하는 함수를 만들어 사용한다.
...</p></div><footer class=entry-footer><span title='2024-12-29 14:00:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1158 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가지치기(Pruning)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/pruning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Algorithmic Thinking</h2></header><div class=entry-content><p>Algorithmic Thinking 알고리즘적 사고는 현대 디지털 사회에서 문제 해결의 핵심이 되는 인지적 접근 방식.
이는 단순히 컴퓨터 프로그래밍에만 국한되지 않고, 다양한 분야에서 체계적이고 효율적인 문제 해결을 위한 사고 방식으로 발전해왔다.
정의와 본질 알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.
이는 다음과 같은 핵심 특성을 가진다:
단계적 분해: 복잡한 문제를 작고 관리 가능한 부분들로 나누는 능력 논리적 순서화: 문제 해결 단계를 효율적이고 논리적인 순서로 배열하는 능력 추상화: 문제의 본질을 파악하고 불필요한 세부사항을 제거하는 능력 패턴 인식: 문제들 사이의 공통점을 찾고 일반화하는 능력 효율성 고려: 자원(시간, 공간 등)을 최적화하는 해결책을 모색하는 능력 알고리즘적 사고의 구성 요소 문제 분해(Decomposition)
복잡한 문제를 더 작고 관리 가능한 부분들로 나누는 과정:
...</p></div><footer class=entry-footer><span title='2024-12-27 07:00:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;642 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Algorithmic Thinking" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/algorithmic-thinking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ASCII(American Standard Code for Information Interchange)</h2></header><div class=entry-content><p>ASCII(American Standard Code for Information Interchange) ASCII는 현대 컴퓨터 시스템과 통신 프로토콜의 근간이 된 가장 기본적인 문자 인코딩 표준이다.
디지털 세계에서 텍스트 정보를 표현하는 방식의 시작점으로, 컴퓨터가 문자를 이해하고 처리하는 방식에 결정적 영향을 미쳤.
ASCII는 수십 년 전에 개발된 단순한 문자 인코딩 체계지만, 그 영향력은 오늘날 디지털 세계 전체에 걸쳐 있다.
모든 현대 텍스트 인코딩의 기초가 되었으며, 컴퓨터 시스템의 근본적인 부분으로 자리 잡았다.
개발자로서 ASCII에 대한 이해는 다음과 같은 이유로 중요하다:
...</p></div><footer class=entry-footer><span title='2024-12-13 16:20:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2065 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ASCII(American Standard Code for Information Interchange)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/character-encodings/types/ascii/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>꼬리 재귀(Tail Recursion)</h2></header><div class=entry-content><p>꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.
꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.
특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.
일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.
각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.
입력값이 크면 다음과 같은 문제가 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;511 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 꼬리 재귀(Tail Recursion)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>인접 행렬(Adjacency Matrix)</h2></header><div class=entry-content><p>인접 행렬(Adjacency Matrix) 인접 행렬은 그래프를 표현하는 가장 기본적인 방법 중 하나로, 수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.
행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.
인접 행렬은 그래프를 표현하는 직관적이고 효율적인 방법이다. 특히 간선의 존재 여부를 빠르게 확인해야 하거나, 간선이 많은 밀집 그래프를 다룰 때 유용하다. 또한, 행렬 연산을 통해 그래프의 다양한 속성을 분석할 수 있다는 장점이 있다.
하지만 정점이 많고 간선이 적은 희소 그래프에서는 메모리 사용량이 많아지는 단점이 있다. 이러한 경우에는 인접 리스트나 희소 행렬 표현과 같은 대안을 고려할 필요가 있다.
...</p></div><footer class=entry-footer><span title='2024-12-07 03:04:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2354 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인접 행렬(Adjacency Matrix)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Preorder Traversal</h2></header><div class=entry-content><p>전위 순회(Preorder Traversal) 전위 순회(Preorder Traversal)는 트리 자료구조를 탐색하는 가장 기본적인 방법 중 하나이다.
전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태이다.
이 방법에서는 다음과 같은 순서로 노드를 방문한다:
현재 노드(루트)를 방문합니다. 왼쪽 서브트리를 전위 순회한다. 오른쪽 서브트리를 전위 순회한다. 이 과정은 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 “전위(Pre)“는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1873 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Preorder Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/preorder-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Control Structures</h2></header><div class=entry-content><p>Control Structures Control Structures는 프로그램 내에서 실행 흐름을 제어하는 기본적이고 필수적인 구성 요소이다.
이 구조들은 코드의 순차적 실행, 조건에 따른 분기 처리, 그리고 반복문 실행을 통해 프로그램이 동적으로 동작할 수 있도록 돕는다.
제어 구조는 프로그래밍의 핵심 요소로, 코드의 실행 흐름을 제어하고 다양한 상황에 대응할 수 있게 한다.
순차적 구조, 선택 구조, 반복 구조 등의 기본 제어 구조부터 예외 처리, 비동기 프로그래밍을 위한 고급 제어 구조까지, 이들을 효과적으로 활용하면 더 유연하고 강력한 프로그램을 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-05 03:22:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2608 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Control Structures" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-syntax/control-structures/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ECMAScript</h2></header><div class=entry-content><p>ECMAScript ECMAScript는 자바스크립트의 표준 규격으로, Ecma International이 ECMA-262 기술 규격을 통해 정의한 스크립트 프로그래밍 언어이다.
1997년 처음 표준화되었으며, 자바스크립트의 핵심 문법과 기능을 규정한다.
ECMAScript는 ECMA 인터내셔널(ECMA International)에서 제정한 스크립트 프로그래밍 언어의 표준 사양이다.
이 표준은 다양한 스크립트 언어의 상호 운용성을 보장하기 위해 만들어졌으며, JavaScript, JScript, ActionScript 등이 ECMAScript 표준을 준수한다.
ECMAScript는 1997년에 첫 번째 버전이 발표된 이후 지속적으로 발전해 왔다.
주요 버전으로는 2015년에 발표된 ECMAScript 6(ES6), 2016년의 ECMAScript 2016(ES7), 2017년의 ECMAScript 2017(ES8) 등이 있으며, 각 버전마다 새로운 기능과 개선 사항이 추가되었다.
...</p></div><footer class=entry-footer><span title='2024-12-04 17:43:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ECMAScript" href=https://buenhyden.github.io/posts/programming-languages/javascript/ecmascript/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Infrastructure</h2></header><div class=entry-content><p>Infrastructure Infrastructure(인프라스트럭처)는 조직의 IT 환경을 지원하고 운영하는 데 필요한 기본적인 구성 요소들의 집합이다.
이는 하드웨어, 소프트웨어, 네트워크 리소스 및 서비스를 포함한다.
Infrastructure의 주요 구성 요소 하드웨어
서버: 네트워크 저장소 및 애플리케이션 처리를 제공 스토리지 장치: 하드 드라이브, SSD 등 네트워킹 장비: 라우터, 스위치, 케이블 등 데이터 센터: 중요한 IT 장비와 지원 인프라를 수용하는 시설 소프트웨어
운영 체제: 하드웨어 운영 및 애플리케이션 실행의 기반 데이터베이스: 대량의 데이터를 조직, 저장 및 접근 용이하게 함 미들웨어: 소프트웨어 애플리케이션 간 통신 및 데이터 교환을 위한 연결 계층 네트워크 인프라
...</p></div><footer class=entry-footer><span title='2024-11-10 01:29:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;204 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Infrastructure" href=https://buenhyden.github.io/posts/devops/infrastructure/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>