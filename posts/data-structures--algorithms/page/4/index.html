<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structures and Algorithms | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Data-Structures-and-Algorithms"><meta name=description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data Structures and Algorithms"><meta property="og:description" content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data Structures and Algorithms"><meta name=twitter:description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures--algorithms/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Data Structures and Algorithms</h1><div class=post-description>데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문</div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분할 정복 (Divide and Conquer)</h2></header><div class=entry-content><p>분할 정복 (Divide and Conquer) 분할 정복은 알고리즘 설계에서 가장 강력하고 널리 사용되는 패러다임 중 하나이다.
복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 이 접근법은 효율적인 알고리즘 설계의 핵심 원리이다.
정의와 원리 분할 정복(Divide and Conquer)은 복잡한 문제를 다음과 같은 세 단계로 해결하는 알고리즘 설계 기법이다:
분할(Divide): 원래 문제를 같은 유형의 더 작은 하위 문제들로 나눈다. 정복(Conquer): 하위 문제들을 재귀적으로 해결한다. 하위 문제가 충분히 작으면 직접 해결한다. 결합(Combine): 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 만든다. 분할 정복은 재귀적 사고에 기반하며, 큰 문제를 동일한 형태의 작은 문제들로 축소하여 해결하는 방식이다.
이 과정은 문제가 충분히 작아질 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분할 정복 (Divide and Conquer)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>트리 (Tree)</h2></header><div class=entry-content><p>트리 (Tree) 트리는 컴퓨터 과학에서 가장 중요하고 널리 사용되는 비선형 자료구조 중 하나이다.
계층적 관계를 표현하기에 적합한 구조로, 파일 시스템, 데이터베이스 색인, 검색 알고리즘 등 다양한 응용 분야에서 활용된다.
트리 자료구조는 컴퓨터 과학과 프로그래밍의 핵심 요소로, 다양한 문제와 응용 분야에서 중요한 역할을 한다.
기본적인 이진 트리부터 복잡한 세그먼트 트리, B+트리에 이르기까지 각 트리 자료구조는 특정 상황에 최적화된 성능과 기능을 제공한다.
최근의 트리 자료구조 연구와 활용 동향은 다음과 같다:
분산 시스템에서의 트리: 대규모 분산 시스템에서 일관성과 확장성을 보장하기 위한 특수한 트리 구조가 연구되고 있다. 인메모리 데이터베이스: 현대의 인메모리 데이터베이스는 최적화된 트리 구조를 사용하여 빠른 데이터 접근과 처리를 가능하게 한다. 기계 학습과 트리: 결정 트리와 그 앙상블(예: 랜덤 포레스트, 그래디언트 부스팅)은 해석 가능한 머신 러닝 모델로 계속해서 중요한 역할을 하고 있다. 양자 컴퓨팅과 트리: 양자 컴퓨팅 환경에서 효율적인 트리 알고리즘의 개발이 새로운 연구 영역으로 떠오르고 있다. 신경망과 트리의 결합: 트리 구조를 신경망과 결합하여 해석 가능성과 성능을 모두 개선하는 하이브리드 모델이 연구되고 있다.
트리 자료구조는 그 다양성과 적응성으로 인해 컴퓨터 과학의 발전과 함께 계속해서 진화하고 있으며, 미래의 컴퓨팅 패러다임에서도 중요한 위치를 차지할 것으로 예상되고 있다.
프로그래머와 컴퓨터 과학자는 다양한 트리 자료구조의 특성과 활용법을 잘 이해함으로써 효율적이고 견고한 소프트웨어 시스템을 설계하고 구현할 수 있다. 트리의 기본 개념 ![Tree Data Structure](Introduction-to-tree-.webp “https://www.geeksforgeeks.org/introduction-to-tree-data-structure/)
...</p></div><footer class=entry-footer><span title='2024-10-07 05:53:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 트리 (Tree)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/trees/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적 계획법 (Dynamic Programming)</h2></header><div class=entry-content><p>동적 계획법 (Dynamic Programming, DP) 동적 계획법은 컴퓨터 과학과 수학 분야에서 복잡한 문제를 더 간단한 하위 문제로 나누어 해결하는 강력한 알고리즘 설계 기법이다.
이 접근법은 특히 최적화 문제를 해결하는 데 매우 효과적이며, 다양한 응용 분야에서 널리 사용된다.
최적 부분 구조와 중복되는 하위 문제 특성을 가진 문제들에 적용할 수 있으며, 분할 정복과 달리 이미 해결한 하위 문제의 결과를 저장하고 재활용함으로써 계산 효율성을 크게 향상시킨다.
동적 계획법의 기본 개념 동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 여러 개의 겹치는 하위 문제로 나누고, 각 하위 문제를 한 번만 풀어 그 결과를 저장해두고 재활용하는 알고리즘 설계 방법이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적 계획법 (Dynamic Programming)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>탐욕 알고리즘 (Greedy Algorithm)</h2></header><div class=entry-content><p>탐욕 알고리즘 (Greedy Algorithm) 탐욕 알고리즘(Greedy Algorithm)은 최적화 문제를 해결하기 위한 간단하면서도 강력한 알고리즘 패러다임이다.
이 알고리즘은 ‘탐욕적’이라는 이름처럼, 각 단계에서 현재 상황에서 가장 좋아 보이는 선택(locally optimal choice)을 하는 방식으로 동작한다.
즉, 지금 당장 최적의 선택을 하면 전체적으로도 최적의 결과를 얻을 수 있을 것이라는 기대를 바탕으로 한다.
탐욕 알고리즘은 직관적이고 효율적인 알고리즘 설계 패러다임으로, 많은 최적화 문제에서 간단하면서도 강력한 해결책을 제공한다.
각 단계에서 현재 상황에서 가장 좋은 선택을 하는 방식으로 작동하며, 일부 문제에서는 전역 최적해를 보장한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 탐욕 알고리즘 (Greedy Algorithm)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/greedy-algorithms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>랜덤화 알고리즘 (Randomized Algorithm)</h2></header><div class=entry-content><p>랜덤화 알고리즘 (Randomized Algorithm) 랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다. 이 무작위성은 알고리즘의 동작이나 결정에 영향을 미치며, 같은 입력에 대해서도 매번 다른 결과를 낼 수 있다.
특성 무작위성: 알고리즘의 핵심 특성으로, 난수를 사용하여 결정을 내린다. 확률적 성능: 알고리즘의 성능이 확률적으로 분석된다. 다양성: 같은 입력에 대해 다양한 출력이 가능하다. 목적과 필요성 복잡한 문제의 간단한 해결책 제공 최악의 경우 성능 개선 결정론적 알고리즘의 한계 극복 평균 실행 시간 단축 장점 단순성: 복잡한 문제에 대해 간단한 해결책 제공 효율성: 많은 경우에 결정론적 알고리즘보다 빠름 유연성: 다양한 문제에 적용 가능 단점 결과의 일관성 부족: 같은 입력에 대해 다른 결과 가능 디버깅의 어려움: 무작위성으로 인해 재현이 어려울 수 있음 최악의 경우 보장 부족: 확률적 성능으로 인해 최악의 경우를 완전히 배제할 수 없음 작동 원리 문제 정의 무작위 선택 요소 식별 난수 생성기 사용 무작위 선택에 기반한 결정 결과 도출 및 분석 좋은 알고리즘의 조건 효율성: 평균적으로 좋은 성능을 보여야 함 정확성: 높은 확률로 정확한 결과를 제공해야 함 단순성: 구현과 이해가 쉬워야 함 확장성: 다양한 입력 크기에 대응할 수 있어야 함 효율적인 구현을 위한 팁 고품질의 난수 생성기 사용 무작위성의 적절한 활용 확률 분석을 통한 성능 최적화 병렬화 가능성 고려 핵심 구성 요소 난수 생성기 무작위 선택 메커니즘 결정 함수 종료 조건 실제 예시 랜덤화된 퀵 정렬 알고리즘
...</p></div><footer class=entry-footer><span title='2024-10-13 05:55:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 랜덤화 알고리즘 (Randomized Algorithm)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/randomized-algorithms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>슬라이딩 윈도우 기법 (Sliding Window Technique)</h2></header><div class=entry-content><p>슬라이딩 윈도우 기법 (Sliding Window Technique) 슬라이딩 윈도우 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 특정 범위의 요소들을 효율적으로 처리하기 위한 알고리즘 패러다임.
이 기법은 “창문(window)“처럼 움직이는 부분 배열을 이용하여 시간 복잡도를 획기적으로 개선할 수 있는 강력한 문제 해결 방법이다.
슬라이딩 윈도우 기법은 선형 데이터 구조에서 연속된 요소들을 효율적으로 처리하기 위한 강력한 알고리즘 패러다임으로 이 기법을 이해하고 적용하면 중첩 반복문을 사용하는 시간 복잡도를 O(n²)에서 O(n)으로 줄일 수 있어, 성능 개선에 크게 기여할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-24 00:21:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 슬라이딩 윈도우 기법 (Sliding Window Technique)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sliding-window/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Graph</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-01-18 03:05:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Graph" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graph-types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Greedy Algorithm vs. Divide and Conquer</h2></header><div class=entry-content><p>Divide and Conquer vs. Greedy Algorithm “Divide and Conquer"와 “Greedy Algorithm"은 문제 해결을 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.
분할 정복은 정확한 최적해를 보장하지만 구현이 복잡할 수 있고, 탐욕 알고리즘은 구현이 간단하고 효율적이지만 항상 최적해를 보장하지는 않는다. 문제의 특성을 잘 이해하고 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-28 10:55:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Greedy Algorithm vs. Divide and Conquer" href=https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/paradigm-comparison/greedy-vs-divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dynamic Programming vs. Divide and Conquer</h2></header><div class=entry-content><p>Divide and Conquer vs. Dynamic Programming “Divide and Conquer"와 “Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.
분할 정복은 문제를 독립적인 하위 문제로 나누어 효율성을 높이는 반면, 동적 계획법은 중복되는 하위 문제의 결과를 저장하여 재계산을 방지한다.
알고리즘 선택은 문제의 성격에 따라 달라져야 한다.
하위 문제 간 중복이 있는지, 최적 부분 구조가 있는지를 파악하여 적절한 알고리즘을 선택하는 것이 중요하다.
Divide and Conquer(분할 정복) 알고리즘 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 다음과 같은 세 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-12-09 05:08:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dynamic Programming vs. Divide and Conquer" href=https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/paradigm-comparison/divide-and-conquer-vs-dp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Stack vs Queue</h2></header><div class=entry-content><p>Stack vs. Queue 스택(Stack)과 큐(Queue)는 컴퓨터 과학에서 널리 사용되는 선형 자료구조로, 데이터의 저장 및 처리 방식에서 차이가 있다.
스택(Stack) 스택은 후입선출(LIFO, Last-In First-Out) 방식의 자료구조로, 가장 마지막에 삽입된 데이터가 가장 먼저 제거된다.
데이터의 삽입과 삭제는 모두 스택의 **탑(top)**에서 이루어진다.
주요 연산: 삽입(Push): 데이터를 스택의 탑에 추가한다. 삭제(Pop): 스택의 탑에 있는 데이터를 제거하고 반환한다. 탑 확인(Peek): 스택의 탑에 있는 데이터를 제거하지 않고 확인한다. 비어있는지 확인(IsEmpty): 스택이 비어 있는지 여부를 확인한다. 큐(Queue) 큐는 선입선출(FIFO, First-In First-Out) 방식의 자료구조로, 가장 먼저 삽입된 데이터가 가장 먼저 제거된다.
데이터의 삽입은 **후단(Rear)**에서, 삭제는 **전단(Front)**에서 이루어진다.
...</p></div><footer class=entry-footer><span title='2024-12-08 08:55:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stack vs Queue" href=https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/data-structure-comparisons/linear-structure-comparison/stack-vs-queue/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>