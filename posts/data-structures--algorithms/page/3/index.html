<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structures and Algorithms | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Data-Structures-and-Algorithms"><meta name=description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data Structures and Algorithms"><meta property="og:description" content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data Structures and Algorithms"><meta name=twitter:description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures--algorithms/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Data Structures and Algorithms</h1><div class=post-description>데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문</div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 테이블(Hash Table)</h2></header><div class=entry-content><p>해시 테이블(Hash Table) 해시 테이블은 키(key)와 값(value) 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 키를 배열의 인덱스로 변환해 데이터를 빠르게 삽입, 검색, 삭제할 수 있도록 설계되어 있다.
이 자료구조는 데이터 접근 시간을 평균적으로 O(1)에 가깝게 만들어 효율적인 데이터 관리가 가능하도록 한다.
![Hash table](Introduction-to-Hashing.webp “https://www.geeksforgeeks.org/hashing-data-structure/?ref=outind)
해시 테이블의 기본 개념 해시 테이블은 ‘배열’과 ‘해시 함수’를 결합한 자료구조로 각 데이터 항목이 키와 값으로 구성되며, 이 키를 해시 함수에 입력하여 정수 형태의 해시 값을 산출한 후 배열 내의 특정 인덱스로 매핑하는 방식이다.
이렇게 매핑된 인덱스(버킷 또는 슬롯이라 부름)는 데이터가 저장되는 위치로 활용되며, 단순한 배열 구조를 기반으로 한다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:54:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 테이블(Hash Table)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>부동 소수점 (Float)</h2></header><div class=entry-content><p>부동 소수점 (Float) 부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.
‘부동’은 소수점이 움직인다는 의미로, 넓은 범위의 실수를 표현할 수 있다.
특징 IEEE 754 표준을 따름 부호, 지수, 가수 부분으로 구성 IEEE 754 표준에 따른 부동 소수점 종류 Half Precision
이 형식은 가장 작은 부동 소수점 표현 방식.
16비트를 사용한다.
1비트는 부호, 5비트는 지수부, 10비트는 가수부로 구성된다.
주로 그래픽스나 머신러닝에서 메모리를 절약하기 위해 사용된다.
약 3자리의 십진 정밀도를 제공하며, ±6.1 × 10⁻⁵에서 ±6.5 × 10⁴까지의 범위를 표현할 수 있다.
예시:
Python: 1 2 3 import numpy as np x = np.float16(3.14) print(x) # 3.14 JavaScript: JavaScript는 기본적으로 Half Precision을 지원하지 않는다. 외부 라이브러리를 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부동 소수점 (Float)" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/floating-point/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>퀵 정렬 (Quick Sort)</h2></header><div class=entry-content><p>퀵 정렬 (Quick Sort) 퀵 정렬은 1960년 Tony Hoare가 개발한 효율적인 분할 정복(Divide and Conquer) 알고리즘으로, 평균적으로 매우 빠른 성능을 보이는 정렬 방식이다. 실제 많은 프로그래밍 언어의 표준 라이브러리에 구현되어 있을 정도로 실용적인 정렬 알고리즘이다.
퀵 정렬은 간단한 아이디어를 바탕으로 하면서도 매우 효율적인 정렬 알고리즘이다.
평균적인 성능이 우수하고 실제 구현에서 다양한 최적화 기법을 적용할 수 있어 많은 환경에서 선호된다.
최악의 경우를 대비한 피벗 선택 최적화와 하이브리드 접근 방식을 통해 단점을 보완하여 현대적인 정렬 알고리즘의 기반이 되고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 퀵 정렬 (Quick Sort)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/quick-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백트래킹 (Backtracking)</h2></header><div class=entry-content><p>백트래킹 (Backtracking) 백트래킹은 해결책을 찾는 과정에서 후보군을 구축하다가 해당 후보군이 해결책이 될 수 없다고 판단되면, 즉시 이전 단계로 돌아가서(백트랙) 다른 후보군을 탐색하는 문제 해결 전략이다.
알고리즘의 효율성을 높이는 중요한 기법으로, 완전 탐색보다 효율적으로 문제를 해결할 수 있게 해준다.
백트래킹은 조합 최적화 문제를 해결하는 강력한 알고리즘 패러다임이다.
모든 가능한 해결책을 체계적으로 탐색하면서도, 불가능한 경로를 조기에 차단하여 효율성을 높이는 특징이 있다.
N-Queen, 스도쿠, 미로 찾기, 조합 문제 등 다양한 영역에서 활용되며, 복잡한 문제를 해결하는 데 필수적인 도구이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 백트래킹 (Backtracking)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/back-tracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Splay Tree</h2></header><div class=entry-content><p>Splay Tree Splay Tree는 이진 검색 트리(Binary Search Tree)의 한 종류로, 데이터를 저장하고 효율적으로 검색, 삽입, 삭제할 수 있는 구조를 가지고 있다.
데이터베이스, 캐시 관리, 네트워크 라우팅 등 다양한 응용 분야에서 사용된다.
Splay Tree는 자체 균형 이진 검색 트리의 일종으로, 최근에 접근한 노드를 루트로 이동시키는 “splay” 연산을 통해 자가 조정되는 특징을 가진다.
특징 자체 균형: splay 연산을 통해 트리의 균형을 유지한다. 최근 접근 노드 최적화: 자주 접근하는 노드를 루트 근처로 이동시켜 빠른 접근을 가능하게 한다. 동적 구조: 삽입, 삭제, 검색 연산 후 트리 구조가 변경된다. 장점 구현이 상대적으로 단순하다. 자주 접근하는 데이터에 대해 빠른 접근 속도를 제공한다. 추가적인 균형 정보 저장이 필요 없다. 단점 최악의 경우 트리의 높이가 O(n)이 될 수 있다. 연산마다 트리 구조가 변경되어 예측이 어려울 수 있다. 응용 캐시 관리: 최근 접근 데이터의 빠른 검색에 활용. 네트워크 라우팅: IP 라우팅 테이블 관리. 자동 완성 및 검색 엔진: 빠른 검색 결과 제공. Garbage Collector 알고리즘. 동작 원리 Splay Tree의 핵심 동작은 “splay” 연산이다.
이 연산은 다음과 같은 단계로 이루어진다:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:57:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Splay Tree" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/splay-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>스택 (Stack)</h2></header><div class=entry-content><p>스택 (Stack) 스택은 ‘쌓아올린 더미’라는 의미를 가진 자료구조로, 데이터를 차곡차곡 쌓아 올리는 형태를 취한다. 실생활에서 접시를 쌓아두거나 책을 쌓아두는 방식과 유사하다.
스택은 데이터의 삽입과 삭제가 한쪽 끝(스택의 상단 또는 top)에서만 이루어지는 제한적인 자료구조이다.
스택은 단순하지만 강력한 자료구조로, 다양한 알고리즘과 시스템에서 핵심적인 역할을 한다.
LIFO 특성을 활용하여 함수 호출 관리, 수식 계산, 구문 분석 등 다양한 문제를 효율적으로 해결할 수 있다.
스택의 모든 기본 연산이 O(1) 시간 복잡도를 가지므로 성능이 중요한 애플리케이션에서도 유용하게 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:53:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스택 (Stack)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/stack/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>힙 정렬 (Heap Sort)</h2></header><div class=entry-content><p>힙 정렬 (Heap Sort) 힙 정렬은 비교 기반 정렬 알고리즘으로, 이진 힙 자료구조를 활용하여 효율적인 정렬을 수행한다.
시간 복잡도가 안정적이고 추가 메모리를 거의 사용하지 않는 특징을 가지고 있어 많은 시스템에서 널리 사용된다.
힙 정렬은 비교 기반 정렬 알고리즘 중에서 시간 복잡도가 보장되고 추가 메모리를 거의 사용하지 않는 효율적인 알고리즘이다.
최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지며, 특히 메모리 제약이 있는 환경에서 유용하다.
불안정 정렬이라는 단점이 있지만, 안정성이 중요하지 않은 많은 응용 분야에서 여전히 강력한 선택지이다. 힙 자료구조의 이해는 우선순위 큐, 그래프 알고리즘 등 컴퓨터 과학의 다른 영역에도 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 정렬 (Heap Sort)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/heap--priority-queue/priority-queue-applications/heap-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분기 한정법 (Branch and Bound)</h2></header><div class=entry-content><p>분기 한정법 (Branch and Bound) 분기한정법(Branch and Bound)은 최적화 문제를 해결하기 위한 효율적인 알고리즘 설계 패러다임이다.
이 방법은 거대한, 때로는 지수적으로 큰 해공간을 체계적으로 탐색하면서 최적해를 찾아내는 강력한 기법이다.
분기한정법은 다양한 최적화 문제를 해결하기 위한 강력하고 유연한 알고리즘 패러다임이다.
이 방법의 핵심은 문제를 체계적으로 나누고, 각 하위 문제의 한계값을 계산하여 유망하지 않은 경로를 가지치기함으로써 탐색 공간을 효과적으로 줄이는 데 있다.
분기한정법은 외판원 문제, 배낭 문제, 작업 할당 문제 등 다양한 NP-hard 최적화 문제에 성공적으로 적용되어 왔다.
물론 최악의 경우에는 여전히 지수 시간이 필요하지만, 효과적인 한계 함수와 가지치기 전략을 통해 실용적인 시간 내에 최적해 또는 근사 최적해를 찾을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분기 한정법 (Branch and Bound)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>힙 (Heap)</h2></header><div class=entry-content><p>힙 (Heap) 힙(Heap)은 완전 이진 트리(Complete Binary Tree) 기반의 특수한 트리 자료구조로, 특정한 순서 속성을 만족한다.
특히 우선순위 큐를 구현하는 데 효율적으로 사용되며, 다양한 알고리즘에서 핵심적인 역할을 한다.
힙은 최댓값이나 최솟값에 빠르게 접근해야 하는 상황에서 매우 유용한 자료구조이다.
힙은 효율적인 우선순위 접근과 관리를 제공하는 강력한 자료구조이다.
최댓값이나 최솟값에 빠르게 접근해야 하지만 다른 요소들의 전체 정렬은 필요하지 않을 때 특히 유용하다.
효율적인 삽입, 삭제, 최댓값/최솟값 접근 연산을 통해 다양한 알고리즘과 시스템에서 중요한 역할을 수행한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 05:54:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 (Heap)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/heap--priority-queue/heaps/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>큐 (Queue)</h2></header><div class=entry-content><p>큐 (Queue) 큐는 컴퓨터 과학에서 가장 기본적이고 중요한 자료구조 중 하나이다.
일상생활에서 은행 창구나 매표소의 대기열과 같은 개념으로, 컴퓨터 과학에서도 데이터를 순서대로 처리하는 다양한 상황에 활용된다.
큐는 데이터를 일정한 순서에 따라 저장하고 접근하는 선형 자료구조이다.
큐의 가장 큰 특징은 데이터가 들어온 순서대로 처리된다는 점이다.
큐는 단순하면서도 강력한 자료구조로, 다양한 알고리즘과 시스템에서 핵심적인 역할을 한다.
FIFO 특성을 활용하여 작업 스케줄링, 버퍼링, 그래프 탐색 등 다양한 문제를 효율적으로 해결할 수 있다.
큐는 배열, 연결 리스트, 또는 이중 스택 등 다양한 방식으로 구현할 수 있으며, 각 구현 방식은 고유한 장단점을 가진다.
응용 분야와 요구사항에 따라 적절한 큐 구현을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-10-07 05:53:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 큐 (Queue)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/queue/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>