<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structures and Algorithms | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Data-Structures-and-Algorithms"><meta name=description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data Structures and Algorithms"><meta property="og:description" content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data Structures and Algorithms"><meta name=twitter:description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures--algorithms/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Data Structures and Algorithms</h1><div class=post-description>데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문</div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AVL 트리 (AVL tree)</h2></header><div class=entry-content><p>AVL 트리 (AVL tree) AVL 트리는 Adelson-Velsky와 Landis가 1962년에 발명한 자체 균형 이진 검색 트리(self-balancing binary search tree)이다.
각 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 균형 잡힌 트리 구조를 유지한다.
정렬된 정보의 빠른 저장과 검색을 위해 사용되는 자료구조이다.
https://en.wikipedia.org/wiki/AVL_tree
특징 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이(균형 인수)가 -1, 0, 1 중 하나이다. 트리의 높이는 항상 O(log N)을 유지한다 (N은 노드의 수). 자체 균형 기능으로 삽입, 삭제, 검색 연산의 시간 복잡도가 O(log N)으로 보장된다. 장점 검색, 삽입, 삭제 연산의 시간 복잡도가 O(log N)으로 보장된다. 트리의 균형을 유지하여 최악의 경우에도 효율적인 성능을 제공한다. 레드-블랙 트리에 비해 더 엄격한 균형을 유지하여 검색 작업에 더 효율적이다. 응용 데이터베이스 인덱싱 메모리 관리 시스템 파일 시스템 구현 맵(Map)과 셋(Set) 자료구조 구현 동작 원리 삽입: 새 노드를 일반 이진 검색 트리처럼 삽입한 후, 균형 인수를 확인하고 필요시 회전을 수행하여 균형을 유지한다. 일반적인 이진 탐색 트리처럼 새로운 노드를 삽입한다. 삽입 경로를 따라 올라가면서 각 노드의 높이를 갱신한다. 불균형이 발생한 경우(균형 인수의 절댓값이 2가 된 경우) 회전 연산을 수행한다. LL Case: 오른쪽 회전 RR Case: 왼쪽 회전 LR Case: 왼쪽-오른쪽 회전 RL Case: 오른쪽-왼쪽 회전 삭제: 노드를 제거한 후, 트리의 균형을 유지하기 위해 필요한 회전을 수행한다. 검색: 일반적인 이진 검색 트리와 동일한 방식으로 수행된다. 구성 요소 노드: 키 값, 왼쪽 자식 포인터, 오른쪽 자식 포인터, 높이 정보를 포함한다. 키(key): 데이터 값 높이(height): 해당 노드를 루트로 하는 서브트리의 높이 왼쪽 자식 포인터 오른쪽 자식 포인터 (선택적으로) 부모 노드 포인터 균형 인수(Balance Factor): 각 노드의 왼쪽과 오른쪽 서브트리의 높이 차이를 나타낸다. 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이 수식으로는 BF = height(left) - height(right) 이 값은 항상 -1, 0, 1 중 하나여야 합니다 회전 연산: 트리의 균형을 유지하기 위한 왼쪽 회전, 오른쪽 회전, 왼쪽-오른쪽 회전, 오른쪽-왼쪽 회전이 있다. 구현 방식 AVL 트리는 일반적으로 다음과 같은 구조로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:35:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AVL 트리 (AVL tree)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/avl-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>논리값 (Boolean)</h2></header><div class=entry-content><p>논리값 (Boolean) Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.
Boolean 데이터 타입은 참(true)과 거짓(false)의 두 가지 값만을 가질 수 있는 데이터 타입으로, 수학자 George Boole의 이름을 따서 명명되었으며, 논리 연산과 조건문에서 주로 사용된다.
특징 오직 두 가지 값만 가짐: true 또는 false 조건문과 논리 연산에서 주로 사용됨 메모리 사용이 효율적 (일반적으로 1비트만으로도 표현이 가능하다(true = 1, false = 0). 하지만 실제 프로그래밍 언어에서는 메모리 정렬(alignment) 때문에 보통 1바이트를 사용) 특성 비교 연산의 결과로 자주 생성됨 제어 흐름을 결정하는 데 중요한 역할을 함 다른 데이터 타입으로부터 변환 가능 (예: 숫자 0은 false, 나머지는 true) 연산 종류 및 설명 논리 연산 AND (&&): 두 피연산자가 모두 true일 때만 true 반환 OR (||): 두 피연산자 중 하나라도 true이면 true 반환 NOT (!): 피연산자의 값을 반전 비교 연산 동등 비교 (==, ===) 부등 비교 (!=,!==) 대소 비교 (&lt;, >, &lt;=, >=) 실제 활용 사례 및 설명 조건문에서의 사용 플래그 변수로 사용 (예: 상태 체크) 데이터 유효성 검사 각 언어별 예시와 특징 각 언어의 특징적인 부분을 살펴보면:
...</p></div><footer class=entry-footer><span title='2024-10-07 07:33:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 논리값 (Boolean)" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/boolean-logic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>이진 검색 (Binary Search)</h2></header><div class=entry-content><p>이진 검색 (Binary Search) 이진 탐색은 정렬된 배열에서 특정 값을 찾기 위한 효율적인 알고리즘이다.
일반적인 선형 탐색보다 훨씬 빠르며, 특히 대규모 데이터셋에서 그 효율성이 두드러진다.
이진 탐색은 간단하면서도 강력한 알고리즘으로, 정렬된 데이터에서 매우 효율적인 검색을 가능하게 한다.
O(log n)의 시간 복잡도는 대규모 데이터셋에서 특히 중요하다.
이 알고리즘을 마스터하면 다양한 문제 해결과 시스템 최적화에 적용할 수 있다.
이진 검색은 정렬된 리스트에서 특정 값을 찾는 효율적인 알고리즘이다.
이 알고리즘은 리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:40:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 (Binary Search)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/binary-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>검색 알고리즘 (Search Algorithms)</h2></header><div class=entry-content><p>검색 알고리즘 (Searching Algorithms) 검색 알고리즘은 데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 알고리즘이다
이러한 알고리즘은 컴퓨터 과학의 핵심 요소로, 우리가 디지털 세계에서 정보를 찾고 처리하는 방식의 기반이 된다.
검색 알고리즘의 효율성은 데이터베이스, 웹 검색 엔진, 인공지능 등 현대 기술의 성능에 직접적인 영향을 미친다.
검색 알고리즘은 컴퓨터 과학의 핵심 요소로, 데이터를 효율적으로 찾고 처리하는 기초가 된다.
순차 검색부터 이진 검색, 해시 기반 검색, 트리 기반 검색, 그래프 검색 등 다양한 검색 알고리즘이 있으며, 각각은 특정 상황과 데이터 유형에 적합한 장단점을 가지고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-14 01:27:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 검색 알고리즘 (Search Algorithms)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/searching-algorithms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>이진 검색 트리 (Binary Search Tree)</h2></header><div class=entry-content><p>이진 검색 트리 (Binary Search Tree) 이진 검색 트리(Binary Search Tree, BST)는 컴퓨터 과학에서 가장 중요한 자료구조 중 하나로, 효율적인 검색, 삽입, 삭제 연산을 제공하는 이진 트리 형태의 자료구조이다.
이진 검색 트리는 컴퓨터 과학과 소프트웨어 개발에서 중요한 위치를 차지하는 자료구조이다.
그 구조적 단순함과 직관적인 연산에도 불구하고, 효율적인 검색, 삽입, 삭제 및 정렬된 접근을 제공하여 다양한 응용 분야에서 활용되고 있다.
이진 검색 트리의 주요 장점은 다음과 같다:
효율적인 검색 연산: 균형 잡힌 트리에서는 O(log n)의 시간 복잡도로 요소를 검색할 수 있다. 동적인 크기 조정: 삽입과 삭제가 용이하므로 동적으로 변화하는 데이터셋에 적합하다. 정렬된 데이터 접근: 중위 순회를 통해 정렬된 순서로 모든 요소에 접근할 수 있다. 범위 쿼리 효율성: 특정 범위 내의 모든 요소를 효율적으로 찾을 수 있다. 확장성: 자가 균형 트리, 멀티셋 등 다양한 확장과 변형이 가능하다. 그러나 이진 검색 트리에는 몇 가지 단점도 있다:
...</p></div><footer class=entry-footer><span title='2024-10-07 12:34:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 트리 (Binary Search Tree)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/tree-structures--algorithms/binary-search-trees/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 (Character)과 문자열 (String)</h2></header><div class=entry-content><p>문자 (Character) 단일 문자를 표현하는 데이터 타입이다. 각 프로그래밍 언어별로 character의 구현과 사용 방식이 다소 다르다.
Character는 단일 문자를 나타내는 데이터 타입으로, 일반적으로 문자, 숫자, 특수 문자, 공백 등을 포함할 수 있다.
특징 고정 크기: 대부분의 언어에서 character는 고정된 메모리 크기를 가진다. 유니코드 지원: 많은 현대 프로그래밍 언어에서 유니코드 문자를 지원한다. 정수형과의 호환성: 대부분의 언어에서 character는 정수형으로 변환 가능하다. 특성 불변성: 많은 언어에서 character는 불변(immutable) 타입이다. 순서성: ASCII 또는 유니코드 값을 기반으로 순서를 가진다. 단일 값: 하나의 문자만을 저장할 수 있다. 연산 종류 및 설명 비교 연산: 문자 간 대소 비교가 가능하다. 산술 연산: 정수형으로 변환하여 산술 연산이 가능하다. 형변환: 정수형이나 문자열로의 변환이 가능하다. 실제 활용 사례 및 설명 Java Java에서는 ‘char’ 키워드를 사용하여 character를 선언한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 (Character)과 문자열 (String)" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/characters-and-strings/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정수(Integer)</h2></header><div class=entry-content><p>정수 (Integer) 정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.
특징과 특성 고정된 크기의 메모리 사용 빠른 연산 속도 범위의 제한 (오버플로우 가능성) 직접적인 산술 연산 지원 종류 byte
범위: -128 ~ 127 8비트 비트 구성: 1비트 부호 + 7비트 값 특징: 가장 작은 정수 타입 메모리 효율적이지만 표현 범위가 제한적 주로 작은 범위의 데이터나 문자 표현에 사용 short
범위: -32,768 ~ 32,767 16비트 비트 구성: 1비트 부호 + 15비트 값 특징: 8비트보다 넓은 범위 표현 가능 메모리 사용량과 표현 범위의 균형이 좋음 작은 정수 값을 다룰 때 효율적 int
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 정수(Integer)" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/primitive-types--basic-concepts/integer-types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>연결 리스트 (Linked List)</h2></header><div class=entry-content><p>연결 리스트 (Linked List) 연결 리스트(Linked List)는 노드(Node)들의 연결을 통해 데이터를 저장하는 동적 자료구조이다.
각 노드는 데이터(Data)와 다음 노드를 가리키는 포인터(Next)로 구성되며, 필요에 따라 동적으로 크기를 조절할 수 있다.
배열과 달리 메모리의 연속적인 공간을 요구하지 않으며, 삽입/삭제 연산이 효율적이다.
연결 리스트는 유연한 메모리 관리와 효율적인 삽입/삭제 연산으로 인해 다양한 응용 분야에서 활용되는 중요한 데이터 구조이다. 배열에 비해 특정 위치 접근이 느리지만, 동적 크기 조정과 삽입/삭제 연산의 효율성은 큰 장점이다.
다양한 형태(단일, 이중, 원형)와 최적화 기법(센티넬 노드, 런너 기법 등)을 적절히, 활용하면 복잡한 문제도 효율적으로 해결할 수 있다. 특히 스택, 큐, 해시 테이블, 그래프 등 다른 자료구조의 구현에도 널리 사용되어 알고리즘과 데이터 구조를 이해하는 데 필수적인 개념이다.
...</p></div><footer class=entry-footer><span title='2024-10-07 05:53:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 연결 리스트 (Linked List)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/linked-lists/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬은 분할 정복(Divide and Conquer) 패러다임을 기반으로 하는 효율적인 정렬 알고리즘이다.
여러 정렬 알고리즘 중에서도 안정적인 성능과 일관된 시간 복잡도를 제공하는 방식으로 널리 사용된다.
병합 정렬은 안정적인 성능과 예측 가능한 시간 복잡도를 제공하는 매우 유용한 정렬 알고리즘. 추가 메모리가 필요하다는 단점이 있지만, 대규모 데이터 처리나 외부 정렬에 적합하며, 안정적인 정렬이 필요한 상황에서 특히 유용하다.
알고리즘의 단순성과 병렬화 가능성도 중요한 장점이다.
병합 정렬의 기본 원리 병합 정렬은 다음 세 단계로 동작한다:
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/recursion--divide-and-conquer/classic-dc-algorithms/merge-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>레드-블랙 트리 (red-black tree)</h2></header><div class=entry-content><p>레드-블랙 트리 (red-black tree) Red-black tree는 자체 균형 이진 검색 트리(self-balancing binary search tree)의 한 종류로, 컴퓨터 과학에서 정렬된 정보의 빠른 저장과 검색을 위해 사용되는 데이터 구조이다. 데이터베이스와 파일 시스템에서 널리 사용된다.
Red-black tree는 각 노드에 추가적인 색상 속성(빨간색 또는 검은색)을 가진 자체 균형 이진 검색 트리로, 트리의 균형을 유지하여 효율적인 검색, 삽입, 삭제 연산을 보장한다.
https://www.geeksforgeeks.org/introduction-to-red-black-tree/
특징 모든 노드는 빨간색 또는 검은색이다. 루트 노드는 항상 검은색이다. 모든 리프 노드(NIL 노드)는 검은색이다. 빨간색 노드의 자식은 항상 검은색이다 (연속된 빨간색 노드는 없음). 모든 경로에서 검은색 노드의 수는 동일하다. 장점 삽입, 삭제, 검색 연산의 시간 복잡도가 O(log n)으로 보장된다. 자체 균형 기능으로 효율적인 성능을 유지한다. AVL 트리에 비해 삽입과 삭제가 더 빠르다. 응용 데이터베이스 인덱싱 파일 시스템 구현 맵(Map)과 셋(Set) 자료구조 구현 구성 요소 노드: 값, 색상, 왼쪽 자식, 오른쪽 자식, 부모 노드 참조를 포함한다. 루트: 트리의 최상위 노드이다. NIL 노드: 리프 노드로 사용되는 특별한 검은색 노드이다. 구현 방식 Red-black tree는 일반적으로 다음과 같은 구조로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-11 12:35:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 레드-블랙 트리 (red-black tree)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/red-black-tree/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>