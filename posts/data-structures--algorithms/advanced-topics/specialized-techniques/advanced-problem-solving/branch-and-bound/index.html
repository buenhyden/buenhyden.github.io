<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>분기 한정법 (Branch and Bound) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Branch-and-Bound"><meta name=description content="분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="분기 한정법 (Branch and Bound)"><meta property="og:description" content="분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="분기 한정법 (Branch and Bound)"><meta name=twitter:description content="분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":3,"name":"분기 한정법 (Branch and Bound)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>분기 한정법 (Branch and Bound)</h1><div class=post-description>분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.</div></header><div class=post-content><h2 id=분기-한정법-branch-and-bound>분기 한정법 (Branch and Bound)<a hidden class=anchor aria-hidden=true href=#분기-한정법-branch-and-bound>#</a></h2><p>분기한정법(Branch and Bound)은 최적화 문제를 해결하기 위한 효율적인 알고리즘 설계 패러다임이다.<br>이 방법은 거대한, 때로는 지수적으로 큰 해공간을 체계적으로 탐색하면서 최적해를 찾아내는 강력한 기법이다.</p><p>분기한정법은 다양한 최적화 문제를 해결하기 위한 강력하고 유연한 알고리즘 패러다임이다.<br>이 방법의 핵심은 문제를 체계적으로 나누고, 각 하위 문제의 한계값을 계산하여 유망하지 않은 경로를 가지치기함으로써 탐색 공간을 효과적으로 줄이는 데 있다.</p><p>분기한정법은 외판원 문제, 배낭 문제, 작업 할당 문제 등 다양한 NP-hard 최적화 문제에 성공적으로 적용되어 왔다.<br>물론 최악의 경우에는 여전히 지수 시간이 필요하지만, 효과적인 한계 함수와 가지치기 전략을 통해 실용적인 시간 내에 최적해 또는 근사 최적해를 찾을 수 있다.</p><p>현대 컴퓨팅 환경에서는 병렬 처리, 분산 컴퓨팅, 그리고 머신 러닝과 같은 기술의 발전에 힘입어 분기한정법의 활용 범위가 더욱 확장되고 있다. 이러한 발전은 더 큰 규모의 실제 문제를 효율적으로 해결할 수 있는 가능성을 열어주고 있다.</p><h3 id=분기-한정법의-기본-개념>분기 한정법의 기본 개념<a hidden class=anchor aria-hidden=true href=#분기-한정법의-기본-개념>#</a></h3><p>분기 한정법은 &lsquo;분기(Branch)&lsquo;와 &lsquo;한정(Bound)&lsquo;이라는 두 가지 핵심 동작을 결합한 알고리즘이다.</p><h4 id=분기branch>분기(Branch)<a hidden class=anchor aria-hidden=true href=#분기branch>#</a></h4><p><strong>분기</strong>는 문제를 작은 부분 문제로 나누어 탐색 공간을 확장하는 과정을 의미한다.</p><ul><li>목적: 복잡한 문제를 더 간단하고 관리하기 쉬운 하위 문제들로 분할한다.</li><li>방법: 상태 공간 트리(State Space Tree)를 사용하여 가능한 모든 해결책을 체계적으로 나열한다.</li><li>특징: 각 노드에서 가능한 모든 선택을 고려하여 하위 노드를 생성한다.</li></ul><h4 id=한정bound>한정(Bound)<a hidden class=anchor aria-hidden=true href=#한정bound>#</a></h4><p>한정은 각 하위 문제의 해결 가능성을 평가하고 불필요한 탐색을 제거하는 과정이다.</p><ul><li>목적: 유망하지 않은 해결책을 조기에 제거하여 탐색 공간을 줄인다.</li><li>방법: 각 노드에서 한계값(bound)을 계산하여 해당 노드의 유망성을 판단한다.</li><li>특징:<ol><li>한계값은 해당 노드에서 얻을 수 있는 최선의 해결책을 예측한다.<ul><li><strong>상한(Upper Bound)</strong>: 최대화 문제에서는 가능한 최대값의 추정치</li><li><strong>하한(Lower Bound)</strong>: 최소화 문제에서는 가능한 최소값의 추정치</li></ul></li><li>현재까지 찾은 최적해와 비교하여 더 좋은 해결책을 찾을 가능성이 있는지 판단한다.</li></ol></li></ul><h4 id=분기와-한정의-상호작용>분기와 한정의 상호작용<a hidden class=anchor aria-hidden=true href=#분기와-한정의-상호작용>#</a></h4><ol><li>분기 과정에서 생성된 각 하위 문제에 대해 한정 과정을 적용한다.</li><li>한정 과정에서 유망하지 않다고 판단된 노드의 하위 트리는 더 이상 탐색하지 않는다.</li><li>가장 유망한 노드를 선택하여 다음 분기를 수행한다.</li></ol><h3 id=분기-한정법의-작동-원리>분기 한정법의 작동 원리<a hidden class=anchor aria-hidden=true href=#분기-한정법의-작동-원리>#</a></h3><p>분기 한정법은 다음과 같은 단계로 진행된다:</p><ol><li><strong>초기화</strong>: 초기 문제를 설정하고, 최적해의 초기값을 설정한다(최대화 문제의 경우 음의 무한대, 최소화 문제의 경우 양의 무한대).</li><li><strong>분기</strong>: 현재 문제를 여러 부분 문제로 나눈다.</li><li><strong>한계값 계산</strong>: 각 부분 문제에 대한 한계값을 계산한다.</li><li><strong>가지치기</strong>: 한계값이 현재까지의 최적해보다 더 나쁜 부분 문제는 탐색하지 않는다.</li><li><strong>탐색</strong>: 가지치기되지 않은 부분 문제들을 특정 순서(일반적으로 최선 우선 탐색)로 계속 탐색한다.</li><li><strong>종료</strong>: 모든 부분 문제가 탐색되거나 가지치기될 때까지 반복한다.</li></ol><h3 id=분기-한정법의-핵심-구성-요소>분기 한정법의 핵심 구성 요소<a hidden class=anchor aria-hidden=true href=#분기-한정법의-핵심-구성-요소>#</a></h3><p>분기 한정법을 구현할 때 다음 구성 요소를 고려해야 한다:</p><h4 id=상태-표현state-representation>상태 표현(State Representation)<a hidden class=anchor aria-hidden=true href=#상태-표현state-representation>#</a></h4><p>문제의 각 상태를 어떻게 표현할지 정의한다.<br>0-1 배낭 문제에서는 현재 고려 중인 물건의 인덱스, 현재까지 선택한 물건들의 총 무게와 가치, 그리고 선택 상태를 나타내는 배열이 필요하다.</p><h4 id=분기-전략branching-strategy>분기 전략(Branching Strategy)<a hidden class=anchor aria-hidden=true href=#분기-전략branching-strategy>#</a></h4><p>문제를 어떻게 부분 문제로 나눌지 결정한다. 일반적으로 이진 분기(선택함/선택 안함)가 많이 사용되지만, 문제에 따라 다양한 방식이 가능하다.</p><h4 id=한계값-함수bounding-function>한계값 함수(Bounding Function)<a hidden class=anchor aria-hidden=true href=#한계값-함수bounding-function>#</a></h4><p>한계 함수(Bounding Function)는 분기한정법의 효율성을 결정하는 핵심 요소.</p><p>좋은 한계 함수는 다음과 같은 특성을 가져야 한다:</p><ol><li><strong>효율성</strong>: 빠르게 계산할 수 있어야 한다.</li><li><strong>정확성</strong>: 실제 최적값에 가까울수록 더 효과적.</li><li><strong>단조성</strong>: 트리를 따라 내려갈수록 더 정확해져야 한다.</li></ol><p>한계 함수는 문제의 특성에 따라 다양하게 설계될 수 있으며, 일반적으로 다음과 같은 방법으로 도출된다:</p><ol><li><strong>완화(Relaxation)</strong>: 문제의 일부 제약 조건을 완화하여 더 쉽게 해결할 수 있는 문제로 변환</li><li><strong>라그랑지안 완화(Lagrangian Relaxation)</strong>: 제약 조건을 목적 함수에 페널티 항으로 통합</li><li><strong>선형 프로그래밍 완화(Linear Programming Relaxation)</strong>: 정수 제약을 완화하여 선형 프로그래밍 문제로 해결</li></ol><h4 id=탐색-전략search-strategy>탐색 전략(Search Strategy)<a hidden class=anchor aria-hidden=true href=#탐색-전략search-strategy>#</a></h4><p>분기한정법에서 사용되는 주요 탐색 전략은 다음과 같다:</p><ol><li><p>최상 우선 탐색(Best-First Search)<br>최상 우선 탐색은 하한/상한이 가장 유망한(promising) 노드를 먼저 탐색한다.<br>이 방법은 최적해를 더 빨리 찾을 가능성이 높지만, 우선순위 큐를 관리해야 하는 추가 오버헤드가 있다.</p></li><li><p>깊이 우선 탐색(Depth-First Search)<br>깊이 우선 탐색은 가능한 한 깊이 탐색한 후, 막다른 길에 도달하면 백트래킹한다.<br>이 방법은 메모리 효율적이지만, 최적해를 늦게 발견할 수 있다.</p></li><li><p>너비 우선 탐색(Breadth-First Search)<br>너비 우선 탐색은 레벨별로 모든 노드를 탐색한다. 이 방법은 특정 조건에서 최적해를 보장할 수 있지만, 메모리 요구사항이 매우 높다.</p></li><li><p>최소 하한 탐색(Least Lower Bound)<br>최소 하한 탐색은 하한이 가장 작은 노드를 먼저 탐색하는 방법이다. 이 방법은 최적해에 빨리 도달할 가능성이 높다.</p></li></ol><h3 id=분기-한정법의-장단점>분기 한정법의 장단점<a hidden class=anchor aria-hidden=true href=#분기-한정법의-장단점>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ol><li><strong>최적해 보장</strong>: 분기 한정법은 최적해를 보장한다. 가지치기를 통해 일부 경로를 건너뛰지만, 최적해가 포함된 경로는 절대 가지치기되지 않는다.</li><li><strong>효율성</strong>: 효과적인 가지치기를 통해 전체 탐색 공간 중 작은 부분만 탐색하므로, 완전 탐색보다 훨씬 효율적이다.</li><li><strong>유연성</strong>: 다양한 최적화 문제에 적용할 수 있으며, 문제의 특성에 맞게 한계값 함수와 탐색 전략을 조정할 수 있다.</li></ol><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ol><li><strong>최악의 경우 복잡성</strong>: 최악의 경우(가지치기가 거의 발생하지 않는 경우), 여전히 모든 가능한 해결책을 탐색해야 할 수 있다.</li><li><strong>한계값 함수의 의존성</strong>: 알고리즘의 효율성은 한계값 함수의 정확성과 계산 속도에 크게 의존합니다. 정확하지만 계산이 복잡한 한계값 함수는 오히려 전체 성능을 저하시킬 수 있다.</li><li><strong>메모리 요구사항</strong>: 특히 큐 기반 구현에서는 많은 노드를 메모리에 저장해야 할 수 있어 큰 문제에서는 메모리 부족 문제가 발생할 수 있다.</li></ol><h3 id=분기한정법의-시간-및-공간-복잡도>분기한정법의 시간 및 공간 복잡도<a hidden class=anchor aria-hidden=true href=#분기한정법의-시간-및-공간-복잡도>#</a></h3><p>분기한정법의 효율성은 문제의 특성, 한계 함수의 품질, 그리고 가지치기의 효과에 크게 의존한다.</p><ul><li>시간 복잡도<ul><li><strong>최악의 경우</strong>: O(b^d)으로, b는 분기 팩터(각 노드의 평균 자식 수), d는 최대 깊이.</li><li><strong>평균 시간</strong>: 효과적인 한계 함수와 가지치기를 통해 크게 개선될 수 있다.</li></ul></li><li>공간 복잡도<ul><li><strong>최악의 경우</strong>: O(b^d)으로, 모든 노드를 저장해야 할 수도 있다.</li><li><strong>깊이 우선 탐색 사용 시</strong>: O(bd)로 개선될 수 있다.</li></ul></li></ul><h3 id=분기한정법의-향상-기법>분기한정법의 향상 기법<a hidden class=anchor aria-hidden=true href=#분기한정법의-향상-기법>#</a></h3><p>분기한정법의 성능을 더욱 향상시키기 위한 여러 기법들이 연구되어 왔다:</p><ol><li><p>지배 관계(Dominance Relations)<br>어떤 노드가 다른 노드를 지배한다면(항상 더 나은 해결책을 제공), 열등한 노드는 탐색에서 제외할 수 있다.</p></li><li><p>휴리스틱 함수(Heuristic Functions)<br>초기 해결책을 빠르게 찾거나, 탐색 순서를 개선하기 위해 휴리스틱 함수를 사용할 수 있다.</p></li><li><p>병렬 처리(Parallelization)<br>독립적인 하위 문제들을 여러 프로세서에서 병렬로 처리하여 성능을 향상시킬 수 있다.</p></li><li><p>메모이제이션(Memoization)<br>이미 탐색한 상태를 저장하여 중복 계산을 피할 수 있다.</p></li><li><p>구조적 특성 활용(Exploiting Problem Structure)<br>문제의 특수한 구조적 특성을 활용하여 더 효과적인 한계 함수를 설계할 수 있다.</p></li></ol><h3 id=분기-한정법-구현-시-주의사항>분기 한정법 구현 시 주의사항<a hidden class=anchor aria-hidden=true href=#분기-한정법-구현-시-주의사항>#</a></h3><p>분기 한정법을 효과적으로 구현하기 위한 몇 가지 주의사항:</p><ol><li><strong>한계값 함수의 균형</strong>: 계산이 간단하면서도 정확한 한계값 함수를 설계해야 한다. 너무 느슨한 한계값은 가지치기 효과가 적고, 너무 복잡한 계산은 오버헤드가 크다.</li><li><strong>메모리 관리</strong>: 특히 큐 기반 구현에서는 메모리 사용량에 주의해야 한다. 노드 생성과 저장을 최적화하는 전략이 필요할 수 있다.</li><li><strong>초기 해결책</strong>: 가능하면 탐색 시작 전에 좋은 초기 해결책을 구하여 가지치기 효과를 극대화한다.</li><li><strong>문제 특성 활용</strong>: 문제의 구조와 특성을 분석하여 더 효과적인 분기 전략과 한계값 함수를 설계한다.</li></ol><h3 id=분기한정법의-구현>분기한정법의 구현<a hidden class=anchor aria-hidden=true href=#분기한정법의-구현>#</a></h3><p>기본 방식</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>branch_and_bound</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>목표_달성</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>결과_저장</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>유망성_검사</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>  <span class=c1># 가지치기</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>다음_선택</span> <span class=ow>in</span> <span class=n>가능한_선택들</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>상태_변경</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>,</span> <span class=n>다음_선택</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>branch_and_bound</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>상태_복구</span><span class=p>(</span><span class=n>현재_상태</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>분기 한정법은 크게 두 가지 방식으로 구현된다:</p><h4 id=재귀적-구현recursive-implementation>재귀적 구현(Recursive Implementation)<a hidden class=anchor aria-hidden=true href=#재귀적-구현recursive-implementation>#</a></h4><p>재귀 함수를 사용하여 구현한다. 이 방식은 깊이 우선 탐색을 기반으로 하며, 구현이 직관적이고 간단하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>current_weight</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>current_value</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>best_value</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기저 조건: 모든 아이템을 고려했거나 용량을 초과한 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span> <span class=ow>or</span> <span class=n>current_weight</span> <span class=o>&gt;</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>best_value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 아이템을 선택하지 않는 경우</span>
</span></span><span class=line><span class=cl>    <span class=n>best_value</span> <span class=o>=</span> <span class=n>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>best_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 아이템을 선택하는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>new_value</span> <span class=o>=</span> <span class=n>current_value</span> <span class=o>+</span> <span class=n>values</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>new_value</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>best_value</span> <span class=o>=</span> <span class=n>new_value</span>
</span></span><span class=line><span class=cl>        <span class=n>best_value</span> <span class=o>=</span> <span class=n>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>index</span><span class=p>],</span> <span class=n>new_value</span><span class=p>,</span> <span class=n>best_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>weights</span> <span class=o>=</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>values</span> <span class=o>=</span> <span class=p>[</span><span class=mi>60</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>120</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>capacity</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;최대 가치: </span><span class=si>{</span><span class=n>result</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=큐-기반-구현queue-based-implementation>큐 기반 구현(Queue-based Implementation)<a hidden class=anchor aria-hidden=true href=#큐-기반-구현queue-based-implementation>#</a></h4><p>우선순위 큐를 사용하여 구현하는 방식으로, 최선 우선 탐색을 기반으로 한다. 한계값이 가장 유망한 노드를 먼저 탐색하므로 효율성이 높다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span><span class=lnt id=hl-2-39><a class=lnlinks href=#hl-2-39>39</a>
</span><span class=lnt id=hl-2-40><a class=lnlinks href=#hl-2-40>40</a>
</span><span class=lnt id=hl-2-41><a class=lnlinks href=#hl-2-41>41</a>
</span><span class=lnt id=hl-2-42><a class=lnlinks href=#hl-2-42>42</a>
</span><span class=lnt id=hl-2-43><a class=lnlinks href=#hl-2-43>43</a>
</span><span class=lnt id=hl-2-44><a class=lnlinks href=#hl-2-44>44</a>
</span><span class=lnt id=hl-2-45><a class=lnlinks href=#hl-2-45>45</a>
</span><span class=lnt id=hl-2-46><a class=lnlinks href=#hl-2-46>46</a>
</span><span class=lnt id=hl-2-47><a class=lnlinks href=#hl-2-47>47</a>
</span><span class=lnt id=hl-2-48><a class=lnlinks href=#hl-2-48>48</a>
</span><span class=lnt id=hl-2-49><a class=lnlinks href=#hl-2-49>49</a>
</span><span class=lnt id=hl-2-50><a class=lnlinks href=#hl-2-50>50</a>
</span><span class=lnt id=hl-2-51><a class=lnlinks href=#hl-2-51>51</a>
</span><span class=lnt id=hl-2-52><a class=lnlinks href=#hl-2-52>52</a>
</span><span class=lnt id=hl-2-53><a class=lnlinks href=#hl-2-53>53</a>
</span><span class=lnt id=hl-2-54><a class=lnlinks href=#hl-2-54>54</a>
</span><span class=lnt id=hl-2-55><a class=lnlinks href=#hl-2-55>55</a>
</span><span class=lnt id=hl-2-56><a class=lnlinks href=#hl-2-56>56</a>
</span><span class=lnt id=hl-2-57><a class=lnlinks href=#hl-2-57>57</a>
</span><span class=lnt id=hl-2-58><a class=lnlinks href=#hl-2-58>58</a>
</span><span class=lnt id=hl-2-59><a class=lnlinks href=#hl-2-59>59</a>
</span><span class=lnt id=hl-2-60><a class=lnlinks href=#hl-2-60>60</a>
</span><span class=lnt id=hl-2-61><a class=lnlinks href=#hl-2-61>61</a>
</span><span class=lnt id=hl-2-62><a class=lnlinks href=#hl-2-62>62</a>
</span><span class=lnt id=hl-2-63><a class=lnlinks href=#hl-2-63>63</a>
</span><span class=lnt id=hl-2-64><a class=lnlinks href=#hl-2-64>64</a>
</span><span class=lnt id=hl-2-65><a class=lnlinks href=#hl-2-65>65</a>
</span><span class=lnt id=hl-2-66><a class=lnlinks href=#hl-2-66>66</a>
</span><span class=lnt id=hl-2-67><a class=lnlinks href=#hl-2-67>67</a>
</span><span class=lnt id=hl-2-68><a class=lnlinks href=#hl-2-68>68</a>
</span><span class=lnt id=hl-2-69><a class=lnlinks href=#hl-2-69>69</a>
</span><span class=lnt id=hl-2-70><a class=lnlinks href=#hl-2-70>70</a>
</span><span class=lnt id=hl-2-71><a class=lnlinks href=#hl-2-71>71</a>
</span><span class=lnt id=hl-2-72><a class=lnlinks href=#hl-2-72>72</a>
</span><span class=lnt id=hl-2-73><a class=lnlinks href=#hl-2-73>73</a>
</span><span class=lnt id=hl-2-74><a class=lnlinks href=#hl-2-74>74</a>
</span><span class=lnt id=hl-2-75><a class=lnlinks href=#hl-2-75>75</a>
</span><span class=lnt id=hl-2-76><a class=lnlinks href=#hl-2-76>76</a>
</span><span class=lnt id=hl-2-77><a class=lnlinks href=#hl-2-77>77</a>
</span><span class=lnt id=hl-2-78><a class=lnlinks href=#hl-2-78>78</a>
</span><span class=lnt id=hl-2-79><a class=lnlinks href=#hl-2-79>79</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_branch_and_bound_queue</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 가치/무게 비율에 따라 물건 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>/</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최적해를 저장할 변수들</span>
</span></span><span class=line><span class=cl>    <span class=n>best_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>best_solution</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상한값 계산 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bound</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># (앞의 예제와 동일)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>&gt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>bound_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>=</span> <span class=n>current_weight</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>k</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>total_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>+=</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>-</span> <span class=n>total_weight</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>/</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>][</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound_value</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기 노드 생성</span>
</span></span><span class=line><span class=cl>    <span class=c1># (노드 형식: (-상한값, 물건 인덱스, 현재 무게, 현재 가치, 선택 상태))</span>
</span></span><span class=line><span class=cl>    <span class=c1># 우선순위 큐에서 최대 상한값을 가진 노드를 먼저 처리하기 위해 상한값에 음수 부호를 사용</span>
</span></span><span class=line><span class=cl>    <span class=n>bound_value</span> <span class=o>=</span> <span class=n>bound</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[(</span><span class=o>-</span><span class=n>bound_value</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heapify</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 최대 상한값을 가진 노드 추출</span>
</span></span><span class=line><span class=cl>        <span class=n>_</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>solution</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가지치기: 상한값이 현재 최적해보다 작거나 같으면 탐색 중단</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>-</span><span class=n>_</span> <span class=o>&lt;=</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 물건을 고려했을 때</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_value</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>                <span class=n>best_solution</span> <span class=o>=</span> <span class=n>solution</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 물건 정보</span>
</span></span><span class=line><span class=cl>        <span class=n>item_value</span><span class=p>,</span> <span class=n>item_weight</span><span class=p>,</span> <span class=n>original_index</span> <span class=o>=</span> <span class=n>items</span><span class=p>[</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 물건을 선택하는 경우 (왼쪽 분기)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>item_weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>new_solution</span> <span class=o>=</span> <span class=n>solution</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>            <span class=n>new_solution</span><span class=p>[</span><span class=n>original_index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>new_value</span> <span class=o>=</span> <span class=n>current_value</span> <span class=o>+</span> <span class=n>item_value</span>
</span></span><span class=line><span class=cl>            <span class=n>new_weight</span> <span class=o>=</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>item_weight</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>=</span> <span class=n>bound</span><span class=p>(</span><span class=n>k</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>new_weight</span><span class=p>,</span> <span class=n>new_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 가지치기 전에 상한값 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>bound_value</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=o>-</span><span class=n>bound_value</span><span class=p>,</span> <span class=n>k</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>new_weight</span><span class=p>,</span> <span class=n>new_value</span><span class=p>,</span> <span class=n>new_solution</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 물건을 선택하지 않는 경우 (오른쪽 분기)</span>
</span></span><span class=line><span class=cl>        <span class=n>new_solution</span> <span class=o>=</span> <span class=n>solution</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>        <span class=n>new_solution</span><span class=p>[</span><span class=n>original_index</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>bound_value</span> <span class=o>=</span> <span class=n>bound</span><span class=p>(</span><span class=n>k</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가지치기 전에 상한값 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>bound_value</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=o>-</span><span class=n>bound_value</span><span class=p>,</span> <span class=n>k</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>new_solution</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span></code></pre></td></tr></table></div></div><p>이 구현에서는 우선순위 큐를 사용하여 항상 가장 유망한(상한값이 높은) 노드를 먼저 탐색한다.</p><h3 id=분기한정법의-대표적인-적용-사례>분기한정법의 대표적인 적용 사례<a hidden class=anchor aria-hidden=true href=#분기한정법의-대표적인-적용-사례>#</a></h3><p>분기한정법은 다양한 최적화 문제에 성공적으로 적용되어 왔다.</p><p>다음은 가장 잘 알려진 적용 사례들:</p><h4 id=외판원-문제traveling-salesman-problem-tsp>외판원 문제(Traveling Salesman Problem, TSP)<a hidden class=anchor aria-hidden=true href=#외판원-문제traveling-salesman-problem-tsp>#</a></h4><p>외판원 문제는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span><span class=lnt id=hl-3-42><a class=lnlinks href=#hl-3-42>42</a>
</span><span class=lnt id=hl-3-43><a class=lnlinks href=#hl-3-43>43</a>
</span><span class=lnt id=hl-3-44><a class=lnlinks href=#hl-3-44>44</a>
</span><span class=lnt id=hl-3-45><a class=lnlinks href=#hl-3-45>45</a>
</span><span class=lnt id=hl-3-46><a class=lnlinks href=#hl-3-46>46</a>
</span><span class=lnt id=hl-3-47><a class=lnlinks href=#hl-3-47>47</a>
</span><span class=lnt id=hl-3-48><a class=lnlinks href=#hl-3-48>48</a>
</span><span class=lnt id=hl-3-49><a class=lnlinks href=#hl-3-49>49</a>
</span><span class=lnt id=hl-3-50><a class=lnlinks href=#hl-3-50>50</a>
</span><span class=lnt id=hl-3-51><a class=lnlinks href=#hl-3-51>51</a>
</span><span class=lnt id=hl-3-52><a class=lnlinks href=#hl-3-52>52</a>
</span><span class=lnt id=hl-3-53><a class=lnlinks href=#hl-3-53>53</a>
</span><span class=lnt id=hl-3-54><a class=lnlinks href=#hl-3-54>54</a>
</span><span class=lnt id=hl-3-55><a class=lnlinks href=#hl-3-55>55</a>
</span><span class=lnt id=hl-3-56><a class=lnlinks href=#hl-3-56>56</a>
</span><span class=lnt id=hl-3-57><a class=lnlinks href=#hl-3-57>57</a>
</span><span class=lnt id=hl-3-58><a class=lnlinks href=#hl-3-58>58</a>
</span><span class=lnt id=hl-3-59><a class=lnlinks href=#hl-3-59>59</a>
</span><span class=lnt id=hl-3-60><a class=lnlinks href=#hl-3-60>60</a>
</span><span class=lnt id=hl-3-61><a class=lnlinks href=#hl-3-61>61</a>
</span><span class=lnt id=hl-3-62><a class=lnlinks href=#hl-3-62>62</a>
</span><span class=lnt id=hl-3-63><a class=lnlinks href=#hl-3-63>63</a>
</span><span class=lnt id=hl-3-64><a class=lnlinks href=#hl-3-64>64</a>
</span><span class=lnt id=hl-3-65><a class=lnlinks href=#hl-3-65>65</a>
</span><span class=lnt id=hl-3-66><a class=lnlinks href=#hl-3-66>66</a>
</span><span class=lnt id=hl-3-67><a class=lnlinks href=#hl-3-67>67</a>
</span><span class=lnt id=hl-3-68><a class=lnlinks href=#hl-3-68>68</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_tsp</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>cost</span><span class=p>,</span> <span class=n>bound</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=o>=</span> <span class=n>path</span>  <span class=c1># 현재까지의 경로</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>  <span class=c1># 현재까지의 비용</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>bound</span>  <span class=c1># 하한 값</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__lt__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>other</span><span class=o>.</span><span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>compute_bound</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 하한값 계산: 현재 비용 + 각 미방문 도시에서의 최소 비용</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>)</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>  <span class=c1># 모든 도시 방문 완료</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>+</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>bound</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>current_city</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 각 미방문 도시에 대해 최소 비용 간선 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_edge</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>j</span> <span class=o>!=</span> <span class=n>i</span> <span class=ow>and</span> <span class=n>j</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>min_edge</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_edge</span><span class=p>,</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>bound</span> <span class=o>+=</span> <span class=n>min_edge</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 시작 노드 (0번 도시부터 시작)</span>
</span></span><span class=line><span class=cl>    <span class=n>start_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>([</span><span class=mi>0</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>start_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>start_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>start_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>best_tour</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>best_cost</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=o>.</span><span class=n>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;=</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>)</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>  <span class=c1># 모든 도시 방문</span>
</span></span><span class=line><span class=cl>            <span class=c1># 출발점으로 돌아가는 비용 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>total_cost</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>+</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>total_cost</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_cost</span> <span class=o>=</span> <span class=n>total_cost</span>
</span></span><span class=line><span class=cl>                <span class=n>best_tour</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span> <span class=o>+</span> <span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current_city</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>next_city</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>next_city</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_path</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span> <span class=o>+</span> <span class=p>[</span><span class=n>next_city</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_cost</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>+</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>current_city</span><span class=p>][</span><span class=n>next_city</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>new_path</span><span class=p>,</span> <span class=n>new_cost</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>new_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>new_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>new_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_tour</span><span class=p>,</span> <span class=n>best_cost</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=0-1-배낭-문제knapsack-problem>0-1 배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#0-1-배낭-문제knapsack-problem>#</a></h4><p>배낭 문제는 주어진 무게 제한 내에서 최대 가치를 갖는 아이템 조합을 선택하는 문제.</p><p>주어진 조건:</p><ul><li>n개의 물건이 있음</li><li>각 물건 i는 무게 <code>w[i]</code>와 가치 <code>v[i]</code>를 가짐</li><li>배낭의 최대 수용 가능 무게는 W</li><li>각 물건은 통째로 선택하거나 선택하지 않아야 함 (0 또는 1)</li></ul><p>목표:</p><ul><li>배낭의 무게 제한을 초과하지 않으면서</li><li>선택된 물건들의 총 가치를 최대화하는 물건들의 조합을 찾는 것</li></ul><p>수학적 표현:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>최대화: `Σ(v[i] * x[i])  (i = 1 to n)`
</span></span><span class=line><span class=cl>제약 조건: `Σ(w[i] * x[i]) ≤ W`
</span></span><span class=line><span class=cl>여기서` x[i]는 0 또는 1 (물건을 선택하거나 선택하지 않음)`
</span></span></code></pre></td></tr></table></div></div><p><figure><img alt="0/1 Knapsack using Branch and Bound" loading=lazy src=/img/0-1-Knapsack-using-Branch-and-Bound3.jpg><figcaption>Source: https://www.geeksforgeeks.org/0-1-knapsack-using-branch-and-bound/</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span><span class=lnt id=hl-5-33><a class=lnlinks href=#hl-5-33>33</a>
</span><span class=lnt id=hl-5-34><a class=lnlinks href=#hl-5-34>34</a>
</span><span class=lnt id=hl-5-35><a class=lnlinks href=#hl-5-35>35</a>
</span><span class=lnt id=hl-5-36><a class=lnlinks href=#hl-5-36>36</a>
</span><span class=lnt id=hl-5-37><a class=lnlinks href=#hl-5-37>37</a>
</span><span class=lnt id=hl-5-38><a class=lnlinks href=#hl-5-38>38</a>
</span><span class=lnt id=hl-5-39><a class=lnlinks href=#hl-5-39>39</a>
</span><span class=lnt id=hl-5-40><a class=lnlinks href=#hl-5-40>40</a>
</span><span class=lnt id=hl-5-41><a class=lnlinks href=#hl-5-41>41</a>
</span><span class=lnt id=hl-5-42><a class=lnlinks href=#hl-5-42>42</a>
</span><span class=lnt id=hl-5-43><a class=lnlinks href=#hl-5-43>43</a>
</span><span class=lnt id=hl-5-44><a class=lnlinks href=#hl-5-44>44</a>
</span><span class=lnt id=hl-5-45><a class=lnlinks href=#hl-5-45>45</a>
</span><span class=lnt id=hl-5-46><a class=lnlinks href=#hl-5-46>46</a>
</span><span class=lnt id=hl-5-47><a class=lnlinks href=#hl-5-47>47</a>
</span><span class=lnt id=hl-5-48><a class=lnlinks href=#hl-5-48>48</a>
</span><span class=lnt id=hl-5-49><a class=lnlinks href=#hl-5-49>49</a>
</span><span class=lnt id=hl-5-50><a class=lnlinks href=#hl-5-50>50</a>
</span><span class=lnt id=hl-5-51><a class=lnlinks href=#hl-5-51>51</a>
</span><span class=lnt id=hl-5-52><a class=lnlinks href=#hl-5-52>52</a>
</span><span class=lnt id=hl-5-53><a class=lnlinks href=#hl-5-53>53</a>
</span><span class=lnt id=hl-5-54><a class=lnlinks href=#hl-5-54>54</a>
</span><span class=lnt id=hl-5-55><a class=lnlinks href=#hl-5-55>55</a>
</span><span class=lnt id=hl-5-56><a class=lnlinks href=#hl-5-56>56</a>
</span><span class=lnt id=hl-5-57><a class=lnlinks href=#hl-5-57>57</a>
</span><span class=lnt id=hl-5-58><a class=lnlinks href=#hl-5-58>58</a>
</span><span class=lnt id=hl-5-59><a class=lnlinks href=#hl-5-59>59</a>
</span><span class=lnt id=hl-5-60><a class=lnlinks href=#hl-5-60>60</a>
</span><span class=lnt id=hl-5-61><a class=lnlinks href=#hl-5-61>61</a>
</span><span class=lnt id=hl-5-62><a class=lnlinks href=#hl-5-62>62</a>
</span><span class=lnt id=hl-5-63><a class=lnlinks href=#hl-5-63>63</a>
</span><span class=lnt id=hl-5-64><a class=lnlinks href=#hl-5-64>64</a>
</span><span class=lnt id=hl-5-65><a class=lnlinks href=#hl-5-65>65</a>
</span><span class=lnt id=hl-5-66><a class=lnlinks href=#hl-5-66>66</a>
</span><span class=lnt id=hl-5-67><a class=lnlinks href=#hl-5-67>67</a>
</span><span class=lnt id=hl-5-68><a class=lnlinks href=#hl-5-68>68</a>
</span><span class=lnt id=hl-5-69><a class=lnlinks href=#hl-5-69>69</a>
</span><span class=lnt id=hl-5-70><a class=lnlinks href=#hl-5-70>70</a>
</span><span class=lnt id=hl-5-71><a class=lnlinks href=#hl-5-71>71</a>
</span><span class=lnt id=hl-5-72><a class=lnlinks href=#hl-5-72>72</a>
</span><span class=lnt id=hl-5-73><a class=lnlinks href=#hl-5-73>73</a>
</span><span class=lnt id=hl-5-74><a class=lnlinks href=#hl-5-74>74</a>
</span><span class=lnt id=hl-5-75><a class=lnlinks href=#hl-5-75>75</a>
</span><span class=lnt id=hl-5-76><a class=lnlinks href=#hl-5-76>76</a>
</span><span class=lnt id=hl-5-77><a class=lnlinks href=#hl-5-77>77</a>
</span><span class=lnt id=hl-5-78><a class=lnlinks href=#hl-5-78>78</a>
</span><span class=lnt id=hl-5-79><a class=lnlinks href=#hl-5-79>79</a>
</span><span class=lnt id=hl-5-80><a class=lnlinks href=#hl-5-80>80</a>
</span><span class=lnt id=hl-5-81><a class=lnlinks href=#hl-5-81>81</a>
</span><span class=lnt id=hl-5-82><a class=lnlinks href=#hl-5-82>82</a>
</span><span class=lnt id=hl-5-83><a class=lnlinks href=#hl-5-83>83</a>
</span><span class=lnt id=hl-5-84><a class=lnlinks href=#hl-5-84>84</a>
</span><span class=lnt id=hl-5-85><a class=lnlinks href=#hl-5-85>85</a>
</span><span class=lnt id=hl-5-86><a class=lnlinks href=#hl-5-86>86</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_knapsack</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>bound</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>level</span> <span class=o>=</span> <span class=n>level</span>  <span class=c1># 현재 고려 중인 아이템 레벨</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>  <span class=c1># 현재까지의 가치</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight</span>  <span class=c1># 현재까지의 무게</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>bound</span>  <span class=c1># 상한 값</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__lt__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;</span> <span class=n>other</span><span class=o>.</span><span class=n>bound</span>  <span class=c1># 최대화 문제이므로 내림차순</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>compute_bound</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 이미 무게 제한 초과시 유효하지 않음</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span> <span class=o>&gt;</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재까지의 가치를 기준값으로 설정</span>
</span></span><span class=line><span class=cl>        <span class=n>bound</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>level</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 남은 아이템을 가치/무게 비율이 높은 순서대로 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>total_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bound</span> <span class=o>+=</span> <span class=n>values</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 아이템은 비율에 따라 부분적으로 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bound</span> <span class=o>+=</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>-</span> <span class=n>total_weight</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>/</span> <span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 가치/무게 비율에 따라 아이템 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>/</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정렬된 순서에 맞게 값 재배치</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_values</span> <span class=o>=</span> <span class=p>[</span><span class=n>item</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>items</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_weights</span> <span class=o>=</span> <span class=p>[</span><span class=n>item</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>items</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 시작 노드</span>
</span></span><span class=line><span class=cl>    <span class=n>start_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>start_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>start_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>start_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>best_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>best_solution</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=o>.</span><span class=n>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;=</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 아이템 고려 완료</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_value</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>                <span class=n>best_solution</span> <span class=o>=</span> <span class=p>[</span><span class=n>items</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>included</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재 아이템을 포함하는 경우</span>
</span></span><span class=line><span class=cl>            <span class=n>include_weight</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span> <span class=o>+</span> <span class=n>sorted_weights</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>include_weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>include_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                    <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>+</span> <span class=n>sorted_values</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                                    <span class=n>include_weight</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>include_node</span><span class=o>.</span><span class=n>included</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>included</span> <span class=o>+</span> <span class=p>[</span><span class=kc>True</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>include_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>include_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>include_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>include_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 현재 아이템을 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>            <span class=n>exclude_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>exclude_node</span><span class=o>.</span><span class=n>included</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>included</span> <span class=o>+</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>exclude_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>exclude_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>exclude_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>exclude_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=작업-할당-문제assignment-problem>작업 할당 문제(Assignment Problem)<a hidden class=anchor aria-hidden=true href=#작업-할당-문제assignment-problem>#</a></h4><p>작업 할당 문제는 n개의 작업을 n명의 작업자에게 최소 비용으로 할당하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span><span class=lnt id=hl-6-33><a class=lnlinks href=#hl-6-33>33</a>
</span><span class=lnt id=hl-6-34><a class=lnlinks href=#hl-6-34>34</a>
</span><span class=lnt id=hl-6-35><a class=lnlinks href=#hl-6-35>35</a>
</span><span class=lnt id=hl-6-36><a class=lnlinks href=#hl-6-36>36</a>
</span><span class=lnt id=hl-6-37><a class=lnlinks href=#hl-6-37>37</a>
</span><span class=lnt id=hl-6-38><a class=lnlinks href=#hl-6-38>38</a>
</span><span class=lnt id=hl-6-39><a class=lnlinks href=#hl-6-39>39</a>
</span><span class=lnt id=hl-6-40><a class=lnlinks href=#hl-6-40>40</a>
</span><span class=lnt id=hl-6-41><a class=lnlinks href=#hl-6-41>41</a>
</span><span class=lnt id=hl-6-42><a class=lnlinks href=#hl-6-42>42</a>
</span><span class=lnt id=hl-6-43><a class=lnlinks href=#hl-6-43>43</a>
</span><span class=lnt id=hl-6-44><a class=lnlinks href=#hl-6-44>44</a>
</span><span class=lnt id=hl-6-45><a class=lnlinks href=#hl-6-45>45</a>
</span><span class=lnt id=hl-6-46><a class=lnlinks href=#hl-6-46>46</a>
</span><span class=lnt id=hl-6-47><a class=lnlinks href=#hl-6-47>47</a>
</span><span class=lnt id=hl-6-48><a class=lnlinks href=#hl-6-48>48</a>
</span><span class=lnt id=hl-6-49><a class=lnlinks href=#hl-6-49>49</a>
</span><span class=lnt id=hl-6-50><a class=lnlinks href=#hl-6-50>50</a>
</span><span class=lnt id=hl-6-51><a class=lnlinks href=#hl-6-51>51</a>
</span><span class=lnt id=hl-6-52><a class=lnlinks href=#hl-6-52>52</a>
</span><span class=lnt id=hl-6-53><a class=lnlinks href=#hl-6-53>53</a>
</span><span class=lnt id=hl-6-54><a class=lnlinks href=#hl-6-54>54</a>
</span><span class=lnt id=hl-6-55><a class=lnlinks href=#hl-6-55>55</a>
</span><span class=lnt id=hl-6-56><a class=lnlinks href=#hl-6-56>56</a>
</span><span class=lnt id=hl-6-57><a class=lnlinks href=#hl-6-57>57</a>
</span><span class=lnt id=hl-6-58><a class=lnlinks href=#hl-6-58>58</a>
</span><span class=lnt id=hl-6-59><a class=lnlinks href=#hl-6-59>59</a>
</span><span class=lnt id=hl-6-60><a class=lnlinks href=#hl-6-60>60</a>
</span><span class=lnt id=hl-6-61><a class=lnlinks href=#hl-6-61>61</a>
</span><span class=lnt id=hl-6-62><a class=lnlinks href=#hl-6-62>62</a>
</span><span class=lnt id=hl-6-63><a class=lnlinks href=#hl-6-63>63</a>
</span><span class=lnt id=hl-6-64><a class=lnlinks href=#hl-6-64>64</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_assignment</span><span class=p>(</span><span class=n>cost_matrix</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>cost_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>assignments</span><span class=p>,</span> <span class=n>cost</span><span class=p>,</span> <span class=n>bound</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>level</span> <span class=o>=</span> <span class=n>level</span>  <span class=c1># 현재 할당 중인 작업자</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>assignments</span> <span class=o>=</span> <span class=n>assignments</span>  <span class=c1># 현재까지의 할당 상태</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>  <span class=c1># 현재까지의 비용</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>bound</span>  <span class=c1># 하한 값</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__lt__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>other</span><span class=o>.</span><span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>compute_bound</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재까지의 비용을 기준값으로 설정</span>
</span></span><span class=line><span class=cl>        <span class=n>bound</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 각 미할당 작업에 대해 최소 비용 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>assigned_tasks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>assignments</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>min_cost</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>j</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>assigned_tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>min_cost</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_cost</span><span class=p>,</span> <span class=n>cost_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>bound</span> <span class=o>+=</span> <span class=n>min_cost</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 시작 노드</span>
</span></span><span class=line><span class=cl>    <span class=n>start_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=p>[],</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>start_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>start_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>start_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>best_assignment</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>best_cost</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=o>.</span><span class=n>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;=</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 작업자에게 할당 완료</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_cost</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span>
</span></span><span class=line><span class=cl>                <span class=n>best_assignment</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>assignments</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재 작업자에게 각 미할당 작업 할당 시도</span>
</span></span><span class=line><span class=cl>            <span class=n>assigned_tasks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>assignments</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>task</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>task</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>assigned_tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_assignments</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>assignments</span> <span class=o>+</span> <span class=p>[</span><span class=n>task</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_cost</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>+</span> <span class=n>cost_matrix</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>][</span><span class=n>task</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>new_assignments</span><span class=p>,</span> <span class=n>new_cost</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>new_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>new_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>new_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_assignment</span><span class=p>,</span> <span class=n>best_cost</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실제-응용-사례>실제 응용 사례<a hidden class=anchor aria-hidden=true href=#실제-응용-사례>#</a></h3><p>분기한정법은 다양한 실제 문제에 응용되고 있다:</p><ol><li>물류 및 운송 최적화<ul><li>차량 경로 문제(Vehicle Routing Problem)</li><li>작업 스케줄링(Job Scheduling)</li></ul></li><li>네트워크 설계<ul><li>네트워크 흐름 최적화</li><li>통신 네트워크 설계</li></ul></li><li>자원 할당<ul><li>프로젝트 스케줄링</li><li>인력 배치 최적화</li></ul></li><li>생산 계획<ul><li>공정 최적화</li><li>재고 관리</li></ul></li><li>금융 분야<ul><li>포트폴리오 최적화</li><li>위험 최소화 전략</li></ul></li></ol><h3 id=분기한정법의-미래-발전-방향>분기한정법의 미래 발전 방향<a hidden class=anchor aria-hidden=true href=#분기한정법의-미래-발전-방향>#</a></h3><p>분기한정법은 계속해서 발전하고 있으며, 다음과 같은 방향으로 연구가 진행되고 있다:</p><ol><li><strong>머신 러닝 통합</strong>: 노드 선택 및 분기 전략을 개선하기 위한 머신 러닝 기법 활용</li><li><strong>고급 한계 함수</strong>: 더 정확하고 계산 효율적인 한계 함수 개발</li><li><strong>분산 및 병렬 알고리즘</strong>: 대규모 문제를 위한 분산 컴퓨팅 방법론</li><li><strong>하이브리드 접근법</strong>: 메타휴리스틱, 동적 계획법 등 다른 기법과의 통합</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branch and Bound vs. Backtracking</h2></header><div class=entry-content><p>Back Tracking vs. Branch and Bound 백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.
두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.
백트래킹과 분기한정법은 조합 최적화 문제를 해결하기 위한 강력한 도구이다.
백트래킹은 제약 충족 문제에 더 적합하며, 가능한 모든 해결책이나 첫 번째 유효한 해결책을 찾는 데 중점을 둔다. 반면 분기한정법은 최적화 문제에 더 적합하며, 경계값을 사용하여 최적해를 효율적으로 찾는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2025-01-10 04:36:00 +0000 UTC'>January 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branch and Bound vs. Backtracking" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>State Representation</h2></header><div class=entry-content><p>상태 표현(State Representation) 상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.
Branch and Bound 알고리즘에서 상태 표현은 다음과 같은 중요한 역할을 한다:
문제 공간 표현: 가능한 모든 해결책(solution space)을 체계적으로 표현한다. 탐색 진행 상황 추적: 알고리즘이 문제 공간을 탐색하는 과정에서 현재 위치를 나타낸다. 한계값(bound) 계산 지원: 각 상태에서 가능한 최적값의 상한 또는 하한을 계산할 수 있게 한다. 가지치기(pruning) 결정 기반: 더 이상 탐색할 가치가 없는 상태를 식별하는 데 사용된다. 상태 표현의 주요 특성 및 고려 사항 상태 표현의 완전성(Completeness)
상태 표현은 문제의 모든 가능한 해결책을 표현할 수 있어야 한다.
불완전한 상태 표현은 최적해를 놓치게 할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Representation" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/state-representation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branching Strategies</h2></header><div class=entry-content><p>Branching Strategies Branch and Bound(분기한정법)은 조합 최적화 문제를 해결하기 위한 알고리즘 패러다임으로, 가능한 해결책의 공간을 체계적으로 탐색하여 최적의 해를 찾는 방법이다.
이 알고리즘의 핵심 요소 중 하나가 바로 ‘분기 전략(Branching Strategies)‘이다.
분기 전략은 문제 공간을 어떻게 분할하고 탐색할 것인지를 결정하며, 이는 알고리즘의 효율성과 성능에 직접적인 영향을 미친다.
문제 구조를 이해하고 적절한 분기 전략을 선택하는 것은 효율적인 알고리즘 구현을 위해 필수적이다. 변수 기반, 제약 기반, 문제 특화 분기 등 다양한 전략을 이해하고, 문제의 특성에 맞게 적용하거나 조합하는 능력이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching Strategies" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branching-strategies/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>한계 함수(Bounding Functions)</h2></header><div class=entry-content><p>한계 함수(Bounding Functions) Branch and Bound(분기한정법)은 조합 최적화 문제를 해결하기 위한 강력한 알고리즘 패러다임으로, 이 알고리즘의 핵심 요소 중 하나가 바로 ‘한계 함수(Bounding Functions)‘이다.
한계 함수는 분기한정법의 효율성을 결정짓는 중요한 요소로, 불필요한 탐색을 줄이고 최적해를 빠르게 찾는 데 결정적인 역할을 한다.
한계 함수(Bounding Functions)는 Branch and Bound 알고리즘의 핵심 요소로, 불필요한 해공간 탐색을 줄이고 최적해를 효율적으로 찾는 데 중요한 역할을 한다. 효과적인 한계 함수는 정확성, 강도, 계산 효율성, 단조성 등의 특성을 가져야 한다.
...</p></div><footer class=entry-footer><span title='2025-01-03 11:34:00 +0000 UTC'>January 3, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 한계 함수(Bounding Functions)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/bounding-functions/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>