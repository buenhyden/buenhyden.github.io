<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Branch and Bound vs. Backtracking | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Branch-and-Bound"><meta name=description content="백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.  두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Branch and Bound vs. Backtracking"><meta property="og:description" content="백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.  두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-10T04:36:00+00:00"><meta property="article:modified_time" content="2025-01-10T04:36:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Branch-and-Bound"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Branch and Bound vs. Backtracking"><meta name=twitter:description content="백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.  두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"Branch and Bound vs. Backtracking","item":"https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Branch and Bound vs. Backtracking","name":"Branch and Bound vs. Backtracking","description":"백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.  두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Branch-and-Bound"],"articleBody":"Back Tracking vs. Branch and Bound 백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.\n두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.\n백트래킹과 분기한정법은 조합 최적화 문제를 해결하기 위한 강력한 도구이다.\n백트래킹은 제약 충족 문제에 더 적합하며, 가능한 모든 해결책이나 첫 번째 유효한 해결책을 찾는 데 중점을 둔다. 반면 분기한정법은 최적화 문제에 더 적합하며, 경계값을 사용하여 최적해를 효율적으로 찾는 데 중점을 둔다.\n문제의 특성, 해의 요구사항, 가용 자원에 따라 적절한 기법을 선택하거나 두 기법의 장점을 결합한 하이브리드 접근법을 고려할 수 있다. 최근 연구에서는 이러한 알고리즘의 효율성을 더욱 향상시키기 위한 다양한 휴리스틱과 최적화 기법이 개발되고 있다.\n궁극적으로, 이러한 체계적인 문제 해결 기법들은 컴퓨터 과학의 핵심 도구로서, NP-하드 문제와 같은 계산적으로 어려운 문제들을 실용적으로 접근할 수 있게 해준다.\n백트래킹(Backtracking) 백트래킹은 가능한 모든 해결책을 탐색하는 체계적인 방법으로, 후보 해결책을 점진적으로 구축하다가 더 이상 진행할 수 없을 때 이전 단계로 돌아가(backtrack) 다른 대안을 시도하는 기법.\n이는 특히 제약 충족 문제(Constraint Satisfaction Problems)를 해결하는 데 효과적.\n작동 원리:\n상태 공간 트리(State Space Tree): 가능한 모든 해결책을 트리 형태로 표현. 깊이 우선 탐색(DFS): 특정 경로를 따라 가능한 한 깊이 탐색. 제약 조건 검사: 현재 부분 해결책이 제약 조건을 만족하는지 확인. 가지치기(Pruning): 제약 조건을 위반하면 해당 경로를 더 이상 탐색하지 않는다. 되돌아가기(Backtracking): 막다른 길이나 유효하지 않은 경로에 도달하면 이전 결정 지점으로 돌아간다. 복잡도 시간 복잡도\n백트래킹: 최악의 경우 지수 시간(O(b^d)), 여기서 b는 분기 팩터, d는 최대 깊이 공간 복잡도\n백트래킹: O(d), 재귀 호출 스택의 깊이에 비례 백트래킹 구현 시 고려사항 상태 표현: 부분 해결책을 효율적으로 표현하는 방법 제약 조건 검사: 가능한 한 빨리 유효하지 않은 경로를 식별 재귀 함수 설계: 스택 오버플로우를 방지하기 위한 적절한 재귀 깊이 관리 상태 복원: 백트래킹 후 이전 상태로 정확히 복원하는 메커니즘 백트래킹 최적화 전방 검사(Forward Checking): 현재 할당의 영향을 미리 확인 가장 제약이 많은 변수 선택(MRV): 가장 선택지가 적은 변수부터 처리 가장 제약이 적은 값 선택(LCV): 다른 변수에 가장 적은 제약을 가하는 값 선택 아크 일관성(Arc Consistency): 변수 쌍 간의 일관성 유지 백트래킹 적용 사례 N-Queens 문제: N×N 체스판에 N개의 퀸을 배치하는 문제 스도쿠 퍼즐: 9×9 그리드에 1-9의 숫자를 채우는 퍼즐 그래프 컬러링: 인접한 정점이 같은 색상을 갖지 않도록 그래프의 각 정점에 색상을 할당 부분집합 합 문제: 주어진 집합에서 합이 특정 값이 되는 부분집합 찾기 해밀턴 경로: 그래프의 모든 정점을 정확히 한 번씩 방문하는 경로 찾기 알고리즘 템플릿 1 2 3 4 5 6 7 8 9 10 def backtrack(candidate): if is_complete(candidate): output(candidate) # 완전한 해결책 발견 return for next_candidate in get_candidates(candidate): if is_valid(next_candidate): # 제약 조건 검사 place(next_candidate) # 후보 배치 backtrack(next_candidate) # 재귀적으로 다음 단계 탐색 remove(next_candidate) # 백트래킹 (후보 제거) 예시: N-Queens 문제 N-Queens 문제는 N×N 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치하는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def solve_n_queens(n): def is_valid(board, row, col): # 같은 열에 퀸이 있는지 확인 for i in range(row): if board[i] == col: return False # 대각선 확인 if abs(board[i] - col) == row - i: return False return True def backtrack(board, row): if row == n: solutions.append(board[:]) return for col in range(n): if is_valid(board, row, col): board[row] = col backtrack(board, row + 1) # 백트래킹 (명시적인 제거는 필요 없음, 다른 값으로 덮어씀) solutions = [] backtrack([-1] * n, 0) return solutions 분기한정법(Branch And Bound) 분기한정법은 최적화 문제를 해결하기 위한 알고리즘으로, 해공간을 체계적으로 탐색하면서 가능한 해결책의 상한과 하한을 계산하여 최적해를 찾는 방법이다.\n이 방법은 특히 최소화 또는 최대화 문제에 효과적.\n작동 원리:\n분기(Branching): 문제를 더 작은 하위 문제로 분할. 한정(Bounding): 각 하위 문제에 대한 상한과 하한을 계산. 가지치기(Pruning): 현재까지 발견된 최적해보다 나쁜 경계값을 가진 하위 문제는 제외. 탐색 전략: 일반적으로 최상 우선 탐색(Best-First Search) 또는 너비 우선 탐색(BFS)을 사용. 복잡도 시간 복잡도 백트래킹: 최악의 경우 지수 시간(O(b^d)), 여기서 b는 분기 팩터, d는 최대 깊이 분기한정법: 최악의 경우 지수 시간(O(b^d)), 그러나 효과적인 한정 함수를 사용하면 평균적으로 더 나은 성능 공간 복잡도 백트래킹: O(d), 재귀 호출 스택의 깊이에 비례 분기한정법: O(b^d), 최악의 경우 모든 노드를 저장해야 할 수 있음 분기한정법 구현 시 고려사항 경계 함수 설계: 정확하고 계산이 빠른 하한/상한 함수 개발 노드 표현: 상태, 비용, 경계값을 효율적으로 저장 우선순위 큐 관리: 큐의 크기가 지나치게 커지는 것을 방지 중복 상태 처리: 동일한 상태가 여러 번 탐색되는 것을 방지 분기한정법 최적화 더 나은 경계 함수: 더 정확한 하한/상한 계산 휴리스틱 함수 사용: 유망한 해결책으로 빠르게 유도 지배 관계(Dominance Relations): 더 나은 해결책이 보장된 상태 식별 병렬 처리: 독립적인 하위 문제를 병렬로 처리 분기한정법 적용 사례 외판원 문제(TSP): 모든 도시를 한 번씩 방문하고 출발점으로 돌아오는 최단 경로 찾기 0-1 배낭 문제: 제한된 무게 내에서 최대 가치를 갖는 아이템 선택 작업 할당 문제: n개의 작업을 n명의 작업자에게 최소 비용으로 할당 최단 경로 문제: 그래프에서 두 정점 사이의 최단 경로 찾기 정수 선형 계획법(ILP): 정수 변수를 사용하는 선형 최적화 문제 알고리즘 템플릿 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def branch_and_bound(problem): queue = PriorityQueue() # 우선순위 큐 (경계값 기준) queue.put(initial_node) best_solution = None best_value = float('inf') # 최소화 문제 가정 while not queue.empty(): node = queue.get() if node.bound \u003c best_value: # 유망한 노드인지 확인 if is_leaf(node): if node.value \u003c best_value: best_value = node.value best_solution = node.solution else: for child in branch(node): child.bound = compute_bound(child) if child.bound \u003c best_value: # 유망한 자식만 추가 queue.put(child) return best_solution 예시: 외판원 문제(TSP) 외판원 문제는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def solve_tsp(distance_matrix): n = len(distance_matrix) class Node: def __init__(self, path, cost, bound): self.path = path self.cost = cost self.bound = bound def __lt__(self, other): return self.bound \u003c other.bound def compute_bound(node): # 하한값 계산 (각 미방문 도시에서 가장 짧은 간선들의 합) bound = node.cost visited = set(node.path) for i in range(n): if i not in visited: min_edge = float('inf') for j in range(n): if j != i and (j not in visited or j == node.path[0]): min_edge = min(min_edge, distance_matrix[i][j]) bound += min_edge return bound # 시작 노드 (0번 도시부터 시작) start = Node([0], 0, 0) start.bound = compute_bound(start) queue = PriorityQueue() queue.put(start) best_tour = None best_cost = float('inf') while not queue.empty(): node = queue.get() if node.bound \u003c best_cost: if len(node.path) == n: # 마지막 도시에서 시작 도시로 돌아가는 비용 추가 total_cost = node.cost + distance_matrix[node.path[-1]][node.path[0]] if total_cost \u003c best_cost: best_cost = total_cost best_tour = node.path + [node.path[0]] else: for next_city in range(n): if next_city not in node.path: new_path = node.path + [next_city] new_cost = node.cost + distance_matrix[node.path[-1]][next_city] new_node = Node(new_path, new_cost, 0) new_node.bound = compute_bound(new_node) if new_node.bound \u003c best_cost: queue.put(new_node) return best_tour, best_cost 두 기법의 핵심 차이점 목적: 백트래킹: 모든 가능한 해결책을 찾거나 제약 조건을 만족하는 해결책을 찾는 데 중점을 둔다. 분기한정법: 최적화 문제에서 최적해를 찾는 데 중점을 둔다. 탐색 전략: 백트래킹: 일반적으로 깊이 우선 탐색(DFS)을 사용. 분기한정법: 일반적으로 최상 우선 탐색(Best-First Search) 또는 너비 우선 탐색(BFS)을 사용. 가지치기 기준: 백트래킹: 제약 조건 위반 여부에 따라 가지치기. 분기한정법: 경계값(bound)과 현재 최적해 비교를 통해 가지치기. 상태 공간 탐색: 백트래킹: 가능한 모든 조합을 체계적으로 생성하고 테스트. 분기한정법: 유망한 부분 공간을 우선적으로 탐색. 메모리 사용: 백트래킹: 재귀 호출 스택에 의존하므로 상대적으로 메모리 효율적. 분기한정법: 우선순위 큐나 활성 노드 목록을 유지해야 하므로 더 많은 메모리가 필요할 수 있다. 하이브리드 접근법 최근에는 두 기법의 장점을 결합한 하이브리드 알고리즘이 개발되고 있다:\n백트래킹 + 하한 계산: 백트래킹 알고리즘에 하한 계산을 추가하여 더 효과적인 가지치기 분기한정법 + 깊이 우선 탐색: 메모리 효율성을 위해 DFS 전략을 사용하는 분기한정법 제약 프로그래밍 + 분기한정법: 제약 프로그래밍의 유연성과 분기한정법의 최적화 능력 결합 비교 분석 표 특성 백트래킹(Backtracking) 분기한정법(Branch and Bound) 주요 목적 모든 가능한 해결책 찾기 또는 제약 충족 최적화 문제에서 최적해 찾기 탐색 전략 깊이 우선 탐색(DFS) 최상 우선 탐색 또는 너비 우선 탐색 가지치기 기준 제약 조건 위반 경계값과 현재 최적해 비교 공간 탐색 방식 체계적 생성 및 테스트 유망한 영역 우선 탐색 상태 유지 현재 경로만 유지 유망한 모든 부분 문제 유지 시간 복잡도 O(b^d), 가지치기로 개선 가능 O(b^d), 효과적인 한정으로 개선 가능 공간 복잡도 O(d), 깊이에 비례 O(b^d), 최악의 경우 적합한 문제 유형 제약 충족 문제(CSP) 조합 최적화 문제 대표적 알고리즘 N-Queens, 스도쿠 솔버 외판원 문제, 0-1 배낭 문제 해의 품질 모든 해 또는 첫 번째 유효한 해 최적해 보장 메모리 효율성 높음 (재귀 스택만 사용) 낮음 (활성 노드 목록 유지) 구현 난이도 중간 높음 (좋은 경계 함수 설계 필요) 병렬화 가능성 제한적 높음 (독립적 하위 문제) 조기 해 발견 가능 (첫 번째 해가 중요한 경우) 최적해 보장을 위해 계속 실행 휴리스틱 활용 제한적 광범위 (경계 함수, 탐색 전략) 변형/확장 전방 검사, MRV, LCV A* 알고리즘, 휴리스틱 탐색 참고 및 출처 ","wordCount":"1458","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-10T04:36:00Z","dateModified":"2025-01-10T04:36:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/specialized-techniques/advanced-problem-solving/branch-and-bound/branch-and-bound-vs-backtracking/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Branch and Bound vs. Backtracking</h1><div class=post-description>백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다. 두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.</div><div class=post-meta><span title='2025-01-10 04:36:00 +0000 UTC'>January 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20&%20Algorithms/Advanced%20Topics/Specialized%20Techniques/Advanced%20Problem%20Solving/Branch%20and%20Bound/branch-and-bound-vs-backtracking.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#back-tracking-vs-branch-and-bound>Back Tracking vs. Branch and Bound</a><ul><li><a href=#백트래킹backtracking>백트래킹(Backtracking)</a></li><li><a href=#분기한정법branch-and-bound>분기한정법(Branch And Bound)</a></li><li><a href=#두-기법의-핵심-차이점>두 기법의 핵심 차이점</a></li><li><a href=#하이브리드-접근법>하이브리드 접근법</a></li><li><a href=#비교-분석-표>비교 분석 표</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=back-tracking-vs-branch-and-bound>Back Tracking vs. Branch and Bound<a hidden class=anchor aria-hidden=true href=#back-tracking-vs-branch-and-bound>#</a></h2><p>백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.<br>두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.</p><p>백트래킹과 분기한정법은 조합 최적화 문제를 해결하기 위한 강력한 도구이다.<br>백트래킹은 제약 충족 문제에 더 적합하며, 가능한 모든 해결책이나 첫 번째 유효한 해결책을 찾는 데 중점을 둔다. 반면 분기한정법은 최적화 문제에 더 적합하며, 경계값을 사용하여 최적해를 효율적으로 찾는 데 중점을 둔다.</p><p>문제의 특성, 해의 요구사항, 가용 자원에 따라 적절한 기법을 선택하거나 두 기법의 장점을 결합한 하이브리드 접근법을 고려할 수 있다. 최근 연구에서는 이러한 알고리즘의 효율성을 더욱 향상시키기 위한 다양한 휴리스틱과 최적화 기법이 개발되고 있다.</p><p>궁극적으로, 이러한 체계적인 문제 해결 기법들은 컴퓨터 과학의 핵심 도구로서, NP-하드 문제와 같은 계산적으로 어려운 문제들을 실용적으로 접근할 수 있게 해준다.</p><h3 id=백트래킹backtracking>백트래킹(Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹backtracking>#</a></h3><p>백트래킹은 가능한 모든 해결책을 탐색하는 체계적인 방법으로, 후보 해결책을 점진적으로 구축하다가 더 이상 진행할 수 없을 때 이전 단계로 돌아가(backtrack) 다른 대안을 시도하는 기법.<br>이는 특히 제약 충족 문제(Constraint Satisfaction Problems)를 해결하는 데 효과적.</p><p>작동 원리:</p><ol><li><strong>상태 공간 트리(State Space Tree)</strong>: 가능한 모든 해결책을 트리 형태로 표현.</li><li><strong>깊이 우선 탐색(DFS)</strong>: 특정 경로를 따라 가능한 한 깊이 탐색.</li><li><strong>제약 조건 검사</strong>: 현재 부분 해결책이 제약 조건을 만족하는지 확인.</li><li><strong>가지치기(Pruning)</strong>: 제약 조건을 위반하면 해당 경로를 더 이상 탐색하지 않는다.</li><li><strong>되돌아가기(Backtracking)</strong>: 막다른 길이나 유효하지 않은 경로에 도달하면 이전 결정 지점으로 돌아간다.</li></ol><h4 id=복잡도>복잡도<a hidden class=anchor aria-hidden=true href=#복잡도>#</a></h4><ol><li><p>시간 복잡도</p><ul><li><strong>백트래킹</strong>: 최악의 경우 지수 시간(O(b^d)), 여기서 b는 분기 팩터, d는 최대 깊이</li></ul></li><li><p>공간 복잡도</p><ul><li><strong>백트래킹</strong>: O(d), 재귀 호출 스택의 깊이에 비례</li></ul></li></ol><h4 id=백트래킹-구현-시-고려사항>백트래킹 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#백트래킹-구현-시-고려사항>#</a></h4><ol><li><strong>상태 표현</strong>: 부분 해결책을 효율적으로 표현하는 방법</li><li><strong>제약 조건 검사</strong>: 가능한 한 빨리 유효하지 않은 경로를 식별</li><li><strong>재귀 함수 설계</strong>: 스택 오버플로우를 방지하기 위한 적절한 재귀 깊이 관리</li><li><strong>상태 복원</strong>: 백트래킹 후 이전 상태로 정확히 복원하는 메커니즘</li></ol><h4 id=백트래킹-최적화>백트래킹 최적화<a hidden class=anchor aria-hidden=true href=#백트래킹-최적화>#</a></h4><ol><li><strong>전방 검사(Forward Checking)</strong>: 현재 할당의 영향을 미리 확인</li><li><strong>가장 제약이 많은 변수 선택(MRV)</strong>: 가장 선택지가 적은 변수부터 처리</li><li><strong>가장 제약이 적은 값 선택(LCV)</strong>: 다른 변수에 가장 적은 제약을 가하는 값 선택</li><li><strong>아크 일관성(Arc Consistency)</strong>: 변수 쌍 간의 일관성 유지</li></ol><h4 id=백트래킹-적용-사례>백트래킹 적용 사례<a hidden class=anchor aria-hidden=true href=#백트래킹-적용-사례>#</a></h4><ol><li><strong>N-Queens 문제</strong>: N×N 체스판에 N개의 퀸을 배치하는 문제</li><li><strong>스도쿠 퍼즐</strong>: 9×9 그리드에 1-9의 숫자를 채우는 퍼즐</li><li><strong>그래프 컬러링</strong>: 인접한 정점이 같은 색상을 갖지 않도록 그래프의 각 정점에 색상을 할당</li><li><strong>부분집합 합 문제</strong>: 주어진 집합에서 합이 특정 값이 되는 부분집합 찾기</li><li><strong>해밀턴 경로</strong>: 그래프의 모든 정점을 정확히 한 번씩 방문하는 경로 찾기</li></ol><h4 id=알고리즘-템플릿>알고리즘 템플릿<a hidden class=anchor aria-hidden=true href=#알고리즘-템플릿>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>candidate</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>is_complete</span><span class=p>(</span><span class=n>candidate</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>output</span><span class=p>(</span><span class=n>candidate</span><span class=p>)</span>  <span class=c1># 완전한 해결책 발견</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>next_candidate</span> <span class=ow>in</span> <span class=n>get_candidates</span><span class=p>(</span><span class=n>candidate</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_valid</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>):</span>  <span class=c1># 제약 조건 검사</span>
</span></span><span class=line><span class=cl>            <span class=n>place</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>)</span>  <span class=c1># 후보 배치</span>
</span></span><span class=line><span class=cl>            <span class=n>backtrack</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>)</span>  <span class=c1># 재귀적으로 다음 단계 탐색</span>
</span></span><span class=line><span class=cl>            <span class=n>remove</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>)</span>  <span class=c1># 백트래킹 (후보 제거)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=예시-n-queens-문제>예시: N-Queens 문제<a hidden class=anchor aria-hidden=true href=#예시-n-queens-문제>#</a></h4><p>N-Queens 문제는 N×N 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_valid</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 같은 열에 퀸이 있는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>col</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 대각선 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>abs</span><span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>col</span><span class=p>)</span> <span class=o>==</span> <span class=n>row</span> <span class=o>-</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>solutions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>board</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_valid</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=n>col</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># 백트래킹 (명시적인 제거는 필요 없음, 다른 값으로 덮어씀)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>solutions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>([</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solutions</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=분기한정법branch-and-bound>분기한정법(Branch And Bound)<a hidden class=anchor aria-hidden=true href=#분기한정법branch-and-bound>#</a></h3><p>분기한정법은 최적화 문제를 해결하기 위한 알고리즘으로, 해공간을 체계적으로 탐색하면서 가능한 해결책의 상한과 하한을 계산하여 최적해를 찾는 방법이다.<br>이 방법은 특히 최소화 또는 최대화 문제에 효과적.</p><p>작동 원리:</p><ol><li><strong>분기(Branching)</strong>: 문제를 더 작은 하위 문제로 분할.</li><li><strong>한정(Bounding)</strong>: 각 하위 문제에 대한 상한과 하한을 계산.</li><li><strong>가지치기(Pruning)</strong>: 현재까지 발견된 최적해보다 나쁜 경계값을 가진 하위 문제는 제외.</li><li><strong>탐색 전략</strong>: 일반적으로 최상 우선 탐색(Best-First Search) 또는 너비 우선 탐색(BFS)을 사용.</li></ol><h4 id=복잡도-1>복잡도<a hidden class=anchor aria-hidden=true href=#복잡도-1>#</a></h4><ol><li>시간 복잡도<ul><li><strong>백트래킹</strong>: 최악의 경우 지수 시간(O(b^d)), 여기서 b는 분기 팩터, d는 최대 깊이</li><li><strong>분기한정법</strong>: 최악의 경우 지수 시간(O(b^d)), 그러나 효과적인 한정 함수를 사용하면 평균적으로 더 나은 성능</li></ul></li><li>공간 복잡도<ul><li><strong>백트래킹</strong>: O(d), 재귀 호출 스택의 깊이에 비례</li><li><strong>분기한정법</strong>: O(b^d), 최악의 경우 모든 노드를 저장해야 할 수 있음</li></ul></li></ol><h4 id=분기한정법-구현-시-고려사항>분기한정법 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#분기한정법-구현-시-고려사항>#</a></h4><ol><li><strong>경계 함수 설계</strong>: 정확하고 계산이 빠른 하한/상한 함수 개발</li><li><strong>노드 표현</strong>: 상태, 비용, 경계값을 효율적으로 저장</li><li><strong>우선순위 큐 관리</strong>: 큐의 크기가 지나치게 커지는 것을 방지</li><li><strong>중복 상태 처리</strong>: 동일한 상태가 여러 번 탐색되는 것을 방지</li></ol><h4 id=분기한정법-최적화>분기한정법 최적화<a hidden class=anchor aria-hidden=true href=#분기한정법-최적화>#</a></h4><ol><li><strong>더 나은 경계 함수</strong>: 더 정확한 하한/상한 계산</li><li><strong>휴리스틱 함수 사용</strong>: 유망한 해결책으로 빠르게 유도</li><li><strong>지배 관계(Dominance Relations)</strong>: 더 나은 해결책이 보장된 상태 식별</li><li><strong>병렬 처리</strong>: 독립적인 하위 문제를 병렬로 처리</li></ol><h4 id=분기한정법-적용-사례>분기한정법 적용 사례<a hidden class=anchor aria-hidden=true href=#분기한정법-적용-사례>#</a></h4><ol><li><strong>외판원 문제(TSP)</strong>: 모든 도시를 한 번씩 방문하고 출발점으로 돌아오는 최단 경로 찾기</li><li><strong>0-1 배낭 문제</strong>: 제한된 무게 내에서 최대 가치를 갖는 아이템 선택</li><li><strong>작업 할당 문제</strong>: n개의 작업을 n명의 작업자에게 최소 비용으로 할당</li><li><strong>최단 경로 문제</strong>: 그래프에서 두 정점 사이의 최단 경로 찾기</li><li><strong>정수 선형 계획법(ILP)</strong>: 정수 변수를 사용하는 선형 최적화 문제</li></ol><h4 id=알고리즘-템플릿-1>알고리즘 템플릿<a hidden class=anchor aria-hidden=true href=#알고리즘-템플릿-1>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>branch_and_bound</span><span class=p>(</span><span class=n>problem</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>()</span>  <span class=c1># 우선순위 큐 (경계값 기준)</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>initial_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>best_solution</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>best_value</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>  <span class=c1># 최소화 문제 가정</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=o>.</span><span class=n>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>best_value</span><span class=p>:</span>  <span class=c1># 유망한 노드인지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_leaf</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&lt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>best_value</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>                    <span class=n>best_solution</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>solution</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>branch</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=n>child</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>best_value</span><span class=p>:</span>  <span class=c1># 유망한 자식만 추가</span>
</span></span><span class=line><span class=cl>                        <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_solution</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=예시-외판원-문제tsp>예시: 외판원 문제(TSP)<a hidden class=anchor aria-hidden=true href=#예시-외판원-문제tsp>#</a></h4><p>외판원 문제는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span><span class=lnt id=hl-3-42><a class=lnlinks href=#hl-3-42>42</a>
</span><span class=lnt id=hl-3-43><a class=lnlinks href=#hl-3-43>43</a>
</span><span class=lnt id=hl-3-44><a class=lnlinks href=#hl-3-44>44</a>
</span><span class=lnt id=hl-3-45><a class=lnlinks href=#hl-3-45>45</a>
</span><span class=lnt id=hl-3-46><a class=lnlinks href=#hl-3-46>46</a>
</span><span class=lnt id=hl-3-47><a class=lnlinks href=#hl-3-47>47</a>
</span><span class=lnt id=hl-3-48><a class=lnlinks href=#hl-3-48>48</a>
</span><span class=lnt id=hl-3-49><a class=lnlinks href=#hl-3-49>49</a>
</span><span class=lnt id=hl-3-50><a class=lnlinks href=#hl-3-50>50</a>
</span><span class=lnt id=hl-3-51><a class=lnlinks href=#hl-3-51>51</a>
</span><span class=lnt id=hl-3-52><a class=lnlinks href=#hl-3-52>52</a>
</span><span class=lnt id=hl-3-53><a class=lnlinks href=#hl-3-53>53</a>
</span><span class=lnt id=hl-3-54><a class=lnlinks href=#hl-3-54>54</a>
</span><span class=lnt id=hl-3-55><a class=lnlinks href=#hl-3-55>55</a>
</span><span class=lnt id=hl-3-56><a class=lnlinks href=#hl-3-56>56</a>
</span><span class=lnt id=hl-3-57><a class=lnlinks href=#hl-3-57>57</a>
</span><span class=lnt id=hl-3-58><a class=lnlinks href=#hl-3-58>58</a>
</span><span class=lnt id=hl-3-59><a class=lnlinks href=#hl-3-59>59</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_tsp</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>cost</span><span class=p>,</span> <span class=n>bound</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=o>=</span> <span class=n>path</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>bound</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__lt__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>other</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>other</span><span class=o>.</span><span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>compute_bound</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 하한값 계산 (각 미방문 도시에서 가장 짧은 간선들의 합)</span>
</span></span><span class=line><span class=cl>        <span class=n>bound</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_edge</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>j</span> <span class=o>!=</span> <span class=n>i</span> <span class=ow>and</span> <span class=p>(</span><span class=n>j</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span> <span class=ow>or</span> <span class=n>j</span> <span class=o>==</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>                        <span class=n>min_edge</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_edge</span><span class=p>,</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>bound</span> <span class=o>+=</span> <span class=n>min_edge</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 시작 노드 (0번 도시부터 시작)</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>Node</span><span class=p>([</span><span class=mi>0</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>best_tour</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>best_cost</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=ow>not</span> <span class=n>queue</span><span class=o>.</span><span class=n>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>)</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 마지막 도시에서 시작 도시로 돌아가는 비용 추가</span>
</span></span><span class=line><span class=cl>                <span class=n>total_cost</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>+</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>total_cost</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>best_cost</span> <span class=o>=</span> <span class=n>total_cost</span>
</span></span><span class=line><span class=cl>                    <span class=n>best_tour</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span> <span class=o>+</span> <span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>next_city</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>next_city</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>new_path</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>path</span> <span class=o>+</span> <span class=p>[</span><span class=n>next_city</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                        <span class=n>new_cost</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>cost</span> <span class=o>+</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][</span><span class=n>next_city</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                        <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>new_path</span><span class=p>,</span> <span class=n>new_cost</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>new_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=n>compute_bound</span><span class=p>(</span><span class=n>new_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=n>new_node</span><span class=o>.</span><span class=n>bound</span> <span class=o>&lt;</span> <span class=n>best_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                            <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>new_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_tour</span><span class=p>,</span> <span class=n>best_cost</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=두-기법의-핵심-차이점>두 기법의 핵심 차이점<a hidden class=anchor aria-hidden=true href=#두-기법의-핵심-차이점>#</a></h3><ol><li><strong>목적</strong>:<ul><li>백트래킹: 모든 가능한 해결책을 찾거나 제약 조건을 만족하는 해결책을 찾는 데 중점을 둔다.</li><li>분기한정법: 최적화 문제에서 최적해를 찾는 데 중점을 둔다.</li></ul></li><li><strong>탐색 전략</strong>:<ul><li>백트래킹: 일반적으로 깊이 우선 탐색(DFS)을 사용.</li><li>분기한정법: 일반적으로 최상 우선 탐색(Best-First Search) 또는 너비 우선 탐색(BFS)을 사용.</li></ul></li><li><strong>가지치기 기준</strong>:<ul><li>백트래킹: 제약 조건 위반 여부에 따라 가지치기.</li><li>분기한정법: 경계값(bound)과 현재 최적해 비교를 통해 가지치기.</li></ul></li><li><strong>상태 공간 탐색</strong>:<ul><li>백트래킹: 가능한 모든 조합을 체계적으로 생성하고 테스트.</li><li>분기한정법: 유망한 부분 공간을 우선적으로 탐색.</li></ul></li><li><strong>메모리 사용</strong>:<ul><li>백트래킹: 재귀 호출 스택에 의존하므로 상대적으로 메모리 효율적.</li><li>분기한정법: 우선순위 큐나 활성 노드 목록을 유지해야 하므로 더 많은 메모리가 필요할 수 있다.</li></ul></li></ol><h3 id=하이브리드-접근법>하이브리드 접근법<a hidden class=anchor aria-hidden=true href=#하이브리드-접근법>#</a></h3><p>최근에는 두 기법의 장점을 결합한 하이브리드 알고리즘이 개발되고 있다:</p><ol><li><strong>백트래킹 + 하한 계산</strong>: 백트래킹 알고리즘에 하한 계산을 추가하여 더 효과적인 가지치기</li><li><strong>분기한정법 + 깊이 우선 탐색</strong>: 메모리 효율성을 위해 DFS 전략을 사용하는 분기한정법</li><li><strong>제약 프로그래밍 + 분기한정법</strong>: 제약 프로그래밍의 유연성과 분기한정법의 최적화 능력 결합</li></ol><h3 id=비교-분석-표>비교 분석 표<a hidden class=anchor aria-hidden=true href=#비교-분석-표>#</a></h3><table><thead><tr><th>특성</th><th>백트래킹(Backtracking)</th><th>분기한정법(Branch and Bound)</th></tr></thead><tbody><tr><td><strong>주요 목적</strong></td><td>모든 가능한 해결책 찾기 또는 제약 충족</td><td>최적화 문제에서 최적해 찾기</td></tr><tr><td><strong>탐색 전략</strong></td><td>깊이 우선 탐색(DFS)</td><td>최상 우선 탐색 또는 너비 우선 탐색</td></tr><tr><td><strong>가지치기 기준</strong></td><td>제약 조건 위반</td><td>경계값과 현재 최적해 비교</td></tr><tr><td><strong>공간 탐색 방식</strong></td><td>체계적 생성 및 테스트</td><td>유망한 영역 우선 탐색</td></tr><tr><td><strong>상태 유지</strong></td><td>현재 경로만 유지</td><td>유망한 모든 부분 문제 유지</td></tr><tr><td><strong>시간 복잡도</strong></td><td>O(b^d), 가지치기로 개선 가능</td><td>O(b^d), 효과적인 한정으로 개선 가능</td></tr><tr><td><strong>공간 복잡도</strong></td><td>O(d), 깊이에 비례</td><td>O(b^d), 최악의 경우</td></tr><tr><td><strong>적합한 문제 유형</strong></td><td>제약 충족 문제(CSP)</td><td>조합 최적화 문제</td></tr><tr><td><strong>대표적 알고리즘</strong></td><td>N-Queens, 스도쿠 솔버</td><td>외판원 문제, 0-1 배낭 문제</td></tr><tr><td><strong>해의 품질</strong></td><td>모든 해 또는 첫 번째 유효한 해</td><td>최적해 보장</td></tr><tr><td><strong>메모리 효율성</strong></td><td>높음 (재귀 스택만 사용)</td><td>낮음 (활성 노드 목록 유지)</td></tr><tr><td><strong>구현 난이도</strong></td><td>중간</td><td>높음 (좋은 경계 함수 설계 필요)</td></tr><tr><td><strong>병렬화 가능성</strong></td><td>제한적</td><td>높음 (독립적 하위 문제)</td></tr><tr><td><strong>조기 해 발견</strong></td><td>가능 (첫 번째 해가 중요한 경우)</td><td>최적해 보장을 위해 계속 실행</td></tr><tr><td><strong>휴리스틱 활용</strong></td><td>제한적</td><td>광범위 (경계 함수, 탐색 전략)</td></tr><tr><td><strong>변형/확장</strong></td><td>전방 검사, MRV, LCV</td><td>A* 알고리즘, 휴리스틱 탐색</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/branch-and-bound/>Branch-and-Bound</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/character-encoding/regional-encodings/ansi/><span class=title>« Prev</span><br><span>ANSI</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/non-tail-recursion/><span class=title>Next »</span><br><span>비꼬리 재귀(Non-tail Recursion)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>