<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>B 트리 (B-Trees) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Tree,Types,Multiway-Trees,B-tree"><meta name=description content="균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="B 트리 (B-Trees)"><meta property="og:description" content="균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="B 트리 (B-Trees)"><meta name=twitter:description content="균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":3,"name":"B 트리 (B-Trees)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/self-balancing-trees/b-trees/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>B 트리 (B-Trees)</h1><div class=post-description>균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조</div></header><div class=post-content><h2 id=b-트리-b-tree>B 트리 (B Tree)<a hidden class=anchor aria-hidden=true href=#b-트리-b-tree>#</a></h2><p>B 트리는 1972년 루돌프 바이어(Rudolf Bayer)와 에드워드 맥크라이트(Edward McCreight)가 개발한 자가 균형(self-balancing) 트리 자료구조로, 대용량 데이터를 효율적으로 저장하고 검색하는 데 최적화되어 있다.</p><p>특히 디스크나 외부 메모리에 데이터를 저장할 때 발생하는 입출력 연산을 최소화하도록 설계되었으며, 현대 데이터베이스 시스템과 파일 시스템의 근간이 되는 중요한 자료구조이다.</p><p>B 트리는 대용량 데이터를 효율적으로 관리하기 위한 강력한 자료구조로, 특히 디스크 기반 저장 시스템에서 탁월한 성능을 발휘한다. 데이터베이스 시스템, 파일 시스템, 검색 엔진 등 다양한 분야에서 핵심적인 역할을 하고 있으며, 여러 변형이 개발되어 특정 응용 분야에 맞게 최적화되었다.</p><p>B 트리의 균형 유지 메커니즘, 다중 분기 구조, 효율적인 디스크 I/O 특성은 빅데이터 시대에도 여전히 중요한 가치를 지니고 있으며, 새로운 하드웨어와 응용 환경에 적응하기 위한 연구가 계속되고 있다.</p><h3 id=트리의-기본-개념>트리의 기본 개념<a hidden class=anchor aria-hidden=true href=#트리의-기본-개념>#</a></h3><ol><li><p>정의와 특성<br>B 트리는 다음과 같은 특성을 가진 균형 검색 트리이다:</p><ul><li><strong>다중 분기 트리(Multiway Tree)</strong>: 하나의 노드가 둘 이상의 자식을 가질 수 있다.</li><li><strong>차수(Order)</strong>: B 트리의 차수 m은 노드당 최대 자식 수를 의미.</li><li><strong>균형 유지</strong>: 모든 리프 노드는 같은 깊이에 있어 트리가 항상 균형을 유지한다.</li><li><strong>노드 채움 규칙</strong>: 루트와 리프를 제외한 모든 노드는 최소 <code>⌈m/2⌉-1개</code>개의 키를 가져야 한다.</li><li><strong>정렬된 키</strong>: 각 노드 내의 키는 오름차순으로 정렬되어 있다.</li><li><strong>분할과 병합</strong>: 노드가 너무 많은 키를 가지면 분할(split)하고, 너무 적은 키를 가지면 이웃 노드와 병합(merge)하거나 재분배(redistribution)한다.</li></ul></li><li><p>B 트리 노드의 구조<br>B 트리의 노드는 다음과 같은 구성 요소를 가진다:</p><ul><li><strong>키(Keys)</strong>: 정렬된 값들로, 검색과 범위 질의에 사용.</li><li><strong>포인터(Pointers)</strong>: 자식 노드를 가리키는 참조.</li><li><strong>노드 종류</strong>: 내부 노드(Internal node)와 리프 노드(Leaf node)로 구분.<br>차수가 m인 B 트리의 각 노드는:</li><li>최대 m-1개의 키를 저장할 수 있다.</li><li>최대 m개의 자식 포인터를 가질 수 있다.</li><li>루트를 제외한 내부 노드는 최소 ⌈m/2⌉개의 자식을 가져야 한다.</li><li>루트는 최소 2개의 자식을 가져야 한다(단, 루트가 리프인 경우 제외).</li></ul></li><li><p>부모-자식 관계 규칙<br>B 트리에서는 부모 노드의 키 값은 자식 노드의 모든 키보다 크거나 같고, 왼쪽 서브트리의 모든 키보다 작아야 한다. 즉, 각 자식 노드는 부모 키의 범위 내에 존재하는 값을 포함해야 한다.</p></li></ol><p>차수 m=6인 B-트리에서:</p><ol><li><strong>최대 키 개수</strong>: m-1 = 6-1 = 5개</li><li><strong>최소 키 개수</strong>: ⌈m/2⌉-1 = ⌈6/2⌉-1 = 3-1 = 2개 (루트 노드 제외)</li><li><strong>최대 자식 수</strong>: m = 6개</li><li><strong>최소 자식 수</strong>: ⌈m/2⌉ = ⌈6/2⌉ = 3개 (루트 노드 제외)<br>루트 노드의 경우:</li></ol><ul><li>최소 키 개수: 1개 (트리에 노드가 1개만 있는 경우 0개도 가능)</li><li>최소 자식 수: 2개 (1개의 키를 가질 때)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                                    [50]
</span></span><span class=line><span class=cl>                                  /      \
</span></span><span class=line><span class=cl>                  [20, 35]                     [80, 100, 120, 140, 160]
</span></span><span class=line><span class=cl>                 /    |    \                  /    |    |    |    |    \
</span></span><span class=line><span class=cl>    [5,10,15] [25,30] [40,45]  [55,60,70,75] [85,90,95] [105,110,115] [125,130,135] [145,150,155] [170,180,190]
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>노드</th><th>노드 내용</th><th>키 개수</th><th>자식 수</th><th>분류</th></tr></thead><tbody><tr><td>루트 노드</td><td>[50]</td><td>1개</td><td>2개</td><td>최소 키 개수와 최소 자식 수를 가진 노드</td></tr><tr><td>내부 노드 1</td><td>[20, 35]</td><td>2개</td><td>3개</td><td>최소 키 개수와 최소 자식 수를 가진 노드</td></tr><tr><td>내부 노드 2</td><td>[80, 100, 120, 140, 160]</td><td>5개</td><td>6개</td><td>최대 키 개수와 최대 자식 수를 가진 노드</td></tr><tr><td>리프 노드 1</td><td>[5, 10, 15]</td><td>3개</td><td>0개</td><td>일반 노드</td></tr><tr><td>리프 노드 2</td><td>[25, 30]</td><td>2개</td><td>0개</td><td>최소 키 개수를 가진 노드</td></tr><tr><td>리프 노드 3</td><td>[40, 45]</td><td>2개</td><td>0개</td><td>최소 키 개수를 가진 노드</td></tr><tr><td>리프 노드 4</td><td>[55, 60, 70, 75]</td><td>4개</td><td>0개</td><td>일반 노드</td></tr><tr><td>리프 노드 5</td><td>[85, 90, 95]</td><td>3개</td><td>0개</td><td>일반 노드</td></tr><tr><td>리프 노드 6</td><td>[105, 110, 115]</td><td>3개</td><td>0개</td><td>일반 노드</td></tr><tr><td>리프 노드 7</td><td>[125, 130, 135]</td><td>3개</td><td>0개</td><td>일반 노드</td></tr><tr><td>리프 노드 8</td><td>[145, 150, 155]</td><td>3개</td><td>0개</td><td>일반 노드</td></tr><tr><td>리프 노드 9</td><td>[170, 180, 190]</td><td>3개</td><td>0개</td><td>일반 노드</td></tr></tbody></table><h3 id=b-트리의-장단점>B 트리의 장단점<a hidden class=anchor aria-hidden=true href=#b-트리의-장단점>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li><strong>균형 유지</strong>: 트리가 항상 균형을 유지하여 최악의 경우에도 일관된 성능을 보장한다.</li><li><strong>디스크 효율성</strong>: 높은 분기 계수로 I/O 연산을 최소화하여 디스크 기반 시스템에 적합하다.</li><li><strong>범위 검색</strong>: 정렬된 키를 저장하므로 범위 검색이 효율적이다(특히 B+ 트리).</li><li><strong>확장성</strong>: 대용량 데이터를 처리할 수 있도록 설계되었다.</li><li><strong>동적 크기 조정</strong>: 데이터가 증가하거나 감소함에 따라 자동으로 크기가 조정된다.</li></ul><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li><strong>구현 복잡성</strong>: 삽입, 삭제 연산의 구현이 상대적으로 복잡하다.</li><li><strong>메모리 오버헤드</strong>: 각 노드가 여러 키와 포인터를 저장하므로 일부 메모리 오버헤드가 발생한다.</li><li><strong>캐시 효율성</strong>: 노드 크기가 크면 CPU 캐시 효율성이 떨어질 수 있다.</li><li><strong>동시성 제어</strong>: 멀티스레드 환경에서 B 트리의 동시성 제어는 복잡할 수 있다.</li></ul><h3 id=b-트리의-연산>B 트리의 연산<a hidden class=anchor aria-hidden=true href=#b-트리의-연산>#</a></h3><h4 id=검색-연산>검색 연산<a hidden class=anchor aria-hidden=true href=#검색-연산>#</a></h4><p>B 트리에서의 검색은 다음과 같은 단계로 이루어진다:</p><ol><li>루트 노드에서 시작한다.</li><li>현재 노드에서 키를 순차적으로 검사하여 목표 키를 찾는다.</li><li>만약 현재 노드에서 목표 키를 찾지 못하면, 적절한 자식 노드로 이동한다.</li><li>리프 노드에 도달할 때까지 과정을 반복한다.</li></ol><h5 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h5><ol><li><strong>노드 내부 검색</strong>: 각 노드 내에서 키를 검색할 때는 일반적으로 순차 검색 또는 이진 검색을 사용한다.</li><li><strong>경로 검색</strong>: 루트에서 적절한 리프 노드까지 한 번에 하나의 노드만 방문하므로, 디스크 I/O를 최소화한다.</li><li><strong>균형 트리 이점</strong>: 항상 균형을 유지하므로 최악의 경우에도 일관된 검색 성능을 보장한다.</li><li><strong>블록 접근 최적화</strong>: 디스크 블록 크기에 맞게 노드 크기를 설정하면 각 노드 접근이 단일 I/O 연산으로 이루어져 효율성이 향상된다.</li></ol><h5 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>leaf</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>keys</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 키를 저장하는 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 자식 노드를 가리키는 포인터 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>leaf</span> <span class=o>=</span> <span class=n>leaf</span>  <span class=c1># 리프 노드 여부</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;B 트리에서 키를 검색하는 함수&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드에서 키의 위치를 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=n>key</span> <span class=o>&gt;</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 키를 찾은 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=n>key</span> <span class=o>==</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>  <span class=c1># 노드와 키의 인덱스 반환</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 리프 노드에 도달했지만 키를 찾지 못한 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>  <span class=c1># 키가 트리에 존재하지 않음</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 적절한 자식 노드로 이동하여 재귀적으로 검색</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>key</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>B 트리에서의 검색 시간 복잡도는 O(log_m n)<br>여기서:</p><ul><li>m은 B 트리의 차수</li><li>n은 트리에 저장된 키의 총 개수</li></ul><h5 id=예시>예시<a hidden class=anchor aria-hidden=true href=#예시>#</a></h5><p>다음과 같은 차수 5인 B 트리가 있다고 가정해 보자:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                    [30, 60]
</span></span><span class=line><span class=cl>                   /    |    \
</span></span><span class=line><span class=cl>        [10, 20]        [40, 50]        [70, 80, 90]
</span></span></code></pre></td></tr></table></div></div><p>이 B 트리에서 몇 가지 키 값을 검색해 보면</p><ol><li><p>키 값 45 검색하기<br>키 값 45를 검색하는 과정은 다음과 같다:</p><ol><li><strong>루트 노드 검사</strong>: [30, 60]을 확인.<ul><li>45는 30보다 크고 60보다 작다.</li><li>따라서 중간 자식 노드로 이동한다.</li></ul></li><li><strong>중간 자식 노드 검사</strong>: [40, 50]을 확인.<ul><li>45는 40보다 크고 50보다 작다.</li><li>만약 이 노드 사이에 45가 있다면 찾았을 것.</li><li>그러나 없으므로 검색은 실패.<br>결과: 키 값 45는 트리에 존재하지 않는다.</li></ul></li></ol></li><li><p>키 값 80 검색하기<br>키 값 80을 검색하는 과정은 다음과 같다:</p><ol><li><strong>루트 노드 검사</strong>: [30, 60]을 확인.<ul><li>80은 60보다 크다.</li><li>따라서 오른쪽 자식 노드로 이동한다.</li></ul></li><li><strong>오른쪽 자식 노드 검사</strong>: [70, 80, 90]을 확인한다.<ul><li>80이 노드 내에 존재! (두 번째 키 값)</li><li>검색 성공!<br>결과: 키 값 80은 트리의 오른쪽 자식 노드의 두 번째 키 값으로 존재.</li></ul></li></ol></li><li><p>키 값 25 검색하기<br>키 값 25를 검색하는 과정은 다음과 같다:</p><ol><li><strong>루트 노드 검사</strong>: [30, 60]을 확인.<ul><li>25는 30보다 작다.</li><li>따라서 왼쪽 자식 노드로 이동합니다.</li></ul></li><li><strong>왼쪽 자식 노드 검사</strong>: [10, 20]을 확인.<ul><li>25는 20보다 크다.</li><li>이 노드에는 25가 없으므로, 만약 더 자식 노드가 있다면 20과 30 사이의 자식 노드로 이동해야 한다.</li><li>그러나 이 노드는 리프 노드이므로 검색은 실패.<br>결과: 키 값 25는 트리에 존재하지 않는다.</li></ul></li></ol></li></ol><p>전체 검색 과정 시각화(키 값 80 검색):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. 루트 노드 [30, 60] 검사
</span></span><span class=line><span class=cl>   - 80 &gt; 60 이므로 오른쪽 자식으로 이동
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   [30, 60]
</span></span><span class=line><span class=cl>      /|\
</span></span><span class=line><span class=cl>     / | \
</span></span><span class=line><span class=cl>    /  |  \
</span></span><span class=line><span class=cl>   /   |   \
</span></span><span class=line><span class=cl>  v    v    v
</span></span><span class=line><span class=cl>[10,20] [40,50] [70,80,90]
</span></span><span class=line><span class=cl>                     ^
</span></span><span class=line><span class=cl>                     |
</span></span><span class=line><span class=cl>1. [70, 80, 90] 노드 검사
</span></span><span class=line><span class=cl>   - 80 == 80 이므로 검색 성공!
</span></span><span class=line><span class=cl>   - 결과: 노드 [70, 80, 90]의 인덱스 1에서 키 80 발견
</span></span></code></pre></td></tr></table></div></div><h4 id=삽입-연산>삽입 연산<a hidden class=anchor aria-hidden=true href=#삽입-연산>#</a></h4><p>B 트리에 새로운 키를 삽입하는 과정은 다음과 같다:</p><ol><li>적절한 리프 노드를 찾는다.</li><li>해당 리프 노드에 키를 삽입한다.</li><li>노드의 키 개수가 최대치(m-1)를 초과하면 노드를 분할한다:<ul><li>중앙 키를 부모 노드로 이동시킨다.</li><li>나머지 키들을 두 개의 노드로 분할한다.</li></ul></li><li>필요한 경우 분할이 루트까지 전파될 수 있다.</li></ol><h5 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h5><ol><li><strong>항상 리프 노드에서 시작</strong>: 새로운 키는 항상 리프 노드에 삽입된다.</li><li><strong>상향식 성장</strong>: 노드가 가득 차면 분할하고 중간 키를 부모로 올리는 방식으로 트리가 위로 성장한다.</li><li><strong>사전 분할(Proactive Splitting)</strong>: 삽입 경로에서 꽉 찬 노드를 미리 분할하여 삽입 후 재조정을 방지한다.</li><li><strong>균형 유지</strong>: 삽입 과정에서 트리의 균형이 자동으로 유지된다.</li><li><strong>높이 증가</strong>: 루트 노드가 분할될 때만 트리의 높이가 증가한다.</li><li><strong>특성 보존</strong>: 삽입 과정에서 B 트리의 모든 특성이 유지된다.</li></ol><h5 id=구현-예시-1>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span><span class=lnt id=hl-4-47><a class=lnlinks href=#hl-4-47>47</a>
</span><span class=lnt id=hl-4-48><a class=lnlinks href=#hl-4-48>48</a>
</span><span class=lnt id=hl-4-49><a class=lnlinks href=#hl-4-49>49</a>
</span><span class=lnt id=hl-4-50><a class=lnlinks href=#hl-4-50>50</a>
</span><span class=lnt id=hl-4-51><a class=lnlinks href=#hl-4-51>51</a>
</span><span class=lnt id=hl-4-52><a class=lnlinks href=#hl-4-52>52</a>
</span><span class=lnt id=hl-4-53><a class=lnlinks href=#hl-4-53>53</a>
</span><span class=lnt id=hl-4-54><a class=lnlinks href=#hl-4-54>54</a>
</span><span class=lnt id=hl-4-55><a class=lnlinks href=#hl-4-55>55</a>
</span><span class=lnt id=hl-4-56><a class=lnlinks href=#hl-4-56>56</a>
</span><span class=lnt id=hl-4-57><a class=lnlinks href=#hl-4-57>57</a>
</span><span class=lnt id=hl-4-58><a class=lnlinks href=#hl-4-58>58</a>
</span><span class=lnt id=hl-4-59><a class=lnlinks href=#hl-4-59>59</a>
</span><span class=lnt id=hl-4-60><a class=lnlinks href=#hl-4-60>60</a>
</span><span class=lnt id=hl-4-61><a class=lnlinks href=#hl-4-61>61</a>
</span><span class=lnt id=hl-4-62><a class=lnlinks href=#hl-4-62>62</a>
</span><span class=lnt id=hl-4-63><a class=lnlinks href=#hl-4-63>63</a>
</span><span class=lnt id=hl-4-64><a class=lnlinks href=#hl-4-64>64</a>
</span><span class=lnt id=hl-4-65><a class=lnlinks href=#hl-4-65>65</a>
</span><span class=lnt id=hl-4-66><a class=lnlinks href=#hl-4-66>66</a>
</span><span class=lnt id=hl-4-67><a class=lnlinks href=#hl-4-67>67</a>
</span><span class=lnt id=hl-4-68><a class=lnlinks href=#hl-4-68>68</a>
</span><span class=lnt id=hl-4-69><a class=lnlinks href=#hl-4-69>69</a>
</span><span class=lnt id=hl-4-70><a class=lnlinks href=#hl-4-70>70</a>
</span><span class=lnt id=hl-4-71><a class=lnlinks href=#hl-4-71>71</a>
</span><span class=lnt id=hl-4-72><a class=lnlinks href=#hl-4-72>72</a>
</span><span class=lnt id=hl-4-73><a class=lnlinks href=#hl-4-73>73</a>
</span><span class=lnt id=hl-4-74><a class=lnlinks href=#hl-4-74>74</a>
</span><span class=lnt id=hl-4-75><a class=lnlinks href=#hl-4-75>75</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>leaf</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=n>t</span>  <span class=c1># 최소 차수</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>keys</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 키를 저장하는 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 자식 노드를 가리키는 포인터 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>leaf</span> <span class=o>=</span> <span class=n>leaf</span>  <span class=c1># 리프 노드 여부</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>split_child</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 노드 y를 분할하는 함수 (y는 self의 i번째 자식)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 새로운 노드 z를 생성하여 y의 오른쪽 절반을 이동시킴</span>
</span></span><span class=line><span class=cl>        <span class=n>z</span> <span class=o>=</span> <span class=n>BTreeNode</span><span class=p>(</span><span class=n>y</span><span class=o>.</span><span class=n>t</span><span class=p>,</span> <span class=n>y</span><span class=o>.</span><span class=n>leaf</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># t-1개의 키를 z로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>z</span><span class=o>.</span><span class=n>keys</span> <span class=o>=</span> <span class=n>y</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span><span class=o>.</span><span class=n>keys</span> <span class=o>=</span> <span class=n>y</span><span class=o>.</span><span class=n>keys</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 리프 노드가 아니면 자식도 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>y</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>z</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=n>y</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>            <span class=n>y</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=n>y</span><span class=o>.</span><span class=n>children</span><span class=p>[:</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 부모 노드에 중앙 키 삽입 및 새 자식 연결</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>z</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>y</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>mid</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>mid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTree</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>t</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=n>t</span>  <span class=c1># 최소 차수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 트리가 비어있는 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>BTreeNode</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>,</span> <span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 루트가 가득 찬 경우, 높이가 증가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span> <span class=o>=</span> <span class=n>BTreeNode</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>,</span> <span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=o>.</span><span class=n>split_child</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=n>s</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_insert_non_full</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_insert_non_full</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_insert_non_full</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 키를 삽입할 위치 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 리프 노드인 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>x</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 적절한 위치에 키 삽입</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>x</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 내부 노드인 경우</span>
</span></span><span class=line><span class=cl>            <span class=c1># 키가 삽입될 자식 노드 찾기</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>x</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 자식이 가득 차 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>==</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>x</span><span class=o>.</span><span class=n>split_child</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>x</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=c1># 분할 후 어느 쪽 자식으로 가야 할지 결정</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>k</span> <span class=o>&gt;</span> <span class=n>x</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 적절한 자식으로 재귀 호출</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_insert_non_full</span><span class=p>(</span><span class=n>x</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>B 트리 삽입 연산의 시간 복잡도는 O(log_t n)<br>여기서:</p><ul><li>t는 B 트리의 최소 차수</li><li>n은 트리에 저장된 키의 총 개수</li></ul><h5 id=예시-1>예시<a hidden class=anchor aria-hidden=true href=#예시-1>#</a></h5><p>B 트리에 새로운 키를 삽입하는 과정을 차수 m=5인 B 트리를 통해 자세히 살펴보자.<br>차수가 5인 B 트리에서는 각 노드가 최소 2개, 최대 4개의 키를 가질 수 있으며, 각 내부 노드는 최소 3개, 최대 5개의 자식을 가질 수 있다.</p><ul><li>B 트리의 속성 (차수 m=5)<br>먼저 차수가 5인 B 트리의 주요 속성:<br>1. <strong>최대 키 개수</strong>: m-1 = 5-1 = 4개<br>2. <strong>최소 키 개수</strong>: ⌈m/2⌉-1 = ⌈5/2⌉-1 = 3-1 = 2개 (루트 노드 제외)<br>3. <strong>최대 자식 수</strong>: m = 5개<br>4. <strong>최소 자식 수</strong>: ⌈m/2⌉ = ⌈5/2⌉ = 3개 (루트 노드 제외)<br>루트 노드의 경우:<ul><li>최소 키 개수: 1개 (트리에 노드가 1개만 있는 경우 0개도 가능)</li><li>최소 자식 수: 2개 (1개의 키를 가질 때)</li></ul></li></ul><p>초기:<br>처음에는 빈 B 트리에서 시작하여 여러 키를 차례로 삽입하면서 B 트리가 어떻게 성장하는지 살펴보자.</p><ol><li><p>키 값 50 삽입하기:<br>빈 트리에 첫 번째 키 50을 삽입.</p><ol><li>트리가 비어 있으므로, 새로운 루트 노드를 생성하고 50을 삽입.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[50]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 30 삽입하기</p><ol><li>루트 노드 [50]에서 30은 50보다 작으므로, 왼쪽에 삽입한다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[30, 50]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 70 삽입하기</p><ol><li>루트 노드 [30, 50]에서 70은 50보다 크므로, 오른쪽에 삽입한다.</li><li>삽입 후 노드는 [30, 50, 70]이 된다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[30, 50, 70]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 20 삽입하기</p><ol><li>루트 노드 [30, 50, 70]에서 20은 30보다 작으므로, 왼쪽에 삽입한다.</li><li>삽입 후 노드는 [20, 30, 50, 70]이 된다.</li><li>노드는 이제 최대 키 개수(4개)에 도달.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[20, 30, 50, 70]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 40 삽입하기 (첫 번째 분할 발생)<br>키 값 40을 삽입하려고 하지만, 루트 노드는 이미 최대 키 개수(4개)를 가지고 있다.<br>따라서 노드 분할이 필요하다.</p><ol><li>노드 [20, 30, 50, 70]에 40을 삽입하려고 하면, 정렬된 배열은 [20, 30, 40, 50, 70]이 된다.<br>그러나 이는 최대 키 개수를 초과한다.</li><li>노드 분할 과정:<ul><li>중간 키(40)를 새로운 루트로 선택한다.</li><li>왼쪽 노드에는 [20, 30], 오른쪽 노드에는 [50, 70]이 위치한다.<br>결과 트리:</li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>      [40]
</span></span><span class=line><span class=cl>     /    \
</span></span><span class=line><span class=cl>[20, 30]  [50, 70]
</span></span></code></pre></td></tr></table></div></div><p>이제 트리는 높이가 1 증가했으며, 모든 노드가 B 트리 속성을 만족.</p></li><li><p>키 값 60 삽입하기</p><ol><li>루트 노드 [40]에서 60은 40보다 크므로, 오른쪽 자식 노드 [50, 70]으로 이동한다.</li><li>[50, 70] 노드에서 60은 50보다 크고 70보다 작으므로, 50과 70 사이에 삽입한다.</li><li>삽입 후 노드는 [50, 60, 70]이 된다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>      [40]
</span></span><span class=line><span class=cl>     /    \
</span></span><span class=line><span class=cl>[20, 30]  [50, 60, 70]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 10 삽입하기</p><ol><li>루트 노드 [40]에서 10은 40보다 작으므로, 왼쪽 자식 노드 [20, 30]으로 이동한다.</li><li>[20, 30] 노드에서 10은 20보다 작으므로, 10을 맨 앞에 삽입한다.</li><li>삽입 후 노드는 [10, 20, 30]이 된다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [40]
</span></span><span class=line><span class=cl>       /    \
</span></span><span class=line><span class=cl>[10, 20, 30]  [50, 60, 70]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 80 삽입하기</p><ol><li>루트 노드 [40]에서 80은 40보다 크므로, 오른쪽 자식 노드 [50, 60, 70]으로 이동한다.</li><li>[50, 60, 70] 노드에서 80은 70보다 크므로, 80을 맨 끝에 삽입한다.</li><li>삽입 후 노드는 [50, 60, 70, 80]이 된다.</li><li>노드는 이제 최대 키 개수(4개)에 도달함.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [40]
</span></span><span class=line><span class=cl>       /    \
</span></span><span class=line><span class=cl>[10, 20, 30]  [50, 60, 70, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 75 삽입하기 (두 번째 분할 발생)<br>키 값 75를 삽입하려고 하지만, 오른쪽 자식 노드는 이미 최대 키 개수(4개)를 가지고 있다.<br>따라서 노드 분할이 필요하다.</p><ol><li>[50, 60, 70, 80] 노드에 75를 삽입하려고 하면, 정렬된 배열은 [50, 60, 70, 75, 80]이 된다.<br>그러나 이는 최대 키 개수를 초과한다.</li><li>노드 분할 과정:<ul><li>중간 키(70)를 부모 노드로 올린다.</li><li>왼쪽 노드에는 [50, 60], 오른쪽 노드에는 [75, 80]이 위치한다.</li><li>부모 노드 [40]은 [40, 70]이 된다.<br>결과 트리:</li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [40, 70]
</span></span><span class=line><span class=cl>       /    |    \
</span></span><span class=line><span class=cl>[10, 20, 30]  [50, 60]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 15 삽입하기</p><ol><li>루트 노드 [40, 70]에서 15는 40보다 작으므로, 첫 번째 자식 노드 [10, 20, 30]으로 이동한다.</li><li>[10, 20, 30] 노드에서 15는 10보다 크고 20보다 작으므로, 10과 20 사이에 삽입한다.</li><li>삽입 후 노드는 [10, 15, 20, 30]이 된다.</li><li>노드는 이제 최대 키 개수(4개)에 도달함.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [40, 70]
</span></span><span class=line><span class=cl>       /    |    \
</span></span><span class=line><span class=cl>[10, 15, 20, 30]  [50, 60]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 5 삽입하기 (세 번째 분할 발생)<br>키 값 5를 삽입하려고 하지만, 왼쪽 자식 노드는 이미 최대 키 개수(4개)를 가지고 있다.<br>따라서 노드 분할이 필요하다.</p><ol><li>[10, 15, 20, 30] 노드에 5를 삽입하려고 하면, 정렬된 배열은 [5, 10, 15, 20, 30]이 된다. 그러나 이는 최대 키 개수를 초과한다.</li><li>노드 분할 과정:<ul><li>중간 키(15)를 부모 노드로 올린다.</li><li>왼쪽 노드에는 [5, 10], 오른쪽 노드에는 [20, 30]이 위치한다.</li><li>부모 노드 [40, 70]은 [15, 40, 70]이 된다.<br>결과 트리:</li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 70]
</span></span><span class=line><span class=cl>       /    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 30]  [50, 60]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 55 삽입하기</p><ol><li>루트 노드 [15, 40, 70]에서 55는 40보다 크고 70보다 작으므로, 세 번째 자식 노드 [50, 60]으로 이동한다.</li><li>[50, 60] 노드에서 55는 50보다 크고 60보다 작으므로, 50과 60 사이에 삽입한다.</li><li>삽입 후 노드는 [50, 55, 60]이 된다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 70]
</span></span><span class=line><span class=cl>       /    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 30]  [50, 55, 60]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 45 삽입하기</p><ol><li>루트 노드 [15, 40, 70]에서 45는 40보다 크고 70보다 작으므로, 세 번째 자식 노드 [50, 55, 60]으로 이동한다.</li><li>[50, 55, 60] 노드에서 45는 모든 키보다 작으므로, 45를 맨 앞에 삽입한다.</li><li>삽입 후 노드는 [45, 50, 55, 60]이 된다.</li><li>노드는 이제 최대 키 개수(4개)에 도달함.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 70]
</span></span><span class=line><span class=cl>       /    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 30]  [45, 50, 55, 60]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 65 삽입하기 (네 번째 분할 발생)<br>키 값 65를 삽입하려고 하지만, 세 번째 자식 노드는 이미 최대 키 개수(4개)를 가지고 있다.<br>따라서 노드 분할이 필요하다.</p><ol><li>[45, 50, 55, 60] 노드에 65를 삽입하려고 하면, 정렬된 배열은 [45, 50, 55, 60, 65]가 된다. 그러나 이는 최대 키 개수를 초과한다.</li><li>노드 분할 과정:<ul><li>중간 키(55)를 부모 노드로 올린다.</li><li>왼쪽 노드에는 [45, 50], 오른쪽 노드에는 [60, 65]가 위치한다.</li><li>부모 노드 [15, 40, 70]은 [15, 40, 55, 70]이 된다.<br>결과 트리:</li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 55, 70]
</span></span><span class=line><span class=cl>       /    |    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 30]  [45, 50]  [60, 65]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 35 삽입하기 (다섯 번째 분할과 루트 분할 발생)<br>먼저 삽입 위치를 찾아야 한다.</p><ol><li>루트 노드 [15, 40, 55, 70]에서 35는 15보다 크고 40보다 작으므로, 두 번째 자식 노드 [20, 30]으로 이동한다.</li><li>[20, 30] 노드에서 35는 30보다 크므로, 35를 맨 끝에 삽입한다.</li><li>삽입 후 노드는 [20, 30, 35]이 된다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 55, 70]
</span></span><span class=line><span class=cl>       /    |    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 30, 35]  [45, 50]  [60, 65]  [75, 80]
</span></span></code></pre></td></tr></table></div></div><p>그러나 루트 노드가 이미 최대 키 개수(4개)에 도달했으므로, 새로운 키가 루트 노드에 삽입되어야 할 경우 루트 분할이 필요하다.</p></li><li><p>키 값 42 삽입하기 (루트 분할 발생)</p><ol><li>루트 노드 [15, 40, 55, 70]에서 42는 40보다 크고 55보다 작으므로, 세 번째 자식 노드 [45, 50]으로 이동한다.</li><li>[45, 50] 노드에서 42는 모든 키보다 작으므로, 42를 맨 앞에 삽입한다.</li><li>삽입 후 노드는 [42, 45, 50]이 된다.</li><li>노드는 최대 4개의 키를 가질 수 있으므로, 오버플로우가 발생하지 않는다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 55, 70]
</span></span><span class=line><span class=cl>       /    |    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 30, 35]  [42, 45, 50]  [60, 65]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 25 삽입하기 (루트 분할 발생)</p><ol><li>루트 노드 [15, 40, 55, 70]에서 25는 15보다 크고 40보다 작으므로, 두 번째 자식 노드 [20, 30, 35]으로 이동한다.</li><li>[20, 30, 35] 노드에서 25는 20보다 크고 30보다 작으므로, 20과 30 사이에 삽입한다.</li><li>삽입 후 노드는 [20, 25, 30, 35]가 되어 최대 키 개수에 도달한다.<br>결과 트리:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        [15, 40, 55, 70]
</span></span><span class=line><span class=cl>       /    |    |    |    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 25, 30, 35]  [42, 45, 50]  [60, 65]  [75, 80]
</span></span></code></pre></td></tr></table></div></div></li><li><p>키 값 23 삽입하기 (자식 노드 분할 및 루트 분할 발생)<br>키 값 23을 삽입하려고 하지만, 두 번째 자식 노드는 이미 최대 키 개수에 도달함.<br>따라서 노드 분할이 필요하다.</p><ol><li>[20, 25, 30, 35] 노드에 23을 삽입하려고 하면, 정렬된 배열은 [20, 23, 25, 30, 35]가 된다. 이는 최대 키 개수를 초과한다.</li><li>노드 분할 과정:<ul><li>중간 키(25)를 부모 노드로 올린다.</li><li>왼쪽 노드에는 [20, 23], 오른쪽 노드에는 [30, 35]가 위치한다.</li><li>부모 노드 [15, 40, 55, 70]에 25를 삽입하면 [15, 25, 40, 55, 70]이 된다. 그러나 이는 최대 키 개수를 초과한다.</li></ul></li><li>루트 노드 분할 과정:<ul><li>중간 키(40)를 새로운 루트로 선택한다.</li><li>왼쪽 노드에는 [15, 25], 오른쪽 노드에는 [55, 70]이 위치한다.<br>결과 트리:</li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3>3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4>4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [40]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 25]     [55, 70]
</span></span><span class=line><span class=cl>       /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [42, 45, 50]  [60, 65]  [75, 80]
</span></span></code></pre></td></tr></table></div></div><p>이 예시에서는 두 번의 분할이 발생했다.<br>먼저 자식 노드가 분할되었고, 그 결과로 루트 노드도 분할되어 트리의 높이가 증가했다.</p></li></ol><h4 id=삭제-연산>삭제 연산<a hidden class=anchor aria-hidden=true href=#삭제-연산>#</a></h4><p>B 트리에서 삭제 연산은 트리의 균형을 유지하기 위해 종종 복잡한 재구성이 필요하다.<br>키 삭제 후 트리의 모든 노드(루트 제외)가 최소 키 개수(m/2 올림 - 1, 여기서는 2개)를 유지해야 하므로, 단순한 키 이동만으로는 해결되지 않을 때가 많다.<br>이런 경우 트리 전체의 균형을 다시 맞추기 위해 여러 노드의 키를 재분배하거나 노드 병합, 분할 등의 작업이 수행된다.</p><p>B 트리에서 키를 삭제하는 과정을 요약하면 다음과 같다:</p><ol><li>삭제할 키를 찾는다.</li><li><strong>리프 노드에서 키 삭제</strong>: 키가 리프 노드에 있으면 직접 삭제한다.</li><li><strong>내부 노드에서 키 삭제</strong>: 키가 내부 노드에 있으면 선행자나 후행자로 대체한 후, 그 키를 리프 노드에서 삭제한다.</li><li><strong>키 부족 상황 해결</strong>:<ul><li>형제 노드에서 키를 빌리거나(재분배)</li><li>부모 노드의 키와 함께 형제 노드와 병합한다.</li></ul></li><li><strong>트리 높이 감소</strong>: 루트 노드가 비어 있고 단 하나의 자식만 있는 경우, 그 자식을 새로운 루트로 승격시킨다.</li><li>필요한 경우 병합이 루트까지 전파될 수 있다.</li></ol><h5 id=특징-2>특징<a hidden class=anchor aria-hidden=true href=#특징-2>#</a></h5><ol><li><strong>복잡한 케이스 처리</strong>: 삭제는 여러 경우(리프 vs 내부, 최소 키 개수 등)를 고려해야 한다.</li><li><strong>하향식 접근</strong>: 삭제는 루트에서 리프로 내려가면서 최소 키 조건을 미리 만족시킨다.</li><li><strong>키 재분배</strong>: 형제 노드에서 키를 빌려오는 방식으로 최소 키 개수 요구사항을 유지한다.</li><li><strong>노드 병합</strong>: 형제 노드에서 키를 빌려올 수 없는 경우, 부모 노드의 키와 함께 노드를 병합한다.</li><li><strong>키 대체</strong>: 내부 노드에서 키를 삭제할 때는 선행자나 후행자로 대체한다.</li><li><strong>병합 전파</strong>: 노드 병합은 트리 위로 전파될 수 있으며, 경우에 따라 트리 높이가 감소한다.</li><li><strong>균형 유지</strong>: 삭제 과정에서도 B 트리의 균형 속성이 유지된다.</li><li><strong>트리 높이 감소</strong>: 루트 노드가 비어있게 되면 트리의 높이가 감소합니다.</li></ol><h5 id=구현-예시-2>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시-2>#</a></h5><p>실제 B 트리의 삭제 구현은 복잡하므로, 핵심 부분에 대한 의사 코드:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>  1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>  2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>  3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>  4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>  5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6>  6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7>  7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8>  8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9>  9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10> 10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11> 11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12> 12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13> 13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14> 14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15> 15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16> 16</a>
</span><span class=lnt id=hl-23-17><a class=lnlinks href=#hl-23-17> 17</a>
</span><span class=lnt id=hl-23-18><a class=lnlinks href=#hl-23-18> 18</a>
</span><span class=lnt id=hl-23-19><a class=lnlinks href=#hl-23-19> 19</a>
</span><span class=lnt id=hl-23-20><a class=lnlinks href=#hl-23-20> 20</a>
</span><span class=lnt id=hl-23-21><a class=lnlinks href=#hl-23-21> 21</a>
</span><span class=lnt id=hl-23-22><a class=lnlinks href=#hl-23-22> 22</a>
</span><span class=lnt id=hl-23-23><a class=lnlinks href=#hl-23-23> 23</a>
</span><span class=lnt id=hl-23-24><a class=lnlinks href=#hl-23-24> 24</a>
</span><span class=lnt id=hl-23-25><a class=lnlinks href=#hl-23-25> 25</a>
</span><span class=lnt id=hl-23-26><a class=lnlinks href=#hl-23-26> 26</a>
</span><span class=lnt id=hl-23-27><a class=lnlinks href=#hl-23-27> 27</a>
</span><span class=lnt id=hl-23-28><a class=lnlinks href=#hl-23-28> 28</a>
</span><span class=lnt id=hl-23-29><a class=lnlinks href=#hl-23-29> 29</a>
</span><span class=lnt id=hl-23-30><a class=lnlinks href=#hl-23-30> 30</a>
</span><span class=lnt id=hl-23-31><a class=lnlinks href=#hl-23-31> 31</a>
</span><span class=lnt id=hl-23-32><a class=lnlinks href=#hl-23-32> 32</a>
</span><span class=lnt id=hl-23-33><a class=lnlinks href=#hl-23-33> 33</a>
</span><span class=lnt id=hl-23-34><a class=lnlinks href=#hl-23-34> 34</a>
</span><span class=lnt id=hl-23-35><a class=lnlinks href=#hl-23-35> 35</a>
</span><span class=lnt id=hl-23-36><a class=lnlinks href=#hl-23-36> 36</a>
</span><span class=lnt id=hl-23-37><a class=lnlinks href=#hl-23-37> 37</a>
</span><span class=lnt id=hl-23-38><a class=lnlinks href=#hl-23-38> 38</a>
</span><span class=lnt id=hl-23-39><a class=lnlinks href=#hl-23-39> 39</a>
</span><span class=lnt id=hl-23-40><a class=lnlinks href=#hl-23-40> 40</a>
</span><span class=lnt id=hl-23-41><a class=lnlinks href=#hl-23-41> 41</a>
</span><span class=lnt id=hl-23-42><a class=lnlinks href=#hl-23-42> 42</a>
</span><span class=lnt id=hl-23-43><a class=lnlinks href=#hl-23-43> 43</a>
</span><span class=lnt id=hl-23-44><a class=lnlinks href=#hl-23-44> 44</a>
</span><span class=lnt id=hl-23-45><a class=lnlinks href=#hl-23-45> 45</a>
</span><span class=lnt id=hl-23-46><a class=lnlinks href=#hl-23-46> 46</a>
</span><span class=lnt id=hl-23-47><a class=lnlinks href=#hl-23-47> 47</a>
</span><span class=lnt id=hl-23-48><a class=lnlinks href=#hl-23-48> 48</a>
</span><span class=lnt id=hl-23-49><a class=lnlinks href=#hl-23-49> 49</a>
</span><span class=lnt id=hl-23-50><a class=lnlinks href=#hl-23-50> 50</a>
</span><span class=lnt id=hl-23-51><a class=lnlinks href=#hl-23-51> 51</a>
</span><span class=lnt id=hl-23-52><a class=lnlinks href=#hl-23-52> 52</a>
</span><span class=lnt id=hl-23-53><a class=lnlinks href=#hl-23-53> 53</a>
</span><span class=lnt id=hl-23-54><a class=lnlinks href=#hl-23-54> 54</a>
</span><span class=lnt id=hl-23-55><a class=lnlinks href=#hl-23-55> 55</a>
</span><span class=lnt id=hl-23-56><a class=lnlinks href=#hl-23-56> 56</a>
</span><span class=lnt id=hl-23-57><a class=lnlinks href=#hl-23-57> 57</a>
</span><span class=lnt id=hl-23-58><a class=lnlinks href=#hl-23-58> 58</a>
</span><span class=lnt id=hl-23-59><a class=lnlinks href=#hl-23-59> 59</a>
</span><span class=lnt id=hl-23-60><a class=lnlinks href=#hl-23-60> 60</a>
</span><span class=lnt id=hl-23-61><a class=lnlinks href=#hl-23-61> 61</a>
</span><span class=lnt id=hl-23-62><a class=lnlinks href=#hl-23-62> 62</a>
</span><span class=lnt id=hl-23-63><a class=lnlinks href=#hl-23-63> 63</a>
</span><span class=lnt id=hl-23-64><a class=lnlinks href=#hl-23-64> 64</a>
</span><span class=lnt id=hl-23-65><a class=lnlinks href=#hl-23-65> 65</a>
</span><span class=lnt id=hl-23-66><a class=lnlinks href=#hl-23-66> 66</a>
</span><span class=lnt id=hl-23-67><a class=lnlinks href=#hl-23-67> 67</a>
</span><span class=lnt id=hl-23-68><a class=lnlinks href=#hl-23-68> 68</a>
</span><span class=lnt id=hl-23-69><a class=lnlinks href=#hl-23-69> 69</a>
</span><span class=lnt id=hl-23-70><a class=lnlinks href=#hl-23-70> 70</a>
</span><span class=lnt id=hl-23-71><a class=lnlinks href=#hl-23-71> 71</a>
</span><span class=lnt id=hl-23-72><a class=lnlinks href=#hl-23-72> 72</a>
</span><span class=lnt id=hl-23-73><a class=lnlinks href=#hl-23-73> 73</a>
</span><span class=lnt id=hl-23-74><a class=lnlinks href=#hl-23-74> 74</a>
</span><span class=lnt id=hl-23-75><a class=lnlinks href=#hl-23-75> 75</a>
</span><span class=lnt id=hl-23-76><a class=lnlinks href=#hl-23-76> 76</a>
</span><span class=lnt id=hl-23-77><a class=lnlinks href=#hl-23-77> 77</a>
</span><span class=lnt id=hl-23-78><a class=lnlinks href=#hl-23-78> 78</a>
</span><span class=lnt id=hl-23-79><a class=lnlinks href=#hl-23-79> 79</a>
</span><span class=lnt id=hl-23-80><a class=lnlinks href=#hl-23-80> 80</a>
</span><span class=lnt id=hl-23-81><a class=lnlinks href=#hl-23-81> 81</a>
</span><span class=lnt id=hl-23-82><a class=lnlinks href=#hl-23-82> 82</a>
</span><span class=lnt id=hl-23-83><a class=lnlinks href=#hl-23-83> 83</a>
</span><span class=lnt id=hl-23-84><a class=lnlinks href=#hl-23-84> 84</a>
</span><span class=lnt id=hl-23-85><a class=lnlinks href=#hl-23-85> 85</a>
</span><span class=lnt id=hl-23-86><a class=lnlinks href=#hl-23-86> 86</a>
</span><span class=lnt id=hl-23-87><a class=lnlinks href=#hl-23-87> 87</a>
</span><span class=lnt id=hl-23-88><a class=lnlinks href=#hl-23-88> 88</a>
</span><span class=lnt id=hl-23-89><a class=lnlinks href=#hl-23-89> 89</a>
</span><span class=lnt id=hl-23-90><a class=lnlinks href=#hl-23-90> 90</a>
</span><span class=lnt id=hl-23-91><a class=lnlinks href=#hl-23-91> 91</a>
</span><span class=lnt id=hl-23-92><a class=lnlinks href=#hl-23-92> 92</a>
</span><span class=lnt id=hl-23-93><a class=lnlinks href=#hl-23-93> 93</a>
</span><span class=lnt id=hl-23-94><a class=lnlinks href=#hl-23-94> 94</a>
</span><span class=lnt id=hl-23-95><a class=lnlinks href=#hl-23-95> 95</a>
</span><span class=lnt id=hl-23-96><a class=lnlinks href=#hl-23-96> 96</a>
</span><span class=lnt id=hl-23-97><a class=lnlinks href=#hl-23-97> 97</a>
</span><span class=lnt id=hl-23-98><a class=lnlinks href=#hl-23-98> 98</a>
</span><span class=lnt id=hl-23-99><a class=lnlinks href=#hl-23-99> 99</a>
</span><span class=lnt id=hl-23-100><a class=lnlinks href=#hl-23-100>100</a>
</span><span class=lnt id=hl-23-101><a class=lnlinks href=#hl-23-101>101</a>
</span><span class=lnt id=hl-23-102><a class=lnlinks href=#hl-23-102>102</a>
</span><span class=lnt id=hl-23-103><a class=lnlinks href=#hl-23-103>103</a>
</span><span class=lnt id=hl-23-104><a class=lnlinks href=#hl-23-104>104</a>
</span><span class=lnt id=hl-23-105><a class=lnlinks href=#hl-23-105>105</a>
</span><span class=lnt id=hl-23-106><a class=lnlinks href=#hl-23-106>106</a>
</span><span class=lnt id=hl-23-107><a class=lnlinks href=#hl-23-107>107</a>
</span><span class=lnt id=hl-23-108><a class=lnlinks href=#hl-23-108>108</a>
</span><span class=lnt id=hl-23-109><a class=lnlinks href=#hl-23-109>109</a>
</span><span class=lnt id=hl-23-110><a class=lnlinks href=#hl-23-110>110</a>
</span><span class=lnt id=hl-23-111><a class=lnlinks href=#hl-23-111>111</a>
</span><span class=lnt id=hl-23-112><a class=lnlinks href=#hl-23-112>112</a>
</span><span class=lnt id=hl-23-113><a class=lnlinks href=#hl-23-113>113</a>
</span><span class=lnt id=hl-23-114><a class=lnlinks href=#hl-23-114>114</a>
</span><span class=lnt id=hl-23-115><a class=lnlinks href=#hl-23-115>115</a>
</span><span class=lnt id=hl-23-116><a class=lnlinks href=#hl-23-116>116</a>
</span><span class=lnt id=hl-23-117><a class=lnlinks href=#hl-23-117>117</a>
</span><span class=lnt id=hl-23-118><a class=lnlinks href=#hl-23-118>118</a>
</span><span class=lnt id=hl-23-119><a class=lnlinks href=#hl-23-119>119</a>
</span><span class=lnt id=hl-23-120><a class=lnlinks href=#hl-23-120>120</a>
</span><span class=lnt id=hl-23-121><a class=lnlinks href=#hl-23-121>121</a>
</span><span class=lnt id=hl-23-122><a class=lnlinks href=#hl-23-122>122</a>
</span><span class=lnt id=hl-23-123><a class=lnlinks href=#hl-23-123>123</a>
</span><span class=lnt id=hl-23-124><a class=lnlinks href=#hl-23-124>124</a>
</span><span class=lnt id=hl-23-125><a class=lnlinks href=#hl-23-125>125</a>
</span><span class=lnt id=hl-23-126><a class=lnlinks href=#hl-23-126>126</a>
</span><span class=lnt id=hl-23-127><a class=lnlinks href=#hl-23-127>127</a>
</span><span class=lnt id=hl-23-128><a class=lnlinks href=#hl-23-128>128</a>
</span><span class=lnt id=hl-23-129><a class=lnlinks href=#hl-23-129>129</a>
</span><span class=lnt id=hl-23-130><a class=lnlinks href=#hl-23-130>130</a>
</span><span class=lnt id=hl-23-131><a class=lnlinks href=#hl-23-131>131</a>
</span><span class=lnt id=hl-23-132><a class=lnlinks href=#hl-23-132>132</a>
</span><span class=lnt id=hl-23-133><a class=lnlinks href=#hl-23-133>133</a>
</span><span class=lnt id=hl-23-134><a class=lnlinks href=#hl-23-134>134</a>
</span><span class=lnt id=hl-23-135><a class=lnlinks href=#hl-23-135>135</a>
</span><span class=lnt id=hl-23-136><a class=lnlinks href=#hl-23-136>136</a>
</span><span class=lnt id=hl-23-137><a class=lnlinks href=#hl-23-137>137</a>
</span><span class=lnt id=hl-23-138><a class=lnlinks href=#hl-23-138>138</a>
</span><span class=lnt id=hl-23-139><a class=lnlinks href=#hl-23-139>139</a>
</span><span class=lnt id=hl-23-140><a class=lnlinks href=#hl-23-140>140</a>
</span><span class=lnt id=hl-23-141><a class=lnlinks href=#hl-23-141>141</a>
</span><span class=lnt id=hl-23-142><a class=lnlinks href=#hl-23-142>142</a>
</span><span class=lnt id=hl-23-143><a class=lnlinks href=#hl-23-143>143</a>
</span><span class=lnt id=hl-23-144><a class=lnlinks href=#hl-23-144>144</a>
</span><span class=lnt id=hl-23-145><a class=lnlinks href=#hl-23-145>145</a>
</span><span class=lnt id=hl-23-146><a class=lnlinks href=#hl-23-146>146</a>
</span><span class=lnt id=hl-23-147><a class=lnlinks href=#hl-23-147>147</a>
</span><span class=lnt id=hl-23-148><a class=lnlinks href=#hl-23-148>148</a>
</span><span class=lnt id=hl-23-149><a class=lnlinks href=#hl-23-149>149</a>
</span><span class=lnt id=hl-23-150><a class=lnlinks href=#hl-23-150>150</a>
</span><span class=lnt id=hl-23-151><a class=lnlinks href=#hl-23-151>151</a>
</span><span class=lnt id=hl-23-152><a class=lnlinks href=#hl-23-152>152</a>
</span><span class=lnt id=hl-23-153><a class=lnlinks href=#hl-23-153>153</a>
</span><span class=lnt id=hl-23-154><a class=lnlinks href=#hl-23-154>154</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>leaf</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=n>t</span>  <span class=c1># 최소 차수</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>keys</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 키를 저장하는 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 자식 노드를 가리키는 포인터 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>leaf</span> <span class=o>=</span> <span class=n>leaf</span>  <span class=c1># 리프 노드 여부</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTree</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>t</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=n>t</span>  <span class=c1># 최소 차수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>delete</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키 삭제</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_delete_key</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 루트가 빈 내부 노드가 된 경우 높이 감소</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_delete_key</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 노드에서 키의 인덱스 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_find_key</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드에서 키를 찾은 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>==</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 리프 노드인 경우 직접 삭제</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_remove_from_leaf</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_remove_from_non_leaf</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 키가 현재 노드에 없는 경우</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;키 </span><span class=si>{</span><span class=n>k</span><span class=si>}</span><span class=s2>가 트리에 존재하지 않습니다.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 마지막 자식으로 내려갈지 결정</span>
</span></span><span class=line><span class=cl>            <span class=n>last_child</span> <span class=o>=</span> <span class=n>idx</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 자식이 최소 키 개수만 가지고 있는 경우 처리</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_fill</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 마지막 자식이 병합된 경우</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>last_child</span> <span class=ow>and</span> <span class=n>idx</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_delete_key</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_delete_key</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>],</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 리프 노드에서 키 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_remove_from_leaf</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 내부 노드에서 키 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_remove_from_non_leaf</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 자식에서 선행자 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>pred</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_predecessor</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>pred</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_delete_key</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>],</span> <span class=n>pred</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 자식에서 후행자 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>succ</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_successor</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>succ</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_delete_key</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=n>succ</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 두 자식 모두 최소 키 개수를 가진 경우 병합</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_merge</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_delete_key</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>],</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 선행자(predecessor) 찾기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_get_predecessor</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>curr</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=ow>not</span> <span class=n>curr</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>curr</span> <span class=o>=</span> <span class=n>curr</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>curr</span><span class=o>.</span><span class=n>keys</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>curr</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 후행자(successor) 찾기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_get_successor</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>curr</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=ow>not</span> <span class=n>curr</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>curr</span> <span class=o>=</span> <span class=n>curr</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>curr</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최소 키 개수보다 적은 노드를 채우기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_fill</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 형제에서 키 빌리기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>idx</span> <span class=o>!=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_borrow_from_prev</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 형제에서 키 빌리기</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>idx</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_borrow_from_next</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 병합</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>idx</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_merge</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_merge</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 형제에서 키 빌리기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_borrow_from_prev</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>sibling</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 자식 노드에 부모 키 추가하고, 부모 노드에 형제의 마지막 키 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>child</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>sibling</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>pop</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>sibling</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 형제에서 키 빌리기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_borrow_from_next</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>sibling</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 자식 노드에 부모 키 추가하고, 부모 노드에 형제의 첫 번째 키 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>child</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>sibling</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>sibling</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 노드 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_merge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>idx</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>sibling</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 부모 키를 자식에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 형제의 모든 키와 자식을 자식 노드로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>sibling</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>child</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>sibling</span><span class=o>.</span><span class=n>children</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 부모 노드에서 키와 자식 노드 제거</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>idx</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 노드에서 키의 인덱스 찾기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_find_key</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>idx</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>idx</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>idx</span>
</span></span></code></pre></td></tr></table></div></div><p>B 트리의 삭제 연산 시간 복잡도는 O(log_t n).<br>여기서:</p><ul><li>t는 B 트리의 최소 차수</li><li>n은 트리에 저장된 키의 총 개수</li></ul><h5 id=예시-2>예시<a hidden class=anchor aria-hidden=true href=#예시-2>#</a></h5><p>B 트리에서 키를 삭제하는 연산은 일반적으로 삽입보다 더 복잡하다.<br>삭제 시 B 트리의 속성을 유지하기 위해 여러 케이스를 처리해야 하기 때문이다.<br>차수 m=5인 B 트리를 사용하여 삭제 연산의 다양한 경우를 단계별 설명.</p><ul><li>먼저 차수가 5인 B 트리의 주요 속성을 확인:<ol><li><strong>최대 키 개수</strong>: m-1 = 5-1 = 4개</li><li><strong>최소 키 개수</strong>: ⌈m/2⌉-1 = ⌈5/2⌉-1 = 3-1 = 2개 (루트 노드 제외)</li><li><strong>최대 자식 수</strong>: m = 5개</li><li><strong>최소 자식 수</strong>: ⌈m/2⌉ = ⌈5/2⌉ = 3개 (루트 노드 제외)</li></ol></li><li>루트 노드의 경우:<ul><li>최소 키 개수: 1개 (트리에 노드가 1개만 있는 경우 0개도 가능)</li><li>최소 자식 수: 2개 (1개의 키를 가질 때)</li></ul></li></ul><h6 id=복잡한-재조정이-필요-없는-경우-85-삭제>복잡한 재조정이 필요 없는 경우 (85 삭제)<a hidden class=anchor aria-hidden=true href=#복잡한-재조정이-필요-없는-경우-85-삭제>#</a></h6><p>초기 상태:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [40]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 25]     [55, 70]
</span></span><span class=line><span class=cl>       /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [45, 50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>85를 삭제하는 과정에서 모든 B 트리 속성을 유지하는 해결책:</p><ol><li>[75, 80, 85, 90]에서 85를 삭제하면 [75, 80, 90]이 되어 여전히 최소 키 개수(2개)를 충족.</li><li>따라서 추가적인 재조정 없이 트리가 유효하다.</li></ol><p>결과:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3>3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4>4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [40]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 25]     [55, 70]
</span></span><span class=line><span class=cl>       /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [45, 50]  [60, 65]  [75, 80, 90]
</span></span></code></pre></td></tr></table></div></div><h6 id=리프-노드에서-삭제---복잡한-재구성이-필요한-경우-10-삭제>리프 노드에서 삭제 - 복잡한 재구성이 필요한 경우 (10 삭제)<a hidden class=anchor aria-hidden=true href=#리프-노드에서-삭제---복잡한-재구성이-필요한-경우-10-삭제>#</a></h6><p>초기 상태:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[40]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[15, 25]     [55, 70]
</span></span><span class=line><span class=cl>	   /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [45, 50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>10을 삭제하면 복잡한 재구성이 필요하다.<br>차수 m=5인 B 트리에서는 모든 내부 노드(루트 제외)가 최소 2개의 키를 가져야 하므로:</p><ol><li>우선 [5, 10]에서 10을 삭제하면 [5]만 남는다.</li><li>이 문제를 해결하기 위해 전체 트리를 재구성해야 한다.<br>가장 효과적인 방법은 트리의 높이를 유지하면서 모든 노드들 사이에 키를 균등하게 재분배하는 것이다:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2>2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3>3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4>4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[35]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[15, 25]     [55, 75]
</span></span><span class=line><span class=cl>	   /    |    \    /    |    \
</span></span><span class=line><span class=cl>   [5]  [20, 23]  [30]  [40, 45, 50]  [60, 65, 70]  [80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>하지만 여기서도 [5]와 [30] 리프 노드가 최소 키 개수를 위반한다.<br>더 균형 잡힌 트리를 위해:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3>3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4>4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[45]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[20, 35]     [65, 80]
</span></span><span class=line><span class=cl>	   /    |    \    /    |    \
</span></span><span class=line><span class=cl>  [5, 15] [23, 25, 30] [40] [50, 55, 60] [70, 75] [85, 90]
</span></span></code></pre></td></tr></table></div></div><p>여기서도 [40] 리프 노드가 최소 키 개수를 위반한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1>1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2>2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3>3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4>4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[45]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[20, 35]     [70]
</span></span><span class=line><span class=cl>	   /    |    \    /  \
</span></span><span class=line><span class=cl>  [5, 15] [23, 25, 30] [40] [50, 55, 60, 65] [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>이 구조에서도 아직 [40] 리프 노드가 최소 키 개수를 위반한다:<br>최종 해결책:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2>2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3>3</a>
</span><span class=lnt id=hl-30-4><a class=lnlinks href=#hl-30-4>4</a>
</span><span class=lnt id=hl-30-5><a class=lnlinks href=#hl-30-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[45]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[20, 30]     [65, 80]
</span></span><span class=line><span class=cl>	   /    |    \    /    |    \
</span></span><span class=line><span class=cl>  [5, 15] [23, 25] [35, 40] [50, 55, 60] [70, 75] [85, 90]
</span></span></code></pre></td></tr></table></div></div><p>이제 모든 내부 노드와 리프 노드가 최소 2개의 키를 가져 B 트리의 요구사항을 충족한다.</p><h6 id=리프-노드에서-삭제---병합-필요한-경우-60-삭제>리프 노드에서 삭제 - 병합 필요한 경우 (60 삭제)<a hidden class=anchor aria-hidden=true href=#리프-노드에서-삭제---병합-필요한-경우-60-삭제>#</a></h6><p>초기 상태:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span><span class=lnt id=hl-31-4><a class=lnlinks href=#hl-31-4>4</a>
</span><span class=lnt id=hl-31-5><a class=lnlinks href=#hl-31-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[40]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[15, 25]     [55, 70]
</span></span><span class=line><span class=cl>	   /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [45, 50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><ol><li>[60, 65]에서 60을 삭제하면 [65]만 남는다.</li><li>전체 트리를 재구성하여 모든 노드가 B 트리 요구사항을 충족하도록 한다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1>1</a>
</span><span class=lnt id=hl-32-2><a class=lnlinks href=#hl-32-2>2</a>
</span><span class=lnt id=hl-32-3><a class=lnlinks href=#hl-32-3>3</a>
</span><span class=lnt id=hl-32-4><a class=lnlinks href=#hl-32-4>4</a>
</span><span class=lnt id=hl-32-5><a class=lnlinks href=#hl-32-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[40]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[15, 25]     [65]
</span></span><span class=line><span class=cl>	   /    |    \    /  \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35, 55]  [45, 50, 60]  [70, 75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>하지만 이 구조에서는 내부 노드 [65]가 최소 키 개수를 위반한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1>1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2>2</a>
</span><span class=lnt id=hl-33-3><a class=lnlinks href=#hl-33-3>3</a>
</span><span class=lnt id=hl-33-4><a class=lnlinks href=#hl-33-4>4</a>
</span><span class=lnt id=hl-33-5><a class=lnlinks href=#hl-33-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[40, 65]
</span></span><span class=line><span class=cl>			  /    |    \
</span></span><span class=line><span class=cl>		[15, 25]  [50, 55]  [80]
</span></span><span class=line><span class=cl>	   /    |    \  /   \   /  \
</span></span><span class=line><span class=cl>   [5, 10] [20, 23] [30, 35, 45] [70, 75] [85, 90]
</span></span></code></pre></td></tr></table></div></div><p>이 구조에서도 내부 노드 [80]이 최소 키 개수를 위반한다:</p><p>최종 해결책:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span><span class=lnt id=hl-34-3><a class=lnlinks href=#hl-34-3>3</a>
</span><span class=lnt id=hl-34-4><a class=lnlinks href=#hl-34-4>4</a>
</span><span class=lnt id=hl-34-5><a class=lnlinks href=#hl-34-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>				[40]
</span></span><span class=line><span class=cl>			  /      \
</span></span><span class=line><span class=cl>		[15, 25]     [65, 80]
</span></span><span class=line><span class=cl>	   /    |    \    /    |    \
</span></span><span class=line><span class=cl>  [5, 10] [20, 23] [30, 35] [45, 50, 55] [70, 75] [85, 90]
</span></span></code></pre></td></tr></table></div></div><h6 id=내부-노드에서-삭제---후계자-대체-25-삭제>내부 노드에서 삭제 - 후계자 대체 (25 삭제)<a hidden class=anchor aria-hidden=true href=#내부-노드에서-삭제---후계자-대체-25-삭제>#</a></h6><p>초기 상태:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span><span class=lnt id=hl-35-2><a class=lnlinks href=#hl-35-2>2</a>
</span><span class=lnt id=hl-35-3><a class=lnlinks href=#hl-35-3>3</a>
</span><span class=lnt id=hl-35-4><a class=lnlinks href=#hl-35-4>4</a>
</span><span class=lnt id=hl-35-5><a class=lnlinks href=#hl-35-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [40]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 25]     [55, 70]
</span></span><span class=line><span class=cl>       /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [45, 50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>25를 삭제하는 과정을 처음부터 다시 살펴보면:</p><ol><li>25는 내부 노드에 있으므로, 후계자로 대체해야 한다.<br>25의 후계자는 오른쪽 서브트리의 가장 작은 키인 30이다.</li><li>30을 25 위치로 이동시키고, [30, 35]에서 30을 삭제한다.</li><li>이로 인해 [35]만 남게 되어 최소 키 개수를 위반한다.<br>이 문제를 해결하기 위한 완전한 재구성을 진행해보면:</li></ol><ul><li><p>방법1: 키 재분배를 통한 해결</p><ul><li>가장 가까운 형제 노드인 [45, 50]에서 키를 빌려올 수 있다:<ol><li>부모 키 40을 [35] 노드로 내리고, [45, 50]의 키 45를 부모로 올린다.</li><li>결과적으로 [35, 40]과 [50] 노드가 된다.</li><li>그러나 [50] 노드도 최소 키 개수를 위반하므로 또 다른 조정이 필요하다.</li></ol></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1>1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2>2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3>3</a>
</span><span class=lnt id=hl-36-4><a class=lnlinks href=#hl-36-4>4</a>
</span><span class=lnt id=hl-36-5><a class=lnlinks href=#hl-36-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [45]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 30]     [55, 70]
</span></span><span class=line><span class=cl>       /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [35,40]  [50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div></li><li><p>방법 2: 노드 병합을 통한 해결</p><ul><li>[35]와 [45, 50] 노드를 병합하고 부모 키 40을 가져온다:<ol><li>결과는 [35, 40, 45, 50] 노드가 된다.</li><li>부모 노드는 이제 [15, 30, 55, 70]이 된다.</li></ol></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1>1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2>2</a>
</span><span class=lnt id=hl-37-3><a class=lnlinks href=#hl-37-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [15, 30, 55, 70]
</span></span><span class=line><span class=cl>               /    |    |    \
</span></span><span class=line><span class=cl>      [5, 10]  [20, 23]  [35, 40, 45, 50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>이 구조에서도 문제가 없는지 확인해보면:</p><ul><li>루트 노드 [15, 30, 55, 70]은 최대 키 개수(4개)를 충족한다.</li><li>모든 리프 노드는 최소 키 개수(2개)를 충족한다.</li><li>하지만 트리의 높이가 감소했다.</li></ul></li><li><p>방법 3: 균형 잡힌 트리를 위한 완전한 재구성<br>좀 더 균형 잡힌 구조를 만들기 위해 전체 트리를 재구성한다:</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-38-1><a class=lnlinks href=#hl-38-1>1</a>
</span><span class=lnt id=hl-38-2><a class=lnlinks href=#hl-38-2>2</a>
</span><span class=lnt id=hl-38-3><a class=lnlinks href=#hl-38-3>3</a>
</span><span class=lnt id=hl-38-4><a class=lnlinks href=#hl-38-4>4</a>
</span><span class=lnt id=hl-38-5><a class=lnlinks href=#hl-38-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [45]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 30]     [65, 80]
</span></span><span class=line><span class=cl>       /    |    \    /    |    \
</span></span><span class=line><span class=cl>  [5, 10] [20, 23] [35, 40] [50, 55, 60] [70, 75] [85, 90]
</span></span></code></pre></td></tr></table></div></div><h6 id=루트-노드가-비어지는-경우-40-삭제>루트 노드가 비어지는 경우 (40 삭제)<a hidden class=anchor aria-hidden=true href=#루트-노드가-비어지는-경우-40-삭제>#</a></h6><p>초기 상태:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-39-1><a class=lnlinks href=#hl-39-1>1</a>
</span><span class=lnt id=hl-39-2><a class=lnlinks href=#hl-39-2>2</a>
</span><span class=lnt id=hl-39-3><a class=lnlinks href=#hl-39-3>3</a>
</span><span class=lnt id=hl-39-4><a class=lnlinks href=#hl-39-4>4</a>
</span><span class=lnt id=hl-39-5><a class=lnlinks href=#hl-39-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [40]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 25]     [55, 70]
</span></span><span class=line><span class=cl>       /    |    \    /    \
</span></span><span class=line><span class=cl>   [5, 10]  [20, 23]  [30, 35]  [45, 50]  [60, 65]  [75, 80, 85, 90]
</span></span></code></pre></td></tr></table></div></div><p>40을 삭제하는 과정에서 모든 B 트리 속성을 유지하는 해결책:</p><ol><li>40의 후계자인 45를 찾아 40 위치에 대체한다.</li><li>[45, 50]에서 45를 삭제하면 [50]만 남아 최소 키 개수를 위반한다.</li><li>트리 전체를 재구성한다.</li></ol><p>균형 잡힌 해결책:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-40-1><a class=lnlinks href=#hl-40-1>1</a>
</span><span class=lnt id=hl-40-2><a class=lnlinks href=#hl-40-2>2</a>
</span><span class=lnt id=hl-40-3><a class=lnlinks href=#hl-40-3>3</a>
</span><span class=lnt id=hl-40-4><a class=lnlinks href=#hl-40-4>4</a>
</span><span class=lnt id=hl-40-5><a class=lnlinks href=#hl-40-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [45]
</span></span><span class=line><span class=cl>              /      \
</span></span><span class=line><span class=cl>        [15, 25]     [65, 80]
</span></span><span class=line><span class=cl>       /    |    \    /    |    \
</span></span><span class=line><span class=cl>  [5, 10] [20, 23] [30, 35] [50, 55, 60] [70, 75] [85, 90]
</span></span></code></pre></td></tr></table></div></div><h3 id=b-트리의-변형>B 트리의 변형<a hidden class=anchor aria-hidden=true href=#b-트리의-변형>#</a></h3><h4 id=b-트리>B+ 트리<a hidden class=anchor aria-hidden=true href=#b-트리>#</a></h4><p>B+ 트리는 B 트리의 변형으로, 모든 키가 리프 노드에 저장되고 리프 노드들이 연결 리스트로 연결된 구조.<br>이러한 특성으로 인해 범위 검색에 더 효율적이다.</p><p>주요 특징:</p><ul><li>모든 데이터는 리프 노드에만 저장된다.</li><li>내부 노드는 인덱스 역할만 한다.</li><li>리프 노드들이 연결 리스트로 연결되어 있어 순차적 접근이 용이하다.</li><li>데이터베이스 인덱싱에 널리 사용된다.</li></ul><h4 id=b-트리-1>B* 트리<a hidden class=anchor aria-hidden=true href=#b-트리-1>#</a></h4><p>B* 트리는 노드 분할을 최소화하기 위해 노드 사용률을 더 높게 유지하는 B 트리의 변형이다.</p><p>주요 특징:</p><ul><li>노드는 최소 2/3 이상 채워져 있어야 한다(일반 B 트리는 1/2).</li><li>노드가 가득 차면, 이웃 노드에 여유 공간이 있을 경우 재분배를 먼저 시도한다.</li><li>두 노드가 모두 가득 차면 세 개의 노드로 분할한다.</li></ul><h4 id=r-트리>R 트리<a hidden class=anchor aria-hidden=true href=#r-트리>#</a></h4><p>R 트리는 다차원 공간 데이터(예: 지리적 좌표)를 저장하기 위한 B 트리의 확장이다.</p><p>주요 특징:</p><ul><li>점이 아닌 사각형(또는 다차원 객체)을 저장한다.</li><li>각 노드는 최소 경계 사각형(Minimum Bounding Rectangle, MBR)을 가진다.</li><li>지리 정보 시스템(GIS)과 공간 데이터베이스에 사용된다.</li></ul><h3 id=b-트리의-성능-분석>B 트리의 성능 분석<a hidden class=anchor aria-hidden=true href=#b-트리의-성능-분석>#</a></h3><ol><li><p>시간 복잡도<br>B 트리의 주요 연산에 대한 시간 복잡도는 다음과 같다:</p><ul><li><strong>검색</strong>: O(log_m n) - 트리의 높이에 비례</li><li><strong>삽입</strong>: O(log_m n) - 키 위치 찾기와 노드 분할 포함</li><li><strong>삭제</strong>: O(log_m n) - 키 위치 찾기와 노드 병합/재분배 포함</li><li><strong>순차 접근</strong>: O(n) - 모든 키를 순서대로 방문<br>여기서 m은 B 트리의 차수, n은 저장된 키의 총 개수.</li></ul></li><li><p>공간 복잡도<br>B 트리의 공간 복잡도는 O(n).<br>그러나 B 트리는 일반적인 이진 검색 트리보다 공간 효율성이 좋다.<br>이는 B 트리가 더 높은 분기 계수를 가져 더 적은 노드와 포인터를 사용하기 때문.</p></li><li><p>디스크 I/O 효율성<br>B 트리의 주요 장점 중 하나는 디스크 기반 저장 시스템에서의 효율성:</p><ul><li><strong>블록 접근</strong>: 노드 크기를 디스크 블록 크기에 맞춰 I/O 연산을 최소화.</li><li><strong>높이 최소화</strong>: 높은 분기 계수로 트리 높이를 낮게 유지하여 검색 시 필요한 디스크 액세스 횟수를 줄인다.</li><li><strong>지역성</strong>: 관련 키들이 같은 노드에 저장되어 캐시 효율성이 향상된다.</li></ul></li></ol><h3 id=b-트리의-응용>B 트리의 응용<a hidden class=anchor aria-hidden=true href=#b-트리의-응용>#</a></h3><ol><li><p>데이터베이스 시스템<br>B 트리와 그 변형(특히 B+ 트리)은 거의 모든 관계형 데이터베이스 관리 시스템(RDBMS)의 인덱싱 메커니즘으로 사용된다:</p><ul><li><strong>MySQL</strong>: InnoDB 스토리지 엔진은 B+ 트리 인덱스를 사용.</li><li><strong>PostgreSQL</strong>: B 트리 기반 인덱스를 기본으로 제공.</li><li><strong>Oracle</strong>: B+ 트리 인덱스를 사용.</li><li><strong>SQLite</strong>: B 트리 변형인 B* 트리를 사용.</li></ul></li><li><p>파일 시스템<br>많은 현대 파일 시스템이 B 트리 또는 그 변형을 사용하여 파일과 디렉토리 구조를 관리한다:</p><ul><li><strong>NTFS</strong>: B+ 트리를 사용하여 Master File Table(MFT)을 구현.</li><li><strong>ext4</strong>: B+ 트리를 사용하여 디렉토리 인덱싱을 구현.</li><li><strong>HFS+</strong>: B 트리를 사용하여 파일 카탈로그를 관리.</li><li><strong>Btrfs</strong>: B 트리 파일 시스템으로, 이름 자체가 B 트리에서 유래.</li></ul></li><li><p>기타 응용 분야</p><ul><li><strong>검색 엔진</strong>: 역색인(inverted index)을 구현하는 데 사용된다.</li><li><strong>네트워크 라우팅</strong>: IP 주소를 빠르게 조회하는 데 사용된다.</li><li><strong>공간 데이터베이스</strong>: R 트리를 사용하여 공간 데이터를 효율적으로 인덱싱한다.</li><li><strong>메모리 관리</strong>: 일부 시스템에서는 메모리 할당을 관리하는 데 B 트리를 사용한다.</li></ul></li></ol><h3 id=b-트리-구현-예시>B 트리 구현 예시<a hidden class=anchor aria-hidden=true href=#b-트리-구현-예시>#</a></h3><p>다음은 Python으로 B 트리의 기본 구조와 연산을 구현한 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-41-1><a class=lnlinks href=#hl-41-1> 1</a>
</span><span class=lnt id=hl-41-2><a class=lnlinks href=#hl-41-2> 2</a>
</span><span class=lnt id=hl-41-3><a class=lnlinks href=#hl-41-3> 3</a>
</span><span class=lnt id=hl-41-4><a class=lnlinks href=#hl-41-4> 4</a>
</span><span class=lnt id=hl-41-5><a class=lnlinks href=#hl-41-5> 5</a>
</span><span class=lnt id=hl-41-6><a class=lnlinks href=#hl-41-6> 6</a>
</span><span class=lnt id=hl-41-7><a class=lnlinks href=#hl-41-7> 7</a>
</span><span class=lnt id=hl-41-8><a class=lnlinks href=#hl-41-8> 8</a>
</span><span class=lnt id=hl-41-9><a class=lnlinks href=#hl-41-9> 9</a>
</span><span class=lnt id=hl-41-10><a class=lnlinks href=#hl-41-10>10</a>
</span><span class=lnt id=hl-41-11><a class=lnlinks href=#hl-41-11>11</a>
</span><span class=lnt id=hl-41-12><a class=lnlinks href=#hl-41-12>12</a>
</span><span class=lnt id=hl-41-13><a class=lnlinks href=#hl-41-13>13</a>
</span><span class=lnt id=hl-41-14><a class=lnlinks href=#hl-41-14>14</a>
</span><span class=lnt id=hl-41-15><a class=lnlinks href=#hl-41-15>15</a>
</span><span class=lnt id=hl-41-16><a class=lnlinks href=#hl-41-16>16</a>
</span><span class=lnt id=hl-41-17><a class=lnlinks href=#hl-41-17>17</a>
</span><span class=lnt id=hl-41-18><a class=lnlinks href=#hl-41-18>18</a>
</span><span class=lnt id=hl-41-19><a class=lnlinks href=#hl-41-19>19</a>
</span><span class=lnt id=hl-41-20><a class=lnlinks href=#hl-41-20>20</a>
</span><span class=lnt id=hl-41-21><a class=lnlinks href=#hl-41-21>21</a>
</span><span class=lnt id=hl-41-22><a class=lnlinks href=#hl-41-22>22</a>
</span><span class=lnt id=hl-41-23><a class=lnlinks href=#hl-41-23>23</a>
</span><span class=lnt id=hl-41-24><a class=lnlinks href=#hl-41-24>24</a>
</span><span class=lnt id=hl-41-25><a class=lnlinks href=#hl-41-25>25</a>
</span><span class=lnt id=hl-41-26><a class=lnlinks href=#hl-41-26>26</a>
</span><span class=lnt id=hl-41-27><a class=lnlinks href=#hl-41-27>27</a>
</span><span class=lnt id=hl-41-28><a class=lnlinks href=#hl-41-28>28</a>
</span><span class=lnt id=hl-41-29><a class=lnlinks href=#hl-41-29>29</a>
</span><span class=lnt id=hl-41-30><a class=lnlinks href=#hl-41-30>30</a>
</span><span class=lnt id=hl-41-31><a class=lnlinks href=#hl-41-31>31</a>
</span><span class=lnt id=hl-41-32><a class=lnlinks href=#hl-41-32>32</a>
</span><span class=lnt id=hl-41-33><a class=lnlinks href=#hl-41-33>33</a>
</span><span class=lnt id=hl-41-34><a class=lnlinks href=#hl-41-34>34</a>
</span><span class=lnt id=hl-41-35><a class=lnlinks href=#hl-41-35>35</a>
</span><span class=lnt id=hl-41-36><a class=lnlinks href=#hl-41-36>36</a>
</span><span class=lnt id=hl-41-37><a class=lnlinks href=#hl-41-37>37</a>
</span><span class=lnt id=hl-41-38><a class=lnlinks href=#hl-41-38>38</a>
</span><span class=lnt id=hl-41-39><a class=lnlinks href=#hl-41-39>39</a>
</span><span class=lnt id=hl-41-40><a class=lnlinks href=#hl-41-40>40</a>
</span><span class=lnt id=hl-41-41><a class=lnlinks href=#hl-41-41>41</a>
</span><span class=lnt id=hl-41-42><a class=lnlinks href=#hl-41-42>42</a>
</span><span class=lnt id=hl-41-43><a class=lnlinks href=#hl-41-43>43</a>
</span><span class=lnt id=hl-41-44><a class=lnlinks href=#hl-41-44>44</a>
</span><span class=lnt id=hl-41-45><a class=lnlinks href=#hl-41-45>45</a>
</span><span class=lnt id=hl-41-46><a class=lnlinks href=#hl-41-46>46</a>
</span><span class=lnt id=hl-41-47><a class=lnlinks href=#hl-41-47>47</a>
</span><span class=lnt id=hl-41-48><a class=lnlinks href=#hl-41-48>48</a>
</span><span class=lnt id=hl-41-49><a class=lnlinks href=#hl-41-49>49</a>
</span><span class=lnt id=hl-41-50><a class=lnlinks href=#hl-41-50>50</a>
</span><span class=lnt id=hl-41-51><a class=lnlinks href=#hl-41-51>51</a>
</span><span class=lnt id=hl-41-52><a class=lnlinks href=#hl-41-52>52</a>
</span><span class=lnt id=hl-41-53><a class=lnlinks href=#hl-41-53>53</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>t</span><span class=p>,</span> <span class=n>leaf</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=n>t</span>  <span class=c1># 최소 차수 (minimum degree)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>keys</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 키를 저장하는 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>children</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 자식 노드를 가리키는 포인터 리스트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>leaf</span> <span class=o>=</span> <span class=n>leaf</span>  <span class=c1># 리프 노드 여부</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 노드와 서브트리를 중위 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1># 리프가 아닌 경우 자식 노드 순회</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>keys</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>traverse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>end</span><span class=o>=</span><span class=s1>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 자식 순회</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>traverse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BTree</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>t</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>t</span> <span class=o>=</span> <span class=n>t</span>  <span class=c1># 최소 차수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>traverse</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=o>.</span><span class=n>traverse</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_search</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=c1># 노드에서 k보다 크거나 같은 첫 번째 키 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=n>k</span> <span class=o>&gt;</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키를 찾은 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>)</span> <span class=ow>and</span> <span class=n>k</span> <span class=o>==</span> <span class=n>node</span><span class=o>.</span><span class=n>keys</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>node</span><span class=p>,</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키를 찾지 못했고 리프인 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>leaf</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 적절한 자식 노드로 재귀 호출</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_search</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>children</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 삽입, 삭제 등 다른 메서드 구현…</span>
</span></span></code></pre></td></tr></table></div></div><p>이 구현은 B 트리의 기본 구조와 몇 가지 핵심 연산만을 포함하고 있다.<br>실제 완전한 구현에는 삽입, 삭제, 노드 분할, 병합 등의 복잡한 연산이 추가되어야 한다.</p><h3 id=최신-연구-및-발전-동향>최신 연구 및 발전 동향<a hidden class=anchor aria-hidden=true href=#최신-연구-및-발전-동향>#</a></h3><p>B 트리는 수십 년 동안 사용되어 왔지만, 여전히 다음과 같은 영역에서 연구와 발전이 계속되고 있다:</p><ol><li><p>병렬 및 분산 B 트리</p><ul><li><strong>병렬 B 트리</strong>: 다중 코어/프로세서 환경에서 병렬 연산을 지원.</li><li><strong>분산 B 트리</strong>: 여러 서버에 걸쳐 분산된 B 트리 구현을 통해 확장성을 높인다.</li><li><strong>Bw-트리</strong>: Microsoft에서 개발한 잠금 없는(lock-free) B 트리 변형.</li></ul></li><li><p>비휘발성 메모리(NVM) 최적화</p><ul><li><strong>NV-트리</strong>: 비휘발성 메모리에 최적화된 B 트리 변형.</li><li><strong>영속성</strong>: 전원 장애 후에도 데이터 일관성을 유지할 수 있는 기법들이 연구되고 있다.</li></ul></li><li><p>압축 기법</p><ul><li><strong>압축 B 트리</strong>: 키와 포인터를 압축하여 메모리 효율성을 높인다.</li><li><strong>접두사 압축</strong>: 공통 접두사를 공유하여 저장 공간을 절약한다.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>