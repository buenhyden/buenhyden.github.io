<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>중복되는 하위 문제(Overlapping Subproblems) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Dynamic-Programming,Principles,Overlapping-Subproblems"><meta name=description content="중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="중복되는 하위 문제(Overlapping Subproblems)"><meta property="og:description" content="중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="중복되는 하위 문제(Overlapping Subproblems)"><meta name=twitter:description content="중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":6,"name":"중복되는 하위 문제(Overlapping Subproblems)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>중복되는 하위 문제(Overlapping Subproblems)</h1><div class=post-description>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.</div></header><div class=post-content><h2 id=중복되는-하위-문제overlapping-subproblems>중복되는 하위 문제(Overlapping Subproblems)<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제overlapping-subproblems>#</a></h2><p>동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.<br>동적 계획법이 효과적으로 적용되기 위해서는 두 가지 핵심 특성이 필요하다:</p><ul><li>최적 부분 구조(Optimal Substructure)</li><li>중복되는 하위 문제(Overlapping Subproblems)<br>이다.</li></ul><h3 id=중복되는-하위-문제overlapping-subproblems의-기본-개념>중복되는 하위 문제(Overlapping Subproblems)의 기본 개념<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제overlapping-subproblems의-기본-개념>#</a></h3><p>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.<br>즉, 문제를 해결하는 과정에서 같은 계산이 여러 번 수행되는 경우이다.<br>중복되는 하위 문제가 있을 때 동적 계획법은 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피함으로써 효율성을 크게 향상시킨다.</p><h4 id=중복되는-하위-문제의-핵심-특성>중복되는 하위 문제의 핵심 특성<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-핵심-특성>#</a></h4><ol><li><strong>반복 계산</strong>: 동일한 입력 매개변수에 대해 같은 계산이 여러 번 수행된다.</li><li><strong>결과 재사용 가능성</strong>: 한 번 계산된 하위 문제의 결과를 저장하고 재사용할 수 있다.</li><li><strong>하위 문제 개수의 다항성</strong>: 문제 크기에 대해 하위 문제의 총 개수가 다항식적(polynomial)이다.</li><li><strong>하위 문제 간 의존성</strong>: 여러 상위 문제가 동일한 하위 문제에 의존한다.</li></ol><h4 id=재귀적-알고리즘에서의-중복>재귀적 알고리즘에서의 중복<a hidden class=anchor aria-hidden=true href=#재귀적-알고리즘에서의-중복>#</a></h4><p>중복되는 하위 문제는 재귀적 알고리즘에서 특히 두드러진다.<br>예를 들어, 피보나치 수열의 단순 재귀 구현을 보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드에서 <code>fibonacci(n-2)</code>는 <code>fibonacci(n-1)</code> 계산 과정에서도 호출되므로, 동일한 하위 문제가 중복해서 계산된다.<br>예를 들어, <code>fibonacci(5)</code>를 계산할 때:</p><ul><li><code>fibonacci(5)</code> → <code>fibonacci(4)</code> + <code>fibonacci(3)</code></li><li><code>fibonacci(4)</code> → <code>fibonacci(3)</code> + <code>fibonacci(2)</code></li><li><code>fibonacci(3)</code> → <code>fibonacci(2)</code> + <code>fibonacci(1)</code></li></ul><p>여기서 <code>fibonacci(3)</code>과 <code>fibonacci(2)</code>가 각각 여러 번 계산되는 것을 볼 수 있다.</p><h4 id=중복되는-하위-문제-식별-방법>중복되는 하위 문제 식별 방법<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-식별-방법>#</a></h4><p>중복되는 하위 문제를 식별하는 방법은 다음과 같다:</p><ol><li><strong>재귀 트리 분석</strong>: 재귀 호출 트리를 그려보고 동일한 함수 호출이 반복되는지 확인한다.</li><li><strong>하위 문제 정의 분석</strong>: 하위 문제가 소수의 매개변수로 완전히 정의되고, 이 매개변수가 제한된 범위를 가지는지 확인한다.</li><li><strong>중복 횟수 측정</strong>: 간단한 테스트 케이스에서 각 하위 문제가 몇 번 호출되는지 측정한다.</li></ol><h3 id=중복되는-하위-문제-해결-방법>중복되는 하위 문제 해결 방법<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-해결-방법>#</a></h3><h4 id=메모이제이션memoization---하향식top-down-접근>메모이제이션(Memoization) - 하향식(Top-Down) 접근<a hidden class=anchor aria-hidden=true href=#메모이제이션memoization---하향식top-down-접근>#</a></h4><p>메모이제이션은 하위 문제의 결과를 저장하여 중복 계산을 피하는 기법이다.<br>재귀적 접근에 저장소(주로 배열이나 해시맵)를 추가하여 구현한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 이미 계산된 결과가 있으면 바로 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 계산 및 저장</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 필요한 하위 문제만 계산하고 결과를 저장하여 재사용한다.</p><h4 id=테이블링tabulation---상향식bottom-up-접근>테이블링(Tabulation) - 상향식(Bottom-Up) 접근<a hidden class=anchor aria-hidden=true href=#테이블링tabulation---상향식bottom-up-접근>#</a></h4><p>테이블링은 작은 하위 문제부터 시작하여 더 큰 문제를 해결하는 방식이다.<br>결과를 테이블(주로 배열)에 저장하며, 재귀 호출 없이 반복문으로 구현한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_tab</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># DP 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 작은 문제부터 큰 문제까지 해결</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 모든 하위 문제를 순차적으로 해결하며, 메모리 접근 패턴이 더 효율적일 수 있다.</p><h4 id=두-접근-방식의-비교>두 접근 방식의 비교<a hidden class=anchor aria-hidden=true href=#두-접근-방식의-비교>#</a></h4><table><thead><tr><th>특성</th><th>메모이제이션(하향식)</th><th>테이블링(상향식)</th></tr></thead><tbody><tr><td><strong>구현 방식</strong></td><td>재귀 + 메모 저장소</td><td>반복문 + 테이블</td></tr><tr><td><strong>계산 순서</strong></td><td>필요한 하위 문제만 계산</td><td>모든 하위 문제를 순차적으로 계산</td></tr><tr><td><strong>재귀 호출</strong></td><td>있음 (스택 오버플로우 가능성)</td><td>없음</td></tr><tr><td><strong>공간 효율성</strong></td><td>필요한 하위 문제만 저장 가능</td><td>일반적으로 모든 하위 문제 저장</td></tr><tr><td><strong>호출 오버헤드</strong></td><td>재귀 호출 오버헤드 존재</td><td>오버헤드 적음</td></tr><tr><td><strong>코드 가독성</strong></td><td>일반적으로 더 직관적</td><td>때로 더 복잡할 수 있음</td></tr><tr><td><strong>최적화 기회</strong></td><td>필요 없는 하위 문제 계산 회피</td><td>메모리 최적화 용이</td></tr></tbody></table><h3 id=다양한-중복되는-하위-문제-유형>다양한 중복되는 하위 문제 유형<a hidden class=anchor aria-hidden=true href=#다양한-중복되는-하위-문제-유형>#</a></h3><h4 id=선형-의존성linear-dependency>선형 의존성(Linear Dependency)<a hidden class=anchor aria-hidden=true href=#선형-의존성linear-dependency>#</a></h4><p>하위 문제가 일정한 간격으로 이전 하위 문제들에 의존하는 경우.</p><p><strong>예시</strong>: 피보나치 수열, 계단 오르기 문제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 계단 오르기 문제: 한 번에 1단 또는 2단씩 오를 수 있을 때, n개의 계단을 오르는 방법의 수</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>climb_stairs</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>  <span class=c1># 선형 의존성</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=구간-의존성range-dependency>구간 의존성(Range Dependency)<a hidden class=anchor aria-hidden=true href=#구간-의존성range-dependency>#</a></h4><p>하위 문제가 특정 구간 내의 다른 하위 문제들에 의존하는 경우.</p><p><strong>예시</strong>: 행렬 곱셈 연쇄, 최적 이진 검색 트리</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 행렬 곱셈 연쇄 문제</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>matrix_chain_multiplication</span><span class=p>(</span><span class=n>dims</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>dims</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = i부터 j까지의 행렬을 곱하는 최소 연산 횟수</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 구간 내 모든 분할점 k에 대해 최소값 찾기 (구간 의존성)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>dims</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>dims</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>dims</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=상태-전이-의존성state-transition-dependency>상태 전이 의존성(State Transition Dependency)<a hidden class=anchor aria-hidden=true href=#상태-전이-의존성state-transition-dependency>#</a></h4><p>하위 문제가 여러 이전 상태에서의 전이에 의존하는 경우.</p><p><strong>예시</strong>: 배낭 문제, 동전 교환 문제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 동전 교환 문제: 주어진 금액을 만들기 위한 최소 동전 개수</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>coin_change</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=p>(</span><span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>coin</span><span class=p>,</span> <span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재 금액에서 동전 값을 뺀 상태에서 전이 (상태 전이 의존성)</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>coin</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=다차원-의존성multi-dimensional-dependency>다차원 의존성(Multi-dimensional Dependency)<a hidden class=anchor aria-hidden=true href=#다차원-의존성multi-dimensional-dependency>#</a></h4><p>하위 문제가 여러 차원의 상태에 의존하는 경우.</p><p><strong>예시</strong>: 최장 공통 부분 수열, 편집 거리</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 편집 거리 문제</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit_distance</span><span class=p>(</span><span class=n>word1</span><span class=p>,</span> <span class=n>word2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>word1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>word2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = word1[:i]와 word2[:j] 간의 편집 거리</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 빈 문자열로 변환</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>word1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>word2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>  <span class=c1># 문자가 같으면 대각선 값 사용</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 삽입, 삭제, 대체 중 최소값 (다차원 의존성)</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중복되는-하위-문제의-일반적인-예시와-분석>중복되는 하위 문제의 일반적인 예시와 분석<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-일반적인-예시와-분석>#</a></h3><h4 id=피보나치-수열fibonacci-sequence>피보나치 수열(Fibonacci Sequence)<a hidden class=anchor aria-hidden=true href=#피보나치-수열fibonacci-sequence>#</a></h4><p>피보나치 수열은 중복되는 하위 문제의 가장 대표적인 예.<br><strong>분석</strong>:</p><ul><li>F(n) = F(n-1) + F(n-2)의 형태로 하위 문제에 의존.</li><li>F(n)을 계산하기 위해 F(n-2)가 F(n-1)과 F(n-2) 양쪽에서 필요.</li><li>단순 재귀 구현의 시간 복잡도는 O(2^n)이지만, DP를 적용하면 O(n)으로 개선.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 하위 문제 중복 횟수 분석</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>count_fibonacci_calls</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># n=5일 때 호출 횟수: F(0):3번, F(1):5번, F(2):3번, F(3):2번, F(4):1번, F(5):1번</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최장-증가-부분-수열longest-increasing-subsequence>최장 증가 부분 수열(Longest Increasing Subsequence)<a hidden class=anchor aria-hidden=true href=#최장-증가-부분-수열longest-increasing-subsequence>#</a></h4><p>배열에서 값이 증가하는 가장 긴 부분 수열을 찾는 문제이다.<br><strong>분석</strong>:</p><ul><li>LIS(i)는 인덱스 i까지의 LIS 길이.</li><li>LIS(i) = <code>max(LIS(j) + 1)</code> (<code>j &lt; i 이고 A[j] &lt; A[i]</code>)의 형태로 하위 문제에 의존.</li><li>각 위치 i에 대해 이전의 모든 위치 j에서의 LIS 값을 참조.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># dp[i] = 인덱스 i까지의 LIS 길이</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=배낭-문제knapsack-problem>배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#배낭-문제knapsack-problem>#</a></h4><p>제한된 무게 내에서 최대 가치를 가지는 물건들을 선택하는 문제.<br><strong>분석</strong>:</p><ul><li><code>DP[i][w]</code>는 처음 i개 물건으로 무게 w를 채울 때의 최대 가치이다.</li><li><code>DP[i][w] = max(DP[i-1][w], DP[i-1][w-wᵢ] + vᵢ)</code>의 형태로 하위 문제에 의존한다.</li><li>동일한 (i, w) 조합이 여러 경로에서 참조된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_01</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중복되는-하위-문제의-복잡도-분석>중복되는 하위 문제의 복잡도 분석<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-복잡도-분석>#</a></h3><h4 id=시간-복잡도-개선>시간 복잡도 개선<a hidden class=anchor aria-hidden=true href=#시간-복잡도-개선>#</a></h4><p>중복되는 하위 문제에 메모이제이션이나 테이블링을 적용하면 시간 복잡도를 크게 개선할 수 있다.</p><table><thead><tr><th>문제</th><th>단순 재귀</th><th>동적 계획법</th><th>개선 비율</th></tr></thead><tbody><tr><td>피보나치 수열</td><td>O(2^n)</td><td>O(n)</td><td>지수적 개선</td></tr><tr><td>이항 계수</td><td>O(2^n)</td><td>O(n²)</td><td>지수적 개선</td></tr><tr><td>최장 증가 부분 수열</td><td>O(2^n)</td><td>O(n²)</td><td>지수적 개선</td></tr><tr><td>배낭 문제</td><td>O(2^n)</td><td>O(n·W)</td><td>지수적 개선</td></tr><tr><td>편집 거리</td><td>O(3^(m+n))</td><td>O(m·n)</td><td>지수적 개선</td></tr></tbody></table><h4 id=중복-하위-문제의-수-분석>중복 하위 문제의 수 분석<a hidden class=anchor aria-hidden=true href=#중복-하위-문제의-수-분석>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>analyze_subproblem_calls</span><span class=p>(</span><span class=n>dp_function</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 하위 문제 호출 추적을 위한 래퍼 함수</span>
</span></span><span class=line><span class=cl>    <span class=n>call_count</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 튜플로 변환하여 해시 가능하게 만듦</span>
</span></span><span class=line><span class=cl>        <span class=n>args_tuple</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>args_tuple</span> <span class=ow>in</span> <span class=n>call_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>call_count</span><span class=p>[</span><span class=n>args_tuple</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>call_count</span><span class=p>[</span><span class=n>args_tuple</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp_function</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 함수 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>wrapper</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분석 결과</span>
</span></span><span class=line><span class=cl>    <span class=n>total_calls</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>call_count</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>unique_subproblems</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>call_count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>max_repetition</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>call_count</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;total_calls&#34;</span><span class=p>:</span> <span class=n>total_calls</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;unique_subproblems&#34;</span><span class=p>:</span> <span class=n>unique_subproblems</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;max_repetition&#34;</span><span class=p>:</span> <span class=n>max_repetition</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;detailed_counts&#34;</span><span class=p>:</span> <span class=n>call_count</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=공간-복잡도-분석>공간 복잡도 분석<a hidden class=anchor aria-hidden=true href=#공간-복잡도-분석>#</a></h4><p>중복되는 하위 문제 해결을 위한 저장 공간의 크기는 하위 문제의 수에 비례합니다.</p><table><thead><tr><th>문제</th><th>메모이제이션 공간</th><th>테이블링 공간</th><th>최적화된 공간</th></tr></thead><tbody><tr><td>피보나치 수열</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>최장 증가 부분 수열</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>배낭 문제</td><td>O(n·W)</td><td>O(n·W)</td><td>O(W)</td></tr><tr><td>편집 거리</td><td>O(m·n)</td><td>O(m·n)</td><td>O(min(m,n))</td></tr><tr><td>행렬 곱셈 연쇄</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td></tr></tbody></table><h4 id=하위-문제-간-의존성-그래프>하위 문제 간 의존성 그래프<a hidden class=anchor aria-hidden=true href=#하위-문제-간-의존성-그래프>#</a></h4><p>하위 문제 간의 의존성을 방향 그래프로 표현할 수 있다.<br>노드는 하위 문제, 엣지는 의존성을 나타낸다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>build_dependency_graph</span><span class=p>(</span><span class=n>problem_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 예: 피보나치 수열의 의존성 그래프</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>problem_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 기본 사례는 의존성 없음</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>  <span class=c1># F(i)는 F(i-1)과 F(i-2)에 의존</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>graph</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중복되는-하위-문제가-없는-알고리즘>중복되는 하위 문제가 없는 알고리즘<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제가-없는-알고리즘>#</a></h3><p>모든 문제가 중복되는 하위 문제를 가지는 것은 아니다.<br>다음은 중복되는 하위 문제가 없는 대표적인 알고리즘들.</p><h4 id=분할-정복divide-and-conquer-알고리즘>분할 정복(Divide and Conquer) 알고리즘<a hidden class=anchor aria-hidden=true href=#분할-정복divide-and-conquer-알고리즘>#</a></h4><p>분할 정복 알고리즘은 문제를 더 작은 하위 문제로 나누지만, 이들 하위 문제가 중복되지 않는 경우가 많다.</p><p><strong>병합 정렬(Merge Sort)</strong> 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>])</span>  <span class=c1># 독립적인 하위 문제</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:])</span>  <span class=c1># 독립적인 하위 문제</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>병합 정렬에서는 배열의 서로 다른 부분을 정렬하므로, 동일한 하위 문제가 중복해서 해결되지 않는다.</p><h4 id=다익스트라-알고리즘dijkstras-algorithm>다익스트라 알고리즘(Dijkstra&rsquo;s Algorithm)<a hidden class=anchor aria-hidden=true href=#다익스트라-알고리즘dijkstras-algorithm>#</a></h4><p>다익스트라 알고리즘은 그래프에서 최단 경로를 찾는 알고리즘으로, 각 노드를 한 번씩만 방문한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_distance</span><span class=p>,</span> <span class=n>current_node</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이미 처리된 노드는 건너뛰기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_distance</span> <span class=o>&gt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>current_node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>current_node</span><span class=p>]</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>distance</span> <span class=o>=</span> <span class=n>current_distance</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>distance</span> <span class=o>&lt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=n>distance</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distances</span>
</span></span></code></pre></td></tr></table></div></div><p>다익스트라 알고리즘에서는 각 노드의 최단 거리를 한 번만 계산하므로 중복되는 하위 문제가 없다.</p><h4 id=퀵-정렬quick-sort>퀵 정렬(Quick Sort)<a hidden class=anchor aria-hidden=true href=#퀵-정렬quick-sort>#</a></h4><p>퀵 정렬은 피벗을 기준으로 배열을 나누어 정렬하는 알고리즘으로, 하위 문제가 중복되지 않는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>퀵 정렬에서는 각 하위 배열이 독립적으로 정렬되므로 중복되는 하위 문제가 없다.</p><h3 id=중복되는-하위-문제의-식별-및-최적화-방법>중복되는 하위 문제의 식별 및 최적화 방법<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-식별-및-최적화-방법>#</a></h3><h4 id=중복되는-하위-문제-식별-체크리스트>중복되는 하위 문제 식별 체크리스트<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-식별-체크리스트>#</a></h4><ol><li><strong>재귀 호출 패턴 분석</strong>: 동일한 매개변수로 함수가 반복 호출되는지 확인한다.</li><li><strong>상태 공간 크기 검토</strong>: 가능한 하위 문제 상태의 수가 입력 크기에 다항식적인지 확인한다.</li><li><strong>의존성 그래프 구성</strong>: 하위 문제 간의 의존성을 그래프로 표현하여 중복 여부를 확인한다.</li><li><strong>계산 추적</strong>: 간단한 예제에서 각 하위 문제가 몇 번 계산되는지 추적한다.</li></ol><h4 id=메모이제이션-최적화-기법>메모이제이션 최적화 기법<a hidden class=anchor aria-hidden=true href=#메모이제이션-최적화-기법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>memoization_optimization</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;함수에 메모이제이션을 적용하는 데코레이터&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 인수를 해시 가능한 형태로 변환</span>
</span></span><span class=line><span class=cl>        <span class=n>args_key</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=nb>list</span><span class=p>)</span> <span class=k>else</span> <span class=n>x</span><span class=p>,</span> <span class=n>args</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>args_key</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>memo</span><span class=p>[</span><span class=n>args_key</span><span class=p>]</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>args_key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@memoization_optimization</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=테이블링-최적화-기법>테이블링 최적화 기법<a hidden class=anchor aria-hidden=true href=#테이블링-최적화-기법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>tabulation_optimization</span><span class=p>(</span><span class=n>fibonacci</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;상향식 테이블링으로 피보나치 수열 최적화&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 2개의 변수만 사용하여 공간 복잡도 최적화</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 전체 DP 테이블을 유지하는 대신 필수적인 값만 저장하여 공간 복잡도를 O(n)에서 O(1)로 개선한다.</p><h3 id=상태-공간-축소-기법>상태 공간 축소 기법<a hidden class=anchor aria-hidden=true href=#상태-공간-축소-기법>#</a></h3><p>상태 공간 축소는 문제의 상태 표현을 최소화하여 중복되는 하위 문제의 수를 줄이는 기법.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 원래 배낭 문제 구현 (2차원 배열)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_original</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>capacity</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 상태 공간 축소 버전 (1차원 배열)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_optimized</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 역순으로 순회하여 이전 상태에 영향을 주지 않도록 함</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span><span class=p>,</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>w</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>w</span> <span class=o>-</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 최적화는 공간 복잡도를 O(n·W)에서 O(W)로 줄인다.</p><h3 id=실제-응용-사례에서의-중복되는-하위-문제>실제 응용 사례에서의 중복되는 하위 문제<a hidden class=anchor aria-hidden=true href=#실제-응용-사례에서의-중복되는-하위-문제>#</a></h3><h4 id=문자열-처리-알고리즘>문자열 처리 알고리즘<a hidden class=anchor aria-hidden=true href=#문자열-처리-알고리즘>#</a></h4><p>문자열 처리에서 중복되는 하위 문제를 활용한 알고리즘의 예시.</p><p><strong>예시: 최장 회문 부분 문자열(Longest Palindromic Substring)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_palindromic_substring</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = s[i:j+1]이 회문인지 여부</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 길이 1인 부분 문자열은 회문</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>max_length</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 2인 부분 문자열 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=n>max_length</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 3 이상인 부분 문자열 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># s[i+1:j]가 회문이고 s[i]와 s[j]가 같은지 확인 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=ow>and</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>length</span> <span class=o>&gt;</span> <span class=n>max_length</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                    <span class=n>max_length</span> <span class=o>=</span> <span class=n>length</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>start</span> <span class=o>+</span> <span class=n>max_length</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 더 작은 부분 문자열이 회문인지에 대한 정보를 재사용하여 효율성을 높인다.</p><h4 id=그래프-알고리즘>그래프 알고리즘<a hidden class=anchor aria-hidden=true href=#그래프-알고리즘>#</a></h4><p>그래프 알고리즘에서 중복되는 하위 문제를 활용한 예시.</p><p><strong>예시: 모든 쌍 최단 경로(All-Pairs Shortest Path) - 플로이드-워셜 알고리즘</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>floyd_warshall</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[:]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>]</span>  <span class=c1># 그래프 복사</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># k = 중간 정점</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># i = 시작 정점</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># j = 종료 정점</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># i→k→j 경로가 i→j 직접 경로보다 짧은지 확인 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>                <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dist</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 노드 k를 통과하는 모든 경로를 계산할 때, 이전에 계산한 k-1까지의 중간 노드를 사용한 최단 경로 정보를 재사용한다.</p><h4 id=최적화-문제>최적화 문제<a hidden class=anchor aria-hidden=true href=#최적화-문제>#</a></h4><p>최적화 문제에서 중복되는 하위 문제를 활용한 예시.</p><p><strong>예시: 로드 밸런싱(Load Balancing) 문제</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span><span class=lnt id=hl-20-16><a class=lnlinks href=#hl-20-16>16</a>
</span><span class=lnt id=hl-20-17><a class=lnlinks href=#hl-20-17>17</a>
</span><span class=lnt id=hl-20-18><a class=lnlinks href=#hl-20-18>18</a>
</span><span class=lnt id=hl-20-19><a class=lnlinks href=#hl-20-19>19</a>
</span><span class=lnt id=hl-20-20><a class=lnlinks href=#hl-20-20>20</a>
</span><span class=lnt id=hl-20-21><a class=lnlinks href=#hl-20-21>21</a>
</span><span class=lnt id=hl-20-22><a class=lnlinks href=#hl-20-22>22</a>
</span><span class=lnt id=hl-20-23><a class=lnlinks href=#hl-20-23>23</a>
</span><span class=lnt id=hl-20-24><a class=lnlinks href=#hl-20-24>24</a>
</span><span class=lnt id=hl-20-25><a class=lnlinks href=#hl-20-25>25</a>
</span><span class=lnt id=hl-20-26><a class=lnlinks href=#hl-20-26>26</a>
</span><span class=lnt id=hl-20-27><a class=lnlinks href=#hl-20-27>27</a>
</span><span class=lnt id=hl-20-28><a class=lnlinks href=#hl-20-28>28</a>
</span><span class=lnt id=hl-20-29><a class=lnlinks href=#hl-20-29>29</a>
</span><span class=lnt id=hl-20-30><a class=lnlinks href=#hl-20-30>30</a>
</span><span class=lnt id=hl-20-31><a class=lnlinks href=#hl-20-31>31</a>
</span><span class=lnt id=hl-20-32><a class=lnlinks href=#hl-20-32>32</a>
</span><span class=lnt id=hl-20-33><a class=lnlinks href=#hl-20-33>33</a>
</span><span class=lnt id=hl-20-34><a class=lnlinks href=#hl-20-34>34</a>
</span><span class=lnt id=hl-20-35><a class=lnlinks href=#hl-20-35>35</a>
</span><span class=lnt id=hl-20-36><a class=lnlinks href=#hl-20-36>36</a>
</span><span class=lnt id=hl-20-37><a class=lnlinks href=#hl-20-37>37</a>
</span><span class=lnt id=hl-20-38><a class=lnlinks href=#hl-20-38>38</a>
</span><span class=lnt id=hl-20-39><a class=lnlinks href=#hl-20-39>39</a>
</span><span class=lnt id=hl-20-40><a class=lnlinks href=#hl-20-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_completion_time</span><span class=p>(</span><span class=n>jobs</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    k개의 프로세서에 작업을 할당하여 마지막 작업이 완료되는 시간을 최소화
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>jobs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[mask][i] = 비트마스크 mask로 표현된 작업들을 i개의 프로세서에 할당했을 때의 최소 완료 시간</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve</span><span class=p>(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 작업이 할당됨</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>mask</span> <span class=o>==</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이미 계산된 상태</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>)</span> <span class=ow>in</span> <span class=n>dp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>dp</span><span class=p>[(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가능한 모든 미할당 작업 조합 시도</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 새 프로세서 시작</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>processors</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)):</span>  <span class=c1># 작업 i가 아직 할당되지 않음</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_mask</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 작업 i를 새 프로세서에 할당 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>                    <span class=n>result</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=nb>max</span><span class=p>(</span><span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>solve</span><span class=p>(</span><span class=n>new_mask</span><span class=p>,</span> <span class=n>processors</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 기존 프로세서에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)):</span>  <span class=c1># 작업 i가 아직 할당되지 않음</span>
</span></span><span class=line><span class=cl>                <span class=n>new_mask</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># 작업 i를 기존 프로세서에 추가 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>solve</span><span class=p>(</span><span class=n>new_mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>)]</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solve</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 동일한 작업 집합과 프로세서 수에 대한 계산을 재사용하여 효율성을 높인다.</p><h3 id=중복되는-하위-문제-비교-분석표>중복되는 하위 문제 비교 분석표<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-비교-분석표>#</a></h3><p>아래 표는 다양한 알고리즘 문제에서 중복되는 하위 문제의 특성을 비교 분석:</p><table><thead><tr><th>문제</th><th>중복되는 하위 문제 수</th><th>하위 문제 의존성 유형</th><th>메모리 요구량</th><th>메모이제이션 효과</th><th>중복 계산 비율</th><th>재사용 패턴</th></tr></thead><tbody><tr><td><strong>피보나치 수열</strong></td><td>O(n)</td><td>선형</td><td>O(n)</td><td>매우 높음</td><td>>99%</td><td>F(n-2)가 F(n-1), F(n) 계산에 재사용</td></tr><tr><td><strong>최장 증가 부분 수열</strong></td><td>O(n)</td><td>분기</td><td>O(n)</td><td>높음</td><td>~50%</td><td>LIS(j)가 여러 LIS(i)에 재사용 (j &lt; i)</td></tr><tr><td><strong>0-1 배낭 문제</strong></td><td>O(n·W)</td><td>상태 전이</td><td>O(n·W)</td><td>높음</td><td>~70%</td><td>DP[i-1][w], DP[i-1][w-wᵢ]가 재사용</td></tr><tr><td><strong>편집 거리</strong></td><td>O(m·n)</td><td>다차원</td><td>O(m·n)</td><td>높음</td><td>~75%</td><td>ED[i-1][j], ED[i][j-1], ED[i-1][j-1]이 재사용</td></tr><tr><td><strong>행렬 곱셈 연쇄</strong></td><td>O(n²)</td><td>구간</td><td>O(n²)</td><td>중간</td><td>~60%</td><td>DP[i][k], DP[k+1][j]가 여러 구간에 재사용</td></tr><tr><td><strong>최장 공통 부분 수열</strong></td><td>O(m·n)</td><td>다차원</td><td>O(m·n)</td><td>높음</td><td>~70%</td><td>LCS[i-1][j], LCS[i][j-1], LCS[i-1][j-1]이 재사용</td></tr><tr><td><strong>동전 교환 문제</strong></td><td>O(n·amount)</td><td>상태 전이</td><td>O(amount)</td><td>높음</td><td>~80%</td><td>DP[i-coin]이 여러 금액에 재사용</td></tr><tr><td><strong>최적 이진 검색 트리</strong></td><td>O(n²)</td><td>구간</td><td>O(n²)</td><td>중간</td><td>~65%</td><td>DP[i][k-1], DP[k+1][j]가 여러 구간에 재사용</td></tr><tr><td><strong>팰린드롬 파티셔닝</strong></td><td>O(n²)</td><td>구간</td><td>O(n²)</td><td>높음</td><td>~75%</td><td>palindrome[i+1][j-1], cut[i][k]가 재사용</td></tr><tr><td><strong>외판원 문제(TSP)</strong></td><td>O(n·2^n)</td><td>상태/집합</td><td>O(n·2^n)</td><td>매우 높음</td><td>>95%</td><td>DP[S-{j}][i]가 여러 상태에 재사용</td></tr></tbody></table><h3 id=중복되는-하위-문제의-실무-구현-가이드>중복되는 하위 문제의 실무 구현 가이드<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-실무-구현-가이드>#</a></h3><h4 id=하향식top-down-메모이제이션-구현-패턴>하향식(Top-down) 메모이제이션 구현 패턴<a hidden class=anchor aria-hidden=true href=#하향식top-down-메모이제이션-구현-패턴>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19>19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20>20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21>21</a>
</span><span class=lnt id=hl-21-22><a class=lnlinks href=#hl-21-22>22</a>
</span><span class=lnt id=hl-21-23><a class=lnlinks href=#hl-21-23>23</a>
</span><span class=lnt id=hl-21-24><a class=lnlinks href=#hl-21-24>24</a>
</span><span class=lnt id=hl-21-25><a class=lnlinks href=#hl-21-25>25</a>
</span><span class=lnt id=hl-21-26><a class=lnlinks href=#hl-21-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>problem_solver_memoization</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 메모이제이션 캐시 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve_recursive</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 상태가 이미 계산되었는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>state</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>state</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 기본 사례 체크</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_base_case</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>base_case_value</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가능한 모든 선택지에 대해 최적값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>initial_value</span>  <span class=c1># 문제에 따라 초기값 설정 (최소값/최대값)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>choice</span> <span class=ow>in</span> <span class=n>possible_choices</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>next_state</span> <span class=o>=</span> <span class=n>apply_choice</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>choice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>subproblem_result</span> <span class=o>=</span> <span class=n>solve_recursive</span><span class=p>(</span><span class=n>next_state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=n>combine_results</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>subproblem_result</span><span class=p>,</span> <span class=n>choice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 결과 저장 및 반환</span>
</span></span><span class=line><span class=cl>        <span class=n>memo</span><span class=p>[</span><span class=n>state</span><span class=p>]</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기 상태에서 시작</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solve_recursive</span><span class=p>(</span><span class=n>initial_state</span><span class=p>(</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=상향식bottom-up-테이블링-구현-패턴>상향식(Bottom-up) 테이블링 구현 패턴<a hidden class=anchor aria-hidden=true href=#상향식bottom-up-테이블링-구현-패턴>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12>12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13>13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14>14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15>15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16>16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>problem_solver_tabulation</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 문제 크기 및 필요한 매개변수 추출</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>extract_problem_size</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># DP 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=n>initialize_dp_table</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례 설정</span>
</span></span><span class=line><span class=cl>    <span class=n>set_base_cases</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상향식으로 테이블 채우기</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>smallest_non_base_case</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>additional_dimension_if_needed</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>calculate_value</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최종 결과 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>extract_result</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=메모리-최적화-기법>메모리 최적화 기법<a hidden class=anchor aria-hidden=true href=#메모리-최적화-기법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14>14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15>15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16>16</a>
</span><span class=lnt id=hl-23-17><a class=lnlinks href=#hl-23-17>17</a>
</span><span class=lnt id=hl-23-18><a class=lnlinks href=#hl-23-18>18</a>
</span><span class=lnt id=hl-23-19><a class=lnlinks href=#hl-23-19>19</a>
</span><span class=lnt id=hl-23-20><a class=lnlinks href=#hl-23-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>memory_optimized_dp</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>extract_problem_size</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 1. 차원 축소: 2차원 → 1차원</span>
</span></span><span class=line><span class=cl>    <span class=c1># 예: 배낭 문제에서 행(물건)을 기준으로 반복하면서 한 행만 유지</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=n>initialize_reduced_dp_table</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 2. 순회 방향 최적화: 역순 순회로 이전 값 보존</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>max_value</span><span class=p>,</span> <span class=n>min_value</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>calculate_with_previous_values</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>input_data</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 3. 슬라이딩 윈도우: 필요한 이전 상태만 유지</span>
</span></span><span class=line><span class=cl>    <span class=c1># 예: 피보나치 수열에서 마지막 두 값만 유지</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>initial_values</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>combine</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=효율적인-구현을-위한-자료구조-선택>효율적인 구현을 위한 자료구조 선택<a hidden class=anchor aria-hidden=true href=#효율적인-구현을-위한-자료구조-선택>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1> 1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2> 2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3> 3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4> 4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5> 5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6> 6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7> 7</a>
</span><span class=lnt id=hl-24-8><a class=lnlinks href=#hl-24-8> 8</a>
</span><span class=lnt id=hl-24-9><a class=lnlinks href=#hl-24-9> 9</a>
</span><span class=lnt id=hl-24-10><a class=lnlinks href=#hl-24-10>10</a>
</span><span class=lnt id=hl-24-11><a class=lnlinks href=#hl-24-11>11</a>
</span><span class=lnt id=hl-24-12><a class=lnlinks href=#hl-24-12>12</a>
</span><span class=lnt id=hl-24-13><a class=lnlinks href=#hl-24-13>13</a>
</span><span class=lnt id=hl-24-14><a class=lnlinks href=#hl-24-14>14</a>
</span><span class=lnt id=hl-24-15><a class=lnlinks href=#hl-24-15>15</a>
</span><span class=lnt id=hl-24-16><a class=lnlinks href=#hl-24-16>16</a>
</span><span class=lnt id=hl-24-17><a class=lnlinks href=#hl-24-17>17</a>
</span><span class=lnt id=hl-24-18><a class=lnlinks href=#hl-24-18>18</a>
</span><span class=lnt id=hl-24-19><a class=lnlinks href=#hl-24-19>19</a>
</span><span class=lnt id=hl-24-20><a class=lnlinks href=#hl-24-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>choose_appropriate_data_structure</span><span class=p>(</span><span class=n>problem_type</span><span class=p>,</span> <span class=n>input_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;linear_dependency&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 배열이나 리스트로 충분</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;two_dimensional&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 2D 배열 또는 딕셔너리</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>input_size</span> <span class=o>&lt;=</span> <span class=mi>1000</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 희소 행렬의 경우 딕셔너리가 더 효율적</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;state_based&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 복잡한 상태는 해시 맵이 적합</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;bit_manipulation&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 비트마스크 사용</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>input_size</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>