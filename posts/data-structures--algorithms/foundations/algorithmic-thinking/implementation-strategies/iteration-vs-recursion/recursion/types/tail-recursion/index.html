<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>꼬리 재귀(Tail Recursion) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Recursion,Types,Tail-Recursion"><meta name=description content="Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="꼬리 재귀(Tail Recursion)"><meta property="og:description" content="Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-09T09:37:00+00:00"><meta property="article:modified_time" content="2024-12-09T09:37:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Recursion"><meta property="article:tag" content="Types"><meta property="article:tag" content="Tail-Recursion"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="꼬리 재귀(Tail Recursion)"><meta name=twitter:description content="Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":9,"name":"꼬리 재귀(Tail Recursion)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"꼬리 재귀(Tail Recursion)","name":"꼬리 재귀(Tail Recursion)","description":"Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Recursion","Types","Tail-Recursion"],"articleBody":"꼬리 재귀(Tail Recursion) 꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.\n꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.\n특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.\n일반 재귀의 문제점 일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.\n각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.\n입력값이 크면 다음과 같은 문제가 발생할 수 있다:\n스택 오버플로우(Stack Overflow): 재귀 깊이가 너무 깊어지면 스택 메모리가 부족해질 수 있다. 성능 저하: 많은 스택 프레임 생성과 관리는 성능에 영향을 준다. 팩토리얼을 계산하는 일반적인 재귀 함수:\n1 2 3 4 5 6 7 def factorial(n): # 기본 케이스: 0! 또는 1!은 1 if n \u003c= 1: return 1 # 재귀 케이스: n! = n * (n-1)! else: return n * factorial(n-1) 꼬리 재귀(Tail Recursion)란? 꼬리 재귀는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다.\n중요한 점은 재귀 호출 후에 추가 계산이 없어야 한다는 것.\n앞서 본 팩토리얼 함수는 꼬리 재귀가 아닙니다. 왜냐하면 return n * factorial(n-1)에서 재귀 호출 후에 곱셈 연산이 필요하기 때문.\n꼬리 재귀 형태로 변환하면 다음과 같다:\n1 2 3 4 5 6 7 def factorial_tail(n, accumulator=1): # 기본 케이스 if n \u003c= 1: return accumulator # 꼬리 재귀 호출: 중간 결과를 accumulator에 저장 else: return factorial_tail(n-1, n * accumulator) 여기서 accumulator는 현재까지의 계산 결과를 저장하는 매개변수.\n꼬리 재귀의 장점 꼬리 호출 최적화(Tail Call Optimization, TCO): 많은 언어와 컴파일러는 꼬리 재귀 호출을 최적화하여 일반 반복문처럼 처리할 수 있다. 이렇게 하면 새 스택 프레임을 만들 필요가 없어진다. 스택 오버플로우 방지: 컴파일러가 TCO를 지원하면, 꼬리 재귀는 입력 크기에 관계없이 일정한 스택 공간을 사용한다. 성능 향상: 스택 프레임을 재사용하므로 메모리 사용량과 함수 호출 오버헤드가 줄어든다. 다양한 언어에서의 꼬리 재귀 지원 꼬리 재귀 최적화 지원은 언어와 컴파일러마다 다르다:\n강력한 지원: Scheme, Scala, Haskell, Erlang 등 함수형 언어들은 TCO를 적극 지원한다. 부분 지원: JavaScript: ES6부터 TCO를 지원하도록 명세되었지만, 대부분의 브라우저는 아직 구현하지 않았다. C/C++: 대부분의 컴파일러는 최적화 옵션을 켰을 때 TCO를 지원한다. 지원 안함: Python: CPython 인터프리터는 TCO를 지원하지 않는다. Java: JVM은 기본적으로 TCO를 지원하지 않는다. 꼬리 재귀 예제: 피보나치 수열 일반 재귀로 구현한 피보나치:\n1 2 3 4 5 def fibonacci(n): if n \u003c= 1: return n else: return fibonacci(n-1) + fibonacci(n-2) # 꼬리 재귀 아님 꼬리 재귀로 구현한 피보나치:\n1 2 3 4 5 def fibonacci_tail(n, a=0, b=1): if n == 0: return a else: return fibonacci_tail(n-1, b, a+b) # 꼬리 재귀 꼬리 재귀로 변환하는 일반적인 기법 누산기 매개변수 추가: 중간 결과를 저장할 추가 매개변수를 도입한다. 재귀 호출을 함수의 마지막 연산으로 이동: 재귀 호출 후 추가 계산이 없어야 한다. 헬퍼 함수 사용: 원래 함수를 감싸는 헬퍼 함수를 만들어 사용자가 추가 매개변수를 전달하지 않도록 한다. 꼬리 재귀와 반복문 비교 꼬리 재귀 최적화가 지원되면, 꼬리 재귀 함수는 반복문과 거의 동일한 성능을 보인다.\n예를 들어, 팩토리얼 계산을 반복문으로 구현하면:\n1 2 3 4 5 def factorial_iterative(n): result = 1 for i in range(1, n+1): result *= i return result 이 반복문 버전은 꼬리 재귀 버전과 개념적으로 유사하며, 컴파일러가 TCO를 지원하면 비슷한 실행 패턴으로 최적화된다.\n참고 및 출처 ","wordCount":"511","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-09T09:37:00Z","dateModified":"2024-12-09T09:37:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/types/tail-recursion/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">꼬리 재귀(Tail Recursion)</h1><div class=post-description>Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다.</div><div class=post-meta><span title='2024-12-09 09:37:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20&%20Algorithms/Foundations/Algorithmic%20Thinking/Implementation%20Strategies/Iteration%20vs%20Recursion/Recursion/Types/tail-recursion.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#꼬리-재귀tail-recursion>꼬리 재귀(Tail Recursion)</a><ul><li><a href=#일반-재귀의-문제점>일반 재귀의 문제점</a></li><li><a href=#꼬리-재귀tail-recursion란>꼬리 재귀(Tail Recursion)란?</a></li><li><a href=#꼬리-재귀의-장점>꼬리 재귀의 장점</a></li><li><a href=#다양한-언어에서의-꼬리-재귀-지원>다양한 언어에서의 꼬리 재귀 지원</a></li><li><a href=#꼬리-재귀-예제-피보나치-수열>꼬리 재귀 예제: 피보나치 수열</a></li><li><a href=#꼬리-재귀로-변환하는-일반적인-기법>꼬리 재귀로 변환하는 일반적인 기법</a></li><li><a href=#꼬리-재귀와-반복문-비교>꼬리 재귀와 반복문 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=꼬리-재귀tail-recursion>꼬리 재귀(Tail Recursion)<a hidden class=anchor aria-hidden=true href=#꼬리-재귀tail-recursion>#</a></h2><p>꼬리 재귀는 재귀 프로그래밍의 특별한 형태로, 많은 현대 프로그래밍 언어와 컴파일러에서 중요한 최적화 기법이다.</p><p>꼬리 재귀는 재귀의 표현력과 반복문의 효율성을 결합한 강력한 프로그래밍 기법이다.<br>특히 함수형 프로그래밍에서 중요한 패턴으로, 메모리 사용을 최소화하면서도 재귀의 간결함과 우아함을 유지할 수 있게 해준다. 하지만 사용하기 전에 언어나 컴파일러가 꼬리 호출 최적화를 지원하는지 확인하는 것이 중요하다.</p><h3 id=일반-재귀의-문제점>일반 재귀의 문제점<a hidden class=anchor aria-hidden=true href=#일반-재귀의-문제점>#</a></h3><p>일반적인 재귀 함수는 호출 스택(call stack)을 많이 사용한다.<br>각 재귀 호출마다 새로운 스택 프레임이 생성되어 이전 호출의 상태를 저장해야 한다.<br>입력값이 크면 다음과 같은 문제가 발생할 수 있다:</p><ol><li><strong>스택 오버플로우(Stack Overflow)</strong>: 재귀 깊이가 너무 깊어지면 스택 메모리가 부족해질 수 있다.</li><li><strong>성능 저하</strong>: 많은 스택 프레임 생성과 관리는 성능에 영향을 준다.</li></ol><p>팩토리얼을 계산하는 일반적인 재귀 함수:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 0! 또는 1!은 1</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=c1># 재귀 케이스: n! = n * (n-1)!</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=꼬리-재귀tail-recursion란>꼬리 재귀(Tail Recursion)란?<a hidden class=anchor aria-hidden=true href=#꼬리-재귀tail-recursion란>#</a></h3><p>꼬리 재귀는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다.<br>중요한 점은 재귀 호출 후에 추가 계산이 없어야 한다는 것.</p><p>앞서 본 팩토리얼 함수는 꼬리 재귀가 아닙니다. 왜냐하면 <code>return n * factorial(n-1)</code>에서 재귀 호출 후에 곱셈 연산이 필요하기 때문.</p><p>꼬리 재귀 형태로 변환하면 다음과 같다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial_tail</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>accumulator</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>accumulator</span>
</span></span><span class=line><span class=cl>    <span class=c1># 꼬리 재귀 호출: 중간 결과를 accumulator에 저장</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>factorial_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>*</span> <span class=n>accumulator</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>여기서 <code>accumulator</code>는 현재까지의 계산 결과를 저장하는 매개변수.</p><h3 id=꼬리-재귀의-장점>꼬리 재귀의 장점<a hidden class=anchor aria-hidden=true href=#꼬리-재귀의-장점>#</a></h3><ol><li><strong>꼬리 호출 최적화(Tail Call Optimization, TCO)</strong>: 많은 언어와 컴파일러는 꼬리 재귀 호출을 최적화하여 일반 반복문처럼 처리할 수 있다. 이렇게 하면 새 스택 프레임을 만들 필요가 없어진다.</li><li><strong>스택 오버플로우 방지</strong>: 컴파일러가 TCO를 지원하면, 꼬리 재귀는 입력 크기에 관계없이 일정한 스택 공간을 사용한다.</li><li><strong>성능 향상</strong>: 스택 프레임을 재사용하므로 메모리 사용량과 함수 호출 오버헤드가 줄어든다.</li></ol><h3 id=다양한-언어에서의-꼬리-재귀-지원>다양한 언어에서의 꼬리 재귀 지원<a hidden class=anchor aria-hidden=true href=#다양한-언어에서의-꼬리-재귀-지원>#</a></h3><p>꼬리 재귀 최적화 지원은 언어와 컴파일러마다 다르다:</p><ol><li><strong>강력한 지원</strong>: Scheme, Scala, Haskell, Erlang 등 함수형 언어들은 TCO를 적극 지원한다.</li><li><strong>부분 지원</strong>:<ul><li>JavaScript: ES6부터 TCO를 지원하도록 명세되었지만, 대부분의 브라우저는 아직 구현하지 않았다.</li><li>C/C++: 대부분의 컴파일러는 최적화 옵션을 켰을 때 TCO를 지원한다.</li></ul></li><li><strong>지원 안함</strong>:<ul><li>Python: CPython 인터프리터는 TCO를 지원하지 않는다.</li><li>Java: JVM은 기본적으로 TCO를 지원하지 않는다.</li></ul></li></ol><h3 id=꼬리-재귀-예제-피보나치-수열>꼬리 재귀 예제: 피보나치 수열<a hidden class=anchor aria-hidden=true href=#꼬리-재귀-예제-피보나치-수열>#</a></h3><p>일반 재귀로 구현한 피보나치:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># 꼬리 재귀 아님</span>
</span></span></code></pre></td></tr></table></div></div><p>꼬리 재귀로 구현한 피보나치:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_tail</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>fibonacci_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>)</span>  <span class=c1># 꼬리 재귀</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=꼬리-재귀로-변환하는-일반적인-기법>꼬리 재귀로 변환하는 일반적인 기법<a hidden class=anchor aria-hidden=true href=#꼬리-재귀로-변환하는-일반적인-기법>#</a></h3><ol><li><strong>누산기 매개변수 추가</strong>: 중간 결과를 저장할 추가 매개변수를 도입한다.</li><li><strong>재귀 호출을 함수의 마지막 연산으로 이동</strong>: 재귀 호출 후 추가 계산이 없어야 한다.</li><li><strong>헬퍼 함수 사용</strong>: 원래 함수를 감싸는 헬퍼 함수를 만들어 사용자가 추가 매개변수를 전달하지 않도록 한다.</li></ol><h3 id=꼬리-재귀와-반복문-비교>꼬리 재귀와 반복문 비교<a hidden class=anchor aria-hidden=true href=#꼬리-재귀와-반복문-비교>#</a></h3><p>꼬리 재귀 최적화가 지원되면, 꼬리 재귀 함수는 반복문과 거의 동일한 성능을 보인다.<br>예를 들어, 팩토리얼 계산을 반복문으로 구현하면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial_iterative</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>*=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 반복문 버전은 꼬리 재귀 버전과 개념적으로 유사하며, 컴파일러가 TCO를 지원하면 비슷한 실행 패턴으로 최적화된다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/recursion/>Recursion</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/tail-recursion/>Tail-Recursion</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/system-architecture--design/overview/system-design/><span class=title>« Prev</span><br><span>System Design Overview</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/es6+-features/ecmascript/><span class=title>Next »</span><br><span>ECMAScript</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>