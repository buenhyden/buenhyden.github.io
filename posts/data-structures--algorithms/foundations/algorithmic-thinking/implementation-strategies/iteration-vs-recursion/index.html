<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Recursion vs. Iteration | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Recursion,Iteration"><meta name=description content="Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Recursion vs. Iteration"><meta property="og:description" content="Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Recursion vs. Iteration"><meta name=twitter:description content="Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":5,"name":"Recursion vs. Iteration","item":"https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Recursion vs. Iteration</h1><div class=post-description>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</div></header><div class=post-content><h2 id=recursion-vs-iteration>Recursion vs. Iteration<a hidden class=anchor aria-hidden=true href=#recursion-vs-iteration>#</a></h2><p>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</p><p>Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.<br>주로 for, while 등의 루프 구조를 사용한다.<br>Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.</p><p>Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.<br>복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.<br>Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.</p><h3 id=iteration-vs-recursion>Iteration vs. Recursion<a hidden class=anchor aria-hidden=true href=#iteration-vs-recursion>#</a></h3><table><thead><tr><th>특성</th><th>Iteration</th><th>Recursion</th></tr></thead><tbody><tr><td>정의</td><td>루프를 사용한 반복 실행</td><td>함수가 자기 자신을 호출</td></tr><tr><td>제어 구조</td><td>루프 (for, while 등)</td><td>함수 호출 스택</td></tr><tr><td>종료 조건</td><td>루프 조건이 거짓이 될 때</td><td>Base case에 도달할 때</td></tr><tr><td>메모리 사용</td><td>일반적으로 적음</td><td>함수 호출 스택으로 인해 많음</td></tr><tr><td>속도</td><td>대체로 빠름</td><td>대체로 느림 (오버헤드 존재)</td></tr><tr><td>코드 복잡성</td><td>간단한 문제에 적합</td><td>복잡한 문제 해결에 유용</td></tr><tr><td>무한 반복 위험</td><td>루프 조건 오류 시 발생</td><td>Base case 누락 시 발생</td></tr><tr><td>문제 해결 접근</td><td>순차적 실행</td><td>분할 정복</td></tr><tr><td>가독성</td><td>단순한 경우 높음</td><td>복잡한 경우 높음</td></tr><tr><td>디버깅</td><td>상대적으로 쉬움</td><td>상대적으로 어려움</td></tr></tbody></table><p>두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.<br>Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.</p><h4 id=예시를-통한-비교>예시를 통한 비교<a hidden class=anchor aria-hidden=true href=#예시를-통한-비교>#</a></h4><p>피보나치 수열을 구하는 알고리즘을 통한 두 가지 방식의 구현:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_iterative</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 반복적 방식으로 피보나치 수열의 n번째 값을 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 이전 두 수를 저장할 변수 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># n-1번 반복하면서 다음 피보나치 수를 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span><span class=p>,</span> <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=p>,</span> <span class=n>prev</span> <span class=o>+</span> <span class=n>current</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>current</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 재귀적 방식으로 피보나치 수열의 n번째 값을 계산</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기저 조건</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=c1># 재귀 단계: f(n) = f(n-1) + f(n-2)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행 예시</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Iterative result: </span><span class=si>{</span><span class=n>fibonacci_iterative</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 5</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Recursive result: </span><span class=si>{</span><span class=n>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 5</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Recursion</h2></header><div class=entry-content><p>재귀 (Recursion) 재귀는 컴퓨터 과학과 수학에서 매우 중요한 문제 해결 기법으로, 자기 자신을 호출하는 함수나 알고리즘을 통해 복잡한 문제를 더 작고 동일한 형태의 하위 문제로 나누어 해결하는 방법이다.
재귀는 복잡한 문제를 더 작고 관리하기 쉬운 부분으로 나누는 강력한 문제 해결 기법이다.
재귀적 접근법은 많은 컴퓨터 과학 알고리즘과 자료구조의 기반이 된다.
효과적인 재귀 알고리즘을 작성하려면 기저 조건을 명확히 정의하고, 문제를 적절히 분해하며, 필요한 경우 최적화 기법을 사용해야 한다.
재귀에 익숙해지면 이전에는 복잡하게만 보였던 많은 문제를 우아하고 효율적으로 해결할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-10-14 13:27:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Recursion" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/recursion/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>