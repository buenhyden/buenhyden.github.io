<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Algorithmic Thinking | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Algorithmic-Thinking"><meta name=description content="알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Algorithmic Thinking"><meta property="og:description" content="알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Algorithmic Thinking"><meta name=twitter:description content="알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Algorithmic Thinking","item":"https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Algorithmic Thinking</h1><div class=post-description>알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.</div></header><div class=post-content><h2 id=algorithmic-thinking>Algorithmic Thinking<a hidden class=anchor aria-hidden=true href=#algorithmic-thinking>#</a></h2><p>알고리즘적 사고는 현대 디지털 사회에서 문제 해결의 핵심이 되는 인지적 접근 방식.<br>이는 단순히 컴퓨터 프로그래밍에만 국한되지 않고, 다양한 분야에서 체계적이고 효율적인 문제 해결을 위한 사고 방식으로 발전해왔다.</p><h3 id=정의와-본질>정의와 본질<a hidden class=anchor aria-hidden=true href=#정의와-본질>#</a></h3><p>알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.</p><p>이는 다음과 같은 핵심 특성을 가진다:</p><ul><li><strong>단계적 분해</strong>: 복잡한 문제를 작고 관리 가능한 부분들로 나누는 능력</li><li><strong>논리적 순서화</strong>: 문제 해결 단계를 효율적이고 논리적인 순서로 배열하는 능력</li><li><strong>추상화</strong>: 문제의 본질을 파악하고 불필요한 세부사항을 제거하는 능력</li><li><strong>패턴 인식</strong>: 문제들 사이의 공통점을 찾고 일반화하는 능력</li><li><strong>효율성 고려</strong>: 자원(시간, 공간 등)을 최적화하는 해결책을 모색하는 능력</li></ul><h3 id=알고리즘적-사고의-구성-요소>알고리즘적 사고의 구성 요소<a hidden class=anchor aria-hidden=true href=#알고리즘적-사고의-구성-요소>#</a></h3><ol><li><p>문제 분해(Decomposition)<br>복잡한 문제를 더 작고 관리 가능한 부분들로 나누는 과정:</p><ul><li><strong>하향식 분해</strong>: 큰 문제를 점점 작은 문제들로 세분화</li><li><strong>모듈화</strong>: 독립적으로 해결 가능한 구성 요소들로 구조화</li><li><strong>계층적 구조화</strong>: 문제의 계층적 관계 파악</li></ul><p>예를 들어, 학교 시간표 작성 문제를 교사 할당, 교실 배정, 시간 슬롯 배치 등의 하위 문제로 분해할 수 있다.</p></li><li><p>패턴 인식(Pattern Recognition)<br>문제들 사이의 유사성을 식별하고 패턴을 발견하는 능력:</p><ul><li><strong>공통 구조 인식</strong>: 서로 다른 문제들 사이의 공통된 구조 파악</li><li><strong>해결책 재사용</strong>: 이전에 해결한 문제의 방법을 유사한 새 문제에 적용</li><li><strong>일반화</strong>: 특정 문제의 해결 방법을 더 넓은 문제 군으로 확장</li></ul><p>검색, 정렬, 그래프 순회와 같은 기본 알고리즘 패턴은 다양한 문제 상황에 적용될 수 있다.</p></li><li><p>추상화(Abstraction)<br>문제의 핵심 요소를 파악하고 불필요한 세부사항을 제거하는 과정:</p><ul><li><strong>핵심 변수 식별</strong>: 문제 해결에 중요한 변수와 그렇지 않은 변수 구분</li><li><strong>모델링</strong>: 현실 세계의 복잡한 시스템을 단순화된 모델로 표현</li><li><strong>표현 방식 선택</strong>: 문제를 표현하기 위한 적절한 자료구조와 알고리즘 선택</li></ul><p>예를 들어, 네비게이션 문제에서 도로를 그래프로, 교차로를 노드로, 도로를 간선으로 추상화할 수 있다.</p></li><li><p>알고리즘 설계(Algorithm Design)<br>문제 해결을 위한 단계적인 절차를 설계하는 과정:</p><ul><li><strong>입력과 출력 정의</strong>: 알고리즘이 받아들이는 입력과 생성해야 할 출력 명확화</li><li><strong>단계적 절차 개발</strong>: 입력을 출력으로 변환하는 명확한 단계 수립</li><li><strong>효율성 고려</strong>: 시간 및 공간 효율성을 고려한 설계</li></ul><p>알고리즘 설계는 분할 정복, 그리디, 동적 프로그래밍 등 다양한 전략을 활용할 수 있다.</p></li><li><p>평가와 디버깅(Evaluation and Debugging)<br>알고리즘의 정확성과 효율성을 평가하고 개선하는 과정:</p><ul><li><strong>정확성 검증</strong>: 알고리즘이 모든 가능한 입력에 대해 올바른 결과를 생성하는지 확인</li><li><strong>효율성 분석</strong>: 시간 복잡도와 공간 복잡도 분석</li><li><strong>개선 전략</strong>: 성능 병목 지점 식별 및 최적화</li></ul><p>알고리즘 평가는 이론적 분석뿐만 아니라 실험적 테스트를 통해서도 이루어진다.</p></li></ol><h3 id=알고리즘적-사고의-실천-전략>알고리즘적 사고의 실천 전략<a hidden class=anchor aria-hidden=true href=#알고리즘적-사고의-실천-전략>#</a></h3><h4 id=문제-정의-및-이해>문제 정의 및 이해<a hidden class=anchor aria-hidden=true href=#문제-정의-및-이해>#</a></h4><p>알고리즘적 접근의 첫 단계는 문제를 명확히 정의하는 것:</p><ul><li><strong>문제 명세 작성</strong>: 해결해야 할 문제를 명확한 언어로 기술</li><li><strong>입력과 출력 정의</strong>: 주어진 것과 찾아야 할 것을 명확히 구분</li><li><strong>제약 조건 파악</strong>: 시간, 공간, 자원 등의 제약사항 이해</li><li><strong>예시 탐색</strong>: 간단한 예시를 통해 문제 이해 깊이기</li></ul><p>예를 들어, &ldquo;효율적인 경로 찾기&rdquo; 대신 &ldquo;A 지점에서 B 지점까지 가장 짧은 시간에 도달할 수 있는 경로 찾기"와 같이 구체적으로 정의.</p><h4 id=효과적인-문제-해결-접근법>효과적인 문제 해결 접근법<a hidden class=anchor aria-hidden=true href=#효과적인-문제-해결-접근법>#</a></h4><p>알고리즘적 문제 해결을 위한 전략적 접근법:</p><ul><li><strong>패턴 매칭</strong>: 유사한 기존 문제와의 연관성 찾기</li><li><strong>단순화 전략</strong>: 복잡한 문제를 단순한 버전으로 먼저 해결</li><li><strong>점진적 개선</strong>: 기본 솔루션에서 시작하여 단계적으로 개선</li><li><strong>브레인스토밍</strong>: 다양한 접근법을 자유롭게 탐색</li><li><strong>역방향 사고</strong>: 목표에서 시작하여 초기 상태로 거슬러 올라가는 방식</li></ul><p>복잡한 문제는 종종 &ldquo;분할 정복(Divide and Conquer)&rdquo; 접근법이 효과적.</p><h4 id=알고리즘-표현-방법>알고리즘 표현 방법<a hidden class=anchor aria-hidden=true href=#알고리즘-표현-방법>#</a></h4><p>알고리즘을 명확하게 표현하는 다양한 방법:</p><ul><li><strong>의사코드(Pseudocode)</strong>: 프로그래밍 언어와 유사하지만 더 자유로운 형식의 서술</li><li><strong>순서도(Flowchart)</strong>: 알고리즘의 흐름을 시각적으로 표현</li><li><strong>자연어 설명</strong>: 단계별 설명을 일상 언어로 서술</li><li><strong>프로그래밍 언어</strong>: 실제 코드로 구현</li></ul><p>의사코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>함수 이진탐색(배열, 대상값):
</span></span><span class=line><span class=cl>    시작 = 0
</span></span><span class=line><span class=cl>    끝 = 배열.길이 - 1
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    반복 (시작 &lt;= 끝):
</span></span><span class=line><span class=cl>        중간 = (시작 + 끝) / 2 (내림)
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        만약 배열[중간] == 대상값:
</span></span><span class=line><span class=cl>            반환 중간
</span></span><span class=line><span class=cl>        아니면 만약 배열[중간] &lt; 대상값:
</span></span><span class=line><span class=cl>            시작 = 중간 + 1
</span></span><span class=line><span class=cl>        아니면:
</span></span><span class=line><span class=cl>            끝 = 중간 - 1
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>    반환 &#34;찾지 못함&#34;
</span></span></code></pre></td></tr></table></div></div><h4 id=알고리즘-분석-및-개선>알고리즘 분석 및 개선<a hidden class=anchor aria-hidden=true href=#알고리즘-분석-및-개선>#</a></h4><p>알고리즘 성능을 분석하고 개선하는 방법:</p><ul><li><strong>시간 복잡도 분석</strong>: Big O 표기법을 사용한 실행 시간 예측</li><li><strong>공간 복잡도 분석</strong>: 메모리 사용량 평가</li><li><strong>병목 지점 식별</strong>: 성능 저하의 주요 원인 파악</li><li><strong>최적화 전략</strong>: 알고리즘 구조 개선, 캐싱, 병렬화 등 다양한 기법 적용</li></ul><p>예를 들어, 선형 탐색(O(n))을 이진 탐색(O(log n))으로 개선하거나, 버블 정렬(O(n²))을 퀵 정렬(O(n log n))로 대체하는 것이 알고리즘 개선의 예.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Recursion vs. Iteration</h2></header><div class=entry-content><p>Recursion vs. Iteration Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.
Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.
주로 for, while 등의 루프 구조를 사용한다.
Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.
Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.
복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.
Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.
Iteration vs. Recursion 특성 Iteration Recursion 정의 루프를 사용한 반복 실행 함수가 자기 자신을 호출 제어 구조 루프 (for, while 등) 함수 호출 스택 종료 조건 루프 조건이 거짓이 될 때 Base case에 도달할 때 메모리 사용 일반적으로 적음 함수 호출 스택으로 인해 많음 속도 대체로 빠름 대체로 느림 (오버헤드 존재) 코드 복잡성 간단한 문제에 적합 복잡한 문제 해결에 유용 무한 반복 위험 루프 조건 오류 시 발생 Base case 누락 시 발생 문제 해결 접근 순차적 실행 분할 정복 가독성 단순한 경우 높음 복잡한 경우 높음 디버깅 상대적으로 쉬움 상대적으로 어려움 두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.
Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.
...</p></div><footer class=entry-footer><span title='2024-10-06 11:03:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Recursion vs. Iteration" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/implementation-strategies/iteration-vs-recursion/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>