<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Primitive vs Non-Primitive structure | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Primitive-structure,Non-Primitive-structure"><meta name=description content="Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Primitive vs Non-Primitive structure"><meta property="og:description" content="Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-12T08:39:00+00:00"><meta property="article:modified_time" content="2024-10-12T08:39:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Primitive-Structure"><meta property="article:tag" content="Non-Primitive-Structure"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Primitive vs Non-Primitive structure"><meta name=twitter:description content="Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":5,"name":"Primitive vs Non-Primitive structure","item":"https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Primitive vs Non-Primitive structure","name":"Primitive vs Non-Primitive structure","description":"Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Primitive-structure","Non-Primitive-structure"],"articleBody":"Primitive Data Structure vs. Non-Primitive Data Structure Primitive Data Structure Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.\n이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.\n주요 특징 단순성: 가장 기본적이고 이해하기 쉬운 데이터 타입이다. 고정 크기: 일반적으로 고정된 메모리 크기를 가진다. 효율성: 메모리 사용과 접근 시간 측면에서 매우 효율적이다. 직접 표현: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다. 값 의미론: 변수에 실제 값이 직접 저장된다. 스택 할당: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다. 주요 primitive data structure들을 비교 분석하여 정리한 표:\n데이터 타입 설명 비트 수 값 범위 특징 Java JavaScript Python Go Boolean 참/거짓 값을 나타내는 논리 데이터 타입 1 비트 또는 1 바이트 true/false 조건문과 논리 연산에 사용 boolean Boolean bool bool Character 단일 문자를 나타내는 데이터 타입 16 비트 (Java), 8 비트 (대부분) U+0000 ~ U+FFFF (Java) 문자 인코딩에 따라 다름 char - - byte (uint8) String 문자열을 나타내는 데이터 타입 가변 제한 없음 (메모리 한계까지) 불변(Java, Python), 가변(JavaScript) String String str string Float (Half Precision) 16비트 부동 소수점 16 비트 ±6.10 × 10^−5 ~ ±6.55 × 10^4 정밀도 낮음, 저장 공간 절약 - - - float16 (패키지) Float (Single Precision) 32비트 부동 소수점 32 비트 ±1.18 × 10^−38 ~ ±3.4 × 10^38 일반적인 실수 계산에 사용 float Number float float32 Float (Double Precision) 64비트 부동 소수점 64 비트 ±2.23 × 10^−308 ~ ±1.80 × 10^308 높은 정밀도 필요 시 사용 double Number float float64 Float (Quadruple Precision) 128비트 부동 소수점 128 비트 ±3.36 × 10^−4932 ~ ±1.18 × 10^4932 매우 높은 정밀도, 특수 용도 - - Decimal (모듈) - Integer (Byte) 8비트 정수 8 비트 -128 ~ 127 작은 범위의 정수에 사용 byte - int int8 Integer (Short) 16비트 정수 16 비트 -32,768 ~ 32,767 중간 범위의 정수에 사용 short - int int16 Integer (Int) 32비트 정수 32 비트 -2^31 ~ 2^31 - 1 가장 일반적으로 사용되는 정수 타입 int Number int int Integer (Long) 64비트 정수 64 비트 -2^63 ~ 2^63 - 1 매우 큰 정수 값에 사용 long BigInt int int64 사용법:\nJava: Boolean: boolean b = true; Character: char c = 'A'; String: String s = \"Hello\"; Float: float f = 3.14f; double d = 3.14; Integer: byte b = 100; short s = 1000; int i = 10000; long l = 1000000L; JavaScript: Boolean: let b = true; String: let s = \"Hello\"; Number: let n = 3.14; (모든 숫자는 64비트 부동 소수점) BigInt: let bi = 1234567890123456789n; Python: Boolean: b = True String: s = \"Hello\" Float: f = 3.14 Integer: i = 10000 (자동으로 크기 조정) Go: Boolean: var b bool = true String: var s string = \"Hello\" Float: var f float32 = 3.14 var d float64 = 3.14 Integer: var i int = 10000 var l int64 = 1000000 각 언어별 특징:\nJava: 가장 세분화된 데이터 타입 지원 JavaScript: 동적 타입 언어로, 대부분의 숫자를 Number로 처리 Python: 동적 타입 언어로, 정수와 부동소수점을 자동으로 처리 Go: 정적 타입 언어로, 명시적인 타입 선언 필요 Non-Primitive Data Structure Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다. 이는 프로그래밍 언어에서 기본적으로 제공하는 원시 자료형을 조합하여 만든 사용자 정의 자료구조라고도 볼 수 있다.\n주요 특징 복합성: 여러 원시 자료형을 조합하여 만들어진 복합적인 구조를 가진다. 유연성: 데이터의 저장, 접근, 수정이 더 유연하게 이루어질 수 있다. 동적 크기: 대부분의 비원시 자료구조는 크기가 동적으로 변할 수 있다. 참조 타입: 변수에 값 대신 메모리 주소를 저장한다. 분류 Non-primitive data structure는 크게 두 가지로 분류된다.\n구분 Linear Data Structure Non-Linear Data Structure 정의 데이터 요소가 순차적으로 배열되어 각 요소가 이전 및 다음 요소와 연결된 구조 데이터 요소가 계층적으로 구성되어 여러 경로로 연결될 수 있는 구조 특징 - 단일 레벨 구조\n- 한 번의 실행으로 모든 요소 순회 가능\n- 구현이 상대적으로 간단\n- 메모리 사용이 덜 효율적 - 다중 레벨 구조\n- 한 번의 실행으로 모든 요소 순회 불가\n- 구현이 상대적으로 복잡\n- 메모리 사용이 더 효율적 주요 유형 Array, Linked List, Stack, Queue, Deque Graph, Hash-based Structure, Tree, Heap 각 데이터 구조의 특징과 주요 프로그래밍 언어에서의 지원 여부 및 사용법 데이터 구조 유형 특징 Java JavaScript Python Go Array Linear 연속된 메모리 위치에 요소 저장, 인덱스로 빠른 접근 가능 기본 지원 기본 지원 기본 지원 (List) 기본 지원 Linked List Linear 노드가 다음 노드를 가리키는 구조, 삽입/삭제 효율적 java.util.LinkedList 라이브러리 필요 라이브러리 필요 container/list Stack Linear LIFO 원칙, 푸시/팝 연산 java.util.Stack 배열로 구현 가능 리스트로 구현 가능 슬라이스로 구현 가능 Queue Linear FIFO 원칙, 인큐/디큐 연산 java.util.Queue 배열로 구현 가능 queue 모듈 container/list Deque Linear 양쪽 끝에서 삽입/삭제 가능 java.util.Deque 배열로 구현 가능 collections.deque container/list Graph Non-Linear 노드와 엣지로 구성, 복잡한 관계 표현 사용자 정의 필요 라이브러리 필요 networkx 라이브러리 사용자 정의 필요 Hash-based Structure Non-Linear 키-값 쌍으로 데이터 저장, 빠른 검색 java.util.HashMap Object, Map dict map Tree Non-Linear 계층적 구조, 루트와 자식 노드로 구성 사용자 정의 필요 사용자 정의 필요 사용자 정의 필요 사용자 정의 필요 Heap Non-Linear 완전 이진 트리 기반, 최대/최소 값 빠른 접근 java.util.PriorityQueue 사용자 정의 필요 heapq 모듈 container/heap 각 언어별 특징:\nJava: 대부분의 데이터 구조를 기본적으로 지원하거나 java.util 패키지를 통해 제공한다. JavaScript: 배열과 객체를 기본으로 제공하며, 다른 구조는 사용자 정의나 라이브러리를 통해 구현해야 한다. Python: 리스트, 딕셔너리, 세트 등 다양한 데이터 구조를 기본으로 제공하며, 추가 모듈을 통해 더 많은 구조를 지원한다. Go: 배열, 슬라이스, 맵을 기본으로 제공하며, container 패키지를 통해 list, heap 등을 지원한다. 이 데이터 구조들은 각각의 특성에 따라 다양한 상황에서 효율적으로 사용될 수 있으며, 프로그래밍 언어별로 지원 방식이 다르므로 적절한 선택이 중요하다.\nPrimitive Data Structure vs. Non-Primitive Data Structure 비교 특성 Primitive Data Structure Non-Primitive Data Structure 정의 프로그래밍 언어에 내장된 기본 데이터 타입 기본 데이터 타입을 사용하여 구축된 복잡한 데이터 구조 예시 정수, 실수, 문자, 불리언 배열, 연결 리스트, 스택, 큐, 트리, 그래프 크기 고정 크기 동적 크기 가능 복잡성 단순함 복잡함 메모리 효율성 높음 상대적으로 낮음 구현 언어에 내장됨 사용자 정의 가능 NULL 값 일반적으로 허용하지 않음 허용 가능 연산 기본 연산만 지원 복잡한 연산 및 메서드 지원 추상화 수준 낮음 높음 사용 목적 단순한 데이터 표현 복잡한 데이터 관계 및 구조 표현 공통점:\n둘 다 데이터를 저장하고 관리하는 데 사용된다. 프로그래밍에서 중요한 역할을 한다. 특정 연산과 조작이 가능하다. 차이점:\n복잡성: Primitive는 단순하고, Non-Primitive는 복잡하다. 크기: Primitive는 고정 크기, Non-Primitive는 동적 크기가 가능하다. 구현: Primitive는 언어에 내장되어 있고, Non-Primitive는 사용자가 정의할 수 있다. 유연성: Non-Primitive는 더 유연하고 다양한 데이터 관계를 표현할 수 있다. 메모리 사용: Primitive가 일반적으로 더 효율적이다. 기능: Non-Primitive는 더 복잡한 연산과 메서드를 제공한다. Primitive data structure는 기본적이고 효율적인 데이터 표현에 사용되며, Non-Primitive data structure는 복잡한 데이터 관계와 구조를 표현하는 데 사용된다. 프로그래밍에서는 두 유형을 적절히 조합하여 효율적이고 강력한 애플리케이션을 구축한다.\n참고 및 출처 ","wordCount":"1085","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-12T08:39:00Z","dateModified":"2024-10-12T08:39:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/primitive-vs-non-primitive-structure/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Primitive vs Non-Primitive structure</h1><div class=post-description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</div><div class=post-meta><span title='2024-10-12 08:39:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20&%20Algorithms/Overview/Data%20Structures/Primitive-vs-Non-Primitive-structure.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#primitive-data-structure-vs-non-primitive-data-structure>Primitive Data Structure vs. Non-Primitive Data Structure</a><ul><li><a href=#primitive-data-structure>Primitive Data Structure</a></li><li><a href=#non-primitive-data-structure>Non-Primitive Data Structure</a></li><li><a href=#primitive-data-structure-vs-non-primitive-data-structure-비교>Primitive Data Structure vs. Non-Primitive Data Structure 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=primitive-data-structure-vs-non-primitive-data-structure>Primitive Data Structure vs. Non-Primitive Data Structure<a hidden class=anchor aria-hidden=true href=#primitive-data-structure-vs-non-primitive-data-structure>#</a></h2><h3 id=primitive-data-structure>Primitive Data Structure<a hidden class=anchor aria-hidden=true href=#primitive-data-structure>#</a></h3><p>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이다.<br>이들은 단일 값을 표현하며, 더 이상 분해할 수 없는 가장 작은 단위의 데이터 구조이다.</p><h4 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h4><ol><li><strong>단순성</strong>: 가장 기본적이고 이해하기 쉬운 데이터 타입이다.</li><li><strong>고정 크기</strong>: 일반적으로 고정된 메모리 크기를 가진다.</li><li><strong>효율성</strong>: 메모리 사용과 접근 시간 측면에서 매우 효율적이다.</li><li><strong>직접 표현</strong>: 컴퓨터 하드웨어에서 직접 지원되는 데이터 타입이다.</li><li><strong>값 의미론</strong>: 변수에 실제 값이 직접 저장된다.</li><li><strong>스택 할당</strong>: 주로 스택 메모리에 할당되어 빠른 접근이 가능하다.</li></ol><p>주요 primitive data structure들을 비교 분석하여 정리한 표:</p><table><thead><tr><th>데이터 타입</th><th>설명</th><th>비트 수</th><th>값 범위</th><th>특징</th><th>Java</th><th>JavaScript</th><th>Python</th><th>Go</th></tr></thead><tbody><tr><td>Boolean</td><td>참/거짓 값을 나타내는 논리 데이터 타입</td><td>1 비트 또는 1 바이트</td><td>true/false</td><td>조건문과 논리 연산에 사용</td><td>boolean</td><td>Boolean</td><td>bool</td><td>bool</td></tr><tr><td>Character</td><td>단일 문자를 나타내는 데이터 타입</td><td>16 비트 (Java), 8 비트 (대부분)</td><td>U+0000 ~ U+FFFF (Java)</td><td>문자 인코딩에 따라 다름</td><td>char</td><td>-</td><td>-</td><td>byte (uint8)</td></tr><tr><td>String</td><td>문자열을 나타내는 데이터 타입</td><td>가변</td><td>제한 없음 (메모리 한계까지)</td><td>불변(Java, Python), 가변(JavaScript)</td><td>String</td><td>String</td><td>str</td><td>string</td></tr><tr><td>Float (Half Precision)</td><td>16비트 부동 소수점</td><td>16 비트</td><td>±6.10 × 10^−5 ~ ±6.55 × 10^4</td><td>정밀도 낮음, 저장 공간 절약</td><td>-</td><td>-</td><td>-</td><td>float16 (패키지)</td></tr><tr><td>Float (Single Precision)</td><td>32비트 부동 소수점</td><td>32 비트</td><td>±1.18 × 10^−38 ~ ±3.4 × 10^38</td><td>일반적인 실수 계산에 사용</td><td>float</td><td>Number</td><td>float</td><td>float32</td></tr><tr><td>Float (Double Precision)</td><td>64비트 부동 소수점</td><td>64 비트</td><td>±2.23 × 10^−308 ~ ±1.80 × 10^308</td><td>높은 정밀도 필요 시 사용</td><td>double</td><td>Number</td><td>float</td><td>float64</td></tr><tr><td>Float (Quadruple Precision)</td><td>128비트 부동 소수점</td><td>128 비트</td><td>±3.36 × 10^−4932 ~ ±1.18 × 10^4932</td><td>매우 높은 정밀도, 특수 용도</td><td>-</td><td>-</td><td>Decimal (모듈)</td><td>-</td></tr><tr><td>Integer (Byte)</td><td>8비트 정수</td><td>8 비트</td><td>-128 ~ 127</td><td>작은 범위의 정수에 사용</td><td>byte</td><td>-</td><td>int</td><td>int8</td></tr><tr><td>Integer (Short)</td><td>16비트 정수</td><td>16 비트</td><td>-32,768 ~ 32,767</td><td>중간 범위의 정수에 사용</td><td>short</td><td>-</td><td>int</td><td>int16</td></tr><tr><td>Integer (Int)</td><td>32비트 정수</td><td>32 비트</td><td>-2^31 ~ 2^31 - 1</td><td>가장 일반적으로 사용되는 정수 타입</td><td>int</td><td>Number</td><td>int</td><td>int</td></tr><tr><td>Integer (Long)</td><td>64비트 정수</td><td>64 비트</td><td>-2^63 ~ 2^63 - 1</td><td>매우 큰 정수 값에 사용</td><td>long</td><td>BigInt</td><td>int</td><td>int64</td></tr></tbody></table><p>사용법:</p><ul><li>Java:<ul><li>Boolean: <code>boolean b = true;</code></li><li>Character: <code>char c = 'A';</code></li><li>String: <code>String s = "Hello";</code></li><li>Float: <code>float f = 3.14f;</code> <code>double d = 3.14;</code></li><li>Integer: <code>byte b = 100;</code> <code>short s = 1000;</code> <code>int i = 10000;</code> <code>long l = 1000000L;</code></li></ul></li><li>JavaScript:<ul><li>Boolean: <code>let b = true;</code></li><li>String: <code>let s = "Hello";</code></li><li>Number: <code>let n = 3.14;</code> (모든 숫자는 64비트 부동 소수점)</li><li>BigInt: <code>let bi = 1234567890123456789n;</code></li></ul></li><li>Python:<ul><li>Boolean: <code>b = True</code></li><li>String: <code>s = "Hello"</code></li><li>Float: <code>f = 3.14</code></li><li>Integer: <code>i = 10000</code> (자동으로 크기 조정)</li></ul></li><li>Go:<ul><li>Boolean: <code>var b bool = true</code></li><li>String: <code>var s string = "Hello"</code></li><li>Float: <code>var f float32 = 3.14</code> <code>var d float64 = 3.14</code></li><li>Integer: <code>var i int = 10000</code> <code>var l int64 = 1000000</code></li></ul></li></ul><p>각 언어별 특징:</p><ul><li>Java: 가장 세분화된 데이터 타입 지원</li><li>JavaScript: 동적 타입 언어로, 대부분의 숫자를 Number로 처리</li><li>Python: 동적 타입 언어로, 정수와 부동소수점을 자동으로 처리</li><li>Go: 정적 타입 언어로, 명시적인 타입 선언 필요</li></ul><h3 id=non-primitive-data-structure>Non-Primitive Data Structure<a hidden class=anchor aria-hidden=true href=#non-primitive-data-structure>#</a></h3><p>Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다. 이는 프로그래밍 언어에서 기본적으로 제공하는 원시 자료형을 조합하여 만든 사용자 정의 자료구조라고도 볼 수 있다.</p><h4 id=주요-특징-1>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징-1>#</a></h4><ol><li><strong>복합성</strong>: 여러 원시 자료형을 조합하여 만들어진 복합적인 구조를 가진다.</li><li><strong>유연성</strong>: 데이터의 저장, 접근, 수정이 더 유연하게 이루어질 수 있다.</li><li><strong>동적 크기</strong>: 대부분의 비원시 자료구조는 크기가 동적으로 변할 수 있다.</li><li><strong>참조 타입</strong>: 변수에 값 대신 메모리 주소를 저장한다.</li></ol><h4 id=분류>분류<a hidden class=anchor aria-hidden=true href=#분류>#</a></h4><p>Non-primitive data structure는 크게 두 가지로 분류된다.</p><table><thead><tr><th>구분</th><th>Linear Data Structure</th><th>Non-Linear Data Structure</th></tr></thead><tbody><tr><td>정의</td><td>데이터 요소가 순차적으로 배열되어 각 요소가 이전 및 다음 요소와 연결된 구조</td><td>데이터 요소가 계층적으로 구성되어 여러 경로로 연결될 수 있는 구조</td></tr><tr><td>특징</td><td>- 단일 레벨 구조<br>- 한 번의 실행으로 모든 요소 순회 가능<br>- 구현이 상대적으로 간단<br>- 메모리 사용이 덜 효율적</td><td>- 다중 레벨 구조<br>- 한 번의 실행으로 모든 요소 순회 불가<br>- 구현이 상대적으로 복잡<br>- 메모리 사용이 더 효율적</td></tr><tr><td>주요 유형</td><td>Array, Linked List, Stack, Queue, Deque</td><td>Graph, Hash-based Structure, Tree, Heap</td></tr></tbody></table><h5 id=각-데이터-구조의-특징과-주요-프로그래밍-언어에서의-지원-여부-및-사용법>각 데이터 구조의 특징과 주요 프로그래밍 언어에서의 지원 여부 및 사용법<a hidden class=anchor aria-hidden=true href=#각-데이터-구조의-특징과-주요-프로그래밍-언어에서의-지원-여부-및-사용법>#</a></h5><table><thead><tr><th>데이터 구조</th><th>유형</th><th>특징</th><th>Java</th><th>JavaScript</th><th>Python</th><th>Go</th></tr></thead><tbody><tr><td>Array</td><td>Linear</td><td>연속된 메모리 위치에 요소 저장, 인덱스로 빠른 접근 가능</td><td>기본 지원</td><td>기본 지원</td><td>기본 지원 (List)</td><td>기본 지원</td></tr><tr><td>Linked List</td><td>Linear</td><td>노드가 다음 노드를 가리키는 구조, 삽입/삭제 효율적</td><td>java.util.LinkedList</td><td>라이브러리 필요</td><td>라이브러리 필요</td><td>container/list</td></tr><tr><td>Stack</td><td>Linear</td><td>LIFO 원칙, 푸시/팝 연산</td><td>java.util.Stack</td><td>배열로 구현 가능</td><td>리스트로 구현 가능</td><td>슬라이스로 구현 가능</td></tr><tr><td>Queue</td><td>Linear</td><td>FIFO 원칙, 인큐/디큐 연산</td><td>java.util.Queue</td><td>배열로 구현 가능</td><td>queue 모듈</td><td>container/list</td></tr><tr><td>Deque</td><td>Linear</td><td>양쪽 끝에서 삽입/삭제 가능</td><td>java.util.Deque</td><td>배열로 구현 가능</td><td>collections.deque</td><td>container/list</td></tr><tr><td>Graph</td><td>Non-Linear</td><td>노드와 엣지로 구성, 복잡한 관계 표현</td><td>사용자 정의 필요</td><td>라이브러리 필요</td><td>networkx 라이브러리</td><td>사용자 정의 필요</td></tr><tr><td>Hash-based Structure</td><td>Non-Linear</td><td>키-값 쌍으로 데이터 저장, 빠른 검색</td><td>java.util.HashMap</td><td>Object, Map</td><td>dict</td><td>map</td></tr><tr><td>Tree</td><td>Non-Linear</td><td>계층적 구조, 루트와 자식 노드로 구성</td><td>사용자 정의 필요</td><td>사용자 정의 필요</td><td>사용자 정의 필요</td><td>사용자 정의 필요</td></tr><tr><td>Heap</td><td>Non-Linear</td><td>완전 이진 트리 기반, 최대/최소 값 빠른 접근</td><td>java.util.PriorityQueue</td><td>사용자 정의 필요</td><td>heapq 모듈</td><td>container/heap</td></tr></tbody></table><p>각 언어별 특징:</p><ul><li>Java: 대부분의 데이터 구조를 기본적으로 지원하거나 java.util 패키지를 통해 제공한다.</li><li>JavaScript: 배열과 객체를 기본으로 제공하며, 다른 구조는 사용자 정의나 라이브러리를 통해 구현해야 한다.</li><li>Python: 리스트, 딕셔너리, 세트 등 다양한 데이터 구조를 기본으로 제공하며, 추가 모듈을 통해 더 많은 구조를 지원한다.</li><li>Go: 배열, 슬라이스, 맵을 기본으로 제공하며, container 패키지를 통해 list, heap 등을 지원한다.</li></ul><p>이 데이터 구조들은 각각의 특성에 따라 다양한 상황에서 효율적으로 사용될 수 있으며, 프로그래밍 언어별로 지원 방식이 다르므로 적절한 선택이 중요하다.</p><h3 id=primitive-data-structure-vs-non-primitive-data-structure-비교>Primitive Data Structure vs. Non-Primitive Data Structure 비교<a hidden class=anchor aria-hidden=true href=#primitive-data-structure-vs-non-primitive-data-structure-비교>#</a></h3><table><thead><tr><th>특성</th><th>Primitive Data Structure</th><th>Non-Primitive Data Structure</th></tr></thead><tbody><tr><td>정의</td><td>프로그래밍 언어에 내장된 기본 데이터 타입</td><td>기본 데이터 타입을 사용하여 구축된 복잡한 데이터 구조</td></tr><tr><td>예시</td><td>정수, 실수, 문자, 불리언</td><td>배열, 연결 리스트, 스택, 큐, 트리, 그래프</td></tr><tr><td>크기</td><td>고정 크기</td><td>동적 크기 가능</td></tr><tr><td>복잡성</td><td>단순함</td><td>복잡함</td></tr><tr><td>메모리 효율성</td><td>높음</td><td>상대적으로 낮음</td></tr><tr><td>구현</td><td>언어에 내장됨</td><td>사용자 정의 가능</td></tr><tr><td>NULL 값</td><td>일반적으로 허용하지 않음</td><td>허용 가능</td></tr><tr><td>연산</td><td>기본 연산만 지원</td><td>복잡한 연산 및 메서드 지원</td></tr><tr><td>추상화 수준</td><td>낮음</td><td>높음</td></tr><tr><td>사용 목적</td><td>단순한 데이터 표현</td><td>복잡한 데이터 관계 및 구조 표현</td></tr></tbody></table><p>공통점:</p><ol><li>둘 다 데이터를 저장하고 관리하는 데 사용된다.</li><li>프로그래밍에서 중요한 역할을 한다.</li><li>특정 연산과 조작이 가능하다.</li></ol><p>차이점:</p><ol><li>복잡성: Primitive는 단순하고, Non-Primitive는 복잡하다.</li><li>크기: Primitive는 고정 크기, Non-Primitive는 동적 크기가 가능하다.</li><li>구현: Primitive는 언어에 내장되어 있고, Non-Primitive는 사용자가 정의할 수 있다.</li><li>유연성: Non-Primitive는 더 유연하고 다양한 데이터 관계를 표현할 수 있다.</li><li>메모리 사용: Primitive가 일반적으로 더 효율적이다.</li><li>기능: Non-Primitive는 더 복잡한 연산과 메서드를 제공한다.</li></ol><p>Primitive data structure는 기본적이고 효율적인 데이터 표현에 사용되며, Non-Primitive data structure는 복잡한 데이터 관계와 구조를 표현하는 데 사용된다.
프로그래밍에서는 두 유형을 적절히 조합하여 효율적이고 강력한 애플리케이션을 구축한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/primitive-structure/>Primitive-Structure</a></li><li><a href=https://buenhyden.github.io/tags/non-primitive-structure/>Non-Primitive-Structure</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/overview/data-structures/linear-vs-non-linear-structure/><span class=title>« Prev</span><br><span>Linear Data Structure vs Non-Linear Data Structure</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/submodule-vs-subtree/><span class=title>Next »</span><br><span>Git Submodule vs. Subtree</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>