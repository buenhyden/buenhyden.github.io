<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>백트래킹 (Backtracking) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Backtracking"><meta name=description content="백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="백트래킹 (Backtracking)"><meta property="og:description" content="백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="백트래킹 (Backtracking)"><meta name=twitter:description content="백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":4,"name":"백트래킹 (Backtracking)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>백트래킹 (Backtracking)</h1><div class=post-description>백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.</div></header><div class=post-content><h2 id=백트래킹-backtracking>백트래킹 (Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹-backtracking>#</a></h2><p>백트래킹은 해결책을 찾는 과정에서 후보군을 구축하다가 해당 후보군이 해결책이 될 수 없다고 판단되면, 즉시 이전 단계로 돌아가서(백트랙) 다른 후보군을 탐색하는 문제 해결 전략이다.</p><p>알고리즘의 효율성을 높이는 중요한 기법으로, 완전 탐색보다 효율적으로 문제를 해결할 수 있게 해준다.</p><p>백트래킹은 조합 최적화 문제를 해결하는 강력한 알고리즘 패러다임이다.<br>모든 가능한 해결책을 체계적으로 탐색하면서도, 불가능한 경로를 조기에 차단하여 효율성을 높이는 특징이 있다.<br>N-Queen, 스도쿠, 미로 찾기, 조합 문제 등 다양한 영역에서 활용되며, 복잡한 문제를 해결하는 데 필수적인 도구이다.</p><p>효율적인 백트래킹 알고리즘을 작성하기 위해서는 유망함을 판단하는 조건을 잘 설계하는 것이 핵심이다.<br>이를 통해 최대한 많은 불필요한 탐색을 줄이고, 해결책을 빠르게 찾을 수 있다.</p><h3 id=백트래킹의-개념>백트래킹의 개념<a hidden class=anchor aria-hidden=true href=#백트래킹의-개념>#</a></h3><p>백트래킹은 가능한 모든 해결책을 탐색하는 브루트 포스(brute force) 방식을 개선한 알고리즘이다.<br>&lsquo;되돌아가기&rsquo;라는 이름에서 알 수 있듯이, 이 방법은 해결책을 찾아가는 과정에서 더 이상 진행이 불가능하다고 판단되면 이전 단계로 돌아가(백트래킹) 다른 가능성을 시도한다.</p><p>쉽게 말해서, 백트래킹은 &ldquo;일단 한 방향으로 가보고, 그 방향이 막히면 다시 돌아와서 다른 방향으로 시도하는&rdquo; 전략이다.<br>미로를 탐색하는 사람을 상상해보자. 갈림길에서 한 방향을 선택하고, 막다른 길에 도달하면 마지막 갈림길로 돌아와 다른 방향을 시도하는 것과 같다.</p><p>특정 조건을 만족하지 않으면 더 이상 탐색하지 않고 이전 단계로 돌아가는 &lsquo;가지치기(pruning)&lsquo;를 통해 불필요한 연산을 줄인다.</p><h3 id=백트래킹의-핵심-개념>백트래킹의 핵심 개념<a hidden class=anchor aria-hidden=true href=#백트래킹의-핵심-개념>#</a></h3><ul><li><strong>상태 공간 트리(State Space Tree)</strong>: 문제의 모든 가능한 해결책을 나타내는 트리 구조</li><li><strong>유망함(Promising)</strong>: 현재 상태가 해결책으로 이어질 가능성이 있는지 판단하는 조건</li><li><strong>가지치기(Pruning)</strong>: 유망하지 않은 분기를 제거하여 탐색 효율을 높이는 과정</li></ul><h3 id=백트래킹의-동작-원리>백트래킹의 동작 원리<a hidden class=anchor aria-hidden=true href=#백트래킹의-동작-원리>#</a></h3><p>백트래킹은 다음과 같은 단계로 작동한다:</p><ol><li>해결책의 일부분을 구성하고 있는 현재 상태에서 시작한다.</li><li>현재 상태가 유망한지(promising) 검사한다.</li><li>유망하다면, 다음 단계로 진행한다.</li><li>유망하지 않다면, 이전 단계로 돌아가(backtrack) 다른 선택지를 탐색한다.</li><li>해결책을 찾거나 모든 가능성을 탐색할 때까지 반복한다.</li></ol><p><figure><img alt=Backtracking loading=lazy src=/img/backtracking.png><figcaption>Source: https://www.geeksforgeeks.org/introduction-to-backtracking-2/</figcaption></figure></p><ul><li>그림에서 보여지는 것처럼,<ul><li><strong>IS</strong>: 재귀 호출이 유효한 솔루션을 찾기 시작하는 <strong>초기 상태</strong>를 나타낸다.</li><li><strong>C</strong>: 재귀 호출에 대한 다른 <strong><strong>체크포인트를</strong></strong> 나타낸다.</li><li><strong>TN</strong>: 더 이상 재귀 호출을 할 수 없는 <strong><strong>터미널 노드를</strong></strong> 나타낸다. 이러한 노드는 재귀의 기본 사례로 작용하며 이 상태에서 현재 솔루션이 유효한지 여부를 판별한다.</li></ul></li><li>각 체크포인트에서 프로그램은 몇 가지 결정을 내리고 다른 체크포인트로 이동하여 최종 노드에 도달한 후, 솔루션이 유효한지 여부를 확인한 후 프로그램은 체크포인트로 돌아가 다른 경로를 탐색하기 시작한다.<br>예를 들어 위의 이미지에서 <strong><strong>TN1…TN5</strong></strong> 는 솔루션이 허용되지 않는 최종 노드이고, <strong><strong>TN6</strong></strong> 은 유효한 솔루션을 찾은 상태이다.</li><li>이미지 속 뒤로 가는 화살표는 동작의 후퇴를 보여주며, 어떤 체크포인트에서 변경한 내용을 되돌리는 것을 의미한다.</li></ul><h3 id=백트래킹-구현-방법>백트래킹 구현 방법<a hidden class=anchor aria-hidden=true href=#백트래킹-구현-방법>#</a></h3><p>백트래킹은 보통 재귀 함수를 사용하여 구현한다.<br>파이썬으로 구현한 일반적인 백트래킹 알고리즘의 틀은 다음과 같다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 종료 조건 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>is_solution</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 해결책 발견</span>
</span></span><span class=line><span class=cl>        <span class=n>process_solution</span><span class=p>(</span><span class=n>candidate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 다음 단계에서 가능한 선택지 탐색</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>next_candidate</span> <span class=ow>in</span> <span class=n>get_candidates</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 유망성 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_promising</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 선택한 후보를 해결책에 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>candidate</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 다음 단계 재귀 호출</span>
</span></span><span class=line><span class=cl>            <span class=n>backtrack</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 백트래킹: 해당 후보를 제거하고 다른 후보 탐색</span>
</span></span><span class=line><span class=cl>            <span class=n>candidate</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=백트래킹이-효과적인-문제-유형>백트래킹이 효과적인 문제 유형<a hidden class=anchor aria-hidden=true href=#백트래킹이-효과적인-문제-유형>#</a></h3><p>백트래킹은 다음과 같은 문제 유형에 특히 효과적이다:</p><ol><li><strong>조합 문제</strong>: 특정 조건을 만족하는 조합이나 순열을 찾는 문제</li><li><strong>제약 만족 문제</strong>: 여러 제약 조건을 만족하는 해를 찾는 문제 (스도쿠, N-Queens 등)</li><li><strong>결정 문제</strong>: 특정 조건을 만족하는 해가 존재하는지 판단하는 문제</li><li><strong>최적화 문제</strong>: 여러 가능한 해 중에서 최적의 해를 찾는 문제 (단, 가지치기가 효과적일 때)</li></ol><h3 id=백트래킹-최적화-기법>백트래킹 최적화 기법<a hidden class=anchor aria-hidden=true href=#백트래킹-최적화-기법>#</a></h3><p>백트래킹 알고리즘의 성능을 향상시키기 위한 몇 가지 기법이 있다:</p><ol><li><strong>가지치기(Pruning)</strong>: 유망하지 않은 경로를 일찍 제거하여 탐색 공간을 줄인다.</li><li><strong>순서 최적화</strong>: 가장 제약이 많은 변수나 값부터 시도하여 실패 가능성이 높은 경로를 먼저 탐색한다.</li><li><strong>메모이제이션(Memoization)</strong>: 이미 계산한 부분 문제의 결과를 저장하여 재계산을 방지한다.</li><li><strong>선 제약 검사(Forward Checking)</strong>: 변수에 값을 할당할 때마다 관련된 다른 변수의 도메인을 업데이트한다.</li></ol><h3 id=실제-문제에-백트래킹-적용하기>실제 문제에 백트래킹 적용하기<a hidden class=anchor aria-hidden=true href=#실제-문제에-백트래킹-적용하기>#</a></h3><p>백트래킹을 실제 문제에 적용하는 방법은 다음과 같다:</p><ol><li><strong>문제 분석</strong>: 문제의 상태 공간과 제약 조건을 명확히 이해한다.</li><li><strong>상태 표현 정의</strong>: 문제의 상태를 어떻게 표현할지 결정한다.</li><li><strong>유효성 검사 함수 개발</strong>: 특정 상태가 문제의 제약 조건을 만족하는지 확인하는 함수를 작성한다.</li><li><strong>종료 조건 정의</strong>: 완전한 해를 찾았거나 더 이상 탐색할 필요가 없는 조건을 정의한다.</li><li><strong>백트래킹 함수 구현</strong>: 상태 공간을 재귀적으로 탐색하는 백트래킹 함수를 구현한다.</li></ol><h3 id=개발자가-알아야-할-백트래킹-팁>개발자가 알아야 할 백트래킹 팁<a hidden class=anchor aria-hidden=true href=#개발자가-알아야-할-백트래킹-팁>#</a></h3><ol><li><strong>종료 조건 명확화</strong>: 재귀 함수의 종료 조건을 명확히 정의하여 무한 재귀를 방지한다.</li><li><strong>상태 관리</strong>: 백트래킹 시 상태를 올바르게 복원하여 다른 경로에 영향을 주지 않도록 한다.</li><li><strong>가지치기 최적화</strong>: 가능한 한 일찍 유망하지 않은 경로를 제거하여 효율성을 높인다.</li><li><strong>디버깅 전략</strong>: 각 재귀 호출의 상태를 시각화하거나 로깅하여 디버깅을 용이하게 한다.</li><li><strong>테스트 케이스 작성</strong>: 작은 입력부터 시작하여 알고리즘의 정확성을 검증한다.</li></ol><h3 id=백트래킹의-장단점>백트래킹의 장단점<a hidden class=anchor aria-hidden=true href=#백트래킹의-장단점>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li>모든 가능한 해결책을 찾을 수 있다.</li><li>가지치기를 통해 불필요한 연산을 줄인다.</li><li>공간 효율성이 좋다(깊이에 비례한 메모리만 사용).</li></ul><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li>최악의 경우 지수 시간 복잡도를 가질 수 있다.</li><li>구현이 복잡할 수 있다.</li><li>문제의 크기가 커지면 실행 시간이 급격히 증가할 수 있다.</li></ul><h3 id=백트래킹의-시간-복잡도>백트래킹의 시간 복잡도<a hidden class=anchor aria-hidden=true href=#백트래킹의-시간-복잡도>#</a></h3><p>백트래킹의 시간 복잡도는 문제마다 다르지만, 일반적으로 O(b^d)로 표현된다:</p><ul><li>b: 각 단계에서 가능한 선택지의 수(분기 계수)</li><li>d: 해결책을 찾기 위한 최대 깊이</li></ul><p>백트래킹은 가지치기를 통해 탐색 공간을 줄이지만, 최악의 경우 모든 경우를 탐색해야 할 수도 있다. 하지만 실제로는 많은 가지를 제거하기 때문에 완전 탐색보다 훨씬 효율적이다.</p><h3 id=백트래킹-대표-응용-사례>백트래킹 대표 응용 사례<a hidden class=anchor aria-hidden=true href=#백트래킹-대표-응용-사례>#</a></h3><h4 id=n-queen-문제>N-Queen 문제<a hidden class=anchor aria-hidden=true href=#n-queen-문제>#</a></h4><p>N x N 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_safe</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 같은 열에 퀸이 있는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>col</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 대각선 위치에 퀸이 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>abs</span><span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>col</span><span class=p>)</span> <span class=o>==</span> <span class=nb>abs</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 퀸을 배치했으면 해결책 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>solutions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>board</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 행의 각 열에 퀸 배치 시도</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_safe</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=n>col</span>  <span class=c1># 퀸 배치</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 다음 행으로 진행</span>
</span></span><span class=line><span class=cl>                <span class=c1># 백트래킹 (명시적으로 할 필요는 없지만 개념상 이 위치)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=n>solutions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>([</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solutions</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=스도쿠-풀이>스도쿠 풀이<a hidden class=anchor aria-hidden=true href=#스도쿠-풀이>#</a></h4><p>9x9 격자에 1~9까지의 숫자를 중복 없이 배치하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span><span class=lnt id=hl-2-39><a class=lnlinks href=#hl-2-39>39</a>
</span><span class=lnt id=hl-2-40><a class=lnlinks href=#hl-2-40>40</a>
</span><span class=lnt id=hl-2-41><a class=lnlinks href=#hl-2-41>41</a>
</span><span class=lnt id=hl-2-42><a class=lnlinks href=#hl-2-42>42</a>
</span><span class=lnt id=hl-2-43><a class=lnlinks href=#hl-2-43>43</a>
</span><span class=lnt id=hl-2-44><a class=lnlinks href=#hl-2-44>44</a>
</span><span class=lnt id=hl-2-45><a class=lnlinks href=#hl-2-45>45</a>
</span><span class=lnt id=hl-2-46><a class=lnlinks href=#hl-2-46>46</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_sudoku</span><span class=p>(</span><span class=n>board</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_valid</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span> <span class=n>num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 같은 행에 중복 체크</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>x</span><span class=p>]</span> <span class=o>==</span> <span class=n>num</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 같은 열에 중복 체크</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>x</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>==</span> <span class=n>num</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 3x3 박스 내 중복 체크</span>
</span></span><span class=line><span class=cl>        <span class=n>box_row</span><span class=p>,</span> <span class=n>box_col</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=p>(</span><span class=n>row</span> <span class=o>//</span> <span class=mi>3</span><span class=p>),</span> <span class=mi>3</span> <span class=o>*</span> <span class=p>(</span><span class=n>col</span> <span class=o>//</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>box_row</span> <span class=o>+</span> <span class=n>i</span><span class=p>][</span><span class=n>box_col</span> <span class=o>+</span> <span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>num</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># 빈 칸 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>9</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># 빈 칸</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 가능한 숫자 시도 (1~9)</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=n>is_valid</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span> <span class=n>num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                            <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>=</span> <span class=n>num</span>  <span class=c1># 숫자 배치</span>
</span></span><span class=line><span class=cl>                            
</span></span><span class=line><span class=cl>                            <span class=c1># 재귀적으로 다음 빈 칸 해결 시도</span>
</span></span><span class=line><span class=cl>                            <span class=k>if</span> <span class=n>backtrack</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                            
</span></span><span class=line><span class=cl>                            <span class=c1># 실패하면 백트래킹</span>
</span></span><span class=line><span class=cl>                            <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 모든 숫자가 유효하지 않음</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 빈 칸이 채워짐</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>board</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=부분집합의-합-문제-subset-sum>부분집합의 합 문제 (Subset Sum)<a hidden class=anchor aria-hidden=true href=#부분집합의-합-문제-subset-sum>#</a></h4><p>주어진 집합에서 특정 합을 만드는 부분집합을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>subset_sum</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>current_sum</span><span class=p>,</span> <span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 목표 합을 찾았을 때</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>path</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 목표 합을 초과하거나 모든 요소를 확인했을 때</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_sum</span> <span class=o>&gt;</span> <span class=n>target</span> <span class=ow>or</span> <span class=n>start</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 요소를 포함하는 경우</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>start</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_sum</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>start</span><span class=p>],</span> <span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 백트래킹: 현재 요소를 제외하는 경우</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_sum</span><span class=p>,</span> <span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Brute Force</h2></header><div class=entry-content><p>Back Tracking vs. Brute Force 브루트 포스와 백트래킹은 모두 조합 최적화 문제를 해결하는 데 사용되는 중요한 알고리즘 패러다임이다.
브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.
브루트 포스(Brute Force) 브루트 포스는 가능한 모든 경우의 수를 전부 확인하는 완전 탐색 알고리즘이다.
이 방법은 문제 해결을 위해 가능한 모든 후보해를 체계적으로 나열하고 각각을 검사한다.
브루트 포스의 작동 방식:
...</p></div><footer class=entry-footer><span title='2024-12-29 14:02:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Brute Force" href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/back-tracking-vs-brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Traversal</h2></header><div class=entry-content><p>Back Tracking vs. Traversal 백트래킹과 트래버설은 컴퓨터 과학에서 문제 해결과 데이터 구조 탐색에 사용되는 중요한 알고리즘 패러다임이다.
두 기법은 겉보기에 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.
백트래킹과 트래버설은 서로 다른 목적과 접근 방식을 가지고 있지만, 많은 복잡한 문제 해결에서 상호 보완적으로 사용된다.
트래버설은 데이터 구조의 모든 요소를 효율적으로 방문하는 체계적인 방법을 제공하고, 백트래킹은 방대한 해결책 공간에서 효율적으로 유망한 해결책을 찾는 전략을 제공한다.
실제 문제 해결에서는 두 개념의 장점을 결합하여 사용하는 것이 효과적이다.
예를 들어, 그래프에서 특정 조건을 만족하는 경로를 찾기 위해 DFS나 BFS와 같은 트래버설 알고리즘으로 그래프를 탐색하면서, 백트래킹 기법을 활용하여 유망하지 않은 경로는 조기에 포기하는 방식이다.
...</p></div><footer class=entry-footer><span title='2024-12-09 14:55:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Traversal" href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/back-tracking-vs-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Depth-First Search</h2></header><div class=entry-content><p>Back Tracking vs. Depth-First Search 백트래킹과 깊이 우선 탐색은 모두 그래프나 트리 구조에서 해결책을 찾기 위한 알고리즘 기법이다.
DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.
백트래킹은 DFS의 개념을 기반으로 하지만, 유망성 테스트와 가지치기라는 중요한 최적화 기법을 추가하여 탐색 공간을 줄이고 효율성을 높인다. 따라서 백트래킹은 DFS의 확장된 형태라고 볼 수 있다.
깊이 우선 탐색(Depth-First Search, DFS) 깊이 우선 탐색은 그래프 탐색 알고리즘으로, 가능한 한 깊이 들어가면서 모든 노드를 방문하는 방법이다.
...</p></div><footer class=entry-footer><span title='2024-12-29 13:55:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Depth-First Search" href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/back-tracking-vs-depth-first-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>가지치기(Pruning)</h2></header><div class=entry-content><p>가지치기(Pruning) 가지치기는 백트래킹 과정에서 더 이상 유망하지 않은(promising하지 않은) 경로를 조기에 차단하는 기법이다.
즉, 특정 경로가 해결책으로 이어질 가능성이 없다고 판단되면, 그 경로를 더 이상 탐색하지 않고 바로 다른 경로를 탐색합니다.
가지치기의 중요성 효율성 향상: 불필요한 탐색을 줄여 알고리즘의 실행 시간을 크게 단축한다. 자원 절약: 메모리 사용량을 줄이고 CPU 자원을 효율적으로 사용한다. 실용성 증대: 가지치기 없이는 현실적으로 해결하기 어려운 복잡한 문제도 해결 가능하게 만든다. 가지치기 적용 방법 가지치기를 적용하는 핵심은 ‘유망성 테스트(promising test)‘이다.
각 단계에서 현재 상태가 최종 해결책으로 이어질 가능성이 있는지를 판단하는 함수를 만들어 사용한다.
...</p></div><footer class=entry-footer><span title='2024-12-29 14:00:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가지치기(Pruning)" href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/optimization-techniques/pruning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상태 공간 트리(State Space Tree)</h2></header><div class=entry-content><p>상태 공간 트리(State Space Tree) 백트래킹 알고리즘을 제대로 이해하기 위해서는 “상태 공간 트리(State Space Tree)“라는 개념을 먼저 파악하는 것이 매우 중요하다.
이 개념은 백트래킹의 이론적 기초가 되며, 문제 해결 과정을 시각적으로 표현하는 데 도움이 된다.
이 트리는 문제 해결 과정의 모든 가능한 경로를 체계적으로 표현하며, 백트래킹은 이 트리를 효율적으로 탐색하는 방법을 제공한다.
상태 공간 트리를 잘 이해하고 설계하면 복잡한 문제도 체계적으로 접근할 수 있다.
특히 상태 표현 방법, 유효성 검사 함수, 가지치기 전략을 최적화하는 것이 효율적인 백트래킹 알고리즘을 개발하는 핵심이다.
...</p></div><footer class=entry-footer><span title='2024-12-29 13:59:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상태 공간 트리(State Space Tree)" href=https://buenhyden.github.io/posts/data-structures--algorithms/problem-solving-techniques/search-and-exploration/back-tracking/implementation-strategies/state-space/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>