<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>병합 정렬 (Merge Sort) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Algorithms,Sorting,Types,Merge-Sort"><meta name=description content="병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/efficient-sorts/merge-sort/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/efficient-sorts/merge-sort/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/efficient-sorts/merge-sort/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="병합 정렬 (Merge Sort)"><meta property="og:description" content="병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-15T08:38:00+00:00"><meta property="article:modified_time" content="2024-10-15T08:38:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Sorting"><meta property="article:tag" content="Types"><meta property="article:tag" content="Merge-Sort"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="병합 정렬 (Merge Sort)"><meta name=twitter:description content="병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":4,"name":"병합 정렬 (Merge Sort)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/efficient-sorts/merge-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"병합 정렬 (Merge Sort)","name":"병합 정렬 (Merge Sort)","description":"병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.","keywords":["Data-Structures-and-Algorithms","Algorithms","Sorting","Types","Merge-Sort"],"articleBody":"병합 정렬 (Merge Sort) 병합 정렬은 분할 정복(Divide and Conquer) 패러다임을 기반으로 하는 효율적인 정렬 알고리즘이다.\n여러 정렬 알고리즘 중에서도 안정적인 성능과 일관된 시간 복잡도를 제공하는 방식으로 널리 사용된다.\n병합 정렬은 안정적인 성능과 예측 가능한 시간 복잡도를 제공하는 매우 유용한 정렬 알고리즘. 추가 메모리가 필요하다는 단점이 있지만, 대규모 데이터 처리나 외부 정렬에 적합하며, 안정적인 정렬이 필요한 상황에서 특히 유용하다.\n알고리즘의 단순성과 병렬화 가능성도 중요한 장점이다.\n병합 정렬의 기본 원리 병합 정렬은 다음 세 단계로 동작한다:\n분할(Divide): 입력 배열을 두 개의 부분 배열로 나눈다. 정복(Conquer): 두 부분 배열을 재귀적으로 정렬한다. 병합(Merge): 정렬된 두 부분 배열을 하나의 정렬된 배열로 병합한다.\n이 과정은 부분 배열의 크기가 1이 될 때까지 계속되며, 크기가 1인 배열은 이미 정렬되어 있다고 간주한다. https://www.programiz.com/dsa/merge-sort\n병합 정렬의 시각화 과정 [5, 2, 4, 7, 1, 3, 8, 6] 배열을 병합 정렬로 정렬하는 과정을 시각화:\n분할 단계:\n1 2 3 4 5 6 7 [5, 2, 4, 7, 1, 3, 8, 6] / \\ [5, 2, 4, 7] [1, 3, 8, 6] / \\ / \\ [5, 2] [4, 7] [1, 3] [8, 6] / \\ / \\ / \\ / \\ [5] [2] [4] [7] [1] [3] [8] [6] 병합 단계:\n1 2 3 4 5 6 7 [5] [2] [4] [7] [1] [3] [8] [6] \\ / \\ / \\ / \\ / [2, 5] [4, 7] [1, 3] [6, 8] \\ / \\ / [2, 4, 5, 7] [1, 3, 6, 8] \\ / [1, 2, 3, 4, 5, 6, 7, 8] 병합 정렬의 특징 시간 복잡도\n최선의 경우: O(n log n) 평균적인 경우: O(n log n) 최악의 경우: O(n log n)\n병합 정렬은 입력 배열의 상태와 관계없이 항상 일정한 시간 복잡도를 보이는 것이 큰 장점이다. 공간 복잡도\nO(n) - 정렬 과정에서 추가적인 배열이 필요하다. 안정성\n병합 정렬은 안정적인 정렬 알고리즘이다. 동일한 값을 가진 요소들의 상대적인 순서가 정렬 후에도 유지된다. 병합 정렬의 구현 다음은 Python으로 구현한 병합 정렬 알고리즘:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def merge_sort(arr): # 종료 조건: 배열의 길이가 1 이하면 이미 정렬된 것으로 간주 if len(arr) \u003c= 1: return arr # 분할 단계: 배열을 두 부분으로 나눔 mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] # 정복 단계: 두 부분을 재귀적으로 정렬 left_half = merge_sort(left_half) right_half = merge_sort(right_half) # 병합 단계: 정렬된 두 부분을 병합 return merge(left_half, right_half) def merge(left, right): result = [] i = j = 0 # 두 배열의 요소를 비교하여 작은 값부터 결과 배열에 추가 while i \u003c len(left) and j \u003c len(right): if left[i] \u003c= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # 남은 요소들 추가 result.extend(left[i:]) result.extend(right[j:]) return result # 사용 예시 arr = [38, 27, 43, 3, 9, 82, 10] sorted_arr = merge_sort(arr) print(sorted_arr) # [3, 9, 10, 27, 38, 43, 82] 입력 배열:\n1 arr = [38, 27, 43, 3, 9, 82, 10] 실행 과정: merge_sort는 “분할(Divide) → 정복(Conquer) → 병합(Merge)” 단계를 거쳐 정렬된다.\n분할 (Divide) 배열을 절반으로 나누면서 재귀 호출이 계속된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 merge_sort([38, 27, 43, 3, 9, 82, 10]) ├─ merge_sort([38, 27, 43]) │ ├─ merge_sort([38]) → [38] (Base Case) │ ├─ merge_sort([27, 43]) │ │ ├─ merge_sort([27]) → [27] (Base Case) │ │ ├─ merge_sort([43]) → [43] (Base Case) │ │ └─ merge([27], [43]) → [27, 43] │ └─ merge([38], [27, 43]) → [27, 38, 43] │ ├─ merge_sort([3, 9, 82, 10]) ├─ merge_sort([3, 9]) │ ├─ merge_sort([3]) → [3] (Base Case) │ ├─ merge_sort([9]) → [9] (Base Case) │ └─ merge([3], [9]) → [3, 9] │ ├─ merge_sort([82, 10]) │ ├─ merge_sort([82]) → [82] (Base Case) │ ├─ merge_sort([10]) → [10] (Base Case) │ └─ merge([82], [10]) → [10, 82] │ └─ merge([3, 9], [10, 82]) → [3, 9, 10, 82] └─ merge([27, 38, 43], [3, 9, 10, 82]) → [3, 9, 10, 27, 38, 43, 82] 병합 (Merge) 이제, 작은 배열부터 차례로 병합하며 정렬된 배열을 완성한다.\n[27] 과 [43] 병합 → [27, 43] [38] 과 [27, 43] 병합 → [27, 38, 43] [3] 과 [9] 병합 → [3, 9] [82] 과 [10] 병합 → [10, 82] [3, 9] 과 [10, 82] 병합 → [3, 9, 10, 82] [27, 38, 43] 과 [3, 9, 10, 82] 병합 → [3, 9, 10, 27, 38, 43, 82] 병합 정렬의 최적화 방법 작은 배열에 대한 최적화\n작은 크기의 배열(일반적으로 크기가 10~20 이하)에 대해서는 삽입 정렬과 같은 더 간단한 정렬 알고리즘을 사용하여 성능을 개선할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 def optimized_merge_sort(arr): # 작은 배열에 대해 삽입 정렬 사용 if len(arr) \u003c= 10: return insertion_sort(arr) # 이하 기존 병합 정렬과 동일 mid = len(arr) // 2 left_half = optimized_merge_sort(arr[:mid]) right_half = optimized_merge_sort(arr[mid:]) return merge(left_half, right_half) 제자리 병합 정렬\n추가 메모리 사용을 줄이기 위해 제자리(in-place) 병합 정렬을 구현할 수도 있다. 하지만 이는 구현이 복잡하고 성능이 저하될 수 있다. 병합 정렬의 응용 외부 정렬(External Sorting)\n병합 정렬은 대용량 데이터를 다룰 때 유용한 외부 정렬 알고리즘의 기초가 된다.\n주 메모리보다 큰 데이터를 처리할 때 사용된다.\n병렬 정렬\n병합 정렬은 병렬 처리에 적합한 구조를 가지고 있어, 다중 코어 환경에서 효율적으로 구현할 수 있다.\n역순 쌍 계산\n병합 정렬은 배열 내의 역순 쌍(inversion pairs)을 계산하는 데에도 활용될 수 있다.\n참고 및 출처 ","wordCount":"898","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-15T08:38:00Z","dateModified":"2024-10-15T08:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/efficient-sorts/merge-sort/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">병합 정렬 (Merge Sort)</h1><div class=post-description>병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.</div><div class=post-meta><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20&%20Algorithms/Algorithms/Sorting%20and%20Searching/Comparison-Based%20Sorting/Efficient%20Sorts/Merge-Sort.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#병합-정렬-merge-sort>병합 정렬 (Merge Sort)</a><ul><li><a href=#병합-정렬의-기본-원리>병합 정렬의 기본 원리</a></li><li><a href=#병합-정렬의-시각화-과정>병합 정렬의 시각화 과정</a></li><li><a href=#병합-정렬의-특징>병합 정렬의 특징</a></li><li><a href=#병합-정렬의-구현>병합 정렬의 구현</a></li><li><a href=#병합-정렬의-최적화-방법>병합 정렬의 최적화 방법</a></li><li><a href=#병합-정렬의-응용>병합 정렬의 응용</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=병합-정렬-merge-sort>병합 정렬 (Merge Sort)<a hidden class=anchor aria-hidden=true href=#병합-정렬-merge-sort>#</a></h2><p>병합 정렬은 분할 정복(Divide and Conquer) 패러다임을 기반으로 하는 효율적인 정렬 알고리즘이다.<br>여러 정렬 알고리즘 중에서도 안정적인 성능과 일관된 시간 복잡도를 제공하는 방식으로 널리 사용된다.</p><p>병합 정렬은 안정적인 성능과 예측 가능한 시간 복잡도를 제공하는 매우 유용한 정렬 알고리즘. 추가 메모리가 필요하다는 단점이 있지만, 대규모 데이터 처리나 외부 정렬에 적합하며, 안정적인 정렬이 필요한 상황에서 특히 유용하다.<br>알고리즘의 단순성과 병렬화 가능성도 중요한 장점이다.</p><h3 id=병합-정렬의-기본-원리>병합 정렬의 기본 원리<a hidden class=anchor aria-hidden=true href=#병합-정렬의-기본-원리>#</a></h3><p>병합 정렬은 다음 세 단계로 동작한다:</p><ol><li><strong>분할(Divide)</strong>: 입력 배열을 두 개의 부분 배열로 나눈다.</li><li><strong>정복(Conquer)</strong>: 두 부분 배열을 재귀적으로 정렬한다.</li><li><strong>병합(Merge)</strong>: 정렬된 두 부분 배열을 하나의 정렬된 배열로 병합한다.<br>이 과정은 부분 배열의 크기가 1이 될 때까지 계속되며, 크기가 1인 배열은 이미 정렬되어 있다고 간주한다.</li></ol><p><figure><img alt="Merge Sort" loading=lazy src=/img/merge-sort-example_0.png><figcaption>https://www.programiz.com/dsa/merge-sort</figcaption></figure></p><h3 id=병합-정렬의-시각화-과정>병합 정렬의 시각화 과정<a hidden class=anchor aria-hidden=true href=#병합-정렬의-시각화-과정>#</a></h3><p><code>[5, 2, 4, 7, 1, 3, 8, 6]</code> 배열을 병합 정렬로 정렬하는 과정을 시각화:</p><p><strong>분할 단계:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[5, 2, 4, 7, 1, 3, 8, 6]
</span></span><span class=line><span class=cl>          /        \
</span></span><span class=line><span class=cl>   [5, 2, 4, 7]    [1, 3, 8, 6]
</span></span><span class=line><span class=cl>     /    \          /    \
</span></span><span class=line><span class=cl>  [5, 2]  [4, 7]   [1, 3]  [8, 6]
</span></span><span class=line><span class=cl>   / \     / \      / \     / \
</span></span><span class=line><span class=cl> [5] [2] [4] [7]  [1] [3] [8] [6]
</span></span></code></pre></td></tr></table></div></div><p><strong>병합 단계:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> [5] [2] [4] [7]  [1] [3] [8] [6]
</span></span><span class=line><span class=cl>   \ /     \ /      \ /     \ /
</span></span><span class=line><span class=cl>  [2, 5]  [4, 7]   [1, 3]  [6, 8]
</span></span><span class=line><span class=cl>     \    /          \    /
</span></span><span class=line><span class=cl>   [2, 4, 5, 7]    [1, 3, 6, 8]
</span></span><span class=line><span class=cl>          \        /
</span></span><span class=line><span class=cl>    [1, 2, 3, 4, 5, 6, 7, 8]
</span></span></code></pre></td></tr></table></div></div><h3 id=병합-정렬의-특징>병합 정렬의 특징<a hidden class=anchor aria-hidden=true href=#병합-정렬의-특징>#</a></h3><ol><li><p>시간 복잡도</p><ul><li><strong>최선의 경우</strong>: O(n log n)</li><li><strong>평균적인 경우</strong>: O(n log n)</li><li><strong>최악의 경우</strong>: O(n log n)<br>병합 정렬은 입력 배열의 상태와 관계없이 항상 일정한 시간 복잡도를 보이는 것이 큰 장점이다.</li></ul></li><li><p>공간 복잡도</p><ul><li>O(n) - 정렬 과정에서 추가적인 배열이 필요하다.</li></ul></li><li><p>안정성</p><ul><li>병합 정렬은 안정적인 정렬 알고리즘이다.</li><li>동일한 값을 가진 요소들의 상대적인 순서가 정렬 후에도 유지된다.</li></ul></li></ol><h3 id=병합-정렬의-구현>병합 정렬의 구현<a hidden class=anchor aria-hidden=true href=#병합-정렬의-구현>#</a></h3><p>다음은 Python으로 구현한 병합 정렬 알고리즘:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span><span class=lnt id=hl-2-39><a class=lnlinks href=#hl-2-39>39</a>
</span><span class=lnt id=hl-2-40><a class=lnlinks href=#hl-2-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 종료 조건: 배열의 길이가 1 이하면 이미 정렬된 것으로 간주</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계: 배열을 두 부분으로 나눔</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left_half</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right_half</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정복 단계: 두 부분을 재귀적으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>left_half</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>left_half</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>right_half</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>right_half</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 병합 단계: 정렬된 두 부분을 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left_half</span><span class=p>,</span> <span class=n>right_half</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 배열의 요소를 비교하여 작은 값부터 결과 배열에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>38</span><span class=p>,</span> <span class=mi>27</span><span class=p>,</span> <span class=mi>43</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>82</span><span class=p>,</span> <span class=mi>10</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>sorted_arr</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sorted_arr</span><span class=p>)</span>  <span class=c1># [3, 9, 10, 27, 38, 43, 82]</span>
</span></span></code></pre></td></tr></table></div></div><p>입력 배열:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>arr = [38, 27, 43, 3, 9, 82, 10]
</span></span></code></pre></td></tr></table></div></div><p>실행 과정:
merge_sort는 <strong>&ldquo;분할(Divide) → 정복(Conquer) → 병합(Merge)&rdquo;</strong> 단계를 거쳐 정렬된다.</p><ol><li><p>분할 (Divide)
배열을 절반으로 나누면서 재귀 호출이 계속된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>merge_sort([38, 27, 43, 3, 9, 82, 10])
</span></span><span class=line><span class=cl>  ├─ merge_sort([38, 27, 43])  
</span></span><span class=line><span class=cl>  │    ├─ merge_sort([38])  → [38] (Base Case)
</span></span><span class=line><span class=cl>  │    ├─ merge_sort([27, 43])
</span></span><span class=line><span class=cl>  │    │    ├─ merge_sort([27])  → [27] (Base Case)
</span></span><span class=line><span class=cl>  │    │    ├─ merge_sort([43])  → [43] (Base Case)
</span></span><span class=line><span class=cl>  │    │    └─ merge([27], [43]) → [27, 43]
</span></span><span class=line><span class=cl>  │    └─ merge([38], [27, 43]) → [27, 38, 43]
</span></span><span class=line><span class=cl>  │
</span></span><span class=line><span class=cl>  ├─ merge_sort([3, 9, 82, 10])
</span></span><span class=line><span class=cl>       ├─ merge_sort([3, 9])  
</span></span><span class=line><span class=cl>       │    ├─ merge_sort([3])  → [3] (Base Case)
</span></span><span class=line><span class=cl>       │    ├─ merge_sort([9])  → [9] (Base Case)
</span></span><span class=line><span class=cl>       │    └─ merge([3], [9]) → [3, 9]
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       ├─ merge_sort([82, 10])
</span></span><span class=line><span class=cl>       │    ├─ merge_sort([82])  → [82] (Base Case)
</span></span><span class=line><span class=cl>       │    ├─ merge_sort([10])  → [10] (Base Case)
</span></span><span class=line><span class=cl>       │    └─ merge([82], [10]) → [10, 82]
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       └─ merge([3, 9], [10, 82]) → [3, 9, 10, 82]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  └─ merge([27, 38, 43], [3, 9, 10, 82]) → [3, 9, 10, 27, 38, 43, 82]
</span></span></code></pre></td></tr></table></div></div></li><li><p>병합 (Merge)
이제, 작은 배열부터 차례로 병합하며 정렬된 배열을 완성한다.</p><ol><li><code>[27]</code> 과 <code>[43]</code> 병합 → <code>[27, 43]</code></li><li><code>[38]</code> 과 <code>[27, 43]</code> 병합 → <code>[27, 38, 43]</code></li><li><code>[3]</code> 과 <code>[9]</code> 병합 → <code>[3, 9]</code></li><li><code>[82]</code> 과 <code>[10]</code> 병합 → <code>[10, 82]</code></li><li><code>[3, 9]</code> 과 <code>[10, 82]</code> 병합 → <code>[3, 9, 10, 82]</code></li><li><code>[27, 38, 43]</code> 과 <code>[3, 9, 10, 82]</code> 병합 → <code>[3, 9, 10, 27, 38, 43, 82]</code></li></ol></li></ol><h3 id=병합-정렬의-최적화-방법>병합 정렬의 최적화 방법<a hidden class=anchor aria-hidden=true href=#병합-정렬의-최적화-방법>#</a></h3><ol><li>작은 배열에 대한 최적화<br>작은 크기의 배열(일반적으로 크기가 10~20 이하)에 대해서는 삽입 정렬과 같은 더 간단한 정렬 알고리즘을 사용하여 성능을 개선할 수 있다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>optimized_merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 작은 배열에 대해 삽입 정렬 사용</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>10</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>insertion_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 이하 기존 병합 정렬과 동일</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left_half</span> <span class=o>=</span> <span class=n>optimized_merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>right_half</span> <span class=o>=</span> <span class=n>optimized_merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left_half</span><span class=p>,</span> <span class=n>right_half</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>제자리 병합 정렬<br>추가 메모리 사용을 줄이기 위해 제자리(in-place) 병합 정렬을 구현할 수도 있다. 하지만 이는 구현이 복잡하고 성능이 저하될 수 있다.</li></ol><h3 id=병합-정렬의-응용>병합 정렬의 응용<a hidden class=anchor aria-hidden=true href=#병합-정렬의-응용>#</a></h3><ol><li><p>외부 정렬(External Sorting)<br>병합 정렬은 대용량 데이터를 다룰 때 유용한 외부 정렬 알고리즘의 기초가 된다.<br>주 메모리보다 큰 데이터를 처리할 때 사용된다.</p></li><li><p>병렬 정렬<br>병합 정렬은 병렬 처리에 적합한 구조를 가지고 있어, 다중 코어 환경에서 효율적으로 구현할 수 있다.</p></li><li><p>역순 쌍 계산<br>병합 정렬은 배열 내의 역순 쌍(inversion pairs)을 계산하는 데에도 활용될 수 있다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/algorithms/>Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/sorting/>Sorting</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/merge-sort/>Merge-Sort</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/quality-control/><span class=title>« Prev</span><br><span>Quality Control</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/just-in-time-compiler/><span class=title>Next »</span><br><span>Just-In-Time (JIT) Compiler</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>