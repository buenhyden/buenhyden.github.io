<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>브루트 포스 (Brute Force) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Brute-Force"><meta name=description content='브루트 포스는 "무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/string-algorithms/pattern-matching/naive-algorithms/brute-force/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/string-algorithms/pattern-matching/naive-algorithms/brute-force/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/string-algorithms/pattern-matching/naive-algorithms/brute-force/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/string-algorithms/pattern-matching/naive-algorithms/brute-force/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="브루트 포스 (Brute Force)"><meta property="og:description" content='브루트 포스는 "무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="브루트 포스 (Brute Force)"><meta name=twitter:description content='브루트 포스는 "무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":4,"name":"브루트 포스 (Brute Force)","item":"https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/string-algorithms/pattern-matching/naive-algorithms/brute-force/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>브루트 포스 (Brute Force)</h1><div class=post-description>브루트 포스는 &ldquo;무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.</div></header><div class=post-content><h2 id=브루트-포스-brute-force>브루트 포스 (Brute Force)<a hidden class=anchor aria-hidden=true href=#브루트-포스-brute-force>#</a></h2><p>브루트 포스는 가장 직관적이고 단순한 문제 해결 기법으로, 가능한 모든 경우의 수를 철저하게 조사하여 문제의 해결책을 찾는 방법이다.<br>&ldquo;무차별 대입법&rdquo; 또는 &ldquo;완전 탐색"이라고도 불리는 이 접근법은 컴퓨터 과학과 알고리즘 설계에서 기본적인 방법론으로 사용된다.</p><p>브루트 포스는 가장 직관적이고 단순한 문제 해결 접근법으로, 구현이 쉽고 모든 가능한 해결책을 검사하기 때문에 완전성을 보장한다. 그러나 시간 복잡도가 높아 큰 문제에는 적합하지 않다.</p><p>실제 응용에서는 브루트 포스를 단독으로 사용하기보다는 다른 최적화 기법과 함께 사용하거나, 더 효율적인 알고리즘이 없는 경우의 대안으로 활용한다. 또한, 브루트 포스는 문제 해결의 기본 접근법으로서 다른 고급 알고리즘의 기초가 된다.</p><p>알고리즘 설계에서 브루트 포스는 종종 첫 번째 단계로, 문제를 더 깊이 이해하고 최적화된 해결책을 개발하기 위한 출발점으로 사용된다. 따라서 브루트 포스의 원리와 한계를 이해하는 것은 효과적인 알고리즘 개발을 위한 중요한 기초이다.</p><h3 id=브루트-포스의-기본-원리>브루트 포스의 기본 원리<a hidden class=anchor aria-hidden=true href=#브루트-포스의-기본-원리>#</a></h3><p>브루트 포스 알고리즘은 다음과 같은 원리로 작동한다:</p><ol><li>문제의 가능한 모든 후보 해결책을 생성한다.</li><li>각 후보 해결책이 문제의 조건을 만족하는지 확인한다.</li><li>조건을 만족하는 해결책을 찾거나, 모든 가능성을 검사할 때까지 과정을 반복한다.</li></ol><h3 id=브루트-포스의-특징>브루트 포스의 특징<a hidden class=anchor aria-hidden=true href=#브루트-포스의-특징>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li><strong>단순성</strong>: 구현이 간단하고 직관적.</li><li><strong>완전성</strong>: 해결책이 존재한다면 반드시 찾아낸다.</li><li><strong>정확성</strong>: 모든 가능성을 검사하므로 최적해를 보장한다.</li><li><strong>전처리 불필요</strong>: 특별한 사전 준비나 데이터 구조가 필요하지 않다.</li><li><strong>기준점 제공</strong>: 다른 알고리즘의 정확성과 효율성을 검증하는 기준으로 사용된다.</li></ul><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li><strong>비효율성</strong>: 시간 복잡도가 매우 높아 큰 문제에서는 비실용적.</li><li><strong>확장성 부족</strong>: 입력 크기가 커질수록 실행 시간이 기하급수적으로 증가.</li><li><strong>메모리 사용</strong>: 경우에 따라 많은 메모리를 필요로 할 수 있다.</li></ul><h3 id=브루트-포스의-시간-복잡도>브루트 포스의 시간 복잡도<a hidden class=anchor aria-hidden=true href=#브루트-포스의-시간-복잡도>#</a></h3><p>브루트 포스 알고리즘의 시간 복잡도는 문제의 특성에 따라 달라지지만, 일반적으로 다음과 같은 범위에 속한다:</p><ul><li><strong>O(2^n)</strong>: 이진 결정(예/아니오)이 필요한 각 요소에 대해 (부분집합 문제)</li><li><strong>O(n!)</strong>: 요소의 순서가 중요한 경우 (순열 문제)</li><li><strong>O(n^k)</strong>: k개의 요소를 선택하는 경우 (조합 문제)</li><li><strong>O(m^n)</strong>: 각 위치에 m개의 가능한 값이 있는 n개의 위치 (카테시안 곱)</li></ul><h3 id=브루트-포스의-적용-분야>브루트 포스의 적용 분야<a hidden class=anchor aria-hidden=true href=#브루트-포스의-적용-분야>#</a></h3><p>브루트 포스 알고리즘은 다양한 분야에서 활용된다:</p><ol><li><p>암호학</p><ul><li><strong>비밀번호 크래킹</strong>: 가능한 모든 비밀번호 조합을 시도</li><li><strong>암호 해독</strong>: 모든 가능한 키를 시도하여 암호문 해독</li><li><strong>해시 충돌 찾기</strong>: 같은 해시 값을 갖는 서로 다른 입력 찾기</li></ul></li><li><p>최적화 문제</p><ul><li><strong>외판원 문제(TSP)</strong>: 모든 가능한 경로를 탐색하여 최적 경로 찾기</li><li><strong>배낭 문제</strong>: 모든 물건 조합을 시도하여 최대 가치 찾기</li><li><strong>작업 할당 문제</strong>: 모든 가능한 할당을 검사하여 최적 할당 찾기</li></ul></li><li><p>문자열 처리</p><ul><li><strong>문자열 매칭</strong>: 텍스트 내에서 패턴을 찾기 위해 모든 위치 검사</li><li><strong>DNA 서열 정렬</strong>: 모든 가능한 정렬을 시도</li><li><strong>아나그램 탐지</strong>: 두 문자열의 모든 가능한 재배열 비교</li></ul></li><li><p>게임 이론</p><ul><li><strong>틱택토(Tic-tac-toe)와 같은 간단한 게임</strong>: 모든 가능한 이동을 탐색</li><li><strong>체스와 같은 복잡한 게임</strong>: 제한된 깊이까지의 모든 가능한 이동 검사</li><li><strong>퍼즐 해결</strong>: 스도쿠, 십자말풀이 등의 모든 가능한 해결책 시도</li></ul></li><li><p>컴퓨터 비전</p><ul><li><strong>이미지 매칭</strong>: 두 이미지 간의 모든 가능한 정렬 시도</li><li><strong>특징점 검출</strong>: 모든 가능한 위치에서 특징 탐색</li></ul></li></ol><h3 id=브루트-포스-알고리즘의-구현-방법>브루트 포스 알고리즘의 구현 방법<a hidden class=anchor aria-hidden=true href=#브루트-포스-알고리즘의-구현-방법>#</a></h3><p>브루트 포스 알고리즘은 다양한 방식으로 구현할 수 있다:</p><ol><li><p>반복문을 이용한 방법<br>중첩된 반복문을 사용하여 모든 가능한 조합을 생성.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 두 숫자의 합이 target이 되는 쌍 찾기</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_pair_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>None</span>  <span class=c1># 해당하는 쌍이 없는 경우</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>재귀를 이용한 방법<br>재귀 함수를 사용하여 가능한 모든 상태를 탐색.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 부분집합의 합이 target과 같은 경우 찾기</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>subset_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>current_sum</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>subset</span><span class=o>=</span><span class=p>[]):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 합이 target과 같은 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>current_sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>subset</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 배열의 끝에 도달한 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 요소를 포함하는 경우</span>
</span></span><span class=line><span class=cl>    <span class=n>include</span> <span class=o>=</span> <span class=n>subset_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>current_sum</span><span class=o>+</span><span class=n>arr</span><span class=p>[</span><span class=n>index</span><span class=p>],</span> <span class=n>subset</span><span class=o>+</span><span class=p>[</span><span class=n>arr</span><span class=p>[</span><span class=n>index</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>include</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>include</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 요소를 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>    <span class=n>exclude</span> <span class=o>=</span> <span class=n>subset_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>current_sum</span><span class=p>,</span> <span class=n>subset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>exclude</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>비트마스크를 이용한 방법<br>비트 연산을 활용하여 모든 부분집합을 효율적으로 생성.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 비트마스크를 사용한 모든 부분집합 생성</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_all_subsets</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>subsets</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 0부터 2^n-1까지의 모든 숫자 (총 2^n개의 부분집합)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>subset</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 상태(i)에서 각 비트가 1인지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>subset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>subsets</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>subset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>subsets</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>순열 생성<br>모든 가능한 순열을 생성하는 방법.</p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 재귀를 사용한 모든 순열 생성</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_permutations</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>start</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>start</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 기본 케이스: 마지막 요소에 도달했을 때 현재 순열 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=n>arr</span><span class=p>[:]]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>permutations</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 위치(start)와 i 위치의 요소 교환</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 다음 위치에 대한 모든 순열 생성</span>
</span></span><span class=line><span class=cl>        <span class=n>permutations</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>generate_permutations</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 원래 상태로 복원 (백트래킹)</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>permutations</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=브루트-포스의-실제-문제-적용-사례>브루트 포스의 실제 문제 적용 사례<a hidden class=anchor aria-hidden=true href=#브루트-포스의-실제-문제-적용-사례>#</a></h3><ol><li><p>선형 검색 (Linear Search)<br>정렬되지 않은 배열에서 특정 값을 찾는 가장 기본적인 브루트 포스 알고리즘.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>linear_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span>  <span class=c1># 찾은 요소의 인덱스 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 요소를 찾지 못한 경우</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도</strong>: O(n)</p></li><li><p>문자열 매칭 (Naive String Matching)<br>텍스트에서 패턴을 찾는 간단한 브루트 포스 접근법.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>naive_string_match</span><span class=p>(</span><span class=n>text</span><span class=p>,</span> <span class=n>pattern</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>pattern</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>positions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 텍스트의 모든 가능한 시작 위치 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>match</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 위치에서 패턴과 일치하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>text</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=n>pattern</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>match</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=k>match</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>positions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>positions</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도</strong>: O((n-m+1) * m) = O(n*m)</p></li><li><p>외판원 문제 (Traveling Salesman Problem)<br>모든 도시를 한 번씩 방문하는 최단 경로를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>tsp_brute_force</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 시작 노드를 제외한 모든 노드</span>
</span></span><span class=line><span class=cl>    <span class=n>vertices</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=k>if</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>min_path</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>best_path</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 순열 생성 및 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>perm</span> <span class=ow>in</span> <span class=n>generate_permutations</span><span class=p>(</span><span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 시작 노드에서 첫 번째 도시까지의 거리</span>
</span></span><span class=line><span class=cl>        <span class=n>current_path_weight</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>start</span><span class=p>][</span><span class=n>perm</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 순열에 따라 도시 간 이동 거리 계산</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>perm</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>current_path_weight</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>perm</span><span class=p>[</span><span class=n>i</span><span class=p>]][</span><span class=n>perm</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 도시에서 시작 도시로 돌아오는 거리</span>
</span></span><span class=line><span class=cl>        <span class=n>current_path_weight</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>perm</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 최소 경로 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_path_weight</span> <span class=o>&lt;</span> <span class=n>min_path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>min_path</span> <span class=o>=</span> <span class=n>current_path_weight</span>
</span></span><span class=line><span class=cl>            <span class=n>best_path</span> <span class=o>=</span> <span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>+</span> <span class=n>perm</span> <span class=o>+</span> <span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_path</span><span class=p>,</span> <span class=n>best_path</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도</strong>: O(n!), 여기서 n은 도시의 개수.</p></li><li><p>부분 집합의 합 (Subset Sum)<br>주어진 집합에서 합이 목표값과 같은 부분 집합을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>subset_sum_brute_force</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 부분집합 검사 (2^n)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>subset</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>subset_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># i의 이진 표현에서 1인 비트에 해당하는 요소 선택</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>subset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>subset_sum</span> <span class=o>+=</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 합이 타겟과 일치하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>subset_sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>subset</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 해당하는 부분집합이 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>None</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도</strong>: O(2^n * n), 여기서 n은 집합의 크기.</p></li><li><p>최대 부분 배열 합 (Maximum Subarray Sum)<br>연속된 부분 배열 중 합이 최대인 부분 배열을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_subarray_brute_force</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>max_sum</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>best_start</span> <span class=o>=</span> <span class=n>best_end</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 시작점</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>start</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>current_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 가능한 끝점</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>end</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>current_sum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 최대 합 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_sum</span> <span class=o>&gt;</span> <span class=n>max_sum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_sum</span> <span class=o>=</span> <span class=n>current_sum</span>
</span></span><span class=line><span class=cl>                <span class=n>best_start</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>                <span class=n>best_end</span> <span class=o>=</span> <span class=n>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_sum</span><span class=p>,</span> <span class=n>arr</span><span class=p>[</span><span class=n>best_start</span><span class=p>:</span><span class=n>best_end</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도</strong>: O(n^2), 여기서 n은 배열의 크기.</p></li></ol><h3 id=브루트-포스-알고리즘의-최적화-기법>브루트 포스 알고리즘의 최적화 기법<a hidden class=anchor aria-hidden=true href=#브루트-포스-알고리즘의-최적화-기법>#</a></h3><p>브루트 포스는 그 자체로는 비효율적일 수 있지만, 다양한 기법을 통해 최적화할 수 있다:</p><ol><li><p>조기 종료 (Early Termination)<br>조건을 만족하는 해결책을 찾는 즉시 탐색을 중단한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>contains_sum_pair</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>  <span class=c1># 합이 target인 쌍을 찾으면 즉시 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>가지치기 (Pruning)<br>유망하지 않은 경로를 조기에 제거하여 탐색 공간을 줄인다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_brute_force_pruned</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>index</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>current_value</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>current_weight</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 모든 아이템을 고려했거나 배낭이 가득 찬 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>values</span><span class=p>)</span> <span class=ow>or</span> <span class=n>current_weight</span> <span class=o>==</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 아이템을 넣을 수 없는 경우 (가지치기)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>knapsack_brute_force_pruned</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                          <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 아이템을 포함하는 경우</span>
</span></span><span class=line><span class=cl>    <span class=n>include</span> <span class=o>=</span> <span class=n>knapsack_brute_force_pruned</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>current_value</span> <span class=o>+</span> <span class=n>values</span><span class=p>[</span><span class=n>index</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>current_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 아이템을 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>    <span class=n>exclude</span> <span class=o>=</span> <span class=n>knapsack_brute_force_pruned</span><span class=p>(</span><span class=n>values</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                         <span class=n>index</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 두 경우 중 더 나은 결과 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>include</span><span class=p>,</span> <span class=n>exclude</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>휴리스틱 (Heuristics)<br>문제의 특성을 활용한 경험적 규칙을 적용하여 가능성이 높은 해결책부터 탐색한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20>20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>nearest_neighbor_tsp</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span> <span class=o>=</span> <span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>    <span class=n>unvisited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>unvisited</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total_distance</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 가장 가까운 이웃을 순차적으로 방문</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>unvisited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>nearest</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>unvisited</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>graph</span><span class=p>[</span><span class=n>current</span><span class=p>][</span><span class=n>x</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>unvisited</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>nearest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nearest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>total_distance</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>current</span><span class=p>][</span><span class=n>nearest</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>nearest</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 시작점으로 돌아가기</span>
</span></span><span class=line><span class=cl>    <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total_distance</span> <span class=o>+=</span> <span class=n>graph</span><span class=p>[</span><span class=n>current</span><span class=p>][</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_distance</span><span class=p>,</span> <span class=n>path</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>병렬화 (Parallelization)<br>브루트 포스 알고리즘은 독립적인 작업으로 쉽게 분할할 수 있어 병렬 처리에 적합하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span><span class=lnt id=hl-12-27><a class=lnlinks href=#hl-12-27>27</a>
</span><span class=lnt id=hl-12-28><a class=lnlinks href=#hl-12-28>28</a>
</span><span class=lnt id=hl-12-29><a class=lnlinks href=#hl-12-29>29</a>
</span><span class=lnt id=hl-12-30><a class=lnlinks href=#hl-12-30>30</a>
</span><span class=lnt id=hl-12-31><a class=lnlinks href=#hl-12-31>31</a>
</span><span class=lnt id=hl-12-32><a class=lnlinks href=#hl-12-32>32</a>
</span><span class=lnt id=hl-12-33><a class=lnlinks href=#hl-12-33>33</a>
</span><span class=lnt id=hl-12-34><a class=lnlinks href=#hl-12-34>34</a>
</span><span class=lnt id=hl-12-35><a class=lnlinks href=#hl-12-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>multiprocessing</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>parallel_brute_force</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>num_processes</span><span class=o>=</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>chunk_size</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=o>//</span> <span class=n>num_processes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 각 프로세스가 처리할 범위 설정</span>
</span></span><span class=line><span class=cl>    <span class=n>ranges</span> <span class=o>=</span> <span class=p>[(</span><span class=n>i</span> <span class=o>*</span> <span class=n>chunk_size</span><span class=p>,</span> <span class=nb>min</span><span class=p>((</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>chunk_size</span><span class=p>,</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>))</span> 
</span></span><span class=line><span class=cl>              <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_processes</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 부분집합 합 계산 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>check_subsets</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>subset</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=n>subset_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>subset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                    <span class=n>subset_sum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>subset_sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>subset</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 병렬 처리</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>multiprocessing</span><span class=o>.</span><span class=n>Pool</span><span class=p>(</span><span class=n>processes</span><span class=o>=</span><span class=n>num_processes</span><span class=p>)</span> <span class=k>as</span> <span class=n>pool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>results</span> <span class=o>=</span> <span class=n>pool</span><span class=o>.</span><span class=n>starmap</span><span class=p>(</span><span class=n>check_subsets</span><span class=p>,</span> <span class=n>ranges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 결과 처리</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>result</span> <span class=ow>in</span> <span class=n>results</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>None</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>메모이제이션 (Memoization)<br>이미 계산된 결과를 저장하여 중복 계산을 방지한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7>7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_memoized</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_memoized</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_memoized</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=브루트-포스가-효과적인-상황과-그렇지-않은-상황>브루트 포스가 효과적인 상황과 그렇지 않은 상황<a hidden class=anchor aria-hidden=true href=#브루트-포스가-효과적인-상황과-그렇지-않은-상황>#</a></h3><h4 id=브루트-포스가-효과적인-상황>브루트 포스가 효과적인 상황<a hidden class=anchor aria-hidden=true href=#브루트-포스가-효과적인-상황>#</a></h4><ol><li><strong>문제 크기가 작은 경우</strong>: 입력 데이터의 크기가 작아 시간 제약 내에 모든 경우를 검사할 수 있을 때</li><li><strong>최적화가 중요하지 않은 경우</strong>: 빠른 구현이 필요하고 성능이 중요하지 않을 때</li><li><strong>문제에 대한 특별한 알고리즘이 없는 경우</strong>: 더 효율적인 알고리즘이 알려져 있지 않은 문제</li><li><strong>정확성 검증이 필요한 경우</strong>: 다른 알고리즘의 결과를 검증하기 위한 기준으로 사용할 때</li><li><strong>일회성 작업인 경우</strong>: 한 번만 실행하면 되는 문제</li></ol><h4 id=브루트-포스가-비효율적인-상황>브루트 포스가 비효율적인 상황<a hidden class=anchor aria-hidden=true href=#브루트-포스가-비효율적인-상황>#</a></h4><ol><li><strong>문제 크기가 큰 경우</strong>: 입력 데이터의 크기가 커서 모든 경우를 검사하는 데 너무 많은 시간이 필요할 때</li><li><strong>실시간 처리가 필요한 경우</strong>: 빠른 응답 시간이 요구되는 애플리케이션</li><li><strong>반복적인 계산이 필요한 경우</strong>: 동일한 계산을 여러 번 수행해야 하는 문제</li><li><strong>효율적인 알고리즘이 존재하는 경우</strong>: 이미 더 효율적인 알고리즘이 알려진 문제</li><li><strong>지수적 또는 팩토리얼 복잡도를 가진 문제</strong>: NP-난해 문제와 같이 입력 크기에 따라 복잡도가 급격히 증가하는 문제</li></ol><h3 id=브루트-포스와-관련된-고급-주제>브루트 포스와 관련된 고급 주제<a hidden class=anchor aria-hidden=true href=#브루트-포스와-관련된-고급-주제>#</a></h3><ol><li><p>백트래킹과의 관계<br>백트래킹은 브루트 포스의 확장으로, 유망하지 않은 경로를 조기에 포기하여 효율성을 높인다.<br>브루트 포스가 모든 경우를 무차별적으로 검사한다면, 백트래킹은 &ldquo;가지치기(pruning)&rdquo; 기법을 적용하여 탐색 공간을 줄인다.</p></li><li><p>분기 한정법(Branch and Bound)과의 관계<br>분기 한정법은 최적화 문제를 해결하기 위한 알고리즘으로, 백트래킹과 유사하지만 &ldquo;한계(bound)&rdquo; 함수를 사용하여 최적해를 포함할 가능성이 없는 경로를 더 효과적으로 제거한다.</p></li><li><p>휴리스틱 탐색과의 관계<br>휴리스틱 탐색은 모든 경우를 검사하지 않고 문제의 특성을 활용하여 좋은 해결책을 빠르게 찾는 방법이다.<br>브루트 포스가 완전하다면(모든 해결책을 찾음), 휴리스틱 탐색은 불완전하지만 효율적이다.</p></li><li><p>암호화 및 보안에서의 역할<br>브루트 포스 공격은 암호 시스템의 보안을 테스트하는 중요한 방법이다.<br>강력한 암호 시스템은 브루트 포스 공격에 대해 내성이 있어야 한다.<br>이는 모든 가능한 키를 시도하는 데 비현실적으로 긴 시간이 걸리도록 설계된다.</p></li></ol><h3 id=브루트-포스의-실무-적용-예시>브루트 포스의 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#브루트-포스의-실무-적용-예시>#</a></h3><ol><li>소프트웨어 테스팅<br>모든 가능한 입력 조합을 테스트하여 소프트웨어의 정확성을 검증한다.</li><li>데이터 복구<br>손상된 데이터를 복구하기 위해 가능한 모든 시나리오를 시도한다.</li><li>생물정보학<br>DNA 서열 정렬, 단백질 구조 예측 등에서 가능한 모든 구성을 탐색한다.</li><li>컴퓨터 비전<br>이미지 매칭, 특징점 검출 등에서 모든 가능한 위치나 구성을 검사한다.</li><li>최적화 문제<br>작은 규모의 최적화 문제에서 최적해를 보장하기 위해 사용된다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>