<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Data Structures and Algorithms | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Data-Structures-and-Algorithms"><meta name=description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures--algorithms/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures--algorithms/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures--algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures--algorithms/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Data Structures and Algorithms"><meta property="og:description" content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Data Structures and Algorithms"><meta name=twitter:description content="데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures--algorithms/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Data Structures and Algorithms</h1><div class=post-description>데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문</div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>배열 (Array)</h2></header><div class=entry-content><p>배열 (Array) 배열은 동일한 데이터 타입의 여러 값을 연속적인 메모리 공간에 순차적으로 저장하는 선형 자료구조로, 인덱스를 통해 빠른 접근이 가능한 특징이 있다.
배열은 초기 한 번 선언 시 정해진 크기를 가지며, 이 크기를 변경하기 어렵기 때문에 메모리 관리와 연산 측면에서 장단점을 지니고 있다.
배열은 같은 데이터 타입의 값들을 하나의 변수명으로 관리하며, 각 요소는 메모리상에 연속된 위치에 저장된다. **인덱스(index)**를 이용하여 원하는 위치의 데이터를 빠르게 검색할 수 있으며, 대부분 0번부터 시작하는 경우가 많다. 배열은 선형 자료구조이므로, 요소들이 순차적으로 배치되어 있어 특정 인덱스에 접근할 때 기본 위치에 오프셋을 더하는 방식으로 계산된다. https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/
...</p></div><footer class=entry-footer><span title='2024-10-07 05:52:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 배열 (Array)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>그래프 (Graph)</h2></header><div class=entry-content><p>그래프 (Graph) 그래프는 컴퓨터 과학에서 가장 유연하고 강력한 자료구조 중 하나이다.
다양한 관계를 표현할 수 있어 현실 세계의 복잡한 문제를 모델링하는 데 매우 유용하다.
그래프는 다양한 문제를 해결하는 데 사용되는 강력한 자료구조이다.
인접 행렬, 인접 리스트, 간선 리스트 등 다양한 방법으로 표현할 수 있으며, DFS, BFS 등의 탐색 알고리즘부터 다익스트라, 벨만-포드 등의 최단 경로 알고리즘, 크루스칼, 프림 등의 최소 신장 트리 알고리즘까지 다양한 알고리즘이 그래프에 적용된다.
현실 세계의 많은 문제들을 그래프로 모델링할 수 있기 때문에, 그래프 이론은 컴퓨터 과학에서 매우 중요한 분야이다.
특히 소셜 네트워크, 내비게이션 시스템, 웹 페이지 랭킹 등 현대 기술의 핵심 부분에 그래프 알고리즘이 적용되고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-07 05:54:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 그래프 (Graph)" href=https://buenhyden.github.io/posts/data-structures--algorithms/advanced-topics/advanced-trees--graphs/graph-structures--algorithms/graphs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Asymptotic Notation</h2></header><div class=entry-content><p>점근적 표기법(Asymptotic Notation) 점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.
알고리즘 분석에서 가장 중요한 도구 중 하나로, 알고리즘의 시간 복잡도와 공간 복잡도를 표현하는 데 사용된다.
점근적 표기법은 알고리즘의 효율성을 분석하고 비교하는 강력한 도구이다.
빅오, 빅오메가, 빅세타 등의 표기법을 통해 알고리즘의 시간 복잡도와 공간 복잡도를 표현할 수 있으며, 이는 효율적인 알고리즘을 설계하고 선택하는 데 필수적이다.
그러나 점근적 표기법은 입력 크기가 무한히 커질 때의 동작만을 고려하며, 상수 인수나 낮은 차수의 항을 무시한다.
따라서 실제 응용에서는 점근적 분석과 함께 구체적인 성능 테스트와 프로파일링을 병행하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 10:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Asymptotic Notation" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/asymptotic-notation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Sorting Algorithm</h2></header><div class=entry-content><p>Sorting Algorithms 비교 정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다.
정렬 알고리즘은 시간 복잡도, 공간 복잡도, 안정성, 실행 속도 등의 성능 차이로 인해 다양한 방식이 존재한다.
각 정렬 알고리즘은 고유한 특성과 작동 방식을 가지고 있습니다. 여기서는 6가지 주요 정렬 알고리즘을 공통된 예시 배열 [8, 5, 2, 6, 9, 3, 1, 4, 7]을 사용하여 비교 분석하겠습니다.
정렬 알고리즘 비교 각 정렬 알고리즘은 고유한 특성과 장단점을 가지고 있으며, 적용 상황에 따라 최적의 선택이 달라진다:
...</p></div><footer class=entry-footer><span title='2024-10-15 04:16:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Sorting Algorithm" href=https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/sorting-algorithm-comparison/comparison--of-sorting-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cuckoo Hash Table</h2></header><div class=entry-content><p>Cuckoo Hash Table Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.
특징 다중 해시 함수: 일반적으로 두 개 이상의 해시 함수를 사용한다. 결정적 성능: 최악의 경우에도 일정한 시간 복잡도를 보장한다. 동적 재배치: 충돌 발생 시 기존 항목을 다른 위치로 이동시킨다. 장점 빠른 검색 속도: O(1) 시간 복잡도로 검색 연산을 수행한다. 공간 효율성: 높은 로드 팩터를 유지할 수 있다. 삭제 연산 지원: Bloom Filter와 달리 효율적인 삭제가 가능하다. 단점 삽입 연산의 복잡성: 최악의 경우 무한 루프에 빠질 수 있어 재해싱이 필요할 수 있다. 구현의 복잡성: 일반 해시 테이블에 비해 구현이 더 복잡하다. 응용 데이터베이스 인덱싱 네트워크 라우팅 테이블 캐시 시스템 스팸 필터링 동작 원리 삽입:
...</p></div><footer class=entry-footer><span title='2024-10-09 12:57:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cuckoo Hash Table" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/cuckoo-hashing/cuckoo-hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circular Queue</h2></header><div class=entry-content><p>Circular Queue (Circular Buffer) 이는 선형 큐의 확장된 버전으로, 데이터를 효율적으로 저장하고 관리하는 특정한 방식을 제공한다.
Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.
이는 ‘Ring Buffer’라고도 불리며, 고정 크기의 배열을 사용하여 데이터를 연속적인 루프로 저장한다.
https://www.geeksforgeeks.org/what-is-circular-queue-circular-queue-meaning/
특징 원형 구조: 마지막 위치가 첫 번째 위치와 연결되어 있다. FIFO (First In First Out) 원칙을 따른다. 두 개의 포인터: 큐의 front와 rear를 추적하는 두 개의 포인터를 사용한다. 고정 크기: 초기화 시 크기가 설정되며, 이후 변경이 어렵다. 장점 메모리 효율성: 선형 큐의 주요 한계인 메모리 낭비 문제를 해결한다. 빠른 연산: 삽입과 삭제 연산의 시간 복잡도가 O(1)이다. 공간 재사용: 큐의 앞부분이 비어있을 때 재사용이 가능하다. 캐시 지역성: 연속된 메모리 사용으로 CPU 캐시 성능이 향상된다. 단점 크기 제한: 고정 크기로 인해 오버플로우와 데이터 손실 가능성이 있다. 구현 복잡성: 선형 큐보다 구현이 복잡하다. 디버깅 어려움: 원형 구조로 인해 디버깅이 어려울 수 있다. 동적 크기 조정의 어려움: 크기를 동적으로 조정하기 어렵다. 응용 CPU 스케줄링: 운영 체제에서 프로세스 관리에 사용된다. 트래픽 관리 시스템: 교차로에서의 효율적인 흐름 제어에 활용된다. 메모리 관리: 운영 체제의 메모리 관리에 사용된다. 스트리밍 서비스: 오디오 및 비디오 스트리밍에 활용된다. 네트워크 패킷 관리: 라우터와 스위치에서 패킷 데이터 처리에 사용된다. 동작 원리 초기화: front와 rear 포인터를 -1로 설정한다. 삽입(Enqueue): 큐가 가득 찼는지 확인한다. rear 포인터를 원형으로 증가시킨 ((rear + 1) % size). 새 요소를 rear 위치에 삽입한다[11]. 삭제(Dequeue): 큐가 비어있는지 확인한다. front 위치의 요소를 반환한다. front 포인터를 원형으로 증가시킨다 ((front + 1) % size). 구성 요소 배열: 데이터를 저장하는 고정 크기의 배열. front 포인터: 큐의 첫 번째 요소를 가리킨다. rear 포인터: 큐의 마지막 요소를 가리킨다. size: 큐의 최대 크기를 나타낸다. 구현 방식 JavaScript를 사용한 Circular Queue 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circular Queue" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/stack--queue/queue-implementation/circular-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Algorithmic Thinking</h2></header><div class=entry-content><p>Algorithmic Thinking 알고리즘적 사고는 현대 디지털 사회에서 문제 해결의 핵심이 되는 인지적 접근 방식.
이는 단순히 컴퓨터 프로그래밍에만 국한되지 않고, 다양한 분야에서 체계적이고 효율적인 문제 해결을 위한 사고 방식으로 발전해왔다.
정의와 본질 알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.
이는 다음과 같은 핵심 특성을 가진다:
단계적 분해: 복잡한 문제를 작고 관리 가능한 부분들로 나누는 능력 논리적 순서화: 문제 해결 단계를 효율적이고 논리적인 순서로 배열하는 능력 추상화: 문제의 본질을 파악하고 불필요한 세부사항을 제거하는 능력 패턴 인식: 문제들 사이의 공통점을 찾고 일반화하는 능력 효율성 고려: 자원(시간, 공간 등)을 최적화하는 해결책을 모색하는 능력 알고리즘적 사고의 구성 요소 문제 분해(Decomposition)
복잡한 문제를 더 작고 관리 가능한 부분들로 나누는 과정:
...</p></div><footer class=entry-footer><span title='2024-12-27 07:00:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Algorithmic Thinking" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/algorithmic-thinking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Algorithmic Complexity</h2></header><div class=entry-content><p>Algorithmic Complexity 알고리즘 복잡도는 프로그램이나 알고리즘이 문제를 해결할 때 소요하는 시간과 공간, 즉 컴퓨팅 자원의 사용량을 입력 크기에 따라 수학적으로 분석하는 방법이다. 이러한 분석을 통해 하드웨어나 구현 세부사항에 구애받지 않고 알고리즘의 근본적인 효율성을 평가할 수 있다.
여러 알고리즘 중 어떤 것이 더 효율적인지, 또는 주어진 알고리즘이 특정 문제를 해결하는 데 얼마나 많은 자원(시간, 메모리)이 필요한지를 수학적으로 표현한다. 알고리즘 복잡도를 이해하면 더 나은 프로그램을 설계하고 최적화하는 데 큰 도움이 된다.
알고리즘 복잡도 분석은 문제 해결 과정에서 효율적인 알고리즘 선택과 최적화를 가능하게 하며, 이를 통해 작은 규모의 데이터뿐 아니라 대규모 데이터 처리 시에도 실행 시간과 메모리 사용을 예측할 수 있다. 또한, 알고리즘 복잡도는 비효율적인 알고리즘을 사전에 식별하고 개선할 수 있는 기준을 제공하므로, 실제 응용 프로그램 개발이나 시스템 설계에서 매우 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-12-06 11:12:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Algorithmic Complexity" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/mathematical-foundations/complexity-analysis/asymptotic-analysis/algorithmic-complexity/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정렬 알고리즘 (Sorting Algorithms)</h2></header><div class=entry-content><p>정렬 알고리즘 (Sorting Algorithms) 정렬 알고리즘은 컴퓨터 과학에서 가장 기본적이면서도 중요한 알고리즘 중 하나이다.
데이터를 특정 순서(일반적으로 오름차순이나 내림차순)로 재배열하는 과정으로, 데이터 처리와 분석의 기초가 된다.
단순한 버블 정렬부터 복잡한 하이브리드 알고리즘까지, 각각의 정렬 알고리즘은 특정 상황에서 고유한 장점을 가지고 있다.
효율적인 소프트웨어 개발을 위해서는 다양한 정렬 알고리즘의 동작 원리, 시간 및 공간 복잡도, 안정성 등을 이해하고, 상황에 맞는 최적의 알고리즘을 선택할 수 있어야 한다. 또한, 데이터의 특성과 하드웨어/소프트웨어 환경을 고려한 최적화를 통해 정렬 성능을 더욱 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-14 01:26:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 정렬 알고리즘 (Sorting Algorithms)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>튜링 기계 (Turing Machine)</h2></header><div class=entry-content><p>튜링 기계 (Turing Machine) 튜링 기계는 1936년 영국의 수학자이자 컴퓨터 과학자인 앨런 튜링(Alan Turing)이 “계산 가능한 수에 관하여(On Computable Numbers, with an Application to the Entscheidungsproblem)“라는 논문에서 처음 소개한 수학적 모델이다.
튜링은 당시 힐베르트(David Hilbert)의 결정 문제(Entscheidungsproblem)라는 수학적 난제를 해결하기 위해 이 개념을 고안했다.
결정 문제란 “주어진 명제가 참인지 거짓인지를 판별할 수 있는 알고리즘이 존재하는가?“라는 질문이었다. 튜링은 이 문제에 대한 답을 찾기 위해 “계산 가능성"의 정확한 수학적 정의가 필요하다고 생각했고, 그 결과 튜링 기계라는 추상적 기계 모델을 고안했다.
...</p></div><footer class=entry-footer><span title='2024-10-13 10:07:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 튜링 기계 (Turing Machine)" href=https://buenhyden.github.io/posts/data-structures--algorithms/foundations/computational-models/machine-models/turing-machine/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>