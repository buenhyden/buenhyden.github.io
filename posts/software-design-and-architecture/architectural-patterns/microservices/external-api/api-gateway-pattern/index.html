<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>API Gateway Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,External-API,API-Gateway-Pattern"><meta name=description content="마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/api-gateway-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/api-gateway-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/api-gateway-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="API Gateway Pattern"><meta property="og:description" content="마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-14T01:22:00+00:00"><meta property="article:modified_time" content="2024-11-14T01:22:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="External-API"><meta property="article:tag" content="API-Gateway-Pattern"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="API Gateway Pattern"><meta name=twitter:description content="마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Architectural Patterns","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/"},{"@type":"ListItem","position":4,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/"},{"@type":"ListItem","position":5,"name":"External API","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/"},{"@type":"ListItem","position":6,"name":"API Gateway Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/api-gateway-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"API Gateway Pattern","name":"API Gateway Pattern","description":"마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소","keywords":["Software-Design-and-Architecture","MSA-Patterns","External-API","API-Gateway-Pattern"],"articleBody":"API Gateway Pattern API Gateway Pattern은 마이크로서비스 아키텍처에서 중요한 역할을 하는 디자인 패턴이다.\nAPI Gateway Pattern은 클라이언트와 백엔드 마이크로서비스 사이에 위치하는 중간 계층으로, 다음과 같은 주요 기능을 제공한다:\n단일 진입점: 클라이언트는 여러 마이크로서비스에 직접 접근하지 않고, API Gateway를 통해 단일 엔드포인트로 접근한다. 요청 라우팅: 클라이언트의 요청을 적절한 마이크로서비스로 전달한다. 프로토콜 변환: 클라이언트와 백엔드 서비스 간의 프로토콜 차이를 해결한다. 요청/응답 변환: 클라이언트의 요구사항에 맞게 데이터 형식을 변환한다. https://learn.microsoft.com/ko-kr/azure/architecture/microservices/design/gateway\nAPI Gateway Pattern의 주요 기능 인증 및 인가\nAPI Gateway는 모든 요청에 대해 인증과 인가를 처리한다.\n이를 통해 보안을 중앙화하고 각 마이크로서비스의 부담을 줄일 수 있다.\n로드 밸런싱\n여러 서비스 인스턴스 간에 트래픽을 분산시켜 시스템의 안정성과 성능을 향상시킨다.\n캐싱\n자주 요청되는 데이터를 캐시하여 응답 시간을 단축하고 백엔드 서비스의 부하를 줄인다.\n요청 집계\n여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공한다.\n이는 네트워크 호출을 줄이고 클라이언트의 복잡성을 감소시킨다.\n로깅 및 모니터링\n모든 API 호출에 대한 로그를 생성하고 시스템의 상태를 모니터링한다.\n이를 통해 문제 진단과 성능 최적화가 가능해진다.\nAPI Gateway Pattern 구현 방법 API Gateway를 구현하는 방법에는 크게 두 가지가 있다:\n프레임워크 사용: Spring Cloud Gateway, Netflix Zuul 등의 프레임워크를 사용하여 구현할 수 있다. 직접 구현: 특정 비즈니스 요구사항에 맞춰 API Gateway를 직접 개발할 수 있다. API Gateway Pattern의 장단점 장점:\n클라이언트와 마이크로서비스 간의 결합도 감소 중앙화된 보안 관리 성능 최적화 및 확장성 향상 클라이언트 요구사항에 맞는 API 제공 용이 단점:\n추가적인 네트워크 홉으로 인한 지연 가능성 단일 실패 지점(Single Point of Failure) 위험 구현 및 관리의 복잡성 증가 API Gateway Pattern 사용 시 고려사항 고가용성 확보: API Gateway의 장애가 전체 시스템에 영향을 미치지 않도록 해야 한다. 성능 최적화: 캐싱, 비동기 처리 등을 통해 지연을 최소화해야 한다. 확장성 고려: 트래픽 증가에 대비하여 수평적 확장이 가능하도록 설계해야 한다. 모니터링 및 로깅: 시스템의 상태를 실시간으로 파악하고 문제를 신속히 해결할 수 있어야 한다. 참고 및 출처 ","wordCount":"288","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-14T01:22:00Z","dateModified":"2024-11-14T01:22:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/api-gateway-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/>Architectural Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/>MSA Pattern</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/>External API</a></div><h1 class="post-title entry-hint-parent">API Gateway Pattern</h1><div class=post-description>마이크로서비스 아키텍처에서 클라이언트와 백엔드 서비스 간의 단일 진입점 역할을 수행하는 중요한 구성 요소</div><div class=post-meta><span title='2024-11-14 01:22:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;288 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/Architectural%20Patterns/Microservices/External%20API/API-Gateway-Pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#api-gateway-pattern>API Gateway Pattern</a><ul><li><a href=#api-gateway-pattern의-주요-기능>API Gateway Pattern의 주요 기능</a></li><li><a href=#api-gateway-pattern-구현-방법>API Gateway Pattern 구현 방법</a></li><li><a href=#api-gateway-pattern의-장단점>API Gateway Pattern의 장단점</a></li><li><a href=#api-gateway-pattern-사용-시-고려사항>API Gateway Pattern 사용 시 고려사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=api-gateway-pattern>API Gateway Pattern<a hidden class=anchor aria-hidden=true href=#api-gateway-pattern>#</a></h2><p>API Gateway Pattern은 마이크로서비스 아키텍처에서 중요한 역할을 하는 디자인 패턴이다.</p><p>API Gateway Pattern은 클라이언트와 백엔드 마이크로서비스 사이에 위치하는 중간 계층으로, 다음과 같은 주요 기능을 제공한다:</p><ol><li>단일 진입점: 클라이언트는 여러 마이크로서비스에 직접 접근하지 않고, API Gateway를 통해 단일 엔드포인트로 접근한다.</li><li>요청 라우팅: 클라이언트의 요청을 적절한 마이크로서비스로 전달한다.</li><li>프로토콜 변환: 클라이언트와 백엔드 서비스 간의 프로토콜 차이를 해결한다.</li><li>요청/응답 변환: 클라이언트의 요구사항에 맞게 데이터 형식을 변환한다.</li></ol><p><figure><img alt="API Gateway" loading=lazy src=/img/gateway.png><figcaption>https://learn.microsoft.com/ko-kr/azure/architecture/microservices/design/gateway</figcaption></figure></p><h3 id=api-gateway-pattern의-주요-기능>API Gateway Pattern의 주요 기능<a hidden class=anchor aria-hidden=true href=#api-gateway-pattern의-주요-기능>#</a></h3><ol><li><p>인증 및 인가<br>API Gateway는 모든 요청에 대해 인증과 인가를 처리한다.<br>이를 통해 보안을 중앙화하고 각 마이크로서비스의 부담을 줄일 수 있다.</p></li><li><p>로드 밸런싱<br>여러 서비스 인스턴스 간에 트래픽을 분산시켜 시스템의 안정성과 성능을 향상시킨다.</p></li><li><p>캐싱<br>자주 요청되는 데이터를 캐시하여 응답 시간을 단축하고 백엔드 서비스의 부하를 줄인다.</p></li><li><p>요청 집계<br>여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공한다.<br>이는 네트워크 호출을 줄이고 클라이언트의 복잡성을 감소시킨다.</p></li><li><p>로깅 및 모니터링<br>모든 API 호출에 대한 로그를 생성하고 시스템의 상태를 모니터링한다.<br>이를 통해 문제 진단과 성능 최적화가 가능해진다.</p></li></ol><h3 id=api-gateway-pattern-구현-방법>API Gateway Pattern 구현 방법<a hidden class=anchor aria-hidden=true href=#api-gateway-pattern-구현-방법>#</a></h3><p>API Gateway를 구현하는 방법에는 크게 두 가지가 있다:</p><ol><li>프레임워크 사용: Spring Cloud Gateway, Netflix Zuul 등의 프레임워크를 사용하여 구현할 수 있다.</li><li>직접 구현: 특정 비즈니스 요구사항에 맞춰 API Gateway를 직접 개발할 수 있다.</li></ol><h3 id=api-gateway-pattern의-장단점>API Gateway Pattern의 장단점<a hidden class=anchor aria-hidden=true href=#api-gateway-pattern의-장단점>#</a></h3><p>장점:</p><ol><li>클라이언트와 마이크로서비스 간의 결합도 감소</li><li>중앙화된 보안 관리</li><li>성능 최적화 및 확장성 향상</li><li>클라이언트 요구사항에 맞는 API 제공 용이</li></ol><p>단점:</p><ol><li>추가적인 네트워크 홉으로 인한 지연 가능성</li><li>단일 실패 지점(Single Point of Failure) 위험</li><li>구현 및 관리의 복잡성 증가</li></ol><h3 id=api-gateway-pattern-사용-시-고려사항>API Gateway Pattern 사용 시 고려사항<a hidden class=anchor aria-hidden=true href=#api-gateway-pattern-사용-시-고려사항>#</a></h3><ol><li>고가용성 확보: API Gateway의 장애가 전체 시스템에 영향을 미치지 않도록 해야 한다.</li><li>성능 최적화: 캐싱, 비동기 처리 등을 통해 지연을 최소화해야 한다.</li><li>확장성 고려: 트래픽 증가에 대비하여 수평적 확장이 가능하도록 설계해야 한다.</li><li>모니터링 및 로깅: 시스템의 상태를 실시간으로 파악하고 문제를 신속히 해결할 수 있어야 한다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/external-api/>External-API</a></li><li><a href=https://buenhyden.github.io/tags/api-gateway-pattern/>API-Gateway-Pattern</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/backend-for-frontend/><span class=title>« Prev</span><br><span>Backend for Frontend Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/deployment/service-deployment-platform/><span class=title>Next »</span><br><span>Service deployment platform</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>