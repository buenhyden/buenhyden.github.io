<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backend for Frontend Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,External-API,Backend-for-Frontend-Pattern"><meta name=description content="BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/backend-for-frontend/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/backend-for-frontend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/backend-for-frontend/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Backend for Frontend Pattern"><meta property="og:description" content="BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-14T10:07:00+00:00"><meta property="article:modified_time" content="2024-11-14T10:07:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="External-API"><meta property="article:tag" content="Backend-for-Frontend-Pattern"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Backend for Frontend Pattern"><meta name=twitter:description content="BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Architectural Patterns","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/"},{"@type":"ListItem","position":4,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/"},{"@type":"ListItem","position":5,"name":"External API","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/"},{"@type":"ListItem","position":6,"name":"Backend for Frontend Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/backend-for-frontend/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Backend for Frontend Pattern","name":"Backend for Frontend Pattern","description":"BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다.","keywords":["Software-Design-and-Architecture","MSA-Patterns","External-API","Backend-for-Frontend-Pattern"],"articleBody":"Backend for Frontend Pattern Backend for Frontend (BFF) 패턴은 프론트엔드 애플리케이션을 위한 전용 백엔드 서비스를 구축하는 소프트웨어 아키텍처 패턴이다.\nBFF 패턴은 각 프론트엔드 애플리케이션(웹, 모바일 등)의 특정 요구사항에 맞춰 설계된 백엔드 서비스를 제공한다.\n이는 프론트엔드와 백엔드 사이에 위치하는 중간 계층으로, 프론트엔드의 요구사항에 최적화된 API를 제공한다.\n전통적인 모놀리식 아키텍처에서는 모든 클라이언트가 동일한 백엔드 API를 사용한다. 그러나 각 클라이언트의 요구사항이 다를 수 있으며, 특히 모바일 앱과 웹 애플리케이션은 데이터 사용량, 화면 크기, 네트워크 상태 등에서 차이가 있다. 이러한 차이를 고려하지 않고 동일한 API를 사용할 경우, 불필요한 데이터 전송이나 복잡한 데이터 처리 로직이 클라이언트에 부과될 수 있다. BFF 패턴은 이러한 문제를 해결하기 위해 각 클라이언트에 특화된 백엔드 서비스를 제공하여 효율성을 높인다.\nBFF 패턴의 주요 특징 클라이언트 특화: 각 클라이언트 유형(웹, 모바일, IoT 등)에 맞춤형 백엔드 서비스를 제공한다. 데이터 최적화: 프론트엔드에 필요한 데이터만을 제공하여 네트워크 효율성을 높인다. 비즈니스 로직 처리: 프론트엔드의 복잡한 비즈니스 로직을 BFF 계층에서 처리한다. API 통합: 여러 마이크로서비스의 API를 통합하여 프론트엔드에 단일 인터페이스를 제공한다. BFF 패턴의 장점 성능 향상: 각 프론트엔드에 최적화된 데이터를 제공하여 성능을 개선한다. 유지보수 용이성: 프론트엔드와 백엔드의 관심사를 분리하여 유지보수가 쉬워진다. 유연성: 각 프론트엔드의 요구사항에 맞게 API를 쉽게 수정할 수 있다. 보안 강화: 민감한 정보를 숨기고 필요한 데이터만 프론트엔드에 전달할 수 있다. BFF 패턴 구현 방법 프론트엔드 요구사항 분석: 각 프론트엔드 애플리케이션의 특정 요구사항을 파악한다. BFF 서비스 설계: 프론트엔드 요구사항에 맞는 API를 설계한다. 마이크로서비스 통합: 여러 백엔드 마이크로서비스와 통신하여 필요한 데이터를 수집한다. 데이터 변환 및 최적화: 수집된 데이터를 프론트엔드에 적합한 형태로 변환한다. 에러 핸들링: 백엔드 에러를 프론트엔드에 적절한 형태로 변환한다. BFF 패턴 사용 시 고려사항 코드 중복: 여러 BFF 간에 공통 기능의 중복을 최소화해야 한다. 복잡성 관리: 여러 BFF를 관리해야 하므로 운영 복잡성이 증가할 수 있다. 일관성 유지: 여러 BFF 간의 비즈니스 로직 일관성을 유지해야 한다. 확장성: 새로운 프론트엔드 요구사항에 따라 BFF를 쉽게 확장할 수 있어야 한다. BFF 패턴은 프론트엔드와 백엔드 간의 효율적인 통신을 가능하게 하며, 각 프론트엔드의 특성에 맞는 최적화된 서비스를 제공할 수 있다. 하지만 구현 복잡성과 관리 부담이 증가할 수 있으므로, 프로젝트의 규모와 요구사항을 고려하여 적절히 적용해야 한다.\n참고 및 출처 ","wordCount":"325","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-14T10:07:00Z","dateModified":"2024-11-14T10:07:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/backend-for-frontend/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/>Architectural Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/>MSA Pattern</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/>External API</a></div><h1 class="post-title entry-hint-parent">Backend for Frontend Pattern</h1><div class=post-description>BFF는 특정 프론트엔드 애플리케이션을 위해 맞춤형으로 설계된 백엔드 서비스를 의미한다. 이는 마이크로서비스 아키텍처에서 자주 사용되는 패턴으로, 각각의 클라이언트(웹, 모바일, 태블릿 등)가 자신만의 전용 백엔드 서비스를 갖게 된다.</div><div class=post-meta><span title='2024-11-14 10:07:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;325 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/Architectural%20Patterns/Microservices/External%20API/Backend-for-Frontend.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#backend-for-frontend-pattern>Backend for Frontend Pattern</a><ul><li><a href=#bff-패턴의-주요-특징>BFF 패턴의 주요 특징</a></li><li><a href=#bff-패턴의-장점>BFF 패턴의 장점</a></li><li><a href=#bff-패턴-구현-방법>BFF 패턴 구현 방법</a></li><li><a href=#bff-패턴-사용-시-고려사항>BFF 패턴 사용 시 고려사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=backend-for-frontend-pattern>Backend for Frontend Pattern<a hidden class=anchor aria-hidden=true href=#backend-for-frontend-pattern>#</a></h2><p>Backend for Frontend (BFF) 패턴은 프론트엔드 애플리케이션을 위한 전용 백엔드 서비스를 구축하는 소프트웨어 아키텍처 패턴이다.</p><p>BFF 패턴은 각 프론트엔드 애플리케이션(웹, 모바일 등)의 특정 요구사항에 맞춰 설계된 백엔드 서비스를 제공한다.<br>이는 프론트엔드와 백엔드 사이에 위치하는 중간 계층으로, 프론트엔드의 요구사항에 최적화된 API를 제공한다.</p><p>전통적인 모놀리식 아키텍처에서는 모든 클라이언트가 동일한 백엔드 API를 사용한다. 그러나 각 클라이언트의 요구사항이 다를 수 있으며, 특히 모바일 앱과 웹 애플리케이션은 데이터 사용량, 화면 크기, 네트워크 상태 등에서 차이가 있다. 이러한 차이를 고려하지 않고 동일한 API를 사용할 경우, 불필요한 데이터 전송이나 복잡한 데이터 처리 로직이 클라이언트에 부과될 수 있다. BFF 패턴은 이러한 문제를 해결하기 위해 각 클라이언트에 특화된 백엔드 서비스를 제공하여 효율성을 높인다.</p><h3 id=bff-패턴의-주요-특징>BFF 패턴의 주요 특징<a hidden class=anchor aria-hidden=true href=#bff-패턴의-주요-특징>#</a></h3><ol><li><strong>클라이언트 특화</strong>: 각 클라이언트 유형(웹, 모바일, IoT 등)에 맞춤형 백엔드 서비스를 제공한다.</li><li><strong>데이터 최적화</strong>: 프론트엔드에 필요한 데이터만을 제공하여 네트워크 효율성을 높인다.</li><li><strong>비즈니스 로직 처리</strong>: 프론트엔드의 복잡한 비즈니스 로직을 BFF 계층에서 처리한다.</li><li><strong>API 통합</strong>: 여러 마이크로서비스의 API를 통합하여 프론트엔드에 단일 인터페이스를 제공한다.</li></ol><h3 id=bff-패턴의-장점>BFF 패턴의 장점<a hidden class=anchor aria-hidden=true href=#bff-패턴의-장점>#</a></h3><ol><li><strong>성능 향상</strong>: 각 프론트엔드에 최적화된 데이터를 제공하여 성능을 개선한다.</li><li><strong>유지보수 용이성</strong>: 프론트엔드와 백엔드의 관심사를 분리하여 유지보수가 쉬워진다.</li><li><strong>유연성</strong>: 각 프론트엔드의 요구사항에 맞게 API를 쉽게 수정할 수 있다.</li><li><strong>보안 강화</strong>: 민감한 정보를 숨기고 필요한 데이터만 프론트엔드에 전달할 수 있다.</li></ol><h3 id=bff-패턴-구현-방법>BFF 패턴 구현 방법<a hidden class=anchor aria-hidden=true href=#bff-패턴-구현-방법>#</a></h3><ol><li><strong>프론트엔드 요구사항 분석</strong>: 각 프론트엔드 애플리케이션의 특정 요구사항을 파악한다.</li><li><strong>BFF 서비스 설계</strong>: 프론트엔드 요구사항에 맞는 API를 설계한다.</li><li><strong>마이크로서비스 통합</strong>: 여러 백엔드 마이크로서비스와 통신하여 필요한 데이터를 수집한다.</li><li><strong>데이터 변환 및 최적화</strong>: 수집된 데이터를 프론트엔드에 적합한 형태로 변환한다.</li><li><strong>에러 핸들링</strong>: 백엔드 에러를 프론트엔드에 적절한 형태로 변환한다.</li></ol><h3 id=bff-패턴-사용-시-고려사항>BFF 패턴 사용 시 고려사항<a hidden class=anchor aria-hidden=true href=#bff-패턴-사용-시-고려사항>#</a></h3><ol><li><strong>코드 중복</strong>: 여러 BFF 간에 공통 기능의 중복을 최소화해야 한다.</li><li><strong>복잡성 관리</strong>: 여러 BFF를 관리해야 하므로 운영 복잡성이 증가할 수 있다.</li><li><strong>일관성 유지</strong>: 여러 BFF 간의 비즈니스 로직 일관성을 유지해야 한다.</li><li><strong>확장성</strong>: 새로운 프론트엔드 요구사항에 따라 BFF를 쉽게 확장할 수 있어야 한다.</li></ol><p>BFF 패턴은 프론트엔드와 백엔드 간의 효율적인 통신을 가능하게 하며, 각 프론트엔드의 특성에 맞는 최적화된 서비스를 제공할 수 있다. 하지만 구현 복잡성과 관리 부담이 증가할 수 있으므로, 프로젝트의 규모와 요구사항을 고려하여 적절히 적용해야 한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/external-api/>External-API</a></li><li><a href=https://buenhyden.github.io/tags/backend-for-frontend-pattern/>Backend-for-Frontend-Pattern</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/discovery/client-side-discovery/><span class=title>« Prev</span><br><span>Client-side discovery</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/external-api/api-gateway-pattern/><span class=title>Next »</span><br><span>API Gateway Pattern</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>