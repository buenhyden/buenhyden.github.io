<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Observability | hyunyoun's Blog</title><meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,Observability"><meta name=description content="현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Observability"><meta property="og:description" content="현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Observability"><meta name=twitter:description content="현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Observability","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Observability</h1><div class=post-description>현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다.</div></header><div class=post-content><h2 id=observability>Observability<a hidden class=anchor aria-hidden=true href=#observability>#</a></h2><p><strong>Observability(관측 가능성)</strong> 은 현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다. 이는 단순한 모니터링을 넘어, 복잡한 시스템의 성능을 분석하고 문제를 예측하며 해결할 수 있는 깊은 통찰력을 제공한다.</p><p>옵저버빌리티와 모니터링의 차이는 다음과 같다:</p><ul><li><strong>모니터링</strong>: 알고 있는 문제와 예상된 실패 모드를 추적한다.</li><li><strong>옵저버빌리티</strong>: 예상하지 못한 문제와 새로운 실패 모드를 발견하고 이해하는 데 중점을 둔다.</li></ul><h3 id=observability의-필요성>Observability의 필요성<a hidden class=anchor aria-hidden=true href=#observability의-필요성>#</a></h3><p>현대 소프트웨어 시스템은 마이크로서비스 아키텍처와 클라우드 네이티브 환경으로 인해 점점 더 복잡해지고 있다.</p><p>이러한 환경에서 Observability는 다음과 같은 이유로 필수적이다:</p><ul><li><strong>문제 예측 및 예방:</strong><ul><li>메트릭과 로그를 분석하여 이상 징후를 조기에 감지하고 문제 발생 전에 대응할 수 있다.</li></ul></li><li><strong>빠른 문제 해결:</strong><ul><li>트레이스를 통해 문제의 근본 원인을 신속히 파악하여 MTTR(Mean Time to Resolution)을 단축한다.</li></ul></li><li><strong>시스템 신뢰성 향상:</strong><ul><li>지속적인 성능 모니터링과 자동화된 알림을 통해 다운타임을 줄이고 사용자 경험을 개선한다.</li></ul></li></ul><h3 id=옵저버빌리티의-세-가지-핵심-요소>옵저버빌리티의 세 가지 핵심 요소<a hidden class=anchor aria-hidden=true href=#옵저버빌리티의-세-가지-핵심-요소>#</a></h3><p>옵저버빌리티는 일반적으로 세 가지 주요 데이터 유형(흔히 &ldquo;세 가지 기둥"이라고 불림)을 중심으로 구축된다:</p><h4 id=메트릭metrics>메트릭(Metrics)<a hidden class=anchor aria-hidden=true href=#메트릭metrics>#</a></h4><ul><li><strong>정의</strong>: 시간 경과에 따른 시스템의 수치적 측정값.</li><li><strong>특징</strong>: 집계하기 쉽고, 저장 공간이 적게 필요하며, 실시간 대시보드 및 알림에 적합하다.</li><li><strong>예시</strong>: CPU 사용률, 메모리 소비, 요청 처리 시간, 오류율 등</li><li><strong>도구</strong>: Prometheus, Grafana, AWS CloudWatch, Datadog</li></ul><p>메트릭은 다음과 같은 유형으로 분류될 수 있다:</p><ul><li><strong>카운터(Counters)</strong>: 증가하기만 하는 누적 측정값(예: 처리된 총 요청 수)</li><li><strong>게이지(Gauges)</strong>: 시간에 따라 증가하거나 감소할 수 있는 값(예: 현재 메모리 사용량)</li><li><strong>히스토그램(Histograms)</strong>: 값의 분포를 측정(예: 응답 시간의 분포)</li><li><strong>요약(Summaries)</strong>: 히스토그램과 유사하지만 서버 측에서 계산된 백분위수 포함</li></ul><h4 id=로그logs>로그(Logs)<a hidden class=anchor aria-hidden=true href=#로그logs>#</a></h4><ul><li><strong>정의</strong>: 시스템 이벤트의 시간순 기록.</li><li><strong>특징</strong>: 상세한 컨텍스트 정보를 제공하며, 문제 진단에 필수적이다.</li><li><strong>유형</strong>: 구조화된 로그(JSON 형식), 비구조화된 로그(텍스트 파일)</li><li><strong>도구</strong>: ELK Stack(Elasticsearch, Logstash, Kibana), Splunk, Datadog, AWS CloudWatch Logs</li></ul><p>효과적인 로깅을 위한 핵심 사항:</p><ul><li>구조화된 로그 형식 사용(JSON 등)</li><li>일관된 로그 레벨 적용(DEBUG, INFO, WARN, ERROR, FATAL)</li><li>상관관계 ID 포함(트랜잭션 또는 요청 ID)</li><li>민감한 정보 제외</li></ul><h4 id=트레이스traces>트레이스(Traces)<a hidden class=anchor aria-hidden=true href=#트레이스traces>#</a></h4><ul><li><strong>정의</strong>: 분산 시스템을 통과하는 요청의 전체 경로를 추적한다.</li><li><strong>특징</strong>: 여러 서비스와 시스템에 걸친 요청 흐름을 시각화한다.</li><li><strong>구성요소</strong>: 스팬(span - 작업의 단위), 트레이스 ID, 스팬 ID, 부모 스팬 ID</li><li><strong>도구</strong>: Jaeger, Zipkin, AWS X-Ray, Datadog APM, New Relic</li></ul><p>분산 트레이싱의 주요 이점:</p><ul><li>서비스 간 통신의 병목 현상 식별</li><li>오류가 발생한 특정 지점 파악</li><li>엔드-투-엔드 성능 분석</li><li>서비스 의존성 맵 생성</li></ul><h3 id=옵저버빌리티-구현-방법>옵저버빌리티 구현 방법<a hidden class=anchor aria-hidden=true href=#옵저버빌리티-구현-방법>#</a></h3><h4 id=1-계측instrumentation>1. 계측(Instrumentation)<a hidden class=anchor aria-hidden=true href=#1-계측instrumentation>#</a></h4><p>계측은 애플리케이션 코드에 모니터링 기능을 추가하는 과정이다. 이는 옵저버빌리티의 기초가 된다.</p><p><strong>계측 유형</strong>:</p><ul><li><strong>수동 계측</strong>: 개발자가 직접 코드에 모니터링 로직을 추가한다.</li><li><strong>자동 계측</strong>: 에이전트나 라이브러리가 자동으로 데이터를 수집한다.</li></ul><p><strong>효과적인 계측을 위한 접근 방식</strong>:</p><ul><li>OpenTelemetry와 같은 표준화된 프레임워크 사용</li><li>중요한 비즈니스 트랜잭션 우선 계측</li><li>코드 경로의 시작과 끝 표시</li><li>중요한 외부 서비스 호출 계측</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># OpenTelemetry를 사용한 Python 계측 예시</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>opentelemetry</span> <span class=kn>import</span> <span class=n>trace</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>opentelemetry.sdk.trace</span> <span class=kn>import</span> <span class=n>TracerProvider</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>opentelemetry.sdk.trace.export</span> <span class=kn>import</span> <span class=n>ConsoleSpanExporter</span><span class=p>,</span> <span class=n>BatchSpanProcessor</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 트레이서 설정</span>
</span></span><span class=line><span class=cl><span class=n>trace</span><span class=o>.</span><span class=n>set_tracer_provider</span><span class=p>(</span><span class=n>TracerProvider</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>tracer</span> <span class=o>=</span> <span class=n>trace</span><span class=o>.</span><span class=n>get_tracer</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>span_processor</span> <span class=o>=</span> <span class=n>BatchSpanProcessor</span><span class=p>(</span><span class=n>ConsoleSpanExporter</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>trace</span><span class=o>.</span><span class=n>get_tracer_provider</span><span class=p>()</span><span class=o>.</span><span class=n>add_span_processor</span><span class=p>(</span><span class=n>span_processor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 함수 계측</span>
</span></span><span class=line><span class=cl><span class=nd>@tracer.start_as_current_span</span><span class=p>(</span><span class=s2>&#34;process_request&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>process_request</span><span class=p>(</span><span class=n>request_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 비즈니스 로직</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>do_something</span><span class=p>(</span><span class=n>request_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 사용자 정의 속성 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>current_span</span> <span class=o>=</span> <span class=n>trace</span><span class=o>.</span><span class=n>get_current_span</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>current_span</span><span class=o>.</span><span class=n>set_attribute</span><span class=p>(</span><span class=s2>&#34;request.size&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>request_data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>current_span</span><span class=o>.</span><span class=n>set_attribute</span><span class=p>(</span><span class=s2>&#34;processing.result&#34;</span><span class=p>,</span> <span class=s2>&#34;success&#34;</span> <span class=k>if</span> <span class=n>result</span> <span class=k>else</span> <span class=s2>&#34;failure&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=데이터-수집-및-저장>데이터 수집 및 저장<a hidden class=anchor aria-hidden=true href=#데이터-수집-및-저장>#</a></h4><p>수집된 텔레메트리 데이터를 효율적으로 저장하고 처리하는 인프라를 구축해야 한다.</p><p><strong>주요 고려사항</strong>:</p><ul><li>확장성 있는 스토리지 솔루션 선택</li><li>데이터 보존 정책 설정</li><li>샘플링 전략 구현(필요한 경우)</li><li>보안 및 개인정보 보호 고려</li></ul><h4 id=시각화-및-분석>시각화 및 분석<a hidden class=anchor aria-hidden=true href=#시각화-및-분석>#</a></h4><p>수집된 데이터를 의미 있는 인사이트로 변환하는 도구와 대시보드를 구축한다.</p><p><strong>효과적인 대시보드 설계 원칙</strong>:</p><ul><li>RED 방법론(Rate, Error, Duration) 또는 USE 방법론(Utilization, Saturation, Errors) 적용</li><li>비즈니스 KPI와 기술 메트릭 모두 표시</li><li>관련 정보 그룹화</li><li>이상치를 빠르게 식별할 수 있는 시각화</li></ul><h4 id=알림-및-이상-탐지>알림 및 이상 탐지<a hidden class=anchor aria-hidden=true href=#알림-및-이상-탐지>#</a></h4><p>문제가 발생하면 적시에 알림을 받고 가능한 경우 자동으로 대응하는 시스템을 구축한다.</p><p><strong>알림 설계의 모범 사례</strong>:</p><ul><li>알림 피로를 줄이기 위한 우선순위 지정</li><li>경고에 문제 해결 가이드 연결</li><li>정적 임계값보다 동적 임계값 선호</li><li>상관관계 알림 구현(관련 알림 그룹화)</li></ul><h3 id=observability-도구>Observability 도구<a hidden class=anchor aria-hidden=true href=#observability-도구>#</a></h3><p>다양한 Observability 도구가 있으며, 각 도구는 특정 목적에 최적화되어 있다.</p><h4 id=datadog>Datadog<a hidden class=anchor aria-hidden=true href=#datadog>#</a></h4><p>Datadog은 통합된 모니터링 및 보안 플랫폼으로, 인프라, 애플리케이션, 로그를 단일 플랫폼에서 관리할 수 있다.</p><p><strong>주요 기능</strong>:</p><ul><li>200개 이상의 기술과의 즉시 통합</li><li>맞춤형 대시보드</li><li>분산 트레이싱</li><li>로그 관리 및 분석</li><li>인프라 모니터링</li><li>실시간 알림</li></ul><h4 id=aws-cloudwatch>AWS CloudWatch<a hidden class=anchor aria-hidden=true href=#aws-cloudwatch>#</a></h4><p>AWS 서비스를 위한 모니터링 및 관찰 서비스로, AWS 리소스와 애플리케이션의 메트릭을 수집하고 추적한다.</p><p><strong>주요 기능</strong>:</p><ul><li>자동화된 대시보드</li><li>이상 탐지</li><li>CloudWatch Logs</li><li>CloudWatch Events</li><li>AWS X-Ray와의 통합</li></ul><h4 id=sentry>Sentry<a hidden class=anchor aria-hidden=true href=#sentry>#</a></h4><p>주로 애플리케이션 오류 추적 및 성능 모니터링에 중점을 둔 도구이다.</p><p><strong>주요 기능</strong>:</p><ul><li>실시간 오류 추적</li><li>릴리스 건전성 모니터링</li><li>성능 모니터링</li><li>이슈 그룹화 및 우선순위 지정</li><li>다양한 프로그래밍 언어 지원</li></ul><h4 id=new-relic>New Relic<a hidden class=anchor aria-hidden=true href=#new-relic>#</a></h4><p>종합적인 옵저버빌리티 플랫폼으로, 애플리케이션 성능 모니터링부터 인프라 모니터링까지 폭넓은 기능을 제공한다.</p><p><strong>주요 기능</strong>:</p><ul><li>APM(애플리케이션 성능 모니터링)</li><li>분산 트레이싱</li><li>인프라 모니터링</li><li>로그 관리</li><li>사용자 경험 모니터링</li></ul><h4 id=오픈소스-솔루션>오픈소스 솔루션<a hidden class=anchor aria-hidden=true href=#오픈소스-솔루션>#</a></h4><p><strong>Prometheus + Grafana</strong>:</p><ul><li>Prometheus: 메트릭 수집 및 알림</li><li>Grafana: 시각화 및 대시보드</li></ul><p><strong>ELK Stack</strong>:</p><ul><li>Elasticsearch: 로그 및 메트릭 저장 및 검색</li><li>Logstash: 데이터 수집 및 변환</li><li>Kibana: 데이터 시각화</li></ul><p><strong>OpenTelemetry</strong>:</p><ul><li>여러 벤더에 구애받지 않는 계측을 위한 표준 API, 라이브러리 및 에이전트</li><li>단일 도구로 메트릭, 로그, 트레이스 수집</li></ul><h3 id=효과적인-옵저버빌리티-구현을-위한-모범-사례>효과적인 옵저버빌리티 구현을 위한 모범 사례<a hidden class=anchor aria-hidden=true href=#효과적인-옵저버빌리티-구현을-위한-모범-사례>#</a></h3><ol><li><p>비즈니스 컨텍스트 포함<br>기술적 메트릭을 비즈니스 성과와 연결한다.<br><strong>예시</strong>:</p><ul><li>트랜잭션당 수익과 API 응답 시간 상관 관계</li><li>사용자 경험 메트릭과 고객 이탈률 연결</li></ul></li><li><p>확장성 있는 아키텍처 설계<br>시스템 성장에 따라 확장될 수 있는 옵저버빌리티 인프라를 구축한다.<br><strong>전략</strong>:</p><ul><li>샘플링 구현</li><li>데이터 압축</li><li>데이터 보존 정책 정의</li><li>클라우드 네이티브 스토리지 솔루션 활용</li></ul></li><li><p>개발자 경험 최적화<br>개발자가 쉽게 코드를 계측하고 옵저버빌리티 데이터를 활용할 수 있도록 한다.<br><strong>접근 방식</strong>:</p><ul><li>표준화된 라이브러리 및 SDK 제공</li><li>자동 계측 활용</li><li>개발 환경에서의 로컬 텔레메트리 시각화</li><li>옵저버빌리티 교육 및 문서화</li></ul></li><li><p>실제 사용자 모니터링(RUM) 구현<br>최종 사용자 관점에서 애플리케이션 성능을 측정한다.<br><strong>측정 항목</strong>:</p><ul><li>페이지 로드 시간</li><li>첫 번째 콘텐츠가 있는 페인트(FCP)</li><li>상호 작용까지의 시간(TTI)</li><li>누적 레이아웃 시프트(CLS)</li></ul></li></ol><h3 id=옵저버빌리티의-미래-동향>옵저버빌리티의 미래 동향<a hidden class=anchor aria-hidden=true href=#옵저버빌리티의-미래-동향>#</a></h3><ol><li><p>AIOps(인공지능 운영)<br>기계 학습 및 AI 기술을 활용하여 옵저버빌리티 데이터에서 인사이트를 도출하고 자동화된 대응을 제공한다.<br><strong>핵심 기능</strong>:</p><ul><li>이상 탐지</li><li>근본 원인 분석</li><li>자동화된 문제 해결</li><li>예측 분석</li></ul></li><li><p>서비스 수준 목표(SLO) 중심 접근 방식<br>기술적 메트릭보다는 비즈니스 성과와 사용자 경험에 초점을 맞춘 모니터링.<br><strong>구성 요소</strong>:</p><ul><li>서비스 수준 지표(SLI)</li><li>서비스 수준 목표(SLO)</li><li>오류 예산</li></ul></li><li><p>eBPF(Extended Berkeley Packet Filter)<br>커널 수준에서 성능 데이터를 안전하게 수집하는 Linux 기술.<br><strong>이점</strong>:</p><ul><li>낮은 오버헤드</li><li>심층적인 시스템 인사이트</li><li>애플리케이션 코드 수정 없이 관찰 가능</li></ul></li><li><p>옵저버빌리티 메시(Mesh)<br>마이크로서비스 환경에서 일관된 텔레메트리 데이터 수집을 제공하는 인프라 레이어이다.<br><strong>특징</strong>:</p><ul><li>서비스 간 통신의 자동 계측</li><li>표준화된 메트릭 및 트레이싱</li><li>정책 기반 트래픽 관리</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Application metrics</h2></header><div class=entry-content><p>Application Metrics 마이크로서비스 아키텍처(MSA) 패턴에서 Observability는 매우 중요한 개념이며, 그 중 Application Metrics는 핵심적인 요소이다.
Application Metrics는 애플리케이션의 성능과 동작을 이해하고 문제를 해결하는 데 필수적인 도구이다.
Application Metrics는 애플리케이션의 성능, 동작, 그리고 건강 상태를 나타내는 수치화된 데이터이다.
이는 개별 작업에 대한 통계를 수집하고, 이를 중앙 집중식 메트릭 서비스에 집계하여 보고 및 경고를 제공하는 패턴을 말한다.
Application Metrics는 MSA 환경에서 Observability를 달성하는 데 핵심적인 역할을 한다.
이를 통해 개발자와 운영팀은 복잡한 시스템을 더 잘 이해하고, 문제를 신속하게 해결하며, 시스템의 성능을 지속적으로 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-16 11:23:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Application metrics" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/application-metrics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Log deployments and changes</h2></header><div class=entry-content><p>Log Deployments and Changes “Log deployments and changes” 패턴은 마이크로서비스 아키텍처(MSA)의 Observability를 향상시키기 위한 전략으로 이 패턴은 시스템의 변경사항을 추적하고 문제 해결을 용이하게 하는 데 중점을 둔다.
패턴의 정의와 목적 “Log deployments and changes” 패턴은 프로덕션 환경에서 발생하는 모든 배포와 변경사항을 로깅하는 것을 의미한다.
이 패턴의 주요 목적은 다음과 같다:
시스템 변경사항과 문제 발생 간의 상관관계 파악 문제 해결 시간 단축 시스템 동작에 대한 이해도 향상 “Log deployments and changes” 패턴을 효과적으로 구현함으로써, 개발팀과 운영팀은 시스템의 변화를 더 잘 이해하고, 문제를 신속하게 해결할 수 있으며, 전반적인 시스템 안정성을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-16 11:23:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log deployments and changes" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/log-deployments-and-changes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Audit Logging</h2></header><div class=entry-content><p>Audit Logging Audit Logging은 시스템 내에서 발생하는 중요한 이벤트와 변경사항을 기록하는 프로세스이다.
이는 사용자 활동, 시스템 변경, 데이터 접근 등을 포함하며, 시스템의 동작을 이해하고 문제를 해결하는 데 필수적이다.
Audit Logging은 MSA 환경에서 시스템의 투명성, 보안성, 그리고 문제 해결 능력을 크게 향상시킨다. 적절히 구현된 Audit Logging 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.
기본 구성 요소 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Audit Log 엔티티 예시 @Entity public class AuditLog { @Id @GeneratedValue private Long id; private String eventType; // 이벤트 유형 private String resourceType; // 리소스 유형 private String resourceId; // 리소스 식별자 private String userId; // 사용자 ID private String action; // 수행된 작업 private String oldValue; // 변경 전 값 private String newValue; // 변경 후 값 private LocalDateTime timestamp; // 발생 시간 private String ipAddress; // IP 주소 private String userAgent; // 사용자 에이전트 // getters, setters } Audit Logging의 중요성 규정 준수: PCI DSS, SOC 2 등의 산업 표준 및 규제 요구사항을 충족하는 데 필요하다. 보안 강화: 비정상적인 활동을 감지하고 보안 위협을 조사하는 데 도움이 된다. 문제 해결: 시스템 장애나 오류의 원인을 파악하는 데 유용하다. 사용자 행동 이해: 고객 지원, 시스템 개선을 위한 인사이트를 제공한다. Audit Logging 구현 방법 중앙 집중식 로깅 서비스: 모든 마이크로서비스의 로그를 한 곳에서 수집하고 저장한다. 표준화된 로그 형식: 일관된 형식을 사용하여 로그 분석을 용이하게 한다. 보안 및 접근 제어: 로그 데이터의 무결성과 기밀성을 보장한다. 확장성 고려: 대량의 로그 데이터를 효율적으로 처리할 수 있어야 한다. Audit Logging 구현 시 고려사항 과도한 로깅 vs 부족한 로깅: 적절한 수준의 로깅을 유지해야 한다. 성능 영향: 로깅이 시스템 성능에 미치는 영향을 최소화해야 한다. 데이터 보존 정책: 로그 데이터의 보존 기간과 방법을 정의해야 한다. 실시간 모니터링: 중요한 이벤트에 대한 실시간 알림 시스템을 구축해야 한다. Audit Logging 도구 및 기술 Elasticsearch, Logstash, Kibana (ELK) 스택: 로그 수집, 저장, 시각화에 널리 사용된다. Serilog:.NET 환경에서 구조화된 로깅을 위한 프레임워크이다. Kafka: 대규모 로그 스트림 처리에 적합한 메시징 시스템이다. Cloud-native 솔루션: AWS CloudWatch, Google Cloud Logging 등이 있다. Audit Logging을 효과적으로 구현하기 위한 방법 비즈니스 로직 내에 로깅 코드 추가: 장점: 구현이 비교적 간단하며, 특정 이벤트에 대한 상세한 로깅이 가능하다. 단점: 비즈니스 로직과 로깅 코드가 혼재되어 코드의 가독성과 유지보수성이 저하될 수 있다. AOP(Aspect-Oriented Programming) 활용: 장점: 비즈니스 로직과 로깅 기능을 분리하여 코드의 모듈성을 향상시킨다. 단점: 메서드명이나 인수에만 접근할 수 있어, 비즈니스 컨텍스트에 따른 상세한 로깅에는 한계가 있을 수 있다. 이벤트 소싱(Event Sourcing) 사용: 장점: 시스템의 상태 변화를 이벤트 형태로 저장하여, 모든 변경 이력을 추적할 수 있다. 단점: 쿼리 작업은 이벤트로 기록되지 않으므로, 이러한 작업에 대한 로깅은 별도의 방법을 통해 구현해야 한다. 모범 사례 상관 관계 ID 사용: 마이크로서비스 간 요청 추적을 위해 고유 ID를 사용한다. 컨텍스트 정보 포함: 사용자 ID, 서비스 이름, 요청 ID 등을 로그에 포함한다. 민감한 정보 보호: 개인정보나 보안 관련 데이터는 마스킹 처리한다. 로그 레벨 구분: 중요도에 따라 로그 레벨을 적절히 설정한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 02:13:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Audit Logging" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/audit-logging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Exception Tracking</h2></header><div class=entry-content><p>Exception Tracking Exception Tracking은 분산 시스템 전반에 걸쳐 발생하는 예외를 중앙에서 수집, 집계, 분석하는 패턴이다.
이 패턴은 복잡한 마이크로서비스 환경에서 오류를 효과적으로 모니터링하고 디버깅하는 데 필수적이다.
Exception Tracking은 MSA 환경에서 시스템의 안정성을 유지하고 문제를 신속하게 해결하는 데 필수적인 도구이다.
이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고 사용자 경험을 개선할 수 있다.
주요 구성 요소 중앙 집중식 예외 로거: 여러 마이크로서비스에서 발생하는 예외 데이터를 수집하고 저장하는 전용 서비스나 도구이다. 예외 처리 미들웨어: 각 마이크로서비스에 구현되어 예외를 캐치하고 중앙 로거로 전달하는 컴포넌트이다. 상관 관계 ID: 여러 서비스에 걸친 요청 흐름과 관련 예외를 추적하는 데 사용되는 고유 식별자이다. 알림 및 모니터링: 중요한 문제에 대해 개발 및 운영 팀에 실시간으로 알리는 통합 모니터링 도구이다. 대시보드: 예외의 빈도, 심각도, 잠재적 영향 등에 대한 인사이트와 분석을 제공하는 사용자 인터페이스이다. Exception Tracking의 중요성 복잡성 관리: 수많은 서비스로 구성된 시스템에서 오류의 흐름을 파악할 수 있다. 성능 최적화: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다. 신속한 문제 해결: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다. 시스템 이해 향상: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다. 구현 방법 중앙 집중식 로깅 서비스 구축: ELK 스택(Elasticsearch, Logstash, Kibana)과 같은 도구를 사용하여 모든 마이크로서비스의 로그를 한 곳에서 수집하고 분석한다. 고유 요청 ID 생성: 각 요청에 고유한 ID를 할당하여 여러 서비스에 걸친 예외 추적을 가능하게 한다. 표준화된 예외 형식 사용: 일관된 형식을 사용하여 예외 데이터를 수집하고 분석한다. 실시간 알림 설정: 중요한 예외 발생 시 개발팀에 즉시 알림을 보내도록 구성한다. Feign Error Decoder 활용: Spring Cloud Openfeign을 사용하는 경우, Feign Error Decoder를 구현하여 마이크로서비스 간 통신 중 발생하는 예외를 효과적으로 처리한다. 모범 사례 예외 분류 및 우선순위 지정: 예외의 심각도와 영향도에 따라 분류하고 우선순위를 지정한다. 컨텍스트 정보 포함: 예외 로그에 사용자 정보, 요청 세부 사항 등 충분한 컨텍스트 정보를 포함시킨다. 정기적인 분석 및 개선: 수집된 예외 데이터를 정기적으로 분석하여 시스템 안정성을 지속적으로 개선한다. Fail Fast 원칙 적용: 문제를 조기에 감지하고 신속하게 대응할 수 있도록 Fail Fast 원칙을 적용한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 02:12:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Exception Tracking" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/exception-tracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Distributed Tracing</h2></header><div class=entry-content><p>Distributed Tracing Distributed Tracing은 마이크로서비스 환경에서 요청이 여러 서비스를 거쳐 처리되는 과정을 추적하고 관찰하는 방법이다. 이 기술은 복잡한 분산 시스템에서 요청의 흐름을 시각화하고, 성능 문제를 식별하며, 시스템 동작을 이해하는 데 필수적이다.
Distributed Tracing은 현대적인 마이크로서비스 아키텍처에서 시스템의 동작을 이해하고 최적화하는 데 필수적인 도구이며 이를 통해 개발팀은 복잡한 분산 시스템을 효과적으로 관리하고, 사용자 경험을 개선할 수 있다.
작동 원리 고유 식별자 할당: 각 요청에 고유한 Trace ID를 부여한다. 스팬 생성: 요청이 각 서비스를 통과할 때마다 ‘스팬’이라는 작업 단위가 생성된다. 계층 구조: 스팬들은 부모-자식 관계를 형성하여 요청의 전체 경로를 표현한다. 메타데이터 수집: 각 스팬은 시작/종료 시간, 서비스 이름, 오류 정보 등의 메타데이터를 포함한다. Distributed Tracing의 중요성 복잡성 관리: 수십 또는 수백 개의 서비스로 구성된 시스템에서 요청 흐름을 파악할 수 있다. 성능 최적화: 병목 현상과 지연을 식별하여 시스템 성능을 개선할 수 있다. 문제 해결: 오류 발생 지점을 정확히 파악하여 디버깅 시간을 단축할 수 있다. 시스템 이해: 서비스 간 의존성과 상호작용을 시각화하여 시스템 아키텍처를 더 잘 이해할 수 있다. 주요 사용 사례 성능 병목 식별: 요청 처리 과정에서 지연이 발생하는 서비스를 찾아낸다. 오류 추적: 실패한 요청의 정확한 실패 지점과 원인을 파악한다. 서비스 의존성 분석: 서비스 간 통신 패턴과 의존성을 시각화한다. 최적화: 전체 시스템의 성능을 개선하기 위한 인사이트를 제공한다. 구현 방법 계측: 코드에 트레이싱 기능을 추가한다. 많은 도구들이 자동 계측을 지원한다. 데이터 수집: 각 요청에 대한 스팬 데이터를 수집한다. 분석 및 시각화: 수집된 데이터를 분석하고 시각화하여 인사이트를 얻는다. 주요 도구 Jaeger: 성능 최적화와 지연 시간 분석에 적합한 오픈소스 도구. Zipkin: 트레이스 데이터를 의존성 그래프와 플레임 그래프로 시각화한다. Datadog APM: 심층적인 가시성과 다양한 기능을 제공하는 엔터프라이즈 솔루션이다. New Relic: 분산 환경에 최적화된 실시간 시각화와 분석 기능을 제공한다. 모범 사례 샘플링 전략 수립: 트래픽 패턴과 시스템 요구사항에 따라 적절한 샘플링 비율을 설정한다. 컨텍스트 전파: 서비스 간 요청 시 트레이스 정보를 올바르게 전달한다. 표준화: OpenTelemetry와 같은 표준 프레임워크를 사용하여 호환성을 확보한다. 시각화 도구 활용: 트레이스 타임라인, 서비스 의존성, 중요 경로 정보를 명확히 표시하는 대시보드를 구성한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 01:59:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Distributed Tracing" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/distributed-tracing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Health Check API</h2></header><div class=entry-content><p>Health Check API Health Check API는 서비스의 상태를 주기적으로 확인하여 서비스의 정상 작동 여부를 판단하는 엔드포인트이다.
이는 마이크로서비스 환경에서 각 서비스의 가용성과 성능을 모니터링하는 데 필수적이다.
Health Check API는 MSA 환경에서 시스템의 안정성과 가용성을 유지하는 데 핵심적인 역할을 한다.
적절히 구현된 Health Check는 문제를 조기에 발견하고, 시스템의 전반적인 상태를 실시간으로 모니터링할 수 있게 해주어 서비스의 품질을 높이는 데 크게 기여한다.
Health Check API의 중요성 고가용성 보장: 로드 밸런서가 정상 작동 중인 서비스에만 트래픽을 전달하여 서비스의 고가용성을 확보한다. 문제 조기 발견: 서비스의 이상을 조기에 감지하여 대응할 수 있다. 시스템 안정성 향상: 전체 시스템의 안정성을 높이고 장애 전파를 방지한다. Health Check API의 주요 기능 상태 확인: 서비스 인스턴스의 현재 상태를 반환하여, 해당 인스턴스가 요청을 처리할 수 있는지 여부를 판단한다. 종속성 검사: 서비스가 의존하는 데이터베이스, 메시지 브로커 등 외부 시스템과의 연결 상태를 확인한다. 리소스 모니터링: 디스크 공간, 메모리 사용량 등 호스트 시스템의 자원 상태를 점검한다. Health Check API의 중요성 장애 감지: 서비스 인스턴스가 비정상 상태에 빠졌을 때 이를 신속하게 감지하여 알림을 생성하고, 로드 밸런서나 서비스 레지스트리가 해당 인스턴스를 요청 대상에서 제외할 수 있다. 서비스 디스커버리 통합: 서비스 레지스트리는 헬스 체크를 통해 현재 사용 가능한 서비스 인스턴스 목록을 유지하며, 클라이언트는 이 정보를 기반으로 요청을 보낸다. 시스템 안정성 향상: 주기적인 상태 확인을 통해 잠재적인 문제를 조기에 발견하고 대응함으로써 전체 시스템의 안정성을 높일 수 있다. Health Check API 구현 방법 엔드포인트 생성: 일반적으로 /health 또는 /ping 경로로 설정한다. 응답 코드: 정상 상태일 때 HTTP 200 OK를 반환한다. 상태 정보 포함: 단순 생존 여부뿐만 아니라 데이터베이스 연결, 외부 서비스 의존성 등의 상태도 포함할 수 있다. Health Check 유형 Passive Health Checks: 실제 요청에 대한 응답을 모니터링한다. Active Health Checks: 주기적으로 특별한 요청을 보내 서비스 상태를 확인한다. Agent-based Health Checks: 서버 내부에 에이전트를 설치하여 상세한 정보를 수집한다. Health Check API 구현 도구 Spring Boot Actuator: 자동으로 /actuator/health 엔드포인트를 제공한다. Kubernetes Probes: Liveness Probe: 애플리케이션이 살아있는지 확인 Readiness Probe: 애플리케이션이 요청을 처리할 준비가 되었는지 확인 Startup Probe: 애플리케이션의 시작이 완료되었는지 확인 Health Check API 모범 사례 상세한 상태 정보: 단순 UP/DOWN이 아닌 구체적인 상태 정보를 제공한다. 성능 고려: Health Check 자체가 시스템에 부담을 주지 않도록 설계한다. 보안: Health Check 엔드포인트에 대한 적절한 접근 제어를 구현한다. 로깅 및 모니터링: Health Check 결과를 로깅하고 모니터링하여 트렌드를 분석한다. 커스터마이징: 애플리케이션의 특성에 맞게 Health Check 로직을 커스터마이징한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-16 01:59:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Health Check API" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/health-check-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Log Aggregation</h2></header><div class=entry-content><p>Log Aggregation 마이크로서비스 아키텍처(MSA)에서 Log Aggregation은 Observability를 구현하는 핵심 패턴 중 하나이다.
이 패턴은 분산된 마이크로서비스 환경에서 로그 데이터를 효과적으로 관리하고 분석하는 방법을 제공한다.
Log Aggregation은 여러 마이크로서비스와 시스템 구성 요소에서 생성된 로그 데이터를 중앙 집중식 저장소로 수집, 통합, 정규화하는 프로세스이다. 이를 통해 개발자와 운영팀은 전체 시스템의 동작을 포괄적으로 이해하고 문제를 효과적으로 해결할 수 있다.
Log Aggregation은 MSA 환경에서 시스템의 투명성을 높이고, 문제 해결 능력을 향상시키며, 전반적인 시스템 성능과 안정성을 개선하는 데 핵심적인 역할을 한다. 적절히 구현된 Log Aggregation 시스템은 개발팀과 운영팀이 복잡한 마이크로서비스 환경을 효과적으로 관리하고 최적화하는 데 필수적인 도구가 된다.
...</p></div><footer class=entry-footer><span title='2024-11-16 01:58:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log Aggregation" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/observability/log-aggregation/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>