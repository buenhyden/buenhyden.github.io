<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Design Patterns | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Design-Patterns"><meta name=description content="자주 발생하는 문제들을 해결하기 위한 재사용 가능한 설계 템플릿"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Design Patterns"><meta property="og:description" content="자주 발생하는 문제들을 해결하기 위한 재사용 가능한 설계 템플릿"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Design Patterns"><meta name=twitter:description content="자주 발생하는 문제들을 해결하기 위한 재사용 가능한 설계 템플릿"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Software Design Patterns","item":"https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/"},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":"https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/>Software Design Patterns</a></div><h1>Software Design Patterns</h1><div class=post-description>자주 발생하는 문제들을 해결하기 위한 재사용 가능한 설계 템플릿</div></header><div class=post-content><h2 id=software-design-patterns>Software Design Patterns<a hidden class=anchor aria-hidden=true href=#software-design-patterns>#</a></h2><p>소프트웨어 디자인 패턴은 소프트웨어 개발에서 자주 발생하는 문제들에 대한 일반적이고 재사용 가능한 해결책이다.<br>이는 코드의 품질을 향상시키고 유지보수를 용이하게 만드는 중요한 도구이다.</p><p>디자인 패턴을 효과적으로 사용하려면 지속적인 학습과 실제 프로젝트에서의 적용 경험이 필요하다.<br>각 패턴의 장단점을 이해하고, 적절한 상황에서 올바르게 적용하는 것이 중요하다. 이를 통해 더 유연하고 유지보수가 용이한 소프트웨어를 설계할 수 있다.</p><h3 id=디자인-패턴의-목적>디자인 패턴의 목적<a hidden class=anchor aria-hidden=true href=#디자인-패턴의-목적>#</a></h3><ol><li><strong>코드 재사용성 향상</strong>: 검증된 해결책을 제공하여 개발 시간을 단축시킨다.</li><li><strong>유지보수성 개선</strong>: 표준화된 방식으로 문제를 해결하여 코드의 이해와 수정을 쉽게 만든다.</li><li><strong>확장성 증대</strong>: 기존 코드의 변경 없이 새로운 기능을 추가할 수 있게 한다.</li><li><strong>복잡성 관리</strong>: 복잡한 시스템을 구조화하여 관리하기 쉽게 만든다.</li></ol><h3 id=디자인-패턴의-종류>디자인 패턴의 종류<a hidden class=anchor aria-hidden=true href=#디자인-패턴의-종류>#</a></h3><p>디자인 패턴은 주로 세 가지 카테고리로 분류된다:</p><table><thead><tr><th>구분</th><th>생성 패턴 (Creational)</th><th>구조 패턴 (Structural)</th><th>행위 패턴 (Behavioral)</th></tr></thead><tbody><tr><td>정의</td><td>객체 생성과 초기화를 처리하는 패턴</td><td>클래스나 객체를 조합해 더 큰 구조를 만드는 패턴</td><td>알고리즘들 및 객체 간의 책임 할당과 관련이 있는 패턴</td></tr><tr><td>목적</td><td>객체 생성 과정의 유연성을 높이고 코드의 재사용성을 증가</td><td>클래스와 객체를 조합하여 더 큰 구조를 만들되, 유연하고 효율적인 구조 설계</td><td>객체 간의 통신과 작업 처리 방식을 체계화하고 유연한 상호작용 구현</td></tr><tr><td>주요 패턴</td><td>- Singleton<br>- Factory Method<br>- Abstract Factory<br>- Builder<br>- Prototype</td><td>- Adapter<br>- Bridge<br>- Composite<br>- Decorator<br>- Facade<br>- Flyweight<br>- Proxy</td><td>- Chain of Responsibility<br>- Command<br>- Iterator<br>- Mediator<br>- Memento<br>- Observer<br>- State<br>- Strategy<br>- Template Method<br>- Visitor</td></tr><tr><td>사용 시기</td><td>- 객체 생성 로직이 복잡할 때<br>- 객체 생성 방식의 변경이 예상될 때<br>- 객체 생성을 제어해야 할 때<br>- 객체의 재사용이 필요할 때</td><td>- 시스템 구조가 복잡해질 때<br>- 서로 다른 인터페이스를 통합해야 할 때<br>- 기존 객체의 기능을 동적으로 확장해야 할 때<br>- 시스템의 복잡도를 감추고 싶을 때</td><td>- 객체 간 통신이 복잡할 때<br>- 작업의 실행/취소가 필요할 때<br>- 상태 변화를 여러 객체에 알려야 할 때<br>- 알고리즘의 변경이 필요할 때</td></tr><tr><td>장점</td><td>- 객체 생성의 유연성 증가<br>- 코드 재사용성 향상<br>- 결합도 감소<br>- 객체 생성 로직 캡슐화</td><td>- 시스템 유연성 증가<br>- 확장성 향상<br>- 클래스 간의 결합도 감소<br>- 코드 재사용성 향상</td><td>- 객체 간 결합도 감소<br>- 코드 유지보수성 향상<br>- 알고리즘 재사용 용이<br>- 책임 분리 명확</td></tr><tr><td>주의사항</td><td>- 과도한 객체 생성 패턴 사용 지양<br>- 생성 로직의 복잡도 관리<br>- 성능 고려</td><td>- 불필요한 계층 구조 생성 방지<br>- 복잡도 증가 관리<br>- 인터페이스 설계 신중</td><td>- Observer 패턴의 성능 고려<br>- 순환 참조 방지<br>- 상태 일관성 유지</td></tr></tbody></table><h3 id=디자인-패턴-사용-방법>디자인 패턴 사용 방법<a hidden class=anchor aria-hidden=true href=#디자인-패턴-사용-방법>#</a></h3><ol><li><strong>문제 식별</strong>: 현재 직면한 설계 문제를 명확히 파악한다.</li><li><strong>적절한 패턴 선택</strong>: 문제에 가장 적합한 디자인 패턴을 선택한다.</li><li><strong>패턴 적용</strong>: 선택한 패턴의 구조와 원칙을 코드에 적용한다.</li><li><strong>패턴 커스터마이징</strong>: 필요에 따라 패턴을 프로젝트의 특정 요구사항에 맞게 조정한다.</li><li><strong>리팩토링</strong>: 기존 코드에 패턴을 적용할 때는 점진적으로 리팩토링한다.</li></ol><h3 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h3><ul><li><strong>과도한 사용 주의</strong>: 모든 문제에 패턴을 적용하려 하지 마세요. 간단한 해결책이 더 적합할 수 있다.</li><li><strong>패턴의 이해</strong>: 패턴의 의도와 적용 상황을 정확히 이해한 후 사용한다.</li><li><strong>성능 고려</strong>: 일부 패턴은 추가적인 복잡성을 도입할 수 있으므로 성능에 미치는 영향을 고려해야 한다.</li></ul><hr><h3 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h3></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns Vs Creational Design Patterns Vs Structural Design Patterns Behavioral Design Patterns, Creational Design Patterns, 그리고 Structural Design Patterns은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리이다.
각 카테고리는 서로 다른 측면의 객체 지향 설계 문제를 다룬다.
구분 Creational Patterns Structural Patterns Behavioral Patterns 정의 객체 생성 메커니즘을 다루는 패턴 클래스와 객체의 구조를 다루는 패턴 객체 간의 상호작용과 책임 분배를 다루는 패턴 주요 목적 시스템이 사용할 구체 클래스를 지정하지 않으면서 객체 인스턴스 생성 클래스와 객체를 더 큰 구조로 조합하면서 유연성 유지 객체 간의 통신 방법과 책임 할당 방식을 정의 중점 사항 객체 생성 과정의 유연성 클래스와 객체를 더 큰 구조로 조합 알고리즘과 객체 간 책임 분배 유연성 제공 객체 생성 방식 객체 구조와 구성 객체 간 통신 방식 문제 해결 영역 객체 인스턴스화 클래스와 객체의 구조화 객체 상호작용 및 책임 핵심 원칙 “생성과 구현의 분리” “구조와 기능의 분리” “행위와 책임의 분리” 대표적인 패턴들 - Singleton
Factory Method
Abstract Factory
Builder
Prototype - Adapter
Bridge
Composite
Decorator
Facade - Observer
Strategy
Command
Iterator
Mediator 구현 예시 javascript const instance = Singleton.getInstance(); javascript const wrapper = new Adapter(oldInterface); javascript subject.addObserver(observer); 사용 시점 - 객체 생성 로직이 복잡할 때
- 객체 생성을 유연하게 처리해야 할 때
- 객체 재사용이 필요할 때 - 서로 다른 인터페이스를 통합할 때
- 시스템을 계층화할 때
- 기능을 동적으로 추가할 때 - 객체 간 결합도를 낮추고 싶을 때
- 알고리즘을 캡슐화할 때
- 객체 간 통신을 체계화할 때 주요 장점 - 객체 생성의 유연성 확보
- 코드 재사용성 향상
- 생성 로직 캡슐화 - 시스템 확장성 향상
- 클래스 간 결합도 감소
- 유연한 구조 설계 - 객체 간 느슨한 결합
- 책임의 명확한 분리
- 코드 재사용성 증가 주요 단점 - 클래스 수 증가
- 복잡성 증가
- 생성 패턴 과다 사용 시 오버헤드 - 추상화로 인한 복잡도 증가
- 클래스 계층 구조의 복잡화 - 관찰자 패턴의 성능 저하 가능성
- 패턴 적용의 오버헤드 적용 사례 - DB 연결 관리
- 객체 풀 관리
- 설정 관리 - GUI 컴포넌트
- 레거시 시스템 통합
- 프레임워크 개발 - 이벤트 처리
UI 업데이트
- 게임 로직 적용 시기 객체 생성이 복잡하거나 유연성이 필요할 때 클래스나 객체를 더 큰 구조로 조직해야 할 때 객체 간 통신이 복잡할 때 런타임 영향 객체 생성 시점에만 영향 전반적인 구조에 영향 실행 시간 전반에 영향 코드 유지보수성 중간 높음 높음 코드 재사용성 객체 생성 로직의 재사용 기존 코드의 재사용 및 확장 알고리즘의 재사용 촉진 시스템 영향 시스템과 객체 생성의 분리 클래스 간 관계 단순화 객체 간 결합도 감소 유지보수성 객체 생성 로직 변경 용이 구조 변경 및 확장 용이 동작 로직 변경 용이 디버깅 난이도 낮음-중간 중간 중간-높음 각 패턴 카테고리의 실제 활용 예시:
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;584 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Creational Design Patterns</h2></header><div class=entry-content><p>Creational Design Patterns 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 08:26:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Creational Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/creational-design-patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Structural Design Patterns</h2></header><div class=entry-content><p>Structural Design Patterns 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 08:26:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/structural-design-patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns 행동 디자인 패턴(Behavioral Design Pattern)은 객체들 사이의 알고리즘과 책임 할당에 관한 패턴이다. 이 패턴들은 객체나 클래스 사이의 상호작용과 책임 분배 방법을 정의한다. 행동 패턴의 주요 목적은 객체 간의 효율적인 통신과 책임 분배를 통해 시스템의 유연성과 확장성을 높이는 것이다.
행동 디자인 패턴의 주요 특징 객체 간 통신 패턴 정의: 객체들이 서로 어떻게 상호작용하고 통신할지에 대한 패턴을 제공한다. 복잡한 제어 흐름 관리: 런타임에 따라가기 어려운 복잡한 제어 흐름을 관리한다. 알고리즘의 캡슐화: 특정 행동을 캡슐화하여 객체 간에 교환 가능하게 만든다. 객체 결합도 감소: 객체 간의 직접적인 의존성을 줄여 시스템의 유연성을 높인다. 주요 행동 디자인 패턴 책임 연쇄 패턴(Chain of Responsibility)
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;331 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>