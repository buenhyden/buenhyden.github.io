<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MSA Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Pattern,Microservice-architecture-Pattern"><meta name=description content="마이크로서비스 아키텍처의 주요 패턴"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="MSA Pattern"><meta property="og:description" content="마이크로서비스 아키텍처의 주요 패턴"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="MSA Pattern"><meta name=twitter:description content="마이크로서비스 아키텍처의 주요 패턴"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a></div><h1>MSA Pattern</h1><div class=post-description>마이크로서비스 아키텍처의 주요 패턴</div></header><div class=post-content><h2 id=msa>MSA<a hidden class=anchor aria-hidden=true href=#msa>#</a></h2><p>현대적인 소프트웨어 개발 접근 방식으로, 복잡한 애플리케이션을 작고 독립적인 서비스로 분할하는 아키텍처 스타일.</p><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ol><li>독립성: 각 마이크로서비스는 독립적으로 개발, 배포, 확장이 가능합니다.</li><li>느슨한 결합: 서비스 간 의존성을 최소화하여 유연성을 높입니다.</li><li>기술 다양성: 각 서비스에 최적화된 기술 스택을 선택할 수 있습니다.</li><li>API 기반 통신: 서비스 간 통신은 표준화된 API를 통해 이루어집니다.</li><li>분산 데이터 관리: 각 서비스는 자체 데이터베이스를 관리합니다.</li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>확장성: 개별 서비스 단위로 독립적인 확장이 가능합니다.</li><li>유연성: 빠른 개발 및 배포 주기를 지원합니다.</li><li>장애 격리: 한 서비스의 문제가 전체 시스템에 영향을 미치지 않습니다.</li><li>팀 생산성 향상: 작은 팀이 특정 서비스에 집중할 수 있습니다.</li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li>복잡성 증가: 분산 시스템 관리의 복잡성이 높아집니다.</li><li>운영 비용 증가: 더 많은 서비스를 관리해야 하므로 비용이 증가할 수 있습니다.</li><li>데이터 일관성 유지의 어려움: 분산된 데이터베이스로 인해 일관성 유지가 어려울 수 있습니다.</li><li>보안 복잡성: 여러 서비스에 걸친 보안 관리가 더 복잡해집니다.</li></ol><p>MSA는 대규모, 복잡한 애플리케이션 개발에 적합하며, 빠른 변화와 확장이 필요한 비즈니스 환경에서 특히 유용하다.<br>현의 복잡성과 운영 비용을 고려해야 하며, 조직의 요구사항과 역량에 맞게 신중히 도입해야 한다.</p><h3 id=서비스-관리>서비스 관리<a hidden class=anchor aria-hidden=true href=#서비스-관리>#</a></h3><p>MSA(Microservice Architecture)에서 독립적인 서비스는 다음과 같은 방식으로 관리된다:</p><ol><li><p>서비스 레지스트리와 디스커버리:<br>서비스 레지스트리는 마이크로서비스의 메타데이터(위치, 호스트, 포트 등)를 중앙에서 관리한다.<br>서비스는 시작 시 레지스트리에 등록되고, 종료 시 등록 해제된다.<br>소비자는 서비스 레지스트리를 통해 사용 가능한 서비스와 위치를 찾을 수 있다.</p></li><li><p>분산 데이터 관리:<br>각 마이크로서비스는 자체 데이터베이스를 가지며, 다른 서비스의 데이터베이스에 직접 접근할 수 없다.<br>이를 통해 서비스 간 결합도를 낮추고 독립성을 유지한다.</p></li><li><p>독립적인 개발 및 배포:<br>각 서비스는 독립적으로 개발, 배포, 확장될 수 있다.<br>이를 통해 빠른 개발 주기와 유연한 확장성을 제공한다.</p></li><li><p>API 기반 통신:<br>서비스 간 통신은 잘 정의된 API를 통해 이루어진다.<br>이는 서비스의 독립성을 유지하면서도 필요한 상호작용을 가능하게 한다.</p></li><li><p>중앙화된 모니터링 및 관찰성:<br>서비스 메트릭, 로깅, 추적 데이터는 중앙화된 도구를 통해 관리된다.<br>이를 통해 전체 시스템의 상태를 모니터링하고 문제를 신속하게 파악할 수 있다.</p></li><li><p>API 관리:<br>선택된 서비스들을 관리형 API로 노출할 때는 API 관리 기술을 활용한다.<br>이는 MSA에서 중앙화된 컴포넌트로 구현된다.</p></li></ol><h3 id=서비스-간-통신-관리>서비스 간 통신 관리<a hidden class=anchor aria-hidden=true href=#서비스-간-통신-관리>#</a></h3><p>MSA(Microservice Architecture)에서 서비스 간 통신은 다음과 같은 방식으로 관리된다:</p><ol><li><p>동기식 통신</p><ul><li>RESTful API를 통한 HTTP/HTTPS 통신</li><li>gRPC를 이용한 원격 프로시저 호출</li><li>WebSocket을 활용한 실시간 양방향 통신</li></ul></li><li><p>비동기식 통신</p><ul><li>메시징 큐(RabbitMQ, Apache Kafka, Amazon SQS 등)를 이용한 이벤트 기반 통신</li><li>이벤트 스트리밍 플랫폼을 활용한 실시간 이벤트 처리</li></ul></li><li><p>서비스 메시</p><ul><li>서비스 디스커버리, 로드 밸런싱, 암호화, 모니터링 등의 기능 제공</li><li>사이드카 프록시를 통한 서비스 간 통신 관리</li></ul></li><li><p>보안</p><ul><li>상호 TLS(mTLS)를 통한 인증 및 암호화</li><li>OpenID Connect(OIDC)를 이용한 인증</li></ul></li><li><p>트랜잭션 관리</p><ul><li>Saga 패턴을 활용한 분산 트랜잭션 관리</li></ul></li><li><p>모니터링 및 관찰성</p><ul><li>중앙화된 로깅 및 모니터링 시스템 구축</li></ul></li><li><p>문서화 및 교육</p><ul><li>서비스 간 통신 프로토콜, 도구, 모범 사례에 대한 포괄적인 문서화 및 교육 제공</li></ul></li></ol><h3 id=구현에-중요한-기술적-요소>구현에 중요한 기술적 요소<a hidden class=anchor aria-hidden=true href=#구현에-중요한-기술적-요소>#</a></h3><p><figure><img alt="Microservice Architecture" loading=lazy src=/img/microservices-logical.png><figcaption>https://learn.microsoft.com/ko-kr/azure/architecture/guide/architecture-styles/microservices</figcaption></figure></p><ol><li><p>API Gateway<br>모든 클라이언트 요청이 먼저 도착하는 관문.<br>역할:</p><ul><li>인증/인가</li><li>요청 라우팅</li><li>로드 밸런싱</li><li>응답 캐싱</li></ul></li><li><p>Service Discovery<br>서비스들의 위치를 자동으로 찾아주는 기능.<br>Netflix Eureka나 Consul과 같은 도구들이 이 역할을 수행.</p></li><li><p>서비스 간 통신<br>마이크로서비스들은 다음과 같은 방식으로 통신한다.<br>- 동기 통신: REST API, gRPC<br>- 비동기 통신: Kafka, RabbitMQ<br>예를 들어, 주문 서비스가 결제 서비스에 결제 요청을 보내고, 결제가 완료되면 배송 서비스에 알림을 보내는 식.</p></li><li><p>데이터 관리<br>각 서비스는 자신만의 데이터베이스를 가진다.<br>이를 데이터베이스 per 서비스 패턴이라고 한다.<br>예를 들어:</p><ul><li>상품 서비스: MySQL</li><li>검색 서비스: Elasticsearch</li><li>장바구니 서비스: Redis</li></ul></li><li><p>장애 처리<br>MSA에서는 장애가 전파되지 않도록 하는 것이 중요하다.<br>이를 위해 다음과 같은 패턴들을 사용한다:</p><ul><li>Circuit Breaker: 서비스 장애 시 빠른 실패 처리</li><li>Fallback: 대체 로직 실행</li><li>Bulkhead: 자원 격리</li></ul></li></ol><h3 id=데이터-일관성을-유지하는-주요-방법>데이터 일관성을 유지하는 주요 방법<a hidden class=anchor aria-hidden=true href=#데이터-일관성을-유지하는-주요-방법>#</a></h3><p>MSA(Microservice Architecture)에서 데이터 일관성을 유지하는 주요 방법은 다음과 같다:</p><ol><li><p>최종 일관성 (Eventual Consistency)</p><ul><li>일시적인 불일치를 허용하되, 시간이 지나면 모든 서비스의 데이터가 일관성을 갖도록 합니다.</li><li>즉시 일관성이 필요하지 않은 경우에 적합합니다.</li></ul></li><li><p>Saga 패턴</p><ul><li>분산 트랜잭션을 관리하기 위한 패턴입니다.</li><li>각 서비스가 로컬 트랜잭션을 수행하고, 실패 시 보상 트랜잭션으로 변경사항을 취소한다.</li></ul></li><li><p>CQRS (Command Query Responsibility Segregation)</p><ul><li>읽기 작업과 쓰기 작업을 분리하여 처리합니다.</li><li>이벤트를 통해 변경사항을 전파하여 일관성을 유지합니다.</li></ul></li><li><p>데이터베이스 per 서비스</p><ul><li>각 서비스가 자체 데이터베이스를 관리합니다.</li><li>서비스 간 결합도를 낮추고 독립성을 높입니다.</li></ul></li><li><p>이벤트 소싱 (Event Sourcing)</p><ul><li>상태 변경을 이벤트로 저장하고 이를 기반으로 현재 상태를 재구성합니다.</li></ul></li><li><p>변경 데이터 캡처 (Change Data Capture, CDC)</p><ul><li>데이터 변경을 감지하고 이벤트로 발행하여 다른 서비스에 전파합니다.</li></ul></li><li><p>분산 캐싱</p><ul><li>자주 사용되는 데이터를 여러 위치에 캐싱하여 일관성을 유지합니다.</li></ul></li><li><p>보상 트랜잭션</p><ul><li>실패한 트랜잭션의 영향을 취소하기 위한 역방향 트랜잭션을 수행합니다.</li></ul></li></ol><h3 id=msa-pattern>MSA Pattern<a hidden class=anchor aria-hidden=true href=#msa-pattern>#</a></h3><table><thead><tr><th>패턴 이름</th><th>목적</th><th>주요 구성요소</th><th>장점</th><th>단점</th><th>적용 시나리오</th><th></th></tr></thead><tbody><tr><td>API Gateway 패턴</td><td>클라이언트와 마이크로서비스 간의 중앙 집중식 진입점 제공</td><td>- API Gateway 서버<br>- 라우팅 규칙<br>- 프록시 서비스<br>- 인증/인가 필터</td><td>- 단일 진입점으로 보안 강화<br>- 클라이언트 요청 통합 처리<br>- 횡단 관심사 중앙화</td><td>- 단일 실패점 가능성<br>- 추가적인 네트워크 홉<br>- 관리 복잡도 증가</td><td>- 다수의 클라이언트 지원<br>API 버전 관리 필요<br>- 인증/인가 통합 필요</td><td></td></tr><tr><td>Event-Driven 패턴</td><td>서비스 간 느슨한 결합을 위한 이벤트 기반 통신</td><td>- 이벤트 브로커<br>- 이벤트 생산자<br>- 이벤트 소비자<br>- 이벤트 채널</td><td>- 느슨한 결합<br>- 확장성 향상<br>- 비동기 처리</td><td>- 디버깅 어려움<br>- 일관성 보장 어려움<br>- 복잡한 이벤트 추적</td><td>- 실시간 데이터 처리<br>- 비동기 워크플로우<br>- 확장 가능한 시스템</td><td></td></tr><tr><td>Database per Service</td><td>각 서비스별 독립적인 데이터베이스 운영</td><td>- 독립 데이터베이스<br>- 서비스별 스키마<br>- 데이터 동기화 메커니즘</td><td>- 데이터 독립성<br>- 스키마 변경 용이<br>- 확장성 향상</td><td>- 데이터 중복<br>- 일관성 관리 어려움<br>- 통합 쿼리 복잡</td><td>- 서비스 독립성 중요<br>- 다른 스키마 필요<br>- 독립 확장 필요</td><td></td></tr><tr><td>Circuit Breaker</td><td>장애 전파 방지를 위한 자동 차단 메커니즘</td><td>- 상태 모니터<br>- 임계값 설정<br>- 폴백 메커니즘<br>- 재시도 로직</td><td>- 장애 전파 방지<br>- 시스템 복원력 향상<br>- 자동 복구</td><td>- 설정 복잡<br>- 임계값 조정 어려움<br>- 오버헤드 발생</td><td>- 외부 서비스 호출<br>- 네트워크 불안정<br>- 종속성 관리</td><td></td></tr><tr><td>Saga</td><td>분산 트랜잭션 관리를 위한 보상 트랜잭션 패턴</td><td>- 사가 오케스트레이터<br>- 보상 트랜잭션<br>- 상태 관리자</td><td>- 데이터 일관성<br>- 롤백 가능<br>- 장애 복구</td><td>- 구현 복잡<br>- 디버깅 어려움<br>- 성능 오버헤드</td><td>- 분산 트랜잭션<br>- 장기 실행 프로세스<br>- 다중 서비스 조정</td><td></td></tr><tr><td>CQRS</td><td>읽기와 쓰기 작업의 분리</td><td>- 명령 모델<br>- 쿼리 모델<br>- 동기화 메커니즘<br>- 이벤트 저장소</td><td>- 성능 최적화<br>- 확장성 향상<br>- 모델 분리</td><td>- 복잡도 증가<br>- 일관성 지연<br>- 학습 곡선</td><td>- 복잡한 도메인<br>- 높은 읽기 부하<br>- 이벤트 소싱 필요</td><td></td></tr><tr><td>Service Discovery</td><td>동적 서비스 위치 탐색 및 로드밸런싱</td><td>- 서비스 레지스트리<br>- 헬스체크<br>- 로드밸런서</td><td>- 동적 확장<br>- 자동 장애 복구<br>- 로드밸런싱</td><td>- 추가 인프라 필요<br>- 설정 복잡<br>- 지연 가능성</td><td>- 동적 환경<br>- 클라우드 배포<br>- 자동 확장/축소</td><td></td></tr><tr><td>Bulkhead</td><td>서비스 격리를 통한 장애 전파 방지</td><td>- 격리 컴파트먼트<br>- 자원 할당<br>- 모니터링</td><td>- 장애 격리<br>- 리소스 보호<br>- 안정성 향상</td><td>- 리소스 낭비<br>- 설정 복잡<br>- 비용 증가</td><td>- 중요 서비스 보호<br>- 리소스 분리<br>- 멀티테넌시</td><td></td></tr><tr><td>Backend for Frontend</td><td>클라이언트별 최적화된 API 제공</td><td>- 클라이언트별 API<br>- 데이터 변환<br>- 캐싱 레이어</td><td>- 클라이언트 최적화<br>- 성능 향상<br>- 유지보수성</td><td>- 코드 중복<br>- 관리 복잡<br>- 개발 부담</td><td>- 다양한 클라이언트<br>- 다른 데이터 요구사항<br>UI 최적화 필요</td><td></td></tr><tr><td>Strangler Fig</td><td>점진적인 시스템 마이그레이션</td><td>- 프록시 레이어<br>- 변환 컴포넌트<br>- 라우팅 규칙</td><td>- 점진적 전환<br>- 리스크 감소<br>- 검증 용이</td><td>- 장기 관리 필요<br>- 복잡도 증가<br>- 성능 영향</td><td>- 레거시 마이그레이션<br>- 점진적 현대화<br>- 위험 완화</td><td></td></tr><tr><td>Sidecar</td><td>서비스에 부가 기능 제공</td><td>- 사이드카 컨테이너<br>- 프록시<br>- 모니터링 에이전트</td><td>- 재사용성<br>- 독립적 업데이트<br>- 언어 중립적</td><td>- 리소스 오버헤드<br>- 복잡도 증가<br>- 네트워크 지연</td><td>- 크로스커팅 관심사<br>- 레거시 확장<br>- 공통 기능 추가</td><td></td></tr><tr><td>Ambassador</td><td>서비스 프록시 및 네트워크 추상화</td><td>- 프록시 서버<br>- 프로토콜 변환<br>- 로깅/모니터링</td><td>- 프로토콜 추상화<br>- 모니터링 용이<br>- 보안 강화</td><td>- 추가 홉<br>- 복잡도 증가<br>- 지연 가능성</td><td>- 레거시 통합<br>- 프로토콜 변환<br>- 보안 강화</td><td></td></tr><tr><td>Anti-corruption Layer</td><td>레거시 시스템과의 통합 인터페이스</td><td>- 변환 레이어<br>- 어댑터<br>- 캐싱</td><td>- 도메인 격리<br>- 변환 단순화<br>- 유지보수성</td><td>- 추가 레이어<br>- 성능 영향<br>- 복잡도 증가</td><td>- 레거시 통합<br>- 도메인 변환<br>- 점진적 현대화</td><td></td></tr><tr><td>재시도(Retry) 패턴</td><td>일시적 장애 복구를 위한 자동 재시도</td><td>- 재시도 정책<br>- 백오프 전략<br>- 실패 감지기</td><td>- 복원력 향상<br>- 자동 복구<br>- 안정성 향상</td><td>- 리소스 소비<br>- 지연 증가<br>- 상태 관리 복잡</td><td>- 네트워크 불안정<br>- 일시적 장애<br>- 외부 서비스 호출</td><td></td></tr></tbody></table><p>이러한 패턴들은 특정 문제를 해결하기 위해 설계되었으며, 실제 구현 시에는 여러 패턴을 조합하여 사용하는 것이 일반적입니다.<br>예를 들어:</p><ul><li>Strangler Fig 패턴과 Anti-Corruption Layer 패턴을 함께 사용하여 레거시 시스템을 안전하게 마이그레이션할 수 있다.</li><li>Service Registry & Discovery 패턴과 Sidecar 패턴을 조합하여 동적이고 확장 가능한 서비스 메시를 구축할 수 있다.</li><li>Backend for Frontend 패턴과 Ambassador 패턴을 통해 클라이언트별로 최적화된 안전한 API를 제공할 수 있다.</li><li>API Gateway 패턴과 Circuit Breaker 패턴을 함께 사용하여 시스템의 안정성을 높일 수 있다.</li><li>Event-Driven 패턴과 Saga 패턴을 조합하여 복잡한 비즈니스 프로세스를 처리할 수 있다.</li></ul><h3 id=패턴-선택-시-고려해야-할-핵심-사항들>패턴 선택 시 고려해야 할 핵심 사항들<a hidden class=anchor aria-hidden=true href=#패턴-선택-시-고려해야-할-핵심-사항들>#</a></h3><ol><li><p>시스템 요구사항</p><ul><li>확장성 필요성</li><li>성능 요구사항</li><li>보안 요구사항</li><li>유지보수성</li></ul></li><li><p>조직적 맥락</p><ul><li>팀의 기술적 역량</li><li>개발 및 운영 리소스</li><li>비즈니스 우선순위</li><li>시간 제약</li></ul></li><li><p>기술적 제약</p><ul><li>기존 인프라스트럭처</li><li>통합해야 할 시스템들</li><li>사용 가능한 도구와 플랫폼</li><li>비용 제약</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>External API</h2></header><div class=entry-content><p>참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-14 18:40:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;3 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to External API" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/external-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service Discovery</h2></header><div class=entry-content><p>Service Discovery 마이크로서비스 아키텍처(MSA)에서 Service Discovery는 핵심적인 패턴 중 하나이다.
이 패턴은 동적으로 변화하는 분산 환경에서 서비스 간 통신을 가능하게 하는 중요한 메커니즘이다.
Service Discovery는 네트워크 상의 서비스 위치(IP 주소와 포트)를 자동으로 감지하고 관리하는 프로세스이다.
이는 클라우드 환경이나 컨테이너 기반 아키텍처에서 특히 중요한데, 서비스 인스턴스가 동적으로 생성되고 제거되는 상황에서 효과적인 통신을 가능하게 한다.
필요성 동적 환경 대응: 클라우드 및 컨테이너 기반 환경에서 서비스의 IP 주소와 포트가 동적으로 변경된다. 자동 스케일링: 서비스 인스턴스가 자동으로 추가되거나 제거될 때 이를 감지하고 관리해야 한다. 장애 대응: 서비스 장애 시 자동으로 대체 인스턴스로 전환할 수 있어야 한다. Service Discovery의 주요 구성 요소 서비스 레지스트리: 사용 가능한 서비스 인스턴스의 네트워크 위치를 저장하는 데이터베이스 서비스 등록: 서비스 인스턴스가 시작될 때 자신의 정보를 레지스트리에 등록하는 프로세스 서비스 발견: 클라이언트가 필요한 서비스의 위치를 레지스트리에서 조회하는 프로세스 상태 모니터링: 등록된 서비스의 상태를 주기적으로 확인하는 메커니즘 Service Discovery 패턴의 종류 Client-Side Discovery: 클라이언트가 직접 서비스 레지스트리에 질의하여 서비스 위치를 찾는 방식.
장점:
...</p></div><footer class=entry-footer><span title='2024-11-14 10:06:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;955 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Discovery" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decomposition</h2></header><div class=entry-content><p>Decomposition 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-13 01:20:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decomposition" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/decomposition/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deployment</h2></header><div class=entry-content><p>Deployment 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-13 01:20:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deployment" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/deployment/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Database</h2></header><div class=entry-content><p>Database 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 11:22:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Database" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Communication style</h2></header><div class=entry-content><p>Communication style 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 02:18:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Communication style" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cross-Cutting Concern Patterns</h2></header><div class=entry-content><p>Cross-Cutting Concern Patterns 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 02:18:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cross-Cutting Concern Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>