<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Remote-Procedure | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,Communication-style"><meta name=description content="Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Remote-Procedure"><meta property="og:description" content="Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-12T11:22:00+00:00"><meta property="article:modified_time" content="2024-11-12T11:22:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="Communication-Style"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Remote-Procedure"><meta name=twitter:description content="Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"},{"@type":"ListItem","position":4,"name":"Communication style","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/"},{"@type":"ListItem","position":5,"name":"Remote-Procedure","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Remote-Procedure","name":"Remote-Procedure","description":"Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.","keywords":["Software-Design-and-Architecture","MSA-Patterns","Communication-style"],"articleBody":"Remote-Procedure Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.\nRPC의 작동 원리 클라이언트가 로컬 프로시저를 호출한다. 클라이언트 스텁이 파라미터를 마샬링(marshaling)하여 메시지로 패킹한다. 클라이언트의 운영체제가 메시지를 서버 머신으로 전송한다. 서버의 운영체제가 수신된 패킷을 서버 스텁으로 전달한다. 서버 스텁이 파라미터를 언마샬링(unmarshalling)한다. 서버 스텁이 서버 프로시저를 호출한다. RPC의 특징 투명성: 분산 컴퓨팅을 중앙 집중식 컴퓨팅처럼 보이게 만든다. 높은 수준의 프로토콜: 소켓 통신보다 더 높은 수준의 추상화를 제공한다. 위치 및 구현 언어에 대한 투명성 제공: 클라이언트-서버 통신에 대한 투명성을 제공한다. RPI 패턴의 주요 구성 요소 통신 프로토콜: HTTP/REST가 가장 일반적이지만, gRPC나 GraphQL도 사용될 수 있습니다. 각 프로토콜은 자신만의 장단점이 있다. 예를 들어, REST는 간단하고 이해하기 쉽지만, gRPC는 더 높은 성능을 제공한다. 서비스 인터페이스: API 계약은 매우 중요하다. 버저닝, 문서화, 그리고 하위 호환성을 고려해야 한다. 예를 들어, Swagger나 OpenAPI를 사용하여 API를 문서화하고 관리할 수 있다. 오류 처리: 네트워크 오류, 타임아웃, 서비스 불가용 등 다양한 실패 케이스를 고려해야 한다. Circuit Breaker 패턴을 사용하여 연쇄 실패를 방지할 수 있다. 보안: 인증, 인가, 데이터 암호화 등 보안 측면을 고려해야 한다. OAuth2나 JWT를 사용하여 서비스 간 인증을 구현할 수 있다. RPC의 장점 효율성: 도메인 특화 기능으로 통신 효율성이 높아진다. 구현 용이성: REST나 gRPC와 같은 잘 알려진 RPC 기술을 사용하여 쉽게 구현할 수 있다. 직관적인 프로그래밍 모델: 개발자가 분산 시스템을 로컬 시스템처럼 프로그래밍할 수 있게 해준다. RPC의 단점 네트워크 문제로 인한 실패 가능성: 예측할 수 없는 네트워크 문제로 인해 원격 호출이 실패할 수 있다. 복잡성: 로컬 호출과 달리 네트워크 지연, 오류 처리 등 추가적인 복잡성이 발생한다. 호환성 문제: 다른 시스템과의 통합이 어려울 수 있다. RPI 패턴 구현 시 고려해야 할 사항 성능 최적화: 네트워크 지연을 최소화하고, 캐싱을 활용하며, 배치 처리를 고려해야 한다. 예를 들어, 여러 개의 작은 요청 대신 하나의 큰 요청으로 처리하는 것이 효율적일 수 있다. 확장성: 서비스 디스커버리, 로드 밸런싱, 그리고 자동 스케일링을 구현해야 한다. Eureka나 Consul과 같은 서비스 디스커버리 도구를 활용할 수 있다. 모니터링: 요청/응답 시간, 오류율, 처리량 등을 모니터링해야 한다. Prometheus나 Grafana와 같은 도구를 사용하여 메트릭스를 수집하고 시각화할 수 있다. MSA에서의 RPC 활용 마이크로서비스 아키텍처에서 RPC는 서비스 간 통신을 위한 효과적인 방법 중 하나이다. 특히 동기식, 저지연 상호작용이 필요한 경우에 적합하다. REST, gRPC, Apache Thrift 등의 기술을 활용하여 구현할 수 있다.\nRPC는 MSA 환경에서 서비스 간 효율적인 통신을 가능하게 하는 강력한 패턴입니다. 그러나 시스템의 요구사항과 특성에 따라 적절한 통신 방식을 선택하는 것이 중요합니다.\n참고 및 출처 ","wordCount":"386","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-12T11:22:00Z","dateModified":"2024-11-12T11:22:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/>MSA Pattern</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/>Communication style</a></div><h1 class="post-title entry-hint-parent">Remote-Procedure</h1><div class=post-description>Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.</div><div class=post-meta><span title='2024-11-12 11:22:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/MSA%20Patterns/Communication%20style/Remote-Procedure.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#remote-procedure>Remote-Procedure</a><ul><li><a href=#rpc의-작동-원리>RPC의 작동 원리</a></li><li><a href=#rpc의-특징>RPC의 특징</a></li><li><a href=#rpi-패턴의-주요-구성-요소>RPI 패턴의 주요 구성 요소</a></li><li><a href=#rpc의-장점>RPC의 장점</a></li><li><a href=#rpc의-단점>RPC의 단점</a></li><li><a href=#rpi-패턴-구현-시-고려해야-할-사항>RPI 패턴 구현 시 고려해야 할 사항</a></li><li><a href=#msa에서의-rpc-활용>MSA에서의 RPC 활용</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=remote-procedure>Remote-Procedure<a hidden class=anchor aria-hidden=true href=#remote-procedure>#</a></h2><p>Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.</p><h3 id=rpc의-작동-원리>RPC의 작동 원리<a hidden class=anchor aria-hidden=true href=#rpc의-작동-원리>#</a></h3><ol><li>클라이언트가 로컬 프로시저를 호출한다.</li><li>클라이언트 스텁이 파라미터를 마샬링(marshaling)하여 메시지로 패킹한다.</li><li>클라이언트의 운영체제가 메시지를 서버 머신으로 전송한다.</li><li>서버의 운영체제가 수신된 패킷을 서버 스텁으로 전달한다.</li><li>서버 스텁이 파라미터를 언마샬링(unmarshalling)한다.</li><li>서버 스텁이 서버 프로시저를 호출한다.</li></ol><h3 id=rpc의-특징>RPC의 특징<a hidden class=anchor aria-hidden=true href=#rpc의-특징>#</a></h3><ol><li>투명성: 분산 컴퓨팅을 중앙 집중식 컴퓨팅처럼 보이게 만든다.</li><li>높은 수준의 프로토콜: 소켓 통신보다 더 높은 수준의 추상화를 제공한다.</li><li>위치 및 구현 언어에 대한 투명성 제공: 클라이언트-서버 통신에 대한 투명성을 제공한다.</li></ol><h3 id=rpi-패턴의-주요-구성-요소>RPI 패턴의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#rpi-패턴의-주요-구성-요소>#</a></h3><ol><li>통신 프로토콜: HTTP/REST가 가장 일반적이지만, gRPC나 GraphQL도 사용될 수 있습니다. 각 프로토콜은 자신만의 장단점이 있다. 예를 들어, REST는 간단하고 이해하기 쉽지만, gRPC는 더 높은 성능을 제공한다.</li><li>서비스 인터페이스: API 계약은 매우 중요하다. 버저닝, 문서화, 그리고 하위 호환성을 고려해야 한다. 예를 들어, Swagger나 OpenAPI를 사용하여 API를 문서화하고 관리할 수 있다.</li><li>오류 처리: 네트워크 오류, 타임아웃, 서비스 불가용 등 다양한 실패 케이스를 고려해야 한다. Circuit Breaker 패턴을 사용하여 연쇄 실패를 방지할 수 있다.</li><li>보안: 인증, 인가, 데이터 암호화 등 보안 측면을 고려해야 한다. OAuth2나 JWT를 사용하여 서비스 간 인증을 구현할 수 있다.</li></ol><h3 id=rpc의-장점>RPC의 장점<a hidden class=anchor aria-hidden=true href=#rpc의-장점>#</a></h3><ol><li>효율성: 도메인 특화 기능으로 통신 효율성이 높아진다.</li><li>구현 용이성: REST나 gRPC와 같은 잘 알려진 RPC 기술을 사용하여 쉽게 구현할 수 있다.</li><li>직관적인 프로그래밍 모델: 개발자가 분산 시스템을 로컬 시스템처럼 프로그래밍할 수 있게 해준다.</li></ol><h3 id=rpc의-단점>RPC의 단점<a hidden class=anchor aria-hidden=true href=#rpc의-단점>#</a></h3><ol><li>네트워크 문제로 인한 실패 가능성: 예측할 수 없는 네트워크 문제로 인해 원격 호출이 실패할 수 있다.</li><li>복잡성: 로컬 호출과 달리 네트워크 지연, 오류 처리 등 추가적인 복잡성이 발생한다.</li><li>호환성 문제: 다른 시스템과의 통합이 어려울 수 있다.</li></ol><h3 id=rpi-패턴-구현-시-고려해야-할-사항>RPI 패턴 구현 시 고려해야 할 사항<a hidden class=anchor aria-hidden=true href=#rpi-패턴-구현-시-고려해야-할-사항>#</a></h3><ol><li>성능 최적화: 네트워크 지연을 최소화하고, 캐싱을 활용하며, 배치 처리를 고려해야 한다. 예를 들어, 여러 개의 작은 요청 대신 하나의 큰 요청으로 처리하는 것이 효율적일 수 있다.</li><li>확장성: 서비스 디스커버리, 로드 밸런싱, 그리고 자동 스케일링을 구현해야 한다. Eureka나 Consul과 같은 서비스 디스커버리 도구를 활용할 수 있다.</li><li>모니터링: 요청/응답 시간, 오류율, 처리량 등을 모니터링해야 한다. Prometheus나 Grafana와 같은 도구를 사용하여 메트릭스를 수집하고 시각화할 수 있다.</li></ol><h3 id=msa에서의-rpc-활용>MSA에서의 RPC 활용<a hidden class=anchor aria-hidden=true href=#msa에서의-rpc-활용>#</a></h3><p>마이크로서비스 아키텍처에서 RPC는 서비스 간 통신을 위한 효과적인 방법 중 하나이다. 특히 동기식, 저지연 상호작용이 필요한 경우에 적합하다. REST, gRPC, Apache Thrift 등의 기술을 활용하여 구현할 수 있다.</p><p>RPC는 MSA 환경에서 서비스 간 효율적인 통신을 가능하게 하는 강력한 패턴입니다. 그러나 시스템의 요구사항과 특성에 따라 적절한 통신 방식을 선택하는 것이 중요합니다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/communication-style/>Communication-Style</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/><span class=title>« Prev</span><br><span>Domain-specific</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/><span class=title>Next »</span><br><span>Messaging</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>