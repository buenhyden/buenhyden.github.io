<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Communication Patterns | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Architecture,Software-Architecture-Patterns,Application-Structure,MSA-Patterns,Asynchronous-Communication-Pattern,Message-based-Communication-Pattern,Synchronous-Communication-Pattern,Commnication,Publisher-Subscriber-Pattern"><meta name=description content="통신 패턴들은 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 가능하게 하며, 시스템의 확장성, 유연성, 성능을 향상시키는 데 중요한 역할을 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Communication Patterns"><meta property="og:description" content="통신 패턴들은 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 가능하게 하며, 시스템의 확장성, 유연성, 성능을 향상시키는 데 중요한 역할을 한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Communication Patterns"><meta name=twitter:description content="통신 패턴들은 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 가능하게 하며, 시스템의 확장성, 유연성, 성능을 향상시키는 데 중요한 역할을 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"},{"@type":"ListItem","position":4,"name":"Communication Patterns","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/>MSA Pattern</a></div><h1>Communication Patterns</h1><div class=post-description>통신 패턴들은 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 가능하게 하며, 시스템의 확장성, 유연성, 성능을 향상시키는 데 중요한 역할을 한다.</div></header><div class=post-content><h2 id=communication-patterns>Communication Patterns<a hidden class=anchor aria-hidden=true href=#communication-patterns>#</a></h2><p>통신 패턴들은 마이크로서비스 아키텍처에서 서비스 간의 효율적인 통신을 가능하게 하며, 시스템의 확장성, 유연성, 성능을 향상시키는 데 중요한 역할을 한다. 각 패턴은 특정 상황과 요구사항에 따라 선택되어 사용되며, 때로는 여러 패턴을 조합하여 사용하기도 한다.</p><p>비동기 통신 패턴과 메시지 기반 통신 패턴은 유사한 특성을 가지고 있으며, 둘 다 높은 확장성과 성능을 제공한다.<br>동기 통신 패턴은 구현이 간단하지만 확장성과 성능 면에서 제한적이다.<br>발행/구독 패턴은 가장 낮은 결합도와 높은 확장성을 제공하지만, 구현 복잡성이 높다.</p><p><figure><img alt="Illustrating the call flows of sync and async communication. Source: Walking Tree Technologies 2018." loading=lazy src=/img/1895.1550201849.png><figcaption>https://devopedia.org/inter-service-communication-for-microservices</figcaption></figure></p><p>마이크로서비스 아키텍처에서는 서비스 간의 느슨한 결합과 높은 확장성이 중요하기 때문에, 비동기 통신 패턴, 메시지 기반 통신 패턴, 그리고 발행/구독 패턴이 더 널리 사용되는 경향이 있다.</p><p>이러한 통신 패턴들은 다음과 같은 목적을 위해 사용된다:</p><ol><li><strong>유연성과 확장성 향상</strong>:<br>이러한 패턴들은 서비스 간의 결합도를 낮추어 시스템의 유연성과 확장성을 높인다.<br>특히 비동기 통신과 발행/구독 패턴은 서비스를 독립적으로 확장할 수 있게 해준다.</li><li><strong>성능 최적화</strong>:<br>비동기 통신과 메시지 기반 통신은 시스템의 전반적인 성능을 향상시킬 수 있다.<br>서비스가 다른 서비스의 응답을 기다리지 않고 작업을 계속할 수 있어 리소스를 효율적으로 사용할 수 있다.</li><li><strong>장애 격리</strong>:<br>이러한 패턴들은 서비스 간의 의존성을 줄여 한 서비스의 장애가 전체 시스템으로 전파되는 것을 방지한다.<br>특히 비동기 통신과 메시지 기반 통신은 일시적인 서비스 중단을 더 잘 처리할 수 있다.</li><li><strong>이벤트 기반 아키텍처 지원</strong>:<br>발행/구독 패턴과 메시지 기반 통신은 이벤트 기반 아키텍처를 구현하는 데 매우 유용하다.<br>이는 시스템이 실시간으로 변화에 반응할 수 있게 해준다.</li><li><strong>분산 시스템 구현</strong>:<br>이러한 패턴들은 분산 시스템을 구현하는 데 필수적이다.<br>서비스 간의 효율적인 통신을 가능하게 하여 복잡한 분산 시스템을 구축하고 관리할 수 있게 해준다.</li><li><strong>비즈니스 요구사항 대응</strong>:<br>다양한 통신 패턴을 사용함으로써 다양한 비즈니스 요구사항에 더 잘 대응할 수 있다.<br>예를 들어, 실시간 처리가 필요한 경우 비동기 통신을, 즉각적인 응답이 필요한 경우 동기 통신을 사용할 수 있다.</li></ol><table><thead><tr><th>항목</th><th>Synchronous Communication</th><th>Asynchronous Communication</th><th>Request-Response Pattern</th><th>Message-based Communication</th><th>Publisher-Subscriber Pattern</th><th>Event-Driven Pattern</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>- 요청-응답 기반 통신<br>- 호출자가 응답을 기다림<br>- 직접적인 서비스 간 통신</td><td>- 비동기 요청-응답<br>- 호출자가 응답을 기다리지 않음<br>- 콜백이나 이벤트로 결과 처리</td><td>- 클라이언트가 서버에 요청을 보내고 응답을 받음<br>1:1 통신<br>- 요청-응답 사이클 기반<br>- 서비스 간 직접 통신</td><td>- 메시지 큐를 통한 통신<br>- 메시지 브로커 사용<br>- 메시지 기반의 비동기 처리</td><td>- 이벤트 기반 통신<br>- 발행자와 구독자의 분리<br>- 다대다 통신 지원</td><td>- 이벤트 생성과 소비 기반<br>- 이벤트 브로커 사용<br>- 이벤트 중심 비즈니스 로직<br>- 느슨한 결합 구조</td></tr><tr><td><strong>통신 방식</strong></td><td>- REST API<br>gRPC<br>GraphQL</td><td>- 웹소켓<br>Server-Sent Events<br>Long Polling</td><td>- HTTP/REST API<br>gRPC<br>GraphQL<br>SOAP</td><td>- Apache Kafka<br>RabbitMQ<br>Amazon SQS</td><td>- Apache Kafka<br>Redis Pub/Sub<br>RabbitMQ</td><td>- Event Bus<br>Message Broker<br>Event Stream<br>Webhook</td></tr><tr><td><strong>장점</strong></td><td>- 구현이 단순<br>- 즉각적인 응답<br>- 직관적인 에러 처리<br>- 트랜잭션 관리 용이</td><td>- 높은 확장성<br>- 성능 향상<br>- 서비스 간 느슨한 결합<br>- 부하 분산 용이</td><td>- 직관적인 구현<br>- 즉각적인 피드백<br>- 간단한 디버깅<br>- 명확한 인터페이스</td><td>- 안정적인 메시지 전달<br>- 시스템 복원력 향상<br>- 부하 처리 우수<br>- 메시지 영속성</td><td>- 높은 확장성<br>- 유연한 시스템 구조<br>- 실시간 이벤트 처리<br>- 다중 구독자 지원</td><td>- 높은 확장성<br>- 느슨한 결합<br>- 유연한 시스템 구조<br>- 실시간 처리 용이</td></tr><tr><td><strong>단점</strong></td><td>- 강한 결합<br>- 확장성 제한<br>- 지연 시간 증가<br>- 단일 장애점 위험</td><td>- 복잡한 구현<br>- 디버깅 어려움<br>- 일관성 보장 어려움<br>- 추적성 관리 필요</td><td>- 강한 결합도<br>- 동기 처리의 제약<br>- 확장성 제한<br>- 대기 시간 증가</td><td>- 메시지 브로커 의존성<br>- 시스템 복잡도 증가<br>- 추가 인프라 필요<br>- 운영 비용 증가</td><td>- 메시지 순서 보장 어려움<br>- 시스템 복잡도 증가<br>- 메시지 신뢰성 관리 필요<br>- 구독자 관리 부담</td><td>- 복잡한 이벤트 추적<br>- 일관성 보장 어려움<br>- 이벤트 순서 관리<br>- 시스템 복잡도 증가</td></tr><tr><td><strong>적용 사례</strong></td><td>- 사용자 인증<br>- 결제 처리<br>CRUD 작업<br>- 실시간 조회</td><td>- 알림 시스템<br>- 로그 처리<br>- 비동기 작업<br>- 배치 처리</td><td>- API 호출<br>- 데이터 조회<br>- 인증/인가<br>- 단순 CRUD 작업</td><td>- 주문 처리<br>- 재고 관리<br>- 이메일 발송<br>- 작업 큐 관리</td><td>- 실시간 모니터링<br>- 이벤트 스트리밍<br>- 로그 수집<br>- 메트릭 수집</td><td>- 실시간 분석<br>- 워크플로우 관리<br>- 도메인 이벤트 처리<br>- 시스템 통합</td></tr><tr><td><strong>성능 특성</strong></td><td>- 낮은 지연 시간<br>- 높은 일관성<br>- 제한된 처리량<br>- 리소스 사용 증가</td><td>- 변동적 지연 시간<br>- 높은 처리량<br>- 리소스 효율성<br>- 부하 분산 가능</td><td>- 예측 가능한 지연시간<br>- 높은 일관성<br>- 제한된 처리량<br>- 동시성 제약</td><td>- 안정적인 처리량<br>- 메시지 보장<br>- 부하 조절 가능<br>- 장애 복구 지원</td><td>- 높은 처리량<br>- 실시간 성능<br>- 확장성 우수<br>- 부하 분산 자동화</td><td>- 높은 처리량<br>- 비동기 처리<br>- 확장성 우수<br>- 이벤트 버퍼링</td></tr><tr><td><strong>설계 고려사항</strong></td><td>- 타임아웃 설정<br>- 서킷 브레이커 적용<br>- 재시도 정책<br>- 에러 처리</td><td>- 메시지 순서<br>- 상태 관리<br>- 장애 처리<br>- 모니터링</td><td>- 타임아웃 설정<br>- 재시도 정책<br>- 서킷브레이커<br>API 버전 관리</td><td>- 메시지 포맷<br>- 큐 관리<br>- 데드레터 큐<br>- 메시지 라우팅</td><td>- 이벤트 스키마<br>- 구독자 관리<br>- 메시지 필터링<br>- 장애 복구</td><td>- 이벤트 스키마<br>- 이벤트 저장소<br>- 이벤트 라우팅<br>- 실패 처리</td></tr><tr><td><strong>모니터링/운영</strong></td><td>- 응답 시간<br>- 에러율<br>- 서비스 상태<br>- 트래픽 패턴</td><td>- 메시지 처리율<br>- 큐 길이<br>- 처리 지연<br>- 실패율</td><td>- 응답 시간<br>- 요청 성공률<br>API 사용량<br>- 에러율</td><td>- 큐 상태<br>- 처리량<br>- 브로커 상태<br>- 메시지 적체</td><td>- 이벤트 처리율<br>- 구독자 상태<br>- 전달 지연<br>- 시스템 부하</td><td>- 이벤트 처리율<br>- 이벤트 지연시간<br>- 이벤트 큐 상태<br>consumer 상태</td></tr></tbody></table><ul><li>Request-Response Pattern은 Synchronous Communication과 많은 특징을 공유하지만, 비동기적으로도 구현될 수 있어 더 유연하다.</li><li>Event-Driven Pattern은 Publisher-Subscriber Pattern과 유사하나, 이벤트의 발생과 처리에 더 중점을 두며 시스템 전체의 아키텍처적 관점을 가진다.</li><li>두 패턴 모두 다른 패턴들과 조합하여 사용될 수 있으며, 특히 마이크로서비스 아키텍처에서는 여러 패턴을 상황에 맞게 혼용하는 것이 일반적이다.</li></ul><ol><li><p>패턴 선택 기준</p><ul><li>실시간성이 필요한 경우: Synchronous Communication</li><li>높은 확장성이 필요한 경우: Asynchronous 또는 Pub/Sub</li><li>안정적인 메시지 전달이 중요한 경우: Message-based</li><li>이벤트 기반 처리가 필요한 경우: Publisher-Subscriber</li></ul></li><li><p>패턴 조합 사용</p><ul><li>실제 MSA 환경에서는 단일 패턴만 사용하지 않음</li><li>요구사항에 따라 여러 패턴을 조합하여 사용</li><li>각 패턴의 장점을 활용하고 단점을 보완</li></ul></li><li><p>구현 시 고려사항</p><ul><li>시스템의 규모와 복잡도</li><li>팀의 기술적 역량</li><li>운영/모니터링 환경</li><li>비용과 리소스 제약</li></ul></li></ol><p>MSA 환경에서는 이러한 통신 패턴들을 적절히 조합하여 사용하는 것이 중요하다.<br>각 서비스의 특성과 요구사항을 고려하여 최적의 패턴을 선택하고, 필요한 경우 여러 패턴을 함께 사용하는 것이 효과적이다.</p><h3 id=message-based-communication-vs-publisher-subscriber-pattern-vs-event-driven-pattern>Message-based Communication Vs Publisher-subscriber Pattern Vs Event-Driven Pattern<a hidden class=anchor aria-hidden=true href=#message-based-communication-vs-publisher-subscriber-pattern-vs-event-driven-pattern>#</a></h3><p>![메시지 큐 모델과 Pub/Sub 이벤트 스트림 모델의 비교](event-driven-architecture-pubsub-1-comparison-overview.svg &ldquo;<a href="https://cloud.google.com/solutions/event-driven-architecture-pubsub?hl=ko">https://cloud.google.com/solutions/event-driven-architecture-pubsub?hl=ko</a> _</p><p>Event-Driven Pattern은 이벤트 중심의 설계로, 상태 변화를 이벤트로 처리하고 비동기적으로 시스템 컴포넌트들이 반응하는 방식을 취한다.<br>이는 높은 확장성과 유연성을 제공하며, 복잡한 비즈니스 프로세스를 처리하는 데 적합하다.<br>Event-Driven Pattern은 다른 두 패턴과 비교하여 더 높은 수준의 추상화를 제공하며, 시스템의 전반적인 아키텍처에 영향을 미친다. 이 패턴은 마이크로서비스 아키텍처와 잘 어울리며, 실시간 데이터 처리와 복잡한 워크플로우 관리에 특히 유용하다.</p><p>각 패턴은 고유한 장단점을 가지고 있으며, 시스템의 요구사항과 특성에 따라 적절한 패턴을 선택하거나 조합하여 사용할 수 있다.<br>예를 들어, 높은 신뢰성과 순서 보장이 필요한 경우 Message-based Communication을,<br>실시간 데이터 스트리밍이 필요한 경우 Publisher-Subscriber Pattern을,<br>그리고 복잡한 비즈니스 로직과 높은 확장성이 필요한 경우 Event-Driven Pattern을 선택할 수 있다.</p><table><thead><tr><th>비교 항목</th><th>Message-based Communication</th><th>Publisher-Subscriber Pattern</th><th>Event-Driven Pattern</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>- 메시지 큐를 통한 점대점(Point-to-Point) 통신<br>- 단일 수신자 지향<br>- 메시지는 한 번만 처리됨<br>- 메시지 보존 및 순서 보장 중시</td><td>- 이벤트 기반의 다대다 통신<br>- 다중 수신자 지향<br>- 동일 메시지 다수 구독자 처리 가능<br>- 이벤트 전파와 실시간성 중시</td><td>- 이벤트 중심의 비즈니스 로직<br>- 상태 변화를 이벤트로 처리<br>- 이벤트 소싱 가능<br>- 도메인 이벤트 중심 설계</td></tr><tr><td><strong>메시지 전달 방식</strong></td><td>- 큐 기반 전달<br>FIFO 순서 보장<br>- 메시지 영속성 지원<br>- 메시지 손실 방지 메커니즘</td><td>- 토픽/채널 기반 전달<br>- 브로드캐스팅 방식<br>- 실시간 스트리밍 가능<br>- 이벤트 기반 라우팅</td><td>- 이벤트 스트림 기반<br>- 이벤트 소싱<br>- 상태 변경 전파<br>- 이벤트 저장소 활용</td></tr><tr><td><strong>수신자 처리</strong></td><td>- 단일 수신자가 메시지 처리<br>- 메시지 처리 후 큐에서 제거<br>- 작업 분배 패턴<br>- 로드 밸런싱 용이</td><td>- 다수의 구독자 동시 처리<br>- 메시지 복사본 전달<br>- 관심사 기반 구독<br>- 동적 구독자 관리</td><td>- 이벤트 핸들러 기반 처리<br>- 이벤트 소스별 처리<br>- 이벤트 재생 가능<br>- 상태 재구성 가능</td></tr><tr><td><strong>데이터 지속성</strong></td><td>- 강력한 메시지 보존<br>- 디스크 기반 저장<br>- 장애 복구 지원<br>- 트랜잭션 지원</td><td>- 일시적 메시지 처리<br>- 메모리 기반 처리<br>- 실시간 전달 중심<br>- 이벤트 스트리밍</td><td>- 이벤트 저장소 영구 보존<br>- 이벤트 히스토리 관리<br>- 상태 스냅샷 지원<br>- 이벤트 버전 관리</td></tr><tr><td><strong>확장성 특성</strong></td><td>- 수직적 확장성<br>- 큐 파티셔닝<br>- 메시지 그룹핑<br>- 처리량 제어</td><td>- 수평적 확장성<br>- 토픽 파티셔닝<br>- 구독자 그룹<br>- 동적 스케일링</td><td>- 이벤트 소싱 기반 확장<br>- 이벤트 파티셔닝<br>CQRS 패턴 활용<br>- 분산 처리 용이</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>- 주문 처리 시스템<br>- 결제 처리<br>- 배치 작업<br>- 워크플로우 관리</td><td>- 실시간 모니터링<br>- 로그 수집<br>- 알림 시스템<br>- 실시간 분석</td><td>- 도메인 이벤트 처리<br>- 감사 로깅<br>- 상태 추적<br>- 비즈니스 프로세스 자동화</td></tr><tr><td><strong>구현 도구</strong></td><td>- RabbitMQ<br>ActiveMQ<br>Amazon SQS<br>Azure Service Bus</td><td>- Apache Kafka<br>Redis Pub/Sub<br>Google Cloud Pub/Sub<br>AWS SNS</td><td>- Event Store<br>Axon Framework<br>Eventuate<br>Apache Kafka Streams</td></tr><tr><td><strong>장점</strong></td><td>- 신뢰성 높은 메시지 전달<br>- 트랜잭션 보장<br>- 순서 보장<br>- 장애 복구 용이</td><td>- 높은 확장성<br>- 낮은 지연 시간<br>- 유연한 구독 모델<br>- 실시간 처리</td><td>- 완벽한 감사 추적<br>- 시스템 상태 재현<br>- 높은 확장성<br>- 도메인 중심 설계</td></tr><tr><td><strong>단점</strong></td><td>- 상대적으로 높은 지연시간<br>- 시스템 복잡도 증가<br>- 운영 비용 증가<br>- 큐 관리 부담</td><td>- 메시지 순서 보장 어려움<br>- 일시적 메시지 손실 가능<br>- 구독자 관리 복잡<br>- 중복 처리 가능성</td><td>- 학습 곡선이 높음<br>- 복잡한 이벤트 관리<br>- 저장소 크기 증가<br>- 이벤트 버전 관리 필요</td></tr><tr><td><strong>성능 특성</strong></td><td>- 높은 신뢰성<br>- 중간~높은 지연시간<br>- 보통 처리량<br>- 리소스 사용량 높음</td><td>- 낮은 지연시간<br>- 매우 높은 처리량<br>- 효율적 리소스 사용<br>- 실시간 성능</td><td>- 읽기 성능 우수<br>- 쓰기 지연 가능<br>- 이벤트 재생 부하<br>- 스냅샷 처리 영향</td></tr><tr><td><strong>모니터링 중점</strong></td><td>- 큐 길이<br>- 처리 지연<br>- 메시지 상태<br>- 실패율</td><td>- 구독자 상태<br>- 이벤트 처리율<br>- 전달 지연<br>- 시스템 부하</td><td>- 이벤트 처리 상태<br>- 이벤트 스토어 크기<br>- 재생 성능<br>- 스냅샷 생성 주기</td></tr><tr><td><strong>장애 처리</strong></td><td>- 자동 재시도<br>- 데드레터 큐<br>- 장애 복구 메커니즘<br>- 메시지 재처리</td><td>- 구독자 재연결<br>- 이벤트 재발행<br>- 장애 격리<br>- 백프레셔 처리</td><td>- 이벤트 재생<br>- 스냅샷 복구<br>- 버전 충돌 해결<br>- 이벤트 정합성 검증</td></tr></tbody></table><p>세 패턴의 주요 차이점:</p><ol><li>메시지 전달 방식과 목적<ol><li>Message-based Communication은 신뢰성 있는 메시지 전달에 중점을 둔다.<br>메시지는 큐에 저장되어 순차적으로 처리되며, 하나의 메시지는 단일 수신자에 의해서만 처리된다.<br>예를 들어, 주문 처리 시스템에서 각 주문은 정확히 한 번만 처리되어야 하므로 이 패턴이 적합하다.</li><li>Publisher-Subscriber Pattern은 이벤트의 실시간 전파에 초점을 맞춘다.<br>하나의 이벤트가 여러 구독자에게 동시에 전달될 수 있으며, 구독자들은 자신의 관심사에 따라 필요한 이벤트만 수신한다.<br>실시간 모니터링 시스템이 좋은 예시이다. 시스템 상태 변경을 여러 모니터링 도구가 동시에 관찰해야 하는 경우에 효과적이다.</li><li>Event-Driven Pattern은 비즈니스 로직을 이벤트 중심으로 구성한다.<br>시스템의 상태 변화를 이벤트로 표현하고, 이를 기반으로 다른 작업들이 트리거된다.<br>이는 도메인 이벤트를 중심으로 시스템을 설계하는 방식으로, 예를 들어 전자상거래 시스템에서 &lsquo;주문완료&rsquo; 이벤트가 발생하면 자동으로 재고 확인, 결제 처리, 배송 준비 등의 프로세스가 시작되는 방식이다.</li></ol></li><li>데이터 처리와 저장<ol><li>Message-based Communication은 메시지의 영속성과 순서를 보장한다.<br>모든 메시지는 디스크에 저장되어 장애 상황에서도 손실되지 않으며, FIFO(First In First Out) 순서가 유지된다.<br>이는 금융 거래와 같이 데이터 손실이 허용되지 않는 시스템에 적합하다.</li><li>Publisher-Subscriber Pattern은 일반적으로 메모리 기반의 실시간 처리를 수행한다.<br>이벤트는 발생 즉시 구독자들에게 전달되며, 영속성보다는 전달 속도가 중요시된다.<br>실시간 채팅 시스템이나 주식 시세 정보 전달과 같은 용도에 적합하다.</li><li>Event-Driven Pattern은 이벤트 저장소를 통해 모든 이벤트의 히스토리를 보관한다.<br>이를 통해 시스템의 상태를 언제든 재구성할 수 있으며, 감사(audit) 추적이 가능하다.<br>이는 규제가 엄격한 산업이나 변경 이력 추적이 중요한 시스템에 유용하다.</li></ol></li></ol><p>선택 기준:</p><ol><li>시스템 요구사항에 따른 선택 신뢰성이 최우선인 경우: Message-based Communication을 선택한다.<br>메시지 손실이 허용되지 않는 금융 거래, 주문 처리 등의 시스템에 적합하다.</li><li>실시간성이 중요한 경우: Publisher-Subscriber Pattern이 적합하다.<br>실시간 알림, 모니터링, 로그 수집 등 즉각적인 데이터 전파가 필요한 상황에서 사용한다.</li><li>비즈니스 프로세스 자동화가 필요한 경우: Event-Driven Pattern을 고려한다.<br>복잡한 업무 흐름을 이벤트 기반으로 자동화하고, 시스템의 상태 변화를 추적해야 하는 경우에 적합하다.</li><li>기술적 고려사항 확장성 요구사항: Publisher-Subscriber Pattern과 Event-Driven Pattern은 높은 확장성을 제공한다.<br>구독자나 이벤트 핸들러를 독립적으로 확장할 수 있다.</li><li>운영 복잡도:<br>Message-based Communication은 상대적으로 단순한 운영을 제공한다.<br>반면 Event-Driven Pattern은 복잡한 이벤트 관리와 버전 관리가 필요할 수 있다.</li><li>리소스 사용:<br>Message-based Communication은 메시지 저장과 관리를 위해 더 많은 리소스를 필요로 한다.<br>Publisher-Subscriber Pattern은 메모리 기반 처리로 리소스 사용이 효율적이다.</li></ol><p>실제 구현 시에는 이러한 패턴들을 조합하여 사용하는 것이 일반적이다. 예를 들어, 중요한 트랜잭션은 Message-based Communication으로 처리하고, 상태 변경 알림은 Publisher-Subscriber Pattern을 통해 전달하며, 전체 시스템의 워크플로우는 Event-Driven Pattern으로 관리하는 방식이다. 이를 통해 각 패턴의 장점을 최대한 활용하면서 시스템의 요구사항을 효과적으로 충족할 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비동기 통신 패턴(Asynchronous Communication Pattern)</h2></header><div class=entry-content><p>비동기 통신 패턴(Asynchronous Communication Pattern) Asynchronous Communication Pattern은 마이크로서비스 간 통신에서 메시지를 보내는 서비스가 즉각적인 응답을 기다리지 않고 계속해서 작업을 수행할 수 있게 하는 방식이다.
이 패턴은 서비스 간 느슨한 결합을 가능하게 하며, 시스템의 확장성과 탄력성을 향상시킨다.
Asynchronous Communication Pattern은 MSA에서 서비스 간 효율적인 통신을 가능하게 하며, 시스템의 확장성과 탄력성을 크게 향상시킨다.
하지만 구현의 복잡성과 메시지 순서 관리 등의 도전 과제도 존재하므로, 이를 고려하여 적절히 설계하고 구현해야 한다.
Asynchronous Communication의 주요 특징 비동기 처리: 서비스는 메시지를 보낸 후 응답을 기다리지 않고 다음 작업을 수행한다. 메시지 브로커 사용: Kafka나 RabbitMQ와 같은 메시지 브로커를 통해 서비스 간 통신이 이루어진다. 유연성: 팀원들이 자신의 일정에 맞춰 작업할 수 있어 글로벌 팀이나 원격 근무에 적합하다. 확장성: 서비스들이 독립적으로 메시지를 처리할 수 있어 더 나은 확장성을 제공한다. Asynchronous Communication Pattern의 장점 높은 확장성: 서비스들이 독립적으로 메시지를 처리할 수 있어 시스템 전체의 확장성이 향상된다. 향상된 장애 허용성: 서비스 간 결합도가 낮아 한 서비스의 실패가 다른 서비스에 즉각적인 영향을 미치지 않는다. 유연한 의존성 관리: 이벤트 기반 아키텍처를 통해 서비스 간 의존성을 줄일 수 있다. 높은 처리량: 서비스들이 동시에 메시지를 처리할 수 있어 전체적인 처리량이 증가한다. Asynchronous Communication 구현 방식 메시징 시스템: Kafka, RabbitMQ 등의 메시지 브로커를 사용한다. 이벤트 기반 아키텍처: 서비스들이 이벤트를 발행하고 구독하는 방식으로 통신한다. 비동기 프로토콜: AMQP와 같은 비동기 프로토콜을 사용하여 메시지를 전송한다. Asynchronous Communication Pattern의 사용 사례 알림 시스템: SMS, 이메일 등의 알림을 보낼 때 사용된다. 주문 처리: 온라인 상점에서 주문 확인 메시지를 보낼 때 활용된다. 보고서 생성: 시간이 오래 걸리는 보고서 생성 작업에 적합하다. 구현 시 고려사항 메시지 순서: 메시지의 순서가 중요한 경우, 적절한 순서 보장 메커니즘을 구현해야 한다. 트랜잭션 관리: 클라이언트 측에서 트랜잭션을 관리하여 일관성을 유지해야 한다. 메시지 지속성: 시스템 장애 시에도 메시지가 손실되지 않도록 보장해야 한다. 모니터링 및 추적: 비동기 통신의 특성상 문제 발생 시 디버깅이 어려울 수 있으므로, 적절한 모니터링 및 추적 시스템을 구축해야 한다. Asynchronous Communication Pattern을 활용한 실제 구현 예시 %%{init: {'theme': 'default', 'themeVariables': { 'fontSize': '12px'}, 'flowchart': {'width': 400, 'height': 250, 'diagramPadding': 8}}}%% sequenceDiagram participant Client participant OrderService participant MessageQueue participant PaymentService participant NotificationService Note over Client,NotificationService: Async Flow Client->>OrderService: 1. Create Order activate OrderService OrderService-->>Client: 2. Accepted (202) OrderService->>MessageQueue: 3. Publish Event deactivate OrderService MessageQueue->>PaymentService: 4a. Consume activate PaymentService PaymentService->>MessageQueue: 5a. Process deactivate PaymentService MessageQueue->>NotificationService: 4b. Consume activate NotificationService NotificationService-->>MessageQueue: 5b. Ack deactivate NotificationService MessageQueue->>OrderService: 6. Update activate OrderService OrderService->>MessageQueue: 7. Status deactivate OrderService MessageQueue->>NotificationService: 8. Send activate NotificationService NotificationService->>Client: 9. Push deactivate NotificationService 알림 시스템과 주문 처리 시스템
주요 컴포넌트와 특징:
...</p></div><footer class=entry-footer><span title='2024-12-28 03:56:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1273 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비동기 통신 패턴(Asynchronous Communication Pattern)" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/asynchronous-communication-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>