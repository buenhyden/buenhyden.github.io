<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Retry Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,Reliability"><meta name=description content="Retry Pattern
Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.
Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.
Retry Pattern의 주요 특징

재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다.
재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다.
백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다.
조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다.

Retry Pattern 구현 방법

Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다.
Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다.
커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다.

재시도 패턴 구현 시 고려사항
재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Retry Pattern"><meta property="og:description" content="Retry Pattern Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.
Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.
Retry Pattern의 주요 특징 재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다. 재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다. 백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다. 조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다. Retry Pattern 구현 방법 Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다. Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다. 커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다. 재시도 패턴 구현 시 고려사항 재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-17T02:18:00+00:00"><meta property="article:modified_time" content="2024-11-17T02:18:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="Reliability"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Retry Pattern"><meta name=twitter:description content="Retry Pattern
Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.
Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.
Retry Pattern의 주요 특징

재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다.
재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다.
백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다.
조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다.

Retry Pattern 구현 방법

Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다.
Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다.
커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다.

재시도 패턴 구현 시 고려사항
재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"},{"@type":"ListItem","position":4,"name":"Reliability","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/"},{"@type":"ListItem","position":5,"name":"Retry Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Retry Pattern","name":"Retry Pattern","description":"Retry Pattern Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.\n특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.\nRetry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.\n일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.\nRetry Pattern의 주요 특징 재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다. 재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다. 백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다. 조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다. Retry Pattern 구현 방법 Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다. Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다. 커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다. 재시도 패턴 구현 시 고려사항 재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:\n","keywords":["Software-Design-and-Architecture","MSA-Patterns","Reliability"],"articleBody":"Retry Pattern Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.\n특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.\nRetry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.\n일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.\nRetry Pattern의 주요 특징 재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다. 재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다. 백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다. 조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다. Retry Pattern 구현 방법 Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다. Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다. 커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다. 재시도 패턴 구현 시 고려사항 재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:\n재시도 대상 오류 식별\n모든 오류에 대해 재시도를 시도하는 것은 비효율적일 수 있다.\n따라서 재시도가 효과적인 오류와 그렇지 않은 오류를 구분해야 한다.\n예를 들어:\n재시도에 적합한 오류: 네트워크 타임아웃, 일시적인 서비스 불가 등 재시도에 부적합한 오류: 인증 실패, 잘못된 요청 등 재시도 횟수 및 간격 설정\n무한정 재시도를 시도하는 것은 시스템 자원을 낭비하고, 대상 서비스에 추가적인 부하를 줄 수 있다.\n따라서:\n최대 재시도 횟수를 설정하여 무한 재시도를 방지한다. 재시도 간격을 설정하여 연속적인 재시도로 인한 부하를 완화한다. 백오프(Backoff) 전략\n재시도 간격을 점진적으로 늘리는 백오프 전략을 적용하면, 대상 서비스에 가해지는 부하를 줄이고 복구 시간을 확보할 수 있다.\n일반적인 백오프 전략으로는 지수 백오프(Exponential Backoff) 가 있으며, 이는 재시도 간격을 지수 함수적으로 증가시키는 방식이다.\n멱등성(Idempotency) 보장\n재시도 시 동일한 요청이 여러 번 처리될 수 있으므로, 대상 서비스의 작업이 멱등성을 보장해야 한다.\n즉, 동일한 요청이 여러 번 수행되더라도 시스템의 상태가 일관되게 유지되어야 한다.\n재시도 스톰 방지\n여러 서비스가 동시에 재시도를 수행하여 시스템에 과부하를 주는 상황을 피해야 한다.\n타임아웃 설정\n각 재시도에 적절한 타임아웃을 설정하여 전체 처리 시간을 제한해야 한다.\n로깅과 모니터링\n재시도 횟수와 결과를 로깅하고 모니터링하여 시스템의 동작을 파악해야 한다.\nRetry Pattern의 장단점 장점:\n일시적인 오류를 자동으로 복구할 수 있다. 시스템의 안정성과 가용성을 향상시킨다. 단점:\n구현이 복잡해질 수 있다. 부적절한 사용 시 시스템 부하를 증가시킬 수 있다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 재시도 로직을 포함한 서비스 클라이언트 구현 class ServiceClient { constructor(options = {}) { this.maxRetries = options.maxRetries || 3; this.initialDelay = options.initialDelay || 1000; this.maxDelay = options.maxDelay || 5000; this.backoffMultiplier = options.backoffMultiplier || 2; } async executeWithRetry(operation) { let lastError; let delay = this.initialDelay; // 재시도 횟수만큼 반복 for (let attempt = 1; attempt \u003c= this.maxRetries; attempt++) { try { // 작업 실행 const result = await operation(); // 성공 시 즉시 반환 return result; } catch (error) { lastError = error; // 재시도 가능한 오류인지 확인 if (!this.isRetryable(error)) { throw error; } // 마지막 시도였다면 오류 발생 if (attempt === this.maxRetries) { throw new Error(`작업 실패 after ${this.maxRetries} attempts: ${error.message}`); } // 대기 후 재시도 await this.wait(delay); // 지연 시간을 지수적으로 증가 delay = Math.min(delay * this.backoffMultiplier, this.maxDelay); } } } // 재시도 가능한 오류인지 판단 isRetryable(error) { return error.status === 429 || // Too Many Requests error.status === 503 || // Service Unavailable error.code === 'ECONNRESET' || // 연결 재설정 error.code === 'ETIMEDOUT'; // 타임아웃 } // 지정된 시간만큼 대기 wait(ms) { return new Promise(resolve =\u003e setTimeout(resolve, ms)); } } 참고 및 출처 ","wordCount":"610","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-17T02:18:00Z","dateModified":"2024-11-17T02:18:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/>MSA Pattern</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/>Reliability</a></div><h1 class="post-title entry-hint-parent">Retry Pattern</h1><div class=post-meta><span title='2024-11-17 02:18:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;610 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/MSA%20Patterns/Reliability/Retry.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#retry-pattern>Retry Pattern</a><ul><li><a href=#retry-pattern의-주요-특징>Retry Pattern의 주요 특징</a></li><li><a href=#retry-pattern-구현-방법>Retry Pattern 구현 방법</a></li><li><a href=#재시도-패턴-구현-시-고려사항>재시도 패턴 구현 시 고려사항</a></li><li><a href=#retry-pattern의-장단점>Retry Pattern의 장단점</a></li><li><a href=#구현-예시>구현 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=retry-pattern>Retry Pattern<a hidden class=anchor aria-hidden=true href=#retry-pattern>#</a></h2><p>Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.<br>특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.</p><p>Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.<br>일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.</p><h3 id=retry-pattern의-주요-특징>Retry Pattern의 주요 특징<a hidden class=anchor aria-hidden=true href=#retry-pattern의-주요-특징>#</a></h3><ol><li><strong>재시도 횟수</strong>: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다.</li><li><strong>재시도 간격</strong>: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다.</li><li><strong>백오프 전략</strong>: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다.</li><li><strong>조건부 재시도</strong>: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다.</li></ol><h3 id=retry-pattern-구현-방법>Retry Pattern 구현 방법<a hidden class=anchor aria-hidden=true href=#retry-pattern-구현-방법>#</a></h3><ol><li><strong>Spring Retry 사용</strong>: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다.</li><li><strong>Resilience4j 사용</strong>: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다.</li><li><strong>커스텀 구현</strong>: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다.</li></ol><h3 id=재시도-패턴-구현-시-고려사항>재시도 패턴 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#재시도-패턴-구현-시-고려사항>#</a></h3><p>재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:</p><ol><li><p>재시도 대상 오류 식별<br>모든 오류에 대해 재시도를 시도하는 것은 비효율적일 수 있다.<br>따라서 재시도가 효과적인 오류와 그렇지 않은 오류를 구분해야 한다.<br>예를 들어:</p><ul><li><strong>재시도에 적합한 오류</strong>: 네트워크 타임아웃, 일시적인 서비스 불가 등</li><li><strong>재시도에 부적합한 오류</strong>: 인증 실패, 잘못된 요청 등</li></ul></li><li><p>재시도 횟수 및 간격 설정<br>무한정 재시도를 시도하는 것은 시스템 자원을 낭비하고, 대상 서비스에 추가적인 부하를 줄 수 있다.<br>따라서:</p><ul><li><strong>최대 재시도 횟수</strong>를 설정하여 무한 재시도를 방지한다.</li><li><strong>재시도 간격</strong>을 설정하여 연속적인 재시도로 인한 부하를 완화한다.</li></ul></li><li><p>백오프(Backoff) 전략<br>재시도 간격을 점진적으로 늘리는 <strong>백오프 전략</strong>을 적용하면, 대상 서비스에 가해지는 부하를 줄이고 복구 시간을 확보할 수 있다.<br>일반적인 백오프 전략으로는 <strong>지수 백오프(Exponential Backoff)</strong> 가 있으며, 이는 재시도 간격을 지수 함수적으로 증가시키는 방식이다.</p></li><li><p>멱등성(Idempotency) 보장<br>재시도 시 동일한 요청이 여러 번 처리될 수 있으므로, 대상 서비스의 작업이 멱등성을 보장해야 한다.<br>즉, 동일한 요청이 여러 번 수행되더라도 시스템의 상태가 일관되게 유지되어야 한다.</p></li><li><p>재시도 스톰 방지<br>여러 서비스가 동시에 재시도를 수행하여 시스템에 과부하를 주는 상황을 피해야 한다.</p></li><li><p>타임아웃 설정<br>각 재시도에 적절한 타임아웃을 설정하여 전체 처리 시간을 제한해야 한다.</p></li><li><p>로깅과 모니터링<br>재시도 횟수와 결과를 로깅하고 모니터링하여 시스템의 동작을 파악해야 한다.</p></li></ol><h3 id=retry-pattern의-장단점>Retry Pattern의 장단점<a hidden class=anchor aria-hidden=true href=#retry-pattern의-장단점>#</a></h3><p>장점:</p><ul><li>일시적인 오류를 자동으로 복구할 수 있다.</li><li>시스템의 안정성과 가용성을 향상시킨다.</li></ul><p>단점:</p><ul><li>구현이 복잡해질 수 있다.</li><li>부적절한 사용 시 시스템 부하를 증가시킬 수 있다.</li></ul><h3 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span><span class=lnt id=hl-0-42><a class=lnlinks href=#hl-0-42>42</a>
</span><span class=lnt id=hl-0-43><a class=lnlinks href=#hl-0-43>43</a>
</span><span class=lnt id=hl-0-44><a class=lnlinks href=#hl-0-44>44</a>
</span><span class=lnt id=hl-0-45><a class=lnlinks href=#hl-0-45>45</a>
</span><span class=lnt id=hl-0-46><a class=lnlinks href=#hl-0-46>46</a>
</span><span class=lnt id=hl-0-47><a class=lnlinks href=#hl-0-47>47</a>
</span><span class=lnt id=hl-0-48><a class=lnlinks href=#hl-0-48>48</a>
</span><span class=lnt id=hl-0-49><a class=lnlinks href=#hl-0-49>49</a>
</span><span class=lnt id=hl-0-50><a class=lnlinks href=#hl-0-50>50</a>
</span><span class=lnt id=hl-0-51><a class=lnlinks href=#hl-0-51>51</a>
</span><span class=lnt id=hl-0-52><a class=lnlinks href=#hl-0-52>52</a>
</span><span class=lnt id=hl-0-53><a class=lnlinks href=#hl-0-53>53</a>
</span><span class=lnt id=hl-0-54><a class=lnlinks href=#hl-0-54>54</a>
</span><span class=lnt id=hl-0-55><a class=lnlinks href=#hl-0-55>55</a>
</span><span class=lnt id=hl-0-56><a class=lnlinks href=#hl-0-56>56</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 재시도 로직을 포함한 서비스 클라이언트 구현
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>ServiceClient</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>options</span> <span class=o>=</span> <span class=p>{})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>maxRetries</span> <span class=o>=</span> <span class=nx>options</span><span class=p>.</span><span class=nx>maxRetries</span> <span class=o>||</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>initialDelay</span> <span class=o>=</span> <span class=nx>options</span><span class=p>.</span><span class=nx>initialDelay</span> <span class=o>||</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>maxDelay</span> <span class=o>=</span> <span class=nx>options</span><span class=p>.</span><span class=nx>maxDelay</span> <span class=o>||</span> <span class=mi>5000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>backoffMultiplier</span> <span class=o>=</span> <span class=nx>options</span><span class=p>.</span><span class=nx>backoffMultiplier</span> <span class=o>||</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>async</span> <span class=nx>executeWithRetry</span><span class=p>(</span><span class=nx>operation</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nx>lastError</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nx>delay</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>initialDelay</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 재시도 횟수만큼 반복
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>attempt</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>attempt</span> <span class=o>&lt;=</span> <span class=k>this</span><span class=p>.</span><span class=nx>maxRetries</span><span class=p>;</span> <span class=nx>attempt</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// 작업 실행
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>operation</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1>// 성공 시 즉시 반환
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nx>lastError</span> <span class=o>=</span> <span class=nx>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// 재시도 가능한 오류인지 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>isRetryable</span><span class=p>(</span><span class=nx>error</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=nx>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// 마지막 시도였다면 오류 발생
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=nx>attempt</span> <span class=o>===</span> <span class=k>this</span><span class=p>.</span><span class=nx>maxRetries</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=sb>`작업 실패 after </span><span class=si>${</span><span class=k>this</span><span class=p>.</span><span class=nx>maxRetries</span><span class=si>}</span><span class=sb> attempts: </span><span class=si>${</span><span class=nx>error</span><span class=p>.</span><span class=nx>message</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// 대기 후 재시도
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kr>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>wait</span><span class=p>(</span><span class=nx>delay</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1>// 지연 시간을 지수적으로 증가
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nx>delay</span> <span class=o>=</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>min</span><span class=p>(</span><span class=nx>delay</span> <span class=o>*</span> <span class=k>this</span><span class=p>.</span><span class=nx>backoffMultiplier</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=nx>maxDelay</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 재시도 가능한 오류인지 판단
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>isRetryable</span><span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>error</span><span class=p>.</span><span class=nx>status</span> <span class=o>===</span> <span class=mi>429</span> <span class=o>||</span> <span class=c1>// Too Many Requests
</span></span></span><span class=line><span class=cl><span class=c1></span>               <span class=nx>error</span><span class=p>.</span><span class=nx>status</span> <span class=o>===</span> <span class=mi>503</span> <span class=o>||</span> <span class=c1>// Service Unavailable
</span></span></span><span class=line><span class=cl><span class=c1></span>               <span class=nx>error</span><span class=p>.</span><span class=nx>code</span> <span class=o>===</span> <span class=s1>&#39;ECONNRESET&#39;</span> <span class=o>||</span> <span class=c1>// 연결 재설정
</span></span></span><span class=line><span class=cl><span class=c1></span>               <span class=nx>error</span><span class=p>.</span><span class=nx>code</span> <span class=o>===</span> <span class=s1>&#39;ETIMEDOUT&#39;</span><span class=p>;</span> <span class=c1>// 타임아웃
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 지정된 시간만큼 대기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wait</span><span class=p>(</span><span class=nx>ms</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>ms</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/reliability/>Reliability</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/><span class=title>« Prev</span><br><span>Timeout Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/><span class=title>Next »</span><br><span>Strangler Application</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>