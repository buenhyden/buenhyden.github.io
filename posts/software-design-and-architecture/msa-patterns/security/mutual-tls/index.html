<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mutual TLS | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,Security"><meta name=description content="Mutual TLS
마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.

  https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점

일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다.
mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다.

mTLS의 작동 원리
mTLS는 다음과 같은 단계로 작동한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Mutual TLS"><meta property="og:description" content="Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.
https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-18T12:08:00+00:00"><meta property="article:modified_time" content="2024-11-18T12:08:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="Security"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Mutual TLS"><meta name=twitter:description content="Mutual TLS
마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.

  https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점

일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다.
mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다.

mTLS의 작동 원리
mTLS는 다음과 같은 단계로 작동한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"},{"@type":"ListItem","position":4,"name":"Security","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/"},{"@type":"ListItem","position":5,"name":"Mutual TLS","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mutual TLS","name":"Mutual TLS","description":"Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.\nmTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.\nMutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.\nhttps://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/\n일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.\n","keywords":["Software-Design-and-Architecture","MSA-Patterns","Security"],"articleBody":"Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.\nmTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.\nMutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.\nhttps://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/\n일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.\n클라이언트가 서버에 연결을 요청한다. 서버가 자신의 TLS 인증서를 클라이언트에게 제공한다. 클라이언트는 서버의 인증서를 확인한다. 클라이언트가 자신의 인증서를 서버에게 제공한다. 서버는 클라이언트의 인증서를 확인한다. 양쪽 모두 인증이 완료되면 안전한 통신 채널이 설정된다. mTLS의 인증서 검증 과정 디지털 서명 검증: 서버와 클라이언트는 받은 인증서의 디저털 서명을 검증한다. 인증서에서 발급자의 공개키 추출 인증서의 서명 알고리즘 확인 인증서 본문의 해시값 계산 디지털 서명 검증 인증서 체인 검증: 신뢰할 수 있는 루트 CA까지의 인증서 체인을 검증한다. 인증서 체인 구성: 상위 인증서를 찾고, 자체 서명된 인증서(루트 CA)에 도달하면 종료 체인의 각 인증서 검증: 상위 인증서로 현재 인증서 검증하고 인증서 제약 조건을 검증한다. 루트 CA가 신뢰할 수 있는 CA인지 확인 유효기간 및 목적 검증: 인증서의 유효기간과 사용 목적을 확인한다. 유효기간 검증 키 사용 목적 검증 실시간 폐기 상태 확인: CRL 또는 OCSP를 통해 인증서의 폐기 상태를 확인한다. OCSP를 통한 확인 CRL을 통한 확인 호스트명 검증: 서버 인증서의 경우 추가로 호스트명을 검증한다. Subject Alternative Names 확인 Common Name 확인 (레거시 지원) 이러한 검증 과정은 TLS 핸드셰이크 중에 자동으로 수행되며, 검증에 실패하면 연결이 즉시 종료된다. 각 단계는 보안을 위해 매우 중요하며, 하나라도 실패하면 전체 인증 과정이 실패하게 된다.\nmTLS의 장점 강화된 보안: 양방향 인증을 통해 중간자 공격(MitM)과 같은 보안 위협을 방지할 수 있다. 세분화된 접근 제어: 클라이언트의 신원을 확인할 수 있어 더 정교한 접근 제어가 가능하다. 데이터 무결성 보장: 암호화된 통신으로 데이터의 기밀성과 무결성을 보장한다. 신뢰할 수 있는 통신: 서버와 클라이언트 모두 신뢰할 수 있는 엔터티임을 확인할 수 있다. MSA에서의 mTLS 활용 마이크로서비스 아키텍처에서 mTLS는 다음과 같이 활용된다:\n서비스 간 통신 보안: 마이크로서비스 간의 모든 통신을 암호화하고 인증한다. 제로 트러스트 보안 모델: 네트워크 내부의 모든 통신에 대해 인증을 요구하여 보안을 강화한다. 서비스 메시와의 통합: Istio와 같은 서비스 메시 도구를 사용하여 mTLS를 쉽게 구현하고 관리할 수 있다. mTLS의 실제 적용 사례 Istio와 같은 서비스 메시는 mTLS를 통해 마이크로서비스 간의 안전한 통신을 지원한다.\nIstio에서는 프록시 간의 통신에 mTLS를 적용하여, TLS가 아닌 모든 통신을 차단함으로써 불법적인 접근을 방지한다.\n또한, NGINX와 같은 로드 밸런서를 활용하여 mTLS를 적용할 수 있다. 이를 통해 클라이언트와 서버 간의 상호 인증을 구현하고, 데이터의 기밀성과 무결성을 보장할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 server { listen 443 ssl; server_name example.com; ssl_certificate /path/to/server.crt; ssl_certificate_key /path/to/server.key; ssl_client_certificate /path/to/ca.crt; ssl_verify_client on; location / { proxy_pass http://backend; } } 이 설정에서 ssl_client_certificate와 ssl_verify_client 지시어를 통해 클라이언트 인증서 검증을 활성화한다.\n주의사항 인증서 관리: 많은 수의 클라이언트 인증서를 관리해야 할 수 있으므로 효율적인 인증서 관리 시스템이 필요하다. 성능 영향: 추가적인 인증 과정으로 인해 약간의 성능 저하가 있을 수 있다. 구현 복잡성: 일반 TLS에 비해 구현이 더 복잡할 수 있으므로 적절한 도구와 프레임워크의 사용이 중요하다. 참고 및 출처 ","wordCount":"514","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-18T12:08:00Z","dateModified":"2024-11-18T12:08:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/mutual-tls/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/>MSA Pattern</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/>Security</a></div><h1 class="post-title entry-hint-parent">Mutual TLS</h1><div class=post-meta><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;514 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/MSA%20Patterns/Security/mutual-tls.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#mutual-tls>Mutual TLS</a><ul><li><a href=#일반-tls와의-차이점>일반 TLS와의 차이점</a></li><li><a href=#mtls의-작동-원리>mTLS의 작동 원리</a></li><li><a href=#mtls의-장점>mTLS의 장점</a></li><li><a href=#msa에서의-mtls-활용>MSA에서의 mTLS 활용</a></li><li><a href=#mtls의-실제-적용-사례>mTLS의 실제 적용 사례</a></li><li><a href=#주의사항>주의사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=mutual-tls>Mutual TLS<a hidden class=anchor aria-hidden=true href=#mutual-tls>#</a></h2><p>마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.</p><p>mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.</p><p>Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.</p><p><figure><img alt=mTLS loading=lazy src=/img/how_mtls_works-what_is_mutual_tls.webp><figcaption>https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/</figcaption></figure></p><h3 id=일반-tls와의-차이점>일반 TLS와의 차이점<a hidden class=anchor aria-hidden=true href=#일반-tls와의-차이점>#</a></h3><ol><li>일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다.</li><li>mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다.</li></ol><h3 id=mtls의-작동-원리>mTLS의 작동 원리<a hidden class=anchor aria-hidden=true href=#mtls의-작동-원리>#</a></h3><p>mTLS는 다음과 같은 단계로 작동한다.</p><ol><li>클라이언트가 서버에 연결을 요청한다.</li><li>서버가 자신의 TLS 인증서를 클라이언트에게 제공한다.</li><li>클라이언트는 서버의 인증서를 확인한다.</li><li>클라이언트가 자신의 인증서를 서버에게 제공한다.</li><li>서버는 클라이언트의 인증서를 확인한다.</li><li>양쪽 모두 인증이 완료되면 안전한 통신 채널이 설정된다.</li></ol><h4 id=mtls의-인증서-검증-과정>mTLS의 인증서 검증 과정<a hidden class=anchor aria-hidden=true href=#mtls의-인증서-검증-과정>#</a></h4><ol><li>디지털 서명 검증: 서버와 클라이언트는 받은 인증서의 디저털 서명을 검증한다.<ol><li>인증서에서 발급자의 공개키 추출</li><li>인증서의 서명 알고리즘 확인</li><li>인증서 본문의 해시값 계산</li><li>디지털 서명 검증</li></ol></li><li>인증서 체인 검증: 신뢰할 수 있는 루트 CA까지의 인증서 체인을 검증한다.<ol><li>인증서 체인 구성: 상위 인증서를 찾고, 자체 서명된 인증서(루트 CA)에 도달하면 종료</li><li>체인의 각 인증서 검증: 상위 인증서로 현재 인증서 검증하고 인증서 제약 조건을 검증한다.</li><li>루트 CA가 신뢰할 수 있는 CA인지 확인</li></ol></li><li>유효기간 및 목적 검증: 인증서의 유효기간과 사용 목적을 확인한다.<ol><li>유효기간 검증</li><li>키 사용 목적 검증</li></ol></li><li>실시간 폐기 상태 확인: CRL 또는 OCSP를 통해 인증서의 폐기 상태를 확인한다.<ol><li>OCSP를 통한 확인</li><li>CRL을 통한 확인</li></ol></li><li>호스트명 검증: 서버 인증서의 경우 추가로 호스트명을 검증한다.<ol><li>Subject Alternative Names 확인</li><li>Common Name 확인 (레거시 지원)</li></ol></li></ol><p>이러한 검증 과정은 TLS 핸드셰이크 중에 자동으로 수행되며, 검증에 실패하면 연결이 즉시 종료된다. 각 단계는 보안을 위해 매우 중요하며, 하나라도 실패하면 전체 인증 과정이 실패하게 된다.</p><h3 id=mtls의-장점>mTLS의 장점<a hidden class=anchor aria-hidden=true href=#mtls의-장점>#</a></h3><ol><li><strong>강화된 보안</strong>: 양방향 인증을 통해 중간자 공격(MitM)과 같은 보안 위협을 방지할 수 있다.</li><li><strong>세분화된 접근 제어</strong>: 클라이언트의 신원을 확인할 수 있어 더 정교한 접근 제어가 가능하다.</li><li><strong>데이터 무결성 보장</strong>: 암호화된 통신으로 데이터의 기밀성과 무결성을 보장한다.</li><li><strong>신뢰할 수 있는 통신</strong>: 서버와 클라이언트 모두 신뢰할 수 있는 엔터티임을 확인할 수 있다.</li></ol><h3 id=msa에서의-mtls-활용>MSA에서의 mTLS 활용<a hidden class=anchor aria-hidden=true href=#msa에서의-mtls-활용>#</a></h3><p>마이크로서비스 아키텍처에서 mTLS는 다음과 같이 활용된다:</p><ol><li><strong>서비스 간 통신 보안</strong>: 마이크로서비스 간의 모든 통신을 암호화하고 인증한다.</li><li><strong>제로 트러스트 보안 모델</strong>: 네트워크 내부의 모든 통신에 대해 인증을 요구하여 보안을 강화한다.</li><li><strong>서비스 메시와의 통합</strong>: Istio와 같은 서비스 메시 도구를 사용하여 mTLS를 쉽게 구현하고 관리할 수 있다.</li></ol><h3 id=mtls의-실제-적용-사례>mTLS의 실제 적용 사례<a hidden class=anchor aria-hidden=true href=#mtls의-실제-적용-사례>#</a></h3><p><strong>Istio</strong>와 같은 서비스 메시는 mTLS를 통해 마이크로서비스 간의 안전한 통신을 지원한다.<br>Istio에서는 프록시 간의 통신에 mTLS를 적용하여, TLS가 아닌 모든 통신을 차단함으로써 불법적인 접근을 방지한다.</p><p>또한, <strong>NGINX</strong>와 같은 로드 밸런서를 활용하여 mTLS를 적용할 수 있다. 이를 통해 클라이언트와 서버 간의 상호 인증을 구현하고, 데이터의 기밀성과 무결성을 보장할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-nginx data-lang=nginx><span class=line><span class=cl><span class=k>server</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kn>listen</span> <span class=mi>443</span> <span class=s>ssl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kn>server_name</span> <span class=s>example.com</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kn>ssl_certificate</span> <span class=s>/path/to/server.crt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kn>ssl_certificate_key</span> <span class=s>/path/to/server.key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kn>ssl_client_certificate</span> <span class=s>/path/to/ca.crt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kn>ssl_verify_client</span> <span class=no>on</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kn>proxy_pass</span> <span class=s>http://backend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>이 설정에서 <code>ssl_client_certificate</code>와 <code>ssl_verify_client</code> 지시어를 통해 클라이언트 인증서 검증을 활성화한다.</p><h3 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h3><ol><li><strong>인증서 관리</strong>: 많은 수의 클라이언트 인증서를 관리해야 할 수 있으므로 효율적인 인증서 관리 시스템이 필요하다.</li><li><strong>성능 영향</strong>: 추가적인 인증 과정으로 인해 약간의 성능 저하가 있을 수 있다.</li><li><strong>구현 복잡성</strong>: 일반 TLS에 비해 구현이 더 복잡할 수 있으므로 적절한 도구와 프레임워크의 사용이 중요하다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/security/>Security</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/cors/><span class=title>« Prev</span><br><span>CORS</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/security/oauth2-oidc/><span class=title>Next »</span><br><span>OAuth2/OIDC (OpenID Connect)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>