<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event Sourcing | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,MSA-Patterns,Maintaining-Data-Consistency"><meta name=description content="Event Sourcing
Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.
Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.
Event Sourcing의 핵심 개념

이벤트 중심 저장: 시스템의 모든 상태 변경을 이벤트로 저장한다.
불변성: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.
시간 순서: 이벤트는 발생한 순서대로 저장된다.
상태 재구성: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.

Event Sourcing의 장점

완전한 감사 추적: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.
시간 여행 가능: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.
확장성: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.
유연성: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.

Event Sourcing의 구현 방법

이벤트 정의: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.
이벤트 저장소: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.
이벤트 핸들러: 각 이벤트 유형에 대한 처리 로직을 구현한다.
상태 재구성 로직: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.

Event Sourcing의 주의사항

성능 고려: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.
이벤트 버전 관리: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.
최종 일관성: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.

이벤트 소싱의 구현 시 고려사항


이벤트 저장소(Event Store): 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Event Sourcing"><meta property="og:description" content="Event Sourcing Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.
Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.
Event Sourcing의 핵심 개념 이벤트 중심 저장: 시스템의 모든 상태 변경을 이벤트로 저장한다. 불변성: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다. 시간 순서: 이벤트는 발생한 순서대로 저장된다. 상태 재구성: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다. Event Sourcing의 장점 완전한 감사 추적: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다. 시간 여행 가능: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다. 확장성: 이벤트 저장소는 추가만 하므로 확장이 용이합니다. 유연성: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다. Event Sourcing의 구현 방법 이벤트 정의: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다. 이벤트 저장소: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다. 이벤트 핸들러: 각 이벤트 유형에 대한 처리 로직을 구현한다. 상태 재구성 로직: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다. Event Sourcing의 주의사항 성능 고려: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다. 이벤트 버전 관리: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다. 최종 일관성: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다. 이벤트 소싱의 구현 시 고려사항 이벤트 저장소(Event Store): 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-15T01:54:00+00:00"><meta property="article:modified_time" content="2024-11-15T01:54:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="MSA-Patterns"><meta property="article:tag" content="Maintaining-Data-Consistency"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Event Sourcing"><meta name=twitter:description content="Event Sourcing
Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.
이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.
Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.
Event Sourcing의 핵심 개념

이벤트 중심 저장: 시스템의 모든 상태 변경을 이벤트로 저장한다.
불변성: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.
시간 순서: 이벤트는 발생한 순서대로 저장된다.
상태 재구성: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.

Event Sourcing의 장점

완전한 감사 추적: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.
시간 여행 가능: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.
확장성: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.
유연성: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.

Event Sourcing의 구현 방법

이벤트 정의: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.
이벤트 저장소: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.
이벤트 핸들러: 각 이벤트 유형에 대한 처리 로직을 구현한다.
상태 재구성 로직: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.

Event Sourcing의 주의사항

성능 고려: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.
이벤트 버전 관리: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.
최종 일관성: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.

이벤트 소싱의 구현 시 고려사항


이벤트 저장소(Event Store): 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"MSA Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/"},{"@type":"ListItem","position":4,"name":"Maintaining Data Consistency","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/"},{"@type":"ListItem","position":5,"name":"Event Sourcing","item":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event Sourcing","name":"Event Sourcing","description":"Event Sourcing Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.\n이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.\nEvent Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.\nEvent Sourcing의 핵심 개념 이벤트 중심 저장: 시스템의 모든 상태 변경을 이벤트로 저장한다. 불변성: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다. 시간 순서: 이벤트는 발생한 순서대로 저장된다. 상태 재구성: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다. Event Sourcing의 장점 완전한 감사 추적: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다. 시간 여행 가능: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다. 확장성: 이벤트 저장소는 추가만 하므로 확장이 용이합니다. 유연성: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다. Event Sourcing의 구현 방법 이벤트 정의: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다. 이벤트 저장소: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다. 이벤트 핸들러: 각 이벤트 유형에 대한 처리 로직을 구현한다. 상태 재구성 로직: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다. Event Sourcing의 주의사항 성능 고려: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다. 이벤트 버전 관리: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다. 최종 일관성: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다. 이벤트 소싱의 구현 시 고려사항 이벤트 저장소(Event Store): 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.\n","keywords":["Software-Design-and-Architecture","MSA-Patterns","Maintaining-Data-Consistency"],"articleBody":"Event Sourcing Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.\n이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.\nEvent Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.\nEvent Sourcing의 핵심 개념 이벤트 중심 저장: 시스템의 모든 상태 변경을 이벤트로 저장한다. 불변성: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다. 시간 순서: 이벤트는 발생한 순서대로 저장된다. 상태 재구성: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다. Event Sourcing의 장점 완전한 감사 추적: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다. 시간 여행 가능: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다. 확장성: 이벤트 저장소는 추가만 하므로 확장이 용이합니다. 유연성: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다. Event Sourcing의 구현 방법 이벤트 정의: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다. 이벤트 저장소: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다. 이벤트 핸들러: 각 이벤트 유형에 대한 처리 로직을 구현한다. 상태 재구성 로직: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다. Event Sourcing의 주의사항 성능 고려: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다. 이벤트 버전 관리: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다. 최종 일관성: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다. 이벤트 소싱의 구현 시 고려사항 이벤트 저장소(Event Store): 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.\n이벤트 발행 및 구독 메커니즘: 이벤트를 발행하고, 이를 구독하는 서비스 간의 통신 메커니즘을 설계해야 한다. 이는 메시지 브로커나 이벤트 스트리밍 플랫폼을 활용할 수 있다.\n트랜잭션 관리: 이벤트 저장과 관련된 트랜잭션을 원자적으로 처리하여, 데이터 일관성을 보장해야 한다.\nEvent Sourcing과 CQRS Event Sourcing은 종종 CQRS(Command Query Responsibility Segregation) 패턴과 함께 사용된다. CQRS는 데이터의 쓰기(Command)와 읽기(Query) 모델을 분리하는 패턴으로, Event Sourcing과 결합하면 더욱 강력한 아키텍처를 구성할 수 있다.\n구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // 이벤트 기본 클래스 class Event { constructor(data) { this.eventId = crypto.randomUUID(); this.timestamp = new Date(); this.data = data; this.version = 1; } } // 주문 관련 이벤트들 class OrderCreatedEvent extends Event { constructor(orderId, customerId, items) { super({ orderId, customerId, items, status: 'CREATED' }); this.type = 'ORDER_CREATED'; } } // 이벤트 저장소 class EventStore { constructor() { this.events = []; this.eventHandlers = new Map(); this.snapshots = new Map(); } async saveEvent(event) { // 이벤트 유효성 검증 this.validateEvent(event); // 이벤트 저장 this.events.push(event); // 이벤트 처리 await this.processEvent(event); // 스냅샷 필요 여부 확인 await this.checkForSnapshot(event.data.orderId); return event; } async getEvents(aggregateId) { return this.events.filter( event =\u003e event.data.orderId === aggregateId ); } } 참고 및 출처 ","wordCount":"494","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-15T01:54:00Z","dateModified":"2024-11-15T01:54:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/event-sourcing/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/>MSA Pattern</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/>Maintaining Data Consistency</a></div><h1 class="post-title entry-hint-parent">Event Sourcing</h1><div class=post-meta><span title='2024-11-15 01:54:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;494 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/MSA%20Patterns/Maintaining%20Data%20Consistency/Event-Sourcing.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#event-sourcing>Event Sourcing</a><ul><li><a href=#event-sourcing의-핵심-개념>Event Sourcing의 핵심 개념</a></li><li><a href=#event-sourcing의-장점>Event Sourcing의 장점</a></li><li><a href=#event-sourcing의-구현-방법>Event Sourcing의 구현 방법</a></li><li><a href=#event-sourcing의-주의사항>Event Sourcing의 주의사항</a></li><li><a href=#이벤트-소싱의-구현-시-고려사항>이벤트 소싱의 구현 시 고려사항</a></li><li><a href=#event-sourcing과-cqrs>Event Sourcing과 CQRS</a></li><li><a href=#구현-예시>구현 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=event-sourcing>Event Sourcing<a hidden class=anchor aria-hidden=true href=#event-sourcing>#</a></h2><p>Event Sourcing은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하는 중요한 패턴 중 하나이다.<br>이 패턴은 시스템의 상태 변화를 일련의 이벤트로 저장하고 관리하는 방식을 말한다. 합니다.</p><p>Event Sourcing은 복잡한 도메인 모델을 가진 시스템이나 높은 감사 요구사항이 있는 금융, 의료 등의 분야에서 특히 유용하다. 하지만 구현의 복잡성과 초기 학습 곡선이 높다는 점을 고려해야 한다.</p><h3 id=event-sourcing의-핵심-개념>Event Sourcing의 핵심 개념<a hidden class=anchor aria-hidden=true href=#event-sourcing의-핵심-개념>#</a></h3><ol><li><strong>이벤트 중심 저장</strong>: 시스템의 모든 상태 변경을 이벤트로 저장한다.</li><li><strong>불변성</strong>: 저장된 이벤트는 수정되거나 삭제되지 않고 항상 추가만 된다.</li><li><strong>시간 순서</strong>: 이벤트는 발생한 순서대로 저장된다.</li><li><strong>상태 재구성</strong>: 현재 상태는 저장된 이벤트를 순차적으로 적용하여 재구성한다.</li></ol><h3 id=event-sourcing의-장점>Event Sourcing의 장점<a hidden class=anchor aria-hidden=true href=#event-sourcing의-장점>#</a></h3><ol><li><strong>완전한 감사 추적</strong>: 모든 변경 사항이 이벤트로 저장되어 시스템의 전체 히스토리를 추적할 수 있다.</li><li><strong>시간 여행 가능</strong>: 특정 시점의 상태를 재구성할 수 있어 디버깅과 분석에 유용하다.</li><li><strong>확장성</strong>: 이벤트 저장소는 추가만 하므로 확장이 용이합니다.</li><li><strong>유연성</strong>: 새로운 요구사항에 따라 이벤트를 재해석하여 새로운 뷰를 만들 수 있다.</li></ol><h3 id=event-sourcing의-구현-방법>Event Sourcing의 구현 방법<a hidden class=anchor aria-hidden=true href=#event-sourcing의-구현-방법>#</a></h3><ol><li><strong>이벤트 정의</strong>: 시스템에서 발생할 수 있는 모든 이벤트 유형을 정의한다.</li><li><strong>이벤트 저장소</strong>: 이벤트를 영구적으로 저장할 수 있는 저장소를 구현한다.</li><li><strong>이벤트 핸들러</strong>: 각 이벤트 유형에 대한 처리 로직을 구현한다.</li><li><strong>상태 재구성 로직</strong>: 저장된 이벤트를 기반으로 현재 상태를 재구성하는 로직을 구현한다.</li></ol><h3 id=event-sourcing의-주의사항>Event Sourcing의 주의사항<a hidden class=anchor aria-hidden=true href=#event-sourcing의-주의사항>#</a></h3><ol><li><strong>성능 고려</strong>: 이벤트가 많아질수록 상태 재구성에 시간이 걸릴 수 있다. 이를 위해 스냅샷을 주기적으로 저장하는 방법을 고려해야 한다.</li><li><strong>이벤트 버전 관리</strong>: 시스템이 발전함에 따라 이벤트 스키마가 변경될 수 있으므로, 버전 관리가 필요하다.</li><li><strong>최종 일관성</strong>: Event Sourcing은 일반적으로 최종 일관성 모델을 따르므로, 즉시 일관성이 필요한 경우 추가적인 메커니즘이 필요할 수 있다.</li></ol><h3 id=이벤트-소싱의-구현-시-고려사항>이벤트 소싱의 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#이벤트-소싱의-구현-시-고려사항>#</a></h3><ol><li><p><strong>이벤트 저장소(Event Store)</strong>: 이벤트를 영구적으로 저장하고, 효율적으로 조회할 수 있는 저장소를 구축해야 한다. 이는 관계형 데이터베이스, NoSQL 데이터베이스, 또는 전문 이벤트 저장소를 사용할 수 있다.</p></li><li><p><strong>이벤트 발행 및 구독 메커니즘</strong>: 이벤트를 발행하고, 이를 구독하는 서비스 간의 통신 메커니즘을 설계해야 한다. 이는 메시지 브로커나 이벤트 스트리밍 플랫폼을 활용할 수 있다.</p></li><li><p><strong>트랜잭션 관리</strong>: 이벤트 저장과 관련된 트랜잭션을 원자적으로 처리하여, 데이터 일관성을 보장해야 한다.</p></li></ol><h3 id=event-sourcing과-cqrs>Event Sourcing과 CQRS<a hidden class=anchor aria-hidden=true href=#event-sourcing과-cqrs>#</a></h3><p>Event Sourcing은 종종 CQRS(Command Query Responsibility Segregation) 패턴과 함께 사용된다. CQRS는 데이터의 쓰기(Command)와 읽기(Query) 모델을 분리하는 패턴으로, Event Sourcing과 결합하면 더욱 강력한 아키텍처를 구성할 수 있다.</p><h3 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span><span class=lnt id=hl-0-42><a class=lnlinks href=#hl-0-42>42</a>
</span><span class=lnt id=hl-0-43><a class=lnlinks href=#hl-0-43>43</a>
</span><span class=lnt id=hl-0-44><a class=lnlinks href=#hl-0-44>44</a>
</span><span class=lnt id=hl-0-45><a class=lnlinks href=#hl-0-45>45</a>
</span><span class=lnt id=hl-0-46><a class=lnlinks href=#hl-0-46>46</a>
</span><span class=lnt id=hl-0-47><a class=lnlinks href=#hl-0-47>47</a>
</span><span class=lnt id=hl-0-48><a class=lnlinks href=#hl-0-48>48</a>
</span><span class=lnt id=hl-0-49><a class=lnlinks href=#hl-0-49>49</a>
</span><span class=lnt id=hl-0-50><a class=lnlinks href=#hl-0-50>50</a>
</span><span class=lnt id=hl-0-51><a class=lnlinks href=#hl-0-51>51</a>
</span><span class=lnt id=hl-0-52><a class=lnlinks href=#hl-0-52>52</a>
</span><span class=lnt id=hl-0-53><a class=lnlinks href=#hl-0-53>53</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 이벤트 기본 클래스
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>Event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>eventId</span> <span class=o>=</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>randomUUID</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>timestamp</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Date</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>data</span> <span class=o>=</span> <span class=nx>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>version</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 주문 관련 이벤트들
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderCreatedEvent</span> <span class=kr>extends</span> <span class=nx>Event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>orderId</span><span class=p>,</span> <span class=nx>customerId</span><span class=p>,</span> <span class=nx>items</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>super</span><span class=p>({</span>
</span></span><span class=line><span class=cl>            <span class=nx>orderId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>customerId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>items</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=nx>status</span><span class=o>:</span> <span class=s1>&#39;CREATED&#39;</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>type</span> <span class=o>=</span> <span class=s1>&#39;ORDER_CREATED&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 이벤트 저장소
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>EventStore</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>events</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>eventHandlers</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>snapshots</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Map</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>async</span> <span class=nx>saveEvent</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 이벤트 유효성 검증
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>validateEvent</span><span class=p>(</span><span class=nx>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 이벤트 저장
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>events</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 이벤트 처리
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>processEvent</span><span class=p>(</span><span class=nx>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 스냅샷 필요 여부 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>await</span> <span class=k>this</span><span class=p>.</span><span class=nx>checkForSnapshot</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>.</span><span class=nx>orderId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>async</span> <span class=nx>getEvents</span><span class=p>(</span><span class=nx>aggregateId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>events</span><span class=p>.</span><span class=nx>filter</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=nx>event</span> <span class=p>=&gt;</span> <span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>.</span><span class=nx>orderId</span> <span class=o>===</span> <span class=nx>aggregateId</span>
</span></span><span class=line><span class=cl>        <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/msa-patterns/>MSA-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/maintaining-data-consistency/>Maintaining-Data-Consistency</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/maintaining-data-consistency/aggregate/><span class=title>« Prev</span><br><span>Aggregate Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/discovery/3rd-party-registration/><span class=title>Next »</span><br><span>3rd party registration</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>