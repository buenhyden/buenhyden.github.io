<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>KISS Principle | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Design-Principles,KISS-Principle"><meta name=description content="시스템이나 코드의 복잡성을 최소화하라."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/kiss-principle/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/kiss-principle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/kiss-principle/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="KISS Principle"><meta property="og:description" content="시스템이나 코드의 복잡성을 최소화하라."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-23T01:00:00+00:00"><meta property="article:modified_time" content="2024-09-23T01:00:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="Design-Principles"><meta property="article:tag" content="KISS-Principle"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="KISS Principle"><meta name=twitter:description content="시스템이나 코드의 복잡성을 최소화하라."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/"},{"@type":"ListItem","position":4,"name":"KISS Principle","item":"https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/kiss-principle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"KISS Principle","name":"KISS Principle","description":"시스템이나 코드의 복잡성을 최소화하라.","keywords":["Software-Design-and-Architecture","Design-Principles","KISS-Principle"],"articleBody":"KISS (Keep It Simple, Stupid) 원칙 KISS 원칙은 “Keep It Simple, Stupid\"의 약자로, 때로는 “Keep It Short and Simple” 또는 “Keep It Simple and Straightforward\"로도 해석된다. 이 원칙은 시스템 설계에서 단순함을 추구해야 한다는 기본 철학을 담고 있다.\nKISS 원칙은 1960년대 미 해군의 항공기 엔지니어인 켈리 존슨(Kelly Johnson)이 처음 제안했다고 알려져 있다. 그는 항공기 설계와 관련하여 “어떤 항공기든 평균적인 기술자가 기본적인 도구만으로 현장에서 수리할 수 있을 만큼 단순해야 한다\"고 주장했다. 이 철학은 소프트웨어 개발을 포함한 다양한 엔지니어링 분야로 확장되었다.\nKISS 원칙은 소프트웨어 개발에서 가장 중요한 원칙 중 하나이다. 단순성을 추구함으로써 개발자는 더 유지보수하기 쉽고, 더 안정적이며, 더 이해하기 쉬운 시스템을 만들 수 있다.\nKISS 원칙을 적용할 때는 다음을 기억해야 한다:\n단순함은 목표이지만, 필요한 기능성을 희생해서는 안 된다. 지속적인 리팩토링과 코드 개선이 단순성을 유지하는 열쇠이다. 단순함과 확장성 사이의 적절한 균형을 찾는 것이 중요하다. 단순함은 주관적일 수 있으므로, 팀 내에서 공통된 이해를 형성하는 것이 중요하다. KISS 원칙의 핵심 아이디어 KISS 원칙의 핵심은 다음과 같다:\n복잡성은 이해하기 어렵고, 유지보수하기 어렵고, 오류가 발생하기 쉽다 가능한 한 간단한 해결책이 최선의 해결책이다. 불필요한 복잡성은 피해야 한다. 시스템은 필요 이상으로 정교해서는 안 된다. KISS 원칙은 “단순한 것이 아름답다\"는 개념과 밀접하게 연관되어 있으며, 비슷한 원칙으로는 오컴의 면도날(“필요 이상으로 가설을 늘리지 말라”)과 앨버트 아인슈타인의 명언 “가능한 한 단순하게 만들되, 그 이상은 단순화하지 말라\"가 있다.\n소프트웨어 개발에서의 KISS 원칙 소프트웨어 개발에서 KISS 원칙은 다음과 같은 방식으로 적용된다:\n코드 단순화 1 2 3 4 5 6 7 8 9 10 # 복잡한 버전 (KISS 원칙 위반) def is_even(num): if num % 2 == 0: return True else: return False # 단순한 버전 (KISS 원칙 준수) def is_even(num): return num % 2 == 0 복잡한 버전은 불필요한 조건문과 반환 구문을 사용하고 있으며, 단순한 버전은 직접적으로 결과를 반환한다.\n설계 패턴의 적절한 사용 설계 패턴은 공통적인 문제에 대한 검증된 해결책을 제공하지만, 모든 상황에서 반드시 필요한 것은 아니다. KISS 원칙은 실제로 필요할 때만 디자인 패턴을 사용할 것을 권장한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 복잡한 버전 - 단순한 기능에 팩토리 패턴 사용 (과도한 패턴 적용) interface Logger { void log(String message); } class ConsoleLogger implements Logger { public void log(String message) { System.out.println(message); } } class LoggerFactory { public static Logger createLogger() { return new ConsoleLogger(); } } // 클라이언트 코드 Logger logger = LoggerFactory.createLogger(); logger.log(\"메시지\"); // 단순한 버전 - 직접적인 접근 System.out.println(\"메시지\"); 단순한 로깅 기능에 팩토리 패턴과 인터페이스를 사용하는 것은 미래의 확장성을 제공할 수 있지만, 현재 요구사항이 단순하다면 과도한 복잡성을 초래할 수 있다.\n간결한 API 설계 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 복잡한 API (KISS 위반) function createUser(firstName, lastName, age, email, phone, address, city, country, zipCode, isActive) { // 사용자 생성 로직 } // 단순한 API (KISS 준수) function createUser(userDetails) { // 사용자 생성 로직 } // 사용 예시 createUser({ firstName: \"홍\", lastName: \"길동\", email: \"hong@example.com\", // 필요한 속성만 포함 }); 복잡한 API는 많은 매개변수를 가지고 있어 사용하기 어렵고 실수하기 쉽다. 단순한 API는 객체를 사용하여 필요한 속성만 전달할 수 있게 한다.\nKISS 원칙의 적용 방법 문제를 명확하게 이해하기\n복잡한 솔루션을 만들기 전에 문제를 완전히 이해해야 한다.\n문제를 철저히 분석하면 종종 더 단순한 해결책을 발견할 수 있다.\n점진적인 개발 및 리팩토링\n작은 단계로 시작하여 필요에 따라 기능을 추가한다. 정기적으로 코드를 리팩토링하여 복잡성을 제거한다. 기능이 더 이상 필요하지 않으면 제거한다. 복잡성의 원인 식별\n복잡성은 여러 형태로 나타날 수 있다:\n불필요한 기능 과도한 추상화 복잡한 알고리즘 이해하기 어려운 코드 구조 너무 많은 의존성\n이러한 복잡성의 원인을 식별하고 제거하는 것이 중요하다. “유스 케이스 중심” 설계\n현재 필요한 기능에 집중하고, 미래에 필요할 수 있는 가상의 기능을 위해 복잡한 구조를 미리 만들지 않는다. 이를 “YAGNI”(You Aren’t Gonna Need It) 원칙이라고도 한다.\nKISS 원칙의 장점 향상된 코드 품질\n단순한 코드는 버그가 적고, 이해하기 쉬우며, 디버깅하기 쉽다. 복잡한 코드는 버그를 숨기는 경향이 있다.\n유지보수성 향상\n단순한 코드는 유지보수하기 쉽다. 개발자가 코드를 빠르게 이해하고 필요한 변경을 수행할 수 있다.\n개발 속도 향상\n단순한 솔루션은 구현하는 데 시간이 덜 걸리고, 테스트하기 쉬우며, 배포하기 쉽다.\n온보딩 시간 단축\n새로운 팀원은 단순한 코드베이스를 더 빠르게 이해할 수 있으므로, 생산성을 더 빨리 발휘할 수 있다.\n유연성 향상\n역설적으로, 단순한 코드는 종종 더 유연하다. 복잡한 구조에 얽매이지 않기 때문에 요구사항이 변경될 때 적응하기 쉽다.\nKISS 원칙의 실제 적용 사례 유닉스 철학\n유닉스 운영체제의 설계 철학은 KISS 원칙의 좋은 예:\n각 프로그램은 한 가지 일을 잘 수행해야 한다. 프로그램은 함께 작동해야 한다. 텍스트 스트림은 보편적인 인터페이스이다.\n이 철학은 단순하면서도 강력한 도구와 유틸리티를 만드는 데 기여했다. 구글의 홈페이지\n구글의 홈페이지는 KISS 원칙의 대표적인 예.\n복잡한 UI 요소 대신 검색창에 집중하여 사용자 경험을 단순화함.\n애자일 개발\n애자일 개발 방법론은 KISS 원칙을 반영한다:\n작은 반복으로 개발하여 복잡성을 관리한다. 지속적인 리팩토링을 통해 코드를 단순하게 유지한다. 현재 필요한 기능에 집중한다. KISS 원칙의 도전과제 단순함과 기능성 간의 균형\n단순성을 추구하는 것은 중요하지만, 필요한 기능을 희생해서는 안 된다. 단순함과 기능성 사이의 적절한 균형을 찾는 것이 중요하다.\n단순함은 주관적일 수 있음\n“단순함\"은 경험, 배경, 지식 수준에 따라 다르게 해석될 수 있다. 한 개발자에게 단순한 것이 다른 개발자에게는 복잡할 수 있다.\n“과도한 단순화” 피하기\n때로는 복잡성이 필요하다. 특히 복잡한 비즈니스 로직이나 성능 최적화를 다룰 때는 더욱 그렇다. 과도한 단순화는 중요한 세부 사항을 무시할 수 있다.\n미래의 요구사항 예측\n현재의 단순한 솔루션이 미래의 요구사항을 수용하기 어려울 수 있다. 확장성과 단순성 사이의 균형을 맞추는 것이 중요하다.\n현대 소프트웨어 개발에서의 KISS 적용 마이크로서비스 아키텍처 마이크로서비스 아키텍처는 KISS 원칙을 대규모 시스템에 적용하는 방법이다.\n각 서비스는 하나의 비즈니스 기능에 집중하여 단순성을 유지한다.\n// 모놀리식 접근 방식 (복잡함) 한 애플리케이션에서 사용자 관리, 결제 처리, 재고 관리, 배송 처리 등 모든 기능 처리 // 마이크로서비스 접근 방식 (각 서비스는 단순함) - 사용자 서비스: 사용자 관리만 담당 - 결제 서비스: 결제 처리만 담당 - 재고 서비스: 재고 관리만 담당 - 배송 서비스: 배송 처리만 담당 함수형 프로그래밍 함수형 프로그래밍은 순수 함수와 불변성을 강조하여 코드의 복잡성을 줄인다.\n1 2 3 4 5 6 7 8 // 명령형 접근 방식 (상태 변경으로 복잡함) let total = 0; for (let i = 0; i \u003c numbers.length; i++) { total += numbers[i]; } // 함수형 접근 방식 (단순함) const total = numbers.reduce((sum, num) =\u003e sum + num, 0); 지속적인 리팩토링 지속적인 리팩토링은 코드가 시간이 지남에 따라 복잡해지는 것을 방지한다.\n기술 부채를 관리하고 코드 품질을 유지하는 중요한 방법이다.\n용어 정리 용어 설명 참고 및 출처 ","wordCount":"1013","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-23T01:00:00Z","dateModified":"2024-09-23T01:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/kiss-principle/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/>Design Principles</a></div><h1 class="post-title entry-hint-parent">KISS Principle</h1><div class=post-description>시스템이나 코드의 복잡성을 최소화하라.</div><div class=post-meta><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/Design%20Principles/KISS-Principle.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#kiss-keep-it-simple-stupid-원칙>KISS (Keep It Simple, Stupid) 원칙</a><ul><li><a href=#kiss-원칙의-핵심-아이디어>KISS 원칙의 핵심 아이디어</a></li><li><a href=#소프트웨어-개발에서의-kiss-원칙>소프트웨어 개발에서의 KISS 원칙</a></li><li><a href=#kiss-원칙의-적용-방법>KISS 원칙의 적용 방법</a></li><li><a href=#kiss-원칙의-장점>KISS 원칙의 장점</a></li><li><a href=#kiss-원칙의-실제-적용-사례>KISS 원칙의 실제 적용 사례</a></li><li><a href=#kiss-원칙의-도전과제>KISS 원칙의 도전과제</a></li><li><a href=#현대-소프트웨어-개발에서의-kiss-적용>현대 소프트웨어 개발에서의 KISS 적용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=kiss-keep-it-simple-stupid-원칙>KISS (Keep It Simple, Stupid) 원칙<a hidden class=anchor aria-hidden=true href=#kiss-keep-it-simple-stupid-원칙>#</a></h2><p>KISS 원칙은 &ldquo;Keep It Simple, Stupid"의 약자로, 때로는 &ldquo;Keep It Short and Simple&rdquo; 또는 &ldquo;Keep It Simple and Straightforward"로도 해석된다. 이 원칙은 시스템 설계에서 단순함을 추구해야 한다는 기본 철학을 담고 있다.</p><p>KISS 원칙은 1960년대 미 해군의 항공기 엔지니어인 켈리 존슨(Kelly Johnson)이 처음 제안했다고 알려져 있다. 그는 항공기 설계와 관련하여 &ldquo;어떤 항공기든 평균적인 기술자가 기본적인 도구만으로 현장에서 수리할 수 있을 만큼 단순해야 한다"고 주장했다. 이 철학은 소프트웨어 개발을 포함한 다양한 엔지니어링 분야로 확장되었다.</p><p>KISS 원칙은 소프트웨어 개발에서 가장 중요한 원칙 중 하나이다. 단순성을 추구함으로써 개발자는 더 유지보수하기 쉽고, 더 안정적이며, 더 이해하기 쉬운 시스템을 만들 수 있다.</p><p>KISS 원칙을 적용할 때는 다음을 기억해야 한다:</p><ul><li>단순함은 목표이지만, 필요한 기능성을 희생해서는 안 된다.</li><li>지속적인 리팩토링과 코드 개선이 단순성을 유지하는 열쇠이다.</li><li>단순함과 확장성 사이의 적절한 균형을 찾는 것이 중요하다.</li><li>단순함은 주관적일 수 있으므로, 팀 내에서 공통된 이해를 형성하는 것이 중요하다.</li></ul><h3 id=kiss-원칙의-핵심-아이디어>KISS 원칙의 핵심 아이디어<a hidden class=anchor aria-hidden=true href=#kiss-원칙의-핵심-아이디어>#</a></h3><p>KISS 원칙의 핵심은 다음과 같다:</p><ul><li>복잡성은 이해하기 어렵고, 유지보수하기 어렵고, 오류가 발생하기 쉽다</li><li>가능한 한 간단한 해결책이 최선의 해결책이다.</li><li>불필요한 복잡성은 피해야 한다.</li><li>시스템은 필요 이상으로 정교해서는 안 된다.</li></ul><p>KISS 원칙은 &ldquo;단순한 것이 아름답다"는 개념과 밀접하게 연관되어 있으며, 비슷한 원칙으로는 오컴의 면도날(&ldquo;필요 이상으로 가설을 늘리지 말라&rdquo;)과 앨버트 아인슈타인의 명언 &ldquo;가능한 한 단순하게 만들되, 그 이상은 단순화하지 말라"가 있다.</p><h3 id=소프트웨어-개발에서의-kiss-원칙>소프트웨어 개발에서의 KISS 원칙<a hidden class=anchor aria-hidden=true href=#소프트웨어-개발에서의-kiss-원칙>#</a></h3><p>소프트웨어 개발에서 KISS 원칙은 다음과 같은 방식으로 적용된다:</p><h4 id=코드-단순화>코드 단순화<a hidden class=anchor aria-hidden=true href=#코드-단순화>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 복잡한 버전 (KISS 원칙 위반)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_even</span><span class=p>(</span><span class=n>num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>num</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 단순한 버전 (KISS 원칙 준수)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_even</span><span class=p>(</span><span class=n>num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>num</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>복잡한 버전은 불필요한 조건문과 반환 구문을 사용하고 있으며, 단순한 버전은 직접적으로 결과를 반환한다.</p><h4 id=설계-패턴의-적절한-사용>설계 패턴의 적절한 사용<a hidden class=anchor aria-hidden=true href=#설계-패턴의-적절한-사용>#</a></h4><p>설계 패턴은 공통적인 문제에 대한 검증된 해결책을 제공하지만, 모든 상황에서 반드시 필요한 것은 아니다. KISS 원칙은 실제로 필요할 때만 디자인 패턴을 사용할 것을 권장한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 복잡한 버전 - 단순한 기능에 팩토리 패턴 사용 (과도한 패턴 적용)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>interface</span> <span class=nc>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>ConsoleLogger</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>LoggerFactory</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Logger</span><span class=w> </span><span class=nf>createLogger</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ConsoleLogger</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 클라이언트 코드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Logger</span><span class=w> </span><span class=n>logger</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LoggerFactory</span><span class=p>.</span><span class=na>createLogger</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>logger</span><span class=p>.</span><span class=na>log</span><span class=p>(</span><span class=s>&#34;메시지&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 단순한 버전 - 직접적인 접근</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;메시지&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>단순한 로깅 기능에 팩토리 패턴과 인터페이스를 사용하는 것은 미래의 확장성을 제공할 수 있지만, 현재 요구사항이 단순하다면 과도한 복잡성을 초래할 수 있다.</p><h4 id=간결한-api-설계>간결한 API 설계<a hidden class=anchor aria-hidden=true href=#간결한-api-설계>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 복잡한 API (KISS 위반)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>createUser</span><span class=p>(</span><span class=nx>firstName</span><span class=p>,</span> <span class=nx>lastName</span><span class=p>,</span> <span class=nx>age</span><span class=p>,</span> <span class=nx>email</span><span class=p>,</span> <span class=nx>phone</span><span class=p>,</span> <span class=nx>address</span><span class=p>,</span> <span class=nx>city</span><span class=p>,</span> <span class=nx>country</span><span class=p>,</span> <span class=nx>zipCode</span><span class=p>,</span> <span class=nx>isActive</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 사용자 생성 로직
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 단순한 API (KISS 준수)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>createUser</span><span class=p>(</span><span class=nx>userDetails</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 사용자 생성 로직
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 사용 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>createUser</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>firstName</span><span class=o>:</span> <span class=s2>&#34;홍&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>lastName</span><span class=o>:</span> <span class=s2>&#34;길동&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>email</span><span class=o>:</span> <span class=s2>&#34;hong@example.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 필요한 속성만 포함
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><p>복잡한 API는 많은 매개변수를 가지고 있어 사용하기 어렵고 실수하기 쉽다. 단순한 API는 객체를 사용하여 필요한 속성만 전달할 수 있게 한다.</p><h3 id=kiss-원칙의-적용-방법>KISS 원칙의 적용 방법<a hidden class=anchor aria-hidden=true href=#kiss-원칙의-적용-방법>#</a></h3><ol><li><p>문제를 명확하게 이해하기<br>복잡한 솔루션을 만들기 전에 문제를 완전히 이해해야 한다.<br>문제를 철저히 분석하면 종종 더 단순한 해결책을 발견할 수 있다.</p></li><li><p>점진적인 개발 및 리팩토링</p><ul><li>작은 단계로 시작하여 필요에 따라 기능을 추가한다.</li><li>정기적으로 코드를 리팩토링하여 복잡성을 제거한다.</li><li>기능이 더 이상 필요하지 않으면 제거한다.</li></ul></li><li><p>복잡성의 원인 식별<br>복잡성은 여러 형태로 나타날 수 있다:</p><ul><li>불필요한 기능</li><li>과도한 추상화</li><li>복잡한 알고리즘</li><li>이해하기 어려운 코드 구조</li><li>너무 많은 의존성<br>이러한 복잡성의 원인을 식별하고 제거하는 것이 중요하다.</li></ul></li><li><p>&ldquo;유스 케이스 중심&rdquo; 설계<br>현재 필요한 기능에 집중하고, 미래에 필요할 수 있는 가상의 기능을 위해 복잡한 구조를 미리 만들지 않는다. 이를 &ldquo;YAGNI&rdquo;(You Aren&rsquo;t Gonna Need It) 원칙이라고도 한다.</p></li></ol><h3 id=kiss-원칙의-장점>KISS 원칙의 장점<a hidden class=anchor aria-hidden=true href=#kiss-원칙의-장점>#</a></h3><ol><li><p>향상된 코드 품질<br>단순한 코드는 버그가 적고, 이해하기 쉬우며, 디버깅하기 쉽다. 복잡한 코드는 버그를 숨기는 경향이 있다.</p></li><li><p>유지보수성 향상<br>단순한 코드는 유지보수하기 쉽다. 개발자가 코드를 빠르게 이해하고 필요한 변경을 수행할 수 있다.</p></li><li><p>개발 속도 향상<br>단순한 솔루션은 구현하는 데 시간이 덜 걸리고, 테스트하기 쉬우며, 배포하기 쉽다.</p></li><li><p>온보딩 시간 단축<br>새로운 팀원은 단순한 코드베이스를 더 빠르게 이해할 수 있으므로, 생산성을 더 빨리 발휘할 수 있다.</p></li><li><p>유연성 향상<br>역설적으로, 단순한 코드는 종종 더 유연하다. 복잡한 구조에 얽매이지 않기 때문에 요구사항이 변경될 때 적응하기 쉽다.</p></li></ol><h3 id=kiss-원칙의-실제-적용-사례>KISS 원칙의 실제 적용 사례<a hidden class=anchor aria-hidden=true href=#kiss-원칙의-실제-적용-사례>#</a></h3><ol><li><p>유닉스 철학<br>유닉스 운영체제의 설계 철학은 KISS 원칙의 좋은 예:</p><ul><li>각 프로그램은 한 가지 일을 잘 수행해야 한다.</li><li>프로그램은 함께 작동해야 한다.</li><li>텍스트 스트림은 보편적인 인터페이스이다.<br>이 철학은 단순하면서도 강력한 도구와 유틸리티를 만드는 데 기여했다.</li></ul></li><li><p>구글의 홈페이지<br>구글의 홈페이지는 KISS 원칙의 대표적인 예.<br>복잡한 UI 요소 대신 검색창에 집중하여 사용자 경험을 단순화함.</p></li><li><p>애자일 개발<br>애자일 개발 방법론은 KISS 원칙을 반영한다:</p><ul><li>작은 반복으로 개발하여 복잡성을 관리한다.</li><li>지속적인 리팩토링을 통해 코드를 단순하게 유지한다.</li><li>현재 필요한 기능에 집중한다.</li></ul></li></ol><h3 id=kiss-원칙의-도전과제>KISS 원칙의 도전과제<a hidden class=anchor aria-hidden=true href=#kiss-원칙의-도전과제>#</a></h3><ol><li><p>단순함과 기능성 간의 균형<br>단순성을 추구하는 것은 중요하지만, 필요한 기능을 희생해서는 안 된다. 단순함과 기능성 사이의 적절한 균형을 찾는 것이 중요하다.</p></li><li><p>단순함은 주관적일 수 있음<br>&ldquo;단순함"은 경험, 배경, 지식 수준에 따라 다르게 해석될 수 있다. 한 개발자에게 단순한 것이 다른 개발자에게는 복잡할 수 있다.</p></li><li><p>&ldquo;과도한 단순화&rdquo; 피하기<br>때로는 복잡성이 필요하다. 특히 복잡한 비즈니스 로직이나 성능 최적화를 다룰 때는 더욱 그렇다. 과도한 단순화는 중요한 세부 사항을 무시할 수 있다.</p></li><li><p>미래의 요구사항 예측<br>현재의 단순한 솔루션이 미래의 요구사항을 수용하기 어려울 수 있다. 확장성과 단순성 사이의 균형을 맞추는 것이 중요하다.</p></li></ol><h3 id=현대-소프트웨어-개발에서의-kiss-적용>현대 소프트웨어 개발에서의 KISS 적용<a hidden class=anchor aria-hidden=true href=#현대-소프트웨어-개발에서의-kiss-적용>#</a></h3><h4 id=마이크로서비스-아키텍처>마이크로서비스 아키텍처<a hidden class=anchor aria-hidden=true href=#마이크로서비스-아키텍처>#</a></h4><p>마이크로서비스 아키텍처는 KISS 원칙을 대규모 시스템에 적용하는 방법이다.<br>각 서비스는 하나의 비즈니스 기능에 집중하여 단순성을 유지한다.</p><pre class=mermaid>// 모놀리식 접근 방식 (복잡함)
한 애플리케이션에서 사용자 관리, 결제 처리, 재고 관리, 배송 처리 등 모든 기능 처리

// 마이크로서비스 접근 방식 (각 서비스는 단순함)
- 사용자 서비스: 사용자 관리만 담당
- 결제 서비스: 결제 처리만 담당
- 재고 서비스: 재고 관리만 담당
- 배송 서비스: 배송 처리만 담당
</pre><h4 id=함수형-프로그래밍>함수형 프로그래밍<a hidden class=anchor aria-hidden=true href=#함수형-프로그래밍>#</a></h4><p>함수형 프로그래밍은 순수 함수와 불변성을 강조하여 코드의 복잡성을 줄인다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 명령형 접근 방식 (상태 변경으로 복잡함)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>total</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>numbers</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>total</span> <span class=o>+=</span> <span class=nx>numbers</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 함수형 접근 방식 (단순함)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>total</span> <span class=o>=</span> <span class=nx>numbers</span><span class=p>.</span><span class=nx>reduce</span><span class=p>((</span><span class=nx>sum</span><span class=p>,</span> <span class=nx>num</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>sum</span> <span class=o>+</span> <span class=nx>num</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=지속적인-리팩토링>지속적인 리팩토링<a hidden class=anchor aria-hidden=true href=#지속적인-리팩토링>#</a></h4><p>지속적인 리팩토링은 코드가 시간이 지남에 따라 복잡해지는 것을 방지한다.<br>기술 부채를 관리하고 코드 품질을 유지하는 중요한 방법이다.</p><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/design-principles/>Design-Principles</a></li><li><a href=https://buenhyden.github.io/tags/kiss-principle/>KISS-Principle</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/fundamentals/programming-paradigms/imperative-programming/oop/access-modifiers/><span class=title>« Prev</span><br><span>Access Modifiers</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/yagni-principle/><span class=title>Next »</span><br><span>YAGNI Principle</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>