<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Architecture-Patterns"><meta name=description content="주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Architecture Pattern"><meta property="og:description" content="주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Architecture Pattern"><meta name=twitter:description content="주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Software Architecture Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a></div><h1>Software Architecture Pattern</h1><div class=post-description>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</div></header><div class=post-content><h2 id=software-architecture-pattern>Software Architecture Pattern<a hidden class=anchor aria-hidden=true href=#software-architecture-pattern>#</a></h2><p>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</p><p><figure><img alt="Software Architecture Patrterns" loading=lazy src=/img/86fdda13-d57b-4d9c-b868-ac35d3c52569_1600x1582.webp><figcaption>https://blog.bytebytego.com/p/software-architecture-patterns</figcaption></figure></p><table><thead><tr><th>패턴 이름</th><th>핵심 개념</th><th>주요 구성요소</th><th>특징</th><th>장점</th><th>단점</th><th>활용 사례</th></tr></thead><tbody><tr><td>Monolithic Pattern</td><td>단일 실행 파일로 구성된 전통적인 아키텍처</td><td>- 단일 코드베이스<br>- 단일 데이터베이스<br>- 통합된 비즈니스 로직</td><td>- 모든 기능이 하나의 프로세스로 실행<br>- 강한 결합도<br>- 단순한 배포 구조</td><td>- 개발 단순성<br>- 쉬운 테스트<br>- 성능 최적화 용이</td><td>- 확장성 제한<br>- 유지보수 어려움<br>- 기술 스택 제한</td><td>- 작은 규모 애플리케이션<br>- 프로토타입<br>- 단순한 비즈니스 로직</td></tr><tr><td>Layered Pattern</td><td>관심사의 수직적 분리를 통한 계층화</td><td>- 프레젠테이션 계층<br>- 비즈니스 계층<br>- 데이터 계층<br>- 인프라 계층</td><td>- 계층간 단방향 의존성<br>- 관심사 분리<br>- 모듈화</td><td>- 유지보수성<br>- 테스트 용이성<br>- 역할 분리 명확</td><td>- 성능 오버헤드<br>- 불필요한 계층 통과<br>- 유연성 제한</td><td>- 엔터프라이즈 시스템<br>- 웹 애플리케이션<br>- 데이터 중심 애플리케이션</td></tr><tr><td>Client-Server Pattern</td><td>서비스 제공자와 소비자의 분리</td><td>- 클라이언트<br>- 서버<br>- 통신 프로토콜</td><td>- 중앙 집중식 리소스 관리<br>- 역할 분리<br>- 네트워크 기반 통신</td><td>- 리소스 중앙화<br>- 보안 통제 용이<br>- 유지보수 편의</td><td>- 서버 의존성<br>- 네트워크 지연<br>- 단일 실패점</td><td>- 웹 서비스<br>- 데이터베이스 시스템<br>- 네트워크 애플리케이션</td></tr><tr><td>Master-Slave Pattern</td><td>작업 분배와 결과 통합</td><td>- 마스터 노드<br>- 슬레이브 노드<br>- 작업 분배기</td><td>- 병렬 처리<br>- 중앙 제어<br>- 결과 취합</td><td>- 성능 향상<br>- 확장성<br>- 신뢰성</td><td>- 마스터 병목<br>- 복잡한 구현<br>- 오버헤드</td><td>- 데이터베이스 복제<br>- 병렬 컴퓨팅<br>- 분산 처리</td></tr><tr><td>Pipe-Filter Pattern</td><td>데이터 스트림 처리의 단계적 변환</td><td>- 파이프<br>- 필터<br>- 데이터 스트림</td><td>- 순차적 처리<br>- 단방향 데이터 흐름<br>- 모듈식 구성</td><td>- 재사용성<br>- 유연한 조합<br>- 병렬 처리 가능</td><td>- 데이터 형식 변환<br>- 처리 지연<br>- 리소스 소비</td><td>- ETL 프로세스<br>- 텍스트 처리<br>- 이미지 처리</td></tr><tr><td>Broker Pattern</td><td>분산 서비스의 조정 및 통신</td><td>- 브로커<br>- 클라이언트<br>- 서버<br>- 브릿지</td><td>- 서비스 중개<br>- 위치 투명성<br>- 상호운용성</td><td>- 확장성<br>- 유연성<br>- 재사용성</td><td>- 복잡성<br>- 성능 오버헤드<br>- 단일 실패점</td><td>- 메시지 큐<br>- 서비스 중개<br>- 분산 시스템</td></tr><tr><td>Peer-to-Peer Pattern</td><td>분산된 피어 간의 직접 통신</td><td>- 피어 노드<br>- 리소스 공유<br>- 검색 메커니즘</td><td>- 탈중앙화<br>- 자율성<br>- 리소스 공유</td><td>- 확장성<br>- 견고성<br>- 비용 효율성</td><td>- 보안 관리<br>- 일관성 유지<br>- 신뢰성</td><td>- 파일 공유<br>- 블록체인<br>- 협업 도구</td></tr><tr><td>Event-Bus Pattern</td><td>이벤트 기반 통신을 위한 중앙 버스</td><td>- 이벤트 버스<br>- 발행자<br>- 구독자<br>- 이벤트 핸들러</td><td>- 느슨한 결합<br>- 비동기 통신<br>- 다대다 통신</td><td>- 확장성<br>- 유연성<br>- 모듈성</td><td>- 디버깅 어려움<br>- 성능 병목<br>- 복잡성</td><td>- GUI 시스템<br>- 메시징 시스템<br>- 이벤트 처리</td></tr><tr><td>MVC Pattern</td><td>사용자 인터페이스와 비즈니스 로직의 분리</td><td>- 모델<br>- 뷰<br>- 컨트롤러</td><td>- 관심사 분리<br>- 데이터와 표현 분리<br>- 재사용성</td><td>- 유지보수성<br>- 병렬 개발<br>- 유연성</td><td>- 복잡성<br>- 오버헤드<br>- 학습 곡선</td><td>- 웹 애플리케이션<br>- 데스크톱 앱<br>- 모바일 앱</td></tr><tr><td>Microservices Pattern</td><td>독립적으로 배포 가능한 작은 서비스들의 집합</td><td>- 서비스<br>API 게이트웨이<br>- 서비스 레지스트리</td><td>- 서비스 독립성<br>- 분산 데이터 관리<br>- 자동화된 배포</td><td>- 확장성<br>- 기술 다양성<br>- 장애 격리</td><td>- 분산 복잡성<br>- 운영 부담<br>- 일관성 관리</td><td>- 대규모 시스템<br>- 클라우드 네이티브<br>- 확장 가능 서비스</td></tr><tr><td>Hexagonal Architecture</td><td>포트와 어댑터를 통한 외부 시스템 격리</td><td>- 도메인 코어<br>- 포트<br>- 어댑터</td><td>- 의존성 역전<br>- 도메인 중심<br>- 테스트 용이성</td><td>- 유지보수성<br>- 테스트 용이<br>- 유연성</td><td>- 복잡성<br>- 학습 곡선<br>- 초기 개발 시간</td><td>- 비즈니스 애플리케이션<br>- 도메인 중심 설계<br>- 레거시 현대화</td></tr><tr><td>Space-Based Architecture</td><td>메모리 내 데이터 그리드 기반 확장</td><td>- 처리 유닛<br>- 가상 미들웨어<br>- 데이터 그리드</td><td>- 선형 확장성<br>- 인메모리 처리<br>- 고가용성</td><td>- 성능<br>- 확장성<br>- 응답성</td><td>- 복잡성<br>- 비용<br>- 데이터 일관성</td><td>- 고성능 시스템<br>- 실시간 처리<br>- 대규모 트래픽</td></tr><tr><td>Microkernel Architecture</td><td>플러그인 기반의 확장 가능한 시스템</td><td>- 코어 시스템<br>- 플러그인<br>- 확장 포인트</td><td>- 모듈식 설계<br>- 확장성<br>- 유연성</td><td>- 커스터마이징<br>- 유지보수성<br>- 안정성</td><td>- 성능 오버헤드<br>- 버전 관리<br>- 통합 복잡성</td><td>- IDE<br>- 브라우저<br>- 플러그인 기반 시스템</td></tr><tr><td>CQRS</td><td>읽기와 쓰기 모델의 분리</td><td>- 명령 모델<br>- 쿼리 모델<br>- 동기화 메커니즘</td><td>- 성능 최적화<br>- 확장성<br>- 복잡성 관리</td><td>- 성능<br>- 확장성<br>- 유연성</td><td>- 복잡성<br>- 일관성 관리<br>- 학습 곡선</td><td>- 고성능 시스템<br>- 복잡한 도메인<br>- 이벤트 소싱</td></tr><tr><td>Domain-Driven Design</td><td>복잡한 도메인의 모델링과 설계</td><td>- 도메인 모델<br>- 바운디드 컨텍스트<br>- 애그리게잇</td><td>- 도메인 중심<br>- 유비쿼터스 언어<br>- 컨텍스트 경계</td><td>- 비즈니스 정렬<br>- 복잡성 관리<br>- 명확한 경계</td><td>- 학습 곡선<br>- 초기 투자<br>- 오버엔지니어링</td><td>- 복잡한 비즈니스<br>- 대규모 시스템<br>- 도메인 중심 시스템</td></tr><tr><td>Repository Pattern</td><td>데이터 접근 계층의 추상화</td><td>- 리포지토리<br>- 엔티티<br>- 데이터 매퍼</td><td>- 데이터 접근 추상화<br>- 영속성 로직 분리<br>- 테스트 용이성</td><td>- 유지보수성<br>- 테스트 용이<br>- 코드 재사용</td><td>- 추가 계층<br>- 복잡성<br>- 성능 영향</td><td>- 데이터 중심 앱<br>ORM 시스템<br>- 엔터프라이즈 앱</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Peer-to-Peer Pattern</h2></header><div class=entry-content><p>Peer-to-Peer Pattern (P2P 패턴) 피어-투-피어(Peer-to-Peer, P2P) 패턴은 분산 네트워크 아키텍처의 한 형태로, 각 노드(피어)가 클라이언트와 서버의 역할을 동시에 수행하는 구조.
이 패턴은 중앙 서버에 의존하지 않고 피어들이 직접 리소스를 공유하고 통신하는 것이 특징이다.
https://www.geeksforgeeks.org/what-is-p2p-peer-to-peer-process/
P2P 패턴의 주요 특징 분산화: 중앙 서버 없이 모든 피어가 동등한 권한과 책임을 가집니다. 자율성: 각 피어는 독립적으로 작동하며, 네트워크의 전체 기능에 영향을 주지 않고 참여하거나 떠날 수 있습니다. 확장성: 새로운 피어가 추가될수록 네트워크의 전체 용량과 리소스 풀이 증가합니다. 리소스 공유: 피어들은 파일, 대역폭, 처리 능력 등의 리소스를 직접 공유합니다. 익명성: 중앙 서버를 통하지 않고 직접 통신하므로 사용자의 익명성을 유지할 수 있습니다. 장점 효율적인 리소스 활용: 유휴 컴퓨팅 자원을 효과적으로 활용할 수 있습니다. 높은 확장성: 피어가 증가할수록 네트워크의 성능이 향상됩니다. 내결함성: 일부 피어의 장애가 전체 네트워크에 큰 영향을 미치지 않습니다. 비용 효율성: 중앙 서버 구축 및 유지 비용이 감소합니다. 단점 보안 위험: 중앙 통제가 없어 악성 코드나 불법 콘텐츠의 유통 위험이 있습니다. 성능 불균형: 피어들의 리소스 제공 정도에 따라 네트워크 성능이 불균형할 수 있습니다. 데이터 무결성: 피어들이 자유롭게 데이터를 추가하고 조작할 수 있어 데이터 무결성 유지가 어려울 수 있습니다. 구현 시 고려사항 피어 발견:
...</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;891 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Peer-to-Peer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/peer-to-peer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pipe-Filter Pattern</h2></header><div class=entry-content><p>Pipe-Filter Pattern 파이프-필터 패턴(Pipe-Filter Pattern)은 데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 복잡한 처리 과정을 독립적인 단계로 나누어 모듈화하고, 이들을 순차적으로 연결하여 데이터를 처리한다.
주요 구성 요소 필터(Filter):
단일 작업을 수행하는 처리 컴포넌트입니다 입력을 받아 처리하고 출력을 생성합니다 독립적으로 동작하며 다른 필터에 대해 알지 못합니다 재사용이 가능하고 조합할 수 있어야 합니다 파이프(Pipe):
필터 간의 데이터 전달을 담당합니다 데이터 버퍼링과 동기화를 처리합니다 필터들을 느슨하게 결합시킵니다 대개 큐나 스트림으로 구현됩니다 파이프라인(Pipeline):
...</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;829 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe-Filter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/pipe-filter-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Client-Server Pattern</h2></header><div class=entry-content><p>Client-Server Pattern 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나눈다:
서비스를 제공하는 서버 서비스를 요청하는 클라이언트.
이들은 네트워크를 통해 서로 통신하며, 각자 명확한 역할과 책임을 가지고 있다. 클라이언트-서버 패턴 (Client-Server Pattern) 클라이언트-서버 패턴은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴이다.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나뉜다:
서비스를 제공하는 서버와 서비스를 요청하는 클라이언트이다.
주요 구성 요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
클라이언트 (Client):
...</p></div><footer class=entry-footer><span title='2024-11-20 08:27:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;264 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-Server Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/client-server-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/page/5/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>