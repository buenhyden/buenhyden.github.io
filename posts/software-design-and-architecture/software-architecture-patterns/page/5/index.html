<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Software Architecture Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Architecture-Patterns"><meta name=description content="주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Software Architecture Pattern"><meta property="og:description" content="주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Software Architecture Pattern"><meta name=twitter:description content="주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Software Architecture Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a></div><h1>Software Architecture Pattern</h1><div class=post-description>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</div></header><div class=post-content><h2 id=software-architecture-pattern>Software Architecture Pattern<a hidden class=anchor aria-hidden=true href=#software-architecture-pattern>#</a></h2><p>주어진 상황에서의 소프트웨어 아키텍쳐에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다. 아키텍쳐 패턴은 소프트웨어 디자인 패턴과 유사하지만 더 큰 범주에 속한다.</p><p><figure><img alt="Software Architecture Patrterns" loading=lazy src=/img/86fdda13-d57b-4d9c-b868-ac35d3c52569_1600x1582.webp><figcaption>https://blog.bytebytego.com/p/software-architecture-patterns</figcaption></figure></p><table><thead><tr><th>패턴 이름</th><th>핵심 개념</th><th>주요 구성요소</th><th>특징</th><th>장점</th><th>단점</th><th>활용 사례</th></tr></thead><tbody><tr><td>Monolithic Pattern</td><td>단일 실행 파일로 구성된 전통적인 아키텍처</td><td>- 단일 코드베이스<br>- 단일 데이터베이스<br>- 통합된 비즈니스 로직</td><td>- 모든 기능이 하나의 프로세스로 실행<br>- 강한 결합도<br>- 단순한 배포 구조</td><td>- 개발 단순성<br>- 쉬운 테스트<br>- 성능 최적화 용이</td><td>- 확장성 제한<br>- 유지보수 어려움<br>- 기술 스택 제한</td><td>- 작은 규모 애플리케이션<br>- 프로토타입<br>- 단순한 비즈니스 로직</td></tr><tr><td>Layered Pattern</td><td>관심사의 수직적 분리를 통한 계층화</td><td>- 프레젠테이션 계층<br>- 비즈니스 계층<br>- 데이터 계층<br>- 인프라 계층</td><td>- 계층간 단방향 의존성<br>- 관심사 분리<br>- 모듈화</td><td>- 유지보수성<br>- 테스트 용이성<br>- 역할 분리 명확</td><td>- 성능 오버헤드<br>- 불필요한 계층 통과<br>- 유연성 제한</td><td>- 엔터프라이즈 시스템<br>- 웹 애플리케이션<br>- 데이터 중심 애플리케이션</td></tr><tr><td>Client-Server Pattern</td><td>서비스 제공자와 소비자의 분리</td><td>- 클라이언트<br>- 서버<br>- 통신 프로토콜</td><td>- 중앙 집중식 리소스 관리<br>- 역할 분리<br>- 네트워크 기반 통신</td><td>- 리소스 중앙화<br>- 보안 통제 용이<br>- 유지보수 편의</td><td>- 서버 의존성<br>- 네트워크 지연<br>- 단일 실패점</td><td>- 웹 서비스<br>- 데이터베이스 시스템<br>- 네트워크 애플리케이션</td></tr><tr><td>Master-Slave Pattern</td><td>작업 분배와 결과 통합</td><td>- 마스터 노드<br>- 슬레이브 노드<br>- 작업 분배기</td><td>- 병렬 처리<br>- 중앙 제어<br>- 결과 취합</td><td>- 성능 향상<br>- 확장성<br>- 신뢰성</td><td>- 마스터 병목<br>- 복잡한 구현<br>- 오버헤드</td><td>- 데이터베이스 복제<br>- 병렬 컴퓨팅<br>- 분산 처리</td></tr><tr><td>Pipe-Filter Pattern</td><td>데이터 스트림 처리의 단계적 변환</td><td>- 파이프<br>- 필터<br>- 데이터 스트림</td><td>- 순차적 처리<br>- 단방향 데이터 흐름<br>- 모듈식 구성</td><td>- 재사용성<br>- 유연한 조합<br>- 병렬 처리 가능</td><td>- 데이터 형식 변환<br>- 처리 지연<br>- 리소스 소비</td><td>- ETL 프로세스<br>- 텍스트 처리<br>- 이미지 처리</td></tr><tr><td>Broker Pattern</td><td>분산 서비스의 조정 및 통신</td><td>- 브로커<br>- 클라이언트<br>- 서버<br>- 브릿지</td><td>- 서비스 중개<br>- 위치 투명성<br>- 상호운용성</td><td>- 확장성<br>- 유연성<br>- 재사용성</td><td>- 복잡성<br>- 성능 오버헤드<br>- 단일 실패점</td><td>- 메시지 큐<br>- 서비스 중개<br>- 분산 시스템</td></tr><tr><td>Peer-to-Peer Pattern</td><td>분산된 피어 간의 직접 통신</td><td>- 피어 노드<br>- 리소스 공유<br>- 검색 메커니즘</td><td>- 탈중앙화<br>- 자율성<br>- 리소스 공유</td><td>- 확장성<br>- 견고성<br>- 비용 효율성</td><td>- 보안 관리<br>- 일관성 유지<br>- 신뢰성</td><td>- 파일 공유<br>- 블록체인<br>- 협업 도구</td></tr><tr><td>Event-Bus Pattern</td><td>이벤트 기반 통신을 위한 중앙 버스</td><td>- 이벤트 버스<br>- 발행자<br>- 구독자<br>- 이벤트 핸들러</td><td>- 느슨한 결합<br>- 비동기 통신<br>- 다대다 통신</td><td>- 확장성<br>- 유연성<br>- 모듈성</td><td>- 디버깅 어려움<br>- 성능 병목<br>- 복잡성</td><td>- GUI 시스템<br>- 메시징 시스템<br>- 이벤트 처리</td></tr><tr><td>MVC Pattern</td><td>사용자 인터페이스와 비즈니스 로직의 분리</td><td>- 모델<br>- 뷰<br>- 컨트롤러</td><td>- 관심사 분리<br>- 데이터와 표현 분리<br>- 재사용성</td><td>- 유지보수성<br>- 병렬 개발<br>- 유연성</td><td>- 복잡성<br>- 오버헤드<br>- 학습 곡선</td><td>- 웹 애플리케이션<br>- 데스크톱 앱<br>- 모바일 앱</td></tr><tr><td>Microservices Pattern</td><td>독립적으로 배포 가능한 작은 서비스들의 집합</td><td>- 서비스<br>API 게이트웨이<br>- 서비스 레지스트리</td><td>- 서비스 독립성<br>- 분산 데이터 관리<br>- 자동화된 배포</td><td>- 확장성<br>- 기술 다양성<br>- 장애 격리</td><td>- 분산 복잡성<br>- 운영 부담<br>- 일관성 관리</td><td>- 대규모 시스템<br>- 클라우드 네이티브<br>- 확장 가능 서비스</td></tr><tr><td>Hexagonal Architecture</td><td>포트와 어댑터를 통한 외부 시스템 격리</td><td>- 도메인 코어<br>- 포트<br>- 어댑터</td><td>- 의존성 역전<br>- 도메인 중심<br>- 테스트 용이성</td><td>- 유지보수성<br>- 테스트 용이<br>- 유연성</td><td>- 복잡성<br>- 학습 곡선<br>- 초기 개발 시간</td><td>- 비즈니스 애플리케이션<br>- 도메인 중심 설계<br>- 레거시 현대화</td></tr><tr><td>Space-Based Architecture</td><td>메모리 내 데이터 그리드 기반 확장</td><td>- 처리 유닛<br>- 가상 미들웨어<br>- 데이터 그리드</td><td>- 선형 확장성<br>- 인메모리 처리<br>- 고가용성</td><td>- 성능<br>- 확장성<br>- 응답성</td><td>- 복잡성<br>- 비용<br>- 데이터 일관성</td><td>- 고성능 시스템<br>- 실시간 처리<br>- 대규모 트래픽</td></tr><tr><td>Microkernel Architecture</td><td>플러그인 기반의 확장 가능한 시스템</td><td>- 코어 시스템<br>- 플러그인<br>- 확장 포인트</td><td>- 모듈식 설계<br>- 확장성<br>- 유연성</td><td>- 커스터마이징<br>- 유지보수성<br>- 안정성</td><td>- 성능 오버헤드<br>- 버전 관리<br>- 통합 복잡성</td><td>- IDE<br>- 브라우저<br>- 플러그인 기반 시스템</td></tr><tr><td>CQRS</td><td>읽기와 쓰기 모델의 분리</td><td>- 명령 모델<br>- 쿼리 모델<br>- 동기화 메커니즘</td><td>- 성능 최적화<br>- 확장성<br>- 복잡성 관리</td><td>- 성능<br>- 확장성<br>- 유연성</td><td>- 복잡성<br>- 일관성 관리<br>- 학습 곡선</td><td>- 고성능 시스템<br>- 복잡한 도메인<br>- 이벤트 소싱</td></tr><tr><td>Domain-Driven Design</td><td>복잡한 도메인의 모델링과 설계</td><td>- 도메인 모델<br>- 바운디드 컨텍스트<br>- 애그리게잇</td><td>- 도메인 중심<br>- 유비쿼터스 언어<br>- 컨텍스트 경계</td><td>- 비즈니스 정렬<br>- 복잡성 관리<br>- 명확한 경계</td><td>- 학습 곡선<br>- 초기 투자<br>- 오버엔지니어링</td><td>- 복잡한 비즈니스<br>- 대규모 시스템<br>- 도메인 중심 시스템</td></tr><tr><td>Repository Pattern</td><td>데이터 접근 계층의 추상화</td><td>- 리포지토리<br>- 엔티티<br>- 데이터 매퍼</td><td>- 데이터 접근 추상화<br>- 영속성 로직 분리<br>- 테스트 용이성</td><td>- 유지보수성<br>- 테스트 용이<br>- 코드 재사용</td><td>- 추가 계층<br>- 복잡성<br>- 성능 영향</td><td>- 데이터 중심 앱<br>ORM 시스템<br>- 엔터프라이즈 앱</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Sourcing Pattern</h2></header><div class=entry-content><p>Event Sourcing Pattern Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.
https://www.geeksforgeeks.org/event-sourcing-pattern/
주요 개념 이벤트 기반 데이터 저장
Event Sourcing은 데이터의 최종 상태만을 저장하는 대신, 모든 변경 사항을 이벤트로 기록한다.
예를 들어, 주문 시스템에서 “주문 생성”, “아이템 추가”, “주문 완료” 등의 이벤트가 순차적으로 저장된다.
이벤트 스토어
모든 이벤트는 추가 전용(append-only) 로그인 이벤트 스토어에 순차적으로 저장된다.
이 스토어는 시스템의 권위 있는 데이터 소스 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-11-20 11:17:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;697 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Sourcing Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CQRS 패턴 (Command Query Responsibility Segregation)</h2></header><div class=entry-content><p>CQRS 패턴 (Command Query Responsibility Segregation) 애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴
이 패턴은 데이터를 변경하는 작업과 데이터를 읽는 작업을 별도의 모델로 분리하여 처리한다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from dataclasses import dataclass from datetime import datetime from typing import List, Optional # 도메인 모델 @dataclass class Product: id: str name: str price: float stock: int created_at: datetime updated_at: datetime # Command 모델 (쓰기 작업) @dataclass class CreateProductCommand: name: str price: float stock: int @dataclass class UpdateProductStockCommand: product_id: str stock: int # Query 모델 (읽기 작업) @dataclass class ProductDetailsQuery: product_id: str @dataclass class ProductListQuery: page: int page_size: int # Command 핸들러 (쓰기 작업 처리) class ProductCommandHandler: def __init__(self, command_db): self.command_db = command_db def handle_create_product(self, command: CreateProductCommand) -> str: product = Product( id=generate_id(), name=command.name, price=command.price, stock=command.stock, created_at=datetime.now(), updated_at=datetime.now() ) self.command_db.save(product) # 이벤트 발행 (읽기 데이터베이스 동기화를 위함) publish_event("ProductCreated", product) return product.id def handle_update_stock(self, command: UpdateProductStockCommand): product = self.command_db.get_by_id(command.product_id) if not product: raise ValueError("Product not found") product.stock = command.stock product.updated_at = datetime.now() self.command_db.update(product) publish_event("ProductStockUpdated", product) # Query 핸들러 (읽기 작업 처리) class ProductQueryHandler: def __init__(self, query_db): self.query_db = query_db def handle_product_details(self, query: ProductDetailsQuery) -> Optional[Product]: return self.query_db.get_by_id(query.product_id) def handle_product_list(self, query: ProductListQuery) -> List[Product]: return self.query_db.get_page(query.page, query.page_size) # API 레이어 class ProductAPI: def __init__(self, command_handler: ProductCommandHandler, query_handler: ProductQueryHandler): self.command_handler = command_handler self.query_handler = query_handler def create_product(self, name: str, price: float, stock: int) -> str: command = CreateProductCommand(name=name, price=price, stock=stock) return self.command_handler.handle_create_product(command) def update_stock(self, product_id: str, stock: int): command = UpdateProductStockCommand(product_id=product_id, stock=stock) self.command_handler.handle_update_stock(command) def get_product(self, product_id: str) -> Optional[Product]: query = ProductDetailsQuery(product_id=product_id) return self.query_handler.handle_product_details(query) def list_products(self, page: int, page_size: int) -> List[Product]: query = ProductListQuery(page=page, page_size=page_size) return self.query_handler.handle_product_list(query) 주요 구성 요소 https://junuuu.tistory.com/891
...</p></div><footer class=entry-footer><span title='2024-11-20 08:30:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CQRS 패턴 (Command Query Responsibility Segregation)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Repository Pattern</h2></header><div class=entry-content><p>Repository Pattern 리포지토리 패턴(Repository Pattern)은 데이터 접근 로직을 추상화하고 캡슐화하여 비즈니스 로직과 데이터 저장소 간의 의존성을 줄이는 소프트웨어 아키텍처 패턴.
이 패턴은 데이터의 저장, 검색 및 관리를 위한 일관된 인터페이스를 제공한다.
주요 개념 추상화: 데이터 접근 로직을 추상화하여 비즈니스 로직이 데이터 저장소의 구체적인 구현에 의존하지 않도록 합니다. 캡슐화: CRUD(Create, Read, Update, Delete) 작업을 캡슐화하여 데이터 접근의 복잡성을 숨깁니다. 중앙 집중화: 데이터 접근 로직을 중앙에서 관리하여 코드 중복을 줄이고 일관성을 유지합니다. 구조 ![](repository-aggregate-database-table-relationships.png “https://tech.buzzvil.com/handbook/repository/ _
...</p></div><footer class=entry-footer><span title='2024-11-20 08:30:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1057 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Repository Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Blackboard Pattern</h2></header><div class=entry-content><p>Blackboard Pattern Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴.
이 패턴은 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.
기본 개념은 실제 교실의 칠판과 매우 유사하다.
여러 전문가들이 함께 모여 칠판에 정보를 공유하고, 문제를 해결해나가는 과정을 소프트웨어 아키텍처로 구현한 것.
Blackboard 패턴은 다음과 같은 상황에서 특히 유용하다:
명확한 해결 알고리즘이 없는 복잡한 문제 여러 전문 분야의 지식이 필요한 문제 다양한 해결 접근 방식을 시도해볼 필요가 있는 경우 Blackboard 패턴은 다음과 같은 분야에서 주로 사용된다:
...</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;653 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blackboard Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/blackboard-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Master-Slave Pattern</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;742 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/page/4/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/page/6/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>