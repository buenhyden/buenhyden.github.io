<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event Sourcing Pattern | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Software-Architecture-Patterns,Event-Sourcing-Pattern"><meta name=description content="Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Event Sourcing Pattern"><meta property="og:description" content="Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-25T11:17:00+00:00"><meta property="article:modified_time" content="2024-09-25T11:17:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="Software-Architecture-Patterns"><meta property="article:tag" content="Event-Sourcing-Pattern"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Event Sourcing Pattern"><meta name=twitter:description content="Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Software Architecture Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/"},{"@type":"ListItem","position":4,"name":"Event Sourcing Pattern","item":"https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event Sourcing Pattern","name":"Event Sourcing Pattern","description":"Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.","keywords":["Software-Design-and-Architecture","Software-Architecture-Patterns","Event-Sourcing-Pattern"],"articleBody":"Event Sourcing Pattern Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.\nhttps://www.geeksforgeeks.org/event-sourcing-pattern/\n주요 개념 이벤트 기반 데이터 저장\nEvent Sourcing은 데이터의 최종 상태만을 저장하는 대신, 모든 변경 사항을 이벤트로 기록한다.\n예를 들어, 주문 시스템에서 “주문 생성”, “아이템 추가”, “주문 완료” 등의 이벤트가 순차적으로 저장된다.\n이벤트 스토어\n모든 이벤트는 추가 전용(append-only) 로그인 이벤트 스토어에 순차적으로 저장된다.\n이 스토어는 시스템의 권위 있는 데이터 소스 역할을 한다.\n상태 재구성\n현재 상태가 필요할 때, 시스템은 저장된 이벤트를 순서대로 재생하여 상태를 재구성한다.\n이를 통해 시스템의 어느 시점의 상태도 재현할 수 있다.\nEvent Sourcing Pattern의 주요 특징 불변성과 순차적 저장 Event Sourcing의 핵심 특징은 모든 상태 변화를 불변의 이벤트로 기록한다는 점이다. 이벤트는 시간 순서대로 추가 전용(append-only) 로그에 저장되며, 한 번 저장된 이벤트는 절대 변경되거나 삭제되지 않는다.\n상태 재구성 현재 상태는 저장된 이벤트를 순차적으로 재생(replay)하여 얻어진다. 이를 통해 시스템의 어느 시점의 상태도 재현할 수 있다.\n완전한 감사 추적 모든 변경사항이 이벤트로 기록되기 때문에, 시스템의 전체 히스토리를 정확하게 추적할 수 있다. 이는 감사, 규정 준수, 디버깅에 매우 유용하다.\n성능과 확장성 이벤트는 단순히 추가되기만 하므로 쓰기 성능이 우수하며, 수평적 확장이 용이하다. 또한 이벤트 처리를 백그라운드에서 수행할 수 있어 UI 응답성을 향상시킬 수 있다.\n시스템 복원력 장애 발생 시 이벤트를 재생하여 시스템 상태를 복구할 수 있어 높은 복원력을 제공한다.\n도메인 중심 설계 이벤트는 비즈니스 도메인의 중요한 변화를 표현하므로, 도메인 주도 설계(DDD)와 잘 어울린다.\n유연성과 다양한 뷰 동일한 이벤트 스트림을 사용하여 다양한 뷰나 모델을 생성할 수 있어 유연성이 높다.\n이러한 특징들로 인해 Event Sourcing은 복잡한 비즈니스 로직, 높은 감사 요구사항, 실시간 데이터 분석이 필요한 시스템에 특히 유용하다. 그러나 구현의 복잡성과 학습 곡선, 이벤트 스키마 변경의 어려움 등의 단점도 고려해야 한다.\n구성 요소 Event Sourcing Pattern의 주요 구성 요소와 그 역할, 특징은 다음과 같다:\n이벤트 (Events)\n역할: 시스템의 상태 변화를 나타내는 불변의 기록 특징: 과거 시제로 명명 (예: “OrderCreated”, “ItemAdded”) 변경 불가능(immutable) 시간 순서대로 저장 상태 변화에 필요한 모든 관련 정보 포함 이벤트 스토어 (Event Store)\n역할: 이벤트를 영구적으로 저장하고 관리하는 데이터 저장소 특징: 추가 전용(append-only) 로그 형태 이벤트를 시간 순서대로 저장 이벤트 조회 및 재생 기능 제공 시스템의 권위 있는 데이터 소스 역할 애그리게이트 (Aggregate)\n역할: 관련 도메인 객체들을 논리적으로 그룹화하여 일관성 경계를 형성 특징: 명령을 처리하고 이벤트를 생성 비즈니스 로직과 상태 변경을 캡슐화 각 애그리게이트는 이벤트 스토어에서 고유한 이벤트 스트림과 연결 명령 (Command)\n역할: 시스템에 상태 변경을 요청하는 지시 특징: 의도를 표현하는 명령형으로 명명 (예: “CreateOrder”, “AddItem”) 애그리게이트에 의해 처리되어 이벤트 생성 프로젝션 (Projection) 역할: 이벤트 스트림을 기반으로 현재 상태를 표현하는 읽기 모델 생성 특징: 이벤트를 처리하여 쿼리에 최적화된 뷰 모델 생성 보고 및 조회를 위한 효율적인 데이터 접근 제공 CQRS 패턴과 함께 자주 사용됨 이벤트 버스 (Event Bus) 역할: 이벤트를 발행하고 구독하는 메시징 인프라 특징: 이벤트 발행자와 구독자 간의 느슨한 결합 제공 비동기 이벤트 처리 지원 시스템 컴포넌트 간 확장성과 유연성 향상 Event Sourcing Pattern은 이러한 구성 요소들을 통해 시스템의 모든 상태 변화를 순차적인 이벤트로 기록하고, 이를 기반으로 현재 상태를 재구성할 수 있는 아키텍처를 제공한다.\n이 패턴은 데이터의 완전한 감사 추적, 시스템 상태의 시간 기반 쿼리, 그리고 복잡한 도메인 모델링에 특히 유용하다.\n작동 방식 이벤트 캡처: 시스템의 모든 변경사항을 이벤트로 기록한다. 순차적 저장: 이벤트를 발생 순서대로 이벤트 스토어에 저장한다. 상태 재구성: 필요시 이벤트를 재생하여 현재 상태를 구축한다. 새 이벤트 처리: 새로운 변경사항이 발생하면 새 이벤트를 생성하고 추가한다. 디버깅을 위한 이벤트 재생: 문제 해결이나 상태 변화 추적을 위해 이벤트를 재생할 수 있다. https://www.perplexity.ai/search/architecture-patternsjung-even-OKzUvT2NR8Cu7LeglzRn8A\n장점 데이터 무결성: 이벤트는 변경 불가능하며 추가만 가능하므로 데이터 무결성이 보장된다. 성능 및 확장성: 이벤트 처리가 백그라운드에서 이루어져 UI 응답성이 향상된다. 완전한 감사 추적: 모든 변경사항이 이벤트로 기록되어 완벽한 감사가 가능한다. 시스템 복원력: 장애 발생 시 이벤트를 재생하여 시스템을 복구할 수 있다. 유연성: 다양한 유형의 메시지를 저장할 수 있고, 적절한 접근 권한이 있는 모든 소비자가 이벤트 스토어에 접근할 수 있다. 단점 복잡성: 전통적인 CRUD 모델에 비해 구현과 이해가 더 복잡할 수 있다. 이벤트 스키마 변경: 이벤트 구조 변경 시 기존 이벤트와의 호환성 문제가 발생할 수 있다. 쿼리 성능: 현재 상태를 얻기 위해 많은 이벤트를 처리해야 할 수 있어 쿼리 성능이 저하될 수 있다. 사용 사례 Event Sourcing은 금융, 물류, 의료, 소매, 정부, 운송, 비디오 게임 개발 등 다양한 분야에서 활용된다.\n특히 다음과 같은 상황에서 유용하다:\n복잡한 도메인 모델링이 필요한 경우 감사, 규정 준수, 보안이 중요한 시스템 실시간 데이터 분석이 필요한 경우 마이크로서비스 아키텍처에서 데이터 일관성 유지가 필요한 경우 참고 및 출처 ","wordCount":"697","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-25T11:17:00Z","dateModified":"2024-09-25T11:17:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/>Software Architecture Pattern</a></div><h1 class="post-title entry-hint-parent">Event Sourcing Pattern</h1><div class=post-description>Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.</div><div class=post-meta><span title='2024-09-25 11:17:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;697 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Design%20and%20Architecture/Software%20Architecture%20Patterns/Event-Sourcing-Pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#event-sourcing-pattern>Event Sourcing Pattern</a><ul><li><a href=#주요-개념>주요 개념</a></li><li><a href=#event-sourcing-pattern의-주요-특징>Event Sourcing Pattern의 주요 특징</a></li><li><a href=#구성-요소>구성 요소</a></li></ul></li><li><a href=#프로젝션-projection>프로젝션 (Projection)</a></li><li><a href=#이벤트-버스-event-bus>이벤트 버스 (Event Bus)</a><ul><li><a href=#작동-방식>작동 방식</a></li><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#사용-사례>사용 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=event-sourcing-pattern>Event Sourcing Pattern<a hidden class=anchor aria-hidden=true href=#event-sourcing-pattern>#</a></h2><p>Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.</p><p><figure><img alt="Event Sourcing Pattern" loading=lazy src=/img/Event-Sourcing-Pattern_1.webp><figcaption>https://www.geeksforgeeks.org/event-sourcing-pattern/</figcaption></figure></p><h3 id=주요-개념>주요 개념<a hidden class=anchor aria-hidden=true href=#주요-개념>#</a></h3><ol><li><p>이벤트 기반 데이터 저장<br>Event Sourcing은 데이터의 최종 상태만을 저장하는 대신, 모든 변경 사항을 이벤트로 기록한다.<br>예를 들어, 주문 시스템에서 &ldquo;주문 생성&rdquo;, &ldquo;아이템 추가&rdquo;, &ldquo;주문 완료&rdquo; 등의 이벤트가 순차적으로 저장된다.</p></li><li><p>이벤트 스토어<br>모든 이벤트는 추가 전용(append-only) 로그인 이벤트 스토어에 순차적으로 저장된다.<br>이 스토어는 시스템의 권위 있는 데이터 소스 역할을 한다.</p></li><li><p>상태 재구성<br>현재 상태가 필요할 때, 시스템은 저장된 이벤트를 순서대로 재생하여 상태를 재구성한다.<br>이를 통해 시스템의 어느 시점의 상태도 재현할 수 있다.</p></li></ol><h3 id=event-sourcing-pattern의-주요-특징>Event Sourcing Pattern의 주요 특징<a hidden class=anchor aria-hidden=true href=#event-sourcing-pattern의-주요-특징>#</a></h3><ol><li><p>불변성과 순차적 저장
Event Sourcing의 핵심 특징은 모든 상태 변화를 불변의 이벤트로 기록한다는 점이다.
이벤트는 시간 순서대로 추가 전용(append-only) 로그에 저장되며, 한 번 저장된 이벤트는 절대 변경되거나 삭제되지 않는다.</p></li><li><p>상태 재구성
현재 상태는 저장된 이벤트를 순차적으로 재생(replay)하여 얻어진다.
이를 통해 시스템의 어느 시점의 상태도 재현할 수 있다.</p></li><li><p>완전한 감사 추적
모든 변경사항이 이벤트로 기록되기 때문에, 시스템의 전체 히스토리를 정확하게 추적할 수 있다.
이는 감사, 규정 준수, 디버깅에 매우 유용하다.</p></li><li><p>성능과 확장성
이벤트는 단순히 추가되기만 하므로 쓰기 성능이 우수하며, 수평적 확장이 용이하다.
또한 이벤트 처리를 백그라운드에서 수행할 수 있어 UI 응답성을 향상시킬 수 있다.</p></li><li><p>시스템 복원력
장애 발생 시 이벤트를 재생하여 시스템 상태를 복구할 수 있어 높은 복원력을 제공한다.</p></li><li><p>도메인 중심 설계
이벤트는 비즈니스 도메인의 중요한 변화를 표현하므로, 도메인 주도 설계(DDD)와 잘 어울린다.</p></li><li><p>유연성과 다양한 뷰
동일한 이벤트 스트림을 사용하여 다양한 뷰나 모델을 생성할 수 있어 유연성이 높다.</p></li></ol><p>이러한 특징들로 인해 Event Sourcing은 복잡한 비즈니스 로직, 높은 감사 요구사항, 실시간 데이터 분석이 필요한 시스템에 특히 유용하다.
그러나 구현의 복잡성과 학습 곡선, 이벤트 스키마 변경의 어려움 등의 단점도 고려해야 한다.</p><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><p>Event Sourcing Pattern의 주요 구성 요소와 그 역할, 특징은 다음과 같다:</p><ol><li><p>이벤트 (Events)</p><ul><li>역할: 시스템의 상태 변화를 나타내는 불변의 기록</li><li>특징:<ul><li>과거 시제로 명명 (예: &ldquo;OrderCreated&rdquo;, &ldquo;ItemAdded&rdquo;)</li><li>변경 불가능(immutable)</li><li>시간 순서대로 저장</li><li>상태 변화에 필요한 모든 관련 정보 포함</li></ul></li></ul></li><li><p>이벤트 스토어 (Event Store)</p><ul><li>역할: 이벤트를 영구적으로 저장하고 관리하는 데이터 저장소</li><li>특징:<ul><li>추가 전용(append-only) 로그 형태</li><li>이벤트를 시간 순서대로 저장</li><li>이벤트 조회 및 재생 기능 제공</li><li>시스템의 권위 있는 데이터 소스 역할</li></ul></li></ul></li><li><p>애그리게이트 (Aggregate)</p><ul><li>역할: 관련 도메인 객체들을 논리적으로 그룹화하여 일관성 경계를 형성</li><li>특징:<ul><li>명령을 처리하고 이벤트를 생성</li><li>비즈니스 로직과 상태 변경을 캡슐화</li><li>각 애그리게이트는 이벤트 스토어에서 고유한 이벤트 스트림과 연결</li></ul></li></ul></li><li><p>명령 (Command)</p><ul><li>역할: 시스템에 상태 변경을 요청하는 지시</li><li>특징:<ul><li>의도를 표현하는 명령형으로 명명 (예: &ldquo;CreateOrder&rdquo;, &ldquo;AddItem&rdquo;)</li><li>애그리게이트에 의해 처리되어 이벤트 생성</li></ul></li></ul></li></ol><h2 id=프로젝션-projection>프로젝션 (Projection)<a hidden class=anchor aria-hidden=true href=#프로젝션-projection>#</a></h2><ul><li>역할: 이벤트 스트림을 기반으로 현재 상태를 표현하는 읽기 모델 생성</li><li>특징:<ul><li>이벤트를 처리하여 쿼리에 최적화된 뷰 모델 생성</li><li>보고 및 조회를 위한 효율적인 데이터 접근 제공</li><li>CQRS 패턴과 함께 자주 사용됨</li></ul></li></ul><h2 id=이벤트-버스-event-bus>이벤트 버스 (Event Bus)<a hidden class=anchor aria-hidden=true href=#이벤트-버스-event-bus>#</a></h2><ul><li>역할: 이벤트를 발행하고 구독하는 메시징 인프라</li><li>특징:<ul><li>이벤트 발행자와 구독자 간의 느슨한 결합 제공</li><li>비동기 이벤트 처리 지원</li><li>시스템 컴포넌트 간 확장성과 유연성 향상</li></ul></li></ul><p>Event Sourcing Pattern은 이러한 구성 요소들을 통해 시스템의 모든 상태 변화를 순차적인 이벤트로 기록하고, 이를 기반으로 현재 상태를 재구성할 수 있는 아키텍처를 제공한다.<br>이 패턴은 데이터의 완전한 감사 추적, 시스템 상태의 시간 기반 쿼리, 그리고 복잡한 도메인 모델링에 특히 유용하다.</p><h3 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h3><ol><li><strong>이벤트 캡처</strong>: 시스템의 모든 변경사항을 이벤트로 기록한다.</li><li><strong>순차적 저장</strong>: 이벤트를 발생 순서대로 이벤트 스토어에 저장한다.</li><li><strong>상태 재구성</strong>: 필요시 이벤트를 재생하여 현재 상태를 구축한다.</li><li><strong>새 이벤트 처리</strong>: 새로운 변경사항이 발생하면 새 이벤트를 생성하고 추가한다.</li><li><strong>디버깅을 위한 이벤트 재생</strong>: 문제 해결이나 상태 변화 추적을 위해 이벤트를 재생할 수 있다.</li></ol><p><figure><img alt="Event Sourcing" loading=lazy src=/img/Event-Sourcing.webp><figcaption>https://www.perplexity.ai/search/architecture-patternsjung-even-OKzUvT2NR8Cu7LeglzRn8A</figcaption></figure></p><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li><strong>데이터 무결성</strong>: 이벤트는 변경 불가능하며 추가만 가능하므로 데이터 무결성이 보장된다.</li><li><strong>성능 및 확장성</strong>: 이벤트 처리가 백그라운드에서 이루어져 UI 응답성이 향상된다.</li><li><strong>완전한 감사 추적</strong>: 모든 변경사항이 이벤트로 기록되어 완벽한 감사가 가능한다.</li><li><strong>시스템 복원력</strong>: 장애 발생 시 이벤트를 재생하여 시스템을 복구할 수 있다.</li><li><strong>유연성</strong>: 다양한 유형의 메시지를 저장할 수 있고, 적절한 접근 권한이 있는 모든 소비자가 이벤트 스토어에 접근할 수 있다.</li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li><strong>복잡성</strong>: 전통적인 CRUD 모델에 비해 구현과 이해가 더 복잡할 수 있다.</li><li><strong>이벤트 스키마 변경</strong>: 이벤트 구조 변경 시 기존 이벤트와의 호환성 문제가 발생할 수 있다.</li><li><strong>쿼리 성능</strong>: 현재 상태를 얻기 위해 많은 이벤트를 처리해야 할 수 있어 쿼리 성능이 저하될 수 있다.</li></ol><h3 id=사용-사례>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h3><p>Event Sourcing은 금융, 물류, 의료, 소매, 정부, 운송, 비디오 게임 개발 등 다양한 분야에서 활용된다.<br>특히 다음과 같은 상황에서 유용하다:</p><ul><li>복잡한 도메인 모델링이 필요한 경우</li><li>감사, 규정 준수, 보안이 중요한 시스템</li><li>실시간 데이터 분석이 필요한 경우</li><li>마이크로서비스 아키텍처에서 데이터 일관성 유지가 필요한 경우</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/software-architecture-patterns/>Software-Architecture-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/event-sourcing-pattern/>Event-Sourcing-Pattern</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/><span class=title>« Prev</span><br><span>Model-View-ViewModel-Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/monolithic-pattern/><span class=title>Next »</span><br><span>Monolithic Pattern</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>