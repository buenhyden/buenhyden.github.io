<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Architectural Styles | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Architectural-Styles"><meta name=description content="Architectural Styles

참고 및 출처"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Architectural Styles"><meta property="og:description" content="Architectural Styles 참고 및 출처"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Architectural Styles"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Architectural Styles","item":"https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a></div><h1>Architectural Styles</h1></header><div class=post-content><h2 id=architectural-styles>Architectural Styles<a hidden class=anchor aria-hidden=true href=#architectural-styles>#</a></h2><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Publish Subscribe</h2></header><div class=entry-content><p>Publish Subscribe 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-21 04:48:00 +0000 UTC'>December 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Publish Subscribe" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/publish-subscribe/publish-subscribe/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture</h2></header><div class=entry-content><p>Event-Driven Architecture Event-Driven Architecture (EDA)는 현대 소프트웨어 아키텍처 패턴 중 하나로, 시스템 내에서 발생하는 이벤트를 중심으로 동작하는 설계 방식이다.
이 아키텍처는 분산 시스템, 마이크로서비스, 실시간 애플리케이션 등에서 널리 사용되며, 시스템의 유연성, 확장성, 그리고 반응성을 향상시키는 데 중요한 역할을 한다.
https://medium.com/@seetharamugn/the-complete-guide-to-event-driven-architecture-b25226594227
주요 구성 요소 이벤트 생성자 (Event Producer)
이벤트를 감지하고 생성하는 컴포넌트 예: 사용자 액션, 센서 데이터, 시스템 상태 변화 등 이벤트 채널 (Event Channel)
이벤트를 전달하는 메시징 인프라 예: Apache Kafka, RabbitMQ, AWS SNS 등 이벤트 처리자 (Event Consumer)
...</p></div><footer class=entry-footer><span title='2024-09-26 11:38:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;542 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/event-driven/event-driven-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분산 시스템 (Distributed System)</h2></header><div class=entry-content><p>분산 시스템 (Distributed System) 분산 시스템은 네트워크로 연결된 여러 독립적인 컴퓨터들이 하나의 통합된 시스템처럼 작동하는 컴퓨팅 환경을 말한다.
마치 여러 사람이 각자 맡은 일을 하면서도 하나의 팀으로 협력하는 것처럼, 분산 시스템의 각 컴퓨터들도 서로 메시지를 주고받으며 협력하여 작업을 수행한다.
분산 시스템의 주요 특징 동시성(Concurrency):
여러 컴포넌트가 동시에 작동하면서 자원을 공유하고 작업을 처리한다.
예를 들어, 온라인 쇼핑몰에서 수많은 사용자가 동시에 주문을 처리할 수 있다.
확장성(Scalability):
시스템의 크기와 성능을 필요에 따라 쉽게 확장할 수 있다.
수평적 확장(더 많은 컴퓨터 추가)과 수직적 확장(더 강력한 컴퓨터로 교체) 모두 가능하다.
...</p></div><footer class=entry-footer><span title='2024-11-11 02:51:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;575 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 시스템 (Distributed System)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/distributed-system/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분산 데이터베이스 (Distributed Database)</h2></header><div class=entry-content><p>분산 데이터베이스 (Distributed Database) 분산 데이터베이스는 네트워크로 연결된 여러 컴퓨터 시스템에 물리적으로 분산되어 있지만, 논리적으로는 하나의 데이터베이스처럼 사용자에게 투명하게 제공되는 데이터베이스 시스템이다. 이는 여러 CPU에 연결된 저장장치들을 하나의 데이터베이스 관리 시스템(DBMS)으로 제어하는 형태를 취한다.
예를 들어, 글로벌 전자상거래 기업이 아시아, 유럽, 미주 등 여러 지역에 데이터베이스를 두고 운영하는 경우를 생각해볼 수 있다.
분산 데이터베이스의 구조를 코드로 이해해보자:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 분산 데이터베이스 시스템의 기본 구조 예시 class DistributedDatabase: def __init__(self): # 여러 지역의 데이터베이스 노드 설정 self.nodes = { 'asia': DatabaseNode('asia-server', replica_set=['asia-1', 'asia-2']), 'europe': DatabaseNode('europe-server', replica_set=['eu-1', 'eu-2']), 'americas': DatabaseNode('americas-server', replica_set=['am-1', 'am-2']) } def write_data(self, data, region): # 데이터 쓰기 작업 수행 primary_node = self.nodes[region] primary_node.write(data) # 다른 지역으로 복제 self._replicate_to_other_regions(data, region) def read_data(self, query, region): # 가장 가까운 노드에서 데이터 읽기 return self.nodes[region].read(query) 주요 특징 데이터 분할(Partitioning)
데이터를 여러 노드에 나누어 저장하는 방식이다.
수평 분할(Sharding)과 수직 분할이 있다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:19:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 데이터베이스 (Distributed Database)" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/distributed-database/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Monolithic Pattern</h2></header><div class=entry-content><p>Monolithic Pattern 모놀리식 패턴(Monolithic Pattern)은 소프트웨어 아키텍처에서 가장 전통적이고 널리 사용되는 패턴 중 하나.
이 패턴은 애플리케이션의 모든 구성 요소가 단일 코드베이스와 단일 실행 단위로 통합된 형태를 취한다.
주요 특징 단일 코드베이스: 모든 기능과 모듈이 하나의 코드베이스에 통합되어 있습니다. 단일 배포 단위: 전체 애플리케이션이 하나의 단위로 빌드되고 배포됩니다. 공유 데이터베이스: 일반적으로 하나의 중앙 집중식 데이터베이스를 사용합니다. 통합된 구성 요소: UI, 비즈니스 로직, 데이터 접근 계층 등이 모두 하나의 애플리케이션 내에 포함됩니다. 주요 구성 요소 https://medium.com/design-microservices-architecture-with-patterns/monolithic-to-microservices-architecture-with-patterns-best-practices-a768272797b2
...</p></div><footer class=entry-footer><span title='2024-09-27 11:14:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1252 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monolithic Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/monolithic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Peer-to-Peer Pattern</h2></header><div class=entry-content><p>Peer-to-Peer Pattern (P2P 패턴) 피어-투-피어(Peer-to-Peer, P2P) 패턴은 분산 네트워크 아키텍처의 한 형태로, 각 노드(피어)가 클라이언트와 서버의 역할을 동시에 수행하는 구조.
이 패턴은 중앙 서버에 의존하지 않고 피어들이 직접 리소스를 공유하고 통신하는 것이 특징이다.
https://www.geeksforgeeks.org/what-is-p2p-peer-to-peer-process/
P2P 패턴의 주요 특징 분산화: 중앙 서버 없이 모든 피어가 동등한 권한과 책임을 가집니다. 자율성: 각 피어는 독립적으로 작동하며, 네트워크의 전체 기능에 영향을 주지 않고 참여하거나 떠날 수 있습니다. 확장성: 새로운 피어가 추가될수록 네트워크의 전체 용량과 리소스 풀이 증가합니다. 리소스 공유: 피어들은 파일, 대역폭, 처리 능력 등의 리소스를 직접 공유합니다. 익명성: 중앙 서버를 통하지 않고 직접 통신하므로 사용자의 익명성을 유지할 수 있습니다. 장점 효율적인 리소스 활용: 유휴 컴퓨팅 자원을 효과적으로 활용할 수 있습니다. 높은 확장성: 피어가 증가할수록 네트워크의 성능이 향상됩니다. 내결함성: 일부 피어의 장애가 전체 네트워크에 큰 영향을 미치지 않습니다. 비용 효율성: 중앙 서버 구축 및 유지 비용이 감소합니다. 단점 보안 위험: 중앙 통제가 없어 악성 코드나 불법 콘텐츠의 유통 위험이 있습니다. 성능 불균형: 피어들의 리소스 제공 정도에 따라 네트워크 성능이 불균형할 수 있습니다. 데이터 무결성: 피어들이 자유롭게 데이터를 추가하고 조작할 수 있어 데이터 무결성 유지가 어려울 수 있습니다. 구현 시 고려사항 피어 발견:
...</p></div><footer class=entry-footer><span title='2024-09-27 08:28:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;891 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Peer-to-Peer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/peer-to-peer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Component-Based Architecture</h2></header><div class=entry-content><p>Component-Based Architecture 컴포넌트 기반 아키텍처(Component-based Architecture)는 소프트웨어 개발에서 중요한 설계 패턴 중 하나이다.
이 아키텍처는 애플리케이션을 독립적이고 재사용 가능한 단위인 ‘컴포넌트’로 구성하는 방식을 말한다.
컴포넌트 기반 아키텍처는 소프트웨어를 독립적으로 배포 가능한 모듈인 ‘컴포넌트’로 구성하는 설계 방식이다.
각 컴포넌트는 특정 기능을 수행하며, 잘 정의된 인터페이스를 통해 다른 컴포넌트와 상호작용한다.
컴포넌트 기반 아키텍처는 소프트웨어 개발의 복잡성을 관리하고, 재사용성을 높이며, 유지보수를 용이하게 하는 강력한 접근 방식이다. 이는 현대 소프트웨어 개발에서 중요한 역할을 하며, 특히 대규모 애플리케이션 개발에 적합하다.
...</p></div><footer class=entry-footer><span title='2024-09-26 11:48:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;440 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Component-Based Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/component-based/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Client-Server Pattern</h2></header><div class=entry-content><p>Client-Server Pattern 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나눈다:
서비스를 제공하는 서버 서비스를 요청하는 클라이언트.
이들은 네트워크를 통해 서로 통신하며, 각자 명확한 역할과 책임을 가지고 있다. 클라이언트-서버 패턴 (Client-Server Pattern) 클라이언트-서버 패턴은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴이다.
이 패턴은 시스템을 두 가지 주요 구성 요소로 나뉜다:
서비스를 제공하는 서버와 서비스를 요청하는 클라이언트이다.
주요 구성 요소 https://apptraitsolutions.com/different-software-architectural-patterns-and-how-to-choose-the-right-one-for-your-app/
클라이언트 (Client):
...</p></div><footer class=entry-footer><span title='2024-09-26 08:27:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;264 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-Server Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/distributed/client-server/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Layered Pattern</h2></header><div class=entry-content><p>Layered Pattern 레이어드 패턴(Layered Pattern)은 소프트웨어 아키텍처에서 가장 널리 사용되는 패턴 중 하나.
이 패턴은 애플리케이션의 구성 요소를 수평적 계층으로 조직화하여 각 계층이 특정 기능을 담당하도록 한다.
주요 계층의 역할과 책임 &lt;https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html
일반적으로 레이어드 아키텍처는 다음과 같은 4개의 표준 계층으로 구성된다:
프레젠테이션 계층 (Presentation Layer): 사용자 또는 외부 시스템과의 상호작용을 담당합니다 입력 데이터의 기본적인 유효성 검사를 수행합니다 응답 데이터를 적절한 형식으로 변환합니다 REST API, 웹 인터페이스, CLI 등의 형태로 구현될 수 있습니다 비즈니스 계층 (Business Layer): 핵심 비즈니스 로직을 구현합니다 트랜잭션 관리를 담당합니다 도메인 객체들의 상태를 조작합니다 비즈니스 규칙을 검증합니다 도메인 계층 (Domain Layer): 비즈니스 도메인의 핵심 개념을 표현합니다 도메인 객체들의 상태와 행위를 정의합니다 비즈니스 규칙을 캡슐화합니다 특정 기술에 독립적입니다 데이터 접근 계층 (Data Access Layer): 데이터의 영속성을 관리합니다 데이터베이스나 외부 시스템과의 통신을 담당합니다 CRUD 작업을 추상화합니다 데이터 매핑을 처리합니다 작은 애플리케이션의 경우 3개 계층으로, 복잡한 애플리케이션은 5개 이상의 계층으로 구성될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-26 08:26:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;997 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Layered Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/structural/layered/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>