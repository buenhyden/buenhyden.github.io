<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interface vs Abstract class | hyunyoun's Blog</title>
<meta name=keywords content="Software-Design-and-Architecture,Programming-Paradigms,OOP,Object-Oriented-Programming"><meta name=description content="인터페이스는 클래스가 '무엇을 해야 하는지'를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Interface vs Abstract class"><meta property="og:description" content="인터페이스는 클래스가 '무엇을 해야 하는지'를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-13T05:39:00+00:00"><meta property="article:modified_time" content="2025-01-13T05:39:00+00:00"><meta property="article:tag" content="Software-Design-and-Architecture"><meta property="article:tag" content="Programming-Paradigms"><meta property="article:tag" content="OOP"><meta property="article:tag" content="Object-Oriented-Programming"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Interface vs Abstract class"><meta name=twitter:description content="인터페이스는 클래스가 '무엇을 해야 하는지'를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Design and Architecture","item":"https://buenhyden.github.io/posts/software-design-and-architecture/"},{"@type":"ListItem","position":3,"name":"Programming Paradigm","item":"https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/"},{"@type":"ListItem","position":4,"name":"객체 지향 프로그래밍 (Object-Oriented Programming)","item":"https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/"},{"@type":"ListItem","position":5,"name":"Interface vs Abstract class","item":"https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Interface vs Abstract class","name":"Interface vs Abstract class","description":"인터페이스는 클래스가 '무엇을 해야 하는지'를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.","keywords":["Software-Design-and-Architecture","Programming-Paradigms","OOP","Object-Oriented-Programming"],"articleBody":"Interface Vs Abstract Class 인터페이스는 클래스가 ‘무엇을 해야 하는지’를 정의하는 계약(contract)과 같은 역할을 한다.\n모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.\n이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.\n추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.\n일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.\n특성 Interface Abstract Class 정의 완전히 추상화된 클래스, 메서드 시그니처만 정의 부분적으로 구현된 클래스, 추상 메서드와 구체 메서드 모두 포함 가능 메서드 추상 메서드만 가능 추상 메서드와 구체 메서드 모두 가능 변수 public static final 상수만 가능 모든 종류의 변수 선언 가능 생성자 생성자를 가질 수 없음 생성자를 가질 수 있음 다중 상속 다중 구현 가능 단일 상속만 가능 접근 제어자 모든 메서드는 public (암묵적) 모든 접근 제어자 사용 가능 인스턴스화 직접 인스턴스화 불가능 직접 인스턴스화 불가능 사용 목적 클래스의 행동을 정의하는 계약 관련 클래스들의 공통 특성을 정의하고 일부 구현 제공 확장성 쉽게 확장 가능 확장에 제한이 있을 수 있음 구현 복잡성 상대적으로 간단 더 복잡할 수 있음 주요 차이점과 특징 구현 수준의 차이: 인터페이스는 메서드의 선언만을 포함하지만, 추상 클래스는 일부 구현된 메서드를 포함할 수 있다. 이는 코드 재사용성 측면에서 중요한 차이를 만든다. 목적의 차이: 인터페이스는 클래스의 행위를 규정하는 계약의 역할을 하며, 추상 클래스는 관련된 클래스들의 공통 기능을 제공하고 확장성을 부여한다. 사용 시나리오: 인터페이스는 서로 다른 클래스들이 동일한 방식으로 동작해야 할 때 사용된다. 예를 들어, 다양한 결제 방식(신용카드, 현금, 모바일 결제 등)을 구현할 때 유용하다. 추상 클래스는 비슷한 특성을 가진 클래스들의 공통 기능을 정의할 때 사용된다.\n예를 들어, 다양한 도형 클래스들의 공통 특성을 정의할 때 적합하다.\n다중 상속/구현: 한 클래스는 여러 인터페이스를 동시에 구현할 수 있지만, 추상 클래스는 단일 상속만 가능하다. 이는 설계의 유연성에 큰 영향을 미친다. 멤버 변수와 메서드: 인터페이스는 일반적으로 상수와 추상 메서드만을 포함할 수 있다. 반면 추상 클래스는 인스턴스 변수, 생성자, 일반 메서드, 추상 메서드 등 모든 종류의 멤버를 가질 수 있다. 인터페이스와 추상 클래스를 함께 사용하는 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Drawable(ABC): @abstractmethod def draw(self): pass class Shape(ABC): def __init__(self, color): self.color = color def get_color(self): return self.color @abstractmethod def calculate_area(self): pass class Circle(Shape, Drawable): def __init__(self, color, radius): super().__init__(color) self.radius = radius def draw(self): print(f\"Drawing a {self.color} circle\") def calculate_area(self): return 3.14 * self.radius * self.radius 이 예시에서 Drawable은 인터페이스의 역할을, Shape는 추상 클래스의 역할을 한다.\nCircle 클래스는 둘 다의 특성을 상속받아 구체적인 기능을 구현한다.\n참고 및 출처 ","wordCount":"419","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-13T05:39:00Z","dateModified":"2025-01-13T05:39:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/>Programming Paradigm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/>객체 지향 프로그래밍 (Object-Oriented Programming)</a></div><h1 class="post-title entry-hint-parent">Interface vs Abstract class</h1><div class=post-description>인터페이스는 클래스가 '무엇을 해야 하는지'를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.</div><div class=post-meta><span title='2025-01-13 05:39:00 +0000 UTC'>January 13, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#interface-vs-abstract-class>Interface Vs Abstract Class</a><ul><li><a href=#주요-차이점과-특징>주요 차이점과 특징</a></li><li><a href=#인터페이스와-추상-클래스를-함께-사용하는-예시>인터페이스와 추상 클래스를 함께 사용하는 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=interface-vs-abstract-class>Interface Vs Abstract Class<a hidden class=anchor aria-hidden=true href=#interface-vs-abstract-class>#</a></h2><p>인터페이스는 클래스가 &lsquo;무엇을 해야 하는지&rsquo;를 정의하는 계약(contract)과 같은 역할을 한다.<br>모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.<br>이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.</p><p>추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.<br>일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.</p><table><thead><tr><th>특성</th><th>Interface</th><th>Abstract Class</th></tr></thead><tbody><tr><td>정의</td><td>완전히 추상화된 클래스, 메서드 시그니처만 정의</td><td>부분적으로 구현된 클래스, 추상 메서드와 구체 메서드 모두 포함 가능</td></tr><tr><td>메서드</td><td>추상 메서드만 가능</td><td>추상 메서드와 구체 메서드 모두 가능</td></tr><tr><td>변수</td><td>public static final 상수만 가능</td><td>모든 종류의 변수 선언 가능</td></tr><tr><td>생성자</td><td>생성자를 가질 수 없음</td><td>생성자를 가질 수 있음</td></tr><tr><td>다중 상속</td><td>다중 구현 가능</td><td>단일 상속만 가능</td></tr><tr><td>접근 제어자</td><td>모든 메서드는 public (암묵적)</td><td>모든 접근 제어자 사용 가능</td></tr><tr><td>인스턴스화</td><td>직접 인스턴스화 불가능</td><td>직접 인스턴스화 불가능</td></tr><tr><td>사용 목적</td><td>클래스의 행동을 정의하는 계약</td><td>관련 클래스들의 공통 특성을 정의하고 일부 구현 제공</td></tr><tr><td>확장성</td><td>쉽게 확장 가능</td><td>확장에 제한이 있을 수 있음</td></tr><tr><td>구현 복잡성</td><td>상대적으로 간단</td><td>더 복잡할 수 있음</td></tr></tbody></table><h3 id=주요-차이점과-특징>주요 차이점과 특징<a hidden class=anchor aria-hidden=true href=#주요-차이점과-특징>#</a></h3><ol><li>구현 수준의 차이: 인터페이스는 메서드의 선언만을 포함하지만, 추상 클래스는 일부 구현된 메서드를 포함할 수 있다. 이는 코드 재사용성 측면에서 중요한 차이를 만든다.</li><li>목적의 차이: 인터페이스는 클래스의 행위를 규정하는 계약의 역할을 하며, 추상 클래스는 관련된 클래스들의 공통 기능을 제공하고 확장성을 부여한다.</li><li>사용 시나리오: 인터페이스는 서로 다른 클래스들이 동일한 방식으로 동작해야 할 때 사용된다. 예를 들어, 다양한 결제 방식(신용카드, 현금, 모바일 결제 등)을 구현할 때 유용하다.</li></ol><p>추상 클래스는 비슷한 특성을 가진 클래스들의 공통 기능을 정의할 때 사용된다.<br>예를 들어, 다양한 도형 클래스들의 공통 특성을 정의할 때 적합하다.</p><ol start=4><li>다중 상속/구현: 한 클래스는 여러 인터페이스를 동시에 구현할 수 있지만, 추상 클래스는 단일 상속만 가능하다. 이는 설계의 유연성에 큰 영향을 미친다.</li><li>멤버 변수와 메서드: 인터페이스는 일반적으로 상수와 추상 메서드만을 포함할 수 있다. 반면 추상 클래스는 인스턴스 변수, 생성자, 일반 메서드, 추상 메서드 등 모든 종류의 멤버를 가질 수 있다.</li></ol><h3 id=인터페이스와-추상-클래스를-함께-사용하는-예시>인터페이스와 추상 클래스를 함께 사용하는 예시<a hidden class=anchor aria-hidden=true href=#인터페이스와-추상-클래스를-함께-사용하는-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Drawable</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>draw</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>color</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>color</span> <span class=o>=</span> <span class=n>color</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_color</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>color</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>calculate_area</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Circle</span><span class=p>(</span><span class=n>Shape</span><span class=p>,</span> <span class=n>Drawable</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>color</span><span class=p>,</span> <span class=n>radius</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>color</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>radius</span> <span class=o>=</span> <span class=n>radius</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>draw</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Drawing a </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>color</span><span class=si>}</span><span class=s2> circle&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>calculate_area</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mf>3.14</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>radius</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>radius</span>
</span></span></code></pre></td></tr></table></div></div><p>이 예시에서 Drawable은 인터페이스의 역할을, Shape는 추상 클래스의 역할을 한다.<br>Circle 클래스는 둘 다의 특성을 상속받아 구체적인 기능을 구현한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-design-and-architecture/>Software-Design-and-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/programming-paradigms/>Programming-Paradigms</a></li><li><a href=https://buenhyden.github.io/tags/oop/>OOP</a></li><li><a href=https://buenhyden.github.io/tags/object-oriented-programming/>Object-Oriented-Programming</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstract-class/><span class=title>« Prev</span><br><span>Abstract class</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/concepts/exception-handling/><span class=title>Next »</span><br><span>Exception Handling</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>