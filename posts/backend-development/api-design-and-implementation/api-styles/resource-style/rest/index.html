<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RESTful API | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,API-Styles,RESTful-API"><meta name=description content='REST는 네트워크 시스템, 특히 웹에서 자원을 정의하고 접근하는 방법을 제공한다. 그 이름에서 알 수 있듯이 핵심은 "표현(Representation)"과 "상태 전이(State Transfer)"이다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="RESTful API"><meta property="og:description" content='REST는 네트워크 시스템, 특히 웹에서 자원을 정의하고 접근하는 방법을 제공한다. 그 이름에서 알 수 있듯이 핵심은 "표현(Representation)"과 "상태 전이(State Transfer)"이다.'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="RESTful API"><meta name=twitter:description content='REST는 네트워크 시스템, 특히 웹에서 자원을 정의하고 접근하는 방법을 제공한다. 그 이름에서 알 수 있듯이 핵심은 "표현(Representation)"과 "상태 전이(State Transfer)"이다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"RESTful API","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>RESTful API</h1><div class=post-description>REST는 네트워크 시스템, 특히 웹에서 자원을 정의하고 접근하는 방법을 제공한다. 그 이름에서 알 수 있듯이 핵심은 &ldquo;표현(Representation)&ldquo;과 &ldquo;상태 전이(State Transfer)&ldquo;이다.</div></header><div class=post-content><h2 id=restful-apirepresentational-state-transfer-api>RESTful API(Representational State Transfer API)<a hidden class=anchor aria-hidden=true href=#restful-apirepresentational-state-transfer-api>#</a></h2><p>REST는 2000년 로이 필딩(Roy Fielding)이 그의 박사 논문에서 처음 제시한 소프트웨어 아키텍처 스타일이다.<br>필딩은 HTTP의 주요 설계자 중 한 명으로, 웹의 기본 아키텍처를 정의하는 과정에서 REST 원칙을 발전시켰다.</p><p>REST는 네트워크 시스템, 특히 웹에서 자원을 정의하고 접근하는 방법을 제공한다. 그 이름에서 알 수 있듯이 핵심은 &ldquo;표현(Representation)&ldquo;과 &ldquo;상태 전이(State Transfer)&ldquo;이다.</p><ul><li><strong>표현(Representation)</strong>: 자원(Resource)의 특정 시점 상태를 표현한 정보이다. 이는 JSON, XML, HTML 등 다양한 형식으로 나타낼 수 있다.</li><li><strong>상태 전이(State Transfer)</strong>: 클라이언트가 서버와 통신하며 자원의 상태를 변경하는 과정이다.</li></ul><p>RESTful API는 웹의 기본 아키텍처를 활용하여 분산 시스템에서 자원에 접근하고 조작하는 일관된 방법을 제공한다.<br>제약 조건을 준수할수록 확장성, 유연성, 독립성이 향상되지만, 모든 상황에 완벽한 솔루션은 아니다.</p><p>REST 원칙을 이해하고, 적절한 상황에 적용하며, 필요할 때 다른 API 스타일(GraphQL, gRPC 등)과 함께 사용하는 것이 중요하다. 이러한 지식을 바탕으로 효율적이고 확장 가능한 웹 서비스를 설계하고 구현할 수 있을 것이다.</p><h3 id=rest의-6가지-제약-조건>REST의 6가지 제약 조건<a hidden class=anchor aria-hidden=true href=#rest의-6가지-제약-조건>#</a></h3><p>REST API를 진정한 의미에서 &ldquo;RESTful"하게 만들기 위해서는 다음 6가지 제약 조건을 준수해야 한다:</p><ol><li><p>클라이언트-서버 아키텍처(Client-Server Architecture)</p><ul><li>사용자 인터페이스와 데이터 저장을 분리해야 한다.</li><li>이를 통해 클라이언트와 서버는 독립적으로 진화할 수 있다.</li></ul></li><li><p>무상태성(Statelessness)</p><ul><li>각 요청에는 그 요청을 이해하는 데 필요한 모든 정보가 포함되어야 한다.</li><li>서버는 클라이언트의 세션 상태를 저장하지 않는다.</li><li>모든 상태 정보는 클라이언트가 관리한다.</li></ul></li><li><p>캐시 가능성(Cacheability)</p><ul><li>응답은 캐싱 가능 여부를 명시해야 한다.</li><li>효율적인 캐싱은 일부 클라이언트-서버 상호작용을 제거하여 성능을 향상시킨다.</li></ul></li><li><p>계층화 시스템(Layered System)</p><ul><li>클라이언트는 일반적으로 서버에 직접 연결되는지 중간 서버에 연결되는지 알 수 없다.</li><li>중간 계층(로드 밸런서, 프록시, 게이트웨이 등)은 확장성을 향상시키고 보안 정책을 적용할 수 있다.</li></ul></li><li><p>통일된 인터페이스(Uniform Interface)</p><ul><li>REST API의 가장 중요한 특징으로, 다음 네 가지 원칙으로 구성된다:<ul><li><strong>자원 식별(Resource Identification)</strong>: URI를 통해 자원을 고유하게 식별한다.</li><li><strong>표현을 통한 자원 조작(Manipulation of Resources Through Representations)</strong>: 클라이언트가 자원의 표현을 가지고 있다면, 서버상의 해당 자원을 수정할 권한이 있어야 한다.</li><li><strong>자기 서술적 메시지(Self-descriptive Messages)</strong>: 각 메시지는 자신을 어떻게 처리해야 하는지에 대한 정보를 포함해야 한다.</li><li><strong>애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS)</strong>: 클라이언트는 초기 URI 외에는 하드코딩된 URI를 사용하지 않고, 서버가 제공하는 링크를 통해 애플리케이션 내에서 상태 전이를 할 수 있어야 한다.</li></ul></li></ul></li><li><p>코드 온 디맨드(Code on Demand, 선택적)</p><ul><li>서버가 클라이언트에 실행 가능한 코드를 전송하여 기능을 확장할 수 있다.</li><li>이는 유일한 선택적 제약 조건이다(예: JavaScript).</li></ul></li></ol><h3 id=자원resources과-uri-설계>자원(Resources)과 URI 설계<a hidden class=anchor aria-hidden=true href=#자원resources과-uri-설계>#</a></h3><p>RESTful API에서 가장 기본적인 개념은 &ldquo;자원(Resource)&ldquo;이다.<br>자원은 명사로 표현되며, URI를 통해 식별된다.</p><h4 id=자원의-특성>자원의 특성<a hidden class=anchor aria-hidden=true href=#자원의-특성>#</a></h4><ul><li>자원은 개념적 대상(예: 사용자, 상품, 주문)이다.</li><li>자원은 단수 또는 복수 개념으로 존재할 수 있다.</li><li>자원은 다른 자원과 관계를 맺을 수 있다.</li></ul><h4 id=uri-설계-원칙>URI 설계 원칙<a hidden class=anchor aria-hidden=true href=#uri-설계-원칙>#</a></h4><ul><li><strong>자원을 명사로 표현</strong>: <code>/users</code>, <code>/products</code>, <code>/orders</code></li><li><strong>계층 관계 표현</strong>: <code>/users/123/orders</code></li><li><strong>복수형 사용</strong>: <code>/users</code> (단수형인 <code>/user</code> 대신)</li><li><strong>소문자 사용</strong>: <code>/users</code> (대문자인 <code>/Users</code> 대신)</li><li><strong>언더스코어(_) 대신 하이픈(-) 사용</strong>: <code>/order-items</code> (언더스코어인 <code>/order_items</code> 대신)</li><li><strong>파일 확장자 사용 자제</strong>: <code>/users</code> (확장자 있는 <code>/users.json</code> 대신)</li><li><strong>행위(동사)는 URI에 포함시키지 않음</strong>: <code>/users</code> (동사 포함한 <code>/getUsers</code> 대신)</li></ul><h3 id=http-메서드와-crud-연산>HTTP 메서드와 CRUD 연산<a hidden class=anchor aria-hidden=true href=#http-메서드와-crud-연산>#</a></h3><p>RESTful API는 HTTP 메서드를 사용하여 자원에 대한 CRUD(Create, Read, Update, Delete) 연산을 수행한다.</p><h4 id=주요-http-메서드>주요 HTTP 메서드<a hidden class=anchor aria-hidden=true href=#주요-http-메서드>#</a></h4><ul><li><strong>GET</strong>: 자원을 조회한다 (Read).<ul><li>예: <code>GET /users/123</code> - ID가 123인 사용자 정보 조회</li><li>데이터를 변경하지 않는 안전한(safe) 요청이어야 한다.</li><li>여러 번 호출해도 동일한 결과를 반환하는 멱등성(idempotent)을 가진다.</li></ul></li><li><strong>POST</strong>: 새 자원을 생성한다 (Create).<ul><li>예: <code>POST /users</code> - 새 사용자 생성</li><li>요청 본문(body)에 생성할 자원의 내용을 포함한다.</li><li>멱등성을 가지지 않는다(여러 번 호출하면 여러 자원이 생성됨).</li></ul></li><li><strong>PUT</strong>: 자원을 수정하거나 없으면 생성한다 (Update/Create).<ul><li>예: <code>PUT /users/123</code> - ID가 123인 사용자 정보 업데이트</li><li>멱등성을 가집니다(같은 요청을 여러 번 해도 결과는 동일).</li><li>요청에 자원의 전체 표현이 포함되어야 한다.</li></ul></li><li><strong>PATCH</strong>: 자원의 일부를 수정한다 (Partial Update).<ul><li>예: <code>PATCH /users/123</code> - ID가 123인 사용자의 일부 정보만 업데이트</li><li>요청에는 변경할 필드만 포함한다.</li><li>일반적으로 멱등성을 가진다(구현에 따라 다를 수 있음).</li></ul></li><li><strong>DELETE</strong>: 자원을 삭제한다 (Delete).<ul><li>예: <code>DELETE /users/123</code> - ID가 123인 사용자 삭제</li><li>멱등성을 가집니다(여러 번 호출해도 결과는 동일).</li></ul></li></ul><h4 id=기타-http-메서드>기타 HTTP 메서드<a hidden class=anchor aria-hidden=true href=#기타-http-메서드>#</a></h4><ul><li><strong>HEAD</strong>: GET과 동일하지만 응답 본문 없이 헤더만 반환한다.</li><li><strong>OPTIONS</strong>: 자원에 대해 사용 가능한 HTTP 메서드를 반환한다.</li></ul><h3 id=http-상태-코드>HTTP 상태 코드<a hidden class=anchor aria-hidden=true href=#http-상태-코드>#</a></h3><p>RESTful API는 표준 HTTP 상태 코드를 사용하여 요청의 결과를 나타낸다.<br>상태 코드는 클라이언트가 요청의 성공 여부와 다음 조치를 이해하는 데 중요하다.</p><h4 id=주요-http-상태-코드-범주>주요 HTTP 상태 코드 범주<a hidden class=anchor aria-hidden=true href=#주요-http-상태-코드-범주>#</a></h4><ul><li><strong>1xx (정보)</strong>: 요청이 수신되어 처리 중이다.</li><li><strong>2xx (성공)</strong>: 요청이 성공적으로 처리되었다.</li><li><strong>3xx (리다이렉션)</strong>: 요청 완료를 위해 추가 조치가 필요하다.</li><li><strong>4xx (클라이언트 오류)</strong>: 요청에 오류가 있어 처리할 수 없다.</li><li><strong>5xx (서버 오류)</strong>: 서버가 유효한 요청을 처리하지 못했다.</li></ul><h4 id=자주-사용되는-상태-코드>자주 사용되는 상태 코드<a hidden class=anchor aria-hidden=true href=#자주-사용되는-상태-코드>#</a></h4><ul><li><strong>200 OK</strong>: 요청이 성공했다.</li><li><strong>201 Created</strong>: 자원이 성공적으로 생성되었다.</li><li><strong>204 No Content</strong>: 요청은 성공했지만 반환할 콘텐츠가 없다.</li><li><strong>400 Bad Request</strong>: 요청 구문이 잘못되었다.</li><li><strong>401 Unauthorized</strong>: 인증이 필요하다.</li><li><strong>403 Forbidden</strong>: 권한이 없다.</li><li><strong>404 Not Found</strong>: 요청한 자원을 찾을 수 없다.</li><li><strong>405 Method Not Allowed</strong>: 해당 자원에 대해 요청한 메서드가 허용되지 않는다.</li><li><strong>409 Conflict</strong>: 요청이 현재 서버 상태와 충돌한다.</li><li><strong>500 Internal Server Error</strong>: 서버에 오류가 발생했다.</li></ul><h3 id=미디어-타입과-콘텐츠-협상>미디어 타입과 콘텐츠 협상<a hidden class=anchor aria-hidden=true href=#미디어-타입과-콘텐츠-협상>#</a></h3><p>RESTful API에서는 다양한 형식으로 자원을 표현할 수 있으며, 클라이언트와 서버 간의 &lsquo;콘텐츠 협상(Content Negotiation)&lsquo;을 통해 가장 적합한 표현을 선택한다.</p><h4 id=주요-미디어-타입>주요 미디어 타입<a hidden class=anchor aria-hidden=true href=#주요-미디어-타입>#</a></h4><ul><li><strong>application/json</strong>: JSON 형식 (현대 웹 API에서 가장 흔히 사용)</li><li><strong>application/xml</strong>: XML 형식</li><li><strong>application/hal+json</strong>: Hypertext Application Language, 하이퍼미디어 제약조건 지원</li><li><strong>application/vnd.api+json</strong>: JSON API 규격</li><li><strong>text/html</strong>: HTML 형식</li></ul><h4 id=콘텐츠-협상-방법>콘텐츠 협상 방법<a hidden class=anchor aria-hidden=true href=#콘텐츠-협상-방법>#</a></h4><ul><li><strong>클라이언트가 요청 헤더로 선호하는 형식 지정</strong>:<ul><li><code>Accept: application/json</code></li><li><code>Accept-Language: ko-KR</code></li></ul></li><li><strong>서버가 응답 헤더로 제공하는 형식 명시</strong>:<ul><li><code>Content-Type: application/json; charset=utf-8</code></li></ul></li></ul><h3 id=하이퍼미디어와-hateoas>하이퍼미디어와 HATEOAS<a hidden class=anchor aria-hidden=true href=#하이퍼미디어와-hateoas>#</a></h3><p>HATEOAS(Hypermedia as the Engine of Application State)는 REST의 성숙도 모델에서 가장 높은 수준으로, 클라이언트가 API를 탐색할 수 있는 링크를 제공한다.</p><h4 id=hateoas의-핵심-개념>HATEOAS의 핵심 개념<a hidden class=anchor aria-hidden=true href=#hateoas의-핵심-개념>#</a></h4><ul><li>클라이언트는 API 엔드포인트의 URI를 하드코딩하지 않는다.</li><li>서버는 응답에 관련 자원으로의 링크를 포함한다.</li><li>클라이언트는 이 링크를 통해 API를 동적으로 탐색한다.</li></ul><h4 id=hateoas-예시-json-형식>HATEOAS 예시 (JSON 형식)<a hidden class=anchor aria-hidden=true href=#hateoas-예시-json-형식>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=mi>123</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;John Doe&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;email&#34;</span><span class=p>:</span> <span class=s2>&#34;john@example.com&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;_links&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;self&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;href&#34;</span><span class=p>:</span> <span class=s2>&#34;/users/123&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;orders&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;href&#34;</span><span class=p>:</span> <span class=s2>&#34;/users/123/orders&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;update&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;href&#34;</span><span class=p>:</span> <span class=s2>&#34;/users/123&#34;</span><span class=p>,</span> <span class=nt>&#34;method&#34;</span><span class=p>:</span> <span class=s2>&#34;PUT&#34;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;delete&#34;</span><span class=p>:</span> <span class=p>{</span> <span class=nt>&#34;href&#34;</span><span class=p>:</span> <span class=s2>&#34;/users/123&#34;</span><span class=p>,</span> <span class=nt>&#34;method&#34;</span><span class=p>:</span> <span class=s2>&#34;DELETE&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=보안>보안<a hidden class=anchor aria-hidden=true href=#보안>#</a></h3><p>RESTful API의 보안은 여러 계층에서 구현될 수 있다.</p><h4 id=인증authentication-방법>인증(Authentication) 방법<a hidden class=anchor aria-hidden=true href=#인증authentication-방법>#</a></h4><ul><li><strong>API 키</strong>: 요청에 API 키를 포함시켜 클라이언트를 식별한다.</li><li><strong>OAuth 2.0</strong>: 사용자 자격 증명 없이 API에 안전하게 액세스할 수 있는 토큰 기반 인증이다.</li><li><strong>JWT(JSON Web Tokens)</strong>: 클레임을 안전하게 전송할 수 있는 컴팩트한 토큰 형식이다.</li><li><strong>기본 인증(Basic Auth)</strong>: 사용자 이름과 비밀번호를 Base64로 인코딩하여 전송한다.</li></ul><h4 id=권한-부여authorization>권한 부여(Authorization)<a hidden class=anchor aria-hidden=true href=#권한-부여authorization>#</a></h4><ul><li>인증된 사용자가 특정 자원에 접근하거나 특정 작업을 수행할 수 있는 권한을 확인한다.</li><li>역할 기반(Role-based)이나 속성 기반(Attribute-based) 접근 제어를 구현할 수 있다.</li></ul><h4 id=기타-보안-고려사항>기타 보안 고려사항<a hidden class=anchor aria-hidden=true href=#기타-보안-고려사항>#</a></h4><ul><li><strong>HTTPS 사용</strong>: 모든 API 통신은 TLS/SSL을 통해 암호화되어야 한다.</li><li><strong>요청 제한(Rate Limiting)</strong>: 과도한 요청을 방지하기 위해 클라이언트당 API 호출 횟수를 제한한다.</li><li><strong>CORS(Cross-Origin Resource Sharing)</strong>: 브라우저 기반 클라이언트를 위한 보안 정책이다.</li><li><strong>입력 검증</strong>: 모든 클라이언트 입력은 서버 측에서 검증되어야 한다.</li></ul><h3 id=api-버전-관리>API 버전 관리<a hidden class=anchor aria-hidden=true href=#api-버전-관리>#</a></h3><p>API가 진화함에 따라 기존 클라이언트의 호환성을 유지하면서 새로운 기능을 추가할 수 있는 버전 관리가 중요하다.</p><h4 id=버전-관리-접근법>버전 관리 접근법<a hidden class=anchor aria-hidden=true href=#버전-관리-접근법>#</a></h4><ul><li><strong>URI 경로</strong>: <code>/api/v1/users</code>, <code>/api/v2/users</code></li><li><strong>쿼리 파라미터</strong>: <code>/api/users?version=1</code></li><li><strong>HTTP 헤더</strong>: <code>Accept: application/vnd.company.api+json;version=1</code></li><li><strong>콘텐츠 협상</strong>: <code>Accept: application/vnd.company.v1+json</code></li></ul><p>각 방식에는 장단점이 있으므로, 프로젝트 요구사항에 가장 적합한 방식을 선택해야 한다.</p><h3 id=문서화>문서화<a hidden class=anchor aria-hidden=true href=#문서화>#</a></h3><p>좋은 API 문서는 개발자가 API를 효과적으로 사용하는 데 필수적이다.</p><h4 id=api-문서화-도구>API 문서화 도구<a hidden class=anchor aria-hidden=true href=#api-문서화-도구>#</a></h4><ul><li><strong>Swagger/OpenAPI</strong>: API 설계, 구축, 문서화, 소비를 돕는 규격과 도구 세트.</li><li><strong>RAML(RESTful API Modeling Language)</strong>: API 설계를 위한 YAML 기반의 언어.</li><li><strong>API Blueprint</strong>: API 문서화를 위한 마크다운 기반 언어.</li><li><strong>Postman</strong>: API 테스트 및 문서화를 위한 강력한 도구.</li></ul><h4 id=문서화-모범-사례>문서화 모범 사례<a hidden class=anchor aria-hidden=true href=#문서화-모범-사례>#</a></h4><ul><li>각 엔드포인트의 목적을 명확히 설명한다.</li><li>필요한 파라미터와 응답 형식을 자세히 기술한다.</li><li>예제 요청과 응답을 포함한다.</li><li>오류 조건과 상태 코드를 문서화한다.</li><li>인증 요구사항을 명확히 설명한다.</li></ul><h3 id=rest-성숙도-모델richardson-maturity-model>REST 성숙도 모델(Richardson Maturity Model)<a hidden class=anchor aria-hidden=true href=#rest-성숙도-모델richardson-maturity-model>#</a></h3><p>레오나르드 리처드슨(Leonard Richardson)이 제안한 REST API의 성숙도 모델은 4단계로 구성된다:</p><h4 id=레벨-0-http를-전송-메커니즘으로만-사용>레벨 0: HTTP를 전송 메커니즘으로만 사용<a hidden class=anchor aria-hidden=true href=#레벨-0-http를-전송-메커니즘으로만-사용>#</a></h4><ul><li>단일 URI와 단일 HTTP 메서드(보통 POST)만 사용한다.</li><li>SOAP이나 XML-RPC와 유사하다.</li></ul><h4 id=레벨-1-자원resources>레벨 1: 자원(Resources)<a hidden class=anchor aria-hidden=true href=#레벨-1-자원resources>#</a></h4><ul><li>다양한 URI를 통해 개별 자원을 식별한다.</li><li>여전히 단일 HTTP 메서드에 의존한다.</li></ul><h4 id=레벨-2-http-동사>레벨 2: HTTP 동사<a hidden class=anchor aria-hidden=true href=#레벨-2-http-동사>#</a></h4><ul><li>다양한 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 자원을 조작한다.</li><li>HTTP 상태 코드를 적절히 사용한다.</li></ul><h4 id=레벨-3-하이퍼미디어-제어hateoas>레벨 3: 하이퍼미디어 제어(HATEOAS)<a hidden class=anchor aria-hidden=true href=#레벨-3-하이퍼미디어-제어hateoas>#</a></h4><ul><li>응답에 관련 자원으로의 링크를 포함한다.</li><li>클라이언트가 API를 동적으로 탐색할 수 있다.</li></ul><p>많은 현대 API는 레벨 2에 해당하며, 레벨 3(HATEOAS)는 완전한 RESTful API를 위한 요구사항이지만 실제로 구현하기 어려운 경우가 많다.</p><h3 id=rest-api-설계-모범-사례>REST API 설계 모범 사례<a hidden class=anchor aria-hidden=true href=#rest-api-설계-모범-사례>#</a></h3><ol><li><p>자원 식별과 URI 디자인</p><ul><li>명사 기반 자원 표현을 사용한다.</li><li>일관된 복수형 명명 규칙을 유지한다.</li><li>계층적 관계를 URI에 반영한다.</li></ul></li><li><p>메서드 사용</p><ul><li>HTTP 메서드의 의미에 맞게 API를 설계한다.</li><li>멱등성과 안전성을 고려한다.</li><li>특수 작업은 하위 자원으로 모델링한다(예: <code>/users/123/activate</code>).</li></ul></li><li><p>상태 코드</p><ul><li>표준 HTTP 상태 코드를 사용한다.</li><li>오류 응답에 의미 있는 메시지를 포함한다.</li></ul></li><li><p>페이지네이션, 필터링, 정렬</p><ul><li>컬렉션 자원에 페이지네이션을 구현한다(예: <code>?page=2&amp;size=10</code>).</li><li>필터링을 위한 쿼리 파라미터를 제공한다(예: <code>?status=active</code>).</li><li>정렬을 위한 파라미터를 지원한다(예: <code>?sort=name,asc</code>).</li></ul></li><li><p>응답 형식</p><ul><li>일관된 응답 구조를 유지한다.</li><li>필요한 메타데이터를 포함한다.</li><li>오류 응답을 표준화한다.</li></ul></li><li><p>성능 최적화</p><ul><li>적절한 캐싱 헤더를 사용한다.</li><li>필요한 데이터만 반환하도록 최적화한다.</li><li>압축(gzip, deflate)을 사용한다.</li></ul></li></ol><h3 id=rest-api와-다른-api-스타일-비교>REST API와 다른 API 스타일 비교<a hidden class=anchor aria-hidden=true href=#rest-api와-다른-api-스타일-비교>#</a></h3><h4 id=rest-vs-soap>REST vs. SOAP<a hidden class=anchor aria-hidden=true href=#rest-vs-soap>#</a></h4><ul><li><strong>형식</strong>: REST는 주로 JSON, SOAP는 XML만 사용한다.</li><li><strong>프로토콜</strong>: REST는 HTTP에 의존, SOAP는 여러 프로토콜(HTTP, SMTP 등)을 지원한다.</li><li><strong>통신</strong>: REST는 주로 비동기적, SOAP는 동기적이다.</li><li><strong>캐싱</strong>: REST는 쉽게 캐싱 가능, SOAP는 제한적이다.</li><li><strong>보안</strong>: SOAP는 WS-Security와 같은 내장 표준이 있고, REST는 더 다양한 방식을 사용한다.</li></ul><h4 id=rest-vs-graphql>REST vs. GraphQL<a hidden class=anchor aria-hidden=true href=#rest-vs-graphql>#</a></h4><ul><li><strong>엔드포인트</strong>: REST는 여러 엔드포인트, GraphQL은 주로 단일 엔드포인트를 사용한다.</li><li><strong>데이터 가져오기</strong>: REST는 서버가 정의한 응답 구조, GraphQL은 클라이언트가 필요한 데이터를 정확히 지정할 수 있다.</li><li><strong>버전 관리</strong>: REST는 명시적인 버전 관리가 필요, GraphQL은 필드 수준 버전 관리가 가능하다.</li><li><strong>오버페칭/언더페칭</strong>: REST는 이런 문제가 발생할 수 있으나, GraphQL은 이를 해결하도록 설계되었다.</li></ul><h4 id=rest-vs-grpc>REST vs. gRPC<a hidden class=anchor aria-hidden=true href=#rest-vs-grpc>#</a></h4><ul><li><strong>프로토콜</strong>: REST는 HTTP/1.1, gRPC는 HTTP/2를 사용한다.</li><li><strong>데이터 형식</strong>: REST는 주로 JSON, gRPC는 Protocol Buffers를 사용한다.</li><li><strong>코드 생성</strong>: gRPC는 강력한 코드 생성 기능을 제공한다.</li><li><strong>스트리밍</strong>: gRPC는 양방향 스트리밍에 뛰어나다.</li><li><strong>성능</strong>: gRPC가 일반적으로 더 효율적이고 빠르다.</li></ul><h3 id=restful-api의-한계>RESTful API의 한계<a hidden class=anchor aria-hidden=true href=#restful-api의-한계>#</a></h3><p>REST가 많은 장점을 제공하지만, 몇 가지 한계와 도전 과제도 있다:</p><ol><li><p>오버페칭과 언더페칭</p><ul><li>클라이언트가 필요한 데이터보다 많거나 적은 데이터를 받을 수 있다.</li><li>여러 관련 자원을 조회하려면 여러 API 호출이 필요할 수 있다.</li></ul></li><li><p>문서화 표준 부족</p><ul><li>REST 자체는 API 문서화를 위한 표준 방식을 정의하지 않는다.</li><li>OpenAPI와 같은 도구가 이 문제를 해결하기 위해 등장했다.</li></ul></li><li><p>복잡한 트랜잭션</p><ul><li>여러 자원에 걸친 트랜잭션 처리는 REST에서 자연스럽게 지원되지 않는다.</li></ul></li><li><p>HATEOAS 구현의 어려움</p><ul><li>완전한 HATEOAS 구현은 복잡하고 많은 오버헤드를 발생시킬 수 있다.</li></ul></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><p><a href=https://leapcell.io/blog/restful-api-principles-design-and-best-practices>RESTful API: Principles, Design, and Best Practices | Leapcell</a></p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Handling CRUD Operations</h2></header><div class=entry-content><p>Handling CRUD Operations CRUD는 데이터 중심 애플리케이션에서 가장 기본적인 네 가지 작업인 생성(Create), 읽기(Read), 업데이트(Update), 삭제(Delete)를 의미한다.
이러한 작업은 데이터베이스, API 디자인, 애플리케이션 개발 등 다양한 분야에서 핵심적인 역할을 한다.
RESTful API에서 CRUD 작업 처리는 API 설계의 핵심이다. 표준 HTTP 메서드와 상태 코드를 활용하고, 자원 모델링, 엔드포인트 설계, 보안, 에러 핸들링 등 다양한 요소를 고려하여 효율적이고 안정적인 API를 구축해야 한다. 또한, 전통적인 CRUD 방식의 문제점을 인식하고, Get-and-Set, Get-and-Patch, Timestamp-Checked와 같은 대안을 고려하여 API의 유연성과 확장성을 높일 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-26 02:51:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Handling CRUD Operations" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Error Handling</h2></header><div class=entry-content><p>Error Handling RESTful API의.오류 처리는 개발자 경험과 시스템 안정성에 중요한 영향을 미치는 핵심 요소이다.
오류 상황을 어떻게 다루고 전달하는지에 따라 API의 품질이 크게 달라질 수 있다.
HTTP 상태 코드의 올바른 활용 HTTP 상태 코드는 클라이언트에게 요청 처리 결과를 전달하는 표준화된 방법이다.
오류 상황에서 적절한 상태 코드를 반환하는 것이 중요하다.
주요 오류 상태 코드 카테고리 4xx (클라이언트 오류): 클라이언트 측의 문제로 인한 오류 400 Bad Request: 요청 구문이 잘못되었거나 유효하지 않은 요청 401 Unauthorized: 인증되지 않은 요청 403 Forbidden: 권한이 없는 요청 404 Not Found: 요청한 리소스를 찾을 수 없음 405 Method Not Allowed: 허용되지 않은 HTTP 메서드 409 Conflict: 리소스 상태와 충돌 415 Unsupported Media Type: 지원하지 않는 미디어 타입 422 Unprocessable Entity: 유효성 검사 실패 5xx (서버 오류): 서버 측의 문제로 인한 오류 500 Internal Server Error: 서버 내부 오류 502 Bad Gateway: 게이트웨이 오류 503 Service Unavailable: 서비스 일시적 사용 불가 504 Gateway Timeout: 게이트웨이 타임아웃 상태 코드를 선택할 때는 상황에 가장 정확하게 맞는 코드를 사용해야 한다. 예를 들어, 사용자 인증이 필요한 경우 403(Forbidden)이 아닌 401(Unauthorized)을 사용하는 것이 적절하다.
...</p></div><footer class=entry-footer><span title='2025-02-26 02:49:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Error Handling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/error-handling/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>