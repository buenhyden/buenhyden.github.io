<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Web Socket vs. Long Polling | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,Real-time-APIs,Types,WebSocket-API"><meta name=description content="WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Web Socket vs. Long Polling"><meta property="og:description" content="WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-09T02:31:00+00:00"><meta property="article:modified_time" content="2025-03-09T02:31:00+00:00"><meta property="article:tag" content="Backend-Development"><meta property="article:tag" content="API-Design-and-Implementation"><meta property="article:tag" content="Real-Time-APIs"><meta property="article:tag" content="Types"><meta property="article:tag" content="WebSocket-API"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Web Socket vs. Long Polling"><meta name=twitter:description content="WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend Development","item":"https://buenhyden.github.io/posts/backend-development/"},{"@type":"ListItem","position":3,"name":"API Design and Implementation","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/"},{"@type":"ListItem","position":4,"name":"API Styles","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/"},{"@type":"ListItem","position":5,"name":"Event-based Style","item":""},{"@type":"ListItem","position":6,"name":"WebSocket","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/"},{"@type":"ListItem","position":7,"name":"Web Socket vs. Long Polling","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Web Socket vs. Long Polling","name":"Web Socket vs. Long Polling","description":"WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다.","keywords":["Backend-Development","API-Design-and-Implementation","Real-time-APIs","Types","WebSocket-API"],"articleBody":"Web Socket vs. Long Polling 실시간 웹 통신은 현대 웹 애플리케이션의 핵심 요소로 자리 잡았다. 사용자들은 새로고침 없이 즉시 정보를 받아보기를 기대하며, 이러한 기대를 충족시키기 위해 여러 기술이 발전해왔다. 그중에서도 Long Polling과 WebSocket은 실시간 통신을 구현하는 대표적인 방식으로, 각각의 특징과 적용 사례가 다르다.\n기본 개념 WebSocket WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. 초기 HTTP 핸드셰이크 후 연결이 WebSocket 프로토콜로 업그레이드되어, 서버와 클라이언트 간에 지속적이고 양방향 통신이 가능해진다. 연결이 한 번 수립되면 두 방향으로 동시에 데이터를 주고받을 수 있으며, 별도의 요청 없이도 서버가 클라이언트에 데이터를 푸시할 수 있다.\nLong Polling Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다. 새 데이터가 생기거나 타임아웃이 발생하면 서버가 응답을 완료하고, 클라이언트는 즉시 새로운 요청을 시작한다. 이는 전통적인 Short Polling보다 지연 시간을 줄이고 불필요한 요청을 감소시킨다.\n작동 메커니즘 WebSocket 작동 원리 클라이언트는 HTTP 요청으로 WebSocket 연결을 시작한다(Upgrade: websocket 헤더 포함). 서버가 이 요청을 수락하면 HTTP 연결이 WebSocket 프로토콜로 업그레이드된다. 이후 양쪽은 동일한 TCP 연결을 통해 데이터 프레임을 자유롭게 주고받을 수 있다. 연결은 명시적으로 종료되기 전까지 지속된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // WebSocket 클라이언트 예시 const socket = new WebSocket('ws://example.com/socket'); socket.onopen = function(event) { console.log('웹소켓 연결이 열렸습니다.'); socket.send('클라이언트에서 서버로 메시지 전송'); }; socket.onmessage = function(event) { console.log('서버에서 메시지 받음:', event.data); }; socket.onclose = function(event) { console.log('웹소켓 연결이 닫혔습니다.'); }; Long Polling 작동 원리 클라이언트가 서버에 HTTP 요청을 보낸다. 서버는 새 데이터가 있으면 즉시 응답하고, 없으면 이벤트가 발생하거나 타임아웃될 때까지 응답을 보류한다. 응답을 받은 클라이언트는 데이터를 처리한 후 즉시 새로운 요청을 시작한다. 이 과정이 계속 반복된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Long Polling 클라이언트 예시 function longPoll() { fetch('/api/events') .then(response =\u003e response.json()) .then(data =\u003e { console.log('서버에서 데이터 받음:', data); // 데이터 처리 후 즉시 다음 요청 시작 longPoll(); }) .catch(error =\u003e { console.error('에러 발생:', error); // 에러 발생 시 잠시 대기 후 재시도 setTimeout(longPoll, 5000); }); } // Long Polling 시작 longPoll(); 프로토콜 및 기술적 특성 WebSocket 프로토콜: ws:// 또는 wss://(보안) 프로토콜 사용 연결 방식: 지속적인 양방향 연결 메시지 형식: 이진 프레임 또는 텍스트 프레임 상태 관리: 연결 상태를 유지하며, 연결 종료 시 특별한 종료 프레임 사용 헤더 오버헤드: 초기 핸드셰이크 이후 매우 적음 (2-14 바이트의 프레임 헤더) Long Polling 프로토콜: 표준 HTTP 프로토콜 사용 연결 방식: 요청-응답 패턴의 확장(응답 지연) 메시지 형식: HTTP 응답 (JSON, XML 등) 상태 관리: 각 요청은 독립적이며, 서버가 클라이언트 상태를 추적해야 함 헤더 오버헤드: 매 요청마다 완전한 HTTP 헤더 포함 (수백 바이트) 성능 비교 지연 시간\nWebSocket: 연결이 이미 수립되어 있어 메시지 전달 지연이 최소화된다. Long Polling: 서버 이벤트 발생 시 즉시 응답하지만, 응답 후 새 요청을 설정하는 시간만큼 지연이 발생한다. 네트워크 효율성\nWebSocket: 헤더 오버헤드가 적어 데이터 전송이 효율적이며, 불필요한 연결 재설정이 없다. Long Polling: 각 메시지마다 새로운 HTTP 요청이 필요하여 헤더 오버헤드가 크고, 연결 설정에 추가 비용이 발생한다. 서버 부하\nWebSocket: 지속적인 연결 유지로 메모리 사용량이 증가하지만, CPU 사용량은 메시지 전송 시에만 발생한다. Long Polling: 연결 설정/해제가 자주 발생하여 CPU 부하가 높을 수 있으며, 활성 연결도 리소스를 소비한다. 확장성\nWebSocket: 동시 연결 수에 따라 서버 메모리 사용량이 증가하므로, 대규모 확장에는 특별한 관리가 필요하다. Long Polling: 요청-응답 주기로 인해 대규모 사용자에 대한 확장이 어려울 수 있으며, 서버 리소스 점유 문제가 있다. 구현 및 호환성 개발 복잡성\nWebSocket: 클라이언트와 서버 모두 WebSocket 프로토콜을 구현해야 하며, 연결 관리와 오류 처리가 필요하다. Long Polling: 표준 HTTP를 기반으로 하므로 상대적으로 구현이 간단하지만, 요청 타임아웃 관리와 연결 상태 추적이 필요하다. 브라우저 지원\nWebSocket: 현대 브라우저에서는 거의 대부분 지원하지만, 일부 오래된 브라우저나 제한된 환경에서는 사용할 수 없을 수 있다. Long Polling: 모든 브라우저에서 완벽하게 지원된다. 네트워크 인프라 호환성\nWebSocket: 일부 프록시, 방화벽, 로드 밸런서는 WebSocket 연결을 차단하거나 제대로 처리하지 못할 수 있다. Long Polling: HTTP 기반이므로 대부분의 네트워크 인프라와 호환된다. 사용 사례 비교 WebSocket 적합 사례 실시간 양방향 통신이 빈번하게 필요한 애플리케이션(온라인 게임, 협업 도구) 낮은 지연 시간이 중요한 실시간 대시보드, 모니터링 시스템 채팅 애플리케이션, 실시간 알림 시스템 주식 거래 플랫폼, 스포츠 중계 등 실시간 데이터 스트리밍 Long Polling 적합 사례 WebSocket을 지원하지 않는 환경을 위한 폴백 메커니즘 메시지 교환이 비교적 드물게 발생하는 시스템 서버에서 클라이언트로의 단방향 알림 위주의 애플리케이션 기존 HTTP 인프라를 활용해야 하는 레거시 시스템 통합 비교 특성 WebSocket Long Polling 프로토콜 별도의 ws:// 또는 wss:// 프로토콜 표준 HTTP 프로토콜 연결 유형 지속적인 양방향 연결 긴 요청-응답 사이클 통신 방향 전이중(Full-duplex) 반이중(Half-duplex) 헤더 오버헤드 초기 핸드셰이크 후 매우 적음 매 요청마다 완전한 HTTP 헤더 실시간성 매우 높음 (밀리초 단위 지연) 중간~높음 (이벤트 발생 시 지연) 서버 푸시 기본 지원 유사하게 구현 가능 메시지 크기 적합 (최대 프레임 크기 한계 있음) 무제한 (HTTP 응답 크기) 연결 상태 명시적 열림/닫힘 상태 관리 각 요청마다 새로운 연결 브라우저 지원 현대 브라우저에서 대부분 지원 모든 브라우저 지원 네트워크 호환성 일부 프록시, 방화벽에서 문제 발생 가능 높은 호환성 네트워크 효율성 높음 (헤더 오버헤드 적음) 중간 (반복적인 HTTP 요청) 확장성 연결당 메모리 사용, 효율적인 관리 필요 동시 연결 처리에 서버 부하 구현 복잡성 중간~높음 (프로토콜 구현, 상태 관리) 중간 (타임아웃, 재연결 관리) 보안 wss:// (WebSocket Secure) https:// (표준 암호화) 방화벽 통과 일부 제한적 대부분 허용 에러 복구 연결 끊김 감지 및 재연결 필요 매 요청 실패 시 재시도 가능 양방향 메시징 효율적 가능하나 비효율적 리소스 사용 지속 연결로 메모리 사용량 높음 연결 수립/해제로 CPU 사용량 높음 적합한 사용 사례 실시간 게임, 채팅, 협업 도구 간헐적 알림, 단방향 업데이트 기존 인프라 활용 새로운 인프라 필요 가능성 기존 HTTP 인프라 활용 스케일링 전략 클러스터링, 연결 부하 분산 수평적 확장, 세션 공유 개발 접근성 클라이언트와 서버 측 모두 구현 필요 기존 HTTP 지식으로 구현 가능 실제 사용 사례 연구 WebSocket 사용 사례: 실시간 협업 도구 Google Docs와 같은 실시간 문서 협업 도구는 WebSocket을 활용하여 여러 사용자의 동시 편집을 지원한다. 문서 변경이 발생할 때마다 양방향 통신을 통해 즉각적으로 모든 참여자에게 변경 사항이 전달되어 실시간 협업이 가능해진다.\nLong Polling 사용 사례: 웹 기반 알림 시스템 이메일 서비스의 새 메일 알림과 같은 시스템은 Long Polling으로 구현될 수 있다. 브라우저가 서버에 새 메일이 있는지 요청하고, 서버는 새 메일이 도착하거나 타임아웃이 발생할 때까지 응답을 보류한다.\n하이브리드 접근법 많은 현대 애플리케이션은 WebSocket을 기본으로 사용하되, WebSocket을 지원하지 않는 환경을 위해 Long Polling을 폴백(fallback) 메커니즘으로 구현한다. Socket.IO와 같은 라이브러리는 이러한 하이브리드 접근법을 자동으로 관리해 개발자가 통합된 API를 통해 실시간 기능을 구현할 수 있게 한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Socket.IO 클라이언트 예시 (WebSocket 우선, Long Polling 폴백) const socket = io('https://example.com', { transports: ['websocket', 'polling'] }); socket.on('connect', () =\u003e { console.log('서버에 연결됨'); }); socket.on('news', (data) =\u003e { console.log('새로운 뉴스:', data); socket.emit('response', { feedback: '받았습니다' }); }); 용어 정리 용어 설명 폴백(fallback) 메커니즘 폴백(Fallback) 메커니즘은 시스템이 정상적으로 작동하지 않을 경우 대체 기능이나 경로를 제공하는 설계 방식을 의미한다. 이는 예상치 못한 오류나 실패 상황에서 시스템의 안정성을 유지하고 사용자 경험을 개선하기 위해 사용된다. 특히 네트워크 통신, API 호출, 데이터 처리 등 다양한 분야에서 널리 활용된다. 참고 및 출처 ","wordCount":"1121","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-03-09T02:31:00Z","dateModified":"2025-03-09T02:31:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/>Backend Development</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/>API Design and Implementation</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/>API Styles</a>&nbsp;»&nbsp;<a href>Event-based Style</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/>WebSocket</a></div><h1 class="post-title entry-hint-parent">Web Socket vs. Long Polling</h1><div class=post-description>WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다.</div><div class=post-meta><span title='2025-03-09 02:31:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend%20Development/API%20Design%20and%20Implementation/API%20Styles/Event-based%20Style/WebSocket/web-socket-vs-long-polling.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#web-socket-vs-long-polling>Web Socket vs. Long Polling</a><ul><li><a href=#기본-개념>기본 개념</a></li><li><a href=#작동-메커니즘>작동 메커니즘</a></li><li><a href=#프로토콜-및-기술적-특성>프로토콜 및 기술적 특성</a></li><li><a href=#성능-비교>성능 비교</a></li><li><a href=#구현-및-호환성>구현 및 호환성</a></li><li><a href=#사용-사례-비교>사용 사례 비교</a></li><li><a href=#비교>비교</a></li><li><a href=#실제-사용-사례-연구>실제 사용 사례 연구</a></li><li><a href=#하이브리드-접근법>하이브리드 접근법</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=web-socket-vs-long-polling>Web Socket vs. Long Polling<a hidden class=anchor aria-hidden=true href=#web-socket-vs-long-polling>#</a></h2><p>실시간 웹 통신은 현대 웹 애플리케이션의 핵심 요소로 자리 잡았다. 사용자들은 새로고침 없이 즉시 정보를 받아보기를 기대하며, 이러한 기대를 충족시키기 위해 여러 기술이 발전해왔다. 그중에서도 Long Polling과 WebSocket은 실시간 통신을 구현하는 대표적인 방식으로, 각각의 특징과 적용 사례가 다르다.</p><h3 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h3><h4 id=websocket>WebSocket<a hidden class=anchor aria-hidden=true href=#websocket>#</a></h4><p>WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. 초기 HTTP 핸드셰이크 후 연결이 WebSocket 프로토콜로 업그레이드되어, 서버와 클라이언트 간에 지속적이고 양방향 통신이 가능해진다. 연결이 한 번 수립되면 두 방향으로 동시에 데이터를 주고받을 수 있으며, 별도의 요청 없이도 서버가 클라이언트에 데이터를 푸시할 수 있다.</p><h4 id=long-polling>Long Polling<a hidden class=anchor aria-hidden=true href=#long-polling>#</a></h4><p>Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다. 새 데이터가 생기거나 타임아웃이 발생하면 서버가 응답을 완료하고, 클라이언트는 즉시 새로운 요청을 시작한다. 이는 전통적인 Short Polling보다 지연 시간을 줄이고 불필요한 요청을 감소시킨다.</p><h3 id=작동-메커니즘>작동 메커니즘<a hidden class=anchor aria-hidden=true href=#작동-메커니즘>#</a></h3><h4 id=websocket-작동-원리>WebSocket 작동 원리<a hidden class=anchor aria-hidden=true href=#websocket-작동-원리>#</a></h4><ol><li>클라이언트는 HTTP 요청으로 WebSocket 연결을 시작한다(<code>Upgrade: websocket</code> 헤더 포함).</li><li>서버가 이 요청을 수락하면 HTTP 연결이 WebSocket 프로토콜로 업그레이드된다.</li><li>이후 양쪽은 동일한 TCP 연결을 통해 데이터 프레임을 자유롭게 주고받을 수 있다.</li><li>연결은 명시적으로 종료되기 전까지 지속된다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// WebSocket 클라이언트 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>socket</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WebSocket</span><span class=p>(</span><span class=s1>&#39;ws://example.com/socket&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>socket</span><span class=p>.</span><span class=nx>onopen</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;웹소켓 연결이 열렸습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>socket</span><span class=p>.</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;클라이언트에서 서버로 메시지 전송&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>socket</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;서버에서 메시지 받음:&#39;</span><span class=p>,</span> <span class=nx>event</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>socket</span><span class=p>.</span><span class=nx>onclose</span> <span class=o>=</span> <span class=kd>function</span><span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;웹소켓 연결이 닫혔습니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=long-polling-작동-원리>Long Polling 작동 원리<a hidden class=anchor aria-hidden=true href=#long-polling-작동-원리>#</a></h4><ol><li>클라이언트가 서버에 HTTP 요청을 보낸다.</li><li>서버는 새 데이터가 있으면 즉시 응답하고, 없으면 이벤트가 발생하거나 타임아웃될 때까지 응답을 보류한다.</li><li>응답을 받은 클라이언트는 데이터를 처리한 후 즉시 새로운 요청을 시작한다.</li><li>이 과정이 계속 반복된다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Long Polling 클라이언트 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>longPoll</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;/api/events&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>data</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;서버에서 데이터 받음:&#39;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 데이터 처리 후 즉시 다음 요청 시작
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>longPoll</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=k>catch</span><span class=p>(</span><span class=nx>error</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>console</span><span class=p>.</span><span class=nx>error</span><span class=p>(</span><span class=s1>&#39;에러 발생:&#39;</span><span class=p>,</span> <span class=nx>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 에러 발생 시 잠시 대기 후 재시도
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>longPoll</span><span class=p>,</span> <span class=mi>5000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Long Polling 시작
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>longPoll</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=프로토콜-및-기술적-특성>프로토콜 및 기술적 특성<a hidden class=anchor aria-hidden=true href=#프로토콜-및-기술적-특성>#</a></h3><h4 id=websocket-1>WebSocket<a hidden class=anchor aria-hidden=true href=#websocket-1>#</a></h4><ul><li><strong>프로토콜</strong>: ws:// 또는 wss://(보안) 프로토콜 사용</li><li><strong>연결 방식</strong>: 지속적인 양방향 연결</li><li><strong>메시지 형식</strong>: 이진 프레임 또는 텍스트 프레임</li><li><strong>상태 관리</strong>: 연결 상태를 유지하며, 연결 종료 시 특별한 종료 프레임 사용</li><li><strong>헤더 오버헤드</strong>: 초기 핸드셰이크 이후 매우 적음 (2-14 바이트의 프레임 헤더)</li></ul><h4 id=long-polling-1>Long Polling<a hidden class=anchor aria-hidden=true href=#long-polling-1>#</a></h4><ul><li><strong>프로토콜</strong>: 표준 HTTP 프로토콜 사용</li><li><strong>연결 방식</strong>: 요청-응답 패턴의 확장(응답 지연)</li><li><strong>메시지 형식</strong>: HTTP 응답 (JSON, XML 등)</li><li><strong>상태 관리</strong>: 각 요청은 독립적이며, 서버가 클라이언트 상태를 추적해야 함</li><li><strong>헤더 오버헤드</strong>: 매 요청마다 완전한 HTTP 헤더 포함 (수백 바이트)</li></ul><h3 id=성능-비교>성능 비교<a hidden class=anchor aria-hidden=true href=#성능-비교>#</a></h3><ol><li><p>지연 시간</p><ul><li><strong>WebSocket</strong>: 연결이 이미 수립되어 있어 메시지 전달 지연이 최소화된다.</li><li><strong>Long Polling</strong>: 서버 이벤트 발생 시 즉시 응답하지만, 응답 후 새 요청을 설정하는 시간만큼 지연이 발생한다.</li></ul></li><li><p>네트워크 효율성</p><ul><li><strong>WebSocket</strong>: 헤더 오버헤드가 적어 데이터 전송이 효율적이며, 불필요한 연결 재설정이 없다.</li><li><strong>Long Polling</strong>: 각 메시지마다 새로운 HTTP 요청이 필요하여 헤더 오버헤드가 크고, 연결 설정에 추가 비용이 발생한다.</li></ul></li><li><p>서버 부하</p><ul><li><strong>WebSocket</strong>: 지속적인 연결 유지로 메모리 사용량이 증가하지만, CPU 사용량은 메시지 전송 시에만 발생한다.</li><li><strong>Long Polling</strong>: 연결 설정/해제가 자주 발생하여 CPU 부하가 높을 수 있으며, 활성 연결도 리소스를 소비한다.</li></ul></li><li><p>확장성</p><ul><li><strong>WebSocket</strong>: 동시 연결 수에 따라 서버 메모리 사용량이 증가하므로, 대규모 확장에는 특별한 관리가 필요하다.</li><li><strong>Long Polling</strong>: 요청-응답 주기로 인해 대규모 사용자에 대한 확장이 어려울 수 있으며, 서버 리소스 점유 문제가 있다.</li></ul></li></ol><h3 id=구현-및-호환성>구현 및 호환성<a hidden class=anchor aria-hidden=true href=#구현-및-호환성>#</a></h3><ol><li><p>개발 복잡성</p><ul><li><strong>WebSocket</strong>: 클라이언트와 서버 모두 WebSocket 프로토콜을 구현해야 하며, 연결 관리와 오류 처리가 필요하다.</li><li><strong>Long Polling</strong>: 표준 HTTP를 기반으로 하므로 상대적으로 구현이 간단하지만, 요청 타임아웃 관리와 연결 상태 추적이 필요하다.</li></ul></li><li><p>브라우저 지원</p><ul><li><strong>WebSocket</strong>: 현대 브라우저에서는 거의 대부분 지원하지만, 일부 오래된 브라우저나 제한된 환경에서는 사용할 수 없을 수 있다.</li><li><strong>Long Polling</strong>: 모든 브라우저에서 완벽하게 지원된다.</li></ul></li><li><p>네트워크 인프라 호환성</p><ul><li><strong>WebSocket</strong>: 일부 프록시, 방화벽, 로드 밸런서는 WebSocket 연결을 차단하거나 제대로 처리하지 못할 수 있다.</li><li><strong>Long Polling</strong>: HTTP 기반이므로 대부분의 네트워크 인프라와 호환된다.</li></ul></li></ol><h3 id=사용-사례-비교>사용 사례 비교<a hidden class=anchor aria-hidden=true href=#사용-사례-비교>#</a></h3><h4 id=websocket-적합-사례>WebSocket 적합 사례<a hidden class=anchor aria-hidden=true href=#websocket-적합-사례>#</a></h4><ul><li>실시간 양방향 통신이 빈번하게 필요한 애플리케이션(온라인 게임, 협업 도구)</li><li>낮은 지연 시간이 중요한 실시간 대시보드, 모니터링 시스템</li><li>채팅 애플리케이션, 실시간 알림 시스템</li><li>주식 거래 플랫폼, 스포츠 중계 등 실시간 데이터 스트리밍</li></ul><h4 id=long-polling-적합-사례>Long Polling 적합 사례<a hidden class=anchor aria-hidden=true href=#long-polling-적합-사례>#</a></h4><ul><li>WebSocket을 지원하지 않는 환경을 위한 폴백 메커니즘</li><li>메시지 교환이 비교적 드물게 발생하는 시스템</li><li>서버에서 클라이언트로의 단방향 알림 위주의 애플리케이션</li><li>기존 HTTP 인프라를 활용해야 하는 레거시 시스템 통합</li></ul><h3 id=비교>비교<a hidden class=anchor aria-hidden=true href=#비교>#</a></h3><table><thead><tr><th>특성</th><th>WebSocket</th><th>Long Polling</th></tr></thead><tbody><tr><td><strong>프로토콜</strong></td><td>별도의 ws:// 또는 wss:// 프로토콜</td><td>표준 HTTP 프로토콜</td></tr><tr><td><strong>연결 유형</strong></td><td>지속적인 양방향 연결</td><td>긴 요청-응답 사이클</td></tr><tr><td><strong>통신 방향</strong></td><td>전이중(Full-duplex)</td><td>반이중(Half-duplex)</td></tr><tr><td><strong>헤더 오버헤드</strong></td><td>초기 핸드셰이크 후 매우 적음</td><td>매 요청마다 완전한 HTTP 헤더</td></tr><tr><td><strong>실시간성</strong></td><td>매우 높음 (밀리초 단위 지연)</td><td>중간~높음 (이벤트 발생 시 지연)</td></tr><tr><td><strong>서버 푸시</strong></td><td>기본 지원</td><td>유사하게 구현 가능</td></tr><tr><td><strong>메시지 크기</strong></td><td>적합 (최대 프레임 크기 한계 있음)</td><td>무제한 (HTTP 응답 크기)</td></tr><tr><td><strong>연결 상태</strong></td><td>명시적 열림/닫힘 상태 관리</td><td>각 요청마다 새로운 연결</td></tr><tr><td><strong>브라우저 지원</strong></td><td>현대 브라우저에서 대부분 지원</td><td>모든 브라우저 지원</td></tr><tr><td><strong>네트워크 호환성</strong></td><td>일부 프록시, 방화벽에서 문제 발생 가능</td><td>높은 호환성</td></tr><tr><td><strong>네트워크 효율성</strong></td><td>높음 (헤더 오버헤드 적음)</td><td>중간 (반복적인 HTTP 요청)</td></tr><tr><td><strong>확장성</strong></td><td>연결당 메모리 사용, 효율적인 관리 필요</td><td>동시 연결 처리에 서버 부하</td></tr><tr><td><strong>구현 복잡성</strong></td><td>중간~높음 (프로토콜 구현, 상태 관리)</td><td>중간 (타임아웃, 재연결 관리)</td></tr><tr><td><strong>보안</strong></td><td>wss:// (WebSocket Secure)</td><td>https:// (표준 암호화)</td></tr><tr><td><strong>방화벽 통과</strong></td><td>일부 제한적</td><td>대부분 허용</td></tr><tr><td><strong>에러 복구</strong></td><td>연결 끊김 감지 및 재연결 필요</td><td>매 요청 실패 시 재시도 가능</td></tr><tr><td><strong>양방향 메시징</strong></td><td>효율적</td><td>가능하나 비효율적</td></tr><tr><td><strong>리소스 사용</strong></td><td>지속 연결로 메모리 사용량 높음</td><td>연결 수립/해제로 CPU 사용량 높음</td></tr><tr><td><strong>적합한 사용 사례</strong></td><td>실시간 게임, 채팅, 협업 도구</td><td>간헐적 알림, 단방향 업데이트</td></tr><tr><td><strong>기존 인프라 활용</strong></td><td>새로운 인프라 필요 가능성</td><td>기존 HTTP 인프라 활용</td></tr><tr><td><strong>스케일링 전략</strong></td><td>클러스터링, 연결 부하 분산</td><td>수평적 확장, 세션 공유</td></tr><tr><td><strong>개발 접근성</strong></td><td>클라이언트와 서버 측 모두 구현 필요</td><td>기존 HTTP 지식으로 구현 가능</td></tr></tbody></table><h3 id=실제-사용-사례-연구>실제 사용 사례 연구<a hidden class=anchor aria-hidden=true href=#실제-사용-사례-연구>#</a></h3><h4 id=websocket-사용-사례-실시간-협업-도구>WebSocket 사용 사례: 실시간 협업 도구<a hidden class=anchor aria-hidden=true href=#websocket-사용-사례-실시간-협업-도구>#</a></h4><p>Google Docs와 같은 실시간 문서 협업 도구는 WebSocket을 활용하여 여러 사용자의 동시 편집을 지원한다. 문서 변경이 발생할 때마다 양방향 통신을 통해 즉각적으로 모든 참여자에게 변경 사항이 전달되어 실시간 협업이 가능해진다.</p><h4 id=long-polling-사용-사례-웹-기반-알림-시스템>Long Polling 사용 사례: 웹 기반 알림 시스템<a hidden class=anchor aria-hidden=true href=#long-polling-사용-사례-웹-기반-알림-시스템>#</a></h4><p>이메일 서비스의 새 메일 알림과 같은 시스템은 Long Polling으로 구현될 수 있다. 브라우저가 서버에 새 메일이 있는지 요청하고, 서버는 새 메일이 도착하거나 타임아웃이 발생할 때까지 응답을 보류한다.</p><h3 id=하이브리드-접근법>하이브리드 접근법<a hidden class=anchor aria-hidden=true href=#하이브리드-접근법>#</a></h3><p>많은 현대 애플리케이션은 WebSocket을 기본으로 사용하되, WebSocket을 지원하지 않는 환경을 위해 Long Polling을 폴백(fallback) 메커니즘으로 구현한다. Socket.IO와 같은 라이브러리는 이러한 하이브리드 접근법을 자동으로 관리해 개발자가 통합된 API를 통해 실시간 기능을 구현할 수 있게 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Socket.IO 클라이언트 예시 (WebSocket 우선, Long Polling 폴백)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>socket</span> <span class=o>=</span> <span class=nx>io</span><span class=p>(</span><span class=s1>&#39;https://example.com&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>transports</span><span class=o>:</span> <span class=p>[</span><span class=s1>&#39;websocket&#39;</span><span class=p>,</span> <span class=s1>&#39;polling&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;서버에 연결됨&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;news&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;새로운 뉴스:&#39;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nx>socket</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;response&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>feedback</span><span class=o>:</span> <span class=s1>&#39;받았습니다&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>폴백(fallback) 메커니즘</td><td>폴백(Fallback) 메커니즘은 <strong>시스템이 정상적으로 작동하지 않을 경우 대체 기능이나 경로를 제공하는 설계 방식</strong>을 의미한다. 이는 예상치 못한 오류나 실패 상황에서 시스템의 안정성을 유지하고 사용자 경험을 개선하기 위해 사용된다. 특히 네트워크 통신, API 호출, 데이터 처리 등 다양한 분야에서 널리 활용된다.</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend-Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design-and-implementation/>API-Design-and-Implementation</a></li><li><a href=https://buenhyden.github.io/tags/real-time-apis/>Real-Time-APIs</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/websocket-api/>WebSocket-API</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-testing/load-testing/><span class=title>« Prev</span><br><span>Load Testing</span>
</a><a class=next href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/server-sent-events/server-sent-events-vs-websocket/><span class=title>Next »</span><br><span>Server-sent Events vs. Websocket</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>