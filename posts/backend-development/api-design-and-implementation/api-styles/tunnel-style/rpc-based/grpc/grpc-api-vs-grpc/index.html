<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>gRPC API vs. gRPC | hyunyoun's Blog</title>
<meta name=keywords content="Backend-Development,API-Design-and-Implementation,API-Styles,gRPC-API"><meta name=description content="gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="gRPC API vs. gRPC"><meta property="og:description" content="gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-28T03:37:00+00:00"><meta property="article:modified_time" content="2025-02-28T03:37:00+00:00"><meta property="article:tag" content="Backend Development"><meta property="article:tag" content="API-Design-and-Implementation"><meta property="article:tag" content="API-Styles"><meta property="article:tag" content="GRPC-API"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="gRPC API vs. gRPC"><meta name=twitter:description content="gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend Development","item":"https://buenhyden.github.io/posts/backend-development/"},{"@type":"ListItem","position":3,"name":"API Design and Implementation","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/"},{"@type":"ListItem","position":4,"name":"API Styles","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/"},{"@type":"ListItem","position":5,"name":"Tunnel Style","item":""},{"@type":"ListItem","position":6,"name":"RPC-Based","item":""},{"@type":"ListItem","position":7,"name":"gRPC API","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/"},{"@type":"ListItem","position":8,"name":"gRPC API vs. gRPC","item":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"gRPC API vs. gRPC","name":"gRPC API vs. gRPC","description":"gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.","keywords":["Backend-Development","API-Design-and-Implementation","API-Styles","gRPC-API"],"articleBody":"gRPC API vs. gRPC gRPC와 gRPC API는 현대 마이크로서비스 아키텍처에서 중요한 역할을 하는 기술이다.\ngRPC 기본 개념 gRPC는 Google에서 개발한 고성능, 오픈소스 RPC(Remote Procedure Call) 프레임워크이다. 2015년에 처음 공개되었으며, HTTP/2 프로토콜 위에 구축되어 있다. ‘g’는 원래 Google을 의미했지만, 현재는 독립적인 오픈소스 프로젝트로 발전했다.\ngRPC는 다음과 같은 주요 특징을 가지고 있다:\nProtocol Buffers(protobuf)를 IDL(Interface Definition Language)로 사용 HTTP/2 기반 통신으로 높은 성능 제공 양방향 스트리밍 지원 다양한 프로그래밍 언어 지원 (C++, Java, Python, Go, Ruby, C# 등) 코드 생성 도구를 통한 클라이언트 및 서버 코드 자동 생성 gRPC API의 정의와 특징 gRPC API는 gRPC 프레임워크를 사용하여 구현된 API를 의미한다. 즉, gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.\ngRPC API의 주요 특징:\nProtocol Buffers로 정의된 서비스 인터페이스 강력한 타입 체크와 계약 기반 개발 지원 자동 생성된 클라이언트 라이브러리를 통한 쉬운 통합 양방향 스트리밍을 활용한 실시간 통신 가능 마이크로서비스 아키텍처에 최적화된 통신 방식 세부 비교 분석 개념적 차이\ngRPC는 기술적 프레임워크이자 프로토콜인 반면, gRPC API는 이 프레임워크를 사용하여 구현된 인터페이스이다. gRPC가 ‘도구’라면, gRPC API는 그 도구로 만들어진 ‘제품’이라고 볼 수 있다.\n구현 방식\ngRPC를 사용하여 API를 구현할 때는 먼저.proto 파일에 서비스를 정의한다. 이후 Protocol Buffers 컴파일러를 사용하여 서버 및 클라이언트 코드를 생성한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 예시 .proto 파일 syntax = \"proto3\"; package example; service ExampleService { rpc GetData (DataRequest) returns (DataResponse); rpc StreamData (DataRequest) returns (stream DataResponse); } message DataRequest { string query = 1; } message DataResponse { string result = 1; } 이 정의를 바탕으로 생성된 인터페이스가 바로 gRPC API의 일부가 된다.\n사용 사례\ngRPC는 다양한 환경에서 서비스 간 통신을 위한 기술적 기반을 제공한다. 반면 gRPC API는 특정 비즈니스 요구 사항을 충족하기 위해 gRPC를 사용하여 설계된 구체적인 인터페이스이다.\n예를 들어, Google Cloud의 많은 서비스는 gRPC API를 제공한다. 이는 Google의 기술 스택이 내부적으로 gRPC를 사용하기 때문이다.\n문서화 및 관리\ngRPC API는 일반적으로 API 문서, 버전 관리, 이전 버전과의 호환성 등을 고려해야 하는 제품으로 관리된다. 반면 gRPC 자체는 기술적 프레임워크로서 기능과 성능 개선에 초점을 맞춘다.\n확장성\ngRPC는 프로토콜 수준에서 HTTP/2의 장점을 활용하여 높은 확장성을 제공한다. gRPC API는 이러한 기술적 이점을 바탕으로 구축되어, 수백 또는 수천 개의 마이크로서비스 간 효율적인 통신을 가능하게 한다.\n개발 프로세스\ngRPC API 개발은 일반적으로 다음 단계를 따른다:\n비즈니스 요구 사항 분석 Protocol Buffers를 사용한 서비스 및 메시지 정의 코드 생성 도구를 사용한 서버 및 클라이언트 코드 생성 서비스 로직 구현 테스트 및 배포\ngRPC 자체의 개발은 프로토콜 최적화, 새로운 언어 지원 추가, 보안 기능 향상 등에 초점을 맞춘다. 비교 표 특성 gRPC gRPC API 정의 Google에서 개발한 오픈소스 RPC 프레임워크 gRPC 프레임워크를 사용하여 구현된 응용 프로그램 인터페이스 목적 서비스 간 효율적인 통신을 위한 기술적 기반 제공 특정 비즈니스 요구 사항을 충족하기 위한 인터페이스 제공 구성 요소 Protocol Buffers, HTTP/2, 코드 생성 도구 서비스 정의, 메시지 형식, 클라이언트 및 서버 구현 중점 사항 성능, 플랫폼 간 호환성, 언어 지원 기능성, 사용성, 문서화, 버전 관리 관계 기술적 프레임워크 (도구) 프레임워크의 구현체 (제품) 개발 주체 Google이 시작했으며 현재는 CNCF 프로젝트 개별 개발자 또는 조직 문서화 기술 문서, 구현 가이드 중심 API 참조, 사용 사례, 예제 중심 버전 관리 프레임워크 자체의 버전 API 계약의 버전 사용 예시 서비스 간 통신 설계 도구 Google Cloud API, 특정 마이크로서비스 API 용어 정리 용어 설명 HTTP/2 하이퍼텍스트 전송 프로토콜(HTTP) 의 두 번째 주요 버전으로, 2015년 국제 인터넷 표준화 기구(IETF)에 의해 공식적으로 발표되었다. HTTP/1.1의 한계를 극복하고 웹 성능을 개선하기 위해 설계된 프로토콜로, 클라이언트와 서버 간 데이터 전송 방식을 최적화하여 지연 시간을 줄이고 효율성을 높이는 데 초점을 맞췄다\nHTTP/2의 주요 특징\n1. 다중화(Multiplexing): - HTTP/2는 단일 TCP 연결을 통해 여러 요청과 응답을 동시에 처리할 수 있다. - 요청 순서에 관계없이 먼저 완료된 응답부터 클라이언트에 전달되므로, HTTP/1.1에서 발생했던 HOL(Head-of-Line Blocking) 문제를 해결한다. 2. 이진 프레이밍(Binary Framing): - HTTP/2는 텍스트 기반이 아닌 이진 형식으로 데이터를 처리한다. - 이로 인해 구문 분석이 더 빠르고 오버헤드가 감소하여 성능이 향상된다. 3. 헤더 압축(Header Compression): - HPACK 압축 방식을 사용하여 중복된 헤더 정보를 효율적으로 압축한다. - 이를 통해 대역폭 사용량을 줄이고 페이지 로딩 속도를 개선한다. 4. 서버 푸시(Server Push): - 서버가 클라이언트 요청 없이도 필요한 리소스를 미리 전송할 수 있다. - 예를 들어, HTML 문서를 요청하면 해당 문서에 포함된 CSS, JS 파일 등을 클라이언트 브라우저 캐시에 미리 저장한다. 이는 추가 요청을 줄여 웹 성능을 크게 향상시킨다. 5. 스트림 우선순위(Stream Prioritization): - 리소스 간 의존 관계를 설정하여 중요한 리소스를 먼저 로드할 수 있다. - 예를 들어, CSS 파일을 이미지보다 먼저 로드하여 브라우저 렌더링 속도를 높인다. 참고 및 출처 ","wordCount":"724","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-02-28T03:37:00Z","dateModified":"2025-02-28T03:37:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/>Backend Development</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/>API Design and Implementation</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/>API Styles</a>&nbsp;»&nbsp;<a href>Tunnel Style</a>&nbsp;»&nbsp;<a href>RPC-Based</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/>gRPC API</a></div><h1 class="post-title entry-hint-parent">gRPC API vs. gRPC</h1><div class=post-description>gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.</div><div class=post-meta><span title='2025-02-28 03:37:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend%20Development/API%20Design%20and%20Implementation/API%20Styles/Tunnel%20Style/RPC-Based/gRPC/grpc-api-vs-grpc.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#grpc-api-vs-grpc>gRPC API vs. gRPC</a><ul><li><a href=#grpc-기본-개념>gRPC 기본 개념</a></li><li><a href=#grpc-api의-정의와-특징>gRPC API의 정의와 특징</a></li><li><a href=#세부-비교-분석>세부 비교 분석</a></li><li><a href=#비교-표>비교 표</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=grpc-api-vs-grpc>gRPC API vs. gRPC<a hidden class=anchor aria-hidden=true href=#grpc-api-vs-grpc>#</a></h2><p>gRPC와 gRPC API는 현대 마이크로서비스 아키텍처에서 중요한 역할을 하는 기술이다.</p><h3 id=grpc-기본-개념>gRPC 기본 개념<a hidden class=anchor aria-hidden=true href=#grpc-기본-개념>#</a></h3><p>gRPC는 Google에서 개발한 고성능, 오픈소스 RPC(Remote Procedure Call) 프레임워크이다. 2015년에 처음 공개되었으며, HTTP/2 프로토콜 위에 구축되어 있다. &lsquo;g&rsquo;는 원래 Google을 의미했지만, 현재는 독립적인 오픈소스 프로젝트로 발전했다.</p><p>gRPC는 다음과 같은 주요 특징을 가지고 있다:</p><ol><li>Protocol Buffers(protobuf)를 IDL(Interface Definition Language)로 사용</li><li>HTTP/2 기반 통신으로 높은 성능 제공</li><li>양방향 스트리밍 지원</li><li>다양한 프로그래밍 언어 지원 (C++, Java, Python, Go, Ruby, C# 등)</li><li>코드 생성 도구를 통한 클라이언트 및 서버 코드 자동 생성</li></ol><h3 id=grpc-api의-정의와-특징>gRPC API의 정의와 특징<a hidden class=anchor aria-hidden=true href=#grpc-api의-정의와-특징>#</a></h3><p>gRPC API는 gRPC 프레임워크를 사용하여 구현된 API를 의미한다. 즉, gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.</p><p>gRPC API의 주요 특징:</p><ol><li>Protocol Buffers로 정의된 서비스 인터페이스</li><li>강력한 타입 체크와 계약 기반 개발 지원</li><li>자동 생성된 클라이언트 라이브러리를 통한 쉬운 통합</li><li>양방향 스트리밍을 활용한 실시간 통신 가능</li><li>마이크로서비스 아키텍처에 최적화된 통신 방식</li></ol><h3 id=세부-비교-분석>세부 비교 분석<a hidden class=anchor aria-hidden=true href=#세부-비교-분석>#</a></h3><ol><li><p>개념적 차이<br>gRPC는 기술적 프레임워크이자 프로토콜인 반면, gRPC API는 이 프레임워크를 사용하여 구현된 인터페이스이다. gRPC가 &lsquo;도구&rsquo;라면, gRPC API는 그 도구로 만들어진 &lsquo;제품&rsquo;이라고 볼 수 있다.</p></li><li><p>구현 방식<br>gRPC를 사용하여 API를 구현할 때는 먼저.proto 파일에 서비스를 정의한다. 이후 Protocol Buffers 컴파일러를 사용하여 서버 및 클라이언트 코드를 생성한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-protobuf data-lang=protobuf><span class=line><span class=cl><span class=c1>// 예시 .proto 파일
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>syntax</span> <span class=o>=</span> <span class=s>&#34;proto3&#34;</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kn>package</span> <span class=nn>example</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>service</span> <span class=n>ExampleService</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>GetData</span> <span class=p>(</span><span class=n>DataRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>DataResponse</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=k>rpc</span> <span class=n>StreamData</span> <span class=p>(</span><span class=n>DataRequest</span><span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>stream</span> <span class=n>DataResponse</span><span class=p>);</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>DataRequest</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=n>query</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kd>message</span> <span class=nc>DataResponse</span> <span class=p>{</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=kt>string</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=p>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>이 정의를 바탕으로 생성된 인터페이스가 바로 gRPC API의 일부가 된다.</p></li><li><p>사용 사례<br>gRPC는 다양한 환경에서 서비스 간 통신을 위한 기술적 기반을 제공한다. 반면 gRPC API는 특정 비즈니스 요구 사항을 충족하기 위해 gRPC를 사용하여 설계된 구체적인 인터페이스이다.<br>예를 들어, Google Cloud의 많은 서비스는 gRPC API를 제공한다. 이는 Google의 기술 스택이 내부적으로 gRPC를 사용하기 때문이다.</p></li><li><p>문서화 및 관리<br>gRPC API는 일반적으로 API 문서, 버전 관리, 이전 버전과의 호환성 등을 고려해야 하는 제품으로 관리된다. 반면 gRPC 자체는 기술적 프레임워크로서 기능과 성능 개선에 초점을 맞춘다.</p></li><li><p>확장성<br>gRPC는 프로토콜 수준에서 HTTP/2의 장점을 활용하여 높은 확장성을 제공한다. gRPC API는 이러한 기술적 이점을 바탕으로 구축되어, 수백 또는 수천 개의 마이크로서비스 간 효율적인 통신을 가능하게 한다.</p></li><li><p>개발 프로세스<br>gRPC API 개발은 일반적으로 다음 단계를 따른다:</p><ol><li>비즈니스 요구 사항 분석</li><li>Protocol Buffers를 사용한 서비스 및 메시지 정의</li><li>코드 생성 도구를 사용한 서버 및 클라이언트 코드 생성</li><li>서비스 로직 구현</li><li>테스트 및 배포<br>gRPC 자체의 개발은 프로토콜 최적화, 새로운 언어 지원 추가, 보안 기능 향상 등에 초점을 맞춘다.</li></ol></li></ol><h3 id=비교-표>비교 표<a hidden class=anchor aria-hidden=true href=#비교-표>#</a></h3><table><thead><tr><th>특성</th><th>gRPC</th><th>gRPC API</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>Google에서 개발한 오픈소스 RPC 프레임워크</td><td>gRPC 프레임워크를 사용하여 구현된 응용 프로그램 인터페이스</td></tr><tr><td><strong>목적</strong></td><td>서비스 간 효율적인 통신을 위한 기술적 기반 제공</td><td>특정 비즈니스 요구 사항을 충족하기 위한 인터페이스 제공</td></tr><tr><td><strong>구성 요소</strong></td><td>Protocol Buffers, HTTP/2, 코드 생성 도구</td><td>서비스 정의, 메시지 형식, 클라이언트 및 서버 구현</td></tr><tr><td><strong>중점 사항</strong></td><td>성능, 플랫폼 간 호환성, 언어 지원</td><td>기능성, 사용성, 문서화, 버전 관리</td></tr><tr><td><strong>관계</strong></td><td>기술적 프레임워크 (도구)</td><td>프레임워크의 구현체 (제품)</td></tr><tr><td><strong>개발 주체</strong></td><td>Google이 시작했으며 현재는 CNCF 프로젝트</td><td>개별 개발자 또는 조직</td></tr><tr><td><strong>문서화</strong></td><td>기술 문서, 구현 가이드 중심</td><td>API 참조, 사용 사례, 예제 중심</td></tr><tr><td><strong>버전 관리</strong></td><td>프레임워크 자체의 버전</td><td>API 계약의 버전</td></tr><tr><td><strong>사용 예시</strong></td><td>서비스 간 통신 설계 도구</td><td>Google Cloud API, 특정 마이크로서비스 API</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>HTTP/2</td><td><strong>하이퍼텍스트 전송 프로토콜(HTTP)</strong> 의 두 번째 주요 버전으로, 2015년 국제 인터넷 표준화 기구(IETF)에 의해 공식적으로 발표되었다. HTTP/1.1의 한계를 극복하고 웹 성능을 개선하기 위해 설계된 프로토콜로, 클라이언트와 서버 간 데이터 전송 방식을 최적화하여 지연 시간을 줄이고 효율성을 높이는 데 초점을 맞췄다<br><br><strong>HTTP/2의 주요 특징</strong><br>1. <strong>다중화(Multiplexing)</strong>:<br>- HTTP/2는 단일 TCP 연결을 통해 여러 요청과 응답을 동시에 처리할 수 있다.<br>- 요청 순서에 관계없이 먼저 완료된 응답부터 클라이언트에 전달되므로, HTTP/1.1에서 발생했던 <em>HOL(Head-of-Line Blocking)</em> 문제를 해결한다.<br>2. <strong>이진 프레이밍(Binary Framing)</strong>:<br>- HTTP/2는 텍스트 기반이 아닌 이진 형식으로 데이터를 처리한다.<br>- 이로 인해 구문 분석이 더 빠르고 오버헤드가 감소하여 성능이 향상된다.<br>3. <strong>헤더 압축(Header Compression)</strong>:<br>- HPACK 압축 방식을 사용하여 중복된 헤더 정보를 효율적으로 압축한다.<br>- 이를 통해 대역폭 사용량을 줄이고 페이지 로딩 속도를 개선한다.<br>4. <strong>서버 푸시(Server Push)</strong>:<br>- 서버가 클라이언트 요청 없이도 필요한 리소스를 미리 전송할 수 있다.<br>- 예를 들어, HTML 문서를 요청하면 해당 문서에 포함된 CSS, JS 파일 등을 클라이언트 브라우저 캐시에 미리 저장한다. 이는 추가 요청을 줄여 웹 성능을 크게 향상시킨다.<br>5. <strong>스트림 우선순위(Stream Prioritization)</strong>:<br>- 리소스 간 의존 관계를 설정하여 중요한 리소스를 먼저 로드할 수 있다.<br>- 예를 들어, CSS 파일을 이미지보다 먼저 로드하여 브라우저 렌더링 속도를 높인다.</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design-and-implementation/>API-Design-and-Implementation</a></li><li><a href=https://buenhyden.github.io/tags/api-styles/>API-Styles</a></li><li><a href=https://buenhyden.github.io/tags/grpc-api/>GRPC-API</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/websocket-api-vs-websocket/><span class=title>« Prev</span><br><span>Websocket API vs. Websocket</span>
</a><a class=next href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/query-style/graphql/graphql-apis/graphql-api-vs-graphql/><span class=title>Next »</span><br><span>GraphQL API vs. GraphQL</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>