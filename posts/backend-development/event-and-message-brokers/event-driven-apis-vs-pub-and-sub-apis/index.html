<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event-driven APIs vs. Pub and Sub APIs | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design-and-Implementation,Real-time-APIs,Types,Event-driven-APIs"><meta name=description content="이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Event-driven APIs vs. Pub and Sub APIs"><meta property="og:description" content="이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-04T06:02:00+00:00"><meta property="article:modified_time" content="2025-04-04T06:02:00+00:00"><meta property="article:tag" content="Backend-Development"><meta property="article:tag" content="API-Design-and-Implementation"><meta property="article:tag" content="Real-Time-APIs"><meta property="article:tag" content="Types"><meta property="article:tag" content="Event-Driven-APIs"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Event-driven APIs vs. Pub and Sub APIs"><meta name=twitter:description content="이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend Development","item":"https://buenhyden.github.io/posts/backend-development/"},{"@type":"ListItem","position":3,"name":"Event and Message Brokers","item":"https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/"},{"@type":"ListItem","position":4,"name":"Event-driven APIs vs. Pub and Sub APIs","item":"https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event-driven APIs vs. Pub and Sub APIs","name":"Event-driven APIs vs. Pub and Sub APIs","description":"이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다.","keywords":["Backend-Development","API-Design-and-Implementation","Real-time-APIs","Types","Event-driven-APIs"],"articleBody":"Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.\nEvent-Driven API (이벤트 기반 API) 이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. 클라이언트는 특정 이벤트에 대한 리스너를 등록하고, 해당 이벤트가 발생하면 서버가 알림을 보낸다. 이를 통해 실시간 반응형 시스템을 구축할 수 있다.\n아키텍처 및 동작 방식 비교 항목 Pub/Sub APIs Event-Driven APIs 통신 모델 토픽 중심 발행-구독 이벤트 트리거 기반 푸시 알림 데이터 흐름 메시지 단위 배치 처리 상태 변화 시 즉각적 스트리밍 결합도 완전 분리 (브로커 의존) 부분 결합 (이벤트 소스와 직접 연결) 메시지 보관 브로커에서 일정 기간 저장 이벤트 발생 후 즉시 소멸 (옵션 저장) 아키텍처 Pub/Sub API 아키텍처 Pub/Sub 시스템은 일반적으로 세 가지 주요 구성 요소로 이루어진다:\n발행자(Publisher): 메시지를 생성하여 특정 주제(Topic)에 발행한다. 브로커(Broker): 메시지를 수신하고 저장하며, 관련 구독자에게 전달한다. 구독자(Subscriber): 관심 있는 주제를 구독하고 해당 주제에 발행된 메시지를 수신한다. 1 2 3 4 5 [발행자1] ───┐ ┌─── [구독자1] │ │ [발행자2] ─── ├─→ [메시지 브로커] ─┼─→ [구독자2] │ │ [발행자3] ───┘ └─── [구독자3] Event-Driven API 아키텍처 이벤트 기반 시스템의 주요 구성 요소는 다음과 같다:\n이벤트 소스(Event Source): 이벤트를 발생시키는 주체이다. 이벤트 채널(Event Channel): 이벤트를 전달하는 매개체이다 (이벤트 버스 등). 이벤트 리스너(Event Listener): 특정 이벤트를 감지하고 처리하는 주체이다. 1 2 3 4 5 ┌─→ [이벤트 처리기1] │ [이벤트 소스] ─→ [이벤트 채널/버스] ───────┼─→ [이벤트 처리기2] │ └─→ [이벤트 처리기3] 주요 구현 기술 비교 Pub/Sub API 구현 기술 Apache Kafka: 높은 처리량과 내구성을 제공하는 분산 이벤트 스트리밍 플랫폼 RabbitMQ: AMQP 프로토콜을 지원하는 강력한 메시지 브로커 Google Cloud Pub/Sub: 완전 관리형 실시간 메시징 서비스 AWS SNS/SQS: 아마존의 알림 서비스와 메시지 큐 서비스 Redis Pub/Sub: 인메모리 데이터 저장소를 활용한 경량 메시징 시스템 Event-Driven API 구현 기술 WebSockets: 클라이언트와 서버 간 양방향 통신 채널을 제공하는 프로토콜 Server-Sent Events (SSE): 서버에서 클라이언트로의 단방향 이벤트 스트림 WebHooks: 특정 이벤트 발생 시 HTTP 콜백을 통한 알림 Socket.IO: 실시간, 양방향, 이벤트 기반 통신을 위한 라이브러리 Vert.x: 이벤트 루프 기반의 반응형 애플리케이션 프레임워크 기술적 특성 특성 Pub/Sub APIs Event-Driven APIs 확장성 초당 100만 메시지 처리 가능 장기 실행 연결 시 확장 제약 지연 시간 100ms~1s (브로커 처리 시간 영향) 10ms~100ms (직접 전달 최적화) 신뢰성 At-least-once 전달 보장 Best-effort (구현 방식에 따라 다름) 트랜잭션 지원 제한적 (배치 단위 커밋) Saga 패턴을 통한 분산 트랜잭션 지원 주요 사용 사례 분야 Pub/Sub APIs 적용 예시 Event-Driven APIs 적용 예시 금융 주문 집행 시스템 실시간 사기 탐지 IoT 디바이스 상태 일괄 수집 센서 임계값 초과 즉시 경고 e-Commerce 재고 동기화 장바구니 포기 알림 미디어 콘텐츠 배포 네트워크 실시간 시청자 상호작용 처리 Pub/Sub API 적합 사례 대규모 데이터 스트리밍: 센서 데이터, 로그 데이터 등 대용량 데이터 처리 마이크로서비스 간 비동기 통신: 서비스 간 느슨한 결합 유지 분산 시스템에서의 이벤트 전파: 여러 시스템에 동일한 메시지 전달 백그라운드 작업 처리: 메인 애플리케이션 흐름에서 분리된 작업 처리 멀티테넌트 시스템: 여러 고객/사용자에게 맞춤형 메시지 전달 Event-Driven API 적합 사례 실시간 사용자 인터페이스: 채팅 애플리케이션, 협업 도구 IoT 응용 프로그램: 장치 상태 변화 모니터링 및 제어 워크플로우 자동화: 특정 이벤트 발생 시 작업 트리거 반응형 시스템: 시스템 상태 변화에 즉각 대응하는 애플리케이션 실시간 분석 및 모니터링: 이상 탐지, 실시간 대시보드 장단점 비교 구분 Pub/Sub APIs 장점 Event-Driven APIs 장점 강점 대량 메시지 처리 최적화 초저지연 실시간 반응 한계 복잡한 라우팅 규칙 구현 어려움 이벤트 소실 가능성 최적 시나리오 1:N 다중 구독자 환경 1:1 또는 N:M 즉각적 반응 요구 시스템 Pub/Sub API 장점:\n느슨한 결합: 발행자와 구독자는 서로에 대해 알 필요가 없음 확장성: 시스템 구성 요소를 독립적으로 확장 가능 안정성: 메시지 브로커가 임시 저장소 역할을 하여 시스템 장애 시에도 메시지 손실 방지 비동기 처리: 발행자는 메시지를 발행하고 즉시 다른 작업 수행 가능 멀티캐스팅: 하나의 메시지를 여러 구독자에게 효율적으로 전달 단점:\n복잡성: 브로커 설정 및 관리에 따른 추가적인 복잡성 지연 시간: 브로커를 통한 메시지 전달로 인한 추가 지연 발생 가능 디버깅 어려움: 비동기 특성으로 인해 문제 추적이 어려울 수 있음 순서 보장의 어려움: 분산 환경에서 메시지 순서 보장이 도전적 리소스 사용: 메시지 저장 및 관리에 추가 리소스 필요 Event-Driven API 장점:\n실시간성: 이벤트 발생 즉시 처리 가능 효율성: 필요한 경우에만 통신이 이루어져 리소스 효율적 반응형 설계: 상태 변화에 즉각적으로 반응하는 시스템 구축 가능 세밀한 제어: 이벤트 타입이나 속성에 따른 세밀한 처리 가능 유연성: 새로운 이벤트 타입이나 처리기를 쉽게 추가 가능 단점:\n복잡한 오류 처리: 비동기 이벤트 처리의 오류 관리가 복잡 테스트 어려움: 이벤트 기반 시스템의 테스트가 도전적일 수 있음 이벤트 폭주: 대량의 이벤트 발생 시 시스템 과부하 가능성 이벤트 의존성: 이벤트 체인의 관리가 복잡해질 수 있음 상태 관리 어려움: 분산된 이벤트 처리에서 일관된 상태 유지가 어려울 수 있음 Event-driven APIs vs. Pub and Sub APIs 비교 특성 Pub/Sub API Event-Driven API 정의 메시지 발행자와 구독자 간의 중개자를 통한 비동기 통신 패턴 이벤트 발생에 따라 시스템이 반응하는 패턴 통신 모델 일반적으로 다대다(many-to-many) 통신 일대다(one-to-many) 또는 다대다 통신 가능 중개자 역할 메시지 브로커(broker)가 중앙에서 메시지 관리 이벤트 버스나 이벤트 메시지 큐 등이 사용됨 메시지/이벤트 수명 메시지가 일반적으로 구독자에게 전달될 때까지 저장됨 이벤트는 주로 즉시 처리되거나 짧은 시간 동안만 유지 결합도 매우 낮음 (발행자와 구독자는 서로를 알 필요 없음) 낮음 (이벤트 소스와 리스너는 이벤트 타입만 알면 됨) 확장성 매우 높음 (수천, 수만 개의 주제와 구독자 지원 가능) 높음 (다양한 이벤트 유형 및 처리기 추가 가능) 데이터 흐름 주로 메시지 중심 (데이터 전송에 초점) 주로 상태 변화 중심 (상태 변화 알림에 초점) 사용 예시 메시징 앱, 이메일 알림, 콘텐츠 배포 시스템 실시간 대시보드, IoT 장치 모니터링, UI 상호작용 구현 기술 Kafka, RabbitMQ, Google Cloud Pub/Sub, AWS SNS/SQS WebSockets, Server-Sent Events, WebHooks, Socket.IO 메시지 필터링 주제(topic) 기반 필터링이 일반적 이벤트 타입이나 속성 기반 필터링이 일반적 메시지 보증 다양한 수준의 전달 보증 제공 가능 (최소 1회, 최대 1회, 정확히 1회) 일반적으로 최선의 전달 노력 (best-effort delivery) 지연시간 브로커를 통한 통신으로 약간의 지연 발생 가능 직접적인 이벤트 처리로 지연시간이 상대적으로 낮을 수 있음 복잡성 브로커 설정과 관리에 따른 복잡성 존재 이벤트 처리 로직과 오류 처리에 따른 복잡성 존재 상태 관리 주로 무상태(stateless) 설계 이벤트 소싱 패턴과 결합 시 상태 관리 가능 메시지 순서 주제 내에서 메시지 순서 보장이 도전적일 수 있음 단일 소스에서의 이벤트 순서는 비교적 쉽게 보장 가능 통합 아키텍처에서의 상호보완적 활용 실제 시스템에서는 두 방식을 혼용하는 경우가 많다.\n예를 들어 IoT 플랫폼에서:\nPub/Sub을 통해 디바이스 → 클라우드 메시지 수집 Event-Driven API로 실시간 이상 감지 시 사용자 알림\n이처럼 이벤트 발생(Event-Driven) → 대량 데이터 처리(Pub/Sub) → 결과 전달(Event-Driven)의 연계 구조가 빈번히 사용된다. 많은 현대적인 시스템에서는 Pub/Sub API와 Event-Driven API의 장점을 결합한 하이브리드 접근 방식을 채택하고 있다. 이러한 접근 방식은 다음과 같은 특징을 가진다:\n이벤트 소싱 + Pub/Sub: 이벤트를 저장하고 발행하는 방식으로 결합 CQRS 패턴 활용: Command(명령)와 Query(조회)를 분리하여 각각에 적합한 모델 적용 메시지 브로커 + WebSocket: 백엔드 시스템 간에는 메시지 브로커를, 클라이언트와는 WebSocket을 사용 계층적 이벤트 처리: 시스템 내부에서는 이벤트 기반 처리, 외부 통신에는 Pub/Sub 활용 도메인 이벤트 활용: 비즈니스 로직에서 발생한 이벤트를 Pub/Sub 시스템을 통해 전파 코드 예시 비교 Pub/Sub API 예시 (Node.js + Redis) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Redis Pub/Sub 예시 const redis = require('redis'); // 발행자 생성 const publisher = redis.createClient(); // 구독자 생성 const subscriber = redis.createClient(); // 구독 설정 subscriber.subscribe('user-notifications'); // 메시지 수신 처리 subscriber.on('message', (channel, message) =\u003e { console.log(`채널 ${channel}에서 메시지 수신: ${message}`); // 메시지 처리 로직 }); // 메시지 발행 function publishUserNotification(userId, message) { const notification = JSON.stringify({ userId, message, timestamp: Date.now() }); publisher.publish('user-notifications', notification); } // 사용 예 publishUserNotification(12345, '새로운 친구 요청이 있습니다.'); Event-Driven API 예시 (Node.js + Express + Socket.IO) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 // Express와 Socket.IO를 사용한 이벤트 기반 서버 const express = require('express'); const http = require('http'); const socketIO = require('socket.io'); const app = express(); const server = http.createServer(app); const io = socketIO(server); // 이벤트 발생 및 처리 io.on('connection', (socket) =\u003e { console.log('새 클라이언트 연결됨'); // 클라이언트에서 발생한 이벤트 처리 socket.on('user-activity', (data) =\u003e { console.log(`사용자 ${data.userId}의 활동: ${data.action}`); // 특정 조건에 따라 새 이벤트 발생 if (data.action === 'purchase') { // 특정 사용자에게만 이벤트 전송 socket.emit('purchase-confirmation', { orderId: generateOrderId(), message: '주문이 완료되었습니다.', timestamp: Date.now() }); // 관리자에게 알림 전송 io.to('admin-room').emit('new-purchase', { userId: data.userId, details: data.details }); } }); // 관리자 사용자 처리 if (isAdmin(socket.request)) { socket.join('admin-room'); } socket.on('disconnect', () =\u003e { console.log('클라이언트 연결 종료'); }); }); server.listen(3000, () =\u003e { console.log('서버가 3000 포트에서 실행 중입니다.'); }); // 헬퍼 함수 function generateOrderId() { return Math.random().toString(36).substring(2, 15); } function isAdmin(request) { // 관리자 확인 로직 return request.headers.role === 'admin'; } 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1498","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-04T06:02:00Z","dateModified":"2025-04-04T06:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/>Backend Development</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/>Event and Message Brokers</a></div><h1 class="post-title entry-hint-parent">Event-driven APIs vs. Pub and Sub APIs</h1><div class=post-description>이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다.</div><div class=post-meta><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Backend%20Development/Event%20and%20Message%20Brokers/event-driven-apis-vs-pub-and-sub-apis.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#event-driven-apis-vs-pub-and-sub-apis>Event-driven APIs vs. Pub and Sub APIs</a><ul><li><a href=#핵심-개념-요약>핵심 개념 요약</a></li><li><a href=#아키텍처-및-동작-방식-비교>아키텍처 및 동작 방식 비교</a></li><li><a href=#기술적-특성>기술적 특성</a></li><li><a href=#주요-사용-사례>주요 사용 사례</a></li><li><a href=#장단점-비교>장단점 비교</a></li><li><a href=#event-driven-apis-vs-pub-and-sub-apis-비교>Event-driven APIs vs. Pub and Sub APIs 비교</a></li><li><a href=#코드-예시-비교>코드 예시 비교</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=event-driven-apis-vs-pub-and-sub-apis>Event-driven APIs vs. Pub and Sub APIs<a hidden class=anchor aria-hidden=true href=#event-driven-apis-vs-pub-and-sub-apis>#</a></h2><h3 id=핵심-개념-요약>핵심 개념 요약<a hidden class=anchor aria-hidden=true href=#핵심-개념-요약>#</a></h3><table><thead><tr><th>구분</th><th>Pub/Sub APIs</th><th>Event-Driven APIs</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>토픽 기반 메시지 브로커 시스템</td><td>상태 변화/이벤트 발생 시 신호 전달 시스템</td></tr><tr><td><strong>주요 목적</strong></td><td>생산자-소비자 간 비동기 메시징</td><td>실시간 이벤트 기반 시스템 반응성 향상</td></tr><tr><td><strong>표준 구현 예시</strong></td><td>Google Cloud Pub/Sub, Apache Kafka</td><td>AWS EventBridge, Webhook, MQTT</td></tr></tbody></table><h4 id=pubsub-api-발행-구독-api>Pub/Sub API (발행-구독 API)<a hidden class=anchor aria-hidden=true href=#pubsub-api-발행-구독-api>#</a></h4><p>Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.</p><h4 id=event-driven-api-이벤트-기반-api>Event-Driven API (이벤트 기반 API)<a hidden class=anchor aria-hidden=true href=#event-driven-api-이벤트-기반-api>#</a></h4><p>이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. 클라이언트는 특정 이벤트에 대한 리스너를 등록하고, 해당 이벤트가 발생하면 서버가 알림을 보낸다. 이를 통해 실시간 반응형 시스템을 구축할 수 있다.</p><h3 id=아키텍처-및-동작-방식-비교>아키텍처 및 동작 방식 비교<a hidden class=anchor aria-hidden=true href=#아키텍처-및-동작-방식-비교>#</a></h3><table><thead><tr><th>항목</th><th>Pub/Sub APIs</th><th>Event-Driven APIs</th></tr></thead><tbody><tr><td><strong>통신 모델</strong></td><td>토픽 중심 발행-구독</td><td>이벤트 트리거 기반 푸시 알림</td></tr><tr><td><strong>데이터 흐름</strong></td><td>메시지 단위 배치 처리</td><td>상태 변화 시 즉각적 스트리밍</td></tr><tr><td><strong>결합도</strong></td><td>완전 분리 (브로커 의존)</td><td>부분 결합 (이벤트 소스와 직접 연결)</td></tr><tr><td><strong>메시지 보관</strong></td><td>브로커에서 일정 기간 저장</td><td>이벤트 발생 후 즉시 소멸 (옵션 저장)</td></tr></tbody></table><h4 id=아키텍처>아키텍처<a hidden class=anchor aria-hidden=true href=#아키텍처>#</a></h4><h5 id=pubsub-api-아키텍처>Pub/Sub API 아키텍처<a hidden class=anchor aria-hidden=true href=#pubsub-api-아키텍처>#</a></h5><p>Pub/Sub 시스템은 일반적으로 세 가지 주요 구성 요소로 이루어진다:</p><ol><li><strong>발행자(Publisher)</strong>: 메시지를 생성하여 특정 주제(Topic)에 발행한다.</li><li><strong>브로커(Broker)</strong>: 메시지를 수신하고 저장하며, 관련 구독자에게 전달한다.</li><li><strong>구독자(Subscriber)</strong>: 관심 있는 주제를 구독하고 해당 주제에 발행된 메시지를 수신한다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[발행자1] ───┐                  ┌─── [구독자1]
</span></span><span class=line><span class=cl>             │                  │
</span></span><span class=line><span class=cl>[발행자2] ─── ├─→ [메시지 브로커] ─┼─→ [구독자2]
</span></span><span class=line><span class=cl>             │                  │
</span></span><span class=line><span class=cl>[발행자3] ───┘                  └─── [구독자3]
</span></span></code></pre></td></tr></table></div></div><h5 id=event-driven-api-아키텍처>Event-Driven API 아키텍처<a hidden class=anchor aria-hidden=true href=#event-driven-api-아키텍처>#</a></h5><p>이벤트 기반 시스템의 주요 구성 요소는 다음과 같다:</p><ol><li><strong>이벤트 소스(Event Source)</strong>: 이벤트를 발생시키는 주체이다.</li><li><strong>이벤트 채널(Event Channel)</strong>: 이벤트를 전달하는 매개체이다 (이벤트 버스 등).</li><li><strong>이벤트 리스너(Event Listener)</strong>: 특정 이벤트를 감지하고 처리하는 주체이다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                                       ┌─→ [이벤트 처리기1]
</span></span><span class=line><span class=cl>                                       │
</span></span><span class=line><span class=cl>[이벤트 소스] ─→ [이벤트 채널/버스] ───────┼─→ [이벤트 처리기2]
</span></span><span class=line><span class=cl>                                       │
</span></span><span class=line><span class=cl>                                       └─→ [이벤트 처리기3]
</span></span></code></pre></td></tr></table></div></div><h4 id=주요-구현-기술-비교>주요 구현 기술 비교<a hidden class=anchor aria-hidden=true href=#주요-구현-기술-비교>#</a></h4><h5 id=pubsub-api-구현-기술>Pub/Sub API 구현 기술<a hidden class=anchor aria-hidden=true href=#pubsub-api-구현-기술>#</a></h5><ol><li><strong>Apache Kafka</strong>: 높은 처리량과 내구성을 제공하는 분산 이벤트 스트리밍 플랫폼</li><li><strong>RabbitMQ</strong>: AMQP 프로토콜을 지원하는 강력한 메시지 브로커</li><li><strong>Google Cloud Pub/Sub</strong>: 완전 관리형 실시간 메시징 서비스</li><li><strong>AWS SNS/SQS</strong>: 아마존의 알림 서비스와 메시지 큐 서비스</li><li><strong>Redis Pub/Sub</strong>: 인메모리 데이터 저장소를 활용한 경량 메시징 시스템</li></ol><h5 id=event-driven-api-구현-기술>Event-Driven API 구현 기술<a hidden class=anchor aria-hidden=true href=#event-driven-api-구현-기술>#</a></h5><ol><li><strong>WebSockets</strong>: 클라이언트와 서버 간 양방향 통신 채널을 제공하는 프로토콜</li><li><strong>Server-Sent Events (SSE)</strong>: 서버에서 클라이언트로의 단방향 이벤트 스트림</li><li><strong>WebHooks</strong>: 특정 이벤트 발생 시 HTTP 콜백을 통한 알림</li><li><strong>Socket.IO</strong>: 실시간, 양방향, 이벤트 기반 통신을 위한 라이브러리</li><li><strong>Vert.x</strong>: 이벤트 루프 기반의 반응형 애플리케이션 프레임워크</li></ol><h3 id=기술적-특성>기술적 특성<a hidden class=anchor aria-hidden=true href=#기술적-특성>#</a></h3><table><thead><tr><th>특성</th><th>Pub/Sub APIs</th><th>Event-Driven APIs</th></tr></thead><tbody><tr><td><strong>확장성</strong></td><td>초당 100만 메시지 처리 가능</td><td>장기 실행 연결 시 확장 제약</td></tr><tr><td><strong>지연 시간</strong></td><td>100ms~1s (브로커 처리 시간 영향)</td><td>10ms~100ms (직접 전달 최적화)</td></tr><tr><td><strong>신뢰성</strong></td><td>At-least-once 전달 보장</td><td>Best-effort (구현 방식에 따라 다름)</td></tr><tr><td><strong>트랜잭션 지원</strong></td><td>제한적 (배치 단위 커밋)</td><td>Saga 패턴을 통한 분산 트랜잭션 지원</td></tr></tbody></table><h3 id=주요-사용-사례>주요 사용 사례<a hidden class=anchor aria-hidden=true href=#주요-사용-사례>#</a></h3><table><thead><tr><th>분야</th><th>Pub/Sub APIs 적용 예시</th><th>Event-Driven APIs 적용 예시</th></tr></thead><tbody><tr><td><strong>금융</strong></td><td>주문 집행 시스템</td><td>실시간 사기 탐지</td></tr><tr><td><strong>IoT</strong></td><td>디바이스 상태 일괄 수집</td><td>센서 임계값 초과 즉시 경고</td></tr><tr><td><strong>e-Commerce</strong></td><td>재고 동기화</td><td>장바구니 포기 알림</td></tr><tr><td><strong>미디어</strong></td><td>콘텐츠 배포 네트워크</td><td>실시간 시청자 상호작용 처리</td></tr></tbody></table><h4 id=pubsub-api-적합-사례>Pub/Sub API 적합 사례<a hidden class=anchor aria-hidden=true href=#pubsub-api-적합-사례>#</a></h4><ol><li><strong>대규모 데이터 스트리밍</strong>: 센서 데이터, 로그 데이터 등 대용량 데이터 처리</li><li><strong>마이크로서비스 간 비동기 통신</strong>: 서비스 간 느슨한 결합 유지</li><li><strong>분산 시스템에서의 이벤트 전파</strong>: 여러 시스템에 동일한 메시지 전달</li><li><strong>백그라운드 작업 처리</strong>: 메인 애플리케이션 흐름에서 분리된 작업 처리</li><li><strong>멀티테넌트 시스템</strong>: 여러 고객/사용자에게 맞춤형 메시지 전달</li></ol><h4 id=event-driven-api-적합-사례>Event-Driven API 적합 사례<a hidden class=anchor aria-hidden=true href=#event-driven-api-적합-사례>#</a></h4><ol><li><strong>실시간 사용자 인터페이스</strong>: 채팅 애플리케이션, 협업 도구</li><li><strong>IoT 응용 프로그램</strong>: 장치 상태 변화 모니터링 및 제어</li><li><strong>워크플로우 자동화</strong>: 특정 이벤트 발생 시 작업 트리거</li><li><strong>반응형 시스템</strong>: 시스템 상태 변화에 즉각 대응하는 애플리케이션</li><li><strong>실시간 분석 및 모니터링</strong>: 이상 탐지, 실시간 대시보드</li></ol><h3 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h3><table><thead><tr><th>구분</th><th>Pub/Sub APIs 장점</th><th>Event-Driven APIs 장점</th></tr></thead><tbody><tr><td><strong>강점</strong></td><td>대량 메시지 처리 최적화</td><td>초저지연 실시간 반응</td></tr><tr><td><strong>한계</strong></td><td>복잡한 라우팅 규칙 구현 어려움</td><td>이벤트 소실 가능성</td></tr><tr><td><strong>최적 시나리오</strong></td><td>1:N 다중 구독자 환경</td><td>1:1 또는 N:M 즉각적 반응 요구 시스템</td></tr></tbody></table><h4 id=pubsub-api>Pub/Sub API<a hidden class=anchor aria-hidden=true href=#pubsub-api>#</a></h4><p>장점:</p><ol><li><strong>느슨한 결합</strong>: 발행자와 구독자는 서로에 대해 알 필요가 없음</li><li><strong>확장성</strong>: 시스템 구성 요소를 독립적으로 확장 가능</li><li><strong>안정성</strong>: 메시지 브로커가 임시 저장소 역할을 하여 시스템 장애 시에도 메시지 손실 방지</li><li><strong>비동기 처리</strong>: 발행자는 메시지를 발행하고 즉시 다른 작업 수행 가능</li><li><strong>멀티캐스팅</strong>: 하나의 메시지를 여러 구독자에게 효율적으로 전달</li></ol><p>단점:</p><ol><li><strong>복잡성</strong>: 브로커 설정 및 관리에 따른 추가적인 복잡성</li><li><strong>지연 시간</strong>: 브로커를 통한 메시지 전달로 인한 추가 지연 발생 가능</li><li><strong>디버깅 어려움</strong>: 비동기 특성으로 인해 문제 추적이 어려울 수 있음</li><li><strong>순서 보장의 어려움</strong>: 분산 환경에서 메시지 순서 보장이 도전적</li><li><strong>리소스 사용</strong>: 메시지 저장 및 관리에 추가 리소스 필요</li></ol><h4 id=event-driven-api>Event-Driven API<a hidden class=anchor aria-hidden=true href=#event-driven-api>#</a></h4><p>장점:</p><ol><li><strong>실시간성</strong>: 이벤트 발생 즉시 처리 가능</li><li><strong>효율성</strong>: 필요한 경우에만 통신이 이루어져 리소스 효율적</li><li><strong>반응형 설계</strong>: 상태 변화에 즉각적으로 반응하는 시스템 구축 가능</li><li><strong>세밀한 제어</strong>: 이벤트 타입이나 속성에 따른 세밀한 처리 가능</li><li><strong>유연성</strong>: 새로운 이벤트 타입이나 처리기를 쉽게 추가 가능</li></ol><p>단점:</p><ol><li><strong>복잡한 오류 처리</strong>: 비동기 이벤트 처리의 오류 관리가 복잡</li><li><strong>테스트 어려움</strong>: 이벤트 기반 시스템의 테스트가 도전적일 수 있음</li><li><strong>이벤트 폭주</strong>: 대량의 이벤트 발생 시 시스템 과부하 가능성</li><li><strong>이벤트 의존성</strong>: 이벤트 체인의 관리가 복잡해질 수 있음</li><li><strong>상태 관리 어려움</strong>: 분산된 이벤트 처리에서 일관된 상태 유지가 어려울 수 있음</li></ol><h3 id=event-driven-apis-vs-pub-and-sub-apis-비교>Event-driven APIs vs. Pub and Sub APIs 비교<a hidden class=anchor aria-hidden=true href=#event-driven-apis-vs-pub-and-sub-apis-비교>#</a></h3><table><thead><tr><th>특성</th><th>Pub/Sub API</th><th>Event-Driven API</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>메시지 발행자와 구독자 간의 중개자를 통한 비동기 통신 패턴</td><td>이벤트 발생에 따라 시스템이 반응하는 패턴</td></tr><tr><td><strong>통신 모델</strong></td><td>일반적으로 다대다(many-to-many) 통신</td><td>일대다(one-to-many) 또는 다대다 통신 가능</td></tr><tr><td><strong>중개자 역할</strong></td><td>메시지 브로커(broker)가 중앙에서 메시지 관리</td><td>이벤트 버스나 이벤트 메시지 큐 등이 사용됨</td></tr><tr><td><strong>메시지/이벤트 수명</strong></td><td>메시지가 일반적으로 구독자에게 전달될 때까지 저장됨</td><td>이벤트는 주로 즉시 처리되거나 짧은 시간 동안만 유지</td></tr><tr><td><strong>결합도</strong></td><td>매우 낮음 (발행자와 구독자는 서로를 알 필요 없음)</td><td>낮음 (이벤트 소스와 리스너는 이벤트 타입만 알면 됨)</td></tr><tr><td><strong>확장성</strong></td><td>매우 높음 (수천, 수만 개의 주제와 구독자 지원 가능)</td><td>높음 (다양한 이벤트 유형 및 처리기 추가 가능)</td></tr><tr><td><strong>데이터 흐름</strong></td><td>주로 메시지 중심 (데이터 전송에 초점)</td><td>주로 상태 변화 중심 (상태 변화 알림에 초점)</td></tr><tr><td><strong>사용 예시</strong></td><td>메시징 앱, 이메일 알림, 콘텐츠 배포 시스템</td><td>실시간 대시보드, IoT 장치 모니터링, UI 상호작용</td></tr><tr><td><strong>구현 기술</strong></td><td>Kafka, RabbitMQ, Google Cloud Pub/Sub, AWS SNS/SQS</td><td>WebSockets, Server-Sent Events, WebHooks, Socket.IO</td></tr><tr><td><strong>메시지 필터링</strong></td><td>주제(topic) 기반 필터링이 일반적</td><td>이벤트 타입이나 속성 기반 필터링이 일반적</td></tr><tr><td><strong>메시지 보증</strong></td><td>다양한 수준의 전달 보증 제공 가능 (최소 1회, 최대 1회, 정확히 1회)</td><td>일반적으로 최선의 전달 노력 (best-effort delivery)</td></tr><tr><td><strong>지연시간</strong></td><td>브로커를 통한 통신으로 약간의 지연 발생 가능</td><td>직접적인 이벤트 처리로 지연시간이 상대적으로 낮을 수 있음</td></tr><tr><td><strong>복잡성</strong></td><td>브로커 설정과 관리에 따른 복잡성 존재</td><td>이벤트 처리 로직과 오류 처리에 따른 복잡성 존재</td></tr><tr><td><strong>상태 관리</strong></td><td>주로 무상태(stateless) 설계</td><td>이벤트 소싱 패턴과 결합 시 상태 관리 가능</td></tr><tr><td><strong>메시지 순서</strong></td><td>주제 내에서 메시지 순서 보장이 도전적일 수 있음</td><td>단일 소스에서의 이벤트 순서는 비교적 쉽게 보장 가능</td></tr></tbody></table><h4 id=통합-아키텍처에서의-상호보완적-활용>통합 아키텍처에서의 상호보완적 활용<a hidden class=anchor aria-hidden=true href=#통합-아키텍처에서의-상호보완적-활용>#</a></h4><p>실제 시스템에서는 두 방식을 혼용하는 경우가 많다.</p><p>예를 들어 IoT 플랫폼에서:</p><ol><li><strong>Pub/Sub</strong>을 통해 디바이스 → 클라우드 메시지 수집</li><li><strong>Event-Driven API</strong>로 실시간 이상 감지 시 사용자 알림<br>이처럼 이벤트 발생(Event-Driven) → 대량 데이터 처리(Pub/Sub) → 결과 전달(Event-Driven)의 연계 구조가 빈번히 사용된다.</li></ol><p>많은 현대적인 시스템에서는 Pub/Sub API와 Event-Driven API의 장점을 결합한 하이브리드 접근 방식을 채택하고 있다. 이러한 접근 방식은 다음과 같은 특징을 가진다:</p><ol><li><strong>이벤트 소싱 + Pub/Sub</strong>: 이벤트를 저장하고 발행하는 방식으로 결합</li><li><strong>CQRS 패턴 활용</strong>: Command(명령)와 Query(조회)를 분리하여 각각에 적합한 모델 적용</li><li><strong>메시지 브로커 + WebSocket</strong>: 백엔드 시스템 간에는 메시지 브로커를, 클라이언트와는 WebSocket을 사용</li><li><strong>계층적 이벤트 처리</strong>: 시스템 내부에서는 이벤트 기반 처리, 외부 통신에는 Pub/Sub 활용</li><li><strong>도메인 이벤트 활용</strong>: 비즈니스 로직에서 발생한 이벤트를 Pub/Sub 시스템을 통해 전파</li></ol><h3 id=코드-예시-비교>코드 예시 비교<a hidden class=anchor aria-hidden=true href=#코드-예시-비교>#</a></h3><h4 id=pubsub-api-예시-nodejs--redis>Pub/Sub API 예시 (Node.js + Redis)<a hidden class=anchor aria-hidden=true href=#pubsub-api-예시-nodejs--redis>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Redis Pub/Sub 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>redis</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;redis&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 발행자 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>publisher</span> <span class=o>=</span> <span class=nx>redis</span><span class=p>.</span><span class=nx>createClient</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 구독자 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>subscriber</span> <span class=o>=</span> <span class=nx>redis</span><span class=p>.</span><span class=nx>createClient</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 구독 설정
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>subscriber</span><span class=p>.</span><span class=nx>subscribe</span><span class=p>(</span><span class=s1>&#39;user-notifications&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 메시지 수신 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>subscriber</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;message&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>channel</span><span class=p>,</span> <span class=nx>message</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`채널 </span><span class=si>${</span><span class=nx>channel</span><span class=si>}</span><span class=sb>에서 메시지 수신: </span><span class=si>${</span><span class=nx>message</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 메시지 처리 로직
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 메시지 발행
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>publishUserNotification</span><span class=p>(</span><span class=nx>userId</span><span class=p>,</span> <span class=nx>message</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>notification</span> <span class=o>=</span> <span class=nx>JSON</span><span class=p>.</span><span class=nx>stringify</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=nx>userId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>message</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>timestamp</span><span class=o>:</span> <span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=nx>publisher</span><span class=p>.</span><span class=nx>publish</span><span class=p>(</span><span class=s1>&#39;user-notifications&#39;</span><span class=p>,</span> <span class=nx>notification</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 사용 예
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>publishUserNotification</span><span class=p>(</span><span class=mi>12345</span><span class=p>,</span> <span class=s1>&#39;새로운 친구 요청이 있습니다.&#39;</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=event-driven-api-예시-nodejs--express--socketio>Event-Driven API 예시 (Node.js + Express + Socket.IO)<a hidden class=anchor aria-hidden=true href=#event-driven-api-예시-nodejs--express--socketio>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span><span class=lnt id=hl-3-42><a class=lnlinks href=#hl-3-42>42</a>
</span><span class=lnt id=hl-3-43><a class=lnlinks href=#hl-3-43>43</a>
</span><span class=lnt id=hl-3-44><a class=lnlinks href=#hl-3-44>44</a>
</span><span class=lnt id=hl-3-45><a class=lnlinks href=#hl-3-45>45</a>
</span><span class=lnt id=hl-3-46><a class=lnlinks href=#hl-3-46>46</a>
</span><span class=lnt id=hl-3-47><a class=lnlinks href=#hl-3-47>47</a>
</span><span class=lnt id=hl-3-48><a class=lnlinks href=#hl-3-48>48</a>
</span><span class=lnt id=hl-3-49><a class=lnlinks href=#hl-3-49>49</a>
</span><span class=lnt id=hl-3-50><a class=lnlinks href=#hl-3-50>50</a>
</span><span class=lnt id=hl-3-51><a class=lnlinks href=#hl-3-51>51</a>
</span><span class=lnt id=hl-3-52><a class=lnlinks href=#hl-3-52>52</a>
</span><span class=lnt id=hl-3-53><a class=lnlinks href=#hl-3-53>53</a>
</span><span class=lnt id=hl-3-54><a class=lnlinks href=#hl-3-54>54</a>
</span><span class=lnt id=hl-3-55><a class=lnlinks href=#hl-3-55>55</a>
</span><span class=lnt id=hl-3-56><a class=lnlinks href=#hl-3-56>56</a>
</span><span class=lnt id=hl-3-57><a class=lnlinks href=#hl-3-57>57</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Express와 Socket.IO를 사용한 이벤트 기반 서버
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>express</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;express&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>http</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;http&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>socketIO</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;socket.io&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>app</span> <span class=o>=</span> <span class=nx>express</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>server</span> <span class=o>=</span> <span class=nx>http</span><span class=p>.</span><span class=nx>createServer</span><span class=p>(</span><span class=nx>app</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>io</span> <span class=o>=</span> <span class=nx>socketIO</span><span class=p>(</span><span class=nx>server</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 이벤트 발생 및 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>io</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>socket</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;새 클라이언트 연결됨&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 클라이언트에서 발생한 이벤트 처리
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;user-activity&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`사용자 </span><span class=si>${</span><span class=nx>data</span><span class=p>.</span><span class=nx>userId</span><span class=si>}</span><span class=sb>의 활동: </span><span class=si>${</span><span class=nx>data</span><span class=p>.</span><span class=nx>action</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 특정 조건에 따라 새 이벤트 발생
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>action</span> <span class=o>===</span> <span class=s1>&#39;purchase&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 특정 사용자에게만 이벤트 전송
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>socket</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;purchase-confirmation&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>orderId</span><span class=o>:</span> <span class=nx>generateOrderId</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;주문이 완료되었습니다.&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>timestamp</span><span class=o>:</span> <span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=p>});</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>      <span class=c1>// 관리자에게 알림 전송
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=nx>io</span><span class=p>.</span><span class=nx>to</span><span class=p>(</span><span class=s1>&#39;admin-room&#39;</span><span class=p>).</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;new-purchase&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>userId</span><span class=o>:</span> <span class=nx>data</span><span class=p>.</span><span class=nx>userId</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>details</span><span class=o>:</span> <span class=nx>data</span><span class=p>.</span><span class=nx>details</span>
</span></span><span class=line><span class=cl>      <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 관리자 사용자 처리
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>isAdmin</span><span class=p>(</span><span class=nx>socket</span><span class=p>.</span><span class=nx>request</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>socket</span><span class=p>.</span><span class=nx>join</span><span class=p>(</span><span class=s1>&#39;admin-room&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;disconnect&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;클라이언트 연결 종료&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>server</span><span class=p>.</span><span class=nx>listen</span><span class=p>(</span><span class=mi>3000</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;서버가 3000 포트에서 실행 중입니다.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 헬퍼 함수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>generateOrderId</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>random</span><span class=p>().</span><span class=nx>toString</span><span class=p>(</span><span class=mi>36</span><span class=p>).</span><span class=nx>substring</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>15</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>isAdmin</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 관리자 확인 로직
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=nx>request</span><span class=p>.</span><span class=nx>headers</span><span class=p>.</span><span class=nx>role</span> <span class=o>===</span> <span class=s1>&#39;admin&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend-Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design-and-implementation/>API-Design-and-Implementation</a></li><li><a href=https://buenhyden.github.io/tags/real-time-apis/>Real-Time-APIs</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/event-driven-apis/>Event-Driven-APIs</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback-vs-fail-over/><span class=title>« Prev</span><br><span>Failback vs. Fail Over</span>
</a><a class=next href=https://buenhyden.github.io/posts/backend-development/migration-strategies/load-shifting/load-shifting-vs-load-balancing/><span class=title>Next »</span><br><span>Load Shifting vs. Load Balancing</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>