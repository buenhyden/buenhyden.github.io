<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event and Message Brokers | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,Event-and-Message-Brokers"><meta name=description content="분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커(Message Broker)와 이벤트 브로커(Event Broker)이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Event and Message Brokers"><meta property="og:description" content="분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커(Message Broker)와 이벤트 브로커(Event Broker)이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Event and Message Brokers"><meta name=twitter:description content="분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커(Message Broker)와 이벤트 브로커(Event Broker)이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Backend Development","item":"https://buenhyden.github.io/posts/backend-development/"},{"@type":"ListItem","position":3,"name":"Event and Message Brokers","item":"https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/backend-development/>Backend Development</a></div><h1>Event and Message Brokers</h1><div class=post-description>분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커(Message Broker)와 이벤트 브로커(Event Broker)이다.</div></header><div class=post-content><h2 id=event-and-message-brokers>Event and Message Brokers<a hidden class=anchor aria-hidden=true href=#event-and-message-brokers>#</a></h2><p>분산 시스템에서 애플리케이션 간의 효율적인 통신은 현대 소프트웨어 아키텍처의 중요한 측면이다. 이러한 통신을 관리하는 핵심 컴포넌트가 바로 메시지 브로커 (Message Broker) 와 이벤트 브로커 (Event Broker) 이다.</p><h3 id=메시지-브로커-message-broker-의-이해>메시지 브로커 (Message Broker) 의 이해<a hidden class=anchor aria-hidden=true href=#메시지-브로커-message-broker-의-이해>#</a></h3><p>메시지 브로커는 애플리케이션 간의 메시지 교환을 중재하며, 시스템 구성 요소 간의 결합도를 낮추는 역할을 합니다. 메시지 브로커는 주로 &rsquo; 수행할 작업 &rsquo; 에 초점을 맞추며, 명령 (Command) 이나 요청 (Request) 을 전달하는 데 사용됩니다.</p><h4 id=메시지-브로커의-주요-특징>메시지 브로커의 주요 특징<a hidden class=anchor aria-hidden=true href=#메시지-브로커의-주요-특징>#</a></h4><ol><li><strong>포인트 - 투 - 포인트 통신</strong>: 특정 메시지가 하나의 생산자 (producer) 에서 하나의 소비자 (consumer) 로 직접 전달된다.</li><li><strong>메시지 큐</strong>: 메시지는 큐 (queue) 에 저장되며, 각 메시지는 일반적으로 하나의 소비자에 의해서만 처리된다. 한 번 처리되면 큐에서 제거된다.</li><li><strong>동기 또는 비동기 통신</strong>: 두 가지 모드 모두 지원할 수 있으나, 주로 비동기 통신에 사용된다.</li><li><strong>목적 지향적</strong>: 메시지는 특정 목적지 또는 수신자를 대상으로 한다.</li><li><strong>신뢰성 있는 전달</strong>: 메시지가 적어도 한 번은 성공적으로 전달되도록 보장하는 메커니즘을 제공한다.</li></ol><h4 id=일반적인-사용-사례>일반적인 사용 사례<a hidden class=anchor aria-hidden=true href=#일반적인-사용-사례>#</a></h4><ul><li>작업 분배 및 로드 밸런싱</li><li>비동기 처리 및 백그라운드 작업</li><li>마이크로서비스 간 통신</li><li>시스템 간 안정적인 데이터 전송</li></ul><h4 id=대표적인-메시지-브로커>대표적인 메시지 브로커<a hidden class=anchor aria-hidden=true href=#대표적인-메시지-브로커>#</a></h4><ul><li><strong>RabbitMQ</strong>: AMQP(Advanced Message Queuing Protocol) 를 구현한 견고한 메시지 브로커로, 다양한 메시징 패턴을 지원한다.</li><li><strong>ActiveMQ</strong>: Apache 에서 개발한 오픈 소스 메시지 브로커로, JMS(Java Message Service) API 를 지원한다.</li><li><strong>IBM MQ</strong>: 엔터프라이즈급 메시징 솔루션으로 높은 보안성과 안정성을 제공한다.</li></ul><h3 id=이벤트-브로커-event-broker-의-이해>이벤트 브로커 (Event Broker) 의 이해<a hidden class=anchor aria-hidden=true href=#이벤트-브로커-event-broker-의-이해>#</a></h3><p>이벤트 브로커는 이벤트 주도 아키텍처 (Event-Driven Architecture) 의 핵심 구성 요소로, 이벤트 생산자 (Producer) 와 소비자 (Consumer) 간의 비동기 통신을 지원한다. 이벤트 브로커는 주로 &rsquo; 발생한 일 &rsquo; 에 초점을 맞추며, 시스템 내의 상태 변화나 중요한 비즈니스 사건을 이벤트로 전파한다.</p><h4 id=이벤트-브로커의-주요-특징>이벤트 브로커의 주요 특징<a hidden class=anchor aria-hidden=true href=#이벤트-브로커의-주요-특징>#</a></h4><ol><li><strong>발행 - 구독 (Publish-Subscribe) 모델</strong>: 생산자는 이벤트를 발행 (publish) 하고, 관심 있는 소비자들은 해당 이벤트를 구독 (subscribe) 한다.</li><li><strong>다중 소비자</strong>: 하나의 이벤트가 여러 소비자에게 동시에 전달될 수 있다.</li><li><strong>토픽 기반 라우팅</strong>: 일반적으로 이벤트는 토픽 (topic) 으로 분류되며, 소비자는 관심 있는 토픽을 구독한다.</li><li><strong>상태 지향적</strong>: 시스템 상태의 변화를 표현하는 데 중점을 둔다.</li><li><strong>로그 기반 스토리지</strong>: 많은 이벤트 브로커는 지속성을 위해 로그 기반 스토리지를 사용한다.</li></ol><h4 id=일반적인-사용-사례-1>일반적인 사용 사례<a hidden class=anchor aria-hidden=true href=#일반적인-사용-사례-1>#</a></h4><ul><li>실시간 데이터 스트리밍</li><li>이벤트 소싱 (Event Sourcing) 아키텍처</li><li>비즈니스 이벤트 처리</li><li>IoT 데이터 처리</li><li>실시간 분석 및 모니터링</li></ul><h4 id=대표적인-이벤트-브로커>대표적인 이벤트 브로커<a hidden class=anchor aria-hidden=true href=#대표적인-이벤트-브로커>#</a></h4><ul><li><strong>Apache Kafka</strong>: 고성능, 내구성이 강한 분산 스트리밍 플랫폼으로, 대규모 이벤트 처리에 적합하다.</li><li><strong>Amazon Kinesis</strong>: AWS 에서 제공하는 실시간 데이터 스트리밍 서비스이다.</li><li><strong>Google Pub/Sub</strong>: Google Cloud 의 완전 관리형 실시간 메시징 서비스이다.</li><li><strong>NATS</strong>: 클라우드 네이티브 애플리케이션을 위한 경량 메시징 시스템이다.</li><li><strong>Confluent Platform</strong>: Kafka 를 기반으로 한 완전한 이벤트 스트리밍 플랫폼이다.</li></ul><h3 id=메시지-브로커와-이벤트-브로커의-주요-차이점>메시지 브로커와 이벤트 브로커의 주요 차이점<a hidden class=anchor aria-hidden=true href=#메시지-브로커와-이벤트-브로커의-주요-차이점>#</a></h3><p>이 두 유형의 브로커는 분산 시스템에서 중요한 역할을 하지만, 다음과 같은 핵심적인 차이점이 있다:</p><ol><li><strong>통신 패턴</strong>:<ul><li>메시지 브로커: 주로 포인트 - 투 - 포인트 (Point-to-Point) 통신</li><li>이벤트 브로커: 주로 발행 - 구독 (Publish-Subscribe) 통신</li></ul></li><li><strong>메시지 소비</strong>:<ul><li>메시지 브로커: 메시지는 일반적으로 하나의 소비자에 의해 한 번만 처리됨</li><li>이벤트 브로커: 이벤트는 여러 소비자에 의해 독립적으로 처리될 수 있음</li></ul></li><li><strong>데이터 지속성</strong>:<ul><li>메시지 브로커: 메시지가 처리되면 일반적으로 제거됨</li><li>이벤트 브로커: 이벤트 로그가 유지되어 재생 및 분석에 사용될 수 있음</li></ul></li><li><strong>사용 목적</strong>:<ul><li>메시지 브로커: 작업 분배와 명령 처리에 중점</li><li>이벤트 브로커: 상태 변화 통지와 데이터 스트리밍에 중점</li></ul></li><li><strong>확장성과 처리량</strong>:<ul><li>메시지 브로커: 중간 정도의 규모와 처리량에 최적화</li><li>이벤트 브로커: 대규모 데이터 스트림과 높은 처리량에 최적화</li></ul></li></ol><h3 id=아키텍처-패턴과-통합>아키텍처 패턴과 통합<a hidden class=anchor aria-hidden=true href=#아키텍처-패턴과-통합>#</a></h3><h4 id=메시지-브로커-기반-아키텍처>메시지 브로커 기반 아키텍처<a hidden class=anchor aria-hidden=true href=#메시지-브로커-기반-아키텍처>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[서비스 A] ---&gt; [메시지 큐] ---&gt; [서비스 B]
</span></span><span class=line><span class=cl>                   |
</span></span><span class=line><span class=cl>                   ↓
</span></span><span class=line><span class=cl>               [서비스 C]
</span></span></code></pre></td></tr></table></div></div><p>메시지 브로커는 일반적으로 다음과 같은 패턴에서 사용된다:</p><ol><li><strong>메시지 큐 (Message Queue)</strong>: 작업을 비동기적으로 처리하기 위한 큐 기반 시스템이다.</li><li><strong>요청 - 응답 (Request-Reply)</strong>: 클라이언트가 요청을 보내고 서버로부터 응답을 받는 패턴이다.</li><li><strong>경쟁 소비자 (Competing Consumers)</strong>: 여러 소비자가 메시지 큐에서 작업을 가져와 처리하는 패턴이다.</li></ol><h4 id=이벤트-브로커-기반-아키텍처>이벤트 브로커 기반 아키텍처<a hidden class=anchor aria-hidden=true href=#이벤트-브로커-기반-아키텍처>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                [이벤트 소비자 A]
</span></span><span class=line><span class=cl>                       ↑
</span></span><span class=line><span class=cl>[이벤트 생산자] ---&gt; [이벤트 브로커] ---&gt; [이벤트 소비자 B]
</span></span><span class=line><span class=cl>                       ↓
</span></span><span class=line><span class=cl>                [이벤트 소비자 C]
</span></span></code></pre></td></tr></table></div></div><p>이벤트 브로커는 다음과 같은 패턴에서 주로 사용된다:</p><ol><li><strong>이벤트 기반 아키텍처 (Event-Driven Architecture)</strong>: 이벤트 생성, 감지, 소비 및 반응을 중심으로 설계된 아키텍처이다.</li><li><strong>이벤트 소싱 (Event Sourcing)</strong>: 애플리케이션의 상태 변경을 이벤트 시퀀스로 저장하는 패턴이다.</li><li><strong>CQRS(Command Query Responsibility Segregation)</strong>: 명령과 쿼리 책임을 분리하는 패턴으로, 이벤트 소싱과 함께 자주 사용된다.</li><li><strong>스트림 처리 (Stream Processing)</strong>: 연속적인 데이터 스트림을 실시간으로 처리하는 패턴이다.</li></ol><h3 id=구현-시-고려사항>구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#구현-시-고려사항>#</a></h3><h4 id=메시지-브로커-선택-시-고려-사항>메시지 브로커 선택 시 고려 사항<a hidden class=anchor aria-hidden=true href=#메시지-브로커-선택-시-고려-사항>#</a></h4><ol><li><strong>메시지 보장 (Delivery Guarantee)</strong>:<ul><li>At-least-once delivery (최소 한 번 전달)</li><li>At-most-once delivery (최대 한 번 전달)</li><li>Exactly-once delivery (정확히 한 번 전달)</li></ul></li><li><strong>트랜잭션 지원</strong>: 여러 메시지 작업을 하나의 트랜잭션으로 처리할 수 있는지 여부이다.</li><li><strong>메시지 우선순위</strong>: 중요한 메시지를 먼저 처리할 수 있는 우선순위 메커니즘이 있는지 여부이다.</li><li><strong>메시지 만료</strong>: 특정 시간이 지난 후 메시지가 만료되도록 설정할 수 있는지 여부이다.</li></ol><h4 id=이벤트-브로커-선택-시-고려-사항>이벤트 브로커 선택 시 고려 사항<a hidden class=anchor aria-hidden=true href=#이벤트-브로커-선택-시-고려-사항>#</a></h4><ol><li><strong>이벤트 순서 보장</strong>: 이벤트의 순서가 중요한 경우, 순서 보장 메커니즘이 있는지 확인해야 한다.</li><li><strong>확장성</strong>: 대량의 이벤트를 처리할 수 있는 수평적 확장성이 필요하다.</li><li><strong>내구성과 복제</strong>: 데이터 손실 방지를 위한 복제 및 내구성 기능이 중요하다.</li><li><strong>이벤트 저장 기간</strong>: 이벤트를 얼마나 오래 보관할 수 있는지가 중요한 고려 사항이다.</li><li><strong>실시간 처리 능력</strong>: 지연 시간이 낮은 실시간 처리가 필요한 경우 중요하다.</li></ol><h3 id=브로커-기술의-미래-동향>브로커 기술의 미래 동향<a hidden class=anchor aria-hidden=true href=#브로커-기술의-미래-동향>#</a></h3><p>현대 분산 시스템에서 메시지 브로커와 이벤트 브로커의 중요성은 계속해서 증가하고 있으며, 다음과 같은 동향이 관찰된다:</p><ol><li><strong>하이브리드 브로커 시스템</strong>: 메시지 브로커와 이벤트 브로커의 특성을 모두 갖춘 하이브리드 솔루션의 등장</li><li><strong>서버리스 이벤트 처리</strong>: 클라우드 제공업체들이 서버리스 이벤트 처리 서비스를 확장하고 개선</li><li><strong>실시간 분석 통합</strong>: 이벤트 브로커와 실시간 분석 도구의 통합 강화</li><li><strong>IoT 와의 연계</strong>: IoT 기기의 증가로 인한 이벤트 및 메시지 브로커의 중요성 증대</li><li><strong>에지 컴퓨팅 지원</strong>: 에지 장치에서 작동할 수 있는 경량화된 브로커 시스템 개발</li></ol><h3 id=상세-비교-분석>상세 비교 분석<a hidden class=anchor aria-hidden=true href=#상세-비교-분석>#</a></h3><ol><li><p>메시징 모델</p><ul><li><strong>이벤트 브로커</strong>: 주로 발행/구독 (Publish/Subscribe) 모델을 따르며, 이벤트 스트림을 중심으로 설계된다. 생산자는 이벤트를 발행하고, 관심 있는 소비자는 이를 구독한다.</li><li><strong>메시지 브로커</strong>: 점대점 (Point-to-Point), 발행/구독, 요청/응답 (Request/Reply) 등 다양한 메시징 패턴을 지원한다. 주로 큐 중심의 아키텍처를 가진다.</li></ul></li><li><p>메시지 보존</p><ul><li><strong>이벤트 브로커</strong>: 일반적으로 이벤트를 로그 형태로 저장하며, 장기간 보존하는 것이 일반적이다 (특히 Kafka, Pulsar).</li><li><strong>메시지 브로커</strong>: 메시지는 주로 소비자에게 전달될 때까지만 임시로 저장되며, 처리 후에는 삭제된다.</li></ul></li><li><p>확장성</p><ul><li><strong>이벤트 브로커</strong>: 수평적 확장에 최적화되어 있으며, 대량의 이벤트를 처리하도록 설계되었다.</li><li><strong>메시지 브로커</strong>: 전통적으로는 수직적 확장에 더 적합했지만, 최신 메시지 브로커는 수평적 확장도 지원한다.</li></ul></li><li><p>주요 사용 사례</p><ul><li><strong>이벤트 브로커</strong>: 실시간 데이터 파이프라인, 스트림 처리, 대규모 이벤트 처리, 데이터 통합, 이벤트 소싱</li><li><strong>메시지 브로커</strong>: 작업 큐, 비동기 처리, 부하 분산, 서비스 간 통신, RPC(원격 프로시저 호출)</li></ul></li><li><p>처리 보장</p><ul><li><strong>이벤트 브로커</strong>: 일반적으로 최소 한 번 (at-least-once) 전달을 보장하며, Kafka 나 Pulsar 와 같은 시스템은 정확히 한 번 (exactly-once) 처리도 지원한다.</li><li><strong>메시지 브로커</strong>: 트랜잭션 메시징, 메시지 확인 (ACK), 데드 레터 큐 (DLQ) 등을 통해 메시지 전달 보장을 제공합니다.</li></ul></li><li><p>성능 특성</p><ul><li><strong>이벤트 브로커</strong>: 높은 처리량 (throughput) 에 최적화되어 있으며, 초당 수백만 개의 이벤트를 처리할 수 있다.</li><li><strong>메시지 브로커</strong>: 일반적으로 낮은 지연 시간 (latency) 에 최적화되어 있으며, 복잡한 라우팅을 지원한다.</li></ul></li></ol><h3 id=종합-비교>종합 비교<a hidden class=anchor aria-hidden=true href=#종합-비교>#</a></h3><table><thead><tr><th>특성</th><th>이벤트 브로커 (Event Broker)</th><th>메시지 브로커 (Message Broker)</th></tr></thead><tbody><tr><td><strong>핵심 개념</strong></td><td>이벤트 중심, &rsquo; 무슨 일이 발생했는지 '</td><td>메시지 중심, &rsquo; 무엇을 해야 하는지 '</td></tr><tr><td><strong>메시징 모델</strong></td><td>주로 발행/구독 (Pub/Sub)</td><td>점대점, 발행/구독, 요청/응답 등 다양한 패턴</td></tr><tr><td><strong>데이터 흐름</strong></td><td>스트림 지향적</td><td>큐 지향적</td></tr><tr><td><strong>메시지 보존</strong></td><td>장기간 보존 (로그 기반)</td><td>일반적으로 처리 후 삭제</td></tr><tr><td><strong>확장성</strong></td><td>수평적 확장에 최적화</td><td>전통적으로 수직적 확장, 최근엔 수평적 확장도 지원</td></tr><tr><td><strong>처리량</strong></td><td>매우 높음 (초당 수백만 메시지)</td><td>중간~높음</td></tr><tr><td><strong>지연 시간</strong></td><td>일반적으로 더 높음 (밀리초 단위)</td><td>일반적으로 더 낮음 (마이크로초~밀리초)</td></tr><tr><td><strong>전달 보장</strong></td><td>최소 한 번, 정확히 한 번</td><td>최소 한 번, 최대 한 번, 정확히 한 번</td></tr><tr><td><strong>라우팅 복잡성</strong></td><td>상대적으로 단순</td><td>다양하고 복잡한 라우팅 지원</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>실시간 데이터 파이프라인, 스트림 처리, 이벤트 소싱</td><td>작업 큐, 비동기 처리, 부하 분산, RPC</td></tr><tr><td><strong>대표 제품</strong></td><td>Apache Kafka, Pulsar, AWS EventBridge</td><td>RabbitMQ, ActiveMQ, IBM MQ</td></tr><tr><td><strong>리소스 요구사항</strong></td><td>일반적으로 더 높음</td><td>일반적으로 더 낮음</td></tr><tr><td><strong>구현 복잡성</strong></td><td>중간~높음</td><td>낮음~중간</td></tr></tbody></table><h3 id=주요-제품별-세부-비교>주요 제품별 세부 비교<a hidden class=anchor aria-hidden=true href=#주요-제품별-세부-비교>#</a></h3><table><thead><tr><th>제품</th><th>유형</th><th>개발사</th><th>주요 특징</th><th>라이선스</th><th>지원 프로토콜</th><th>최적 사용 사례</th></tr></thead><tbody><tr><td><strong>Apache Kafka</strong></td><td>이벤트 브로커</td><td>Apache</td><td>높은 처리량, 분산 로그, 파티셔닝</td><td>Apache 2.0</td><td>Kafka 프로토콜</td><td>대용량 데이터 스트리밍, 로그 집계</td></tr><tr><td><strong>Apache Pulsar</strong></td><td>이벤트 브로커</td><td>Apache</td><td>멀티 테넌시, 계층형 스토리지</td><td>Apache 2.0</td><td>Pulsar, Kafka 프로토콜</td><td>이벤트 스트리밍, 메시징, 저장소 통합</td></tr><tr><td><strong>RabbitMQ</strong></td><td>메시지 브로커</td><td>Pivotal</td><td>유연한 라우팅, 다양한 패턴</td><td>Mozilla Public License</td><td>AMQP, MQTT, STOMP</td><td>복잡한 라우팅, 비동기 작업</td></tr><tr><td><strong>ActiveMQ</strong></td><td>메시지 브로커</td><td>Apache</td><td>JMS 지원, 다중 프로토콜</td><td>Apache 2.0</td><td>OpenWire, AMQP, MQTT, STOMP</td><td>Java 기반 시스템, 기업 메시징</td></tr><tr><td><strong>Redis Pub/Sub</strong></td><td>경량 메시지 브로커</td><td>Redis Labs</td><td>인메모리, 간단한 구현</td><td>BSD</td><td>Redis 프로토콜</td><td>실시간 채팅, 알림</td></tr><tr><td><strong>AWS SNS/SQS</strong></td><td>관리형 메시지 서비스</td><td>Amazon</td><td>서버리스, 관리 불필요</td><td>상용</td><td>HTTP, HTTPS</td><td>AWS 기반 마이크로서비스</td></tr><tr><td><strong>Solace PubSub+</strong></td><td>이벤트 브로커</td><td>Solace</td><td>하이브리드 클라우드, 이벤트 메시</td><td>상용/커뮤니티</td><td>AMQP, MQTT, REST, JMS</td><td>엔터프라이즈 이벤트 메시</td></tr><tr><td><strong>NATS</strong></td><td>메시지 브로커</td><td>Synadia</td><td>경량, 고성능</td><td>Apache 2.0</td><td>NATS 프로토콜</td><td>마이크로서비스, IoT 통신</td></tr><tr><td><strong>IBM MQ</strong></td><td>메시지 브로커</td><td>IBM</td><td>엔터프라이즈급 안정성</td><td>상용</td><td>JMS, MQTT, AMQP</td><td>미션 크리티컬 엔터프라이즈 시스템</td></tr><tr><td><strong>Azure Event Hubs</strong></td><td>이벤트 브로커</td><td>Microsoft</td><td>스트리밍 플랫폼, 대규모 수집</td><td>상용</td><td>AMQP, Kafka</td><td>텔레메트리 수집, 로그 분석</td></tr></tbody></table><h3 id=실제-구현-사례>실제 구현 사례<a hidden class=anchor aria-hidden=true href=#실제-구현-사례>#</a></h3><h4 id=apache-kafka-를-이용한-이벤트-브로커-구현-예시>Apache Kafka 를 이용한 이벤트 브로커 구현 예시<a hidden class=anchor aria-hidden=true href=#apache-kafka-를-이용한-이벤트-브로커-구현-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 이벤트 생산자 코드 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Properties</span><span class=w> </span><span class=n>props</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Properties</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;bootstrap.servers&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;localhost:9092&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;key.serializer&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;value.serializer&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;org.apache.kafka.common.serialization.StringSerializer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Producer</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>producer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>KafkaProducer</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>props</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ProducerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>record</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ProducerRecord</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=s>&#34;user-events&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;user123&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;login&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>producer</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>record</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>producer</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 이벤트 소비자 코드 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Properties</span><span class=w> </span><span class=n>props</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Properties</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;bootstrap.servers&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;localhost:9092&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;group.id&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;user-event-consumer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;key.deserializer&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;org.apache.kafka.common.serialization.StringDeserializer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>props</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=s>&#34;value.deserializer&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;org.apache.kafka.common.serialization.StringDeserializer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>KafkaConsumer</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>consumer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>KafkaConsumer</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>props</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>consumer</span><span class=p>.</span><span class=na>subscribe</span><span class=p>(</span><span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;user-events&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofMillis</span><span class=p>(</span><span class=n>100</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>ConsumerRecord</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>record</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>records</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>printf</span><span class=p>(</span><span class=s>&#34;offset = %d, key = %s, value = %s%n&#34;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>                          </span><span class=kd>record</span><span class=err>.</span><span class=nc>offset</span><span class=p>(),</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=na>key</span><span class=p>(),</span><span class=w> </span><span class=n>record</span><span class=p>.</span><span class=na>value</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=rabbitmq-를-이용한-메시지-브로커-구현-예시>RabbitMQ 를 이용한 메시지 브로커 구현 예시<a hidden class=anchor aria-hidden=true href=#rabbitmq-를-이용한-메시지-브로커-구현-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 메시지 생산자 코드 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ConnectionFactory</span><span class=w> </span><span class=n>factory</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ConnectionFactory</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>factory</span><span class=p>.</span><span class=na>setHost</span><span class=p>(</span><span class=s>&#34;localhost&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>Connection</span><span class=w> </span><span class=n>connection</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>newConnection</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>connection</span><span class=p>.</span><span class=na>createChannel</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>channel</span><span class=p>.</span><span class=na>queueDeclare</span><span class=p>(</span><span class=s>&#34;task_queue&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Task message&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>channel</span><span class=p>.</span><span class=na>basicPublish</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;task_queue&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>MessageProperties</span><span class=p>.</span><span class=na>PERSISTENT_TEXT_PLAIN</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>message</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 메시지 소비자 코드 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ConnectionFactory</span><span class=w> </span><span class=n>factory</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ConnectionFactory</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>factory</span><span class=p>.</span><span class=na>setHost</span><span class=p>(</span><span class=s>&#34;localhost&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Connection</span><span class=w> </span><span class=n>connection</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>factory</span><span class=p>.</span><span class=na>newConnection</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>connection</span><span class=p>.</span><span class=na>createChannel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>channel</span><span class=p>.</span><span class=na>queueDeclare</span><span class=p>(</span><span class=s>&#34;task_queue&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>channel</span><span class=p>.</span><span class=na>basicQos</span><span class=p>(</span><span class=n>1</span><span class=p>);</span><span class=w> </span><span class=c1>// 한 번에 하나의 메시지만 가져오도록 설정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>DeliverCallback</span><span class=w> </span><span class=n>deliverCallback</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>consumerTag</span><span class=p>,</span><span class=w> </span><span class=n>delivery</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=n>delivery</span><span class=p>.</span><span class=na>getBody</span><span class=p>(),</span><span class=w> </span><span class=s>&#34;UTF-8&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>processMessage</span><span class=p>(</span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>channel</span><span class=p>.</span><span class=na>basicAck</span><span class=p>(</span><span class=n>delivery</span><span class=p>.</span><span class=na>getEnvelope</span><span class=p>().</span><span class=na>getDeliveryTag</span><span class=p>(),</span><span class=w> </span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>channel</span><span class=p>.</span><span class=na>basicConsume</span><span class=p>(</span><span class=s>&#34;task_queue&#34;</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=n>deliverCallback</span><span class=p>,</span><span class=w> </span><span class=n>consumerTag</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=1-주제의-분류-적합성>1. 주제의 분류 적합성<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적합성>#</a></h3><p>&ldquo;Event and Message Brokers&rdquo;(이벤트 및 메시지 브로커) 는 &ldquo;Computer Science and Engineering > Backend Development&rdquo; 분류에 매우 적합합니다. 메시지 브로커와 이벤트 브로커는 백엔드 시스템, 마이크로서비스 아키텍처, 실시간 데이터 처리, 시스템 간 통합 등 현대 백엔드 개발의 핵심 인프라로 자리잡고 있습니다 [2][3][17].</p><hr><h3 id=2-200-자-요약>2. 200 자 요약<a hidden class=anchor aria-hidden=true href=#2-200-자-요약>#</a></h3><p>이벤트 및 메시지 브로커는 시스템 간 비동기 통신을 중개하여 서비스 간 결합도를 낮추고, 확장성과 신뢰성을 높입니다. 메시지 브로커는 메시지 큐 기반의 안정적 전달에, 이벤트 브로커는 실시간 이벤트 스트림과 Pub/Sub(발행 - 구독) 패턴에 특화되어, 대규모 분산 시스템에서 핵심 역할을 담당합니다 [2][3][17].</p><hr><h3 id=3-전체-개요-250-자-내외>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외>#</a></h3><p>이벤트 및 메시지 브로커는 현대 백엔드 시스템에서 서비스 간 비동기 통신을 지원하는 미들웨어로, 마이크로서비스, IoT, 실시간 데이터 처리 등 다양한 환경에서 핵심 역할을 합니다. 메시지 브로커는 큐 기반의 신뢰성 높은 메시지 전달에, 이벤트 브로커는 이벤트 스트림과 Pub/Sub 패턴을 통해 실시간 데이터 분배에 최적화되어 있습니다. 이들은 시스템 간 결합도를 낮추고, 확장성, 장애 대응, 데이터 일관성, 실시간성 등 다양한 요구를 충족하며, RabbitMQ, Apache Kafka, AWS SNS/SQS, Google Pub/Sub 등이 대표적입니다 [2][3][5][17].</p><hr><h2 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h2><ul><li><p><strong>메시지 브로커 (Message Broker)</strong>:<br>서로 다른 애플리케이션, 시스템, 서비스 간 메시지를 중개하고 전달하는 미들웨어. 메시지 큐, 라우팅, 저장, 변환, 보증된 전달 등 다양한 기능을 제공합니다 [2][4][14].</p></li><li><p><strong>이벤트 브로커 (Event Broker)</strong>:<br>이벤트 기반 아키텍처에서 이벤트 (상태 변화, 특정 액션 등) 를 발행자 (Producer) 로부터 구독자 (Consumer) 에게 실시간으로 전달하는 미들웨어. Pub/Sub, 스트리밍, 이벤트 소싱 등 고급 기능을 지원합니다 [3][6][17].</p></li><li><p><strong>비동기 통신 (Asynchronous Communication)</strong>:<br>서비스 간 직접 호출 대신, 메시지/이벤트를 브로커에 전달하고, 소비자는 필요 시 메시지를 받아 처리함으로써 결합도를 낮추고 확장성을 확보합니다 [2][3][6].</p></li></ul><hr><h2 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h2><ul><li>서비스 간 결합도 (Dependency) 해소 및 유연한 확장성 확보</li><li>장애 격리 및 메시지 유실 방지, 신뢰성 있는 데이터 전달</li><li>실시간 데이터 처리 및 이벤트 기반 아키텍처 구현</li><li>다양한 언어/플랫폼 간 통신 지원 (이기종 시스템 통합)</li><li>대용량 트래픽 처리 및 로드 밸런싱, 워크로드 분산 [2][3][11][17]</li></ul><hr><h2 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h2><ul><li>메시지 큐잉 및 저장, 라우팅, 전달, 변환</li><li>Pub/Sub(발행 - 구독), Point-to-Point, 스트리밍 등 다양한 패턴 지원</li><li>메시지 순서 보장, 중복 방지, 재시도, 오류 처리, 트랜잭션 관리</li><li>인증, 보안, 접근 제어, 모니터링, 확장성 제공 [2][3][5][14][16]</li></ul><hr><h2 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h2><ul><li><strong>메시지 브로커</strong>: 큐 기반, 신뢰성, 순차적 전달, Point-to-Point 에 강점</li><li><strong>이벤트 브로커</strong>: Pub/Sub, 실시간 스트림, 대규모 분산 환경에 강점</li><li>다양한 품질 보장 (Exactly once, At least once 등), 확장성 및 장애 복구 기능 [3][5][7][16]</li></ul><hr><h2 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h2><ul><li>서비스 간 느슨한 결합 (Loose Coupling)</li><li>신뢰성 있는 메시지/이벤트 전달</li><li>확장성, 장애 격리, 데이터 일관성 보장</li><li>표준화된 메시징 패턴 및 프로토콜 준수 [2][3][6][14]</li></ul><hr><h2 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h2><ul><li>**Producer(발행자)**가 메시지/이벤트를 브로커에 전송</li><li>**Broker(브로커)**가 메시지/이벤트를 저장, 라우팅, 전달 (큐 또는 토픽)</li><li>**Consumer(소비자)**가 메시지/이벤트를 수신 및 처리</li><li>메시지 순서, 중복 방지, 오류 처리, 재시도 등 내부 로직 적용</li></ul><h3 id=주요-작동-원리-다이어그램>주요 작동 원리 다이어그램<a hidden class=anchor aria-hidden=true href=#주요-작동-원리-다이어그램>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Producer] --(Message/Event)--&gt; [Broker(Queue/Topic)] --(Delivery)--&gt; [Consumer]
</span></span></code></pre></td></tr></table></div></div><ul><li>메시지 브로커: Queue 중심, 1:1 또는 1:N</li><li>이벤트 브로커: Topic 중심, 1:N Pub/Sub</li></ul><hr><h2 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h2><h3 id=필수-구성요소>필수 구성요소<a hidden class=anchor aria-hidden=true href=#필수-구성요소>#</a></h3><ul><li><strong>Producer(발행자)</strong>: 메시지/이벤트 생성 및 전송</li><li><strong>Broker(브로커)</strong>: 메시지/이벤트 저장, 라우팅, 전달</li><li><strong>Consumer(소비자)</strong>: 메시지/이벤트 수신 및 처리</li></ul><h3 id=선택-구성요소>선택 구성요소<a hidden class=anchor aria-hidden=true href=#선택-구성요소>#</a></h3><ul><li><strong>토픽/채널 (Topic/Channel)</strong>: Pub/Sub 구조에서 논리적 분리</li><li><strong>스키마 레지스트리 (Schema Registry)</strong>: 메시지 구조 관리 및 호환성 보장</li><li><strong>모니터링/관리 도구</strong>: 성능, 장애, 트래픽 모니터링 및 관리</li></ul><h4 id=구조-다이어그램-예시>구조 다이어그램 예시<a hidden class=anchor aria-hidden=true href=#구조-다이어그램-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Producer] → [Broker (Queue/Topic/Channel)] → [Consumer]
</span></span><span class=line><span class=cl>         ↘︎         ↑
</span></span><span class=line><span class=cl>      [Schema Registry] (선택)
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h2><table><thead><tr><th>구현 기법</th><th>정의/구성</th><th>목적</th><th>실제 예시 (시스템/시나리오)</th></tr></thead><tbody><tr><td>Point-to-Point</td><td>큐 (Queue) 기반 1:1 메시지 전달</td><td>신뢰성, 순차적 처리</td><td>RabbitMQ, AWS SQS</td></tr><tr><td>Publish/Subscribe</td><td>토픽 기반 1:N 이벤트 분배</td><td>실시간 데이터 분배, 확장성</td><td>Kafka, Google Pub/Sub</td></tr><tr><td>스트리밍</td><td>실시간 데이터 스트림 처리</td><td>대용량 실시간 처리</td><td>Kafka, Pulsar</td></tr><tr><td>이벤트 소싱</td><td>이벤트 로그 기반 상태 관리</td><td>데이터 추적, 복구</td><td>Kafka, EventStoreDB</td></tr></tbody></table><hr><h2 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>결합도 감소</td><td>서비스 간 직접 의존성 해소, 유연한 확장</td></tr><tr><td></td><td>신뢰성</td><td>메시지 유실 방지, 재시도, 장애 격리</td></tr><tr><td></td><td>확장성</td><td>대용량 트래픽, 수평 확장 용이</td></tr><tr><td></td><td>실시간성</td><td>이벤트 기반 실시간 처리 가능</td></tr><tr><td></td><td>다양한 패턴</td><td>큐, Pub/Sub, 스트리밍 등 지원</td></tr><tr><td>⚠ 단점</td><td>복잡성</td><td>운영, 모니터링, 장애 분석 난이도</td></tr><tr><td></td><td>지연</td><td>브로커 장애, 네트워크 이슈 시 지연 가능</td></tr><tr><td></td><td>일관성</td><td>Eventually Consistent, 즉각적 일관성 어려움</td></tr><tr><td></td><td>운영 비용</td><td>인프라, 관리, 보안 등 추가 리소스 필요</td></tr></tbody></table><hr><h2 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h2><ul><li>메시지 순서 보장, 중복 방지, 트랜잭션 처리</li><li>장애 복구, 데이터 유실 방지, 확장성 관리</li><li>운영 복잡성, 모니터링 및 실시간 장애 탐지</li><li>스키마/버전 관리, 호환성, 보안 강화 [13][14][17]</li></ul><hr><h2 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h2><table><thead><tr><th>분류 기준</th><th>종류/유형</th><th>설명</th></tr></thead><tbody><tr><td>메시징 패턴</td><td>Point-to-Point, Pub/Sub, 스트리밍, 이벤트 소싱</td><td>메시지 전달 방식에 따른 분류</td></tr><tr><td>아키텍처</td><td>큐 기반, 토픽 기반, 로그 기반</td><td>내부 저장/분배 구조</td></tr><tr><td>배포 형태</td><td>온프레미스, 클라우드, 매니지드 서비스</td><td>배포 및 운영 방식</td></tr><tr><td>제품</td><td>RabbitMQ, Kafka, AWS SNS/SQS, Google Pub/Sub, Solace, NATS 등</td><td>대표 솔루션별 분류</td></tr></tbody></table><hr><h2 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h2><table><thead><tr><th>적용 분야</th><th>적용 예시</th><th>설명</th></tr></thead><tbody><tr><td>주문 처리</td><td>RabbitMQ</td><td>주문 이벤트 큐로 비동기 처리</td></tr><tr><td>실시간 분석</td><td>Kafka</td><td>대용량 실시간 로그 스트림</td></tr><tr><td>알림 서비스</td><td>AWS SNS/SQS</td><td>다양한 채널로 이벤트 전달</td></tr><tr><td>IoT</td><td>MQTT, NATS</td><td>센서 데이터 실시간 수집/분배</td></tr><tr><td>데이터 파이프라인</td><td>Google Pub/Sub</td><td>데이터 이동 및 ETL 자동화</td></tr></tbody></table><hr><h2 id=활용-사례-시나리오>활용 사례 (시나리오)<a hidden class=anchor aria-hidden=true href=#활용-사례-시나리오>#</a></h2><h3 id=시나리오-글로벌-이커머스-실시간-주문알림-시스템>시나리오: 글로벌 이커머스 실시간 주문/알림 시스템<a hidden class=anchor aria-hidden=true href=#시나리오-글로벌-이커머스-실시간-주문알림-시스템>#</a></h3><p><strong>시스템 구성</strong></p><ul><li>주문 서비스 (Producer) → Kafka(이벤트 브로커, Topic: order-events) → 결제/알림/배송 서비스 (Consumer)</li><li>알림 서비스 → RabbitMQ(메시지 브로커, Queue: notification) → 이메일/SMS/푸시 서버</li></ul><p><strong>시스템 다이어그램</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[주문 서비스] --(order 이벤트)--&gt; [Kafka Topic] --(구독)--&gt; [결제/알림/배송 서비스]
</span></span><span class=line><span class=cl>[알림 서비스] --(알림 메시지)--&gt; [RabbitMQ Queue] --(수신)--&gt; [이메일/SMS/푸시 서버]
</span></span></code></pre></td></tr></table></div></div><p><strong>Workflow</strong></p><ol><li>주문 발생 시 order 이벤트를 Kafka 에 발행</li><li>결제, 알림, 배송 서비스가 각자 필요한 이벤트만 구독</li><li>알림 서비스는 RabbitMQ 를 통해 다양한 채널로 메시지 분배</li><li>장애 발생 시 브로커가 메시지 임시 저장, 재시도</li></ol><p><strong>담당 역할</strong></p><ul><li>Kafka: 대용량 이벤트 스트림, Pub/Sub, 실시간 처리</li><li>RabbitMQ: 신뢰성 있는 큐잉, 다양한 채널로 메시지 분배</li></ul><hr><h2 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>메시지 패턴</td><td>큐, Pub/Sub 등 요구에 맞는 패턴 선택</td><td>시스템 요구사항 분석 후 설계</td></tr><tr><td>확장성</td><td>트래픽 증가 대비 수평 확장성 확보</td><td>클러스터링, 파티셔닝 적용</td></tr><tr><td>장애 복구</td><td>데이터 유실 방지, 장애 격리</td><td>복제, 백업, 장애 복구 시나리오 구축</td></tr><tr><td>모니터링</td><td>성능, 지연, 장애 실시간 모니터링</td><td>APM, 대시보드, 알림 설정</td></tr><tr><td>보안</td><td>인증, 암호화, 접근 제어</td><td>TLS, ACL, 권한 분리 적용</td></tr><tr><td>스키마 관리</td><td>메시지 구조 일관성 유지</td><td>Schema Registry, 버전 관리 도입</td></tr></tbody></table><hr><h2 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>메시지 크기</td><td>메시지 최소화, 불필요 데이터 제거</td><td>10MB 이하, 경량 포맷 사용</td></tr><tr><td>브로커 설정</td><td>최적화된 큐/토픽/파티션 구성</td><td>테스트 기반 튜닝, 병렬 처리</td></tr><tr><td>네트워크</td><td>대역폭, 지연 최소화</td><td>전용 네트워크, 로컬 배치</td></tr><tr><td>리소스 할당</td><td>CPU/메모리/디스크 충분히 확보</td><td>오토스케일링, 모니터링</td></tr><tr><td>오류 처리</td><td>재시도, 백오프, DLQ 적용</td><td>자동화된 오류 처리 로직 구현</td></tr><tr><td>캐싱/비동기</td><td>병렬/비동기 처리로 처리량 증대</td><td>캐시, 비동기 API 활용</td></tr></tbody></table><hr><h2 id=2025-년-기준-최신-동향>2025 년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#2025-년-기준-최신-동향>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>클라우드 네이티브</td><td>매니지드 브로커 서비스</td><td>Kafka, RabbitMQ 등 클라우드 통합, 자동 확장</td></tr><tr><td>AI/ML</td><td>AI 기반 트래픽 예측, 자동 튜닝</td><td>AI 가 메시지 패턴 분석, 리소스 자동 할당</td></tr><tr><td>IoT</td><td>초경량 브로커, MQTT 확산</td><td>IoT 데이터 실시간 수집/분배</td></tr><tr><td>보안</td><td>고급 암호화, 인증 강화</td><td>TLS, OAuth 등 보안 강화 추세</td></tr><tr><td>에코시스템</td><td>이벤트 메시시 (mesh)</td><td>멀티 브로커 연결, 글로벌 이벤트 분배</td></tr></tbody></table><hr><h2 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>메시지 패턴</td><td>Pub/Sub, Point-to-Point</td><td>다양한 패턴 조합으로 유연한 통신</td></tr><tr><td>스키마 관리</td><td>Schema Registry</td><td>메시지 구조 일관성, 호환성 보장</td></tr><tr><td>장애 복구</td><td>복제, 파티셔닝</td><td>데이터 유실 방지, 고가용성</td></tr><tr><td>실시간성</td><td>스트리밍, 이벤트 소싱</td><td>대용량 실시간 데이터 처리</td></tr><tr><td>운영 자동화</td><td>오토스케일링, AI 기반 튜닝</td><td>운영 효율성 및 장애 대응 강화</td></tr></tbody></table><hr><h2 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>시장 성장</td><td>메시지 브로커 시장</td><td>연평균 20% 이상 성장, IoT/클라우드 영향</td></tr><tr><td>AI 통합</td><td>AI/ML 기반 브로커</td><td>예측, 자동화, 장애 탐지 강화</td></tr><tr><td>IoT 확장</td><td>초경량 브로커</td><td>엣지/IoT 환경에 최적화</td></tr><tr><td>글로벌 메시시</td><td>이벤트 메시시</td><td>멀티 브로커, 글로벌 분산 트래픽</td></tr><tr><td>보안</td><td>고급 보안 기능</td><td>데이터 보호, 규제 대응 강화</td></tr></tbody></table><hr><h2 id=하위-주제-및-추가-학습-필요-내용>하위 주제 및 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#하위-주제-및-추가-학습-필요-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>메시징 패턴</td><td>Pub/Sub, Point-to-Point, 스트리밍</td><td>각 패턴별 특징, 적용법</td></tr><tr><td>브로커 비교</td><td>Kafka, RabbitMQ, SQS 등</td><td>주요 브로커별 장단점, 아키텍처</td></tr><tr><td>스키마 관리</td><td>Schema Registry</td><td>메시지 구조 관리, 버전 호환성</td></tr><tr><td>장애 복구</td><td>복제, 파티셔닝, DLQ</td><td>고가용성, 장애/오류 처리</td></tr><tr><td>보안</td><td>인증, 암호화, 접근제어</td><td>보안 설계 및 운영 가이드</td></tr></tbody></table><hr><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>아키텍처</td><td>이벤트 메시시, 글로벌 분산</td><td>멀티 브로커, 이벤트 메시시 구조</td></tr><tr><td>운영</td><td>모니터링, 오토스케일링</td><td>실시간 성능/장애 관리</td></tr><tr><td>성능</td><td>튜닝, 최적화</td><td>브로커별 성능 최적화 방법</td></tr><tr><td>클라우드</td><td>매니지드 서비스</td><td>클라우드 기반 브로커 활용법</td></tr><tr><td>개발</td><td>API, SDK 활용</td><td>다양한 언어/플랫폼 연동법</td></tr></tbody></table><hr><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Pub/Sub</td><td>발행 - 구독 패턴, 이벤트를 여러 구독자에게 분배하는 구조</td></tr><tr><td>Queue</td><td>메시지 큐, 순차적 메시지 전달 구조</td></tr><tr><td>Topic</td><td>Pub/Sub 에서 논리적 메시지 분배 단위</td></tr><tr><td>DLQ(Dead Letter Queue)</td><td>처리 실패 메시지 임시 저장 큐</td></tr><tr><td>파티셔닝 (Partitioning)</td><td>데이터 분산 저장 및 처리 구조</td></tr><tr><td>Schema Registry</td><td>메시지 구조 (스키마) 관리 시스템</td></tr><tr><td>이벤트 메시시 (Event Mesh)</td><td>복수 브로커 연결한 글로벌 분산 구조</td></tr><tr><td>오토스케일링</td><td>자동 리소스 확장/축소 기능</td></tr></tbody></table><hr><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><a href=https://www.ibm.com/think/topics/message-brokers>IBM Message Broker 개념</a></li><li><a href=https://solace.com/what-is-an-event-broker/>Solace Event Broker 설명</a></li><li><a href=https://www.koyeb.com/blog/rabbitmq-vs-apache-kafka-comparing-message-brokers-and-modern-event-streaming-platforms>RabbitMQ vs Kafka 비교</a></li><li><a href=https://learn.microsoft.com/en-us/azure/architecture/example-scenario/integration/queues-events>Azure 메시지 브로커 아키텍처</a></li><li><a href=https://www.nucamp.co/blog/coding-bootcamp-backend-with-python-2025-eventdriven-architectures-how-backend-systems-are-changing-in-2025>EDA와 메시지 브로커 실무 동향</a></li><li><a href=https://hevodata.com/learn/message-brokers/>Message Broker Best Practices</a></li><li><a href=https://pmarketresearch.com/product/worldwide-real-time-data-streaming-tool-market-research-2024-by-type-application-participants-and-countries-forecast-to-2030/worldwide-message-broker-platform-market-research-2024-by-type-application-participants-and-countries-forecast-to-2030>2025년 메시지 브로커 시장 동향</a></li><li><a href=https://estuary.dev/blog/event-driven-architecture-examples/>Event-Driven Architecture 실무 적용 사례</a></li><li><a href=https://www.gartner.com/reviews/market/event-brokers>Event Broker 기능 및 비교</a></li><li><a href=https://dev.to/oleg_potapov/message-brokers-queue-based-vs-log-based-2f21>Message Brokers: Queue-based vs Log-based</a></li><li><a href=https://dev.to/jhonifaber/introduction-to-event-driven-architecture-eda-3ioj>EDA 개념 및 아키텍처</a></li></ul><p>Citations:<br>[1] <a href=https://kth.diva-portal.org/smash/get/diva2>https://kth.diva-portal.org/smash/get/diva2</a>:1801007/FULLTEXT01.pdf<br>[2] <a href=https://www.ibm.com/think/topics/message-brokers>https://www.ibm.com/think/topics/message-brokers</a><br>[3] <a href=https://solace.com/what-is-an-event-broker/>https://solace.com/what-is-an-event-broker/</a><br>[4] <a href=https://www.upsolver.com/blog/comparing-message-brokers-and-event-processing-tools>https://www.upsolver.com/blog/comparing-message-brokers-and-event-processing-tools</a><br>[5] <a href=https://www.koyeb.com/blog/rabbitmq-vs-apache-kafka-comparing-message-brokers-and-modern-event-streaming-platforms>https://www.koyeb.com/blog/rabbitmq-vs-apache-kafka-comparing-message-brokers-and-modern-event-streaming-platforms</a><br>[6] <a href=https://dev.to/stack-labs/serverless-day-10-principles-for-your-event-driven-architecture-2lb7>https://dev.to/stack-labs/serverless-day-10-principles-for-your-event-driven-architecture-2lb7</a><br>[7] <a href=https://dev.to/oleg_potapov/message-brokers-queue-based-vs-log-based-2f21>https://dev.to/oleg_potapov/message-brokers-queue-based-vs-log-based-2f21</a><br>[8] <a href=https://estuary.dev/blog/event-driven-architecture-examples/>https://estuary.dev/blog/event-driven-architecture-examples/</a><br>[9] <a href=https://codeopinion.com/real-world-event-driven-architecture-4-practical-examples/>https://codeopinion.com/real-world-event-driven-architecture-4-practical-examples/</a><br>[10] <a href=https://learn.microsoft.com/en-us/azure/architecture/example-scenario/integration/queues-events>https://learn.microsoft.com/en-us/azure/architecture/example-scenario/integration/queues-events</a><br>[11] <a href=https://www.designgurus.io/answers/detail/use-cases-of-message-brokers>https://www.designgurus.io/answers/detail/use-cases-of-message-brokers</a><br>[12] <a href=https://www.infoq.com/articles/choosing-message-broker/>https://www.infoq.com/articles/choosing-message-broker/</a><br>[13] <a href=https://www.site24x7.com/blog/troubleshooting-latency-issues-in-event-driven-architectures>https://www.site24x7.com/blog/troubleshooting-latency-issues-in-event-driven-architectures</a><br>[14] <a href=https://hevodata.com/learn/message-brokers/>https://hevodata.com/learn/message-brokers/</a><br>[15] <a href=https://bridgingthegap.eu.com/articles/Event-Driven_One-way_point-to-point>https://bridgingthegap.eu.com/articles/Event-Driven_One-way_point-to-point</a><br>[16] <a href=https://www.gartner.com/reviews/market/event-brokers>https://www.gartner.com/reviews/market/event-brokers</a><br>[17] <a href=https://www.nucamp.co/blog/coding-bootcamp-backend-with-python-2025-eventdriven-architectures-how-backend-systems-are-changing-in-2025>https://www.nucamp.co/blog/coding-bootcamp-backend-with-python-2025-eventdriven-architectures-how-backend-systems-are-changing-in-2025</a><br>[18] <a href=https://pmarketresearch.com/product/worldwide-real-time-data-streaming-tool-market-research-2024-by-type-application-participants-and-countries-forecast-to-2030/worldwide-message-broker-platform-market-research-2024-by-type-application-participants-and-countries-forecast-to-2030>https://pmarketresearch.com/product/worldwide-real-time-data-streaming-tool-market-research-2024-by-type-application-participants-and-countries-forecast-to-2030/worldwide-message-broker-platform-market-research-2024-by-type-application-participants-and-countries-forecast-to-2030</a><br>[19] <a href=https://solace.com/resources/pubsub-event-broker/why-pubsub-is-the-worlds-best-event-broker-2-video>https://solace.com/resources/pubsub-event-broker/why-pubsub-is-the-worlds-best-event-broker-2-video</a><br>[20] <a href=https://dev.to/jhonifaber/introduction-to-event-driven-architecture-eda-3ioj>https://dev.to/jhonifaber/introduction-to-event-driven-architecture-eda-3ioj</a><br>[21] <a href=https://docs.solace.com/Features/features-lp.htm>https://docs.solace.com/Features/features-lp.htm</a><br>[22] <a href=https://dzone.com/articles/top-5-considerations-when-selecting-an-event-broke>https://dzone.com/articles/top-5-considerations-when-selecting-an-event-broke</a><br>[23] <a href=https://en.wikipedia.org/wiki/Event-driven_architecture>https://en.wikipedia.org/wiki/Event-driven_architecture</a><br>[24] <a href=https://blog.emb.global/message-broker/>https://blog.emb.global/message-broker/</a><br>[25] <a href=https://moldstud.com/articles/p-optimize-event-driven-microservices-for-peak-performance>https://moldstud.com/articles/p-optimize-event-driven-microservices-for-peak-performance</a><br>[26] <a href=https://www.businessresearchinsights.com/market-reports/message-broker-market-113346>https://www.businessresearchinsights.com/market-reports/message-broker-market-113346</a><br>[27] <a href=https://hevodata.com/learn/popular-message-broker/>https://hevodata.com/learn/popular-message-broker/</a><br>[28] <a href=https://docs.solace.com/Get-Started/what-are-event-brokers.htm>https://docs.solace.com/Get-Started/what-are-event-brokers.htm</a><br>[29] <a href=https://solace.com/blog/gartner-how-to-choose-an-event-broker/>https://solace.com/blog/gartner-how-to-choose-an-event-broker/</a><br>[30] <a href=https://tsh.io/blog/message-broker/>https://tsh.io/blog/message-broker/</a><br>[31] <a href=https://www.radissonhotels.com/en-us/blog/meetings/top-event-trends-for-planners-2025>https://www.radissonhotels.com/en-us/blog/meetings/top-event-trends-for-planners-2025</a><br>[32] <a href=https://learn.g2.com/message-broker>https://learn.g2.com/message-broker</a><br>[33] <a href=https://danieltammadge.com/2021/11/message-brokers-vs-event-brokers/>https://danieltammadge.com/2021/11/message-brokers-vs-event-brokers/</a><br>[34] <a href=http://abitdeployed.com/2023/04/21/top-5-considerations-when-selecting-an-event-broker/>http://abitdeployed.com/2023/04/21/top-5-considerations-when-selecting-an-event-broker/</a><br>[35] <a href=https://blog.devops.dev/roadmap-to-backend-programming-master-understanding-and-implementing-message-brokers-in-net-92fce8089203>https://blog.devops.dev/roadmap-to-backend-programming-master-understanding-and-implementing-message-brokers-in-net-92fce8089203</a><br>[36] <a href=https://solace.com/blog/5-considerations-for-monitoring-your-event-broker/>https://solace.com/blog/5-considerations-for-monitoring-your-event-broker/</a><br>[37] <a href=https://github.com/cheatsnake/backend-cheats>https://github.com/cheatsnake/backend-cheats</a><br>[38] <a href=https://www.turing.com/blog/software-architecture-patterns-types>https://www.turing.com/blog/software-architecture-patterns-types</a><br>[39] <a href=https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern>https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern</a><br>[40] <a href=https://www.linkedin.com/pulse/practical-python-programming-tips-writing-high-quality-code-ekpue>https://www.linkedin.com/pulse/practical-python-programming-tips-writing-high-quality-code-ekpue</a><br>[41] <a href=https://epub.jku.at/download/pdf/8092986.pdf>https://epub.jku.at/download/pdf/8092986.pdf</a><br>[42] <a href=https://careers.walmart.com/us/jobs/WD2086176-usa-senior-software-engineer>https://careers.walmart.com/us/jobs/WD2086176-usa-senior-software-engineer</a><br>[43] <a href=https://nordicapis.com/whats-the-difference-between-event-brokers-and-message-queues/>https://nordicapis.com/whats-the-difference-between-event-brokers-and-message-queues/</a><br>[44] <a href="https://learn.microsoft.com/en-us/sql/relational-databases/event-classes/broker-message-classify-event-class?view=sql-server-ver16">https://learn.microsoft.com/en-us/sql/relational-databases/event-classes/broker-message-classify-event-class?view=sql-server-ver16</a><br>[45] <a href=https://www.infobip.com/downloads/messaging-trends-report-2025>https://www.infobip.com/downloads/messaging-trends-report-2025</a><br>[46] <a href=https://slashdot.org/software/event-brokers/>https://slashdot.org/software/event-brokers/</a><br>[47] <a href=https://www.eventible.com/learning/event-trends/>https://www.eventible.com/learning/event-trends/</a><br>[48] <a href=https://dev.to/binoy123/message-brokers-overview-42pe>https://dev.to/binoy123/message-brokers-overview-42pe</a></p><hr><p>Perplexity 로부터의 답변: pplx.ai/share<br><a href="https://www.ppomppu.co.kr/zboard/view.php?id=event2&amp;no=83373"><figure><img alt="[카카오톡] 크리스마스 프로필 꾸미기 이벤트 - 뽐뿌:이벤트게시판" loading=lazy src="https://tse2.mm.bing.net/th?id=OIP.ONkyBGfO4npnAxHHRE5EnAHaHR&pid=Api"></figure></a></p><p>주제인 &ldquo;Event and Message Brokers&rdquo; 는 &ldquo;Computer Science and Engineering > Backend Development&rdquo; 분류에 적절합니다. 이는 분산 시스템, 마이크로서비스 아키텍처, 비동기 통신 등 백엔드 개발의 핵심 영역과 밀접한 관련이 있기 때문입니다.</p><hr><h3 id=-요약-문장-200-자-이내>✅ 요약 문장 (200 자 이내)<a hidden class=anchor aria-hidden=true href=#-요약-문장-200-자-이내>#</a></h3><p>이벤트 및 메시지 브로커는 분산 시스템에서 구성 요소 간의 비동기 통신을 중개하여 확장성과 유연성을 높이는 핵심 인프라입니다.</p><hr><h3 id=-개요-250-자-이내>🧭 개요 (250 자 이내)<a hidden class=anchor aria-hidden=true href=#-개요-250-자-이내>#</a></h3><p>이벤트 및 메시지 브로커는 분산 시스템에서 서비스 간의 비동기 메시지 전달을 중개하는 미들웨어로, 시스템의 결합도를 낮추고 확장성과 유연성을 향상시킵니다. 이들은 이벤트 기반 아키텍처의 핵심 구성 요소로, 실시간 데이터 처리와 마이크로서비스 통합에 필수적입니다.</p><hr><h2 id=1-핵심-개념>1. 핵심 개념<a hidden class=anchor aria-hidden=true href=#1-핵심-개념>#</a></h2><ul><li><p><strong>메시지 브로커 (Message Broker)</strong>: 생산자 (Producer) 와 소비자 (Consumer) 간의 메시지를 중개하여 비동기 통신을 가능하게 하는 미들웨어입니다.(<a href="https://www.geeksforgeeks.org/what-are-message-brokers-in-system-design/?utm_source=chatgpt.com" title="What are Message Brokers in System Design? - GeeksforGeeks">GeeksforGeeks</a>)</p></li><li><p><strong>이벤트 브로커 (Event Broker)</strong>: 시스템 내에서 발생하는 이벤트를 관리하고, 이를 구독한 서비스에 전달하는 역할을 합니다.(<a href="https://www.confluent.io/learn/event-driven-architecture/?utm_source=chatgpt.com" title="Event-Driven Architecture (EDA): A Complete Introduction - Confluent">Confluent</a>)</p></li><li><p><strong>이벤트 기반 아키텍처 (Event-Driven Architecture)</strong>: 이벤트를 중심으로 시스템이 동작하는 아키텍처로, 이벤트 브로커를 통해 구성 요소 간의 느슨한 결합을 실현합니다.</p></li></ul><hr><h2 id=2-목적-및-필요성>2. 목적 및 필요성<a hidden class=anchor aria-hidden=true href=#2-목적-및-필요성>#</a></h2><ul><li><p>서비스 간 결합도 감소 (<a href="https://slashdot.org/software/event-brokers/?utm_source=chatgpt.com" title="Top Event Brokers in 2025 - Slashdot">Slashdot</a>)</p></li><li><p>비동기 통신 지원 (<a href="https://blog.greetinghr.com/greeting-release-update-1116/?utm_source=chatgpt.com" title="[11/16 릴리즈] 그리팅 문자메시지 업데이트 , 대량 문자 발송도 가능해요! - 그리팅 블로그">그리팅 블로그 | 채용에 경쟁력을 더하다</a>)</p></li><li><p>확장성과 유연성 향상</p></li><li><p>실시간 데이터 처리 가능</p></li><li><p>장애 격리 및 복원력 강화</p></li></ul><hr><h2 id=3-주요-기능-및-역할>3. 주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#3-주요-기능-및-역할>#</a></h2><ul><li><p>메시지 라우팅</p></li><li><p>메시지 저장 및 전달 보장</p></li><li><p>메시지 변환 및 필터링</p></li><li><p>트랜잭션 관리</p></li><li><p>모니터링 및 로깅</p></li></ul><hr><h2 id=4-특징>4. 특징<a hidden class=anchor aria-hidden=true href=#4-특징>#</a></h2><ul><li><p><strong>비동기성</strong>: 생산자와 소비자가 동시에 동작할 필요 없음</p></li><li><p><strong>확장성</strong>: 수평 확장을 통해 처리량 증가 가능 (<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern?utm_source=chatgpt.com" title="Publish–subscribe pattern">위키백과</a>)</p></li><li><p><strong>유연성</strong>: 다양한 프로토콜 및 데이터 형식 지원</p></li><li><p><strong>신뢰성</strong>: 메시지 손실 없이 전달 보장</p></li></ul><hr><h2 id=5-핵심-원칙>5. 핵심 원칙<a hidden class=anchor aria-hidden=true href=#5-핵심-원칙>#</a></h2><ul><li><p><strong>느슨한 결합 (Loose Coupling)</strong>: 서비스 간의 의존성을 최소화하여 독립적인 개발 및 배포 가능</p></li><li><p><strong>비동기 메시징 (Asynchronous Messaging)</strong>: 동기화된 호출 없이 메시지를 주고받음 (<a href="https://www.wallarm.com/what/what-is-a-message-broker?utm_source=chatgpt.com" title="What is a Message Broker? Explains Wallarm">wallarm.com</a>)</p></li><li><p><strong>발행 - 구독 모델 (Publish-Subscribe Model)</strong>: 생산자가 메시지를 발행하면, 이를 구독한 소비자들이 수신</p></li></ul><hr><h2 id=6-주요-원리-및-작동-원리>6. 주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#6-주요-원리-및-작동-원리>#</a></h2><p>이벤트 및 메시지 브로커는 다음과 같은 흐름으로 동작합니다:</p><ol><li><p><strong>생산자 (Producer)</strong>: 메시지를 생성하여 브로커에 전송</p></li><li><p><strong>브로커 (Broker)</strong>: 메시지를 수신하고, 설정된 규칙에 따라 큐나 토픽에 저장</p></li><li><p><strong>소비자 (Consumer)</strong>: 브로커로부터 메시지를 수신하여 처리</p></li></ol><p>이러한 구조는 시스템의 확장성과 유연성을 높이며, 장애 격리에도 유리합니다.</p><hr><h2 id=7-구조-및-아키텍처>7. 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#7-구조-및-아키텍처>#</a></h2><h3 id=필수-구성-요소>필수 구성 요소<a hidden class=anchor aria-hidden=true href=#필수-구성-요소>#</a></h3><ul><li><p><strong>생산자 (Producer)</strong>: 메시지를 생성하여 브로커에 전송하는 컴포넌트</p></li><li><p><strong>브로커 (Broker)</strong>: 메시지를 수신하고, 큐나 토픽에 저장하며, 소비자에게 전달</p></li><li><p><strong>소비자 (Consumer)</strong>: 브로커로부터 메시지를 수신하여 처리하는 컴포넌트</p></li></ul><h3 id=선택-구성-요소>선택 구성 요소<a hidden class=anchor aria-hidden=true href=#선택-구성-요소>#</a></h3><ul><li><p><strong>메시지 큐 (Message Queue)</strong>: 메시지를 순서대로 저장하는 구조</p></li><li><p><strong>토픽 (Topic)</strong>: 발행 - 구독 모델에서 메시지를 분류하는 단위</p></li><li><p><strong>라우터 (Router)</strong>: 메시지를 특정 경로로 전달하는 역할</p></li><li><p><strong>변환기 (Transformer)</strong>: 메시지의 형식을 변환하는 컴포넌트</p></li></ul><hr><h2 id=8-구현-기법>8. 구현 기법<a hidden class=anchor aria-hidden=true href=#8-구현-기법>#</a></h2><h3 id=81-메시지-큐-기반>8.1 메시지 큐 기반<a hidden class=anchor aria-hidden=true href=#81-메시지-큐-기반>#</a></h3><ul><li><p><strong>정의</strong>: 메시지를 큐에 저장하고, 소비자가 순차적으로 처리</p></li><li><p><strong>구성</strong>: 생산자, 메시지 큐, 소비자</p></li><li><p><strong>목적</strong>: 처리량 조절, 비동기 처리</p></li><li><p><strong>예시</strong>: RabbitMQ, Amazon SQS(<a href="https://www.infoq.com/articles/choosing-message-broker/?utm_source=chatgpt.com" title="A Practical Guide to Choosing the Right Message Broker - InfoQ">InfoQ</a>)</p></li></ul><h3 id=82-발행---구독-기반>8.2 발행 - 구독 기반<a hidden class=anchor aria-hidden=true href=#82-발행---구독-기반>#</a></h3><ul><li><p><strong>정의</strong>: 생산자가 메시지를 발행하면, 구독한 소비자들이 수신</p></li><li><p><strong>구성</strong>: 생산자, 브로커, 토픽, 소비자</p></li><li><p><strong>목적</strong>: 다수의 소비자에게 메시지 전달</p></li><li><p><strong>예시</strong>: Apache Kafka, Google Pub/Sub</p></li></ul><hr><h2 id=9-장점과-단점>9. 장점과 단점<a hidden class=anchor aria-hidden=true href=#9-장점과-단점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>확장성</td><td>수평 확장을 통해 처리량 증가 가능</td></tr><tr><td></td><td>유연성</td><td>다양한 프로토콜 및 데이터 형식 지원</td></tr><tr><td></td><td>신뢰성</td><td>메시지 손실 없이 전달 보장</td></tr><tr><td>⚠ 단점</td><td>복잡성</td><td>시스템 아키텍처가 복잡해질 수 있음</td></tr><tr><td></td><td>지연</td><td>메시지 전달에 시간이 소요될 수 있음</td></tr><tr><td></td><td>관리</td><td>브로커의 모니터링 및 유지보수가 필요</td></tr></tbody></table><hr><h2 id=10-도전-과제>10. 도전 과제<a hidden class=anchor aria-hidden=true href=#10-도전-과제>#</a></h2><ul><li><p><strong>메시지 순서 보장</strong>: 분산 환경에서 메시지의 순서를 보장하는 것은 어려울 수 있습니다.</p></li><li><p><strong>중복 메시지 처리</strong>: 메시지 중복 수신에 대한 처리 로직이 필요합니다.</p></li><li><p><strong>보안</strong>: 메시지의 기밀성, 무결성, 인증을 보장해야 합니다.</p></li><li><p><strong>모니터링 및 로깅</strong>: 시스템 상태를 실시간으로 모니터링하고, 로그를 분석할 수 있는 체계가 필요합니다.</p></li></ul><hr><h2 id=11-분류에-따른-종류-및-유형>11. 분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#11-분류에-따른-종류-및-유형>#</a></h2><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>메시징 모델</td><td>메시지 큐</td><td>생산자와 소비자 간의 일대일 통신</td></tr><tr><td></td><td>발행 - 구독</td><td>생산자가 메시지를 발행하면, 구독한 소비자들이 수신</td></tr><tr><td>배포 방식</td><td>온프레미스</td><td>자체 서버에 브로커를 설치하여 운영</td></tr><tr><td></td><td>클라우드 기반</td><td>클라우드 서비스로 브로커를 이용</td></tr><tr><td>사용 목적</td><td>데이터 스트리밍</td><td>실시간 데이터 처리에 최적화</td></tr><tr><td></td><td>작업 큐</td><td>백그라운드 작업 처리에 활용</td></tr></tbody></table><hr><h2 id=12-실무-적용-예시>12. 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#12-실무-적용-예시>#</a></h2><table><thead><tr><th>사례</th><th>설명</th></tr></thead><tbody><tr><td>전자상거래 주문 처리</td><td>주문 생성 시 메시지를 브로커에 발행하고, 재고 관리, 결제 처리, 배송 시스템이 이를 구독하여 처리</td></tr><tr><td>로그 수집 및 분석</td><td>애플리케이션 로그를 브로커를 통해 중앙 로그 시스템으로 전달하여 분석</td></tr><tr><td>실시간 알림 시스템</td><td>이</td></tr><tr><td>물론입니다. “12. 실무 적용 예시”부터 이어서 계속 작성하겠습니다.</td><td></td></tr></tbody></table><hr><h2 id=12-실무-적용-예시-계속>12. 실무 적용 예시 (계속)<a hidden class=anchor aria-hidden=true href=#12-실무-적용-예시-계속>#</a></h2><table><thead><tr><th>사례</th><th>설명</th></tr></thead><tbody><tr><td>✅ 실시간 알림 시스템</td><td>이벤트 발생 시 메시지를 브로커를 통해 사용자에게 실시간 푸시 알림 또는 이메일 전송</td></tr><tr><td>✅ IoT 센서 데이터 수집</td><td>수천 개의 센서에서 수집된 데이터를 브로커를 통해 중앙 처리 시스템으로 실시간 전송</td></tr><tr><td>✅ 금융 거래 처리</td><td>결제 요청, 거래 알림 등의 메시지를 안전하게 브로커를 통해 전달하고 처리 흐름을 분리</td></tr><tr><td>✅ 주문형 콘텐츠 스트리밍</td><td>사용자 요청 이벤트를 브로커로 전달하여 캐싱, 콘텐츠 인코딩, 전송 등의 처리를 병렬 수행</td></tr></tbody></table><hr><h2 id=13-활용-사례>13. 활용 사례<a hidden class=anchor aria-hidden=true href=#13-활용-사례>#</a></h2><h3 id=-시나리오-마이크로서비스-기반-이커머스-플랫폼의-주문-처리>🧪 시나리오: <strong>마이크로서비스 기반 이커머스 플랫폼의 주문 처리</strong><a hidden class=anchor aria-hidden=true href=#-시나리오-마이크로서비스-기반-이커머스-플랫폼의-주문-처리>#</a></h3><p><strong>1. 상황 설명:</strong><br>고객이 상품을 주문하면 여러 마이크로서비스(주문, 결제, 재고, 배송, 알림 등)가 비동기적으로 반응해야 함.</p><p><strong>2. 사용된 시스템 구성:</strong></p><ul><li><p><strong>이벤트 브로커</strong>: Apache Kafka</p></li><li><p><strong>서비스</strong>: 주문 서비스, 결제 서비스, 재고 서비스, 배송 서비스, 알림 서비스</p></li><li><p><strong>메시지 유형</strong>: <code>OrderCreated</code>, <code>PaymentProcessed</code>, <code>InventoryReserved</code>, <code>ShipmentScheduled</code>, <code>NotificationSent</code></p></li></ul><p><strong>3. 시스템 아키텍처 다이어그램:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[사용자]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[주문 서비스] -- OrderCreated --&gt; [Kafka Topic: orders]
</span></span><span class=line><span class=cl>                                            |
</span></span><span class=line><span class=cl>                      ------------------------------------------------
</span></span><span class=line><span class=cl>                      |                      |                      |
</span></span><span class=line><span class=cl>            [결제 서비스]       [재고 서비스]       [알림 서비스]
</span></span><span class=line><span class=cl>                      |                      |
</span></span><span class=line><span class=cl>            PaymentProcessed     InventoryReserved
</span></span><span class=line><span class=cl>                      |
</span></span><span class=line><span class=cl>             --&gt; Kafka Topic --&gt; [배송 서비스]
</span></span></code></pre></td></tr></table></div></div><p><strong>4. Workflow:</strong></p><ol><li><p>사용자 주문 → 주문 서비스가 <code>OrderCreated</code> 이벤트 생성</p></li><li><p>Kafka 토픽(<code>orders</code>)에 메시지 전송</p></li><li><p>결제/재고/알림 서비스는 이 토픽을 구독하여 동시 처리</p></li><li><p>결제 완료 후 <code>PaymentProcessed</code> 메시지 전송</p></li><li><p>배송 서비스가 해당 메시지를 받아 배송 스케줄링 진행</p></li></ol><p><strong>5. 담당 역할:</strong></p><ul><li><p>Kafka: 메시지 라우팅 및 전달</p></li><li><p>각 서비스: 독립적인 도메인 처리 및 이벤트 구독</p></li><li><p>알림 시스템: 이메일, 푸시 알림 등 사용자 피드백 전송</p></li></ul><hr><h2 id=14-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>14. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#14-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>메시지 중복</td><td>네트워크 장애 시 메시지가 중복 수신될 수 있음</td><td>멱등성(idempotency) 보장 로직 구현</td></tr><tr><td>메시지 순서</td><td>여러 파티션 사용 시 순서 보장이 어려움</td><td>키 기반 파티셔닝 또는 순서 보장 큐 사용</td></tr><tr><td>모니터링</td><td>메시지 흐름 추적 및 오류 분석 어려움</td><td>브로커 상태, lag, 소비자 상태 모니터링 도구 도입 (예: Prometheus + Grafana)</td></tr><tr><td>스키마 관리</td><td>메시지 포맷 변경 시 역호환성 문제 발생</td><td>Avro + Confluent Schema Registry 사용 권장</td></tr><tr><td>성능 병목</td><td>브로커 또는 소비자 처리 속도 제한</td><td>파티션 수 조정, 소비자 그룹 확장</td></tr><tr><td>장애 복구</td><td>브로커 장애 시 전체 서비스에 영향</td><td>클러스터 구성, 리플리케이션 설정 필요</td></tr></tbody></table><hr><h2 id=15-성능을-최적화하기-위한-고려사항-및-주의할-점>15. 성능을 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#15-성능을-최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>Throughput (처리량)</td><td>초당 처리 가능한 메시지 수</td><td>Batch 전송, 압축 사용, 프로듀서 Acks 설정 조정</td></tr><tr><td>Latency (지연)</td><td>메시지가 소비자에게 도달하는 시간</td><td>네트워크 대역폭 확보, 빠른 직렬화 포맷 (e.g., Avro) 사용</td></tr><tr><td>Storage</td><td>디스크 용량 및 메시지 보존 시간</td><td>Retention 기간 조절, 압축 전략 적용</td></tr><tr><td>Consumer Lag</td><td>소비자와 브로커 간 메시지 처리 지연</td><td>소비자 수 증가, 처리 병렬화</td></tr><tr><td>네트워크 오버헤드</td><td>데이터 전송량이 많을 경우 병목 발생</td><td>클러스터 간 데이터 로컬 처리, VPC 피어링 고려</td></tr><tr><td>메시지 직렬화</td><td>JSON 등 텍스트 기반 직렬화는 성능 저하</td><td>바이너리 포맷(Avro, Protobuf) 사용 권장</td></tr></tbody></table><hr><h2 id=16-추가로-알아야-할-하위-주제>16. 추가로 알아야 할 하위 주제<a hidden class=anchor aria-hidden=true href=#16-추가로-알아야-할-하위-주제>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>메시징 패턴</td><td>Pub/Sub, Queue, Fanout</td><td>이벤트 전달 구조별 메시지 처리 방식</td></tr><tr><td>QoS 보장</td><td>At-most-once, At-least-once, Exactly-once</td><td>메시지 수신 보장 수준</td></tr><tr><td>이벤트 저장소</td><td>Event Store vs Log</td><td>이벤트 저장 방식과 재생 기능 차이</td></tr><tr><td>브로커 아키텍처</td><td>중앙 집중형 vs 분산형</td><td>성능 및 장애 대응 전략에 따라 선택</td></tr><tr><td>클라우드 브로커</td><td>AWS SNS/SQS, GCP Pub/Sub</td><td>서버리스 메시징 시스템의 활용 방식</td></tr></tbody></table><hr><h2 id=17-추가로-학습해야-할-내용>17. 추가로 학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#17-추가로-학습해야-할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>데이터 흐름 제어</td><td>Flow Control</td><td>브로커와 소비자 간 처리 속도 균형 맞추기</td></tr><tr><td>이벤트 재처리</td><td>Replay / Rewind</td><td>장애 상황에서 메시지 재처리를 위한 기능</td></tr><tr><td>보안 설정</td><td>인증, 암호화, 권한 관리</td><td>메시징 시스템의 접근 제어 및 보안 설정</td></tr><tr><td>브로커 성능 분석</td><td>모니터링 지표 해석</td><td>CPU, 메모리, 네트워크, 토픽별 상태 분석</td></tr><tr><td>이벤트 설계</td><td>이벤트 정의 및 설계 전략</td><td>이벤트 이름, 필드 정의, 버전 관리 가이드라인</td></tr></tbody></table><hr><h2 id=18-2025년-기준-최신-동향>18. 2025년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#18-2025년-기준-최신-동향>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>기술</td><td>Kafka 4.0 릴리즈</td><td>KRaft 기반 클러스터 관리, ZooKeeper 제거</td></tr><tr><td>클라우드</td><td>Serverless 메시징 서비스</td><td>AWS EventBridge, GCP Pub/Sub 등의 성장</td></tr><tr><td>아키텍처</td><td>Event Mesh 확산</td><td>여러 브로커 간 이벤트 연결 및 표준화 진행 (AsyncAPI 기반)</td></tr><tr><td>보안</td><td>메시지 수준 암호화</td><td>메시지 단위의 보안 정책 강화 추세</td></tr><tr><td>성능</td><td>Zero-copy I/O 도입</td><td>Kafka, Pulsar 등에서 성능 극대화 기능 도입</td></tr></tbody></table><hr><h2 id=19-주제와-관련하여-주목할-내용>19. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#19-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>성능 최적화</td><td>Record Batching</td><td>소량 메시지의 묶음 전송으로 Throughput 향상</td></tr><tr><td>안정성 강화</td><td>Exactly-once Semantics</td><td>중복 메시지 방지 위한 기능 (Kafka, Pulsar 지원)</td></tr><tr><td>표준화</td><td>AsyncAPI</td><td>메시징 시스템 API 설계 표준으로 확산 중</td></tr><tr><td>운영 자동화</td><td>브로커 클러스터 오토스케일링</td><td>K8s 기반 브로커 자동 확장 적용 추세</td></tr></tbody></table><hr><h2 id=20-앞으로의-전망>20. 앞으로의 전망<a hidden class=anchor aria-hidden=true href=#20-앞으로의-전망>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>아키텍처</td><td>이벤트 중심 설계의 대중화</td><td>마이크로서비스, 서버리스 아키텍처와 결합되어 주류로 자리잡음</td></tr><tr><td>표준</td><td>AsyncAPI 확산</td><td>REST 이후 메시지 기반 API의 표준으로 채택 확대</td></tr><tr><td>인공지능</td><td>실시간 이벤트 기반 추론 시스템</td><td>실시간 스트리밍 데이터를 기반으로 한 AI 모델 추론 증가</td></tr><tr><td>브로커 기술</td><td>단일 브로커 → 이벤트 메시 네트워크로 확장</td><td>멀티 브로커 연계 구조 보편화</td></tr></tbody></table><hr><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Pub/Sub</td><td>발행-구독 모델로, 생산자가 발행한 메시지를 다수의 소비자가 구독하여 수신하는 구조</td></tr><tr><td>메시지 큐 (Message Queue)</td><td>메시지를 순서대로 저장하고 소비자에 의해 하나씩 처리되도록 하는 큐 기반 메시징</td></tr><tr><td>토픽 (Topic)</td><td>메시지를 특정 주제로 분류하여 다수의 소비자가 구독할 수 있도록 지원하는 단위</td></tr><tr><td>멱등성 (Idempotency)</td><td>동일한 메시지를 여러 번 처리해도 결과가 동일한 성질</td></tr><tr><td>Consumer Lag</td><td>브로커에 저장된 메시지와 소비자가 수신한 메시지 간 차이 (지연 지표)</td></tr></tbody></table><hr><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><p><a href=https://kafka.apache.org/>Apache Kafka 공식 문서</a></p></li><li><p><a href=https://www.rabbitmq.com/tutorials/tutorial-one-python.html>RabbitMQ 아키텍처 설명</a></p></li><li><p><a href=https://aws.amazon.com/messaging/>AWS Messaging 서비스 소개</a></p></li><li><p><a href=https://www.confluent.io/what-is-apache-kafka/>Confluent Kafka 설명 문서</a></p></li><li><p><a href=https://www.asyncapi.com/>AsyncAPI 공식 사이트</a></p></li></ul><hr><p>필요 시 각 요소에 대한 다이어그램, 시스템 설계 문서, 혹은 특정 브로커 비교 분석도 제공 가능합니다. 추가 요청해 주세요.</p><p>좋습니다. 아래에 <strong>시스템 설계 문서 샘플</strong>과 함께, 대표적인 메시지 브로커에 대한 <strong>비교 분석 표</strong>를 제공하겠습니다.</p><hr><h2 id=-시스템-설계-문서-샘플-이벤트-기반-주문-처리-시스템>✅ 시스템 설계 문서 (샘플: 이벤트 기반 주문 처리 시스템)<a hidden class=anchor aria-hidden=true href=#-시스템-설계-문서-샘플-이벤트-기반-주문-처리-시스템>#</a></h2><h3 id=-목적>🎯 목적<a hidden class=anchor aria-hidden=true href=#-목적>#</a></h3><p>이커머스 플랫폼에서 주문 요청을 이벤트 기반으로 처리하여, 유연한 마이크로서비스 통신과 확장성을 확보.</p><h3 id=-시스템-구성-요소>🏗️ 시스템 구성 요소<a hidden class=anchor aria-hidden=true href=#-시스템-구성-요소>#</a></h3><table><thead><tr><th>컴포넌트</th><th>설명</th></tr></thead><tbody><tr><td><strong>주문 서비스 (Order Service)</strong></td><td>주문 요청을 받아 <code>OrderCreated</code> 이벤트 발행</td></tr><tr><td><strong>이벤트 브로커 (Kafka)</strong></td><td>메시지 큐 및 토픽 기반으로 이벤트 중계</td></tr><tr><td><strong>결제 서비스 (Payment Service)</strong></td><td><code>OrderCreated</code> 이벤트 수신 후 결제 진행</td></tr><tr><td><strong>재고 서비스 (Inventory Service)</strong></td><td><code>OrderCreated</code> 수신 후 재고 차감</td></tr><tr><td><strong>배송 서비스 (Shipping Service)</strong></td><td><code>PaymentProcessed</code> 이벤트 이후 배송 예약</td></tr><tr><td><strong>알림 서비스 (Notification Service)</strong></td><td>각 이벤트 발생 시 사용자에게 알림 전송</td></tr></tbody></table><h3 id=-메시지-흐름-워크플로우>📌 메시지 흐름 (워크플로우)<a hidden class=anchor aria-hidden=true href=#-메시지-흐름-워크플로우>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>[주문 서비스]
</span></span><span class=line><span class=cl>     └─ OrderCreated 이벤트
</span></span><span class=line><span class=cl>          └──&gt; [Kafka: orders 토픽]
</span></span><span class=line><span class=cl>                    ├─&gt; [결제 서비스]
</span></span><span class=line><span class=cl>                    ├─&gt; [재고 서비스]
</span></span><span class=line><span class=cl>                    └─&gt; [알림 서비스]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[결제 완료 시]
</span></span><span class=line><span class=cl>     └─ PaymentProcessed 이벤트
</span></span><span class=line><span class=cl>          └──&gt; [Kafka: payments 토픽]
</span></span><span class=line><span class=cl>                    └─&gt; [배송 서비스]
</span></span></code></pre></td></tr></table></div></div><h3 id=-설계-고려-사항>⚙️ 설계 고려 사항<a hidden class=anchor aria-hidden=true href=#-설계-고려-사항>#</a></h3><table><thead><tr><th>고려 요소</th><th>설명</th><th>대응 방안</th></tr></thead><tbody><tr><td>메시지 유실 방지</td><td>장애 발생 시 메시지 보존</td><td>Kafka replication, ACK 설정</td></tr><tr><td>순서 보장</td><td>순차적 주문 처리 필요</td><td>파티션 키 설정, 단일 파티션 사용</td></tr><tr><td>중복 방지</td><td>중복 이벤트 처리 리스크</td><td>멱등성 ID, 상태 기반 필터링</td></tr><tr><td>장애 복구</td><td>하나의 서비스가 실패할 경우 전체 영향</td><td>재시도 전략, DLQ (Dead Letter Queue) 구성</td></tr></tbody></table><hr><h2 id=-대표-메시지-브로커-비교-분석>✅ 대표 메시지 브로커 비교 분석<a hidden class=anchor aria-hidden=true href=#-대표-메시지-브로커-비교-분석>#</a></h2><table><thead><tr><th>항목</th><th>Apache Kafka</th><th>RabbitMQ</th><th>Amazon SQS</th><th>Google Pub/Sub</th><th>NATS</th></tr></thead><tbody><tr><td><strong>모델</strong></td><td>로그 기반 스트리밍 (Pub/Sub)</td><td>큐 기반 (Pub/Sub 지원)</td><td>큐 기반 (FIFO 지원)</td><td>Pub/Sub 스트리밍</td><td>Pub/Sub 및 RPC</td></tr><tr><td><strong>설치 형태</strong></td><td>온프레미스, 클라우드</td><td>온프레미스, 클라우드</td><td>Fully managed</td><td>Fully managed</td><td>경량형 배포</td></tr><tr><td><strong>브로커 구조</strong></td><td>분산형, 파티셔닝</td><td>중앙 집중형</td><td>클라우드 내부</td><td>클라우드 내부</td><td>경량 메시지 버스</td></tr><tr><td><strong>사용 언어</strong></td><td>Java 중심 (다양한 클라이언트 제공)</td><td>Erlang</td><td>REST API</td><td>REST, gRPC</td><td>Go</td></tr><tr><td><strong>장점</strong></td><td>고처리량, 확장성, 메시지 재처리</td><td>간단한 설정, 빠른 응답</td><td>서버리스, 확장성 우수</td><td>실시간 확장성, 관리 용이</td><td>초경량, 빠른 메시징</td></tr><tr><td><strong>단점</strong></td><td>복잡한 설정, 운영 비용</td><td>메시지 지속성 약함</td><td>메시지 처리 지연 존재</td><td>Latency 발생 가능</td><td>기능 제한적</td></tr><tr><td><strong>신뢰성</strong></td><td>Exactly-once 지원 (v2 이상)</td><td>At-least-once 중심</td><td>At-least-once</td><td>At-least-once</td><td>기본은 at-most-once</td></tr><tr><td><strong>스키마 지원</strong></td><td>Avro + Schema Registry</td><td>없음</td><td>없음</td><td>JSON 기반</td><td>없음</td></tr><tr><td><strong>활용 사례</strong></td><td>대규모 로그, 이벤트 처리</td><td>백오피스 작업 큐</td><td>주문형 메시징</td><td>실시간 이벤트 수집</td><td>IoT, Edge 데이터 처리</td></tr></tbody></table><hr><h2 id=-추가-비교-다이어그램-브로커-선택-기준>🔎 추가 비교 다이어그램 (브로커 선택 기준)<a hidden class=anchor aria-hidden=true href=#-추가-비교-다이어그램-브로커-선택-기준>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>            ┌─────────────┐
</span></span><span class=line><span class=cl>            │ 성능이 중요한가? │
</span></span><span class=line><span class=cl>            └─────┬───────┘
</span></span><span class=line><span class=cl>                  │ 예
</span></span><span class=line><span class=cl>                  ▼
</span></span><span class=line><span class=cl>           ┌─────────────┐
</span></span><span class=line><span class=cl>           │ Kafka or NATS │
</span></span><span class=line><span class=cl>           └─────┬───────┘
</span></span><span class=line><span class=cl>        아니오   │
</span></span><span class=line><span class=cl>        ┌────────┴────────┐
</span></span><span class=line><span class=cl>        ▼                 ▼
</span></span><span class=line><span class=cl>    설정이 단순한가?   서버리스가 필요한가?
</span></span><span class=line><span class=cl>        │ 예             │ 예
</span></span><span class=line><span class=cl>        ▼                 ▼
</span></span><span class=line><span class=cl>    RabbitMQ           AWS SQS / PubSub
</span></span></code></pre></td></tr></table></div></div><hr><p>이후 원하시면 다음 항목도 확장해 드릴 수 있습니다:</p><ul><li><p>브로커 별 메시지 보장 전략 시나리오 비교</p></li><li><p>Kafka vs Pulsar 심층 비교</p></li><li><p>실시간 vs 비실시간 메시지 처리 시스템 설계 차이</p></li><li><p>IoT, 게임, 금융 등 산업별 브로커 활용 사례</p></li></ul><p>필요한 항목을 말씀해 주세요.</p><p>실시간(Real-time) 메시지 처리 시스템과 비실시간(Batch 또는 Near Real-time) 메시지 처리 시스템은 <strong>설계 목적, 성능 요구사항, 아키텍처 구성</strong>에서 명확한 차이를 가집니다. 아래에 비교를 통해 설계 차이를 정리하고, 시스템 구조 예시를 포함해 설명드리겠습니다.</p><hr><h2 id=-실시간-vs-비실시간-메시지-처리-시스템-비교>✅ 실시간 vs 비실시간 메시지 처리 시스템 비교<a hidden class=anchor aria-hidden=true href=#-실시간-vs-비실시간-메시지-처리-시스템-비교>#</a></h2><table><thead><tr><th>구분</th><th>실시간 메시지 처리 시스템</th><th>비실시간 메시지 처리 시스템</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>이벤트가 발생하는 즉시 처리</td><td>이벤트가 일정 시간 단위로 일괄 처리</td></tr><tr><td><strong>처리 지연</strong></td><td>수 ms ~ 수 초</td><td>수 초 ~ 수 분 이상</td></tr><tr><td><strong>브로커 예시</strong></td><td>Apache Kafka, NATS, Pulsar, Google Pub/Sub</td><td>Amazon SQS, RabbitMQ, AWS Kinesis Data Firehose</td></tr><tr><td><strong>사용 목적</strong></td><td>실시간 알림, 금융 거래, IoT 센서, AI 추론</td><td>로그 수집, 통계 처리, 보고서 생성</td></tr><tr><td><strong>처리 단위</strong></td><td>단건 이벤트, Stream</td><td>일괄 메시지, Batch</td></tr><tr><td><strong>복잡도</strong></td><td>높은 동기화, 장애 대응 필요</td><td>상대적으로 단순</td></tr><tr><td><strong>데이터 정확성</strong></td><td>고신뢰 메시지 보장 필요</td><td>지연 허용 가능, 신뢰성 일부 낮음</td></tr><tr><td><strong>보통 구조</strong></td><td>Pub/Sub, Stream Processing</td><td>Queue 기반 일괄 소비</td></tr><tr><td><strong>대표 기술</strong></td><td>Kafka + Flink, Pulsar Functions, EventBridge</td><td>SQS + Lambda, Kinesis Firehose, Hadoop</td></tr><tr><td><strong>장점</strong></td><td>사용자 반응성, 자동화, 예측 기반 처리</td><td>단순 구성, 비용 효율성, 안정성</td></tr><tr><td><strong>단점</strong></td><td>운영 복잡도, 높은 인프라 비용</td><td>늦은 응답, 실시간 피드백 불가</td></tr></tbody></table><hr><h2 id=-아키텍처-차이-도식>🏗️ 아키텍처 차이 도식<a hidden class=anchor aria-hidden=true href=#-아키텍처-차이-도식>#</a></h2><h3 id=1-실시간-메시지-처리-아키텍처>1. 실시간 메시지 처리 아키텍처<a hidden class=anchor aria-hidden=true href=#1-실시간-메시지-처리-아키텍처>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[이벤트 발생 (앱, IoT, 웹)]
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>   [Message Broker (Kafka)]
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>[실시간 처리 엔진 (Flink, Spark Streaming)]
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>   [DB / 알림 시스템 / 추론 API]
</span></span></code></pre></td></tr></table></div></div><ul><li>특징: 메시지가 발생하는 즉시 소비자에게 전달 → 실시간 처리 후 알림 또는 결과 반환</li></ul><hr><h3 id=2-비실시간-메시지-처리-아키텍처>2. 비실시간 메시지 처리 아키텍처<a hidden class=anchor aria-hidden=true href=#2-비실시간-메시지-처리-아키텍처>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[로그, 이벤트 수집]
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>[Message Queue (SQS, RabbitMQ)]
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>[Batch Consumer (Lambda, ETL Job)]
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>[Data Lake, RDS, 보고서 시스템]
</span></span></code></pre></td></tr></table></div></div><ul><li>특징: 일정 주기로 메시지를 수신하여 한번에 묶어 처리 → DB 적재 또는 정기 리포트 생성</li></ul><hr><h2 id=-설계-시-고려할-점>📌 설계 시 고려할 점<a hidden class=anchor aria-hidden=true href=#-설계-시-고려할-점>#</a></h2><table><thead><tr><th>요소</th><th>실시간 설계 시 고려사항</th><th>비실시간 설계 시 고려사항</th></tr></thead><tbody><tr><td>메시지 지연</td><td>Low Latency (ms 단위)</td><td>1분 이상 허용</td></tr><tr><td>메시지 순서</td><td>순서 보장 필수 (Kafka 파티션)</td><td>순서 필요 없을 수 있음</td></tr><tr><td>장애 복구</td><td>이벤트 재처리 또는 재시도 큐 구성</td><td>실패한 Job의 재시도 설정 중심</td></tr><tr><td>데이터 보존</td><td>이벤트 저장 (로그 재생 등)</td><td>일정 기간 후 삭제</td></tr><tr><td>리소스 비용</td><td>지속적인 소비 → 높은 비용</td><td>예약 실행, 스팟 인스턴스 등으로 절감 가능</td></tr></tbody></table><hr><h2 id=-사용-시나리오-예시>🧪 사용 시나리오 예시<a hidden class=anchor aria-hidden=true href=#-사용-시나리오-예시>#</a></h2><table><thead><tr><th>시스템</th><th>실시간</th><th>비실시간</th></tr></thead><tbody><tr><td>온라인 쇼핑 결제</td><td>✅</td><td>❌</td></tr><tr><td>시스템 로그 분석</td><td>❌</td><td>✅</td></tr><tr><td>실시간 주가 모니터링</td><td>✅</td><td>❌</td></tr><tr><td>월간 매출 보고서</td><td>❌</td><td>✅</td></tr><tr><td>사용자 행동 기반 추천</td><td>✅</td><td>✅ (Near Real-time)</td></tr><tr><td>고객 알림 전송</td><td>✅</td><td>✅ (스케줄형)</td></tr></tbody></table><hr><h2 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><ul><li><p><strong>실시간 처리 시스템</strong>은 반응성, 자동화, 사용자 경험 향상을 중시하는 분야에 적합하지만 복잡도와 비용이 증가합니다.</p></li><li><p><strong>비실시간 처리 시스템</strong>은 대규모 데이터 처리에 안정성과 경제성을 제공하지만, 실시간 피드백이 필요한 시스템에는 부적합합니다.</p></li><li><p>실무에서는 <strong>혼합형 아키텍처</strong>(예: Kafka + S3 + Athena)로 실시간과 비실시간 처리를 병행하는 사례가 많습니다.</p></li></ul><hr><p>필요하시면 <strong>Kafka 기반 실시간 처리 구성도</strong> 혹은 <strong>SQS 기반 비실시간 처리 예제 코드</strong>도 추가로 제공해드릴 수 있습니다. 어떤 항목이 더 궁금하신가요?</p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Brokers</h2></header><div class=entry-content><p>Event Brokers 이벤트 브로커는 현대 분산 시스템과 마이크로서비스 아키텍처의 핵심 구성 요소로, 비동기 통신과 시스템 간 느슨한 결합을 가능하게 한다. Event Broker 는 이벤트 생성자 (Producer) 와 이벤트 소비자 (Consumer) 사이에서 중개자 역할을 수행한다.
Source: https://developer.confluent.io/patterns/event-stream/event-broker/
이벤트 브로커 기초 개념 이벤트 브로커란? 이벤트 브로커는 이벤트 생산자 (Producer) 와 소비자 (Consumer) 사이에서 메시지를 중개하는 미들웨어이다. 생산자는 이벤트를 발행 (publish) 하고, 소비자는 관심 있는 이벤트를 구독 (subscribe) 하는 발행 - 구독 (Pub/Sub) 패턴을 기반으로 한다.
...</p></div><footer class=entry-footer><span title='2024-10-25 06:28:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;62 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Brokers" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/fundamentals/event-brokers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs</h2></header><div class=entry-content><p>Event-driven APIs 이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다. 전통적인 요청-응답(Request-Response) 방식과 달리, 이벤트 기반 API에서는 클라이언트가 특정 이벤트에 관심을 표현하고 구독하면, 해당 이벤트가 발생할 때마다 서버가 클라이언트에게 알림을 보낸다.
이벤트 기반 API의 핵심 원리는 느슨한 결합(loose coupling)과 비동기 통신(asynchronous communication)에 있다. 이벤트 발행자(producer)와 소비자(consumer) 사이에는 직접적인 의존성이 없으며, 이벤트 브로커나 메시지 버스를 통해 간접적으로 통신한다. 이러한 특성은 시스템 구성 요소 간의 독립성을 높이고, 확장성과 유연성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-02-28 03:40:00 +0000 UTC'>February 28, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>