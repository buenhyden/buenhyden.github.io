<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SAML vs. OAuth 2.0 | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design,Authentication-Methods,SAML"><meta name=description content="SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이고 OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/saml-vs-oauth-20/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/saml-vs-oauth-20/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/saml-vs-oauth-20/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="SAML vs. OAuth 2.0"><meta property="og:description" content="SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이고 OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-11T13:31:00+00:00"><meta property="article:modified_time" content="2025-03-11T13:31:00+00:00"><meta property="article:tag" content="Backend Development"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="Authentication-Methods"><meta property="article:tag" content="SAML"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="SAML vs. OAuth 2.0"><meta name=twitter:description content="SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이고 OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Cybersecurity and Information Security","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/"},{"@type":"ListItem","position":3,"name":"Access Control","item":""},{"@type":"ListItem","position":4,"name":"Authentication","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/"},{"@type":"ListItem","position":6,"name":"SAML","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/"},{"@type":"ListItem","position":7,"name":"SAML vs. OAuth 2.0","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/saml-vs-oauth-20/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SAML vs. OAuth 2.0","name":"SAML vs. OAuth 2.0","description":"SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이고 OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다.","keywords":["Backend-Development","API-Design","Authentication-Methods","SAML"],"articleBody":"SAML vs. OAuth 2.0 인증(Authentication)과 권한 부여(Authorization)는 현대 웹 애플리케이션과 시스템에서 핵심적인 보안 구성 요소이다. SAML(Security Assertion Markup Language)과 OAuth 2.0은 이러한 기능을 제공하는 두 가지 주요 프로토콜이지만, 설계 철학, 사용 사례 및 기술적 구현에서 상당한 차이가 있다.\n기본 개념 및 역사 SAML (Security Assertion Markup Language) SAML은 2002년 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 개발된 XML 기반 개방형 표준으로, 당시 기업들이 직면한 단일 인증 문제를 해결하기 위해 설계되었다. 현재 가장 널리 사용되는 버전은 2005년에 발표된 SAML 2.0이다.\nSAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이다. 이를 통해 사용자는 한 번 로그인하여 여러 서비스에 접근할 수 있다(SSO, Single Sign-On).\nOAuth 2.0 OAuth는 원래 2007년에 Twitter와 Google의 엔지니어들에 의해 개발되었으며, 2012년에 IETF(Internet Engineering Task Force)에 의해 OAuth 2.0으로 표준화되었다.\nOAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다. 이는 소셜 미디어 플랫폼이 성장하면서 발생한 ‘비밀번호 안티패턴’(여러 서비스에 동일한 비밀번호 사용) 문제를 해결하기 위해 개발되었다.\n기본 아키텍처 및 작동 방식 SAML의 작동 방식 SAML은 다음과 같은 주요 구성 요소로 이루어져 있다:\n주체(Principal): 인증을 요청하는 사용자 신원 공급자(IdP): 사용자를 인증하고 SAML 어설션을 발행하는 시스템 서비스 공급자(SP): 사용자가 접근하고자 하는 애플리케이션 또는 서비스 SAML의 일반적인 인증 흐름은 다음과 같다(SP-초기화 흐름 기준):\n사용자가 SP에 접근을 시도한다. SP는 사용자를 IdP로 리다이렉트한다(SAML 인증 요청 포함). IdP는 사용자를 인증한다(이미 인증된 세션이 없는 경우). IdP는 SAML 어설션(사용자 ID 및 속성 정보 포함)을 생성한다. IdP는 사용자 브라우저를 SAML 어설션과 함께 SP로 다시 리다이렉트한다. SP는 SAML 어설션을 검증하고 사용자에게 접근 권한을 부여한다. OAuth 2.0의 작동 방식 OAuth 2.0은 다음과 같은 주요 구성 요소로 이루어져 있다:\n리소스 소유자(Resource Owner): 보호된 리소스에 대한 접근 권한을 부여하는 사용자 클라이언트(Client): 리소스 소유자를 대신하여 보호된 리소스에 접근하려는 애플리케이션 권한 부여 서버(Authorization Server): 리소스 소유자를 인증하고 액세스 토큰을 발행하는 서버 리소스 서버(Resource Server): 보호된 리소스를 호스팅하는 서버 OAuth 2.0의 일반적인 권한 부여 흐름(권한 부여 코드 흐름)은 다음과 같다:\n클라이언트가 리소스 소유자에게 권한을 요청한다. 리소스 소유자가 권한을 부여하면, 클라이언트는 권한 부여 코드를 받는다. 클라이언트는 권한 부여 코드와 자신의 인증 정보를 권한 부여 서버에 제출한다. 권한 부여 서버는 클라이언트를 인증하고 권한 부여 코드를 검증한 후, 액세스 토큰을 발행한다. 클라이언트는 액세스 토큰을 사용하여 리소스 서버의 보호된 리소스에 접근한다. 주요 차이점 주요 목적 및 용도\nSAML: 주로 기업 환경에서 단일 로그인(SSO)을 구현하기 위해 설계되었다. 사용자가 여러 애플리케이션에 한 번만 로그인할 수 있도록 하는 인증(Authentication)에 중점을 둔다. OAuth 2.0: 주로 타사 애플리케이션이 사용자 데이터에 접근할 수 있도록 권한을 부여하는 데 중점을 둔다. 즉, 인증보다는 권한 부여(Authorization)에 초점을 맞춘다. 기술적 구현\nSAML: XML 기반 프로토콜로, 메시지 형식이 복잡하고 크기가 크다. XML 서명과 암호화를 사용하여 메시지 보안을 제공한다. OAuth 2.0: 경량화된 JSON/HTTP 기반 프로토콜로, 구현이 상대적으로 간단하다. TLS/SSL을 통한 전송 보안에 의존한다. 토큰 및 데이터 형식\nSAML: SAML 어설션은 XML 문서로, 서명 및 암호화될 수 있다. 어설션에는 인증, 속성 및 권한 부여 결정 정보가 포함될 수 있다. OAuth 2.0: 액세스 토큰은 일반적으로 불투명한 문자열이며, 리프레시 토큰을 통해 새로운 액세스 토큰을 획득할 수 있다. JWT(JSON Web Token)를 사용하여 토큰에 클레임을 포함할 수도 있다. 클라이언트 유형 및 애플리케이션 지원\nSAML: 주로 웹 애플리케이션에 초점을 맞추고 있으며, 브라우저 리다이렉션에 의존한다. 모바일 또는 단일 페이지 애플리케이션(SPA)에서는 제한적으로 사용된다. OAuth 2.0: 다양한 클라이언트 유형(웹, 모바일, 데스크톱, IoT 장치 등)을 지원하도록 설계되었다. 다양한 애플리케이션 유형에 맞는 여러 가지 권한 부여 흐름을 제공한다. 확장성 및 적응성\nSAML: 엄격한 XML 스키마를 따르며, 확장이 복잡할 수 있다. 주로 대규모 엔터프라이즈 환경에서 사용된다. OAuth 2.0: 더 모듈화되고 확장 가능한 프레임워크로 설계되었다. OpenID Connect와 같은 확장을 통해 인증 기능을 추가할 수 있다. 수명 주기 및 세션 관리\nSAML: 세션 관리에 대한 내장 지원을 제공한다. 단일 로그아웃(SLO) 기능을 통해 여러 서비스에서 동시에 로그아웃할 수 있다. OAuth 2.0: 기본적으로 세션 관리 기능이 없으며, 토큰 만료 시간을 통해 간접적으로 관리된다. 세션 관리는 일반적으로 추가 메커니즘을 통해 구현해야 한다. 보안 특성\nSAML: XML 서명과 암호화를 통해 강력한 메시지 수준 보안을 제공한다. 기업 환경에서 높은 수준의 보안을 제공하도록 설계되었다. OAuth 2.0: TLS/SSL을 통한 전송 수준 보안에 의존한다. PKCE(Proof Key for Code Exchange)와 같은 추가 보안 메커니즘을 통해 특정 위협을 완화할 수 있다. 사용 사례 비교 SAML에 적합한 사용 사례 기업 단일 로그인(SSO): 직원들이 한 번의 로그인으로 여러 내부 시스템에 접근할 수 있다. B2B 연합(Federation): 비즈니스 파트너 간의 신원 정보 교환을 용이하게 한다. 클라우드 서비스 통합: 기업 자격 증명으로 SaaS 애플리케이션(Salesforce, Office 365 등)에 접근한다. 고도의 규제를 받는 산업: 의료, 금융 등에서 강력한 보안 및 감사 요구 사항을 충족한다. OAuth 2.0에 적합한 사용 사례 API 접근 제어: 타사 애플리케이션이 사용자 데이터에 안전하게 접근할 수 있도록 한다. 소셜 로그인: Facebook, Google 등의 계정을 사용하여 다른 서비스에 로그인한다. 모바일 애플리케이션: 네이티브 모바일 앱에서 서버 API에 대한 권한 부여를 처리한다. 마이크로서비스 아키텍처: 서비스 간 통신에서 권한 부여를 관리한다. IoT 장치: 제한된 리소스를 가진 장치에서 API 접근을 관리한다. 구현 복잡성 SAML 구현의 복잡성\nSAML 구현은 일반적으로 다음과 같은 이유로 더 복잡하다: XML 처리 및 XML 디지털 서명에 대한 지식이 필요하다. 메타데이터 교환 및 관리가 복잡할 수 있다. 디버깅이 어려울 수 있으며, 오류 메시지가 명확하지 않을 수 있다. 초기 설정 및 구성이 복잡하다. OAuth 2.0 구현의 복잡성\nOAuth 2.0은 상대적으로 구현이 더 간단하지만, 여전히 몇 가지 도전 과제가 있다: 다양한 권한 부여 흐름을 이해하고 적절히 선택해야 한다. 토큰 관리 및 검증이 필요하다. CSRF 공격 및 기타 보안 위협에 대한 보호 메커니즘을 구현해야 한다. 리다이렉션 URI 관리 및 상태 파라미터 처리가 필요하다. 최신 동향 및 미래 전망 SAML의 현재 상태 SAML은 성숙한 기술로, 많은 기업에서 여전히 광범위하게 사용되고 있다. 특히 대규모 기업 환경과 전통적인 웹 애플리케이션에서 강점을 보인다. 그러나 모바일 및 최신 웹 아키텍처에서는 사용이 감소하는 추세이다.\nOAuth 2.0의 진화 OAuth 2.0은 계속해서 발전하고 확장되고 있다. OpenID Connect(OIDC)와의 통합을 통해 인증 기능이 강화되었으며, OAuth 2.1이 개발 중이다. OAuth 2.0은 API 경제와 마이크로서비스 아키텍처가 성장함에 따라 더욱 중요해지고 있다.\n두 프로토콜의 사용 전망 현재 많은 조직에서는 사용 사례에 따라 SAML과 OAuth를 함께 사용하고 있다:\nSAML은 내부 기업 SSO 및 B2B 시나리오에서 계속 사용된다. OAuth 2.0과 OIDC는 새로운 API 중심 개발, 모바일 앱 및 최신 웹 애플리케이션에 선호된다. 장기적으로는 OAuth 2.0/OIDC로의 점진적인 이동이 예상되지만, SAML은 특히 레거시 시스템 및 특정 엔터프라이즈 사용 사례에서 계속해서 중요한 역할을 할 것이다. SAML과 OAuth 2.0 비교 특성 SAML 2.0 OAuth 2.0 출시 연도 2005년 2012년 주요 목적 인증(Authentication) 권한 부여(Authorization) 사용 사례 기업 SSO, B2B 연합 API 접근 제어, 소셜 로그인 데이터 형식 XML JSON/HTTP 토큰 유형 SAML 어설션(XML) 액세스 토큰(일반적으로 JWT) 클라이언트 지원 주로 웹 애플리케이션 다양한 클라이언트(웹, 모바일, SPA, IoT 등) 복잡성 높음 중간 메시지 크기 큼 작음 보안 메커니즘 XML 서명 및 암호화 TLS/SSL, JWT 서명 세션 관리 내장 지원(SLO 포함) 제한적(토큰 만료에 의존) 확장성 제한적 높음(OpenID Connect 등 확장 가능) 모바일 지원 제한적 강력함 구현 용이성 낮음 중간에서 높음 디버깅 용이성 낮음 중간 메타데이터 지원 강력함 제한적(디스커버리 메커니즘) 산업 채택률 기업 및 전통적 웹 앱 위주 광범위(웹, 모바일, API 등) 미래 전망 엔터프라이즈 환경에서 안정적 사용 지속적인 성장 및 발전 주요 지원 기업 Microsoft, IBM, Oracle Google, Facebook, Microsoft, Twitter 표준화 기관 OASIS IETF 상호 운용성 높음(기업 환경 내) 높음(다양한 환경) 개방성 개방형 표준 개방형 표준 개발자 친화도 낮음 높음 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1148","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-03-11T13:31:00Z","dateModified":"2025-03-11T13:31:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/saml-vs-oauth-20/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/>Cybersecurity and Information Security</a>&nbsp;»&nbsp;<a href>Access Control</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/>Authentication</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/protocols/saml/>SAML</a></div><h1 class="post-title entry-hint-parent">SAML vs. OAuth 2.0</h1><div class=post-description>SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이고 OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다.</div><div class=post-meta><span title='2025-03-11 13:31:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Cybersecurity%20and%20Information%20Security/Access%20Control/Authentication/Protocols/SAML/saml-vs-oauth-20.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#saml-vs-oauth-20>SAML vs. OAuth 2.0</a><ul><li><a href=#기본-개념-및-역사>기본 개념 및 역사</a></li><li><a href=#기본-아키텍처-및-작동-방식>기본 아키텍처 및 작동 방식</a></li><li><a href=#주요-차이점>주요 차이점</a></li><li><a href=#사용-사례-비교>사용 사례 비교</a></li><li><a href=#구현-복잡성>구현 복잡성</a></li><li><a href=#최신-동향-및-미래-전망>최신 동향 및 미래 전망</a></li><li><a href=#saml과-oauth-20-비교>SAML과 OAuth 2.0 비교</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=saml-vs-oauth-20>SAML vs. OAuth 2.0<a hidden class=anchor aria-hidden=true href=#saml-vs-oauth-20>#</a></h2><p>인증(Authentication)과 권한 부여(Authorization)는 현대 웹 애플리케이션과 시스템에서 핵심적인 보안 구성 요소이다. SAML(Security Assertion Markup Language)과 OAuth 2.0은 이러한 기능을 제공하는 두 가지 주요 프로토콜이지만, 설계 철학, 사용 사례 및 기술적 구현에서 상당한 차이가 있다.</p><h3 id=기본-개념-및-역사>기본 개념 및 역사<a hidden class=anchor aria-hidden=true href=#기본-개념-및-역사>#</a></h3><h4 id=saml-security-assertion-markup-language>SAML (Security Assertion Markup Language)<a hidden class=anchor aria-hidden=true href=#saml-security-assertion-markup-language>#</a></h4><p>SAML은 2002년 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 개발된 XML 기반 개방형 표준으로, 당시 기업들이 직면한 단일 인증 문제를 해결하기 위해 설계되었다. 현재 가장 널리 사용되는 버전은 2005년에 발표된 SAML 2.0이다.</p><p>SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이다. 이를 통해 사용자는 한 번 로그인하여 여러 서비스에 접근할 수 있다(SSO, Single Sign-On).</p><h4 id=oauth-20>OAuth 2.0<a hidden class=anchor aria-hidden=true href=#oauth-20>#</a></h4><p>OAuth는 원래 2007년에 Twitter와 Google의 엔지니어들에 의해 개발되었으며, 2012년에 IETF(Internet Engineering Task Force)에 의해 OAuth 2.0으로 표준화되었다.</p><p>OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다. 이는 소셜 미디어 플랫폼이 성장하면서 발생한 &lsquo;비밀번호 안티패턴&rsquo;(여러 서비스에 동일한 비밀번호 사용) 문제를 해결하기 위해 개발되었다.</p><h3 id=기본-아키텍처-및-작동-방식>기본 아키텍처 및 작동 방식<a hidden class=anchor aria-hidden=true href=#기본-아키텍처-및-작동-방식>#</a></h3><h4 id=saml의-작동-방식>SAML의 작동 방식<a hidden class=anchor aria-hidden=true href=#saml의-작동-방식>#</a></h4><p>SAML은 다음과 같은 주요 구성 요소로 이루어져 있다:</p><ol><li><strong>주체(Principal)</strong>: 인증을 요청하는 사용자</li><li><strong>신원 공급자(IdP)</strong>: 사용자를 인증하고 SAML 어설션을 발행하는 시스템</li><li><strong>서비스 공급자(SP)</strong>: 사용자가 접근하고자 하는 애플리케이션 또는 서비스</li></ol><p>SAML의 일반적인 인증 흐름은 다음과 같다(SP-초기화 흐름 기준):</p><ol><li>사용자가 SP에 접근을 시도한다.</li><li>SP는 사용자를 IdP로 리다이렉트한다(SAML 인증 요청 포함).</li><li>IdP는 사용자를 인증한다(이미 인증된 세션이 없는 경우).</li><li>IdP는 SAML 어설션(사용자 ID 및 속성 정보 포함)을 생성한다.</li><li>IdP는 사용자 브라우저를 SAML 어설션과 함께 SP로 다시 리다이렉트한다.</li><li>SP는 SAML 어설션을 검증하고 사용자에게 접근 권한을 부여한다.</li></ol><h4 id=oauth-20의-작동-방식>OAuth 2.0의 작동 방식<a hidden class=anchor aria-hidden=true href=#oauth-20의-작동-방식>#</a></h4><p>OAuth 2.0은 다음과 같은 주요 구성 요소로 이루어져 있다:</p><ol><li><strong>리소스 소유자(Resource Owner)</strong>: 보호된 리소스에 대한 접근 권한을 부여하는 사용자</li><li><strong>클라이언트(Client)</strong>: 리소스 소유자를 대신하여 보호된 리소스에 접근하려는 애플리케이션</li><li><strong>권한 부여 서버(Authorization Server)</strong>: 리소스 소유자를 인증하고 액세스 토큰을 발행하는 서버</li><li><strong>리소스 서버(Resource Server)</strong>: 보호된 리소스를 호스팅하는 서버</li></ol><p>OAuth 2.0의 일반적인 권한 부여 흐름(권한 부여 코드 흐름)은 다음과 같다:</p><ol><li>클라이언트가 리소스 소유자에게 권한을 요청한다.</li><li>리소스 소유자가 권한을 부여하면, 클라이언트는 권한 부여 코드를 받는다.</li><li>클라이언트는 권한 부여 코드와 자신의 인증 정보를 권한 부여 서버에 제출한다.</li><li>권한 부여 서버는 클라이언트를 인증하고 권한 부여 코드를 검증한 후, 액세스 토큰을 발행한다.</li><li>클라이언트는 액세스 토큰을 사용하여 리소스 서버의 보호된 리소스에 접근한다.</li></ol><h3 id=주요-차이점>주요 차이점<a hidden class=anchor aria-hidden=true href=#주요-차이점>#</a></h3><ol><li><p>주요 목적 및 용도</p><ul><li><strong>SAML</strong>: 주로 기업 환경에서 단일 로그인(SSO)을 구현하기 위해 설계되었다. 사용자가 여러 애플리케이션에 한 번만 로그인할 수 있도록 하는 인증(Authentication)에 중점을 둔다.</li><li><strong>OAuth 2.0</strong>: 주로 타사 애플리케이션이 사용자 데이터에 접근할 수 있도록 권한을 부여하는 데 중점을 둔다. 즉, 인증보다는 권한 부여(Authorization)에 초점을 맞춘다.</li></ul></li><li><p>기술적 구현</p><ul><li><strong>SAML</strong>: XML 기반 프로토콜로, 메시지 형식이 복잡하고 크기가 크다. XML 서명과 암호화를 사용하여 메시지 보안을 제공한다.</li><li><strong>OAuth 2.0</strong>: 경량화된 JSON/HTTP 기반 프로토콜로, 구현이 상대적으로 간단하다. TLS/SSL을 통한 전송 보안에 의존한다.</li></ul></li><li><p>토큰 및 데이터 형식</p><ul><li><strong>SAML</strong>: SAML 어설션은 XML 문서로, 서명 및 암호화될 수 있다. 어설션에는 인증, 속성 및 권한 부여 결정 정보가 포함될 수 있다.</li><li><strong>OAuth 2.0</strong>: 액세스 토큰은 일반적으로 불투명한 문자열이며, 리프레시 토큰을 통해 새로운 액세스 토큰을 획득할 수 있다. JWT(JSON Web Token)를 사용하여 토큰에 클레임을 포함할 수도 있다.</li></ul></li><li><p>클라이언트 유형 및 애플리케이션 지원</p><ul><li><strong>SAML</strong>: 주로 웹 애플리케이션에 초점을 맞추고 있으며, 브라우저 리다이렉션에 의존한다. 모바일 또는 단일 페이지 애플리케이션(SPA)에서는 제한적으로 사용된다.</li><li><strong>OAuth 2.0</strong>: 다양한 클라이언트 유형(웹, 모바일, 데스크톱, IoT 장치 등)을 지원하도록 설계되었다. 다양한 애플리케이션 유형에 맞는 여러 가지 권한 부여 흐름을 제공한다.</li></ul></li><li><p>확장성 및 적응성</p><ul><li><strong>SAML</strong>: 엄격한 XML 스키마를 따르며, 확장이 복잡할 수 있다. 주로 대규모 엔터프라이즈 환경에서 사용된다.</li><li><strong>OAuth 2.0</strong>: 더 모듈화되고 확장 가능한 프레임워크로 설계되었다. OpenID Connect와 같은 확장을 통해 인증 기능을 추가할 수 있다.</li></ul></li><li><p>수명 주기 및 세션 관리</p><ul><li><strong>SAML</strong>: 세션 관리에 대한 내장 지원을 제공한다. 단일 로그아웃(SLO) 기능을 통해 여러 서비스에서 동시에 로그아웃할 수 있다.</li><li><strong>OAuth 2.0</strong>: 기본적으로 세션 관리 기능이 없으며, 토큰 만료 시간을 통해 간접적으로 관리된다. 세션 관리는 일반적으로 추가 메커니즘을 통해 구현해야 한다.</li></ul></li><li><p>보안 특성</p><ul><li><strong>SAML</strong>: XML 서명과 암호화를 통해 강력한 메시지 수준 보안을 제공한다. 기업 환경에서 높은 수준의 보안을 제공하도록 설계되었다.</li><li><strong>OAuth 2.0</strong>: TLS/SSL을 통한 전송 수준 보안에 의존한다. PKCE(Proof Key for Code Exchange)와 같은 추가 보안 메커니즘을 통해 특정 위협을 완화할 수 있다.</li></ul></li></ol><h3 id=사용-사례-비교>사용 사례 비교<a hidden class=anchor aria-hidden=true href=#사용-사례-비교>#</a></h3><h4 id=saml에-적합한-사용-사례>SAML에 적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#saml에-적합한-사용-사례>#</a></h4><ol><li><strong>기업 단일 로그인(SSO)</strong>: 직원들이 한 번의 로그인으로 여러 내부 시스템에 접근할 수 있다.</li><li><strong>B2B 연합(Federation)</strong>: 비즈니스 파트너 간의 신원 정보 교환을 용이하게 한다.</li><li><strong>클라우드 서비스 통합</strong>: 기업 자격 증명으로 SaaS 애플리케이션(Salesforce, Office 365 등)에 접근한다.</li><li><strong>고도의 규제를 받는 산업</strong>: 의료, 금융 등에서 강력한 보안 및 감사 요구 사항을 충족한다.</li></ol><h4 id=oauth-20에-적합한-사용-사례>OAuth 2.0에 적합한 사용 사례<a hidden class=anchor aria-hidden=true href=#oauth-20에-적합한-사용-사례>#</a></h4><ol><li><strong>API 접근 제어</strong>: 타사 애플리케이션이 사용자 데이터에 안전하게 접근할 수 있도록 한다.</li><li><strong>소셜 로그인</strong>: Facebook, Google 등의 계정을 사용하여 다른 서비스에 로그인한다.</li><li><strong>모바일 애플리케이션</strong>: 네이티브 모바일 앱에서 서버 API에 대한 권한 부여를 처리한다.</li><li><strong>마이크로서비스 아키텍처</strong>: 서비스 간 통신에서 권한 부여를 관리한다.</li><li><strong>IoT 장치</strong>: 제한된 리소스를 가진 장치에서 API 접근을 관리한다.</li></ol><h3 id=구현-복잡성>구현 복잡성<a hidden class=anchor aria-hidden=true href=#구현-복잡성>#</a></h3><ol><li>SAML 구현의 복잡성<br>SAML 구현은 일반적으로 다음과 같은 이유로 더 복잡하다:<ul><li>XML 처리 및 XML 디지털 서명에 대한 지식이 필요하다.</li><li>메타데이터 교환 및 관리가 복잡할 수 있다.</li><li>디버깅이 어려울 수 있으며, 오류 메시지가 명확하지 않을 수 있다.</li><li>초기 설정 및 구성이 복잡하다.</li></ul></li><li>OAuth 2.0 구현의 복잡성<br>OAuth 2.0은 상대적으로 구현이 더 간단하지만, 여전히 몇 가지 도전 과제가 있다:<ul><li>다양한 권한 부여 흐름을 이해하고 적절히 선택해야 한다.</li><li>토큰 관리 및 검증이 필요하다.</li><li>CSRF 공격 및 기타 보안 위협에 대한 보호 메커니즘을 구현해야 한다.</li><li>리다이렉션 URI 관리 및 상태 파라미터 처리가 필요하다.</li></ul></li></ol><h3 id=최신-동향-및-미래-전망>최신 동향 및 미래 전망<a hidden class=anchor aria-hidden=true href=#최신-동향-및-미래-전망>#</a></h3><h4 id=saml의-현재-상태>SAML의 현재 상태<a hidden class=anchor aria-hidden=true href=#saml의-현재-상태>#</a></h4><p>SAML은 성숙한 기술로, 많은 기업에서 여전히 광범위하게 사용되고 있다. 특히 대규모 기업 환경과 전통적인 웹 애플리케이션에서 강점을 보인다. 그러나 모바일 및 최신 웹 아키텍처에서는 사용이 감소하는 추세이다.</p><h4 id=oauth-20의-진화>OAuth 2.0의 진화<a hidden class=anchor aria-hidden=true href=#oauth-20의-진화>#</a></h4><p>OAuth 2.0은 계속해서 발전하고 확장되고 있다. OpenID Connect(OIDC)와의 통합을 통해 인증 기능이 강화되었으며, OAuth 2.1이 개발 중이다. OAuth 2.0은 API 경제와 마이크로서비스 아키텍처가 성장함에 따라 더욱 중요해지고 있다.</p><h4 id=두-프로토콜의-사용-전망>두 프로토콜의 사용 전망<a hidden class=anchor aria-hidden=true href=#두-프로토콜의-사용-전망>#</a></h4><p>현재 많은 조직에서는 사용 사례에 따라 SAML과 OAuth를 함께 사용하고 있다:</p><ul><li>SAML은 내부 기업 SSO 및 B2B 시나리오에서 계속 사용된다.</li><li>OAuth 2.0과 OIDC는 새로운 API 중심 개발, 모바일 앱 및 최신 웹 애플리케이션에 선호된다.</li><li>장기적으로는 OAuth 2.0/OIDC로의 점진적인 이동이 예상되지만, SAML은 특히 레거시 시스템 및 특정 엔터프라이즈 사용 사례에서 계속해서 중요한 역할을 할 것이다.</li></ul><h3 id=saml과-oauth-20-비교>SAML과 OAuth 2.0 비교<a hidden class=anchor aria-hidden=true href=#saml과-oauth-20-비교>#</a></h3><table><thead><tr><th>특성</th><th>SAML 2.0</th><th>OAuth 2.0</th></tr></thead><tbody><tr><td><strong>출시 연도</strong></td><td>2005년</td><td>2012년</td></tr><tr><td><strong>주요 목적</strong></td><td>인증(Authentication)</td><td>권한 부여(Authorization)</td></tr><tr><td><strong>사용 사례</strong></td><td>기업 SSO, B2B 연합</td><td>API 접근 제어, 소셜 로그인</td></tr><tr><td><strong>데이터 형식</strong></td><td>XML</td><td>JSON/HTTP</td></tr><tr><td><strong>토큰 유형</strong></td><td>SAML 어설션(XML)</td><td>액세스 토큰(일반적으로 JWT)</td></tr><tr><td><strong>클라이언트 지원</strong></td><td>주로 웹 애플리케이션</td><td>다양한 클라이언트(웹, 모바일, SPA, IoT 등)</td></tr><tr><td><strong>복잡성</strong></td><td>높음</td><td>중간</td></tr><tr><td><strong>메시지 크기</strong></td><td>큼</td><td>작음</td></tr><tr><td><strong>보안 메커니즘</strong></td><td>XML 서명 및 암호화</td><td>TLS/SSL, JWT 서명</td></tr><tr><td><strong>세션 관리</strong></td><td>내장 지원(SLO 포함)</td><td>제한적(토큰 만료에 의존)</td></tr><tr><td><strong>확장성</strong></td><td>제한적</td><td>높음(OpenID Connect 등 확장 가능)</td></tr><tr><td><strong>모바일 지원</strong></td><td>제한적</td><td>강력함</td></tr><tr><td><strong>구현 용이성</strong></td><td>낮음</td><td>중간에서 높음</td></tr><tr><td><strong>디버깅 용이성</strong></td><td>낮음</td><td>중간</td></tr><tr><td><strong>메타데이터 지원</strong></td><td>강력함</td><td>제한적(디스커버리 메커니즘)</td></tr><tr><td><strong>산업 채택률</strong></td><td>기업 및 전통적 웹 앱 위주</td><td>광범위(웹, 모바일, API 등)</td></tr><tr><td><strong>미래 전망</strong></td><td>엔터프라이즈 환경에서 안정적 사용</td><td>지속적인 성장 및 발전</td></tr><tr><td><strong>주요 지원 기업</strong></td><td>Microsoft, IBM, Oracle</td><td>Google, Facebook, Microsoft, Twitter</td></tr><tr><td><strong>표준화 기관</strong></td><td>OASIS</td><td>IETF</td></tr><tr><td><strong>상호 운용성</strong></td><td>높음(기업 환경 내)</td><td>높음(다양한 환경)</td></tr><tr><td><strong>개방성</strong></td><td>개방형 표준</td><td>개방형 표준</td></tr><tr><td><strong>개발자 친화도</strong></td><td>낮음</td><td>높음</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/authentication-methods/>Authentication-Methods</a></li><li><a href=https://buenhyden.github.io/tags/saml/>SAML</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character/types/unicode/utf-8/><span class=title>« Prev</span><br><span>UTF-8</span>
</a><a class=next href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-cookie-based-auth/><span class=title>Next »</span><br><span>Session-Based Auth vs. Cookie-Based Auth</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>