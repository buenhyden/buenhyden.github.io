<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Token Authentication vs. OpenID Connect | hyunyoun's Blog</title><meta name=keywords content="Backend-Development,API-Design,Authentication-Methods,Token-Authentication"><meta name=description content="토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Token Authentication vs. OpenID Connect"><meta property="og:description" content="토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-03T07:22:00+00:00"><meta property="article:modified_time" content="2025-04-03T07:22:00+00:00"><meta property="article:tag" content="Backend Development"><meta property="article:tag" content="API-Design"><meta property="article:tag" content="Authentication-Methods"><meta property="article:tag" content="Token-Authentication"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Token Authentication vs. OpenID Connect"><meta name=twitter:description content="토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Cybersecurity and Information Security","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/"},{"@type":"ListItem","position":3,"name":"Access Control","item":""},{"@type":"ListItem","position":4,"name":"Authentication","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/"},{"@type":"ListItem","position":5,"name":"Implementations","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/"},{"@type":"ListItem","position":6,"name":"Token-Based Authentication","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/"},{"@type":"ListItem","position":7,"name":"Token Authentication vs. OpenID Connect","item":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Token Authentication vs. OpenID Connect","name":"Token Authentication vs. OpenID Connect","description":"토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다.","keywords":["Backend-Development","API-Design","Authentication-Methods","Token-Authentication"],"articleBody":"Token Authentication vs. OpenID Connect 현대 웹과 애플리케이션의 보안 생태계에서 인증과 권한 부여는 필수적인 요소이다. 토큰 인증(Token Authentication)과 OpenID Connect(OIDC)는 모두 이 영역에서 중요한 역할을 하지만, 목적과 기능 면에서 상당한 차이가 있다.\n토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다.\n기본 개념 및 작동 원리 토큰 인증의 핵심 아이디어는 사용자가 로그인하면 서버가 서명된 토큰을 발급하고, 이후 모든 요청에 이 토큰을 포함시켜 사용자를 식별하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.\n인증 흐름: 사용자가 자격 증명(username/password)을 서버에 제출합니다. 서버는 이를 검증하고 토큰을 생성합니다. 클라이언트는 토큰을 저장하고(로컬 스토리지, 쿠키 등) 이후 요청에 포함시킵니다. 서버는 토큰을 검증하여 사용자를 식별합니다. 토큰 구조(JWT 기준): 헤더(Header): 토큰 유형과 사용된 알고리즘 페이로드(Payload): 사용자 ID, 권한, 만료 시간 등의 클레임(claims) 서명(Signature): 토큰이 변조되지 않았음을 보장하는 서명 주요 특징 무상태(Stateless): 서버는 토큰 상태를 저장할 필요가 없다. 자체 포함적(Self-contained): 필요한 모든 정보가 토큰 내에 포함된다. 확장성: 서버 간 세션 공유 없이 수평적 확장이 가능하다. 구현 단순성: 기본적인 토큰 인증은 구현이 상대적으로 간단하다. 직접 인증: 주로 애플리케이션이 사용자를 직접 인증한다. OpenID Connect (OIDC) OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다.\n기본 개념 및 작동 원리 OpenID Connect는, OAuth 2.0의 기본 기능인 권한 부여(Authorization)에 인증(Authentication) 기능을 추가함으로써, 인증과 권한 부여를 모두 처리할 수 있는 완전한 프로토콜을 제공한다.\n주요 구성 요소: OpenID Provider(OP): 사용자 인증을 수행하는 서버 Relying Party(RP): 인증을 요청하는 클라이언트 애플리케이션 ID 토큰: 사용자의 신원 정보를 포함하는 JWT UserInfo 엔드포인트: 추가 사용자 정보를 제공하는 API 인증 흐름(권한 부여 코드 흐름 기준): 클라이언트가 사용자를 OpenID Provider로 리디렉션한다. 사용자가 OP에 로그인하고 클라이언트에 대한 권한을 승인한다. OP는 권한 부여 코드와 함께 사용자를 클라이언트로 리디렉션한다. 클라이언트는 이 코드를 사용하여 OP로부터 ID 토큰과 접근 토큰을 받는다. ID 토큰은 사용자의 신원을 확인하는 데 사용된다. 필요 시 접근 토큰으로 UserInfo 엔드포인트에서 추가 정보를 조회한다. 주요 특징 표준화된 프로토콜: 잘 정의된 규칙과 흐름을 제공한다. 연합 인증(Federated Authentication): 여러 서비스에서 단일 ID를 사용할 수 있다. 다양한 인증 흐름: 다양한 클라이언트 유형에 맞는 여러 인증 흐름을 지원한다. 사용자 정보 표준화: 표준 클레임 세트로 사용자 정보를 제공한다. 위임된 인증: 신뢰할 수 있는 제3자(OP)가 인증을 처리한다. 토큰 인증 vs. OpenID Connect 비교 특성 토큰 인증 OpenID Connect 정의 토큰 기반 인증 메커니즘 OAuth 2.0 위에 구축된 인증 프로토콜 핵심 목적 애플리케이션 내 인증 서비스 간 인증 및 사용자 정보 공유 범위 주로 단일 애플리케이션/서비스 여러 애플리케이션/서비스 간 복잡성 낮음 - 중간 중간 - 높음 표준화 특정 표준 없음(JWT는 표준화됨) OpenID Foundation에 의해 표준화됨 인증 주체 주로 애플리케이션 자체 신뢰할 수 있는 ID 제공자(Google, Facebook 등) 구성 요소 주로 토큰 생성 및 검증 인증 서버, 클라이언트, ID 토큰, UserInfo 엔드포인트 토큰 형태 다양함(JWT, 불투명 토큰 등) JWT 형식의 ID 토큰 토큰 내용 구현에 따라 다양함 표준화된 클레임 세트(sub, iss, aud 등) 구현 난이도 낮음 ~ 중간 중간 ~ 높음 확장성 높음(무상태 특성) 중간(일부 상태 유지 가능) 보안 기능 기본적(구현에 따라 다름) 고급(세션 관리, 토큰 철회, ID 토큰 검증 등) 단일 로그인(SSO) 기본 지원 없음(별도 구현 필요) 기본 지원 사용자 정보 토큰에 직접 포함 또는 별도 조회 표준화된 UserInfo 엔드포인트 사용자 동의 일반적으로 필요 없음 사용자 동의 화면 포함 주요 사용 사례 API 인증, 자체 서비스 인증 SSO, 소셜 로그인, 엔터프라이즈 인증 통합 용이성 높음(단순함) 중간(표준화되었으나 복잡) 프라이버시 제어 제한적 사용자 동의 기반의 정보 공유 개발자 경험 직관적이고 구현이 간단함 복잡하나 표준화된 라이브러리 존재 장단점 분석 토큰 인증의 장단점 장점:\n구현이 상대적으로 간단하다. 무상태 특성으로 서버 확장성이 좋다. 개발 오버헤드가 적다. 자유로운 토큰 설계가 가능하다. 마이크로서비스 아키텍처에 적합하다. 단점:\n표준화된 접근 방식이 없어 구현이 다양할 수 있다. 보안 구현의 책임이 개발자에게 있다. 토큰 취소 메커니즘이 기본적으로 없다. 사용자 정보 관리에 대한 표준이 없다. 서비스 간 신뢰 설정이 복잡할 수 있다. OpenID Connect의 장단점 장점:\n표준화된 인증 프로토콜로 상호 운용성이 좋다. 다양한 인증 흐름을 지원하여 다양한 사용 사례에 적용 가능하다. 신뢰할 수 있는 제3자 인증을 통한 보안 강화가 가능하다. 사용자 정보에 대한 표준화된 접근 방식을 제공한다. 단일 로그인(SSO)을 기본적으로 지원한다. 단점:\n구현 복잡성이 높다. 설정 및 통합에 더 많은 노력이 필요하다. 외부 의존성(ID 제공자)이 생긴다. 네트워크 요청이 증가할 수 있다. 단순한 인증 요구사항에는 과도할 수 있다. 사용 시나리오 토큰 인증이 적합한 경우 단일 애플리케이션/서비스: 외부 서비스와의 통합이 필요 없는 독립적인 애플리케이션 API 인증: 단순한 API 접근 제어 마이크로서비스 내부 통신: 내부 서비스 간 인증 모바일 애플리케이션: 효율적인 API 통신이 필요한 모바일 앱 리소스 제약 환경: 경량 인증이 필요한 IoT 기기 등 OpenID Connect가 적합한 경우 소셜 로그인: “Google로 로그인”, “Facebook으로 로그인” 등의 기능 구현 단일 로그인(SSO): 여러 애플리케이션에 걸친 단일 로그인 구현 엔터프라이즈 환경: 다양한 애플리케이션과 서비스에 대한 중앙 집중식 인증 사용자 정보 공유: 애플리케이션 간에 일관된 사용자 프로필 정보 공유 고급 인증 요구 사항: 다단계 인증, 동적 클라이언트 등록, 세션 관리가 필요한 경우 통합 및 하이브리드 접근법 실제 개발 환경에서는 두 접근 방식을 조합하여 사용하는 경우가 많다:\nOIDC로 인증 후 토큰 인증 사용: OIDC를 통해 사용자 인증 및 기본 정보 획득 자체 JWT 토큰 발급 및 내부 서비스 인증에 사용 내부/외부 서비스 분리: 내부 서비스에는 단순한 토큰 인증 사용 외부 서비스 통합에는 OIDC 사용 계층적 접근: 게이트웨이/경계 수준에서 OIDC 인증 내부 마이크로서비스 간에는 전파된 JWT 사용 보안 고려사항 토큰 인증 보안\n안전한 토큰 전송: HTTPS를 통한 통신 적절한 토큰 수명: 짧은 만료 시간 설정 안전한 토큰 저장: XSS 공격 방지를 위한 안전한 저장소 사용 토큰 서명 검증: 모든 요청에서 서명 검증 비밀 키 보호: 서명 키의 안전한 관리 민감한 정보 제외: 토큰에 비밀 데이터 포함 자제 OpenID Connect 보안\n정확한 ID 토큰 검증: 발급자, 대상, 만료 시간, nonce 검증 상태 파라미터 사용: CSRF 공격 방지 클라이언트 인증: 클라이언트 시크릿 보호 리디렉션 URI 검증: 등록된 URI로만 리디렉션 적절한 범위 요청: 필요한 최소한의 권한만 요청 PKCE(Proof Key for Code Exchange) 사용: 모바일/SPA 애플리케이션의 보안 강화 최신 동향 토큰 인증 발전:\nJWT 프로필 표준화 토큰 바인딩(Token Binding) DPoP(Demonstration of Proof-of-Possession) 자체 서명 토큰 OpenID Connect 발전:\nFAPI(Financial-grade API) 프로필 자체 발급 OpenID Provider(SIOP) 분산 ID(Decentralized Identity) 통합 장치 간 인증 최적화 심층 분석 개념적 차이 가장 근본적인 차이점은 토큰 인증이 인증 메커니즘인 반면, OpenID Connect는 인증 프로토콜이라는 점이다. 토큰 인증은 서버가 토큰을 생성하고 클라이언트가 이를 제시하는 방식을 설명하는 일반적인 접근 방식이다. 반면, OIDC는 인증을 처리하기 위한 구체적인 규칙, 엔드포인트, 메시지 형식 및 흐름을 정의하는 완전한 프로토콜이다.\n토큰 인증 작동 방식 예시 (JWT 사용) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 1. 로그인 및 토큰 발급 app.post('/login', (req, res) =\u003e { const { username, password } = req.body; // 사용자 검증 if (validateUser(username, password)) { // JWT 생성 const token = jwt.sign( { userId: user.id, username: user.username }, 'your-secret-key', { expiresIn: '1h' } ); return res.json({ token }); } return res.status(401).json({ message: '인증 실패' }); }); // 2. 토큰 검증 function authenticateToken(req, res, next) { const authHeader = req.headers['authorization']; const token = authHeader \u0026\u0026 authHeader.split(' ')[1]; if (!token) return res.status(401).send('토큰 없음'); jwt.verify(token, 'your-secret-key', (err, user) =\u003e { if (err) return res.status(403).send('토큰 무효'); req.user = user; next(); }); } // 3. 보호된 리소스 접근 app.get('/protected', authenticateToken, (req, res) =\u003e { res.json({ message: '보호된 데이터', user: req.user }); }); OpenID Connect 작동 방식 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // 1. 인증 시작 app.get('/login', (req, res) =\u003e { // 상태 및 nonce 생성 (보안) const state = crypto.randomBytes(16).toString('hex'); const nonce = crypto.randomBytes(16).toString('hex'); req.session.oidc_state = state; req.session.oidc_nonce = nonce; // OpenID Provider로 리디렉션 const authUrl = `https://openid-provider.com/auth?` + `client_id=your-client-id\u0026` + `redirect_uri=${encodeURIComponent('http://your-app.com/callback')}\u0026` + `response_type=code\u0026` + `scope=openid profile email\u0026` + `state=${state}\u0026` + `nonce=${nonce}`; res.redirect(authUrl); }); // 2. 콜백 처리 app.get('/callback', async (req, res) =\u003e { const { code, state } = req.query; // 상태 검증 if (state !== req.session.oidc_state) { return res.status(403).send('상태 불일치, CSRF 공격 가능성'); } try { // 권한 부여 코드를 토큰으로 교환 const tokenResponse = await axios.post('https://openid-provider.com/token', { grant_type: 'authorization_code', code, redirect_uri: 'http://your-app.com/callback', client_id: 'your-client-id', client_secret: 'your-client-secret' }); const { id_token, access_token } = tokenResponse.data; // ID 토큰 검증 const decodedToken = jwt.decode(id_token); // nonce 검증 if (decodedToken.nonce !== req.session.oidc_nonce) { return res.status(403).send('nonce 불일치'); } // 추가 검증 (발행자, 대상, 만료 시간 등) // ... // 사용자 정보 조회 (선택적) const userInfoResponse = await axios.get('https://openid-provider.com/userinfo', { headers: { 'Authorization': `Bearer ${access_token}` } }); // 사용자 정보 저장 및 세션 설정 req.session.user = { ...decodedToken, ...userInfoResponse.data }; res.redirect('/dashboard'); } catch (error) { res.status(500).send('인증 처리 중 오류 발생'); } }); 용어 정리 용어 설명 참고 및 출처 ","wordCount":"1440","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-04-03T07:22:00Z","dateModified":"2025-04-03T07:22:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/>Cybersecurity and Information Security</a>&nbsp;»&nbsp;<a href>Access Control</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/>Authentication</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/>Implementations</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/>Token-Based Authentication</a></div><h1 class="post-title entry-hint-parent">Token Authentication vs. OpenID Connect</h1><div class=post-description>토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다.</div><div class=post-meta><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Cybersecurity%20and%20Information%20Security/Access%20Control/Authentication/Implementations/Token-Based%20Authentication/Token-Based-authentication-vs-OpenID-Connect.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#token-authentication-vs-openid-connect>Token Authentication vs. OpenID Connect</a><ul><li><a href=#토큰-인증token-authentication>토큰 인증(Token Authentication)</a></li><li><a href=#openid-connect-oidc>OpenID Connect (OIDC)</a></li><li><a href=#토큰-인증-vs-openid-connect-비교>토큰 인증 vs. OpenID Connect 비교</a></li><li><a href=#장단점-분석>장단점 분석</a></li><li><a href=#사용-시나리오>사용 시나리오</a></li><li><a href=#통합-및-하이브리드-접근법>통합 및 하이브리드 접근법</a></li><li><a href=#보안-고려사항>보안 고려사항</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#심층-분석>심층 분석</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=token-authentication-vs-openid-connect>Token Authentication vs. OpenID Connect<a hidden class=anchor aria-hidden=true href=#token-authentication-vs-openid-connect>#</a></h2><p>현대 웹과 애플리케이션의 보안 생태계에서 인증과 권한 부여는 필수적인 요소이다. 토큰 인증(Token Authentication)과 OpenID Connect(OIDC)는 모두 이 영역에서 중요한 역할을 하지만, 목적과 기능 면에서 상당한 차이가 있다.</p><h3 id=토큰-인증token-authentication>토큰 인증(Token Authentication)<a hidden class=anchor aria-hidden=true href=#토큰-인증token-authentication>#</a></h3><p>토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다.</p><h4 id=기본-개념-및-작동-원리>기본 개념 및 작동 원리<a hidden class=anchor aria-hidden=true href=#기본-개념-및-작동-원리>#</a></h4><p>토큰 인증의 핵심 아이디어는 사용자가 로그인하면 서버가 서명된 토큰을 발급하고, 이후 모든 요청에 이 토큰을 포함시켜 사용자를 식별하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.</p><ol><li><strong>인증 흐름</strong>:<ul><li>사용자가 자격 증명(username/password)을 서버에 제출합니다.</li><li>서버는 이를 검증하고 토큰을 생성합니다.</li><li>클라이언트는 토큰을 저장하고(로컬 스토리지, 쿠키 등) 이후 요청에 포함시킵니다.</li><li>서버는 토큰을 검증하여 사용자를 식별합니다.</li></ul></li><li><strong>토큰 구조</strong>(JWT 기준):<ul><li>헤더(Header): 토큰 유형과 사용된 알고리즘</li><li>페이로드(Payload): 사용자 ID, 권한, 만료 시간 등의 클레임(claims)</li><li>서명(Signature): 토큰이 변조되지 않았음을 보장하는 서명</li></ul></li></ol><h4 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h4><ul><li><strong>무상태(Stateless)</strong>: 서버는 토큰 상태를 저장할 필요가 없다.</li><li><strong>자체 포함적(Self-contained)</strong>: 필요한 모든 정보가 토큰 내에 포함된다.</li><li><strong>확장성</strong>: 서버 간 세션 공유 없이 수평적 확장이 가능하다.</li><li><strong>구현 단순성</strong>: 기본적인 토큰 인증은 구현이 상대적으로 간단하다.</li><li><strong>직접 인증</strong>: 주로 애플리케이션이 사용자를 직접 인증한다.</li></ul><h3 id=openid-connect-oidc>OpenID Connect (OIDC)<a hidden class=anchor aria-hidden=true href=#openid-connect-oidc>#</a></h3><p>OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다.</p><h4 id=기본-개념-및-작동-원리-1>기본 개념 및 작동 원리<a hidden class=anchor aria-hidden=true href=#기본-개념-및-작동-원리-1>#</a></h4><p>OpenID Connect는, OAuth 2.0의 기본 기능인 권한 부여(Authorization)에 인증(Authentication) 기능을 추가함으로써, 인증과 권한 부여를 모두 처리할 수 있는 완전한 프로토콜을 제공한다.</p><ol><li><strong>주요 구성 요소</strong>:<ul><li>OpenID Provider(OP): 사용자 인증을 수행하는 서버</li><li>Relying Party(RP): 인증을 요청하는 클라이언트 애플리케이션</li><li>ID 토큰: 사용자의 신원 정보를 포함하는 JWT</li><li>UserInfo 엔드포인트: 추가 사용자 정보를 제공하는 API</li></ul></li><li><strong>인증 흐름</strong>(권한 부여 코드 흐름 기준):<ul><li>클라이언트가 사용자를 OpenID Provider로 리디렉션한다.</li><li>사용자가 OP에 로그인하고 클라이언트에 대한 권한을 승인한다.</li><li>OP는 권한 부여 코드와 함께 사용자를 클라이언트로 리디렉션한다.</li><li>클라이언트는 이 코드를 사용하여 OP로부터 ID 토큰과 접근 토큰을 받는다.</li><li>ID 토큰은 사용자의 신원을 확인하는 데 사용된다.</li><li>필요 시 접근 토큰으로 UserInfo 엔드포인트에서 추가 정보를 조회한다.</li></ul></li></ol><h4 id=주요-특징-1>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징-1>#</a></h4><ul><li><strong>표준화된 프로토콜</strong>: 잘 정의된 규칙과 흐름을 제공한다.</li><li><strong>연합 인증(Federated Authentication)</strong>: 여러 서비스에서 단일 ID를 사용할 수 있다.</li><li><strong>다양한 인증 흐름</strong>: 다양한 클라이언트 유형에 맞는 여러 인증 흐름을 지원한다.</li><li><strong>사용자 정보 표준화</strong>: 표준 클레임 세트로 사용자 정보를 제공한다.</li><li><strong>위임된 인증</strong>: 신뢰할 수 있는 제3자(OP)가 인증을 처리한다.</li></ul><h3 id=토큰-인증-vs-openid-connect-비교>토큰 인증 vs. OpenID Connect 비교<a hidden class=anchor aria-hidden=true href=#토큰-인증-vs-openid-connect-비교>#</a></h3><table><thead><tr><th>특성</th><th>토큰 인증</th><th>OpenID Connect</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>토큰 기반 인증 메커니즘</td><td>OAuth 2.0 위에 구축된 인증 프로토콜</td></tr><tr><td><strong>핵심 목적</strong></td><td>애플리케이션 내 인증</td><td>서비스 간 인증 및 사용자 정보 공유</td></tr><tr><td><strong>범위</strong></td><td>주로 단일 애플리케이션/서비스</td><td>여러 애플리케이션/서비스 간</td></tr><tr><td><strong>복잡성</strong></td><td>낮음 - 중간</td><td>중간 - 높음</td></tr><tr><td><strong>표준화</strong></td><td>특정 표준 없음(JWT는 표준화됨)</td><td>OpenID Foundation에 의해 표준화됨</td></tr><tr><td><strong>인증 주체</strong></td><td>주로 애플리케이션 자체</td><td>신뢰할 수 있는 ID 제공자(Google, Facebook 등)</td></tr><tr><td><strong>구성 요소</strong></td><td>주로 토큰 생성 및 검증</td><td>인증 서버, 클라이언트, ID 토큰, UserInfo 엔드포인트</td></tr><tr><td><strong>토큰 형태</strong></td><td>다양함(JWT, 불투명 토큰 등)</td><td>JWT 형식의 ID 토큰</td></tr><tr><td><strong>토큰 내용</strong></td><td>구현에 따라 다양함</td><td>표준화된 클레임 세트(sub, iss, aud 등)</td></tr><tr><td><strong>구현 난이도</strong></td><td>낮음 ~ 중간</td><td>중간 ~ 높음</td></tr><tr><td><strong>확장성</strong></td><td>높음(무상태 특성)</td><td>중간(일부 상태 유지 가능)</td></tr><tr><td><strong>보안 기능</strong></td><td>기본적(구현에 따라 다름)</td><td>고급(세션 관리, 토큰 철회, ID 토큰 검증 등)</td></tr><tr><td><strong>단일 로그인(SSO)</strong></td><td>기본 지원 없음(별도 구현 필요)</td><td>기본 지원</td></tr><tr><td><strong>사용자 정보</strong></td><td>토큰에 직접 포함 또는 별도 조회</td><td>표준화된 UserInfo 엔드포인트</td></tr><tr><td><strong>사용자 동의</strong></td><td>일반적으로 필요 없음</td><td>사용자 동의 화면 포함</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>API 인증, 자체 서비스 인증</td><td>SSO, 소셜 로그인, 엔터프라이즈 인증</td></tr><tr><td><strong>통합 용이성</strong></td><td>높음(단순함)</td><td>중간(표준화되었으나 복잡)</td></tr><tr><td><strong>프라이버시 제어</strong></td><td>제한적</td><td>사용자 동의 기반의 정보 공유</td></tr><tr><td><strong>개발자 경험</strong></td><td>직관적이고 구현이 간단함</td><td>복잡하나 표준화된 라이브러리 존재</td></tr></tbody></table><h3 id=장단점-분석>장단점 분석<a hidden class=anchor aria-hidden=true href=#장단점-분석>#</a></h3><h4 id=토큰-인증의-장단점>토큰 인증의 장단점<a hidden class=anchor aria-hidden=true href=#토큰-인증의-장단점>#</a></h4><p><strong>장점</strong>:</p><ul><li>구현이 상대적으로 간단하다.</li><li>무상태 특성으로 서버 확장성이 좋다.</li><li>개발 오버헤드가 적다.</li><li>자유로운 토큰 설계가 가능하다.</li><li>마이크로서비스 아키텍처에 적합하다.</li></ul><p><strong>단점</strong>:</p><ul><li>표준화된 접근 방식이 없어 구현이 다양할 수 있다.</li><li>보안 구현의 책임이 개발자에게 있다.</li><li>토큰 취소 메커니즘이 기본적으로 없다.</li><li>사용자 정보 관리에 대한 표준이 없다.</li><li>서비스 간 신뢰 설정이 복잡할 수 있다.</li></ul><h4 id=openid-connect의-장단점>OpenID Connect의 장단점<a hidden class=anchor aria-hidden=true href=#openid-connect의-장단점>#</a></h4><p><strong>장점</strong>:</p><ul><li>표준화된 인증 프로토콜로 상호 운용성이 좋다.</li><li>다양한 인증 흐름을 지원하여 다양한 사용 사례에 적용 가능하다.</li><li>신뢰할 수 있는 제3자 인증을 통한 보안 강화가 가능하다.</li><li>사용자 정보에 대한 표준화된 접근 방식을 제공한다.</li><li>단일 로그인(SSO)을 기본적으로 지원한다.</li></ul><p><strong>단점</strong>:</p><ul><li>구현 복잡성이 높다.</li><li>설정 및 통합에 더 많은 노력이 필요하다.</li><li>외부 의존성(ID 제공자)이 생긴다.</li><li>네트워크 요청이 증가할 수 있다.</li><li>단순한 인증 요구사항에는 과도할 수 있다.</li></ul><h3 id=사용-시나리오>사용 시나리오<a hidden class=anchor aria-hidden=true href=#사용-시나리오>#</a></h3><ul><li>토큰 인증이 적합한 경우<ol><li><strong>단일 애플리케이션/서비스</strong>: 외부 서비스와의 통합이 필요 없는 독립적인 애플리케이션</li><li><strong>API 인증</strong>: 단순한 API 접근 제어</li><li><strong>마이크로서비스 내부 통신</strong>: 내부 서비스 간 인증</li><li><strong>모바일 애플리케이션</strong>: 효율적인 API 통신이 필요한 모바일 앱</li><li><strong>리소스 제약 환경</strong>: 경량 인증이 필요한 IoT 기기 등</li></ol></li><li>OpenID Connect가 적합한 경우<ol><li><strong>소셜 로그인</strong>: &ldquo;Google로 로그인&rdquo;, &ldquo;Facebook으로 로그인&rdquo; 등의 기능 구현</li><li><strong>단일 로그인(SSO)</strong>: 여러 애플리케이션에 걸친 단일 로그인 구현</li><li><strong>엔터프라이즈 환경</strong>: 다양한 애플리케이션과 서비스에 대한 중앙 집중식 인증</li><li><strong>사용자 정보 공유</strong>: 애플리케이션 간에 일관된 사용자 프로필 정보 공유</li><li><strong>고급 인증 요구 사항</strong>: 다단계 인증, 동적 클라이언트 등록, 세션 관리가 필요한 경우</li></ol></li></ul><h3 id=통합-및-하이브리드-접근법>통합 및 하이브리드 접근법<a hidden class=anchor aria-hidden=true href=#통합-및-하이브리드-접근법>#</a></h3><p>실제 개발 환경에서는 두 접근 방식을 조합하여 사용하는 경우가 많다:</p><ol><li><strong>OIDC로 인증 후 토큰 인증 사용</strong>:<ul><li>OIDC를 통해 사용자 인증 및 기본 정보 획득</li><li>자체 JWT 토큰 발급 및 내부 서비스 인증에 사용</li></ul></li><li><strong>내부/외부 서비스 분리</strong>:<ul><li>내부 서비스에는 단순한 토큰 인증 사용</li><li>외부 서비스 통합에는 OIDC 사용</li></ul></li><li><strong>계층적 접근</strong>:<ul><li>게이트웨이/경계 수준에서 OIDC 인증</li><li>내부 마이크로서비스 간에는 전파된 JWT 사용</li></ul></li></ol><h3 id=보안-고려사항>보안 고려사항<a hidden class=anchor aria-hidden=true href=#보안-고려사항>#</a></h3><ul><li><p>토큰 인증 보안</p><ol><li><strong>안전한 토큰 전송</strong>: HTTPS를 통한 통신</li><li><strong>적절한 토큰 수명</strong>: 짧은 만료 시간 설정</li><li><strong>안전한 토큰 저장</strong>: XSS 공격 방지를 위한 안전한 저장소 사용</li><li><strong>토큰 서명 검증</strong>: 모든 요청에서 서명 검증</li><li><strong>비밀 키 보호</strong>: 서명 키의 안전한 관리</li><li><strong>민감한 정보 제외</strong>: 토큰에 비밀 데이터 포함 자제</li></ol></li><li><p>OpenID Connect 보안</p><ol><li><strong>정확한 ID 토큰 검증</strong>: 발급자, 대상, 만료 시간, nonce 검증</li><li><strong>상태 파라미터 사용</strong>: CSRF 공격 방지</li><li><strong>클라이언트 인증</strong>: 클라이언트 시크릿 보호</li><li><strong>리디렉션 URI 검증</strong>: 등록된 URI로만 리디렉션</li><li><strong>적절한 범위 요청</strong>: 필요한 최소한의 권한만 요청</li><li><strong>PKCE(Proof Key for Code Exchange) 사용</strong>: 모바일/SPA 애플리케이션의 보안 강화</li></ol></li></ul><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><ol><li><p><strong>토큰 인증 발전</strong>:</p><ul><li>JWT 프로필 표준화</li><li>토큰 바인딩(Token Binding)</li><li>DPoP(Demonstration of Proof-of-Possession)</li><li>자체 서명 토큰</li></ul></li><li><p><strong>OpenID Connect 발전</strong>:</p><ul><li>FAPI(Financial-grade API) 프로필</li><li>자체 발급 OpenID Provider(SIOP)</li><li>분산 ID(Decentralized Identity) 통합</li><li>장치 간 인증 최적화</li></ul></li></ol><h3 id=심층-분석>심층 분석<a hidden class=anchor aria-hidden=true href=#심층-분석>#</a></h3><h4 id=개념적-차이>개념적 차이<a hidden class=anchor aria-hidden=true href=#개념적-차이>#</a></h4><p>가장 근본적인 차이점은 토큰 인증이 <strong>인증 메커니즘</strong>인 반면, OpenID Connect는 <strong>인증 프로토콜</strong>이라는 점이다. 토큰 인증은 서버가 토큰을 생성하고 클라이언트가 이를 제시하는 방식을 설명하는 일반적인 접근 방식이다. 반면, OIDC는 인증을 처리하기 위한 구체적인 규칙, 엔드포인트, 메시지 형식 및 흐름을 정의하는 완전한 프로토콜이다.</p><h4 id=토큰-인증-작동-방식-예시-jwt-사용>토큰 인증 작동 방식 예시 (JWT 사용)<a hidden class=anchor aria-hidden=true href=#토큰-인증-작동-방식-예시-jwt-사용>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 1. 로그인 및 토큰 발급
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>app</span><span class=p>.</span><span class=nx>post</span><span class=p>(</span><span class=s1>&#39;/login&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>username</span><span class=p>,</span> <span class=nx>password</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>req</span><span class=p>.</span><span class=nx>body</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 사용자 검증
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>validateUser</span><span class=p>(</span><span class=nx>username</span><span class=p>,</span> <span class=nx>password</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// JWT 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=nx>jwt</span><span class=p>.</span><span class=nx>sign</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span> <span class=nx>userId</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>id</span><span class=p>,</span> <span class=nx>username</span><span class=o>:</span> <span class=nx>user</span><span class=p>.</span><span class=nx>username</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>      <span class=s1>&#39;your-secret-key&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span> <span class=nx>expiresIn</span><span class=o>:</span> <span class=s1>&#39;1h&#39;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>json</span><span class=p>({</span> <span class=nx>token</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>401</span><span class=p>).</span><span class=nx>json</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;인증 실패&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2. 토큰 검증
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>authenticateToken</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>,</span> <span class=nx>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>authHeader</span> <span class=o>=</span> <span class=nx>req</span><span class=p>.</span><span class=nx>headers</span><span class=p>[</span><span class=s1>&#39;authorization&#39;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>token</span> <span class=o>=</span> <span class=nx>authHeader</span> <span class=o>&amp;&amp;</span> <span class=nx>authHeader</span><span class=p>.</span><span class=nx>split</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>token</span><span class=p>)</span> <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>401</span><span class=p>).</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;토큰 없음&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>jwt</span><span class=p>.</span><span class=nx>verify</span><span class=p>(</span><span class=nx>token</span><span class=p>,</span> <span class=s1>&#39;your-secret-key&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>user</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>403</span><span class=p>).</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;토큰 무효&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>req</span><span class=p>.</span><span class=nx>user</span> <span class=o>=</span> <span class=nx>user</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>next</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 3. 보호된 리소스 접근
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>app</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;/protected&#39;</span><span class=p>,</span> <span class=nx>authenticateToken</span><span class=p>,</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>res</span><span class=p>.</span><span class=nx>json</span><span class=p>({</span> <span class=nx>message</span><span class=o>:</span> <span class=s1>&#39;보호된 데이터&#39;</span><span class=p>,</span> <span class=nx>user</span><span class=o>:</span> <span class=nx>req</span><span class=p>.</span><span class=nx>user</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=openid-connect-작동-방식-예시>OpenID Connect 작동 방식 예시<a hidden class=anchor aria-hidden=true href=#openid-connect-작동-방식-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span><span class=lnt id=hl-1-42><a class=lnlinks href=#hl-1-42>42</a>
</span><span class=lnt id=hl-1-43><a class=lnlinks href=#hl-1-43>43</a>
</span><span class=lnt id=hl-1-44><a class=lnlinks href=#hl-1-44>44</a>
</span><span class=lnt id=hl-1-45><a class=lnlinks href=#hl-1-45>45</a>
</span><span class=lnt id=hl-1-46><a class=lnlinks href=#hl-1-46>46</a>
</span><span class=lnt id=hl-1-47><a class=lnlinks href=#hl-1-47>47</a>
</span><span class=lnt id=hl-1-48><a class=lnlinks href=#hl-1-48>48</a>
</span><span class=lnt id=hl-1-49><a class=lnlinks href=#hl-1-49>49</a>
</span><span class=lnt id=hl-1-50><a class=lnlinks href=#hl-1-50>50</a>
</span><span class=lnt id=hl-1-51><a class=lnlinks href=#hl-1-51>51</a>
</span><span class=lnt id=hl-1-52><a class=lnlinks href=#hl-1-52>52</a>
</span><span class=lnt id=hl-1-53><a class=lnlinks href=#hl-1-53>53</a>
</span><span class=lnt id=hl-1-54><a class=lnlinks href=#hl-1-54>54</a>
</span><span class=lnt id=hl-1-55><a class=lnlinks href=#hl-1-55>55</a>
</span><span class=lnt id=hl-1-56><a class=lnlinks href=#hl-1-56>56</a>
</span><span class=lnt id=hl-1-57><a class=lnlinks href=#hl-1-57>57</a>
</span><span class=lnt id=hl-1-58><a class=lnlinks href=#hl-1-58>58</a>
</span><span class=lnt id=hl-1-59><a class=lnlinks href=#hl-1-59>59</a>
</span><span class=lnt id=hl-1-60><a class=lnlinks href=#hl-1-60>60</a>
</span><span class=lnt id=hl-1-61><a class=lnlinks href=#hl-1-61>61</a>
</span><span class=lnt id=hl-1-62><a class=lnlinks href=#hl-1-62>62</a>
</span><span class=lnt id=hl-1-63><a class=lnlinks href=#hl-1-63>63</a>
</span><span class=lnt id=hl-1-64><a class=lnlinks href=#hl-1-64>64</a>
</span><span class=lnt id=hl-1-65><a class=lnlinks href=#hl-1-65>65</a>
</span><span class=lnt id=hl-1-66><a class=lnlinks href=#hl-1-66>66</a>
</span><span class=lnt id=hl-1-67><a class=lnlinks href=#hl-1-67>67</a>
</span><span class=lnt id=hl-1-68><a class=lnlinks href=#hl-1-68>68</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 1. 인증 시작
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>app</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;/login&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 상태 및 nonce 생성 (보안)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>state</span> <span class=o>=</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>randomBytes</span><span class=p>(</span><span class=mi>16</span><span class=p>).</span><span class=nx>toString</span><span class=p>(</span><span class=s1>&#39;hex&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>nonce</span> <span class=o>=</span> <span class=nx>crypto</span><span class=p>.</span><span class=nx>randomBytes</span><span class=p>(</span><span class=mi>16</span><span class=p>).</span><span class=nx>toString</span><span class=p>(</span><span class=s1>&#39;hex&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>req</span><span class=p>.</span><span class=nx>session</span><span class=p>.</span><span class=nx>oidc_state</span> <span class=o>=</span> <span class=nx>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>req</span><span class=p>.</span><span class=nx>session</span><span class=p>.</span><span class=nx>oidc_nonce</span> <span class=o>=</span> <span class=nx>nonce</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// OpenID Provider로 리디렉션
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>const</span> <span class=nx>authUrl</span> <span class=o>=</span> <span class=sb>`https://openid-provider.com/auth?`</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=sb>`client_id=your-client-id&amp;`</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=sb>`redirect_uri=</span><span class=si>${</span><span class=nb>encodeURIComponent</span><span class=p>(</span><span class=s1>&#39;http://your-app.com/callback&#39;</span><span class=p>)</span><span class=si>}</span><span class=sb>&amp;`</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=sb>`response_type=code&amp;`</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=sb>`scope=openid profile email&amp;`</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=sb>`state=</span><span class=si>${</span><span class=nx>state</span><span class=si>}</span><span class=sb>&amp;`</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>    <span class=sb>`nonce=</span><span class=si>${</span><span class=nx>nonce</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>res</span><span class=p>.</span><span class=nx>redirect</span><span class=p>(</span><span class=nx>authUrl</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 2. 콜백 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>app</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;/callback&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>req</span><span class=p>,</span> <span class=nx>res</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>code</span><span class=p>,</span> <span class=nx>state</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>req</span><span class=p>.</span><span class=nx>query</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 상태 검증
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=nx>state</span> <span class=o>!==</span> <span class=nx>req</span><span class=p>.</span><span class=nx>session</span><span class=p>.</span><span class=nx>oidc_state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>403</span><span class=p>).</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;상태 불일치, CSRF 공격 가능성&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 권한 부여 코드를 토큰으로 교환
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>tokenResponse</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>axios</span><span class=p>.</span><span class=nx>post</span><span class=p>(</span><span class=s1>&#39;https://openid-provider.com/token&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>grant_type</span><span class=o>:</span> <span class=s1>&#39;authorization_code&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>code</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>redirect_uri</span><span class=o>:</span> <span class=s1>&#39;http://your-app.com/callback&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>client_id</span><span class=o>:</span> <span class=s1>&#39;your-client-id&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nx>client_secret</span><span class=o>:</span> <span class=s1>&#39;your-client-secret&#39;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=p>{</span> <span class=nx>id_token</span><span class=p>,</span> <span class=nx>access_token</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>tokenResponse</span><span class=p>.</span><span class=nx>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// ID 토큰 검증
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>decodedToken</span> <span class=o>=</span> <span class=nx>jwt</span><span class=p>.</span><span class=nx>decode</span><span class=p>(</span><span class=nx>id_token</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// nonce 검증
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>decodedToken</span><span class=p>.</span><span class=nx>nonce</span> <span class=o>!==</span> <span class=nx>req</span><span class=p>.</span><span class=nx>session</span><span class=p>.</span><span class=nx>oidc_nonce</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>403</span><span class=p>).</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;nonce 불일치&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 추가 검증 (발행자, 대상, 만료 시간 등)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=c1>// 사용자 정보 조회 (선택적)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kr>const</span> <span class=nx>userInfoResponse</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>axios</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;https://openid-provider.com/userinfo&#39;</span><span class=p>,</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>headers</span><span class=o>:</span> <span class=p>{</span> <span class=s1>&#39;Authorization&#39;</span><span class=o>:</span> <span class=sb>`Bearer </span><span class=si>${</span><span class=nx>access_token</span><span class=si>}</span><span class=sb>`</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 사용자 정보 저장 및 세션 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>req</span><span class=p>.</span><span class=nx>session</span><span class=p>.</span><span class=nx>user</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span><span class=nx>decodedToken</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span><span class=nx>userInfoResponse</span><span class=p>.</span><span class=nx>data</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>res</span><span class=p>.</span><span class=nx>redirect</span><span class=p>(</span><span class=s1>&#39;/dashboard&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span><span class=p>.</span><span class=nx>status</span><span class=p>(</span><span class=mi>500</span><span class=p>).</span><span class=nx>send</span><span class=p>(</span><span class=s1>&#39;인증 처리 중 오류 발생&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/backend-development/>Backend Development</a></li><li><a href=https://buenhyden.github.io/tags/api-design/>API-Design</a></li><li><a href=https://buenhyden.github.io/tags/authentication-methods/>Authentication-Methods</a></li><li><a href=https://buenhyden.github.io/tags/token-authentication/>Token-Authentication</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-oauth-20/><span class=title>« Prev</span><br><span>Token Authentication vs. OAuth</span>
</a><a class=next href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-cookie-based-auth/><span class=title>Next »</span><br><span>Token Authentication vs. Cookie-Based Auth</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>