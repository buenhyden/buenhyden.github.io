<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Memory Architecture | hyunyoun's Blog</title><meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture"><meta name=description content="컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Memory Architecture"><meta property="og:description" content="컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Memory Architecture"><meta name=twitter:description content="컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":4,"name":"Computer Architecture","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/"},{"@type":"ListItem","position":5,"name":"Memory Architecture","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/>Computer Architecture</a></div><h1>Memory Architecture</h1><div class=post-description>컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다.</div></header><div class=post-content><h2 id=memory-architecture>Memory Architecture<a hidden class=anchor aria-hidden=true href=#memory-architecture>#</a></h2><p>컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다.</p><p>컴퓨터에서는 빠른 속도와 큰 용량을 동시에 얻기가 어렵다. 빠른 메모리는 비용이 매우 높고, 큰 용량의 메모리는 상대적으로 느리다. 이러한 기술적, 경제적 제약을 해결하기 위해 여러 층의 메모리를 계층적으로 구성하게 되었다.</p><h3 id=메모리-계층-구조>메모리 계층 구조<a hidden class=anchor aria-hidden=true href=#메모리-계층-구조>#</a></h3><p>메모리 계층 구조는 접근 속도와 용량에 따라 여러 단계로 구성된다:</p><ol><li><strong>레지스터</strong>:<br>CPU 내부에 위치한 소용량의 초고속 메모리로, 현재 실행 중인 명령어와 관련된 데이터를 저장한다. 일반적으로 몇 비트에서 수십 비트 정도의 용량을 가지며, 접근 속도는 한 사이클 이내로 가장 빠르다.</li><li><strong>캐시 메모리</strong>:<br>주기억장치와 CPU 레지스터 사이에 위치하여, 자주 사용되는 데이터를 일시적으로 저장함으로써 CPU의 처리 속도를 향상시킨다. 일반적으로 L1, L2, L3 등의 여러 레벨로 구성되며, 레벨이 높아질수록 용량은 증가하지만 접근 속도는 감소한다.</li><li><strong>주 메모리 (RAM)</strong>:<br>프로그램과 데이터를 일시적으로 저장하는 휘발성 메모리로, 시스템의 작업 공간 역할을 한다. 용량은 수 기가바이트에서 수십 기가바이트에 이르며, 캐시 메모리보다 접근 속도는 느리지만 더 많은 데이터를 저장할 수 있다.</li><li><strong>보조 기억 장치</strong>:<br>하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD)와 같은 비휘발성 저장 장치로, 대용량의 데이터를 영구적으로 저장한다. 주기억장치보다 접근 속도는 느리지만, 데이터의 영구 저장이 가능하다.</li></ol><p>이러한 계층 구조는 데이터 접근 시간을 최소화하고 전체 시스템의 성능을 향상시킨다.</p><h3 id=주요-메모리-유형>주요 메모리 유형<a hidden class=anchor aria-hidden=true href=#주요-메모리-유형>#</a></h3><ol><li><p><strong>RAM (Random Access Memory)</strong>:</p><ul><li>휘발성 메모리로, 전원이 꺼지면 데이터가 사라진다.</li><li>SRAM(Static RAM)과 DRAM(Dynamic RAM)으로 구분된다.</li></ul></li><li><p><strong>ROM (Read Only Memory)</strong>:</p><ul><li>비휘발성 메모리로, 데이터가 영구적으로 저장된다.</li><li>PROM, EPROM, EEPROM 등 여러 종류가 있다.</li></ul></li><li><p><strong>캐시 메모리</strong>:</p><ul><li>CPU와 주 메모리 사이에 위치한 고속 메모리이다.</li><li>자주 사용되는 데이터를 저장하여 접근 속도를 높인다.</li><li>운영체제는 페이징이나 세그먼테이션을 통해 가상 주소를 물리 주소로 변환한다.</li></ul></li></ol><h3 id=메모리-관리-기법>메모리 관리 기법<a hidden class=anchor aria-hidden=true href=#메모리-관리-기법>#</a></h3><ol><li><p><strong>가상 메모리</strong>:</p><ul><li>물리적 메모리 크기의 한계를 극복하기 위한 기술이다.</li><li>하드 디스크의 일부를 RAM처럼 사용한다.</li></ul></li><li><p><strong>메모리 매핑</strong>:</p><ul><li>물리적 메모리 주소와 논리적 메모리 주소를 연결한다.</li><li>프로그램의 메모리 접근을 관리한다.</li></ul></li></ol><h3 id=최적화>최적화<a hidden class=anchor aria-hidden=true href=#최적화>#</a></h3><ol><li><strong>캐싱</strong>: 자주 사용되는 데이터를 고속 메모리에 저장한다.</li><li><strong>병렬 처리</strong>: 여러 메모리 유닛을 동시에 접근하여 처리 속도를 높인다.</li><li><strong>메모리 인터리빙</strong>: 연속된 메모리 주소를 여러 메모리 뱅크에 분산 저장한다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Replacement Policy</h2></header><div class=entry-content><p>Replacement Policy Cache Replacement Policy(캐시 교체 정책) 는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.
캐시는 한정된 크기를 가지므로, 새로운 데이터가 들어올 때 기존의 데이터를 교체해야 한다. 이때 어떤 데이터를 선택할지는 시스템의 성능에 큰 영향을 미친다.
Cache Replacement Policy는 캐시 메모리의 효율성을 극대화하는 데 중요한 역할을 한다. LRU, FIFO, LFU 등 다양한 정책들이 있으며, 각 정책은 특정 상황과 요구 사항에 따라 장단점이 다르다.
적절한 교체 정책을 선택함으로써 시스템의 성능을 개선하고 데이터 접근 속도를 높일 수 있다. 캐시를 효과적으로 관리하기 위해서는 워크로드 특성과 시스템 요구 사항을 면밀히 분석하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Replacement Policy" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/cache-design/replacement-policies/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 접근 방법 (Memory Access Methods)</h2></header><div class=entry-content><p>메모리 접근 방식 (Memory Access Methods) 컴퓨터 시스템에서 메모리에 접근하는 주요 방식은 다음과 같다:
순차적 접근 (Sequential Access)
메모리를 선형적인 순서로 접근하는 방식. 데이터를 처음부터 순서대로 읽거나 쓰며, 특정 위치에 접근하려면 그 앞의 모든 데이터를 거쳐야 한다. 주로 자기 테이프와 같은 저장 장치에서 사용된다. 직접 접근 (Direct Access)
각 메모리 블록이 고유한 주소를 가지고 있어 직접 접근이 가능하다. 일반적인 위치로 직접 접근한 후, 순차적 검색을 통해 최종 목적지에 도달한다. 하드 디스크와 같은 저장 장치에서 주로 사용된다. 랜덤 접근 (Random Access)
...</p></div><footer class=entry-footer><span title='2024-09-30 08:05:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 접근 방법 (Memory Access Methods)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/memory-management/address-translation/memory-access-methods/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 주소 지정 방식 (Memory Address Modes)</h2></header><div class=entry-content><p>메모리 주소 지정 방식 (Memory Address Modes) 메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.
유형 즉시 주소 지정 방식 (Immediate Addressing):
데이터가 명령어 자체에 포함되어 있다. 예: “5를 더해라” 라고 직접 지시하는 것과 같다. 가장 빠르지만, 큰 데이터를 다루기 어렵다. 직접 주소 지정 방식 (Direct Addressing):
명령어에 데이터가 있는 메모리 주소를 직접 지정한다. 예: “주소 100번에 있는 값을 가져와라” 라고 지시하는 것과 같다. 간단하고 이해하기 쉽다. 간접 주소 지정 방식 (Indirect Addressing):
...</p></div><footer class=entry-footer><span title='2024-09-30 08:04:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 주소 지정 방식 (Memory Address Modes)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/memory-management/address-translation/memory-address-modes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리의 계층 구조 (Memory Hierarchy)</h2></header><div class=entry-content><p>메모리의 계층 구조 (Memory Hierarchy) 메모리 계층 구조는 컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조.
이 구조는 속도, 용량, 비용 간의 균형을 고려하여 여러 종류의 메모리를 계층적으로 배치한다.
메모리 계층 구조의 각 레벨은 위로 올라갈수록 다음과 같은 특성을 가진다.
접근 속도가 빨라짐 용량이 작아짐 비트당 가격이 높아짐 CPU에 의한 접근 빈도가 증가함 1 2 3 4 5 6 7 8 계층 구조 (위에서 아래로): 레지스터 ↓ 캐시 (L1 → L2 → L3) ↓ 메인 메모리 (RAM) ↓ 보조 기억 장치 (SSD/HDD) 이러한 계층 구조는 ‘참조 지역성(Locality of Reference)’ 원리를 활용하여 전체 시스템의 성능을 최적화한다.
자주 사용되는 데이터를 빠른 상위 계층에 유지함으로써, 평균 데이터 접근 시간을 줄이고 전체적인 시스템 성능을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:33:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리의 계층 구조 (Memory Hierarchy)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/memory-hierarchy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Coherence</h2></header><div class=entry-content><p>Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.
멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.
캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.
멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Coherence" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/cache-design/cache-coherence/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>