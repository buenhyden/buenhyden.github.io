<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Microarchitecture | hyunyoun's Blog</title><meta name=keywords content="Computer-Science,Computer-System,Computer-Architecture,Processor"><meta name=description content="마이크로아키텍처는 컴퓨터 아키텍처의 핵심 영역으로, 명령어 집합 아키텍처 (ISA) 를 실제 하드웨어로 구현하는 방법과 관련된 설계 접근법을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/microarchitecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/microarchitecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/microarchitecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/microarchitecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Microarchitecture"><meta property="og:description" content="마이크로아키텍처는 컴퓨터 아키텍처의 핵심 영역으로, 명령어 집합 아키텍처 (ISA) 를 실제 하드웨어로 구현하는 방법과 관련된 설계 접근법을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Microarchitecture"><meta name=twitter:description content="마이크로아키텍처는 컴퓨터 아키텍처의 핵심 영역으로, 명령어 집합 아키텍처 (ISA) 를 실제 하드웨어로 구현하는 방법과 관련된 설계 접근법을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Microarchitecture","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/microarchitecture/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a></div><h1>Microarchitecture</h1><div class=post-description>마이크로아키텍처는 컴퓨터 아키텍처의 핵심 영역으로, 명령어 집합 아키텍처 (ISA) 를 실제 하드웨어로 구현하는 방법과 관련된 설계 접근법을 의미한다.</div></header><div class=post-content><h2 id=microarchitecture>Microarchitecture<a hidden class=anchor aria-hidden=true href=#microarchitecture>#</a></h2><p>마이크로아키텍처는 컴퓨터 아키텍처의 핵심 영역으로, 명령어 집합 아키텍처 (ISA) 를 실제 하드웨어로 구현하는 방법과 관련된 설계 접근법을 의미한다.<br>ISA 가 " 무엇을 할 수 있는가 " 를 정의한다면, 마이크로아키텍처는 " 어떻게 구현할 것인가 " 에 초점을 맞춘다. 같은 ISA 를 구현하더라도 서로 다른 마이크로아키텍처 설계를 통해 성능, 효율성, 비용, 전력 소비 등의 측면에서 큰 차이를 만들어낼 수 있다.</p><h3 id=마이크로아키텍처의-기본-개념>마이크로아키텍처의 기본 개념<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처의-기본-개념>#</a></h3><p>마이크로아키텍처는 프로세서의 내부 구조를 설계하는 방법론으로, ISA 가 정의한 추상적 명령어를 실제 하드웨어 동작으로 변환하는 과정을 다룬다.</p><h4 id=마이크로아키텍처와-isa-의-관계>마이크로아키텍처와 ISA 의 관계<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처와-isa-의-관계>#</a></h4><p>마이크로아키텍처와 ISA 는 밀접한 관계를 가지고 있지만 명확히 구분된다:</p><ul><li><p><strong>ISA(명령어 집합 아키텍처)</strong>: 소프트웨어와 하드웨어 사이의 인터페이스로, 프로그래머가 접근할 수 있는 레지스터, 명령어, 어드레싱 모드, 메모리 모델 등을 정의한다. x86, ARM, MIPS, RISC-V 등이 대표적인 ISA 이다.</p></li><li><p><strong>마이크로아키텍처</strong>: ISA 를 구현하는 방법으로, 파이프라인 구성, 캐시 계층 구조, 분기 예측기, 명령어 인출 및 디코딩 메커니즘 등을 포함한다. 인텔의 Skylake, AMD 의 Zen, ARM 의 Cortex-A78 등이 대표적인 마이크로아키텍처 사례이다.</p></li></ul><p>같은 ISA(예: x86-64) 를 공유하는 여러 프로세서 (인텔의 Core i7, AMD 의 Ryzen 등) 가 서로 다른 마이크로아키텍처를 가질 수 있으며, 이로 인해 성능, 전력 효율성, 발열 특성에 차이가 생긴다. 그러나 이러한 프로세서들은 동일한 소프트웨어를 실행할 수 있다.</p><h4 id=마이크로아키텍처의-추상화-수준>마이크로아키텍처의 추상화 수준<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처의-추상화-수준>#</a></h4><p>컴퓨터 시스템의 추상화 계층에서 마이크로아키텍처는 다음과 같은 위치를 차지한다:</p><ol><li><strong>애플리케이션 소프트웨어</strong> (최상위 계층)</li><li><strong>운영 체제</strong></li><li><strong>컴파일러와 어셈블러</strong></li><li><strong>명령어 집합 아키텍처 (ISA)</strong></li><li><strong>마이크로아키텍처</strong></li><li><strong>RTL(Register Transfer Level) 설계</strong></li><li><strong>게이트 수준 설계</strong></li><li><strong>트랜지스터 수준 설계</strong> (최하위 계층)</li></ol><p>마이크로아키텍처는 ISA 아래에 위치하며, 실제 하드웨어 구현에 가까운 수준의 추상화를 제공한다.</p><h3 id=마이크로아키텍처의-역사적-발전>마이크로아키텍처의 역사적 발전<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처의-역사적-발전>#</a></h3><p>마이크로아키텍처는 컴퓨터의 발전과 함께 끊임없이 진화해왔다.</p><p>주요 발전 단계를 살펴보면:</p><ol><li><p>초기 마이크로아키텍처<br>1950-60 년대의 초기 컴퓨터는 단순한 마이크로아키텍처를 가졌다:</p><ul><li><strong>순차 실행</strong>: 한 명령어가 완전히 실행된 후에 다음 명령어가 시작되는 방식</li><li><strong>하드와이어드 제어</strong>: 명령어를 실행하기 위한 제어 논리가 하드웨어로 직접 구현</li><li><strong>단일 ALU(산술 논리 장치)</strong>: 모든 연산이 하나의 ALU 에서 처리됨</li></ul></li><li><p>CISC 와 RISC 의 등장<br>1970-80 년대에는 두 가지 주요 마이크로아키텍처 철학이 등장했다:</p><ul><li><strong>CISC(Complex Instruction Set Computer)</strong>: 복잡하고 강력한 명령어를 제공하여 컴파일러 설계를 단순화하고 메모리 사용을 최소화하는 접근 방식. 인텔의 x86 아키텍처가 대표적이다.</li><li><strong>RISC(Reduced Instruction Set Computer)</strong>: 간단하고 균일한 명령어 세트를 사용하여 하드웨어 복잡성을 줄이고 파이프라이닝과 같은 최적화를 용이하게 하는 접근 방식. ARM, MIPS, SPARC, RISC-V 등이 이에 해당한다.</li></ul></li><li><p>현대 마이크로아키텍처로의 진화<br>1990 년대 이후 마이크로아키텍처는 다음과 같은 방향으로 발전했다:</p><ul><li><strong>하이브리드 접근법</strong>: 현대 CISC 프로세서는 내부적으로 CISC 명령어를 더 단순한 마이크로 연산 (micro-ops) 으로 변환하는 RISC 스타일의 코어를 사용한다. 인텔의 P6 마이크로아키텍처 (1995 년) 부터 이 접근법이 도입되었다.</li><li><strong>고급 최적화 기법</strong>: 비순차적 실행 (Out-of-Order Execution), 투기적 실행 (Speculative Execution), 슈퍼스칼라 설계 등 성능을 향상시키는 다양한 기법이 도입되었다.</li><li><strong>멀티코어 설계</strong>: 단일 코어의 성능 한계를 극복하기 위해 여러 프로세서 코어를 하나의 칩에 통합하는 접근법이 주류가 되었다.</li></ul></li></ol><h3 id=마이크로아키텍처의-기본-구성-요소>마이크로아키텍처의 기본 구성 요소<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처의-기본-구성-요소>#</a></h3><p>마이크로아키텍처는 여러 핵심 구성 요소로 이루어져 있으며, 이들의 설계와 통합 방식이 전체 성능을 결정한다.</p><ol><li><p>명령어 인출 및 디코딩 유닛<br>프로세서가 메모리에서 명령어를 가져오고 해석하는 부분:</p><ul><li><strong>명령어 인출 유닛 (Instruction Fetch Unit)</strong>: 메모리에서 명령어를 가져와 명령어 큐에 저장한다.</li><li><strong>명령어 디코딩 유닛 (Instruction Decode Unit)</strong>: 인출된 명령어를 해석하여 프로세서가 이해할 수 있는 내부 형식으로 변환한다.</li><li><strong>분기 예측기 (Branch Predictor)</strong>: 조건부 분기 명령어의 결과를 예측하여 명령어 파이프라인의 효율성을 높인다.</li></ul></li><li><p>실행 유닛<br>명령어를 실제로 처리하는 프로세서의 핵심 부분:</p><ul><li><strong>산술 논리 장치 (ALU)</strong>: 정수 연산, 논리 연산 등을 수행한다.</li><li><strong>부동 소수점 유닛 (FPU)</strong>: 부동 소수점 연산을 처리한다.</li><li><strong>벡터 처리 유닛 (Vector Processing Unit)</strong>: SIMD(Single Instruction, Multiple Data) 명령어를 처리한다.</li><li><strong>로드 - 저장 유닛 (Load-Store Unit)</strong>: 메모리 접근 명령어를 처리한다.</li></ul></li><li><p>레지스터 파일<br>프로세서 내부의 고속 저장소로, 현재 작업 중인 데이터와 명령어를 저장한다:</p><ul><li><strong>아키텍처 레지스터</strong>: ISA 에 정의된, 프로그래머가 접근할 수 있는 레지스터.</li><li><strong>물리적 레지스터</strong>: 실제 하드웨어 구현에 사용되는 레지스터로, 레지스터 리네이밍 (Register Renaming) 을 통해 아키텍처 레지스터와 매핑된다.</li><li><strong>특수 레지스터</strong>: 프로그램 카운터 (PC), 스택 포인터 (SP), 상태 레지스터 등 특별한 용도로 사용되는 레지스터.</li></ul></li><li><p>메모리 계층 구조<br>데이터와 명령어에 대한 접근 시간과 처리량을 최적화하는 계층적 저장 시스템이다:</p><ul><li><strong>L1 캐시</strong>: CPU 코어에 가장 가까운 소규모, 고속 캐시로, 보통 명령어용 (L1i) 과 데이터용 (L1d) 으로 분리.</li><li><strong>L2 캐시</strong>: L1 보다 크고 약간 느린 중간 수준의 캐시.</li><li><strong>L3 캐시 (LLC, Last Level Cache)</strong>: 여러 코어가 공유하는 대규모 캐시.</li><li><strong>메모리 컨트롤러</strong>: 주 메모리 (RAM) 에 대한 접근을 관리한다.</li></ul></li><li><p>제어 유닛<br>프로세서의 모든 부분을 조정하고 관리하는 역할을 한다:</p><ul><li><strong>파이프라인 제어 로직</strong>: 파이프라인의 흐름을 관리한다.</li><li><strong>클럭 분배 시스템</strong>: 프로세서의 여러 부분에 클럭 신호를 분배한다.</li><li><strong>인터럽트 처리기</strong>: 외부 및 내부 인터럽트를 처리한다.</li><li><strong>전력 관리 유닛</strong>: 프로세서의 전력 소비를 제어한다.</li></ul></li></ol><h3 id=마이크로아키텍처의-핵심-기술>마이크로아키텍처의 핵심 기술<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처의-핵심-기술>#</a></h3><p>마이크로아키텍처의 성능, 효율성, 복잡성은 다양한 설계 기술과 최적화에 크게 의존한다.</p><h4 id=파이프라이닝-pipelining>파이프라이닝 (Pipelining)<a hidden class=anchor aria-hidden=true href=#파이프라이닝-pipelining>#</a></h4><p>파이프라이닝은 명령어 실행을 여러 단계로 분할하여 여러 명령어가 동시에 서로 다른 단계에서 처리될 수 있도록 하는 기술이다.</p><h5 id=기본-5-단계-파이프라인>기본 5 단계 파이프라인<a hidden class=anchor aria-hidden=true href=#기본-5-단계-파이프라인>#</a></h5><p>가장 기본적인 RISC 파이프라인은 다음 5 단계로 구성된다:</p><ol><li><strong>명령어 인출 (IF, Instruction Fetch)</strong>: 메모리에서 명령어 가져오기</li><li><strong>명령어 해독 (ID, Instruction Decode)</strong>: 명령어 해석 및 레지스터 읽기</li><li><strong>실행 (EX, Execute)</strong>: ALU 연산 수행</li><li><strong>메모리 접근 (MEM, Memory Access)</strong>: 필요한 경우 메모리 읽기/쓰기</li><li><strong>레지스터 쓰기 (WB, Write Back)</strong>: 결과를 레지스터에 저장</li></ol><h5 id=파이프라인-위험-hazards>파이프라인 위험 (Hazards)<a hidden class=anchor aria-hidden=true href=#파이프라인-위험-hazards>#</a></h5><p>파이프라인 처리 시 발생할 수 있는 문제들:</p><ul><li><strong>구조적 위험 (Structural Hazard)</strong>: 여러 명령어가 같은 하드웨어 자원을 동시에 사용하려고 할 때 발생한다.</li><li><strong>데이터 위험 (Data Hazard)</strong>: 명령어가 아직 파이프라인에서 처리 중인 이전 명령어의 결과에 의존할 때 발생한다.</li><li><strong>제어 위험 (Control Hazard)</strong>: 분기 명령어로 인해 프로그램 흐름이 바뀔 때 발생한다.</li></ul><h5 id=위험-해결-방법>위험 해결 방법<a hidden class=anchor aria-hidden=true href=#위험-해결-방법>#</a></h5><ul><li><strong>포워딩 (Forwarding)/바이패싱 (Bypassing)</strong>: 레지스터에 쓰기 전에 결과를 다음 명령어로 직접 전달하여 데이터 위험을 줄인다.</li><li><strong>파이프라인 스톨 (Stall)</strong>: 위험이 해결될 때까지 파이프라인의 일부 또는 전체를 일시 중지한다.</li><li><strong>분기 예측 (Branch Prediction)</strong>: 분기의 결과를 예측하여 제어 위험으로 인한 지연을 최소화한다.</li></ul><h4 id=슈퍼스칼라-아키텍처-superscalar-architecture>슈퍼스칼라 아키텍처 (Superscalar Architecture)<a hidden class=anchor aria-hidden=true href=#슈퍼스칼라-아키텍처-superscalar-architecture>#</a></h4><p>슈퍼스칼라 설계는 동일한 파이프라인을 여러 개 두어 한 클럭 사이클에 여러 명령어를 동시에 인출, 디코딩, 실행할 수 있게 한다.</p><h5 id=발행-폭-issue-width>발행 폭 (Issue Width)<a hidden class=anchor aria-hidden=true href=#발행-폭-issue-width>#</a></h5><p>한 사이클에 처리할 수 있는 명령어의 수를 의미한다. 현대 프로세서는 보통 2-6 개의 명령어를 동시에 처리할 수 있다.</p><h5 id=명령어-스케줄링>명령어 스케줄링<a hidden class=anchor aria-hidden=true href=#명령어-스케줄링>#</a></h5><p>어떤 명령어를 어떤 실행 유닛에서 처리할지 결정하는 메커니즘:</p><ul><li><strong>정적 스케줄링</strong>: 컴파일 시간에 결정된다 (VLIW 아키텍처에서 사용).</li><li><strong>동적 스케줄링</strong>: 런타임에 하드웨어가 결정한다 (대부분의 현대 프로세서에서 사용).</li></ul><h4 id=비순차적-실행-out-of-order-execution>비순차적 실행 (Out-of-Order Execution)<a hidden class=anchor aria-hidden=true href=#비순차적-실행-out-of-order-execution>#</a></h4><p>명령어가 프로그램 순서대로 실행되지 않고, 데이터 의존성과 자원 가용성에 따라 최적의 순서로 실행되는 기법.</p><h5 id=토마술로-알고리즘-tomasulos-algorithm>토마술로 알고리즘 (Tomasulo&rsquo;s Algorithm)<a hidden class=anchor aria-hidden=true href=#토마술로-알고리즘-tomasulos-algorithm>#</a></h5><p>IBM 의 로버트 토마술로가 개발한 이 알고리즘은 현대 비순차적 실행의 기초가 되었다.<br>이 알고리즘은 다음과 같은 요소로 구성된다:</p><ul><li><strong>예약 스테이션 (Reservation Stations)</strong>: 실행을 기다리는 명령어를 저장한다.</li><li><strong>레지스터 리네이밍 (Register Renaming)</strong>: 쓰기 후 읽기 (RAW) 의존성만 유지하고 다른 의존성을 제거한다.</li><li><strong>공통 데이터 버스 (Common Data Bus)</strong>: 결과를 필요로 하는 모든 유닛에 동시에 브로드캐스트한다.</li></ul><h5 id=재정렬-버퍼-reorder-buffer-rob>재정렬 버퍼 (Reorder Buffer, ROB)<a hidden class=anchor aria-hidden=true href=#재정렬-버퍼-reorder-buffer-rob>#</a></h5><p>비순차적으로 실행된 명령어의 결과를 프로그램 순서대로 커밋 (commit) 하기 위한 버퍼이다. 이를 통해 정확한 예외 처리와 프로그램 의미론을 유지할 수 있다.</p><h4 id=투기적-실행-speculative-execution>투기적 실행 (Speculative Execution)<a hidden class=anchor aria-hidden=true href=#투기적-실행-speculative-execution>#</a></h4><p>프로그램 흐름의 변화 (주로 조건부 분기) 를 예측하여 미리 명령어를 실행하는 기법.</p><h5 id=분기-예측-branch-prediction>분기 예측 (Branch Prediction)<a hidden class=anchor aria-hidden=true href=#분기-예측-branch-prediction>#</a></h5><p>조건부 분기의 결과 (분기를 취할지 여부) 를 예측하는 기술:</p><ul><li><strong>정적 예측기</strong>: 항상 같은 방식으로 예측한다 (예: " 항상 분기를 취한다 " 또는 " 앞으로 향하는 분기는 취하고 뒤로 향하는 분기는 취하지 않는다 &ldquo;).</li><li><strong>동적 예측기</strong>: 이전 실행 패턴을 기반으로 예측한다:<ul><li><strong>1 비트 예측기</strong>: 마지막 결과만 기억한다.</li><li><strong>2 비트 예측기</strong>: 상태 기계를 사용하여 더 안정적인 예측을 제공한다.</li><li><strong>상관 예측기</strong>: 여러 분기의 이력을 함께 고려한다.</li><li><strong>신경망 기반 예측기</strong>: 최신 프로세서에서 사용되는 고급 예측 방식이다.</li></ul></li></ul><h5 id=메모리-의존성-예측>메모리 의존성 예측<a hidden class=anchor aria-hidden=true href=#메모리-의존성-예측>#</a></h5><p>로드 명령어가 앞선 저장 명령어와 동일한 메모리 위치를 참조할지 예측하는 기술. 이를 통해 메모리 작업의 비순차적 실행을 최적화할 수 있다.</p><h4 id=simdsingle-instruction-multiple-data-처리>SIMD(Single Instruction, Multiple Data) 처리<a hidden class=anchor aria-hidden=true href=#simdsingle-instruction-multiple-data-처리>#</a></h4><p>하나의 명령어로 여러 데이터 요소를 동시에 처리하는 병렬 처리 기법.</p><h5 id=simd-확장>SIMD 확장<a hidden class=anchor aria-hidden=true href=#simd-확장>#</a></h5><p>다양한 ISA 에 추가된 SIMD 명령어 세트:</p><ul><li><strong>x86</strong>: MMX, SSE, AVX, AVX-512</li><li><strong>ARM</strong>: NEON, SVE(Scalable Vector Extension)</li><li><strong>RISC-V</strong>: V 확장 (Vector Extension)</li></ul><h5 id=벡터-레지스터>벡터 레지스터<a hidden class=anchor aria-hidden=true href=#벡터-레지스터>#</a></h5><p>SIMD 연산에 사용되는 넓은 레지스터로, 여러 개의 데이터 요소를 포함할 수 있다 (예: 256 비트 AVX 레지스터는 8 개의 32 비트 부동 소수점 값을 저장할 수 있음).</p><h3 id=5-캐시-및-메모리-시스템-설계>5. 캐시 및 메모리 시스템 설계<a hidden class=anchor aria-hidden=true href=#5-캐시-및-메모리-시스템-설계>#</a></h3><p>메모리 시스템은 마이크로아키텍처 성능에 결정적인 영향을 미치는 요소이다.<br>현대 프로세서는 메모리 접근 지연 시간을 줄이기 위해 정교한 캐시 계층 구조를 사용한다.</p><h4 id=캐시-구성-및-정책>캐시 구성 및 정책<a hidden class=anchor aria-hidden=true href=#캐시-구성-및-정책>#</a></h4><h5 id=캐시-구성-매개변수>캐시 구성 매개변수<a hidden class=anchor aria-hidden=true href=#캐시-구성-매개변수>#</a></h5><ul><li><strong>캐시 크기</strong>: 저장할 수 있는 총 데이터 양</li><li><strong>라인 크기 (블록 크기)</strong>: 캐시의 기본 접근 단위</li><li><strong>연관성 (Associativity)</strong>: 메모리 블록이 캐시의 어느 위치에 저장될 수 있는지 결정</li></ul><h5 id=캐시-매핑-방식>캐시 매핑 방식<a hidden class=anchor aria-hidden=true href=#캐시-매핑-방식>#</a></h5><ul><li><strong>직접 매핑 (Direct Mapped)</strong>: 각 메모리 위치가 캐시의 특정 위치에만 매핑</li><li><strong>전체 연관 매핑 (Fully Associative)</strong>: 메모리 블록이 캐시의 어느 위치에나 저장 가능</li><li><strong>세트 연관 매핑 (Set Associative)</strong>: n-way 세트 연관 캐시에서는 메모리 블록이 특정 세트 내의 n 개 위치 중 하나에 저장 가능</li></ul><h5 id=교체-정책>교체 정책<a hidden class=anchor aria-hidden=true href=#교체-정책>#</a></h5><p>캐시가 가득 찼을 때 어떤 항목을 제거할지 결정하는 알고리즘:</p><ul><li><strong>LRU(Least Recently Used)</strong>: 가장 오래 사용되지 않은 항목을 교체</li><li><strong>FIFO(First In, First Out)</strong>: 가장 먼저 들어온 항목을 교체</li><li><strong>의사 -LRU(Pseudo-LRU)</strong>: 완전한 LRU 의 근사값 (구현 복잡성 감소)</li><li><strong>NRU(Not Recently Used)</strong>: 최근에 접근되지 않은 항목 교체</li></ul><h5 id=쓰기-정책>쓰기 정책<a hidden class=anchor aria-hidden=true href=#쓰기-정책>#</a></h5><p>캐시의 데이터가 수정될 때 메인 메모리를 어떻게 업데이트할지 결정한다:</p><ul><li><strong>쓰기 관통 (Write-Through)</strong>: 캐시와 메인 메모리를 동시에 업데이트</li><li><strong>쓰기 후 반영 (Write-Back)</strong>: 캐시만 즉시 업데이트하고, 블록이 교체될 때 메인 메모리에 반영</li></ul><h4 id=캐시-일관성-cache-coherence>캐시 일관성 (Cache Coherence)<a hidden class=anchor aria-hidden=true href=#캐시-일관성-cache-coherence>#</a></h4><p>멀티코어 시스템에서 여러 캐시가 동일한 메모리 위치의 복사본을 저장할 때, 이 복사본들이 일관된 상태를 유지하도록 하는 메커니즘.</p><h5 id=스누핑-snooping-프로토콜>스누핑 (Snooping) 프로토콜<a hidden class=anchor aria-hidden=true href=#스누핑-snooping-프로토콜>#</a></h5><p>각 캐시 컨트롤러가 공유 버스의 모든 트랜잭션을 &rsquo; 엿듣고 &rsquo; 필요한 경우 조치를 취하는 방식이다:</p><ul><li><strong>MESI 프로토콜</strong>: 캐시 라인의 상태를 Modified(수정됨), Exclusive(독점), Shared(공유), Invalid(무효) 중 하나로 표시</li><li><strong>MOESI 프로토콜</strong>: MESI 에 Owned(소유) 상태를 추가하여 쓰기 작업 최적화</li><li><strong>MESIF 프로토콜</strong>: MESI 에 Forward(전달) 상태를 추가하여 읽기 요청 최적화</li></ul><h5 id=디렉토리-기반-directory-based-프로토콜>디렉토리 기반 (Directory-Based) 프로토콜<a hidden class=anchor aria-hidden=true href=#디렉토리-기반-directory-based-프로토콜>#</a></h5><p>중앙 디렉토리가 각 메모리 블록의 상태 및 위치 정보를 유지하는 방식으로, 대규모 다중 프로세서 시스템에 적합하다:</p><ul><li><strong>완전 디렉토리 (Full-map Directory)</strong>: 각 메모리 블록마다 모든 프로세서의 상태를 추적</li><li><strong>제한된 디렉토리 (Limited Directory)</strong>: 특정 수의 프로세서만 추적 (확장성 향상)</li></ul><h4 id=메모리-주소-변환-및-tlb>메모리 주소 변환 및 TLB<a hidden class=anchor aria-hidden=true href=#메모리-주소-변환-및-tlb>#</a></h4><p>가상 메모리 시스템에서 가상 주소를 물리적 주소로 변환하는 과정입니다.</p><h5 id=페이지-테이블-page-table>페이지 테이블 (Page Table)<a hidden class=anchor aria-hidden=true href=#페이지-테이블-page-table>#</a></h5><p>가상 주소와 물리적 주소 간의 매핑 정보를 저장하는 데이터 구조:</p><ul><li><strong>단일 레벨 페이지 테이블</strong>: 간단하지만 큰 주소 공간에서는 비효율적</li><li><strong>다중 레벨 페이지 테이블</strong>: 계층적 구조로 메모리 효율성 향상</li><li><strong>역 페이지 테이블 (Inverted Page Table)</strong>: 물리적 페이지에서 가상 페이지로의 매핑</li></ul><h5 id=tlbtranslation-lookaside-buffer>TLB(Translation Lookaside Buffer)<a hidden class=anchor aria-hidden=true href=#tlbtranslation-lookaside-buffer>#</a></h5><p>최근 주소 변환 결과를 캐싱하는 특수 캐시로, 주소 변환 지연 시간을 줄인다:</p><ul><li><strong>완전 연관 TLB</strong>: 높은 적중률 (hit rate)</li><li><strong>세트 연관 TLB</strong>: 적중률과 하드웨어 복잡성의 균형</li><li><strong>다중 레벨 TLB</strong>: L1, L2 TLB 로 구성된 계층적 구조</li></ul><h3 id=마이크로아키텍처-최적화-기법>마이크로아키텍처 최적화 기법<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처-최적화-기법>#</a></h3><p>성능, 효율성, 신뢰성을 향상시키기 위한 다양한 최적화 기법이 마이크로아키텍처에 적용된다.</p><h4 id=최적화>최적화<a hidden class=anchor aria-hidden=true href=#최적화>#</a></h4><ol><li><p>프리페칭 (Prefetching)<br>프로세서가 앞으로 필요할 것으로 예상되는 데이터나 명령어를 미리 메모리에서 캐시로 가져오는 기술:</p><ul><li><strong>명령어 프리페칭</strong>: 곧 실행될 명령어를 미리 가져옴</li><li><strong>데이터 프리페칭</strong>: 액세스 패턴을 분석하여 곧 필요할 데이터를 예측하고 가져옴</li><li><strong>소프트웨어 프리페칭</strong>: 프로그래머나 컴파일러에 의한 명시적 프리페치 지시</li></ul></li><li><p>메모리 계층 최적화</p><ul><li><strong>뱅크 인터리빙 (Bank Interleaving)</strong>: 여러 메모리 뱅크를 병렬로 접근하여 대역폭 향상</li><li><strong>캐시 계층 조정</strong>: 작업 부하 특성에 맞게 캐시 크기, 연관성, 라인 크기 최적화</li><li><strong>비차단 캐시 (Non-blocking Cache)</strong>: 캐시 미스가 발생해도 다른 요청을 계속 처리</li></ul></li><li><p>명령어 최적화</p><ul><li><strong>트레이스 캐시 (Trace Cache)</strong>: 디코딩된 명령어 시퀀스를 저장하여 디코딩 단계 우회</li><li><strong>루프 캐싱 (Loop Caching)</strong>: 자주 실행되는 루프를 특수 캐시에 저장</li><li><strong>마이크로 연산 퓨전 (Micro-op Fusion)</strong>: 여러 마이크로 연산을 하나로 결합하여 처리</li></ul></li></ol><h4 id=전력-효율성-최적화>전력 효율성 최적화<a hidden class=anchor aria-hidden=true href=#전력-효율성-최적화>#</a></h4><ol><li><p>동적 전압 및 주파수 조정 (DVFS, Dynamic Voltage and Frequency Scaling)<br>작업 부하에 따라 프로세서의 전압과 주파수를 동적으로 조정하여 전력 소비를 최적화한다.</p></li><li><p>전력 게이팅 (Power Gating)<br>사용하지 않는 프로세서 부분의 전원을 차단하여 정적 전력 소비를 줄인다.</p></li><li><p>클럭 게이팅 (Clock Gating)<br>활성화되지 않은 회로에 클럭 신호를 차단하여 동적 전력 소비를 줄인다. 이는 불필요한 회로의 스위칭 활동을 방지하여 에너지를 절약한다.</p></li><li><p>비대칭 코어 설계 (Asymmetric Core Design)<br>서로 다른 성능과 전력 특성을 가진 코어를 조합하여 효율성을 극대화한다:</p><ul><li><strong>빅.리틀 (big.LITTLE) 아키텍처</strong>: ARM 이 개발한 이 설계는 고성능 &rsquo; 빅 &rsquo; 코어와 저전력 &rsquo; 리틀 &rsquo; 코어를 결합한다.</li><li><strong>하이브리드 코어 (Hybrid Cores)</strong>: 인텔의 Alder Lake 와 같은 프로세서는 성능 코어 (P-cores) 와 효율 코어 (E-cores) 를 결합한다.</li></ul></li></ol><h4 id=신뢰성-최적화>신뢰성 최적화<a hidden class=anchor aria-hidden=true href=#신뢰성-최적화>#</a></h4><ol><li><p>오류 감지 및 수정 (Error Detection and Correction)<br>데이터 무결성을 보장하기 위한 기법:</p><ul><li><strong>패리티 체크 (Parity Check)</strong>: 간단한 오류 감지 방식</li><li><strong>ECC(Error-Correcting Code) 메모리</strong>: 단일 비트 오류를 감지하고 수정할 수 있는 메모리</li><li><strong>SECDED(Single Error Correction, Double Error Detection)</strong>: 단일 비트 오류는 수정하고 이중 비트 오류는 감지</li></ul></li><li><p>장애 허용 (Fault Tolerance) 기법<br>하드웨어 장애 발생 시에도 시스템이 계속 작동할 수 있도록 하는 방법:</p><ul><li><strong>중복 실행 (Redundant Execution)</strong>: 동일한 연산을 여러 번 수행하여 결과 비교</li><li><strong>체크포인팅 (Checkpointing)</strong>: 프로세서 상태를 주기적으로 저장하여 장애 발생 시 복구</li><li><strong>잔여중복모듈 (Residue Redundant Modules)</strong>: 결과 검증을 위한 추가 계산 모듈</li></ul></li><li><p>열 관리 (Thermal Management)<br>과열로 인한 성능 저하와 하드웨어 손상을 방지하는 기법:</p><ul><li><strong>동적 열 관리 (Dynamic Thermal Management)</strong>: 온도가 임계값에 도달하면 성능을 조절</li><li><strong>열 설계 전력 (TDP, Thermal Design Power)</strong>: 냉각 시스템이 처리할 수 있는 최대 열 발산량</li><li><strong>열 스로틀링 (Thermal Throttling)</strong>: 과열 시 클럭 속도를 낮추어 발열 감소</li></ul></li></ol><h3 id=마이크로아키텍처의-설계-방법론>마이크로아키텍처의 설계 방법론<a hidden class=anchor aria-hidden=true href=#마이크로아키텍처의-설계-방법론>#</a></h3><p>마이크로아키텍처를 설계하는 과정은 복잡하고 다양한 트레이드오프를 고려해야 한다.</p><h4 id=설계-고려-사항>설계 고려 사항<a hidden class=anchor aria-hidden=true href=#설계-고려-사항>#</a></h4><ol><li><p>성능 목표<br>마이크로아키텍처 설계의 주요 성능 목표:</p><ul><li><strong>IPC(Instructions Per Cycle)</strong>: 사이클당 처리할 수 있는 명령어 수</li><li><strong>주파수 (Frequency)</strong>: 클럭 속도 (GHz)</li><li><strong>지연 시간 (Latency)</strong>: 명령어 처리에 소요되는 시간</li><li><strong>처리량 (Throughput)</strong>: 단위 시간당 처리할 수 있는 작업량</li></ul></li><li><p>제약 조건<br>마이크로아키텍처 설계 시 고려해야 할 제약 사항:</p><ul><li><strong>전력 소비 (Power Consumption)</strong>: 프로세서가 소비하는 총 전력량</li><li><strong>다이 크기 (Die Size)</strong>: 칩이 차지하는 실리콘 면적</li><li><strong>열 발산 (Heat Dissipation)</strong>: 발생하는 열의 양과 방출 방법</li><li><strong>생산 비용 (Manufacturing Cost)</strong>: 설계의 경제적 실현 가능성</li></ul></li><li><p>워크로드 특성<br>대상 애플리케이션의 특성에 따라 최적화 방향이 달라진다:</p><ul><li><strong>명령어 혼합 (Instruction Mix)</strong>: 정수, 부동 소수점, 벡터, 분기 등 명령어 유형의 분포</li><li><strong>ILP(Instruction-Level Parallelism)</strong>: 명령어 간의 병렬 실행 가능성</li><li><strong>메모리 접근 패턴 (Memory Access Pattern)</strong>: 순차적, 랜덤, 스트라이드 등의 접근 패턴</li><li><strong>데이터 지역성 (Data Locality)</strong>: 시간적, 공간적 지역성의 정도</li></ul></li></ol><h4 id=설계-프로세스>설계 프로세스<a hidden class=anchor aria-hidden=true href=#설계-프로세스>#</a></h4><ol><li><p>설계 단계<br>마이크로아키텍처 설계의 주요 단계:</p><ol><li><strong>요구사항 분석</strong>: 성능, 전력, 비용 등의 목표 설정</li><li><strong>아키텍처 정의</strong>: 파이프라인 깊이, 발행 폭, 캐시 계층 구조 등 주요 매개변수 결정</li><li><strong>마이크로아키텍처 설계</strong>: 각 컴포넌트의 상세 설계</li><li><strong>RTL(Register Transfer Level) 구현</strong>: 하드웨어 설명 언어로 설계 구현</li><li><strong>검증 및 테스트</strong>: 시뮬레이션, 에뮬레이션, 프로토타이핑을 통한 검증</li><li><strong>물리적 설계</strong>: 레이아웃, 배선, 타이밍 등 물리적 구현</li></ol></li><li><p>설계 공간 탐색 (Design Space Exploration)<br>다양한 설계 옵션을 평가하고 최적의 조합을 찾는 과정:</p><ul><li><strong>시뮬레이션 기반 탐색</strong>: 다양한 설계 매개변수를 시뮬레이션하여 결과 비교</li><li><strong>분석적 모델링</strong>: 수학적 모델을 사용하여 설계 옵션 평가</li><li><strong>기계 학습 기반 탐색</strong>: AI 기술을 활용하여 방대한 설계 공간을 효율적으로 탐색</li></ul></li><li><p>설계 검증 (Design Verification)<br>설계가 요구사항을 충족하고 올바르게 작동하는지 확인하는 과정:</p><ul><li><strong>기능적 검증</strong>: 설계가 ISA 사양을 정확히 구현하는지 확인</li><li><strong>성능 검증</strong>: 설계가 성능 목표를 달성하는지 평가</li><li><strong>전력 분석</strong>: 전력 소비 특성 분석</li><li><strong>정형 검증 (Formal Verification)</strong>: 수학적 방법을 사용하여 설계의 정확성 증명</li></ul></li></ol><h4 id=설계-도구-및-환경>설계 도구 및 환경<a hidden class=anchor aria-hidden=true href=#설계-도구-및-환경>#</a></h4><ol><li><p>시뮬레이션 도구<br>마이크로아키텍처의 동작을 모델링하고 분석하는 도구:</p><ul><li><strong>사이클 정확 시뮬레이터 (Cycle-Accurate Simulator)</strong>: gem5, SimpleScalar 등</li><li><strong>트레이스 기반 시뮬레이터 (Trace-Based Simulator)</strong>: 사전 기록된 명령어 트레이스를 사용</li><li><strong>통계적 시뮬레이터 (Statistical Simulator)</strong>: 확률적 모델을 사용하여 빠른 시뮬레이션 제공</li></ul></li><li><p>설계 자동화 도구<br>마이크로아키텍처 설계 과정을 지원하는 도구:</p><ul><li><strong>HDL(Hardware Description Language) 도구</strong>: Verilog/VHDL 편집, 시뮬레이션, 합성 도구</li><li><strong>고수준 합성 도구 (High-Level Synthesis)</strong>: C/C++ 와 같은 고수준 언어에서 하드웨어 설계 생성</li><li><strong>전력 분석 도구</strong>: 설계의 전력 소비 특성 분석</li><li><strong>타이밍 분석 도구</strong>: 설계의 타이밍 제약 충족 여부 검증</li></ul></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>파이프라이닝 (Pipelining)</h2></header><div class=entry-content><p>파이프라이닝 (Pipelining) 프로세서 아키텍처에서의 파이프라이닝(Pipelining)은 CPU의 성능을 향상시키는 중요한 기술이다.
파이프라이닝은 여러 명령어의 실행 단계를 중첩시켜 전체적인 처리량을 향상시키는 기술로, 여러 단계를 동시에 처리함으로써 효율성을 높인다.
현대 프로세서 설계에서 필수적인 기술이며, 대부분의 현대 CPU는 최소 2단계에서 최대 30-40단계의 파이프라인을 사용한다.
이 기술을 통해 프로세서의 전체적인 성능을 크게 향상시킬 수 있지만, 효과적인 구현을 위해서는 복잡한 설계 고려사항들을 신중히 관리해야 한다.
Source: https://www.geeksforgeeks.org/pipelined-architecture-with-its-diagram/
파이프라이닝의 작동 원리 파이프라이닝은 명령어 실행 과정을 여러 단계로 나누어 처리한다.
일반적인 파이프라인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-29 02:20:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 파이프라이닝 (Pipelining)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/microarchitecture/pipeline/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>