<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>UTF-8 | hyunyoun's Blog</title><meta name=keywords content="Computer-Science,Fundamentals,Character-Encodings,Types,Unicode"><meta name=description content="UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/utf-8/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/utf-8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/utf-8/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="UTF-8"><meta property="og:description" content="UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-12T13:16:00+00:00"><meta property="article:modified_time" content="2025-03-12T13:16:00+00:00"><meta property="article:tag" content="Computer-Science"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Character-Encodings"><meta property="article:tag" content="Types"><meta property="article:tag" content="Unicode"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="UTF-8"><meta name=twitter:description content="UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals Overview","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Encoding and Decoding","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/"},{"@type":"ListItem","position":4,"name":"문자 인코딩(Character Encodings)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/"},{"@type":"ListItem","position":5,"name":"Unicode","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/"},{"@type":"ListItem","position":6,"name":"UTF-8","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/utf-8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"UTF-8","name":"UTF-8","description":"UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다.","keywords":["Computer-Science","Fundamentals","Character-Encodings","Types","Unicode"],"articleBody":"UTF-8 UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다. 웹 페이지의 95% 이상이 UTF-8로 인코딩되어 있을 만큼 인터넷의 표준이 되었으며, 현대 소프트웨어 개발에서 필수적인 요소로 자리잡았다.\n역사적 배경과 개발 동기 문자 인코딩의 역사적 진화 컴퓨터는 기본적으로 숫자만 처리할 수 있으므로, 텍스트를 저장하고 표시하기 위해서는 각 문자를 숫자로 매핑하는 인코딩 시스템이 필요했다. 초기에는 ASCII(American Standard Code for Information Interchange)가 영어 알파벳과 기본 기호를 7비트(0-127)로 표현했지만, 영어 외 언어를 처리하기에는 충분하지 않았다.\n이후 다양한 국가와 언어별로 자체 인코딩 방식이 개발되었다(예: 한글의 EUC-KR, 일본어의 Shift-JIS, 중국어의 GB 등). 그러나 이러한 인코딩 방식들은 서로 호환되지 않아, 여러 언어가 혼합된 문서 처리에 큰 어려움이 있었다.\n유니코드의 등장 이런 문제를 해결하기 위해 1980년대 후반부터 모든 언어의 모든 문자를 하나의 통일된 코드 체계로 표현하기 위한 유니코드(Unicode) 프로젝트가 시작되었다. 유니코드는 각 문자에 고유한 코드 포인트(code point)를 할당하는 방식으로, 현재는 150개 이상의 현대 및 역사적 문자 체계를 포함하며 140만 개 이상의 문자를 수용할 수 있다.\nUTF-8의 탄생 유니코드의 초기 구현인 UCS-2와 UTF-16은 모든 문자를 2바이트 이상으로 표현했는데, 이는 기존의 ASCII 기반 시스템과의 호환성 문제를 일으켰다. 이 문제를 해결하기 위해 1992년 켄 톰슨(Ken Thompson)과 롭 파이크(Rob Pike)가 UTF-8을 개발했다.\n가변 길이 인코딩을 통해 ASCII와의 완벽한 호환성을 유지하면서도 전 세계 모든 문자를 표현할 수 있는 혁신적인 방식이었다.\nUTF-8의 기술적 구조 가변 길이 인코딩 방식 UTF-8의 가장 큰 특징은 가변 길이 인코딩 방식이다. 문자에 따라 1바이트부터 4바이트까지 다양한 길이로 인코딩되며, 이는 저장 공간과 대역폭을 효율적으로 사용할 수 있게 해준다.\n1바이트: ASCII 문자(영문자, 숫자, 기본 기호) 2바이트: 대부분의 라틴 문자 기반 언어, 히브리어, 아랍어, 그리스어 등 3바이트: BMP(Basic Multilingual Plane) 내의 대부분의 현대 언어(한글, 일본어, 중국어 포함) 4바이트: 이모티콘, 역사적 문자, 수학 기호 등 보조 평면(supplementary planes)의 문자들 바이트 구조와 인코딩 알고리즘 UTF-8 인코딩은 다음과 같은 바이트 패턴을 사용한다:\n1바이트 문자: 0xxxxxxx (ASCII와 동일) 2바이트 문자: 110xxxxx 10xxxxxx 3바이트 문자: 1110xxxx 10xxxxxx 10xxxxxx 4바이트 문자: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 첫 바이트의 선두 비트 패턴은 해당 문자가 총 몇 바이트로 구성되어 있는지를 나타내며, 후속 바이트는 항상 10으로 시작한다. 이 구조 덕분에 UTF-8은 자기 동기화(self-synchronizing) 기능을 가지고 있어, 텍스트 스트림의 어느 지점에서든 바이트 시퀀스의 시작과 끝을 쉽게 식별할 수 있다.\n유니코드 코드 포인트와 UTF-8 인코딩의 관계 유니코드 코드 포인트와 UTF-8 인코딩 사이의 변환은 다음과 같은 알고리즘을 따른다:\nU+0000 ~ U+007F (7비트): 그대로 1바이트로 인코딩 (0xxxxxxx) U+0080 ~ U+07FF (11비트): 2바이트로 인코딩 첫 바이트: 110xxxxx (상위 5비트) 둘째 바이트: 10xxxxxx (하위 6비트) U+0800 ~ U+FFFF (16비트): 3바이트로 인코딩 첫 바이트: 1110xxxx (상위 4비트) 둘째 바이트: 10xxxxxx (중간 6비트) 셋째 바이트: 10xxxxxx (하위 6비트) U+10000 ~ U+10FFFF (21비트): 4바이트로 인코딩 첫 바이트: 11110xxx (상위 3비트) 둘째 바이트: 10xxxxxx (상위 중간 6비트) 셋째 바이트: 10xxxxxx (하위 중간 6비트) 넷째 바이트: 10xxxxxx (하위 6비트) 실제 인코딩 예시 예를 들어, 한글 ‘가’(U+AC00)의 UTF-8 인코딩을 살펴보면:\n유니코드 코드 포인트: U+AC00 (10101100 00000000 이진수로 표현) 이는 U+0800 ~ U+FFFF 범위에 속하므로 3바이트로 인코딩된다. 인코딩 과정: 첫 바이트: 1110xxxx → 11101010 (1010은 상위 4비트) 둘째 바이트: 10xxxxxx → 10110000 (110000은 중간 6비트) 셋째 바이트: 10xxxxxx → 10000000 (000000은 하위 6비트) 최종 UTF-8 인코딩: 11101010 10110000 10000000 (16진수로 표현하면 EA B0 80) UTF-8의 장점과 특징 ASCII와의 호환성\nUTF-8의 가장 큰 강점 중 하나는 ASCII와 100% 호환된다는 점이다. ASCII 문자(0-127)는 UTF-8에서도 동일한 1바이트 값을 가지므로, 기존의 ASCII 텍스트는 수정 없이 그대로 UTF-8 텍스트로 간주될 수 있다. 이는 기존 시스템에서 UTF-8로의 전환을 매우 용이하게 만들었다.\n공간 효율성\nUTF-8은 가변 길이 인코딩 방식을 사용하기 때문에, 영어와 같은 라틴 문자 위주의 텍스트는 매우 효율적으로 저장된다. 예를 들어, 영어 텍스트는 UTF-16이나 UTF-32에 비해 UTF-8에서 50% 이상 공간을 절약할 수 있다. 물론 동아시아 언어와 같이 대부분의 문자가 3바이트를 차지하는 경우에는 UTF-16보다 공간 효율성이 떨어질 수 있다.\n자기 동기화 기능\nUTF-8의 바이트 패턴 설계는 문자열의 어느 지점에서든 각 문자의 시작점을 쉽게 식별할 수 있게 해준다. 이는 텍스트 처리 시 문자 경계를 정확히 파악할 수 있게 하여, 텍스트 편집기나 검색 엔진 같은 애플리케이션에서 매우 유용하다.\n바이트 순서(Endianness) 문제 없음\nUTF-16이나 UTF-32와 달리, UTF-8은 바이트 순서(엔디안)에 영향을 받지 않는다. 빅 엔디안과 리틀 엔디안 시스템 사이에서 데이터를 교환할 때 추가적인 변환이 필요 없어 플랫폼 간 호환성이 뛰어나다.\n유효성 검사 용이\nUTF-8의 엄격한 바이트 패턴 규칙 덕분에 잘못된 인코딩을 쉽게 탐지할 수 있다. 예를 들어, 후속 바이트는 항상 10으로 시작해야 하며, 그렇지 않으면 인코딩 오류로 판단할 수 있다. 이는 데이터 무결성 검증에 유리하다.\nUTF-8 관련 실용적 지식 다양한 프로그래밍 언어에서의 UTF-8 처리 대부분의 현대 프로그래밍 언어는 UTF-8을 기본적으로 지원한다.\n주요 언어별 UTF-8 처리 방식을 살펴보면:\nPython:\n1 2 3 4 5 6 7 8 # UTF-8 인코딩 text = \"안녕하세요\" encoded = text.encode('utf-8') print(encoded) # b'\\xec\\x95\\x88\\xeb\\x85\\x95\\xed\\x95\\x98\\xec\\x84\\xb8\\xec\\x9a\\x94' # UTF-8 디코딩 decoded = encoded.decode('utf-8') print(decoded) # '안녕하세요' JavaScript:\n1 2 3 4 5 6 7 8 9 10 // UTF-8 인코딩 const text = \"안녕하세요\"; const encoder = new TextEncoder(); const encoded = encoder.encode(text); console.log(encoded); // Uint8Array(15) [236, 149, 136, 235, 133, 149, 237, 149, 152, 236, 132, 184, 236, 154, 148] // UTF-8 디코딩 const decoder = new TextDecoder(); const decoded = decoder.decode(encoded); console.log(decoded); // \"안녕하세요\" Java:\n1 2 3 4 5 6 7 // UTF-8 인코딩 String text = \"안녕하세요\"; byte[] encoded = text.getBytes(StandardCharsets.UTF_8); // UTF-8 디코딩 String decoded = new String(encoded, StandardCharsets.UTF_8); System.out.println(decoded); // \"안녕하세요\" 웹 개발에서의 UTF-8 웹 개발에서 UTF-8을 올바르게 처리하기 위해서는 여러 계층에서 인코딩을 명시해야 한다:\nHTML 문서:\n1 2 3 4 5 6 7 8 9 10 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eUTF-8 문서\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e안녕하세요! こんにちは! 你好! Привет! مرحبا! שלום!\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e HTTP 헤더: 서버는 응답 헤더에 인코딩을 명시해야 한다:\n1 Content-Type: text/html; charset=UTF-8 데이터베이스 설정: MySQL 데이터베이스 예시:\n1 2 3 4 5 CREATE DATABASE mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; CREATE TABLE mytable ( id INT PRIMARY KEY, text_column TEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci ); (참고: MySQL에서는 완전한 UTF-8 지원을 위해 utf8mb4를 사용해야 한다. 기존의 utf8은 최대 3바이트만 지원하므로 이모티콘과 같은 4바이트 문자를 저장할 수 없다.)\nUTF-8 BOM (Byte Order Mark) BOM(Byte Order Mark)은 텍스트 파일의 시작 부분에 특수 마커를 삽입하여 인코딩을 식별하는 데 사용된다. UTF-8의 BOM은 EF BB BF 바이트 시퀀스이다.\nUTF-8은 바이트 순서 문제가 없기 때문에 원칙적으로 BOM이 필요하지 않다. 그러나 일부 소프트웨어(특히 Microsoft Windows 환경)에서는 인코딩 식별을 위해 BOM을 사용한다.\n이로 인해 다음과 같은 문제가 발생할 수 있다:\nBOM이 있는 파일을 BOM을 인식하지 못하는 시스템에서 처리할 때 첫 부분에 이상한 문자가 표시될 수 있다. 특히 웹 서버에서 HTTP 헤더 앞에 BOM이 포함되면 “헤더가 이미 전송되었습니다” 오류가 발생할 수 있다. 대부분의 현대적인 텍스트 에디터는 UTF-8 BOM 유무를 설정할 수 있는 옵션을 제공한다.\n일반적으로 웹 개발 시에는 BOM 없는 UTF-8을 사용하는 것이 권장된다.\nUTF-8과 다른 유니코드 인코딩 비교 UTF-16 UTF-16은 대부분의 문자를 2바이트로 인코딩하며, 특정 문자(주로 이모티콘과 같은 보조 평면 문자)는 4바이트로 인코딩한다.\n주요 특징과 UTF-8과의 차이점은 다음과 같다:\n장점: BMP 내의 모든 문자(대부분의 현대 언어)가 일정한 2바이트를 차지하므로, 문자 수 계산과 인덱싱이 더 간단하다. 동아시아 언어(한국어, 중국어, 일본어)의 경우 UTF-8(3바이트)보다 UTF-16(2바이트)이 더 공간 효율적이다. 단점: ASCII와 호환되지 않는다. 바이트 순서(빅 엔디안/리틀 엔디안) 문제가 있어, BOM 사용이 권장된다. 서로게이트 쌍(surrogate pair)을 사용하여 보조 평면 문자를 표현하는데, 이는 처리가 복잡하다. UTF-16은 Windows의 내부 문자열 처리, Java의 초기 버전, JavaScript 내부 문자열 표현 등에서 사용된다.\nUTF-32 UTF-32는 모든 유니코드 문자를 고정된 4바이트로 인코딩한다:\n장점: 모든 문자가 동일한 크기를 가지므로, 문자 인덱싱이 매우 간단하다(상수 시간 접근). 인코딩/디코딩 알고리즘이 단순하다. 단점: 공간 효율성이 매우 낮다. ASCII 문자도 4바이트를 차지한다. ASCII와 호환되지 않는다. 바이트 순서 문제가 있다. UTF-32는 주로 내부 처리나 특수한 환경에서 사용되며, 저장이나 전송에는 거의 사용되지 않는다.\n인코딩별 예시 비교 다음은 여러 문자를 다양한 유니코드 인코딩으로 표현한 예시:\n문자 코드 포인트 UTF-8 UTF-16BE UTF-32BE A U+0041 41 00 41 00 00 00 41 € U+20AC E2 82 AC 20 AC 00 00 20 AC 가 U+AC00 EA B0 80 AC 00 00 00 AC 00 😊 U+1F60A F0 9F 98 8A D8 3D DC 0A 00 01 F6 0A 이 비교에서 볼 수 있듯이, 문자에 따라 어떤 인코딩이 더 효율적인지가 달라진다. 영어와 같은 라틴 문자는 UTF-8이 가장 효율적이며, 동아시아 언어는 UTF-16이 더 효율적일 수 있다.\nUTF-8과 관련된 일반적인 문제와 해결책 인코딩 오류(Mojibake)\n인코딩 오류(일본어로 ‘모지바케’라고 함)는 텍스트가 잘못된 인코딩으로 해석될 때 발생한다. 예를 들어, UTF-8로 인코딩된 한글을 EUC-KR로 해석하면 깨진 문자가 표시된다.\n예방 및 해결 방법:\n모든 시스템 계층(파일, 데이터베이스, 웹 페이지, API 등)에서 일관된 UTF-8 인코딩을 사용한다. 명시적으로 인코딩을 지정한다(HTML 태그, HTTP 헤더, 데이터베이스 연결 설정 등). 이미 깨진 텍스트의 경우, 원본 인코딩을 추측하여 올바르게 재해석하는 도구를 사용할 수 있다. 정규화 문제\n유니코드에서는 일부 문자가 여러 방식으로 표현될 수 있다. 예를 들어, ‘é’는 단일 코드 포인트(U+00E9)로 표현하거나, ’e’(U+0065)와 억음 부호(U+0301)의 조합으로 표현할 수 있다. 두 표현은 시각적으로는 동일하지만 내부 표현이 다르므로, 문자열 비교나 검색 시 문제가 발생할 수 있다.\n해결 방법: 유니코드 정규화를 사용하여 모든 문자열을 일관된 형태로 변환한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Python에서의 유니코드 정규화 예시 import unicodedata # 결합 문자를 사용한 표현 combined = \"e\\u0301\" # 'e' + 억음 부호 print(combined) # 'é' # 단일 코드 포인트 표현 single = \"\\u00e9\" # 'é' print(single) # 'é' # 두 문자열은 시각적으로 동일하지만 비교 시 다름 print(combined == single) # False # 정규화 후에는 동일하게 인식됨 normalized_combined = unicodedata.normalize('NFC', combined) normalized_single = unicodedata.normalize('NFC', single) print(normalized_combined == normalized_single) # True 주요 정규화 형태:\nNFC(Normalization Form Canonical Composition): 가능한 한 결합 문자를 단일 코드 포인트로 변환 NFD(Normalization Form Canonical Decomposition): 결합 가능한 문자를 기본 문자와 결합 문자로 분해 NFKC, NFKD: 추가적으로 호환성 문자까지 정규화 문자열 처리와 인덱싱\nUTF-8에서는 문자가 가변 길이를 가지므로, 바이트 기반 인덱싱이 직관적이지 않을 수 있다. 예를 들어, 5번째 바이트가 반드시 5번째 문자를 의미하지는 않는다.\n해결 방법:\n문자 단위(코드 포인트 또는 그래핌 클러스터)로 처리하는 함수 사용 문자열을 처리하기 전에 문자 경계를 식별하는 알고리즘 적용\n대부분의 현대 프로그래밍 언어는 유니코드 문자를 올바르게 처리하는 함수를 제공한다. UTF-8의 미래와 발전 방향 전 세계적 채택 현황\nUTF-8은 현재 인터넷에서 압도적인 점유율을 보이고 있다. 2008년에는 웹 페이지의 약 30%만이 UTF-8을 사용했지만, 2022년에는 97% 이상의 웹 페이지가 UTF-8을 사용하고 있다. 이는 다국어 콘텐츠의 증가, 글로벌 소프트웨어 배포, 그리고 개발자들의 인코딩 표준화 노력 덕분이다.\n이모티콘과 새로운 문자의 증가\n유니코드는 계속해서 새로운 문자와 기호를 추가하고 있으며, 특히 이모티콘의 사용이 급증하고 있다. 이러한 추세는 UTF-8의 중요성을 더욱 강화하고 있다. 특히 이모티콘과 같은 4바이트 문자의 처리를 올바르게 지원하는 시스템의 필요성이 커지고 있다.\n레거시 시스템 마이그레이션\n많은 기업과 기관이 여전히 레거시 인코딩 시스템을 사용하고 있으며, 이를 UTF-8로 마이그레이션하는 과정에서 다양한 기술적 도전과 비용이 발생한다. 이러한 마이그레이션은 특히 대규모 레거시 데이터베이스와 애플리케이션을 보유한 기업에게 중요한 과제이다.\n용어 정리 용어 설명 참고 및 출처 ","wordCount":"1688","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-03-12T13:16:00Z","dateModified":"2025-03-12T13:16:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/utf-8/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals Overview</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/>Encoding and Decoding</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/>문자 인코딩(Character Encodings)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/encoding-and-decoding/character-encoding/unicode/>Unicode</a></div><h1 class="post-title entry-hint-parent">UTF-8</h1><div class=post-description>UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다.</div><div class=post-meta><span title='2025-03-12 13:16:00 +0000 UTC'>March 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Encoding%20and%20Decoding/Character%20Encoding/Unicode/utf-8.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#utf-8>UTF-8</a><ul><li><a href=#역사적-배경과-개발-동기>역사적 배경과 개발 동기</a></li><li><a href=#utf-8의-기술적-구조>UTF-8의 기술적 구조</a></li><li><a href=#utf-8의-장점과-특징>UTF-8의 장점과 특징</a></li><li><a href=#utf-8-관련-실용적-지식>UTF-8 관련 실용적 지식</a></li><li><a href=#utf-8과-다른-유니코드-인코딩-비교>UTF-8과 다른 유니코드 인코딩 비교</a></li><li><a href=#utf-8과-관련된-일반적인-문제와-해결책>UTF-8과 관련된 일반적인 문제와 해결책</a></li><li><a href=#utf-8의-미래와-발전-방향>UTF-8의 미래와 발전 방향</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=utf-8>UTF-8<a hidden class=anchor aria-hidden=true href=#utf-8>#</a></h2><p>UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다. 웹 페이지의 95% 이상이 UTF-8로 인코딩되어 있을 만큼 인터넷의 표준이 되었으며, 현대 소프트웨어 개발에서 필수적인 요소로 자리잡았다.</p><h3 id=역사적-배경과-개발-동기>역사적 배경과 개발 동기<a hidden class=anchor aria-hidden=true href=#역사적-배경과-개발-동기>#</a></h3><h4 id=문자-인코딩의-역사적-진화>문자 인코딩의 역사적 진화<a hidden class=anchor aria-hidden=true href=#문자-인코딩의-역사적-진화>#</a></h4><p>컴퓨터는 기본적으로 숫자만 처리할 수 있으므로, 텍스트를 저장하고 표시하기 위해서는 각 문자를 숫자로 매핑하는 인코딩 시스템이 필요했다. 초기에는 ASCII(American Standard Code for Information Interchange)가 영어 알파벳과 기본 기호를 7비트(0-127)로 표현했지만, 영어 외 언어를 처리하기에는 충분하지 않았다.</p><p>이후 다양한 국가와 언어별로 자체 인코딩 방식이 개발되었다(예: 한글의 EUC-KR, 일본어의 Shift-JIS, 중국어의 GB 등). 그러나 이러한 인코딩 방식들은 서로 호환되지 않아, 여러 언어가 혼합된 문서 처리에 큰 어려움이 있었다.</p><h4 id=유니코드의-등장>유니코드의 등장<a hidden class=anchor aria-hidden=true href=#유니코드의-등장>#</a></h4><p>이런 문제를 해결하기 위해 1980년대 후반부터 모든 언어의 모든 문자를 하나의 통일된 코드 체계로 표현하기 위한 유니코드(Unicode) 프로젝트가 시작되었다. 유니코드는 각 문자에 고유한 코드 포인트(code point)를 할당하는 방식으로, 현재는 150개 이상의 현대 및 역사적 문자 체계를 포함하며 140만 개 이상의 문자를 수용할 수 있다.</p><h4 id=utf-8의-탄생>UTF-8의 탄생<a hidden class=anchor aria-hidden=true href=#utf-8의-탄생>#</a></h4><p>유니코드의 초기 구현인 UCS-2와 UTF-16은 모든 문자를 2바이트 이상으로 표현했는데, 이는 기존의 ASCII 기반 시스템과의 호환성 문제를 일으켰다. 이 문제를 해결하기 위해 1992년 켄 톰슨(Ken Thompson)과 롭 파이크(Rob Pike)가 UTF-8을 개발했다.</p><p>가변 길이 인코딩을 통해 ASCII와의 완벽한 호환성을 유지하면서도 전 세계 모든 문자를 표현할 수 있는 혁신적인 방식이었다.</p><h3 id=utf-8의-기술적-구조>UTF-8의 기술적 구조<a hidden class=anchor aria-hidden=true href=#utf-8의-기술적-구조>#</a></h3><h4 id=가변-길이-인코딩-방식>가변 길이 인코딩 방식<a hidden class=anchor aria-hidden=true href=#가변-길이-인코딩-방식>#</a></h4><p>UTF-8의 가장 큰 특징은 가변 길이 인코딩 방식이다. 문자에 따라 1바이트부터 4바이트까지 다양한 길이로 인코딩되며, 이는 저장 공간과 대역폭을 효율적으로 사용할 수 있게 해준다.</p><ol><li><strong>1바이트</strong>: ASCII 문자(영문자, 숫자, 기본 기호)</li><li><strong>2바이트</strong>: 대부분의 라틴 문자 기반 언어, 히브리어, 아랍어, 그리스어 등</li><li><strong>3바이트</strong>: BMP(Basic Multilingual Plane) 내의 대부분의 현대 언어(한글, 일본어, 중국어 포함)</li><li><strong>4바이트</strong>: 이모티콘, 역사적 문자, 수학 기호 등 보조 평면(supplementary planes)의 문자들</li></ol><h4 id=바이트-구조와-인코딩-알고리즘>바이트 구조와 인코딩 알고리즘<a hidden class=anchor aria-hidden=true href=#바이트-구조와-인코딩-알고리즘>#</a></h4><p>UTF-8 인코딩은 다음과 같은 바이트 패턴을 사용한다:</p><ol><li><strong>1바이트 문자</strong>: <code>0xxxxxxx</code> (ASCII와 동일)</li><li><strong>2바이트 문자</strong>: <code>110xxxxx 10xxxxxx</code></li><li><strong>3바이트 문자</strong>: <code>1110xxxx 10xxxxxx 10xxxxxx</code></li><li><strong>4바이트 문자</strong>: <code>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</code></li></ol><p>첫 바이트의 선두 비트 패턴은 해당 문자가 총 몇 바이트로 구성되어 있는지를 나타내며, 후속 바이트는 항상 <code>10</code>으로 시작한다. 이 구조 덕분에 UTF-8은 자기 동기화(self-synchronizing) 기능을 가지고 있어, 텍스트 스트림의 어느 지점에서든 바이트 시퀀스의 시작과 끝을 쉽게 식별할 수 있다.</p><h4 id=유니코드-코드-포인트와-utf-8-인코딩의-관계>유니코드 코드 포인트와 UTF-8 인코딩의 관계<a hidden class=anchor aria-hidden=true href=#유니코드-코드-포인트와-utf-8-인코딩의-관계>#</a></h4><p>유니코드 코드 포인트와 UTF-8 인코딩 사이의 변환은 다음과 같은 알고리즘을 따른다:</p><ol><li><strong>U+0000 ~ U+007F</strong> (7비트): 그대로 1바이트로 인코딩 (<code>0xxxxxxx</code>)</li><li><strong>U+0080 ~ U+07FF</strong> (11비트): 2바이트로 인코딩<ul><li>첫 바이트: <code>110xxxxx</code> (상위 5비트)</li><li>둘째 바이트: <code>10xxxxxx</code> (하위 6비트)</li></ul></li><li><strong>U+0800 ~ U+FFFF</strong> (16비트): 3바이트로 인코딩<ul><li>첫 바이트: <code>1110xxxx</code> (상위 4비트)</li><li>둘째 바이트: <code>10xxxxxx</code> (중간 6비트)</li><li>셋째 바이트: <code>10xxxxxx</code> (하위 6비트)</li></ul></li><li><strong>U+10000 ~ U+10FFFF</strong> (21비트): 4바이트로 인코딩<ul><li>첫 바이트: <code>11110xxx</code> (상위 3비트)</li><li>둘째 바이트: <code>10xxxxxx</code> (상위 중간 6비트)</li><li>셋째 바이트: <code>10xxxxxx</code> (하위 중간 6비트)</li><li>넷째 바이트: <code>10xxxxxx</code> (하위 6비트)</li></ul></li></ol><h4 id=실제-인코딩-예시>실제 인코딩 예시<a hidden class=anchor aria-hidden=true href=#실제-인코딩-예시>#</a></h4><p>예를 들어, 한글 &lsquo;가&rsquo;(U+AC00)의 UTF-8 인코딩을 살펴보면:</p><ol><li>유니코드 코드 포인트: U+AC00 (10101100 00000000 이진수로 표현)</li><li>이는 U+0800 ~ U+FFFF 범위에 속하므로 3바이트로 인코딩된다.</li><li>인코딩 과정:<ul><li>첫 바이트: <code>1110xxxx</code> → <code>11101010</code> (1010은 상위 4비트)</li><li>둘째 바이트: <code>10xxxxxx</code> → <code>10110000</code> (110000은 중간 6비트)</li><li>셋째 바이트: <code>10xxxxxx</code> → <code>10000000</code> (000000은 하위 6비트)</li></ul></li><li>최종 UTF-8 인코딩: <code>11101010 10110000 10000000</code> (16진수로 표현하면 <code>EA B0 80</code>)</li></ol><h3 id=utf-8의-장점과-특징>UTF-8의 장점과 특징<a hidden class=anchor aria-hidden=true href=#utf-8의-장점과-특징>#</a></h3><ol><li><p>ASCII와의 호환성<br>UTF-8의 가장 큰 강점 중 하나는 ASCII와 100% 호환된다는 점이다. ASCII 문자(0-127)는 UTF-8에서도 동일한 1바이트 값을 가지므로, 기존의 ASCII 텍스트는 수정 없이 그대로 UTF-8 텍스트로 간주될 수 있다. 이는 기존 시스템에서 UTF-8로의 전환을 매우 용이하게 만들었다.</p></li><li><p>공간 효율성<br>UTF-8은 가변 길이 인코딩 방식을 사용하기 때문에, 영어와 같은 라틴 문자 위주의 텍스트는 매우 효율적으로 저장된다. 예를 들어, 영어 텍스트는 UTF-16이나 UTF-32에 비해 UTF-8에서 50% 이상 공간을 절약할 수 있다. 물론 동아시아 언어와 같이 대부분의 문자가 3바이트를 차지하는 경우에는 UTF-16보다 공간 효율성이 떨어질 수 있다.</p></li><li><p>자기 동기화 기능<br>UTF-8의 바이트 패턴 설계는 문자열의 어느 지점에서든 각 문자의 시작점을 쉽게 식별할 수 있게 해준다. 이는 텍스트 처리 시 문자 경계를 정확히 파악할 수 있게 하여, 텍스트 편집기나 검색 엔진 같은 애플리케이션에서 매우 유용하다.</p></li><li><p>바이트 순서(Endianness) 문제 없음<br>UTF-16이나 UTF-32와 달리, UTF-8은 바이트 순서(엔디안)에 영향을 받지 않는다. 빅 엔디안과 리틀 엔디안 시스템 사이에서 데이터를 교환할 때 추가적인 변환이 필요 없어 플랫폼 간 호환성이 뛰어나다.</p></li><li><p>유효성 검사 용이<br>UTF-8의 엄격한 바이트 패턴 규칙 덕분에 잘못된 인코딩을 쉽게 탐지할 수 있다. 예를 들어, 후속 바이트는 항상 <code>10</code>으로 시작해야 하며, 그렇지 않으면 인코딩 오류로 판단할 수 있다. 이는 데이터 무결성 검증에 유리하다.</p></li></ol><h3 id=utf-8-관련-실용적-지식>UTF-8 관련 실용적 지식<a hidden class=anchor aria-hidden=true href=#utf-8-관련-실용적-지식>#</a></h3><h4 id=다양한-프로그래밍-언어에서의-utf-8-처리>다양한 프로그래밍 언어에서의 UTF-8 처리<a hidden class=anchor aria-hidden=true href=#다양한-프로그래밍-언어에서의-utf-8-처리>#</a></h4><p>대부분의 현대 프로그래밍 언어는 UTF-8을 기본적으로 지원한다.</p><p>주요 언어별 UTF-8 처리 방식을 살펴보면:</p><p><strong>Python</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># UTF-8 인코딩</span>
</span></span><span class=line><span class=cl><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;안녕하세요&#34;</span>
</span></span><span class=line><span class=cl><span class=n>encoded</span> <span class=o>=</span> <span class=n>text</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>encoded</span><span class=p>)</span>  <span class=c1># b&#39;\xec\x95\x88\xeb\x85\x95\xed\x95\x98\xec\x84\xb8\xec\x9a\x94&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># UTF-8 디코딩</span>
</span></span><span class=line><span class=cl><span class=n>decoded</span> <span class=o>=</span> <span class=n>encoded</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s1>&#39;utf-8&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>decoded</span><span class=p>)</span>  <span class=c1># &#39;안녕하세요&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>JavaScript</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// UTF-8 인코딩
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>text</span> <span class=o>=</span> <span class=s2>&#34;안녕하세요&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>encoder</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>TextEncoder</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>encoded</span> <span class=o>=</span> <span class=nx>encoder</span><span class=p>.</span><span class=nx>encode</span><span class=p>(</span><span class=nx>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>encoded</span><span class=p>);</span>  <span class=c1>// Uint8Array(15) [236, 149, 136, 235, 133, 149, 237, 149, 152, 236, 132, 184, 236, 154, 148]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// UTF-8 디코딩
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>decoder</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>TextDecoder</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>decoded</span> <span class=o>=</span> <span class=nx>decoder</span><span class=p>.</span><span class=nx>decode</span><span class=p>(</span><span class=nx>encoded</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>decoded</span><span class=p>);</span>  <span class=c1>// &#34;안녕하세요&#34;
</span></span></span></code></pre></td></tr></table></div></div><p><strong>Java</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// UTF-8 인코딩</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>text</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;안녕하세요&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>encoded</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>text</span><span class=p>.</span><span class=na>getBytes</span><span class=p>(</span><span class=n>StandardCharsets</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// UTF-8 디코딩</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>decoded</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=n>encoded</span><span class=p>,</span><span class=w> </span><span class=n>StandardCharsets</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>decoded</span><span class=p>);</span><span class=w>  </span><span class=c1>// &#34;안녕하세요&#34;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=웹-개발에서의-utf-8>웹 개발에서의 UTF-8<a hidden class=anchor aria-hidden=true href=#웹-개발에서의-utf-8>#</a></h4><p>웹 개발에서 UTF-8을 올바르게 처리하기 위해서는 여러 계층에서 인코딩을 명시해야 한다:</p><ol><li><p><strong>HTML 문서</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=cp>&lt;!DOCTYPE html&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>meta</span> <span class=na>charset</span><span class=o>=</span><span class=s>&#34;UTF-8&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>title</span><span class=p>&gt;</span>UTF-8 문서<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>안녕하세요! こんにちは! 你好! Привет! مرحبا! שלום!<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>HTTP 헤더</strong>: 서버는 응답 헤더에 인코딩을 명시해야 한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Content-Type: text/html; charset=UTF-8
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>데이터베이스 설정</strong>: MySQL 데이터베이스 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>DATABASE</span><span class=w> </span><span class=n>mydb</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_unicode_ci</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>mytable</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>text_column</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=nb>CHARACTER</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>utf8mb4</span><span class=w> </span><span class=k>COLLATE</span><span class=w> </span><span class=n>utf8mb4_unicode_ci</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>(참고: MySQL에서는 완전한 UTF-8 지원을 위해 <code>utf8mb4</code>를 사용해야 한다. 기존의 <code>utf8</code>은 최대 3바이트만 지원하므로 이모티콘과 같은 4바이트 문자를 저장할 수 없다.)</p></li></ol><h4 id=utf-8-bom-byte-order-mark>UTF-8 BOM (Byte Order Mark)<a hidden class=anchor aria-hidden=true href=#utf-8-bom-byte-order-mark>#</a></h4><p>BOM(Byte Order Mark)은 텍스트 파일의 시작 부분에 특수 마커를 삽입하여 인코딩을 식별하는 데 사용된다. UTF-8의 BOM은 <code>EF BB BF</code> 바이트 시퀀스이다.</p><p>UTF-8은 바이트 순서 문제가 없기 때문에 원칙적으로 BOM이 필요하지 않다. 그러나 일부 소프트웨어(특히 Microsoft Windows 환경)에서는 인코딩 식별을 위해 BOM을 사용한다.</p><p>이로 인해 다음과 같은 문제가 발생할 수 있다:</p><ol><li>BOM이 있는 파일을 BOM을 인식하지 못하는 시스템에서 처리할 때 첫 부분에 이상한 문자가 표시될 수 있다.</li><li>특히 웹 서버에서 HTTP 헤더 앞에 BOM이 포함되면 &ldquo;헤더가 이미 전송되었습니다&rdquo; 오류가 발생할 수 있다.</li></ol><p>대부분의 현대적인 텍스트 에디터는 UTF-8 BOM 유무를 설정할 수 있는 옵션을 제공한다.<br>일반적으로 웹 개발 시에는 BOM 없는 UTF-8을 사용하는 것이 권장된다.</p><h3 id=utf-8과-다른-유니코드-인코딩-비교>UTF-8과 다른 유니코드 인코딩 비교<a hidden class=anchor aria-hidden=true href=#utf-8과-다른-유니코드-인코딩-비교>#</a></h3><h4 id=utf-16>UTF-16<a hidden class=anchor aria-hidden=true href=#utf-16>#</a></h4><p>UTF-16은 대부분의 문자를 2바이트로 인코딩하며, 특정 문자(주로 이모티콘과 같은 보조 평면 문자)는 4바이트로 인코딩한다.</p><p>주요 특징과 UTF-8과의 차이점은 다음과 같다:</p><ol><li><strong>장점</strong>:<ul><li>BMP 내의 모든 문자(대부분의 현대 언어)가 일정한 2바이트를 차지하므로, 문자 수 계산과 인덱싱이 더 간단하다.</li><li>동아시아 언어(한국어, 중국어, 일본어)의 경우 UTF-8(3바이트)보다 UTF-16(2바이트)이 더 공간 효율적이다.</li></ul></li><li><strong>단점</strong>:<ul><li>ASCII와 호환되지 않는다.</li><li>바이트 순서(빅 엔디안/리틀 엔디안) 문제가 있어, BOM 사용이 권장된다.</li><li>서로게이트 쌍(surrogate pair)을 사용하여 보조 평면 문자를 표현하는데, 이는 처리가 복잡하다.</li></ul></li></ol><p>UTF-16은 Windows의 내부 문자열 처리, Java의 초기 버전, JavaScript 내부 문자열 표현 등에서 사용된다.</p><h4 id=utf-32>UTF-32<a hidden class=anchor aria-hidden=true href=#utf-32>#</a></h4><p>UTF-32는 모든 유니코드 문자를 고정된 4바이트로 인코딩한다:</p><ol><li><strong>장점</strong>:<ul><li>모든 문자가 동일한 크기를 가지므로, 문자 인덱싱이 매우 간단하다(상수 시간 접근).</li><li>인코딩/디코딩 알고리즘이 단순하다.</li></ul></li><li><strong>단점</strong>:<ul><li>공간 효율성이 매우 낮다. ASCII 문자도 4바이트를 차지한다.</li><li>ASCII와 호환되지 않는다.</li><li>바이트 순서 문제가 있다.</li></ul></li></ol><p>UTF-32는 주로 내부 처리나 특수한 환경에서 사용되며, 저장이나 전송에는 거의 사용되지 않는다.</p><h4 id=인코딩별-예시-비교>인코딩별 예시 비교<a hidden class=anchor aria-hidden=true href=#인코딩별-예시-비교>#</a></h4><p>다음은 여러 문자를 다양한 유니코드 인코딩으로 표현한 예시:</p><table><thead><tr><th>문자</th><th>코드 포인트</th><th>UTF-8</th><th>UTF-16BE</th><th>UTF-32BE</th></tr></thead><tbody><tr><td>A</td><td>U+0041</td><td>41</td><td>00 41</td><td>00 00 00 41</td></tr><tr><td>€</td><td>U+20AC</td><td>E2 82 AC</td><td>20 AC</td><td>00 00 20 AC</td></tr><tr><td>가</td><td>U+AC00</td><td>EA B0 80</td><td>AC 00</td><td>00 00 AC 00</td></tr><tr><td>😊</td><td>U+1F60A</td><td>F0 9F 98 8A</td><td>D8 3D DC 0A</td><td>00 01 F6 0A</td></tr></tbody></table><p>이 비교에서 볼 수 있듯이, 문자에 따라 어떤 인코딩이 더 효율적인지가 달라진다. 영어와 같은 라틴 문자는 UTF-8이 가장 효율적이며, 동아시아 언어는 UTF-16이 더 효율적일 수 있다.</p><h3 id=utf-8과-관련된-일반적인-문제와-해결책>UTF-8과 관련된 일반적인 문제와 해결책<a hidden class=anchor aria-hidden=true href=#utf-8과-관련된-일반적인-문제와-해결책>#</a></h3><ol><li><p>인코딩 오류(Mojibake)<br>인코딩 오류(일본어로 &lsquo;모지바케&rsquo;라고 함)는 텍스트가 잘못된 인코딩으로 해석될 때 발생한다. 예를 들어, UTF-8로 인코딩된 한글을 EUC-KR로 해석하면 깨진 문자가 표시된다.<br><strong>예방 및 해결 방법</strong>:</p><ol><li>모든 시스템 계층(파일, 데이터베이스, 웹 페이지, API 등)에서 일관된 UTF-8 인코딩을 사용한다.</li><li>명시적으로 인코딩을 지정한다(HTML <code>&lt;meta></code> 태그, HTTP 헤더, 데이터베이스 연결 설정 등).</li><li>이미 깨진 텍스트의 경우, 원본 인코딩을 추측하여 올바르게 재해석하는 도구를 사용할 수 있다.</li></ol></li><li><p>정규화 문제<br>유니코드에서는 일부 문자가 여러 방식으로 표현될 수 있다. 예를 들어, &lsquo;é&rsquo;는 단일 코드 포인트(U+00E9)로 표현하거나, &rsquo;e&rsquo;(U+0065)와 억음 부호(U+0301)의 조합으로 표현할 수 있다. 두 표현은 시각적으로는 동일하지만 내부 표현이 다르므로, 문자열 비교나 검색 시 문제가 발생할 수 있다.<br><strong>해결 방법</strong>: 유니코드 정규화를 사용하여 모든 문자열을 일관된 형태로 변환한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 유니코드 정규화 예시</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>unicodedata</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 결합 문자를 사용한 표현</span>
</span></span><span class=line><span class=cl><span class=n>combined</span> <span class=o>=</span> <span class=s2>&#34;e</span><span class=se>\u0301</span><span class=s2>&#34;</span>  <span class=c1># &#39;e&#39; + 억음 부호</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>combined</span><span class=p>)</span>  <span class=c1># &#39;é&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 단일 코드 포인트 표현</span>
</span></span><span class=line><span class=cl><span class=n>single</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\u00e9</span><span class=s2>&#34;</span>  <span class=c1># &#39;é&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>single</span><span class=p>)</span>  <span class=c1># &#39;é&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 두 문자열은 시각적으로 동일하지만 비교 시 다름</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>combined</span> <span class=o>==</span> <span class=n>single</span><span class=p>)</span>  <span class=c1># False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 정규화 후에는 동일하게 인식됨</span>
</span></span><span class=line><span class=cl><span class=n>normalized_combined</span> <span class=o>=</span> <span class=n>unicodedata</span><span class=o>.</span><span class=n>normalize</span><span class=p>(</span><span class=s1>&#39;NFC&#39;</span><span class=p>,</span> <span class=n>combined</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>normalized_single</span> <span class=o>=</span> <span class=n>unicodedata</span><span class=o>.</span><span class=n>normalize</span><span class=p>(</span><span class=s1>&#39;NFC&#39;</span><span class=p>,</span> <span class=n>single</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>normalized_combined</span> <span class=o>==</span> <span class=n>normalized_single</span><span class=p>)</span>  <span class=c1># True</span>
</span></span></code></pre></td></tr></table></div></div><p>주요 정규화 형태:</p><ul><li><strong>NFC</strong>(Normalization Form Canonical Composition): 가능한 한 결합 문자를 단일 코드 포인트로 변환</li><li><strong>NFD</strong>(Normalization Form Canonical Decomposition): 결합 가능한 문자를 기본 문자와 결합 문자로 분해</li><li><strong>NFKC</strong>, <strong>NFKD</strong>: 추가적으로 호환성 문자까지 정규화</li></ul></li><li><p>문자열 처리와 인덱싱<br>UTF-8에서는 문자가 가변 길이를 가지므로, 바이트 기반 인덱싱이 직관적이지 않을 수 있다. 예를 들어, 5번째 바이트가 반드시 5번째 문자를 의미하지는 않는다.<br><strong>해결 방법</strong>:</p><ol><li>문자 단위(코드 포인트 또는 그래핌 클러스터)로 처리하는 함수 사용</li><li>문자열을 처리하기 전에 문자 경계를 식별하는 알고리즘 적용<br>대부분의 현대 프로그래밍 언어는 유니코드 문자를 올바르게 처리하는 함수를 제공한다.</li></ol></li></ol><h3 id=utf-8의-미래와-발전-방향>UTF-8의 미래와 발전 방향<a hidden class=anchor aria-hidden=true href=#utf-8의-미래와-발전-방향>#</a></h3><ol><li><p>전 세계적 채택 현황<br>UTF-8은 현재 인터넷에서 압도적인 점유율을 보이고 있다. 2008년에는 웹 페이지의 약 30%만이 UTF-8을 사용했지만, 2022년에는 97% 이상의 웹 페이지가 UTF-8을 사용하고 있다. 이는 다국어 콘텐츠의 증가, 글로벌 소프트웨어 배포, 그리고 개발자들의 인코딩 표준화 노력 덕분이다.</p></li><li><p>이모티콘과 새로운 문자의 증가<br>유니코드는 계속해서 새로운 문자와 기호를 추가하고 있으며, 특히 이모티콘의 사용이 급증하고 있다. 이러한 추세는 UTF-8의 중요성을 더욱 강화하고 있다. 특히 이모티콘과 같은 4바이트 문자의 처리를 올바르게 지원하는 시스템의 필요성이 커지고 있다.</p></li><li><p>레거시 시스템 마이그레이션<br>많은 기업과 기관이 여전히 레거시 인코딩 시스템을 사용하고 있으며, 이를 UTF-8로 마이그레이션하는 과정에서 다양한 기술적 도전과 비용이 발생한다. 이러한 마이그레이션은 특히 대규모 레거시 데이터베이스와 애플리케이션을 보유한 기업에게 중요한 과제이다.</p></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science/>Computer-Science</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/character-encodings/>Character-Encodings</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/unicode/>Unicode</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/design-patterns-and-integration/communication-patterns/hybrid-communication/webhooks-vs-polling/polling/types/smart-polling/><span class=title>« Prev</span><br><span>Smart Polling</span>
</a><a class=next href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication/protocols/federation-sso/saml/saml-vs-oauth-20/><span class=title>Next »</span><br><span>SAML vs. OAuth 2.0</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>