<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Allocation Policy | hyunyoun's Blog</title><meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Cache-Policy"><meta name=description content="Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/allocation-policy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/allocation-policy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/allocation-policy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Allocation Policy"><meta property="og:description" content="Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T10:53:00+00:00"><meta property="article:modified_time" content="2024-09-30T10:53:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Cache-Policy"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Allocation Policy"><meta name=twitter:description content="Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":""},{"@type":"ListItem","position":3,"name":"Computer Architecture","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/"},{"@type":"ListItem","position":4,"name":"Memory Architecture","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/"},{"@type":"ListItem","position":5,"name":"Cache Memory","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/"},{"@type":"ListItem","position":6,"name":"Cache Policy","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/"},{"@type":"ListItem","position":7,"name":"Allocation Policy","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/allocation-policy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Allocation Policy","name":"Allocation Policy","description":"Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Caching","Cache-Policy"],"articleBody":"Allocation Policy Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.\n이 정책은 시스템의 성능과 효율성에 큰 영향을 미치므로 신중하게 선택해야 한다.\nCache Allocation Policy의 주요 유형과 특징 Write-Allocate (Fetch-on-Write)\nWrite-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우(write miss), 먼저 해당 블록을 캐시로 가져온 후 쓰기 작업을 수행한다. 이 방식은 후속 읽기 작업이 캐시에서 바로 데이터를 찾을 수 있어 읽기 성능을 향상시킬 수 있다.\nNo-Write-Allocate (Write-No-Allocate)\nNo-Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우, 캐시를 건너뛰고 직접 메인 메모리에 데이터를 쓴다. 이 방식은 캐시 공간을 절약할 수 있지만, 후속 읽기 작업에서 캐시 미스가 발생할 가능성이 높아진다.\nExclusive Allocation\nExclusive Allocation은 데이터가 하나의 코어에서만 사용될 때 적용된다. 예를 들어, 코어 0에서 처음 요청한 데이터는 L1 또는 L2 캐시에 할당되지만 L3 캐시에는 할당되지 않는다. 이 데이터가 코어 0에서 제거될 때 L3 캐시에 할당된다. 코어 0이 이 데이터를 다시 가져오면, L1 또는 L2 캐시에 할당되고 L3 캐시에서는 제거되어 배타적 상태를 유지한다.\nInclusive Allocation\nInclusive Allocation은 데이터가 여러 코어 간에 공유될 때 사용된다. 예를 들어, 코어 1이 이미 코어 0에 캐시된 데이터에 접근하면, 해당 데이터는 코어 0의 캐시에 남아있으면서 동시에 코어 1의 캐시와 L3 캐시에도 할당된다.\n동적 캐시 할당 (Dynamic Cache Allocation)\n동적 캐시 할당은 시스템의 요구사항에 따라 캐시 할당을 실시간으로 조정하는 방식이다. 예를 들어, 중요한 작업에 고정된 수의 캐시 웨이를 할당하고, 작업이 시작될 때 할당을 활성화하는 방식으로 구현할 수 있다. 이 방식은 정적 할당의 단점을 보완하고 시스템의 유연성을 높일 수 있다.\nCache Allocation Policy를 선택할 때 고려해야할 사항 쓰기 빈도: 데이터가 얼마나 자주 쓰이는지 읽기 빈도: 데이터가 얼마나 자주 읽히는지 데이터 일관성 요구사항: 캐시와 메인 메모리 간의 데이터 일관성이 얼마나 중요한지 시스템 성능 목표: 읽기/쓰기 성능과 전체 시스템 효율성의 균형 워크로드 특성: 높은 지역성이나 무작위 접근 패턴 등 작업 부하의 특성 참고 및 출처 ","wordCount":"295","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T10:53:00Z","dateModified":"2024-09-30T10:53:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/allocation-policy/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/>Computer Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/>Memory Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/>Cache Memory</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/>Cache Policy</a></div><h1 class="post-title entry-hint-parent">Allocation Policy</h1><div class=post-description>Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.</div><div class=post-meta><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Computer%20Architecture/Memory%20Architectures/Cache%20Hierarchies/Cache%20Policy/allocation-policy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#allocation-policy>Allocation Policy</a><ul><li><a href=#cache-allocation-policy의-주요-유형과-특징>Cache Allocation Policy의 주요 유형과 특징</a></li><li><a href=#cache-allocation-policy를-선택할-때-고려해야할-사항>Cache Allocation Policy를 선택할 때 고려해야할 사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=allocation-policy>Allocation Policy<a hidden class=anchor aria-hidden=true href=#allocation-policy>#</a></h2><p>Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.<br>이 정책은 시스템의 성능과 효율성에 큰 영향을 미치므로 신중하게 선택해야 한다.</p><h3 id=cache-allocation-policy의-주요-유형과-특징>Cache Allocation Policy의 주요 유형과 특징<a hidden class=anchor aria-hidden=true href=#cache-allocation-policy의-주요-유형과-특징>#</a></h3><ol><li><p>Write-Allocate (Fetch-on-Write)<br>Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우(write miss), 먼저 해당 블록을 캐시로 가져온 후 쓰기 작업을 수행한다. 이 방식은 후속 읽기 작업이 캐시에서 바로 데이터를 찾을 수 있어 읽기 성능을 향상시킬 수 있다.</p></li><li><p>No-Write-Allocate (Write-No-Allocate)<br>No-Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우, 캐시를 건너뛰고 직접 메인 메모리에 데이터를 쓴다. 이 방식은 캐시 공간을 절약할 수 있지만, 후속 읽기 작업에서 캐시 미스가 발생할 가능성이 높아진다.</p></li><li><p>Exclusive Allocation<br>Exclusive Allocation은 데이터가 하나의 코어에서만 사용될 때 적용된다. 예를 들어, 코어 0에서 처음 요청한 데이터는 L1 또는 L2 캐시에 할당되지만 L3 캐시에는 할당되지 않는다. 이 데이터가 코어 0에서 제거될 때 L3 캐시에 할당된다. 코어 0이 이 데이터를 다시 가져오면, L1 또는 L2 캐시에 할당되고 L3 캐시에서는 제거되어 배타적 상태를 유지한다.</p></li><li><p>Inclusive Allocation<br>Inclusive Allocation은 데이터가 여러 코어 간에 공유될 때 사용된다. 예를 들어, 코어 1이 이미 코어 0에 캐시된 데이터에 접근하면, 해당 데이터는 코어 0의 캐시에 남아있으면서 동시에 코어 1의 캐시와 L3 캐시에도 할당된다.</p></li><li><p>동적 캐시 할당 (Dynamic Cache Allocation)<br>동적 캐시 할당은 시스템의 요구사항에 따라 캐시 할당을 실시간으로 조정하는 방식이다. 예를 들어, 중요한 작업에 고정된 수의 캐시 웨이를 할당하고, 작업이 시작될 때 할당을 활성화하는 방식으로 구현할 수 있다. 이 방식은 정적 할당의 단점을 보완하고 시스템의 유연성을 높일 수 있다.</p></li></ol><h3 id=cache-allocation-policy를-선택할-때-고려해야할-사항>Cache Allocation Policy를 선택할 때 고려해야할 사항<a hidden class=anchor aria-hidden=true href=#cache-allocation-policy를-선택할-때-고려해야할-사항>#</a></h3><ol><li>쓰기 빈도: 데이터가 얼마나 자주 쓰이는지</li><li>읽기 빈도: 데이터가 얼마나 자주 읽히는지</li><li>데이터 일관성 요구사항: 캐시와 메인 메모리 간의 데이터 일관성이 얼마나 중요한지</li><li>시스템 성능 목표: 읽기/쓰기 성능과 전체 시스템 효율성의 균형</li><li>워크로드 특성: 높은 지역성이나 무작위 접근 패턴 등 작업 부하의 특성</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/cache-policy/>Cache-Policy</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/addressability/byte-addressable-memory-vs-word-addressable-memory/><span class=title>« Prev</span><br><span>Byte Addressable Memory vs Word Addressable Memory</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-architectures/cache-hierarchies/cache-policy/prefetch-policy/><span class=title>Next »</span><br><span>Prefetch Policy</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>