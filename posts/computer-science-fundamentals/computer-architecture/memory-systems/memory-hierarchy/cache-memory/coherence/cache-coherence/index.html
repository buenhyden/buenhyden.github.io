<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cache Coherence | hyunyoun's Blog</title><meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Cache-Coherence"><meta name=description content="Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Cache Coherence"><meta property="og:description" content="Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T03:30:00+00:00"><meta property="article:modified_time" content="2024-09-30T03:30:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Cache-Coherence"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Cache Coherence"><meta name=twitter:description content="Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Cache Coherence","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cache Coherence","name":"Cache Coherence","description":"Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Caching","Cache-Coherence"],"articleBody":"Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.\n멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.\n캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.\n멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.\nCache Coherence는 멀티코어 및 병렬 처리 환경에서 필수적인 개념으로, 데이터 불일치를 방지하고 신뢰할 수 있는 연산 결과를 보장한다. Snooping 및 Directory 기반 프로토콜과 같은 다양한 기법이 활용되며, MESI와 MOESI 같은 표준 프로토콜은 이를 효과적으로 구현한다. 하지만 False Sharing과 같은 문제를 해결하기 위해 추가적인 설계 고려사항도 필요하다. Cache Coherence는 고성능 컴퓨팅 시스템 설계의 핵심 요소 중 하나이다.\nCache Coherence 문제 문제 발생 시나리오 데이터 불일치 문제:\n프로세서 A와 B가 동일한 메모리 주소(예: 변수 X)를 참조한다고 가정하자. A가 X 값을 수정했지만, B의 캐시는 여전히 이전 값을 유지하고 있다면, 이는 데이터 불일치 상태이다. 예제:\n초기 값: 메모리와 모든 캐시에 변수 X = 0. 프로세서 A가 X = 1로 수정. 프로세서 B는 여전히 자신의 캐시에 X = 0을 가지고 있음 → 불일치 발생. 주요 원인 Write-back 정책: 데이터를 수정할 때 메모리에 즉시 반영하지 않고, 로컬 캐시에만 저장하는 정책으로 인해 발생. 캐시 간 독립성: 각 프로세서의 캐시는 독립적으로 동작하므로, 다른 캐시의 상태를 자동으로 알지 못함. Cache Coherence 유지 방법 캐시 일관성을 유지하기 위해 하드웨어 또는 소프트웨어 수준에서 다양한 프로토콜과 기법이 사용된다.\nSnooping Protocol 모든 캐시가 공유 버스를 감시(스누핑)하여 다른 캐시에서 발생하는 쓰기 작업을 확인하고, 필요 시 자신의 캐시를 업데이트하거나 무효화한다.\n방식: Write-invalidate: 다른 캐시에서 쓰기가 발생하면 해당 데이터를 무효화(Invalid) 상태로 만든다. Write-update: 다른 캐시에서 쓰기가 발생하면 최신 데이터를 브로드캐스트하여 모든 캐시에 업데이트한다. 특징: 버스 기반 시스템에 적합. 노드 수가 증가하면 브로드캐스트로 인해 대역폭 문제가 발생할 수 있음. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class CacheController: def __init__(self): self.cache = {} self.bus = SystemBus() def monitor_bus(self): # 버스의 모든 트래픽을 모니터링 while True: transaction = self.bus.listen() if transaction.type == 'WRITE': if transaction.address in self.cache: # 다른 프로세서가 데이터를 수정했다면 # 자신의 캐시를 무효화 self.cache[transaction.address].invalidate() Directory-based Protocol 중앙 디렉터리를 사용하여 각 데이터 블록이 어느 캐시에 존재하는지 추적한다. 특정 노드에서 데이터 변경이 발생하면 디렉터리가 이를 감지하고 관련된 캐시에 알린다.\n특징: 대규모 시스템에 적합 (64개 이상의 프로세서를 가지는 환경). 브로드캐스트 없이 특정 노드에만 요청하므로 대역폭 효율적. 1 2 3 4 5 6 7 8 9 10 11 class CacheDirectory: def __init__(self): self.directory = {} # 각 메모리 블록의 상태 관리 def request_write(self, processor_id, address): if address in self.directory: # 해당 주소를 캐시한 모든 프로세서에게 # 무효화 메시지 전송 for proc_id in self.directory[address]: if proc_id != processor_id: send_invalidate_message(proc_id, address) Cache Coherence Protocols 캐시 일관성을 유지하기 위해 다양한 프로토콜이 개발되었다.\n대표적인 예는 다음과 같다:\nMESI Protocol 데이터의 상태를 네 가지로 구분하여 관리:\nModified (M): 수정된 상태로, 메모리와 다름. 이 데이터를 가진 유일한 복사본. Exclusive (E): 수정되지 않았으며, 메모리와 동일. 이 데이터를 가진 유일한 복사본. Shared (S): 여러 캐시에 존재하며, 메모리와 동일. Invalid (I): 무효화된 상태로, 최신 데이터가 아님. 작동 방식:\n쓰기 작업 시 다른 캐시에 있는 데이터를 무효화(Invalidate). 읽기 작업 시 필요한 경우 데이터를 공유 상태로 전환. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class CacheLine: def __init__(self): # Modified: 이 캐시만이 최신 데이터를 가짐 # Exclusive: 이 캐시만이 데이터의 복사본을 가짐 # Shared: 여러 캐시가 같은 데이터를 가짐 # Invalid: 이 캐시의 데이터는 더 이상 유효하지 않음 self.state = 'Invalid' self.data = None def write_data(self, new_value): if self.state == 'Shared': # 다른 캐시들의 복사본을 무효화 invalidate_other_copies() self.data = new_value self.state = 'Modified' MOESI Protocol MESI를 확장하여 Modified와 Shared 사이에 “Owned” 상태 추가:\nOwned(O): 데이터가 수정되었지만 공유 중인 상태로, 이 데이터는 다른 캐시에 복사본이 존재하며 메모리에 저장되지 않음. False Sharing 문제 정의 False Sharing은 서로 다른 프로세서가 동일한 캐시 라인(Cache Line)에 속하는 데이터를 사용할 때 발생하는 비효율적인 상황.\n예제 두 프로세서 A와 B가 같은 캐시 라인에 있는 서로 다른 변수를 사용한다고 가정하자. A가 자신의 변수를 수정하면 B의 변수가 포함된 전체 캐시 라인이 무효화된다. 결과적으로 B는 자신의 변수를 다시 가져와야 하며, 이는 성능 저하로 이어진다. 해결 방법 데이터를 적절히 정렬하거나 패딩(Padding)을 추가하여 서로 다른 변수들이 동일한 캐시 라인에 배치되지 않도록 설계한다. Cache Coherence의 장점과 단점 장점 데이터 일관성 보장: 멀티코어 환경에서 신뢰할 수 있는 데이터 액세스 제공. 성능 향상: 최신 데이터를 항상 사용할 수 있어 잘못된 계산 방지. 시스템 안정성 강화: 데이터 불일치로 인한 오류 방지. 단점 복잡성 증가: 하드웨어 및 소프트웨어 설계가 복잡해짐. 오버헤드 발생: 브로드캐스트 및 스누핑으로 인해 성능 저하 가능. 확장성 문제: 노드 수 증가 시 대역폭 요구량 급증. 실제 활용 사례 멀티코어 CPU:\n현대 CPU는 각 코어마다 독립적인 L1/L2/L3 캐시를 가지며, 이를 통해 고속 처리를 수행한다. Intel 및 AMD 프로세서는 MESI 또는 MOESI와 같은 프로토콜을 사용하여 일관성을 유지한다. 병렬 컴퓨팅 환경:\n병렬 처리 애플리케이션에서 여러 스레드가 동일한 데이터를 공유할 때 일관성을 보장한다. 분산 시스템:\n분산된 노드 간에 공유 데이터를 관리할 때도 유사한 원리가 적용된다. 참고 및 출처 ","wordCount":"834","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T03:30:00Z","dateModified":"2024-09-30T03:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Cache Coherence</h1><div class=post-description>Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.</div><div class=post-meta><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Computer%20Architecture/Memory%20Systems/Memory%20Hierarchy/Cache%20Memory/Coherence/Cache-Coherence.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cache-coherence>Cache Coherence</a><ul><li><a href=#cache-coherence-문제>Cache Coherence 문제</a></li><li><a href=#cache-coherence-유지-방법>Cache Coherence 유지 방법</a></li><li><a href=#cache-coherence-protocols>Cache Coherence Protocols</a></li><li><a href=#false-sharing-문제>False Sharing 문제</a></li><li><a href=#cache-coherence의-장점과-단점>Cache Coherence의 장점과 단점</a></li><li><a href=#실제-활용-사례>실제 활용 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=cache-coherence>Cache Coherence<a hidden class=anchor aria-hidden=true href=#cache-coherence>#</a></h2><p>Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.<br>멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.</p><p>캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.</p><p>멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.</p><p>Cache Coherence는 멀티코어 및 병렬 처리 환경에서 필수적인 개념으로, 데이터 불일치를 방지하고 신뢰할 수 있는 연산 결과를 보장한다. Snooping 및 Directory 기반 프로토콜과 같은 다양한 기법이 활용되며, MESI와 MOESI 같은 표준 프로토콜은 이를 효과적으로 구현한다. 하지만 False Sharing과 같은 문제를 해결하기 위해 추가적인 설계 고려사항도 필요하다. Cache Coherence는 고성능 컴퓨팅 시스템 설계의 핵심 요소 중 하나이다.</p><h3 id=cache-coherence-문제>Cache Coherence 문제<a hidden class=anchor aria-hidden=true href=#cache-coherence-문제>#</a></h3><h4 id=문제-발생-시나리오><strong>문제 발생 시나리오</strong><a hidden class=anchor aria-hidden=true href=#문제-발생-시나리오>#</a></h4><ol><li><p><strong>데이터 불일치 문제</strong>:</p><ul><li>프로세서 A와 B가 동일한 메모리 주소(예: 변수 X)를 참조한다고 가정하자.</li><li>A가 X 값을 수정했지만, B의 캐시는 여전히 이전 값을 유지하고 있다면, 이는 데이터 불일치 상태이다.</li></ul></li><li><p><strong>예제</strong>:</p><ul><li>초기 값: 메모리와 모든 캐시에 변수 X = 0.</li><li>프로세서 A가 X = 1로 수정.</li><li>프로세서 B는 여전히 자신의 캐시에 X = 0을 가지고 있음 → 불일치 발생.</li></ul></li></ol><h4 id=주요-원인>주요 원인<a hidden class=anchor aria-hidden=true href=#주요-원인>#</a></h4><ul><li><strong>Write-back 정책</strong>: 데이터를 수정할 때 메모리에 즉시 반영하지 않고, 로컬 캐시에만 저장하는 정책으로 인해 발생.</li><li><strong>캐시 간 독립성</strong>: 각 프로세서의 캐시는 독립적으로 동작하므로, 다른 캐시의 상태를 자동으로 알지 못함.</li></ul><h3 id=cache-coherence-유지-방법>Cache Coherence 유지 방법<a hidden class=anchor aria-hidden=true href=#cache-coherence-유지-방법>#</a></h3><p>캐시 일관성을 유지하기 위해 하드웨어 또는 소프트웨어 수준에서 다양한 프로토콜과 기법이 사용된다.</p><h4 id=snooping-protocol>Snooping Protocol<a hidden class=anchor aria-hidden=true href=#snooping-protocol>#</a></h4><p>모든 캐시가 공유 버스를 감시(스누핑)하여 다른 캐시에서 발생하는 쓰기 작업을 확인하고, 필요 시 자신의 캐시를 업데이트하거나 무효화한다.</p><ul><li><strong>방식</strong>:<ul><li><strong>Write-invalidate</strong>: 다른 캐시에서 쓰기가 발생하면 해당 데이터를 무효화(Invalid) 상태로 만든다.</li><li><strong>Write-update</strong>: 다른 캐시에서 쓰기가 발생하면 최신 데이터를 브로드캐스트하여 모든 캐시에 업데이트한다.</li></ul></li><li><strong>특징</strong>:<ul><li>버스 기반 시스템에 적합.</li><li>노드 수가 증가하면 브로드캐스트로 인해 대역폭 문제가 발생할 수 있음.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CacheController</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>bus</span> <span class=o>=</span> <span class=n>SystemBus</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>monitor_bus</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 버스의 모든 트래픽을 모니터링</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>transaction</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>bus</span><span class=o>.</span><span class=n>listen</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>transaction</span><span class=o>.</span><span class=n>type</span> <span class=o>==</span> <span class=s1>&#39;WRITE&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>transaction</span><span class=o>.</span><span class=n>address</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 다른 프로세서가 데이터를 수정했다면</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 자신의 캐시를 무효화</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>transaction</span><span class=o>.</span><span class=n>address</span><span class=p>]</span><span class=o>.</span><span class=n>invalidate</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=directory-based-protocol>Directory-based Protocol<a hidden class=anchor aria-hidden=true href=#directory-based-protocol>#</a></h4><p>중앙 디렉터리를 사용하여 각 데이터 블록이 어느 캐시에 존재하는지 추적한다. 특정 노드에서 데이터 변경이 발생하면 디렉터리가 이를 감지하고 관련된 캐시에 알린다.</p><ul><li><strong>특징</strong>:<ul><li>대규모 시스템에 적합 (64개 이상의 프로세서를 가지는 환경).</li><li>브로드캐스트 없이 특정 노드에만 요청하므로 대역폭 효율적.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CacheDirectory</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>directory</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 각 메모리 블록의 상태 관리</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>request_write</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>processor_id</span><span class=p>,</span> <span class=n>address</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>address</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>directory</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 해당 주소를 캐시한 모든 프로세서에게</span>
</span></span><span class=line><span class=cl>            <span class=c1># 무효화 메시지 전송</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>proc_id</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>directory</span><span class=p>[</span><span class=n>address</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>proc_id</span> <span class=o>!=</span> <span class=n>processor_id</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>send_invalidate_message</span><span class=p>(</span><span class=n>proc_id</span><span class=p>,</span> <span class=n>address</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=cache-coherence-protocols>Cache Coherence Protocols<a hidden class=anchor aria-hidden=true href=#cache-coherence-protocols>#</a></h3><p>캐시 일관성을 유지하기 위해 다양한 프로토콜이 개발되었다.<br>대표적인 예는 다음과 같다:</p><h4 id=mesi-protocol>MESI Protocol<a hidden class=anchor aria-hidden=true href=#mesi-protocol>#</a></h4><p>데이터의 상태를 네 가지로 구분하여 관리:</p><ol><li><strong>Modified (M)</strong>: 수정된 상태로, 메모리와 다름. 이 데이터를 가진 유일한 복사본.</li><li><strong>Exclusive (E)</strong>: 수정되지 않았으며, 메모리와 동일. 이 데이터를 가진 유일한 복사본.</li><li><strong>Shared (S)</strong>: 여러 캐시에 존재하며, 메모리와 동일.</li><li><strong>Invalid (I)</strong>: 무효화된 상태로, 최신 데이터가 아님.</li></ol><p>작동 방식:</p><ul><li>쓰기 작업 시 다른 캐시에 있는 데이터를 무효화(Invalidate).</li><li>읽기 작업 시 필요한 경우 데이터를 공유 상태로 전환.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CacheLine</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Modified: 이 캐시만이 최신 데이터를 가짐</span>
</span></span><span class=line><span class=cl>        <span class=c1># Exclusive: 이 캐시만이 데이터의 복사본을 가짐</span>
</span></span><span class=line><span class=cl>        <span class=c1># Shared: 여러 캐시가 같은 데이터를 가짐</span>
</span></span><span class=line><span class=cl>        <span class=c1># Invalid: 이 캐시의 데이터는 더 이상 유효하지 않음</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=s1>&#39;Invalid&#39;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>write_data</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>new_value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>==</span> <span class=s1>&#39;Shared&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 다른 캐시들의 복사본을 무효화</span>
</span></span><span class=line><span class=cl>            <span class=n>invalidate_other_copies</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>new_value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=s1>&#39;Modified&#39;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=moesi-protocol>MOESI Protocol<a hidden class=anchor aria-hidden=true href=#moesi-protocol>#</a></h4><p>MESI를 확장하여 Modified와 Shared 사이에 &ldquo;Owned&rdquo; 상태 추가:</p><ul><li>Owned(O): 데이터가 수정되었지만 공유 중인 상태로, 이 데이터는 다른 캐시에 복사본이 존재하며 메모리에 저장되지 않음.</li></ul><h3 id=false-sharing-문제>False Sharing 문제<a hidden class=anchor aria-hidden=true href=#false-sharing-문제>#</a></h3><h4 id=정의>정의<a hidden class=anchor aria-hidden=true href=#정의>#</a></h4><p>False Sharing은 서로 다른 프로세서가 동일한 캐시 라인(Cache Line)에 속하는 데이터를 사용할 때 발생하는 비효율적인 상황.</p><h4 id=예제>예제<a hidden class=anchor aria-hidden=true href=#예제>#</a></h4><ol><li>두 프로세서 A와 B가 같은 캐시 라인에 있는 서로 다른 변수를 사용한다고 가정하자.</li><li>A가 자신의 변수를 수정하면 B의 변수가 포함된 전체 캐시 라인이 무효화된다.</li><li>결과적으로 B는 자신의 변수를 다시 가져와야 하며, 이는 성능 저하로 이어진다.</li></ol><h4 id=해결-방법>해결 방법<a hidden class=anchor aria-hidden=true href=#해결-방법>#</a></h4><ul><li>데이터를 적절히 정렬하거나 패딩(Padding)을 추가하여 서로 다른 변수들이 동일한 캐시 라인에 배치되지 않도록 설계한다.</li></ul><h3 id=cache-coherence의-장점과-단점>Cache Coherence의 장점과 단점<a hidden class=anchor aria-hidden=true href=#cache-coherence의-장점과-단점>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ol><li>데이터 일관성 보장: 멀티코어 환경에서 신뢰할 수 있는 데이터 액세스 제공.</li><li>성능 향상: 최신 데이터를 항상 사용할 수 있어 잘못된 계산 방지.</li><li>시스템 안정성 강화: 데이터 불일치로 인한 오류 방지.</li></ol><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ol><li>복잡성 증가: 하드웨어 및 소프트웨어 설계가 복잡해짐.</li><li>오버헤드 발생: 브로드캐스트 및 스누핑으로 인해 성능 저하 가능.</li><li>확장성 문제: 노드 수 증가 시 대역폭 요구량 급증.</li></ol><h3 id=실제-활용-사례>실제 활용 사례<a hidden class=anchor aria-hidden=true href=#실제-활용-사례>#</a></h3><ol><li><p><strong>멀티코어 CPU</strong>:</p><ul><li>현대 CPU는 각 코어마다 독립적인 L1/L2/L3 캐시를 가지며, 이를 통해 고속 처리를 수행한다.</li><li>Intel 및 AMD 프로세서는 MESI 또는 MOESI와 같은 프로토콜을 사용하여 일관성을 유지한다.</li></ul></li><li><p><strong>병렬 컴퓨팅 환경</strong>:</p><ul><li>병렬 처리 애플리케이션에서 여러 스레드가 동일한 데이터를 공유할 때 일관성을 보장한다.</li></ul></li><li><p><strong>분산 시스템</strong>:</p><ul><li>분산된 노드 간에 공유 데이터를 관리할 때도 유사한 원리가 적용된다.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/cache-coherence/>Cache-Coherence</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/enterprise-usage/monorepo-vs-multirepo/><span class=title>« Prev</span><br><span>MonoRepo vs. MultiRepo</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/types/caching-techniques/><span class=title>Next »</span><br><span>Caching Techniques</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>