<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Architecture | hyunyoun's Blog</title>
<meta name=keywords content="Computer-Science,Computer-System,Computer-Architecture"><meta name=description content="컴퓨터 시스템의 구조와 설계를 정의하는 기본적인 프레임워크."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Architecture"><meta property="og:description" content="컴퓨터 시스템의 구조와 설계를 정의하는 기본적인 프레임워크."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Architecture"><meta name=twitter:description content="컴퓨터 시스템의 구조와 설계를 정의하는 기본적인 프레임워크."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Computer Architecture","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>컴퓨터 과학</a></div><h1>Computer Architecture</h1><div class=post-description>컴퓨터 시스템의 구조와 설계를 정의하는 기본적인 프레임워크.</div></header><div class=post-content><h2 id=computer-architecture>Computer Architecture<a hidden class=anchor aria-hidden=true href=#computer-architecture>#</a></h2><p>컴퓨터 아키텍처(Computer Architecture)는 컴퓨터 시스템의 구조, 기능, 설계 및 구현에 관한 학문 분야이다.<br>이는 하드웨어와 소프트웨어의 상호작용을 포함하며, 컴퓨터 시스템이 어떻게 구성되고 작동하는지를 연구한다.<br>컴퓨터 아키텍처는 현대 정보 기술의 근간으로, 그 이해는 컴퓨터 과학 및 엔지니어링 분야에서 필수적이다.</p><h3 id=컴퓨터-아키텍처의-기본-개념>컴퓨터 아키텍처의 기본 개념<a hidden class=anchor aria-hidden=true href=#컴퓨터-아키텍처의-기본-개념>#</a></h3><p>컴퓨터 아키텍처는 크게 세 가지 측면에서 정의할 수 있다:</p><ol><li><p><strong>명령어 집합 아키텍처(ISA, Instruction Set Architecture)</strong>: 컴퓨터가 이해하고 실행할 수 있는 명령어의 집합이다. 이는 프로그래머가 볼 수 있는 하드웨어의 추상화 층으로, 레지스터, 메모리 접근 방식, 입출력 모델 등을 정의한다.</p></li><li><p><strong>마이크로아키텍처(Microarchitecture)</strong>: ISA를 하드웨어로 구현하는 방법을 설명한다. 파이프라이닝, 캐시 구성, 분기 예측 등의 기술이 포함된다.</p></li><li><p><strong>시스템 설계(System Design)</strong>: 프로세서, 메모리 시스템, 입출력 장치 등을 어떻게 통합하여 완전한 컴퓨터 시스템을 구성하는지를 다룬다.</p></li></ol><h3 id=컴퓨터-아키텍처의-역사적-발전>컴퓨터 아키텍처의 역사적 발전<a hidden class=anchor aria-hidden=true href=#컴퓨터-아키텍처의-역사적-발전>#</a></h3><ol><li><p>초기 컴퓨터 아키텍처 (1940-1950년대)<br>최초의 전자식 컴퓨터들은 특정 목적을 위해 설계되었다. ENIAC(Electronic Numerical Integrator and Computer)과 같은 초기 컴퓨터는 거대한 진공관으로 구성되었고, 재프로그래밍이 어려웠다.</p></li><li><p>폰 노이만 아키텍처의 등장<br>존 폰 노이만이 1945년에 발표한 이 구조는 현대 컴퓨터의 기초가 되었다.<br>주요 특징은 다음과 같다:</p><ul><li><strong>저장 프로그램 방식</strong>: 프로그램과 데이터를 같은 메모리에 저장</li><li><strong>순차적 처리</strong>: 명령어를 순차적으로 실행</li><li><strong>주요 구성 요소</strong>: 중앙 처리 장치(CPU), 메모리, 입출력 장치, 제어 장치</li></ul></li><li><p>RISC와 CISC 아키텍처의 발전<br>1970-80년대에는 명령어 집합의 설계 철학에 따라 두 가지 주요 접근 방식이 등장했다:</p><ul><li><strong>CISC(Complex Instruction Set Computer)</strong>: 복잡하고 다양한 명령어를 제공하여 하나의 명령어로 여러 작업을 수행할 수 있다. 대표적인 예로 x86 아키텍처가 있다.</li><li><strong>RISC(Reduced Instruction Set Computer)</strong>: 간단하고 최적화된, 적은 수의 명령어를 사용한다. 각 명령어는 한 클럭 사이클 내에 실행될 수 있도록 설계되었다. ARM, MIPS, SPARC 등이 이에 해당한다.</li></ul></li><li><p>현대 아키텍처로의 진화<br>현대 컴퓨터 아키텍처는 RISC와 CISC의 장점을 혼합하고, 멀티코어 프로세서, 가상화 기술, 고급 캐싱 등의 기술을 포함하여 발전해왔다.</p></li></ol><h3 id=컴퓨터-시스템의-하드웨어-구성-요소>컴퓨터 시스템의 하드웨어 구성 요소<a hidden class=anchor aria-hidden=true href=#컴퓨터-시스템의-하드웨어-구성-요소>#</a></h3><p><figure><img alt="Computer Architecture" loading=lazy src=/img/Computer_architecture_block_diagram.png><figcaption>Source: https://en.wikipedia.org/wiki/Computer_architecture</figcaption></figure></p><h4 id=중앙-처리-장치cpu-아키텍처>중앙 처리 장치(CPU) 아키텍처<a hidden class=anchor aria-hidden=true href=#중앙-처리-장치cpu-아키텍처>#</a></h4><h5 id=cpu의-기본-구성-요소>CPU의 기본 구성 요소<a hidden class=anchor aria-hidden=true href=#cpu의-기본-구성-요소>#</a></h5><ol><li><p>산술 논리 장치(ALU)<br>ALU는 수학적, 논리적 연산을 수행하는 디지털 회로이다.<br>덧셈, 뺄셈, 곱셈, 나눗셈과 같은 산술 연산과 AND, OR, NOT과 같은 논리 연산을 처리한다.</p></li><li><p>제어 장치(Control Unit)<br>제어 장치는 CPU의 작동을 조정하고 감독한다. 이는 명령어를 가져오고, 해독하며, 실행하는 과정을 제어한다. 현대 CPU에서는 종종 마이크로코드 형태로 구현된다.</p></li><li><p>레지스터(Registers)<br>레지스터는 CPU 내부의 고속 저장 장치로, 현재 처리 중인 데이터와 명령어를 저장한다.<br>레지스터의 종류에는 다음이 포함된다:</p><ul><li><strong>범용 레지스터(General-Purpose Registers)</strong>: 다양한 용도로 사용</li><li><strong>특수 레지스터(Special-Purpose Registers)</strong>:<ul><li>프로그램 카운터(PC): 다음에 실행할 명령어의 주소</li><li>명령어 레지스터(IR): 현재 실행 중인 명령어</li><li>상태 레지스터(Status Register): CPU의 상태 정보(플래그)</li><li>메모리 주소 레지스터(MAR): 메모리 접근을 위한 주소</li><li>메모리 데이터 레지스터(MDR): 메모리에서 읽거나 쓸 데이터</li></ul></li></ul></li></ol><h5 id=명령어-처리-파이프라인>명령어 처리 파이프라인<a hidden class=anchor aria-hidden=true href=#명령어-처리-파이프라인>#</a></h5><p>현대 CPU는 명령어 실행을 여러 단계로 나누어 병렬 처리하는 파이프라이닝 기법을 사용한다.</p><p>기본적인 5단계 파이프라인은 다음과 같다:</p><ol><li><strong>명령어 인출(Instruction Fetch)</strong>: 메모리에서 명령어를 가져옴</li><li><strong>명령어 해독(Instruction Decode)</strong>: 명령어의 의미를 해석</li><li><strong>실행(Execute)</strong>: ALU에서 연산 수행</li><li><strong>메모리 접근(Memory Access)</strong>: 필요한 경우 메모리 읽기/쓰기</li><li><strong>결과 저장(Write Back)</strong>: 결과를 레지스터에 저장</li></ol><p>이 파이프라인은 여러 명령어가 동시에 서로 다른 단계에서 처리되도록 하여 처리량을 증가시킨다.</p><h5 id=고급-cpu-기술>고급 CPU 기술<a hidden class=anchor aria-hidden=true href=#고급-cpu-기술>#</a></h5><ol><li><p>슈퍼스칼라 아키텍처(Superscalar Architecture)<br>여러 명령어를 동시에 인출하고 실행할 수 있는 구조이다. 이는 한 클럭 사이클에 여러 명령어가 실행될 수 있도록 하여 성능을 향상시킨다.</p></li><li><p>분기 예측(Branch Prediction)<br>분기 명령어(조건문)의 결과를 예측하여 명령어 파이프라인의 공백을 최소화하는 기술이다. 정적 예측(항상 같은 방향으로 예측)과 동적 예측(이전 실행 패턴을 기반으로 예측) 방식이 있다.</p></li><li><p>투기적 실행(Speculative Execution)<br>분기 예측을 기반으로 아직 필요한지 확실하지 않은 명령어를 미리 실행하는 기술이다. 예측이 맞으면 성능이 향상되지만, 틀리면 실행 결과를 폐기하고 올바른 경로로 돌아가야 한다.</p></li><li><p>명령어 수준 병렬성(ILP, Instruction-Level Parallelism)<br>여러 명령어를 병렬로 실행하여 성능을 향상시키는 기법이다.<br>주요 방법으로는 파이프라이닝, 슈퍼스칼라 실행, 비순차적 실행(Out-of-Order Execution) 등이 있다.</p></li></ol><h4 id=메모리-아키텍처>메모리 아키텍처<a hidden class=anchor aria-hidden=true href=#메모리-아키텍처>#</a></h4><h5 id=메모리-계층-구조>메모리 계층 구조<a hidden class=anchor aria-hidden=true href=#메모리-계층-구조>#</a></h5><p>컴퓨터 시스템은 속도, 용량, 비용의 균형을 맞추기 위해 여러 계층의 메모리를 사용한다:</p><ol><li><strong>레지스터</strong>: 가장 빠르고 용량이 작은 CPU 내부 메모리</li><li><strong>캐시 메모리</strong>:<ul><li>L1 캐시: CPU에 가장 가까운 소규모, 고속 캐시</li><li>L2 캐시: L1보다 크고 느린 중간 캐시</li><li>L3 캐시: 여러 코어가 공유하는 대규모 캐시</li></ul></li><li><strong>주 메모리(RAM)</strong>: CPU가 직접 접근할 수 있는 휘발성 메모리</li><li><strong>보조 메모리</strong>: HDD, SSD와 같은 비휘발성 저장 장치</li></ol><h5 id=캐시-구조와-작동-원리>캐시 구조와 작동 원리<a hidden class=anchor aria-hidden=true href=#캐시-구조와-작동-원리>#</a></h5><p>캐시는 자주 접근하는 데이터를 고속 메모리에 저장하여 성능을 향상시킨다.</p><ol><li><p>캐시 매핑 방식</p><ul><li><strong>직접 매핑(Direct Mapping)</strong>: 각 메모리 위치가 캐시의 특정 위치에만 매핑</li><li><strong>연관 매핑(Associative Mapping)</strong>: 메모리 블록이 캐시의 어느 위치에나 저장 가능</li><li><strong>집합 연관 매핑(Set-Associative Mapping)</strong>: 직접 매핑과 연관 매핑의 절충안</li></ul></li><li><p>캐시 일관성(Cache Coherence)<br>멀티프로세서 시스템에서 여러 캐시가 동일한 메모리 위치를 참조할 때 일관성을 유지하는 프로토콜이다. 주요 프로토콜로는 MESI, MOESI, MESIF 등이 있습니다.</p></li></ol><h5 id=가상-메모리>가상 메모리<a hidden class=anchor aria-hidden=true href=#가상-메모리>#</a></h5><p>물리적 메모리보다 더 큰 주소 공간을 제공하는 메모리 관리 기법이다.<br>이는 디스크의 일부를 RAM의 확장으로 사용한다.</p><ol><li><p>페이징(Paging)<br>가상 메모리를 고정 크기의 블록(페이지)으로 나누어 관리하는 방식이다. 가상 주소를 물리적 주소로 변환하기 위해 페이지 테이블을 사용한다.</p></li><li><p>세그멘테이션(Segmentation)<br>메모리를 논리적 단위(세그먼트)로 분할하는 방식이다. 각 세그먼트는 크기가 다를 수 있으며, 세그먼트 테이블을 통해 주소를 변환한다.</p></li><li><p>주소 변환<br>가상 주소에서 물리적 주소로의 변환은 다음과 같은 단계로 이루어진다:</p><ol><li>가상 주소를 페이지 번호와 오프셋으로 분리</li><li>페이지 테이블에서 해당 페이지의 물리적 프레임 번호 찾기</li><li>물리적 프레임 번호와 오프셋을 결합하여 물리적 주소 생성<br>이 과정은 TLB(Translation Lookaside Buffer)라는 특수 캐시를 통해 가속화된다.</li></ol></li></ol><h4 id=입출력io-아키텍처>입출력(I/O) 아키텍처<a hidden class=anchor aria-hidden=true href=#입출력io-아키텍처>#</a></h4><h5 id=io-제어-방식>I/O 제어 방식<a hidden class=anchor aria-hidden=true href=#io-제어-방식>#</a></h5><p>컴퓨터가 주변 장치와 통신하는 방법에는 여러 가지가 있다:</p><ol><li><p>프로그램된 I/O(Programmed I/O)<br>CPU가 I/O 장치의 상태를 주기적으로 확인하는 방식이다. 간단하지만 CPU 시간을 많이 소모한다.</p></li><li><p>인터럽트 기반 I/O(Interrupt-Driven I/O)<br>I/O 장치가 작업을 완료하면 CPU에 인터럽트를 발생시키는 방식이다. CPU는 인터럽트가 발생할 때까지 다른 작업을 수행할 수 있다.</p></li><li><p>DMA(Direct Memory Access)<br>CPU 개입 없이 I/O 장치가 메모리에 직접 접근할 수 있게 하는 방식이다. 대량 데이터 전송에 효율적이다.</p></li></ol><h5 id=버스-아키텍처>버스 아키텍처<a hidden class=anchor aria-hidden=true href=#버스-아키텍처>#</a></h5><p>버스는 컴퓨터 내부 구성 요소 간의 데이터 전송 경로:</p><ol><li><p>내부 버스<br>CPU 내부에서 데이터를 전송하는 버스.</p></li><li><p>시스템 버스</p><ul><li><strong>주소 버스(Address Bus)</strong>: 메모리나 I/O 장치의 주소 전송</li><li><strong>데이터 버스(Data Bus)</strong>: 실제 데이터 전송</li><li><strong>제어 버스(Control Bus)</strong>: 제어 신호 전송</li></ul></li><li><p>입출력 버스<br>CPU와 외부 장치를 연결하는 버스. PCI, PCI Express, USB 등이 여기에 해당한다.</p></li></ol><h5 id=io-인터페이스>I/O 인터페이스<a hidden class=anchor aria-hidden=true href=#io-인터페이스>#</a></h5><p>CPU와 I/O 장치 간의 데이터 전송을 관리하는 하드웨어:</p><ol><li><p>포트 매핑(Port-Mapped I/O)<br>I/O 장치를 위한 별도의 주소 공간을 사용하는 방식. 특별한 I/O 명령어(IN, OUT 등)가 필요하다.</p></li><li><p>메모리 매핑(Memory-Mapped I/O)<br>I/O 장치를 메모리 주소 공간의 일부로 취급하는 방식. 일반 메모리 접근 명령어를 사용하여 I/O 장치와 통신할 수 있다.</p></li></ol><h3 id=병렬-컴퓨터-아키텍처>병렬 컴퓨터 아키텍처<a hidden class=anchor aria-hidden=true href=#병렬-컴퓨터-아키텍처>#</a></h3><h4 id=플린의-분류flynns-taxonomy>플린의 분류(Flynn&rsquo;s Taxonomy)<a hidden class=anchor aria-hidden=true href=#플린의-분류flynns-taxonomy>#</a></h4><p>컴퓨터 아키텍처를 명령어 스트림과 데이터 스트림의 개수에 따라 분류한 체계:</p><ol><li>SISD(Single Instruction, Single Data): 전통적인 단일 프로세서 컴퓨터로, 한 번에 하나의 명령어로 하나의 데이터를 처리한다.</li><li>SIMD(Single Instruction, Multiple Data): 한 번의 명령어로 여러 데이터를 동시에 처리한다. 벡터 프로세서와 GPU가 이에 해당한다.</li><li>MISD(Multiple Instruction, Single Data): 여러 명령어가 하나의 데이터 스트림을 처리한다. 실제로 이 구조를 사용하는 시스템은 드물다.</li><li>MIMD(Multiple Instruction, Multiple Data): 여러 프로세서가 서로 독립적으로 다른 데이터를 처리한다. 현대의 멀티코어 프로세서와 클러스터 시스템이 여기에 해당한다.</li></ol><h4 id=멀티코어-프로세서>멀티코어 프로세서<a hidden class=anchor aria-hidden=true href=#멀티코어-프로세서>#</a></h4><p>하나의 물리적 CPU 칩에 여러 프로세서 코어를 통합한 구조:</p><ol><li><p>대칭형 멀티프로세싱(SMP, Symmetric Multi-Processing)<br>모든 코어가 동일한 메모리와 I/O 버스를 공유하는 구조. 각 코어는 동등한 권한을 가지고 독립적으로 작업을 수행할 수 있다.</p></li><li><p>비대칭형 멀티프로세싱(AMP, Asymmetric Multi-Processing)<br>코어마다 역할과 권한이 다른 구조. 일부 코어는 특수 목적으로 최적화될 수 있다.</p></li></ol><h4 id=분산-컴퓨팅-아키텍처>분산 컴퓨팅 아키텍처<a hidden class=anchor aria-hidden=true href=#분산-컴퓨팅-아키텍처>#</a></h4><p>여러 독립적인 컴퓨터가 네트워크를 통해 연결된 시스템:</p><ol><li><p>클러스터 컴퓨팅<br>물리적으로 근접한 여러 컴퓨터가 하나의 시스템처럼 작동하는 구조. 고성능 컴퓨팅과 고가용성 서비스에 활용된다.</p></li><li><p>그리드 컴퓨팅<br>지리적으로 분산된 컴퓨터 자원을 공유하는 구조. 대규모 과학 계산에 주로 사용된다.</p></li><li><p>클라우드 컴퓨팅<br>인터넷을 통해 컴퓨팅 자원을 서비스로 제공하는 모델이다. IaaS, PaaS, SaaS 등의 형태로 구현된다.</p></li></ol><h3 id=특수-목적-컴퓨터-아키텍처>특수 목적 컴퓨터 아키텍처<a hidden class=anchor aria-hidden=true href=#특수-목적-컴퓨터-아키텍처>#</a></h3><h4 id=gpugraphics-processing-unit-아키텍처>GPU(Graphics Processing Unit) 아키텍처<a hidden class=anchor aria-hidden=true href=#gpugraphics-processing-unit-아키텍처>#</a></h4><p>그래픽 렌더링과 병렬 계산에 최적화된 프로세서:</p><ol><li><p>SIMT(Single Instruction, Multiple Threads) 아키텍처<br>SIMD의 확장 형태로, 여러 스레드가 동일한 명령어를 각자의 데이터에 실행한다.</p></li><li><p>스트리밍 멀티프로세서(SM)<br>수백~수천 개의 간단한 코어를 포함하는 GPU의 기본 연산 유닛.</p></li><li><p>GPGPU(General-Purpose Computing on GPU)<br>그래픽이 아닌 일반적인 계산을 GPU로 처리하는 기술. CUDA, OpenCL과 같은 프레임워크를 통해 구현된다.</p></li></ol><h4 id=dspdigital-signal-processor-아키텍처>DSP(Digital Signal Processor) 아키텍처<a hidden class=anchor aria-hidden=true href=#dspdigital-signal-processor-아키텍처>#</a></h4><p>디지털 신호 처리에 최적화된 프로세서:</p><ol><li><p>하버드 아키텍처(Harvard Architecture)<br>명령어와 데이터를 위한 별도의 메모리 버스를 사용하여 병렬 접근을 가능하게 한다.</p></li><li><p>특수 명령어<br>MAC(Multiply-Accumulate) 연산과 같이 신호 처리에 자주 사용되는 연산을 위한 최적화된 명령어를 제공한다.</p></li><li><p>FPGA(Field-Programmable Gate Array)<br>사용자가 재구성할 수 있는 디지털 회로:</p><ul><li>LUT(Look-Up Table): FPGA의 기본 구성 요소로, 임의의 논리 함수를 구현할 수 있다.</li><li>하드웨어 설명 언어(HDL): VHDL, Verilog와 같은 언어를 사용하여 FPGA의 회로를 프로그래밍한다.</li></ul></li></ol><h3 id=명령어-집합-아키텍처isa>명령어 집합 아키텍처(ISA)<a hidden class=anchor aria-hidden=true href=#명령어-집합-아키텍처isa>#</a></h3><h4 id=isa의-분류>ISA의 분류<a hidden class=anchor aria-hidden=true href=#isa의-분류>#</a></h4><ol><li><p>스택 기반 아키텍처<br>연산자와 피연산자를 스택에 저장하고 관리하는 구조. Java Virtual Machine(JVM)이 대표적인 예.</p></li><li><p>누산기 기반 아키텍처<br>하나의 특별한 레지스터(누산기)에 결과를 저장하는 구조. 초기 컴퓨터에서 주로 사용되었다.</p></li><li><p>레지스터-메모리 아키텍처<br>연산을 수행할 때 레지스터와 메모리를 직접 참조할 수 있는 구조. x86이 대표적.</p></li><li><p>레지스터-레지스터 아키텍처(로드-저장 아키텍처)<br>메모리 접근은 로드와 저장 명령어로만 가능하고, 연산은 레지스터 간에만 수행되는 구조. MIPS, ARM 등이 여기에 해당한다다.</p></li></ol><h4 id=명령어-형식>명령어 형식<a hidden class=anchor aria-hidden=true href=#명령어-형식>#</a></h4><ol><li><p>명령어 길이</p><ul><li><strong>고정 길이 명령어</strong>: 모든 명령어가 동일한 길이(예: 32비트)</li><li><strong>가변 길이 명령어</strong>: 명령어마다 길이가 다를 수 있음(예: x86)</li></ul></li><li><p>명령어 필드<br>명령어는 일반적으로 다음과 같은 필드로 구성된다:</p><ul><li><strong>연산 코드(Opcode)</strong>: 수행할 연산의 종류</li><li><strong>오퍼랜드(Operand)</strong>: 연산에 사용될 데이터나 데이터의 위치</li><li><strong>어드레싱 모드(Addressing Mode)</strong>: 오퍼랜드의 실제 위치를 찾는 방법</li></ul></li></ol><h4 id=어드레싱-모드>어드레싱 모드<a hidden class=anchor aria-hidden=true href=#어드레싱-모드>#</a></h4><p>오퍼랜드의 실제 위치를 결정하는 방식</p><ol><li>즉시 어드레싱(Immediate Addressing): 명령어 자체에 오퍼랜드 값이 포함된다.</li><li>직접 어드레싱(Direct Addressing): 명령어에 오퍼랜드의 메모리 주소가 직접 지정된다.</li><li>간접 어드레싱(Indirect Addressing): 명령어에 지정된 주소에 있는 값이 실제 오퍼랜드의 주소이다.</li><li>레지스터 어드레싱(Register Addressing): 오퍼랜드가 레지스터에 있음을 나타낸다.</li><li>레지스터 간접 어드레싱(Register Indirect Addressing): 레지스터에 저장된 값이 오퍼랜드의 메모리 주소이다.</li></ol><h3 id=현대-컴퓨터-아키텍처의-주요-이슈>현대 컴퓨터 아키텍처의 주요 이슈<a hidden class=anchor aria-hidden=true href=#현대-컴퓨터-아키텍처의-주요-이슈>#</a></h3><h4 id=성능과-효율성>성능과 효율성<a hidden class=anchor aria-hidden=true href=#성능과-효율성>#</a></h4><ol><li><p>아론달의 법칙(Amdahl&rsquo;s Law)<br>병렬화를 통한 성능 향상의 한계를 설명하는 법칙. 프로그램의 순차적 부분이 전체 성능 향상을 제한한다.</p></li><li><p>전력 소비와 발열<br>현대 프로세서 설계에서 전력 효율성은 핵심적인 고려 사항.<br>이는 성능뿐만 아니라 배터리 수명, 냉각 요구 사항 등과도 관련된다.</p></li><li><p>메모리 벽(Memory Wall)<br>프로세서 속도와 메모리 속도 간의 격차로 인한 성능 제한을 의미한다. 이를 완화하기 위해 캐시 계층 구조와 메모리 기술이 발전해왔다.</p></li></ol><h4 id=보안-아키텍처>보안 아키텍처<a hidden class=anchor aria-hidden=true href=#보안-아키텍처>#</a></h4><ol><li><p>하드웨어 보안 기능</p><ul><li><strong>신뢰 실행 환경(TEE, Trusted Execution Environment)</strong>: 보안이 강화된 별도의 실행 환경</li><li><strong>보안 부팅(Secure Boot)</strong>: 시스템 부팅 시 모든 소프트웨어의 무결성 검증</li><li><strong>하드웨어 암호화 가속기</strong>: 암호화 및 복호화 작업을 하드웨어로 가속화</li></ul></li><li><p>사이드 채널 공격 대응<br>캐시 타이밍, 전력 분석, 전자기 방출 등을 이용한 공격에 대응하기 위한 아키텍처 설계 방안.</p></li><li><p>Meltdown과 Spectre 취약점<br>투기적 실행과 같은 성능 최적화 기술로 인해 발생하는 보안 취약점. 이는 아키텍처 수준의 재설계를 필요로 한다.</p></li></ol><h4 id=특수화와-가속화>특수화와 가속화<a hidden class=anchor aria-hidden=true href=#특수화와-가속화>#</a></h4><ol><li><p>도메인 특화 아키텍처(Domain-Specific Architecture)<br>특정 응용 분야에 최적화된 아키텍처. AI 가속기, 비디오 인코더/디코더 등이 여기에 해당한다.</p></li><li><p>이기종 컴퓨팅(Heterogeneous Computing)<br>CPU, GPU, NPU, FPGA 등 다양한 프로세서를 함께 사용하여 특정 작업의 성능을 최적화하는 접근 방식.</p></li><li><p>시스템 온 칩(SoC, System on Chip)<br>하나의 집적 회로에 프로세서, 메모리, I/O 등 컴퓨팅 시스템의 모든 구성 요소를 통합한 설계. 모바일 기기에서 널리 사용된다.</p></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CPU</h2></header><div class=entry-content><p>CPU CPU(중앙처리장치)는 컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.
CPU의 주요 구성요소 CPU는 크게 세 가지 주요 구성요소로 이루어져 있다
제어장치 (Control Unit, CU) 산술논리장치 (Arithmetic Logic Unit, ALU) 레지스터 (Registers) 제어장치 (Control Unit) 제어장치는 CPU의 ‘교통 경찰’ 역할을 한다.
주요 기능:
명령어를 순서대로 실행할 수 있도록 제어 주기억장치로부터 프로그램 명령을 순차적으로 가져와 해독 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치 등으로 전송 산술논리장치 (ALU) ALU는 CPU 내에서 실제 연산을 수행하는 부분
...</p></div><footer class=entry-footer><span title='2024-09-29 16:44:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CPU" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/cpu/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memory Architecture</h2></header><div class=entry-content><p>Memory Architecture 컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다.
컴퓨터에서는 빠른 속도와 큰 용량을 동시에 얻기가 어렵다. 빠른 메모리는 비용이 매우 높고, 큰 용량의 메모리는 상대적으로 느리다. 이러한 기술적, 경제적 제약을 해결하기 위해 여러 층의 메모리를 계층적으로 구성하게 되었다.
메모리 계층 구조 메모리 계층 구조는 접근 속도와 용량에 따라 여러 단계로 구성된다:
레지스터:
CPU 내부에 위치한 소용량의 초고속 메모리로, 현재 실행 중인 명령어와 관련된 데이터를 저장한다. 일반적으로 몇 비트에서 수십 비트 정도의 용량을 가지며, 접근 속도는 한 사이클 이내로 가장 빠르다. 캐시 메모리:
주기억장치와 CPU 레지스터 사이에 위치하여, 자주 사용되는 데이터를 일시적으로 저장함으로써 CPU의 처리 속도를 향상시킨다. 일반적으로 L1, L2, L3 등의 여러 레벨로 구성되며, 레벨이 높아질수록 용량은 증가하지만 접근 속도는 감소한다. 주 메모리 (RAM):
프로그램과 데이터를 일시적으로 저장하는 휘발성 메모리로, 시스템의 작업 공간 역할을 한다. 용량은 수 기가바이트에서 수십 기가바이트에 이르며, 캐시 메모리보다 접근 속도는 느리지만 더 많은 데이터를 저장할 수 있다. 보조 기억 장치:
하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD)와 같은 비휘발성 저장 장치로, 대용량의 데이터를 영구적으로 저장한다. 주기억장치보다 접근 속도는 느리지만, 데이터의 영구 저장이 가능하다. 이러한 계층 구조는 데이터 접근 시간을 최소화하고 전체 시스템의 성능을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-09-30 15:55:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memory Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Computer Architecture</h2></header><div class=entry-content><p>Von Neumann Architecture vs. Harvard Architecture 하버드 아키텍처(Harvard Architecture)와 폰 노이만 아키텍처(von Neumann Architecture)는 컴퓨터 시스템의 메모리 구조를 정의하는 두 가지 대표적인 설계 방식이다.
각 아키텍처는 메모리와 버스 구조에 대한 접근 방식에서 차이를 보이며, 이에 따라 성능, 설계 복잡성, 활용 분야 등에서 차별화된다.
특성 하버드 아키텍처 폰 노이만 아키텍처 메모리 구조 명령어와 데이터를 위한 별도의 메모리 명령어와 데이터가 동일한 메모리에 저장 버스 구조 명령어 버스와 데이터 버스가 분리 하나의 공유 버스 사용 병렬 처리 명령어 fetch와 데이터 접근을 동시에 수행 가능 명령어 fetch와 데이터 접근을 순차적으로 수행 성능 일반적으로 더 빠른 실행 속도 메모리 병목 현상으로 인해 상대적으로 느림 복잡성 하드웨어 구조가 더 복잡 상대적으로 단순한 구조 비용 일반적으로 더 높은 구현 비용 상대적으로 낮은 구현 비용 유연성 메모리 사용의 유연성이 낮음 메모리 사용의 유연성이 높음 보안성 프로그램과 데이터 분리로 인한 높은 보안성 상대적으로 낮은 보안성 주요 응용 분야 임베디드 시스템, DSP, 마이크로컨트롤러 범용 컴퓨터, 개인용 컴퓨터 메모리 접근 동시에 명령어와 데이터 접근 가능 순차적 메모리 접근 명령어 실행 1 사이클에 1 명령어 실행 가능 여러 사이클에 걸쳐 명령어 실행 메모리 확장 명령어와 데이터 메모리 독립적 확장 가능 단일 메모리 확장 전력 효율성 일반적으로 더 높은 전력 효율성 상대적으로 낮은 전력 효율성 캐시 구조 명령어 캐시와 데이터 캐시 분리 통합 캐시 또는 분리된 캐시 사용 가능 이 두 아키텍처는 각각의 장단점을 가지고 있으며, 현대의 많은 프로세서들은 두 아키텍처의 장점을 결합한 하이브리드 구조를 채택하고 있다. 예를 들어, 내부적으로는 하버드 구조를 사용하여 성능을 향상시키고, 외부적으로는 폰 노이만 구조를 유지하여 유연성을 확보하는 방식을 사용한다.
...</p></div><footer class=entry-footer><span title='2024-09-29 05:34:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Computer Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Instruction Set Architecture</h2></header><div class=entry-content><p>Instruction Set Architecture 명령어 집합 구조(Instruction Set Architecture, ISA)는 프로세서 아키텍처의 핵심 요소로, 하드웨어와 소프트웨어 간의 인터페이스 역할을 한다.
ISA는 프로세서가 실행할 수 있는 명령어들의 집합을 정의하며, 프로그래머와 컴파일러 작성자에게 중요한 추상화 계층을 제공한다.
Source: https://www.geeksforgeeks.org/microarchitecture-and-instruction-set-architecture/
ISA의 주요 구성 요소 명령어 세트
연산 유형: 산술 연산, 논리 연산, 데이터 이동, 제어 흐름 등 명령어 형식: 각 명령어의 비트 구조와 인코딩 방식 주소 지정 모드: 직접 주소 지정, 간접 주소 지정, 즉시 주소 지정 등 레지스터
...</p></div><footer class=entry-footer><span title='2024-09-29 02:18:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Instruction Set Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/processor-architecture/instruction-set-architecture/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>