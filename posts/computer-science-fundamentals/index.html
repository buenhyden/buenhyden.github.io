<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Science Fundamentals | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals"><meta name=description content="Computer Science Fundamentals - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Science Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Science Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Computer Science Fundamentals</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>복잡도 클래스(Complexity Classes)</h2></header><div class=entry-content><p>복잡도 클래스(Complexity Classes) 복잡도 클래스(Complexity Classes)는 계산 이론의 핵심 개념으로, 문제 해결에 필요한 계산 자원(시간, 공간 등)의 양에 따라 문제들을 분류하는 체계이다.
복잡도 클래스는 계산 복잡도 이론의 핵심 개념으로, 알고리즘과 문제의 복잡성을 분류하고 이해하는 데 중요한 역할을 한다. 이 분야는 컴퓨터 과학에서 “무엇이 효율적으로 계산 가능한가?“라는 근본적인 질문을 다룬다.
알고리즘의 효율성 분석과 문제 간의 관계 이해에 기여하며, 특히 P vs NP 문제와 같은 근본적인 질문을 탐구하는 기반이 된다. P vs NP 문제를 비롯한 미해결 과제들은 인공지능, 암호학, 최적화 분야에 직간접적 영향을 미친다.
...</p></div><footer class=entry-footer><span title='2024-10-13 09:54:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 복잡도 클래스(Complexity Classes)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/complexity-classes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p-vs-np-problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데커 알고리즘 (Dekker's Algorithm)</h2></header><div class=entry-content><p>데커 알고리즘 (Dekker’s Algorithm) 데커 알고리즘(Dekker’s Algorithm)은 두 프로세스 간 **상호 배제(Mutual Exclusion)**를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.
이 알고리즘은 두 개의 프로세스가 공유 자원에 동시에 접근하는 것을 방지하여 경쟁 상태(race condition)를 해결하는 방법을 제시한다.
공유 자원에 대한 안전한 접근을 위해 **플래그(flag)**와 턴(turn) 변수를 활용하며, 하드웨어적 명령어 없이 소프트웨어만으로 구현 가능하다.
데커 알고리즘은 상호 배제 문제 해결의 역사적 중요성을 가지지만, 현대 시스템에서는 **세마포어(Semaphore)**나 **뮤텍스(Mutex)**와 같은 더 효율적인 동기화 기법이 주로 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데커 알고리즘 (Dekker's Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/dekkers-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)</h2></header><div class=entry-content><p>램포트의 빵집 알고리즘 (Lamport’s Bakery Algorithm) 램포트의 빵집 알고리즘(Lamport’s Bakery Algorithm)은 N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.
램포트의 빵집 알고리즘은 병행 프로그래밍의 이론적 토대를 제공했지만, 현대 시스템에서는 주로 하드웨어 지원 동기화 기법이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.
핵심 원리 번호표 시스템 각 프로세스는 임계 영역 진입 전 고유한 번호표를 받는다. 번호표는 단조 증가(monotonically increasing) 방식으로 발급되며, 동시 접근 시 프로세스 ID로 우선순위 결정한다. 단조 증가(monotonically increasing)란 함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질을 의미한다. 즉, 감소하는 구간 없이 유지되거나 증가하는 경우를 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/lamports-bakery-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>피터슨 알고리즘 (Peterson's Algorithm)</h2></header><div class=entry-content><p>피터슨 알고리즘 (Peterson’s Algorithm) 피터슨 알고리즘(Peterson’s Algorithm)은 두 프로세스의 **상호 배제(Mutual Exclusion)**를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.
1981년 개리 피터슨(Gary L. Peterson)이 제안한 이 알고리즘은 간결성과 이론적 엄밀성으로 운영체제 및 병행 프로그래밍 분야에서 널리 연구된다.
피터슨 알고리즘은 이론적 완결성을 인정받지만, 현대 시스템에서는 주로 하드웨어 기반 동기화 기법(예: TAS, CAS)이 사용됩니다. 그러나 병행 프로그래밍의 근본 원리를 이해하는 데 여전히 핵심적인 역할을 한다.
핵심 구성 요소 플래그 배열(flag) 각 프로세스의 임계 영역 진입 의사 표시 (flag, flag 초기값 False) 턴 변수(turn) 임계 영역 진입 순서 결정 (0 또는 1 값을 가짐) 동작 원리 진입 의사 표시:
프로세스 i가 임계 영역 진입 전 flag[i] = True 설정.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 피터슨 알고리즘 (Peterson's Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/classical-problems/mutual-exclusion-algorithms/petersons-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Computer Architecture</h2></header><div class=entry-content><p>Computer Architecture 컴퓨터 아키텍처 (Computer Architecture) 는 컴퓨터 시스템의 구조, 기능, 설계 및 구현에 관한 학문 분야이다.
이는 하드웨어와 소프트웨어의 상호작용을 포함하며, 컴퓨터 시스템이 어떻게 구성되고 작동하는지를 연구한다.
컴퓨터 아키텍처는 현대 정보 기술의 근간으로, 그 이해는 컴퓨터 과학 및 엔지니어링 분야에서 필수적이다.
컴퓨터 아키텍처의 기본 개념 컴퓨터 아키텍처는 크게 세 가지 측면에서 정의할 수 있다:
명령어 집합 아키텍처 (ISA, Instruction Set Architecture): 컴퓨터가 이해하고 실행할 수 있는 명령어의 집합이다. 이는 프로그래머가 볼 수 있는 하드웨어의 추상화 층으로, 레지스터, 메모리 접근 방식, 입출력 모델 등을 정의한다.
...</p></div><footer class=entry-footer><span title='2024-09-29 21:24:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Computer Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Computer Science Fundamentals Overview</h2></header><div class=entry-content><p>Computer Science Fundamentals Computer Science Fundamentals 는 현대 컴퓨팅의 토대가 되는 핵심 원리들을 다루는 종합적인 학문 분야이다. 이론적 기초인 알고리즘과 데이터 구조부터 실용적 구현인 시스템 아키텍처, 운영체제, 데이터베이스 관리까지 포괄한다. 컴퓨터 과학 이론과 소프트웨어 공학 실무를 결합하여 확장 가능하고 효율적인 컴퓨팅 솔루션을 설계하는 능력을 기르며, 현대 기술 발전의 핵심 역량을 제공한다.
핵심 개념 분류 핵심 개념 주요 내용 요약 1. 계산 사고 (Computational Thinking) - 문제 분해, 패턴 인식, 추상화, 알고리즘적 사고 문제 해결 능력의 기반 사고 체계 2. 자료구조 (Data Structures) - 선형 구조: 배열, 연결 리스트, 스택, 큐
- 비선형 구조: 트리, 그래프, 해시 테이블
- 추상 자료형 (ADT), 메모리 효율 데이터의 효율적 저장과 접근 3. 알고리즘 (Algorithms) - 탐색/정렬/최적화/분할정복/동적계획법/그리디
- 시간·공간 복잡도 분석, Big-O 표기법 성능 중심의 문제 해결 전략 4. 프로그래밍 기초 및 언어 (Programming Fundamentals & Languages) - 조건문, 반복문, 함수, 재귀, 스코프, 메모리 모델
- 프로그래밍 언어: Python, Java, C++, JavaScript 등 알고리즘 구현을 위한 실용 문법 5. 컴퓨터 아키텍처 (Computer Architecture) - CPU, ALU, 레지스터, 명령어 세트 (ISA)
- 메모리 계층 (캐시, RAM), 파이프라이닝, 병렬처리 하드웨어 수준의 시스템 이해 6. 운영체제 (Operating Systems) - 프로세스/스레드 관리, 스케줄링, 동기화
- 가상 메모리, 파일 시스템, 입출력 시스템 컴퓨터 자원의 효율적 관리 원리 7. 네트워크 (Computer Networks) - OSI 7 계층, TCP/IP, 라우팅, DNS, HTTP/HTTPS
- 패킷 스위칭, 포트, 방화벽, NAT 데이터 통신과 연결 구조 8. 데이터베이스 (Databases) - 관계형 DB, SQL, 트랜잭션 (ACID), 정규화
- 인덱싱, 동시성 제어, 분산 DB 시스템 대규모 데이터의 일관된 저장/조회 9. 컴파일러 및 언어 처리기 (Compilers & Language Processors) - 렉서 (lexer), 파서 (parser), AST, IR
- 최적화, 기계어 코드 생성 코드 → 실행의 전환 과정 이해 10. 이론 컴퓨터 과학 (Theoretical Computer Science) - 튜링 머신, 유한 상태 머신 (FSM)
- 결정 가능성, 계산 복잡도 (P vs NP 등) 계산 가능한 문제의 이론적 경계 11. 소프트웨어 공학 (Software Engineering) - SDLC, 테스트 기법, 빌드/배포 자동화
- 버전관리 (Git), 요구사항 분석, 디버깅 전략 체계적인 소프트웨어 개발 및 유지관리 방법론 배경 컴퓨터 과학 기초 (CS Fundamentals) 는 계산 이론, 문제 해결 패턴, 데이터 표현, 시스템 구조에 대한 근본적인 이해를 다루는 분야이다.
컴퓨터 과학은 1936 년 앨런 튜링 (Alan Turing) 의 튜링 머신 이론으로 계산 가능성 (Computability) 을 정의하며 형성되었고, 20 세기 중후반에는 자료구조, 알고리즘, 운영체제, 컴파일러, 네트워크 등 세부 영역이 체계화되었다.
현재는 소프트웨어 엔지니어링, AI, 시스템 설계, DevOps 등 모든 기술 기반의 바탕이 되는 학문이자 실무 역량이다.
...</p></div><footer class=entry-footer><span title='2024-09-19 01:29:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Computer Science Fundamentals Overview" href=https://buenhyden.github.io/posts/computer-science-fundamentals/overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Operating System</h2></header><div class=entry-content><p>Operating System 컴퓨터 하드웨어와 소프트웨어 자원을 관리하고 다양한 서비스를 제공하는 소프트웨어.
Source: https://www.tutorialspoint.com/operating_system/os_overview.htm
특성 동시성: 여러 작업을 동시에 처리할 수 있음 하드웨어 추상화: 하드웨어 세부사항을 숨기고 일관된 인터페이스 제공 자원 할당: 시스템 자원을 효율적으로 관리하고 할당 가상화: 가상 메모리와 가상 CPU 생성 보안: 무단 접근 방지 및 데이터 보호 결함 허용: 하드웨어 및 소프트웨어 오류 처리 주요 기능 프로세스 관리: 프로세스 생성, 실행, 종료 관리하며 프로세스 간 통신을 지원 메모리 관리: 메모리 할당 및 해제를 관리하고 가상 메모리를 구현 파일 시스템 관리: 파일 저장, 검색, 조직화 장치 관리: 입출력 장치 제어 및 드라이버 관리 사용자 인터페이스 제공: GUI 또는 CLI 제공 보안 및 보호: 데이터 및 시스템 보호 네트워킹: 네트워크 통신 지원 운영체제의 목적 운영체제는 다음과 같은 주요 목적을 가지고 있다:
...</p></div><footer class=entry-footer><span title='2024-10-01 17:13:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Operating System" href=https://buenhyden.github.io/posts/computer-science-fundamentals/system-software/operating-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Basic Concepts</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-09-27 07:22:00 +0000 UTC'>September 27, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Basic Concepts" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock</h2></header><div class=entry-content><p>Lock Lock 은 동시성 환경에서 공유 자원의 일관성과 무결성을 보장하기 위한 상호 배제 (Mutual Exclusion) 동기화 기법이다.
하드웨어의 원자적 명령 (CAS, TAS) 기반에서 소프트웨어 추상화 수준 (Mutex, ReentrantLock 등) 까지 다양한 구현이 존재한다. Mutex, Spinlock, Reader-Writer Lock 외에도 Ticket Lock, MCS Lock, Backoff 기반 알고리즘이 활용되며, 운영체제, 데이터베이스, 분산 시스템 등에서 핵심 동기화 수단으로 사용된다. 적절한 적용은 성능 최적화와 안정성을 보장하지만, 데드락, 라이블락, Starvation 등의 문제를 유발할 수 있다.
등장 배경 및 발전 과정 락 (Lock) 은 멀티태스킹 환경에서 공유 자원에 대한 동시 접근으로 인한 충돌을 방지하기 위해 도입된 핵심 동기화 기법이다.
초기에는 단일 프로세서 시스템에서 인터럽트를 비활성화하여 원자성을 보장했지만, 멀티프로세서 환경에서는 하드웨어 수준의 원자 명령어 (Test-and-Set, Compare-and-Swap 등) 를 활용한 락이 필요해졌다.
...</p></div><footer class=entry-footer><span title='2025-08-04 03:54:00 +0000 UTC'>August 4, 2025</span>&nbsp;·&nbsp;45 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/lock/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>