<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>비꼬리 재귀(Non-tail Recursion) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Recursion,Types,Non-tail-Recursion"><meta name=description content="Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="비꼬리 재귀(Non-tail Recursion)"><meta property="og:description" content="Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-09T09:36:00+00:00"><meta property="article:modified_time" content="2024-12-09T09:36:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Recursion"><meta property="article:tag" content="Types"><meta property="article:tag" content="Non-Tail-Recursion"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="비꼬리 재귀(Non-tail Recursion)"><meta name=twitter:description content="Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":4,"name":"Fundamentals of Data Structures and Algorithms","item":""},{"@type":"ListItem","position":6,"name":"Recursion","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/"},{"@type":"ListItem","position":7,"name":"Types of Recursion","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/"},{"@type":"ListItem","position":8,"name":"비꼬리 재귀(Non-tail Recursion)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"비꼬리 재귀(Non-tail Recursion)","name":"비꼬리 재귀(Non-tail Recursion)","description":"Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Recursion","Types","Non-tail-Recursion"],"articleBody":"비꼬리 재귀(Non-tail Recursion) 비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.\n이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.\n비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.\n이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.\n그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.\n재귀적 알고리즘을 설계할 때는 문제의 특성과 제약 조건을 고려하여 비꼬리 재귀와 꼬리 재귀 중 적절한 방식을 선택하는 것이 중요하다.\n비꼬리 재귀의 정의 비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수를 말한다. 즉, 함수 내에서 자기 자신을 호출한 후 그 결과에 대해 추가적인 처리가 필요한 경우를 의미한다.\n예를 들어, 다음과 같은 팩토리얼 함수는 비꼬리 재귀의 전형적인 예:\n1 2 3 4 5 6 def factorial(n): if n \u003c= 1: return 1 else: # 재귀 호출 이후 곱셈 연산이 추가로 필요함 return n * factorial(n-1) # Non-tail recursion 위 함수에서 factorial(n-1)을 호출한 후에 그 결과에 n을 곱하는 추가 연산이 필요하므로 비꼬리 재귀이다.\n비꼬리 재귀의 특징 추가 연산 필요: 재귀 호출 이후에 추가적인 연산(곱셈, 덧셈, 함수 호출 등)이 필요하다. 콜 스택 보존: 재귀 호출이 완료된 후에도 현재 함수의 스택 프레임이 유지되어야 한다. 최적화 제한: 꼬리 재귀 최적화(Tail Recursion Optimization)를 적용할 수 없다. 메모리 사용: 재귀 깊이에 비례하여 메모리 사용량이 증가한다. 비꼬리 재귀의 예제 피보나치 수열 (비꼬리 재귀)\n1 2 3 4 5 6 def fibonacci(n): if n \u003c= 1: return n else: # 두 개의 재귀 호출 결과를 더하는 추가 연산이 필요 return fibonacci(n-1) + fibonacci(n-2) # Non-tail recursion 이 함수는 fibonacci(n-1)과 fibonacci(n-2)의 두 재귀 호출 결과를 더하는 추가 연산이 필요하므로 비꼬리 재귀.\n이진 트리 순회 (비꼬리 재귀)\n1 2 3 4 5 6 def inorder_traversal(root): if root is None: return [] # 재귀 호출 결과를 결합하는 추가 연산이 필요 return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) # Non-tail recursion 이 함수는 왼쪽 하위 트리 순회 결과, 루트 값, 오른쪽 하위 트리 순회 결과를 결합하는 추가 연산이 필요하므로 비꼬리 재귀.\n하노이 탑 (비꼬리 재귀)\n1 2 3 4 5 6 7 8 9 10 11 12 def hanoi_tower(n, source, auxiliary, target): if n == 1: print(f\"원판 1을 {source}에서 {target}으로 이동\") return # 첫 번째 재귀 호출 hanoi_tower(n-1, source, target, auxiliary) print(f\"원판 {n}을 {source}에서 {target}으로 이동\") # 두 번째 재귀 호출 hanoi_tower(n-1, auxiliary, source, target) # Non-tail recursion 이 함수는 첫 번째 재귀 호출 이후에 출력 연산과 두 번째 재귀 호출이 있으므로 비꼬리 재귀.\n비꼬리 재귀를 꼬리 재귀로 변환 많은 비꼬리 재귀 함수는 누적 매개변수(accumulator)를 도입하여 꼬리 재귀로 변환할 수 있다.\n이렇게 하면 컴파일러가 최적화할 수 있고 스택 오버플로우 위험이 줄어든다.\n팩토리얼 예제 1 2 3 4 5 6 7 8 9 10 11 # 비꼬리 재귀 버전 def factorial_non_tail(n): if n \u003c= 1: return 1 return n * factorial_non_tail(n-1) # Non-tail recursion # 꼬리 재귀 버전 def factorial_tail(n, accumulator=1): if n \u003c= 1: return accumulator return factorial_tail(n-1, n * accumulator) # Tail recursion 피보나치 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 # 비꼬리 재귀 버전 def fibonacci_non_tail(n): if n \u003c= 1: return n return fibonacci_non_tail(n-1) + fibonacci_non_tail(n-2) # Non-tail recursion # 꼬리 재귀 버전 def fibonacci_tail(n, a=0, b=1): if n == 0: return a if n == 1: return b return fibonacci_tail(n-1, b, a+b) # Tail recursion 비꼬리 재귀의 성능 고려사항 스택 공간 복잡도\n비꼬리 재귀는 재귀 깊이에 비례하여 스택 공간을 사용한다. 입력 크기가 크면 스택 오버플로우가 발생할 수 있다.\n예를 들어, 팩토리얼 함수에서:\nfactorial(5)는 5개의 스택 프레임을 사용한다. factorial(1000)은 1000개의 스택 프레임을 사용하려고 시도하므로 대부분의 언어에서 스택 오버플로우가 발생한다. 중복 계산 문제\n비꼬리 재귀는 종종 동일한 하위 문제를 여러 번 계산하게 된다.\n이는 특히 피보나치 수열과 같은 문제에서 두드러진다.\n예를 들어, fibonacci(5)를 계산할 때:\nfibonacci(3)은 두 번 계산된다. fibonacci(2)는 세 번 계산된다. fibonacci(1)은 다섯 번 계산된다.\n이러한 중복 계산은 메모이제이션(memoization)을 통해 해결할 수 있다: 1 2 3 4 5 6 7 def fibonacci_memo(n, memo={}): if n in memo: return memo[n] if n \u003c= 1: return n memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo) return memo[n] 비꼬리 재귀가 유용한 상황 비꼬리 재귀가 특히 유용한 상황은 다음과 같다:\n자연스러운 문제 해결: 일부 문제는 비꼬리 재귀로 표현하는 것이 더 자연스럽고 직관적. 트리와 그래프 처리: 트리 순회나 그래프 탐색과 같은 작업은 비꼬리 재귀로 표현하는 것이 자연스럽다. 분할 정복 알고리즘: 퀵 정렬, 병합 정렬과 같은 알고리즘은 비꼬리 재귀를 사용. 표현식 평가: 수학 표현식이나 프로그래밍 언어 파서는 종종 비꼬리 재귀를 사용. 비꼬리 재귀의 또 다른 예제: 퀵 정렬 퀵 정렬은 비꼬리 재귀의 또 다른 좋은 예:\n1 2 3 4 5 6 7 8 9 10 11 def quicksort(arr): if len(arr) \u003c= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x \u003c pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x \u003e pivot] # 재귀 호출 결과를 결합하는 추가 연산이 필요 return quicksort(left) + middle + quicksort(right) # Non-tail recursion 이 퀵 정렬 구현은 두 개의 재귀 호출 결과와 중간 배열을 결합하는 추가 연산이 필요하므로 비꼬리 재귀.\n비꼬리 재귀의 시각적 표현: 호출 트리 비꼬리 재귀의 호출 구조를 시각적으로 이해하기 위해 간단한 예제의 호출 트리.\n예를 들어, factorial(4)의 호출 트리는 다음과 같다:\n1 2 3 4 5 6 7 8 factorial(4) ├── 재귀 호출: factorial(3) │ ├── 재귀 호출: factorial(2) │ │ ├── 재귀 호출: factorial(1) │ │ │ └── 반환: 1 │ │ └── 반환: 2 * 1 = 2 │ └── 반환: 3 * 2 = 6 └── 반환: 4 * 6 = 24 이 호출 트리에서 볼 수 있듯이, 각 재귀 호출이 완료된 후 해당 결과에 추가 연산(곱셈)이 적용된다.\n이것이 비꼬리 재귀의 특징이다.\n비꼬리 재귀가 가진 실용적인 문제점 비꼬리 재귀는 몇 가지 실용적인 문제점을 가지고 있다:\n스택 오버플로우: 큰 입력에 대해 많은 스택 프레임이 생성되어 스택 오버플로우가 발생할 수 있다. 성능 저하: 중복 계산, 스택 프레임 생성 및 해제 비용으로 인해 성능이 저하될 수 있다. 최적화 어려움: 컴파일러가 꼬리 재귀 최적화를 적용할 수 없어 최적화가 제한된다. 참고 및 출처 ","wordCount":"991","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-09T09:36:00Z","dateModified":"2024-12-09T09:36:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href>Fundamentals of Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/>Recursion</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/>Types of Recursion</a></div><h1 class="post-title entry-hint-parent">비꼬리 재귀(Non-tail Recursion)</h1><div class=post-description>Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다</div><div class=post-meta><span title='2024-12-09 09:36:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Data%20Structures%20and%20Algorithms/Fundamentals/Basic%20Concepts/Recursion/Types/non-tail-recursion.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#비꼬리-재귀non-tail-recursion>비꼬리 재귀(Non-tail Recursion)</a><ul><li><a href=#비꼬리-재귀의-정의>비꼬리 재귀의 정의</a></li><li><a href=#비꼬리-재귀의-특징>비꼬리 재귀의 특징</a></li><li><a href=#비꼬리-재귀의-예제>비꼬리 재귀의 예제</a></li><li><a href=#비꼬리-재귀를-꼬리-재귀로-변환>비꼬리 재귀를 꼬리 재귀로 변환</a></li><li><a href=#비꼬리-재귀의-성능-고려사항>비꼬리 재귀의 성능 고려사항</a></li><li><a href=#비꼬리-재귀가-유용한-상황>비꼬리 재귀가 유용한 상황</a></li><li><a href=#비꼬리-재귀의-또-다른-예제-퀵-정렬>비꼬리 재귀의 또 다른 예제: 퀵 정렬</a></li><li><a href=#비꼬리-재귀의-시각적-표현-호출-트리>비꼬리 재귀의 시각적 표현: 호출 트리</a></li><li><a href=#비꼬리-재귀가-가진-실용적인-문제점>비꼬리 재귀가 가진 실용적인 문제점</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=비꼬리-재귀non-tail-recursion>비꼬리 재귀(Non-tail Recursion)<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀non-tail-recursion>#</a></h2><p>비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.<br>이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.</p><p>비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.<br>이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.</p><p>그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.</p><p>재귀적 알고리즘을 설계할 때는 문제의 특성과 제약 조건을 고려하여 비꼬리 재귀와 꼬리 재귀 중 적절한 방식을 선택하는 것이 중요하다.</p><h3 id=비꼬리-재귀의-정의>비꼬리 재귀의 정의<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀의-정의>#</a></h3><p>비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수를 말한다. 즉, 함수 내에서 자기 자신을 호출한 후 그 결과에 대해 추가적인 처리가 필요한 경우를 의미한다.</p><p>예를 들어, 다음과 같은 팩토리얼 함수는 비꼬리 재귀의 전형적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 재귀 호출 이후 곱셈 연산이 추가로 필요함</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><p>위 함수에서 <code>factorial(n-1)</code>을 호출한 후에 그 결과에 <code>n</code>을 곱하는 추가 연산이 필요하므로 비꼬리 재귀이다.</p><h3 id=비꼬리-재귀의-특징>비꼬리 재귀의 특징<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀의-특징>#</a></h3><ol><li><strong>추가 연산 필요</strong>: 재귀 호출 이후에 추가적인 연산(곱셈, 덧셈, 함수 호출 등)이 필요하다.</li><li><strong>콜 스택 보존</strong>: 재귀 호출이 완료된 후에도 현재 함수의 스택 프레임이 유지되어야 한다.</li><li><strong>최적화 제한</strong>: 꼬리 재귀 최적화(Tail Recursion Optimization)를 적용할 수 없다.</li><li><strong>메모리 사용</strong>: 재귀 깊이에 비례하여 메모리 사용량이 증가한다.</li></ol><h3 id=비꼬리-재귀의-예제>비꼬리 재귀의 예제<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀의-예제>#</a></h3><ol><li><p>피보나치 수열 (비꼬리 재귀)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 두 개의 재귀 호출 결과를 더하는 추가 연산이 필요</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><p>이 함수는 <code>fibonacci(n-1)</code>과 <code>fibonacci(n-2)</code>의 두 재귀 호출 결과를 더하는 추가 연산이 필요하므로 비꼬리 재귀.</p></li><li><p>이진 트리 순회 (비꼬리 재귀)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 재귀 호출 결과를 결합하는 추가 연산이 필요</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=p>[</span><span class=n>root</span><span class=o>.</span><span class=n>value</span><span class=p>]</span> <span class=o>+</span> <span class=n>inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><p>이 함수는 왼쪽 하위 트리 순회 결과, 루트 값, 오른쪽 하위 트리 순회 결과를 결합하는 추가 연산이 필요하므로 비꼬리 재귀.</p></li><li><p>하노이 탑 (비꼬리 재귀)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>hanoi_tower</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>source</span><span class=p>,</span> <span class=n>auxiliary</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;원판 1을 </span><span class=si>{</span><span class=n>source</span><span class=si>}</span><span class=s2>에서 </span><span class=si>{</span><span class=n>target</span><span class=si>}</span><span class=s2>으로 이동&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 재귀 호출</span>
</span></span><span class=line><span class=cl>    <span class=n>hanoi_tower</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>auxiliary</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;원판 </span><span class=si>{</span><span class=n>n</span><span class=si>}</span><span class=s2>을 </span><span class=si>{</span><span class=n>source</span><span class=si>}</span><span class=s2>에서 </span><span class=si>{</span><span class=n>target</span><span class=si>}</span><span class=s2>으로 이동&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 두 번째 재귀 호출</span>
</span></span><span class=line><span class=cl>    <span class=n>hanoi_tower</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>auxiliary</span><span class=p>,</span> <span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><p>이 함수는 첫 번째 재귀 호출 이후에 출력 연산과 두 번째 재귀 호출이 있으므로 비꼬리 재귀.</p></li></ol><h3 id=비꼬리-재귀를-꼬리-재귀로-변환>비꼬리 재귀를 꼬리 재귀로 변환<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀를-꼬리-재귀로-변환>#</a></h3><p>많은 비꼬리 재귀 함수는 누적 매개변수(accumulator)를 도입하여 꼬리 재귀로 변환할 수 있다.<br>이렇게 하면 컴파일러가 최적화할 수 있고 스택 오버플로우 위험이 줄어든다.</p><h4 id=팩토리얼-예제>팩토리얼 예제<a hidden class=anchor aria-hidden=true href=#팩토리얼-예제>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 비꼬리 재귀 버전</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial_non_tail</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>factorial_non_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 꼬리 재귀 버전</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial_tail</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>accumulator</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>accumulator</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>factorial_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>*</span> <span class=n>accumulator</span><span class=p>)</span>  <span class=c1># Tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=피보나치-예제>피보나치 예제<a hidden class=anchor aria-hidden=true href=#피보나치-예제>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 비꼬리 재귀 버전</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_non_tail</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci_non_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_non_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 꼬리 재귀 버전</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_tail</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>a</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>b</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci_tail</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span><span class=o>+</span><span class=n>b</span><span class=p>)</span>  <span class=c1># Tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=비꼬리-재귀의-성능-고려사항>비꼬리 재귀의 성능 고려사항<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀의-성능-고려사항>#</a></h3><ol><li><p>스택 공간 복잡도<br>비꼬리 재귀는 재귀 깊이에 비례하여 스택 공간을 사용한다. 입력 크기가 크면 스택 오버플로우가 발생할 수 있다.<br>예를 들어, 팩토리얼 함수에서:</p><ul><li><code>factorial(5)</code>는 5개의 스택 프레임을 사용한다.</li><li><code>factorial(1000)</code>은 1000개의 스택 프레임을 사용하려고 시도하므로 대부분의 언어에서 스택 오버플로우가 발생한다.</li></ul></li><li><p>중복 계산 문제<br>비꼬리 재귀는 종종 동일한 하위 문제를 여러 번 계산하게 된다.<br>이는 특히 피보나치 수열과 같은 문제에서 두드러진다.<br>예를 들어, <code>fibonacci(5)</code>를 계산할 때:</p><ul><li><code>fibonacci(3)</code>은 두 번 계산된다.</li><li><code>fibonacci(2)</code>는 세 번 계산된다.</li><li><code>fibonacci(1)</code>은 다섯 번 계산된다.<br>이러한 중복 계산은 메모이제이션(memoization)을 통해 해결할 수 있다:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=비꼬리-재귀가-유용한-상황>비꼬리 재귀가 유용한 상황<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀가-유용한-상황>#</a></h3><p>비꼬리 재귀가 특히 유용한 상황은 다음과 같다:</p><ol><li><strong>자연스러운 문제 해결</strong>: 일부 문제는 비꼬리 재귀로 표현하는 것이 더 자연스럽고 직관적.</li><li><strong>트리와 그래프 처리</strong>: 트리 순회나 그래프 탐색과 같은 작업은 비꼬리 재귀로 표현하는 것이 자연스럽다.</li><li><strong>분할 정복 알고리즘</strong>: 퀵 정렬, 병합 정렬과 같은 알고리즘은 비꼬리 재귀를 사용.</li><li><strong>표현식 평가</strong>: 수학 표현식이나 프로그래밍 언어 파서는 종종 비꼬리 재귀를 사용.</li></ol><h3 id=비꼬리-재귀의-또-다른-예제-퀵-정렬>비꼬리 재귀의 또 다른 예제: 퀵 정렬<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀의-또-다른-예제-퀵-정렬>#</a></h3><p>퀵 정렬은 비꼬리 재귀의 또 다른 좋은 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quicksort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 재귀 호출 결과를 결합하는 추가 연산이 필요</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quicksort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>quicksort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>  <span class=c1># Non-tail recursion</span>
</span></span></code></pre></td></tr></table></div></div><p>이 퀵 정렬 구현은 두 개의 재귀 호출 결과와 중간 배열을 결합하는 추가 연산이 필요하므로 비꼬리 재귀.</p><h3 id=비꼬리-재귀의-시각적-표현-호출-트리>비꼬리 재귀의 시각적 표현: 호출 트리<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀의-시각적-표현-호출-트리>#</a></h3><p>비꼬리 재귀의 호출 구조를 시각적으로 이해하기 위해 간단한 예제의 호출 트리.</p><p>예를 들어, <code>factorial(4)</code>의 호출 트리는 다음과 같다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>factorial(4)
</span></span><span class=line><span class=cl>├── 재귀 호출: factorial(3)
</span></span><span class=line><span class=cl>│   ├── 재귀 호출: factorial(2)
</span></span><span class=line><span class=cl>│   │   ├── 재귀 호출: factorial(1)
</span></span><span class=line><span class=cl>│   │   │   └── 반환: 1
</span></span><span class=line><span class=cl>│   │   └── 반환: 2 * 1 = 2
</span></span><span class=line><span class=cl>│   └── 반환: 3 * 2 = 6
</span></span><span class=line><span class=cl>└── 반환: 4 * 6 = 24
</span></span></code></pre></td></tr></table></div></div><p>이 호출 트리에서 볼 수 있듯이, 각 재귀 호출이 완료된 후 해당 결과에 추가 연산(곱셈)이 적용된다.<br>이것이 비꼬리 재귀의 특징이다.</p><h3 id=비꼬리-재귀가-가진-실용적인-문제점>비꼬리 재귀가 가진 실용적인 문제점<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀가-가진-실용적인-문제점>#</a></h3><p>비꼬리 재귀는 몇 가지 실용적인 문제점을 가지고 있다:</p><ol><li><strong>스택 오버플로우</strong>: 큰 입력에 대해 많은 스택 프레임이 생성되어 스택 오버플로우가 발생할 수 있다.</li><li><strong>성능 저하</strong>: 중복 계산, 스택 프레임 생성 및 해제 비용으로 인해 성능이 저하될 수 있다.</li><li><strong>최적화 어려움</strong>: 컴파일러가 꼬리 재귀 최적화를 적용할 수 없어 최적화가 제한된다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/recursion/>Recursion</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/non-tail-recursion/>Non-Tail-Recursion</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-vs-python/><span class=title>« Prev</span><br><span>Javascript vs. Python</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/><span class=title>Next »</span><br><span>Inorder Traversal</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>