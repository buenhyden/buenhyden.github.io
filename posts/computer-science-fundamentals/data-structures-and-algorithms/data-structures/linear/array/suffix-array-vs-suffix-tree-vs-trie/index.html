<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Suffix Array vs Suffix Tree vs Trie | hyunyoun's Blog</title><meta name=keywords content="Computer-Science,Fundamentals,String-Search-and-Manipulations,Data-Structures,Suffix-Array,Suffix-Tree,Trie"><meta name=description content="Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Suffix Array vs Suffix Tree vs Trie"><meta property="og:description" content="Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-12T15:40:00+00:00"><meta property="article:modified_time" content="2024-10-12T15:40:00+00:00"><meta property="article:tag" content="Computer-Science"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="String-Search-and-Manipulations"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Suffix-Array"><meta property="article:tag" content="Suffix-Tree"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Suffix Array vs Suffix Tree vs Trie"><meta name=twitter:description content="Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":4,"name":"Data Structures","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":6,"name":"배열 (Array)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/"},{"@type":"ListItem","position":7,"name":"Suffix Array vs Suffix Tree vs Trie","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Suffix Array vs Suffix Tree vs Trie","name":"Suffix Array vs Suffix Tree vs Trie","description":"Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.","keywords":["Computer-Science","Fundamentals","String-Search-and-Manipulations","Data-Structures","Suffix-Array","Suffix-Tree","Trie"],"articleBody":"Suffix Array vs. Suffix Tree vs. Trie Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.\n특성 Suffix Array Suffix Tree Trie 기본 구조 모든 접미사를 정렬하여 저장하는 1차원 배열 모든 접미사를 트리 형태로 저장하는 압축된 트리 구조 문자열을 문자 단위로 저장하는 트리 구조 메모리 효율성 O(n), 매우 효율적 O(n), 하지만 실제로는 4n 정도로 큼 O(ALPHABET_SIZE key_length n), 매우 큼 구축 시간 O(n log n) O(n) (Ukkonen’s Algorithm 사용 시) O(n * key_length) 검색 시간 O(m log n + occ), m은 패턴 길이 O(m + occ), m은 패턴 길이 O(m), m은 검색할 문자열 길이 구현 난이도 비교적 간단 매우 복잡 비교적 간단 LCP 계산 추가 배열 필요 트리 구조에서 직접 계산 가능 해당 없음 패턴 매칭 이진 검색 이용 트리 순회로 직접 검색 트리 순회로 직접 검색 공간 지역성 매우 좋음 (연속된 메모리) 보통 (포인터로 인한 흩어짐) 나쁨 (노드가 메모리에 흩어짐) 주요 응용 텍스트 검색, DNA 분석 문자열 처리, 바이오인포매틱스 사전 구현, 자동 완성 동적 업데이트 어려움 가능하나 복잡 쉬움 접두사 검색 어려움 가능하나 비효율적 매우 효율적 최장 공통 접두사 추가 작업 필요 직접 계산 가능 직접 계산 가능 최장 공통 부분 문자열 LCP 배열 필요 직접 계산 가능 부적합 압축 가능성 제한적 매우 좋음 있음 (압축 트라이) 캐시 성능 매우 좋음 보통 나쁨 실제 사용 사례 대용량 문자열 검색 시스템 생물정보학, 문자열 처리 자동 완성, 사전 검색 추가적인 중요 고려사항:\n메모리 사용 패턴:\nSuffix Array: 연속된 메모리 공간 사용으로 캐시 효율성 높음 Suffix Tree: 포인터 기반 구조로 메모리 사용이 분산됨 Trie: 노드별 메모리 할당으로 가장 분산된 사용 패턴 성능 트레이드오프:\nSuffix Array: 공간 효율성 vs 검색 속도 Suffix Tree: 구현 복잡성 vs 기능성 Trie: 메모리 사용량 vs 검색 단순성 적합한 사용 시나리오:\nSuffix Array: 메모리 제약이 있는 대규모 문자열 처리 Suffix Tree: 복잡한 문자열 처리가 필요한 고성능 응용 Trie: 접두사 기반 검색이 중요한 응용 참고 및 출처 ","wordCount":"309","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-12T15:40:00Z","dateModified":"2024-10-12T15:40:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/>배열 (Array)</a></div><h1 class="post-title entry-hint-parent">Suffix Array vs Suffix Tree vs Trie</h1><div class=post-description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</div><div class=post-meta><span title='2024-10-12 15:40:00 +0000 UTC'>October 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Data%20Structures%20and%20Algorithms/Data%20Structures/Linear/Array/Suffix-Array-vs-Suffix-Tree-vs-Trie.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#suffix-array-vs-suffix-tree-vs-trie>Suffix Array vs. Suffix Tree vs. Trie</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=suffix-array-vs-suffix-tree-vs-trie>Suffix Array vs. Suffix Tree vs. Trie<a hidden class=anchor aria-hidden=true href=#suffix-array-vs-suffix-tree-vs-trie>#</a></h2><p>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</p><table><thead><tr><th>특성</th><th>Suffix Array</th><th>Suffix Tree</th><th>Trie</th></tr></thead><tbody><tr><td><strong>기본 구조</strong></td><td>모든 접미사를 정렬하여 저장하는 1차원 배열</td><td>모든 접미사를 트리 형태로 저장하는 압축된 트리 구조</td><td>문자열을 문자 단위로 저장하는 트리 구조</td></tr><tr><td><strong>메모리 효율성</strong></td><td>O(n), 매우 효율적</td><td>O(n), 하지만 실제로는 4n 정도로 큼</td><td>O(ALPHABET_SIZE <em>key_length</em> n), 매우 큼</td></tr><tr><td><strong>구축 시간</strong></td><td>O(n log n)</td><td>O(n) (Ukkonen&rsquo;s Algorithm 사용 시)</td><td>O(n * key_length)</td></tr><tr><td><strong>검색 시간</strong></td><td>O(m log n + occ), m은 패턴 길이</td><td>O(m + occ), m은 패턴 길이</td><td>O(m), m은 검색할 문자열 길이</td></tr><tr><td><strong>구현 난이도</strong></td><td>비교적 간단</td><td>매우 복잡</td><td>비교적 간단</td></tr><tr><td><strong>LCP 계산</strong></td><td>추가 배열 필요</td><td>트리 구조에서 직접 계산 가능</td><td>해당 없음</td></tr><tr><td><strong>패턴 매칭</strong></td><td>이진 검색 이용</td><td>트리 순회로 직접 검색</td><td>트리 순회로 직접 검색</td></tr><tr><td><strong>공간 지역성</strong></td><td>매우 좋음 (연속된 메모리)</td><td>보통 (포인터로 인한 흩어짐)</td><td>나쁨 (노드가 메모리에 흩어짐)</td></tr><tr><td><strong>주요 응용</strong></td><td>텍스트 검색, DNA 분석</td><td>문자열 처리, 바이오인포매틱스</td><td>사전 구현, 자동 완성</td></tr><tr><td><strong>동적 업데이트</strong></td><td>어려움</td><td>가능하나 복잡</td><td>쉬움</td></tr><tr><td><strong>접두사 검색</strong></td><td>어려움</td><td>가능하나 비효율적</td><td>매우 효율적</td></tr><tr><td><strong>최장 공통 접두사</strong></td><td>추가 작업 필요</td><td>직접 계산 가능</td><td>직접 계산 가능</td></tr><tr><td><strong>최장 공통 부분 문자열</strong></td><td>LCP 배열 필요</td><td>직접 계산 가능</td><td>부적합</td></tr><tr><td><strong>압축 가능성</strong></td><td>제한적</td><td>매우 좋음</td><td>있음 (압축 트라이)</td></tr><tr><td><strong>캐시 성능</strong></td><td>매우 좋음</td><td>보통</td><td>나쁨</td></tr><tr><td><strong>실제 사용 사례</strong></td><td>대용량 문자열 검색 시스템</td><td>생물정보학, 문자열 처리</td><td>자동 완성, 사전 검색</td></tr></tbody></table><p>추가적인 중요 고려사항:</p><ol><li><p>메모리 사용 패턴:</p><ul><li>Suffix Array: 연속된 메모리 공간 사용으로 캐시 효율성 높음</li><li>Suffix Tree: 포인터 기반 구조로 메모리 사용이 분산됨</li><li>Trie: 노드별 메모리 할당으로 가장 분산된 사용 패턴</li></ul></li><li><p>성능 트레이드오프:</p><ul><li>Suffix Array: 공간 효율성 vs 검색 속도</li><li>Suffix Tree: 구현 복잡성 vs 기능성</li><li>Trie: 메모리 사용량 vs 검색 단순성</li></ul></li><li><p>적합한 사용 시나리오:</p><ul><li>Suffix Array: 메모리 제약이 있는 대규모 문자열 처리</li><li>Suffix Tree: 복잡한 문자열 처리가 필요한 고성능 응용</li><li>Trie: 접두사 기반 검색이 중요한 응용</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science/>Computer-Science</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/string-search-and-manipulations/>String-Search-and-Manipulations</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/suffix-array/>Suffix-Array</a></li><li><a href=https://buenhyden.github.io/tags/suffix-tree/>Suffix-Tree</a></li><li><a href=https://buenhyden.github.io/tags/trie/>Trie</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/quality-assurance/sdlc/6-deployment/><span class=title>« Prev</span><br><span>6. 배포 (Deployment)</span>
</a><a class=next href=https://buenhyden.github.io/posts/quality-assurance/sdlc/7-maintenance/><span class=title>Next »</span><br><span>7. 유지보수 (Maintenance)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>