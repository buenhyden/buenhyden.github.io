<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Divide and Conquer vs. Branch and Bound | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Divide-and-Conquer,Branch-and-Bound"><meta name=description content="분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Divide and Conquer vs. Branch and Bound"><meta property="og:description" content="분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T02:16:00+00:00"><meta property="article:modified_time" content="2025-01-24T02:16:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Divide-and-Conquer"><meta property="article:tag" content="Branch-and-Bound"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Divide and Conquer vs. Branch and Bound"><meta name=twitter:description content="분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/"},{"@type":"ListItem","position":4,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":5,"name":"분할 정복 (Divide and Conquer)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/"},{"@type":"ListItem","position":6,"name":"Divide and Conquer vs. Branch and Bound","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Divide and Conquer vs. Branch and Bound","name":"Divide and Conquer vs. Branch and Bound","description":"분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Divide-and-Conquer","Branch-and-Bound"],"articleBody":"Divide and Conquer vs. Branch and Bound “Divide and Conquer(분할 정복)“과 “Branch and Bound(분기 한정)“은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.\n“Divide and Conquer\"와 “Branch and Bound\"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.\n분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.\n분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.\n두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.\nDivide and Conquer(분할 정복) 알고리즘 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.\n이 알고리즘은 다음과 같은 세 단계로 구성된다:\n분할(Divide): 원래 문제를 더 작은 하위 문제들로 나눈다. 정복(Conquer): 각 하위 문제를 재귀적으로 해결한다. 결합(Combine): 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다. 대규모 건설 프로젝트와 유사하다. 전체 건물(문제)을 여러 층이나 구역(하위 문제)으로 나누어 각각 건설(정복)한 다음, 모든 부분을 연결(결합)하여 전체 건물을 완성한다.\n작동 원리 예시: 퀵 정렬(Quick Sort) 퀵 정렬은 분할 정복의 대표적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def quick_sort(arr): if len(arr) \u003c= 1: return arr # 피벗 선택 (여기서는 첫 번째 요소를 피벗으로 선택) pivot = arr[0] # 분할: 피벗보다 작은 요소와 큰 요소를 분리 less = [x for x in arr[1:] if x \u003c= pivot] greater = [x for x in arr[1:] if x \u003e pivot] # 정복: 재귀적으로 하위 배열 정렬 less = quick_sort(less) greater = quick_sort(greater) # 결합: 정렬된 하위 배열과 피벗을 결합 return less + [pivot] + greater 이 알고리즘은 배열을 피벗을 기준으로 두 부분(분할)으로 나누고, 각 부분을 재귀적으로 정렬(정복)한 다음, 정렬된 두 부분을 피벗과 함께 결합하여 최종 정렬된 배열을 만든다.\n특징 및 장단점 장점:\n큰 문제를 작은 문제로 나누어 해결함으로써 복잡성을 줄일 수 있다. 많은 경우 효율적인 시간 복잡도(일반적으로 O(n log n))를 가진다. 일부 문제에서 병렬 처리에 적합하다. 단점:\n재귀 호출로 인한 스택 오버플로우가 발생할 수 있다. 모든 하위 문제를 해결해야 하므로 가지치기(pruning)가 어렵다. 일부 경우에 비효율적일 수 있다(예: 피벗 선택이 잘못된 경우의 퀵 정렬). Branch and Bound(분기 한정) 알고리즘 분기 한정은 최적화 문제(주로 조합 최적화 문제)를 해결하기 위한, 특히 NP-hard 문제에 효과적인 알고리즘이다.\n이 알고리즘은 다음과 같은 두 가지 주요 요소로 구성된다:\n분기(Branching): 문제의 해공간을 여러 하위 공간으로 분할한다. 한정(Bounding): 각 하위 공간에 대한 한계(상한 또는 하한)를 계산하여 유망하지 않은 해공간을 가지치기한다. 분기 한정 알고리즘은 일반적으로 탐색 트리를 사용하여 문제의 해공간을 탐색하며, 유망하지 않은 가지(subspace)를 제거하여 탐색 공간을 줄인다.\n미로에서 보물 찾기와 유사하다.미로의 여러 경로(분기)를 탐색하되, 각 경로마다 보물과의 최소 거리(한계)를 계산한다. 이미 찾은 보물까지의 거리보다 현재 경로의 최소 거리 추정치가 더 크면, 그 경로는 더 이상 탐색하지 않는다(가지치기).\n작동 원리 예시: 배낭 문제(Knapsack Problem) 배낭 문제는 분기 한정의 대표적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def knapsack_branch_and_bound(weights, values, capacity): n = len(weights) # 항목을 가치/무게 비율에 따라 내림차순 정렬 items = sorted([(values[i]/weights[i], weights[i], values[i], i) for i in range(n)], reverse=True) # 최적해와 최대 가치를 저장할 변수 best_value = 0 best_solution = [0] * n # 현재 상태를 나타내는 클래스 class Node: def __init__(self, level, weight, value, includes): self.level = level # 현재 결정 레벨 self.weight = weight # 현재까지의 무게 self.value = value # 현재까지의 가치 self.includes = includes.copy() # 포함된 항목 목록 # 상한 계산 (남은 공간에 분할 가능한 물건을 넣을 경우의 가치) self.bound = self.calculate_bound(weights, values, capacity, items) def calculate_bound(self, weights, values, capacity, items): if self.weight \u003e capacity: return 0 bound_value = self.value j = self.level total_weight = self.weight # 남은 항목들을 가치/무게 비율이 높은 순으로 최대한 추가 while j \u003c n and total_weight + items[j][1] \u003c= capacity: total_weight += items[j][1] bound_value += items[j][2] j += 1 # 마지막 항목은 분수로 추가 if j \u003c n: bound_value += (capacity - total_weight) * items[j][0] return bound_value # 탐색 큐 queue = [Node(0, 0, 0, [0] * n)] while queue: node = queue.pop(0) # 마지막 레벨에 도달한 경우 if node.level == n: if node.value \u003e best_value and node.weight \u003c= capacity: best_value = node.value best_solution = node.includes continue # 현재 항목의 인덱스 i = items[node.level][3] # 현재 항목을 포함하지 않는 경우 new_includes = node.includes.copy() child = Node(node.level + 1, node.weight, node.value, new_includes) # 한계값이 현재 최대 가치보다 크면 유망하다고 판단 if child.bound \u003e best_value: queue.append(child) # 현재 항목을 포함하는 경우 if node.weight + items[node.level][1] \u003c= capacity: new_includes = node.includes.copy() new_includes[i] = 1 child = Node(node.level + 1, node.weight + items[node.level][1], node.value + items[node.level][2], new_includes) if child.bound \u003e best_value: queue.append(child) return best_value, best_solution 이 알고리즘은 가치/무게 비율이 높은 항목부터 고려하며, 각 항목을 포함하거나 포함하지 않는 두 가지 선택지(분기)를 탐색한다. 각 노드에서 상한(bound)을 계산하여 유망하지 않은 가지는 더 이상 탐색하지 않는다(한정).\n특징 및 장단점 장점:\n최적화 문제에서 효율적으로 최적해를 찾을 수 있다. 가지치기를 통해 불필요한 탐색을 줄일 수 있다. 복잡한 조합 최적화 문제에 적합하다. 단점:\n구현이 상대적으로 복잡하다. 효율적인 한계 함수(bounding function)를 설계하는 것이 중요하며 어려울 수 있다. 최악의 경우 여전히 지수 시간이 소요될 수 있다. 두 알고리즘의 핵심 차이점 문제 해결 접근 방식\n분할 정복: 문제를 독립적인 하위 문제로 나누어 각각 해결한 후 결합한다. 분기 한정: 해공간을 체계적으로 탐색하며, 유망하지 않은 부분을 제거한다. 탐색 공간\n분할 정복: 모든 하위 문제를 해결한다. 분기 한정: 유망한 하위 문제만 탐색하고, 나머지는 가지치기한다. 적용 문제 유형\n분할 정복: 정렬, 검색, 행렬 곱셈 등 다양한 문제에 적용할 수 있다. 분기 한정: 주로 조합 최적화 문제(TSP, 배낭 문제 등)에 적용된다. 예시로 보는 차이: 외판원 문제(TSP)\n외판원 문제(Traveling Salesman Problem)는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제다.\n분할 정복 접근: 모든 가능한 경로를 나열하고 비교한다. 이는 도시 수가 많아지면 비효율적입니다(시간 복잡도: O(n!)). 분기 한정 접근: 부분 경로의 하한(lower bound)을 계산하여 유망하지 않은 경로는 탐색하지 않는다. 이를 통해 탐색 공간을 크게 줄일 수 있다. 실제 적용 사례 Divide and Conquer 적용 사례 병합 정렬(Merge Sort): 배열을 절반으로 나누어 정렬한 후 병합 이진 검색(Binary Search): 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄임 카라츠바 알고리즘(Karatsuba Algorithm): 큰 수의 곱셈을 효율적으로 수행 최근접 점쌍 찾기(Closest Pair of Points): 2D 평면에서 가장 가까운 두 점을 찾음 Branch and Bound 적용 사례 외판원 문제(Traveling Salesman Problem): 모든 도시를 방문하는 최단 경로 찾기 배낭 문제(Knapsack Problem): 제한된 무게 내에서 최대 가치의 물건 선택 작업 할당 문제(Job Assignment Problem): n개의 작업을 n명의 작업자에게 최적으로 할당 정수 계획법(Integer Programming): 정수 제약 조건이 있는 최적화 문제 해결 코드 비교: 최적 해 찾기 문제 두 알고리즘의 차이를 보여주기 위해 간단한 최적화 문제.\n분할 정복 접근법: 모든 부분집합 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def find_optimal_subset_dc(weights, values, capacity): n = len(weights) # 모든 가능한 부분집합을 생성하여 최적해 찾기 def generate_subsets(index, current_weight, current_value, selected): if index == n: return current_value if current_weight \u003c= capacity else 0, selected.copy() # 현재 항목을 포함하지 않는 경우 val1, sel1 = generate_subsets(index + 1, current_weight, current_value, selected) # 현재 항목을 포함하는 경우 selected.append(index) val2, sel2 = generate_subsets(index + 1, current_weight + weights[index], current_value + values[index], selected) selected.pop() # 더 나은 결과 반환 if val1 \u003e= val2: return val1, sel1 else: return val2, sel2 return generate_subsets(0, 0, 0, []) 분기 한정 접근법: 유망한 부분집합만 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def find_optimal_subset_bnb(weights, values, capacity): n = len(weights) # 항목을 가치/무게 비율에 따라 내림차순 정렬 items = [(values[i]/weights[i], weights[i], values[i], i) for i in range(n)] items.sort(reverse=True) best_value = 0 best_selection = [] def bound(index, current_weight, current_value): if current_weight \u003e capacity: return 0 bound_value = current_value j = index total_weight = current_weight # 남은 항목들을 가치/무게 비율이 높은 순으로 최대한 추가 while j \u003c n and total_weight + items[j][1] \u003c= capacity: total_weight += items[j][1] bound_value += items[j][2] j += 1 # 마지막 항목은 분수로 추가 if j \u003c n: bound_value += (capacity - total_weight) * items[j][0] return bound_value def branch_and_bound(index, current_weight, current_value, selected): nonlocal best_value, best_selection # 종료 조건 if index == n: if current_value \u003e best_value and current_weight \u003c= capacity: best_value = current_value best_selection = selected.copy() return # 현재 상태의 상한 계산 upper_bound = bound(index, current_weight, current_value) # 가지치기: 상한이 현재 최적값보다 작으면 탐색 중단 if upper_bound \u003c= best_value: return # 현재 항목을 포함하지 않는 경우 branch_and_bound(index + 1, current_weight, current_value, selected) # 현재 항목을 포함하는 경우 if current_weight + items[index][1] \u003c= capacity: selected.append(items[index][3]) branch_and_bound(index + 1, current_weight + items[index][1], current_value + items[index][2], selected) selected.pop() branch_and_bound(0, 0, 0, []) return best_value, best_selection 분할 정복 방식은 모든 가능한 부분집합을 생성하여 비교하는 반면, 분기 한정 방식은 상한(bound)을 계산하여 유망하지 않은 가지는 탐색하지 않는다.\n이를 통해 분기 한정 방식이 더 효율적으로 최적해를 찾을 수 있다.\n선택 가이드 Divide and Conquer를 선택해야 할 때 문제가 자연스럽게 독립적인 하위 문제로 나뉠 때 하위 문제의 해결책을 쉽게 결합할 수 있을 때 재귀적 구조가 명확할 때 정렬, 검색과 같은 기본적인 알고리즘 문제를 해결할 때 병렬 처리가 필요할 때 Branch and Bound를 선택해야 할 때 최적화 문제를 해결해야 할 때 문제의 해공간이 너무 크지만, 효과적인 가지치기가 가능할 때 완전 탐색이 비효율적일 때 조합 최적화 문제(TSP, 배낭 문제 등)를 해결할 때 효율적인 한계 함수를 설계할 수 있을 때 문제 접근 방법 문제 분석: 문제의 구조와 특성을 파악한다. 문제가 독립적인 하위 문제로 나눌 수 있는지 최적화 문제인지, 효과적인 가지치기가 가능한지 알고리즘 선택: 문제가 명확하게 분할 가능하고 하위 문제를 결합할 수 있으면 → 분할 정복 최적화 문제이고 효과적인 한계 함수를 설계할 수 있으면 → 분기 한정 구현 방법: 분할 정복: 재귀 함수를 사용하여 하위 문제를 해결하고 결과를 결합 분기 한정: 상태 공간 트리를 탐색하며 한계 함수를 사용하여 가지치기 두 알고리즘 비교 특성 Divide and Conquer Branch and Bound 기본 원리 문제를 작은 하위 문제로 분할하여 해결 해공간을 분기하고 유망하지 않은 부분을 가지치기 목적 효율적인 문제 해결 최적화 문제의 최적해 찾기 접근 방식 재귀적, 하향식(top-down) 체계적인 열거, 상태 공간 트리 탐색 문제 해결 전략 분할 → 정복 → 결합 분기 → 한계 계산 → 가지치기 탐색 범위 모든 하위 문제 탐색 유망한 하위 문제만 탐색 가지치기(pruning) 일반적으로 사용하지 않음 필수적으로 사용(핵심 요소) 적용 문제 유형 정렬, 검색, 행렬 연산 등 조합 최적화 문제(TSP, 배낭 문제 등) 시간 복잡도 일반적으로 O(n log n) (예: 병합 정렬) 최악의 경우 지수 시간이지만 가지치기로 개선 공간 복잡도 재귀 호출 스택으로 인해 높을 수 있음 탐색 트리 저장으로 인해 높을 수 있음 최적해 보장 일반적으로 보장 완전한 탐색 시 보장 중간 결과 활용 하위 문제 해결 후 결합 현재까지의 최적값을 가지치기에 활용 구현 복잡성 중간 높음 (한계 함수 설계가 어려움) 대표 알고리즘 병합 정렬, 퀵 정렬, 이진 검색 분기한정법 기반 TSP, 배낭 문제 해결 상태 관리 하위 문제별 독립적 상태 탐색 경로의 전체 상태 유지 적합한 문제 크기 중간~큰 크기 중간 크기 (너무 크면 여전히 비효율적) 병렬화 가능성 높음 (독립적 하위 문제) 제한적 (탐색 상태 의존성) 메모리 사용 패턴 분할-결합 단계에서 메모리 사용 가지치기 결정을 위한 상태 정보 저장 탐색 순서 문제 구조에 따라 결정 BFS, DFS, 최선 우선 등 다양한 전략 사용 가능 휴리스틱 활용 일반적으로 사용하지 않음 한계 함수, 탐색 순서 등에 활용 참고 및 출처 ","wordCount":"1904","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-24T02:16:00Z","dateModified":"2025-01-24T02:16:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/>분할 정복 (Divide and Conquer)</a></div><h1 class="post-title entry-hint-parent">Divide and Conquer vs. Branch and Bound</h1><div class=post-description>분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.</div><div class=post-meta><span title='2025-01-24 02:16:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Divide%20and%20Conquer/divide-and-conquer-vs-branch-and-bound.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#divide-and-conquer-vs-branch-and-bound>Divide and Conquer vs. Branch and Bound</a><ul><li><a href=#divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘</a></li><li><a href=#branch-and-bound분기-한정-알고리즘>Branch and Bound(분기 한정) 알고리즘</a></li><li><a href=#두-알고리즘의-핵심-차이점>두 알고리즘의 핵심 차이점</a></li><li><a href=#실제-적용-사례>실제 적용 사례</a></li><li><a href=#코드-비교-최적-해-찾기-문제>코드 비교: 최적 해 찾기 문제</a></li><li><a href=#선택-가이드>선택 가이드</a></li><li><a href=#두-알고리즘-비교>두 알고리즘 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=divide-and-conquer-vs-branch-and-bound>Divide and Conquer vs. Branch and Bound<a hidden class=anchor aria-hidden=true href=#divide-and-conquer-vs-branch-and-bound>#</a></h2><p>&ldquo;Divide and Conquer(분할 정복)&ldquo;과 &ldquo;Branch and Bound(분기 한정)&ldquo;은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.</p><p>&ldquo;Divide and Conquer"와 &ldquo;Branch and Bound"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.<br>분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.</p><p>분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.<br>두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.</p><h3 id=divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘<a hidden class=anchor aria-hidden=true href=#divide-and-conquer분할-정복-알고리즘>#</a></h3><p>분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.<br>이 알고리즘은 다음과 같은 세 단계로 구성된다:</p><ol><li><strong>분할(Divide)</strong>: 원래 문제를 더 작은 하위 문제들로 나눈다.</li><li><strong>정복(Conquer)</strong>: 각 하위 문제를 재귀적으로 해결한다.</li><li><strong>결합(Combine)</strong>: 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다.</li></ol><p>대규모 건설 프로젝트와 유사하다. 전체 건물(문제)을 여러 층이나 구역(하위 문제)으로 나누어 각각 건설(정복)한 다음, 모든 부분을 연결(결합)하여 전체 건물을 완성한다.</p><h4 id=작동-원리-예시-퀵-정렬quick-sort>작동 원리 예시: 퀵 정렬(Quick Sort)<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-퀵-정렬quick-sort>#</a></h4><p>퀵 정렬은 분할 정복의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 피벗 선택 (여기서는 첫 번째 요소를 피벗으로 선택)</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할: 피벗보다 작은 요소와 큰 요소를 분리</span>
</span></span><span class=line><span class=cl>    <span class=n>less</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;=</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>greater</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정복: 재귀적으로 하위 배열 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>less</span> <span class=o>=</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>less</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>greater</span> <span class=o>=</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>greater</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결합: 정렬된 하위 배열과 피벗을 결합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>less</span> <span class=o>+</span> <span class=p>[</span><span class=n>pivot</span><span class=p>]</span> <span class=o>+</span> <span class=n>greater</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 배열을 피벗을 기준으로 두 부분(분할)으로 나누고, 각 부분을 재귀적으로 정렬(정복)한 다음, 정렬된 두 부분을 피벗과 함께 결합하여 최종 정렬된 배열을 만든다.</p><h4 id=특징-및-장단점>특징 및 장단점<a hidden class=anchor aria-hidden=true href=#특징-및-장단점>#</a></h4><p><strong>장점:</strong></p><ul><li>큰 문제를 작은 문제로 나누어 해결함으로써 복잡성을 줄일 수 있다.</li><li>많은 경우 효율적인 시간 복잡도(일반적으로 O(n log n))를 가진다.</li><li>일부 문제에서 병렬 처리에 적합하다.</li></ul><p><strong>단점:</strong></p><ul><li>재귀 호출로 인한 스택 오버플로우가 발생할 수 있다.</li><li>모든 하위 문제를 해결해야 하므로 가지치기(pruning)가 어렵다.</li><li>일부 경우에 비효율적일 수 있다(예: 피벗 선택이 잘못된 경우의 퀵 정렬).</li></ul><h3 id=branch-and-bound분기-한정-알고리즘>Branch and Bound(분기 한정) 알고리즘<a hidden class=anchor aria-hidden=true href=#branch-and-bound분기-한정-알고리즘>#</a></h3><p>분기 한정은 최적화 문제(주로 조합 최적화 문제)를 해결하기 위한, 특히 NP-hard 문제에 효과적인 알고리즘이다.<br>이 알고리즘은 다음과 같은 두 가지 주요 요소로 구성된다:</p><ol><li><strong>분기(Branching)</strong>: 문제의 해공간을 여러 하위 공간으로 분할한다.</li><li><strong>한정(Bounding)</strong>: 각 하위 공간에 대한 한계(상한 또는 하한)를 계산하여 유망하지 않은 해공간을 가지치기한다.</li></ol><p>분기 한정 알고리즘은 일반적으로 탐색 트리를 사용하여 문제의 해공간을 탐색하며, 유망하지 않은 가지(subspace)를 제거하여 탐색 공간을 줄인다.</p><p>미로에서 보물 찾기와 유사하다.미로의 여러 경로(분기)를 탐색하되, 각 경로마다 보물과의 최소 거리(한계)를 계산한다. 이미 찾은 보물까지의 거리보다 현재 경로의 최소 거리 추정치가 더 크면, 그 경로는 더 이상 탐색하지 않는다(가지치기).</p><h4 id=작동-원리-예시-배낭-문제knapsack-problem>작동 원리 예시: 배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-배낭-문제knapsack-problem>#</a></h4><p>배낭 문제는 분기 한정의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span><span class=lnt id=hl-1-42><a class=lnlinks href=#hl-1-42>42</a>
</span><span class=lnt id=hl-1-43><a class=lnlinks href=#hl-1-43>43</a>
</span><span class=lnt id=hl-1-44><a class=lnlinks href=#hl-1-44>44</a>
</span><span class=lnt id=hl-1-45><a class=lnlinks href=#hl-1-45>45</a>
</span><span class=lnt id=hl-1-46><a class=lnlinks href=#hl-1-46>46</a>
</span><span class=lnt id=hl-1-47><a class=lnlinks href=#hl-1-47>47</a>
</span><span class=lnt id=hl-1-48><a class=lnlinks href=#hl-1-48>48</a>
</span><span class=lnt id=hl-1-49><a class=lnlinks href=#hl-1-49>49</a>
</span><span class=lnt id=hl-1-50><a class=lnlinks href=#hl-1-50>50</a>
</span><span class=lnt id=hl-1-51><a class=lnlinks href=#hl-1-51>51</a>
</span><span class=lnt id=hl-1-52><a class=lnlinks href=#hl-1-52>52</a>
</span><span class=lnt id=hl-1-53><a class=lnlinks href=#hl-1-53>53</a>
</span><span class=lnt id=hl-1-54><a class=lnlinks href=#hl-1-54>54</a>
</span><span class=lnt id=hl-1-55><a class=lnlinks href=#hl-1-55>55</a>
</span><span class=lnt id=hl-1-56><a class=lnlinks href=#hl-1-56>56</a>
</span><span class=lnt id=hl-1-57><a class=lnlinks href=#hl-1-57>57</a>
</span><span class=lnt id=hl-1-58><a class=lnlinks href=#hl-1-58>58</a>
</span><span class=lnt id=hl-1-59><a class=lnlinks href=#hl-1-59>59</a>
</span><span class=lnt id=hl-1-60><a class=lnlinks href=#hl-1-60>60</a>
</span><span class=lnt id=hl-1-61><a class=lnlinks href=#hl-1-61>61</a>
</span><span class=lnt id=hl-1-62><a class=lnlinks href=#hl-1-62>62</a>
</span><span class=lnt id=hl-1-63><a class=lnlinks href=#hl-1-63>63</a>
</span><span class=lnt id=hl-1-64><a class=lnlinks href=#hl-1-64>64</a>
</span><span class=lnt id=hl-1-65><a class=lnlinks href=#hl-1-65>65</a>
</span><span class=lnt id=hl-1-66><a class=lnlinks href=#hl-1-66>66</a>
</span><span class=lnt id=hl-1-67><a class=lnlinks href=#hl-1-67>67</a>
</span><span class=lnt id=hl-1-68><a class=lnlinks href=#hl-1-68>68</a>
</span><span class=lnt id=hl-1-69><a class=lnlinks href=#hl-1-69>69</a>
</span><span class=lnt id=hl-1-70><a class=lnlinks href=#hl-1-70>70</a>
</span><span class=lnt id=hl-1-71><a class=lnlinks href=#hl-1-71>71</a>
</span><span class=lnt id=hl-1-72><a class=lnlinks href=#hl-1-72>72</a>
</span><span class=lnt id=hl-1-73><a class=lnlinks href=#hl-1-73>73</a>
</span><span class=lnt id=hl-1-74><a class=lnlinks href=#hl-1-74>74</a>
</span><span class=lnt id=hl-1-75><a class=lnlinks href=#hl-1-75>75</a>
</span><span class=lnt id=hl-1-76><a class=lnlinks href=#hl-1-76>76</a>
</span><span class=lnt id=hl-1-77><a class=lnlinks href=#hl-1-77>77</a>
</span><span class=lnt id=hl-1-78><a class=lnlinks href=#hl-1-78>78</a>
</span><span class=lnt id=hl-1-79><a class=lnlinks href=#hl-1-79>79</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 항목을 가치/무게 비율에 따라 내림차순 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>([(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>/</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>                   <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최적해와 최대 가치를 저장할 변수</span>
</span></span><span class=line><span class=cl>    <span class=n>best_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>best_solution</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 현재 상태를 나타내는 클래스</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>includes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>level</span> <span class=o>=</span> <span class=n>level</span>      <span class=c1># 현재 결정 레벨</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight</span>    <span class=c1># 현재까지의 무게</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>      <span class=c1># 현재까지의 가치</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>includes</span> <span class=o>=</span> <span class=n>includes</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 포함된 항목 목록</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 상한 계산 (남은 공간에 분할 가능한 물건을 넣을 경우의 가치)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>calculate_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>calculate_bound</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>,</span> <span class=n>items</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>&gt;</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>level</span>
</span></span><span class=line><span class=cl>            <span class=n>total_weight</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>weight</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 남은 항목들을 가치/무게 비율이 높은 순으로 최대한 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>total_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 마지막 항목은 분수로 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>bound_value</span> <span class=o>+=</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>-</span> <span class=n>total_weight</span><span class=p>)</span> <span class=o>*</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>bound_value</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 탐색 큐</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=p>[</span><span class=n>Node</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 레벨에 도달한 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&gt;</span> <span class=n>best_value</span> <span class=ow>and</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_value</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>                <span class=n>best_solution</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>includes</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목의 인덱스</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>items</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목을 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>        <span class=n>new_includes</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>includes</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span><span class=p>,</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>new_includes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 한계값이 현재 최대 가치보다 크면 유망하다고 판단</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목을 포함하는 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>new_includes</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>includes</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>new_includes</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>level</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                         <span class=n>node</span><span class=o>.</span><span class=n>weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                         <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>level</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                         <span class=n>new_includes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=n>bound</span> <span class=o>&gt;</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 가치/무게 비율이 높은 항목부터 고려하며, 각 항목을 포함하거나 포함하지 않는 두 가지 선택지(분기)를 탐색한다. 각 노드에서 상한(bound)을 계산하여 유망하지 않은 가지는 더 이상 탐색하지 않는다(한정).</p><h4 id=특징-및-장단점-1>특징 및 장단점<a hidden class=anchor aria-hidden=true href=#특징-및-장단점-1>#</a></h4><p><strong>장점:</strong></p><ul><li>최적화 문제에서 효율적으로 최적해를 찾을 수 있다.</li><li>가지치기를 통해 불필요한 탐색을 줄일 수 있다.</li><li>복잡한 조합 최적화 문제에 적합하다.</li></ul><p><strong>단점:</strong></p><ul><li>구현이 상대적으로 복잡하다.</li><li>효율적인 한계 함수(bounding function)를 설계하는 것이 중요하며 어려울 수 있다.</li><li>최악의 경우 여전히 지수 시간이 소요될 수 있다.</li></ul><h3 id=두-알고리즘의-핵심-차이점>두 알고리즘의 핵심 차이점<a hidden class=anchor aria-hidden=true href=#두-알고리즘의-핵심-차이점>#</a></h3><ol><li><p>문제 해결 접근 방식</p><ul><li><strong>분할 정복</strong>: 문제를 독립적인 하위 문제로 나누어 각각 해결한 후 결합한다.</li><li><strong>분기 한정</strong>: 해공간을 체계적으로 탐색하며, 유망하지 않은 부분을 제거한다.</li></ul></li><li><p>탐색 공간</p><ul><li><strong>분할 정복</strong>: 모든 하위 문제를 해결한다.</li><li><strong>분기 한정</strong>: 유망한 하위 문제만 탐색하고, 나머지는 가지치기한다.</li></ul></li><li><p>적용 문제 유형</p><ul><li><strong>분할 정복</strong>: 정렬, 검색, 행렬 곱셈 등 다양한 문제에 적용할 수 있다.</li><li><strong>분기 한정</strong>: 주로 조합 최적화 문제(TSP, 배낭 문제 등)에 적용된다.</li></ul></li><li><p>예시로 보는 차이: 외판원 문제(TSP)<br>외판원 문제(Traveling Salesman Problem)는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제다.</p><ul><li><strong>분할 정복 접근</strong>: 모든 가능한 경로를 나열하고 비교한다. 이는 도시 수가 많아지면 비효율적입니다(시간 복잡도: O(n!)).</li><li><strong>분기 한정 접근</strong>: 부분 경로의 하한(lower bound)을 계산하여 유망하지 않은 경로는 탐색하지 않는다. 이를 통해 탐색 공간을 크게 줄일 수 있다.</li></ul></li></ol><h3 id=실제-적용-사례>실제 적용 사례<a hidden class=anchor aria-hidden=true href=#실제-적용-사례>#</a></h3><ul><li>Divide and Conquer 적용 사례<ol><li><strong>병합 정렬(Merge Sort)</strong>: 배열을 절반으로 나누어 정렬한 후 병합</li><li><strong>이진 검색(Binary Search)</strong>: 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄임</li><li><strong>카라츠바 알고리즘(Karatsuba Algorithm)</strong>: 큰 수의 곱셈을 효율적으로 수행</li><li><strong>최근접 점쌍 찾기(Closest Pair of Points)</strong>: 2D 평면에서 가장 가까운 두 점을 찾음</li></ol></li><li>Branch and Bound 적용 사례<ol><li><strong>외판원 문제(Traveling Salesman Problem)</strong>: 모든 도시를 방문하는 최단 경로 찾기</li><li><strong>배낭 문제(Knapsack Problem)</strong>: 제한된 무게 내에서 최대 가치의 물건 선택</li><li><strong>작업 할당 문제(Job Assignment Problem)</strong>: n개의 작업을 n명의 작업자에게 최적으로 할당</li><li><strong>정수 계획법(Integer Programming)</strong>: 정수 제약 조건이 있는 최적화 문제 해결</li></ol></li></ul><h3 id=코드-비교-최적-해-찾기-문제>코드 비교: 최적 해 찾기 문제<a hidden class=anchor aria-hidden=true href=#코드-비교-최적-해-찾기-문제>#</a></h3><p>두 알고리즘의 차이를 보여주기 위해 간단한 최적화 문제.</p><h4 id=분할-정복-접근법-모든-부분집합-생성>분할 정복 접근법: 모든 부분집합 생성<a hidden class=anchor aria-hidden=true href=#분할-정복-접근법-모든-부분집합-생성>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_optimal_subset_dc</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 부분집합을 생성하여 최적해 찾기</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>generate_subsets</span><span class=p>(</span><span class=n>index</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>selected</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>current_value</span> <span class=k>if</span> <span class=n>current_weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span> <span class=k>else</span> <span class=mi>0</span><span class=p>,</span> <span class=n>selected</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목을 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>        <span class=n>val1</span><span class=p>,</span> <span class=n>sel1</span> <span class=o>=</span> <span class=n>generate_subsets</span><span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>selected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목을 포함하는 경우</span>
</span></span><span class=line><span class=cl>        <span class=n>selected</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>val2</span><span class=p>,</span> <span class=n>sel2</span> <span class=o>=</span> <span class=n>generate_subsets</span><span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                     <span class=n>current_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>index</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                                     <span class=n>current_value</span> <span class=o>+</span> <span class=n>values</span><span class=p>[</span><span class=n>index</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                                     <span class=n>selected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>selected</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 더 나은 결과 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>val1</span> <span class=o>&gt;=</span> <span class=n>val2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>val1</span><span class=p>,</span> <span class=n>sel1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>val2</span><span class=p>,</span> <span class=n>sel2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>generate_subsets</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[])</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=분기-한정-접근법-유망한-부분집합만-생성>분기 한정 접근법: 유망한 부분집합만 생성<a hidden class=anchor aria-hidden=true href=#분기-한정-접근법-유망한-부분집합만-생성>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span><span class=lnt id=hl-3-42><a class=lnlinks href=#hl-3-42>42</a>
</span><span class=lnt id=hl-3-43><a class=lnlinks href=#hl-3-43>43</a>
</span><span class=lnt id=hl-3-44><a class=lnlinks href=#hl-3-44>44</a>
</span><span class=lnt id=hl-3-45><a class=lnlinks href=#hl-3-45>45</a>
</span><span class=lnt id=hl-3-46><a class=lnlinks href=#hl-3-46>46</a>
</span><span class=lnt id=hl-3-47><a class=lnlinks href=#hl-3-47>47</a>
</span><span class=lnt id=hl-3-48><a class=lnlinks href=#hl-3-48>48</a>
</span><span class=lnt id=hl-3-49><a class=lnlinks href=#hl-3-49>49</a>
</span><span class=lnt id=hl-3-50><a class=lnlinks href=#hl-3-50>50</a>
</span><span class=lnt id=hl-3-51><a class=lnlinks href=#hl-3-51>51</a>
</span><span class=lnt id=hl-3-52><a class=lnlinks href=#hl-3-52>52</a>
</span><span class=lnt id=hl-3-53><a class=lnlinks href=#hl-3-53>53</a>
</span><span class=lnt id=hl-3-54><a class=lnlinks href=#hl-3-54>54</a>
</span><span class=lnt id=hl-3-55><a class=lnlinks href=#hl-3-55>55</a>
</span><span class=lnt id=hl-3-56><a class=lnlinks href=#hl-3-56>56</a>
</span><span class=lnt id=hl-3-57><a class=lnlinks href=#hl-3-57>57</a>
</span><span class=lnt id=hl-3-58><a class=lnlinks href=#hl-3-58>58</a>
</span><span class=lnt id=hl-3-59><a class=lnlinks href=#hl-3-59>59</a>
</span><span class=lnt id=hl-3-60><a class=lnlinks href=#hl-3-60>60</a>
</span><span class=lnt id=hl-3-61><a class=lnlinks href=#hl-3-61>61</a>
</span><span class=lnt id=hl-3-62><a class=lnlinks href=#hl-3-62>62</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_optimal_subset_bnb</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 항목을 가치/무게 비율에 따라 내림차순 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>/</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>best_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>best_selection</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bound</span><span class=p>(</span><span class=n>index</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>&gt;</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>bound_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>=</span> <span class=n>current_weight</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 남은 항목들을 가치/무게 비율이 높은 순으로 최대한 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>total_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 항목은 분수로 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>+=</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>-</span> <span class=n>total_weight</span><span class=p>)</span> <span class=o>*</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound_value</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>branch_and_bound</span><span class=p>(</span><span class=n>index</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>selected</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>best_value</span><span class=p>,</span> <span class=n>best_selection</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 종료 조건</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_value</span> <span class=o>&gt;</span> <span class=n>best_value</span> <span class=ow>and</span> <span class=n>current_weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>                <span class=n>best_selection</span> <span class=o>=</span> <span class=n>selected</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 상태의 상한 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>upper_bound</span> <span class=o>=</span> <span class=n>bound</span><span class=p>(</span><span class=n>index</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가지치기: 상한이 현재 최적값보다 작으면 탐색 중단</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>upper_bound</span> <span class=o>&lt;=</span> <span class=n>best_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목을 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>        <span class=n>branch_and_bound</span><span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>selected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 항목을 포함하는 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>index</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>selected</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>items</span><span class=p>[</span><span class=n>index</span><span class=p>][</span><span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>branch_and_bound</span><span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                           <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>index</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                           <span class=n>current_value</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>index</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                           <span class=n>selected</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>selected</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>branch_and_bound</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_value</span><span class=p>,</span> <span class=n>best_selection</span>
</span></span></code></pre></td></tr></table></div></div><p>분할 정복 방식은 모든 가능한 부분집합을 생성하여 비교하는 반면, 분기 한정 방식은 상한(bound)을 계산하여 유망하지 않은 가지는 탐색하지 않는다.<br>이를 통해 분기 한정 방식이 더 효율적으로 최적해를 찾을 수 있다.</p><h3 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h3><ul><li>Divide and Conquer를 선택해야 할 때<ul><li>문제가 자연스럽게 독립적인 하위 문제로 나뉠 때</li><li>하위 문제의 해결책을 쉽게 결합할 수 있을 때</li><li>재귀적 구조가 명확할 때</li><li>정렬, 검색과 같은 기본적인 알고리즘 문제를 해결할 때</li><li>병렬 처리가 필요할 때</li></ul></li><li>Branch and Bound를 선택해야 할 때<ul><li>최적화 문제를 해결해야 할 때</li><li>문제의 해공간이 너무 크지만, 효과적인 가지치기가 가능할 때</li><li>완전 탐색이 비효율적일 때</li><li>조합 최적화 문제(TSP, 배낭 문제 등)를 해결할 때</li><li>효율적인 한계 함수를 설계할 수 있을 때</li></ul></li><li>문제 접근 방법<ol><li><strong>문제 분석</strong>: 문제의 구조와 특성을 파악한다.<ul><li>문제가 독립적인 하위 문제로 나눌 수 있는지</li><li>최적화 문제인지, 효과적인 가지치기가 가능한지</li></ul></li><li><strong>알고리즘 선택</strong>:<ul><li>문제가 명확하게 분할 가능하고 하위 문제를 결합할 수 있으면 → 분할 정복</li><li>최적화 문제이고 효과적인 한계 함수를 설계할 수 있으면 → 분기 한정</li></ul></li><li><strong>구현 방법</strong>:<ul><li>분할 정복: 재귀 함수를 사용하여 하위 문제를 해결하고 결과를 결합</li><li>분기 한정: 상태 공간 트리를 탐색하며 한계 함수를 사용하여 가지치기</li></ul></li></ol></li></ul><h3 id=두-알고리즘-비교>두 알고리즘 비교<a hidden class=anchor aria-hidden=true href=#두-알고리즘-비교>#</a></h3><table><thead><tr><th>특성</th><th>Divide and Conquer</th><th>Branch and Bound</th></tr></thead><tbody><tr><td><strong>기본 원리</strong></td><td>문제를 작은 하위 문제로 분할하여 해결</td><td>해공간을 분기하고 유망하지 않은 부분을 가지치기</td></tr><tr><td><strong>목적</strong></td><td>효율적인 문제 해결</td><td>최적화 문제의 최적해 찾기</td></tr><tr><td><strong>접근 방식</strong></td><td>재귀적, 하향식(top-down)</td><td>체계적인 열거, 상태 공간 트리 탐색</td></tr><tr><td><strong>문제 해결 전략</strong></td><td>분할 → 정복 → 결합</td><td>분기 → 한계 계산 → 가지치기</td></tr><tr><td><strong>탐색 범위</strong></td><td>모든 하위 문제 탐색</td><td>유망한 하위 문제만 탐색</td></tr><tr><td><strong>가지치기(pruning)</strong></td><td>일반적으로 사용하지 않음</td><td>필수적으로 사용(핵심 요소)</td></tr><tr><td><strong>적용 문제 유형</strong></td><td>정렬, 검색, 행렬 연산 등</td><td>조합 최적화 문제(TSP, 배낭 문제 등)</td></tr><tr><td><strong>시간 복잡도</strong></td><td>일반적으로 O(n log n) (예: 병합 정렬)</td><td>최악의 경우 지수 시간이지만 가지치기로 개선</td></tr><tr><td><strong>공간 복잡도</strong></td><td>재귀 호출 스택으로 인해 높을 수 있음</td><td>탐색 트리 저장으로 인해 높을 수 있음</td></tr><tr><td><strong>최적해 보장</strong></td><td>일반적으로 보장</td><td>완전한 탐색 시 보장</td></tr><tr><td><strong>중간 결과 활용</strong></td><td>하위 문제 해결 후 결합</td><td>현재까지의 최적값을 가지치기에 활용</td></tr><tr><td><strong>구현 복잡성</strong></td><td>중간</td><td>높음 (한계 함수 설계가 어려움)</td></tr><tr><td><strong>대표 알고리즘</strong></td><td>병합 정렬, 퀵 정렬, 이진 검색</td><td>분기한정법 기반 TSP, 배낭 문제 해결</td></tr><tr><td><strong>상태 관리</strong></td><td>하위 문제별 독립적 상태</td><td>탐색 경로의 전체 상태 유지</td></tr><tr><td><strong>적합한 문제 크기</strong></td><td>중간~큰 크기</td><td>중간 크기 (너무 크면 여전히 비효율적)</td></tr><tr><td><strong>병렬화 가능성</strong></td><td>높음 (독립적 하위 문제)</td><td>제한적 (탐색 상태 의존성)</td></tr><tr><td><strong>메모리 사용 패턴</strong></td><td>분할-결합 단계에서 메모리 사용</td><td>가지치기 결정을 위한 상태 정보 저장</td></tr><tr><td><strong>탐색 순서</strong></td><td>문제 구조에 따라 결정</td><td>BFS, DFS, 최선 우선 등 다양한 전략 사용 가능</td></tr><tr><td><strong>휴리스틱 활용</strong></td><td>일반적으로 사용하지 않음</td><td>한계 함수, 탐색 순서 등에 활용</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/divide-and-conquer/>Divide-and-Conquer</a></li><li><a href=https://buenhyden.github.io/tags/branch-and-bound/>Branch-and-Bound</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/><span class=title>« Prev</span><br><span>Divide and Conquer vs. Brute Force</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/><span class=title>Next »</span><br><span>최적 부분 구조(Optimal Substructure)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>