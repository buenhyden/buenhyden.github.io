<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Divide and Conquer vs. Brute Force | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Divide-and-Conquer"><meta name=description content="Divide and Conquer vs. Brute Force 비교 분석"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Divide and Conquer vs. Brute Force"><meta property="og:description" content="Divide and Conquer vs. Brute Force 비교 분석"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T07:17:00+00:00"><meta property="article:modified_time" content="2025-01-24T07:17:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Divide-and-Conquer"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Divide and Conquer vs. Brute Force"><meta name=twitter:description content="Divide and Conquer vs. Brute Force 비교 분석"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/"},{"@type":"ListItem","position":4,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":5,"name":"분할 정복 (Divide and Conquer)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/"},{"@type":"ListItem","position":6,"name":"Divide and Conquer vs. Brute Force","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Divide and Conquer vs. Brute Force","name":"Divide and Conquer vs. Brute Force","description":"Divide and Conquer vs. Brute Force 비교 분석","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Divide-and-Conquer"],"articleBody":"Divide and Conquer vs. Brute Force 알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.\n두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.\n먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.\nDivide and Conquer(분할 정복) 알고리즘 기본 개념 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.\n이 알고리즘은 세 가지 주요 단계로 구성된다:\n분할(Divide): 원래 문제를 더 작은 하위 문제들로 나눈다. 정복(Conquer): 각 하위 문제를 해결한다. 결합(Combine): 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다. 작동 원리 예시: 병합 정렬(Merge Sort) 병합 정렬은 분할 정복 알고리즘의 대표적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def merge_sort(arr): # 기본 사례: 리스트의 길이가 1 이하면 이미 정렬된 것으로 간주 if len(arr) \u003c= 1: return arr # 분할 단계: 배열을 두 부분으로 나눔 mid = len(arr) // 2 left = arr[:mid] right = arr[mid:] # 정복 단계: 재귀적으로 각 부분을 정렬 left = merge_sort(left) right = merge_sort(right) # 결합 단계: 정렬된 두 부분을 병합 return merge(left, right) def merge(left, right): result = [] i = j = 0 # 두 리스트의 요소를 비교하여 작은 것부터 결과에 추가 while i \u003c len(left) and j \u003c len(right): if left[i] \u003c right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # 남은 요소들을 결과에 추가 result.extend(left[i:]) result.extend(right[j:]) return result 장점 복잡한 문제를 더 간단한 하위 문제로 나눠 효율적으로 해결할 수 있다. 많은 경우 시간 복잡도가 O(n log n)으로, 대규모 데이터 세트에서 효율적. 병렬 처리에 적합. 단점 재귀 호출로 인한 추가 메모리 사용이 발생. 간단한 문제에 적용할 경우 오버헤드가 발생할 수 있다. 구현이 상대적으로 복잡할 수 있다. Brute Force(무차별 대입) 알고리즘 기본 개념 브루트 포스는 가능한 모든 경우를 철저히 검사하여 문제를 해결하는 방법.\n간단하고 직관적이지만, 대체로 효율성은 떨어진다.\n작동 원리 예시: 선형 검색(Linear Search) 선형 검색은 브루트 포스 알고리즘의 대표적인 예:\n1 2 3 4 5 6 7 8 def linear_search(arr, target): # 배열의 모든 요소를 순차적으로 확인 for i in range(len(arr)): # 현재 요소가 찾는 값과 일치하면 해당 인덱스 반환 if arr[i] == target: return i # 찾는 값이 없으면 -1 반환 return -1 장점 구현이 매우 간단하고 직관적. 소규모 데이터 세트나 간단한 문제에서는 효율적일 수 있다. 항상 정확한 해답을 찾을 수 있다. 단점 대규모 데이터 세트에서는 매우 비효율적일 수 있다. 시간 복잡도가 일반적으로 O(n) 또는 그 이상으로 높다. 복잡한 문제에서는 실행 시간이 기하급수적으로 증가할 수 있다. 실제 적용 사례 Divide and Conquer 적용 사례 퀵 정렬(Quick Sort): 배열을 피벗을 기준으로 분할하여 정렬. 이진 검색(Binary Search): 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄여가며 찾는다. 최대 부분 배열 문제(Maximum Subarray Problem): 배열을 분할하여 최대 합을 가진 부분 배열을 찾는다. 행렬 곱셈의 스트라센 알고리즘(Strassen Algorithm): 행렬을 분할하여 곱셈을 효율적으로 수행한다. Brute Force 적용 사례 암호 해독: 가능한 모든 키를 시도하여 암호를 해독한다. 부분 문자열 검색: 문자열 내에서 패턴을 찾기 위해 모든 위치를 확인한다. 여행자 문제(Traveling Salesman Problem)의 직접 접근법: 모든 가능한 경로를 확인한다. 최단 경로 찾기(단순한 경우): 모든 가능한 경로를 계산하여 최단 경로를 찾는다. 초보 개발자를 위한 선택 가이드 문제의 규모를 고려한다: 작은 규모의 문제나 데이터 세트: Brute Force가 더 간단하고 효과적일 수 있다. 큰 규모의 문제나 데이터 세트: Divide and Conquer가 더 효율적. 시간과 공간 제약을 고려하세요: 시간이 제한적인 경우: Divide and Conquer가 일반적으로 더 빠르다. 메모리가 제한적인 경우: Brute Force가 더 적은 메모리를 사용할 수 있다. 문제의 복잡성을 고려하세요: 간단한 문제: Brute Force로 시작하고, 필요에 따라 최적화한다. 복잡한 문제: Divide and Conquer가 더 관리하기 쉬운 해결책을 제공할 수 있다. 비교 특성 Divide and Conquer Brute Force 기본 원리 문제를 작은 하위 문제로 분할하여 해결 가능한 모든 경우를 철저히 검사 효율성 일반적으로 더 효율적(O(n log n) 등) 일반적으로 덜 효율적(O(n), O(n²) 등) 메모리 사용 재귀 호출로 인한 추가 메모리 필요 일반적으로 더 적은 메모리 사용 구현 복잡성 상대적으로 복잡함 매우 간단하고 직관적 대표적인 알고리즘 병합 정렬, 퀵 정렬, 이진 검색 선형 검색, 버블 정렬, 순차적 문자열 매칭 적합한 상황 대규모 데이터, 복잡한 문제 소규모 데이터, 간단한 문제, 완전한 해결책 필요 시 병렬 처리 적합성 높음 낮음 시간 복잡도 예시 병합 정렬: O(n log n) 버블 정렬: O(n²) 특징 재귀적 접근, 분할과 결합 과정 직접적이고 철저한 검사 코드 가독성 중간 높음 참고 및 출처 ","wordCount":"720","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-24T07:17:00Z","dateModified":"2025-01-24T07:17:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/>분할 정복 (Divide and Conquer)</a></div><h1 class="post-title entry-hint-parent">Divide and Conquer vs. Brute Force</h1><div class=post-description>Divide and Conquer vs. Brute Force 비교 분석</div><div class=post-meta><span title='2025-01-24 07:17:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Divide%20and%20Conquer/divide-and-conquer-vs-brute-force.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#divide-and-conquer-vs-brute-force>Divide and Conquer vs. Brute Force</a><ul><li><a href=#divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘</a></li><li><a href=#brute-force무차별-대입-알고리즘>Brute Force(무차별 대입) 알고리즘</a></li><li><a href=#실제-적용-사례>실제 적용 사례</a></li><li><a href=#초보-개발자를-위한-선택-가이드>초보 개발자를 위한 선택 가이드</a></li><li><a href=#비교>비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=divide-and-conquer-vs-brute-force>Divide and Conquer vs. Brute Force<a hidden class=anchor aria-hidden=true href=#divide-and-conquer-vs-brute-force>#</a></h2><p>알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.</p><p>두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.<br>먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.</p><h3 id=divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘<a hidden class=anchor aria-hidden=true href=#divide-and-conquer분할-정복-알고리즘>#</a></h3><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><p>분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.<br>이 알고리즘은 세 가지 주요 단계로 구성된다:</p><ol><li><strong>분할(Divide)</strong>: 원래 문제를 더 작은 하위 문제들로 나눈다.</li><li><strong>정복(Conquer)</strong>: 각 하위 문제를 해결한다.</li><li><strong>결합(Combine)</strong>: 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다.</li></ol><h4 id=작동-원리-예시-병합-정렬merge-sort>작동 원리 예시: 병합 정렬(Merge Sort)<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-병합-정렬merge-sort>#</a></h4><p>병합 정렬은 분할 정복 알고리즘의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례: 리스트의 길이가 1 이하면 이미 정렬된 것으로 간주</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계: 배열을 두 부분으로 나눔</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정복 단계: 재귀적으로 각 부분을 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결합 단계: 정렬된 두 부분을 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 리스트의 요소를 비교하여 작은 것부터 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들을 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li>복잡한 문제를 더 간단한 하위 문제로 나눠 효율적으로 해결할 수 있다.</li><li>많은 경우 시간 복잡도가 O(n log n)으로, 대규모 데이터 세트에서 효율적.</li><li>병렬 처리에 적합.</li></ul><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li>재귀 호출로 인한 추가 메모리 사용이 발생.</li><li>간단한 문제에 적용할 경우 오버헤드가 발생할 수 있다.</li><li>구현이 상대적으로 복잡할 수 있다.</li></ul><h3 id=brute-force무차별-대입-알고리즘>Brute Force(무차별 대입) 알고리즘<a hidden class=anchor aria-hidden=true href=#brute-force무차별-대입-알고리즘>#</a></h3><h4 id=기본-개념-1>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념-1>#</a></h4><p>브루트 포스는 가능한 모든 경우를 철저히 검사하여 문제를 해결하는 방법.<br>간단하고 직관적이지만, 대체로 효율성은 떨어진다.</p><h4 id=작동-원리-예시-선형-검색linear-search>작동 원리 예시: 선형 검색(Linear Search)<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-선형-검색linear-search>#</a></h4><p>선형 검색은 브루트 포스 알고리즘의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>linear_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 배열의 모든 요소를 순차적으로 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 요소가 찾는 값과 일치하면 해당 인덱스 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 없으면 -1 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h4><ul><li>구현이 매우 간단하고 직관적.</li><li>소규모 데이터 세트나 간단한 문제에서는 효율적일 수 있다.</li><li>항상 정확한 해답을 찾을 수 있다.</li></ul><h4 id=단점-1>단점<a hidden class=anchor aria-hidden=true href=#단점-1>#</a></h4><ul><li>대규모 데이터 세트에서는 매우 비효율적일 수 있다.</li><li>시간 복잡도가 일반적으로 O(n) 또는 그 이상으로 높다.</li><li>복잡한 문제에서는 실행 시간이 기하급수적으로 증가할 수 있다.</li></ul><h3 id=실제-적용-사례>실제 적용 사례<a hidden class=anchor aria-hidden=true href=#실제-적용-사례>#</a></h3><h4 id=divide-and-conquer-적용-사례>Divide and Conquer 적용 사례<a hidden class=anchor aria-hidden=true href=#divide-and-conquer-적용-사례>#</a></h4><ol><li><strong>퀵 정렬(Quick Sort)</strong>: 배열을 피벗을 기준으로 분할하여 정렬.</li><li><strong>이진 검색(Binary Search)</strong>: 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄여가며 찾는다.</li><li><strong>최대 부분 배열 문제(Maximum Subarray Problem)</strong>: 배열을 분할하여 최대 합을 가진 부분 배열을 찾는다.</li><li><strong>행렬 곱셈의 스트라센 알고리즘(Strassen Algorithm)</strong>: 행렬을 분할하여 곱셈을 효율적으로 수행한다.</li></ol><h4 id=brute-force-적용-사례>Brute Force 적용 사례<a hidden class=anchor aria-hidden=true href=#brute-force-적용-사례>#</a></h4><ol><li><strong>암호 해독</strong>: 가능한 모든 키를 시도하여 암호를 해독한다.</li><li><strong>부분 문자열 검색</strong>: 문자열 내에서 패턴을 찾기 위해 모든 위치를 확인한다.</li><li><strong>여행자 문제(Traveling Salesman Problem)의 직접 접근법</strong>: 모든 가능한 경로를 확인한다.</li><li><strong>최단 경로 찾기(단순한 경우)</strong>: 모든 가능한 경로를 계산하여 최단 경로를 찾는다.</li></ol><h3 id=초보-개발자를-위한-선택-가이드>초보 개발자를 위한 선택 가이드<a hidden class=anchor aria-hidden=true href=#초보-개발자를-위한-선택-가이드>#</a></h3><ol><li><strong>문제의 규모를 고려한다</strong>:<ul><li>작은 규모의 문제나 데이터 세트: Brute Force가 더 간단하고 효과적일 수 있다.</li><li>큰 규모의 문제나 데이터 세트: Divide and Conquer가 더 효율적.</li></ul></li><li><strong>시간과 공간 제약을 고려하세요</strong>:<ul><li>시간이 제한적인 경우: Divide and Conquer가 일반적으로 더 빠르다.</li><li>메모리가 제한적인 경우: Brute Force가 더 적은 메모리를 사용할 수 있다.</li></ul></li><li><strong>문제의 복잡성을 고려하세요</strong>:<ul><li>간단한 문제: Brute Force로 시작하고, 필요에 따라 최적화한다.</li><li>복잡한 문제: Divide and Conquer가 더 관리하기 쉬운 해결책을 제공할 수 있다.</li></ul></li></ol><h3 id=비교>비교<a hidden class=anchor aria-hidden=true href=#비교>#</a></h3><table><thead><tr><th>특성</th><th>Divide and Conquer</th><th>Brute Force</th></tr></thead><tbody><tr><td><strong>기본 원리</strong></td><td>문제를 작은 하위 문제로 분할하여 해결</td><td>가능한 모든 경우를 철저히 검사</td></tr><tr><td><strong>효율성</strong></td><td>일반적으로 더 효율적(O(n log n) 등)</td><td>일반적으로 덜 효율적(O(n), O(n²) 등)</td></tr><tr><td><strong>메모리 사용</strong></td><td>재귀 호출로 인한 추가 메모리 필요</td><td>일반적으로 더 적은 메모리 사용</td></tr><tr><td><strong>구현 복잡성</strong></td><td>상대적으로 복잡함</td><td>매우 간단하고 직관적</td></tr><tr><td><strong>대표적인 알고리즘</strong></td><td>병합 정렬, 퀵 정렬, 이진 검색</td><td>선형 검색, 버블 정렬, 순차적 문자열 매칭</td></tr><tr><td><strong>적합한 상황</strong></td><td>대규모 데이터, 복잡한 문제</td><td>소규모 데이터, 간단한 문제, 완전한 해결책 필요 시</td></tr><tr><td><strong>병렬 처리 적합성</strong></td><td>높음</td><td>낮음</td></tr><tr><td><strong>시간 복잡도 예시</strong></td><td>병합 정렬: O(n log n)</td><td>버블 정렬: O(n²)</td></tr><tr><td><strong>특징</strong></td><td>재귀적 접근, 분할과 결합 과정</td><td>직접적이고 철저한 검사</td></tr><tr><td><strong>코드 가독성</strong></td><td>중간</td><td>높음</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/divide-and-conquer/>Divide-and-Conquer</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/long-polling/><span class=title>« Prev</span><br><span>Long Polling</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/><span class=title>Next »</span><br><span>Divide and Conquer vs. Branch and Bound</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>