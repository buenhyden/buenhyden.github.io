<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Greedy Algorithm vs. Divide and Conquer | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Greedy-Algorithm"><meta name=description content="분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Greedy Algorithm vs. Divide and Conquer"><meta property="og:description" content="분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-28T10:55:00+00:00"><meta property="article:modified_time" content="2024-12-28T10:55:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Greedy-Algorithm"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Greedy Algorithm vs. Divide and Conquer"><meta name=twitter:description content="분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/"},{"@type":"ListItem","position":4,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":5,"name":"탐욕 알고리즘 (Greedy Algorithm)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/"},{"@type":"ListItem","position":6,"name":"Greedy Algorithm vs. Divide and Conquer","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Greedy Algorithm vs. Divide and Conquer","name":"Greedy Algorithm vs. Divide and Conquer","description":"분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Greedy-Algorithm"],"articleBody":"Divide and Conquer vs. Greedy Algorithm “Divide and Conquer\"와 “Greedy Algorithm\"은 문제 해결을 위한 두 가지 중요한 알고리즘 패러다임이다.\n분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.\n분할 정복은 정확한 최적해를 보장하지만 구현이 복잡할 수 있고, 탐욕 알고리즘은 구현이 간단하고 효율적이지만 항상 최적해를 보장하지는 않는다. 문제의 특성을 잘 이해하고 적절한 알고리즘을 선택하는 것이 중요하다.\nDivide and Conquer(분할 정복) 알고리즘 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.\n이 알고리즘은 다음과 같은 세 단계로 구성된다:\n분할(Divide): 원래 문제를 더 작은 하위 문제들로 나눈다. 정복(Conquer): 각 하위 문제를 재귀적으로 해결한다. 결합(Combine): 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다. 대규모 프로젝트 관리와 유사하다. 큰 프로젝트(문제)를 여러 팀에 나누어 할당(분할)하고, 각 팀이 자신의 과제를 해결(정복)한 다음, 모든 결과를 통합(결합)하여 전체 프로젝트를 완성한다.\n작동 원리 예시: 병합 정렬(Merge Sort) 병합 정렬은 분할 정복의 대표적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def merge_sort(arr): # 기본 사례: 배열의 길이가 1 이하면 이미 정렬된 것으로 간주 if len(arr) \u003c= 1: return arr # 분할 단계: 배열을 두 부분으로 나눔 mid = len(arr) // 2 left = arr[:mid] right = arr[mid:] # 정복 단계: 재귀적으로 각 부분을 정렬 left = merge_sort(left) right = merge_sort(right) # 결합 단계: 정렬된 두 부분을 병합 return merge(left, right) def merge(left, right): result = [] i = j = 0 # 두 리스트의 요소를 비교하여 작은 것부터 결과에 추가 while i \u003c len(left) and j \u003c len(right): if left[i] \u003c right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # 남은 요소들을 결과에 추가 result.extend(left[i:]) result.extend(right[j:]) return result 이 알고리즘은 배열을 절반씩 나누어(분할) 각 부분을 재귀적으로 정렬(정복)한 다음, 정렬된 두 부분을 하나로 병합(결합)한다.\nGreedy Algorithm(탐욕 알고리즘) 탐욕 알고리즘은 각 단계에서 현재 상황에서 가장 최적인 선택(지역적 최적해)을 선택하여 최종적으로 전체 문제의 최적해를 찾는 방법이다.\n이 알고리즘은 다음과 같은 특징을 가진다:\n지역적 최적 선택(Local Optimal Choice): 각 단계에서 현재 상황에서 최선의 선택을 한다. 탐욕적 선택 속성(Greedy Choice Property): 지역적 최적 선택이 전체 문제의 최적해로 이어진다. 최적 부분 구조(Optimal Substructure): 문제의 최적해가 하위 문제의 최적해를 포함한다. 등산을 할 때 매 순간 가장 가파른 경로를 선택하는 것과 유사하다(이를 ‘언덕 오르기’라고도 합니다). 각 지점에서 가장 높이 올라갈 수 있는 방향(지역적 최적)을 선택하여 산 정상(전체 최적)에 도달하려고 한다.\n하지만 이 방법이 항상 정상에 도달하는 것을 보장하지는 않으며, 지역적 정상에 갇힐 수 있다.\n작동 원리 예시: 거스름돈 문제 거스름돈 문제는 탐욕 알고리즘의 대표적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def coin_change_greedy(amount, coins): # 동전을 내림차순으로 정렬 coins.sort(reverse=True) result = [] # 사용할 동전 목록 for coin in coins: # 현재 동전을 최대한 많이 사용 while amount \u003e= coin: amount -= coin result.append(coin) return result # 예시: 한국 화폐 단위로 거스름돈 계산 amount = 1260 coins = [500, 100, 50, 10] print(coin_change_greedy(amount, coins)) # [500, 500, 100, 100, 50, 10] 이 알고리즘은 매 단계에서 가장 큰 단위의 동전부터 사용하여(탐욕적 선택) 최소한의 동전으로 거스름돈을 만든다.\n두 알고리즘의 핵심 차이점 문제 해결 접근 방식\n분할 정복: 문제를 더 작은 하위 문제로 나누어 각각 해결한 후 결합한다. 탐욕 알고리즘: 각 단계에서 현재 상황에서 최선의 선택을 하여 문제를 해결한다. 결정 방식\n분할 정복: 전체 문제를 고려하여 하위 문제로 분할하고, 모든 하위 문제의 해결책을 종합적으로 고려한다. 탐욕 알고리즘: 매 단계에서 지역적 최적 선택만을 고려하며, 이전 결정을 수정하지 않는다. 최적해 보장\n분할 정복: 모든 경우를 고려하므로 일반적으로 최적해를 보장한다. 탐욕 알고리즘: 모든 문제에서 최적해를 보장하지는 않으며, 특정 조건(탐욕적 선택 속성, 최적 부분 구조)을 만족해야 한다. 예시로 보는 차이: 배낭 문제(Knapsack Problem)\n배낭 문제는 두 알고리즘의 차이를 잘 보여주는 예이다:\n일반적인 배낭 문제: 여러 물건의 가치와 무게가 있을 때, 제한된 무게 내에서 최대 가치를 선택하는 문제 분할 가능한 배낭 문제: 물건을 부분적으로 선택할 수 있는 경우\n분할 정복 접근: 모든 가능한 물건의 조합을 고려하여 최적해를 찾습니다. 이는 물건의 수가 많을 때 비효율적이다.\n탐욕 알고리즘 접근: 단위 무게당 가치가 높은 물건부터 선택한다. 이 방법은 분할 가능한 배낭 문제에서는 최적해를 보장하지만, 일반 배낭 문제에서는 최적해를 보장하지 않는다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 분할 가능한 배낭 문제의 탐욕 알고리즘 해결법 def fractional_knapsack(capacity, weights, values): # 각 물건의 단위 무게당 가치 계산 items = [(values[i] / weights[i], weights[i], values[i]) for i in range(len(weights))] # 단위 무게당 가치를 기준으로 내림차순 정렬 items.sort(reverse=True) total_value = 0 for unit_value, weight, value in items: if capacity \u003e= weight: # 물건 전체를 선택 total_value += value capacity -= weight else: # 물건의 일부만 선택 total_value += unit_value * capacity break return total_value 실제 적용 사례 Divide and Conquer 적용 사례 퀵 정렬(Quick Sort): 배열을 피벗을 기준으로 분할하여 정렬 이진 검색(Binary Search): 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄임 최대 부분 배열 문제(Maximum Subarray Problem): 배열을 분할하여 최대 합을 가진 부분 배열을 찾음 스트라센 알고리즘(Strassen’s Algorithm): 행렬 곱셈을 효율적으로 수행 Greedy Algorithm 적용 사례 최소 신장 트리(Minimum Spanning Tree): 크루스칼(Kruskal), 프림(Prim) 알고리즘 다익스트라 알고리즘(Dijkstra’s Algorithm): 최단 경로 찾기 허프만 코딩(Huffman Coding): 데이터 압축 작업 스케줄링(Job Scheduling): 가장 짧은 작업부터 처리하는 방식 코드 비교: 동전 개수 최소화 문제 가능한 동전 종류가 주어졌을 때, 특정 금액을 만들기 위한 최소 동전 개수를 구하는 문제.\n분할 정복 접근법 (실제로는 동적 계획법이 더 적합)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def min_coins_dc(coins, amount): # 모든 가능한 경우를 고려 if amount == 0: return 0 result = float('inf') for coin in coins: if coin \u003c= amount: sub_result = min_coins_dc(coins, amount - coin) if sub_result != float('inf'): result = min(result, sub_result + 1) return result 탐욕 알고리즘 접근법\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def min_coins_greedy(coins, amount): # 동전을 내림차순으로 정렬 coins.sort(reverse=True) count = 0 for coin in coins: # 현재 동전을 최대한 많이 사용 while amount \u003e= coin: amount -= coin count += 1 # 모든 동전을 사용해도 금액을 만들 수 없는 경우 if amount \u003e 0: return -1 return count 여기서 주목할 점은 탐욕 알고리즘이 항상 최적해를 보장하지 않는다는 것.\n예를 들어, 동전 종류가 [1, 3, 4]이고 금액이 6인 경우:\n탐욕 알고리즘: 4 + 1 + 1 = 3개의 동전 사용 최적해: 3 + 3 = 2개의 동전 사용 선택 가이드 Divide and Conquer를 선택해야 할 때 문제가 동일한 구조의 더 작은 하위 문제로 자연스럽게 나눠질 때 문제의 크기가 크고 분할하여 해결할 수 있을 때 정확한 최적해가 필요할 때 병렬 처리가 가능하거나 필요할 때 전체 탐색 공간을 효율적으로 줄일 수 있을 때 Greedy Algorithm을 선택해야 할 때 각 단계에서의 최선의 선택이 전체 문제의 최적해로 이어질 때 빠른 실행 시간이 중요할 때 문제의 크기가 크고 모든 경우를 고려하기 어려울 때 근사 해답이 허용될 때(최적이 아니더라도 충분히 좋은 해답) 문제가 최적 부분 구조와 탐욕적 선택 속성을 가질 때 문제 접근 방법 문제 분석: 문제의 구조와 특성을 파악합니다. 문제가 더 작은 하위 문제로 나눠질 수 있는지 지역적 최적 선택이 전체 최적해로 이어지는지 알고리즘 선택: 문제가 분할 정복의 구조를 가지고 있으면 → 분할 정복 문제가 탐욕적 선택 속성과 최적 부분 구조를 가지고 있으면 → 탐욕 알고리즘 검증: 분할 정복: 하위 문제들이 올바르게 정의되었는지, 결합 방법이 적절한지 확인 탐욕 알고리즘: 선택한 탐욕적 전략이 항상 최적해를 보장하는지 증명하거나 검증 응용 예제: 최소 신장 트리(MST) 구현 최소 신장 트리 문제는 주어진 그래프에서 모든 정점을 포함하면서 간선의 가중치 합이 최소인 트리를 찾는 문제.\n이 문제는 탐욕 알고리즘인 크루스칼 알고리즘으로 효율적으로 해결할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 크루스칼 알고리즘을 이용한 최소 신장 트리 구현 def kruskal_mst(graph, vertices): # 결과를 저장할 리스트 result = [] # 간선을 가중치 기준으로 오름차순 정렬 edges = sorted(graph, key=lambda x: x[2]) # 각 정점의 부모를 자기 자신으로 초기화 parent = [i for i in range(vertices)] # 두 정점이 속한 집합 찾기 (Find 연산) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] # 두 집합 합치기 (Union 연산) def union(x, y): parent[find(x)] = find(y) i, e = 0, 0 # MST는 (정점 수 - 1)개의 간선을 가짐 while e \u003c vertices - 1: u, v, w = edges[i] i += 1 # 사이클을 형성하는지 확인 x = find(u) y = find(v) if x != y: # 사이클이 형성되지 않으면 간선 추가 e += 1 result.append([u, v, w]) union(x, y) return result # 예시 graph = [ [0, 1, 10], # [시작 정점, 도착 정점, 가중치] [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4] ] vertices = 4 mst = kruskal_mst(graph, vertices) print(\"최소 신장 트리의 간선:\", mst) 이 크루스칼 알고리즘은 탐욕적 접근을 사용한다:\n모든 간선을 가중치 순으로 정렬합니다. 가중치가 가장 작은 간선부터 선택합니다(탐욕적 선택). 사이클을 형성하지 않는 간선만 추가합니다. 두 알고리즘 비교 특성 Divide and Conquer Greedy Algorithm 기본 원리 문제를 작은 하위 문제로 분할하여 해결 각 단계에서 지역적 최적 선택을 통해 해결 접근 방식 재귀적, 하향식(top-down) 반복적, 순차적, 상향식(bottom-up) 문제 해결 순서 분할 → 정복 → 결합 선택 → 실행 → 다음 단계로 이동 최적해 보장 일반적으로 보장 조건을 만족할 때만 보장(탐욕적 선택 속성, 최적 부분 구조) 결정 철회 가능성 전체 결과를 고려하므로 가능 한번 내린 결정은 번복하지 않음 적용 조건 문제가 분할 가능할 때 지역적 최적해가 전체 최적해로 이어질 때 시간 복잡도 일반적으로 O(n log n) (예: 병합 정렬) 일반적으로 O(n) 또는 O(n log n) 구현 복잡성 중간~높음 (재귀 구현) 낮음~중간 (직관적인 구현) 메모리 사용 재귀 호출 스택으로 인해 높을 수 있음 일반적으로 낮음 대표 알고리즘 병합 정렬, 퀵 정렬, 이진 검색 다익스트라, 크루스칼, 허프만 코딩 재귀 사용 필수적 선택적(주로 반복문 사용) 적합한 문제 유형 정렬, 검색, 행렬 연산 등 최적화 문제, 스케줄링, 경로 찾기 등 결정 기준 문제의 구조에 따른 분할 휴리스틱이나 평가 함수(가중치, 비용 등) 장점 복잡한 문제를 체계적으로 해결, 병렬 처리 가능 구현이 간단하고 효율적, 빠른 실행 시간 단점 재귀로 인한 오버헤드, 구현 복잡성 항상 최적해를 보장하지 않음 기억해야 할 핵심 포인트 “분할, 정복, 결합” “현재 최선의 선택” 참고 및 출처 ","wordCount":"1677","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-28T10:55:00Z","dateModified":"2024-12-28T10:55:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/>탐욕 알고리즘 (Greedy Algorithm)</a></div><h1 class="post-title entry-hint-parent">Greedy Algorithm vs. Divide and Conquer</h1><div class=post-description>분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.</div><div class=post-meta><span title='2024-12-28 10:55:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Greedy%20Algorithm/greedy-algorithm-vs-divide-and-conquer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#divide-and-conquer-vs-greedy-algorithm>Divide and Conquer vs. Greedy Algorithm</a><ul><li><a href=#divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘</a></li><li><a href=#greedy-algorithm탐욕-알고리즘>Greedy Algorithm(탐욕 알고리즘)</a></li><li><a href=#두-알고리즘의-핵심-차이점>두 알고리즘의 핵심 차이점</a></li><li><a href=#실제-적용-사례>실제 적용 사례</a></li><li><a href=#코드-비교-동전-개수-최소화-문제>코드 비교: 동전 개수 최소화 문제</a></li><li><a href=#선택-가이드>선택 가이드</a></li><li><a href=#응용-예제-최소-신장-트리mst-구현>응용 예제: 최소 신장 트리(MST) 구현</a></li><li><a href=#두-알고리즘-비교>두 알고리즘 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=divide-and-conquer-vs-greedy-algorithm>Divide and Conquer vs. Greedy Algorithm<a hidden class=anchor aria-hidden=true href=#divide-and-conquer-vs-greedy-algorithm>#</a></h2><p>&ldquo;Divide and Conquer"와 &ldquo;Greedy Algorithm"은 문제 해결을 위한 두 가지 중요한 알고리즘 패러다임이다.<br>분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.</p><p>분할 정복은 정확한 최적해를 보장하지만 구현이 복잡할 수 있고, 탐욕 알고리즘은 구현이 간단하고 효율적이지만 항상 최적해를 보장하지는 않는다. 문제의 특성을 잘 이해하고 적절한 알고리즘을 선택하는 것이 중요하다.</p><h3 id=divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘<a hidden class=anchor aria-hidden=true href=#divide-and-conquer분할-정복-알고리즘>#</a></h3><p>분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.<br>이 알고리즘은 다음과 같은 세 단계로 구성된다:</p><ol><li><strong>분할(Divide)</strong>: 원래 문제를 더 작은 하위 문제들로 나눈다.</li><li><strong>정복(Conquer)</strong>: 각 하위 문제를 재귀적으로 해결한다.</li><li><strong>결합(Combine)</strong>: 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다.</li></ol><p>대규모 프로젝트 관리와 유사하다. 큰 프로젝트(문제)를 여러 팀에 나누어 할당(분할)하고, 각 팀이 자신의 과제를 해결(정복)한 다음, 모든 결과를 통합(결합)하여 전체 프로젝트를 완성한다.</p><h4 id=작동-원리-예시-병합-정렬merge-sort>작동 원리 예시: 병합 정렬(Merge Sort)<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-병합-정렬merge-sort>#</a></h4><p>병합 정렬은 분할 정복의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례: 배열의 길이가 1 이하면 이미 정렬된 것으로 간주</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계: 배열을 두 부분으로 나눔</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정복 단계: 재귀적으로 각 부분을 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결합 단계: 정렬된 두 부분을 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 리스트의 요소를 비교하여 작은 것부터 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들을 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 배열을 절반씩 나누어(분할) 각 부분을 재귀적으로 정렬(정복)한 다음, 정렬된 두 부분을 하나로 병합(결합)한다.</p><h3 id=greedy-algorithm탐욕-알고리즘>Greedy Algorithm(탐욕 알고리즘)<a hidden class=anchor aria-hidden=true href=#greedy-algorithm탐욕-알고리즘>#</a></h3><p>탐욕 알고리즘은 각 단계에서 현재 상황에서 가장 최적인 선택(지역적 최적해)을 선택하여 최종적으로 전체 문제의 최적해를 찾는 방법이다.<br>이 알고리즘은 다음과 같은 특징을 가진다:</p><ol><li><strong>지역적 최적 선택(Local Optimal Choice)</strong>: 각 단계에서 현재 상황에서 최선의 선택을 한다.</li><li><strong>탐욕적 선택 속성(Greedy Choice Property)</strong>: 지역적 최적 선택이 전체 문제의 최적해로 이어진다.</li><li><strong>최적 부분 구조(Optimal Substructure)</strong>: 문제의 최적해가 하위 문제의 최적해를 포함한다.</li></ol><p>등산을 할 때 매 순간 가장 가파른 경로를 선택하는 것과 유사하다(이를 &lsquo;언덕 오르기&rsquo;라고도 합니다). 각 지점에서 가장 높이 올라갈 수 있는 방향(지역적 최적)을 선택하여 산 정상(전체 최적)에 도달하려고 한다.<br>하지만 이 방법이 항상 정상에 도달하는 것을 보장하지는 않으며, 지역적 정상에 갇힐 수 있다.</p><h4 id=작동-원리-예시-거스름돈-문제>작동 원리 예시: 거스름돈 문제<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-거스름돈-문제>#</a></h4><p>거스름돈 문제는 탐욕 알고리즘의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>coin_change_greedy</span><span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>coins</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 동전을 내림차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>coins</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 사용할 동전 목록</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 동전을 최대한 많이 사용</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>amount</span> <span class=o>&gt;=</span> <span class=n>coin</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>amount</span> <span class=o>-=</span> <span class=n>coin</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>coin</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시: 한국 화폐 단위로 거스름돈 계산</span>
</span></span><span class=line><span class=cl><span class=n>amount</span> <span class=o>=</span> <span class=mi>1260</span>
</span></span><span class=line><span class=cl><span class=n>coins</span> <span class=o>=</span> <span class=p>[</span><span class=mi>500</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>10</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>coin_change_greedy</span><span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>coins</span><span class=p>))</span>  <span class=c1># [500, 500, 100, 100, 50, 10]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 매 단계에서 가장 큰 단위의 동전부터 사용하여(탐욕적 선택) 최소한의 동전으로 거스름돈을 만든다.</p><h3 id=두-알고리즘의-핵심-차이점>두 알고리즘의 핵심 차이점<a hidden class=anchor aria-hidden=true href=#두-알고리즘의-핵심-차이점>#</a></h3><ol><li><p>문제 해결 접근 방식</p><ul><li><strong>분할 정복</strong>: 문제를 더 작은 하위 문제로 나누어 각각 해결한 후 결합한다.</li><li><strong>탐욕 알고리즘</strong>: 각 단계에서 현재 상황에서 최선의 선택을 하여 문제를 해결한다.</li></ul></li><li><p>결정 방식</p><ul><li><strong>분할 정복</strong>: 전체 문제를 고려하여 하위 문제로 분할하고, 모든 하위 문제의 해결책을 종합적으로 고려한다.</li><li><strong>탐욕 알고리즘</strong>: 매 단계에서 지역적 최적 선택만을 고려하며, 이전 결정을 수정하지 않는다.</li></ul></li><li><p>최적해 보장</p><ul><li><strong>분할 정복</strong>: 모든 경우를 고려하므로 일반적으로 최적해를 보장한다.</li><li><strong>탐욕 알고리즘</strong>: 모든 문제에서 최적해를 보장하지는 않으며, 특정 조건(탐욕적 선택 속성, 최적 부분 구조)을 만족해야 한다.</li></ul></li><li><p>예시로 보는 차이: 배낭 문제(Knapsack Problem)<br>배낭 문제는 두 알고리즘의 차이를 잘 보여주는 예이다:</p><ul><li>일반적인 배낭 문제: 여러 물건의 가치와 무게가 있을 때, 제한된 무게 내에서 최대 가치를 선택하는 문제</li><li>분할 가능한 배낭 문제: 물건을 부분적으로 선택할 수 있는 경우<br><strong>분할 정복 접근</strong>: 모든 가능한 물건의 조합을 고려하여 최적해를 찾습니다. 이는 물건의 수가 많을 때 비효율적이다.<br><strong>탐욕 알고리즘 접근</strong>: 단위 무게당 가치가 높은 물건부터 선택한다. 이 방법은 분할 가능한 배낭 문제에서는 최적해를 보장하지만, 일반 배낭 문제에서는 최적해를 보장하지 않는다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 분할 가능한 배낭 문제의 탐욕 알고리즘 해결법</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fractional_knapsack</span><span class=p>(</span><span class=n>capacity</span><span class=p>,</span> <span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 각 물건의 단위 무게당 가치 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span> <span class=o>=</span> <span class=p>[(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>/</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>])</span> 
</span></span><span class=line><span class=cl>             <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>))]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 단위 무게당 가치를 기준으로 내림차순 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>total_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>unit_value</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span> <span class=ow>in</span> <span class=n>items</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>capacity</span> <span class=o>&gt;=</span> <span class=n>weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 물건 전체를 선택</span>
</span></span><span class=line><span class=cl>            <span class=n>total_value</span> <span class=o>+=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>capacity</span> <span class=o>-=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 물건의 일부만 선택</span>
</span></span><span class=line><span class=cl>            <span class=n>total_value</span> <span class=o>+=</span> <span class=n>unit_value</span> <span class=o>*</span> <span class=n>capacity</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_value</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=실제-적용-사례>실제 적용 사례<a hidden class=anchor aria-hidden=true href=#실제-적용-사례>#</a></h3><ul><li>Divide and Conquer 적용 사례<ol><li><strong>퀵 정렬(Quick Sort)</strong>: 배열을 피벗을 기준으로 분할하여 정렬</li><li><strong>이진 검색(Binary Search)</strong>: 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄임</li><li><strong>최대 부분 배열 문제(Maximum Subarray Problem)</strong>: 배열을 분할하여 최대 합을 가진 부분 배열을 찾음</li><li><strong>스트라센 알고리즘(Strassen&rsquo;s Algorithm)</strong>: 행렬 곱셈을 효율적으로 수행</li></ol></li><li>Greedy Algorithm 적용 사례<ol><li><strong>최소 신장 트리(Minimum Spanning Tree)</strong>: 크루스칼(Kruskal), 프림(Prim) 알고리즘</li><li><strong>다익스트라 알고리즘(Dijkstra&rsquo;s Algorithm)</strong>: 최단 경로 찾기</li><li><strong>허프만 코딩(Huffman Coding)</strong>: 데이터 압축</li><li><strong>작업 스케줄링(Job Scheduling)</strong>: 가장 짧은 작업부터 처리하는 방식</li></ol></li></ul><h3 id=코드-비교-동전-개수-최소화-문제>코드 비교: 동전 개수 최소화 문제<a hidden class=anchor aria-hidden=true href=#코드-비교-동전-개수-최소화-문제>#</a></h3><p>가능한 동전 종류가 주어졌을 때, 특정 금액을 만들기 위한 최소 동전 개수를 구하는 문제.</p><ul><li><p>분할 정복 접근법 (실제로는 동적 계획법이 더 적합)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_coins_dc</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 경우를 고려</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>amount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>coin</span> <span class=o>&lt;=</span> <span class=n>amount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>sub_result</span> <span class=o>=</span> <span class=n>min_coins_dc</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span> <span class=o>-</span> <span class=n>coin</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>sub_result</span> <span class=o>!=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>sub_result</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>탐욕 알고리즘 접근법</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_coins_greedy</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 동전을 내림차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>coins</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 동전을 최대한 많이 사용</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>amount</span> <span class=o>&gt;=</span> <span class=n>coin</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>amount</span> <span class=o>-=</span> <span class=n>coin</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 동전을 사용해도 금액을 만들 수 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>amount</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span>
</span></span></code></pre></td></tr></table></div></div><p>여기서 주목할 점은 탐욕 알고리즘이 항상 최적해를 보장하지 않는다는 것.<br>예를 들어, 동전 종류가 [1, 3, 4]이고 금액이 6인 경우:</p><ul><li>탐욕 알고리즘: 4 + 1 + 1 = 3개의 동전 사용</li><li>최적해: 3 + 3 = 2개의 동전 사용</li></ul></li></ul><h3 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h3><ul><li>Divide and Conquer를 선택해야 할 때<ul><li>문제가 동일한 구조의 더 작은 하위 문제로 자연스럽게 나눠질 때</li><li>문제의 크기가 크고 분할하여 해결할 수 있을 때</li><li>정확한 최적해가 필요할 때</li><li>병렬 처리가 가능하거나 필요할 때</li><li>전체 탐색 공간을 효율적으로 줄일 수 있을 때</li></ul></li><li>Greedy Algorithm을 선택해야 할 때<ul><li>각 단계에서의 최선의 선택이 전체 문제의 최적해로 이어질 때</li><li>빠른 실행 시간이 중요할 때</li><li>문제의 크기가 크고 모든 경우를 고려하기 어려울 때</li><li>근사 해답이 허용될 때(최적이 아니더라도 충분히 좋은 해답)</li><li>문제가 최적 부분 구조와 탐욕적 선택 속성을 가질 때</li></ul></li><li>문제 접근 방법<ol><li><strong>문제 분석</strong>: 문제의 구조와 특성을 파악합니다.<ul><li>문제가 더 작은 하위 문제로 나눠질 수 있는지</li><li>지역적 최적 선택이 전체 최적해로 이어지는지</li></ul></li><li><strong>알고리즘 선택</strong>:<ul><li>문제가 분할 정복의 구조를 가지고 있으면 → 분할 정복</li><li>문제가 탐욕적 선택 속성과 최적 부분 구조를 가지고 있으면 → 탐욕 알고리즘</li></ul></li><li><strong>검증</strong>:<ul><li>분할 정복: 하위 문제들이 올바르게 정의되었는지, 결합 방법이 적절한지 확인</li><li>탐욕 알고리즘: 선택한 탐욕적 전략이 항상 최적해를 보장하는지 증명하거나 검증</li></ul></li></ol></li></ul><h3 id=응용-예제-최소-신장-트리mst-구현>응용 예제: 최소 신장 트리(MST) 구현<a hidden class=anchor aria-hidden=true href=#응용-예제-최소-신장-트리mst-구현>#</a></h3><p>최소 신장 트리 문제는 주어진 그래프에서 모든 정점을 포함하면서 간선의 가중치 합이 최소인 트리를 찾는 문제.<br>이 문제는 탐욕 알고리즘인 크루스칼 알고리즘으로 효율적으로 해결할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span><span class=lnt id=hl-5-33><a class=lnlinks href=#hl-5-33>33</a>
</span><span class=lnt id=hl-5-34><a class=lnlinks href=#hl-5-34>34</a>
</span><span class=lnt id=hl-5-35><a class=lnlinks href=#hl-5-35>35</a>
</span><span class=lnt id=hl-5-36><a class=lnlinks href=#hl-5-36>36</a>
</span><span class=lnt id=hl-5-37><a class=lnlinks href=#hl-5-37>37</a>
</span><span class=lnt id=hl-5-38><a class=lnlinks href=#hl-5-38>38</a>
</span><span class=lnt id=hl-5-39><a class=lnlinks href=#hl-5-39>39</a>
</span><span class=lnt id=hl-5-40><a class=lnlinks href=#hl-5-40>40</a>
</span><span class=lnt id=hl-5-41><a class=lnlinks href=#hl-5-41>41</a>
</span><span class=lnt id=hl-5-42><a class=lnlinks href=#hl-5-42>42</a>
</span><span class=lnt id=hl-5-43><a class=lnlinks href=#hl-5-43>43</a>
</span><span class=lnt id=hl-5-44><a class=lnlinks href=#hl-5-44>44</a>
</span><span class=lnt id=hl-5-45><a class=lnlinks href=#hl-5-45>45</a>
</span><span class=lnt id=hl-5-46><a class=lnlinks href=#hl-5-46>46</a>
</span><span class=lnt id=hl-5-47><a class=lnlinks href=#hl-5-47>47</a>
</span><span class=lnt id=hl-5-48><a class=lnlinks href=#hl-5-48>48</a>
</span><span class=lnt id=hl-5-49><a class=lnlinks href=#hl-5-49>49</a>
</span><span class=lnt id=hl-5-50><a class=lnlinks href=#hl-5-50>50</a>
</span><span class=lnt id=hl-5-51><a class=lnlinks href=#hl-5-51>51</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 크루스칼 알고리즘을 이용한 최소 신장 트리 구현</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>kruskal_mst</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 결과를 저장할 리스트</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 간선을 가중치 기준으로 오름차순 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 정점의 부모를 자기 자신으로 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>parent</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>vertices</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 정점이 속한 집합 찾기 (Find 연산)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>!=</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 집합 합치기 (Union 연산)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>[</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>)]</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>i</span><span class=p>,</span> <span class=n>e</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># MST는 (정점 수 - 1)개의 간선을 가짐</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>e</span> <span class=o>&lt;</span> <span class=n>vertices</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>w</span> <span class=o>=</span> <span class=n>edges</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 사이클을 형성하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>x</span> <span class=o>!=</span> <span class=n>y</span><span class=p>:</span>  <span class=c1># 사이클이 형성되지 않으면 간선 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>e</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>union</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>10</span><span class=p>],</span>  <span class=c1># [시작 정점, 도착 정점, 가중치]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>15</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>vertices</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mst</span> <span class=o>=</span> <span class=n>kruskal_mst</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>vertices</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;최소 신장 트리의 간선:&#34;</span><span class=p>,</span> <span class=n>mst</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 크루스칼 알고리즘은 탐욕적 접근을 사용한다:</p><ol><li>모든 간선을 가중치 순으로 정렬합니다.</li><li>가중치가 가장 작은 간선부터 선택합니다(탐욕적 선택).</li><li>사이클을 형성하지 않는 간선만 추가합니다.</li></ol><h3 id=두-알고리즘-비교>두 알고리즘 비교<a hidden class=anchor aria-hidden=true href=#두-알고리즘-비교>#</a></h3><table><thead><tr><th>특성</th><th>Divide and Conquer</th><th>Greedy Algorithm</th></tr></thead><tbody><tr><td><strong>기본 원리</strong></td><td>문제를 작은 하위 문제로 분할하여 해결</td><td>각 단계에서 지역적 최적 선택을 통해 해결</td></tr><tr><td><strong>접근 방식</strong></td><td>재귀적, 하향식(top-down)</td><td>반복적, 순차적, 상향식(bottom-up)</td></tr><tr><td><strong>문제 해결 순서</strong></td><td>분할 → 정복 → 결합</td><td>선택 → 실행 → 다음 단계로 이동</td></tr><tr><td><strong>최적해 보장</strong></td><td>일반적으로 보장</td><td>조건을 만족할 때만 보장(탐욕적 선택 속성, 최적 부분 구조)</td></tr><tr><td><strong>결정 철회 가능성</strong></td><td>전체 결과를 고려하므로 가능</td><td>한번 내린 결정은 번복하지 않음</td></tr><tr><td><strong>적용 조건</strong></td><td>문제가 분할 가능할 때</td><td>지역적 최적해가 전체 최적해로 이어질 때</td></tr><tr><td><strong>시간 복잡도</strong></td><td>일반적으로 O(n log n) (예: 병합 정렬)</td><td>일반적으로 O(n) 또는 O(n log n)</td></tr><tr><td><strong>구현 복잡성</strong></td><td>중간~높음 (재귀 구현)</td><td>낮음~중간 (직관적인 구현)</td></tr><tr><td><strong>메모리 사용</strong></td><td>재귀 호출 스택으로 인해 높을 수 있음</td><td>일반적으로 낮음</td></tr><tr><td><strong>대표 알고리즘</strong></td><td>병합 정렬, 퀵 정렬, 이진 검색</td><td>다익스트라, 크루스칼, 허프만 코딩</td></tr><tr><td><strong>재귀 사용</strong></td><td>필수적</td><td>선택적(주로 반복문 사용)</td></tr><tr><td><strong>적합한 문제 유형</strong></td><td>정렬, 검색, 행렬 연산 등</td><td>최적화 문제, 스케줄링, 경로 찾기 등</td></tr><tr><td><strong>결정 기준</strong></td><td>문제의 구조에 따른 분할</td><td>휴리스틱이나 평가 함수(가중치, 비용 등)</td></tr><tr><td><strong>장점</strong></td><td>복잡한 문제를 체계적으로 해결, 병렬 처리 가능</td><td>구현이 간단하고 효율적, 빠른 실행 시간</td></tr><tr><td><strong>단점</strong></td><td>재귀로 인한 오버헤드, 구현 복잡성</td><td>항상 최적해를 보장하지 않음</td></tr><tr><td><strong>기억해야 할 핵심 포인트</strong></td><td>&ldquo;분할, 정복, 결합&rdquo;</td><td>&ldquo;현재 최선의 선택&rdquo;</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/greedy-algorithm/>Greedy-Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/polars/><span class=title>« Prev</span><br><span>Polars</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-driven-pattern/><span class=title>Next »</span><br><span>Event-Driven Pattern</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>