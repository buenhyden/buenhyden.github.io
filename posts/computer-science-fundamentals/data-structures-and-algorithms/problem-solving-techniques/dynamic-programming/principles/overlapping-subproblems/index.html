<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>중복되는 하위 문제(Overlapping Subproblems) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Dynamic-Programming,Principles,Overlapping-Subproblems"><meta name=description content="중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="중복되는 하위 문제(Overlapping Subproblems)"><meta property="og:description" content="중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-21T14:02:00+00:00"><meta property="article:modified_time" content="2025-01-21T14:02:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Dynamic-Programming"><meta property="article:tag" content="Principles"><meta property="article:tag" content="Overlapping-Subproblems"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="중복되는 하위 문제(Overlapping Subproblems)"><meta name=twitter:description content="중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/"},{"@type":"ListItem","position":4,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":5,"name":"동적 계획법 (Dynamic Programming)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/"},{"@type":"ListItem","position":6,"name":"Principles of Dynamic Programming","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/"},{"@type":"ListItem","position":7,"name":"중복되는 하위 문제(Overlapping Subproblems)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"중복되는 하위 문제(Overlapping Subproblems)","name":"중복되는 하위 문제(Overlapping Subproblems)","description":"중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Dynamic-Programming","Principles","Overlapping-Subproblems"],"articleBody":"중복되는 하위 문제(Overlapping Subproblems) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.\n동적 계획법이 효과적으로 적용되기 위해서는 두 가지 핵심 특성이 필요하다:\n최적 부분 구조(Optimal Substructure) 중복되는 하위 문제(Overlapping Subproblems)\n이다. 중복되는 하위 문제(Overlapping Subproblems)의 기본 개념 중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.\n즉, 문제를 해결하는 과정에서 같은 계산이 여러 번 수행되는 경우이다.\n중복되는 하위 문제가 있을 때 동적 계획법은 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피함으로써 효율성을 크게 향상시킨다.\n중복되는 하위 문제의 핵심 특성 반복 계산: 동일한 입력 매개변수에 대해 같은 계산이 여러 번 수행된다. 결과 재사용 가능성: 한 번 계산된 하위 문제의 결과를 저장하고 재사용할 수 있다. 하위 문제 개수의 다항성: 문제 크기에 대해 하위 문제의 총 개수가 다항식적(polynomial)이다. 하위 문제 간 의존성: 여러 상위 문제가 동일한 하위 문제에 의존한다. 재귀적 알고리즘에서의 중복 중복되는 하위 문제는 재귀적 알고리즘에서 특히 두드러진다.\n예를 들어, 피보나치 수열의 단순 재귀 구현을 보면:\n1 2 3 4 def fibonacci(n): if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) 이 코드에서 fibonacci(n-2)는 fibonacci(n-1) 계산 과정에서도 호출되므로, 동일한 하위 문제가 중복해서 계산된다.\n예를 들어, fibonacci(5)를 계산할 때:\nfibonacci(5) → fibonacci(4) + fibonacci(3) fibonacci(4) → fibonacci(3) + fibonacci(2) fibonacci(3) → fibonacci(2) + fibonacci(1) 여기서 fibonacci(3)과 fibonacci(2)가 각각 여러 번 계산되는 것을 볼 수 있다.\n중복되는 하위 문제 식별 방법 중복되는 하위 문제를 식별하는 방법은 다음과 같다:\n재귀 트리 분석: 재귀 호출 트리를 그려보고 동일한 함수 호출이 반복되는지 확인한다. 하위 문제 정의 분석: 하위 문제가 소수의 매개변수로 완전히 정의되고, 이 매개변수가 제한된 범위를 가지는지 확인한다. 중복 횟수 측정: 간단한 테스트 케이스에서 각 하위 문제가 몇 번 호출되는지 측정한다. 중복되는 하위 문제 해결 방법 메모이제이션(Memoization) - 하향식(Top-Down) 접근 메모이제이션은 하위 문제의 결과를 저장하여 중복 계산을 피하는 기법이다.\n재귀적 접근에 저장소(주로 배열이나 해시맵)를 추가하여 구현한다.\n1 2 3 4 5 6 7 8 9 10 11 12 def fibonacci_memo(n, memo={}): # 이미 계산된 결과가 있으면 바로 반환 if n in memo: return memo[n] # 기본 사례 if n \u003c= 1: return n # 결과 계산 및 저장 memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo) return memo[n] 이 방식은 필요한 하위 문제만 계산하고 결과를 저장하여 재사용한다.\n테이블링(Tabulation) - 상향식(Bottom-Up) 접근 테이블링은 작은 하위 문제부터 시작하여 더 큰 문제를 해결하는 방식이다.\n결과를 테이블(주로 배열)에 저장하며, 재귀 호출 없이 반복문으로 구현한다.\n1 2 3 4 5 6 7 8 9 10 def fibonacci_tab(n): # DP 테이블 초기화 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 # 작은 문제부터 큰 문제까지 해결 for i in range(2, n + 1): dp[i] = dp[i-1] + dp[i-2] return dp[n] 이 방식은 모든 하위 문제를 순차적으로 해결하며, 메모리 접근 패턴이 더 효율적일 수 있다.\n두 접근 방식의 비교 특성 메모이제이션(하향식) 테이블링(상향식) 구현 방식 재귀 + 메모 저장소 반복문 + 테이블 계산 순서 필요한 하위 문제만 계산 모든 하위 문제를 순차적으로 계산 재귀 호출 있음 (스택 오버플로우 가능성) 없음 공간 효율성 필요한 하위 문제만 저장 가능 일반적으로 모든 하위 문제 저장 호출 오버헤드 재귀 호출 오버헤드 존재 오버헤드 적음 코드 가독성 일반적으로 더 직관적 때로 더 복잡할 수 있음 최적화 기회 필요 없는 하위 문제 계산 회피 메모리 최적화 용이 다양한 중복되는 하위 문제 유형 선형 의존성(Linear Dependency) 하위 문제가 일정한 간격으로 이전 하위 문제들에 의존하는 경우.\n예시: 피보나치 수열, 계단 오르기 문제\n1 2 3 4 5 6 7 8 9 10 11 12 # 계단 오르기 문제: 한 번에 1단 또는 2단씩 오를 수 있을 때, n개의 계단을 오르는 방법의 수 def climb_stairs(n): if n \u003c= 2: return n dp = [0] * (n + 1) dp[1], dp[2] = 1, 2 for i in range(3, n + 1): dp[i] = dp[i-1] + dp[i-2] # 선형 의존성 return dp[n] 구간 의존성(Range Dependency) 하위 문제가 특정 구간 내의 다른 하위 문제들에 의존하는 경우.\n예시: 행렬 곱셈 연쇄, 최적 이진 검색 트리\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 행렬 곱셈 연쇄 문제 def matrix_chain_multiplication(dims): n = len(dims) - 1 # dp[i][j] = i부터 j까지의 행렬을 곱하는 최소 연산 횟수 dp = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = float('inf') # 구간 내 모든 분할점 k에 대해 최소값 찾기 (구간 의존성) for k in range(i, j): dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + dims[i] * dims[k+1] * dims[j+1]) return dp[0][n-1] 상태 전이 의존성(State Transition Dependency) 하위 문제가 여러 이전 상태에서의 전이에 의존하는 경우.\n예시: 배낭 문제, 동전 교환 문제\n1 2 3 4 5 6 7 8 9 10 11 # 동전 교환 문제: 주어진 금액을 만들기 위한 최소 동전 개수 def coin_change(coins, amount): dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for i in range(coin, amount + 1): # 현재 금액에서 동전 값을 뺀 상태에서 전이 (상태 전이 의존성) dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1 다차원 의존성(Multi-dimensional Dependency) 하위 문제가 여러 차원의 상태에 의존하는 경우.\n예시: 최장 공통 부분 수열, 편집 거리\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 편집 거리 문제 def edit_distance(word1, word2): m, n = len(word1), len(word2) # dp[i][j] = word1[:i]와 word2[:j] 간의 편집 거리 dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # 기본 케이스: 빈 문자열로 변환 for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] # 문자가 같으면 대각선 값 사용 else: # 삽입, 삭제, 대체 중 최소값 (다차원 의존성) dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) return dp[m][n] 중복되는 하위 문제의 일반적인 예시와 분석 피보나치 수열(Fibonacci Sequence) 피보나치 수열은 중복되는 하위 문제의 가장 대표적인 예.\n분석:\nF(n) = F(n-1) + F(n-2)의 형태로 하위 문제에 의존. F(n)을 계산하기 위해 F(n-2)가 F(n-1)과 F(n-2) 양쪽에서 필요. 단순 재귀 구현의 시간 복잡도는 O(2^n)이지만, DP를 적용하면 O(n)으로 개선. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 하위 문제 중복 횟수 분석 def count_fibonacci_calls(n): count = [0] * (n + 1) def fibonacci(n): count[n] += 1 if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) fibonacci(n) return count # n=5일 때 호출 횟수: F(0):3번, F(1):5번, F(2):3번, F(3):2번, F(4):1번, F(5):1번 최장 증가 부분 수열(Longest Increasing Subsequence) 배열에서 값이 증가하는 가장 긴 부분 수열을 찾는 문제이다.\n분석:\nLIS(i)는 인덱스 i까지의 LIS 길이. LIS(i) = max(LIS(j) + 1) (j \u003c i 이고 A[j] \u003c A[i])의 형태로 하위 문제에 의존. 각 위치 i에 대해 이전의 모든 위치 j에서의 LIS 값을 참조. 1 2 3 4 5 6 7 8 9 10 11 12 13 def longest_increasing_subsequence(nums): if not nums: return 0 n = len(nums) dp = [1] * n # dp[i] = 인덱스 i까지의 LIS 길이 for i in range(1, n): for j in range(i): if nums[i] \u003e nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 배낭 문제(Knapsack Problem) 제한된 무게 내에서 최대 가치를 가지는 물건들을 선택하는 문제.\n분석:\nDP[i][w]는 처음 i개 물건으로 무게 w를 채울 때의 최대 가치이다. DP[i][w] = max(DP[i-1][w], DP[i-1][w-wᵢ] + vᵢ)의 형태로 하위 문제에 의존한다. 동일한 (i, w) 조합이 여러 경로에서 참조된다. 1 2 3 4 5 6 7 8 9 10 11 12 def knapsack_01(weights, values, capacity): n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i-1] \u003c= w: dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity] 중복되는 하위 문제의 복잡도 분석 시간 복잡도 개선 중복되는 하위 문제에 메모이제이션이나 테이블링을 적용하면 시간 복잡도를 크게 개선할 수 있다.\n문제 단순 재귀 동적 계획법 개선 비율 피보나치 수열 O(2^n) O(n) 지수적 개선 이항 계수 O(2^n) O(n²) 지수적 개선 최장 증가 부분 수열 O(2^n) O(n²) 지수적 개선 배낭 문제 O(2^n) O(n·W) 지수적 개선 편집 거리 O(3^(m+n)) O(m·n) 지수적 개선 중복 하위 문제의 수 분석 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def analyze_subproblem_calls(dp_function, n): # 하위 문제 호출 추적을 위한 래퍼 함수 call_count = {} def wrapper(*args): # 튜플로 변환하여 해시 가능하게 만듦 args_tuple = tuple(args) if args_tuple in call_count: call_count[args_tuple] += 1 else: call_count[args_tuple] = 1 return dp_function(*args) # 함수 실행 wrapper(n) # 분석 결과 total_calls = sum(call_count.values()) unique_subproblems = len(call_count) max_repetition = max(call_count.values()) return { \"total_calls\": total_calls, \"unique_subproblems\": unique_subproblems, \"max_repetition\": max_repetition, \"detailed_counts\": call_count } 공간 복잡도 분석 중복되는 하위 문제 해결을 위한 저장 공간의 크기는 하위 문제의 수에 비례합니다.\n문제 메모이제이션 공간 테이블링 공간 최적화된 공간 피보나치 수열 O(n) O(n) O(1) 최장 증가 부분 수열 O(n) O(n) O(n) 배낭 문제 O(n·W) O(n·W) O(W) 편집 거리 O(m·n) O(m·n) O(min(m,n)) 행렬 곱셈 연쇄 O(n²) O(n²) O(n²) 하위 문제 간 의존성 그래프 하위 문제 간의 의존성을 방향 그래프로 표현할 수 있다.\n노드는 하위 문제, 엣지는 의존성을 나타낸다.\n1 2 3 4 5 6 7 8 9 10 11 def build_dependency_graph(problem_size): # 예: 피보나치 수열의 의존성 그래프 graph = {} for i in range(problem_size + 1): if i \u003c= 1: graph[i] = [] # 기본 사례는 의존성 없음 else: graph[i] = [i-1, i-2] # F(i)는 F(i-1)과 F(i-2)에 의존 return graph 중복되는 하위 문제가 없는 알고리즘 모든 문제가 중복되는 하위 문제를 가지는 것은 아니다.\n다음은 중복되는 하위 문제가 없는 대표적인 알고리즘들.\n분할 정복(Divide and Conquer) 알고리즘 분할 정복 알고리즘은 문제를 더 작은 하위 문제로 나누지만, 이들 하위 문제가 중복되지 않는 경우가 많다.\n병합 정렬(Merge Sort) 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def merge_sort(arr): if len(arr) \u003c= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) # 독립적인 하위 문제 right = merge_sort(arr[mid:]) # 독립적인 하위 문제 return merge(left, right) def merge(left, right): result = [] i = j = 0 while i \u003c len(left) and j \u003c len(right): if left[i] \u003c right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result 병합 정렬에서는 배열의 서로 다른 부분을 정렬하므로, 동일한 하위 문제가 중복해서 해결되지 않는다.\n다익스트라 알고리즘(Dijkstra’s Algorithm) 다익스트라 알고리즘은 그래프에서 최단 경로를 찾는 알고리즘으로, 각 노드를 한 번씩만 방문한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import heapq def dijkstra(graph, start): distances = {node: float('inf') for node in graph} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # 이미 처리된 노드는 건너뛰기 if current_distance \u003e distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance \u003c distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances 다익스트라 알고리즘에서는 각 노드의 최단 거리를 한 번만 계산하므로 중복되는 하위 문제가 없다.\n퀵 정렬(Quick Sort) 퀵 정렬은 피벗을 기준으로 배열을 나누어 정렬하는 알고리즘으로, 하위 문제가 중복되지 않는다.\n1 2 3 4 5 6 7 8 9 10 def quick_sort(arr): if len(arr) \u003c= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x \u003c pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x \u003e pivot] return quick_sort(left) + middle + quick_sort(right) 퀵 정렬에서는 각 하위 배열이 독립적으로 정렬되므로 중복되는 하위 문제가 없다.\n중복되는 하위 문제의 식별 및 최적화 방법 중복되는 하위 문제 식별 체크리스트 재귀 호출 패턴 분석: 동일한 매개변수로 함수가 반복 호출되는지 확인한다. 상태 공간 크기 검토: 가능한 하위 문제 상태의 수가 입력 크기에 다항식적인지 확인한다. 의존성 그래프 구성: 하위 문제 간의 의존성을 그래프로 표현하여 중복 여부를 확인한다. 계산 추적: 간단한 예제에서 각 하위 문제가 몇 번 계산되는지 추적한다. 메모이제이션 최적화 기법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def memoization_optimization(func): \"\"\"함수에 메모이제이션을 적용하는 데코레이터\"\"\" memo = {} def wrapper(*args): # 인수를 해시 가능한 형태로 변환 args_key = tuple(map(lambda x: tuple(x) if isinstance(x, list) else x, args)) if args_key not in memo: memo[args_key] = func(*args) return memo[args_key] return wrapper @memoization_optimization def fibonacci(n): if n \u003c= 1: return n return fibonacci(n-1) + fibonacci(n-2) 테이블링 최적화 기법 1 2 3 4 5 6 7 8 9 10 11 12 13 def tabulation_optimization(fibonacci, n): \"\"\"상향식 테이블링으로 피보나치 수열 최적화\"\"\" # 기본 사례 if n \u003c= 1: return n # 2개의 변수만 사용하여 공간 복잡도 최적화 a, b = 0, 1 for i in range(2, n + 1): a, b = b, a + b return b 이 방식은 전체 DP 테이블을 유지하는 대신 필수적인 값만 저장하여 공간 복잡도를 O(n)에서 O(1)로 개선한다.\n상태 공간 축소 기법 상태 공간 축소는 문제의 상태 표현을 최소화하여 중복되는 하위 문제의 수를 줄이는 기법.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 원래 배낭 문제 구현 (2차원 배열) def knapsack_original(weights, values, capacity): n = len(weights) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i-1] \u003c= w: dp[i][w] = max(dp[i-1][w], values[i-1] + dp[i-1][w-weights[i-1]]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity] # 상태 공간 축소 버전 (1차원 배열) def knapsack_optimized(weights, values, capacity): n = len(weights) dp = [0 for _ in range(capacity + 1)] for i in range(n): # 역순으로 순회하여 이전 상태에 영향을 주지 않도록 함 for w in range(capacity, weights[i] - 1, -1): dp[w] = max(dp[w], values[i] + dp[w - weights[i]]) return dp[capacity] 이 최적화는 공간 복잡도를 O(n·W)에서 O(W)로 줄인다.\n실제 응용 사례에서의 중복되는 하위 문제 문자열 처리 알고리즘 문자열 처리에서 중복되는 하위 문제를 활용한 알고리즘의 예시.\n예시: 최장 회문 부분 문자열(Longest Palindromic Substring)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def longest_palindromic_substring(s): n = len(s) # dp[i][j] = s[i:j+1]이 회문인지 여부 dp = [[False for _ in range(n)] for _ in range(n)] # 모든 길이 1인 부분 문자열은 회문 for i in range(n): dp[i][i] = True start = 0 max_length = 1 # 길이 2인 부분 문자열 확인 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # 길이 3 이상인 부분 문자열 확인 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # s[i+1:j]가 회문이고 s[i]와 s[j]가 같은지 확인 (중복되는 하위 문제 활용) if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length \u003e max_length: start = i max_length = length return s[start:start + max_length] 이 알고리즘은 더 작은 부분 문자열이 회문인지에 대한 정보를 재사용하여 효율성을 높인다.\n그래프 알고리즘 그래프 알고리즘에서 중복되는 하위 문제를 활용한 예시.\n예시: 모든 쌍 최단 경로(All-Pairs Shortest Path) - 플로이드-워셜 알고리즘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def floyd_warshall(graph): n = len(graph) dist = [row[:] for row in graph] # 그래프 복사 # k = 중간 정점 for k in range(n): # i = 시작 정점 for i in range(n): # j = 종료 정점 for j in range(n): # i→k→j 경로가 i→j 직접 경로보다 짧은지 확인 (중복되는 하위 문제 활용) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist 이 알고리즘은 노드 k를 통과하는 모든 경로를 계산할 때, 이전에 계산한 k-1까지의 중간 노드를 사용한 최단 경로 정보를 재사용한다.\n최적화 문제 최적화 문제에서 중복되는 하위 문제를 활용한 예시.\n예시: 로드 밸런싱(Load Balancing) 문제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def min_completion_time(jobs, k): \"\"\" k개의 프로세서에 작업을 할당하여 마지막 작업이 완료되는 시간을 최소화 \"\"\" n = len(jobs) # dp[mask][i] = 비트마스크 mask로 표현된 작업들을 i개의 프로세서에 할당했을 때의 최소 완료 시간 dp = {} def solve(mask, processors): # 모든 작업이 할당됨 if mask == (1 \u003c\u003c n) - 1: return 0 # 이미 계산된 상태 if (mask, processors) in dp: return dp[(mask, processors)] # 가능한 모든 미할당 작업 조합 시도 result = float('inf') # 새 프로세서 시작 if processors \u003e 0: for i in range(n): if not (mask \u0026 (1 \u003c\u003c i)): # 작업 i가 아직 할당되지 않음 new_mask = mask | (1 \u003c\u003c i) # 작업 i를 새 프로세서에 할당 (중복되는 하위 문제 활용) result = min(result, max(jobs[i], solve(new_mask, processors - 1))) # 기존 프로세서에 추가 for i in range(n): if not (mask \u0026 (1 \u003c\u003c i)): # 작업 i가 아직 할당되지 않음 new_mask = mask | (1 \u003c\u003c i) # 작업 i를 기존 프로세서에 추가 (중복되는 하위 문제 활용) result = min(result, jobs[i] + solve(new_mask, processors)) dp[(mask, processors)] = result return result return solve(0, k) 이 알고리즘은 동일한 작업 집합과 프로세서 수에 대한 계산을 재사용하여 효율성을 높인다.\n중복되는 하위 문제 비교 분석표 아래 표는 다양한 알고리즘 문제에서 중복되는 하위 문제의 특성을 비교 분석:\n문제 중복되는 하위 문제 수 하위 문제 의존성 유형 메모리 요구량 메모이제이션 효과 중복 계산 비율 재사용 패턴 피보나치 수열 O(n) 선형 O(n) 매우 높음 \u003e99% F(n-2)가 F(n-1), F(n) 계산에 재사용 최장 증가 부분 수열 O(n) 분기 O(n) 높음 ~50% LIS(j)가 여러 LIS(i)에 재사용 (j \u003c i) 0-1 배낭 문제 O(n·W) 상태 전이 O(n·W) 높음 ~70% DP[i-1][w], DP[i-1][w-wᵢ]가 재사용 편집 거리 O(m·n) 다차원 O(m·n) 높음 ~75% ED[i-1][j], ED[i][j-1], ED[i-1][j-1]이 재사용 행렬 곱셈 연쇄 O(n²) 구간 O(n²) 중간 ~60% DP[i][k], DP[k+1][j]가 여러 구간에 재사용 최장 공통 부분 수열 O(m·n) 다차원 O(m·n) 높음 ~70% LCS[i-1][j], LCS[i][j-1], LCS[i-1][j-1]이 재사용 동전 교환 문제 O(n·amount) 상태 전이 O(amount) 높음 ~80% DP[i-coin]이 여러 금액에 재사용 최적 이진 검색 트리 O(n²) 구간 O(n²) 중간 ~65% DP[i][k-1], DP[k+1][j]가 여러 구간에 재사용 팰린드롬 파티셔닝 O(n²) 구간 O(n²) 높음 ~75% palindrome[i+1][j-1], cut[i][k]가 재사용 외판원 문제(TSP) O(n·2^n) 상태/집합 O(n·2^n) 매우 높음 \u003e95% DP[S-{j}][i]가 여러 상태에 재사용 중복되는 하위 문제의 실무 구현 가이드 하향식(Top-down) 메모이제이션 구현 패턴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def problem_solver_memoization(input_data): # 메모이제이션 캐시 초기화 memo = {} def solve_recursive(state): # 상태가 이미 계산되었는지 확인 if state in memo: return memo[state] # 기본 사례 체크 if is_base_case(state): return base_case_value(state) # 가능한 모든 선택지에 대해 최적값 계산 result = initial_value # 문제에 따라 초기값 설정 (최소값/최대값) for choice in possible_choices(state): next_state = apply_choice(state, choice) subproblem_result = solve_recursive(next_state) result = combine_results(result, subproblem_result, choice) # 결과 저장 및 반환 memo[state] = result return result # 초기 상태에서 시작 return solve_recursive(initial_state(input_data)) 상향식(Bottom-up) 테이블링 구현 패턴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def problem_solver_tabulation(input_data): # 문제 크기 및 필요한 매개변수 추출 n = extract_problem_size(input_data) # DP 테이블 초기화 dp = initialize_dp_table(n) # 기본 사례 설정 set_base_cases(dp) # 상향식으로 테이블 채우기 for i in range(smallest_non_base_case, n + 1): for j in range(additional_dimension_if_needed): dp[i][j] = calculate_value(dp, i, j, input_data) # 최종 결과 반환 return extract_result(dp, n) 메모리 최적화 기법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def memory_optimized_dp(input_data): n = extract_problem_size(input_data) # 1. 차원 축소: 2차원 → 1차원 # 예: 배낭 문제에서 행(물건)을 기준으로 반복하면서 한 행만 유지 dp = initialize_reduced_dp_table() for i in range(1, n + 1): # 2. 순회 방향 최적화: 역순 순회로 이전 값 보존 for j in range(max_value, min_value - 1, -1): dp[j] = calculate_with_previous_values(dp, j, input_data[i-1]) # 3. 슬라이딩 윈도우: 필요한 이전 상태만 유지 # 예: 피보나치 수열에서 마지막 두 값만 유지 a, b = initial_values for i in range(2, n + 1): a, b = b, combine(a, b) return b 효율적인 구현을 위한 자료구조 선택 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def choose_appropriate_data_structure(problem_type, input_size): if problem_type == \"linear_dependency\": # 배열이나 리스트로 충분 return [0] * (input_size + 1) elif problem_type == \"two_dimensional\": # 2D 배열 또는 딕셔너리 if input_size \u003c= 1000: return [[0 for _ in range(input_size + 1)] for _ in range(input_size + 1)] else: # 희소 행렬의 경우 딕셔너리가 더 효율적 return {} elif problem_type == \"state_based\": # 복잡한 상태는 해시 맵이 적합 return {} elif problem_type == \"bit_manipulation\": # 비트마스크 사용 return [0] * (1 \u003c\u003c input_size) 참고 및 출처 ","wordCount":"3402","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-21T14:02:00Z","dateModified":"2025-01-21T14:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/>동적 계획법 (Dynamic Programming)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/>Principles of Dynamic Programming</a></div><h1 class="post-title entry-hint-parent">중복되는 하위 문제(Overlapping Subproblems)</h1><div class=post-description>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.</div><div class=post-meta><span title='2025-01-21 14:02:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Dynamic%20Programming/Principles/overlapping-subproblems.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#중복되는-하위-문제overlapping-subproblems>중복되는 하위 문제(Overlapping Subproblems)</a><ul><li><a href=#중복되는-하위-문제overlapping-subproblems의-기본-개념>중복되는 하위 문제(Overlapping Subproblems)의 기본 개념</a></li><li><a href=#중복되는-하위-문제-해결-방법>중복되는 하위 문제 해결 방법</a></li><li><a href=#다양한-중복되는-하위-문제-유형>다양한 중복되는 하위 문제 유형</a></li><li><a href=#중복되는-하위-문제의-일반적인-예시와-분석>중복되는 하위 문제의 일반적인 예시와 분석</a></li><li><a href=#중복되는-하위-문제의-복잡도-분석>중복되는 하위 문제의 복잡도 분석</a></li><li><a href=#중복되는-하위-문제가-없는-알고리즘>중복되는 하위 문제가 없는 알고리즘</a></li><li><a href=#중복되는-하위-문제의-식별-및-최적화-방법>중복되는 하위 문제의 식별 및 최적화 방법</a></li><li><a href=#상태-공간-축소-기법>상태 공간 축소 기법</a></li><li><a href=#실제-응용-사례에서의-중복되는-하위-문제>실제 응용 사례에서의 중복되는 하위 문제</a></li><li><a href=#중복되는-하위-문제-비교-분석표>중복되는 하위 문제 비교 분석표</a></li><li><a href=#중복되는-하위-문제의-실무-구현-가이드>중복되는 하위 문제의 실무 구현 가이드</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=중복되는-하위-문제overlapping-subproblems>중복되는 하위 문제(Overlapping Subproblems)<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제overlapping-subproblems>#</a></h2><p>동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.<br>동적 계획법이 효과적으로 적용되기 위해서는 두 가지 핵심 특성이 필요하다:</p><ul><li>최적 부분 구조(Optimal Substructure)</li><li>중복되는 하위 문제(Overlapping Subproblems)<br>이다.</li></ul><h3 id=중복되는-하위-문제overlapping-subproblems의-기본-개념>중복되는 하위 문제(Overlapping Subproblems)의 기본 개념<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제overlapping-subproblems의-기본-개념>#</a></h3><p>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.<br>즉, 문제를 해결하는 과정에서 같은 계산이 여러 번 수행되는 경우이다.<br>중복되는 하위 문제가 있을 때 동적 계획법은 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피함으로써 효율성을 크게 향상시킨다.</p><h4 id=중복되는-하위-문제의-핵심-특성>중복되는 하위 문제의 핵심 특성<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-핵심-특성>#</a></h4><ol><li><strong>반복 계산</strong>: 동일한 입력 매개변수에 대해 같은 계산이 여러 번 수행된다.</li><li><strong>결과 재사용 가능성</strong>: 한 번 계산된 하위 문제의 결과를 저장하고 재사용할 수 있다.</li><li><strong>하위 문제 개수의 다항성</strong>: 문제 크기에 대해 하위 문제의 총 개수가 다항식적(polynomial)이다.</li><li><strong>하위 문제 간 의존성</strong>: 여러 상위 문제가 동일한 하위 문제에 의존한다.</li></ol><h4 id=재귀적-알고리즘에서의-중복>재귀적 알고리즘에서의 중복<a hidden class=anchor aria-hidden=true href=#재귀적-알고리즘에서의-중복>#</a></h4><p>중복되는 하위 문제는 재귀적 알고리즘에서 특히 두드러진다.<br>예를 들어, 피보나치 수열의 단순 재귀 구현을 보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드에서 <code>fibonacci(n-2)</code>는 <code>fibonacci(n-1)</code> 계산 과정에서도 호출되므로, 동일한 하위 문제가 중복해서 계산된다.<br>예를 들어, <code>fibonacci(5)</code>를 계산할 때:</p><ul><li><code>fibonacci(5)</code> → <code>fibonacci(4)</code> + <code>fibonacci(3)</code></li><li><code>fibonacci(4)</code> → <code>fibonacci(3)</code> + <code>fibonacci(2)</code></li><li><code>fibonacci(3)</code> → <code>fibonacci(2)</code> + <code>fibonacci(1)</code></li></ul><p>여기서 <code>fibonacci(3)</code>과 <code>fibonacci(2)</code>가 각각 여러 번 계산되는 것을 볼 수 있다.</p><h4 id=중복되는-하위-문제-식별-방법>중복되는 하위 문제 식별 방법<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-식별-방법>#</a></h4><p>중복되는 하위 문제를 식별하는 방법은 다음과 같다:</p><ol><li><strong>재귀 트리 분석</strong>: 재귀 호출 트리를 그려보고 동일한 함수 호출이 반복되는지 확인한다.</li><li><strong>하위 문제 정의 분석</strong>: 하위 문제가 소수의 매개변수로 완전히 정의되고, 이 매개변수가 제한된 범위를 가지는지 확인한다.</li><li><strong>중복 횟수 측정</strong>: 간단한 테스트 케이스에서 각 하위 문제가 몇 번 호출되는지 측정한다.</li></ol><h3 id=중복되는-하위-문제-해결-방법>중복되는 하위 문제 해결 방법<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-해결-방법>#</a></h3><h4 id=메모이제이션memoization---하향식top-down-접근>메모이제이션(Memoization) - 하향식(Top-Down) 접근<a hidden class=anchor aria-hidden=true href=#메모이제이션memoization---하향식top-down-접근>#</a></h4><p>메모이제이션은 하위 문제의 결과를 저장하여 중복 계산을 피하는 기법이다.<br>재귀적 접근에 저장소(주로 배열이나 해시맵)를 추가하여 구현한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 이미 계산된 결과가 있으면 바로 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 계산 및 저장</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_memo</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 필요한 하위 문제만 계산하고 결과를 저장하여 재사용한다.</p><h4 id=테이블링tabulation---상향식bottom-up-접근>테이블링(Tabulation) - 상향식(Bottom-Up) 접근<a hidden class=anchor aria-hidden=true href=#테이블링tabulation---상향식bottom-up-접근>#</a></h4><p>테이블링은 작은 하위 문제부터 시작하여 더 큰 문제를 해결하는 방식이다.<br>결과를 테이블(주로 배열)에 저장하며, 재귀 호출 없이 반복문으로 구현한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_tab</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># DP 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 작은 문제부터 큰 문제까지 해결</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 모든 하위 문제를 순차적으로 해결하며, 메모리 접근 패턴이 더 효율적일 수 있다.</p><h4 id=두-접근-방식의-비교>두 접근 방식의 비교<a hidden class=anchor aria-hidden=true href=#두-접근-방식의-비교>#</a></h4><table><thead><tr><th>특성</th><th>메모이제이션(하향식)</th><th>테이블링(상향식)</th></tr></thead><tbody><tr><td><strong>구현 방식</strong></td><td>재귀 + 메모 저장소</td><td>반복문 + 테이블</td></tr><tr><td><strong>계산 순서</strong></td><td>필요한 하위 문제만 계산</td><td>모든 하위 문제를 순차적으로 계산</td></tr><tr><td><strong>재귀 호출</strong></td><td>있음 (스택 오버플로우 가능성)</td><td>없음</td></tr><tr><td><strong>공간 효율성</strong></td><td>필요한 하위 문제만 저장 가능</td><td>일반적으로 모든 하위 문제 저장</td></tr><tr><td><strong>호출 오버헤드</strong></td><td>재귀 호출 오버헤드 존재</td><td>오버헤드 적음</td></tr><tr><td><strong>코드 가독성</strong></td><td>일반적으로 더 직관적</td><td>때로 더 복잡할 수 있음</td></tr><tr><td><strong>최적화 기회</strong></td><td>필요 없는 하위 문제 계산 회피</td><td>메모리 최적화 용이</td></tr></tbody></table><h3 id=다양한-중복되는-하위-문제-유형>다양한 중복되는 하위 문제 유형<a hidden class=anchor aria-hidden=true href=#다양한-중복되는-하위-문제-유형>#</a></h3><h4 id=선형-의존성linear-dependency>선형 의존성(Linear Dependency)<a hidden class=anchor aria-hidden=true href=#선형-의존성linear-dependency>#</a></h4><p>하위 문제가 일정한 간격으로 이전 하위 문제들에 의존하는 경우.</p><p><strong>예시</strong>: 피보나치 수열, 계단 오르기 문제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 계단 오르기 문제: 한 번에 1단 또는 2단씩 오를 수 있을 때, n개의 계단을 오르는 방법의 수</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>climb_stairs</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>  <span class=c1># 선형 의존성</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=구간-의존성range-dependency>구간 의존성(Range Dependency)<a hidden class=anchor aria-hidden=true href=#구간-의존성range-dependency>#</a></h4><p>하위 문제가 특정 구간 내의 다른 하위 문제들에 의존하는 경우.</p><p><strong>예시</strong>: 행렬 곱셈 연쇄, 최적 이진 검색 트리</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 행렬 곱셈 연쇄 문제</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>matrix_chain_multiplication</span><span class=p>(</span><span class=n>dims</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>dims</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = i부터 j까지의 행렬을 곱하는 최소 연산 횟수</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 구간 내 모든 분할점 k에 대해 최소값 찾기 (구간 의존성)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>dims</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>dims</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>dims</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=상태-전이-의존성state-transition-dependency>상태 전이 의존성(State Transition Dependency)<a hidden class=anchor aria-hidden=true href=#상태-전이-의존성state-transition-dependency>#</a></h4><p>하위 문제가 여러 이전 상태에서의 전이에 의존하는 경우.</p><p><strong>예시</strong>: 배낭 문제, 동전 교환 문제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 동전 교환 문제: 주어진 금액을 만들기 위한 최소 동전 개수</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>coin_change</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=p>(</span><span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>coin</span><span class=p>,</span> <span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재 금액에서 동전 값을 뺀 상태에서 전이 (상태 전이 의존성)</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>coin</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=다차원-의존성multi-dimensional-dependency>다차원 의존성(Multi-dimensional Dependency)<a hidden class=anchor aria-hidden=true href=#다차원-의존성multi-dimensional-dependency>#</a></h4><p>하위 문제가 여러 차원의 상태에 의존하는 경우.</p><p><strong>예시</strong>: 최장 공통 부분 수열, 편집 거리</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 편집 거리 문제</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit_distance</span><span class=p>(</span><span class=n>word1</span><span class=p>,</span> <span class=n>word2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>word1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>word2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = word1[:i]와 word2[:j] 간의 편집 거리</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 빈 문자열로 변환</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>word1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>word2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>  <span class=c1># 문자가 같으면 대각선 값 사용</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 삽입, 삭제, 대체 중 최소값 (다차원 의존성)</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중복되는-하위-문제의-일반적인-예시와-분석>중복되는 하위 문제의 일반적인 예시와 분석<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-일반적인-예시와-분석>#</a></h3><h4 id=피보나치-수열fibonacci-sequence>피보나치 수열(Fibonacci Sequence)<a hidden class=anchor aria-hidden=true href=#피보나치-수열fibonacci-sequence>#</a></h4><p>피보나치 수열은 중복되는 하위 문제의 가장 대표적인 예.<br><strong>분석</strong>:</p><ul><li>F(n) = F(n-1) + F(n-2)의 형태로 하위 문제에 의존.</li><li>F(n)을 계산하기 위해 F(n-2)가 F(n-1)과 F(n-2) 양쪽에서 필요.</li><li>단순 재귀 구현의 시간 복잡도는 O(2^n)이지만, DP를 적용하면 O(n)으로 개선.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 하위 문제 중복 횟수 분석</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>count_fibonacci_calls</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># n=5일 때 호출 횟수: F(0):3번, F(1):5번, F(2):3번, F(3):2번, F(4):1번, F(5):1번</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최장-증가-부분-수열longest-increasing-subsequence>최장 증가 부분 수열(Longest Increasing Subsequence)<a hidden class=anchor aria-hidden=true href=#최장-증가-부분-수열longest-increasing-subsequence>#</a></h4><p>배열에서 값이 증가하는 가장 긴 부분 수열을 찾는 문제이다.<br><strong>분석</strong>:</p><ul><li>LIS(i)는 인덱스 i까지의 LIS 길이.</li><li>LIS(i) = <code>max(LIS(j) + 1)</code> (<code>j &lt; i 이고 A[j] &lt; A[i]</code>)의 형태로 하위 문제에 의존.</li><li>각 위치 i에 대해 이전의 모든 위치 j에서의 LIS 값을 참조.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># dp[i] = 인덱스 i까지의 LIS 길이</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=배낭-문제knapsack-problem>배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#배낭-문제knapsack-problem>#</a></h4><p>제한된 무게 내에서 최대 가치를 가지는 물건들을 선택하는 문제.<br><strong>분석</strong>:</p><ul><li><code>DP[i][w]</code>는 처음 i개 물건으로 무게 w를 채울 때의 최대 가치이다.</li><li><code>DP[i][w] = max(DP[i-1][w], DP[i-1][w-wᵢ] + vᵢ)</code>의 형태로 하위 문제에 의존한다.</li><li>동일한 (i, w) 조합이 여러 경로에서 참조된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_01</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중복되는-하위-문제의-복잡도-분석>중복되는 하위 문제의 복잡도 분석<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-복잡도-분석>#</a></h3><h4 id=시간-복잡도-개선>시간 복잡도 개선<a hidden class=anchor aria-hidden=true href=#시간-복잡도-개선>#</a></h4><p>중복되는 하위 문제에 메모이제이션이나 테이블링을 적용하면 시간 복잡도를 크게 개선할 수 있다.</p><table><thead><tr><th>문제</th><th>단순 재귀</th><th>동적 계획법</th><th>개선 비율</th></tr></thead><tbody><tr><td>피보나치 수열</td><td>O(2^n)</td><td>O(n)</td><td>지수적 개선</td></tr><tr><td>이항 계수</td><td>O(2^n)</td><td>O(n²)</td><td>지수적 개선</td></tr><tr><td>최장 증가 부분 수열</td><td>O(2^n)</td><td>O(n²)</td><td>지수적 개선</td></tr><tr><td>배낭 문제</td><td>O(2^n)</td><td>O(n·W)</td><td>지수적 개선</td></tr><tr><td>편집 거리</td><td>O(3^(m+n))</td><td>O(m·n)</td><td>지수적 개선</td></tr></tbody></table><h4 id=중복-하위-문제의-수-분석>중복 하위 문제의 수 분석<a hidden class=anchor aria-hidden=true href=#중복-하위-문제의-수-분석>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>analyze_subproblem_calls</span><span class=p>(</span><span class=n>dp_function</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 하위 문제 호출 추적을 위한 래퍼 함수</span>
</span></span><span class=line><span class=cl>    <span class=n>call_count</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 튜플로 변환하여 해시 가능하게 만듦</span>
</span></span><span class=line><span class=cl>        <span class=n>args_tuple</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>args_tuple</span> <span class=ow>in</span> <span class=n>call_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>call_count</span><span class=p>[</span><span class=n>args_tuple</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>call_count</span><span class=p>[</span><span class=n>args_tuple</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp_function</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 함수 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>wrapper</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분석 결과</span>
</span></span><span class=line><span class=cl>    <span class=n>total_calls</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>call_count</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>unique_subproblems</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>call_count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>max_repetition</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>call_count</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;total_calls&#34;</span><span class=p>:</span> <span class=n>total_calls</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;unique_subproblems&#34;</span><span class=p>:</span> <span class=n>unique_subproblems</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;max_repetition&#34;</span><span class=p>:</span> <span class=n>max_repetition</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;detailed_counts&#34;</span><span class=p>:</span> <span class=n>call_count</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=공간-복잡도-분석>공간 복잡도 분석<a hidden class=anchor aria-hidden=true href=#공간-복잡도-분석>#</a></h4><p>중복되는 하위 문제 해결을 위한 저장 공간의 크기는 하위 문제의 수에 비례합니다.</p><table><thead><tr><th>문제</th><th>메모이제이션 공간</th><th>테이블링 공간</th><th>최적화된 공간</th></tr></thead><tbody><tr><td>피보나치 수열</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>최장 증가 부분 수열</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>배낭 문제</td><td>O(n·W)</td><td>O(n·W)</td><td>O(W)</td></tr><tr><td>편집 거리</td><td>O(m·n)</td><td>O(m·n)</td><td>O(min(m,n))</td></tr><tr><td>행렬 곱셈 연쇄</td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td></tr></tbody></table><h4 id=하위-문제-간-의존성-그래프>하위 문제 간 의존성 그래프<a hidden class=anchor aria-hidden=true href=#하위-문제-간-의존성-그래프>#</a></h4><p>하위 문제 간의 의존성을 방향 그래프로 표현할 수 있다.<br>노드는 하위 문제, 엣지는 의존성을 나타낸다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>build_dependency_graph</span><span class=p>(</span><span class=n>problem_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 예: 피보나치 수열의 의존성 그래프</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>problem_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 기본 사례는 의존성 없음</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>  <span class=c1># F(i)는 F(i-1)과 F(i-2)에 의존</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>graph</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중복되는-하위-문제가-없는-알고리즘>중복되는 하위 문제가 없는 알고리즘<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제가-없는-알고리즘>#</a></h3><p>모든 문제가 중복되는 하위 문제를 가지는 것은 아니다.<br>다음은 중복되는 하위 문제가 없는 대표적인 알고리즘들.</p><h4 id=분할-정복divide-and-conquer-알고리즘>분할 정복(Divide and Conquer) 알고리즘<a hidden class=anchor aria-hidden=true href=#분할-정복divide-and-conquer-알고리즘>#</a></h4><p>분할 정복 알고리즘은 문제를 더 작은 하위 문제로 나누지만, 이들 하위 문제가 중복되지 않는 경우가 많다.</p><p><strong>병합 정렬(Merge Sort)</strong> 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>])</span>  <span class=c1># 독립적인 하위 문제</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:])</span>  <span class=c1># 독립적인 하위 문제</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>병합 정렬에서는 배열의 서로 다른 부분을 정렬하므로, 동일한 하위 문제가 중복해서 해결되지 않는다.</p><h4 id=다익스트라-알고리즘dijkstras-algorithm>다익스트라 알고리즘(Dijkstra&rsquo;s Algorithm)<a hidden class=anchor aria-hidden=true href=#다익스트라-알고리즘dijkstras-algorithm>#</a></h4><p>다익스트라 알고리즘은 그래프에서 최단 경로를 찾는 알고리즘으로, 각 노드를 한 번씩만 방문한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_distance</span><span class=p>,</span> <span class=n>current_node</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이미 처리된 노드는 건너뛰기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_distance</span> <span class=o>&gt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>current_node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>current_node</span><span class=p>]</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>distance</span> <span class=o>=</span> <span class=n>current_distance</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>distance</span> <span class=o>&lt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=n>distance</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distances</span>
</span></span></code></pre></td></tr></table></div></div><p>다익스트라 알고리즘에서는 각 노드의 최단 거리를 한 번만 계산하므로 중복되는 하위 문제가 없다.</p><h4 id=퀵-정렬quick-sort>퀵 정렬(Quick Sort)<a hidden class=anchor aria-hidden=true href=#퀵-정렬quick-sort>#</a></h4><p>퀵 정렬은 피벗을 기준으로 배열을 나누어 정렬하는 알고리즘으로, 하위 문제가 중복되지 않는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>퀵 정렬에서는 각 하위 배열이 독립적으로 정렬되므로 중복되는 하위 문제가 없다.</p><h3 id=중복되는-하위-문제의-식별-및-최적화-방법>중복되는 하위 문제의 식별 및 최적화 방법<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-식별-및-최적화-방법>#</a></h3><h4 id=중복되는-하위-문제-식별-체크리스트>중복되는 하위 문제 식별 체크리스트<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-식별-체크리스트>#</a></h4><ol><li><strong>재귀 호출 패턴 분석</strong>: 동일한 매개변수로 함수가 반복 호출되는지 확인한다.</li><li><strong>상태 공간 크기 검토</strong>: 가능한 하위 문제 상태의 수가 입력 크기에 다항식적인지 확인한다.</li><li><strong>의존성 그래프 구성</strong>: 하위 문제 간의 의존성을 그래프로 표현하여 중복 여부를 확인한다.</li><li><strong>계산 추적</strong>: 간단한 예제에서 각 하위 문제가 몇 번 계산되는지 추적한다.</li></ol><h4 id=메모이제이션-최적화-기법>메모이제이션 최적화 기법<a hidden class=anchor aria-hidden=true href=#메모이제이션-최적화-기법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>memoization_optimization</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;함수에 메모이제이션을 적용하는 데코레이터&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 인수를 해시 가능한 형태로 변환</span>
</span></span><span class=line><span class=cl>        <span class=n>args_key</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>if</span> <span class=nb>isinstance</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=nb>list</span><span class=p>)</span> <span class=k>else</span> <span class=n>x</span><span class=p>,</span> <span class=n>args</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>args_key</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>memo</span><span class=p>[</span><span class=n>args_key</span><span class=p>]</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>args_key</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@memoization_optimization</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=테이블링-최적화-기법>테이블링 최적화 기법<a hidden class=anchor aria-hidden=true href=#테이블링-최적화-기법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>tabulation_optimization</span><span class=p>(</span><span class=n>fibonacci</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;상향식 테이블링으로 피보나치 수열 최적화&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 2개의 변수만 사용하여 공간 복잡도 최적화</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 전체 DP 테이블을 유지하는 대신 필수적인 값만 저장하여 공간 복잡도를 O(n)에서 O(1)로 개선한다.</p><h3 id=상태-공간-축소-기법>상태 공간 축소 기법<a hidden class=anchor aria-hidden=true href=#상태-공간-축소-기법>#</a></h3><p>상태 공간 축소는 문제의 상태 표현을 최소화하여 중복되는 하위 문제의 수를 줄이는 기법.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 원래 배낭 문제 구현 (2차원 배열)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_original</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>capacity</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 상태 공간 축소 버전 (1차원 배열)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_optimized</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 역순으로 순회하여 이전 상태에 영향을 주지 않도록 함</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span><span class=p>,</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>w</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>w</span> <span class=o>-</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 최적화는 공간 복잡도를 O(n·W)에서 O(W)로 줄인다.</p><h3 id=실제-응용-사례에서의-중복되는-하위-문제>실제 응용 사례에서의 중복되는 하위 문제<a hidden class=anchor aria-hidden=true href=#실제-응용-사례에서의-중복되는-하위-문제>#</a></h3><h4 id=문자열-처리-알고리즘>문자열 처리 알고리즘<a hidden class=anchor aria-hidden=true href=#문자열-처리-알고리즘>#</a></h4><p>문자열 처리에서 중복되는 하위 문제를 활용한 알고리즘의 예시.</p><p><strong>예시: 최장 회문 부분 문자열(Longest Palindromic Substring)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_palindromic_substring</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = s[i:j+1]이 회문인지 여부</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 길이 1인 부분 문자열은 회문</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>max_length</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 2인 부분 문자열 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=n>max_length</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 3 이상인 부분 문자열 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># s[i+1:j]가 회문이고 s[i]와 s[j]가 같은지 확인 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=ow>and</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>length</span> <span class=o>&gt;</span> <span class=n>max_length</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                    <span class=n>max_length</span> <span class=o>=</span> <span class=n>length</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>start</span> <span class=o>+</span> <span class=n>max_length</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 더 작은 부분 문자열이 회문인지에 대한 정보를 재사용하여 효율성을 높인다.</p><h4 id=그래프-알고리즘>그래프 알고리즘<a hidden class=anchor aria-hidden=true href=#그래프-알고리즘>#</a></h4><p>그래프 알고리즘에서 중복되는 하위 문제를 활용한 예시.</p><p><strong>예시: 모든 쌍 최단 경로(All-Pairs Shortest Path) - 플로이드-워셜 알고리즘</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>floyd_warshall</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[:]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>]</span>  <span class=c1># 그래프 복사</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># k = 중간 정점</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># i = 시작 정점</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># j = 종료 정점</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># i→k→j 경로가 i→j 직접 경로보다 짧은지 확인 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>                <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dist</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 노드 k를 통과하는 모든 경로를 계산할 때, 이전에 계산한 k-1까지의 중간 노드를 사용한 최단 경로 정보를 재사용한다.</p><h4 id=최적화-문제>최적화 문제<a hidden class=anchor aria-hidden=true href=#최적화-문제>#</a></h4><p>최적화 문제에서 중복되는 하위 문제를 활용한 예시.</p><p><strong>예시: 로드 밸런싱(Load Balancing) 문제</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span><span class=lnt id=hl-20-16><a class=lnlinks href=#hl-20-16>16</a>
</span><span class=lnt id=hl-20-17><a class=lnlinks href=#hl-20-17>17</a>
</span><span class=lnt id=hl-20-18><a class=lnlinks href=#hl-20-18>18</a>
</span><span class=lnt id=hl-20-19><a class=lnlinks href=#hl-20-19>19</a>
</span><span class=lnt id=hl-20-20><a class=lnlinks href=#hl-20-20>20</a>
</span><span class=lnt id=hl-20-21><a class=lnlinks href=#hl-20-21>21</a>
</span><span class=lnt id=hl-20-22><a class=lnlinks href=#hl-20-22>22</a>
</span><span class=lnt id=hl-20-23><a class=lnlinks href=#hl-20-23>23</a>
</span><span class=lnt id=hl-20-24><a class=lnlinks href=#hl-20-24>24</a>
</span><span class=lnt id=hl-20-25><a class=lnlinks href=#hl-20-25>25</a>
</span><span class=lnt id=hl-20-26><a class=lnlinks href=#hl-20-26>26</a>
</span><span class=lnt id=hl-20-27><a class=lnlinks href=#hl-20-27>27</a>
</span><span class=lnt id=hl-20-28><a class=lnlinks href=#hl-20-28>28</a>
</span><span class=lnt id=hl-20-29><a class=lnlinks href=#hl-20-29>29</a>
</span><span class=lnt id=hl-20-30><a class=lnlinks href=#hl-20-30>30</a>
</span><span class=lnt id=hl-20-31><a class=lnlinks href=#hl-20-31>31</a>
</span><span class=lnt id=hl-20-32><a class=lnlinks href=#hl-20-32>32</a>
</span><span class=lnt id=hl-20-33><a class=lnlinks href=#hl-20-33>33</a>
</span><span class=lnt id=hl-20-34><a class=lnlinks href=#hl-20-34>34</a>
</span><span class=lnt id=hl-20-35><a class=lnlinks href=#hl-20-35>35</a>
</span><span class=lnt id=hl-20-36><a class=lnlinks href=#hl-20-36>36</a>
</span><span class=lnt id=hl-20-37><a class=lnlinks href=#hl-20-37>37</a>
</span><span class=lnt id=hl-20-38><a class=lnlinks href=#hl-20-38>38</a>
</span><span class=lnt id=hl-20-39><a class=lnlinks href=#hl-20-39>39</a>
</span><span class=lnt id=hl-20-40><a class=lnlinks href=#hl-20-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_completion_time</span><span class=p>(</span><span class=n>jobs</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    k개의 프로세서에 작업을 할당하여 마지막 작업이 완료되는 시간을 최소화
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>jobs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[mask][i] = 비트마스크 mask로 표현된 작업들을 i개의 프로세서에 할당했을 때의 최소 완료 시간</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve</span><span class=p>(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 작업이 할당됨</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>mask</span> <span class=o>==</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이미 계산된 상태</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>)</span> <span class=ow>in</span> <span class=n>dp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>dp</span><span class=p>[(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가능한 모든 미할당 작업 조합 시도</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 새 프로세서 시작</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>processors</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)):</span>  <span class=c1># 작업 i가 아직 할당되지 않음</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_mask</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 작업 i를 새 프로세서에 할당 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>                    <span class=n>result</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=nb>max</span><span class=p>(</span><span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>solve</span><span class=p>(</span><span class=n>new_mask</span><span class=p>,</span> <span class=n>processors</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 기존 프로세서에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=p>(</span><span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)):</span>  <span class=c1># 작업 i가 아직 할당되지 않음</span>
</span></span><span class=line><span class=cl>                <span class=n>new_mask</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>|</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># 작업 i를 기존 프로세서에 추가 (중복되는 하위 문제 활용)</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>jobs</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>solve</span><span class=p>(</span><span class=n>new_mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[(</span><span class=n>mask</span><span class=p>,</span> <span class=n>processors</span><span class=p>)]</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solve</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 동일한 작업 집합과 프로세서 수에 대한 계산을 재사용하여 효율성을 높인다.</p><h3 id=중복되는-하위-문제-비교-분석표>중복되는 하위 문제 비교 분석표<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제-비교-분석표>#</a></h3><p>아래 표는 다양한 알고리즘 문제에서 중복되는 하위 문제의 특성을 비교 분석:</p><table><thead><tr><th>문제</th><th>중복되는 하위 문제 수</th><th>하위 문제 의존성 유형</th><th>메모리 요구량</th><th>메모이제이션 효과</th><th>중복 계산 비율</th><th>재사용 패턴</th></tr></thead><tbody><tr><td><strong>피보나치 수열</strong></td><td>O(n)</td><td>선형</td><td>O(n)</td><td>매우 높음</td><td>>99%</td><td>F(n-2)가 F(n-1), F(n) 계산에 재사용</td></tr><tr><td><strong>최장 증가 부분 수열</strong></td><td>O(n)</td><td>분기</td><td>O(n)</td><td>높음</td><td>~50%</td><td>LIS(j)가 여러 LIS(i)에 재사용 (j &lt; i)</td></tr><tr><td><strong>0-1 배낭 문제</strong></td><td>O(n·W)</td><td>상태 전이</td><td>O(n·W)</td><td>높음</td><td>~70%</td><td>DP[i-1][w], DP[i-1][w-wᵢ]가 재사용</td></tr><tr><td><strong>편집 거리</strong></td><td>O(m·n)</td><td>다차원</td><td>O(m·n)</td><td>높음</td><td>~75%</td><td>ED[i-1][j], ED[i][j-1], ED[i-1][j-1]이 재사용</td></tr><tr><td><strong>행렬 곱셈 연쇄</strong></td><td>O(n²)</td><td>구간</td><td>O(n²)</td><td>중간</td><td>~60%</td><td>DP[i][k], DP[k+1][j]가 여러 구간에 재사용</td></tr><tr><td><strong>최장 공통 부분 수열</strong></td><td>O(m·n)</td><td>다차원</td><td>O(m·n)</td><td>높음</td><td>~70%</td><td>LCS[i-1][j], LCS[i][j-1], LCS[i-1][j-1]이 재사용</td></tr><tr><td><strong>동전 교환 문제</strong></td><td>O(n·amount)</td><td>상태 전이</td><td>O(amount)</td><td>높음</td><td>~80%</td><td>DP[i-coin]이 여러 금액에 재사용</td></tr><tr><td><strong>최적 이진 검색 트리</strong></td><td>O(n²)</td><td>구간</td><td>O(n²)</td><td>중간</td><td>~65%</td><td>DP[i][k-1], DP[k+1][j]가 여러 구간에 재사용</td></tr><tr><td><strong>팰린드롬 파티셔닝</strong></td><td>O(n²)</td><td>구간</td><td>O(n²)</td><td>높음</td><td>~75%</td><td>palindrome[i+1][j-1], cut[i][k]가 재사용</td></tr><tr><td><strong>외판원 문제(TSP)</strong></td><td>O(n·2^n)</td><td>상태/집합</td><td>O(n·2^n)</td><td>매우 높음</td><td>>95%</td><td>DP[S-{j}][i]가 여러 상태에 재사용</td></tr></tbody></table><h3 id=중복되는-하위-문제의-실무-구현-가이드>중복되는 하위 문제의 실무 구현 가이드<a hidden class=anchor aria-hidden=true href=#중복되는-하위-문제의-실무-구현-가이드>#</a></h3><h4 id=하향식top-down-메모이제이션-구현-패턴>하향식(Top-down) 메모이제이션 구현 패턴<a hidden class=anchor aria-hidden=true href=#하향식top-down-메모이제이션-구현-패턴>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19>19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20>20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21>21</a>
</span><span class=lnt id=hl-21-22><a class=lnlinks href=#hl-21-22>22</a>
</span><span class=lnt id=hl-21-23><a class=lnlinks href=#hl-21-23>23</a>
</span><span class=lnt id=hl-21-24><a class=lnlinks href=#hl-21-24>24</a>
</span><span class=lnt id=hl-21-25><a class=lnlinks href=#hl-21-25>25</a>
</span><span class=lnt id=hl-21-26><a class=lnlinks href=#hl-21-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>problem_solver_memoization</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 메모이제이션 캐시 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve_recursive</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 상태가 이미 계산되었는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>state</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>state</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 기본 사례 체크</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_base_case</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>base_case_value</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가능한 모든 선택지에 대해 최적값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>initial_value</span>  <span class=c1># 문제에 따라 초기값 설정 (최소값/최대값)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>choice</span> <span class=ow>in</span> <span class=n>possible_choices</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>next_state</span> <span class=o>=</span> <span class=n>apply_choice</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>choice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>subproblem_result</span> <span class=o>=</span> <span class=n>solve_recursive</span><span class=p>(</span><span class=n>next_state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=n>combine_results</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>subproblem_result</span><span class=p>,</span> <span class=n>choice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 결과 저장 및 반환</span>
</span></span><span class=line><span class=cl>        <span class=n>memo</span><span class=p>[</span><span class=n>state</span><span class=p>]</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기 상태에서 시작</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solve_recursive</span><span class=p>(</span><span class=n>initial_state</span><span class=p>(</span><span class=n>input_data</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=상향식bottom-up-테이블링-구현-패턴>상향식(Bottom-up) 테이블링 구현 패턴<a hidden class=anchor aria-hidden=true href=#상향식bottom-up-테이블링-구현-패턴>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12>12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13>13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14>14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15>15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16>16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>problem_solver_tabulation</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 문제 크기 및 필요한 매개변수 추출</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>extract_problem_size</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># DP 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=n>initialize_dp_table</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례 설정</span>
</span></span><span class=line><span class=cl>    <span class=n>set_base_cases</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상향식으로 테이블 채우기</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>smallest_non_base_case</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>additional_dimension_if_needed</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>calculate_value</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최종 결과 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>extract_result</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=메모리-최적화-기법>메모리 최적화 기법<a hidden class=anchor aria-hidden=true href=#메모리-최적화-기법>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14>14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15>15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16>16</a>
</span><span class=lnt id=hl-23-17><a class=lnlinks href=#hl-23-17>17</a>
</span><span class=lnt id=hl-23-18><a class=lnlinks href=#hl-23-18>18</a>
</span><span class=lnt id=hl-23-19><a class=lnlinks href=#hl-23-19>19</a>
</span><span class=lnt id=hl-23-20><a class=lnlinks href=#hl-23-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>memory_optimized_dp</span><span class=p>(</span><span class=n>input_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=n>extract_problem_size</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 1. 차원 축소: 2차원 → 1차원</span>
</span></span><span class=line><span class=cl>    <span class=c1># 예: 배낭 문제에서 행(물건)을 기준으로 반복하면서 한 행만 유지</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=n>initialize_reduced_dp_table</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 2. 순회 방향 최적화: 역순 순회로 이전 값 보존</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>max_value</span><span class=p>,</span> <span class=n>min_value</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>calculate_with_previous_values</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>input_data</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 3. 슬라이딩 윈도우: 필요한 이전 상태만 유지</span>
</span></span><span class=line><span class=cl>    <span class=c1># 예: 피보나치 수열에서 마지막 두 값만 유지</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>initial_values</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>combine</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=효율적인-구현을-위한-자료구조-선택>효율적인 구현을 위한 자료구조 선택<a hidden class=anchor aria-hidden=true href=#효율적인-구현을-위한-자료구조-선택>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1> 1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2> 2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3> 3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4> 4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5> 5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6> 6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7> 7</a>
</span><span class=lnt id=hl-24-8><a class=lnlinks href=#hl-24-8> 8</a>
</span><span class=lnt id=hl-24-9><a class=lnlinks href=#hl-24-9> 9</a>
</span><span class=lnt id=hl-24-10><a class=lnlinks href=#hl-24-10>10</a>
</span><span class=lnt id=hl-24-11><a class=lnlinks href=#hl-24-11>11</a>
</span><span class=lnt id=hl-24-12><a class=lnlinks href=#hl-24-12>12</a>
</span><span class=lnt id=hl-24-13><a class=lnlinks href=#hl-24-13>13</a>
</span><span class=lnt id=hl-24-14><a class=lnlinks href=#hl-24-14>14</a>
</span><span class=lnt id=hl-24-15><a class=lnlinks href=#hl-24-15>15</a>
</span><span class=lnt id=hl-24-16><a class=lnlinks href=#hl-24-16>16</a>
</span><span class=lnt id=hl-24-17><a class=lnlinks href=#hl-24-17>17</a>
</span><span class=lnt id=hl-24-18><a class=lnlinks href=#hl-24-18>18</a>
</span><span class=lnt id=hl-24-19><a class=lnlinks href=#hl-24-19>19</a>
</span><span class=lnt id=hl-24-20><a class=lnlinks href=#hl-24-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>choose_appropriate_data_structure</span><span class=p>(</span><span class=n>problem_type</span><span class=p>,</span> <span class=n>input_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;linear_dependency&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 배열이나 리스트로 충분</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;two_dimensional&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 2D 배열 또는 딕셔너리</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>input_size</span> <span class=o>&lt;=</span> <span class=mi>1000</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>input_size</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 희소 행렬의 경우 딕셔너리가 더 효율적</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;state_based&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 복잡한 상태는 해시 맵이 적합</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>problem_type</span> <span class=o>==</span> <span class=s2>&#34;bit_manipulation&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 비트마스크 사용</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>input_size</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/dynamic-programming/>Dynamic-Programming</a></li><li><a href=https://buenhyden.github.io/tags/principles/>Principles</a></li><li><a href=https://buenhyden.github.io/tags/overlapping-subproblems/>Overlapping-Subproblems</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/><span class=title>« Prev</span><br><span>최적 부분 구조(Optimal Substructure)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/python/advanced/concurrency/asynchrony/asyncio/><span class=title>Next »</span><br><span>asyncio</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>