<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>동적 계획법 (Dynamic Programming) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Dynamic-Programming,DP"><meta name=description content="동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="동적 계획법 (Dynamic Programming)"><meta property="og:description" content="동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="동적 계획법 (Dynamic Programming)"><meta name=twitter:description content="동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":4,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":5,"name":"동적 계획법 (Dynamic Programming)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a></div><h1>동적 계획법 (Dynamic Programming)</h1><div class=post-description>동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법으로, 큰 문제를 작은 하위 문제로 나누고 각 하위 문제의 해결책을 저장해 두었다가 재사용하는 방식으로 전체 문제를 해결하는 방법이다.</div></header><div class=post-content><h2 id=동적-계획법-dynamic-programming-dp>동적 계획법 (Dynamic Programming, DP)<a hidden class=anchor aria-hidden=true href=#동적-계획법-dynamic-programming-dp>#</a></h2><p>동적 계획법은 컴퓨터 과학과 수학 분야에서 복잡한 문제를 더 간단한 하위 문제로 나누어 해결하는 강력한 알고리즘 설계 기법이다.<br>이 접근법은 특히 최적화 문제를 해결하는 데 매우 효과적이며, 다양한 응용 분야에서 널리 사용된다.</p><p>최적 부분 구조와 중복되는 하위 문제 특성을 가진 문제들에 적용할 수 있으며, 분할 정복과 달리 이미 해결한 하위 문제의 결과를 저장하고 재활용함으로써 계산 효율성을 크게 향상시킨다.</p><h3 id=동적-계획법의-기본-개념>동적 계획법의 기본 개념<a hidden class=anchor aria-hidden=true href=#동적-계획법의-기본-개념>#</a></h3><p>동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 여러 개의 겹치는 하위 문제로 나누고, 각 하위 문제를 한 번만 풀어 그 결과를 저장해두고 재활용하는 알고리즘 설계 방법이다.</p><p>&ldquo;동적 계획법"이라는 용어는 1950년대 리처드 벨만(Richard Bellman)이 처음 사용했다. 흥미롭게도, 이 이름은 실제로 수학적 의미보다는 당시 연구 기금을 얻기 위한 전략적 선택이었다고 한다. &ldquo;프로그래밍"이라는 단어는 여기서 컴퓨터 프로그래밍이 아닌 &ldquo;계획법&rdquo; 또는 &ldquo;의사결정 과정의 최적화"를 의미한다.</p><h4 id=핵심-원리>핵심 원리<a hidden class=anchor aria-hidden=true href=#핵심-원리>#</a></h4><p>동적 계획법의 두 가지 핵심 원리는 다음과 같다:</p><ol><li><strong>최적 부분 구조(Optimal Substructure)</strong>: 문제의 최적해가 하위 문제의 최적해로부터 구성될 수 있는 특성이다. 즉, 큰 문제의 최적해를 찾기 위해 더 작은 문제들의 최적해를 활용할 수 있다.</li><li><strong>중복되는 하위 문제(Overlapping Subproblems)</strong>: 동일한 하위 문제가 알고리즘 실행 과정에서 반복적으로 발생하는 특성이다. 이러한 중복 계산을 피하기 위해 각 하위 문제의 해를 저장하고 재사용한다.</li></ol><h4 id=동적-계획법의-접근-방식>동적 계획법의 접근 방식<a hidden class=anchor aria-hidden=true href=#동적-계획법의-접근-방식>#</a></h4><p>동적 계획법은 주로 두 가지 방식으로 구현된다:</p><ol><li><strong>하향식 접근법(Top-down Approach)</strong>: 큰 문제에서 시작하여 작은 하위 문제로 분할하며, 메모이제이션(memoization)을 통해 이미 해결한 하위 문제의 결과를 저장하고 재사용한다. 주로 재귀적 구현에 사용된다.</li><li><strong>상향식 접근법(Bottom-up Approach)</strong>: 가장 작은 하위 문제부터 시작하여 점차 큰 문제를 해결해 나가는 방식이다. 테이블링(tabulation) 기법을 사용하여 결과를 테이블에 채워가며 진행한다. 주로 반복적(iterative) 구현에 사용된다.</li></ol><h3 id=동적-계획법의-구성-요소>동적 계획법의 구성 요소<a hidden class=anchor aria-hidden=true href=#동적-계획법의-구성-요소>#</a></h3><ol><li><p>상태(State) 정의<br>동적 계획법에서 &ldquo;상태"는 문제의 특정 단계나 상황을 나타낸다.<br>상태를 명확하게 정의하는 것은 DP 문제 해결의 첫 단계이다.<br>상태는 보통 문제의 변수들의 조합으로 표현된다.</p><ul><li>피보나치 수열에서 상태는 단순히 현재 계산하려는 수의 인덱스 n이 된다.</li><li>배낭 문제에서는 현재 고려 중인 아이템의 인덱스와 남은 용량의 조합이 상태가 된다.</li></ul></li><li><p>상태 전이 방정식(State Transition Equation)<br>상태 전이 방정식(또는 점화식)은 현재 상태의 해를 이전 상태의 해들로부터 어떻게 계산할 수 있는지 정의한다.<br>이 방정식은 문제의 최적 부분 구조를 수학적으로 표현한다.</p><ul><li>예를 들어, 피보나치 수열의 상태 전이 방정식은 다음과 같다:<ul><li>F(n) = F(n-1) + F(n-2), n ≥ 2</li><li>F(0) = 0, F(1) = 1 (기저 조건)</li></ul></li></ul></li><li><p>기저 조건(Base Case)<br>기저 조건은 더 이상 작은 하위 문제로 나눌 수 없는 가장 작은 문제의 해를 정의한다.<br>이는 재귀적 해결책의 종료 조건이자, 상향식 접근법에서 테이블의 초기값이 된다.</p></li><li><p>메모이제이션과 테이블링</p><ol><li><strong>메모이제이션(Memoization)</strong>: 하향식 접근법에서 사용되는 기법으로, 이미 해결한 하위 문제의 결과를 메모리(보통 배열이나 해시 맵)에 저장하고, 동일한 하위 문제가 다시 발생하면 재계산 없이 저장된 결과를 반환한다.</li><li><strong>테이블링(Tabulation)</strong>: 상향식 접근법에서 사용되는 기법으로, 작은 하위 문제부터 시작하여 점진적으로 더 큰 문제의 해를 계산하면서 테이블에 결과를 채워간다.</li></ol></li></ol><h3 id=시간-및-공간-복잡도-최적화>시간 및 공간 복잡도 최적화<a hidden class=anchor aria-hidden=true href=#시간-및-공간-복잡도-최적화>#</a></h3><h4 id=메모리-사용-최적화>메모리 사용 최적화<a hidden class=anchor aria-hidden=true href=#메모리-사용-최적화>#</a></h4><p>많은 DP 문제에서 전체 테이블이 아닌 최근의 결과만 필요한 경우가 있다.<br>이 경우 공간 복잡도를 크게 줄일 수 있다.</p><p><strong>1차원 배열로 최적화된 0-1 배낭 문제:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_01_optimized</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span><span class=p>,</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>  <span class=c1># 역순으로 순회</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>w</span><span class=p>],</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>w</span> <span class=o>-</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 최적화로 공간 복잡도가 O(n*W)에서 O(W)로 감소한다.</p><h4 id=상태-전이-최적화>상태 전이 최적화<a hidden class=anchor aria-hidden=true href=#상태-전이-최적화>#</a></h4><p>일부 DP 문제에서는 상태 전이를 최적화하여 시간 복잡도를 줄일 수 있다.</p><p><strong>최장 증가 부분 수열(LIS)의 이진 검색 최적화:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence_optimized</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># tails[i]는 길이가 i+1인 증가 부분 수열의 마지막 원소 중 가능한 최소값</span>
</span></span><span class=line><span class=cl>    <span class=n>tails</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 이진 검색으로 num이 들어갈 위치 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>tails</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>tails</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>num</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># num을 적절한 위치에 삽입하거나 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>tails</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>tails</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>tails</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>=</span> <span class=n>num</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>tails</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=슬라이딩-윈도우-최적화>슬라이딩 윈도우 최적화<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-최적화>#</a></h4><p>일부 DP 문제에서는 각 상태를 계산할 때 인접한 몇 개의 이전 상태만 필요한 경우가 있다.<br>이때 슬라이딩 윈도우 기법을 사용하여 공간 복잡도를 크게 줄일 수 있다.</p><p><strong>피보나치 수열의 슬라이딩 윈도우 최적화:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8>8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_sliding_window</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div><p>이 최적화로 공간 복잡도가 O(n)에서 O(1)로 감소합니다.</p><h4 id=분할-정복-최적화>분할 정복 최적화<a hidden class=anchor aria-hidden=true href=#분할-정복-최적화>#</a></h4><p>일부 특수한 DP 문제에서는 분할 정복 기법을 적용하여 시간 복잡도를 개선할 수 있다.</p><p><strong>Knuth&rsquo;s Optimization:</strong> 이 최적화는 다음 조건을 만족하는 구간 DP 문제에 적용할 수 있다:</p><ol><li>상태 전이 방정식의 형태가 <code>dp[i][j] = min(dp[i][k] + dp[k][j]) + C[i][j]</code>인 경우</li><li>최적 분할점 k가 단조롭게 증가하는 경우 (Monotonicity)</li></ol><p>이 최적화를 통해 시간 복잡도를 O(n³)에서 O(n²)로 줄일 수 있다.</p><h3 id=기본적인-동적-계획법-문제>기본적인 동적 계획법 문제<a hidden class=anchor aria-hidden=true href=#기본적인-동적-계획법-문제>#</a></h3><h4 id=피보나치-수열fibonacci-sequence>피보나치 수열(Fibonacci Sequence)<a hidden class=anchor aria-hidden=true href=#피보나치-수열fibonacci-sequence>#</a></h4><p><figure><img alt="Dynamic Programming" loading=lazy src=/img/1_11q5g7hUiSwhQquyfXDXUg.png><figcaption>Source: https://www.enjoyalgorithms.com/blog/introduction-to-dynamic-programming</figcaption></figure></p><p><strong>하향식 접근법(메모이제이션):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_memoization</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>memo</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>memo</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>  <span class=c1># 기저 조건 초기화</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>  <span class=c1># 이미 계산된 값이 있으면 반환</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_memoization</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_memoization</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>상향식 접근법(테이블링):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_tabulation</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 테이블 채우기</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최장-증가-부분-수열longest-increasing-subsequence-lis>최장 증가 부분 수열(Longest Increasing Subsequence, LIS)<a hidden class=anchor aria-hidden=true href=#최장-증가-부분-수열longest-increasing-subsequence-lis>#</a></h4><p>주어진 수열에서 값이 증가하는 가장 긴 부분 수열의 길이를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># 각 위치에서 끝나는 LIS의 길이</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i]</code>는 <code>nums[i]</code>를 마지막 원소로 하는 최장 증가 부분 수열의 길이 상태<br>전이 방정식: <code>dp[i]</code> = <code>max(dp[i], dp[j] + 1)</code> for all <code>j &lt; i</code> where <code>nums[i] > nums[j]</code></p><h4 id=배낭-문제knapsack-problem>배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#배낭-문제knapsack-problem>#</a></h4><p>배낭 문제는 주어진 용량의 배낭에 가치가 최대가 되도록 물건을 담는 문제.</p><p><strong>0-1 배낭 문제</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_01</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>  <span class=c1># 현재 물건을 배낭에 넣을 수 있는 경우</span>
</span></span><span class=line><span class=cl>                <span class=c1># 물건을 넣는 경우와 넣지 않는 경우 중 최대값 선택</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>  <span class=c1># 현재 물건을 배낭에 넣을 수 없는 경우</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>  <span class=c1># 이전 상태 그대로 유지</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][w]</code>는 처음 i개 물건과 용량 w인 배낭으로 얻을 수 있는 최대 가치 상태<br>전이 방정식:</p><ul><li><code>dp[i][w]</code> = <code>max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])</code> if<code> weights[i-1] &lt;= w</code></li><li><code>dp[i][w]</code> = <code>dp[i-1][w]</code> otherwise</li></ul><h4 id=편집-거리edit-distance>편집 거리(Edit Distance)<a hidden class=anchor aria-hidden=true href=#편집-거리edit-distance>#</a></h4><p>두 문자열 사이의 최소 편집 거리를 계산하는 문제.<br>편집 연산은 삽입, 삭제, 대체를 포함.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit_distance</span><span class=p>(</span><span class=n>word1</span><span class=p>,</span> <span class=n>word2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>word1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>word2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기저 조건: 빈 문자열로 변환하는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>  <span class=c1># word1[:i]를 빈 문자열로 변환하려면 i번의 삭제 필요</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span>  <span class=c1># 빈 문자열을 word2[:j]로 변환하려면 j번의 삽입 필요</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>word1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>word2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>  <span class=c1># 현재 문자가 같으면 편집 불필요</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>  <span class=c1># 현재 문자가 다르면 세 가지 연산 중 최소값 선택</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=nb>min</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span>      <span class=c1># 삭제</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span>      <span class=c1># 삽입</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>     <span class=c1># 대체</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 <code>word1[:i]</code>를 <code>word2[:j]</code>로 변환하는 데 필요한 최소 편집 거리 상태<br>전이 방정식:</p><ul><li><code>dp[i][j]</code> = <code>dp[i-1][j-1]</code> if <code>word1[i-1] == word2[j-1]</code></li><li><code>dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])</code> otherwise</li></ul><h3 id=동적-계획법의-분류와-패턴>동적 계획법의 분류와 패턴<a hidden class=anchor aria-hidden=true href=#동적-계획법의-분류와-패턴>#</a></h3><h4 id=문제-유형별-분류>문제 유형별 분류<a hidden class=anchor aria-hidden=true href=#문제-유형별-분류>#</a></h4><ol><li><strong>최적화 문제(Optimization Problems)</strong>: 최대값이나 최소값을 찾는 문제<ul><li>최대 합 경로(Maximum Sum Path)</li><li>최소 비용 문제(Minimum Cost Problems)</li></ul></li><li><strong>계수 문제(Counting Problems)</strong>: 특정 조건을 만족하는 방법의 수를 세는 문제<ul><li>계단 오르기(Climbing Stairs)</li><li>조합의 수 계산(Combination Count)</li></ul></li><li><strong>결정 문제(Decision Problems)</strong>: 특정 조건을 만족하는 해가 존재하는지 여부를 판단하는 문제<ul><li>부분 집합의 합(Subset Sum)</li><li>문자열 매칭(String Matching)</li></ul></li></ol><h4 id=차원에-따른-분류>차원에 따른 분류<a hidden class=anchor aria-hidden=true href=#차원에-따른-분류>#</a></h4><ol><li><strong>1차원 DP</strong>: 상태가 하나의 변수로 표현되는 문제<ul><li>피보나치 수열</li><li>최대 부분 배열 합(Maximum Subarray Sum)</li></ul></li><li><strong>2차원 DP</strong>: 상태가 두 개의 변수로 표현되는 문제<ul><li>배낭 문제</li><li>최장 공통 부분 수열(Longest Common Subsequence)</li></ul></li><li><strong>다차원 DP</strong>: 상태가 세 개 이상의 변수로 표현되는 문제<ul><li>외판원 문제(Traveling Salesman Problem)의 특정 버전</li><li>일부 그래프 관련 DP 문제</li></ul></li></ol><h4 id=공통-패턴>공통 패턴<a hidden class=anchor aria-hidden=true href=#공통-패턴>#</a></h4><ol><li><strong>구간 DP(Interval DP)</strong>: 구간에 대한 연산을 다루는 문제<ul><li>행렬 곱셈 최적화(Matrix Chain Multiplication)</li><li>최적 이진 검색 트리(Optimal Binary Search Tree)</li></ul></li><li><strong>경로 DP(Path DP)</strong>: 그리드나 그래프에서 경로를 찾는 문제<ul><li>로봇 경로 계획(Robot Path Planning)</li><li>최소 경로 합(Minimum Path Sum)</li></ul></li><li><strong>비트마스크 DP(Bitmask DP)</strong>: 상태를 비트로 표현하는 문제<ul><li>외판원 문제(TSP)</li><li>집합 커버링(Set Covering)</li></ul></li><li><strong>트리 DP(Tree DP)</strong>: 트리 구조에서의 최적화 문제<ul><li>독립 집합(Independent Set) 문제</li><li>트리 지름(Tree Diameter) 계산</li></ul></li></ol><h3 id=동적-계획법의-한계-및-대안>동적 계획법의 한계 및 대안<a hidden class=anchor aria-hidden=true href=#동적-계획법의-한계-및-대안>#</a></h3><ol><li>문제의 한계<br>동적 계획법이 효과적이지 않은 경우도 있다:<ol><li><strong>상태 공간이 너무 큰 경우</strong>: 상태 변수가 많거나 값의 범위가 넓으면 메모리 요구량이 과도해질 수 있다.</li><li><strong>상태 전이 관계가 복잡한 경우</strong>: 하위 문제 간의 관계가 명확하지 않거나 복잡하면 DP 접근이 어려울 수 있다.</li><li><strong>중복되는 하위 문제가 적은 경우</strong>: 중복이 적으면 메모이제이션의 이점이 줄어들어 분할 정복이 더 효율적일 수 있다.</li><li><strong>그리디 접근이 최적인 경우</strong>: 일부 문제는 그리디 알고리즘으로 더 간단하고 효율적으로 해결할 수 있다.</li></ol></li><li>대체 접근법<br>동적 계획법의 한계를 극복하기 위한, 또는 특정 상황에서 더 적합할 수 있는 대안 접근법:<ol><li><strong>그리디 알고리즘(Greedy Algorithms)</strong>: 각 단계에서 지역적으로 최적인 선택을 하는 방식으로, 일부 최적화 문제에서 효과적.<ul><li>예: 활동 선택 문제, 허프만 코딩</li></ul></li><li><ol start=2><li>할 정복(Divide and Conquer)**: 중복되는 하위 문제가 적은 경우 더 효율적일 수 있다.</li></ol><ul><li>예: 합병 정렬, 퀵 정렬</li></ul></li><li><ol start=3><li>작위화 알고리즘(Randomized Algorithms)**: 확률적 요소를 도입하여 평균적으로 좋은 성능을 제공한다.</li></ol><ul><li>예: 퀵 정렬의 무작위 피벗 선택</li></ul></li><li><ol start=4><li>사 알고리즘(Approximation Algorithms)**: NP-난해 문제에 대해 근사적인 해를 효율적으로 찾는다.</li></ol><ul><li>예: 여행자 문제의 2-근사 알고리즘</li></ul></li><li><ol start=5><li>타휴리스틱(Metaheuristics)**: 복잡한 최적화 문제를 위한 일반적인 검색 전략이다.</li></ol><ul><li>예: 유전 알고리즘, 시뮬레이티드 어닐링, 개미 군집 최적화</li></ul></li></ol></li><li>하이브리드 접근법<br>여러 알고리즘 기법을 결합하여 각 접근법의 장점을 활용할 수 있다:<ol><li><strong>DP + 그리디</strong>: 문제를 부분적으로는 DP로, 부분적으로는 그리디로 접근한다.<ul><li>예: 일부 스케줄링 문제</li></ul></li><li><ol start=2><li>P + 이진 검색**: 최적화 문제를 결정 문제로 변환하여 이진 검색으로 해결한다.</li></ol><ul><li>예: 특정 파라미터화된 DP 문제</li></ul></li><li><ol start=3><li>P + 분할 정복**: 분할 정복으로 문제를 나누고 DP로 하위 문제를 해결한다.</li></ol><ul><li>예: 일부 구간 DP 문제</li></ul></li></ol></li></ol><h3 id=실제-구현-및-최적화-기법>실제 구현 및 최적화 기법<a hidden class=anchor aria-hidden=true href=#실제-구현-및-최적화-기법>#</a></h3><h4 id=재귀와-반복적-구현-비교>재귀와 반복적 구현 비교<a hidden class=anchor aria-hidden=true href=#재귀와-반복적-구현-비교>#</a></h4><p>동적 계획법은 재귀적(하향식) 또는 반복적(상향식) 방식으로 구현할 수 있으며, 각각 장단점이 있다:</p><p><strong>재귀적 구현(하향식, 메모이제이션)</strong>:</p><ul><li><strong>장점</strong>: 직관적이고 자연스러운 구현, 필요한 상태만 계산</li><li><strong>단점</strong>: 함수 호출 오버헤드, 스택 오버플로 위험</li><li><strong>적합한 경우</strong>: 상태 공간의 일부만 탐색하는 경우, 상태 정의가 복잡한 경우</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8>8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fib_recursive</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>memo</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>memo</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fib_recursive</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fib_recursive</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>반복적 구현(상향식, 테이블링)</strong>:</p><ul><li><strong>장점</strong>: 함수 호출 오버헤드 없음, 메모리 관리 용이</li><li><strong>단점</strong>: 모든 상태를 계산해야 함, 구현이 덜 직관적일 수 있음</li><li><strong>적합한 경우</strong>: 대부분의 상태가 필요한 경우, 상태 간 의존성이 명확한 경우</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fib_iterative</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=메모리-사용-최적화-기법>메모리 사용 최적화 기법<a hidden class=anchor aria-hidden=true href=#메모리-사용-최적화-기법>#</a></h4><p>DP 구현에서 메모리 사용을 최적화하는 다양한 기법:</p><ol><li><p><strong>롤링 배열(Rolling Array)</strong>: 이전 상태의 일부만 필요한 경우, 전체 테이블 대신 필요한 부분만 유지한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fib_rolling_array</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>,</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>b</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>인접 상태만 저장</strong>: 직전 상태만 필요한 2차원 DP 문제에서 공간을 줄일 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_path_sum_optimized</span><span class=p>(</span><span class=n>grid</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>grid</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>grid</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 행 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 나머지 행 처리</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+=</span> <span class=n>grid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># 첫 번째 열 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=o>+</span> <span class=n>grid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>희소 테이블(Sparse Table)</strong>: 모든 상태가 아닌 필요한 상태만 해시 맵에 저장한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit_distance_sparse</span><span class=p>(</span><span class=n>word1</span><span class=p>,</span> <span class=n>word2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dp</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>memo</span><span class=p>[(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>j</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>word1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>word2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>memo</span><span class=p>[(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>memo</span><span class=p>[(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>memo</span><span class=p>),</span> <span class=n>dp</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>),</span> <span class=n>dp</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>word1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>word2</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=병렬화-및-분산-계산>병렬화 및 분산 계산<a hidden class=anchor aria-hidden=true href=#병렬화-및-분산-계산>#</a></h4><p>대규모 DP 문제에서 계산을 가속화하기 위한 기법:</p><ol><li><p><strong>단계별 병렬화</strong>: 같은 단계의 상태는 서로 독립적으로 계산할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parallel_dp_example</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>num_threads</span><span class=o>=</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>concurrent.futures</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>  <span class=c1># 기저 조건</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 각 단계별로 병렬 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 이 단계에서 계산해야 할 상태들</span>
</span></span><span class=line><span class=cl>        <span class=n>states</span> <span class=o>=</span> <span class=n>get_states</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>  <span class=c1># 문제에 따라 다름</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>concurrent</span><span class=o>.</span><span class=n>futures</span><span class=o>.</span><span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=n>max_workers</span><span class=o>=</span><span class=n>num_threads</span><span class=p>)</span> <span class=k>as</span> <span class=n>executor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 각 상태를 병렬로 계산</span>
</span></span><span class=line><span class=cl>            <span class=n>future_to_state</span> <span class=o>=</span> <span class=p>{</span><span class=n>executor</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=n>compute_state</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>dp</span><span class=p>):</span> <span class=n>j</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>states</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>future</span> <span class=ow>in</span> <span class=n>concurrent</span><span class=o>.</span><span class=n>futures</span><span class=o>.</span><span class=n>as_completed</span><span class=p>(</span><span class=n>future_to_state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>state</span> <span class=o>=</span> <span class=n>future_to_state</span><span class=p>[</span><span class=n>future</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>state</span><span class=p>]</span> <span class=o>=</span> <span class=n>future</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>exc</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;상태 </span><span class=si>{</span><span class=n>state</span><span class=si>}</span><span class=s1> 계산 중 오류: </span><span class=si>{</span><span class=n>exc</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>GPU 가속</strong>: 행렬 연산이 많은 DP 문제는 GPU를 활용하여 가속화할 수 있다.</p></li><li><p><strong>맵리듀스(MapReduce)</strong>: 대규모 DP 문제를 분산 환경에서 해결할 수 있다.<br>이러한 병렬화 기법은 상태 간 의존성이 적은 문제에서 특히 효과적이다.</p></li></ol><h3 id=중급-동적-계획법-문제>중급 동적 계획법 문제<a hidden class=anchor aria-hidden=true href=#중급-동적-계획법-문제>#</a></h3><h4 id=최장-공통-부분-수열longest-common-subsequence-lcs>최장 공통 부분 수열(Longest Common Subsequence, LCS)<a hidden class=anchor aria-hidden=true href=#최장-공통-부분-수열longest-common-subsequence-lcs>#</a></h4><p>두 문자열에서 순서가 유지되는 가장 긴 공통 부분 수열의 길이를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_common_subsequence</span><span class=p>(</span><span class=n>text1</span><span class=p>,</span> <span class=n>text2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>text1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>text2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>text1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>text2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 <code>text1[:i]</code>와 <code>text2[:j]</code>의 최장 공통 부분 수열의 길이<br>상태 전이 방정식:</p><ul><li><code>dp[i][j] = dp[i-1][j-1] + 1 if text1[i-1] == text2[j-1]</code></li><li><code>dp[i][j] = max(dp[i-1][j], dp[i][j-1]) otherwise</code></li></ul><h4 id=최대-부분-배열-합maximum-subarray-sum>최대 부분 배열 합(Maximum Subarray Sum)<a hidden class=anchor aria-hidden=true href=#최대-부분-배열-합maximum-subarray-sum>#</a></h4><p>연속된 부분 배열 중 합이 최대인 부분 배열의 합을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>maximum_subarray</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># dp[i]는 nums[i]로 끝나는 최대 부분 배열 합</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i]</code>는 <code>nums[i]</code>를 마지막 원소로 포함하는 최대 부분 배열 합<br>상태 전이 방정식: <code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code></p><h4 id=동전-교환-문제coin-change>동전 교환 문제(Coin Change)<a hidden class=anchor aria-hidden=true href=#동전-교환-문제coin-change>#</a></h4><p>주어진 금액을 만들기 위해 필요한 최소한의 동전 개수를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>coin_change</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i]는 금액 i를 만드는 데 필요한 최소 동전 개수</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=p>(</span><span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 금액 0은 동전 0개로 만들 수 있음</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>coin</span><span class=p>,</span> <span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>coin</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i]</code>는 금액 i를 만드는 데 필요한 최소 동전 개수<br>상태 전이 방정식: <code>dp[i] = min(dp[i], dp[i - coin] + 1) for all available coins</code></p><h4 id=행렬-경로-문제matrix-path-problems>행렬 경로 문제(Matrix Path Problems)<a hidden class=anchor aria-hidden=true href=#행렬-경로-문제matrix-path-problems>#</a></h4><p>그리드에서 특정 시작점에서 목표점까지의 최적 경로를 찾는 문제.</p><p><strong>최소 경로 합(Minimum Path Sum):</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_path_sum</span><span class=p>(</span><span class=n>grid</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>grid</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>grid</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 행 초기화</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>grid</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 열 초기화</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>grid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 나머지 셀 채우기</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=o>+</span> <span class=n>grid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 (0,0)에서 (i,j)까지의 최소 경로 합<br>상태 전이 방정식: <code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></p><h3 id=고급-동적-계획법-기법>고급 동적 계획법 기법<a hidden class=anchor aria-hidden=true href=#고급-동적-계획법-기법>#</a></h3><h4 id=상태-압축state-compression>상태 압축(State Compression)<a hidden class=anchor aria-hidden=true href=#상태-압축state-compression>#</a></h4><p>상태를 비트로 표현하여 메모리 사용량을 줄이는 기법.<br>특히 집합을 다루는 문제에서 유용하다.</p><p><strong>외판원 문제(TSP)의 DP 접근법:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>traveling_salesman</span><span class=p>(</span><span class=n>distances</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>distances</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[mask][i]는 방문한 도시 집합이 mask이고 현재 도시가 i일 때의 최소 거리</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 시작 도시는 0으로 가정</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 비트마스크 1은 0번 도시만 방문했음을 나타냄</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>mask</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재 마스크에 i번 도시가 포함되어 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># i번 도시를 마지막으로 방문했을 때의 이전 마스크</span>
</span></span><span class=line><span class=cl>            <span class=n>prev_mask</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>prev_mask</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># i가 시작 도시인 경우</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>prev_mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>):</span>  <span class=c1># j번 도시가 이전에 방문되었는지 확인</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>mask</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>mask</span><span class=p>][</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>prev_mask</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>distances</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 도시를 방문하고 0번 도시로 돌아오는 최소 거리</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>distances</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=확률적-dpprobabilistic-dp>확률적 DP(Probabilistic DP)<a hidden class=anchor aria-hidden=true href=#확률적-dpprobabilistic-dp>#</a></h4><p>확률과 기대값을 다루는 문제에 DP를 적용하는 기법.</p><p><strong>동전 던지기 기대값:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>expected_coin_flips</span><span class=p>(</span><span class=n>p_heads</span><span class=p>,</span> <span class=n>target_heads</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i]는 이미 i개의 앞면이 나왔을 때, 목표에 도달하기 위한 기대 던지기 횟수</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>target_heads</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>target_heads</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 다음 던지기에서 앞면이 나올 확률 p_heads</span>
</span></span><span class=line><span class=cl>        <span class=c1># dp[i] = 1 (현재 던지기) + p_heads * dp[i+1] (앞면이 나온 경우) + (1-p_heads) * dp[i] (뒷면이 나온 경우)</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>p_heads</span> <span class=o>*</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=o>-</span><span class=n>p_heads</span><span class=p>)</span> <span class=o>*</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>+</span> <span class=n>p_heads</span> <span class=o>*</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=o>/</span> <span class=n>p_heads</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=구간-dpinterval-dp>구간 DP(Interval DP)<a hidden class=anchor aria-hidden=true href=#구간-dpinterval-dp>#</a></h4><p>특정 구간에 대한 연산을 최적화하는 문제에 적용되는 기법.</p><p><strong>행렬 곱셈 최적화:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>matrix_chain_multiplication</span><span class=p>(</span><span class=n>dimensions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>dimensions</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>  <span class=c1># 행렬의 개수</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j]는 i번째 행렬부터 j번째 행렬까지 곱하는 데 필요한 최소 연산 수</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>  <span class=c1># 부분 체인의 길이</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>):</span>  <span class=c1># i와 j 사이의 분할점</span>
</span></span><span class=line><span class=cl>                <span class=n>operations</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>dimensions</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>dimensions</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>dimensions</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>operations</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 i번째 행렬부터 j번째 행렬까지 곱하는 데 필요한 최소 연산 수<br>상태 전이 방정식: <code>dp[i][j] = min(dp[i][k] + dp[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1]) for all k in range(i, j)</code></p><h4 id=결정적-dpdecision-dp>결정적 DP(Decision DP)<a hidden class=anchor aria-hidden=true href=#결정적-dpdecision-dp>#</a></h4><p>최적의 결정 또는 선택 시퀀스를 찾는 문제에 적용되는 기법.</p><p><strong>최적 이진 검색 트리:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19>19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20>20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21>21</a>
</span><span class=lnt id=hl-21-22><a class=lnlinks href=#hl-21-22>22</a>
</span><span class=lnt id=hl-21-23><a class=lnlinks href=#hl-21-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>optimal_bst</span><span class=p>(</span><span class=n>keys</span><span class=p>,</span> <span class=n>freq</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>keys</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j]는 keys[i:j+1]로 구성된 최적 BST의 기대 탐색 비용</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 1인 부분 키 배열에 대한 초기화</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>freq</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>  <span class=c1># 부분 배열의 길이</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 구간 합 계산</span>
</span></span><span class=line><span class=cl>            <span class=n>freq_sum</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>freq</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>  <span class=c1># i부터 j까지의 모든 키를 루트로 시도</span>
</span></span><span class=line><span class=cl>                <span class=n>left_cost</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>r</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>r</span> <span class=o>&gt;</span> <span class=n>i</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=n>right_cost</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>r</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=k>if</span> <span class=n>r</span> <span class=o>&lt;</span> <span class=n>j</span> <span class=k>else</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>left_cost</span> <span class=o>+</span> <span class=n>right_cost</span> <span class=o>+</span> <span class=n>freq_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실제-응용-사례-및-문제>실제 응용 사례 및 문제<a hidden class=anchor aria-hidden=true href=#실제-응용-사례-및-문제>#</a></h3><h4 id=문자열-처리-문제>문자열 처리 문제<a hidden class=anchor aria-hidden=true href=#문자열-처리-문제>#</a></h4><h5 id=팰린드롬-부분-문자열>팰린드롬 부분 문자열<a hidden class=anchor aria-hidden=true href=#팰린드롬-부분-문자열>#</a></h5><p>가장 긴 팰린드롬 부분 문자열을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12>12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13>13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14>14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15>15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16>16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17>17</a>
</span><span class=lnt id=hl-22-18><a class=lnlinks href=#hl-22-18>18</a>
</span><span class=lnt id=hl-22-19><a class=lnlinks href=#hl-22-19>19</a>
</span><span class=lnt id=hl-22-20><a class=lnlinks href=#hl-22-20>20</a>
</span><span class=lnt id=hl-22-21><a class=lnlinks href=#hl-22-21>21</a>
</span><span class=lnt id=hl-22-22><a class=lnlinks href=#hl-22-22>22</a>
</span><span class=lnt id=hl-22-23><a class=lnlinks href=#hl-22-23>23</a>
</span><span class=lnt id=hl-22-24><a class=lnlinks href=#hl-22-24>24</a>
</span><span class=lnt id=hl-22-25><a class=lnlinks href=#hl-22-25>25</a>
</span><span class=lnt id=hl-22-26><a class=lnlinks href=#hl-22-26>26</a>
</span><span class=lnt id=hl-22-27><a class=lnlinks href=#hl-22-27>27</a>
</span><span class=lnt id=hl-22-28><a class=lnlinks href=#hl-22-28>28</a>
</span><span class=lnt id=hl-22-29><a class=lnlinks href=#hl-22-29>29</a>
</span><span class=lnt id=hl-22-30><a class=lnlinks href=#hl-22-30>30</a>
</span><span class=lnt id=hl-22-31><a class=lnlinks href=#hl-22-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_palindromic_substring</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>s</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j]는 s[i:j+1]이 팰린드롬인지 여부</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>start</span><span class=p>,</span> <span class=n>max_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 길이 1인 부분 문자열은 팰린드롬</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 2인 부분 문자열 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=n>max_len</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 길이 3 이상인 부분 문자열 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=ow>and</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                <span class=n>start</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                <span class=n>max_len</span> <span class=o>=</span> <span class=n>length</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>start</span> <span class=o>+</span> <span class=n>max_len</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 <code>s[i:j+1]</code>이 팰린드롬인지 여부<br>상태 전이 방정식: <code>dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]</code></p><h5 id=정규-표현식-매칭>정규 표현식 매칭<a hidden class=anchor aria-hidden=true href=#정규-표현식-매칭>#</a></h5><p>문자열이 주어진 패턴과 매칭되는지 확인하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14>14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15>15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16>16</a>
</span><span class=lnt id=hl-23-17><a class=lnlinks href=#hl-23-17>17</a>
</span><span class=lnt id=hl-23-18><a class=lnlinks href=#hl-23-18>18</a>
</span><span class=lnt id=hl-23-19><a class=lnlinks href=#hl-23-19>19</a>
</span><span class=lnt id=hl-23-20><a class=lnlinks href=#hl-23-20>20</a>
</span><span class=lnt id=hl-23-21><a class=lnlinks href=#hl-23-21>21</a>
</span><span class=lnt id=hl-23-22><a class=lnlinks href=#hl-23-22>22</a>
</span><span class=lnt id=hl-23-23><a class=lnlinks href=#hl-23-23>23</a>
</span><span class=lnt id=hl-23-24><a class=lnlinks href=#hl-23-24>24</a>
</span><span class=lnt id=hl-23-25><a class=lnlinks href=#hl-23-25>25</a>
</span><span class=lnt id=hl-23-26><a class=lnlinks href=#hl-23-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_match</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>p</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j]는 s[:i]와 p[:j]가 매칭되는지 여부</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 빈 문자열과 빈 패턴은 매칭됨</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 빈 문자열과 패턴의 매칭 처리 (패턴이 a*b*c* 형태인 경우)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;*&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;*&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 패턴의 이전 문자를 0번 사용하는 경우</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 패턴의 이전 문자를 1번 이상 사용하는 경우</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;.&#39;</span> <span class=ow>or</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=ow>or</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=s1>&#39;.&#39;</span> <span class=ow>or</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 <code>s[:i]</code>와 <code>p[:j]</code>가 매칭되는지 여부<br>상태 전이 방정식은 패턴의 현재 문자에 따라 다르다.</p><h4 id=그래프-문제>그래프 문제<a hidden class=anchor aria-hidden=true href=#그래프-문제>#</a></h4><h5 id=최단-경로-문제>최단 경로 문제<a hidden class=anchor aria-hidden=true href=#최단-경로-문제>#</a></h5><p>플로이드-워셜(Floyd-Warshall) 알고리즘은 모든 정점 쌍 간의 최단 경로를 찾는 DP 기반 알고리즘이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1> 1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2> 2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3> 3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4> 4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5> 5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6> 6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7> 7</a>
</span><span class=lnt id=hl-24-8><a class=lnlinks href=#hl-24-8> 8</a>
</span><span class=lnt id=hl-24-9><a class=lnlinks href=#hl-24-9> 9</a>
</span><span class=lnt id=hl-24-10><a class=lnlinks href=#hl-24-10>10</a>
</span><span class=lnt id=hl-24-11><a class=lnlinks href=#hl-24-11>11</a>
</span><span class=lnt id=hl-24-12><a class=lnlinks href=#hl-24-12>12</a>
</span><span class=lnt id=hl-24-13><a class=lnlinks href=#hl-24-13>13</a>
</span><span class=lnt id=hl-24-14><a class=lnlinks href=#hl-24-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>floyd_warshall</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[:]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>]</span>  <span class=c1># 그래프의 인접 행렬 복사</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 정점을 중간 정점으로 고려</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 정점 쌍에 대해</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># i에서 k를 거쳐 j로 가는 경로가 더 짧은지 확인</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dist</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dist[i][j]</code>는 정점 i에서 j까지의 최단 거리<br>상태 전이 방정식: <code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</code></p><h5 id=최장-경로-문제>최장 경로 문제<a hidden class=anchor aria-hidden=true href=#최장-경로-문제>#</a></h5><p>유향 비순환 그래프(DAG)에서의 최장 경로 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1> 1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2> 2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3> 3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4> 4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5> 5</a>
</span><span class=lnt id=hl-25-6><a class=lnlinks href=#hl-25-6> 6</a>
</span><span class=lnt id=hl-25-7><a class=lnlinks href=#hl-25-7> 7</a>
</span><span class=lnt id=hl-25-8><a class=lnlinks href=#hl-25-8> 8</a>
</span><span class=lnt id=hl-25-9><a class=lnlinks href=#hl-25-9> 9</a>
</span><span class=lnt id=hl-25-10><a class=lnlinks href=#hl-25-10>10</a>
</span><span class=lnt id=hl-25-11><a class=lnlinks href=#hl-25-11>11</a>
</span><span class=lnt id=hl-25-12><a class=lnlinks href=#hl-25-12>12</a>
</span><span class=lnt id=hl-25-13><a class=lnlinks href=#hl-25-13>13</a>
</span><span class=lnt id=hl-25-14><a class=lnlinks href=#hl-25-14>14</a>
</span><span class=lnt id=hl-25-15><a class=lnlinks href=#hl-25-15>15</a>
</span><span class=lnt id=hl-25-16><a class=lnlinks href=#hl-25-16>16</a>
</span><span class=lnt id=hl-25-17><a class=lnlinks href=#hl-25-17>17</a>
</span><span class=lnt id=hl-25-18><a class=lnlinks href=#hl-25-18>18</a>
</span><span class=lnt id=hl-25-19><a class=lnlinks href=#hl-25-19>19</a>
</span><span class=lnt id=hl-25-20><a class=lnlinks href=#hl-25-20>20</a>
</span><span class=lnt id=hl-25-21><a class=lnlinks href=#hl-25-21>21</a>
</span><span class=lnt id=hl-25-22><a class=lnlinks href=#hl-25-22>22</a>
</span><span class=lnt id=hl-25-23><a class=lnlinks href=#hl-25-23>23</a>
</span><span class=lnt id=hl-25-24><a class=lnlinks href=#hl-25-24>24</a>
</span><span class=lnt id=hl-25-25><a class=lnlinks href=#hl-25-25>25</a>
</span><span class=lnt id=hl-25-26><a class=lnlinks href=#hl-25-26>26</a>
</span><span class=lnt id=hl-25-27><a class=lnlinks href=#hl-25-27>27</a>
</span><span class=lnt id=hl-25-28><a class=lnlinks href=#hl-25-28>28</a>
</span><span class=lnt id=hl-25-29><a class=lnlinks href=#hl-25-29>29</a>
</span><span class=lnt id=hl-25-30><a class=lnlinks href=#hl-25-30>30</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_path_in_dag</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 위상 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>in_degree</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>in_degree</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=k>if</span> <span class=n>in_degree</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>topo_order</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>topo_order</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>in_degree</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>in_degree</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최장 경로 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>in_degree</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># 시작점</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span> <span class=ow>in</span> <span class=n>topo_order</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>u</span><span class=p>]</span> <span class=o>+</span> <span class=n>weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>dist</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>dist</span><span class=p>[</span><span class=n>u</span><span class=p>]</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dist</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dist[i]</code>는 시작점에서 정점 i까지의 최장 경로 길이<br>상태 전이 방정식: <code>dist[v] = max(dist[v], dist[u] + weight) for all edges (u,v)</code></p><h4 id=게임-이론-문제>게임 이론 문제<a hidden class=anchor aria-hidden=true href=#게임-이론-문제>#</a></h4><h5 id=님-게임nim-game>님 게임(Nim Game)<a hidden class=anchor aria-hidden=true href=#님-게임nim-game>#</a></h5><p>여러 개의 돌 더미에서 번갈아가며 돌을 가져가는 님 게임의 승자를 결정하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5>5</a>
</span><span class=lnt id=hl-26-6><a class=lnlinks href=#hl-26-6>6</a>
</span><span class=lnt id=hl-26-7><a class=lnlinks href=#hl-26-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>can_win_nim</span><span class=p>(</span><span class=n>piles</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># XOR 합이 0이 아니면 첫 번째 플레이어가 이길 수 있음</span>
</span></span><span class=line><span class=cl>    <span class=n>xor_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>pile</span> <span class=ow>in</span> <span class=n>piles</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>xor_sum</span> <span class=o>^=</span> <span class=n>pile</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>xor_sum</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>이 문제는 스프라그-그런디 정리(Sprague-Grundy Theorem)를 사용하여 해결할 수 있다.</p><h5 id=돌-게임stone-game>돌 게임(Stone Game)<a hidden class=anchor aria-hidden=true href=#돌-게임stone-game>#</a></h5><p>두 플레이어가 번갈아가며 양끝에서 돌을 가져가는 게임에서 최적의 전략을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1> 1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2> 2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3> 3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4> 4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5> 5</a>
</span><span class=lnt id=hl-27-6><a class=lnlinks href=#hl-27-6> 6</a>
</span><span class=lnt id=hl-27-7><a class=lnlinks href=#hl-27-7> 7</a>
</span><span class=lnt id=hl-27-8><a class=lnlinks href=#hl-27-8> 8</a>
</span><span class=lnt id=hl-27-9><a class=lnlinks href=#hl-27-9> 9</a>
</span><span class=lnt id=hl-27-10><a class=lnlinks href=#hl-27-10>10</a>
</span><span class=lnt id=hl-27-11><a class=lnlinks href=#hl-27-11>11</a>
</span><span class=lnt id=hl-27-12><a class=lnlinks href=#hl-27-12>12</a>
</span><span class=lnt id=hl-27-13><a class=lnlinks href=#hl-27-13>13</a>
</span><span class=lnt id=hl-27-14><a class=lnlinks href=#hl-27-14>14</a>
</span><span class=lnt id=hl-27-15><a class=lnlinks href=#hl-27-15>15</a>
</span><span class=lnt id=hl-27-16><a class=lnlinks href=#hl-27-16>16</a>
</span><span class=lnt id=hl-27-17><a class=lnlinks href=#hl-27-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>stone_game</span><span class=p>(</span><span class=n>piles</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>piles</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j]는 piles[i:j+1]에서 선공이 후공보다 얼마나 많이 가져갈 수 있는지</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기저 조건: 돌이 하나만 있는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>piles</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>length</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=c1># 선공이 왼쪽(piles[i]) 또는 오른쪽(piles[j])을 선택한 후,</span>
</span></span><span class=line><span class=cl>            <span class=c1># 새로운 게임에서는 선공과 후공의 역할이 바뀜</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>piles</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>piles</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>-</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span>  <span class=c1># 선공이 이길 수 있는지 여부</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 <code>piles[i:j+1]</code>에서 선공이 후공보다 얼마나 많이 가져갈 수 있는지<br>상태 전이 방정식: <code>dp[i][j] = max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1])</code></p><h4 id=확률-및-기대값-문제>확률 및 기대값 문제<a hidden class=anchor aria-hidden=true href=#확률-및-기대값-문제>#</a></h4><h5 id=주식-거래-최적-시점best-time-to-buy-and-sell-stock>주식 거래 최적 시점(Best Time to Buy and Sell Stock)<a hidden class=anchor aria-hidden=true href=#주식-거래-최적-시점best-time-to-buy-and-sell-stock>#</a></h5><p>주식 가격 배열이 주어졌을 때, 최대 이익을 얻을 수 있는 거래 방법을 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1> 1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2> 2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3> 3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4> 4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5> 5</a>
</span><span class=lnt id=hl-28-6><a class=lnlinks href=#hl-28-6> 6</a>
</span><span class=lnt id=hl-28-7><a class=lnlinks href=#hl-28-7> 7</a>
</span><span class=lnt id=hl-28-8><a class=lnlinks href=#hl-28-8> 8</a>
</span><span class=lnt id=hl-28-9><a class=lnlinks href=#hl-28-9> 9</a>
</span><span class=lnt id=hl-28-10><a class=lnlinks href=#hl-28-10>10</a>
</span><span class=lnt id=hl-28-11><a class=lnlinks href=#hl-28-11>11</a>
</span><span class=lnt id=hl-28-12><a class=lnlinks href=#hl-28-12>12</a>
</span><span class=lnt id=hl-28-13><a class=lnlinks href=#hl-28-13>13</a>
</span><span class=lnt id=hl-28-14><a class=lnlinks href=#hl-28-14>14</a>
</span><span class=lnt id=hl-28-15><a class=lnlinks href=#hl-28-15>15</a>
</span><span class=lnt id=hl-28-16><a class=lnlinks href=#hl-28-16>16</a>
</span><span class=lnt id=hl-28-17><a class=lnlinks href=#hl-28-17>17</a>
</span><span class=lnt id=hl-28-18><a class=lnlinks href=#hl-28-18>18</a>
</span><span class=lnt id=hl-28-19><a class=lnlinks href=#hl-28-19>19</a>
</span><span class=lnt id=hl-28-20><a class=lnlinks href=#hl-28-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_profit</span><span class=p>(</span><span class=n>prices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>prices</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>prices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j]는 i일에 j상태일 때의 최대 이익 (j: 0=현금 보유, 1=주식 보유)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기저 조건</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 0일에 현금 보유</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=n>prices</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># 0일에 주식 구매</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현금 보유: 전날 현금 그대로 또는 전날 주식 팔기</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1># 주식 보유: 전날 주식 그대로 또는 전날 현금으로 주식 구매</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 마지막 날에는 현금을 갖고 있는 것이 최적</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>상태 정의: <code>dp[i][j]</code>는 i일에 j상태일 때의 최대 이익<br>상태 전이 방정식:</p><ul><li><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</code></li><li><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])</code></li></ul><h3 id=최근-연구-및-동향>최근 연구 및 동향<a hidden class=anchor aria-hidden=true href=#최근-연구-및-동향>#</a></h3><ol><li>강화 학습과의 연관성<br>동적 계획법은 강화 학습의 이론적 기반을 제공한다:<ol><li><strong>벨만 방정식(Bellman Equation)</strong>: 강화 학습의 핵심인 벨만 방정식은 동적 계획법의 원리에 기반한다.</li><li><strong>가치 반복(Value Iteration)과 정책 반복(Policy Iteration)</strong>: 이 두 알고리즘은 마르코프 결정 과정(MDP)에서 최적 정책을 찾기 위한 DP 기반 방법이다.</li><li><strong>Q-learning과 SARSA</strong>: 이러한 모델 프리(model-free) 강화 학습 알고리즘도 DP의 개념을 확장한 것이다.</li><li><strong>심층 강화 학습(Deep Reinforcement Learning)</strong>: DQN(Deep Q-Network)과 같은 알고리즘은 신경망을 사용하여 DP의 한계를 극복한다.</li></ol></li><li>근사 동적 계획법(Approximate Dynamic Programming)<br>대규모 상태 공간을 다루기 위한 DP의 확장:<ol><li><strong>함수 근사기(Function Approximation)</strong>: 모든 상태의 값을 저장하는 대신, 함수(예: 신경망)를 사용하여 값을 근사한다.</li><li><strong>차원 축소(Dimensionality Reduction)</strong>: 고차원 상태 공간을 저차원으로 매핑하여 다루기 쉽게 만든다.</li><li><strong>시뮬레이션 기반 최적화(Simulation-Based Optimization)</strong>: 몬테카를로 시뮬레이션을 사용하여 상태 값을 추정한다.</li><li><strong>시간차 학습(Temporal Difference Learning)</strong>: 샘플 기반 방법으로 벨만 방정식을 근사적으로 해결한다.</li></ol></li><li>메타 동적 계획법(Meta Dynamic Programming)<br>동적 계획법 자체를 최적화하거나 자동화하는 연구:<ol><li><strong>자동 상태 설계(Automatic State Design)</strong>: 문제에 맞는 최적의 상태 표현을 자동으로 찾는다.</li><li><strong>알고리즘 포트폴리오(Algorithm Portfolios)</strong>: 여러 DP 알고리즘을 조합하여 문제에 맞게 적용한다.</li><li><strong>하이퍼파라미터 최적화(Hyperparameter Optimization)</strong>: DP 알고리즘의 파라미터를 자동으로 튜닝한다.</li><li><strong>신경 동적 계획법(Neural Dynamic Programming)</strong>: 신경망과 DP를 결합하여 복잡한 구조적 예측 문제를 해결한다.</li></ol></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dynamic Programming vs. Divide and Conquer</h2></header><div class=entry-content><p>Divide and Conquer vs. Dynamic Programming “Divide and Conquer"와 “Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.
분할 정복은 문제를 독립적인 하위 문제로 나누어 효율성을 높이는 반면, 동적 계획법은 중복되는 하위 문제의 결과를 저장하여 재계산을 방지한다.
알고리즘 선택은 문제의 성격에 따라 달라져야 한다.
하위 문제 간 중복이 있는지, 최적 부분 구조가 있는지를 파악하여 적절한 알고리즘을 선택하는 것이 중요하다.
Divide and Conquer(분할 정복) 알고리즘 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 다음과 같은 세 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-12-09 05:08:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dynamic Programming vs. Divide and Conquer" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Principles of Dynamic Programming</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-01-22 14:02:00 +0000 UTC'>January 22, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Principles of Dynamic Programming" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Approaches of Dynamic Programming</h2></header><div class=entry-content><p>동적 계획법(Dynamic Programming)의 Top-down과 Bottom-up 접근법 비교 분석 동적 계획법은 복잡한 문제를 더 작은 하위 문제로 나누어 해결하는 알고리즘 설계 기법.
실제 개발 과정에서는 때로 두 접근법을 모두 시도해보고 특정 문제에 더 적합한 방식을 선택하는 것이 현명하다.
또한, 문제 해결 과정에서 Top-down 접근으로 먼저 문제를 이해하고 해결책을 구상한 후, 성능이 중요한 경우 Bottom-up 방식으로 최적화하는 개발 전략도 효과적이다.
기본 개념 비교 Top-down 접근법 (하향식) Top-down 접근법은 주어진 문제를 재귀적으로 더 작은 하위 문제로 분할하여 해결한다.
이미 계산된 하위 문제의 결과를 메모리에 저장(메모이제이션)하여 중복 계산을 피한다. 큰 문제에서 시작하여 작은 문제로 내려가는 방식이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 11:25:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approaches of Dynamic Programming" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/approaches/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Components of Dynamic Programming</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-01-22 14:03:00 +0000 UTC'>January 22, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Components of Dynamic Programming" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/components/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>