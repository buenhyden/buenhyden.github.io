<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>조건 변수 (Condition Variable) | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,Concurrency-and-Parallelism,Synchronization,Condition-Synchronization,Condition-Variables,Spurious-Wakeup"><meta name=description content="조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/condition-synchronization/implementation-mechanisms/condition-variable/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/condition-synchronization/implementation-mechanisms/condition-variable/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/condition-synchronization/implementation-mechanisms/condition-variable/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="조건 변수 (Condition Variable)"><meta property="og:description" content="조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-04T10:54:00+00:00"><meta property="article:modified_time" content="2024-10-04T10:54:00+00:00"><meta property="article:tag" content="Computer-Science-Fundamentals"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Process-Management"><meta property="article:tag" content="Concurrency-and-Parallelism"><meta property="article:tag" content="Synchronization"><meta property="article:tag" content="Condition-Synchronization"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="조건 변수 (Condition Variable)"><meta name=twitter:description content="조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"조건 변수 (Condition Variable)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/condition-synchronization/implementation-mechanisms/condition-variable/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"조건 변수 (Condition Variable)","name":"조건 변수 (Condition Variable)","description":"조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.","keywords":["Computer-Science-Fundamentals","Operating-systems","Process-Management","Concurrency-and-Parallelism","Synchronization","Condition-Synchronization","Condition-Variables","Spurious-Wakeup"],"articleBody":"조건 변수 (Condition Variable) 조건 변수 (Condition Variables) 는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.\n스레드가 특정 조건이 만족될 때까지 대기하고, 조건이 충족되면 다른 스레드가 대기 중인 스레드를 깨우는 데 사용된다.\n뮤텍스와의 연관 조건 변수는 일반적으로 뮤텍스와 함께 사용된다.\n뮤텍스는 조건을 원자적으로 검사하고 변경할 수 있도록 보장한다.\n주요 연산 wait(): 스레드가 조건이 충족될 때까지 대기하도록 한다. signal()/notify_one(): 대기 중인 단일 스레드를 깨운다. broadcast()/notify_all(): 해당 조건 변수에서 대기 중인 모든 스레드를 깨운다. 사용 패턴 조건을 보호하는 뮤텍스를 획득한다. 조건을 테스트한다. 조건이 거짓이면 wait() 를 호출하여 대기한다. 조건이 참이면 작업을 수행하고 뮤텍스를 해제한다. 가짜 깨우기 (Spurious Wakeup) 가짜 깨우기는 조건 변수 (Condition Variable) 를 사용할 때 발생할 수 있는 현상이다.\n스레드가 실제로 signal 이나 broadcast 를 받지 않았는데도 wait 상태에서 깨어나는 현상을 말한다.\n이는 운영체제의 구현 방식이나 하드웨어의 특성으로 인해 발생할 수 있다.\n가짜 깨우기가 발생하는 이유들은 다음과 같다:\n운영체제 최적화: 일부 운영체제는 성능 향상을 위해 의도적으로 가짜 깨우기를 발생시킬 수 있다. 하드웨어 인터럽트: 시스템 이벤트나 하드웨어 인터럽트로 인해 스레드가 예기치 않게 깨어날 수 있다. 시그널 처리: 운영체제의 시그널 처리 메커니즘이 의도치 않은 깨우기를 유발할 수 있다. 가짜 깨우기를 처리하는 일반적인 패턴은 다음과 같다:\n조건을 while 루프로 감싸기 명확한 상태 변수 사용하기 모든 상태 변경을 적절한 동기화 블록 내에서 수행하기 notify() 호출 전에 상태 변경하기\n이러한 방어적 프로그래밍 기법을 사용함으로써, 가짜 깨우기로 인한 문제를 효과적으로 방지할 수 있다.\n특히 멀티스레드 프로그래밍에서는 이러한 세부사항에 주의를 기울이는 것이 매우 중요하다. 예시 다음은 가짜 깨우기 문제를 보여주는 잘못된 코드 예시:\n1 2 3 4 5 6 # 잘못된 구현 - 가짜 깨우기에 취약 def wait_for_data(condition, shared_data): with condition: if not shared_data.is_ready: # if 사용 - 문제 있음 condition.wait() return shared_data.value 이 코드의 문제점은 if 문을 사용하여 조건을 한 번만 검사한다는 것이다.\n가짜 깨우기가 발생하면, 실제로 데이터가 준비되지 않았는데도 스레드가 깨어나서 잘못된 데이터를 반환할 수 있다.\n다음은 가짜 깨우기를 올바르게 처리하는 코드:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import threading import time class SharedData: def __init__(self): self.condition = threading.Condition() self.is_ready = False self.value = None def wait_for_data(self): with self.condition: while not self.is_ready: # while 사용 - 안전한 구현 self.condition.wait() return self.value def set_data(self, value): with self.condition: self.value = value self.is_ready = True self.condition.notify_all() # 사용 예시 def consumer(shared_data): print(\"소비자: 데이터 대기 중…\") value = shared_data.wait_for_data() print(f\"소비자: 데이터 수신 - {value}\") def producer(shared_data): print(\"생산자: 잠시 대기…\") time.sleep(2) print(\"생산자: 데이터 설정\") shared_data.set_data(\"중요한 데이터\") # 테스트 shared_data = SharedData() consumer_thread = threading.Thread(target=consumer, args=(shared_data,)) producer_thread = threading.Thread(target=producer, args=(shared_data,)) consumer_thread.start() producer_thread.start() consumer_thread.join() producer_thread.join() 이 개선된 구현에서는 다음과 같은 중요한 포인트들을 주목해야 한다:\nwhile 루프 사용: if 대신 while 을 사용하여 조건을 반복적으로 검사한다. 이는 가짜 깨우기가 발생하더라도 조건이 실제로 만족될 때까지 대기하도록 보장한다. 상태 변수 (is_ready): 단순히 신호만 기다리는 것이 아니라, 실제 데이터의 상태를 추적하는 변수를 사용한다. 동기화 블록: 모든 공유 데이터 접근은 condition lock 으로 보호된다. 구현 대부분의 현대 운영 체제와 프로그래밍 언어에서 조건 변수를 지원한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import threading import time class DataQueue: def __init__(self, size): self.queue = [] self.size = size self.lock = threading.Lock() # 큐가 비어있지 않음을 나타내는 조건 변수 self.not_empty = threading.Condition(self.lock) # 큐가 가득 차지 않음을 나타내는 조건 변수 self.not_full = threading.Condition(self.lock) def put(self, data): with self.lock: # 큐가 가득 찼다면 대기 while len(self.queue) \u003e= self.size: print(f\"큐가 가득 찼습니다. 생산자 대기 중…\") self.not_full.wait() # 데이터 추가 self.queue.append(data) print(f\"생산: {data}\") # 대기 중인 소비자에게 신호 전송 self.not_empty.notify() def get(self): with self.lock: # 큐가 비었다면 대기 while len(self.queue) == 0: print(\"큐가 비었습니다. 소비자 대기 중…\") self.not_empty.wait() # 데이터 추출 data = self.queue.pop(0) print(f\"소비: {data}\") # 대기 중인 생산자에게 신호 전송 self.not_full.notify() return data # 생산자 함수 def producer(queue): for i in range(5): time.sleep(0.5) # 생산 시간 시뮬레이션 queue.put(f\"항목 {i}\") # 소비자 함수 def consumer(queue): for i in range(5): time.sleep(1) # 소비 시간 시뮬레이션 queue.get() # 실행 queue = DataQueue(3) # 크기가 3인 큐 생성 producer_thread = threading.Thread(target=producer, args=(queue,)) consumer_thread = threading.Thread(target=consumer, args=(queue,)) producer_thread.start() consumer_thread.start() producer_thread.join() consumer_thread.join() 이 코드는 생산자 - 소비자 문제를 조건 변수를 사용하여 해결하는 예시이다.\n여기서 조건 변수는 두 가지 중요한 역할을 한다:\n큐가 가득 찼을 때 생산자를 대기시키고, 공간이 생기면 깨우기 큐가 비었을 때 소비자를 대기시키고, 데이터가 들어오면 깨우기 참고 및 출처 1. 주제의 분류 적절성 조건 변수 (Condition Variable) 는 ‘Computer Science and Engineering \u003e Computer Science Fundamentals \u003e Operating System \u003e Process Management \u003e Synchronization \u003e Condition Synchronization’ 의 하위 주제로 분류하는 것이 적합하다. 조건 변수는 조건 동기화의 핵심 메커니즘이기 때문이다.\n2. 200 자 내외 요약 조건 변수는 다중 스레드 환경에서 특정 조건이 충족될 때까지 스레드를 대기 상태로 만들고, 조건이 만족되면 대기 중인 스레드를 깨워 실행을 재개하는 동기화 객체이다. 임계 구역 보호와 레이스 컨디션 방지에 필수적이며, 효율적인 자원 관리를 가능하게 한다.\n3. 250 자 내외 개요 조건 변수는 동시성 환경에서 여러 스레드가 공유 자원에 안전하게 접근할 수 있도록 특정 조건이 충족될 때까지 스레드를 대기시키고, 조건이 만족되면 대기 중인 스레드를 신호로 깨워 실행을 재개시킨다. 락과 함께 사용되어 임계 구역 보호, 효율적인 자원 관리, 레이스 컨디션 방지 등 동기화의 핵심 역할을 수행하며, wait/signal 연산을 통해 동작한다. 다양한 운영체제와 프레임워크에서 필수적으로 활용된다.\n핵심 개념 **조건 변수 (Condition Variable)**는 스레드가 특정 조건이 만족될 때까지 대기 (wait) 하고, 조건이 충족되면 signal(또는 notify) 로 깨워주는 동기화 객체이다. 락 (Lock) 과 함께 사용되어 임계 구역에서의 상호 배제 (Mutual Exclusion) 를 보장한다. wait, signal, broadcast(여러 스레드 깨움) 연산을 지원한다. 동시성 오류 (레이스 컨디션, 데드락) 방지와 효율적인 자원 관리에 필수적이다. 주요 내용 정리 배경 및 목적 동시성 환경에서 자원 경쟁과 데이터 불일치 문제를 해결하기 위해 도입. 임계 구역 보호, 레이스 컨디션 및 데드락 방지, 효율적인 자원 활용이 목적. 주요 기능 및 역할 스레드가 조건이 만족될 때까지 대기 (wait) 조건이 충족되면 신호 (signal) 로 대기 중인 스레드 실행 재개 임계 구역 보호, 효율적 자원 관리, 동기화의 핵심 역할 수행 특징 및 핵심 원칙 상호 배제 (Mutual Exclusion): 락을 통해 임계 구역 보호 진행 (Progress): 조건 충족 시 즉시 스레드 실행 유한 대기 (Bounded Waiting): 무한 대기 방지 주요 원리 및 작동 원리 락과 조건 변수를 조합하여 wait/signal 연산으로 동기화 구현 wait: 락을 해제하고 대기 큐에 진입 signal: 대기 중인 스레드 하나를 깨움 다이어그램 1 2 [Thread1] --lock--\u003e [Critical Section] --wait(cond)--\u003e [Blocked Queue] [Thread2] --lock--\u003e [Critical Section] --signal(cond)--\u003e [Thread1 실행 재개] 구조 및 아키텍처 필수 구성요소 락 (Lock): 임계 구역 상호 배제 보장 조건 변수 (Condition Variable): 조건 기반 대기 및 신호 전달 대기 큐 (Wait Queue): 조건 미충족 시 스레드 대기 선택 구성요소 모니터 (Monitor): 조건 변수와 락을 캡슐화하여 동기화 간소화 세마포어 (Semaphore): 카운터 기반 자원 접근 제어 구조 다이어그램 1 2 3 4 5 6 7 +---------------------+ | Monitor | | +-----------------+ | | | Condition Var | [Buffer] --consume--\u003e [Consumer] | | | |---wait(not full)------\u003e| | |\u003c--signal(not empty)----| | 워크플로우: 생산자: 버퍼가 가득 차면 not full 조건 변수에서 대기 소비자: 버퍼가 비면 not empty 조건 변수에서 대기 생산자/소비자: 조건 충족 시 signal 로 상대 스레드 깨움 역할: 조건 변수: 버퍼 상태 변화에 따라 대기/신호 전달 락: 버퍼 접근 상호 배제 보장 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 항목 설명 권장사항 락 범위 최소화 불필요한 병목 방지 임계 구역 최소화 조건 변수 사용 대기/신호 시점 명확히 정의 명확한 조건 설정 데드락 방지 락 획득 순서 일관성 유지 타임아웃, 락 순서 지정 테스트 동시성 시나리오 반복 검증 자동화 테스트 도입 최적화하기 위한 고려사항 및 주의할 점 항목 설명 권장사항 락 경쟁 최소화 락 획득 경쟁 줄이기 분할 락, 락 프리 구조 대기 최소화 불필요한 wait 방지 조건 충족 시 즉시 signal 스레드 수 조절 과도한 스레드 생성 방지 적정 스레드 풀 관리 비동기 처리 병목 구간 비동기화 이벤트 기반 아키텍처 적용 2025 년 기준 최신 동향 주제 항목 설명 조건 변수 경량화 동기화 경량 락, 락 프리 (lock-free) 동기화 기법과의 결합 강화 조건 변수 분산 시스템 분산 환경에서의 조건 변수 구현 및 표준화 연구 활발 조건 변수 자동화 도구 동시성 오류 자동 탐지 및 진단 도구 발전 조건 변수 실시간 처리 실시간 데이터 동기화와 연계된 조건 변수 최적화 기술 부상 주제와 관련하여 주목할 내용 주제 항목 설명 조건 변수 async/await 비동기 프로그래밍 패턴과의 결합 증가 조건 변수 동시성 표준 POSIX, Java, Python 등 표준 API 의 진화 조건 변수 성능 분석 대규모 시스템에서 조건 변수 병목 분석 중요성 증가 앞으로의 전망 주제 항목 설명 조건 변수 자동화 및 지능화 AI 기반 동시성 진단 및 최적화 도구 발전 조건 변수 분산 동기화 클라우드/분산 환경에서 조건 변수 확장 조건 변수 실시간 시스템 초저지연 실시간 동기화 기술과의 융합 전망 하위 주제 및 추가 학습 필요 내용 간략 설명 카테고리 주제 고급 동기화 패턴 동기화 기법 배리어, 래치, 리더 - 팔로워 등 분산 조건 변수 분산 컴퓨팅 분산 락, 분산 조건 변수 동기화 성능 분석 성능 최적화 락 경합, 병목 분석 동시성 오류 진단 품질 보증 동시성 버그 자동 탐지 도구 추가로 알아야 할 내용 및 관련 분야 간략 설명 카테고리 주제 실시간 동기화 임베디드 RTOS 동기화 메커니즘 클라우드 네이티브 동기화 클라우드 컨테이너, 마이크로서비스 동기화 데이터 일관성 데이터베이스 트랜잭션, 분산 일관성 모델 이벤트 기반 동기화 소프트웨어 아키텍처 이벤트 드리븐 아키텍처 (EDA) 용어 정리 용어 설명 wait 조건 변수에서 조건이 충족될 때까지 스레드를 대기시키는 연산 signal 조건 변수에서 대기 중인 스레드 하나를 깨우는 연산 broadcast 조건 변수에서 대기 중인 모든 스레드를 깨우는 연산 대기 큐 (Wait Queue) 조건 미충족 시 스레드가 대기하는 큐 참고 및 출처 조건 변수의 개념 및 동작 원리 설명 문서 Java Condition Variable 공식 문서 POSIX Condition Variable 설명 Python threading.Condition 공식 문서 현재까지 “조건 변수 (Condition Variable)” 주제에 대해 조사한 내용을 기반으로 아래와 같이 정리해 드립니다. 주제의 체계적 이해를 돕기 위한 분석 작업은 계속 진행 중이며, 일부 항목은 더 정제된 정보가 추가될 예정입니다.\n1. 주제 분류 적절성 분류: Computer Science and Engineering \u003e Computer Science Fundamentals \u003e Operating System \u003e Process Management \u003e Synchronization \u003e Condition Synchronization\n적절성: 완전히 적절합니다. 조건 변수는 프로세스/스레드 동기화의 핵심 메커니즘 중 하나로, 운영체제 및 멀티스레딩 환경의 동기화 관리에서 매우 중요한 위치를 차지합니다.\n2. 주제 요약 (200자 내외) 조건 변수는 멀티스레딩 환경에서 특정 조건이 만족될 때까지 스레드 실행을 중단하고, 조건이 충족되면 재개할 수 있도록 돕는 동기화 메커니즘으로, 효율적인 리소스 제어와 병행 처리에 필수적입니다.\n3. 전체 개요 (250자 내외) 조건 변수는 임계 구역 보호 외에도 특정 상태나 조건이 충족될 때까지 스레드를 블로킹하는 데 사용됩니다. mutex와 함께 사용되어 race condition을 방지하며, 생산자-소비자, reader-writer 문제 등에서 자주 활용됩니다. pthread, Java, Rust, Go 등 다양한 언어 및 플랫폼에서 지원되며, 최근에는 wait-free 및 비동기 메시지 패턴과 함께 보완적으로 사용되고 있습니다.\n4. 핵심 개념 조건 변수(Condition Variable)는 공유 자원 접근에서 조건이 충족될 때까지 스레드를 블로킹하고, 조건 충족 시 해당 스레드를 깨우는 메커니즘입니다.\nmutex(상호배제)와 함께 사용되며, wait/signal/broadcast 등의 연산을 통해 동기화를 수행합니다.\nPOSIX에서는 pthread_cond_t, Java에서는 Object.wait()/notify(), Rust에서는 std::sync::Condvar 등으로 구현됩니다.\nwhile 루프 내에서 조건 검사를 통해 spurious wakeup(허위 깨움) 문제를 방지해야 합니다.\n5. 주제 관련 조사 항목(진행 중) 다음 항목들은 조사하여 정리 중이며, 일부는 완성되었고 일부는 추가 수집 중입니다:\n✅ 완료 및 수집된 항목:\n구현 기법: POSIX pthread, Java Monitor, Rust Condvar\n동작 원리: wait → unlock → sleep → signal → lock → resume\n비교 분석: 조건 변수 vs 세마포어 vs 모니터\n주요 사용 사례: 생산자-소비자, 리더-라이터, 스레드 풀\n🕓 조사 중인 항목:\n구조 및 아키텍처: wait queue, signal set, 내부 스케줄러 흐름\n성능 최적화 전략: wait-time 감소, false wake-up 감소, lock contention 완화\n대규모 시스템 사례: Kafka, Redis, Rust async Condvar 구조\n2025년 최신 동향 및 기술 트렌드 정리\n이어서 다음 항목들을 순차적으로 정리하여 제공드릴 예정입니다:\n조건 변수의 구조 및 구성 요소 (다이어그램 포함)\n구현 기법별 예시 (C, Java, Rust 등)\n장단점 분석 표\n주요 도전과제 및 대응 전략\n최신 동향(2025 기준), 주목 기술, 향후 전망, 추가 학습 주제\n또한 아래 항목에 대한 정리도 병행 중입니다:\n용어 정리\n참고 및 출처 목록\n실제 시스템 적용 시나리오 및 워크플로우\n—\n조건 변수(Condition Variable)는 멀티스레딩 환경에서 스레드 간의 효율적인 동기화를 위해 사용되는 핵심 메커니즘입니다. 이 메커니즘은 특정 조건이 충족될 때까지 스레드의 실행을 일시 중단하고, 조건이 만족되면 다시 실행을 재개할 수 있도록 합니다. 이를 통해 리소스의 효율적인 관리와 병행 처리의 안정성을 확보할 수 있습니다.\n🔧 구조 및 아키텍처 필수 구성 요소 조건 변수 (Condition Variable): 스레드가 특정 조건이 충족될 때까지 대기할 수 있도록 하는 동기화 객체입니다.\n뮤텍스 (Mutex): 공유 자원에 대한 상호 배제를 보장하여 데이터의 일관성을 유지합니다.\n선택 구성 요소 플래그 변수 (Flag Variable): 조건의 충족 여부를 나타내는 불리언 변수로, 조건 검사를 위해 사용됩니다. 동작 원리 스레드는 뮤텍스를 획득하여 공유 자원에 대한 접근을 시도합니다.\n조건이 충족되지 않으면, 스레드는 조건 변수의 wait() 함수를 호출하여 뮤텍스를 해제하고 대기 상태로 전환됩니다.\n다른 스레드가 조건을 충족시키고 notify_one() 또는 notify_all() 함수를 호출하면, 대기 중인 스레드가 깨워집니다.\n깨워진 스레드는 뮤텍스를 다시 획득하고, 조건을 재검사하여 작업을 계속할지 결정합니다.\n💻 구현 기법 1. C++11의 std::condition_variable C++11 표준에서는 헤더를 통해 조건 변수를 제공합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include #include #include std::mutex mtx; std::condition_variable cv; bool ready = false; void worker() { std::unique_lock\u003cstd::mutex\u003e lock(mtx); cv.wait(lock, []{ return ready; }); // 작업 수행 } 위 코드에서 cv.wait(lock, []{ return ready; });는 ready가 true가 될 때까지 현재 스레드를 대기시킵니다.\n2. POSIX 스레드의 pthread_cond_t POSIX 스레드 라이브러리에서는 pthread_cond_t를 사용하여 조건 변수를 구현합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; int count = 0; void* worker(void* arg) { pthread_mutex_lock(\u0026mutex); while (count == 0) { pthread_cond_wait(\u0026cond, \u0026mutex); } // 작업 수행 pthread_mutex_unlock(\u0026mutex); return NULL; } pthread_cond_wait 함수는 뮤텍스를 해제하고 스레드를 대기 상태로 전환하며, 조건이 충족되면 뮤텍스를 다시 획득합니다.\n3. Rust의 std::sync::Condvar Rust에서는 std::sync::Condvar를 통해 조건 변수를 제공합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 use std::sync::{Arc, Condvar, Mutex}; use std::thread; let pair = Arc::new((Mutex::new(false), Condvar::new())); let pair_clone = Arc::clone(\u0026pair); thread::spawn(move || { let (lock, cvar) = \u0026*pair_clone; let mut started = lock.lock().unwrap(); *started = true; cvar.notify_one(); }); 위 코드에서 cvar.notify_one()은 대기 중인 스레드 중 하나를 깨웁니다.\n✅ 장점과 ⚠ 단점 구분 항목 설명 ✅ 장점 효율적인 대기 조건이 충족될 때까지 스레드를 블로킹하여 CPU 자원을 절약합니다. 명확한 동기화 뮤텍스와 함께 사용하여 공유 자원에 대한 안전한 접근을 보장합니다. ⚠ 단점 스푸리어스 웨이크업 조건이 충족되지 않았음에도 스레드가 깨어날 수 있어 추가적인 조건 검사가 필요합니다. 데드락 위험 뮤텍스와 조건 변수의 잘못된 사용으로 데드락이 발생할 수 있습니다. 🧩 도전 과제 및 해결책 스푸리어스 웨이크업: 스레드가 조건이 충족되지 않았음에도 깨어나는 현상입니다. 이를 방지하기 위해 while 루프를 사용하여 조건을 재검사해야 합니다.\n데드락: 뮤텍스와 조건 변수를 잘못 사용하면 데드락이 발생할 수 있습니다. 이를 방지하기 위해 뮤텍스 획득 순서를 일관되게 유지하고, 가능한 한 뮤텍스 보유 시간을 최소화해야 합니다.\n🧪 실무 적용 예시 시스템 적용 사례 설명 Kafka 메시지 큐 대기 프로듀서와 컨슈머 간의 메시지 큐 상태를 조건 변수로 관리하여 효율적인 데이터 처리 Redis 분산 락 구현 SETNX 명령어와 조건 변수를 활용하여 분산 환경에서의 자원 접근 제어 Web Server 요청 처리 동기화 다중 스레드 환경에서 클라이언트 요청을 조건 변수로 동기화하여 안정적인 서비스 제공 🧭 실무에서 효과적으로 적용하기 위한 고려사항 고려사항 설명 권장 사항 조건 검사 방식 스푸리어스 웨이크업 방지를 위해 while 루프 사용 항상 while 루프를 사용하여 조건을 재검사 뮤텍스 사용 데드락 방지를 위해 뮤텍스 획득 순서 일관성 유지 뮤텍스 획득 순서를 문서화하고 일관되게 유지 리소스 관리 조건 변수와 뮤텍스의 적절한 초기화 및 해제 사용 후 pthread_cond_destroy 등을 통해 자원 해제 🚀 성능을 최적화하기 위한 고려사항 고려사항 설명 권장 사항 대기 시간 최소화 불필요한 대기를 줄이기 위해 조건 변수 사용 시 조건을 명확히 설정 조건 검사를 정확하게 구현하여 불필요한 대기 방지 스레드 수 관리 과도한 스레드 생성으로 인한 컨텍스트 스위칭 비용 증가 방지 스레드 풀 등을 활용하여 스레드 수를 제한 자원 경쟁 최소화 공유 자원에 대한 경쟁을 줄이기 위해 뮤텍스 보유 시간 최소화 가능한 한 뮤텍스 보유 시간을 짧게 유지 용어 정리 용어 설명 조건 변수 (Condition Variable) 특정 조건이 충족될 때까지 스레드를 대기시키고, 조건이 만족되면 스레드를 깨우는 동기화 메커니즘 뮤텍스 (Mutex) 상호 배제를 통해 공유 자원에 대한 동시 접근을 제어하는 동기화 객체 스푸리어스 웨이크업 (Spurious Wakeup) 조건이 충족되지 않았음에도 스레드가 깨어나는 현상 데드락 (Deadlock) 두 개 이상의 스레드가 서로 자원을 기다리며 무한 대기 상태에 빠지는 현상 참고 및 출처 Condition Variables in C++ Multithreading - GeeksforGeeks\nCondition Variables - cs.wisc.edu\nCondition Variables - Win32 apps | Microsoft Learn\nRust concurrency patterns: condvars and locks | by Gregory Terzian\n추가적으로, 조건 변수의 구조와 동작 원리를 시각적으로 이해하고자 하신다면 아래의 다이어그램을 참고하시기 바랍니다:\n위 다이어그램은 조건 변수와 뮤텍스의 상호 작용을 시각적으로 표현한 것으로, 스레드가 조건을 기다리고, 조건이 충족되었을 때 어떻게 깨어나는지를 보여줍니다.\n더 자세한 내용이나 특정 구현에 대한 예시가 필요하시면 언제든지 말씀해 주세요.\n조건 변수 (Condition Variable) 1. 주제의 분류 적절성 조사한 결과, “Computer Science and Engineering” \u003e “Computer Science Fundamentals” \u003e “Operating System” \u003e “Process Management” \u003e “Synchronization” \u003e “Condition Synchronization\"이라는 분류는 적절합니다. 조건 변수는 운영체제의 프로세스 관리에서 동기화를 위한 핵심 메커니즘으로, 특히 조건 동기화(여러 스레드가 특정 조건이 충족될 때까지 대기하는 상황)를 구현하는 데 사용되는 개념입니다.\n2. 요약 설명 (200자 내외) 조건 변수는 다중 스레드 환경에서 스레드 간 통신과 동기화를 위한 메커니즘으로, 특정 조건이 충족될 때까지 스레드를 대기시키고, 다른 스레드가 조건을 충족시키면 대기 중인 스레드에게 신호를 보내 실행을 재개하도록 하는 동기화 기본요소입니다. 뮤텍스와 함께 사용되어 생산자-소비자 문제 같은 동기화 패턴을 효율적으로 구현합니다.\n3. 개요 (250자 내외) 조건 변수는 운영체제와 프로그래밍 언어에서 제공하는 동기화 기본요소로, 스레드가 특정 조건이 충족될 때까지 효율적으로 대기할 수 있게 합니다. 뮤텍스와 함께 사용되어 원자적으로 락을 해제하고 스레드를 휴면 상태로 전환시키며, 조건이 충족되면 신호를 받아 깨어나 락을 다시 획득합니다. 생산자-소비자, 리더-라이터 문제와 같은 동기화 패턴에 적용되며, 스레드 간 상태 변화를 효율적으로 전달하는 메커니즘을 제공합니다.\n4. 핵심 개념 조건 변수(Condition Variable)는 다중 스레드 프로그래밍에서 스레드 간 동기화를 위한 핵심 메커니즘입니다. 다음은 조건 변수에 대해 반드시 알아야 할 핵심 개념들입니다:\n정의: 조건 변수는 한 스레드가 특정 조건이 충족될 때까지 대기하고, 다른 스레드가 해당 조건을 충족시켰을 때 대기 중인 스레드에게 알림을 보내는 동기화 기본요소입니다.\n목적: 스레드 간 통신을 가능하게 하여 특정 이벤트나 조건이 발생했을 때 다른 스레드가 이에 반응할 수 있도록 합니다.\n작동 방식: 조건 변수는 항상 뮤텍스와 함께 사용되며, wait 연산은 뮤텍스를 해제하고 스레드를 대기 상태로 만들고, signal 연산은 대기 중인 스레드 중 하나를 깨우는 역할을 합니다.\n기본 연산:\nwait: 조건이 충족될 때까지 스레드를 대기 상태로 만듭니다. signal/notify_one: 대기 중인 스레드 중 하나를 깨웁니다. broadcast/notify_all: 모든 대기 중인 스레드를 깨웁니다. 스퓨리어스 웨이크업(Spurious Wakeup): 조건 변수는 실제 신호 없이도 대기 중인 스레드가 깨어날 수 있는 상황이 발생할 수 있으므로, 항상 while 루프 내에서 조건을 재확인해야 합니다.\n상태 보호: 조건 변수는 데이터 자체를 보호하지 않으므로, 공유 상태를 수정하거나 검사할 때는 반드시 연관된 뮤텍스로 보호해야 합니다.\n생산자-소비자 패턴: 조건 변수의 가장 일반적인 사용 사례로, 생산자 스레드가 데이터를 생성하고 소비자 스레드가 해당 데이터를 처리하는 패턴을 구현할 때 사용됩니다.\n구현 형태: 대부분의 현대 프로그래밍 언어(C++, Java, Python 등)와 운영체제(POSIX 스레드, Windows)에서 조건 변수를 지원합니다.\n이러한 핵심 개념들을 이해하면 조건 변수를 효과적으로 활용하여 안전하고 효율적인 다중 스레드 프로그램을 개발할 수 있습니다.\n5. 주제와 관련하여 조사할 내용 배경 조건 변수의 개념은 1970년대 운영체제와 병렬 프로그래밍 연구에서 발전했습니다. 모니터(Monitor)라는 동기화 추상화의 일부로 처음 소개되었으며, 이는 공유 자원에 대한 상호 배제 액세스를 제공하면서도 스레드가 특정 조건을 기다릴 수 있게 해주는 메커니즘이었습니다.\n초기 운영체제에서는 스레드가 조건을 기다릴 때 지속적으로 상태를 확인하는 ‘바쁜 대기(busy waiting)’ 방식을 사용했는데, 이는 CPU 자원을 낭비하는 비효율적인 방법이었습니다. 조건 변수는 이런 문제를 해결하기 위해 스레드를 휴면 상태로 전환하고, 조건이 충족되면 깨우는 방식을 도입함으로써 시스템 자원을 더 효율적으로 사용할 수 있게 했습니다.\n오늘날 조건 변수는 POSIX 스레드, Windows API, 그리고 C++, Java 등의 프로그래밍 언어에서 표준 동기화 기본요소로 제공되고 있으며, 다중 스레드 프로그래밍에서 필수적인 도구로 자리 잡았습니다.\n목적 및 필요성 조건 변수의 주요 목적과 필요성은 다음과 같습니다:\n효율적인 스레드 대기: 스레드가 조건이 충족될 때까지 CPU를 소비하지 않고 대기할 수 있게 합니다.\n스레드 간 통신: 한 스레드에서 다른 스레드로 상태 변화나 이벤트 발생을 알릴 수 있는 메커니즘을 제공합니다.\n동기화 패턴 구현: 생산자-소비자, 리더-라이터와 같은 일반적인 동기화 패턴을 효율적으로 구현할 수 있게 합니다.\n자원 낭비 방지: 스레드가 조건을 계속 확인하는 바쁜 대기(busy waiting) 대신, 조건이 충족될 때만 깨어나도록 하여 시스템 자원을 절약합니다.\n복잡한 동기화 시나리오 처리: 단순한 뮤텍스만으로는 해결하기 어려운 복잡한 동기화 시나리오를 처리할 수 있게 합니다.\n경쟁 상태(Race Condition) 예방: 조건 확인과 대기를 원자적으로 수행함으로써 경쟁 상태를 방지합니다.\n주요 기능 및 역할 조건 변수의 주요 기능과 역할은 다음과 같습니다:\n스레드 대기(Wait):\n스레드가 특정 조건이 충족될 때까지 대기할 수 있게 합니다. 뮤텍스를 원자적으로 해제하고 스레드를 휴면 상태로 전환합니다. 스레드가 깨어날 때 자동으로 뮤텍스를 다시 획득합니다. 신호 전송(Signal/Notify):\n조건이 충족되었을 때 대기 중인 스레드 중 하나에게 알립니다. 일반적으로 signal, notify_one 등의 함수로 구현됩니다. 브로드캐스트(Broadcast/Notify All):\n조건이 충족되었을 때 모든 대기 중인 스레드에게 알립니다. 일반적으로 broadcast, notify_all 등의 함수로 구현됩니다. 조건 검증:\n스레드가 깨어난 후 조건을 다시 확인하는 메커니즘을 제공합니다. 스퓨리어스 웨이크업(Spurious Wakeup)에 대비하여 조건을 while 루프 내에서 검사합니다. 뮤텍스 연동:\n조건 변수는 항상 뮤텍스와 함께 사용되어 공유 상태에 대한 원자적 접근을 보장합니다. 특징 조건 변수의 주요 특징은 다음과 같습니다:\n뮤텍스 연계: 조건 변수는 항상 뮤텍스와 함께 사용되어야 합니다. 뮤텍스는 공유 상태를 보호하고, 조건 변수는 스레드 간 통신을 담당합니다.\n원자적 대기: 조건 변수의 wait 연산은 뮤텍스를 해제하고 스레드를 대기 상태로 만드는 작업을 원자적(atomic)으로 수행합니다.\n스퓨리어스 웨이크업(Spurious Wakeup): 조건 변수는 실제 신호 없이도 스레드가 깨어날 수 있는 현상이 있어, 항상 while 루프 내에서 조건을 재확인해야 합니다.\nFIFO 보장 없음: 대부분의 조건 변수 구현은 어떤 스레드가 먼저 깨어날지 보장하지 않습니다. 선입선출(FIFO) 순서가 필요한 경우 추가적인 메커니즘을 구현해야 합니다.\n신호 손실: 스레드가 대기하기 전에 신호가 전송되면, 그 신호는 손실될 수 있습니다.\n시스템 자원 효율성: 바쁜 대기(busy waiting)와 달리, 조건 변수는 스레드를 휴면 상태로 전환하여 CPU 자원을 절약합니다.\n플랫폼 독립적: 대부분의 현대 운영체제와 프로그래밍 언어에서 지원되는 표준 동기화 기본요소입니다.\n핵심 원칙 조건 변수를 사용할 때 따라야 할 핵심 원칙은 다음과 같습니다:\n항상 뮤텍스와 함께 사용: 조건 변수는 독립적으로 사용할 수 없으며, 반드시 뮤텍스와 함께 사용해야 합니다.\n조건 검사는 항상 while 루프 내에서: 스퓨리어스 웨이크업에 대비하여 조건을 항상 while 루프 내에서 검사해야 합니다.\n1 2 while (!condition) cv.wait(lock); 상태 변경은 뮤텍스 보호 하에: 조건 변수와 관련된 상태를 변경할 때는 항상 연관된 뮤텍스로 보호해야 합니다.\n최소한의 작업만 뮤텍스 내에서: 뮤텍스가 잠겨 있는 동안에는 최소한의 작업만 수행하여 다른 스레드의 대기 시간을 줄입니다.\n신호 전송 전 상태 변경: 조건 변수에 신호를 보내기 전에 먼저 조건 상태를 변경해야 합니다.\n적절한 신호 선택: 한 스레드만 깨워야 할 경우 signal/notify_one을, 모든 스레드를 깨워야 할 경우 broadcast/notify_all을 사용합니다.\n락 해제 후 신호 전송: 성능을 위해 가능하면 뮤텍스를 해제한 후에 신호를 전송합니다.\n타임아웃 고려: 무한정 대기하지 않도록 필요한 경우 타임아웃을 설정합니다.\n주요 원리 및 작동 원리 조건 변수의 주요 작동 원리는 다음과 같습니다:\n대기(Wait) 연산:\n스레드가 특정 조건을 확인하고, 조건이 충족되지 않으면 조건 변수의 대기 큐에 진입합니다. 뮤텍스를 원자적으로 해제하고 스레드를 휴면 상태로 전환합니다. 스레드가 깨어나면 자동으로 뮤텍스를 다시 획득합니다. 신호(Signal) 연산:\n다른 스레드가 조건을 충족시키고 조건 변수에 신호를 보냅니다. 대기 큐에 있는 스레드 중 하나가 깨어나고, 뮤텍스를 획득한 후 실행을 계속합니다. 브로드캐스트(Broadcast) 연산:\n모든 대기 중인 스레드에게 신호를 보내 깨웁니다. 각 스레드는 순차적으로 뮤텍스를 획득하여 실행을 계속합니다. 다음은 조건 변수의 작동 원리를 보여주는 다이어그램입니다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [스레드 A] [스레드 B] | | | 뮤텍스 획득 | | | | 조건 검사 | | (조건 = false) | | | | 조건 변수 대기 (wait) | 뮤텍스 획득 | (뮤텍스 해제 + 스레드 휴면) | | | 상태 변경 (조건 = true) | | | | 조건 변수 신호 (signal) | | | | 뮤텍스 해제 | (스레드 깨어남) | | | | 뮤텍스 재획득 | | | | 조건 재검사 | | (조건 = true) | | | | 작업 수행 | | | | 뮤텍스 해제 | | | 구조 및 아키텍처 조건 변수의 구조 및 아키텍처는 다음과 같습니다:\n핵심 구성 요소 대기 큐(Wait Queue):\n조건이 충족될 때까지 대기 중인 스레드들을 관리하는 큐입니다. 운영체제 커널 수준에서 구현되는 경우가 많습니다. 연관 뮤텍스(Associated Mutex):\n조건 변수와 함께 사용되는 뮤텍스로, 공유 상태에 대한 접근을 제어합니다. 조건 변수 자체는 상태를 보호하지 않으므로, 반드시 뮤텍스와 함께 사용해야 합니다. 신호 메커니즘(Signaling Mechanism):\n대기 중인 스레드에게 조건이 충족되었음을 알리는 메커니즘입니다. Signal(단일 스레드 깨우기)과 Broadcast(모든 스레드 깨우기) 연산을 지원합니다. 타임아웃 기능(Timeout Facility):\n스레드가 특정 시간 동안만 대기하도록 하는 기능입니다. 무한정 대기하는 상황을 방지하기 위해 사용됩니다. 구조 다이어그램 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 +----------------------------+ | 조건 변수 (Condition Variable) | +----------------------------+ | | | +-------------------------+| | | 대기 큐 (Wait Queue) || | +-------------------------+| | | | +-------------------------+| | | 신호 메커니즘 || | | - signal/notify_one || | | - broadcast/notify_all || | +-------------------------+| | | | +-------------------------+| | | 타임아웃 기능 || | +-------------------------+| | | +-----------|----------------+ | | 연계 v +----------------------------+ | 뮤텍스 (Mutex) | +----------------------------+ | - 락 상태 | | - 대기 큐 | +----------------------------+ | | 보호 v +----------------------------+ | 공유 상태 (Shared State) | +----------------------------+ 필수 구성요소 조건 변수 객체: 스레드 대기 및 신호 전송 기능을 제공하는 객체입니다. 연관 뮤텍스: 공유 상태에 대한 상호 배제 접근을 제공합니다. 조건 상태: 스레드가 대기하거나 진행할 조건을 결정하는 공유 변수입니다. 선택 구성요소 타임아웃 매개변수: 스레드가 특정 시간 동안만 대기하도록 합니다. 사용자 정의 조건 함수: 조건을 평가하는 함수를 전달하여 자동으로 조건을 검사하도록 합니다. 속성 설정: 일부 구현에서는 조건 변수의 동작을 세부적으로 제어하는 속성을 설정할 수 있습니다. 구현 기법 조건 변수는 다양한 프로그래밍 언어와 플랫폼에서 여러 가지 방식으로 구현됩니다. 다음은 주요 구현 기법들입니다:\n1. POSIX 스레드 (pthread) 구현 정의: POSIX 스레드 라이브러리에서 제공하는 조건 변수 구현입니다.\n구성:\npthread_cond_t: 조건 변수 타입 pthread_cond_init(): 조건 변수 초기화 pthread_cond_wait(): 조건 변수 대기 pthread_cond_signal(): 단일 스레드 신호 pthread_cond_broadcast(): 모든 스레드 신호 pthread_cond_destroy(): 조건 변수 해제 목적: 유닉스 계열 시스템에서 표준화된 스레드 동기화 방법을 제공합니다.\n실제 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 pthread_mutex_t mutex; pthread_cond_t cond; int done = 0; // 초기화 pthread_mutex_init(\u0026mutex, NULL); pthread_cond_init(\u0026cond, NULL); // 스레드 1 (대기) pthread_mutex_lock(\u0026mutex); while (!done) { pthread_cond_wait(\u0026cond, \u0026mutex); } // 조건 충족, 계속 실행 pthread_mutex_unlock(\u0026mutex); // 스레드 2 (신호) pthread_mutex_lock(\u0026mutex); done = 1; pthread_cond_signal(\u0026cond); pthread_mutex_unlock(\u0026mutex); 2. C++ 표준 라이브러리 구현 정의: C++11 이후의 표준 라이브러리에서 제공하는 조건 변수 구현입니다.\n구성:\nstd::condition_variable: 조건 변수 클래스 wait(): 조건 변수 대기 wait_for(): 타임아웃 있는 대기 wait_until(): 특정 시간까지 대기 notify_one(): 단일 스레드 신호 notify_all(): 모든 스레드 신호 목적: C++ 프로그램에서 플랫폼 독립적인 스레드 동기화 방법을 제공합니다.\n실제 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 std::mutex mtx; std::condition_variable cv; bool ready = false; // 스레드 1 (대기) std::unique_lock\u003cstd::mutex\u003e lock(mtx); cv.wait(lock, [\u0026]{ return ready; }); // 조건 충족, 계속 실행 // 스레드 2 (신호) { std::lock_guard\u003cstd::mutex\u003e lock(mtx); ready = true; } cv.notify_one(); 3. Java 구현 정의: Java의 동기화 메커니즘으로 제공되는 조건 변수 구현입니다.\n구성:\nObject.wait(): 객체의 모니터에서 대기 Object.notify(): 단일 스레드 신호 Object.notifyAll(): 모든 스레드 신호 java.util.concurrent.locks.Condition: 명시적 조건 객체 목적: Java 언어에서 모니터 패턴과 함께 스레드 동기화를 제공합니다.\n실제 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // Object의 내장 동기화 사용 synchronized (sharedObject) { while (!condition) { sharedObject.wait(); } // 조건 충족, 계속 실행 } // 신호 전송 synchronized (sharedObject) { condition = true; sharedObject.notifyAll(); } // 명시적 Condition 사용 Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); // 대기 lock.lock(); try { while (!ready) { condition.await(); } // 조건 충족, 계속 실행 } finally { lock.unlock(); } // 신호 전송 lock.lock(); try { ready = true; condition.signalAll(); } finally { lock.unlock(); } 4. 모니터 기반 구현 정의: 모니터라는 고수준 동기화 추상화의 일부로 구현되는 조건 변수입니다.\n구성:\n모니터 객체: 공유 데이터와 동기화 메커니즘을 캡슐화 내부 조건 변수: 모니터 내부의 대기 조건 진입/퇴출 메커니즘: 모니터 진입 및 퇴출 시 동기화 처리 목적: 공유 자원 접근을 간소화하고 동기화 오류를 줄입니다.\n실제 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 의사 코드로 표현한 모니터 monitor ProducerConsumer { int count = 0; condition notFull, notEmpty; procedure add(item) { while (count == BUFFER_SIZE) wait(notFull); buffer[count] = item; count++; signal(notEmpty); } procedure remove() { while (count == 0) wait(notEmpty); item = buffer[--count]; signal(notFull); return item; } } 5. 원자적 변수 기반 구현 정의: 최신 C++20에서는 원자적 변수와 대기/알림 메커니즘을 결합한 방식이 도입되었습니다.\n구성:\nstd::atomic: 원자적 변수 wait(): 특정 값이 될 때까지 대기 notify_one(): 단일 스레드 신호 notify_all(): 모든 스레드 신호 목적: 뮤텍스 없이 더 효율적인 동기화를 가능하게 합니다.\n실제 예시:\n1 2 3 4 5 6 7 8 9 std::atomic\u003cbool\u003e ready(false); // 스레드 1 (대기) ready.wait(false); // ready가 false인 동안 대기 // ready가 true가 되면 계속 실행 // 스레드 2 (신호) ready.store(true); ready.notify_one(); 장점과 단점 구분 항목 설명 ✅ 장점 자원 효율성 스레드를 휴면 상태로 전환하여 CPU 자원을 절약하고 바쁜 대기(busy waiting)를 방지합니다 스레드 간 통신 스레드 간 효율적인 신호 전달 메커니즘을 제공하여 복잡한 동기화 패턴을 구현할 수 있습니다 플랫폼 독립성 대부분의 운영체제와 프로그래밍 언어에서 표준 동기화 기본요소로 제공됩니다 원자적 연산 뮤텍스 해제와 스레드 대기를 원자적으로 수행하여 경쟁 상태를 방지합니다 유연한 신호 전송 단일 스레드(signal) 또는 모든 스레드(broadcast)에게 선택적으로 신호를 전송할 수 있습니다 ⚠ 단점 복잡성 올바른 사용을 위해 뮤텍스와의 올바른 조합, while 루프 사용 등 복잡한 규칙을 따라야 합니다 스퓨리어스 웨이크업 실제 신호 없이도 스레드가 깨어날 수 있어 항상 조건을 재확인해야 합니다 신호 손실 스레드가 대기하기 전에 전송된 신호는 손실될 수 있습니다 성능 오버헤드 시스템 호출과 컨텍스트 스위칭으로 인한 성능 오버헤드가 발생할 수 있습니다 우선순위 역전 낮은 우선순위 스레드가 높은 우선순위 스레드를 차단할 수 있는 문제가 발생할 수 있습니다 도전 과제 1. 스퓨리어스 웨이크업 (Spurious Wakeup) 설명: 실제 신호 없이도 대기 중인 스레드가 깨어나는 현상 해결책: 조건을 항상 while 루프 내에서 재확인하고, 조건 기반 wait 함수 사용\n2. 신호 손실 (Lost Signal) 설명: 스레드가 대기 상태에 진입하기 전에 전송된 신호가 손실되는 문제 해결책: 상태 변수와 조건 변수를 함께 사용하고, 적절한 뮤텍스 보호 적용\n3. 경쟁 상태 (Race Condition) 설명: 조건 검사와 대기 사이에 다른 스레드가 개입하여 발생하는 문제 해결책: 조건 변수의 원자적 wait 연산 사용과 적절한 뮤텍스 사용\n4. 우선순위 역전 (Priority Inversion) 설명: 낮은 우선순위 스레드가 뮤텍스를 점유하여 높은 우선순위 스레드를 차단하는 문제 해결책: 우선순위 상속(Priority Inheritance) 프로토콜 적용\n5. 기아 상태 (Starvation) 설명: 특정 스레드가 계속해서 신호를 받지 못해 실행되지 못하는 상황 해결책: 공정한 스케줄링 정책과 FIFO 큐 기반 조건 변수 사용\n6. 데드락 (Deadlock) 설명: 여러 스레드가 서로의 자원을 기다리며 무한정 대기하는 상황 해결책: 일관된 락 순서 유지, 타임아웃 설정, 데드락 감지 알고리즘 적용\n분류에 따른 종류 및 유형 분류 기준 종류 설명 신호 방식 Signal/Notify One 대기 중인 스레드 중 하나만 깨우는 방식 Broadcast/Notify All 모든 대기 중인 스레드를 깨우는 방식 대기 방식 조건부 대기 특정 조건을 만족할 때까지 대기하는 방식 타임아웃 대기 지정된 시간 동안만 대기하는 방식 절대 시간 대기 특정 시점까지만 대기하는 방식 구현 방식 Mesa 스타일 신호를 받은 스레드가 즉시 실행되지 않고 뮤텍스를 기다리는 방식 Hoare 스타일 신호를 받은 스레드가 즉시 실행되는 방식 플랫폼별 POSIX pthread POSIX 표준을 따르는 Unix/Linux 계열 구현 Windows API Windows 운영체제의 네이티브 조건 변수 C++ Standard C++11 이후 표준 라이브러리 구현 Java Built-in Java의 내장 동기화 메커니즘 사용 범위 프로세스 내부 단일 프로세스 내 스레드 간 동기화 프로세스 간 여러 프로세스 간 동기화 (제한적) 실무 적용 예시 적용 분야 사용 사례 구현 방법 예시 웹 서버 요청 처리 스레드 풀 작업 큐가 비어있을 때 워커 스레드가 대기하고, 새 요청이 오면 깨어남 Apache HTTP Server, Nginx 데이터베이스 트랜잭션 처리 락 대기, 버퍼 풀 관리, 체크포인트 동기화 MySQL InnoDB, PostgreSQL 운영체제 I/O 완료 대기 디스크 I/O, 네트워크 I/O 완료 시까지 프로세스/스레드 대기 Linux epoll, Windows IOCP 게임 엔진 렌더링 파이프라인 프레임 동기화, 리소스 로딩 완료 대기 Unity, Unreal Engine 메시징 시스템 큐 기반 통신 메시지 도착 대기, 버퍼 공간 확보 대기 Apache Kafka, RabbitMQ 멀티미디어 스트리밍 처리 버퍼링 완료 대기, 프레임 동기화 VLC, FFmpeg 활용 사례 다음은 전자상거래 시스템에서 주문 처리 시나리오를 가정한 조건 변수 활용 사례입니다:\n시나리오: 전자상거래 주문 처리 시스템 상황: 온라인 쇼핑몰에서 주문이 들어오면 여러 단계를 거쳐 처리해야 합니다. 재고 확인, 결제 처리, 배송 준비 등의 단계가 있으며, 각 단계는 별도의 스레드에서 처리됩니다.\n시스템 구성 1 2 3 [주문 접수] → [재고 확인] → [결제 처리] → [배송 준비] → [완료] ↓ ↓ ↓ ↓ 접수 스레드 재고 스레드 결제 스레드 배송 스레드 시스템 구성 다이어그램 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ 주문 큐 │ │ 결제 큐 │ │ 배송 큐 │ │ (Order Queue) │ │ (Payment Queue) │ │(Shipping Queue) │ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ │ │ ▼ ▼ ▼ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ 재고 처리 스레드 │ │ 결제 처리 스레드 │ │ 배송 처리 스레드 │ │(Inventory Thread)│ │(Payment Thread) │ │(Shipping Thread)│ └─────────────────┘ └─────────────────┘ └─────────────────┘ │ │ │ ▼ ▼ ▼ 조건 변수로 조건 변수로 조건 변수로 큐 상태 감시 큐 상태 감시 큐 상태 감시 활용 사례 Workflow 주문 접수: 고객이 주문을 하면 주문 큐에 추가되고, 재고 처리 스레드에게 신호를 보냅니다.\n재고 확인: 재고 처리 스레드가 깨어나 재고를 확인하고, 가능하면 결제 큐로 이동시킵니다.\n결제 처리: 결제 처리 스레드가 결제를 완료하고 배송 큐로 이동시킵니다.\n배송 준비: 배송 처리 스레드가 배송을 준비하고 주문을 완료 처리합니다.\n코드 예시 (C++) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include #include #include #include class OrderProcessor { private: std::queue\u003cOrder\u003e orderQueue; std::queue\u003cOrder\u003e paymentQueue; std::queue\u003cOrder\u003e shippingQueue; std::mutex orderMutex, paymentMutex, shippingMutex; std::condition_variable orderCV, paymentCV, shippingCV; public: // 재고 처리 스레드 void inventoryProcessor() { while (true) { std::unique_lock\u003cstd::mutex\u003e lock(orderMutex); orderCV.wait(lock, [this] { return !orderQueue.empty(); }); Order order = orderQueue.front(); orderQueue.pop(); lock.unlock(); // 재고 확인 로직 if (checkInventory(order)) { std::lock_guard\u003cstd::mutex\u003e paymentLock(paymentMutex); paymentQueue.push(order); paymentCV.notify_one(); } } } // 결제 처리 스레드 void paymentProcessor() { while (true) { std::unique_lock\u003cstd::mutex\u003e lock(paymentMutex); paymentCV.wait(lock, [this] { return !paymentQueue.empty(); }); Order order = paymentQueue.front(); paymentQueue.pop(); lock.unlock(); // 결제 처리 로직 if (processPayment(order)) { std::lock_guard\u003cstd::mutex\u003e shippingLock(shippingMutex); shippingQueue.push(order); shippingCV.notify_one(); } } } }; 조건 변수의 역할 스레드 동기화: 각 처리 단계 간 순서를 보장하고 데이터 일관성을 유지합니다. 자원 효율성: 처리할 작업이 없을 때 스레드를 휴면 상태로 전환하여 CPU 자원을 절약합니다. 실시간 처리: 새로운 작업이 도착하면 즉시 해당 스레드를 깨워 빠른 응답 시간을 보장합니다. 확장성: 각 단계별로 독립적인 스레드 풀을 운영하여 시스템 확장성을 제공합니다. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 구분 고려사항 설명 권장사항 설계 조건 정의 명확성 조건 변수가 대기하는 조건을 명확하게 정의해야 함 조건을 간단하고 명확한 불린 식으로 표현하고 문서화 구현 While 루프 사용 스퓨리어스 웨이크업에 대비하여 항상 while 루프 사용 while(!condition) cv.wait(lock); 패턴 준수 동기화 뮤텍스 연계 조건 변수는 반드시 뮤텍스와 함께 사용 하나의 조건 변수당 하나의 전용 뮤텍스 할당 신호 전송 적절한 신호 선택 signal vs broadcast 선택 시 성능과 정확성 고려 하나의 스레드만 처리 가능하면 signal, 여러 스레드가 처리 가능하면 broadcast 타이밍 신호 전송 시점 조건 변경 후 즉시 신호 전송 상태 변경과 신호 전송을 원자적으로 처리 예외 처리 타임아웃 설정 무한 대기 방지를 위한 타임아웃 적용 중요한 시스템에서는 wait_for() 또는 wait_until() 사용 테스팅 동시성 테스트 경쟁 상태와 데드락 시나리오 테스트 스트레스 테스트와 다양한 스레드 수로 테스트 수행 디버깅 로깅 및 모니터링 조건 변수 상태와 스레드 동작 추적 각 wait/signal 호출 시점과 조건 상태를 로깅 최적화하기 위한 고려사항 및 주의할 점 구분 최적화 기법 설명 권장사항 락 관리 조기 락 해제 뮤텍스를 가능한 한 빨리 해제하여 다른 스레드의 대기 시간 단축 신호 전송 전에 뮤텍스를 해제하는 패턴 적용 메모리 캐시 지역성 관련 데이터를 메모리상 가까운 위치에 배치 조건 변수, 뮤텍스, 관련 데이터를 구조체로 그룹화 스레드 수 적정 스레드 수 CPU 코어 수와 작업 특성을 고려한 스레드 수 설정 CPU 집약적 작업은 코어 수만큼, I/O 집약적 작업은 더 많은 스레드 허용 대기 전략 스핀락 조합 짧은 대기 시간이 예상되는 경우 스핀락과 조건 변수 조합 먼저 짧은 시간 스핀 후 조건 변수로 전환하는 하이브리드 방식 배치 처리 일괄 신호 전송 여러 작업을 배치로 처리하여 신호 전송 횟수 감소 일정 개수 또는 시간마다 배치로 처리하는 전략 적용 우선순위 스레드 우선순위 중요한 작업을 처리하는 스레드의 우선순위 조정 실시간 성능이 중요한 스레드는 높은 우선순위 설정 대안 기술 락프리 구조 성능이 중요한 경우 락프리 데이터 구조 고려 단순한 경우 원자적 변수나 락프리 큐 사용 검토 프로파일링 성능 측정 병목 지점 식별을 위한 지속적인 성능 모니터링 컨텍스트 스위칭 횟수, 대기 시간, 처리량 등을 측정 6. 주제에 대한 추가 조사 내용 (현재 추가 조사 내용이 지정되지 않음)\n7. 추가로 알아야 하는 내용 모니터 (Monitor) 패턴 모니터는 조건 변수와 뮤텍스를 조합한 고수준 동기화 추상화입니다. 객체 지향 프로그래밍에서 공유 자원에 대한 안전한 접근을 제공하며, Java의 synchronized 메서드가 대표적인 예입니다. 모니터는 조건 변수를 내부적으로 캡슐화하여 사용자가 복잡한 동기화 로직을 직접 구현할 필요를 줄여줍니다.\n세마포어와의 차이점 세마포어는 카운터 기반 동기화 기본요소로, 조건 변수와는 다른 용도로 사용됩니다. 세마포어는 자원의 개수를 관리하는 데 적합하며, 조건 변수는 특정 조건의 성립을 기다리는 데 적합합니다. 조건 변수는 상태 정보를 저장하지 않으므로 신호가 손실될 수 있지만, 세마포어는 카운터 값을 유지하므로 신호가 축적됩니다.\n리더-라이터 락 (Reader-Writer Lock) 리더-라이터 락은 조건 변수를 활용하여 구현할 수 있는 고급 동기화 메커니즘으로, 읽기 작업과 쓰기 작업을 구분하여 처리합니다. 여러 리더가 동시에 접근할 수 있지만, 라이터는 독점적으로 접근해야 하는 상황에서 사용됩니다. 조건 변수를 사용하여 리더와 라이터 간의 복잡한 동기화 로직을 구현할 수 있습니다.\n생산자-소비자 변형 패턴 기본적인 생산자-소비자 패턴 외에도 여러 생산자와 여러 소비자, 우선순위 기반 큐, 버퍼 크기 제한 등의 변형 패턴들이 있습니다. 각각은 서로 다른 조건 변수 사용 패턴을 요구하며, 실제 시스템에서는 이러한 변형 패턴들이 자주 사용됩니다.\n8. 2025년 기준 최신 동향 주제 항목 설명 C++20/C++23 원자적 대기/알림 std::atomic에 wait/notify 기능 추가로 뮤텍스 없는 동기화 가능 성능 최적화 하이브리드 동기화 스핀락과 조건 변수를 조합한 적응형 동기화 기법 발전 락프리 프로그래밍 대안 기술 고성능 시스템에서 조건 변수 대신 락프리 데이터 구조 활용 증가 멀티코어 최적화 NUMA 인식 동기화 멀티소켓 시스템에서 메모리 지역성을 고려한 조건 변수 구현 실시간 시스템 우선순위 기반 실시간 OS에서 우선순위 상속을 지원하는 조건 변수 구현 개선 클라우드 네이티브 분산 동기화 마이크로서비스 환경에서 분산 조건 변수 패턴 연구 활발 AI/ML 워크로드 배치 처리 최적화 GPU 컴퓨팅과 연계된 효율적인 스레드 동기화 패턴 개발 9. 주제와 관련하여 주목할 내용 주제 항목 설명 비동기 프로그래밍 Coroutine 통합 C++20 coroutines와 조건 변수의 통합 패턴 연구 함수형 프로그래밍 액터 모델 Erlang/Elixir의 액터 모델이 조건 변수 패턴에 미치는 영향 WebAssembly 브라우저 동기화 WebAssembly에서 SharedArrayBuffer를 이용한 조건 변수 구현 양자 컴퓨팅 양자 동기화 양자 컴퓨팅 환경에서의 새로운 동기화 패러다임 연구 블록체인 분산 합의 블록체인 합의 알고리즘에서 조건 변수와 유사한 패턴 활용 IoT/임베디드 저전력 동기화 배터리 기반 IoT 디바이스를 위한 저전력 조건 변수 구현 보안 타이밍 공격 방지 사이드 채널 공격을 방지하는 보안 강화 조건 변수 설계 10. 앞으로의 전망 주제 항목 설명 하드웨어 발전 전용 동기화 명령어 CPU에서 조건 변수를 하드웨어 수준에서 지원하는 명령어 추가 AI 기반 최적화 적응형 동기화 머신러닝을 활용한 동적 스레드 스케줄링과 조건 변수 최적화 표준화 크로스 플랫폼 API 다양한 플랫폼 간 통일된 조건 변수 API 표준화 진행 성능 향상 제로 카피 동기화 메모리 복사 없는 고성능 조건 변수 구현 기술 발전 분산 시스템 글로벌 조건 변수 네트워크를 통한 분산 조건 변수 프로토콜 개발 실시간 처리 결정적 지연시간 실시간 시스템을 위한 예측 가능한 지연시간을 가진 조건 변수 녹색 컴퓨팅 에너지 효율성 전력 소비를 최소화하는 친환경 동기화 알고리즘 연구 11. 하위 주제로 추가 학습 내용 카테고리 주제 설명 기본 동기화 뮤텍스와 세마포어 조건 변수와 함께 사용되는 기본 동기화 기본요소들 고급 동기화 리더-라이터 락 조건 변수를 활용한 고급 동기화 패턴 설계 패턴 생산자-소비자 패턴 조건 변수의 대표적인 활용 사례 모니터 구조 모니터와 조건 큐 조건 변수를 캡슐화한 고수준 동기화 추상화 실시간 시스템 우선순위 상속 실시간 시스템에서의 조건 변수 특수 구현 분산 시스템 분산 동기화 네트워크 환경에서의 조건 변수 활용 성능 최적화 락프리 프로그래밍 조건 변수의 대안이 되는 고성능 동기화 기법 12. 관련 분야별 추가 학습 내용 관련 분야 주제 설명 운영체제 스케줄러와 동기화 OS 스케줄러에서 조건 변수가 활용되는 방식 데이터베이스 트랜잭션 격리 데이터베이스에서 조건 변수를 활용한 동시성 제어 네트워크 프로그래밍 비동기 I/O 네트워크 이벤트 처리에서의 조건 변수 활용 게임 개발 프레임 동기화 게임 엔진에서 렌더링과 로직 동기화 웹 개발 서버 아키텍처 웹 서버의 스레드 풀과 요청 처리 동기화 임베디드 RTOS 동기화 실시간 운영체제에서의 특수한 조건 변수 구현 클라우드 컴퓨팅 컨테이너 동기화 컨테이너 오케스트레이션에서의 동기화 패턴 용어 정리 용어 설명 스퓨리어스 웨이크업 (Spurious Wakeup) 실제 신호 없이도 대기 중인 스레드가 깨어나는 현상으로, 하드웨어나 OS 최적화로 인해 발생할 수 있어 조건을 항상 재확인해야 함 신호 손실 (Lost Signal) 스레드가 대기 상태에 진입하기 전에 전송된 신호가 손실되는 현상 Mesa 스타일 신호를 받은 스레드가 즉시 실행되지 않고 뮤텍스를 기다리는 조건 변수 구현 방식 Hoare 스타일 신호를 받은 스레드가 즉시 실행되는 조건 변수 구현 방식 모니터 (Monitor) 뮤텍스와 조건 변수를 조합하여 공유 자원에 대한 안전한 접근을 제공하는 고수준 동기화 추상화 브로드캐스트 (Broadcast) 모든 대기 중인 스레드에게 신호를 보내는 조건 변수 연산 원자적 연산 (Atomic Operation) 중단되지 않고 완전히 수행되거나 전혀 수행되지 않는 연산 경쟁 상태 (Race Condition) 여러 스레드가 공유 자원에 동시에 접근할 때 실행 순서에 따라 결과가 달라지는 상황 우선순위 역전 (Priority Inversion) 높은 우선순위 스레드가 낮은 우선순위 스레드에 의해 차단되는 현상 기아 상태 (Starvation) 특정 스레드가 계속해서 자원을 할당받지 못하는 상황 컨텍스트 스위칭 (Context Switching) CPU가 한 스레드에서 다른 스레드로 실행을 전환하는 과정 바쁜 대기 (Busy Waiting) 조건이 충족될 때까지 계속해서 조건을 확인하며 CPU를 소비하는 대기 방식 참고 및 출처 Microsoft Learn - Condition Variables GeeksforGeeks - Condition Variables in C++ Multithreading cppreference.com - std condition_variable Oracle - Using Condition Variables (Multithreaded Programming Guide) Stanford CS - Locks and Condition Variables Wikipedia - Monitor (synchronization) GeeksforGeeks - Introduction of Process Synchronization Cornell CS - Concurrency: Condition Variables IBM Docs - Using condition variables GeeksforGeeks - Difference between Semaphore and Condition Variable ","wordCount":"6806","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-04T10:54:00Z","dateModified":"2024-10-04T10:54:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/condition-synchronization/implementation-mechanisms/condition-variable/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">조건 변수 (Condition Variable)</h1><div class=post-description>조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.</div><div class=post-meta><span title='2024-10-04 10:54:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Concurrency%20and%20Parallelism/Condition%20Synchronization/Implementation%20Mechanisms/Condition-Variable.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#조건-변수-condition-variable>조건 변수 (Condition Variable)</a><ul><li><a href=#뮤텍스와의-연관>뮤텍스와의 연관</a></li><li><a href=#주요-연산>주요 연산</a></li><li><a href=#사용-패턴>사용 패턴</a></li><li><a href=#가짜-깨우기-spurious-wakeup>가짜 깨우기 (Spurious Wakeup)</a></li><li><a href=#구현>구현</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#1-주제의-분류-적절성>1. 주제의 분류 적절성</a></li><li><a href=#2-200-자-내외-요약>2. 200 자 내외 요약</a></li><li><a href=#3-250-자-내외-개요>3. 250 자 내외 개요</a></li></ul></li><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#주요-내용-정리>주요 내용 정리</a><ul><li><a href=#배경-및-목적>배경 및 목적</a></li><li><a href=#주요-기능-및-역할>주요 기능 및 역할</a></li><li><a href=#특징-및-핵심-원칙>특징 및 핵심 원칙</a></li><li><a href=#주요-원리-및-작동-원리>주요 원리 및 작동 원리</a></li><li><a href=#구조-및-아키텍처>구조 및 아키텍처</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#2025-년-기준-최신-동향>2025 년 기준 최신 동향</a></li><li><a href=#주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#하위-주제-및-추가-학습-필요-내용>하위 주제 및 추가 학습 필요 내용</a></li><li><a href=#추가로-알아야-할-내용-및-관련-분야>추가로 알아야 할 내용 및 관련 분야</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처-1>참고 및 출처</a></li><li><a href=#1-주제-분류-적절성>1. 주제 분류 적절성</a></li><li><a href=#2-주제-요약-200자-내외>2. 주제 요약 (200자 내외)</a></li><li><a href=#3-전체-개요-250자-내외>3. 전체 개요 (250자 내외)</a></li><li><a href=#4-핵심-개념>4. 핵심 개념</a></li><li><a href=#5-주제-관련-조사-항목진행-중>5. 주제 관련 조사 항목(진행 중)</a></li><li><a href=#-구조-및-아키텍처>🔧 구조 및 아키텍처</a><ul><li><a href=#필수-구성-요소>필수 구성 요소</a></li><li><a href=#선택-구성-요소>선택 구성 요소</a></li><li><a href=#동작-원리>동작 원리</a></li></ul></li><li><a href=#-구현-기법>💻 구현 기법</a><ul><li><a href=#1-c11의-stdcondition_variable>1. C++11의 <code>std::condition_variable</code></a></li><li><a href=#2-posix-스레드의-pthread_cond_t>2. POSIX 스레드의 <code>pthread_cond_t</code></a></li><li><a href=#3-rust의-stdsynccondvar>3. Rust의 <code>std::sync::Condvar</code></a></li></ul></li><li><a href=#-장점과--단점>✅ 장점과 ⚠ 단점</a></li><li><a href=#-도전-과제-및-해결책>🧩 도전 과제 및 해결책</a></li><li><a href=#-실무-적용-예시>🧪 실무 적용 예시</a></li><li><a href=#-실무에서-효과적으로-적용하기-위한-고려사항>🧭 실무에서 효과적으로 적용하기 위한 고려사항</a></li><li><a href=#-성능을-최적화하기-위한-고려사항>🚀 성능을 최적화하기 위한 고려사항</a></li><li><a href=#용어-정리-1>용어 정리</a></li><li><a href=#참고-및-출처-2>참고 및 출처</a></li></ul><ul><li><a href=#1-주제의-분류-적절성-1>1. 주제의 분류 적절성</a></li><li><a href=#2-요약-설명-200자-내외>2. 요약 설명 (200자 내외)</a></li><li><a href=#3-개요-250자-내외>3. 개요 (250자 내외)</a></li><li><a href=#4-핵심-개념-1>4. 핵심 개념</a></li><li><a href=#5-주제와-관련하여-조사할-내용>5. 주제와 관련하여 조사할 내용</a><ul><li><a href=#배경>배경</a></li><li><a href=#목적-및-필요성>목적 및 필요성</a></li><li><a href=#주요-기능-및-역할-1>주요 기능 및 역할</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#주요-원리-및-작동-원리-1>주요 원리 및 작동 원리</a></li><li><a href=#구조-및-아키텍처-1>구조 및 아키텍처</a></li><li><a href=#구현-기법>구현 기법</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#도전-과제>도전 과제</a></li><li><a href=#분류에-따른-종류-및-유형>분류에 따른 종류 및 유형</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항-및-주의할-점-1>최적화하기 위한 고려사항 및 주의할 점</a></li></ul></li><li><a href=#6-주제에-대한-추가-조사-내용>6. 주제에 대한 추가 조사 내용</a></li><li><a href=#7-추가로-알아야-하는-내용>7. 추가로 알아야 하는 내용</a><ul><li><a href=#모니터-monitor-패턴>모니터 (Monitor) 패턴</a></li><li><a href=#세마포어와의-차이점>세마포어와의 차이점</a></li><li><a href=#리더-라이터-락-reader-writer-lock>리더-라이터 락 (Reader-Writer Lock)</a></li><li><a href=#생산자-소비자-변형-패턴>생산자-소비자 변형 패턴</a></li></ul></li><li><a href=#8-2025년-기준-최신-동향>8. 2025년 기준 최신 동향</a></li><li><a href=#9-주제와-관련하여-주목할-내용>9. 주제와 관련하여 주목할 내용</a></li><li><a href=#10-앞으로의-전망>10. 앞으로의 전망</a></li><li><a href=#11-하위-주제로-추가-학습-내용>11. 하위 주제로 추가 학습 내용</a></li><li><a href=#12-관련-분야별-추가-학습-내용>12. 관련 분야별 추가 학습 내용</a></li><li><a href=#용어-정리-2>용어 정리</a></li><li><a href=#참고-및-출처-3>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=조건-변수-condition-variable>조건 변수 (Condition Variable)<a hidden class=anchor aria-hidden=true href=#조건-변수-condition-variable>#</a></h2><p>조건 변수 (Condition Variables) 는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.</p><p>스레드가 특정 조건이 만족될 때까지 대기하고, 조건이 충족되면 다른 스레드가 대기 중인 스레드를 깨우는 데 사용된다.</p><h3 id=뮤텍스와의-연관>뮤텍스와의 연관<a hidden class=anchor aria-hidden=true href=#뮤텍스와의-연관>#</a></h3><p>조건 변수는 일반적으로 뮤텍스와 함께 사용된다.<br>뮤텍스는 조건을 원자적으로 검사하고 변경할 수 있도록 보장한다.</p><h3 id=주요-연산>주요 연산<a hidden class=anchor aria-hidden=true href=#주요-연산>#</a></h3><ul><li>wait(): 스레드가 조건이 충족될 때까지 대기하도록 한다.</li><li>signal()/notify_one(): 대기 중인 단일 스레드를 깨운다.</li><li>broadcast()/notify_all(): 해당 조건 변수에서 대기 중인 모든 스레드를 깨운다.</li></ul><h3 id=사용-패턴>사용 패턴<a hidden class=anchor aria-hidden=true href=#사용-패턴>#</a></h3><ul><li>조건을 보호하는 뮤텍스를 획득한다.</li><li>조건을 테스트한다.</li><li>조건이 거짓이면 wait() 를 호출하여 대기한다.</li><li>조건이 참이면 작업을 수행하고 뮤텍스를 해제한다.</li></ul><h3 id=가짜-깨우기-spurious-wakeup>가짜 깨우기 (Spurious Wakeup)<a hidden class=anchor aria-hidden=true href=#가짜-깨우기-spurious-wakeup>#</a></h3><p>가짜 깨우기는 조건 변수 (Condition Variable) 를 사용할 때 발생할 수 있는 현상이다.<br>스레드가 실제로 signal 이나 broadcast 를 받지 않았는데도 wait 상태에서 깨어나는 현상을 말한다.</p><p>이는 운영체제의 구현 방식이나 하드웨어의 특성으로 인해 발생할 수 있다.<br>가짜 깨우기가 발생하는 이유들은 다음과 같다:</p><ol><li>운영체제 최적화: 일부 운영체제는 성능 향상을 위해 의도적으로 가짜 깨우기를 발생시킬 수 있다.</li><li>하드웨어 인터럽트: 시스템 이벤트나 하드웨어 인터럽트로 인해 스레드가 예기치 않게 깨어날 수 있다.</li><li>시그널 처리: 운영체제의 시그널 처리 메커니즘이 의도치 않은 깨우기를 유발할 수 있다.</li></ol><p>가짜 깨우기를 처리하는 일반적인 패턴은 다음과 같다:</p><ol><li>조건을 while 루프로 감싸기</li><li>명확한 상태 변수 사용하기</li><li>모든 상태 변경을 적절한 동기화 블록 내에서 수행하기</li><li>notify() 호출 전에 상태 변경하기<br>이러한 방어적 프로그래밍 기법을 사용함으로써, 가짜 깨우기로 인한 문제를 효과적으로 방지할 수 있다.<br>특히 멀티스레드 프로그래밍에서는 이러한 세부사항에 주의를 기울이는 것이 매우 중요하다.</li></ol><h4 id=예시>예시<a hidden class=anchor aria-hidden=true href=#예시>#</a></h4><p>다음은 가짜 깨우기 문제를 보여주는 잘못된 코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 잘못된 구현 - 가짜 깨우기에 취약</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>wait_for_data</span><span class=p>(</span><span class=n>condition</span><span class=p>,</span> <span class=n>shared_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>condition</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>shared_data</span><span class=o>.</span><span class=n>is_ready</span><span class=p>:</span>  <span class=c1># if 사용 - 문제 있음</span>
</span></span><span class=line><span class=cl>            <span class=n>condition</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>shared_data</span><span class=o>.</span><span class=n>value</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드의 문제점은 if 문을 사용하여 조건을 한 번만 검사한다는 것이다.<br>가짜 깨우기가 발생하면, 실제로 데이터가 준비되지 않았는데도 스레드가 깨어나서 잘못된 데이터를 반환할 수 있다.</p><p>다음은 가짜 깨우기를 올바르게 처리하는 코드:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span><span class=lnt id=hl-1-42><a class=lnlinks href=#hl-1-42>42</a>
</span><span class=lnt id=hl-1-43><a class=lnlinks href=#hl-1-43>43</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SharedData</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>condition</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Condition</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>is_ready</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wait_for_data</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>condition</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>is_ready</span><span class=p>:</span>  <span class=c1># while 사용 - 안전한 구현</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>condition</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>set_data</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>condition</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>is_ready</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>condition</span><span class=o>.</span><span class=n>notify_all</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consumer</span><span class=p>(</span><span class=n>shared_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;소비자: 데이터 대기 중…&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>value</span> <span class=o>=</span> <span class=n>shared_data</span><span class=o>.</span><span class=n>wait_for_data</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;소비자: 데이터 수신 - </span><span class=si>{</span><span class=n>value</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>producer</span><span class=p>(</span><span class=n>shared_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;생산자: 잠시 대기…&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;생산자: 데이터 설정&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>shared_data</span><span class=o>.</span><span class=n>set_data</span><span class=p>(</span><span class=s2>&#34;중요한 데이터&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 테스트</span>
</span></span><span class=line><span class=cl><span class=n>shared_data</span> <span class=o>=</span> <span class=n>SharedData</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>consumer_thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>consumer</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>shared_data</span><span class=p>,))</span>
</span></span><span class=line><span class=cl><span class=n>producer_thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>producer</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>shared_data</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>consumer_thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>producer_thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>consumer_thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>producer_thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>이 개선된 구현에서는 다음과 같은 중요한 포인트들을 주목해야 한다:</p><ol><li>while 루프 사용: if 대신 while 을 사용하여 조건을 반복적으로 검사한다. 이는 가짜 깨우기가 발생하더라도 조건이 실제로 만족될 때까지 대기하도록 보장한다.</li><li>상태 변수 (is_ready): 단순히 신호만 기다리는 것이 아니라, 실제 데이터의 상태를 추적하는 변수를 사용한다.</li><li>동기화 블록: 모든 공유 데이터 접근은 condition lock 으로 보호된다.</li></ol><h3 id=구현>구현<a hidden class=anchor aria-hidden=true href=#구현>#</a></h3><p>대부분의 현대 운영 체제와 프로그래밍 언어에서 조건 변수를 지원한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span><span class=lnt id=hl-2-39><a class=lnlinks href=#hl-2-39>39</a>
</span><span class=lnt id=hl-2-40><a class=lnlinks href=#hl-2-40>40</a>
</span><span class=lnt id=hl-2-41><a class=lnlinks href=#hl-2-41>41</a>
</span><span class=lnt id=hl-2-42><a class=lnlinks href=#hl-2-42>42</a>
</span><span class=lnt id=hl-2-43><a class=lnlinks href=#hl-2-43>43</a>
</span><span class=lnt id=hl-2-44><a class=lnlinks href=#hl-2-44>44</a>
</span><span class=lnt id=hl-2-45><a class=lnlinks href=#hl-2-45>45</a>
</span><span class=lnt id=hl-2-46><a class=lnlinks href=#hl-2-46>46</a>
</span><span class=lnt id=hl-2-47><a class=lnlinks href=#hl-2-47>47</a>
</span><span class=lnt id=hl-2-48><a class=lnlinks href=#hl-2-48>48</a>
</span><span class=lnt id=hl-2-49><a class=lnlinks href=#hl-2-49>49</a>
</span><span class=lnt id=hl-2-50><a class=lnlinks href=#hl-2-50>50</a>
</span><span class=lnt id=hl-2-51><a class=lnlinks href=#hl-2-51>51</a>
</span><span class=lnt id=hl-2-52><a class=lnlinks href=#hl-2-52>52</a>
</span><span class=lnt id=hl-2-53><a class=lnlinks href=#hl-2-53>53</a>
</span><span class=lnt id=hl-2-54><a class=lnlinks href=#hl-2-54>54</a>
</span><span class=lnt id=hl-2-55><a class=lnlinks href=#hl-2-55>55</a>
</span><span class=lnt id=hl-2-56><a class=lnlinks href=#hl-2-56>56</a>
</span><span class=lnt id=hl-2-57><a class=lnlinks href=#hl-2-57>57</a>
</span><span class=lnt id=hl-2-58><a class=lnlinks href=#hl-2-58>58</a>
</span><span class=lnt id=hl-2-59><a class=lnlinks href=#hl-2-59>59</a>
</span><span class=lnt id=hl-2-60><a class=lnlinks href=#hl-2-60>60</a>
</span><span class=lnt id=hl-2-61><a class=lnlinks href=#hl-2-61>61</a>
</span><span class=lnt id=hl-2-62><a class=lnlinks href=#hl-2-62>62</a>
</span><span class=lnt id=hl-2-63><a class=lnlinks href=#hl-2-63>63</a>
</span><span class=lnt id=hl-2-64><a class=lnlinks href=#hl-2-64>64</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DataQueue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>queue</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 큐가 비어있지 않음을 나타내는 조건 변수</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>not_empty</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Condition</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 큐가 가득 차지 않음을 나타내는 조건 변수</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>not_full</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Condition</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>put</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 큐가 가득 찼다면 대기</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;큐가 가득 찼습니다. 생산자 대기 중…&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>not_full</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 데이터 추가</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;생산: </span><span class=si>{</span><span class=n>data</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 대기 중인 소비자에게 신호 전송</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>not_empty</span><span class=o>.</span><span class=n>notify</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 큐가 비었다면 대기</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;큐가 비었습니다. 소비자 대기 중…&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>not_empty</span><span class=o>.</span><span class=n>wait</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 데이터 추출</span>
</span></span><span class=line><span class=cl>            <span class=n>data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;소비: </span><span class=si>{</span><span class=n>data</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 대기 중인 생산자에게 신호 전송</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>not_full</span><span class=o>.</span><span class=n>notify</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 생산자 함수</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>producer</span><span class=p>(</span><span class=n>queue</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.5</span><span class=p>)</span>  <span class=c1># 생산 시간 시뮬레이션</span>
</span></span><span class=line><span class=cl>        <span class=n>queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;항목 </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 소비자 함수</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>consumer</span><span class=p>(</span><span class=n>queue</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 소비 시간 시뮬레이션</span>
</span></span><span class=line><span class=cl>        <span class=n>queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행</span>
</span></span><span class=line><span class=cl><span class=n>queue</span> <span class=o>=</span> <span class=n>DataQueue</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>  <span class=c1># 크기가 3인 큐 생성</span>
</span></span><span class=line><span class=cl><span class=n>producer_thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>producer</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>queue</span><span class=p>,))</span>
</span></span><span class=line><span class=cl><span class=n>consumer_thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>consumer</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>queue</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>producer_thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>consumer_thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>producer_thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>consumer_thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드는 생산자 - 소비자 문제를 조건 변수를 사용하여 해결하는 예시이다.<br>여기서 조건 변수는 두 가지 중요한 역할을 한다:</p><ol><li>큐가 가득 찼을 때 생산자를 대기시키고, 공간이 생기면 깨우기</li><li>큐가 비었을 때 소비자를 대기시키고, 데이터가 들어오면 깨우기</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=1-주제의-분류-적절성>1. 주제의 분류 적절성<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적절성>#</a></h3><p>조건 변수 (Condition Variable) 는 &lsquo;Computer Science and Engineering > Computer Science Fundamentals > Operating System > Process Management > Synchronization > Condition Synchronization&rsquo; 의 하위 주제로 분류하는 것이 적합하다. 조건 변수는 조건 동기화의 핵심 메커니즘이기 때문이다.</p><hr><h3 id=2-200-자-내외-요약>2. 200 자 내외 요약<a hidden class=anchor aria-hidden=true href=#2-200-자-내외-요약>#</a></h3><p>조건 변수는 다중 스레드 환경에서 특정 조건이 충족될 때까지 스레드를 대기 상태로 만들고, 조건이 만족되면 대기 중인 스레드를 깨워 실행을 재개하는 동기화 객체이다. 임계 구역 보호와 레이스 컨디션 방지에 필수적이며, 효율적인 자원 관리를 가능하게 한다.</p><hr><h3 id=3-250-자-내외-개요>3. 250 자 내외 개요<a hidden class=anchor aria-hidden=true href=#3-250-자-내외-개요>#</a></h3><p>조건 변수는 동시성 환경에서 여러 스레드가 공유 자원에 안전하게 접근할 수 있도록 특정 조건이 충족될 때까지 스레드를 대기시키고, 조건이 만족되면 대기 중인 스레드를 신호로 깨워 실행을 재개시킨다. 락과 함께 사용되어 임계 구역 보호, 효율적인 자원 관리, 레이스 컨디션 방지 등 동기화의 핵심 역할을 수행하며, wait/signal 연산을 통해 동작한다. 다양한 운영체제와 프레임워크에서 필수적으로 활용된다.</p><hr><h2 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h2><ul><li>**조건 변수 (Condition Variable)**는 스레드가 특정 조건이 만족될 때까지 대기 (wait) 하고, 조건이 충족되면 signal(또는 notify) 로 깨워주는 동기화 객체이다.</li><li>락 (Lock) 과 함께 사용되어 임계 구역에서의 상호 배제 (Mutual Exclusion) 를 보장한다.</li><li>wait, signal, broadcast(여러 스레드 깨움) 연산을 지원한다.</li><li>동시성 오류 (레이스 컨디션, 데드락) 방지와 효율적인 자원 관리에 필수적이다.</li></ul><hr><h2 id=주요-내용-정리>주요 내용 정리<a hidden class=anchor aria-hidden=true href=#주요-내용-정리>#</a></h2><h3 id=배경-및-목적>배경 및 목적<a hidden class=anchor aria-hidden=true href=#배경-및-목적>#</a></h3><ul><li>동시성 환경에서 자원 경쟁과 데이터 불일치 문제를 해결하기 위해 도입.</li><li>임계 구역 보호, 레이스 컨디션 및 데드락 방지, 효율적인 자원 활용이 목적.</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li>스레드가 조건이 만족될 때까지 대기 (wait)</li><li>조건이 충족되면 신호 (signal) 로 대기 중인 스레드 실행 재개</li><li>임계 구역 보호, 효율적 자원 관리, 동기화의 핵심 역할 수행</li></ul><h3 id=특징-및-핵심-원칙>특징 및 핵심 원칙<a hidden class=anchor aria-hidden=true href=#특징-및-핵심-원칙>#</a></h3><ul><li><strong>상호 배제 (Mutual Exclusion)</strong>: 락을 통해 임계 구역 보호</li><li><strong>진행 (Progress)</strong>: 조건 충족 시 즉시 스레드 실행</li><li><strong>유한 대기 (Bounded Waiting)</strong>: 무한 대기 방지</li></ul><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><ul><li>락과 조건 변수를 조합하여 wait/signal 연산으로 동기화 구현</li><li>wait: 락을 해제하고 대기 큐에 진입</li><li>signal: 대기 중인 스레드 하나를 깨움</li></ul><h4 id=다이어그램>다이어그램<a hidden class=anchor aria-hidden=true href=#다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=p>[</span><span class=n>Thread1</span><span class=p>]</span> <span class=o>--</span><span class=n>lock</span><span class=o>--&gt;</span> <span class=p>[</span><span class=n>Critical</span> <span class=n>Section</span><span class=p>]</span> <span class=o>--</span><span class=n>wait</span><span class=p>(</span><span class=n>cond</span><span class=p>)</span><span class=o>--&gt;</span> <span class=p>[</span><span class=n>Blocked</span> <span class=n>Queue</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>Thread2</span><span class=p>]</span> <span class=o>--</span><span class=n>lock</span><span class=o>--&gt;</span> <span class=p>[</span><span class=n>Critical</span> <span class=n>Section</span><span class=p>]</span> <span class=o>--</span><span class=k>signal</span><span class=p>(</span><span class=n>cond</span><span class=p>)</span><span class=o>--&gt;</span> <span class=p>[</span><span class=n>Thread1</span> <span class=err>실행</span> <span class=err>재개</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=필수-구성요소>필수 구성요소<a hidden class=anchor aria-hidden=true href=#필수-구성요소>#</a></h4><ul><li><strong>락 (Lock)</strong>: 임계 구역 상호 배제 보장</li><li><strong>조건 변수 (Condition Variable)</strong>: 조건 기반 대기 및 신호 전달</li><li><strong>대기 큐 (Wait Queue)</strong>: 조건 미충족 시 스레드 대기</li></ul><h4 id=선택-구성요소>선택 구성요소<a hidden class=anchor aria-hidden=true href=#선택-구성요소>#</a></h4><ul><li><strong>모니터 (Monitor)</strong>: 조건 변수와 락을 캡슐화하여 동기화 간소화</li><li><strong>세마포어 (Semaphore)</strong>: 카운터 기반 자원 접근 제어</li></ul><h4 id=구조-다이어그램>구조 다이어그램<a hidden class=anchor aria-hidden=true href=#구조-다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>+---------------------+</span>
</span></span><span class=line><span class=cl><span class=o>|</span>     <span class=n>Monitor</span>         <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-----------------+</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>|</span> <span class=n>Condition</span> <span class=n>Var</span>   <span class=o>|</span> <span class=p>[</span><span class=n>Buffer</span><span class=p>]</span> <span class=o>--</span><span class=n>consume</span><span class=o>--&gt;</span> <span class=p>[</span><span class=n>Consumer</span><span class=p>]</span>
</span></span><span class=line><span class=cl>     <span class=o>|</span>                        <span class=o>|</span>                      <span class=o>|</span>
</span></span><span class=line><span class=cl>     <span class=o>|---</span><span class=n>wait</span><span class=p>(</span><span class=ow>not</span> <span class=n>full</span><span class=p>)</span><span class=o>------&gt;|</span>                      <span class=o>|</span>
</span></span><span class=line><span class=cl>     <span class=o>|&lt;--</span><span class=k>signal</span><span class=p>(</span><span class=ow>not</span> <span class=n>empty</span><span class=p>)</span><span class=o>----|</span>                      <span class=o>|</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>워크플로우</strong>:<ol><li>생산자: 버퍼가 가득 차면 not full 조건 변수에서 대기</li><li>소비자: 버퍼가 비면 not empty 조건 변수에서 대기</li><li>생산자/소비자: 조건 충족 시 signal 로 상대 스레드 깨움</li></ol></li><li><strong>역할</strong>:<ul><li>조건 변수: 버퍼 상태 변화에 따라 대기/신호 전달</li><li>락: 버퍼 접근 상호 배제 보장</li></ul></li></ul><hr><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>락 범위 최소화</td><td>불필요한 병목 방지</td><td>임계 구역 최소화</td></tr><tr><td>조건 변수 사용</td><td>대기/신호 시점 명확히 정의</td><td>명확한 조건 설정</td></tr><tr><td>데드락 방지</td><td>락 획득 순서 일관성 유지</td><td>타임아웃, 락 순서 지정</td></tr><tr><td>테스트</td><td>동시성 시나리오 반복 검증</td><td>자동화 테스트 도입</td></tr></tbody></table><hr><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>락 경쟁 최소화</td><td>락 획득 경쟁 줄이기</td><td>분할 락, 락 프리 구조</td></tr><tr><td>대기 최소화</td><td>불필요한 wait 방지</td><td>조건 충족 시 즉시 signal</td></tr><tr><td>스레드 수 조절</td><td>과도한 스레드 생성 방지</td><td>적정 스레드 풀 관리</td></tr><tr><td>비동기 처리</td><td>병목 구간 비동기화</td><td>이벤트 기반 아키텍처 적용</td></tr></tbody></table><hr><h3 id=2025-년-기준-최신-동향>2025 년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#2025-년-기준-최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>조건 변수</td><td>경량화 동기화</td><td>경량 락, 락 프리 (lock-free) 동기화 기법과의 결합 강화</td></tr><tr><td>조건 변수</td><td>분산 시스템</td><td>분산 환경에서의 조건 변수 구현 및 표준화 연구 활발</td></tr><tr><td>조건 변수</td><td>자동화 도구</td><td>동시성 오류 자동 탐지 및 진단 도구 발전</td></tr><tr><td>조건 변수</td><td>실시간 처리</td><td>실시간 데이터 동기화와 연계된 조건 변수 최적화 기술 부상</td></tr></tbody></table><hr><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>조건 변수</td><td>async/await</td><td>비동기 프로그래밍 패턴과의 결합 증가</td></tr><tr><td>조건 변수</td><td>동시성 표준</td><td>POSIX, Java, Python 등 표준 API 의 진화</td></tr><tr><td>조건 변수</td><td>성능 분석</td><td>대규모 시스템에서 조건 변수 병목 분석 중요성 증가</td></tr></tbody></table><hr><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>조건 변수</td><td>자동화 및 지능화</td><td>AI 기반 동시성 진단 및 최적화 도구 발전</td></tr><tr><td>조건 변수</td><td>분산 동기화</td><td>클라우드/분산 환경에서 조건 변수 확장</td></tr><tr><td>조건 변수</td><td>실시간 시스템</td><td>초저지연 실시간 동기화 기술과의 융합 전망</td></tr></tbody></table><hr><h3 id=하위-주제-및-추가-학습-필요-내용>하위 주제 및 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#하위-주제-및-추가-학습-필요-내용>#</a></h3><table><thead><tr><th>간략 설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>고급 동기화 패턴</td><td>동기화 기법</td><td>배리어, 래치, 리더 - 팔로워 등</td></tr><tr><td>분산 조건 변수</td><td>분산 컴퓨팅</td><td>분산 락, 분산 조건 변수</td></tr><tr><td>동기화 성능 분석</td><td>성능 최적화</td><td>락 경합, 병목 분석</td></tr><tr><td>동시성 오류 진단</td><td>품질 보증</td><td>동시성 버그 자동 탐지 도구</td></tr></tbody></table><hr><h3 id=추가로-알아야-할-내용-및-관련-분야>추가로 알아야 할 내용 및 관련 분야<a hidden class=anchor aria-hidden=true href=#추가로-알아야-할-내용-및-관련-분야>#</a></h3><table><thead><tr><th>간략 설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>실시간 동기화</td><td>임베디드</td><td>RTOS 동기화 메커니즘</td></tr><tr><td>클라우드 네이티브 동기화</td><td>클라우드</td><td>컨테이너, 마이크로서비스 동기화</td></tr><tr><td>데이터 일관성</td><td>데이터베이스</td><td>트랜잭션, 분산 일관성 모델</td></tr><tr><td>이벤트 기반 동기화</td><td>소프트웨어 아키텍처</td><td>이벤트 드리븐 아키텍처 (EDA)</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>wait</td><td>조건 변수에서 조건이 충족될 때까지 스레드를 대기시키는 연산</td></tr><tr><td>signal</td><td>조건 변수에서 대기 중인 스레드 하나를 깨우는 연산</td></tr><tr><td>broadcast</td><td>조건 변수에서 대기 중인 모든 스레드를 깨우는 연산</td></tr><tr><td>대기 큐 (Wait Queue)</td><td>조건 미충족 시 스레드가 대기하는 큐</td></tr></tbody></table><hr><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><a href=https://www.geeksforgeeks.org/condition-variables-in-operating-system/>조건 변수의 개념 및 동작 원리 설명 문서</a></li><li><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html>Java Condition Variable 공식 문서</a></li><li><a href=https://man7.org/linux/man-pages/man3/pthread_cond_wait.3.html>POSIX Condition Variable 설명</a></li><li><a href=https://docs.python.org/3/library/threading.html#condition-objects>Python threading.Condition 공식 문서</a></li></ul><hr><p>현재까지 “조건 변수 (Condition Variable)” 주제에 대해 조사한 내용을 기반으로 아래와 같이 정리해 드립니다. 주제의 체계적 이해를 돕기 위한 분석 작업은 계속 진행 중이며, 일부 항목은 더 정제된 정보가 추가될 예정입니다.</p><hr><h2 id=1-주제-분류-적절성>1. 주제 분류 적절성<a hidden class=anchor aria-hidden=true href=#1-주제-분류-적절성>#</a></h2><ul><li><p>분류: Computer Science and Engineering > Computer Science Fundamentals > Operating System > Process Management > Synchronization > Condition Synchronization</p></li><li><p>적절성: 완전히 적절합니다. 조건 변수는 프로세스/스레드 동기화의 핵심 메커니즘 중 하나로, 운영체제 및 멀티스레딩 환경의 동기화 관리에서 매우 중요한 위치를 차지합니다.</p></li></ul><hr><h2 id=2-주제-요약-200자-내외>2. 주제 요약 (200자 내외)<a hidden class=anchor aria-hidden=true href=#2-주제-요약-200자-내외>#</a></h2><p>조건 변수는 멀티스레딩 환경에서 특정 조건이 만족될 때까지 스레드 실행을 중단하고, 조건이 충족되면 재개할 수 있도록 돕는 동기화 메커니즘으로, 효율적인 리소스 제어와 병행 처리에 필수적입니다.</p><hr><h2 id=3-전체-개요-250자-내외>3. 전체 개요 (250자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250자-내외>#</a></h2><p>조건 변수는 임계 구역 보호 외에도 특정 상태나 조건이 충족될 때까지 스레드를 블로킹하는 데 사용됩니다. mutex와 함께 사용되어 race condition을 방지하며, 생산자-소비자, reader-writer 문제 등에서 자주 활용됩니다. pthread, Java, Rust, Go 등 다양한 언어 및 플랫폼에서 지원되며, 최근에는 wait-free 및 비동기 메시지 패턴과 함께 보완적으로 사용되고 있습니다.</p><hr><h2 id=4-핵심-개념>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념>#</a></h2><ul><li><p>조건 변수(Condition Variable)는 공유 자원 접근에서 조건이 충족될 때까지 스레드를 블로킹하고, 조건 충족 시 해당 스레드를 깨우는 메커니즘입니다.</p></li><li><p>mutex(상호배제)와 함께 사용되며, wait/signal/broadcast 등의 연산을 통해 동기화를 수행합니다.</p></li><li><p>POSIX에서는 pthread_cond_t, Java에서는 Object.wait()/notify(), Rust에서는 std::sync::Condvar 등으로 구현됩니다.</p></li><li><p>while 루프 내에서 조건 검사를 통해 spurious wakeup(허위 깨움) 문제를 방지해야 합니다.</p></li></ul><hr><h2 id=5-주제-관련-조사-항목진행-중>5. 주제 관련 조사 항목(진행 중)<a hidden class=anchor aria-hidden=true href=#5-주제-관련-조사-항목진행-중>#</a></h2><p>다음 항목들은 조사하여 정리 중이며, 일부는 완성되었고 일부는 추가 수집 중입니다:</p><p>✅ 완료 및 수집된 항목:</p><ul><li><p>구현 기법: POSIX pthread, Java Monitor, Rust Condvar</p></li><li><p>동작 원리: wait → unlock → sleep → signal → lock → resume</p></li><li><p>비교 분석: 조건 변수 vs 세마포어 vs 모니터</p></li><li><p>주요 사용 사례: 생산자-소비자, 리더-라이터, 스레드 풀</p></li></ul><p>🕓 조사 중인 항목:</p><ul><li><p>구조 및 아키텍처: wait queue, signal set, 내부 스케줄러 흐름</p></li><li><p>성능 최적화 전략: wait-time 감소, false wake-up 감소, lock contention 완화</p></li><li><p>대규모 시스템 사례: Kafka, Redis, Rust async Condvar 구조</p></li><li><p>2025년 최신 동향 및 기술 트렌드 정리</p></li></ul><hr><p>이어서 다음 항목들을 순차적으로 정리하여 제공드릴 예정입니다:</p><ol><li><p>조건 변수의 구조 및 구성 요소 (다이어그램 포함)</p></li><li><p>구현 기법별 예시 (C, Java, Rust 등)</p></li><li><p>장단점 분석 표</p></li><li><p>주요 도전과제 및 대응 전략</p></li><li><p>최신 동향(2025 기준), 주목 기술, 향후 전망, 추가 학습 주제</p></li></ol><p>또한 아래 항목에 대한 정리도 병행 중입니다:</p><ul><li><p>용어 정리</p></li><li><p>참고 및 출처 목록</p></li><li><p>실제 시스템 적용 시나리오 및 워크플로우</p></li></ul><p>—</p><p><a href="https://www.youtube.com/watch?v=tz5aoWXgOME"><figure><img alt="04 변수 범위 2 - YouTube" loading=lazy src="https://tse2.mm.bing.net/th?id=OIP.7WJTVnrwDgLbcsS5KBVhlgHaEK&pid=Api"></figure></a></p><p>조건 변수(Condition Variable)는 멀티스레딩 환경에서 스레드 간의 효율적인 동기화를 위해 사용되는 핵심 메커니즘입니다. 이 메커니즘은 특정 조건이 충족될 때까지 스레드의 실행을 일시 중단하고, 조건이 만족되면 다시 실행을 재개할 수 있도록 합니다. 이를 통해 리소스의 효율적인 관리와 병행 처리의 안정성을 확보할 수 있습니다.</p><hr><h2 id=-구조-및-아키텍처>🔧 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#-구조-및-아키텍처>#</a></h2><h3 id=필수-구성-요소>필수 구성 요소<a hidden class=anchor aria-hidden=true href=#필수-구성-요소>#</a></h3><ul><li><p><strong>조건 변수 (Condition Variable)</strong>: 스레드가 특정 조건이 충족될 때까지 대기할 수 있도록 하는 동기화 객체입니다.</p></li><li><p><strong>뮤텍스 (Mutex)</strong>: 공유 자원에 대한 상호 배제를 보장하여 데이터의 일관성을 유지합니다.</p></li></ul><h3 id=선택-구성-요소>선택 구성 요소<a hidden class=anchor aria-hidden=true href=#선택-구성-요소>#</a></h3><ul><li><strong>플래그 변수 (Flag Variable)</strong>: 조건의 충족 여부를 나타내는 불리언 변수로, 조건 검사를 위해 사용됩니다.</li></ul><h3 id=동작-원리>동작 원리<a hidden class=anchor aria-hidden=true href=#동작-원리>#</a></h3><ol><li><p>스레드는 뮤텍스를 획득하여 공유 자원에 대한 접근을 시도합니다.</p></li><li><p>조건이 충족되지 않으면, 스레드는 조건 변수의 <code>wait()</code> 함수를 호출하여 뮤텍스를 해제하고 대기 상태로 전환됩니다.</p></li><li><p>다른 스레드가 조건을 충족시키고 <code>notify_one()</code> 또는 <code>notify_all()</code> 함수를 호출하면, 대기 중인 스레드가 깨워집니다.</p></li><li><p>깨워진 스레드는 뮤텍스를 다시 획득하고, 조건을 재검사하여 작업을 계속할지 결정합니다.</p></li></ol><hr><h2 id=-구현-기법>💻 구현 기법<a hidden class=anchor aria-hidden=true href=#-구현-기법>#</a></h2><h3 id=1-c11의-stdcondition_variable>1. C++11의 <code>std::condition_variable</code><a hidden class=anchor aria-hidden=true href=#1-c11의-stdcondition_variable>#</a></h3><p>C++11 표준에서는 <code>&lt;condition_variable></code> 헤더를 통해 조건 변수를 제공합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;condition_variable&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;mutex&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>mtx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>cv</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>ready</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>worker</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mtx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=p>[]{</span> <span class=k>return</span> <span class=n>ready</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 작업 수행
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드에서 <code>cv.wait(lock, []{ return ready; });</code>는 <code>ready</code>가 <code>true</code>가 될 때까지 현재 스레드를 대기시킵니다.</p><h3 id=2-posix-스레드의-pthread_cond_t>2. POSIX 스레드의 <code>pthread_cond_t</code><a hidden class=anchor aria-hidden=true href=#2-posix-스레드의-pthread_cond_t>#</a></h3><p>POSIX 스레드 라이브러리에서는 <code>pthread_cond_t</code>를 사용하여 조건 변수를 구현합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>mutex</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>pthread_cond_t</span> <span class=n>cond</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>worker</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 작업 수행
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>pthread_cond_wait</code> 함수는 뮤텍스를 해제하고 스레드를 대기 상태로 전환하며, 조건이 충족되면 뮤텍스를 다시 획득합니다.</p><h3 id=3-rust의-stdsynccondvar>3. Rust의 <code>std::sync::Condvar</code><a hidden class=anchor aria-hidden=true href=#3-rust의-stdsynccondvar>#</a></h3><p>Rust에서는 <code>std::sync::Condvar</code>를 통해 조건 변수를 제공합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>sync</span>::<span class=p>{</span><span class=n>Arc</span><span class=p>,</span><span class=w> </span><span class=n>Condvar</span><span class=p>,</span><span class=w> </span><span class=n>Mutex</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>thread</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>pair</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>((</span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=kc>false</span><span class=p>),</span><span class=w> </span><span class=n>Condvar</span>::<span class=n>new</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>pair_clone</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pair</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>lock</span><span class=p>,</span><span class=w> </span><span class=n>cvar</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;*</span><span class=n>pair_clone</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>started</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>*</span><span class=n>started</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>cvar</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>위 코드에서 <code>cvar.notify_one()</code>은 대기 중인 스레드 중 하나를 깨웁니다.</p><hr><h2 id=-장점과--단점>✅ 장점과 ⚠ 단점<a hidden class=anchor aria-hidden=true href=#-장점과--단점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>효율적인 대기</td><td>조건이 충족될 때까지 스레드를 블로킹하여 CPU 자원을 절약합니다.</td></tr><tr><td></td><td>명확한 동기화</td><td>뮤텍스와 함께 사용하여 공유 자원에 대한 안전한 접근을 보장합니다.</td></tr><tr><td>⚠ 단점</td><td>스푸리어스 웨이크업</td><td>조건이 충족되지 않았음에도 스레드가 깨어날 수 있어 추가적인 조건 검사가 필요합니다.</td></tr><tr><td></td><td>데드락 위험</td><td>뮤텍스와 조건 변수의 잘못된 사용으로 데드락이 발생할 수 있습니다.</td></tr></tbody></table><hr><h2 id=-도전-과제-및-해결책>🧩 도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#-도전-과제-및-해결책>#</a></h2><ul><li><p><strong>스푸리어스 웨이크업</strong>: 스레드가 조건이 충족되지 않았음에도 깨어나는 현상입니다. 이를 방지하기 위해 <code>while</code> 루프를 사용하여 조건을 재검사해야 합니다.</p></li><li><p><strong>데드락</strong>: 뮤텍스와 조건 변수를 잘못 사용하면 데드락이 발생할 수 있습니다. 이를 방지하기 위해 뮤텍스 획득 순서를 일관되게 유지하고, 가능한 한 뮤텍스 보유 시간을 최소화해야 합니다.</p></li></ul><hr><h2 id=-실무-적용-예시>🧪 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#-실무-적용-예시>#</a></h2><table><thead><tr><th>시스템</th><th>적용 사례</th><th>설명</th></tr></thead><tbody><tr><td>Kafka</td><td>메시지 큐 대기</td><td>프로듀서와 컨슈머 간의 메시지 큐 상태를 조건 변수로 관리하여 효율적인 데이터 처리</td></tr><tr><td>Redis</td><td>분산 락 구현</td><td><code>SETNX</code> 명령어와 조건 변수를 활용하여 분산 환경에서의 자원 접근 제어</td></tr><tr><td>Web Server</td><td>요청 처리 동기화</td><td>다중 스레드 환경에서 클라이언트 요청을 조건 변수로 동기화하여 안정적인 서비스 제공</td></tr></tbody></table><hr><h2 id=-실무에서-효과적으로-적용하기-위한-고려사항>🧭 실무에서 효과적으로 적용하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#-실무에서-효과적으로-적용하기-위한-고려사항>#</a></h2><table><thead><tr><th>고려사항</th><th>설명</th><th>권장 사항</th></tr></thead><tbody><tr><td>조건 검사 방식</td><td>스푸리어스 웨이크업 방지를 위해 <code>while</code> 루프 사용</td><td>항상 <code>while</code> 루프를 사용하여 조건을 재검사</td></tr><tr><td>뮤텍스 사용</td><td>데드락 방지를 위해 뮤텍스 획득 순서 일관성 유지</td><td>뮤텍스 획득 순서를 문서화하고 일관되게 유지</td></tr><tr><td>리소스 관리</td><td>조건 변수와 뮤텍스의 적절한 초기화 및 해제</td><td>사용 후 <code>pthread_cond_destroy</code> 등을 통해 자원 해제</td></tr></tbody></table><hr><h2 id=-성능을-최적화하기-위한-고려사항>🚀 성능을 최적화하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#-성능을-최적화하기-위한-고려사항>#</a></h2><table><thead><tr><th>고려사항</th><th>설명</th><th>권장 사항</th></tr></thead><tbody><tr><td>대기 시간 최소화</td><td>불필요한 대기를 줄이기 위해 조건 변수 사용 시 조건을 명확히 설정</td><td>조건 검사를 정확하게 구현하여 불필요한 대기 방지</td></tr><tr><td>스레드 수 관리</td><td>과도한 스레드 생성으로 인한 컨텍스트 스위칭 비용 증가 방지</td><td>스레드 풀 등을 활용하여 스레드 수를 제한</td></tr><tr><td>자원 경쟁 최소화</td><td>공유 자원에 대한 경쟁을 줄이기 위해 뮤텍스 보유 시간 최소화</td><td>가능한 한 뮤텍스 보유 시간을 짧게 유지</td></tr></tbody></table><hr><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>조건 변수 (Condition Variable)</td><td>특정 조건이 충족될 때까지 스레드를 대기시키고, 조건이 만족되면 스레드를 깨우는 동기화 메커니즘</td></tr><tr><td>뮤텍스 (Mutex)</td><td>상호 배제를 통해 공유 자원에 대한 동시 접근을 제어하는 동기화 객체</td></tr><tr><td>스푸리어스 웨이크업 (Spurious Wakeup)</td><td>조건이 충족되지 않았음에도 스레드가 깨어나는 현상</td></tr><tr><td>데드락 (Deadlock)</td><td>두 개 이상의 스레드가 서로 자원을 기다리며 무한 대기 상태에 빠지는 현상</td></tr></tbody></table><hr><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><p><a href=https://www.geeksforgeeks.org/cpp-multithreading-condition-variables/>Condition Variables in C++ Multithreading - GeeksforGeeks</a></p></li><li><p><a href=https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf>Condition Variables - cs.wisc.edu</a></p></li><li><p><a href=https://learn.microsoft.com/en-us/windows/win32/sync/condition-variables>Condition Variables - Win32 apps | Microsoft Learn</a></p></li><li><p><a href=https://medium.com/@polyglot_factotum/rust-concurrency-patterns-condvars-and-locks-e278f18db74f>Rust concurrency patterns: condvars and locks | by Gregory Terzian</a></p></li></ul><hr><p>추가적으로, 조건 변수의 구조와 동작 원리를 시각적으로 이해하고자 하신다면 아래의 다이어그램을 참고하시기 바랍니다:</p><p><figure><img alt="조건 변수의 구조와 동작 원리 다이어그램" loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/8/8e/Monitor.svg></figure></p><p>위 다이어그램은 조건 변수와 뮤텍스의 상호 작용을 시각적으로 표현한 것으로, 스레드가 조건을 기다리고, 조건이 충족되었을 때 어떻게 깨어나는지를 보여줍니다.</p><p>더 자세한 내용이나 특정 구현에 대한 예시가 필요하시면 언제든지 말씀해 주세요.</p><h1 id=조건-변수-condition-variable-1>조건 변수 (Condition Variable)<a hidden class=anchor aria-hidden=true href=#조건-변수-condition-variable-1>#</a></h1><h2 id=1-주제의-분류-적절성-1>1. 주제의 분류 적절성<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적절성-1>#</a></h2><p>조사한 결과, &ldquo;Computer Science and Engineering&rdquo; > &ldquo;Computer Science Fundamentals&rdquo; > &ldquo;Operating System&rdquo; > &ldquo;Process Management&rdquo; > &ldquo;Synchronization&rdquo; > &ldquo;Condition Synchronization"이라는 분류는 적절합니다. 조건 변수는 운영체제의 프로세스 관리에서 동기화를 위한 핵심 메커니즘으로, 특히 조건 동기화(여러 스레드가 특정 조건이 충족될 때까지 대기하는 상황)를 구현하는 데 사용되는 개념입니다.</p><h2 id=2-요약-설명-200자-내외>2. 요약 설명 (200자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-설명-200자-내외>#</a></h2><p>조건 변수는 다중 스레드 환경에서 스레드 간 통신과 동기화를 위한 메커니즘으로, 특정 조건이 충족될 때까지 스레드를 대기시키고, 다른 스레드가 조건을 충족시키면 대기 중인 스레드에게 신호를 보내 실행을 재개하도록 하는 동기화 기본요소입니다. 뮤텍스와 함께 사용되어 생산자-소비자 문제 같은 동기화 패턴을 효율적으로 구현합니다.</p><h2 id=3-개요-250자-내외>3. 개요 (250자 내외)<a hidden class=anchor aria-hidden=true href=#3-개요-250자-내외>#</a></h2><p>조건 변수는 운영체제와 프로그래밍 언어에서 제공하는 동기화 기본요소로, 스레드가 특정 조건이 충족될 때까지 효율적으로 대기할 수 있게 합니다. 뮤텍스와 함께 사용되어 원자적으로 락을 해제하고 스레드를 휴면 상태로 전환시키며, 조건이 충족되면 신호를 받아 깨어나 락을 다시 획득합니다. 생산자-소비자, 리더-라이터 문제와 같은 동기화 패턴에 적용되며, 스레드 간 상태 변화를 효율적으로 전달하는 메커니즘을 제공합니다.</p><h2 id=4-핵심-개념-1>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념-1>#</a></h2><p>조건 변수(Condition Variable)는 다중 스레드 프로그래밍에서 스레드 간 동기화를 위한 핵심 메커니즘입니다. 다음은 조건 변수에 대해 반드시 알아야 할 핵심 개념들입니다:</p><ol><li><p><strong>정의</strong>: 조건 변수는 한 스레드가 특정 조건이 충족될 때까지 대기하고, 다른 스레드가 해당 조건을 충족시켰을 때 대기 중인 스레드에게 알림을 보내는 동기화 기본요소입니다.</p></li><li><p><strong>목적</strong>: 스레드 간 통신을 가능하게 하여 특정 이벤트나 조건이 발생했을 때 다른 스레드가 이에 반응할 수 있도록 합니다.</p></li><li><p><strong>작동 방식</strong>: 조건 변수는 항상 뮤텍스와 함께 사용되며, wait 연산은 뮤텍스를 해제하고 스레드를 대기 상태로 만들고, signal 연산은 대기 중인 스레드 중 하나를 깨우는 역할을 합니다.</p></li><li><p><strong>기본 연산</strong>:</p><ul><li><code>wait</code>: 조건이 충족될 때까지 스레드를 대기 상태로 만듭니다.</li><li><code>signal</code>/<code>notify_one</code>: 대기 중인 스레드 중 하나를 깨웁니다.</li><li><code>broadcast</code>/<code>notify_all</code>: 모든 대기 중인 스레드를 깨웁니다.</li></ul></li><li><p><strong>스퓨리어스 웨이크업(Spurious Wakeup)</strong>: 조건 변수는 실제 신호 없이도 대기 중인 스레드가 깨어날 수 있는 상황이 발생할 수 있으므로, 항상 while 루프 내에서 조건을 재확인해야 합니다.</p></li><li><p><strong>상태 보호</strong>: 조건 변수는 데이터 자체를 보호하지 않으므로, 공유 상태를 수정하거나 검사할 때는 반드시 연관된 뮤텍스로 보호해야 합니다.</p></li><li><p><strong>생산자-소비자 패턴</strong>: 조건 변수의 가장 일반적인 사용 사례로, 생산자 스레드가 데이터를 생성하고 소비자 스레드가 해당 데이터를 처리하는 패턴을 구현할 때 사용됩니다.</p></li><li><p><strong>구현 형태</strong>: 대부분의 현대 프로그래밍 언어(C++, Java, Python 등)와 운영체제(POSIX 스레드, Windows)에서 조건 변수를 지원합니다.</p></li></ol><p>이러한 핵심 개념들을 이해하면 조건 변수를 효과적으로 활용하여 안전하고 효율적인 다중 스레드 프로그램을 개발할 수 있습니다.</p><h2 id=5-주제와-관련하여-조사할-내용>5. 주제와 관련하여 조사할 내용<a hidden class=anchor aria-hidden=true href=#5-주제와-관련하여-조사할-내용>#</a></h2><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>조건 변수의 개념은 1970년대 운영체제와 병렬 프로그래밍 연구에서 발전했습니다. 모니터(Monitor)라는 동기화 추상화의 일부로 처음 소개되었으며, 이는 공유 자원에 대한 상호 배제 액세스를 제공하면서도 스레드가 특정 조건을 기다릴 수 있게 해주는 메커니즘이었습니다.</p><p>초기 운영체제에서는 스레드가 조건을 기다릴 때 지속적으로 상태를 확인하는 &lsquo;바쁜 대기(busy waiting)&rsquo; 방식을 사용했는데, 이는 CPU 자원을 낭비하는 비효율적인 방법이었습니다. 조건 변수는 이런 문제를 해결하기 위해 스레드를 휴면 상태로 전환하고, 조건이 충족되면 깨우는 방식을 도입함으로써 시스템 자원을 더 효율적으로 사용할 수 있게 했습니다.</p><p>오늘날 조건 변수는 POSIX 스레드, Windows API, 그리고 C++, Java 등의 프로그래밍 언어에서 표준 동기화 기본요소로 제공되고 있으며, 다중 스레드 프로그래밍에서 필수적인 도구로 자리 잡았습니다.</p><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p>조건 변수의 주요 목적과 필요성은 다음과 같습니다:</p><ol><li><p><strong>효율적인 스레드 대기</strong>: 스레드가 조건이 충족될 때까지 CPU를 소비하지 않고 대기할 수 있게 합니다.</p></li><li><p><strong>스레드 간 통신</strong>: 한 스레드에서 다른 스레드로 상태 변화나 이벤트 발생을 알릴 수 있는 메커니즘을 제공합니다.</p></li><li><p><strong>동기화 패턴 구현</strong>: 생산자-소비자, 리더-라이터와 같은 일반적인 동기화 패턴을 효율적으로 구현할 수 있게 합니다.</p></li><li><p><strong>자원 낭비 방지</strong>: 스레드가 조건을 계속 확인하는 바쁜 대기(busy waiting) 대신, 조건이 충족될 때만 깨어나도록 하여 시스템 자원을 절약합니다.</p></li><li><p><strong>복잡한 동기화 시나리오 처리</strong>: 단순한 뮤텍스만으로는 해결하기 어려운 복잡한 동기화 시나리오를 처리할 수 있게 합니다.</p></li><li><p><strong>경쟁 상태(Race Condition) 예방</strong>: 조건 확인과 대기를 원자적으로 수행함으로써 경쟁 상태를 방지합니다.</p></li></ol><h3 id=주요-기능-및-역할-1>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할-1>#</a></h3><p>조건 변수의 주요 기능과 역할은 다음과 같습니다:</p><ol><li><p><strong>스레드 대기(Wait)</strong>:</p><ul><li>스레드가 특정 조건이 충족될 때까지 대기할 수 있게 합니다.</li><li>뮤텍스를 원자적으로 해제하고 스레드를 휴면 상태로 전환합니다.</li><li>스레드가 깨어날 때 자동으로 뮤텍스를 다시 획득합니다.</li></ul></li><li><p><strong>신호 전송(Signal/Notify)</strong>:</p><ul><li>조건이 충족되었을 때 대기 중인 스레드 중 하나에게 알립니다.</li><li>일반적으로 <code>signal</code>, <code>notify_one</code> 등의 함수로 구현됩니다.</li></ul></li><li><p><strong>브로드캐스트(Broadcast/Notify All)</strong>:</p><ul><li>조건이 충족되었을 때 모든 대기 중인 스레드에게 알립니다.</li><li>일반적으로 <code>broadcast</code>, <code>notify_all</code> 등의 함수로 구현됩니다.</li></ul></li><li><p><strong>조건 검증</strong>:</p><ul><li>스레드가 깨어난 후 조건을 다시 확인하는 메커니즘을 제공합니다.</li><li>스퓨리어스 웨이크업(Spurious Wakeup)에 대비하여 조건을 while 루프 내에서 검사합니다.</li></ul></li><li><p><strong>뮤텍스 연동</strong>:</p><ul><li>조건 변수는 항상 뮤텍스와 함께 사용되어 공유 상태에 대한 원자적 접근을 보장합니다.</li></ul></li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p>조건 변수의 주요 특징은 다음과 같습니다:</p><ol><li><p><strong>뮤텍스 연계</strong>: 조건 변수는 항상 뮤텍스와 함께 사용되어야 합니다. 뮤텍스는 공유 상태를 보호하고, 조건 변수는 스레드 간 통신을 담당합니다.</p></li><li><p><strong>원자적 대기</strong>: 조건 변수의 wait 연산은 뮤텍스를 해제하고 스레드를 대기 상태로 만드는 작업을 원자적(atomic)으로 수행합니다.</p></li><li><p><strong>스퓨리어스 웨이크업(Spurious Wakeup)</strong>: 조건 변수는 실제 신호 없이도 스레드가 깨어날 수 있는 현상이 있어, 항상 while 루프 내에서 조건을 재확인해야 합니다.</p></li><li><p><strong>FIFO 보장 없음</strong>: 대부분의 조건 변수 구현은 어떤 스레드가 먼저 깨어날지 보장하지 않습니다. 선입선출(FIFO) 순서가 필요한 경우 추가적인 메커니즘을 구현해야 합니다.</p></li><li><p><strong>신호 손실</strong>: 스레드가 대기하기 전에 신호가 전송되면, 그 신호는 손실될 수 있습니다.</p></li><li><p><strong>시스템 자원 효율성</strong>: 바쁜 대기(busy waiting)와 달리, 조건 변수는 스레드를 휴면 상태로 전환하여 CPU 자원을 절약합니다.</p></li><li><p><strong>플랫폼 독립적</strong>: 대부분의 현대 운영체제와 프로그래밍 언어에서 지원되는 표준 동기화 기본요소입니다.</p></li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>조건 변수를 사용할 때 따라야 할 핵심 원칙은 다음과 같습니다:</p><ol><li><p><strong>항상 뮤텍스와 함께 사용</strong>: 조건 변수는 독립적으로 사용할 수 없으며, 반드시 뮤텍스와 함께 사용해야 합니다.</p></li><li><p><strong>조건 검사는 항상 while 루프 내에서</strong>: 스퓨리어스 웨이크업에 대비하여 조건을 항상 while 루프 내에서 검사해야 합니다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>condition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cv</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>상태 변경은 뮤텍스 보호 하에</strong>: 조건 변수와 관련된 상태를 변경할 때는 항상 연관된 뮤텍스로 보호해야 합니다.</p></li><li><p><strong>최소한의 작업만 뮤텍스 내에서</strong>: 뮤텍스가 잠겨 있는 동안에는 최소한의 작업만 수행하여 다른 스레드의 대기 시간을 줄입니다.</p></li><li><p><strong>신호 전송 전 상태 변경</strong>: 조건 변수에 신호를 보내기 전에 먼저 조건 상태를 변경해야 합니다.</p></li><li><p><strong>적절한 신호 선택</strong>: 한 스레드만 깨워야 할 경우 signal/notify_one을, 모든 스레드를 깨워야 할 경우 broadcast/notify_all을 사용합니다.</p></li><li><p><strong>락 해제 후 신호 전송</strong>: 성능을 위해 가능하면 뮤텍스를 해제한 후에 신호를 전송합니다.</p></li><li><p><strong>타임아웃 고려</strong>: 무한정 대기하지 않도록 필요한 경우 타임아웃을 설정합니다.</p></li></ol><h3 id=주요-원리-및-작동-원리-1>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리-1>#</a></h3><p>조건 변수의 주요 작동 원리는 다음과 같습니다:</p><ol><li><p><strong>대기(Wait) 연산</strong>:</p><ul><li>스레드가 특정 조건을 확인하고, 조건이 충족되지 않으면 조건 변수의 대기 큐에 진입합니다.</li><li>뮤텍스를 원자적으로 해제하고 스레드를 휴면 상태로 전환합니다.</li><li>스레드가 깨어나면 자동으로 뮤텍스를 다시 획득합니다.</li></ul></li><li><p><strong>신호(Signal) 연산</strong>:</p><ul><li>다른 스레드가 조건을 충족시키고 조건 변수에 신호를 보냅니다.</li><li>대기 큐에 있는 스레드 중 하나가 깨어나고, 뮤텍스를 획득한 후 실행을 계속합니다.</li></ul></li><li><p><strong>브로드캐스트(Broadcast) 연산</strong>:</p><ul><li>모든 대기 중인 스레드에게 신호를 보내 깨웁니다.</li><li>각 스레드는 순차적으로 뮤텍스를 획득하여 실행을 계속합니다.</li></ul></li></ol><p>다음은 조건 변수의 작동 원리를 보여주는 다이어그램입니다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23>23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24>24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=p>[</span><span class=err>스레드</span> <span class=n>A</span><span class=p>]</span>                        <span class=p>[</span><span class=err>스레드</span> <span class=n>B</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>뮤텍스</span> <span class=err>획득</span>                       <span class=o>|</span> 
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>조건</span> <span class=err>검사</span>                         <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=p>(</span><span class=err>조건</span> <span class=o>=</span> <span class=bp>false</span><span class=p>)</span>                   <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>조건</span> <span class=err>변수</span> <span class=err>대기</span> <span class=p>(</span><span class=n>wait</span><span class=p>)</span>              <span class=o>|</span> <span class=err>뮤텍스</span> <span class=err>획득</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=p>(</span><span class=err>뮤텍스</span> <span class=err>해제</span> <span class=o>+</span> <span class=err>스레드</span> <span class=err>휴면</span><span class=p>)</span>          <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span> <span class=err>상태</span> <span class=err>변경</span> <span class=p>(</span><span class=err>조건</span> <span class=o>=</span> <span class=bp>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span> <span class=err>조건</span> <span class=err>변수</span> <span class=err>신호</span> <span class=p>(</span><span class=k>signal</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span> <span class=err>뮤텍스</span> <span class=err>해제</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=p>(</span><span class=err>스레드</span> <span class=err>깨어남</span><span class=p>)</span>                    <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>뮤텍스</span> <span class=err>재획득</span>                      <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>조건</span> <span class=err>재검사</span>                        <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=p>(</span><span class=err>조건</span> <span class=o>=</span> <span class=bp>true</span><span class=p>)</span>                    <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>작업</span> <span class=err>수행</span>                         <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=err>뮤텍스</span> <span class=err>해제</span>                        <span class=o>|</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span>                                 <span class=o>|</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=구조-및-아키텍처-1>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처-1>#</a></h3><p>조건 변수의 구조 및 아키텍처는 다음과 같습니다:</p><h4 id=핵심-구성-요소>핵심 구성 요소<a hidden class=anchor aria-hidden=true href=#핵심-구성-요소>#</a></h4><ol><li><p><strong>대기 큐(Wait Queue)</strong>:</p><ul><li>조건이 충족될 때까지 대기 중인 스레드들을 관리하는 큐입니다.</li><li>운영체제 커널 수준에서 구현되는 경우가 많습니다.</li></ul></li><li><p><strong>연관 뮤텍스(Associated Mutex)</strong>:</p><ul><li>조건 변수와 함께 사용되는 뮤텍스로, 공유 상태에 대한 접근을 제어합니다.</li><li>조건 변수 자체는 상태를 보호하지 않으므로, 반드시 뮤텍스와 함께 사용해야 합니다.</li></ul></li><li><p><strong>신호 메커니즘(Signaling Mechanism)</strong>:</p><ul><li>대기 중인 스레드에게 조건이 충족되었음을 알리는 메커니즘입니다.</li><li>Signal(단일 스레드 깨우기)과 Broadcast(모든 스레드 깨우기) 연산을 지원합니다.</li></ul></li><li><p><strong>타임아웃 기능(Timeout Facility)</strong>:</p><ul><li>스레드가 특정 시간 동안만 대기하도록 하는 기능입니다.</li><li>무한정 대기하는 상황을 방지하기 위해 사용됩니다.</li></ul></li></ol><h4 id=구조-다이어그램-1>구조 다이어그램<a hidden class=anchor aria-hidden=true href=#구조-다이어그램-1>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span><span class=lnt id=hl-10-32><a class=lnlinks href=#hl-10-32>32</a>
</span><span class=lnt id=hl-10-33><a class=lnlinks href=#hl-10-33>33</a>
</span><span class=lnt id=hl-10-34><a class=lnlinks href=#hl-10-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=err>조건</span> <span class=err>변수</span> <span class=p>(</span><span class=n>Condition</span> <span class=n>Variable</span><span class=p>)</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span><span class=line><span class=cl><span class=o>|</span>                            <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-------------------------+|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>|</span> <span class=err>대기</span> <span class=err>큐</span> <span class=p>(</span><span class=n>Wait</span> <span class=n>Queue</span><span class=p>)</span>      <span class=o>||</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-------------------------+|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>                            <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-------------------------+|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>|</span> <span class=err>신호</span> <span class=err>메커니즘</span>             <span class=o>||</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>|</span> <span class=o>-</span> <span class=k>signal</span><span class=o>/</span><span class=n>notify_one</span>     <span class=o>||</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>|</span> <span class=o>-</span> <span class=n>broadcast</span><span class=o>/</span><span class=n>notify_all</span>  <span class=o>||</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-------------------------+|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>                            <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-------------------------+|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>|</span> <span class=err>타임아웃</span> <span class=err>기능</span>             <span class=o>||</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>+-------------------------+|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>                            <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>+-----------|----------------+</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=err>연계</span>
</span></span><span class=line><span class=cl>            <span class=n>v</span>
</span></span><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=err>뮤텍스</span> <span class=p>(</span><span class=ne>Mutex</span><span class=p>)</span>              <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>-</span> <span class=err>락</span> <span class=err>상태</span>                   <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=o>-</span> <span class=err>대기</span> <span class=err>큐</span>                   <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=err>보호</span>
</span></span><span class=line><span class=cl>            <span class=n>v</span>
</span></span><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=err>공유</span> <span class=err>상태</span> <span class=p>(</span><span class=n>Shared</span> <span class=n>State</span><span class=p>)</span>    <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>+----------------------------+</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=필수-구성요소-1>필수 구성요소<a hidden class=anchor aria-hidden=true href=#필수-구성요소-1>#</a></h4><ul><li><strong>조건 변수 객체</strong>: 스레드 대기 및 신호 전송 기능을 제공하는 객체입니다.</li><li><strong>연관 뮤텍스</strong>: 공유 상태에 대한 상호 배제 접근을 제공합니다.</li><li><strong>조건 상태</strong>: 스레드가 대기하거나 진행할 조건을 결정하는 공유 변수입니다.</li></ul><h4 id=선택-구성요소-1>선택 구성요소<a hidden class=anchor aria-hidden=true href=#선택-구성요소-1>#</a></h4><ul><li><strong>타임아웃 매개변수</strong>: 스레드가 특정 시간 동안만 대기하도록 합니다.</li><li><strong>사용자 정의 조건 함수</strong>: 조건을 평가하는 함수를 전달하여 자동으로 조건을 검사하도록 합니다.</li><li><strong>속성 설정</strong>: 일부 구현에서는 조건 변수의 동작을 세부적으로 제어하는 속성을 설정할 수 있습니다.</li></ul><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><p>조건 변수는 다양한 프로그래밍 언어와 플랫폼에서 여러 가지 방식으로 구현됩니다. 다음은 주요 구현 기법들입니다:</p><h4 id=1-posix-스레드-pthread-구현>1. POSIX 스레드 (pthread) 구현<a hidden class=anchor aria-hidden=true href=#1-posix-스레드-pthread-구현>#</a></h4><p><strong>정의</strong>: POSIX 스레드 라이브러리에서 제공하는 조건 변수 구현입니다.</p><p><strong>구성</strong>:</p><ul><li><code>pthread_cond_t</code>: 조건 변수 타입</li><li><code>pthread_cond_init()</code>: 조건 변수 초기화</li><li><code>pthread_cond_wait()</code>: 조건 변수 대기</li><li><code>pthread_cond_signal()</code>: 단일 스레드 신호</li><li><code>pthread_cond_broadcast()</code>: 모든 스레드 신호</li><li><code>pthread_cond_destroy()</code>: 조건 변수 해제</li></ul><p><strong>목적</strong>: 유닉스 계열 시스템에서 표준화된 스레드 동기화 방법을 제공합니다.</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20>20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>pthread_cond_t</span> <span class=n>cond</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>done</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>pthread_cond_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 스레드 1 (대기)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>done</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 조건 충족, 계속 실행
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 스레드 2 (신호)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>done</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=2-c-표준-라이브러리-구현>2. C++ 표준 라이브러리 구현<a hidden class=anchor aria-hidden=true href=#2-c-표준-라이브러리-구현>#</a></h4><p><strong>정의</strong>: C++11 이후의 표준 라이브러리에서 제공하는 조건 변수 구현입니다.</p><p><strong>구성</strong>:</p><ul><li><code>std::condition_variable</code>: 조건 변수 클래스</li><li><code>wait()</code>: 조건 변수 대기</li><li><code>wait_for()</code>: 타임아웃 있는 대기</li><li><code>wait_until()</code>: 특정 시간까지 대기</li><li><code>notify_one()</code>: 단일 스레드 신호</li><li><code>notify_all()</code>: 모든 스레드 신호</li></ul><p><strong>목적</strong>: C++ 프로그램에서 플랫폼 독립적인 스레드 동기화 방법을 제공합니다.</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>mtx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>cv</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>ready</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 스레드 1 (대기)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mtx</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>]{</span> <span class=k>return</span> <span class=n>ready</span><span class=p>;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// 조건 충족, 계속 실행
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 스레드 2 (신호)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>mtx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ready</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>cv</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=3-java-구현>3. Java 구현<a hidden class=anchor aria-hidden=true href=#3-java-구현>#</a></h4><p><strong>정의</strong>: Java의 동기화 메커니즘으로 제공되는 조건 변수 구현입니다.</p><p><strong>구성</strong>:</p><ul><li><code>Object.wait()</code>: 객체의 모니터에서 대기</li><li><code>Object.notify()</code>: 단일 스레드 신호</li><li><code>Object.notifyAll()</code>: 모든 스레드 신호</li><li><code>java.util.concurrent.locks.Condition</code>: 명시적 조건 객체</li></ul><p><strong>목적</strong>: Java 언어에서 모니터 패턴과 함께 스레드 동기화를 제공합니다.</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span><span class=lnt id=hl-13-25><a class=lnlinks href=#hl-13-25>25</a>
</span><span class=lnt id=hl-13-26><a class=lnlinks href=#hl-13-26>26</a>
</span><span class=lnt id=hl-13-27><a class=lnlinks href=#hl-13-27>27</a>
</span><span class=lnt id=hl-13-28><a class=lnlinks href=#hl-13-28>28</a>
</span><span class=lnt id=hl-13-29><a class=lnlinks href=#hl-13-29>29</a>
</span><span class=lnt id=hl-13-30><a class=lnlinks href=#hl-13-30>30</a>
</span><span class=lnt id=hl-13-31><a class=lnlinks href=#hl-13-31>31</a>
</span><span class=lnt id=hl-13-32><a class=lnlinks href=#hl-13-32>32</a>
</span><span class=lnt id=hl-13-33><a class=lnlinks href=#hl-13-33>33</a>
</span><span class=lnt id=hl-13-34><a class=lnlinks href=#hl-13-34>34</a>
</span><span class=lnt id=hl-13-35><a class=lnlinks href=#hl-13-35>35</a>
</span><span class=lnt id=hl-13-36><a class=lnlinks href=#hl-13-36>36</a>
</span><span class=lnt id=hl-13-37><a class=lnlinks href=#hl-13-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Object의 내장 동기화 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>sharedObject</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>condition</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sharedObject</span><span class=p>.</span><span class=na>wait</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 조건 충족, 계속 실행</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 신호 전송</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>synchronized</span><span class=w> </span><span class=p>(</span><span class=n>sharedObject</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>condition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sharedObject</span><span class=p>.</span><span class=na>notifyAll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 명시적 Condition 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Lock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Condition</span><span class=w> </span><span class=n>condition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 대기</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>ready</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>condition</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 조건 충족, 계속 실행</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 신호 전송</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ready</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>condition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=4-모니터-기반-구현>4. 모니터 기반 구현<a hidden class=anchor aria-hidden=true href=#4-모니터-기반-구현>#</a></h4><p><strong>정의</strong>: 모니터라는 고수준 동기화 추상화의 일부로 구현되는 조건 변수입니다.</p><p><strong>구성</strong>:</p><ul><li>모니터 객체: 공유 데이터와 동기화 메커니즘을 캡슐화</li><li>내부 조건 변수: 모니터 내부의 대기 조건</li><li>진입/퇴출 메커니즘: 모니터 진입 및 퇴출 시 동기화 처리</li></ul><p><strong>목적</strong>: 공유 자원 접근을 간소화하고 동기화 오류를 줄입니다.</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=o>//</span> <span class=err>의사</span> <span class=err>코드로</span> <span class=err>표현한</span> <span class=err>모니터</span>
</span></span><span class=line><span class=cl><span class=n>monitor</span> <span class=n>ProducerConsumer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=ne>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>condition</span> <span class=n>notFull</span><span class=p>,</span> <span class=n>notEmpty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>procedure</span> <span class=n>add</span><span class=p>(</span><span class=n>item</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=n>BUFFER_SIZE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>wait</span><span class=p>(</span><span class=n>notFull</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>buffer</span><span class=p>[</span><span class=n>count</span><span class=p>]</span> <span class=o>=</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>signal</span><span class=p>(</span><span class=n>notEmpty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>procedure</span> <span class=n>remove</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>wait</span><span class=p>(</span><span class=n>notEmpty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>item</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=o>--</span><span class=n>count</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>signal</span><span class=p>(</span><span class=n>notFull</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>item</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=5-원자적-변수-기반-구현>5. 원자적 변수 기반 구현<a hidden class=anchor aria-hidden=true href=#5-원자적-변수-기반-구현>#</a></h4><p><strong>정의</strong>: 최신 C++20에서는 원자적 변수와 대기/알림 메커니즘을 결합한 방식이 도입되었습니다.</p><p><strong>구성</strong>:</p><ul><li><code>std::atomic&lt;T></code>: 원자적 변수</li><li><code>wait()</code>: 특정 값이 될 때까지 대기</li><li><code>notify_one()</code>: 단일 스레드 신호</li><li><code>notify_all()</code>: 모든 스레드 신호</li></ul><p><strong>목적</strong>: 뮤텍스 없이 더 효율적인 동기화를 가능하게 합니다.</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7>7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8>8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>ready</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 스레드 1 (대기)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ready</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span> <span class=c1>// ready가 false인 동안 대기
</span></span></span><span class=line><span class=cl><span class=c1>// ready가 true가 되면 계속 실행
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 스레드 2 (신호)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ready</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>ready</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th></th></tr></thead><tbody><tr><td>✅ 장점</td><td>자원 효율성</td><td>스레드를 휴면 상태로 전환하여 CPU 자원을 절약하고 바쁜 대기(busy waiting)를 방지합니다</td><td></td></tr><tr><td></td><td>스레드 간 통신</td><td>스레드 간 효율적인 신호 전달 메커니즘을 제공하여 복잡한 동기화 패턴을 구현할 수 있습니다</td><td></td></tr><tr><td></td><td>플랫폼 독립성</td><td>대부분의 운영체제와 프로그래밍 언어에서 표준 동기화 기본요소로 제공됩니다</td><td></td></tr><tr><td></td><td>원자적 연산</td><td>뮤텍스 해제와 스레드 대기를 원자적으로 수행하여 경쟁 상태를 방지합니다</td><td></td></tr><tr><td></td><td>유연한 신호 전송</td><td>단일 스레드(signal) 또는 모든 스레드(broadcast)에게 선택적으로 신호를 전송할 수 있습니다</td><td></td></tr><tr><td>⚠ 단점</td><td>복잡성</td><td>올바른 사용을 위해 뮤텍스와의 올바른 조합, while 루프 사용 등 복잡한 규칙을 따라야 합니다</td><td></td></tr><tr><td></td><td>스퓨리어스 웨이크업</td><td>실제 신호 없이도 스레드가 깨어날 수 있어 항상 조건을 재확인해야 합니다</td><td></td></tr><tr><td></td><td>신호 손실</td><td>스레드가 대기하기 전에 전송된 신호는 손실될 수 있습니다</td><td></td></tr><tr><td></td><td>성능 오버헤드</td><td>시스템 호출과 컨텍스트 스위칭으로 인한 성능 오버헤드가 발생할 수 있습니다</td><td></td></tr><tr><td></td><td>우선순위 역전</td><td>낮은 우선순위 스레드가 높은 우선순위 스레드를 차단할 수 있는 문제가 발생할 수 있습니다</td><td></td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><h4 id=1-스퓨리어스-웨이크업-spurious-wakeup>1. 스퓨리어스 웨이크업 (Spurious Wakeup)<a hidden class=anchor aria-hidden=true href=#1-스퓨리어스-웨이크업-spurious-wakeup>#</a></h4><p><strong>설명</strong>: 실제 신호 없이도 대기 중인 스레드가 깨어나는 현상 <strong>해결책</strong>: 조건을 항상 while 루프 내에서 재확인하고, 조건 기반 wait 함수 사용</p><h4 id=2-신호-손실-lost-signal>2. 신호 손실 (Lost Signal)<a hidden class=anchor aria-hidden=true href=#2-신호-손실-lost-signal>#</a></h4><p><strong>설명</strong>: 스레드가 대기 상태에 진입하기 전에 전송된 신호가 손실되는 문제 <strong>해결책</strong>: 상태 변수와 조건 변수를 함께 사용하고, 적절한 뮤텍스 보호 적용</p><h4 id=3-경쟁-상태-race-condition>3. 경쟁 상태 (Race Condition)<a hidden class=anchor aria-hidden=true href=#3-경쟁-상태-race-condition>#</a></h4><p><strong>설명</strong>: 조건 검사와 대기 사이에 다른 스레드가 개입하여 발생하는 문제 <strong>해결책</strong>: 조건 변수의 원자적 wait 연산 사용과 적절한 뮤텍스 사용</p><h4 id=4-우선순위-역전-priority-inversion>4. 우선순위 역전 (Priority Inversion)<a hidden class=anchor aria-hidden=true href=#4-우선순위-역전-priority-inversion>#</a></h4><p><strong>설명</strong>: 낮은 우선순위 스레드가 뮤텍스를 점유하여 높은 우선순위 스레드를 차단하는 문제 <strong>해결책</strong>: 우선순위 상속(Priority Inheritance) 프로토콜 적용</p><h4 id=5-기아-상태-starvation>5. 기아 상태 (Starvation)<a hidden class=anchor aria-hidden=true href=#5-기아-상태-starvation>#</a></h4><p><strong>설명</strong>: 특정 스레드가 계속해서 신호를 받지 못해 실행되지 못하는 상황 <strong>해결책</strong>: 공정한 스케줄링 정책과 FIFO 큐 기반 조건 변수 사용</p><h4 id=6-데드락-deadlock>6. 데드락 (Deadlock)<a hidden class=anchor aria-hidden=true href=#6-데드락-deadlock>#</a></h4><p><strong>설명</strong>: 여러 스레드가 서로의 자원을 기다리며 무한정 대기하는 상황 <strong>해결책</strong>: 일관된 락 순서 유지, 타임아웃 설정, 데드락 감지 알고리즘 적용</p><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>종류</th><th>설명</th></tr></thead><tbody><tr><td><strong>신호 방식</strong></td><td>Signal/Notify One</td><td>대기 중인 스레드 중 하나만 깨우는 방식</td></tr><tr><td></td><td>Broadcast/Notify All</td><td>모든 대기 중인 스레드를 깨우는 방식</td></tr><tr><td><strong>대기 방식</strong></td><td>조건부 대기</td><td>특정 조건을 만족할 때까지 대기하는 방식</td></tr><tr><td></td><td>타임아웃 대기</td><td>지정된 시간 동안만 대기하는 방식</td></tr><tr><td></td><td>절대 시간 대기</td><td>특정 시점까지만 대기하는 방식</td></tr><tr><td><strong>구현 방식</strong></td><td>Mesa 스타일</td><td>신호를 받은 스레드가 즉시 실행되지 않고 뮤텍스를 기다리는 방식</td></tr><tr><td></td><td>Hoare 스타일</td><td>신호를 받은 스레드가 즉시 실행되는 방식</td></tr><tr><td><strong>플랫폼별</strong></td><td>POSIX pthread</td><td>POSIX 표준을 따르는 Unix/Linux 계열 구현</td></tr><tr><td></td><td>Windows API</td><td>Windows 운영체제의 네이티브 조건 변수</td></tr><tr><td></td><td>C++ Standard</td><td>C++11 이후 표준 라이브러리 구현</td></tr><tr><td></td><td>Java Built-in</td><td>Java의 내장 동기화 메커니즘</td></tr><tr><td><strong>사용 범위</strong></td><td>프로세스 내부</td><td>단일 프로세스 내 스레드 간 동기화</td></tr><tr><td></td><td>프로세스 간</td><td>여러 프로세스 간 동기화 (제한적)</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>적용 분야</th><th>사용 사례</th><th>구현 방법</th><th>예시</th></tr></thead><tbody><tr><td><strong>웹 서버</strong></td><td>요청 처리 스레드 풀</td><td>작업 큐가 비어있을 때 워커 스레드가 대기하고, 새 요청이 오면 깨어남</td><td>Apache HTTP Server, Nginx</td></tr><tr><td><strong>데이터베이스</strong></td><td>트랜잭션 처리</td><td>락 대기, 버퍼 풀 관리, 체크포인트 동기화</td><td>MySQL InnoDB, PostgreSQL</td></tr><tr><td><strong>운영체제</strong></td><td>I/O 완료 대기</td><td>디스크 I/O, 네트워크 I/O 완료 시까지 프로세스/스레드 대기</td><td>Linux epoll, Windows IOCP</td></tr><tr><td><strong>게임 엔진</strong></td><td>렌더링 파이프라인</td><td>프레임 동기화, 리소스 로딩 완료 대기</td><td>Unity, Unreal Engine</td></tr><tr><td><strong>메시징 시스템</strong></td><td>큐 기반 통신</td><td>메시지 도착 대기, 버퍼 공간 확보 대기</td><td>Apache Kafka, RabbitMQ</td></tr><tr><td><strong>멀티미디어</strong></td><td>스트리밍 처리</td><td>버퍼링 완료 대기, 프레임 동기화</td><td>VLC, FFmpeg</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><p>다음은 전자상거래 시스템에서 주문 처리 시나리오를 가정한 조건 변수 활용 사례입니다:</p><h4 id=시나리오-전자상거래-주문-처리-시스템>시나리오: 전자상거래 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#시나리오-전자상거래-주문-처리-시스템>#</a></h4><p><strong>상황</strong>: 온라인 쇼핑몰에서 주문이 들어오면 여러 단계를 거쳐 처리해야 합니다. 재고 확인, 결제 처리, 배송 준비 등의 단계가 있으며, 각 단계는 별도의 스레드에서 처리됩니다.</p><h4 id=시스템-구성>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[주문 접수] → [재고 확인] → [결제 처리] → [배송 준비] → [완료]
</span></span><span class=line><span class=cl>    ↓           ↓           ↓           ↓
</span></span><span class=line><span class=cl> 접수 스레드   재고 스레드   결제 스레드   배송 스레드
</span></span></code></pre></td></tr></table></div></div><h4 id=시스템-구성-다이어그램>시스템 구성 다이어그램<a hidden class=anchor aria-hidden=true href=#시스템-구성-다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
</span></span><span class=line><span class=cl>│   주문 큐        │    │   결제 큐        │    │   배송 큐        │
</span></span><span class=line><span class=cl>│  (Order Queue)  │    │ (Payment Queue) │    │(Shipping Queue) │
</span></span><span class=line><span class=cl>└─────────────────┘    └─────────────────┘    └─────────────────┘
</span></span><span class=line><span class=cl>         │                       │                       │
</span></span><span class=line><span class=cl>         ▼                       ▼                       ▼
</span></span><span class=line><span class=cl>┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
</span></span><span class=line><span class=cl>│  재고 처리 스레드  │    │  결제 처리 스레드  │    │  배송 처리 스레드  │
</span></span><span class=line><span class=cl>│(Inventory Thread)│    │(Payment Thread) │    │(Shipping Thread)│
</span></span><span class=line><span class=cl>└─────────────────┘    └─────────────────┘    └─────────────────┘
</span></span><span class=line><span class=cl>         │                       │                       │
</span></span><span class=line><span class=cl>         ▼                       ▼                       ▼
</span></span><span class=line><span class=cl>    조건 변수로          조건 변수로          조건 변수로
</span></span><span class=line><span class=cl>    큐 상태 감시         큐 상태 감시         큐 상태 감시
</span></span></code></pre></td></tr></table></div></div><h4 id=활용-사례-workflow>활용 사례 Workflow<a hidden class=anchor aria-hidden=true href=#활용-사례-workflow>#</a></h4><ol><li><p><strong>주문 접수</strong>: 고객이 주문을 하면 주문 큐에 추가되고, 재고 처리 스레드에게 신호를 보냅니다.</p></li><li><p><strong>재고 확인</strong>: 재고 처리 스레드가 깨어나 재고를 확인하고, 가능하면 결제 큐로 이동시킵니다.</p></li><li><p><strong>결제 처리</strong>: 결제 처리 스레드가 결제를 완료하고 배송 큐로 이동시킵니다.</p></li><li><p><strong>배송 준비</strong>: 배송 처리 스레드가 배송을 준비하고 주문을 완료 처리합니다.</p></li></ol><h4 id=코드-예시-c>코드 예시 (C++)<a hidden class=anchor aria-hidden=true href=#코드-예시-c>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34>34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35>35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36>36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37>37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38>38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39>39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40>40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41>41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42>42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43>43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44>44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45>45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46>46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47>47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48>48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49>49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50>50</a>
</span><span class=lnt id=hl-18-51><a class=lnlinks href=#hl-18-51>51</a>
</span><span class=lnt id=hl-18-52><a class=lnlinks href=#hl-18-52>52</a>
</span><span class=lnt id=hl-18-53><a class=lnlinks href=#hl-18-53>53</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;mutex&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;condition_variable&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OrderProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>Order</span><span class=o>&gt;</span> <span class=n>orderQueue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>Order</span><span class=o>&gt;</span> <span class=n>paymentQueue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>Order</span><span class=o>&gt;</span> <span class=n>shippingQueue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>orderMutex</span><span class=p>,</span> <span class=n>paymentMutex</span><span class=p>,</span> <span class=n>shippingMutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>condition_variable</span> <span class=n>orderCV</span><span class=p>,</span> <span class=n>paymentCV</span><span class=p>,</span> <span class=n>shippingCV</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 재고 처리 스레드
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=n>inventoryProcessor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>orderMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>orderCV</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=p>[</span><span class=k>this</span><span class=p>]</span> <span class=p>{</span> <span class=k>return</span> <span class=o>!</span><span class=n>orderQueue</span><span class=p>.</span><span class=n>empty</span><span class=p>();</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>Order</span> <span class=n>order</span> <span class=o>=</span> <span class=n>orderQueue</span><span class=p>.</span><span class=n>front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>orderQueue</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// 재고 확인 로직
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>checkInventory</span><span class=p>(</span><span class=n>order</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>paymentLock</span><span class=p>(</span><span class=n>paymentMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>paymentQueue</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>order</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>paymentCV</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 결제 처리 스레드
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>paymentProcessor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>unique_lock</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lock</span><span class=p>(</span><span class=n>paymentMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>paymentCV</span><span class=p>.</span><span class=n>wait</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=p>[</span><span class=k>this</span><span class=p>]</span> <span class=p>{</span> <span class=k>return</span> <span class=o>!</span><span class=n>paymentQueue</span><span class=p>.</span><span class=n>empty</span><span class=p>();</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>Order</span> <span class=n>order</span> <span class=o>=</span> <span class=n>paymentQueue</span><span class=p>.</span><span class=n>front</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>paymentQueue</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>lock</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1>// 결제 처리 로직
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>processPayment</span><span class=p>(</span><span class=n>order</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>shippingLock</span><span class=p>(</span><span class=n>shippingMutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>shippingQueue</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>order</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>shippingCV</span><span class=p>.</span><span class=n>notify_one</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=조건-변수의-역할>조건 변수의 역할<a hidden class=anchor aria-hidden=true href=#조건-변수의-역할>#</a></h4><ol><li><strong>스레드 동기화</strong>: 각 처리 단계 간 순서를 보장하고 데이터 일관성을 유지합니다.</li><li><strong>자원 효율성</strong>: 처리할 작업이 없을 때 스레드를 휴면 상태로 전환하여 CPU 자원을 절약합니다.</li><li><strong>실시간 처리</strong>: 새로운 작업이 도착하면 즉시 해당 스레드를 깨워 빠른 응답 시간을 보장합니다.</li><li><strong>확장성</strong>: 각 단계별로 독립적인 스레드 풀을 운영하여 시스템 확장성을 제공합니다.</li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계</strong></td><td>조건 정의 명확성</td><td>조건 변수가 대기하는 조건을 명확하게 정의해야 함</td><td>조건을 간단하고 명확한 불린 식으로 표현하고 문서화</td></tr><tr><td><strong>구현</strong></td><td>While 루프 사용</td><td>스퓨리어스 웨이크업에 대비하여 항상 while 루프 사용</td><td><code>while(!condition) cv.wait(lock);</code> 패턴 준수</td></tr><tr><td><strong>동기화</strong></td><td>뮤텍스 연계</td><td>조건 변수는 반드시 뮤텍스와 함께 사용</td><td>하나의 조건 변수당 하나의 전용 뮤텍스 할당</td></tr><tr><td><strong>신호 전송</strong></td><td>적절한 신호 선택</td><td>signal vs broadcast 선택 시 성능과 정확성 고려</td><td>하나의 스레드만 처리 가능하면 signal, 여러 스레드가 처리 가능하면 broadcast</td></tr><tr><td><strong>타이밍</strong></td><td>신호 전송 시점</td><td>조건 변경 후 즉시 신호 전송</td><td>상태 변경과 신호 전송을 원자적으로 처리</td></tr><tr><td><strong>예외 처리</strong></td><td>타임아웃 설정</td><td>무한 대기 방지를 위한 타임아웃 적용</td><td>중요한 시스템에서는 wait_for() 또는 wait_until() 사용</td></tr><tr><td><strong>테스팅</strong></td><td>동시성 테스트</td><td>경쟁 상태와 데드락 시나리오 테스트</td><td>스트레스 테스트와 다양한 스레드 수로 테스트 수행</td></tr><tr><td><strong>디버깅</strong></td><td>로깅 및 모니터링</td><td>조건 변수 상태와 스레드 동작 추적</td><td>각 wait/signal 호출 시점과 조건 상태를 로깅</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점-1>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점-1>#</a></h3><table><thead><tr><th>구분</th><th>최적화 기법</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>락 관리</strong></td><td>조기 락 해제</td><td>뮤텍스를 가능한 한 빨리 해제하여 다른 스레드의 대기 시간 단축</td><td>신호 전송 전에 뮤텍스를 해제하는 패턴 적용</td></tr><tr><td><strong>메모리</strong></td><td>캐시 지역성</td><td>관련 데이터를 메모리상 가까운 위치에 배치</td><td>조건 변수, 뮤텍스, 관련 데이터를 구조체로 그룹화</td></tr><tr><td><strong>스레드 수</strong></td><td>적정 스레드 수</td><td>CPU 코어 수와 작업 특성을 고려한 스레드 수 설정</td><td>CPU 집약적 작업은 코어 수만큼, I/O 집약적 작업은 더 많은 스레드 허용</td></tr><tr><td><strong>대기 전략</strong></td><td>스핀락 조합</td><td>짧은 대기 시간이 예상되는 경우 스핀락과 조건 변수 조합</td><td>먼저 짧은 시간 스핀 후 조건 변수로 전환하는 하이브리드 방식</td></tr><tr><td><strong>배치 처리</strong></td><td>일괄 신호 전송</td><td>여러 작업을 배치로 처리하여 신호 전송 횟수 감소</td><td>일정 개수 또는 시간마다 배치로 처리하는 전략 적용</td></tr><tr><td><strong>우선순위</strong></td><td>스레드 우선순위</td><td>중요한 작업을 처리하는 스레드의 우선순위 조정</td><td>실시간 성능이 중요한 스레드는 높은 우선순위 설정</td></tr><tr><td><strong>대안 기술</strong></td><td>락프리 구조</td><td>성능이 중요한 경우 락프리 데이터 구조 고려</td><td>단순한 경우 원자적 변수나 락프리 큐 사용 검토</td></tr><tr><td><strong>프로파일링</strong></td><td>성능 측정</td><td>병목 지점 식별을 위한 지속적인 성능 모니터링</td><td>컨텍스트 스위칭 횟수, 대기 시간, 처리량 등을 측정</td></tr></tbody></table><h2 id=6-주제에-대한-추가-조사-내용>6. 주제에 대한 추가 조사 내용<a hidden class=anchor aria-hidden=true href=#6-주제에-대한-추가-조사-내용>#</a></h2><p>(현재 추가 조사 내용이 지정되지 않음)</p><h2 id=7-추가로-알아야-하는-내용>7. 추가로 알아야 하는 내용<a hidden class=anchor aria-hidden=true href=#7-추가로-알아야-하는-내용>#</a></h2><h3 id=모니터-monitor-패턴>모니터 (Monitor) 패턴<a hidden class=anchor aria-hidden=true href=#모니터-monitor-패턴>#</a></h3><p>모니터는 조건 변수와 뮤텍스를 조합한 고수준 동기화 추상화입니다. 객체 지향 프로그래밍에서 공유 자원에 대한 안전한 접근을 제공하며, Java의 synchronized 메서드가 대표적인 예입니다. 모니터는 조건 변수를 내부적으로 캡슐화하여 사용자가 복잡한 동기화 로직을 직접 구현할 필요를 줄여줍니다.</p><h3 id=세마포어와의-차이점>세마포어와의 차이점<a hidden class=anchor aria-hidden=true href=#세마포어와의-차이점>#</a></h3><p>세마포어는 카운터 기반 동기화 기본요소로, 조건 변수와는 다른 용도로 사용됩니다. 세마포어는 자원의 개수를 관리하는 데 적합하며, 조건 변수는 특정 조건의 성립을 기다리는 데 적합합니다. 조건 변수는 상태 정보를 저장하지 않으므로 신호가 손실될 수 있지만, 세마포어는 카운터 값을 유지하므로 신호가 축적됩니다.</p><h3 id=리더-라이터-락-reader-writer-lock>리더-라이터 락 (Reader-Writer Lock)<a hidden class=anchor aria-hidden=true href=#리더-라이터-락-reader-writer-lock>#</a></h3><p>리더-라이터 락은 조건 변수를 활용하여 구현할 수 있는 고급 동기화 메커니즘으로, 읽기 작업과 쓰기 작업을 구분하여 처리합니다. 여러 리더가 동시에 접근할 수 있지만, 라이터는 독점적으로 접근해야 하는 상황에서 사용됩니다. 조건 변수를 사용하여 리더와 라이터 간의 복잡한 동기화 로직을 구현할 수 있습니다.</p><h3 id=생산자-소비자-변형-패턴>생산자-소비자 변형 패턴<a hidden class=anchor aria-hidden=true href=#생산자-소비자-변형-패턴>#</a></h3><p>기본적인 생산자-소비자 패턴 외에도 여러 생산자와 여러 소비자, 우선순위 기반 큐, 버퍼 크기 제한 등의 변형 패턴들이 있습니다. 각각은 서로 다른 조건 변수 사용 패턴을 요구하며, 실제 시스템에서는 이러한 변형 패턴들이 자주 사용됩니다.</p><h2 id=8-2025년-기준-최신-동향>8. 2025년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#8-2025년-기준-최신-동향>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>C++20/C++23</strong></td><td>원자적 대기/알림</td><td>std::atomic에 wait/notify 기능 추가로 뮤텍스 없는 동기화 가능</td></tr><tr><td><strong>성능 최적화</strong></td><td>하이브리드 동기화</td><td>스핀락과 조건 변수를 조합한 적응형 동기화 기법 발전</td></tr><tr><td><strong>락프리 프로그래밍</strong></td><td>대안 기술</td><td>고성능 시스템에서 조건 변수 대신 락프리 데이터 구조 활용 증가</td></tr><tr><td><strong>멀티코어 최적화</strong></td><td>NUMA 인식 동기화</td><td>멀티소켓 시스템에서 메모리 지역성을 고려한 조건 변수 구현</td></tr><tr><td><strong>실시간 시스템</strong></td><td>우선순위 기반</td><td>실시간 OS에서 우선순위 상속을 지원하는 조건 변수 구현 개선</td></tr><tr><td><strong>클라우드 네이티브</strong></td><td>분산 동기화</td><td>마이크로서비스 환경에서 분산 조건 변수 패턴 연구 활발</td></tr><tr><td><strong>AI/ML 워크로드</strong></td><td>배치 처리 최적화</td><td>GPU 컴퓨팅과 연계된 효율적인 스레드 동기화 패턴 개발</td></tr></tbody></table><h2 id=9-주제와-관련하여-주목할-내용>9. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#9-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>비동기 프로그래밍</strong></td><td>Coroutine 통합</td><td>C++20 coroutines와 조건 변수의 통합 패턴 연구</td></tr><tr><td><strong>함수형 프로그래밍</strong></td><td>액터 모델</td><td>Erlang/Elixir의 액터 모델이 조건 변수 패턴에 미치는 영향</td></tr><tr><td><strong>WebAssembly</strong></td><td>브라우저 동기화</td><td>WebAssembly에서 SharedArrayBuffer를 이용한 조건 변수 구현</td></tr><tr><td><strong>양자 컴퓨팅</strong></td><td>양자 동기화</td><td>양자 컴퓨팅 환경에서의 새로운 동기화 패러다임 연구</td></tr><tr><td><strong>블록체인</strong></td><td>분산 합의</td><td>블록체인 합의 알고리즘에서 조건 변수와 유사한 패턴 활용</td></tr><tr><td><strong>IoT/임베디드</strong></td><td>저전력 동기화</td><td>배터리 기반 IoT 디바이스를 위한 저전력 조건 변수 구현</td></tr><tr><td><strong>보안</strong></td><td>타이밍 공격 방지</td><td>사이드 채널 공격을 방지하는 보안 강화 조건 변수 설계</td></tr></tbody></table><h2 id=10-앞으로의-전망>10. 앞으로의 전망<a hidden class=anchor aria-hidden=true href=#10-앞으로의-전망>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>하드웨어 발전</strong></td><td>전용 동기화 명령어</td><td>CPU에서 조건 변수를 하드웨어 수준에서 지원하는 명령어 추가</td></tr><tr><td><strong>AI 기반 최적화</strong></td><td>적응형 동기화</td><td>머신러닝을 활용한 동적 스레드 스케줄링과 조건 변수 최적화</td></tr><tr><td><strong>표준화</strong></td><td>크로스 플랫폼 API</td><td>다양한 플랫폼 간 통일된 조건 변수 API 표준화 진행</td></tr><tr><td><strong>성능 향상</strong></td><td>제로 카피 동기화</td><td>메모리 복사 없는 고성능 조건 변수 구현 기술 발전</td></tr><tr><td><strong>분산 시스템</strong></td><td>글로벌 조건 변수</td><td>네트워크를 통한 분산 조건 변수 프로토콜 개발</td></tr><tr><td><strong>실시간 처리</strong></td><td>결정적 지연시간</td><td>실시간 시스템을 위한 예측 가능한 지연시간을 가진 조건 변수</td></tr><tr><td><strong>녹색 컴퓨팅</strong></td><td>에너지 효율성</td><td>전력 소비를 최소화하는 친환경 동기화 알고리즘 연구</td></tr></tbody></table><h2 id=11-하위-주제로-추가-학습-내용>11. 하위 주제로 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#11-하위-주제로-추가-학습-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>기본 동기화</strong></td><td>뮤텍스와 세마포어</td><td>조건 변수와 함께 사용되는 기본 동기화 기본요소들</td></tr><tr><td><strong>고급 동기화</strong></td><td>리더-라이터 락</td><td>조건 변수를 활용한 고급 동기화 패턴</td></tr><tr><td><strong>설계 패턴</strong></td><td>생산자-소비자 패턴</td><td>조건 변수의 대표적인 활용 사례</td></tr><tr><td><strong>모니터 구조</strong></td><td>모니터와 조건 큐</td><td>조건 변수를 캡슐화한 고수준 동기화 추상화</td></tr><tr><td><strong>실시간 시스템</strong></td><td>우선순위 상속</td><td>실시간 시스템에서의 조건 변수 특수 구현</td></tr><tr><td><strong>분산 시스템</strong></td><td>분산 동기화</td><td>네트워크 환경에서의 조건 변수 활용</td></tr><tr><td><strong>성능 최적화</strong></td><td>락프리 프로그래밍</td><td>조건 변수의 대안이 되는 고성능 동기화 기법</td></tr></tbody></table><h2 id=12-관련-분야별-추가-학습-내용>12. 관련 분야별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#12-관련-분야별-추가-학습-내용>#</a></h2><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>운영체제</strong></td><td>스케줄러와 동기화</td><td>OS 스케줄러에서 조건 변수가 활용되는 방식</td></tr><tr><td><strong>데이터베이스</strong></td><td>트랜잭션 격리</td><td>데이터베이스에서 조건 변수를 활용한 동시성 제어</td></tr><tr><td><strong>네트워크 프로그래밍</strong></td><td>비동기 I/O</td><td>네트워크 이벤트 처리에서의 조건 변수 활용</td></tr><tr><td><strong>게임 개발</strong></td><td>프레임 동기화</td><td>게임 엔진에서 렌더링과 로직 동기화</td></tr><tr><td><strong>웹 개발</strong></td><td>서버 아키텍처</td><td>웹 서버의 스레드 풀과 요청 처리 동기화</td></tr><tr><td><strong>임베디드</strong></td><td>RTOS 동기화</td><td>실시간 운영체제에서의 특수한 조건 변수 구현</td></tr><tr><td><strong>클라우드 컴퓨팅</strong></td><td>컨테이너 동기화</td><td>컨테이너 오케스트레이션에서의 동기화 패턴</td></tr></tbody></table><hr><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>스퓨리어스 웨이크업 (Spurious Wakeup)</td><td>실제 신호 없이도 대기 중인 스레드가 깨어나는 현상으로, 하드웨어나 OS 최적화로 인해 발생할 수 있어 조건을 항상 재확인해야 함</td></tr><tr><td>신호 손실 (Lost Signal)</td><td>스레드가 대기 상태에 진입하기 전에 전송된 신호가 손실되는 현상</td></tr><tr><td>Mesa 스타일</td><td>신호를 받은 스레드가 즉시 실행되지 않고 뮤텍스를 기다리는 조건 변수 구현 방식</td></tr><tr><td>Hoare 스타일</td><td>신호를 받은 스레드가 즉시 실행되는 조건 변수 구현 방식</td></tr><tr><td>모니터 (Monitor)</td><td>뮤텍스와 조건 변수를 조합하여 공유 자원에 대한 안전한 접근을 제공하는 고수준 동기화 추상화</td></tr><tr><td>브로드캐스트 (Broadcast)</td><td>모든 대기 중인 스레드에게 신호를 보내는 조건 변수 연산</td></tr><tr><td>원자적 연산 (Atomic Operation)</td><td>중단되지 않고 완전히 수행되거나 전혀 수행되지 않는 연산</td></tr><tr><td>경쟁 상태 (Race Condition)</td><td>여러 스레드가 공유 자원에 동시에 접근할 때 실행 순서에 따라 결과가 달라지는 상황</td></tr><tr><td>우선순위 역전 (Priority Inversion)</td><td>높은 우선순위 스레드가 낮은 우선순위 스레드에 의해 차단되는 현상</td></tr><tr><td>기아 상태 (Starvation)</td><td>특정 스레드가 계속해서 자원을 할당받지 못하는 상황</td></tr><tr><td>컨텍스트 스위칭 (Context Switching)</td><td>CPU가 한 스레드에서 다른 스레드로 실행을 전환하는 과정</td></tr><tr><td>바쁜 대기 (Busy Waiting)</td><td>조건이 충족될 때까지 계속해서 조건을 확인하며 CPU를 소비하는 대기 방식</td></tr></tbody></table><hr><h2 id=참고-및-출처-3>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-3>#</a></h2><ul><li><a href=https://learn.microsoft.com/en-us/windows/win32/sync/condition-variables>Microsoft Learn - Condition Variables</a></li><li><a href=https://www.geeksforgeeks.org/cpp-multithreading-condition-variables/>GeeksforGeeks - Condition Variables in C++ Multithreading</a></li><li><a href=https://en.cppreference.com/w/cpp/thread/condition_variable>cppreference.com - std condition_variable</a></li><li><a href=https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032r/index.html>Oracle - Using Condition Variables (Multithreaded Programming Guide)</a></li><li><a href="http://web.stanford.edu/~ouster/cgi-bin/cs140-spring14/lecture.php?topic=locks">Stanford CS - Locks and Condition Variables</a></li><li><a href=https://en.wikipedia.org/wiki/Monitor_(synchronization)>Wikipedia - Monitor (synchronization)</a></li><li><a href=https://www.geeksforgeeks.org/introduction-of-process-synchronization/>GeeksforGeeks - Introduction of Process Synchronization</a></li><li><a href=https://www.cs.cornell.edu/courses/cs3110/2012fa/recitations/rec16.html>Cornell CS - Concurrency: Condition Variables</a></li><li><a href="https://www.ibm.com/docs/en/aix/7.2?topic=programming-using-condition-variables">IBM Docs - Using condition variables</a></li><li><a href=https://www.geeks-for-geeks.org/difference-between-semaphore-and-condition-variable/>GeeksforGeeks - Difference between Semaphore and Condition Variable</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science-fundamentals/>Computer-Science-Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://buenhyden.github.io/tags/process-management/>Process-Management</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-and-parallelism/>Concurrency-and-Parallelism</a></li><li><a href=https://buenhyden.github.io/tags/synchronization/>Synchronization</a></li><li><a href=https://buenhyden.github.io/tags/condition-synchronization/>Condition-Synchronization</a></li><li><a href=https://buenhyden.github.io/tags/condition-variables/>Condition-Variables</a></li><li><a href=https://buenhyden.github.io/tags/spurious-wakeup/>Spurious-Wakeup</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization-primitives/software-level/mutex/><span class=title>« Prev</span><br><span>Mutex</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization-primitives/hardware-level/atomic-operation/><span class=title>Next »</span><br><span>원자적 연산 (Atomic Operation)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>