<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process vs Thread vs Coroutine | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,Processes,Process,Thread,Coroutine"><meta name=description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems-fundamentals/process-and-thread-fundamentals/process-vs-thread/process-vs-thread-vs-coroutine/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems-fundamentals/process-and-thread-fundamentals/process-vs-thread/process-vs-thread-vs-coroutine/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems-fundamentals/process-and-thread-fundamentals/process-vs-thread/process-vs-thread-vs-coroutine/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems-fundamentals/process-and-thread-fundamentals/process-vs-thread/process-vs-thread-vs-coroutine/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Process vs Thread vs Coroutine"><meta property="og:description" content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Process vs Thread vs Coroutine"><meta name=twitter:description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Process vs Thread vs Coroutine","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems-fundamentals/process-and-thread-fundamentals/process-vs-thread/process-vs-thread-vs-coroutine/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Process vs Thread vs Coroutine</h1><div class=post-description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</div></header><div class=post-content><h2 id=process-vs-thread-vs-coroutine>Process vs. Thread vs. Coroutine<a hidden class=anchor aria-hidden=true href=#process-vs-thread-vs-coroutine>#</a></h2><p>Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.</p><ol><li><p>Process:</p><ul><li>독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다.</li><li>다른 프로세스와 완전히 격리되어 있어 안정성이 높다.</li><li>생성과 전환에 많은 비용이 든다.</li></ul></li><li><p>Thread:</p><ul><li>프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다.</li><li>프로세스보다 가볍고, 생성과 전환 비용이 적다.</li><li>동시성을 제공하지만, 동기화 문제에 주의해야 한다.</li></ul></li><li><p>Coroutine:</p><ul><li>경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위.</li><li>매우 가볍고, 생성과 전환 비용이 매우 적다.</li><li>비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다.</li></ul></li></ol><p>Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:<br><code>CPU > Core > Process > Thread > Coroutine</code></p><ul><li>프로세스는 독립적인 메모리 공간을 가지며, 하나 이상의 스레드를 포함한다.</li><li>스레드는 프로세스 내에서 실행되며, 같은 프로세스의 메모리를 공유한다.</li><li>코루틴은 스레드 내에서 실행되는 더 가벼운 실행 단위이다.<br>이 구조는 각 단위의 특성과 리소스 사용을 잘 보여준다.<br>프로세스가 가장 무겁고, 코루틴이 가장 가벼운 실행 단위이다.</li></ul><p><figure><img alt="Coroutine in User-level Thread" loading=lazy src=/img/1_AD4ZqhM1MgNe-npYcrkWzQ.webp><figcaption>https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-6-coroutine-9eecdbeb2d2d</figcaption></figure></p><h3 id=process-vs-thread-vs-coroutine-비교>Process vs. Thread vs. Coroutine 비교<a hidden class=anchor aria-hidden=true href=#process-vs-thread-vs-coroutine-비교>#</a></h3><table><thead><tr><th>특성</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>독립적인 실행 단위로 자체 메모리 공간 보유</td><td>프로세스 내의 실행 단위로 메모리 공유</td><td>협력적 멀티태스킹을 위한 서브루틴</td></tr><tr><td><strong>메모리 공유</strong></td><td>독립적인 메모리 공간</td><td>같은 프로세스의 메모리 공유</td><td>같은 스레드의 메모리 공유</td></tr><tr><td><strong>컨텍스트 스위칭 비용</strong></td><td>매우 높음</td><td>중간</td><td>매우 낮음</td></tr><tr><td><strong>생성/소멸 비용</strong></td><td>높음</td><td>중간</td><td>낮음</td></tr><tr><td><strong>자원 사용</strong></td><td>많음</td><td>중간</td><td>적음</td></tr><tr><td><strong>통신 방식</strong></td><td>IPC (파이프, 소켓 등)</td><td>공유 메모리, 뮤텍스</td><td>yield/await</td></tr><tr><td><strong>병렬 처리</strong></td><td>실제 병렬 처리 가능</td><td>실제 병렬 처리 가능</td><td>동시성만 제공 (병렬x)</td></tr><tr><td><strong>적합한 작업</strong></td><td>CPU 집약적 작업</td><td>I/O + CPU 혼합 작업</td><td>I/O 집약적 작업</td></tr><tr><td><strong>에러 영향</strong></td><td>다른 프로세스에 영향 없음</td><td>같은 프로세스의 스레드들에 영향</td><td>명시적 에러 처리 필요</td></tr><tr><td><strong>디버깅 난이도</strong></td><td>쉬움</td><td>어려움</td><td>중간</td></tr><tr><td><strong>확장성</strong></td><td>높음 (여러 CPU 코어)</td><td>중간</td><td>단일 스레드 내 제한</td></tr><tr><td><strong>메모리 격리</strong></td><td>완전 격리</td><td>부분 공유</td><td>공유</td></tr></tbody></table><h4 id=실행-모델-비교>실행 모델 비교<a hidden class=anchor aria-hidden=true href=#실행-모델-비교>#</a></h4><table><thead><tr><th>실행 모델</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>스케줄링 주체</strong></td><td>OS</td><td>OS</td><td>프로그램</td></tr><tr><td><strong>선점 여부</strong></td><td>선점형</td><td>선점형</td><td>비선점형</td></tr><tr><td><strong>컨텍스트 스위치</strong></td><td>OS 레벨</td><td>OS 레벨</td><td>사용자 레벨</td></tr><tr><td><strong>동시성 모델</strong></td><td>진정한 병렬성</td><td>진정한 병렬성</td><td>협력적 멀티태스킹</td></tr></tbody></table><h4 id=리소스-사용-비교>리소스 사용 비교<a hidden class=anchor aria-hidden=true href=#리소스-사용-비교>#</a></h4><table><thead><tr><th>리소스</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>메모리 사용량</strong></td><td>높음 (독립 메모리)</td><td>중간 (공유 메모리)</td><td>낮음 (최소 오버헤드)</td></tr><tr><td><strong>CPU 사용</strong></td><td>높음</td><td>중간</td><td>낮음</td></tr><tr><td><strong>시스템 리소스</strong></td><td>많음</td><td>중간</td><td>적음</td></tr><tr><td><strong>스택 크기</strong></td><td>독립적</td><td>독립적</td><td>공유</td></tr></tbody></table><h4 id=성능-특성-비교>성능 특성 비교<a hidden class=anchor aria-hidden=true href=#성능-특성-비교>#</a></h4><table><thead><tr><th>성능 특성</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>생성 시간</strong></td><td>느림</td><td>중간</td><td>빠름</td></tr><tr><td><strong>컨텍스트 스위치 시간</strong></td><td>느림</td><td>중간</td><td>빠름</td></tr><tr><td><strong>메모리 접근</strong></td><td>독립적 (느림)</td><td>공유 (빠름)</td><td>공유 (매우 빠름)</td></tr><tr><td><strong>확장성 한계</strong></td><td>CPU 코어 수</td><td>시스템 리소스</td><td>이벤트 루프 성능</td></tr></tbody></table><h4 id=사용-사례별-비교>사용 사례별 비교<a hidden class=anchor aria-hidden=true href=#사용-사례별-비교>#</a></h4><table><thead><tr><th>사용 사례</th><th>적합한 모델</th><th>이유</th></tr></thead><tbody><tr><td>대규모 데이터 처리</td><td>Process</td><td>메모리 격리와 CPU 활용</td></tr><tr><td>웹 서버</td><td>Thread/Coroutine</td><td>I/O 작업 처리에 효율적</td></tr><tr><td>실시간 게임</td><td>Thread</td><td>낮은 지연시간 필요</td></tr><tr><td>GUI 애플리케이션</td><td>Thread</td><td>사용자 인터페이스 반응성</td></tr><tr><td>네트워크 서비스</td><td>Coroutine</td><td>많은 동시 연결 처리</td></tr><tr><td>이미지/비디오 처리</td><td>Process</td><td>CPU 집약적 작업</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>코루틴(Coroutine)</h2></header><div class=entry-content><p>코루틴 (Coroutine) 1. 태그(Tag) Coroutine, Concurrency, Async-Programming, Thread-Management
2. 분류 구조 적합성 분석 현재 구조
Computer Science Fundamentals > Operating systems > Process Management > Thread Management > Threads
분석 및 개선 제안 **코루틴 (Coroutine)**은 전통적으로 쓰레드(Thread)와 대비되거나, 쓰레드 내에서의 컨트롤 플로우(control flow) 관리 기법으로 간주됨. 하지만, 코루틴은 프로세스(Process)와 쓰레드(Thread)처럼 운영체제 차원의 엔티티가 아닌, “사용자 수준의 비동기 협력 멀티태스킹” 모델로 분류할 수 있음. 따라서, “Thread Management” 아래 “Threads"에 포함된 것은 큰 흐름상 자연스러우나, 더욱 명확히 구분하기 위해 Concurrency and Parallelism > Coroutine 혹은 Thread Management > Coroutine 정도로 독립된 항목으로 명확히 기재하면 이론적, 기술적으로 의미가 강화됨.
근거: 코루틴은 컨커런시(concurrency, 동시성) 제어의 주요 수단이지만, 운영체제 레벨이 아니라 프로그램 언어 혹은 라이브러리 레벨에서 구현됨. 3. 200자 내외 요약 코루틴(Coroutine)은 함수 실행 도중 중단과 재개가 가능한 비동기 협동형 컨트롤 플로우 기법이다. 경량화된 동시성 처리와 자원 효율적 실행을 지원하며, 스레드와 달리 문맥 전환 비용이 낮아 실시간 처리, 비동기 네트워킹, 게임 루프 등에서 폭넓게 활용된다.
...</p></div><footer class=entry-footer><span title='2024-10-05 06:52:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;66 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코루틴(Coroutine)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems-fundamentals/process-and-thread-fundamentals/process-vs-thread/process-vs-thread-vs-coroutine/coroutine/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>