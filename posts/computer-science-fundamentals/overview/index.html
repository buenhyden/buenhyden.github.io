<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Science Fundamentals Overview | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Overview"><meta name=description content="Computer Science Fundamentals 는 컴퓨터 과학의 핵심 이론과 실무를 아우르는 기초 학문으로, 알고리즘과 데이터 구조, 컴퓨터 아키텍처, 운영체제, 데이터베이스, 네트워킹, 소프트웨어 공학 등의 필수 개념들을 포함하여 효율적이고 확장 가능한 컴퓨팅 시스템을 설계하고 구현하는 능력을 기르는 학문 분야이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/overview/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/overview/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/overview/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/overview/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Science Fundamentals Overview"><meta property="og:description" content="Computer Science Fundamentals 는 컴퓨터 과학의 핵심 이론과 실무를 아우르는 기초 학문으로, 알고리즘과 데이터 구조, 컴퓨터 아키텍처, 운영체제, 데이터베이스, 네트워킹, 소프트웨어 공학 등의 필수 개념들을 포함하여 효율적이고 확장 가능한 컴퓨팅 시스템을 설계하고 구현하는 능력을 기르는 학문 분야이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Science Fundamentals Overview"><meta name=twitter:description content="Computer Science Fundamentals 는 컴퓨터 과학의 핵심 이론과 실무를 아우르는 기초 학문으로, 알고리즘과 데이터 구조, 컴퓨터 아키텍처, 운영체제, 데이터베이스, 네트워킹, 소프트웨어 공학 등의 필수 개념들을 포함하여 효율적이고 확장 가능한 컴퓨팅 시스템을 설계하고 구현하는 능력을 기르는 학문 분야이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Computer Science Fundamentals Overview","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/overview/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a></div><h1>Computer Science Fundamentals Overview</h1><div class=post-description>Computer Science Fundamentals 는 컴퓨터 과학의 핵심 이론과 실무를 아우르는 기초 학문으로, 알고리즘과 데이터 구조, 컴퓨터 아키텍처, 운영체제, 데이터베이스, 네트워킹, 소프트웨어 공학 등의 필수 개념들을 포함하여 효율적이고 확장 가능한 컴퓨팅 시스템을 설계하고 구현하는 능력을 기르는 학문 분야이다.</div></header><div class=post-content><h2 id=computer-science-fundamentals>Computer Science Fundamentals<a hidden class=anchor aria-hidden=true href=#computer-science-fundamentals>#</a></h2><p>Computer Science Fundamentals 는 현대 컴퓨팅의 토대가 되는 핵심 원리들을 다루는 종합적인 학문 분야이다. 이론적 기초인 알고리즘과 데이터 구조부터 실용적 구현인 시스템 아키텍처, 운영체제, 데이터베이스 관리까지 포괄한다. 컴퓨터 과학 이론과 소프트웨어 공학 실무를 결합하여 확장 가능하고 효율적인 컴퓨팅 솔루션을 설계하는 능력을 기르며, 현대 기술 발전의 핵심 역량을 제공한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><table><thead><tr><th>분류</th><th>핵심 개념</th><th>주요 내용 요약</th></tr></thead><tbody><tr><td><strong>1. 계산 사고 (Computational Thinking)</strong></td><td>- 문제 분해, 패턴 인식, 추상화, 알고리즘적 사고</td><td>문제 해결 능력의 기반 사고 체계</td></tr><tr><td><strong>2. 자료구조 (Data Structures)</strong></td><td>- 선형 구조: 배열, 연결 리스트, 스택, 큐<br>- 비선형 구조: 트리, 그래프, 해시 테이블<br>- 추상 자료형 (ADT), 메모리 효율</td><td>데이터의 효율적 저장과 접근</td></tr><tr><td><strong>3. 알고리즘 (Algorithms)</strong></td><td>- 탐색/정렬/최적화/분할정복/동적계획법/그리디<br>- 시간·공간 복잡도 분석, Big-O 표기법</td><td>성능 중심의 문제 해결 전략</td></tr><tr><td><strong>4. 프로그래밍 기초 및 언어 (Programming Fundamentals & Languages)</strong></td><td>- 조건문, 반복문, 함수, 재귀, 스코프, 메모리 모델<br>- 프로그래밍 언어: Python, Java, C++, JavaScript 등</td><td>알고리즘 구현을 위한 실용 문법</td></tr><tr><td><strong>5. 컴퓨터 아키텍처 (Computer Architecture)</strong></td><td>- CPU, ALU, 레지스터, 명령어 세트 (ISA)<br>- 메모리 계층 (캐시, RAM), 파이프라이닝, 병렬처리</td><td>하드웨어 수준의 시스템 이해</td></tr><tr><td><strong>6. 운영체제 (Operating Systems)</strong></td><td>- 프로세스/스레드 관리, 스케줄링, 동기화<br>- 가상 메모리, 파일 시스템, 입출력 시스템</td><td>컴퓨터 자원의 효율적 관리 원리</td></tr><tr><td><strong>7. 네트워크 (Computer Networks)</strong></td><td>- OSI 7 계층, TCP/IP, 라우팅, DNS, HTTP/HTTPS<br>- 패킷 스위칭, 포트, 방화벽, NAT</td><td>데이터 통신과 연결 구조</td></tr><tr><td><strong>8. 데이터베이스 (Databases)</strong></td><td>- 관계형 DB, SQL, 트랜잭션 (ACID), 정규화<br>- 인덱싱, 동시성 제어, 분산 DB 시스템</td><td>대규모 데이터의 일관된 저장/조회</td></tr><tr><td><strong>9. 컴파일러 및 언어 처리기 (Compilers & Language Processors)</strong></td><td>- 렉서 (lexer), 파서 (parser), AST, IR<br>- 최적화, 기계어 코드 생성</td><td>코드 → 실행의 전환 과정 이해</td></tr><tr><td><strong>10. 이론 컴퓨터 과학 (Theoretical Computer Science)</strong></td><td>- 튜링 머신, 유한 상태 머신 (FSM)<br>- 결정 가능성, 계산 복잡도 (P vs NP 등)</td><td>계산 가능한 문제의 이론적 경계</td></tr><tr><td><strong>11. 소프트웨어 공학 (Software Engineering)</strong></td><td>- SDLC, 테스트 기법, 빌드/배포 자동화<br>- 버전관리 (Git), 요구사항 분석, 디버깅 전략</td><td>체계적인 소프트웨어 개발 및 유지관리 방법론</td></tr></tbody></table><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>컴퓨터 과학 기초 (CS Fundamentals) 는 <strong>계산 이론</strong>, <strong>문제 해결 패턴</strong>, <strong>데이터 표현</strong>, <strong>시스템 구조</strong>에 대한 근본적인 이해를 다루는 분야이다.<br>컴퓨터 과학은 1936 년 앨런 튜링 (Alan Turing) 의 <strong>튜링 머신 이론</strong>으로 계산 가능성 (Computability) 을 정의하며 형성되었고, 20 세기 중후반에는 자료구조, 알고리즘, 운영체제, 컴파일러, 네트워크 등 세부 영역이 체계화되었다.<br>현재는 <strong>소프트웨어 엔지니어링</strong>, <strong>AI</strong>, <strong>시스템 설계</strong>, <strong>DevOps</strong> 등 모든 기술 기반의 바탕이 되는 학문이자 실무 역량이다.</p><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p><strong>목적:</strong></p><ul><li>효율적이고 확장 가능한 컴퓨팅 시스템 설계 능력 배양</li><li>복잡한 문제를 체계적으로 해결하는 논리적 사고력 개발</li><li>소프트웨어와 하드웨어의 상호작용 이해</li></ul><p><strong>필요성:</strong></p><ul><li>급속한 기술 발전에 대응하는 기초 역량 확보</li><li>다양한 컴퓨팅 환경에서 통용되는 원리 습득</li><li>새로운 기술 학습의 기반 마련</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><p><strong>주요 기능:</strong></p><ul><li><strong>데이터 구조화와 처리</strong>: 정렬, 탐색, 저장, 삭제 등 연산 정의</li><li><strong>계산의 모델링</strong>: 알고리즘으로 문제를 정의하고 해결</li><li><strong>논리적 추론 기반 설계</strong>: 수학적 모델, 이산 구조, 추론 능력 포함</li><li><strong>컴퓨터 시스템의 이해</strong>: CPU, 메모리, OS, 네트워크까지 아우르는 전산 시스템의 통합적 사고</li></ul><p><strong>주요 역할:</strong></p><table><thead><tr><th>영역</th><th>역할 설명</th></tr></thead><tbody><tr><td>소프트웨어 개발</td><td>효율적 알고리즘과 올바른 자료구조를 선택하여 프로그램 작성</td></tr><tr><td>시스템 아키텍처</td><td>컴퓨터 내부 구조 (CPU, 메모리) 이해를 바탕으로 설계에 반영</td></tr><tr><td>네트워크 프로토콜</td><td>OSI/TCP 계층 이해를 통한 성능 및 보안 설계</td></tr><tr><td>데이터베이스 설계</td><td>정규화, 쿼리 최적화, 인덱싱 이해</td></tr><tr><td>인공지능 및 보안</td><td>탐색 알고리즘, 상태 모델링, 암호학적 해시 등 논리적 기초 확립</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>보편성</strong>: 모든 개발자의 공통 기초 능력</li><li><strong>계층성</strong>: 고급 기술을 위한 기반 기술</li><li><strong>수학적 엄밀성</strong>: 복잡도, 결정가능성, 정규 표현 등 이론적 근거 중심</li><li><strong>프로그래밍 언어 독립성</strong>: 언어와 무관하게 논리 기반 학습 가능</li><li><strong>실무 활용도 높음</strong>: 시스템 설계, 디버깅, 최적화 등 실무 전반에 직접적 기여</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ul><li><strong>알고리즘과 데이터 구조</strong>: 효율적 문제 해결의 기초.</li><li><strong>정보 표현</strong>: 모든 정보는 이진수 (0 과 1) 로 표현.</li><li><strong>자동화</strong>: 반복 작업을 자동으로 처리.</li><li><strong>추상화 (Abstraction)</strong>: 복잡한 문제를 단순화하여 해결.</li><li><strong>분해 (Decomposition)</strong>: 문제를 작은 단위로 분해하여 해결.</li></ul><h3 id=컴퓨터-과학-핵심-개념과-시스템-설계-구조>컴퓨터 과학 핵심 개념과 시스템 설계 구조<a hidden class=anchor aria-hidden=true href=#컴퓨터-과학-핵심-개념과-시스템-설계-구조>#</a></h3><p><strong>Computer Science Fundamentals 구조:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;이론적 기초&#34;
        A1[수학적 기초]
        A2[논리 및 이산수학]
        A3[계산 이론]
    end
    
    subgraph &#34;핵심 개념&#34;
        B1[알고리즘]
        B2[데이터 구조]
        B3[프로그래밍 언어]
    end
    
    subgraph &#34;시스템 설계&#34;
        C1[컴퓨터 아키텍처]
        C2[운영체제]
        C3[네트워크]
    end
    
    subgraph &#34;응용 분야&#34;
        D1[데이터베이스]
        D2[소프트웨어 공학]
        D3[보안]
    end
    
    A1 --&gt; B1
    A2 --&gt; B2
    A3 --&gt; B3
    B1 --&gt; C1
    B2 --&gt; C2
    B3 --&gt; C3
    C1 --&gt; D1
    C2 --&gt; D2
    C3 --&gt; D3
</pre><table><thead><tr><th>구분</th><th>구성 요소</th><th>기능</th><th>역할 / 특징</th></tr></thead><tbody><tr><td><strong>핵심 영역</strong></td><td>이론적 기초</td><td>수학적 논리 및 계산 이론 제공</td><td>체계적 사고와 문제 해결 능력의 기반 마련</td></tr><tr><td></td><td>알고리즘과 데이터 구조</td><td>효율적인 문제 해결 방법론 제공</td><td>최적화된 프로그램 설계 지원</td></tr><tr><td></td><td>시스템 아키텍처</td><td>하드웨어와 소프트웨어의 통합 설계</td><td>성능과 확장성을 고려한 시스템 구축</td></tr><tr><td><strong>선택 영역</strong></td><td>특화 분야</td><td>특정 도메인에 특화된 전문 지식 제공</td><td>관심사나 업무 요구에 따라 선택</td></tr><tr><td></td><td>신기술 영역</td><td>최신 기술 동향에 대한 적용 및 대응 지원</td><td>빠르게 변화하는 기술 환경에 맞춘 지속적 학습 필요</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><ul><li><strong>알고리즘 구현</strong>: 문제 해결을 위한 단계적 절차 설계 및 구현.</li><li><strong>데이터 구조 설계</strong>: 데이터를 효율적으로 저장 및 관리하는 구조 설계.</li><li><strong>프로그래밍</strong>: 컴퓨터가 이해할 수 있는 언어로 명령 작성.</li><li><strong>모듈화 및 추상화</strong>: 복잡한 문제를 단순화하여 해결.</li><li><strong>테스트 및 디버깅</strong>: 프로그램의 정확성 및 신뢰성 확보.</li></ul><h3 id=문제점과-해결방안>문제점과 해결방안<a hidden class=anchor aria-hidden=true href=#문제점과-해결방안>#</a></h3><table><thead><tr><th>문제/도전 과제</th><th>원인 또는 설명</th><th>영향 또는 위험</th><th>탐지/진단 방법</th><th>예방 전략</th><th>해결 방안 또는 대응 기법</th></tr></thead><tbody><tr><td><strong>시스템 장애</strong></td><td>하드웨어/소프트웨어 결함</td><td>서비스 중단, 가용성 저하</td><td>모니터링, 로그 분석</td><td>정기 점검, 이중화 구성, 백업</td><td>장애 복구, 롤백, 자동 복구 메커니즘</td></tr><tr><td><strong>보안 침해</strong></td><td>취약점, 악성코드, 인증 실패 등</td><td>정보 유출, 서비스 중단, 신뢰도 하락</td><td>침입 탐지 시스템 (IDS), 로그 감사</td><td>접근 제어, 보안 패치, 최소 권한 원칙 적용</td><td>암호화, 토큰 인증, 사고 대응 프로세스 구축</td></tr><tr><td><strong>성능 저하</strong></td><td>리소스 부족, 비효율 코드, 부하 증가</td><td>응답 지연, 처리량 감소</td><td>APM, 성능 메트릭, 부하 테스트</td><td>코드 최적화, 쿼리 튜닝, 정적 리소스 캐싱</td><td>수평 확장, CDN, 캐시 전략, 병목 해소</td></tr><tr><td><strong>메모리 관리 문제</strong></td><td>대용량 데이터 처리, 누수, 비효율적 구조 사용</td><td>메모리 부족, GC 과부하, 시스템 다운</td><td>힙 덤프, GC 로그 분석, 프로파일링 도구</td><td>메모리 풀, 슬라이스, 적절한 구조 선택</td><td>스트리밍 처리, 페이징, 압축 알고리즘 적용</td></tr><tr><td><strong>동시성 문제</strong></td><td>공유 자원 접근 충돌, 경쟁 조건, 락 미사용</td><td>데이터 손상, 교착 상태</td><td>스레드 덤프 분석, Race Detector 도구</td><td>락 - 프리 알고리즘, 불변 객체, 스레드 세이프 구조 설계</td><td>세마포어, 뮤텍스, Atomic 연산 사용</td></tr><tr><td><strong>확장성 한계</strong></td><td>단일 서버 구조, 모놀리식 아키텍처</td><td>사용자 증가 시 처리 지연, 장애 전이</td><td>부하 테스트, TPS/Latency 측정</td><td>마이크로서비스 구조, Stateless 설계</td><td>로드 밸런서, 샤딩, 오토스케일링 적용</td></tr><tr><td><strong>빅데이터 처리 복잡성</strong></td><td>대규모 데이터 증가, 실시간성 요구</td><td>분석 지연, 저장소 초과</td><td>처리 시간 분석, 큐 대기 시간, 처리율 모니터링</td><td>데이터 파이프라인 설계, 적절한 분할 방식 적용</td><td>분산 처리 시스템 (Spark, Flink), 병렬 처리, 클라우드 저장소 활용</td></tr><tr><td><strong>급속한 기술 변화</strong></td><td>기술 트렌드 변화 속도, 새로운 패러다임 등장</td><td>기술 부채 증가, 대응력 부족</td><td>기술 변화 주기 분석, 기술 갭 측정</td><td>핵심 원리 기반 학습, 기술 로드맵 수립</td><td>유연한 아키텍처 설계, 지속적 학습 문화</td></tr><tr><td><strong>이론과 실무의 간극</strong></td><td>추상적 이론 vs. 현실 시스템의 요구사항 불일치</td><td>아키텍처 부적합, 비효율 구현</td><td>요구사항 명세 정밀도 분석, 설계 - 실행 차이 검토</td><td>실무 사례 기반 학습, DDD, 유스케이스 기반 설계</td><td>프로토타이핑, 산학 협력, 실무 중심 프로젝트 참여</td></tr><tr><td><strong>시스템 복잡성 증가</strong></td><td>다양한 기술 스택, 복합 요구사항</td><td>관리 및 유지보수 비용 증가, 의사결정 지연</td><td>의존성 분석, 구조 시각화 (C4, 계층도)</td><td>모듈화, 관심사 분리, 설계 문서화</td><td>추상화 계층 설계, 아키텍처 리팩토링, 기술 표준화 적용</td></tr></tbody></table><h3 id=활용사례>활용사례<a hidden class=anchor aria-hidden=true href=#활용사례>#</a></h3><h4 id=사례-1-이커머스-검색-시스템---고속-제품-검색-엔진-설계>사례 1: 이커머스 검색 시스템 - 고속 제품 검색 엔진 설계<a hidden class=anchor aria-hidden=true href=#사례-1-이커머스-검색-시스템---고속-제품-검색-엔진-설계>#</a></h4><p><strong>구성 목적</strong>: 사용자가 입력한 키워드를 기반으로 빠르고 정확한 상품 리스트를 반환하며, 실시간 추천 및 필터 기능을 포함.</p><p><strong>시스템 구성도</strong></p><pre class=mermaid>graph TD
  User[사용자]
  UI[&#34;검색 UI (웹/앱)&#34;]
  Gateway[API Gateway]
  SearchAPI[검색 API]
  Cache[Redis 캐시]
  Indexer[역색인 처리기]
  DB[&#34;Product DB&#34;]
  ML[추천 모델 서버]

  User --&gt; UI --&gt; Gateway --&gt; SearchAPI
  SearchAPI --&gt; Cache
  SearchAPI --&gt; Indexer
  Indexer --&gt; DB
  SearchAPI --&gt; ML
  ML --&gt; SearchAPI
</pre><p><strong>워크플로우</strong>:</p><ol><li>사용자 검색어 입력 → UI 전달</li><li>Gateway → Search API 요청</li><li>캐시에 쿼리 결과가 존재하면 바로 응답</li><li>없을 경우 Indexer 가 역색인을 통해 검색 실행</li><li>DB 에서 관련 상품 정보 조회</li><li>ML 서버에서 추천 상품 보강</li><li>최종 결과를 사용자에게 JSON 형태로 반환</li></ol><p><strong>적용된 CS 개념</strong></p><table><thead><tr><th>적용 요소</th><th>관련 CS 지식</th></tr></thead><tbody><tr><td>역색인 자료구조</td><td>해시 테이블, B- 트리</td></tr><tr><td>결과 캐싱</td><td>LRU 캐시, 해시 테이블</td></tr><tr><td>ML 보조 추천</td><td>유사도 기반 알고리즘 (Cosine, Jaccard)</td></tr><tr><td>병렬 처리</td><td>멀티스레딩, 큐 구조</td></tr><tr><td>검색 최적화</td><td>이진 탐색, Trie 적용 가능</td></tr></tbody></table><h4 id=사례-2-google-검색-엔진-아키텍처-사례>사례 2: Google 검색 엔진 아키텍처 사례<a hidden class=anchor aria-hidden=true href=#사례-2-google-검색-엔진-아키텍처-사례>#</a></h4><p><strong>시스템 구성:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;사용자 계층&#34;
        A[웹 브라우저]
        B[모바일 앱]
    end
    
    subgraph &#34;프론트엔드 계층&#34;
        C[로드 밸런서]
        D[웹 서버]
    end
    
    subgraph &#34;검색 처리 계층&#34;
        E[쿼리 분석기]
        F[랭킹 알고리즘]
        G[인덱스 서버]
    end
    
    subgraph &#34;데이터 계층&#34;
        H[분산 파일 시스템]
        I[인덱스 데이터베이스]
        J[웹 크롤 데이터]
    end
    
    A --&gt; C
    B --&gt; C
    C --&gt; D
    D --&gt; E
    E --&gt; F
    F --&gt; G
    G --&gt; H
    G --&gt; I
</pre><p><strong>활용 사례 Workflow:</strong></p><pre class=mermaid>flowchart TD
    A[사용자 검색 쿼리 입력] --&gt; B[쿼리 파싱 및 분석]
    B --&gt; C[인덱스 검색]
    C --&gt; D[관련 문서 리스트 추출]
    D --&gt; E[PageRank 알고리즘 적용]
    E --&gt; F[결과 랭킹 및 정렬]
    F --&gt; G[검색 결과 반환]
    G --&gt; H[사용자에게 표시]
    
    subgraph &#34;백그라운드 프로세스&#34;
        I[웹 크롤링]
        J[인덱스 업데이트]
        K[머신러닝 모델 훈련]
    end
    
    I --&gt; J
    J --&gt; C
    K --&gt; E
</pre><p><strong>Computer Science Fundamentals 의 역할:</strong></p><ol><li><strong>알고리즘</strong>: PageRank, 문자열 매칭, 정렬 알고리즘</li><li><strong>데이터 구조</strong>: 해시 테이블, B- 트리, 분산 해시 테이블</li><li><strong>시스템 아키텍처</strong>: 분산 컴퓨팅, 로드 밸런싱, 캐싱</li><li><strong>데이터베이스</strong>: 분산 데이터베이스, 인덱싱, 쿼리 최적화</li><li><strong>네트워킹</strong>: HTTP 프로토콜, CDN, 네트워크 최적화</li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장 사항</th></tr></thead><tbody><tr><td><strong>설계 단계</strong></td><td>요구사항 명확화</td><td>기능/비기능 요구사항을 체계적으로 정의하고 우선순위 설정</td><td>이해관계자 협업, 점진적 설계 접근 적용</td></tr><tr><td></td><td>시스템 확장성/유지보수성</td><td>변화 대응과 성능 고려한 구조 설계 (모듈화, 추상화 중심)</td><td>계층화 설계, 관심사 분리, SOLID 원칙 적용</td></tr><tr><td></td><td>자료구조 선택</td><td>작업 목적과 성능에 맞는 데이터 구조 사용</td><td>탐색: Trie / 정렬: 힙 / 큐: 덱 등 목적별 선택</td></tr><tr><td><strong>구현 단계</strong></td><td>가독성 높은 코드</td><td>협업 가능성과 유지보수성 고려한 코드 작성</td><td>함수 분할, 네이밍 규칙, 코드 리뷰/페어 프로그래밍 적용</td></tr><tr><td></td><td>추상화/캡슐화</td><td>객체지향 원칙 기반 접근 제한과 인터페이스 설계</td><td>캡슐화, 인터페이스 추상화, DI(의존성 주입) 적용</td></tr><tr><td></td><td>디버깅 편의성</td><td>유닛 테스트 가능 구조 설계로 결함 탐지 용이</td><td>자동화 테스트 및 로깅 체계 구축</td></tr><tr><td><strong>성능 최적화</strong></td><td>병목 분석</td><td>응답 시간 및 리소스 사용량을 고려한 성능 점검</td><td>APM 도구 사용, 프로파일링, 병렬 처리 적용</td></tr><tr><td></td><td>시간/공간 복잡도</td><td>알고리즘 Big-O 분석을 통한 코드 성능 평가</td><td>logN 이하 우선 고려, 반복 최적화보단 구조 개선 우선</td></tr><tr><td><strong>보안</strong></td><td>접근 제어 및 암호화</td><td>민감 정보 보호 및 사용자 인증 강화</td><td>OAuth2, JWT, 데이터 암호화, 보안 점검 자동화 적용</td></tr><tr><td><strong>데이터 관리</strong></td><td>무결성과 일관성 유지</td><td>데이터 처리 시 ACID 속성 보장</td><td>정규화 설계, 백업 주기 설정, 데이터 검증 로직 포함</td></tr><tr><td><strong>테스트 단계</strong></td><td>테스트 커버리지 확보</td><td>다양한 입력값/예외 상황 테스트로 안정성 확보</td><td>TDD(테스트 주도 개발), 테스트 자동화 도구 사용</td></tr><tr><td></td><td>테스팅 전략</td><td>단위/통합/회귀 테스트 구분 설계</td><td>상황별 테스트 시나리오 문서화, CI 파이프라인 연동</td></tr><tr><td><strong>배포 단계</strong></td><td>배포 안정성</td><td>무중단 배포 및 점진적 전환 방식 적용</td><td>Blue-Green, Canary 배포, 롤백 전략 포함</td></tr><tr><td></td><td>CI/CD 적용</td><td>코드 커밋 → 테스트 → 배포 자동화</td><td>GitHub Actions, Jenkins, ArgoCD 등 도구 활용</td></tr><tr><td><strong>운영 단계</strong></td><td>모니터링 체계 구축</td><td>시스템 상태 실시간 확인 및 문제 조기 감지</td><td>Prometheus, Grafana, 로그 수집기 연동 (ELK, Loki 등)</td></tr><tr><td></td><td>사전 장애 대응</td><td>단일 장애점 제거 및 예외 자동 처리 전략 적용</td><td>Circuit Breaker, Retry, Timeout 설정</td></tr><tr><td><strong>유지보수</strong></td><td>기술 부채 관리</td><td>불필요한 복잡도와 레거시 코드 누적 방지</td><td>정기적 리팩토링, ADR 문서화, 기술 부채 트래킹 지표화</td></tr><tr><td></td><td>문서화와 표준화</td><td>의사소통 오류 방지 및 팀 내 통일성 유지</td><td>API 명세 (OpenAPI), 코드 규칙 가이드, 아키텍처 결정 기록 (ADR) 작성</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제 범주</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>기초 기술</strong></td><td>컴퓨터 과학 전반</td><td>알고리즘, 데이터 구조, 프로그래밍 등 컴퓨팅 시스템 전반의 이론과 실무</td></tr><tr><td></td><td>컴퓨터 아키텍처</td><td>CPU, 메모리, 저장장치, 입출력 등 하드웨어와 시스템 설계 요소</td></tr><tr><td></td><td>운영체제 및 네트워크</td><td>자원 관리, 프로세스/스레드 처리, TCP/IP, 암호화 등 데이터 통신 및 보안</td></tr><tr><td></td><td>데이터베이스 관리</td><td>정형/비정형 데이터 저장, 검색, 분석, 트랜잭션 처리 및 정규화 등</td></tr><tr><td></td><td>보안 및 정보 보호</td><td>인증, 접근 제어, 암호화, 보안 정책, 취약점 대응 등</td></tr><tr><td><strong>프로그래밍 패러다임</strong></td><td>함수형 프로그래밍</td><td>부작용 없는 순수 함수 기반, 불변성 중심 프로그래밍 모델</td></tr><tr><td></td><td>반응형 프로그래밍</td><td>이벤트 및 데이터 스트림 중심 비동기 프로그래밍 방식</td></tr><tr><td></td><td>액터 모델</td><td>상태 공유 없이 메시지 기반으로 동시성을 구현하는 모델</td></tr><tr><td><strong>데이터 및 저장 기술</strong></td><td>NoSQL</td><td>스키마 유연성 있는 비정형/반정형 데이터 저장 (문서, 키 - 값, 컬럼, 그래프 등)</td></tr><tr><td></td><td>블록체인</td><td>분산 원장 기술 기반으로 신뢰성·불변성을 보장하는 데이터 저장 방식</td></tr><tr><td></td><td>데이터 레이크</td><td>정형·비정형 대용량 데이터를 통합 저장하고 후처리하는 분석 플랫폼</td></tr><tr><td><strong>시스템 아키텍처</strong></td><td>마이크로서비스 아키텍처 (MSA)</td><td>독립 배포 가능한 소규모 서비스 단위로 구성된 아키텍처</td></tr><tr><td></td><td>서버리스 컴퓨팅</td><td>서버 인프라를 관리하지 않고 함수 단위로 실행되는 클라우드 네이티브 방식</td></tr><tr><td></td><td>컨테이너 오케스트레이션</td><td>Kubernetes 등으로 대규모 컨테이너 기반 서비스 자동화 및 확장 관리</td></tr><tr><td><strong>AI/ML 기술</strong></td><td>딥러닝 프레임워크</td><td>TensorFlow, PyTorch 등 고수준의 신경망 모델 구현 도구</td></tr><tr><td></td><td>AutoML</td><td>파이프라인 생성·학습·튜닝 등 머신러닝 자동화 기술</td></tr><tr><td></td><td>연합 학습 (Federated Learning)</td><td>데이터 이동 없이 개별 장치에서 학습하여 프라이버시와 데이터 소유권을 보호하는 분산 학습 방식</td></tr><tr><td><strong>신기술 트렌드</strong></td><td>양자 컴퓨팅</td><td>큐비트 기반의 병렬 연산으로 기존 한계를 넘는 계산 성능 제공</td></tr><tr><td></td><td>엣지 컴퓨팅</td><td>데이터 생성 지점에서의 분산 처리로 지연 최소화 및 실시간 응답 향상</td></tr><tr><td></td><td>뉴로모픽 컴퓨팅</td><td>인간 두뇌 신경망을 모방한 아키텍처로 초저전력 고성능 컴퓨팅 제공</td></tr></tbody></table><h3 id=추가-학습-및-관련-내용>추가 학습 및 관련 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-및-관련-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td><strong>고급 알고리즘 및 자료구조</strong></td><td>근사/그리디/온라인 알고리즘, 병렬 알고리즘, Trie</td><td>복잡한 문제 해결, 성능 최적화를 위한 특화된 알고리즘과 데이터 구조</td></tr><tr><td><strong>분산 시스템 및 클라우드</strong></td><td>CAP 정리, 합의 알고리즘, 분산 데이터베이스, 클라우드 컴퓨팅</td><td>노드 간 일관성과 가용성 관리, 분산 환경에서의 신뢰성과 확장성 확보</td></tr><tr><td><strong>컴파일러 이론</strong></td><td>어휘 분석, 구문 분석, 코드 생성</td><td>프로그래밍 언어의 내부 처리 과정 이해, 최적화된 실행 코드 생성</td></tr><tr><td><strong>정보 보안</strong></td><td>암호학, 네트워크 보안, 시스템 보안</td><td>정보 보호를 위한 기초 및 고급 보안 기술, 공격 대응 전략</td></tr><tr><td><strong>인공지능 및 머신러닝</strong></td><td>머신러닝, 딥러닝, AutoML</td><td>예측, 분류, 추론을 위한 지능형 시스템 구현 기술</td></tr><tr><td><strong>빅데이터 및 분석 기술</strong></td><td>데이터 수집, 처리, 분석, 시각화</td><td>방대한 데이터를 기반으로 한 의사결정 및 통계 기반 시스템 구축</td></tr><tr><td><strong>IoT 및 임베디드 시스템</strong></td><td>센서 네트워크, 엣지 장치, 실시간 제어</td><td>현실 세계와 컴퓨팅 자원의 연결, 저전력·분산 장치와의 통신</td></tr><tr><td><strong>컴퓨터 그래픽스</strong></td><td>3D 모델링, 렌더링, 애니메이션</td><td>시각적 인터페이스 구성 요소 제작 및 실시간 그래픽 처리 기술</td></tr><tr><td><strong>게임 개발</strong></td><td>게임 엔진, 물리 시뮬레이션, AI 제어</td><td>몰입형 인터랙티브 소프트웨어 개발, 사용자 경험 중심의 로직 구현</td></tr><tr><td><strong>HCI (인간 - 컴퓨터 상호작용)</strong></td><td>UI/UX 설계, 접근성, 사용성 평가</td><td>사용자 중심의 시스템 설계, 인터페이스 최적화 및 사용 편의성 증대</td></tr><tr><td><strong>소프트웨어 공학</strong></td><td>개발 방법론, 품질 보증, 테스트 자동화</td><td>소프트웨어 수명 주기 전반의 이론과 실무 적용, 품질 중심 개발</td></tr><tr><td><strong>네트워크 기본기</strong></td><td>TCP/IP, OSI 모델, 패킷 스위칭</td><td>데이터 통신의 기초 구조, 인터넷과 분산 시스템의 기반 지식</td></tr><tr><td><strong>병렬 및 멀티스레드 처리</strong></td><td>멀티스레딩, 큐 기반 처리, 락/세마포어</td><td>성능 향상 및 자원 효율화를 위한 동시성 제어 전략</td></tr><tr><td><strong>시스템 최적화 설계</strong></td><td>캐시 계층 구조, 데이터 지역성, Load Shedding</td><td>병목 완화 및 리소스 관리 효율화를 위한 하드웨어 - 소프트웨어 통합적 최적화 기법</td></tr><tr><td><strong>바이오인포매틱스</strong></td><td>유전체 분석, 단백질 구조 예측, 진화 알고리즘</td><td>생명과학 데이터를 컴퓨팅 기술로 해석하고 응용하는 융합 학문 분야</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>알고리즘</strong></td><td>Algorithm</td><td>문제 해결을 위한 단계적 절차</td></tr><tr><td></td><td>Big-O 표기법 (Big-O Notation)</td><td>알고리즘의 시간·공간 복잡도를 나타내는 수학적 표기법</td></tr><tr><td></td><td>분할 정복 (Divide and Conquer)</td><td>문제를 나누고 병합하여 해결하는 설계 기법</td></tr><tr><td></td><td>동적 프로그래밍 (Dynamic Programming)</td><td>중복 부분 문제의 결과를 저장해 성능 향상하는 기법</td></tr><tr><td></td><td>Timsort</td><td>합병 정렬과 삽입 정렬을 결합한 하이브리드 정렬 알고리즘</td></tr><tr><td><strong>자료구조</strong></td><td>Data Structure</td><td>데이터를 효율적으로 저장·관리하기 위한 구조</td></tr><tr><td></td><td>해시 테이블 (Hash Table)</td><td>키 - 값 기반의 빠른 탐색이 가능한 자료구조</td></tr><tr><td></td><td>힙 (Heap)</td><td>우선순위 큐로 활용되는 완전 이진 트리 구조</td></tr><tr><td></td><td>큐 (Queue)</td><td>선입선출 구조로 비동기 처리에 활용</td></tr><tr><td></td><td>균형 이진 탐색 트리 (Balanced BST)</td><td>트리의 높이를 유지하여 탐색 성능을 일정하게 보장</td></tr><tr><td></td><td>추상 데이터 타입 (ADT)</td><td>자료형과 연산을 논리적으로 정의한 모델</td></tr><tr><td><strong>시스템 아키텍처</strong></td><td>CPU</td><td>명령어 처리와 연산 수행을 담당하는 중앙 처리 장치</td></tr><tr><td></td><td>Memory</td><td>실행 중인 데이터나 명령어를 임시 저장하는 공간</td></tr><tr><td></td><td>Storage</td><td>데이터를 영구 저장하는 장치 (SSD, HDD 등)</td></tr><tr><td></td><td>LRU Cache</td><td>가장 오래 사용되지 않은 항목을 제거하는 캐시 전략</td></tr><tr><td></td><td>파이프라이닝 (Pipelining)</td><td>명령어를 여러 단계로 나누어 병렬 처리하는 기법</td></tr><tr><td></td><td>캐시 메모리 (Cache Memory)</td><td>자주 사용하는 데이터를 임시 저장하여 접근 속도를 높이는 메모리</td></tr><tr><td></td><td>가상 메모리 (Virtual Memory)</td><td>실제 메모리보다 큰 주소 공간을 제공하는 메모리 관리 기법</td></tr><tr><td><strong>운영체제</strong></td><td>운영체제 (Operating System)</td><td>시스템 자원을 관리하고 사용자·프로그램과 하드웨어를 중재</td></tr><tr><td></td><td>컨텍스트 스위칭 (Context Switching)</td><td>CPU 가 실행 중인 프로세스를 전환하는 과정</td></tr><tr><td></td><td>교착 상태 (Deadlock)</td><td>서로 자원을 기다리며 무한 대기하는 상태</td></tr><tr><td></td><td>세마포어 (Semaphore)</td><td>동시성 제어를 위한 공유 자원 접근 제어 도구</td></tr><tr><td><strong>데이터베이스</strong></td><td>SQL</td><td>관계형 데이터베이스 질의 언어</td></tr><tr><td></td><td>인덱스 (Index)</td><td>검색 성능 향상을 위한 데이터베이스 구조</td></tr><tr><td></td><td>정규화 (Normalization)</td><td>중복 제거 및 무결성 확보를 위한 데이터베이스 설계 기법</td></tr><tr><td></td><td>ACID 속성</td><td>트랜잭션의 원자성, 일관성, 격리성, 지속성을 보장하는 특성</td></tr><tr><td><strong>네트워크</strong></td><td>Protocol</td><td>데이터 통신을 위한 규약 및 약속</td></tr><tr><td></td><td>TCP/IP</td><td>인터넷 통신의 기반이 되는 프로토콜 스택</td></tr><tr><td></td><td>OSI 7 계층 모델</td><td>네트워크 통신 과정을 7 개 계층으로 나눈 추상화 모델</td></tr><tr><td></td><td>라우팅 (Routing)</td><td>네트워크에서 최적 경로를 찾아 패킷을 전달하는 과정</td></tr><tr><td><strong>보안</strong></td><td>암호화 (Encryption)</td><td>데이터를 읽을 수 없도록 변환하여 보호하는 기법</td></tr><tr><td></td><td>해시 함수 (Hash Function)</td><td>데이터를 고정된 길이의 값으로 매핑하는 함수</td></tr><tr><td></td><td>디지털 서명 (Digital Signature)</td><td>메시지 무결성과 송신자 인증을 위한 암호학적 기법</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=핵심-학습-자료>핵심 학습 자료<a hidden class=anchor aria-hidden=true href=#핵심-학습-자료>#</a></h3><ul><li><a href=https://teachyourselfcs.com/>Teach Yourself Computer Science</a></li><li><a href=https://code.org/curriculum/csf>Computer Science Fundamentals Curriculum - Code.org</a></li><li><a href=https://www.geeksforgeeks.org/computer-fundamentals-tutorial/>Computer Fundamentals Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/data-structures/>Data Structures Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/fundamentals-of-algorithms/>Algorithms Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/computer-organization-and-architecture-tutorials/>Computer Organization and Architecture Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/operating-systems/>Operating System Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/dbms/>DBMS Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/introduction-of-theory-of-computation/>Introduction to Theory of Computation - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/system-design-tutorial/>System Design Tutorial - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/articles-on-computer-science-subjects-gq/>Computer Science Core Subjects - GeeksforGeeks</a></li><li><a href=https://www.freecodecamp.org/news/what-every-software-engineer-should-know/>What Every Software Engineer Should Know - freeCodeCamp</a></li></ul><h3 id=대학교-및-공식-강좌>대학교 및 공식 강좌<a hidden class=anchor aria-hidden=true href=#대학교-및-공식-강좌>#</a></h3><ul><li><a href=https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/>MIT OpenCourseWare - Introduction to Computer Science</a></li><li><a href=https://engineering-computer-science.wright.edu/computer-science-and-engineering/computer-science-fundamentals-course-cs5160>Computer Science Fundamentals Course - Wright State University</a></li><li><a href=https://web.stanford.edu/class/cs106b/>Stanford - CS 106B Course Materials</a></li><li><a href=https://www.csfieldguide.org.nz/>Computer Science Field Guide (NZ)</a></li></ul><h3 id=백과사전-및-일반-자료>백과사전 및 일반 자료<a hidden class=anchor aria-hidden=true href=#백과사전-및-일반-자료>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Computer_science>Computer science - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Outline_of_computer_science>Outline of computer science - Wikipedia</a></li><li><a href=https://www.britannica.com/science/computer-science>Computer science | Britannica</a></li><li><a href=https://www.bbc.co.uk/bitesize/topics/zv3j382>Principles of computer science - BBC Bitesize</a></li><li><a href=https://www.bbc.co.uk/bitesize/guides/z7qqmsg/revision/1>Common CPU components - BBC</a></li></ul><h3 id=블로그에세이기타-해설>블로그/에세이/기타 해설<a hidden class=anchor aria-hidden=true href=#블로그에세이기타-해설>#</a></h3><ul><li><a href=https://www.opit.com/magazine/computer-architecture/>Computer Architecture Basics and Definitions - OPIT</a></li><li><a href=https://www.opit.com/magazine/what-is-computer-science/>What Is Computer Science - OPIT</a></li><li><a href=https://www.interviewbit.com/blog/system-architecture/>System Architecture - InterviewBit</a></li><li><a href=https://dev.to/buchman/the-fundamentals-of-computer-science-1m08>Computer Science Fundamentals - DEV Community</a></li><li><a href=https://pwskills.com/blog/computer-science-fundamentals/>Computer Science Fundamentals For Beginners - PW Skills</a></li><li><a href=https://spires.co/online-computer-science-tutors/undergraduate/computer-science-fundamentals-essential-concepts-and-approaches>The Fundamentals of Computer Science - Spires</a></li><li><a href=https://www.berlinsbi.com/blog/what-are-the-most-important-concepts-in-fundamentals-of-computer-science>What are the Most Important Concepts in Computer Science - Berlin SBI</a></li></ul><h3 id=공식-문서-및-pdf>공식 문서 및 PDF<a hidden class=anchor aria-hidden=true href=#공식-문서-및-pdf>#</a></h3><ul><li><a href=https://tau.edu.ng/assets/media/docs/principles-of-operating-system-swe210_1716371553.pdf>PRINCIPLES OF OPERATING SYSTEM - PDF (TAU)</a></li><li><a href=https://vardhaman.org/wp-content/uploads/2021/03/CO.pdf>COMPUTER ORGANIZATION AND ARCHITECTURE - PDF (Vardhaman)</a></li><li><a href=https://www.slideshare.net/slideshow/fundamentals-of-computers-and-operating-system-os/269370808>Fundamentals of Computers and Operating System - SlideShare</a></li></ul><h3 id=기타-참조-정보>기타 참조 정보<a hidden class=anchor aria-hidden=true href=#기타-참조-정보>#</a></h3><ul><li><a href=https://opentextbc.ca/computerstudies/chapter/types-of-computers/>Types of Computers - BC Open Textbooks</a></li><li><a href=https://www.vedantu.com/computer-science/classification-of-computer-based-on-size-and-capacity>Classification of Computer Based on Size and Capacity - Vedantu</a></li><li><a href=https://www.opm.gov/policy-data-oversight/classification-qualifications/general-schedule-qualification-standards/1500/computer-science-series-1550/>Computer Science Series 1550 - OPM</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>