<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Paging vs Segmentation | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Memory-Management,Paging,Segmentation"><meta name=description content="Paging과 Segmentation은 운영체제의 메모리 관리 기법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Paging vs Segmentation"><meta property="og:description" content="Paging과 Segmentation은 운영체제의 메모리 관리 기법이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-05T08:24:00+00:00"><meta property="article:modified_time" content="2024-10-05T08:24:00+00:00"><meta property="article:tag" content="Computer-Science-Fundamentals"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Memory-Management"><meta property="article:tag" content="Paging"><meta property="article:tag" content="Segmentation"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Paging vs Segmentation"><meta name=twitter:description content="Paging과 Segmentation은 운영체제의 메모리 관리 기법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/"},{"@type":"ListItem","position":4,"name":"Memory Management","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/"},{"@type":"ListItem","position":5,"name":"Paging vs Segmentation","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Paging vs Segmentation","name":"Paging vs Segmentation","description":"Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.","keywords":["Computer-Science-Fundamentals","Operating-systems","Memory-Management","Paging","Segmentation"],"articleBody":"Paging vs. Segmentation Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.\nPaging:\n프로세스의 주소 공간을 고정 크기의 페이지로 나누어 관리한다. 물리적 메모리를 같은 크기의 프레임으로 나눈다. 외부 단편화 문제를 해결하고 메모리 할당을 단순화한다. Segmentation:\n프로세스를 논리적 단위인 세그먼트로 나누어 관리한다. 각 세그먼트의 크기는 가변적이다. 프로그램의 논리적 구조를 반영하여 메모리를 관리한다. Paging과 Segmentation 비교 특성 Paging Segmentation 분할 단위 고정 크기 페이지 가변 크기 세그먼트 주소 변환 페이지 테이블 사용 세그먼트 테이블 사용 외부 단편화 없음 발생 가능 내부 단편화 발생 가능 거의 없음 메모리 활용 효율적 유연함 구현 복잡도 상대적으로 간단 복잡함 공유와 보호 페이지 단위 세그먼트 단위 사용자 관점 투명함 프로그램 구조 반영 할당/해제 속도 빠름 상대적으로 느림 테이블 크기 큼 작음 참고 및 출처 ","wordCount":"114","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-05T08:24:00Z","dateModified":"2024-10-05T08:24:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/>Operating System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/>Memory Management</a></div><h1 class="post-title entry-hint-parent">Paging vs Segmentation</h1><div class=post-description>Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.</div><div class=post-meta><span title='2024-10-05 08:24:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Operating%20systems/Memory%20Management/Paging-vs-Segmentation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#paging-vs-segmentation>Paging vs. Segmentation</a><ul><li><a href=#paging과-segmentation-비교>Paging과 Segmentation 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=paging-vs-segmentation>Paging vs. Segmentation<a hidden class=anchor aria-hidden=true href=#paging-vs-segmentation>#</a></h2><p>Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.</p><p>Paging:</p><ul><li>프로세스의 주소 공간을 고정 크기의 페이지로 나누어 관리한다.</li><li>물리적 메모리를 같은 크기의 프레임으로 나눈다.</li><li>외부 단편화 문제를 해결하고 메모리 할당을 단순화한다.</li></ul><p>Segmentation:</p><ul><li>프로세스를 논리적 단위인 세그먼트로 나누어 관리한다.</li><li>각 세그먼트의 크기는 가변적이다.</li><li>프로그램의 논리적 구조를 반영하여 메모리를 관리한다.</li></ul><h3 id=paging과-segmentation-비교>Paging과 Segmentation 비교<a hidden class=anchor aria-hidden=true href=#paging과-segmentation-비교>#</a></h3><table><thead><tr><th>특성</th><th>Paging</th><th>Segmentation</th></tr></thead><tbody><tr><td>분할 단위</td><td>고정 크기 페이지</td><td>가변 크기 세그먼트</td></tr><tr><td>주소 변환</td><td>페이지 테이블 사용</td><td>세그먼트 테이블 사용</td></tr><tr><td>외부 단편화</td><td>없음</td><td>발생 가능</td></tr><tr><td>내부 단편화</td><td>발생 가능</td><td>거의 없음</td></tr><tr><td>메모리 활용</td><td>효율적</td><td>유연함</td></tr><tr><td>구현 복잡도</td><td>상대적으로 간단</td><td>복잡함</td></tr><tr><td>공유와 보호</td><td>페이지 단위</td><td>세그먼트 단위</td></tr><tr><td>사용자 관점</td><td>투명함</td><td>프로그램 구조 반영</td></tr><tr><td>할당/해제 속도</td><td>빠름</td><td>상대적으로 느림</td></tr><tr><td>테이블 크기</td><td>큼</td><td>작음</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science-fundamentals/>Computer-Science-Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://buenhyden.github.io/tags/memory-management/>Memory-Management</a></li><li><a href=https://buenhyden.github.io/tags/paging/>Paging</a></li><li><a href=https://buenhyden.github.io/tags/segmentation/>Segmentation</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/system-integration-and-messaging/event-and-message-brokers/messaging-systems/event-streaming-platforms/kafka/kafka-vs-rabbitmq/><span class=title>« Prev</span><br><span>Kafka vs RabbitMQ</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback-vs-promise-vs-async-await/><span class=title>Next »</span><br><span>Callback vs Promise vs Async/Await</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>