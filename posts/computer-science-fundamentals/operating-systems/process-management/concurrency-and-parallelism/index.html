<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency and Parallelism | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,System-Execution-Models,Concurrency,Parallelism"><meta name=description content="동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concurrency and Parallelism"><meta property="og:description" content="동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concurrency and Parallelism"><meta name=twitter:description content="동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/"},{"@type":"ListItem","position":4,"name":"Concurrency and Parallelism","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>컴퓨터 과학</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/>Operating System</a></div><h1>Concurrency and Parallelism</h1><div class=post-description>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다. 동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.</div></header><div class=post-content><h2 id=동시성-concurrency-vs-병렬성-parallelism>동시성 (Concurrency) vs. 병렬성 (Parallelism)<a hidden class=anchor aria-hidden=true href=#동시성-concurrency-vs-병렬성-parallelism>#</a></h2><p>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.<br>동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.<br>실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.</p><p><figure><img alt="Concurrent vs Parallel" loading=lazy src=/img/8e925d68-4f47-4ef9-8d51-6a39f19c75d2.jpg><figcaption>Source: &lt;https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism</figcaption></figure></p><p>동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.<br>이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 &ldquo;컨텍스트 스위칭(Context Switching)&ldquo;이라고 한다.</p><p>병렬성(Parallelism)은 여러 작업을 실제로 동시에 처리하는 개념으로, 여러 코어나 프로세서가 필요하며, 실제로 동시에 실행된다. 이로 인해 전체적인 처리 속도를 향상시킬 수 있다.<br>이러한 작업들은 여러 코어나 프로세서가 각각 독립적인 작업을 동시에 처리하며 각 작업은 서로 다른 하드웨어 자원을 사용한다.</p><h3 id=동시성concurrency과-병렬성parallelism-비교>동시성(Concurrency)과 병렬성(Parallelism) 비교<a hidden class=anchor aria-hidden=true href=#동시성concurrency과-병렬성parallelism-비교>#</a></h3><table><thead><tr><th>특성</th><th>동시성 (Concurrency)</th><th>병렬성 (Parallelism)</th></tr></thead><tbody><tr><td>정의</td><td>여러 작업을 번갈아가며 실행하여 동시에 처리되는 것처럼 보이게 함</td><td>여러 작업을 실제로 동시에 처리함</td></tr><tr><td>실행 방식</td><td>작업 간 빠른 전환 (Context Switching)</td><td>실제 동시 실행</td></tr><tr><td>하드웨어 요구사항</td><td>단일 코어로도 가능</td><td>다중 코어 또는 프로세서 필요</td></tr><tr><td>목적</td><td>응답성 향상, 자원 효율성 증대</td><td>전체 처리 속도 향상</td></tr><tr><td>성능 특성</td><td>I/O 대기 시간 최소화</td><td>CPU 처리량 최대화</td></tr><tr><td>복잡성</td><td>작업 간 전환과 자원 공유로 인해 복잡할 수 있음</td><td>작업 분할과 결과 통합 과정이 필요</td></tr><tr><td>적용 사례</td><td>웹 서버, 사용자 인터페이스, 멀티태스킹 OS</td><td>대규모 데이터 처리, 과학 계산, 그래픽 렌더링</td></tr><tr><td>구현 방법</td><td>멀티스레딩, 비동기 프로그래밍</td><td>멀티프로세싱, GPU 병렬 처리</td></tr><tr><td>자원 관리</td><td>자원 공유와 동기화 필요</td><td>각 작업이 독립적인 자원 사용</td></tr><tr><td>자원 공유</td><td>쉬움 (공유 메모리)</td><td>어려움 (프로세스 간 통신 필요)</td></tr><tr><td>리소스 효율성</td><td>대기 시간 활용으로 효율적</td><td>CPU 자원 최대 활용</td></tr><tr><td>메모리 사용</td><td>공유 메모리 사용</td><td>독립적인 메모리 공간</td></tr><tr><td>적합한 작업</td><td>I/O 바운드 작업<br>(파일, 네트워크, DB 작업)</td><td>CPU 바운드 작업<br>(복잡한 계산, 데이터 처리)</td></tr><tr><td>확장성</td><td>단일 시스템 내에서 제한적<br>I/O 작업에 대해 좋은 확장성</td><td>여러 시스템으로 확장 가능<br>CPU 코어 수에 비례하여 확장</td></tr><tr><td>성능 향상</td><td>응답 시간 개선에 중점</td><td>처리량 증가에 중점</td></tr><tr><td>에러 처리</td><td>상대적으로 단순</td><td>복잡한 동기화 필요</td></tr><tr><td>디버깅 난이도</td><td>상대적으로 어려움 (타이밍 이슈)</td><td>매우 어려움 (동시성 문제 + 분산 시스템 이슈)</td></tr><tr><td>프로그래밍 모델</td><td>이벤트 기반, 콜백, Promises 등</td><td>MapReduce, 데이터 병렬화 등</td></tr></tbody></table><h4 id=선택-기준표>선택 기준표<a hidden class=anchor aria-hidden=true href=#선택-기준표>#</a></h4><table><thead><tr><th>상황</th><th>권장 방식</th><th>이유</th></tr></thead><tbody><tr><td>웹 서버 개발</td><td>동시성</td><td>대부분 I/O 작업 위주</td></tr><tr><td>이미지 처리</td><td>병렬성</td><td>CPU 집약적 작업</td></tr><tr><td>사용자 인터페이스</td><td>동시성</td><td>반응성 향상 필요</td></tr><tr><td>대규모 데이터 분석</td><td>병렬성</td><td>독립적인 데이터 처리 가능</td></tr><tr><td>실시간 스트리밍</td><td>동시성</td><td>지속적인 I/O 처리 필요</td></tr><tr><td>과학적 계산</td><td>병렬성</td><td>복잡한 계산 작업 분할 가능</td></tr></tbody></table><h4 id=성능-비교표>성능 비교표<a hidden class=anchor aria-hidden=true href=#성능-비교표>#</a></h4><table><thead><tr><th>작업 유형</th><th>동시성 성능</th><th>병렬성 성능</th></tr></thead><tbody><tr><td>I/O 작업</td><td>매우 좋음</td><td>보통</td></tr><tr><td>CPU 작업</td><td>보통</td><td>매우 좋음</td></tr><tr><td>메모리 사용</td><td>효율적</td><td>많은 사용</td></tr><tr><td>응답 시간</td><td>일관적</td><td>변동 가능</td></tr><tr><td>처리량</td><td>중간</td><td>높음</td></tr><tr><td>자원 활용</td><td>효율적</td><td>최대화</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>임계 영역 (Critical Section)</h2></header><div class=entry-content><p>임계 영역 (Critical Section) 운영체제에서 임계 영역(Critical Section)은 여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역을 말한다.
이는 병렬 컴퓨팅 환경에서 중요한 개념으로, 데이터의 일관성과 무결성을 보장하기 위해 사용된다.
여러 프로세스가 동시에 임계 영역에 진입하면 데이터의 일관성이 깨질 수 있다.
1 2 3 4 5 6 7 8 9 10 # 임계 영역 예시 balance = 1000 # 공유 자원 def withdraw(amount): global balance # 임계 영역 시작 temp = balance temp = temp - amount balance = temp # 임계 영역 종료 임계 영역 문제의 해결 조건 상호 배제(Mutual Exclusion): 한 프로세스가 임계 영역에 있을 때 다른 프로세스는 진입할 수 없다. 진행(Progress): 임계 영역에 있는 프로세스가 없다면, 진입하려는 프로세스가 들어갈 수 있어야 한다. 한정된 대기(Bounded Waiting): 프로세스의 임계 영역 진입은 무한정 연기되어서는 안 된다. 임계 영역 관련 문제와 해결 방법 구분 데드락(Deadlock) 경쟁 상태(Race Condition) 기아 상태(Starvation) 라이브락(Livelock) 정의 두 개 이상의 프로세스가 서로의 자원을 기다리며 영구적으로 블록된 상태 여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상태 특정 프로세스가 필요한 자원을 계속 할당받지 못하는 상태 프로세스들이 서로에게 응답하며 상태는 변하지만 실제 진행은 없는 상태 발생 원인 상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시 충족 공유 자원에 대한 동시 접근, 원자성 결여 부적절한 자원 할당 정책, 우선순위 역전 현상 프로세스들의 과도한 양보, 재귀적 회피 동작 결과 시스템 전체 또는 일부 프로세스의 완전한 정지 데이터 불일치, 예측 불가능한 결과 특정 프로세스의 실행 지연 또는 무한 대기 CPU 자원 소비, 실제 작업 진행 없음 특징 프로세스들이 움직이지 않고 완전히 멈춤 타이밍에 따라 결과가 비결정적 자원 할당의 불공정성 프로세스들이 활발히 상태 변경 해결 방법 프로세스 강제 종료, 자원 선점, 데드락 발생 조건 제거 동기화 메커니즘 사용(뮤텍스, 세마포어 등) 에이징(Aging) 기법 도입, 공정한 스케줄링 무작위 대기 시간 도입, 우선순위 조정 예방 기법 자원 할당 그래프 사용, 자원 순서화, 타임아웃 설정 임계 영역 설정, 원자적 연산 사용 자원 예약 시스템, 우선순위 조정 메커니즘 타임아웃 설정, 재시도 횟수 제한 탐지 방법 자원 할당 그래프 분석, 대기 사이클 검출 데이터 일관성 검사, 로그 분석 자원 할당 통계 모니터링 CPU 사용률 분석, 진행률 모니터링 영향 범위 전체 시스템 또는 관련 프로세스 그룹 공유 자원을 사용하는 프로세스들 특정 프로세스 또는 프로세스 그룹 상호 작용하는 프로세스 그룹 복구 방법 프로세스 재시작, 시스템 재부팅 트랜잭션 롤백, 상태 복원 우선순위 재조정, 자원 재할당 프로세스 재시작 또는 동작 패턴 변경 모니터링 방법 시스템 자원 모니터링, 프로세스 상태 감시 로그 분석, 데이터 정합성 검사 자원 할당 히스토리 분석 CPU 사용률 추적, 진행 상태 모니터링 해결 방법 상호 배제(Mutual Exclusion) 구현:
...</p></div><footer class=entry-footer><span title='2024-10-03 07:49:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 임계 영역 (Critical Section)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/critical-section/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>