<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm) | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,Concurrency-and-Parallelism,Synchronization,Mutual-Exclusion"><meta name=description content="N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)"><meta property="og:description" content="N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-03T10:47:00+00:00"><meta property="article:modified_time" content="2024-10-03T10:47:00+00:00"><meta property="article:tag" content="Computer-Science-Fundamentals"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Process-Management"><meta property="article:tag" content="Concurrency-and-Parallelism"><meta property="article:tag" content="Synchronization"><meta property="article:tag" content="Mutual-Exclusion"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)"><meta name=twitter:description content="N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)","name":"램포트의 빵집 알고리즘 (Lamport\u0027s Bakery Algorithm)","description":"N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다","keywords":["Computer-Science-Fundamentals","Operating-systems","Process-Management","Concurrency-and-Parallelism","Synchronization","Mutual-Exclusion"],"articleBody":"램포트의 빵집 알고리즘 (Lamport’s Bakery Algorithm) 램포트의 빵집 알고리즘(Lamport’s Bakery Algorithm)은 N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.\n램포트의 빵집 알고리즘은 병행 프로그래밍의 이론적 토대를 제공했지만, 현대 시스템에서는 주로 하드웨어 지원 동기화 기법이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.\n핵심 원리 번호표 시스템 각 프로세스는 임계 영역 진입 전 고유한 번호표를 받는다. 번호표는 단조 증가(monotonically increasing) 방식으로 발급되며, 동시 접근 시 프로세스 ID로 우선순위 결정한다. 단조 증가(monotonically increasing)란 함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질을 의미한다. 즉, 감소하는 구간 없이 유지되거나 증가하는 경우를 말한다.\n동작 단계 번호표 선택\n1 2 3 choosing[i] = True number[i] = max(number[0], ..., number[n-1]) + 1 choosing[i] = False 프로세스 i가 번호표를 선택할 동안 다른 프로세스가 방해하지 못하도록 choosing[i] 플래그 사용. 대기 조건\n1 2 3 4 for 모든 프로세스 j ≠ i: while choosing[j]: pass # j가 번호표 선택 중이면 대기 while (number[j] != 0) and ((number[j], j) \u003c (number[i], i)): pass # 더 낮은 번호표 또는 동일 시 낮은 ID 대기 모든 프로세스의 번호표와 ID를 비교해 자신의 차례까지 대기. 임계 영역 실행\n1 2 # Critical Section 실행 print(f\"프로세스 {i}가 임계 영역 실행 중\") 종료 및 초기화\n1 number[i] = 0 # 번호표 반납 실행 완료 후 번호표를 0으로 재설정해 다른 프로세스가 진입 가능하게 함. 특징 분석 장점 단점 - N개 프로세스 지원 - Busy Waiting으로 CPU 자원 낭비 - 기아 현상(starvation) 방지 - 높은 메모리 오버헤드(각 프로세스 상태 추적) - 하드웨어 지원 불필요 - 현대 CPU의 메모리 재배치 최적화 시 동작 실패 가능 - FIFO 공정성 보장 - 복잡한 구현으로 인한 버그 발생 가능성 높음 실제 구현 사례 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Python 구현 예시 (3개 스레드) import threading choosing = [False] * 3 number = [0] * 3 def bakery_algorithm(thread_id): global choosing, number # 번호표 선택 choosing[thread_id] = True number[thread_id] = max(number) + 1 choosing[thread_id] = False # 대기 조건 검사 for i in range(3): if i == thread_id: continue while choosing[i]: pass while number[i] != 0 and (number[i], i) \u003c (number[thread_id], thread_id): pass # 임계 영역 실행 print(f\"스레드 {thread_id} 임계 영역 진입\") number[thread_id] = 0 # 초기화 # 스레드 생성 및 실행 threads = [threading.Thread(target=bakery_algorithm, args=(i,)) for i in range(3)] for t in threads: t.start() for t in threads: t.join() 실행 결과:\n스레드 0 임계 영역 진입 → 스레드 1 임계 영역 진입 → 스레드 2 임계 영역 진입\n(실제 실행 시 번호표 순서에 따라 출력 순서 변동) 현대 시스템에서의 활용 Linux 커널: ticket spinlock으로 구현되어 스핀락 경쟁 시 공정성 보장. 분산 시스템: 공유 메모리가 없는 환경에서 타임스탬프 기반 동기화에 응용. 교육용: 상호 배제 개념을 이해하기 위한 표준 예제로 사용. 한계와 개선 방향 Atomic Operation 도입: CAS(Compare-And-Swap) 명령어를 활용해 Busy Waiting 감소. 하이브리드 접근: 세마포어와 결합해 대기 큐를 사용하는 방식으로 전환. 최적화 대응: 메모리 배리어(Memory Barrier) 추가로 CPU 최적화 우회. 참고 및 출처 ","wordCount":"507","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-03T10:47:00Z","dateModified":"2024-10-03T10:47:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)</h1><div class=post-description>N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다</div><div class=post-meta><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Operating%20systems/Process%20Management/Concurrency%20and%20Parallelism/Synchronization/Mutual%20Exclusion/Lamport%27s-Bakery-Algorithm.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#램포트의-빵집-알고리즘-lamports-bakery-algorithm>램포트의 빵집 알고리즘 (Lamport&rsquo;s Bakery Algorithm)</a><ul><li><a href=#핵심-원리><strong>핵심 원리</strong></a></li><li><a href=#특징-분석><strong>특징 분석</strong></a></li><li><a href=#실제-구현-사례><strong>실제 구현 사례</strong></a></li><li><a href=#현대-시스템에서의-활용><strong>현대 시스템에서의 활용</strong></a></li><li><a href=#한계와-개선-방향><strong>한계와 개선 방향</strong></a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=램포트의-빵집-알고리즘-lamports-bakery-algorithm>램포트의 빵집 알고리즘 (Lamport&rsquo;s Bakery Algorithm)<a hidden class=anchor aria-hidden=true href=#램포트의-빵집-알고리즘-lamports-bakery-algorithm>#</a></h2><p>램포트의 빵집 알고리즘(Lamport&rsquo;s Bakery Algorithm)은 <strong>N개 프로세스의 상호 배제(Mutual Exclusion)</strong> 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.</p><p>램포트의 빵집 알고리즘은 <strong>병행 프로그래밍의 이론적 토대</strong>를 제공했지만, 현대 시스템에서는 주로 <strong>하드웨어 지원 동기화 기법</strong>이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.</p><h3 id=핵심-원리><strong>핵심 원리</strong><a hidden class=anchor aria-hidden=true href=#핵심-원리>#</a></h3><h4 id=번호표-시스템>번호표 시스템<a hidden class=anchor aria-hidden=true href=#번호표-시스템>#</a></h4><ul><li>각 프로세스는 임계 영역 진입 전 <strong>고유한 번호표</strong>를 받는다.</li><li>번호표는 <strong>단조 증가(monotonically increasing)</strong> 방식으로 발급되며, 동시 접근 시 <strong>프로세스 ID</strong>로 우선순위 결정한다.</li></ul><blockquote><p>단조 증가(monotonically increasing)란 <strong>함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질</strong>을 의미한다. 즉, <strong>감소하는 구간 없이 유지되거나 증가</strong>하는 경우를 말한다.</p></blockquote><h4 id=동작-단계>동작 단계<a hidden class=anchor aria-hidden=true href=#동작-단계>#</a></h4><ol><li><p>번호표 선택</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>choosing</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl><span class=n>number</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>number</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>...</span><span class=p>,</span> <span class=n>number</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>choosing</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>False</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>프로세스 <code>i</code>가 번호표를 선택할 동안 다른 프로세스가 방해하지 못하도록 <code>choosing[i]</code> 플래그 사용.</li></ul></li><li><p>대기 조건</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>for</span> <span class=n>모든</span> <span class=n>프로세스</span> <span class=n>j</span> <span class=err>≠</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>choosing</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span> <span class=k>pass</span>  <span class=c1># j가 번호표 선택 중이면 대기</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>number</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=ow>and</span> <span class=p>((</span><span class=n>number</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>j</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>number</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)):</span> 
</span></span><span class=line><span class=cl>        <span class=k>pass</span>  <span class=c1># 더 낮은 번호표 또는 동일 시 낮은 ID 대기</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>모든 프로세스의 번호표와 ID를 비교해 자신의 차례까지 대기.</li></ul></li><li><p>임계 영역 실행</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Critical Section 실행</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;프로세스 </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>가 임계 영역 실행 중&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>종료 및 초기화</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>number</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 번호표 반납</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>실행 완료 후 번호표를 0으로 재설정해 다른 프로세스가 진입 가능하게 함.</li></ul></li></ol><h3 id=특징-분석><strong>특징 분석</strong><a hidden class=anchor aria-hidden=true href=#특징-분석>#</a></h3><table><thead><tr><th><strong>장점</strong></th><th><strong>단점</strong></th></tr></thead><tbody><tr><td>- <strong>N개 프로세스</strong> 지원</td><td>- <strong>Busy Waiting</strong>으로 CPU 자원 낭비</td></tr><tr><td>- <strong>기아 현상(starvation) 방지</strong></td><td>- 높은 메모리 오버헤드(각 프로세스 상태 추적)</td></tr><tr><td>- 하드웨어 지원 불필요</td><td>- 현대 CPU의 메모리 재배치 최적화 시 동작 실패 가능</td></tr><tr><td>- FIFO 공정성 보장</td><td>- 복잡한 구현으로 인한 버그 발생 가능성 높음</td></tr></tbody></table><h3 id=실제-구현-사례><strong>실제 구현 사례</strong><a hidden class=anchor aria-hidden=true href=#실제-구현-사례>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python 구현 예시 (3개 스레드)</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>choosing</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=n>number</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bakery_algorithm</span><span class=p>(</span><span class=n>thread_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>choosing</span><span class=p>,</span> <span class=n>number</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 번호표 선택</span>
</span></span><span class=line><span class=cl>    <span class=n>choosing</span><span class=p>[</span><span class=n>thread_id</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=n>number</span><span class=p>[</span><span class=n>thread_id</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>number</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>choosing</span><span class=p>[</span><span class=n>thread_id</span><span class=p>]</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 대기 조건 검사</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=n>thread_id</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>choosing</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>pass</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>number</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=p>(</span><span class=n>number</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>number</span><span class=p>[</span><span class=n>thread_id</span><span class=p>],</span> <span class=n>thread_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>pass</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 임계 영역 실행</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;스레드 </span><span class=si>{</span><span class=n>thread_id</span><span class=si>}</span><span class=s2> 임계 영역 진입&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>number</span><span class=p>[</span><span class=n>thread_id</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 초기화</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 스레드 생성 및 실행</span>
</span></span><span class=line><span class=cl><span class=n>threads</span> <span class=o>=</span> <span class=p>[</span><span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>bakery_algorithm</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>i</span><span class=p>,))</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>실행 결과</strong>:<br><code>스레드 0 임계 영역 진입</code> → <code>스레드 1 임계 영역 진입</code> → <code>스레드 2 임계 영역 진입</code><br>(실제 실행 시 번호표 순서에 따라 출력 순서 변동)</li></ul><h3 id=현대-시스템에서의-활용><strong>현대 시스템에서의 활용</strong><a hidden class=anchor aria-hidden=true href=#현대-시스템에서의-활용>#</a></h3><ul><li><strong>Linux 커널</strong>: <code>ticket spinlock</code>으로 구현되어 스핀락 경쟁 시 공정성 보장.</li><li><strong>분산 시스템</strong>: 공유 메모리가 없는 환경에서 타임스탬프 기반 동기화에 응용.</li><li><strong>교육용</strong>: 상호 배제 개념을 이해하기 위한 표준 예제로 사용.</li></ul><h3 id=한계와-개선-방향><strong>한계와 개선 방향</strong><a hidden class=anchor aria-hidden=true href=#한계와-개선-방향>#</a></h3><ul><li><strong>Atomic Operation 도입</strong>: <code>CAS(Compare-And-Swap)</code> 명령어를 활용해 Busy Waiting 감소.</li><li><strong>하이브리드 접근</strong>: 세마포어와 결합해 대기 큐를 사용하는 방식으로 전환.</li><li><strong>최적화 대응</strong>: 메모리 배리어(Memory Barrier) 추가로 CPU 최적화 우회.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science-fundamentals/>Computer-Science-Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://buenhyden.github.io/tags/process-management/>Process-Management</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-and-parallelism/>Concurrency-and-Parallelism</a></li><li><a href=https://buenhyden.github.io/tags/synchronization/>Synchronization</a></li><li><a href=https://buenhyden.github.io/tags/mutual-exclusion/>Mutual-Exclusion</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/dekkers-algorithm/><span class=title>« Prev</span><br><span>데커 알고리즘 (Dekker's Algorithm)</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/petersons-algorithm/><span class=title>Next »</span><br><span>피터슨 알고리즘 (Peterson's Algorithm)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>