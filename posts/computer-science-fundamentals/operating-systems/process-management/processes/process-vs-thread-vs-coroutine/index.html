<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process vs Thread vs Coroutine | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,Processes,Process,Thread,Coroutine"><meta name=description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Process vs Thread vs Coroutine"><meta property="og:description" content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-06T08:30:00+00:00"><meta property="article:modified_time" content="2024-10-06T08:30:00+00:00"><meta property="article:tag" content="Computer-Science-Fundamentals"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Process-Management"><meta property="article:tag" content="Processes"><meta property="article:tag" content="Process"><meta property="article:tag" content="Thread"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Process vs Thread vs Coroutine"><meta name=twitter:description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Process vs Thread vs Coroutine","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Process vs Thread vs Coroutine","name":"Process vs Thread vs Coroutine","description":"Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.","keywords":["Computer-Science-Fundamentals","Operating-systems","Process-Management","Processes","Process","Thread","Coroutine"],"articleBody":"Process vs. Thread vs. Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.\nProcess:\n독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:\n프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:\n경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:\nCPU \u003e Core \u003e Process \u003e Thread \u003e Coroutine\n프로세스는 독립적인 메모리 공간을 가지며, 하나 이상의 스레드를 포함한다. 스레드는 프로세스 내에서 실행되며, 같은 프로세스의 메모리를 공유한다. 코루틴은 스레드 내에서 실행되는 더 가벼운 실행 단위이다.\n이 구조는 각 단위의 특성과 리소스 사용을 잘 보여준다.\n프로세스가 가장 무겁고, 코루틴이 가장 가벼운 실행 단위이다. https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-6-coroutine-9eecdbeb2d2d\nProcess vs. Thread vs. Coroutine 비교 특성 Process Thread Coroutine 정의 독립적인 실행 단위로 자체 메모리 공간 보유 프로세스 내의 실행 단위로 메모리 공유 협력적 멀티태스킹을 위한 서브루틴 메모리 공유 독립적인 메모리 공간 같은 프로세스의 메모리 공유 같은 스레드의 메모리 공유 컨텍스트 스위칭 비용 매우 높음 중간 매우 낮음 생성/소멸 비용 높음 중간 낮음 자원 사용 많음 중간 적음 통신 방식 IPC (파이프, 소켓 등) 공유 메모리, 뮤텍스 yield/await 병렬 처리 실제 병렬 처리 가능 실제 병렬 처리 가능 동시성만 제공 (병렬x) 적합한 작업 CPU 집약적 작업 I/O + CPU 혼합 작업 I/O 집약적 작업 에러 영향 다른 프로세스에 영향 없음 같은 프로세스의 스레드들에 영향 명시적 에러 처리 필요 디버깅 난이도 쉬움 어려움 중간 확장성 높음 (여러 CPU 코어) 중간 단일 스레드 내 제한 메모리 격리 완전 격리 부분 공유 공유 실행 모델 비교 실행 모델 Process Thread Coroutine 스케줄링 주체 OS OS 프로그램 선점 여부 선점형 선점형 비선점형 컨텍스트 스위치 OS 레벨 OS 레벨 사용자 레벨 동시성 모델 진정한 병렬성 진정한 병렬성 협력적 멀티태스킹 리소스 사용 비교 리소스 Process Thread Coroutine 메모리 사용량 높음 (독립 메모리) 중간 (공유 메모리) 낮음 (최소 오버헤드) CPU 사용 높음 중간 낮음 시스템 리소스 많음 중간 적음 스택 크기 독립적 독립적 공유 성능 특성 비교 성능 특성 Process Thread Coroutine 생성 시간 느림 중간 빠름 컨텍스트 스위치 시간 느림 중간 빠름 메모리 접근 독립적 (느림) 공유 (빠름) 공유 (매우 빠름) 확장성 한계 CPU 코어 수 시스템 리소스 이벤트 루프 성능 사용 사례별 비교 사용 사례 적합한 모델 이유 대규모 데이터 처리 Process 메모리 격리와 CPU 활용 웹 서버 Thread/Coroutine I/O 작업 처리에 효율적 실시간 게임 Thread 낮은 지연시간 필요 GUI 애플리케이션 Thread 사용자 인터페이스 반응성 네트워크 서비스 Coroutine 많은 동시 연결 처리 이미지/비디오 처리 Process CPU 집약적 작업 참고 및 출처 ","wordCount":"435","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-06T08:30:00Z","dateModified":"2024-10-06T08:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Process vs Thread vs Coroutine</h1><div class=post-description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</div><div class=post-meta><span title='2024-10-06 08:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Operating%20systems/Process%20Management/Processes/Process-vs-Thread-vs-Coroutine.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#process-vs-thread-vs-coroutine>Process vs. Thread vs. Coroutine</a><ul><li><a href=#process-vs-thread-vs-coroutine-비교>Process vs. Thread vs. Coroutine 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=process-vs-thread-vs-coroutine>Process vs. Thread vs. Coroutine<a hidden class=anchor aria-hidden=true href=#process-vs-thread-vs-coroutine>#</a></h2><p>Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.</p><ol><li><p>Process:</p><ul><li>독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다.</li><li>다른 프로세스와 완전히 격리되어 있어 안정성이 높다.</li><li>생성과 전환에 많은 비용이 든다.</li></ul></li><li><p>Thread:</p><ul><li>프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다.</li><li>프로세스보다 가볍고, 생성과 전환 비용이 적다.</li><li>동시성을 제공하지만, 동기화 문제에 주의해야 한다.</li></ul></li><li><p>Coroutine:</p><ul><li>경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위.</li><li>매우 가볍고, 생성과 전환 비용이 매우 적다.</li><li>비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다.</li></ul></li></ol><p>Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:<br><code>CPU > Core > Process > Thread > Coroutine</code></p><ul><li>프로세스는 독립적인 메모리 공간을 가지며, 하나 이상의 스레드를 포함한다.</li><li>스레드는 프로세스 내에서 실행되며, 같은 프로세스의 메모리를 공유한다.</li><li>코루틴은 스레드 내에서 실행되는 더 가벼운 실행 단위이다.<br>이 구조는 각 단위의 특성과 리소스 사용을 잘 보여준다.<br>프로세스가 가장 무겁고, 코루틴이 가장 가벼운 실행 단위이다.</li></ul><p><figure><img alt="Coroutine in User-level Thread" loading=lazy src=/img/1_AD4ZqhM1MgNe-npYcrkWzQ.webp><figcaption>https://choi-geonu.medium.com/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%B4-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%A0-%EB%8F%99%EC%8B%9C%EC%84%B1-6-coroutine-9eecdbeb2d2d</figcaption></figure></p><h3 id=process-vs-thread-vs-coroutine-비교>Process vs. Thread vs. Coroutine 비교<a hidden class=anchor aria-hidden=true href=#process-vs-thread-vs-coroutine-비교>#</a></h3><table><thead><tr><th>특성</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>독립적인 실행 단위로 자체 메모리 공간 보유</td><td>프로세스 내의 실행 단위로 메모리 공유</td><td>협력적 멀티태스킹을 위한 서브루틴</td></tr><tr><td><strong>메모리 공유</strong></td><td>독립적인 메모리 공간</td><td>같은 프로세스의 메모리 공유</td><td>같은 스레드의 메모리 공유</td></tr><tr><td><strong>컨텍스트 스위칭 비용</strong></td><td>매우 높음</td><td>중간</td><td>매우 낮음</td></tr><tr><td><strong>생성/소멸 비용</strong></td><td>높음</td><td>중간</td><td>낮음</td></tr><tr><td><strong>자원 사용</strong></td><td>많음</td><td>중간</td><td>적음</td></tr><tr><td><strong>통신 방식</strong></td><td>IPC (파이프, 소켓 등)</td><td>공유 메모리, 뮤텍스</td><td>yield/await</td></tr><tr><td><strong>병렬 처리</strong></td><td>실제 병렬 처리 가능</td><td>실제 병렬 처리 가능</td><td>동시성만 제공 (병렬x)</td></tr><tr><td><strong>적합한 작업</strong></td><td>CPU 집약적 작업</td><td>I/O + CPU 혼합 작업</td><td>I/O 집약적 작업</td></tr><tr><td><strong>에러 영향</strong></td><td>다른 프로세스에 영향 없음</td><td>같은 프로세스의 스레드들에 영향</td><td>명시적 에러 처리 필요</td></tr><tr><td><strong>디버깅 난이도</strong></td><td>쉬움</td><td>어려움</td><td>중간</td></tr><tr><td><strong>확장성</strong></td><td>높음 (여러 CPU 코어)</td><td>중간</td><td>단일 스레드 내 제한</td></tr><tr><td><strong>메모리 격리</strong></td><td>완전 격리</td><td>부분 공유</td><td>공유</td></tr></tbody></table><h4 id=실행-모델-비교>실행 모델 비교<a hidden class=anchor aria-hidden=true href=#실행-모델-비교>#</a></h4><table><thead><tr><th>실행 모델</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>스케줄링 주체</strong></td><td>OS</td><td>OS</td><td>프로그램</td></tr><tr><td><strong>선점 여부</strong></td><td>선점형</td><td>선점형</td><td>비선점형</td></tr><tr><td><strong>컨텍스트 스위치</strong></td><td>OS 레벨</td><td>OS 레벨</td><td>사용자 레벨</td></tr><tr><td><strong>동시성 모델</strong></td><td>진정한 병렬성</td><td>진정한 병렬성</td><td>협력적 멀티태스킹</td></tr></tbody></table><h4 id=리소스-사용-비교>리소스 사용 비교<a hidden class=anchor aria-hidden=true href=#리소스-사용-비교>#</a></h4><table><thead><tr><th>리소스</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>메모리 사용량</strong></td><td>높음 (독립 메모리)</td><td>중간 (공유 메모리)</td><td>낮음 (최소 오버헤드)</td></tr><tr><td><strong>CPU 사용</strong></td><td>높음</td><td>중간</td><td>낮음</td></tr><tr><td><strong>시스템 리소스</strong></td><td>많음</td><td>중간</td><td>적음</td></tr><tr><td><strong>스택 크기</strong></td><td>독립적</td><td>독립적</td><td>공유</td></tr></tbody></table><h4 id=성능-특성-비교>성능 특성 비교<a hidden class=anchor aria-hidden=true href=#성능-특성-비교>#</a></h4><table><thead><tr><th>성능 특성</th><th>Process</th><th>Thread</th><th>Coroutine</th></tr></thead><tbody><tr><td><strong>생성 시간</strong></td><td>느림</td><td>중간</td><td>빠름</td></tr><tr><td><strong>컨텍스트 스위치 시간</strong></td><td>느림</td><td>중간</td><td>빠름</td></tr><tr><td><strong>메모리 접근</strong></td><td>독립적 (느림)</td><td>공유 (빠름)</td><td>공유 (매우 빠름)</td></tr><tr><td><strong>확장성 한계</strong></td><td>CPU 코어 수</td><td>시스템 리소스</td><td>이벤트 루프 성능</td></tr></tbody></table><h4 id=사용-사례별-비교>사용 사례별 비교<a hidden class=anchor aria-hidden=true href=#사용-사례별-비교>#</a></h4><table><thead><tr><th>사용 사례</th><th>적합한 모델</th><th>이유</th></tr></thead><tbody><tr><td>대규모 데이터 처리</td><td>Process</td><td>메모리 격리와 CPU 활용</td></tr><tr><td>웹 서버</td><td>Thread/Coroutine</td><td>I/O 작업 처리에 효율적</td></tr><tr><td>실시간 게임</td><td>Thread</td><td>낮은 지연시간 필요</td></tr><tr><td>GUI 애플리케이션</td><td>Thread</td><td>사용자 인터페이스 반응성</td></tr><tr><td>네트워크 서비스</td><td>Coroutine</td><td>많은 동시 연결 처리</td></tr><tr><td>이미지/비디오 처리</td><td>Process</td><td>CPU 집약적 작업</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science-fundamentals/>Computer-Science-Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://buenhyden.github.io/tags/process-management/>Process-Management</a></li><li><a href=https://buenhyden.github.io/tags/processes/>Processes</a></li><li><a href=https://buenhyden.github.io/tags/process/>Process</a></li><li><a href=https://buenhyden.github.io/tags/thread/>Thread</a></li><li><a href=https://buenhyden.github.io/tags/coroutine/>Coroutine</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/><span class=title>« Prev</span><br><span>슬라이딩 윈도우 기법 (Sliding Window Technique)</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/multithreading-vs-multiprocessing-vs-multitasking/><span class=title>Next »</span><br><span>Multithreading vs. Multiprocessing vs Multitasking</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>