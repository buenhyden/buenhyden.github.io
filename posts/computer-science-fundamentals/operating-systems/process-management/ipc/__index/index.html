<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>프로세스 간 통신 (Inter-Process Communication, IPC) | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,IPC,Inter-Process-Communication"><meta name=description content="서로 독립적으로 실행되는 프로세스들이 데이터를 교환하고 상호작용하기 위한 메커니즘"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="프로세스 간 통신 (Inter-Process Communication, IPC)"><meta property="og:description" content="서로 독립적으로 실행되는 프로세스들이 데이터를 교환하고 상호작용하기 위한 메커니즘"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-02T06:20:00+00:00"><meta property="article:modified_time" content="2024-10-02T06:20:00+00:00"><meta property="article:tag" content="Computer-Science-Fundamentals"><meta property="article:tag" content="Operating-Systems"><meta property="article:tag" content="Process-Management"><meta property="article:tag" content="IPC"><meta property="article:tag" content="Inter-Process-Communication"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="프로세스 간 통신 (Inter-Process Communication, IPC)"><meta name=twitter:description content="서로 독립적으로 실행되는 프로세스들이 데이터를 교환하고 상호작용하기 위한 메커니즘"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"프로세스 간 통신 (Inter-Process Communication, IPC)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"프로세스 간 통신 (Inter-Process Communication, IPC)","name":"프로세스 간 통신 (Inter-Process Communication, IPC)","description":"서로 독립적으로 실행되는 프로세스들이 데이터를 교환하고 상호작용하기 위한 메커니즘","keywords":["Computer-Science-Fundamentals","Operating-systems","Process-Management","IPC","Inter-Process-Communication"],"articleBody":"프로세스 간 통신 (Inter-Process Communication, IPC) 프로세스 간 통신은 서로 다른 프로세스들이 데이터를 주고받거나 서로의 동작을 조율하기 위해 사용하는 메커니즘.\n한 프로세스의 출력이 다른 프로세스의 입력으로 사용될 수 있다.\n이를 통해 프로세스들은 데이터를 교환하고, 작업을 동기화하며, 리소스를 효율적으로 활용할 수 있다.\n프로세스 간 통신(IPC)에 대해 체계적으로 설명해드리겠습니다. 이 개념을 더 쉽게 이해하기 위해, 실제 생활의 예시와 함께 설명을 시작하겠습니다.\nSource: https://www.geeksforgeeks.org/inter-process-communication-ipc/\n장점 프로세스 간 데이터 공유 및 협력 가능 모듈화 및 유연한 시스템 설계 가능 단점 구현 복잡성 증가 동기화 및 데드락 문제 발생 가능성 IPC의 주요 방식 파이프(Pipe) 파이프는 가장 오래되고 간단한 IPC 방식으로, 한 프로세스의 출력이 다른 프로세스의 입력으로 직접 전달된다.\n단방향 통신을 위한 간단한 메커니즘 주로 부모-자식 프로세스 간 통신에 사용 종류 일반 파이프:\n부모-자식 프로세스 간 단방향 통신 표준 입출력 스트림 사용 예: Unix의 ‘|’ 연산자 명명된 파이프(Named Pipe):\n서로 관련 없는 프로세스 간 통신 가능 파일 시스템에 이름을 가진 특별한 파일로 존재 양방향 통신 지원 메시지 큐(Message Queue) 메시지 형태로 데이터를 주고받는 방식.\n특징 구조화된 데이터 전송 가능 비동기 통신 지원 여러 프로세스가 동시에 사용 가능 사용 예 1 2 3 4 5 6 7 8 // 메시지 큐 생성 msgid = msgget(KEY, IPC_CREAT | 0666); // 메시지 전송 msgsnd(msgid, \u0026message, sizeof(message), 0); // 메시지 수신 msgrcv(msgid, \u0026message, sizeof(message), 0, 0); 공유 메모리(Shared Memory) 여러 프로세스가 동일한 메모리 영역을 공유하여 통신하는 방식.\n장점 가장 빠른 IPC 방식 대용량 데이터 공유에 효율적 직접적인 메모리 접근 가능 주의사항 동기화 메커니즘 필요 메모리 관리 주의 필요 데이터 일관성 유지 중요 세마포어(Semaphore) 공유 자원에 대한 접근을 제어하는 신호 체계.\n용도 프로세스 동기화 상호 배제 구현 리소스 카운팅 구현 예 1 2 3 4 5 6 7 8 9 10 11 // 세마포어 생성 sem_t *sem = sem_open(\"mysem\", O_CREAT, 0644, 1); // 세마포어 획득 sem_wait(sem); // 임계 영역 코드 // … // 세마포어 해제 sem_post(sem); 소켓(Socket) 네트워크를 통한 프로세스 간 통신 방식.\n특징 로컬 및 원격 통신 가능 다양한 프로토콜 지원 양방향 통신 가능 사용 사례 클라이언트-서버 애플리케이션 네트워크 서비스 분산 시스템 시그널(Signal) 비동기적인 이벤트를 처리하기 위한 소프트웨어 인터럽트.\n주요 시그널 SIGTERM: 종료 요청 SIGKILL: 강제 종료 SIGUSR1/2: 사용자 정의 시그널 IPC 선택 시 고려사항 통신 패턴\n단방향 vs 양방향 동기 vs 비동기 1:1 vs 1:N 성능 요구사항\n지연 시간 처리량 리소스 사용량 신뢰성\n데이터 손실 가능성 오류 처리 복구 메커니즘 프로세스 간 통신의 실제 응용 데이터베이스 시스템\n쿼리 프로세서와 저장소 엔진 간 통신 캐시 관리 트랜잭션 조정 웹 서버\n워커 프로세스 관리 로드 밸런싱 세션 관리 운영체제\n장치 드라이버 통신 시스템 서비스 간 조정 프로세스 스케줄링 프로세스 간 통신의 발전 방향 분산 시스템\n클라우드 환경에서의 IPC 마이크로서비스 아키텍처 컨테이너 간 통신 새로운 하드웨어 지원\nRDMA(Remote Direct Memory Access) 하드웨어 가속 새로운 버스 아키텍처 보안 강화\n암호화 통신 접근 제어 격리 정책 참고 및 출처 ","wordCount":"445","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-02T06:20:00Z","dateModified":"2024-10-02T06:20:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">프로세스 간 통신 (Inter-Process Communication, IPC)</h1><div class=post-description>서로 독립적으로 실행되는 프로세스들이 데이터를 교환하고 상호작용하기 위한 메커니즘</div><div class=post-meta><span title='2024-10-02 06:20:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Operating%20systems/Process%20Management/IPC/__index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#프로세스-간-통신-inter-process-communication-ipc>프로세스 간 통신 (Inter-Process Communication, IPC)</a><ul><li><a href=#장점>장점</a></li><li><a href=#단점>단점</a></li><li><a href=#ipc의-주요-방식>IPC의 주요 방식</a></li><li><a href=#ipc-선택-시-고려사항>IPC 선택 시 고려사항</a></li><li><a href=#프로세스-간-통신의-실제-응용>프로세스 간 통신의 실제 응용</a></li><li><a href=#프로세스-간-통신의-발전-방향>프로세스 간 통신의 발전 방향</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=프로세스-간-통신-inter-process-communication-ipc>프로세스 간 통신 (Inter-Process Communication, IPC)<a hidden class=anchor aria-hidden=true href=#프로세스-간-통신-inter-process-communication-ipc>#</a></h2><p>프로세스 간 통신은 서로 다른 프로세스들이 데이터를 주고받거나 서로의 동작을 조율하기 위해 사용하는 메커니즘.<br>한 프로세스의 출력이 다른 프로세스의 입력으로 사용될 수 있다.<br>이를 통해 프로세스들은 데이터를 교환하고, 작업을 동기화하며, 리소스를 효율적으로 활용할 수 있다.</p><p>프로세스 간 통신(IPC)에 대해 체계적으로 설명해드리겠습니다. 이 개념을 더 쉽게 이해하기 위해, 실제 생활의 예시와 함께 설명을 시작하겠습니다.</p><p><figure><img alt="Shared Memory and Message Passing" loading=lazy src=/img/1-76.png><figcaption>Source: https://www.geeksforgeeks.org/inter-process-communication-ipc/</figcaption></figure></p><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ul><li>프로세스 간 데이터 공유 및 협력 가능</li><li>모듈화 및 유연한 시스템 설계 가능</li></ul><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ul><li>구현 복잡성 증가</li><li>동기화 및 데드락 문제 발생 가능성</li></ul><h3 id=ipc의-주요-방식>IPC의 주요 방식<a hidden class=anchor aria-hidden=true href=#ipc의-주요-방식>#</a></h3><h4 id=파이프pipe>파이프(Pipe)<a hidden class=anchor aria-hidden=true href=#파이프pipe>#</a></h4><p>파이프는 가장 오래되고 간단한 IPC 방식으로, 한 프로세스의 출력이 다른 프로세스의 입력으로 직접 전달된다.</p><ul><li>단방향 통신을 위한 간단한 메커니즘</li><li>주로 부모-자식 프로세스 간 통신에 사용</li></ul><h5 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h5><p>일반 파이프:</p><ul><li>부모-자식 프로세스 간 단방향 통신</li><li>표준 입출력 스트림 사용</li><li>예: Unix의 &lsquo;|&rsquo; 연산자</li></ul><p>명명된 파이프(Named Pipe):</p><ul><li>서로 관련 없는 프로세스 간 통신 가능</li><li>파일 시스템에 이름을 가진 특별한 파일로 존재</li><li>양방향 통신 지원</li></ul><h4 id=메시지-큐message-queue>메시지 큐(Message Queue)<a hidden class=anchor aria-hidden=true href=#메시지-큐message-queue>#</a></h4><p>메시지 형태로 데이터를 주고받는 방식.</p><h5 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h5><ul><li>구조화된 데이터 전송 가능</li><li>비동기 통신 지원</li><li>여러 프로세스가 동시에 사용 가능</li></ul><h5 id=사용-예>사용 예<a hidden class=anchor aria-hidden=true href=#사용-예>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 메시지 큐 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>msgid</span> <span class=o>=</span> <span class=nf>msgget</span><span class=p>(</span><span class=n>KEY</span><span class=p>,</span> <span class=n>IPC_CREAT</span> <span class=o>|</span> <span class=mo>0666</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 메시지 전송
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>msgsnd</span><span class=p>(</span><span class=n>msgid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>message</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 메시지 수신
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>msgrcv</span><span class=p>(</span><span class=n>msgid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>message</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=공유-메모리shared-memory>공유 메모리(Shared Memory)<a hidden class=anchor aria-hidden=true href=#공유-메모리shared-memory>#</a></h4><p>여러 프로세스가 동일한 메모리 영역을 공유하여 통신하는 방식.</p><h5 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h5><ul><li>가장 빠른 IPC 방식</li><li>대용량 데이터 공유에 효율적</li><li>직접적인 메모리 접근 가능</li></ul><h5 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h5><ul><li>동기화 메커니즘 필요</li><li>메모리 관리 주의 필요</li><li>데이터 일관성 유지 중요</li></ul><h4 id=세마포어semaphore>세마포어(Semaphore)<a hidden class=anchor aria-hidden=true href=#세마포어semaphore>#</a></h4><p>공유 자원에 대한 접근을 제어하는 신호 체계.</p><h5 id=용도>용도<a hidden class=anchor aria-hidden=true href=#용도>#</a></h5><ul><li>프로세스 동기화</li><li>상호 배제 구현</li><li>리소스 카운팅</li></ul><h5 id=구현-예>구현 예<a hidden class=anchor aria-hidden=true href=#구현-예>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 세마포어 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>sem_t</span> <span class=o>*</span><span class=n>sem</span> <span class=o>=</span> <span class=nf>sem_open</span><span class=p>(</span><span class=s>&#34;mysem&#34;</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0644</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 세마포어 획득
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>sem_wait</span><span class=p>(</span><span class=n>sem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 임계 영역 코드
</span></span></span><span class=line><span class=cl><span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 세마포어 해제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>sem_post</span><span class=p>(</span><span class=n>sem</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=소켓socket>소켓(Socket)<a hidden class=anchor aria-hidden=true href=#소켓socket>#</a></h4><p>네트워크를 통한 프로세스 간 통신 방식.</p><h5 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h5><ul><li>로컬 및 원격 통신 가능</li><li>다양한 프로토콜 지원</li><li>양방향 통신 가능</li></ul><h5 id=사용-사례>사용 사례<a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h5><ul><li>클라이언트-서버 애플리케이션</li><li>네트워크 서비스</li><li>분산 시스템</li></ul><h4 id=시그널signal>시그널(Signal)<a hidden class=anchor aria-hidden=true href=#시그널signal>#</a></h4><p>비동기적인 이벤트를 처리하기 위한 소프트웨어 인터럽트.</p><h5 id=주요-시그널>주요 시그널<a hidden class=anchor aria-hidden=true href=#주요-시그널>#</a></h5><ul><li>SIGTERM: 종료 요청</li><li>SIGKILL: 강제 종료</li><li>SIGUSR1/2: 사용자 정의 시그널</li></ul><h3 id=ipc-선택-시-고려사항>IPC 선택 시 고려사항<a hidden class=anchor aria-hidden=true href=#ipc-선택-시-고려사항>#</a></h3><ol><li><p>통신 패턴</p><ul><li>단방향 vs 양방향</li><li>동기 vs 비동기</li><li>1:1 vs 1:N</li></ul></li><li><p>성능 요구사항</p><ul><li>지연 시간</li><li>처리량</li><li>리소스 사용량</li></ul></li><li><p>신뢰성</p><ul><li>데이터 손실 가능성</li><li>오류 처리</li><li>복구 메커니즘</li></ul></li></ol><h3 id=프로세스-간-통신의-실제-응용>프로세스 간 통신의 실제 응용<a hidden class=anchor aria-hidden=true href=#프로세스-간-통신의-실제-응용>#</a></h3><ol><li><p>데이터베이스 시스템</p><ul><li>쿼리 프로세서와 저장소 엔진 간 통신</li><li>캐시 관리</li><li>트랜잭션 조정</li></ul></li><li><p>웹 서버</p><ul><li>워커 프로세스 관리</li><li>로드 밸런싱</li><li>세션 관리</li></ul></li><li><p>운영체제</p><ul><li>장치 드라이버 통신</li><li>시스템 서비스 간 조정</li><li>프로세스 스케줄링</li></ul></li></ol><h3 id=프로세스-간-통신의-발전-방향>프로세스 간 통신의 발전 방향<a hidden class=anchor aria-hidden=true href=#프로세스-간-통신의-발전-방향>#</a></h3><ol><li><p>분산 시스템</p><ul><li>클라우드 환경에서의 IPC</li><li>마이크로서비스 아키텍처</li><li>컨테이너 간 통신</li></ul></li><li><p>새로운 하드웨어 지원</p><ul><li>RDMA(Remote Direct Memory Access)</li><li>하드웨어 가속</li><li>새로운 버스 아키텍처</li></ul></li><li><p>보안 강화</p><ul><li>암호화 통신</li><li>접근 제어</li><li>격리 정책</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-science-fundamentals/>Computer-Science-Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/operating-systems/>Operating-Systems</a></li><li><a href=https://buenhyden.github.io/tags/process-management/>Process-Management</a></li><li><a href=https://buenhyden.github.io/tags/ipc/>IPC</a></li><li><a href=https://buenhyden.github.io/tags/inter-process-communication/>Inter-Process-Communication</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-control-block/><span class=title>« Prev</span><br><span>프로세스 제어 블록(Process Control Block, PCB)</span>
</a><a class=next href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/ci-cd-fundamentals/ci-cd-principles/><span class=title>Next »</span><br><span>CI/CD Principles</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>