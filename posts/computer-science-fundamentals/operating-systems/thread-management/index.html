<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Thread Management | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals,Operating-systems,Process-Management,Thread-Management"><meta name=description content="스레드 관리는 프로세스 내 여러 실행 흐름을 효율적으로 생성, 스케줄링, 동기화, 종료하는 운영체제의 핵심 기능이다. 이를 통해 CPU 자원 활용도를 높이고, 동시성 및 병렬성을 확보할 수 있다. 동기화와 자원 관리가 중요하다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Thread Management"><meta property="og:description" content="스레드 관리는 프로세스 내 여러 실행 흐름을 효율적으로 생성, 스케줄링, 동기화, 종료하는 운영체제의 핵심 기능이다. 이를 통해 CPU 자원 활용도를 높이고, 동시성 및 병렬성을 확보할 수 있다. 동기화와 자원 관리가 중요하다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Thread Management"><meta name=twitter:description content="스레드 관리는 프로세스 내 여러 실행 흐름을 효율적으로 생성, 스케줄링, 동기화, 종료하는 운영체제의 핵심 기능이다. 이를 통해 CPU 자원 활용도를 높이고, 동시성 및 병렬성을 확보할 수 있다. 동기화와 자원 관리가 중요하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":""},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/"},{"@type":"ListItem","position":4,"name":"Thread Management","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/>Operating System</a></div><h1>Thread Management</h1><div class=post-description>스레드 관리는 프로세스 내 여러 실행 흐름을 효율적으로 생성, 스케줄링, 동기화, 종료하는 운영체제의 핵심 기능이다. 이를 통해 CPU 자원 활용도를 높이고, 동시성 및 병렬성을 확보할 수 있다. 동기화와 자원 관리가 중요하다.</div></header><div class=post-content><h2 id=thread-management>Thread Management<a hidden class=anchor aria-hidden=true href=#thread-management>#</a></h2><p>Thread Management 는 프로세스 내에서 여러 스레드의 생성, 실행, 동기화, 종료를 관리하는 운영체제 및 프로그래밍 기술이다. 스레드 관리는 CPU 자원 활용도를 극대화하고, 동시성 및 병렬성을 제공하여 시스템 성능과 응답성을 높인다. 하지만 스레드 간 자원 공유, 동기화, 데드락, 경쟁 상태 등 관리 이슈가 존재하며, 이를 위한 락, 세마포어, 스레드 풀 등 다양한 기법이 활용된다. 서버, 데이터 처리, 실시간 시스템 등에서 필수적으로 적용된다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><strong>스레드 (Thread):</strong> 프로세스 내에서 실행되는 독립적인 명령어 흐름</li><li><strong>스레드 관리 (Thread Management):</strong> 스레드의 생성, 실행, 동기화, 종료, 스케줄링, 예외 처리 등 전체 생명주기를 관리하는 기능</li><li><strong>동기화 (Synchronization):</strong> 여러 스레드가 공유 자원에 안전하게 접근하도록 조율하는 기법 (뮤텍스, 세마포어, 락 등)</li><li><strong>스레드 풀 (Thread Pool):</strong> 미리 생성된 스레드 집합에서 작업을 할당하여 효율적으로 관리</li><li><strong>컨텍스트 스위칭 (Context Switching):</strong> 실행 중인 스레드 간 전환 작업</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ul><li>CPU 자원 활용 극대화 및 처리량 향상</li><li>동시성 및 병렬성 제공</li><li>대규모 동시 요청 처리 (서버, 데이터 처리 등)</li><li>프로그램 응답성 및 실시간성 개선</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li>스레드 생성 및 종료 관리</li><li>스케줄링 및 우선순위 지정</li><li>동기화 및 경쟁 상태 관리</li><li>예외 및 오류 처리</li><li>스레드 풀 관리</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>경량화된 실행 단위 (프로세스 대비)</li><li>자원 공유 (메모리, 파일 등)</li><li>빠른 컨텍스트 스위칭</li><li>동기화 필요성 (데이터 무결성 보장)</li></ul><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><ol><li><strong>스레드 생성:</strong> 메인 스레드 외에 추가 스레드 생성 (직접 생성, 스레드 풀 등)</li><li><strong>스케줄링:</strong> 운영체제 또는 런타임이 스레드에 CPU 할당</li><li><strong>동기화:</strong> 락, 세마포어 등으로 공유 자원 접근 제어</li><li><strong>종료 및 자원 회수:</strong> 스레드 작업 완료 후 종료 및 자원 해제</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[프로세스]
</span></span><span class=line><span class=cl>   ├─[스레드1] ──┐
</span></span><span class=line><span class=cl>   ├─[스레드2] ──┼─&gt; [공유 자원/메모리]
</span></span><span class=line><span class=cl>   └─[스레드N] ──┘
</span></span></code></pre></td></tr></table></div></div><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>성능 향상</td><td>CPU 활용도 극대화, 처리량 증가</td></tr><tr><td></td><td>응답성 개선</td><td>UI, 서버 등 실시간 응답성 향상</td></tr><tr><td></td><td>자원 효율성</td><td>프로세스 대비 적은 오버헤드</td></tr><tr><td></td><td>빠른 통신</td><td>스레드 간 자원 공유로 빠른 데이터 교환</td></tr><tr><td>⚠ 단점</td><td>동기화 문제</td><td>데드락, 경쟁 상태 등 동기화 이슈</td></tr><tr><td></td><td>디버깅 어려움</td><td>동시성 버그 추적 및 재현 어려움</td></tr><tr><td></td><td>자원 경합</td><td>캐시, 메모리 등 하드웨어 자원 경합</td></tr><tr><td></td><td>복잡성 증가</td><td>코드 구조 및 예외 처리 복잡</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><ul><li>동기화 및 경쟁 상태 관리</li><li>데드락, 라이브락, 우선순위 역전 등 문제 해결</li><li>스케줄링 및 부하 분산 최적화</li><li>디버깅 및 테스트의 어려움</li></ul><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>구현 위치</td><td>커널 스레드, 유저 스레드</td><td>커널/유저 공간에서 생성 및 관리</td></tr><tr><td>매핑 방식</td><td>1:1, N:1, M:N</td><td>유저 - 커널 스레드 매핑 방식</td></tr><tr><td>실행 방식</td><td>동시성, 병렬성</td><td>논리적/물리적 동시 실행</td></tr><tr><td>패턴/구조</td><td>스레드 풀, Producer-Consumer, Future 등</td><td>다양한 동시성 패턴 적용</td></tr></tbody></table><h3 id=하위-주제-및-추가-학습-필요-내용>하위 주제 및 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#하위-주제-및-추가-학습-필요-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>동시성</td><td>락, 세마포어, 모니터</td><td>동기화 객체 및 동작 원리</td></tr><tr><td>스레드 관리</td><td>스레드 풀, 스케줄러</td><td>효율적 스레드 생성/관리 기법</td></tr><tr><td>패턴/구조</td><td>Producer-Consumer, Future 등</td><td>동시성 패턴 및 활용법</td></tr><tr><td>디버깅</td><td>동시성 버그 추적</td><td>데드락, 경쟁 상태 등 문제 해결 방법</td></tr></tbody></table><h3 id=추가로-알아야-할-내용-및-관련-분야>추가로 알아야 할 내용 및 관련 분야<a hidden class=anchor aria-hidden=true href=#추가로-알아야-할-내용-및-관련-분야>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>운영체제</td><td>스케줄링 알고리즘</td><td>스레드/프로세스 스케줄링 정책</td></tr><tr><td>네트워크</td><td>비동기 I/O</td><td>멀티스레딩과 결합한 고성능 네트워크 처리</td></tr><tr><td>데이터베이스</td><td>트랜잭션 동시성</td><td>DB 에서의 멀티스레딩 및 동시성 제어</td></tr><tr><td>보안</td><td>스레드 안전성</td><td>멀티스레딩 환경에서의 데이터 보호</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>락 프리 (Lock-Free)</td><td>락 없이 동기화하는 고성능 구조</td></tr><tr><td>스레드 풀 (Thread Pool)</td><td>미리 생성된 스레드 집합에서 작업 할당</td></tr><tr><td>컨텍스트 스위칭 (Context Switching)</td><td>실행 중인 스레드/프로세드 전환 작업</td></tr><tr><td>데드락 (Deadlock)</td><td>상호 자원 점유로 인한 무한 대기 상태</td></tr><tr><td>경쟁 상태 (Race Condition)</td><td>동시 접근 시 예기치 않은 결과 발생 현상</td></tr><tr><td>Future/Promise</td><td>비동기 작업 결과를 처리하는 구조</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.geeksforgeeks.org/thread-management-in-operating-system/>Thread Management in Operating Systems - GeeksforGeeks</a></li><li><a href=https://docs.oracle.com/cd/E18752_01/html/816-5137/threads-1.html>Thread Management Overview - Oracle Docs</a></li><li><a href=https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html>Thread Pools and Concurrency - Java Tutorials</a></li><li><a href=https://www.freecodecamp.org/news/multithreading-for-beginners/>Multithreading for Beginners - freeCodeCamp</a></li><li><a href=https://www.baeldung.com/java-thread-management>Modern Thread Management Patterns - Baeldung</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread vs Coroutine</h2></header><div class=entry-content><p>Process vs. Thread vs. Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.
Process:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:
경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:
CPU > Core > Process > Thread > Coroutine
...</p></div><footer class=entry-footer><span title='2024-10-06 08:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread vs Coroutine" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/thread-types/process-vs-thread-vs-coroutine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>코루틴(Coroutine)</h2></header><div class=entry-content><p>코루틴 (Coroutine) 1. 태그(Tag) Coroutine, Concurrency, Async-Programming, Thread-Management
2. 분류 구조 적합성 분석 현재 구조
Computer Science Fundamentals > Operating systems > Process Management > Thread Management > Threads
분석 및 개선 제안 **코루틴 (Coroutine)**은 전통적으로 쓰레드(Thread)와 대비되거나, 쓰레드 내에서의 컨트롤 플로우(control flow) 관리 기법으로 간주됨. 하지만, 코루틴은 프로세스(Process)와 쓰레드(Thread)처럼 운영체제 차원의 엔티티가 아닌, “사용자 수준의 비동기 협력 멀티태스킹” 모델로 분류할 수 있음. 따라서, “Thread Management” 아래 “Threads"에 포함된 것은 큰 흐름상 자연스러우나, 더욱 명확히 구분하기 위해 Concurrency and Parallelism > Coroutine 혹은 Thread Management > Coroutine 정도로 독립된 항목으로 명확히 기재하면 이론적, 기술적으로 의미가 강화됨.
근거: 코루틴은 컨커런시(concurrency, 동시성) 제어의 주요 수단이지만, 운영체제 레벨이 아니라 프로그램 언어 혹은 라이브러리 레벨에서 구현됨. 3. 200자 내외 요약 코루틴(Coroutine)은 함수 실행 도중 중단과 재개가 가능한 비동기 협동형 컨트롤 플로우 기법이다. 경량화된 동시성 처리와 자원 효율적 실행을 지원하며, 스레드와 달리 문맥 전환 비용이 낮아 실시간 처리, 비동기 네트워킹, 게임 루프 등에서 폭넓게 활용된다.
...</p></div><footer class=entry-footer><span title='2024-10-05 06:52:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;66 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코루틴(Coroutine)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/thread-types/fiber-and-coroutines/coroutine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Threads</h2></header><div class=entry-content><p>Threads 스레드 (Thread) 는 하나의 프로세스 내에서 여러 실행 흐름을 동시에 수행할 수 있도록 하는 경량 실행 단위다.
자원을 공유하면서도 병렬로 처리할 수 있어 CPU 사용률을 극대화하며, 멀티코어 환경에서 반응성과 처리 성능 향상에 핵심적인 역할을 한다.
생성, 종료, 동기화, 스케줄링 등의 관리가 비교적 효율적이지만, 경쟁 상태, 데드락 등의 문제가 발생할 수 있어 주의가 필요하다.
웹 서버, 실시간 시스템, 데이터 처리 등 다양한 분야에서 쓰이며, 현대 소프트웨어에서 동시성과 병렬성을 구현하는 기반 기술로 활용된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 23:32:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;36 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Threads" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/thread-management/threads/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>