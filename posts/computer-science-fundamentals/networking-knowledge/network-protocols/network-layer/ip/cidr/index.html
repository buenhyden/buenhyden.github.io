<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CIDR (Classless Inter-Domain Routing) | hyunyoun's Blog</title><meta name=keywords content="Networking-Knowledge,Network-Protocols,Core-Internet-Protocols,IP,Internet-Protocol,CIDR,Classless-Inter-Domain-Routing"><meta name=description content="CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="CIDR (Classless Inter-Domain Routing)"><meta property="og:description" content="CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-17T11:51:00+00:00"><meta property="article:modified_time" content="2024-10-17T11:51:00+00:00"><meta property="article:tag" content="Networking-Knowledge"><meta property="article:tag" content="Network-Protocols"><meta property="article:tag" content="Core-Internet-Protocols"><meta property="article:tag" content="IP"><meta property="article:tag" content="Internet-Protocol"><meta property="article:tag" content="CIDR"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="CIDR (Classless Inter-Domain Routing)"><meta name=twitter:description content="CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Networking Knowledge","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/"},{"@type":"ListItem","position":4,"name":"Network Protocol","item":""},{"@type":"ListItem","position":5,"name":"Network Layer","item":""},{"@type":"ListItem","position":6,"name":"IP(Internet Protocol)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/"},{"@type":"ListItem","position":7,"name":"CIDR (Classless Inter-Domain Routing)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"CIDR (Classless Inter-Domain Routing)","name":"CIDR (Classless Inter-Domain Routing)","description":"CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식","keywords":["Networking-Knowledge","Network-Protocols","Core-Internet-Protocols","IP","Internet-Protocol","CIDR","Classless-Inter-Domain-Routing"],"articleBody":"CIDR (Classless Inter-Domain Routing) CIDR은 1993년에 도입된 IP 주소 할당 및 라우팅 방식으로, 기존의 클래스 기반 주소 체계(Classful Addressing)의 한계를 극복하기 위해 만들어졌다.\n인터넷이 급속도로 성장하면서 기존의 고정된 클래스 체계로는 IP 주소를 효율적으로 할당하기 어려워졌고, 이를 해결하기 위해 더 유연한 주소 할당 방식이 필요해지면서 탄생되었다.\n네트워크 정보를 여러 개로 나누어진 Sub-Network 들을 모두 나타낼 수 있는 하나의 Network 로 통합해서 보여주는 방법이다.\n목적 IP 주소 자원의 낭비를 줄임 라우팅 테이블의 크기를 감소시킴 더 유연하고 효율적인 주소 할당을 제공 특징 주소 집약(Route Aggregation)\nCIDR의 가장 중요한 특징 중 하나는 라우팅 테이블을 간소화할 수 있는 주소 집약이다.\n예를 들어:\n192.168.0.0/24 192.168.1.0/24 192.168.2.0/24 192.168.3.0/24 이 네 개의 네트워크를 192.168.0.0/22로 집약할 수 있다. 유연한 네트워크 설계\nCIDR을 사용하면 네트워크 크기를 필요에 따라 정확하게 조절할 수 있다.\n이는 다음과 같은 이점을 제공한다:\nIP 주소 낭비 최소화 효율적인 주소 공간 활용 네트워크 구조의 유연한 설계 장점 IP 주소 활용 효율성\n필요한 만큼의 주소만 할당 가능 주소 공간 낭비 최소화 미사용 주소의 재할당 용이 라우팅 효율성\n라우팅 테이블 크기 감소 네트워크 성능 향상 라우터의 메모리 사용량 감소 네트워크 설계 유연성\n다양한 크기의 네트워크 수용 쉬운 네트워크 확장 효율적인 주소 관리 표기법 CIDR은 IP 주소와 슬래시(/) 뒤에 네트워크 프리픽스의 비트 수를 표기하는 방식을 사용한다.\n이는 네트워크 주소와 프리픽스 길이로 표현되며, 프리픽스 길이는 네트워크 부분의 비트 수를 나타낸다.\n점과 숫자로 이루어진 4 부분의 주소와 ‘/’ 뒤의 0 에서 32 까지의 숫자로 이루어진다.\n즉, A.B.C.D/N 과 같은 형태 점과 숫자로 이루어진 부분은 IPv4 주소와 마찬가지로 4 개의 8 비트 단위 바이트로 이루어진 32 비트 이진 숫자이다. ‘/’ 뒤의 숫자는 접두어 길이라고 하며, 주소의 왼쪽으로부터 세어서 공유하는 초기 비트의 수를 가리킨다. 예를 들어 192.168.1.0/24는 다음을 의미한다:\nIP 주소: 192.168.1.0 네트워크 프리픽스: 24비트 호스트 비트: 8비트 (32-24) 이는 기존 클래스 체계의 서브넷 마스크 255.255.255.0과 동일한 의미를 가진다. CIDR 블록 CIDR(Classless Inter-Domain Routing)는 IP 주소를 할당하고 라우팅하는 방식 자체를 의미하는 반면, CIDR 블록은 CIDR 방식을 사용하여 실제로 정의된 특정 주소의 범위를 의미한다.\n예를 들어 192.168.1.0/24와 같은 특정 네트워크 주소 범위를 CIDR 블록이라고 한다.\n구체적인 예시를 들어보면:\nCIDR은 “/24\"나 “/16\"과 같은 접두어 길이를 사용하여 네트워크를 유연하게 분할할 수 있게 해주는 방식. CIDR 블록은 이 방식을 사용하여 실제로 정의된 “192.168.1.0/24\"나 “10.0.0.0/16\"과 같은 특정 주소 범위. 예를 들어 192.168.1.0/24라는 CIDR 블록은 192.168.1.0부터 192.168.1.255까지의 256개 연속된 IP 주소를 포함한다.\nCIDR 블록이라 불리는 그룹에 포함된 여러 IP 주소는 이진 표기를 하였을 때 동일한 일련의 초기 비트를 가진다.\n만약 이진 형태로 변화한 IP 주소의 첫 자리 비트에서 CIDR 접두어 N 비트 길이만큼 일치한다면, 해당 IP 주소는 CIDR 블록의 일부라고 하며, CIDR 접두어와 일치한다고 한다.\nIPv6 주소에서도 사용될 수 있으며, 이 경우 긴 주소로 말미암아 접두어 길이는 0~128 까지의 범위를 지닌다.\nSource: https://ko.wikipedia.org/wiki/CIDR\nCIDR 블록의 할당 1990 년대 후반, 208.130.29.33 은 www.fresssoft.org 웹 서버에 할당되어 있었는데, 3 개의 CIDR 접두어를 가진다. 큰 CIDR 블록인 208.128.0.0/11 이 ARIN(북미 RIR) 에서 MCI 에 할당됨. 버지니아주에 있는 재공급업자인 Automation Research Systems 는 MCI 로부터 인터넷 접속을 승인받아 208.130.28.0/22 를 부여받음. ARS 는 /24 블록을 공공 서버용으로 할당하였고, 208.130.29.33 은 그 중 하나이다. 하나의 주소에 대한 이러한 여러 CIDR 접두어는 네트워크상의 서로 다른 영역에서 각각 사용된다. MCI 네트워크 외부에서는 208.128.0.0/11 접두어가 MCI 트래픽 영역으로 접근하기 위해 사용된다. MCI 네트워크 내부에서는 208.128.28.0/22 가 사용되며, 패킷을 ARS 로 보내는 역할을 한다. 208.130.29.0/24 는 ARS 네트워크 내부에서만 사용된다. Source: https://ko.wikipedia.org/wiki/CIDR\nCIDR의 작동 원리 CIDR은 가변 길이 서브넷 마스킹(VLSM)을 사용하여 네트워크를 더 효율적으로 분할한다.\n네트워크 프리픽스 길이를 자유롭게 조절할 수 있어서, 필요한 만큼의 호스트 주소만을 할당할 수 있다.\n예를 들어:\n/24 네트워크는 256개의 주소(254개 사용 가능) /25 네트워크는 128개의 주소(126개 사용 가능) /26 네트워크는 64개의 주소(62개 사용 가능) CIDR 계산 방법 CIDR 네트워크를 계산할 때는 다음 단계를 따른다:\n네트워크 크기 결정 필요한 호스트 수를 파악하고, 이를 수용할 수 있는 가장 작은 2의 거듭제곱을 찾는다. 프리픽스 길이 계산 32에서 필요한 호스트 비트 수를 뺀 값이 프리픽스 길이가 된다. 네트워크 범위 계산 네트워크 주소와 브로드캐스트 주소를 계산하여 사용 가능한 IP 범위를 결정한다. 실제 CIDR 적용 예시 한 회사에서 직원 60명을 수용할 수 있는 네트워크를 설계해야 한다고 가정해보자.\n네트워크 크기 결정\n필요한 호스트 수: 60대 네트워크 주소와 브로드캐스트 주소를 위해 추가로 2개 주소 필요 따라서 총 필요한 주소 수: 62개 이를 수용할 수 있는 가장 작은 2의 거듭제곱을 찾아보면: 2⁶ = 64가 62개의 주소를 수용할 수 있는 최소 크기 즉, 6비트가 호스트 부분에 필요 프리픽스 길이 계산\nIPv4는 총 32비트 필요한 호스트 비트 수는 6비트 프리픽스 길이 = 32 - 6 = 26 따라서 /26 네트워크가 필요 네트워크 범위 계산\n예를 들어 192.168.1.0/26 네트워크를 사용한다고 하면:\n네트워크 주소: 192.168.1.0 이진수로 표현: 11000000.10101000.00000001.00000000 브로드캐스트 주소: 192.168.1.63 이진수로 표현: 11000000.10101000.00000001.00111111 사용 가능한 IP 주소 범위: 첫 번째 사용 가능 주소: 192.168.1.1 마지막 사용 가능 주소: 192.168.1.62 총 사용 가능한 호스트 수: 62개 (64 - 2) 접두어 합침 (Routing Prefix Aggregation, 혹은 summarization) 접두어 합침(Routing Prefix Aggregation 또는 summarization)은 라우팅 테이블의 크기를 줄이고 네트워크 효율성을 높이기 위해 사용되는 중요한 기술이다.\n접두어 합침은 여러 개의 연속된 IP 주소 블록을 하나의 더 큰 블록으로 결합하는 과정이다.\n이 기술의 주요 목적은:\n라우팅 테이블 크기 감소 네트워크 대역폭 절약 라우터의 처리 부하 감소 네트워크 안정성 향상 장점:\n라우팅 테이블 크기 감소: 여러 개의 경로를 하나로 합치면 라우터의 메모리 사용량이 줄어든다. 라우팅 효율성 향상: 작은 라우팅 테이블은 더 빠른 경로 검색을 가능하게 한다. 네트워크 안정성 개선: 개별 경로의 변동이 전체 네트워크에 미치는 영향을 줄일 수 있다. 주의사항:\n접두어 합침을 사용할 때는 주의가 필요하다.\n과도한 합침은 라우팅의 정확성을 떨어뜨릴 수 있으며, 특정 상황에서는 비효율적인 라우팅을 초래할 수 있다.\n작동 방식:\n접두어 합침은 여러 개의 작은 네트워크를 하나의 큰 네트워크로 표현한다.\n이는 CIDR(Classless Inter-Domain Routing) 표기법을 사용하여 수행된다.\n예시:\n다음과 같은 네트워크 주소들이 있다고 가정해 봅시다:\n172.16.64.0/24 ~ 172.16.71.0/24\n이 네 개의 주소는 172.16.64.0/21로 합칠 수 있다.\n이렇게 하면 라우팅 테이블에 네 개의 항목 대신 하나의 항목만 필요하게 된다. Source: https://docs.vmware.com/en/VMware-SD-WAN/6.0/VMware-SD-WAN-Administration-Guide/GUID-72405FEF-C3B9-47E9-A332-869FB35DB1DC.html\n참고 및 출처 CIDR [네트워크] CIDR이란?(사이더 란?)\n[네트워크] CIDR 범위 쉽게 계산하는 방법\nCIDR\n","wordCount":"934","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-17T11:51:00Z","dateModified":"2024-10-17T11:51:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/>Networking Knowledge</a>&nbsp;»&nbsp;<a href>Network Protocol</a>&nbsp;»&nbsp;<a href>Network Layer</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/>IP(Internet Protocol)</a></div><h1 class="post-title entry-hint-parent">CIDR (Classless Inter-Domain Routing)</h1><div class=post-description>CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식</div><div class=post-meta><span title='2024-10-17 11:51:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Networking%20Knowledge/Network%20Protocols/Network%20Layer/IP/CIDR.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cidr-classless-inter-domain-routing>CIDR (Classless Inter-Domain Routing)</a><ul><li><a href=#목적>목적</a></li><li><a href=#특징>특징</a></li><li><a href=#장점>장점</a></li><li><a href=#표기법>표기법</a></li><li><a href=#cidr의-작동-원리>CIDR의 작동 원리</a></li><li><a href=#cidr-계산-방법>CIDR 계산 방법</a></li><li><a href=#접두어-합침-routing-prefix-aggregation-혹은-summarization>접두어 합침 (Routing Prefix Aggregation, 혹은 summarization)</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#cidr>CIDR</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=cidr-classless-inter-domain-routing>CIDR (Classless Inter-Domain Routing)<a hidden class=anchor aria-hidden=true href=#cidr-classless-inter-domain-routing>#</a></h2><p>CIDR은 1993년에 도입된 IP 주소 할당 및 라우팅 방식으로, 기존의 클래스 기반 주소 체계(Classful Addressing)의 한계를 극복하기 위해 만들어졌다.<br>인터넷이 급속도로 성장하면서 기존의 고정된 클래스 체계로는 IP 주소를 효율적으로 할당하기 어려워졌고, 이를 해결하기 위해 더 유연한 주소 할당 방식이 필요해지면서 탄생되었다.<br>네트워크 정보를 여러 개로 나누어진 Sub-Network 들을 모두 나타낼 수 있는 하나의 Network 로 통합해서 보여주는 방법이다.</p><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><ul><li>IP 주소 자원의 낭비를 줄임</li><li>라우팅 테이블의 크기를 감소시킴</li><li>더 유연하고 효율적인 주소 할당을 제공</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><p>주소 집약(Route Aggregation)<br>CIDR의 가장 중요한 특징 중 하나는 라우팅 테이블을 간소화할 수 있는 주소 집약이다.<br>예를 들어:</p><ul><li>192.168.0.0/24</li><li>192.168.1.0/24</li><li>192.168.2.0/24</li><li>192.168.3.0/24 이 네 개의 네트워크를 192.168.0.0/22로 집약할 수 있다.</li></ul></li><li><p>유연한 네트워크 설계<br>CIDR을 사용하면 네트워크 크기를 필요에 따라 정확하게 조절할 수 있다.<br>이는 다음과 같은 이점을 제공한다:</p><ul><li>IP 주소 낭비 최소화</li><li>효율적인 주소 공간 활용</li><li>네트워크 구조의 유연한 설계</li></ul></li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li><p>IP 주소 활용 효율성</p><ul><li>필요한 만큼의 주소만 할당 가능</li><li>주소 공간 낭비 최소화</li><li>미사용 주소의 재할당 용이</li></ul></li><li><p>라우팅 효율성</p><ul><li>라우팅 테이블 크기 감소</li><li>네트워크 성능 향상</li><li>라우터의 메모리 사용량 감소</li></ul></li><li><p>네트워크 설계 유연성</p><ul><li>다양한 크기의 네트워크 수용</li><li>쉬운 네트워크 확장</li><li>효율적인 주소 관리</li></ul></li></ol><h3 id=표기법>표기법<a hidden class=anchor aria-hidden=true href=#표기법>#</a></h3><p>CIDR은 IP 주소와 슬래시(/) 뒤에 네트워크 프리픽스의 비트 수를 표기하는 방식을 사용한다.<br>이는 네트워크 주소와 프리픽스 길이로 표현되며, 프리픽스 길이는 네트워크 부분의 비트 수를 나타낸다.</p><ul><li>점과 숫자로 이루어진 4 부분의 주소와 &lsquo;/&rsquo; 뒤의 0 에서 32 까지의 숫자로 이루어진다.<br>즉, <code>A.B.C.D/N</code> 과 같은 형태</li><li>점과 숫자로 이루어진 부분은 IPv4 주소와 마찬가지로 4 개의 8 비트 단위 바이트로 이루어진 32 비트 이진 숫자이다.</li><li>&lsquo;/&rsquo; 뒤의 숫자는 <code>접두어 길이</code>라고 하며, 주소의 왼쪽으로부터 세어서 공유하는 초기 비트의 수를 가리킨다.</li></ul><p>예를 들어 192.168.1.0/24는 다음을 의미한다:</p><ul><li>IP 주소: 192.168.1.0</li><li>네트워크 프리픽스: 24비트</li><li>호스트 비트: 8비트 (32-24) 이는 기존 클래스 체계의 서브넷 마스크 255.255.255.0과 동일한 의미를 가진다.</li></ul><h4 id=cidr-블록>CIDR 블록<a hidden class=anchor aria-hidden=true href=#cidr-블록>#</a></h4><p>CIDR(Classless Inter-Domain Routing)는 IP 주소를 할당하고 라우팅하는 방식 자체를 의미하는 반면, <strong>CIDR 블록</strong>은 CIDR 방식을 사용하여 실제로 정의된 특정 주소의 범위를 의미한다.<br>예를 들어 192.168.1.0/24와 같은 특정 네트워크 주소 범위를 CIDR 블록이라고 한다.</p><p>구체적인 예시를 들어보면:</p><ul><li>CIDR은 &ldquo;/24"나 &ldquo;/16"과 같은 접두어 길이를 사용하여 네트워크를 유연하게 분할할 수 있게 해주는 방식.</li><li>CIDR 블록은 이 방식을 사용하여 실제로 정의된 &ldquo;192.168.1.0/24"나 &ldquo;10.0.0.0/16"과 같은 특정 주소 범위.</li></ul><p>예를 들어 192.168.1.0/24라는 CIDR 블록은 192.168.1.0부터 192.168.1.255까지의 256개 연속된 IP 주소를 포함한다.<br>CIDR 블록이라 불리는 그룹에 포함된 여러 IP 주소는 <strong>이진 표기</strong>를 하였을 때 동일한 일련의 초기 비트를 가진다.<br>만약 이진 형태로 변화한 IP 주소의 첫 자리 비트에서 CIDR 접두어 N 비트 길이만큼 일치한다면, 해당 IP 주소는 CIDR 블록의 일부라고 하며, CIDR 접두어와 일치한다고 한다.</p><p>IPv6 주소에서도 사용될 수 있으며, 이 경우 긴 주소로 말미암아 접두어 길이는 0~128 까지의 범위를 지닌다.</p><p><figure><img alt="CIDR 접두어 일치의 예시" loading=lazy src=/img/487px-IP_Address_Match.svg.png><figcaption>Source: https://ko.wikipedia.org/wiki/CIDR</figcaption></figure></p><ul><li>CIDR 블록의 할당<ul><li>1990 년대 후반, 208.130.29.33 은 <code>www.fresssoft.org</code> 웹 서버에 할당되어 있었는데, 3 개의 CIDR 접두어를 가진다.<ul><li>큰 CIDR 블록인 208.128.0.0/11 이 ARIN(북미 RIR) 에서 MCI 에 할당됨.</li><li>버지니아주에 있는 재공급업자인 Automation Research Systems 는 MCI 로부터 인터넷 접속을 승인받아 208.130.28.0/22 를 부여받음.</li><li>ARS 는 /24 블록을 공공 서버용으로 할당하였고, 208.130.29.33 은 그 중 하나이다.</li></ul></li><li>하나의 주소에 대한 이러한 여러 CIDR 접두어는 네트워크상의 서로 다른 영역에서 각각 사용된다.<ul><li>MCI 네트워크 외부에서는 208.128.0.0/11 접두어가 MCI 트래픽 영역으로 접근하기 위해 사용된다.</li><li>MCI 네트워크 내부에서는 208.128.28.0/22 가 사용되며, 패킷을 ARS 로 보내는 역할을 한다.</li><li>208.130.29.0/24 는 ARS 네트워크 내부에서만 사용된다.</li></ul></li></ul></li></ul><p><figure><img alt="An\u00a0broken down by its CIDR prefixes" loading=lazy src=/img/640px-CIDR_Address.svg.png><figcaption>Source: https://ko.wikipedia.org/wiki/CIDR</figcaption></figure></p><h3 id=cidr의-작동-원리>CIDR의 작동 원리<a hidden class=anchor aria-hidden=true href=#cidr의-작동-원리>#</a></h3><p>CIDR은 가변 길이 서브넷 마스킹(VLSM)을 사용하여 네트워크를 더 효율적으로 분할한다.<br>네트워크 프리픽스 길이를 자유롭게 조절할 수 있어서, 필요한 만큼의 호스트 주소만을 할당할 수 있다.</p><p>예를 들어:</p><ul><li>/24 네트워크는 256개의 주소(254개 사용 가능)</li><li>/25 네트워크는 128개의 주소(126개 사용 가능)</li><li>/26 네트워크는 64개의 주소(62개 사용 가능)</li></ul><h3 id=cidr-계산-방법>CIDR 계산 방법<a hidden class=anchor aria-hidden=true href=#cidr-계산-방법>#</a></h3><p>CIDR 네트워크를 계산할 때는 다음 단계를 따른다:</p><ol><li>네트워크 크기 결정 필요한 호스트 수를 파악하고, 이를 수용할 수 있는 가장 작은 2의 거듭제곱을 찾는다.</li><li>프리픽스 길이 계산 32에서 필요한 호스트 비트 수를 뺀 값이 프리픽스 길이가 된다.</li><li>네트워크 범위 계산 네트워크 주소와 브로드캐스트 주소를 계산하여 사용 가능한 IP 범위를 결정한다.</li></ol><h4 id=실제-cidr-적용-예시>실제 CIDR 적용 예시<a hidden class=anchor aria-hidden=true href=#실제-cidr-적용-예시>#</a></h4><p>한 회사에서 직원 60명을 수용할 수 있는 네트워크를 설계해야 한다고 가정해보자.</p><ol><li><p>네트워크 크기 결정</p><ul><li>필요한 호스트 수: 60대</li><li>네트워크 주소와 브로드캐스트 주소를 위해 추가로 2개 주소 필요</li><li>따라서 총 필요한 주소 수: 62개</li><li>이를 수용할 수 있는 가장 작은 2의 거듭제곱을 찾아보면:<ul><li>2⁶ = 64가 62개의 주소를 수용할 수 있는 최소 크기</li><li>즉, 6비트가 호스트 부분에 필요</li></ul></li></ul></li><li><p>프리픽스 길이 계산</p><ul><li>IPv4는 총 32비트</li><li>필요한 호스트 비트 수는 6비트</li><li>프리픽스 길이 = 32 - 6 = 26</li><li>따라서 /26 네트워크가 필요</li></ul></li><li><p>네트워크 범위 계산<br>예를 들어 192.168.1.0/26 네트워크를 사용한다고 하면:</p><ul><li>네트워크 주소: 192.168.1.0<ul><li>이진수로 표현: 11000000.10101000.00000001.00000000</li></ul></li><li>브로드캐스트 주소: 192.168.1.63<ul><li>이진수로 표현: 11000000.10101000.00000001.00111111</li></ul></li><li>사용 가능한 IP 주소 범위:<ul><li>첫 번째 사용 가능 주소: 192.168.1.1</li><li>마지막 사용 가능 주소: 192.168.1.62</li></ul><ul><li>총 사용 가능한 호스트 수: 62개 (64 - 2)</li></ul></li></ul></li></ol><h3 id=접두어-합침-routing-prefix-aggregation-혹은-summarization>접두어 합침 (Routing Prefix Aggregation, 혹은 summarization)<a hidden class=anchor aria-hidden=true href=#접두어-합침-routing-prefix-aggregation-혹은-summarization>#</a></h3><p>접두어 합침(Routing Prefix Aggregation 또는 summarization)은 라우팅 테이블의 크기를 줄이고 네트워크 효율성을 높이기 위해 사용되는 중요한 기술이다.</p><p>접두어 합침은 여러 개의 연속된 IP 주소 블록을 하나의 더 큰 블록으로 결합하는 과정이다.</p><p>이 기술의 주요 목적은:</p><ol><li>라우팅 테이블 크기 감소</li><li>네트워크 대역폭 절약</li><li>라우터의 처리 부하 감소</li><li>네트워크 안정성 향상</li></ol><p>장점:</p><ol><li>라우팅 테이블 크기 감소: 여러 개의 경로를 하나로 합치면 라우터의 메모리 사용량이 줄어든다.</li><li>라우팅 효율성 향상: 작은 라우팅 테이블은 더 빠른 경로 검색을 가능하게 한다.</li><li>네트워크 안정성 개선: 개별 경로의 변동이 전체 네트워크에 미치는 영향을 줄일 수 있다.</li></ol><p>주의사항:<br>접두어 합침을 사용할 때는 주의가 필요하다.<br>과도한 합침은 라우팅의 정확성을 떨어뜨릴 수 있으며, 특정 상황에서는 비효율적인 라우팅을 초래할 수 있다.</p><p>작동 방식:<br>접두어 합침은 여러 개의 작은 네트워크를 하나의 큰 네트워크로 표현한다.<br>이는 CIDR(Classless Inter-Domain Routing) 표기법을 사용하여 수행된다.</p><p>예시:<br>다음과 같은 네트워크 주소들이 있다고 가정해 봅시다:</p><ul><li>172.16.64.0/24 ~ 172.16.71.0/24<br>이 네 개의 주소는 172.16.64.0/21로 합칠 수 있다.<br>이렇게 하면 라우팅 테이블에 네 개의 항목 대신 하나의 항목만 필요하게 된다.</li></ul><p><figure><img alt="Route Summarization" loading=lazy src=/img/GUID-CBB50420-82CE-4F46-98BA-24A1BF644290-low.png><figcaption>Source: https://docs.vmware.com/en/VMware-SD-WAN/6.0/VMware-SD-WAN-Administration-Guide/GUID-72405FEF-C3B9-47E9-A332-869FB35DB1DC.html</figcaption></figure></p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=cidr>CIDR<a hidden class=anchor aria-hidden=true href=#cidr>#</a></h3><p><a href=https://kim-dragon.tistory.com/9>[네트워크] CIDR이란?(사이더 란?)</a><br><a href=https://kim-dragon.tistory.com/154>[네트워크] CIDR 범위 쉽게 계산하는 방법</a><br><a href=https://ko.wikipedia.org/wiki/CIDR>CIDR</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/networking-knowledge/>Networking-Knowledge</a></li><li><a href=https://buenhyden.github.io/tags/network-protocols/>Network-Protocols</a></li><li><a href=https://buenhyden.github.io/tags/core-internet-protocols/>Core-Internet-Protocols</a></li><li><a href=https://buenhyden.github.io/tags/ip/>IP</a></li><li><a href=https://buenhyden.github.io/tags/internet-protocol/>Internet-Protocol</a></li><li><a href=https://buenhyden.github.io/tags/cidr/>CIDR</a></li><li><a href=https://buenhyden.github.io/tags/classless-inter-domain-routing/>Classless-Inter-Domain-Routing</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/nat/><span class=title>« Prev</span><br><span>네트워크 주소 변환 (NAT, Network Address Translation)</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/ip-delivery-modes/><span class=title>Next »</span><br><span>IP Delivery Modes</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>