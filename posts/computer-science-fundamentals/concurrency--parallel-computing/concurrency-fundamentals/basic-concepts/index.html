<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Basic Concepts | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Basic Concepts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Basic Concepts"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Basic Concepts"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Basic Concepts","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a></div><h1>Basic Concepts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Critical Section</h2></header><div class=entry-content><p>Critical Section 임계 구역 (Critical Section) 은 여러 실행 흐름이 공유 자원을 안전하게 사용할 수 있도록 동시 접근을 제어하는 코드 블록이다. 상호 배제, 진행성, 유한 대기의 세 원칙을 기반으로 하며, mutex, semaphore, monitor, atomic 연산 등으로 보호된다. Dekker 와 Peterson 알고리즘 같은 고전적 해법부터 현대 언어의 동기화 추상화까지 폭넓게 활용되며, 데드락, 기아, 경쟁 상태를 예방한다.
등장 배경 및 발전 과정 Critical Section은 단일 흐름 환경에서는 문제가 되지 않았지만, 멀티프로세스/멀티스레드/멀티코어 환경이 도입되면서 **경쟁 조건 (Race Condition)**을 해결하기 위한 동기화 문제의 핵심 개념으로 발전했다. Dekker, Peterson 등의 초기 알고리즘에서 시작해, 세마포어, 모니터, 뮤텍스 등의 운영체제 기반 기술로 이어졌고, 현재는 락프리 구조, 메모리 일관성 모델, 고수준 언어 내장 기법 등으로 진화하고 있다.
...</p></div><footer class=entry-footer><span title='2025-05-20 14:46:00 +0000 UTC'>May 20, 2025</span>&nbsp;·&nbsp;<span>35 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Critical Section" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/critical-section/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency vs.Parallelism</h2></header><div class=entry-content><p>Concurrency vs.Parallelism 동시성과 병렬성은 현대 시스템 설계에서 성능 최적화의 핵심 개념이다. 동시성은 작업 간 전환을 통해 단일 자원으로 다수 작업을 논리적으로 처리하며, 병렬성은 다중 코어 또는 분산 환경에서 여러 작업을 실제 동시에 실행해 처리량을 극대화한다. 두 개념은 멀티스레딩, 비동기 I/O, GPU 병렬 처리, 분산 시스템 등 다양한 분야에서 상호 보완적으로 사용되며, 시스템의 응답성, 확장성, 자원 효율성을 크게 향상시킨다.
등장 배경 및 발전 과정 시기 기술 발전 흐름 주요 내용 요약 1950~1960 년대 초기 컴퓨팅 구조 - 단일 프로그램 실행 환경 (batch processing)
- CPU 유휴 시간 발생, 자원 활용 비효율성 문제 대두 1960 년대 중후반 시분할 시스템 및 멀티프로그래밍 도입 - Multiprogramming: 여러 작업을 메모리에 상주시켜 CPU 활용 극대화
- Time-Sharing System: 사용자 간 자원 공유 지원 1970~1980 년대 멀티태스킹 운영체제, GUI 시대 개막 - Preemptive Scheduling 기반의 멀티태스킹 OS 등장
- 사용자 인터페이스가 GUI 로 진화하며, 백그라운드 동작 (Concurrency) 중요성 증가 1990 년대 네트워크 기반 시스템 확산 - 클라이언트 - 서버 구조 확산
- 웹 서비스 및 이벤트 처리 요구 증가
- 스레드 기반 모델 활성화 2000 년대 초반 멀티코어 프로세서 상용화 - Dual/Quad Core CPU 등장
- 병렬 처리를 위한 물리적 인프라 확보
- 멀티스레딩의 하드웨어적 기반 제공 2010 년대 이후 클라우드, 분산 시스템, 비동기 모델 확산 - Cloud-native 시스템 확산
- 대규모 데이터 처리, 이벤트 기반 아키텍처 필요성 증가
- Async/Await, Reactive, Actor Model 도입 2020 년대~현재 AI, IoT, 엣지 컴퓨팅 시대 - 병렬화 가능한 작업 증가 (딥러닝, 센서 데이터 등)
- GPGPU 병렬 처리, 서버리스 기반 동시성 처리 활용 확대 Concurrency 의 필요성은 CPU 의 유휴 자원 방지와 사용자 응답성 확보에서 출발했으며, 멀티태스킹 OS, GUI 환경, 네트워크 서비스로 이어지며 발전했다. Parallelism 의 발전은 물리적 제약 (CPU 단일코어) 의 극복을 위한 하드웨어 진보 (멀티코어, GPU) 와 맞물려 성능 향상을 목적으로 발전해왔다. 최근에는 클라우드, 분산 시스템, AI/ML, IoT 환경의 확산으로 병렬성과 동시성을 동시에 활용하는 설계가 일반화되었다. 특히, 비동기 처리 모델(Promise, async/await, Rx, coroutine 등) 과 Actor Model, Dataflow 등의 설계 패턴은 실시간성과 확장성을 동시에 요구하는 현대 시스템에서 핵심 기술로 자리잡고 있다. 목적 및 필요성 성능 향상 및 처리량 극대화
...</p></div><footer class=entry-footer><span title='2024-10-05 02:38:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;<span>62 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Concurrency vs.Parallelism" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/concurrency-vs-parallelism/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>