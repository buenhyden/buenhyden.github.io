<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>복잡도 클래스(Complexity Classes) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Fundamentals,Complexity-Classes"><meta name=description content="계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="복잡도 클래스(Complexity Classes)"><meta property="og:description" content="계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="복잡도 클래스(Complexity Classes)"><meta name=twitter:description content="계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"복잡도 클래스(Complexity Classes)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>복잡도 클래스(Complexity Classes)</h1><div class=post-description>계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.</div></header><div class=post-content><h2 id=복잡도-클래스complexity-classes>복잡도 클래스(Complexity Classes)<a hidden class=anchor aria-hidden=true href=#복잡도-클래스complexity-classes>#</a></h2><p>복잡도 클래스(Complexity Classes)는 계산 이론의 핵심 개념으로, 문제 해결에 필요한 계산 자원(시간, 공간 등)의 양에 따라 문제들을 분류하는 체계이다.</p><p>복잡도 클래스는 계산 복잡도 이론의 핵심 개념으로, 알고리즘과 문제의 복잡성을 분류하고 이해하는 데 중요한 역할을 한다. 이 분야는 컴퓨터 과학에서 &ldquo;무엇이 효율적으로 계산 가능한가?&ldquo;라는 근본적인 질문을 다룬다.</p><p>알고리즘의 효율성 분석과 문제 간의 관계 이해에 기여하며, 특히 <strong>P vs NP 문제</strong>와 같은 근본적인 질문을 탐구하는 기반이 된다. <strong>P vs NP</strong> 문제를 비롯한 미해결 과제들은 인공지능, 암호학, 최적화 분야에 직간접적 영향을 미친다.</p><p><figure><img alt="Complexity Classes" loading=lazy src=/img/complexity-classes.png><figcaption>Source: https://www.geeksforgeeks.org/types-of-complexity-classes-p-np-conp-np-hard-and-np-complete/</figcaption></figure></p><h3 id=주요-복잡도-클래스>주요 복잡도 클래스<a hidden class=anchor aria-hidden=true href=#주요-복잡도-클래스>#</a></h3><p><code>L ⊆ NL ⊆ P ⊆ NP ⊆ PSPACE = NPSPACE ⊆ EXPTIME ⊆ EXPSPACE</code></p><h4 id=p-polynomial-time>P (Polynomial Time)<a hidden class=anchor aria-hidden=true href=#p-polynomial-time>#</a></h4><ul><li><strong>정의</strong>: 결정론적 튜링 머신에서 다항 시간에 해결할 수 있는 문제들의 집합</li><li><strong>특징</strong>: 효율적으로 <strong>해결 가능</strong>한 문제들</li><li><strong>예시</strong>: 정렬(Sorting), 이진 검색(Binary Search), 최단 경로 찾기(Shortest Path)</li><li><strong>수학적 표현</strong>: P = { L | L은 다항 시간 안에 결정론적 튜링 머신으로 결정 가능 }</li></ul><h4 id=np-non-deterministic-polynomial-time>NP (Non-deterministic Polynomial Time)<a hidden class=anchor aria-hidden=true href=#np-non-deterministic-polynomial-time>#</a></h4><ul><li><strong>정의</strong>: 비결정론적 튜링 머신에서 다항 시간에 해결할 수 있는 문제들의 집합</li><li><strong>특징</strong>: 해답이 주어지면 다항 시간 내에 <strong>검증 가능</strong>한 문제들</li><li><strong>예시</strong>: 부분집합 합 문제(Subset Sum), 해밀턴 경로(Hamiltonian Path), 배낭 문제(Knapsack Problem)</li><li><strong>수학적 표현</strong>: NP = { L | L은 다항 시간 안에 비결정론적 튜링 머신으로 결정 가능 }</li></ul><h4 id=np-완전np-complete>NP-완전(NP-Complete)<a hidden class=anchor aria-hidden=true href=#np-완전np-complete>#</a></h4><ul><li><strong>정의</strong>: NP의 모든 문제가 다항 시간 내에 환원(reduce)될 수 있는 NP 문제들의 집합</li><li><strong>특징</strong>: NP에서 가장 어려운 문제들로, 하나라도 다항 시간에 해결되면 모든 NP 문제가 다항 시간에 해결됨</li><li><strong>예시</strong>: 3SAT(Boolean Satisfiability Problem), 순회 판매원 문제(Traveling Salesman Problem)</li><li><strong>중요성</strong>: P=NP 문제의 핵심</li></ul><h4 id=np-난해np-hard>NP-난해(NP-Hard)<a hidden class=anchor aria-hidden=true href=#np-난해np-hard>#</a></h4><ul><li><strong>정의</strong>: 적어도 NP 문제만큼 어려운 문제들의 집합 (NP에 속할 필요는 없음)</li><li><strong>특징</strong>: NP의 모든 문제가 다항 시간 내에 이 문제로 환원될 수 있음</li><li><strong>예시</strong>: 일반 형태의 순회 판매원 문제, 최적 스케줄링</li></ul><h4 id=pspace>PSPACE<a hidden class=anchor aria-hidden=true href=#pspace>#</a></h4><ul><li><strong>정의</strong>: 다항 공간에 해결할 수 있는 문제들의 집합</li><li><strong>특징</strong>: P ⊆ NP ⊆ PSPACE</li><li><strong>예시</strong>: 양자화된 불리언 공식(TQBF), 일부 게임 전략</li></ul><p><strong>PSPACE</strong>는 NP를 포함하지만, 실제로 NP와의 관계는 명확하지 않다.<br>PSPACE-완전 문제(예: 양자 회로 시뮬레이션)는 이론적으로 지수 시간이 필요하지만, 다항 공간만 사용한다는 점에서 NP-완전 문제와 구별된다.<br>예를 들어, <strong>QBF(Quantified Boolean Formula)</strong> 문제는 PSPACE-완전으로, 모든 가능한 변수 할당을 재귀적으로 검토하지만 공간 재사용을 통해 메모리 사용을 최적화한다.</p><h4 id=exptime>EXPTIME<a hidden class=anchor aria-hidden=true href=#exptime>#</a></h4><ul><li><strong>정의</strong>: 지수 시간에 해결할 수 있는 문제들의 집합</li><li><strong>특징</strong>: PSPACE ⊆ EXPTIME</li><li><strong>예시</strong>: 체스와 같은 복잡한 게임에서 최적의 움직임 찾기</li></ul><h3 id=복잡도-클래스-간의-관계>복잡도 클래스 간의 관계<a hidden class=anchor aria-hidden=true href=#복잡도-클래스-간의-관계>#</a></h3><p>현재까지 알려진 복잡도 클래스 간의 관계는 다음과 같다:</p><p><code>L ⊆ NL ⊆ P ⊆ NP ⊆ PSPACE ⊆ EXPTIME ⊆ NEXPTIME ⊆ EXPSPACE</code></p><ul><li><strong>L(Logarithmic Space)</strong>: 로그 공간으로 해결 가능한 문제들 (예: 그래프 연결성 검사).</li><li><strong>PSPACE</strong>: 다항 공간으로 해결 가능한 문제들 (예: 양자 게임 이론의 특정 문제).</li><li><strong>EXPTIME</strong>: 지수 시간이 필요한 문제들 (예: 체스의 완전한 전략 수립).</li></ul><p>그러나 이 포함 관계 중 어느 것이 진정한 부분집합(⊂)인지는 아직 증명되지 않았다.<br>이 중 가장 유명한 미해결 문제가 P=NP 문제이다.</p><h3 id=pnp-문제>P=NP 문제<a hidden class=anchor aria-hidden=true href=#pnp-문제>#</a></h3><p>컴퓨터 과학에서 가장 중요한 미해결 문제 중 하나:</p><ul><li><strong>문제</strong>: P와 NP가 동일한 클래스인가?</li><li><strong>의미</strong>: 만약 P=NP라면, 우리가 효율적으로 검증할 수 있는 모든 문제를 효율적으로 해결할 수도 있다는 의미</li><li><strong>영향</strong>: 만약 P=NP가 증명된다면, 암호학, 최적화, 인공지능 등 많은 분야에 혁명적인 변화가 일어날 것</li><li><strong>현재 상태</strong>: 대부분의 컴퓨터 과학자들은 P≠NP라고 믿지만, 아직 증명되지 않았다.</li></ul><h3 id=랜덤화-복잡도-클래스>랜덤화 복잡도 클래스<a hidden class=anchor aria-hidden=true href=#랜덤화-복잡도-클래스>#</a></h3><p>알고리즘이 랜덤성을 활용할 수 있을 때 등장하는 클래스:</p><ol><li><p>BPP (Bounded-error Probabilistic Polynomial Time)</p><ul><li>다항 시간 내에 일정 확률로 올바른 답을 주는 문제들</li><li><code>P ⊆ BPP</code>이며, <code>BPP ⊆ PSPACE</code></li></ul></li><li><p>RP (Randomized Polynomial Time)</p><ul><li>다항 시간 내에 확률적으로 실행되지만, 긍정적인 답만 정확히 인식하는 문제들</li><li><code>P ⊆ RP ⊆ NP</code></li></ul></li><li><p>ZPP (Zero-error Probabilistic Polynomial Time)</p><ul><li>항상 올바른 답을 주며, 예상 실행 시간이 다항식인 문제들</li><li><code>ZPP = RP ∩ co-RP</code></li></ul></li></ol><h3 id=병렬-계산-복잡도-클래스>병렬 계산 복잡도 클래스<a hidden class=anchor aria-hidden=true href=#병렬-계산-복잡도-클래스>#</a></h3><p>여러 프로세서가 동시에 작업할 때의 복잡도 클래스:</p><ol><li>NC (Nick&rsquo;s Class)<ul><li>병렬 프로세서에서 다항 수의 프로세서와 다항 로그 시간 내에 해결 가능한 문제들</li><li>병렬화가 잘 되는 문제들의 클래스</li><li>P-완전 문제들은 병렬화하기 어려운 문제들</li></ul></li></ol><h3 id=양자-복잡도-클래스>양자 복잡도 클래스<a hidden class=anchor aria-hidden=true href=#양자-복잡도-클래스>#</a></h3><p>양자 컴퓨터에서의 복잡도 클래스:</p><ol><li>BQP (Bounded-error Quantum Polynomial Time)<ul><li>양자 컴퓨터에서 다항 시간 내에 일정 확률로 올바른 답을 주는 문제들</li><li><code>BPP ⊆ BQP ⊆ PSPACE</code></li><li>소인수분해와 이산 로그 문제가 여기에 속함</li></ul></li></ol><h3 id=복잡도-클래스의-실제-응용>복잡도 클래스의 실제 응용<a hidden class=anchor aria-hidden=true href=#복잡도-클래스의-실제-응용>#</a></h3><p>복잡도 클래스 이론은 이론적인 것처럼 보이지만, 실제로 많은 응용이 있다:</p><ol><li><p>암호학<br>현대 암호 시스템의 많은 부분이 P≠NP 가정에 기반한다. 만약 P=NP라면, RSA와 같은 많은 암호화 방식이 안전하지 않게 된다.</p></li><li><p>최적화<br>많은 최적화 문제들이 NP-난해하기 때문에, 근사 알고리즘이나 휴리스틱 방법을 사용해야 한다.</p></li><li><p>알고리즘 설계<br>문제의 복잡도 클래스를 이해하면 적절한 접근 방식을 선택하는 데 도움이 된다:</p><ul><li>P 클래스 문제: 정확한 알고리즘을 찾는 데 집중</li><li>NP-완전/NP-난해 문제: 근사 알고리즘, 휴리스틱, 매개변수화된 알고리즘 등을 고려</li></ul></li></ol><h3 id=최근-연구-동향>최근 연구 동향<a hidden class=anchor aria-hidden=true href=#최근-연구-동향>#</a></h3><p>복잡도 이론 분야의 최근 연구 동향은 다음과 같다:</p><ol><li><p>세밀한 복잡도 이론(Fine-grained Complexity Theory)<br>P 클래스 내에서의 더 세밀한 구분을 연구한다.<br>예를 들어, 어떤 문제들이 정확히 O(n²) 시간이 필요하고, O(n²-ε)에는 해결할 수 없는지 연구한다.</p></li><li><p>매개변수화된 복잡도(Parameterized Complexity)<br>문제의 복잡도를 입력 크기뿐만 아니라 다른 매개변수에 따라 분석한다.<br>이를 통해 NP-난해 문제라도 특정 매개변수가 고정될 때 효율적으로 해결할 수 있다.</p></li><li><p>양자 우위(Quantum Supremacy)<br>양자 컴퓨터가 기존 컴퓨터보다 확실히 빠르게 해결할 수 있는 문제를 찾는 연구가 활발히 진행 중이다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>환원 가능성 (Reducibility)</h2></header><div class=entry-content><p>환원 가능성 (Reducibility) 환원 가능성(Reducibility)은 이론 컴퓨터 과학, 특히 계산 복잡도 이론에서 핵심적인 개념으로, 문제들 간의 상대적 난이도를 비교하고 분류하는 강력한 도구이다.
환원 가능성은 계산 복잡도 이론의 핵심 개념으로, 문제들 간의 상대적 난이도를 이해하는 데 필수적인 도구이다.
이는 NP-완전성 증명, 알고리즘 설계, 복잡도 클래스 구조화 등 다양한 이론적, 실용적 목적으로 활용된다.
환원 가능성의 연구는 여전히 활발하게 진행 중이며, 양자 계산, 평균 케이스 복잡도, 매개변수화된 복잡도 등 새로운 계산 모델과 복잡도 측정 방식에 맞춰 계속 발전하고 있다. 이러한 개념의 이해는 컴퓨터 과학의 근본적인 질문인 “어떤 문제가 효율적으로 해결 가능한가?“에 대한 통찰을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 12:03:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 환원 가능성 (Reducibility)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/reducibility/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Classes of Complexity Classes</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-01-14 11:28:00 +0000 UTC'>January 14, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Classes of Complexity Classes" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>