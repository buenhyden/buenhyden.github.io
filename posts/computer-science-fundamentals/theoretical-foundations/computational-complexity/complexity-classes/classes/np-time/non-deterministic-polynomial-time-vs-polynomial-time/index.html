<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Non-deterministic Polynomial Time vs. Polynomial Time | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Complexity-Classes,Classes,NP-Time,Non-deterministic-Polynomial-Time,Polynomial-Time"><meta name=description content="계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Non-deterministic Polynomial Time vs. Polynomial Time"><meta property="og:description" content="계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-27T01:03:00+00:00"><meta property="article:modified_time" content="2024-12-27T01:03:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Complexity-Classes"><meta property="article:tag" content="Classes"><meta property="article:tag" content="NP-Time"><meta property="article:tag" content="Non-Deterministic-Polynomial-Time"><meta property="article:tag" content="Polynomial-Time"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Non-deterministic Polynomial Time vs. Polynomial Time"><meta name=twitter:description content="계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기록하고 기억하고 활용하자.","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Theoretical Foundations","item":""},{"@type":"ListItem","position":5,"name":"복잡도 클래스(Complexity Classes)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/"},{"@type":"ListItem","position":6,"name":"Classes of Complexity Classes","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/"},{"@type":"ListItem","position":7,"name":"비결정론적 다항 시간(Non-deterministic Polynomial Time, NP)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/"},{"@type":"ListItem","position":8,"name":"Non-deterministic Polynomial Time vs. Polynomial Time","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Non-deterministic Polynomial Time vs. Polynomial Time","name":"Non-deterministic Polynomial Time vs. Polynomial Time","description":"계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.","keywords":["Data-Structures-and-Algorithms","Complexity-Classes","Classes","NP-Time","Non-deterministic-Polynomial-Time","Polynomial-Time"],"articleBody":"Non-deterministic Polynomial Time vs. Polynomial Time 계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.\n이 두 클래스는 컴퓨터 과학의 발전 방향을 결정했으며, 현대 암호학과 알고리즘 설계의 이론적 토대를 형성했다.\nP와 NP 클래스의 구분은 계산 복잡도 이론의 근간을 이루며, 어떤 문제가 효율적으로 해결 가능한지에 대한 근본적인 이해를 제공한다.\nP 클래스 문제는 표준 컴퓨터로 효율적으로 해결할 수 있지만, NP 클래스의 많은 문제들(특히 NP-완전 문제들)은 현재 알려진 알고리즘으로는 효율적으로 해결할 수 없다.\nP = NP 문제의 해결은 컴퓨터 과학의 가장 중요한 미해결 과제 중 하나로 남아 있으며, 그 해결은 계산 이론뿐만 아니라 실제 응용에도 혁명적인 영향을 미칠 것이다.\n대부분의 전문가들은 P ≠ NP라고 믿지만, 아직 확정적인 증명은 없다.\n기본 개념 정의 결정론적 다항 시간(P, Polynomial Time) 결정론적 다항 시간(P, Polynomial Time)은 결정론적 튜링 기계(Deterministic Turing Machine)에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합을 의미한다. 간단히 말해, 입력 크기 n에 대해 O(n^k)의 시간 복잡도(k는 상수)를 가진 알고리즘으로 해결할 수 있는 문제들이다.\n결정론적 계산 모델에서는 각 상태와 입력에 대해 정확히 하나의 다음 상태가 결정된다. 즉, 계산의 각 단계마다 컴퓨터가 수행할 명확한 단일 동작이 있으며, 항상 동일한 입력에 대해 동일한 계산 경로를 따라 실행된다.\n비결정론적 다항 시간(NP, Non-deterministic Polynomial Time) 비결정론적 다항 시간(NP, Non-deterministic Polynomial Time)은 비결정론적 튜링 기계에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합이다.\n동등한 정의로, 해답이 주어졌을 때 그 정확성을 다항 시간 내에 검증할 수 있는 문제들의 집합으로 볼 수 있다.\n비결정론적 계산 모델에서는 각 상태와 입력에 대해 여러 개의 가능한 다음 상태가 존재할 수 있다. 이런 모델은 마치 계산의 모든 가능한 경로를 동시에 탐색하는 것처럼 작동한다고 생각할 수 있다. 하나의 경로라도 수용 상태에 도달하면 입력을 수용한다.\n계산 모델 비교 결정론적 튜링 기계(DTM) 결정론적 튜링 기계(DTM)는 현재 상태와 읽은 심볼에 따라 다음 행동이 유일하게 결정되는 계산 모델이다.\n이는 일반적인 컴퓨터의 작동 방식과 유사하다.\n1 상태 전이 함수: δ: Q × Γ → Q × Γ × {L, R, S} 여기서:\nQ: 상태 집합 Γ: 테이프 알파벳 L, R, S: 왼쪽, 오른쪽, 제자리 이동 DTM에서 실행은 초기 구성에서 시작하여 순차적으로 진행된다.\n각 단계에서 정확히 하나의 다음 구성이 있다.\n비결정론적 튜링 기계(NTM) 비결정론적 튜링 기계(NTM)는 현재 상태와 읽은 심볼에 대해 여러 가능한 행동이 존재할 수 있는 계산 모델이다.\n이는 실제로 구현 가능한 물리적 기계가 아니라 이론적 계산 모델이다.\n1 상태 전이 함수: δ: Q × Γ → P(Q × Γ × {L, R, S}) 여기서 P는 멱집합(power set)을 나타낸다.\nNTM의 실행은 계산 트리 형태로 표현될 수 있으며, 하나의 경로라도 수용 상태에 도달하면 입력을 수용한다.\n이는 마치 병렬 계산을 수행하는 것처럼 생각할 수 있다.\n문제 해결 및 검증 관점에서의 차이 P 클래스의 문제 해결 P 클래스의 문제는 결정론적 알고리즘으로 효율적으로(다항 시간 내에) 해결 가능하다.\n이는 찾고자 하는 해답을 단계적으로 구성해나가는 과정을 의미한다.\n예를 들어, 그래프에서 두 정점 간의 최단 경로를 찾는 문제는 다익스트라(Dijkstra) 알고리즘을 사용하여 O(E log V) 시간에 해결할 수 있다.\nNP 클래스의 문제 검증 NP 클래스의 특징은 해답이 주어졌을 때 그 정확성을 다항 시간 내에 검증할 수 있다는 것이다.\n그러나 그 해답을 처음부터 찾는 과정은 다항 시간에 가능하다는 보장이 없다.\n예를 들어, 해밀턴 경로 문제에서 경로가 주어지면, 그것이 실제로 모든 정점을 정확히 한 번씩 방문하는지 쉽게 확인할 수 있다(O(n) 시간). 그러나 그러한 경로를 처음부터 찾는 것은 현재까지 알려진 알고리즘으로는 지수 시간이 필요하다.\nP와 NP의 관계 포함 관계 가장 기본적인 관계는 모든 P 클래스 문제는 NP 클래스에도 속한다는 것이다.\n즉, P ⊆ NP가 성립한다.\n이는 결정론적으로 다항 시간에 해결할 수 있는 문제는 당연히 그 해답을 다항 시간에 검증할 수도 있기 때문이다.\nP = NP 문제 컴퓨터 과학의 가장 중요한 미해결 문제 중 하나는 P = NP인지 여부이다.\n이 질문은 “효율적으로 검증할 수 있는 모든 문제를 효율적으로 해결할 수도 있는가?“를 묻는 것이다.\n만약 P = NP가 증명된다면, 현재 NP-완전으로 분류되는 많은 어려운 문제들(예: 외판원 문제, 배낭 문제 등)이 다항 시간에 해결 가능해진다.\n구체적인 예시를 통한 비교 P 클래스의 예시 문제 정렬 문제: 배열을 오름차순 또는 내림차순으로 정렬하는 문제 (O(n log n)) 최단 경로 문제: 그래프에서 두 정점 간의 최단 경로 찾기 (O(E log V)) 선형 방정식 풀이: Ax = b 형태의 방정식 해결 (O(n³)) 최대 유량 문제: 네트워크에서 소스에서 싱크까지의 최대 유량 찾기 (O(V²E)) 이분 그래프 판별: 주어진 그래프가 이분 그래프인지 판별 (O(V+E)) NP 클래스의 예시 문제 (P에 속하지 않을 가능성이 높은) 해밀턴 경로 문제: 그래프의 모든 정점을 정확히 한 번씩 방문하는 경로 찾기 외판원 문제(TSP): 모든 도시를 방문하고 출발점으로 돌아오는 최단 경로 찾기 부분집합 합 문제: 주어진 집합의 부분집합 중 합이 특정 값인 것 찾기 그래프 색칠 문제: 인접한 정점이 서로 다른 색을 갖도록 그래프 색칠하기 불 만족가능성 문제(SAT): 불리언 식이 참이 되도록 하는 변수 할당 찾기 검증 관점에서의 접근법 비교 P 클래스 문제의 검증과 해결 P 클래스 문제는 해결과 검증 모두 다항 시간에 가능하다.\n예를 들어, 두 도시 간의 최단 경로를 찾는 문제에서:\n해결: 다익스트라 알고리즘으로 O(E log V) 시간에 최단 경로 찾기 검증: 주어진 경로의 총 거리를 계산하고 최단 거리와 비교 (O(E)) NP 클래스 문제의 검증과 해결 NP 클래스 문제는 검증은 다항 시간에 가능하지만, 해결은 현재 알려진 알고리즘으로 지수 시간이 필요할 수 있다.\n예를 들어, 해밀턴 경로 문제에서:\n해결: 현재 알려진 방법으로는 O(2^n) 시간 소요 검증: 주어진 경로가 모든 정점을 정확히 한 번씩 방문하는지 확인 (O(n)) 알고리즘 디자인 패러다임 비교 P 클래스를 위한 알고리즘 디자인 P 클래스 문제를 해결하기 위한, 결정론적이고 효율적인 알고리즘을 위한 주요 패러다임:\n그리디 알고리즘: 각 단계에서 지역적으로 최적의 선택 분할 정복: 문제를 더 작은 부분 문제로 나누어 해결 동적 프로그래밍: 부분 문제의 해를 저장하여 재활용 네트워크 흐름 알고리즘: 네트워크에서의 최적 흐름 계산 NP 클래스를 위한 접근법 NP 클래스 문제(특히 NP-완전 문제)를 다루기 위한 실용적인 접근법:\n백트래킹: 가능성이 있는 모든 해를 체계적으로 탐색 분기한정법(Branch and Bound): 유망하지 않은 해 공간을 가지치기 근사 알고리즘: 최적해에 근접한 해를 다항 시간에 찾기 휴리스틱: 경험적 규칙을 사용하여 좋은 해 찾기 메타휴리스틱: 시뮬레이티드 어닐링, 유전 알고리즘 등 사용 현실적 응용 관점에서의 차이 P 클래스 문제의 응용 P 클래스 문제는 해결 알고리즘이 효율적이므로 실용적인 응용에 직접 활용된다:\n데이터베이스 쿼리 최적화: 효율적인 쿼리 실행 계획 생성 네트워크 라우팅: 패킷 전송을 위한 최적 경로 결정 컴파일러 최적화: 코드 변환 및 최적화 이미지 처리: 필터링, 압축, 변환 알고리즘 NP 클래스 문제의 응용 NP 클래스 문제(특히 NP-완전, NP-난해)는 정확한 해결이 어려우므로 근사, 제약, 휴리스틱 등의 방법으로 접근한다:\n스케줄링 시스템: 작업, 리소스 할당을 위한 휴리스틱 알고리즘 물류 최적화: 배송 경로, 창고 위치 등을 근사 알고리즘으로 결정 VLSI 설계: 칩 레이아웃 최적화를 위한 휴리스틱 단백질 구조 예측: 에너지 최소화를 위한 근사 방법 이론적 영향과 중요성 P 클래스의 이론적 중요성 P 클래스는 “효율적으로 해결 가능한 문제\"의 수학적 정의로서, 알고리즘 복잡도 분석과 효율성 평가의 기준이 된다.\n또한 효율적인 알고리즘 디자인의 목표와 한계를 설정한다.\nNP 클래스의 이론적 중요성 NP 클래스는 “효율적으로 검증 가능한 문제\"를 정의함으로써, 문제의 난이도에 대한 더 넓은 분류 체계를 제공한다.\n특히 NP-완전성 개념을 통해 수많은 문제들의 본질적 어려움을 동등하게 분류할 수 있게 되었다.\nP vs NP 문제는 컴퓨터 과학의 근본적인 질문으로, 계산의 본질과 한계에 관한 철학적 함의도 갖는다.\n10. P와 NP 비교 특성 P (결정론적 다항 시간) NP (비결정론적 다항 시간) 정의 결정론적 튜링 기계로 다항 시간에 해결 가능한 문제 비결정론적 튜링 기계로 다항 시간에 해결 가능한 문제 또는 해답이 다항 시간에 검증 가능한 문제 계산 모델 결정론적 튜링 기계 (DTM) 비결정론적 튜링 기계 (NTM) 상태 전이 함수 δ: Q × Γ → Q × Γ × {L, R, S} δ: Q × Γ → P(Q × Γ × {L, R, S}) 실행 경로 각 입력에 대해 단일 실행 경로 각 입력에 대해 여러 가능한 실행 경로 해결 vs 검증 효율적 해결 + 효율적 검증 효율적 검증 (효율적 해결은 확실하지 않음) 대표적 문제 정렬, 최단 경로, 최대 유량, 이분 그래프 검사 SAT, 해밀턴 경로, TSP, 부분집합 합, 그래프 색칠 알고리즘 패러다임 그리디, 분할 정복, 동적 프로그래밍 백트래킹, 분기한정법, 근사 알고리즘, 휴리스틱 시간 복잡도 O(n^k), k는 상수 비결정론적 모델에서 O(n^k), 결정론적 모델에서는 보통 O(2^n) 이상 공간 복잡도 보통 다항 공간 보통 다항 공간 실용적 구현 직접 구현 가능 직접 구현 불가능, 시뮬레이션 필요 관계 P ⊆ NP NP ⊇ P (P = NP인지는 미해결) 포함하는 주요 하위 클래스 NC, L, NL P, NP-완전 완전성 개념 P-완전 (P 내에서 가장 어려운 문제들) NP-완전 (NP 내에서 가장 어려운 문제들) 현실적 응용 데이터베이스, 네트워크, 컴파일러, 이미지 처리 스케줄링, 물류, VLSI 설계, 생물정보학 병렬화 가능성 문제에 따라 다름 (일부는 효율적 병렬화 가능) 이론적으로는 “완벽한” 병렬화 가정 확률적 관점 결정론적, 확정적 결과 비결정론적 선택의 “행운적” 측면 검증자 관점 해답 생성 + 검증 모두 다항 시간 해답 검증만 다항 시간 보장 참고 및 출처 ","wordCount":"1349","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-27T01:03:00Z","dateModified":"2024-12-27T01:03:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기록하고 기억하고 활용하자.</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href>Theoretical Foundations</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/>복잡도 클래스(Complexity Classes)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/>Classes of Complexity Classes</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/>비결정론적 다항 시간(Non-deterministic Polynomial Time, NP)</a></div><h1 class="post-title entry-hint-parent">Non-deterministic Polynomial Time vs. Polynomial Time</h1><div class=post-description>계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.</div><div class=post-meta><span title='2024-12-27 01:03:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Theoretical%20Foundations/Computational%20Complexity/Complexity%20Classes/Classes/NP%20Time/non-deterministic-polynomial-time-vs-polynomial-time.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#non-deterministic-polynomial-time-vs-polynomial-time>Non-deterministic Polynomial Time vs. Polynomial Time</a><ul><li><a href=#기본-개념-정의>기본 개념 정의</a></li><li><a href=#계산-모델-비교>계산 모델 비교</a></li><li><a href=#문제-해결-및-검증-관점에서의-차이>문제 해결 및 검증 관점에서의 차이</a></li><li><a href=#p와-np의-관계>P와 NP의 관계</a></li><li><a href=#구체적인-예시를-통한-비교>구체적인 예시를 통한 비교</a></li><li><a href=#검증-관점에서의-접근법-비교>검증 관점에서의 접근법 비교</a></li><li><a href=#알고리즘-디자인-패러다임-비교>알고리즘 디자인 패러다임 비교</a></li><li><a href=#현실적-응용-관점에서의-차이>현실적 응용 관점에서의 차이</a></li><li><a href=#이론적-영향과-중요성>이론적 영향과 중요성</a></li><li><a href=#10-p와-np-비교>10. P와 NP 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=non-deterministic-polynomial-time-vs-polynomial-time>Non-deterministic Polynomial Time vs. Polynomial Time<a hidden class=anchor aria-hidden=true href=#non-deterministic-polynomial-time-vs-polynomial-time>#</a></h2><p>계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.<br>이 두 클래스는 컴퓨터 과학의 발전 방향을 결정했으며, 현대 암호학과 알고리즘 설계의 이론적 토대를 형성했다.</p><p>P와 NP 클래스의 구분은 계산 복잡도 이론의 근간을 이루며, 어떤 문제가 효율적으로 해결 가능한지에 대한 근본적인 이해를 제공한다.<br>P 클래스 문제는 표준 컴퓨터로 효율적으로 해결할 수 있지만, NP 클래스의 많은 문제들(특히 NP-완전 문제들)은 현재 알려진 알고리즘으로는 효율적으로 해결할 수 없다.</p><p>P = NP 문제의 해결은 컴퓨터 과학의 가장 중요한 미해결 과제 중 하나로 남아 있으며, 그 해결은 계산 이론뿐만 아니라 실제 응용에도 혁명적인 영향을 미칠 것이다.<br>대부분의 전문가들은 P ≠ NP라고 믿지만, 아직 확정적인 증명은 없다.</p><h3 id=기본-개념-정의>기본 개념 정의<a hidden class=anchor aria-hidden=true href=#기본-개념-정의>#</a></h3><h4 id=결정론적-다항-시간p-polynomial-time>결정론적 다항 시간(P, Polynomial Time)<a hidden class=anchor aria-hidden=true href=#결정론적-다항-시간p-polynomial-time>#</a></h4><p>결정론적 다항 시간(P, Polynomial Time)은 결정론적 튜링 기계(Deterministic Turing Machine)에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합을 의미한다. 간단히 말해, 입력 크기 n에 대해 O(n^k)의 시간 복잡도(k는 상수)를 가진 알고리즘으로 해결할 수 있는 문제들이다.<br>결정론적 계산 모델에서는 각 상태와 입력에 대해 정확히 하나의 다음 상태가 결정된다. 즉, 계산의 각 단계마다 컴퓨터가 수행할 명확한 단일 동작이 있으며, 항상 동일한 입력에 대해 동일한 계산 경로를 따라 실행된다.</p><h4 id=비결정론적-다항-시간np-non-deterministic-polynomial-time>비결정론적 다항 시간(NP, Non-deterministic Polynomial Time)<a hidden class=anchor aria-hidden=true href=#비결정론적-다항-시간np-non-deterministic-polynomial-time>#</a></h4><p>비결정론적 다항 시간(NP, Non-deterministic Polynomial Time)은 비결정론적 튜링 기계에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합이다.<br>동등한 정의로, 해답이 주어졌을 때 그 정확성을 다항 시간 내에 검증할 수 있는 문제들의 집합으로 볼 수 있다.</p><p>비결정론적 계산 모델에서는 각 상태와 입력에 대해 여러 개의 가능한 다음 상태가 존재할 수 있다. 이런 모델은 마치 계산의 모든 가능한 경로를 동시에 탐색하는 것처럼 작동한다고 생각할 수 있다. 하나의 경로라도 수용 상태에 도달하면 입력을 수용한다.</p><h3 id=계산-모델-비교>계산 모델 비교<a hidden class=anchor aria-hidden=true href=#계산-모델-비교>#</a></h3><h4 id=결정론적-튜링-기계dtm>결정론적 튜링 기계(DTM)<a hidden class=anchor aria-hidden=true href=#결정론적-튜링-기계dtm>#</a></h4><p>결정론적 튜링 기계(DTM)는 현재 상태와 읽은 심볼에 따라 다음 행동이 유일하게 결정되는 계산 모델이다.<br>이는 일반적인 컴퓨터의 작동 방식과 유사하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 전이 함수: δ: Q × Γ → Q × Γ × {L, R, S}
</span></span></code></pre></td></tr></table></div></div><p>여기서:</p><ul><li>Q: 상태 집합</li><li>Γ: 테이프 알파벳</li><li>L, R, S: 왼쪽, 오른쪽, 제자리 이동</li></ul><p>DTM에서 실행은 초기 구성에서 시작하여 순차적으로 진행된다.<br>각 단계에서 정확히 하나의 다음 구성이 있다.</p><h4 id=비결정론적-튜링-기계ntm>비결정론적 튜링 기계(NTM)<a hidden class=anchor aria-hidden=true href=#비결정론적-튜링-기계ntm>#</a></h4><p>비결정론적 튜링 기계(NTM)는 현재 상태와 읽은 심볼에 대해 여러 가능한 행동이 존재할 수 있는 계산 모델이다.<br>이는 실제로 구현 가능한 물리적 기계가 아니라 이론적 계산 모델이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 전이 함수: δ: Q × Γ → P(Q × Γ × {L, R, S})
</span></span></code></pre></td></tr></table></div></div><p>여기서 P는 멱집합(power set)을 나타낸다.</p><p>NTM의 실행은 계산 트리 형태로 표현될 수 있으며, 하나의 경로라도 수용 상태에 도달하면 입력을 수용한다.<br>이는 마치 병렬 계산을 수행하는 것처럼 생각할 수 있다.</p><h3 id=문제-해결-및-검증-관점에서의-차이>문제 해결 및 검증 관점에서의 차이<a hidden class=anchor aria-hidden=true href=#문제-해결-및-검증-관점에서의-차이>#</a></h3><h4 id=p-클래스의-문제-해결>P 클래스의 문제 해결<a hidden class=anchor aria-hidden=true href=#p-클래스의-문제-해결>#</a></h4><p>P 클래스의 문제는 결정론적 알고리즘으로 효율적으로(다항 시간 내에) 해결 가능하다.<br>이는 찾고자 하는 해답을 단계적으로 구성해나가는 과정을 의미한다.</p><p>예를 들어, 그래프에서 두 정점 간의 최단 경로를 찾는 문제는 다익스트라(Dijkstra) 알고리즘을 사용하여 O(E log V) 시간에 해결할 수 있다.</p><h4 id=np-클래스의-문제-검증>NP 클래스의 문제 검증<a hidden class=anchor aria-hidden=true href=#np-클래스의-문제-검증>#</a></h4><p>NP 클래스의 특징은 해답이 주어졌을 때 그 정확성을 다항 시간 내에 검증할 수 있다는 것이다.<br>그러나 그 해답을 처음부터 찾는 과정은 다항 시간에 가능하다는 보장이 없다.</p><p>예를 들어, 해밀턴 경로 문제에서 경로가 주어지면, 그것이 실제로 모든 정점을 정확히 한 번씩 방문하는지 쉽게 확인할 수 있다(O(n) 시간). 그러나 그러한 경로를 처음부터 찾는 것은 현재까지 알려진 알고리즘으로는 지수 시간이 필요하다.</p><h3 id=p와-np의-관계>P와 NP의 관계<a hidden class=anchor aria-hidden=true href=#p와-np의-관계>#</a></h3><h4 id=포함-관계>포함 관계<a hidden class=anchor aria-hidden=true href=#포함-관계>#</a></h4><p>가장 기본적인 관계는 모든 P 클래스 문제는 NP 클래스에도 속한다는 것이다.<br>즉, <code>P ⊆ NP</code>가 성립한다.</p><p>이는 결정론적으로 다항 시간에 해결할 수 있는 문제는 당연히 그 해답을 다항 시간에 검증할 수도 있기 때문이다.</p><h4 id=p--np-문제>P = NP 문제<a hidden class=anchor aria-hidden=true href=#p--np-문제>#</a></h4><p>컴퓨터 과학의 가장 중요한 미해결 문제 중 하나는 P = NP인지 여부이다.<br>이 질문은 &ldquo;효율적으로 검증할 수 있는 모든 문제를 효율적으로 해결할 수도 있는가?&ldquo;를 묻는 것이다.</p><p>만약 P = NP가 증명된다면, 현재 NP-완전으로 분류되는 많은 어려운 문제들(예: 외판원 문제, 배낭 문제 등)이 다항 시간에 해결 가능해진다.</p><h3 id=구체적인-예시를-통한-비교>구체적인 예시를 통한 비교<a hidden class=anchor aria-hidden=true href=#구체적인-예시를-통한-비교>#</a></h3><h4 id=p-클래스의-예시-문제>P 클래스의 예시 문제<a hidden class=anchor aria-hidden=true href=#p-클래스의-예시-문제>#</a></h4><ol><li><strong>정렬 문제</strong>: 배열을 오름차순 또는 내림차순으로 정렬하는 문제 (O(n log n))</li><li><strong>최단 경로 문제</strong>: 그래프에서 두 정점 간의 최단 경로 찾기 (O(E log V))</li><li><strong>선형 방정식 풀이</strong>: Ax = b 형태의 방정식 해결 (O(n³))</li><li><strong>최대 유량 문제</strong>: 네트워크에서 소스에서 싱크까지의 최대 유량 찾기 (O(V²E))</li><li><strong>이분 그래프 판별</strong>: 주어진 그래프가 이분 그래프인지 판별 (O(V+E))</li></ol><h4 id=np-클래스의-예시-문제-p에-속하지-않을-가능성이-높은>NP 클래스의 예시 문제 (P에 속하지 않을 가능성이 높은)<a hidden class=anchor aria-hidden=true href=#np-클래스의-예시-문제-p에-속하지-않을-가능성이-높은>#</a></h4><ol><li><strong>해밀턴 경로 문제</strong>: 그래프의 모든 정점을 정확히 한 번씩 방문하는 경로 찾기</li><li><strong>외판원 문제(TSP)</strong>: 모든 도시를 방문하고 출발점으로 돌아오는 최단 경로 찾기</li><li><strong>부분집합 합 문제</strong>: 주어진 집합의 부분집합 중 합이 특정 값인 것 찾기</li><li><strong>그래프 색칠 문제</strong>: 인접한 정점이 서로 다른 색을 갖도록 그래프 색칠하기</li><li><strong>불 만족가능성 문제(SAT)</strong>: 불리언 식이 참이 되도록 하는 변수 할당 찾기</li></ol><h3 id=검증-관점에서의-접근법-비교>검증 관점에서의 접근법 비교<a hidden class=anchor aria-hidden=true href=#검증-관점에서의-접근법-비교>#</a></h3><h4 id=p-클래스-문제의-검증과-해결>P 클래스 문제의 검증과 해결<a hidden class=anchor aria-hidden=true href=#p-클래스-문제의-검증과-해결>#</a></h4><p>P 클래스 문제는 해결과 검증 모두 다항 시간에 가능하다.<br>예를 들어, 두 도시 간의 최단 경로를 찾는 문제에서:</p><ul><li><strong>해결</strong>: 다익스트라 알고리즘으로 O(E log V) 시간에 최단 경로 찾기</li><li><strong>검증</strong>: 주어진 경로의 총 거리를 계산하고 최단 거리와 비교 (O(E))</li></ul><h4 id=np-클래스-문제의-검증과-해결>NP 클래스 문제의 검증과 해결<a hidden class=anchor aria-hidden=true href=#np-클래스-문제의-검증과-해결>#</a></h4><p>NP 클래스 문제는 검증은 다항 시간에 가능하지만, 해결은 현재 알려진 알고리즘으로 지수 시간이 필요할 수 있다.<br>예를 들어, 해밀턴 경로 문제에서:</p><ul><li><strong>해결</strong>: 현재 알려진 방법으로는 O(2^n) 시간 소요</li><li><strong>검증</strong>: 주어진 경로가 모든 정점을 정확히 한 번씩 방문하는지 확인 (O(n))</li></ul><h3 id=알고리즘-디자인-패러다임-비교>알고리즘 디자인 패러다임 비교<a hidden class=anchor aria-hidden=true href=#알고리즘-디자인-패러다임-비교>#</a></h3><h4 id=p-클래스를-위한-알고리즘-디자인>P 클래스를 위한 알고리즘 디자인<a hidden class=anchor aria-hidden=true href=#p-클래스를-위한-알고리즘-디자인>#</a></h4><p>P 클래스 문제를 해결하기 위한, 결정론적이고 효율적인 알고리즘을 위한 주요 패러다임:</p><ol><li><strong>그리디 알고리즘</strong>: 각 단계에서 지역적으로 최적의 선택</li><li><strong>분할 정복</strong>: 문제를 더 작은 부분 문제로 나누어 해결</li><li><strong>동적 프로그래밍</strong>: 부분 문제의 해를 저장하여 재활용</li><li><strong>네트워크 흐름 알고리즘</strong>: 네트워크에서의 최적 흐름 계산</li></ol><h4 id=np-클래스를-위한-접근법>NP 클래스를 위한 접근법<a hidden class=anchor aria-hidden=true href=#np-클래스를-위한-접근법>#</a></h4><p>NP 클래스 문제(특히 NP-완전 문제)를 다루기 위한 실용적인 접근법:</p><ol><li><strong>백트래킹</strong>: 가능성이 있는 모든 해를 체계적으로 탐색</li><li><strong>분기한정법(Branch and Bound)</strong>: 유망하지 않은 해 공간을 가지치기</li><li><strong>근사 알고리즘</strong>: 최적해에 근접한 해를 다항 시간에 찾기</li><li><strong>휴리스틱</strong>: 경험적 규칙을 사용하여 좋은 해 찾기</li><li><strong>메타휴리스틱</strong>: 시뮬레이티드 어닐링, 유전 알고리즘 등 사용</li></ol><h3 id=현실적-응용-관점에서의-차이>현실적 응용 관점에서의 차이<a hidden class=anchor aria-hidden=true href=#현실적-응용-관점에서의-차이>#</a></h3><h4 id=p-클래스-문제의-응용>P 클래스 문제의 응용<a hidden class=anchor aria-hidden=true href=#p-클래스-문제의-응용>#</a></h4><p>P 클래스 문제는 해결 알고리즘이 효율적이므로 실용적인 응용에 직접 활용된다:</p><ol><li><strong>데이터베이스 쿼리 최적화</strong>: 효율적인 쿼리 실행 계획 생성</li><li><strong>네트워크 라우팅</strong>: 패킷 전송을 위한 최적 경로 결정</li><li><strong>컴파일러 최적화</strong>: 코드 변환 및 최적화</li><li><strong>이미지 처리</strong>: 필터링, 압축, 변환 알고리즘</li></ol><h4 id=np-클래스-문제의-응용>NP 클래스 문제의 응용<a hidden class=anchor aria-hidden=true href=#np-클래스-문제의-응용>#</a></h4><p>NP 클래스 문제(특히 NP-완전, NP-난해)는 정확한 해결이 어려우므로 근사, 제약, 휴리스틱 등의 방법으로 접근한다:</p><ol><li><strong>스케줄링 시스템</strong>: 작업, 리소스 할당을 위한 휴리스틱 알고리즘</li><li><strong>물류 최적화</strong>: 배송 경로, 창고 위치 등을 근사 알고리즘으로 결정</li><li><strong>VLSI 설계</strong>: 칩 레이아웃 최적화를 위한 휴리스틱</li><li><strong>단백질 구조 예측</strong>: 에너지 최소화를 위한 근사 방법</li></ol><h3 id=이론적-영향과-중요성>이론적 영향과 중요성<a hidden class=anchor aria-hidden=true href=#이론적-영향과-중요성>#</a></h3><h4 id=p-클래스의-이론적-중요성>P 클래스의 이론적 중요성<a hidden class=anchor aria-hidden=true href=#p-클래스의-이론적-중요성>#</a></h4><p>P 클래스는 &ldquo;효율적으로 해결 가능한 문제"의 수학적 정의로서, 알고리즘 복잡도 분석과 효율성 평가의 기준이 된다.<br>또한 효율적인 알고리즘 디자인의 목표와 한계를 설정한다.</p><h4 id=np-클래스의-이론적-중요성>NP 클래스의 이론적 중요성<a hidden class=anchor aria-hidden=true href=#np-클래스의-이론적-중요성>#</a></h4><p>NP 클래스는 &ldquo;효율적으로 검증 가능한 문제"를 정의함으로써, 문제의 난이도에 대한 더 넓은 분류 체계를 제공한다.<br>특히 NP-완전성 개념을 통해 수많은 문제들의 본질적 어려움을 동등하게 분류할 수 있게 되었다.</p><p>P vs NP 문제는 컴퓨터 과학의 근본적인 질문으로, 계산의 본질과 한계에 관한 철학적 함의도 갖는다.</p><h3 id=10-p와-np-비교>10. P와 NP 비교<a hidden class=anchor aria-hidden=true href=#10-p와-np-비교>#</a></h3><table><thead><tr><th>특성</th><th>P (결정론적 다항 시간)</th><th>NP (비결정론적 다항 시간)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>결정론적 튜링 기계로 다항 시간에 해결 가능한 문제</td><td>비결정론적 튜링 기계로 다항 시간에 해결 가능한 문제 또는 해답이 다항 시간에 검증 가능한 문제</td></tr><tr><td><strong>계산 모델</strong></td><td>결정론적 튜링 기계 (DTM)</td><td>비결정론적 튜링 기계 (NTM)</td></tr><tr><td><strong>상태 전이 함수</strong></td><td>δ: Q × Γ → Q × Γ × {L, R, S}</td><td>δ: Q × Γ → P(Q × Γ × {L, R, S})</td></tr><tr><td><strong>실행 경로</strong></td><td>각 입력에 대해 단일 실행 경로</td><td>각 입력에 대해 여러 가능한 실행 경로</td></tr><tr><td><strong>해결 vs 검증</strong></td><td>효율적 해결 + 효율적 검증</td><td>효율적 검증 (효율적 해결은 확실하지 않음)</td></tr><tr><td><strong>대표적 문제</strong></td><td>정렬, 최단 경로, 최대 유량, 이분 그래프 검사</td><td>SAT, 해밀턴 경로, TSP, 부분집합 합, 그래프 색칠</td></tr><tr><td><strong>알고리즘 패러다임</strong></td><td>그리디, 분할 정복, 동적 프로그래밍</td><td>백트래킹, 분기한정법, 근사 알고리즘, 휴리스틱</td></tr><tr><td><strong>시간 복잡도</strong></td><td>O(n^k), k는 상수</td><td>비결정론적 모델에서 O(n^k), 결정론적 모델에서는 보통 O(2^n) 이상</td></tr><tr><td><strong>공간 복잡도</strong></td><td>보통 다항 공간</td><td>보통 다항 공간</td></tr><tr><td><strong>실용적 구현</strong></td><td>직접 구현 가능</td><td>직접 구현 불가능, 시뮬레이션 필요</td></tr><tr><td><strong>관계</strong></td><td>P ⊆ NP</td><td>NP ⊇ P (P = NP인지는 미해결)</td></tr><tr><td><strong>포함하는 주요 하위 클래스</strong></td><td>NC, L, NL</td><td>P, NP-완전</td></tr><tr><td><strong>완전성 개념</strong></td><td>P-완전 (P 내에서 가장 어려운 문제들)</td><td>NP-완전 (NP 내에서 가장 어려운 문제들)</td></tr><tr><td><strong>현실적 응용</strong></td><td>데이터베이스, 네트워크, 컴파일러, 이미지 처리</td><td>스케줄링, 물류, VLSI 설계, 생물정보학</td></tr><tr><td><strong>병렬화 가능성</strong></td><td>문제에 따라 다름 (일부는 효율적 병렬화 가능)</td><td>이론적으로는 &ldquo;완벽한&rdquo; 병렬화 가정</td></tr><tr><td><strong>확률적 관점</strong></td><td>결정론적, 확정적 결과</td><td>비결정론적 선택의 &ldquo;행운적&rdquo; 측면</td></tr><tr><td><strong>검증자 관점</strong></td><td>해답 생성 + 검증 모두 다항 시간</td><td>해답 검증만 다항 시간 보장</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/complexity-classes/>Complexity-Classes</a></li><li><a href=https://buenhyden.github.io/tags/classes/>Classes</a></li><li><a href=https://buenhyden.github.io/tags/np-time/>NP-Time</a></li><li><a href=https://buenhyden.github.io/tags/non-deterministic-polynomial-time/>Non-Deterministic-Polynomial-Time</a></li><li><a href=https://buenhyden.github.io/tags/polynomial-time/>Polynomial-Time</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/><span class=title>« Prev</span><br><span>P vs NP problem</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/><span class=title>Next »</span><br><span>NP-Hard vs. NP-Complete</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>