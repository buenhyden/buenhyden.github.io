<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>NP-Hard vs. NP-Complete | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Fundamentals,Complexity-Classes,Classes,NP-Hard,NP-Complete"><meta name=description content="NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="NP-Hard vs. NP-Complete"><meta property="og:description" content="NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-27T01:02:00+00:00"><meta property="article:modified_time" content="2024-12-27T01:02:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Complexity-Classes"><meta property="article:tag" content="Classes"><meta property="article:tag" content="NP-Hard"><meta property="article:tag" content="NP-Complete"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="NP-Hard vs. NP-Complete"><meta name=twitter:description content="NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"},{"@type":"ListItem","position":3,"name":"Theoretical Foundations","item":""},{"@type":"ListItem","position":5,"name":"복잡도 클래스(Complexity Classes)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/"},{"@type":"ListItem","position":6,"name":"Classes of Complexity Classes","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/"},{"@type":"ListItem","position":7,"name":"NP-난해(NP-Hard)","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/"},{"@type":"ListItem","position":8,"name":"NP-Hard vs. NP-Complete","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NP-Hard vs. NP-Complete","name":"NP-Hard vs. NP-Complete","description":"NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.","keywords":["Data-Structures-and-Algorithms","Fundamentals","Complexity-Classes","Classes","NP-Hard","NP-Complete"],"articleBody":"NP-Hard vs. NP-Complete 계산 복잡도 이론에서 NP-Hard와 NP-Complete는 문제의 난이도를 분류하는 핵심 개념이다.\n이 두 클래스는 알고리즘과 계산 문제의 근본적인 한계를 이해하는 데 중요하며, 효율적인 문제 해결 접근법을 선택하는 데 필수적인 지식을 제공한다.\nNP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.\n핵심적인 차이점은 NP-Complete 문제는 반드시 NP에 속하고 결정 문제이지만, NP-Hard 문제는 NP에 속하지 않을 수도 있고 결정 문제가 아닐 수도 있다는 점이다. 이러한 차이로 인해 접근 방법과 응용 분야에도 차이가 있다.\n실제 개발과 연구에서는 문제가 NP-Complete인지 NP-Hard인지 파악하는 것이 중요하다.\n이를 통해 문제의 본질적 난이도를 이해하고, 적절한 알고리즘적 접근법을 선택할 수 있기 때문이다. 특히 NP-Hard 최적화 문제에 대해서는 근사 알고리즘과 휴리스틱이 널리 사용되며, NP-Complete 결정 문제에 대해서는 백트래킹과 매개변수화된 알고리즘이 주로 활용된다.\nP vs NP 문제가 미해결인 현 상황에서, 이러한 복잡도 클래스에 대한 이해는 효율적인 알고리즘 설계와 복잡한 문제 해결을 위한 실용적인 지침을 제공한다.\n기본 정의와 개념 NP-Hard (NP-난해) NP-Hard는 “적어도 NP 클래스의 모든 문제만큼 어려운” 문제들의 집합을 의미이다.\n형식적인 정의로는 다음과 같다:\n정의: 문제 H가 NP-Hard라는 것은, 모든 NP 문제가 다항 시간 내에 H로 환원(reduce)될 수 있다는 것을 의미한다.\n여기서 ‘환원’이란 한 문제를 다른 문제로 변환하는 과정을 말한다.\nA가 B로 환원된다는 것은 “B를 해결할 수 있다면 A도 해결할 수 있다\"는 의미이다. 중요한 점은 NP-Hard 문제가 반드시 NP 클래스에 속할 필요는 없다는 것이다.\n이는 NP-Hard 문제 중 일부는 결정 문제(decision problem)가 아니거나, 해답을 다항 시간에 검증하는 것조차 불가능할 수 있음을 의미한다.\nNP-Complete (NP-완전) NP-Complete는 NP-Hard이면서 동시에 NP 클래스에 속하는 문제들의 집합을 의미한다.\n즉, 다음 두 조건을 모두 만족하는 문제들이다:\nNP에 속함: 해답이 주어졌을 때 다항 시간에 검증 가능함 NP-Hard임: 모든 NP 문제가 이 문제로 다항 시간에 환원 가능함 정의: 문제 C가 NP-Complete라는 것은, C가 NP에 속하고 모든 NP 문제가 다항 시간 내에 C로 환원될 수 있다는 것을 의미한다.\n형식적으로는 NP-Complete = NP ∩ NP-Hard로 표현할 수 있다.\n계산 모델과 복잡도 관점에서의 차이 계산 모델 관점 NP-Complete 문제는 비결정론적 튜링 기계(Non-deterministic Turing Machine)의 프레임워크 내에서 정의된다.\n이러한 문제는 해답이 주어졌을 때 결정론적 튜링 기계에서 다항 시간에 검증 가능하다.\n반면, NP-Hard 문제는 반드시 튜링 기계의 프레임워크 내에 있을 필요가 없다. 예를 들어, 정지 문제(Halting Problem)와 같은 계산 불가능한 문제도 NP-Hard일 수 있다.\n결정 문제 vs. 최적화 문제 NP-Complete 문제는 항상 결정 문제(yes/no 답변이 있는 문제)이다.\n예를 들어, “그래프에 해밀턴 경로가 존재하는가?“는 결정 문제이다.\nNP-Hard 문제는 결정 문제일 수도 있고 최적화 문제일 수도 있다.\n예를 들어, “그래프에서 최단 해밀턴 경로의 길이는?“은 최적화 문제이며 NP-Hard이다.\n대표적인 문제 비교 NP-Complete 문제의 예 불 만족가능성 문제(SAT): 불리언 식이 참이 되게 하는 변수 할당이 존재하는지 판별하는 문제 해밀턴 경로 문제: 그래프의 모든 정점을 정확히 한 번씩 방문하는 경로가 존재하는지 판별하는 문제 부분집합 합 문제: 집합의 부분집합 중 합이 정확히 특정 값이 되는 것이 존재하는지 판별하는 문제 정점 커버 문제: 크기가 k 이하인 정점 집합으로 그래프의 모든 간선을 커버할 수 있는지 판별하는 문제 그래프 색칠 문제: 주어진 그래프를 k개의 색으로 적절히 색칠할 수 있는지 판별하는 문제 NP-Hard이지만 NP-Complete가 아닌 문제의 예 최적 순회 판매원 문제(TSP 최적화): 모든 도시를 방문하고 출발 도시로 돌아오는 최소 비용의 경로를 찾는 문제 (결정 버전은 NP-Complete) 정지 문제(Halting Problem): 주어진 프로그램과 입력에 대해 프로그램이 종료되는지 판별하는 문제 (계산 불가능한 문제) 해밀턴 경로 계수 문제: 그래프에 존재하는 해밀턴 경로의 수를 세는 문제 (계수 문제) 그래프 동형 문제: 두 그래프가 동형인지 판별하는 문제 (현재 정확한 복잡도 클래스가 알려지지 않음) 근사 색칠 문제: 그래프를 최소 수의 색으로 색칠하는 문제 (최적화 문제) 증명 방법 비교 NP-Complete 증명 방법 어떤 문제가 NP-Complete임을 증명하기 위해서는 두 단계를 거쳐야 한다:\n문제가 NP에 속함을 증명: 해답이 주어졌을 때 그것이 정말 해답인지 다항 시간에 검증할 수 있음을 보인다. 문제가 NP-Hard임을 증명: 이미 알려진 NP-Complete 문제에서 새로운 문제로의 다항 시간 환원을 보인다. 예를 들어, 해밀턴 경로 문제가 NP-Complete임을 증명하려면:\n해밀턴 경로가 주어졌을 때, 그것이 모든 정점을 정확히 한 번씩 방문하는지 O(n) 시간에 검증할 수 있음을 보인다. 이미 NP-Complete로 알려진 SAT 문제를 해밀턴 경로 문제로 다항 시간에 환원할 수 있음을 보인다. NP-Hard 증명 방법 NP-Hard 증명은 더 간단하다.\n이미 알려진 NP-Hard 문제에서 새로운 문제로의 다항 시간 환원만 보이면 된다.\n문제가 NP에 속하는지는 확인할 필요가 없다.\n예를 들어, 최적 TSP 문제가 NP-Hard임을 증명하려면:\n이미 NP-Hard로 알려진 TSP 결정 문제를 최적 TSP 문제로 다항 시간에 환원할 수 있음을 보인다. 문제 해결 접근법 비교 NP-Complete 문제를 위한 접근법 NP-Complete 문제는 결정 문제이므로, 해답의 존재 여부를 판별하는 데 초점을 맞춘다:\n정확한 알고리즘: 작은 인스턴스에 대해 백트래킹, 분기한정법, 동적 프로그래밍 등을 사용한다. 매개변수화된 알고리즘: 문제의 특정 매개변수가 작을 때 효율적인 알고리즘을 사용한다. 근사 알고리즘: “예” 인스턴스와 “아니오” 인스턴스를 구분하는 확률적 접근법을 사용할 수 있다. NP-Hard 최적화 문제를 위한 접근법 NP-Hard 최적화 문제는 최적의 해를 찾는 데 초점을 맞춘다:\n근사 알고리즘: 최적해에 대한 성능 보장이 있는 다항 시간 알고리즘을 사용한다. 휴리스틱: 경험적 규칙을 사용하여 좋은 해를 빠르게 찾는다. 메타휴리스틱: 시뮬레이티드 어닐링, 유전 알고리즘, 타부 검색 등의 일반적인 최적화 기법을 사용한다. 수리 계획법: 정수 선형 계획법, 제약 만족 문제 등으로 모델링하고 해결한다. 실제 응용 사례 비교 NP-Complete 문제의 응용 스케줄링 결정 문제: 주어진 리소스 제약 하에서 모든 작업이 특정 시간 내에 완료 가능한지 판별 회로 설계 검증: 논리 회로가 특정 속성을 만족하는지 검증 데이터베이스 쿼리 최적화: 쿼리 실행 계획이 특정 성능 요구사항을 충족하는지 판별 네트워크 설계 검증: 네트워크 토폴로지가 특정 요구사항을 만족하는지 검증 NP-Hard 문제의 응용 리소스 할당 최적화: 제한된 자원을 최적으로 배분하는 문제 네트워크 설계 최적화: 비용을 최소화하면서 필요한 연결성을 보장하는 네트워크 설계 로지스틱스: 배송 경로, 창고 위치 등을 최적화하는 문제 포트폴리오 최적화: 주어진 제약 조건 하에서 최대 수익을 내는 투자 포트폴리오 구성 기계 학습: 특성 선택, 모델 구조 최적화 등의 문제 계산 복잡도 이론에서의 위치 복잡도 계층에서의 위치 계산 복잡도 계층 구조에서 NP-Complete와 NP-Hard는 다음과 같은 위치에 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 +------------------+ | NP-Hard | | +------------+ | | | NP | | | | +------+ | | | | | P | | | | | | | | | | | +------+ | | | | | | | | NP-Complete| | | +------------+ | | | +------------------+ 이 다이어그램은 P ≠ NP라고 가정할 때의 관계를 보여준다. NP-Complete는 NP와 NP-Hard의 교집합에 위치한다.\n다른 복잡도 클래스와의 관계 P와의 관계: 만약 어떤 NP-Complete 문제가 P에 속한다면, P = NP가 된다. 반면, NP-Hard 문제 중 일부는 P ≠ NP라도 P에 속할 수 있다. PSPACE와의 관계: NP-Hard ⊆ PSPACE는 성립하지 않는다. 일부 NP-Hard 문제는 PSPACE를 넘어서는 복잡도를 가질 수 있다. 반면, 모든 NP-Complete 문제는 PSPACE에 속한다. #P와의 관계: 계수 복잡도 클래스 #P에 속하는 많은 문제들은 관련된 결정 문제가 NP-Complete일 때 #P-Complete이다. 예를 들어, 해밀턴 경로의 수를 세는 문제는 #P-Complete이다. 이론적 의미와 중요성 NP-Complete의 이론적 중요성 동등한 난이도: 모든 NP-Complete 문제는 계산적 난이도 측면에서 동등하다. 하나의 NP-Complete 문제에 대한 다항 시간 알고리즘은 모든 NP 문제에 대한 다항 시간 알고리즘을 의미한다. P vs NP 문제의 핵심: NP-Complete 문제는 P vs NP 문제의 핵심에 있다. 이들 중 하나라도 다항 시간에 해결할 수 있다면 P = NP가 증명된다. 난이도 분류 도구: NP-Complete 개념은 문제들을 복잡도에 따라 분류하는 강력한 도구를 제공한다. NP-Hard의 이론적 중요성 난이도의 하한선: NP-Hard 문제는 계산적 난이도의 하한선을 제공한다. 이들은 “적어도 NP만큼 어려운” 문제들이다. 최적화 문제의 프레임워크: NP-Hard는 최적화 문제의 난이도를 분석하는 프레임워크를 제공한다. 이를 통해 근사 알고리즘의 설계와 분석이 가능해진다. 계산 불가능성과의 연결: 일부 NP-Hard 문제는 계산 불가능(undecidable)할 수 있어, 계산 가능성 이론과 복잡도 이론을 연결한다. 최근 발전과 연구 동향 NP-Complete 문제 연구의 최근 동향 세밀한 복잡도 분석: 입력의 특정 매개변수에 따른 복잡도 분석을 통해 더 효율적인 알고리즘 개발 양자 알고리즘: 양자 컴퓨팅을 활용한 NP-Complete 문제 해결 가능성 연구 근사 난이도 분류: 근사 알고리즘에 기반한 새로운 복잡도 계층 연구 평균 케이스 분석: 무작위 인스턴스에 대한 복잡도 분석 NP-Hard 최적화 문제 연구의 최근 동향 근사 보존 환원: 근사 인자를 보존하는 환원 개념을 통한 최적화 문제의 난이도 분류 매개변수화된 복잡도: 특정 매개변수가 고정되었을 때의 복잡도 분석 휴리스틱과 ML의 결합: 머신 러닝 기법을 활용한 휴리스틱 최적화 분산 및 병렬 알고리즘: 대규모 NP-Hard 문제를 위한 분산 계산 접근법 NP-Hard vs. NP-Complete 비교 특성 NP-Hard NP-Complete 정의 모든 NP 문제가 다항 시간에 환원 가능한 문제 NP-Hard이면서 동시에 NP에 속하는 문제 형식적 정의 모든 L ∈ NP에 대해 L ≤p H인 문제 H C ∈ NP이고 모든 L ∈ NP에 대해 L ≤p C인 문제 C NP 소속 여부 NP에 속할 수도, 속하지 않을 수도 있음 반드시 NP에 속함 문제 유형 결정 문제, 최적화 문제, 함수 문제 등 반드시 결정 문제(예/아니오 답변) 해답 검증 가능성 다항 시간에 검증 가능하지 않을 수도 있음 반드시 다항 시간에 검증 가능 대표적 문제 최적 TSP, 정지 문제, 해밀턴 경로 계수 SAT, 해밀턴 경로, 정점 커버, 부분집합 합 증명 방법 알려진 NP-Hard 문제로부터의 환원만 필요 NP 소속 증명 + NP-Hard 증명 두 단계 필요 P=NP 가정 시 영향 일부는 여전히 다항 시간에 해결 불가능할 수 있음 모두 다항 시간에 해결 가능해짐 근사 가능성 일부는 근사 불가능할 수 있음 많은 경우 다항 시간 근사 알고리즘 존재 주요 접근 방법 근사 알고리즘, 휴리스틱, 매개변수화 등 백트래킹, 분기한정법, 매개변수화된 알고리즘 등 최초 증명된 문제 첫 NP-Hard 증명은 SAT(Cook, 1971) 첫 NP-Complete 증명은 SAT(Cook, 1971) 수리 계획법 모델링 정수 계획법, 비선형 최적화 등 다양한 형태 주로 정수 선형 계획법, 제약 만족 문제 실제 응용 분야 최적화, 리소스 할당, 설계 문제 등 검증, 스케줄링 결정, 안전성 분석 등 복잡도 계층 위치 NP를 포함하여 더 넓은 범위 NP와 NP-Hard의 교집합 계산 가능성 일부는 계산 불가능할 수 있음 모두 계산 가능(decidable) 다른 복잡도와의 관계 EXPTIME, PSPACE, 계산 불가능 문제 등 포함 가능 PSPACE에 포함됨 메모리 요구사항 다항 공간 이상 필요할 수 있음 대부분 다항 공간 내에서 해결 가능 참고 및 출처 ","wordCount":"1520","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-27T01:02:00Z","dateModified":"2024-12-27T01:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/>Computer Science Fundamentals</a>&nbsp;»&nbsp;<a href>Theoretical Foundations</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/>복잡도 클래스(Complexity Classes)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/>Classes of Complexity Classes</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/>NP-난해(NP-Hard)</a></div><h1 class="post-title entry-hint-parent">NP-Hard vs. NP-Complete</h1><div class=post-description>NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.</div><div class=post-meta><span title='2024-12-27 01:02:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science%20Fundamentals/Theoretical%20Foundations/Computational%20Complexity/Complexity%20Classes/Classes/NP-Hard/np-hard-vs-np-complete.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#np-hard-vs-np-complete>NP-Hard vs. NP-Complete</a><ul><li><a href=#기본-정의와-개념>기본 정의와 개념</a></li><li><a href=#계산-모델과-복잡도-관점에서의-차이>계산 모델과 복잡도 관점에서의 차이</a></li><li><a href=#대표적인-문제-비교>대표적인 문제 비교</a></li><li><a href=#증명-방법-비교>증명 방법 비교</a></li><li><a href=#문제-해결-접근법-비교>문제 해결 접근법 비교</a></li><li><a href=#실제-응용-사례-비교>실제 응용 사례 비교</a></li><li><a href=#계산-복잡도-이론에서의-위치>계산 복잡도 이론에서의 위치</a></li><li><a href=#이론적-의미와-중요성>이론적 의미와 중요성</a></li><li><a href=#최근-발전과-연구-동향>최근 발전과 연구 동향</a></li><li><a href=#np-hard-vs-np-complete-비교>NP-Hard vs. NP-Complete 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=np-hard-vs-np-complete>NP-Hard vs. NP-Complete<a hidden class=anchor aria-hidden=true href=#np-hard-vs-np-complete>#</a></h2><p>계산 복잡도 이론에서 NP-Hard와 NP-Complete는 문제의 난이도를 분류하는 핵심 개념이다.<br>이 두 클래스는 알고리즘과 계산 문제의 근본적인 한계를 이해하는 데 중요하며, 효율적인 문제 해결 접근법을 선택하는 데 필수적인 지식을 제공한다.</p><p>NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.</p><p>핵심적인 차이점은 NP-Complete 문제는 반드시 NP에 속하고 결정 문제이지만, NP-Hard 문제는 NP에 속하지 않을 수도 있고 결정 문제가 아닐 수도 있다는 점이다. 이러한 차이로 인해 접근 방법과 응용 분야에도 차이가 있다.</p><p>실제 개발과 연구에서는 문제가 NP-Complete인지 NP-Hard인지 파악하는 것이 중요하다.<br>이를 통해 문제의 본질적 난이도를 이해하고, 적절한 알고리즘적 접근법을 선택할 수 있기 때문이다. 특히 NP-Hard 최적화 문제에 대해서는 근사 알고리즘과 휴리스틱이 널리 사용되며, NP-Complete 결정 문제에 대해서는 백트래킹과 매개변수화된 알고리즘이 주로 활용된다.</p><p>P vs NP 문제가 미해결인 현 상황에서, 이러한 복잡도 클래스에 대한 이해는 효율적인 알고리즘 설계와 복잡한 문제 해결을 위한 실용적인 지침을 제공한다.</p><h3 id=기본-정의와-개념>기본 정의와 개념<a hidden class=anchor aria-hidden=true href=#기본-정의와-개념>#</a></h3><h4 id=np-hard-np-난해>NP-Hard (NP-난해)<a hidden class=anchor aria-hidden=true href=#np-hard-np-난해>#</a></h4><p>NP-Hard는 &ldquo;적어도 NP 클래스의 모든 문제만큼 어려운&rdquo; 문제들의 집합을 의미이다.</p><p>형식적인 정의로는 다음과 같다:</p><ul><li><strong>정의</strong>: 문제 H가 NP-Hard라는 것은, 모든 NP 문제가 다항 시간 내에 H로 환원(reduce)될 수 있다는 것을 의미한다.<br>여기서 &lsquo;환원&rsquo;이란 한 문제를 다른 문제로 변환하는 과정을 말한다.<br>A가 B로 환원된다는 것은 &ldquo;B를 해결할 수 있다면 A도 해결할 수 있다"는 의미이다.</li></ul><p>중요한 점은 NP-Hard 문제가 반드시 NP 클래스에 속할 필요는 없다는 것이다.<br>이는 NP-Hard 문제 중 일부는 결정 문제(decision problem)가 아니거나, 해답을 다항 시간에 검증하는 것조차 불가능할 수 있음을 의미한다.</p><h4 id=np-complete-np-완전>NP-Complete (NP-완전)<a hidden class=anchor aria-hidden=true href=#np-complete-np-완전>#</a></h4><p>NP-Complete는 NP-Hard이면서 동시에 NP 클래스에 속하는 문제들의 집합을 의미한다.<br>즉, 다음 두 조건을 모두 만족하는 문제들이다:</p><ol><li>NP에 속함: 해답이 주어졌을 때 다항 시간에 검증 가능함</li><li>NP-Hard임: 모든 NP 문제가 이 문제로 다항 시간에 환원 가능함</li></ol><p><strong>정의</strong>: 문제 C가 NP-Complete라는 것은, C가 NP에 속하고 모든 NP 문제가 다항 시간 내에 C로 환원될 수 있다는 것을 의미한다.<br>형식적으로는 <code>NP-Complete = NP ∩ NP-Hard</code>로 표현할 수 있다.</p><h3 id=계산-모델과-복잡도-관점에서의-차이>계산 모델과 복잡도 관점에서의 차이<a hidden class=anchor aria-hidden=true href=#계산-모델과-복잡도-관점에서의-차이>#</a></h3><h4 id=계산-모델-관점>계산 모델 관점<a hidden class=anchor aria-hidden=true href=#계산-모델-관점>#</a></h4><p>NP-Complete 문제는 비결정론적 튜링 기계(Non-deterministic Turing Machine)의 프레임워크 내에서 정의된다.<br>이러한 문제는 해답이 주어졌을 때 결정론적 튜링 기계에서 다항 시간에 검증 가능하다.</p><p>반면, NP-Hard 문제는 반드시 튜링 기계의 프레임워크 내에 있을 필요가 없다. 예를 들어, 정지 문제(Halting Problem)와 같은 계산 불가능한 문제도 NP-Hard일 수 있다.</p><h4 id=결정-문제-vs-최적화-문제>결정 문제 vs. 최적화 문제<a hidden class=anchor aria-hidden=true href=#결정-문제-vs-최적화-문제>#</a></h4><p>NP-Complete 문제는 항상 결정 문제(yes/no 답변이 있는 문제)이다.<br>예를 들어, &ldquo;그래프에 해밀턴 경로가 존재하는가?&ldquo;는 결정 문제이다.</p><p>NP-Hard 문제는 결정 문제일 수도 있고 최적화 문제일 수도 있다.<br>예를 들어, &ldquo;그래프에서 최단 해밀턴 경로의 길이는?&ldquo;은 최적화 문제이며 NP-Hard이다.</p><h3 id=대표적인-문제-비교>대표적인 문제 비교<a hidden class=anchor aria-hidden=true href=#대표적인-문제-비교>#</a></h3><h4 id=np-complete-문제의-예>NP-Complete 문제의 예<a hidden class=anchor aria-hidden=true href=#np-complete-문제의-예>#</a></h4><ol><li><strong>불 만족가능성 문제(SAT)</strong>: 불리언 식이 참이 되게 하는 변수 할당이 존재하는지 판별하는 문제</li><li><strong>해밀턴 경로 문제</strong>: 그래프의 모든 정점을 정확히 한 번씩 방문하는 경로가 존재하는지 판별하는 문제</li><li><strong>부분집합 합 문제</strong>: 집합의 부분집합 중 합이 정확히 특정 값이 되는 것이 존재하는지 판별하는 문제</li><li><strong>정점 커버 문제</strong>: 크기가 k 이하인 정점 집합으로 그래프의 모든 간선을 커버할 수 있는지 판별하는 문제</li><li><strong>그래프 색칠 문제</strong>: 주어진 그래프를 k개의 색으로 적절히 색칠할 수 있는지 판별하는 문제</li></ol><h4 id=np-hard이지만-np-complete가-아닌-문제의-예>NP-Hard이지만 NP-Complete가 아닌 문제의 예<a hidden class=anchor aria-hidden=true href=#np-hard이지만-np-complete가-아닌-문제의-예>#</a></h4><ol><li><strong>최적 순회 판매원 문제(TSP 최적화)</strong>: 모든 도시를 방문하고 출발 도시로 돌아오는 최소 비용의 경로를 찾는 문제 (결정 버전은 NP-Complete)</li><li><strong>정지 문제(Halting Problem)</strong>: 주어진 프로그램과 입력에 대해 프로그램이 종료되는지 판별하는 문제 (계산 불가능한 문제)</li><li><strong>해밀턴 경로 계수 문제</strong>: 그래프에 존재하는 해밀턴 경로의 수를 세는 문제 (계수 문제)</li><li><strong>그래프 동형 문제</strong>: 두 그래프가 동형인지 판별하는 문제 (현재 정확한 복잡도 클래스가 알려지지 않음)</li><li><strong>근사 색칠 문제</strong>: 그래프를 최소 수의 색으로 색칠하는 문제 (최적화 문제)</li></ol><h3 id=증명-방법-비교>증명 방법 비교<a hidden class=anchor aria-hidden=true href=#증명-방법-비교>#</a></h3><h4 id=np-complete-증명-방법>NP-Complete 증명 방법<a hidden class=anchor aria-hidden=true href=#np-complete-증명-방법>#</a></h4><p>어떤 문제가 NP-Complete임을 증명하기 위해서는 두 단계를 거쳐야 한다:</p><ol><li><strong>문제가 NP에 속함을 증명</strong>: 해답이 주어졌을 때 그것이 정말 해답인지 다항 시간에 검증할 수 있음을 보인다.</li><li><strong>문제가 NP-Hard임을 증명</strong>: 이미 알려진 NP-Complete 문제에서 새로운 문제로의 다항 시간 환원을 보인다.</li></ol><p>예를 들어, 해밀턴 경로 문제가 NP-Complete임을 증명하려면:</p><ul><li>해밀턴 경로가 주어졌을 때, 그것이 모든 정점을 정확히 한 번씩 방문하는지 O(n) 시간에 검증할 수 있음을 보인다.</li><li>이미 NP-Complete로 알려진 SAT 문제를 해밀턴 경로 문제로 다항 시간에 환원할 수 있음을 보인다.</li></ul><h4 id=np-hard-증명-방법>NP-Hard 증명 방법<a hidden class=anchor aria-hidden=true href=#np-hard-증명-방법>#</a></h4><p>NP-Hard 증명은 더 간단하다.<br>이미 알려진 NP-Hard 문제에서 새로운 문제로의 다항 시간 환원만 보이면 된다.<br>문제가 NP에 속하는지는 확인할 필요가 없다.</p><p>예를 들어, 최적 TSP 문제가 NP-Hard임을 증명하려면:</p><ul><li>이미 NP-Hard로 알려진 TSP 결정 문제를 최적 TSP 문제로 다항 시간에 환원할 수 있음을 보인다.</li></ul><h3 id=문제-해결-접근법-비교>문제 해결 접근법 비교<a hidden class=anchor aria-hidden=true href=#문제-해결-접근법-비교>#</a></h3><h4 id=np-complete-문제를-위한-접근법>NP-Complete 문제를 위한 접근법<a hidden class=anchor aria-hidden=true href=#np-complete-문제를-위한-접근법>#</a></h4><p>NP-Complete 문제는 결정 문제이므로, 해답의 존재 여부를 판별하는 데 초점을 맞춘다:</p><ol><li><strong>정확한 알고리즘</strong>: 작은 인스턴스에 대해 백트래킹, 분기한정법, 동적 프로그래밍 등을 사용한다.</li><li><strong>매개변수화된 알고리즘</strong>: 문제의 특정 매개변수가 작을 때 효율적인 알고리즘을 사용한다.</li><li><strong>근사 알고리즘</strong>: &ldquo;예&rdquo; 인스턴스와 &ldquo;아니오&rdquo; 인스턴스를 구분하는 확률적 접근법을 사용할 수 있다.</li></ol><h4 id=np-hard-최적화-문제를-위한-접근법>NP-Hard 최적화 문제를 위한 접근법<a hidden class=anchor aria-hidden=true href=#np-hard-최적화-문제를-위한-접근법>#</a></h4><p>NP-Hard 최적화 문제는 최적의 해를 찾는 데 초점을 맞춘다:</p><ol><li><strong>근사 알고리즘</strong>: 최적해에 대한 성능 보장이 있는 다항 시간 알고리즘을 사용한다.</li><li><strong>휴리스틱</strong>: 경험적 규칙을 사용하여 좋은 해를 빠르게 찾는다.</li><li><strong>메타휴리스틱</strong>: 시뮬레이티드 어닐링, 유전 알고리즘, 타부 검색 등의 일반적인 최적화 기법을 사용한다.</li><li><strong>수리 계획법</strong>: 정수 선형 계획법, 제약 만족 문제 등으로 모델링하고 해결한다.</li></ol><h3 id=실제-응용-사례-비교>실제 응용 사례 비교<a hidden class=anchor aria-hidden=true href=#실제-응용-사례-비교>#</a></h3><h4 id=np-complete-문제의-응용>NP-Complete 문제의 응용<a hidden class=anchor aria-hidden=true href=#np-complete-문제의-응용>#</a></h4><ol><li><strong>스케줄링 결정 문제</strong>: 주어진 리소스 제약 하에서 모든 작업이 특정 시간 내에 완료 가능한지 판별</li><li><strong>회로 설계 검증</strong>: 논리 회로가 특정 속성을 만족하는지 검증</li><li><strong>데이터베이스 쿼리 최적화</strong>: 쿼리 실행 계획이 특정 성능 요구사항을 충족하는지 판별</li><li><strong>네트워크 설계 검증</strong>: 네트워크 토폴로지가 특정 요구사항을 만족하는지 검증</li></ol><h4 id=np-hard-문제의-응용>NP-Hard 문제의 응용<a hidden class=anchor aria-hidden=true href=#np-hard-문제의-응용>#</a></h4><ol><li><strong>리소스 할당 최적화</strong>: 제한된 자원을 최적으로 배분하는 문제</li><li><strong>네트워크 설계 최적화</strong>: 비용을 최소화하면서 필요한 연결성을 보장하는 네트워크 설계</li><li><strong>로지스틱스</strong>: 배송 경로, 창고 위치 등을 최적화하는 문제</li><li><strong>포트폴리오 최적화</strong>: 주어진 제약 조건 하에서 최대 수익을 내는 투자 포트폴리오 구성</li><li><strong>기계 학습</strong>: 특성 선택, 모델 구조 최적화 등의 문제</li></ol><h3 id=계산-복잡도-이론에서의-위치>계산 복잡도 이론에서의 위치<a hidden class=anchor aria-hidden=true href=#계산-복잡도-이론에서의-위치>#</a></h3><h4 id=복잡도-계층에서의-위치>복잡도 계층에서의 위치<a hidden class=anchor aria-hidden=true href=#복잡도-계층에서의-위치>#</a></h4><p>계산 복잡도 계층 구조에서 NP-Complete와 NP-Hard는 다음과 같은 위치에 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>         +------------------+
</span></span><span class=line><span class=cl>         |     NP-Hard      |
</span></span><span class=line><span class=cl>         |  +------------+  |
</span></span><span class=line><span class=cl>         |  |    NP      |  |
</span></span><span class=line><span class=cl>         |  |  +------+  |  |
</span></span><span class=line><span class=cl>         |  |  |  P   |  |  |
</span></span><span class=line><span class=cl>         |  |  |      |  |  |
</span></span><span class=line><span class=cl>         |  |  +------+  |  |
</span></span><span class=line><span class=cl>         |  |            |  |
</span></span><span class=line><span class=cl>         |  | NP-Complete|  |
</span></span><span class=line><span class=cl>         |  +------------+  |
</span></span><span class=line><span class=cl>         |                  |
</span></span><span class=line><span class=cl>         +------------------+
</span></span></code></pre></td></tr></table></div></div><p>이 다이어그램은 P ≠ NP라고 가정할 때의 관계를 보여준다. NP-Complete는 NP와 NP-Hard의 교집합에 위치한다.</p><h4 id=다른-복잡도-클래스와의-관계>다른 복잡도 클래스와의 관계<a hidden class=anchor aria-hidden=true href=#다른-복잡도-클래스와의-관계>#</a></h4><ol><li><strong>P와의 관계</strong>: 만약 어떤 NP-Complete 문제가 P에 속한다면, P = NP가 된다. 반면, NP-Hard 문제 중 일부는 P ≠ NP라도 P에 속할 수 있다.</li><li><strong>PSPACE와의 관계</strong>: NP-Hard ⊆ PSPACE는 성립하지 않는다. 일부 NP-Hard 문제는 PSPACE를 넘어서는 복잡도를 가질 수 있다. 반면, 모든 NP-Complete 문제는 PSPACE에 속한다.</li><li><strong><code>#P</code>와의 관계</strong>: 계수 복잡도 클래스 <code>#P</code>에 속하는 많은 문제들은 관련된 결정 문제가 NP-Complete일 때 <code>#P-Complete</code>이다. 예를 들어, 해밀턴 경로의 수를 세는 문제는 <code>#P-Complete</code>이다.</li></ol><h3 id=이론적-의미와-중요성>이론적 의미와 중요성<a hidden class=anchor aria-hidden=true href=#이론적-의미와-중요성>#</a></h3><h4 id=np-complete의-이론적-중요성>NP-Complete의 이론적 중요성<a hidden class=anchor aria-hidden=true href=#np-complete의-이론적-중요성>#</a></h4><ol><li><strong>동등한 난이도</strong>: 모든 NP-Complete 문제는 계산적 난이도 측면에서 동등하다. 하나의 NP-Complete 문제에 대한 다항 시간 알고리즘은 모든 NP 문제에 대한 다항 시간 알고리즘을 의미한다.</li><li><strong>P vs NP 문제의 핵심</strong>: NP-Complete 문제는 P vs NP 문제의 핵심에 있다. 이들 중 하나라도 다항 시간에 해결할 수 있다면 P = NP가 증명된다.</li><li><strong>난이도 분류 도구</strong>: NP-Complete 개념은 문제들을 복잡도에 따라 분류하는 강력한 도구를 제공한다.</li></ol><h4 id=np-hard의-이론적-중요성>NP-Hard의 이론적 중요성<a hidden class=anchor aria-hidden=true href=#np-hard의-이론적-중요성>#</a></h4><ol><li><strong>난이도의 하한선</strong>: NP-Hard 문제는 계산적 난이도의 하한선을 제공한다. 이들은 &ldquo;적어도 NP만큼 어려운&rdquo; 문제들이다.</li><li><strong>최적화 문제의 프레임워크</strong>: NP-Hard는 최적화 문제의 난이도를 분석하는 프레임워크를 제공한다. 이를 통해 근사 알고리즘의 설계와 분석이 가능해진다.</li><li><strong>계산 불가능성과의 연결</strong>: 일부 NP-Hard 문제는 계산 불가능(undecidable)할 수 있어, 계산 가능성 이론과 복잡도 이론을 연결한다.</li></ol><h3 id=최근-발전과-연구-동향>최근 발전과 연구 동향<a hidden class=anchor aria-hidden=true href=#최근-발전과-연구-동향>#</a></h3><h4 id=np-complete-문제-연구의-최근-동향>NP-Complete 문제 연구의 최근 동향<a hidden class=anchor aria-hidden=true href=#np-complete-문제-연구의-최근-동향>#</a></h4><ol><li><strong>세밀한 복잡도 분석</strong>: 입력의 특정 매개변수에 따른 복잡도 분석을 통해 더 효율적인 알고리즘 개발</li><li><strong>양자 알고리즘</strong>: 양자 컴퓨팅을 활용한 NP-Complete 문제 해결 가능성 연구</li><li><strong>근사 난이도 분류</strong>: 근사 알고리즘에 기반한 새로운 복잡도 계층 연구</li><li><strong>평균 케이스 분석</strong>: 무작위 인스턴스에 대한 복잡도 분석</li></ol><h4 id=np-hard-최적화-문제-연구의-최근-동향>NP-Hard 최적화 문제 연구의 최근 동향<a hidden class=anchor aria-hidden=true href=#np-hard-최적화-문제-연구의-최근-동향>#</a></h4><ol><li><strong>근사 보존 환원</strong>: 근사 인자를 보존하는 환원 개념을 통한 최적화 문제의 난이도 분류</li><li><strong>매개변수화된 복잡도</strong>: 특정 매개변수가 고정되었을 때의 복잡도 분석</li><li><strong>휴리스틱과 ML의 결합</strong>: 머신 러닝 기법을 활용한 휴리스틱 최적화</li><li><strong>분산 및 병렬 알고리즘</strong>: 대규모 NP-Hard 문제를 위한 분산 계산 접근법</li></ol><h3 id=np-hard-vs-np-complete-비교>NP-Hard vs. NP-Complete 비교<a hidden class=anchor aria-hidden=true href=#np-hard-vs-np-complete-비교>#</a></h3><table><thead><tr><th>특성</th><th>NP-Hard</th><th>NP-Complete</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>모든 NP 문제가 다항 시간에 환원 가능한 문제</td><td>NP-Hard이면서 동시에 NP에 속하는 문제</td></tr><tr><td><strong>형식적 정의</strong></td><td>모든 L ∈ NP에 대해 L ≤p H인 문제 H</td><td>C ∈ NP이고 모든 L ∈ NP에 대해 L ≤p C인 문제 C</td></tr><tr><td><strong>NP 소속 여부</strong></td><td>NP에 속할 수도, 속하지 않을 수도 있음</td><td>반드시 NP에 속함</td></tr><tr><td><strong>문제 유형</strong></td><td>결정 문제, 최적화 문제, 함수 문제 등</td><td>반드시 결정 문제(예/아니오 답변)</td></tr><tr><td><strong>해답 검증 가능성</strong></td><td>다항 시간에 검증 가능하지 않을 수도 있음</td><td>반드시 다항 시간에 검증 가능</td></tr><tr><td><strong>대표적 문제</strong></td><td>최적 TSP, 정지 문제, 해밀턴 경로 계수</td><td>SAT, 해밀턴 경로, 정점 커버, 부분집합 합</td></tr><tr><td><strong>증명 방법</strong></td><td>알려진 NP-Hard 문제로부터의 환원만 필요</td><td>NP 소속 증명 + NP-Hard 증명 두 단계 필요</td></tr><tr><td><strong>P=NP 가정 시 영향</strong></td><td>일부는 여전히 다항 시간에 해결 불가능할 수 있음</td><td>모두 다항 시간에 해결 가능해짐</td></tr><tr><td><strong>근사 가능성</strong></td><td>일부는 근사 불가능할 수 있음</td><td>많은 경우 다항 시간 근사 알고리즘 존재</td></tr><tr><td><strong>주요 접근 방법</strong></td><td>근사 알고리즘, 휴리스틱, 매개변수화 등</td><td>백트래킹, 분기한정법, 매개변수화된 알고리즘 등</td></tr><tr><td><strong>최초 증명된 문제</strong></td><td>첫 NP-Hard 증명은 SAT(Cook, 1971)</td><td>첫 NP-Complete 증명은 SAT(Cook, 1971)</td></tr><tr><td><strong>수리 계획법 모델링</strong></td><td>정수 계획법, 비선형 최적화 등 다양한 형태</td><td>주로 정수 선형 계획법, 제약 만족 문제</td></tr><tr><td><strong>실제 응용 분야</strong></td><td>최적화, 리소스 할당, 설계 문제 등</td><td>검증, 스케줄링 결정, 안전성 분석 등</td></tr><tr><td><strong>복잡도 계층 위치</strong></td><td>NP를 포함하여 더 넓은 범위</td><td>NP와 NP-Hard의 교집합</td></tr><tr><td><strong>계산 가능성</strong></td><td>일부는 계산 불가능할 수 있음</td><td>모두 계산 가능(decidable)</td></tr><tr><td><strong>다른 복잡도와의 관계</strong></td><td>EXPTIME, PSPACE, 계산 불가능 문제 등 포함 가능</td><td>PSPACE에 포함됨</td></tr><tr><td><strong>메모리 요구사항</strong></td><td>다항 공간 이상 필요할 수 있음</td><td>대부분 다항 공간 내에서 해결 가능</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/complexity-classes/>Complexity-Classes</a></li><li><a href=https://buenhyden.github.io/tags/classes/>Classes</a></li><li><a href=https://buenhyden.github.io/tags/np-hard/>NP-Hard</a></li><li><a href=https://buenhyden.github.io/tags/np-complete/>NP-Complete</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/><span class=title>« Prev</span><br><span>Non-deterministic Polynomial Time vs. Polynomial Time</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying-vs-partial-application/><span class=title>Next »</span><br><span>Currying vs. Partial Application</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>