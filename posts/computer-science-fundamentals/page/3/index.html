<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Science Fundamentals | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals"><meta name=description content="Computer Science Fundamentals - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Science Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Science Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Computer Science Fundamentals</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Floating Point Numbers</h2></header><div class=entry-content><p>부동소수점 수(Floating Point Numbers) 부동소수점 수는 컴퓨터에서 실수를 표현하는 핵심적인 방식으로, 프로그래밍에서 매우 중요한 개념이다.
부동소수점은 컴퓨터에서 실수를 표현하는 효율적인 방법이지만, 그 특성과 한계를 이해하는 것이 중요하다.
정밀도 문제, 반올림 오차, 비교 문제 등을 인식하고 적절히 대응하는 것이 안정적인 소프트웨어 개발의 핵심이다.
실용적인 측면에서는:
정확한 산술이 필요한 영역에서는 Decimal 같은 정밀 타입 사용 부동소수점 비교 시 epsilon 값을 활용한 근사 비교 적용 부동소수점의 특수한 값들(NaN, Infinity 등)을 적절히 처리 필요에 따라 반올림 정책을 명확히 설정하고 일관되게 적용 이러한 원칙을 따르면 부동소수점 관련 문제를 최소화하고 안정적인 시스템을 구축할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Floating Point Numbers" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-representation-and-encoding/binary-representation/floating-point/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 인코딩(Character Encodings)</h2></header><div class=entry-content><p>문자 인코딩(Character Encodings) 문자 인코딩은 인간이 읽을 수 있는 텍스트를 컴퓨터가 이해할 수 있는 이진 형식으로 변환하는 방법을 정의한다.
니다. 컴퓨터는 오직 0과 1만 이해하지만, 우리 인간은 다양한 언어와 기호로 의사소통한다. 문자 인코딩은 이 간극을 메우는 중요한 다리 역할을 한다.
문자 인코딩은 현대 소프트웨어 개발의 기초가 되는 개념이다. UTF-8은 현재 가장 보편적인 인코딩 방식이지만, 레거시 시스템과의 호환성, 효율성, 특정 언어 요구사항 등 다양한 고려사항에 따라 다른 인코딩도 여전히 사용된다.
개발자는 다양한 인코딩 방식을 이해하고, 적절히 처리할 수 있어야 하며, 특히 국제화(i18n)와 지역화(l10n)가 중요한 글로벌 애플리케이션 개발에서는 문자 인코딩에 대한 깊은 이해가 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-12-13 12:56:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 인코딩(Character Encodings)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-representation-and-encoding/character-encoding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency and Parallelism</h2></header><div class=entry-content><p>Concurrency and Parallelism 동시성과 병렬성은 현대 시스템 설계에서 성능 최적화의 핵심 개념이다. 동시성은 작업 간 전환을 통해 단일 자원으로 다수 작업을 논리적으로 처리하며, 병렬성은 다중 코어 또는 분산 환경에서 여러 작업을 실제 동시에 실행해 처리량을 극대화한다. 두 개념은 멀티스레딩, 비동기 I/O, GPU 병렬 처리, 분산 시스템 등 다양한 분야에서 상호 보완적으로 사용되며, 시스템의 응답성, 확장성, 자원 효율성을 크게 향상시킨다.
등장 배경 및 발전 과정 시기 기술 발전 흐름 주요 내용 요약 1950~1960 년대 초기 컴퓨팅 구조 - 단일 프로그램 실행 환경 (batch processing)
- CPU 유휴 시간 발생, 자원 활용 비효율성 문제 대두 1960 년대 중후반 시분할 시스템 및 멀티프로그래밍 도입 - Multiprogramming: 여러 작업을 메모리에 상주시켜 CPU 활용 극대화
- Time-Sharing System: 사용자 간 자원 공유 지원 1970~1980 년대 멀티태스킹 운영체제, GUI 시대 개막 - Preemptive Scheduling 기반의 멀티태스킹 OS 등장
- 사용자 인터페이스가 GUI 로 진화하며, 백그라운드 동작 (Concurrency) 중요성 증가 1990 년대 네트워크 기반 시스템 확산 - 클라이언트 - 서버 구조 확산
- 웹 서비스 및 이벤트 처리 요구 증가
- 스레드 기반 모델 활성화 2000 년대 초반 멀티코어 프로세서 상용화 - Dual/Quad Core CPU 등장
- 병렬 처리를 위한 물리적 인프라 확보
- 멀티스레딩의 하드웨어적 기반 제공 2010 년대 이후 클라우드, 분산 시스템, 비동기 모델 확산 - Cloud-native 시스템 확산
- 대규모 데이터 처리, 이벤트 기반 아키텍처 필요성 증가
- Async/Await, Reactive, Actor Model 도입 2020 년대~현재 AI, IoT, 엣지 컴퓨팅 시대 - 병렬화 가능한 작업 증가 (딥러닝, 센서 데이터 등)
- GPGPU 병렬 처리, 서버리스 기반 동시성 처리 활용 확대 Concurrency 의 필요성은 CPU 의 유휴 자원 방지와 사용자 응답성 확보에서 출발했으며, 멀티태스킹 OS, GUI 환경, 네트워크 서비스로 이어지며 발전했다. Parallelism 의 발전은 물리적 제약 (CPU 단일코어) 의 극복을 위한 하드웨어 진보 (멀티코어, GPU) 와 맞물려 성능 향상을 목적으로 발전해왔다. 최근에는 클라우드, 분산 시스템, AI/ML, IoT 환경의 확산으로 병렬성과 동시성을 동시에 활용하는 설계가 일반화되었다. 특히, 비동기 처리 모델(Promise, async/await, Rx, coroutine 등) 과 Actor Model, Dataflow 등의 설계 패턴은 실시간성과 확장성을 동시에 요구하는 현대 시스템에서 핵심 기술로 자리잡고 있다. 목적 및 필요성 성능 향상 및 처리량 극대화
...</p></div><footer class=entry-footer><span title='2024-10-05 02:38:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;61 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrency and Parallelism" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-fundamentals/basic-concepts/concurrency-vs-parallelism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memory Architecture</h2></header><div class=entry-content><p>Memory Architecture 컴퓨터 시스템의 메모리 아키텍처는 데이터를 효율적으로 저장하고 접근하기 위한 구조이다.
컴퓨터에서는 빠른 속도와 큰 용량을 동시에 얻기가 어렵다. 빠른 메모리는 비용이 매우 높고, 큰 용량의 메모리는 상대적으로 느리다. 이러한 기술적, 경제적 제약을 해결하기 위해 여러 층의 메모리를 계층적으로 구성하게 되었다.
메모리 계층 구조 메모리 계층 구조는 접근 속도와 용량에 따라 여러 단계로 구성된다:
레지스터:
CPU 내부에 위치한 소용량의 초고속 메모리로, 현재 실행 중인 명령어와 관련된 데이터를 저장한다. 일반적으로 몇 비트에서 수십 비트 정도의 용량을 가지며, 접근 속도는 한 사이클 이내로 가장 빠르다. 캐시 메모리:
주기억장치와 CPU 레지스터 사이에 위치하여, 자주 사용되는 데이터를 일시적으로 저장함으로써 CPU의 처리 속도를 향상시킨다. 일반적으로 L1, L2, L3 등의 여러 레벨로 구성되며, 레벨이 높아질수록 용량은 증가하지만 접근 속도는 감소한다. 주 메모리 (RAM):
프로그램과 데이터를 일시적으로 저장하는 휘발성 메모리로, 시스템의 작업 공간 역할을 한다. 용량은 수 기가바이트에서 수십 기가바이트에 이르며, 캐시 메모리보다 접근 속도는 느리지만 더 많은 데이터를 저장할 수 있다. 보조 기억 장치:
하드 디스크 드라이브(HDD), 솔리드 스테이트 드라이브(SSD)와 같은 비휘발성 저장 장치로, 대용량의 데이터를 영구적으로 저장한다. 주기억장치보다 접근 속도는 느리지만, 데이터의 영구 저장이 가능하다. 이러한 계층 구조는 데이터 접근 시간을 최소화하고 전체 시스템의 성능을 향상시킨다.
...</p></div><footer class=entry-footer><span title='2024-09-30 15:55:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memory Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/memory-architectures/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Computer Architecture</h2></header><div class=entry-content><p>Von Neumann Architecture vs. Harvard Architecture 하버드 아키텍처(Harvard Architecture)와 폰 노이만 아키텍처(von Neumann Architecture)는 컴퓨터 시스템의 메모리 구조를 정의하는 두 가지 대표적인 설계 방식이다.
각 아키텍처는 메모리와 버스 구조에 대한 접근 방식에서 차이를 보이며, 이에 따라 성능, 설계 복잡성, 활용 분야 등에서 차별화된다.
특성 하버드 아키텍처 폰 노이만 아키텍처 메모리 구조 명령어와 데이터를 위한 별도의 메모리 명령어와 데이터가 동일한 메모리에 저장 버스 구조 명령어 버스와 데이터 버스가 분리 하나의 공유 버스 사용 병렬 처리 명령어 fetch와 데이터 접근을 동시에 수행 가능 명령어 fetch와 데이터 접근을 순차적으로 수행 성능 일반적으로 더 빠른 실행 속도 메모리 병목 현상으로 인해 상대적으로 느림 복잡성 하드웨어 구조가 더 복잡 상대적으로 단순한 구조 비용 일반적으로 더 높은 구현 비용 상대적으로 낮은 구현 비용 유연성 메모리 사용의 유연성이 낮음 메모리 사용의 유연성이 높음 보안성 프로그램과 데이터 분리로 인한 높은 보안성 상대적으로 낮은 보안성 주요 응용 분야 임베디드 시스템, DSP, 마이크로컨트롤러 범용 컴퓨터, 개인용 컴퓨터 메모리 접근 동시에 명령어와 데이터 접근 가능 순차적 메모리 접근 명령어 실행 1 사이클에 1 명령어 실행 가능 여러 사이클에 걸쳐 명령어 실행 메모리 확장 명령어와 데이터 메모리 독립적 확장 가능 단일 메모리 확장 전력 효율성 일반적으로 더 높은 전력 효율성 상대적으로 낮은 전력 효율성 캐시 구조 명령어 캐시와 데이터 캐시 분리 통합 캐시 또는 분리된 캐시 사용 가능 이 두 아키텍처는 각각의 장단점을 가지고 있으며, 현대의 많은 프로세서들은 두 아키텍처의 장점을 결합한 하이브리드 구조를 채택하고 있다. 예를 들어, 내부적으로는 하버드 구조를 사용하여 성능을 향상시키고, 외부적으로는 폰 노이만 구조를 유지하여 유연성을 확보하는 방식을 사용한다.
...</p></div><footer class=entry-footer><span title='2024-09-29 05:34:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Computer Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/architecture-types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Instruction Set Architecture</h2></header><div class=entry-content><p>Instruction Set Architecture 명령어 집합 구조(Instruction Set Architecture, ISA)는 프로세서 아키텍처의 핵심 요소로, 하드웨어와 소프트웨어 간의 인터페이스 역할을 한다.
ISA는 프로세서가 실행할 수 있는 명령어들의 집합을 정의하며, 프로그래머와 컴파일러 작성자에게 중요한 추상화 계층을 제공한다.
Source: https://www.geeksforgeeks.org/microarchitecture-and-instruction-set-architecture/
ISA의 주요 구성 요소 명령어 세트
연산 유형: 산술 연산, 논리 연산, 데이터 이동, 제어 흐름 등 명령어 형식: 각 명령어의 비트 구조와 인코딩 방식 주소 지정 모드: 직접 주소 지정, 간접 주소 지정, 즉시 주소 지정 등 레지스터
...</p></div><footer class=entry-footer><span title='2024-09-29 02:18:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Instruction Set Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture-and-hardware/processor-architecture/instruction-set-architecture/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/page/2/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>