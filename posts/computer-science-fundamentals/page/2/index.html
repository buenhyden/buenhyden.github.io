<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Science Fundamentals | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals"><meta name=description content="Computer Science Fundamentals - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Science Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Science Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Computer Science Fundamentals</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency Problems</h2></header><div class=entry-content><p>Concurrency Problems 동시성 시스템에서는 자원 공유와 병행 처리로 인해 여러 문제가 발생할 수 있다.
Deadlock은 상호 자원을 대기하다 순환 차단되는 상태이며, Livelock은 상태는 바뀌나 실제 진행이 없는 경우다. Race Condition은 병렬 실행의 타이밍 문제로 인해 예측 불가한 결과가 나타나고, Starvation은 일부 태스크가 지속적으로 자원을 얻지 못해 실행되지 못하는 상황이다. 본 분석은 이 네 가지 문제의 개념, 발생 조건, 대응 전략을 비교하고, 실시간 시스템과 고성능 환경에서의 적용 사례를 통해 효과적인 예방 및 해결 방안을 제시한다.
...</p></div><footer class=entry-footer><span title='2025-05-21 05:56:00 +0000 UTC'>May 21, 2025</span>&nbsp;·&nbsp;45 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrency Problems" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Critical Section</h2></header><div class=entry-content><p>Critical Section 임계 구역 (Critical Section) 은 여러 실행 흐름이 공유 자원을 안전하게 사용할 수 있도록 동시 접근을 제어하는 코드 블록이다. 상호 배제, 진행성, 유한 대기의 세 원칙을 기반으로 하며, mutex, semaphore, monitor, atomic 연산 등으로 보호된다. Dekker 와 Peterson 알고리즘 같은 고전적 해법부터 현대 언어의 동기화 추상화까지 폭넓게 활용되며, 데드락, 기아, 경쟁 상태를 예방한다.
등장 배경 및 발전 과정 Critical Section은 단일 흐름 환경에서는 문제가 되지 않았지만, 멀티프로세스/멀티스레드/멀티코어 환경이 도입되면서 **경쟁 조건 (Race Condition)**을 해결하기 위한 동기화 문제의 핵심 개념으로 발전했다. Dekker, Peterson 등의 초기 알고리즘에서 시작해, 세마포어, 모니터, 뮤텍스 등의 운영체제 기반 기술로 이어졌고, 현재는 락프리 구조, 메모리 일관성 모델, 고수준 언어 내장 기법 등으로 진화하고 있다.
...</p></div><footer class=entry-footer><span title='2025-05-20 14:46:00 +0000 UTC'>May 20, 2025</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Critical Section" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/basic-concepts/critical-section/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Thread Management</h2></header><div class=entry-content><p>Thread Management Thread Management 는 프로세스 내에서 여러 스레드의 생성, 실행, 동기화, 종료를 관리하는 운영체제 및 프로그래밍 기술이다. 스레드 관리는 CPU 자원 활용도를 극대화하고, 동시성 및 병렬성을 제공하여 시스템 성능과 응답성을 높인다. 하지만 스레드 간 자원 공유, 동기화, 데드락, 경쟁 상태 등 관리 이슈가 존재하며, 이를 위한 락, 세마포어, 스레드 풀 등 다양한 기법이 활용된다. 서버, 데이터 처리, 실시간 시스템 등에서 필수적으로 적용된다.
핵심 개념 스레드 (Thread): 프로세스 내에서 실행되는 독립적인 명령어 흐름 스레드 관리 (Thread Management): 스레드의 생성, 실행, 동기화, 종료, 스케줄링, 예외 처리 등 전체 생명주기를 관리하는 기능 동기화 (Synchronization): 여러 스레드가 공유 자원에 안전하게 접근하도록 조율하는 기법 (뮤텍스, 세마포어, 락 등) 스레드 풀 (Thread Pool): 미리 생성된 스레드 집합에서 작업을 할당하여 효율적으로 관리 컨텍스트 스위칭 (Context Switching): 실행 중인 스레드 간 전환 작업 목적 및 필요성 CPU 자원 활용 극대화 및 처리량 향상 동시성 및 병렬성 제공 대규모 동시 요청 처리 (서버, 데이터 처리 등) 프로그램 응답성 및 실시간성 개선 주요 기능 및 역할 스레드 생성 및 종료 관리 스케줄링 및 우선순위 지정 동기화 및 경쟁 상태 관리 예외 및 오류 처리 스레드 풀 관리 특징 경량화된 실행 단위 (프로세스 대비) 자원 공유 (메모리, 파일 등) 빠른 컨텍스트 스위칭 동기화 필요성 (데이터 무결성 보장) 주요 원리 및 작동 원리 스레드 생성: 메인 스레드 외에 추가 스레드 생성 (직접 생성, 스레드 풀 등) 스케줄링: 운영체제 또는 런타임이 스레드에 CPU 할당 동기화: 락, 세마포어 등으로 공유 자원 접근 제어 종료 및 자원 회수: 스레드 작업 완료 후 종료 및 자원 해제 1 2 3 4 [프로세스] ├─[스레드1] ──┐ ├─[스레드2] ──┼─> [공유 자원/메모리] └─[스레드N] ──┘ 장점과 단점 구분 항목 설명 ✅ 장점 성능 향상 CPU 활용도 극대화, 처리량 증가 응답성 개선 UI, 서버 등 실시간 응답성 향상 자원 효율성 프로세스 대비 적은 오버헤드 빠른 통신 스레드 간 자원 공유로 빠른 데이터 교환 ⚠ 단점 동기화 문제 데드락, 경쟁 상태 등 동기화 이슈 디버깅 어려움 동시성 버그 추적 및 재현 어려움 자원 경합 캐시, 메모리 등 하드웨어 자원 경합 복잡성 증가 코드 구조 및 예외 처리 복잡 도전 과제 동기화 및 경쟁 상태 관리 데드락, 라이브락, 우선순위 역전 등 문제 해결 스케줄링 및 부하 분산 최적화 디버깅 및 테스트의 어려움 분류에 따른 종류 및 유형 분류 기준 유형 설명 구현 위치 커널 스레드, 유저 스레드 커널/유저 공간에서 생성 및 관리 매핑 방식 1:1, N:1, M:N 유저 - 커널 스레드 매핑 방식 실행 방식 동시성, 병렬성 논리적/물리적 동시 실행 패턴/구조 스레드 풀, Producer-Consumer, Future 등 다양한 동시성 패턴 적용 하위 주제 및 추가 학습 필요 내용 카테고리 주제 설명 동시성 락, 세마포어, 모니터 동기화 객체 및 동작 원리 스레드 관리 스레드 풀, 스케줄러 효율적 스레드 생성/관리 기법 패턴/구조 Producer-Consumer, Future 등 동시성 패턴 및 활용법 디버깅 동시성 버그 추적 데드락, 경쟁 상태 등 문제 해결 방법 추가로 알아야 할 내용 및 관련 분야 카테고리 주제 설명 운영체제 스케줄링 알고리즘 스레드/프로세스 스케줄링 정책 네트워크 비동기 I/O 멀티스레딩과 결합한 고성능 네트워크 처리 데이터베이스 트랜잭션 동시성 DB 에서의 멀티스레딩 및 동시성 제어 보안 스레드 안전성 멀티스레딩 환경에서의 데이터 보호 용어 정리 용어 설명 락 프리 (Lock-Free) 락 없이 동기화하는 고성능 구조 스레드 풀 (Thread Pool) 미리 생성된 스레드 집합에서 작업 할당 컨텍스트 스위칭 (Context Switching) 실행 중인 스레드/프로세드 전환 작업 데드락 (Deadlock) 상호 자원 점유로 인한 무한 대기 상태 경쟁 상태 (Race Condition) 동시 접근 시 예기치 않은 결과 발생 현상 Future/Promise 비동기 작업 결과를 처리하는 구조 참고 및 출처 Thread Management in Operating Systems - GeeksforGeeks Thread Management Overview - Oracle Docs Thread Pools and Concurrency - Java Tutorials Multithreading for Beginners - freeCodeCamp Modern Thread Management Patterns - Baeldung</p></div><footer class=entry-footer><span title='2025-05-12 03:11:00 +0000 UTC'>May 12, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread Management" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/thread-programming/thread-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Base64</h2></header><div class=entry-content><p>Base64 Base64는 바이너리 데이터를 텍스트 형식으로 안전하게 변환하기 위한 인코딩 시스템이다. 1987년 개발된 이후 인터넷 통신, 데이터 저장, 프로그래밍 등 다양한 분야에서 필수적인 도구로 자리 잡았다.
Base64의 기본 개념과 역사 Base64는 이진 데이터를 ASCII 문자 집합의 부분집합인 64개 문자(A-Z, a-z, 0-9, +, /)를 사용하여 표현하는 인코딩 방식이다. 이름에 ‘64’가 붙은 이유는 정확히 이 64개의 문자를 사용하기 때문이다. 인코딩된 데이터의 끝을 나타내기 위해 패딩 문자로 ‘=‘를 사용하기도 한다.
Base64는 1987년 RFC 989에서 처음 도입되었으며, 이후 1993년 MIME(Multipurpose Internet Mail Extensions) 규격의 일부로 RFC 1521에 정식으로 포함되었다. 초기에는 이메일 시스템에서 바이너리 첨부 파일을 안전하게 전송하기 위한 목적으로 개발되었지만, 오늘날에는 웹 개발, 암호화, 데이터 저장 등 광범위한 분야에서 활용되고 있다.
...</p></div><footer class=entry-footer><span title='2025-03-12 13:15:00 +0000 UTC'>March 12, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Base64" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/encoding-applications/base64-encoding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bitwise Operators</h2></header><div class=entry-content><p>Bitwise Operators 비트와이즈 연산자는 저수준 최적화, 데이터 압축, 하드웨어 제어 등 다양한 영역에서 강력한 도구이다.
모든 비트를 직접 다루기 때문에 신중하게 사용해야 하지만, 잘 활용하면 성능과 메모리 효율성에서 큰 이점을 얻을 수 있다.
현대 프로그래밍에서는 추상화 수준이 높아졌지만, 시스템 프로그래밍, 임베디드 시스템, 게임 개발, 데이터베이스 엔진 등에서 비트와이즈 연산은 여전히 핵심적인 역할을 수행한다. 효율적인 프로그래밍을 위해 비트와이즈 연산자의 활용법을 숙지하는 것이 좋다.
비트와이즈 연산자의 기본 개념 비트와이즈 연산자는 정수 값을 이진수(비트)로 표현하여 비트 단위로 연산을 수행한다.
컴퓨터의 모든 데이터는 결국 이진수로 저장되기 때문에, 비트 단위 조작은 저수준(low-level) 프로그래밍에서 특히 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-14 12:56:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bitwise Operators" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/binary-operations/bitwise-operations/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Endianness</h2></header><div class=entry-content><p>Endianness Endianness의 기본 개념 Endianness(엔디안)는 컴퓨터 메모리에서 데이터를 저장하는 바이트 순서를 의미한다.
이 개념은 다중 바이트 값(2바이트 이상)을 다룰 때 중요하게 작용한다. 근본적으로 엔디안은 “바이트들을 어떤 순서로 배열할 것인가"라는 질문에 대한 답이다.
Big Endian vs. Little Endian 엔디안에는 주로 두 가지 방식이 있다:
Big Endian (빅 엔디안): 가장 중요한(Most Significant Byte, MSB) 바이트가 가장 낮은 메모리 주소에 저장된다. 즉, 메모리 주소가 왼쪽에서 오른쪽으로 증가할 때, 데이터의 가장 중요한 부분이 먼저 나온다. Little Endian (리틀 엔디안): 가장 덜 중요한(Least Significant Byte, LSB) 바이트가 가장 낮은 메모리 주소에 저장된다. 즉, 메모리 주소가 왼쪽에서 오른쪽으로 증가할 때, 데이터의 가장 덜 중요한 부분이 먼저 나옵니다. 예를 들어, 16진수 값 0x12345678을 메모리에 저장한다고 가정해 보면:
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Endianness" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/binary-operations/endianness/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Floating Point Numbers</h2></header><div class=entry-content><p>부동소수점 수(Floating Point Numbers) 부동소수점 수는 컴퓨터에서 실수를 표현하는 핵심적인 방식으로, 프로그래밍에서 매우 중요한 개념이다.
부동소수점은 컴퓨터에서 실수를 표현하는 효율적인 방법이지만, 그 특성과 한계를 이해하는 것이 중요하다.
정밀도 문제, 반올림 오차, 비교 문제 등을 인식하고 적절히 대응하는 것이 안정적인 소프트웨어 개발의 핵심이다.
실용적인 측면에서는:
정확한 산술이 필요한 영역에서는 Decimal 같은 정밀 타입 사용 부동소수점 비교 시 epsilon 값을 활용한 근사 비교 적용 부동소수점의 특수한 값들(NaN, Infinity 등)을 적절히 처리 필요에 따라 반올림 정책을 명확히 설정하고 일관되게 적용 이러한 원칙을 따르면 부동소수점 관련 문제를 최소화하고 안정적인 시스템을 구축할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Floating Point Numbers" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/number-systems/floating-point/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 인코딩(Character Encodings)</h2></header><div class=entry-content><p>문자 인코딩(Character Encodings) 문자 인코딩은 인간이 읽을 수 있는 텍스트를 컴퓨터가 이해할 수 있는 이진 형식으로 변환하는 방법을 정의한다.
니다. 컴퓨터는 오직 0과 1만 이해하지만, 우리 인간은 다양한 언어와 기호로 의사소통한다. 문자 인코딩은 이 간극을 메우는 중요한 다리 역할을 한다.
문자 인코딩은 현대 소프트웨어 개발의 기초가 되는 개념이다. UTF-8은 현재 가장 보편적인 인코딩 방식이지만, 레거시 시스템과의 호환성, 효율성, 특정 언어 요구사항 등 다양한 고려사항에 따라 다른 인코딩도 여전히 사용된다.
개발자는 다양한 인코딩 방식을 이해하고, 적절히 처리할 수 있어야 하며, 특히 국제화(i18n)와 지역화(l10n)가 중요한 글로벌 애플리케이션 개발에서는 문자 인코딩에 대한 깊은 이해가 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-12-13 12:56:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 인코딩(Character Encodings)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/data-representation--encoding/character-encoding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NP-난해(NP-Hard)</h2></header><div class=entry-content><p>NP-난해(NP-Hard) NP-Hard(NP-난해)는 계산 복잡도 이론에서 가장 중요한 개념 중 하나로, 문제의 난이도를 분류하는 방법을 제공한다.
이 개념은 개발자가 어떤 문제가 본질적으로 어려운지, 효율적인 해결책을 기대할 수 있는지 이해하는 데 도움이 된다.
NP-Hard 문제는 컴퓨터 과학과 실제 응용 분야에서 중요한 위치를 차지하고 있다.
비록 다항 시간 알고리즘으로 정확하게 해결하는 것은 어렵지만, 다양한 접근 방법을 통해 실용적인 해결책을 찾을 수 있다.
IT 개발자로서 NP-Hard 문제를 효과적으로 다루는 것은 중요한 기술이다. 문제의 구조를 이해하고, 적절한 알고리즘을 선택하며, 실용적인 트레이드오프를 고려하는 능력은 복잡한 시스템을 설계하고 최적화하는 데 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:29:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NP-난해(NP-Hard)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다항 공간(Polynomial Space) 클래스</h2></header><div class=entry-content><p>다항 공간(Polynomial Space) 클래스 계산 복잡도 이론은 컴퓨터 과학의 핵심 분야로, 문제 해결의 계산적 난이도를 체계적으로 분류한다. 이 중에서 다항 공간(Polynomial Space) 복잡도 클래스는 알고리즘이 사용하는 메모리 리소스에 초점을 맞춘 중요한 개념이다.
다항 공간(PSPACE)의 기본 개념 정의 PSPACE는 결정론적 튜링 기계에서 다항 크기의 메모리를 사용하여 해결할 수 있는 모든 결정 문제의 집합이다.
형식적으로:
PSPACE = ⋃(k≥1) SPACE(n^k)
여기서 SPACE(f(n))는 최악의 경우 공간 복잡도가 O(f(n))인 결정론적 튜링 기계로 해결할 수 있는 문제들의 집합. 중요한 점은 PSPACE가 실행 시간이 아닌 메모리 사용량에 기반한 복잡도 클래스라는 것이다.
PSPACE에 속하는 알고리즘은 다항 크기의 메모리를 사용하지만, 실행 시간은 지수적일 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:29:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다항 공간(Polynomial Space) 클래스" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/space-complexity-classes/pspace/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>