<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Science Fundamentals | hyunyoun's Blog</title><meta name=keywords content="Computer-Science-Fundamentals"><meta name=description content="Computer Science Fundamentals - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science-fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science-fundamentals/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science-fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science-fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Science Fundamentals"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Science Fundamentals"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science Fundamentals","item":"https://buenhyden.github.io/posts/computer-science-fundamentals/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Computer Science Fundamentals</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency Problems</h2></header><div class=entry-content><p>Concurrency Problems 동시성 시스템에서는 자원 공유와 병행 처리로 인해 여러 문제가 발생할 수 있다.
Deadlock은 상호 자원을 대기하다 순환 차단되는 상태이며, Livelock은 상태는 바뀌나 실제 진행이 없는 경우다. Race Condition은 병렬 실행의 타이밍 문제로 인해 예측 불가한 결과가 나타나고, Starvation은 일부 태스크가 지속적으로 자원을 얻지 못해 실행되지 못하는 상황이다. 본 분석은 이 네 가지 문제의 개념, 발생 조건, 대응 전략을 비교하고, 실시간 시스템과 고성능 환경에서의 적용 사례를 통해 효과적인 예방 및 해결 방안을 제시한다.
...</p></div><footer class=entry-footer><span title='2025-05-21 05:56:00 +0000 UTC'>May 21, 2025</span>&nbsp;·&nbsp;<span>46 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Concurrency Problems" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/concurrency-problems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NP-난해(NP-Hard)</h2></header><div class=entry-content><p>NP-난해(NP-Hard) NP-Hard(NP-난해)는 계산 복잡도 이론에서 가장 중요한 개념 중 하나로, 문제의 난이도를 분류하는 방법을 제공한다.
이 개념은 개발자가 어떤 문제가 본질적으로 어려운지, 효율적인 해결책을 기대할 수 있는지 이해하는 데 도움이 된다.
NP-Hard 문제는 컴퓨터 과학과 실제 응용 분야에서 중요한 위치를 차지하고 있다.
비록 다항 시간 알고리즘으로 정확하게 해결하는 것은 어렵지만, 다양한 접근 방법을 통해 실용적인 해결책을 찾을 수 있다.
IT 개발자로서 NP-Hard 문제를 효과적으로 다루는 것은 중요한 기술이다. 문제의 구조를 이해하고, 적절한 알고리즘을 선택하며, 실용적인 트레이드오프를 고려하는 능력은 복잡한 시스템을 설계하고 최적화하는 데 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:29:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NP-난해(NP-Hard)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다항 공간(Polynomial Space) 클래스</h2></header><div class=entry-content><p>다항 공간(Polynomial Space) 클래스 계산 복잡도 이론은 컴퓨터 과학의 핵심 분야로, 문제 해결의 계산적 난이도를 체계적으로 분류한다. 이 중에서 다항 공간(Polynomial Space) 복잡도 클래스는 알고리즘이 사용하는 메모리 리소스에 초점을 맞춘 중요한 개념이다.
다항 공간(PSPACE)의 기본 개념 정의 PSPACE는 결정론적 튜링 기계에서 다항 크기의 메모리를 사용하여 해결할 수 있는 모든 결정 문제의 집합이다.
형식적으로:
PSPACE = ⋃(k≥1) SPACE(n^k)
여기서 SPACE(f(n))는 최악의 경우 공간 복잡도가 O(f(n))인 결정론적 튜링 기계로 해결할 수 있는 문제들의 집합. 중요한 점은 PSPACE가 실행 시간이 아닌 메모리 사용량에 기반한 복잡도 클래스라는 것이다.
PSPACE에 속하는 알고리즘은 다항 크기의 메모리를 사용하지만, 실행 시간은 지수적일 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:29:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>10 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 다항 공간(Polynomial Space) 클래스" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/space-complexity-classes/pspace/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지수 시간(Exponential Time) 복잡도</h2></header><div class=entry-content><p>지수 시간(Exponential Time) 복잡도 지수 시간(Exponential Time) 복잡도는 알고리즘의 실행 시간이 입력 크기에 대해 지수적으로 증가하는 경우를 나타낸다. 이는 계산 복잡도 이론에서 중요한 분류 중 하나로, 알고리즘과 문제의 난이도를 이해하는 데 필수적인 개념이다.
수학적 정의 지수 시간 알고리즘은 실행 시간이 O(c^n)으로 표현되는 알고리즘이다.
여기서:
n은 입력의 크기 c는 1보다 큰 상수 (일반적으로 c ≥ 2) 예를 들어, O(2^n), O(3^n), O(1.5^n) 등이 모두 지수 시간 복잡도에 해당한다.
다항 시간과의 비교 지수 시간 알고리즘은 다항 시간(Polynomial Time) 알고리즘과 비교할 때 확연히 비효율적:
...</p></div><footer class=entry-footer><span title='2024-12-12 14:29:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 지수 시간(Exponential Time) 복잡도" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/exptime/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NP-완전(NP-Complete)</h2></header><div class=entry-content><p>NP-완전(NP-Complete) 계산 복잡도 이론은 컴퓨터 과학의 핵심 분야 중 하나로, 문제의 내재적 난이도를 수학적으로 분류하고 분석한다.
그 중에서도 NP-완전(NP-Complete) 문제들은 효율적인 알고리즘 설계와 문제 해결의 한계를 이해하는 데 결정적인 역할을 한다.
NP-완전성은 컴퓨터 과학의 핵심 개념으로, 효율적인 알고리즘 설계의 근본적인 한계를 이해하는 데 중요하다.
비록 NP-완전 문제를 다항 시간에 정확히 해결하는 알고리즘은 알려져 있지 않지만, 다양한 실용적인 접근법을 통해 많은 실제 인스턴스를 효과적으로 해결할 수 있다.
IT 개발자로서 NP-완전성을 이해하면 문제의 본질적인 난이도를 파악하고, 적절한 알고리즘과 최적화 기법을 선택하는 데 도움이 된다. 또한 시간과 공간 제약 내에서 가능한 최선의 해결책을 찾기 위한 전략을 개발하는 데 필수적인 지식을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:28:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NP-완전(NP-Complete)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/completeness-theory/np-complete/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다항 시간(Polynomial Time, P)</h2></header><div class=entry-content><p>다항 시간(Polynomial Time, P) 다항 시간(Polynomial Time)은 알고리즘 설계와 분석에서 가장 중요한 복잡도 클래스 중 하나이다.
다항 시간 복잡도의 이해는 개발자에게 필수적인 역량이다.
이는 단순히 이론적인 지식이 아니라 실제 문제 해결과 시스템 설계에 직접적인 영향을 미치는 실용적인 도구이다.
이 지식을 효과적으로 활용하기 위한 단계별 접근법:
기초 다지기: 기본적인 복잡도 분석 방법과 주요 알고리즘의 복잡도 이해하기 실습하기: 다양한 알고리즘 구현 및 성능 측정을 통한 직접 경험 쌓기 지속적 학습: 새로운 알고리즘과 데이터 구조에 대한 지식 업데이트하기 실제 적용: 업무 프로젝트에서 성능 최적화 기회 찾기 다항 시간의 기본 개념 정의 다항 시간(Polynomial Time)이란 알고리즘의 실행 시간이 입력 크기 n에 대한 다항식 함수로 표현될 수 있음을 의미한다.
즉, 알고리즘의 시간 복잡도가 O(n^k) 형태로 표현되는 경우를 말한다. 여기서 k는 상수이다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:28:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 다항 시간(Polynomial Time, P)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/p/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비결정론적 다항 시간(Non-deterministic Polynomial Time, NP)</h2></header><div class=entry-content><p>비결정론적 다항 시간(Non-deterministic Polynomial Time, NP) 비결정론적 다항 시간(이하 NP)은 계산 복잡도 이론의 핵심 개념 중 하나로, 알고리즘과 문제 해결의 근본적인 한계를 이해하는 데 중요한 역할을 한다.
IT 개발자로서 NP에 대한 이해는 효율적인 알고리즘 설계와 복잡한 문제에 대한 현실적인 접근 방식을 개발하는 데 필수적이다.
비결정론적 다항 시간(NP) 클래스에 대한 이해는 IT 개발자에게 중요한 이론적 기반을 제공한다.
이러한 이해를 바탕으로 개발자는 복잡한 문제에 직면했을 때:
문제의 난이도를 올바르게 평가하고 적절한 기대치를 설정할 수 있다. 실용적인 해결 전략을 선택하고 구현할 수 있다. 제한된 자원 내에서 최상의 결과를 얻을 수 있는 시스템을 설계할 수 있다. 새로운 계산 패러다임과 도구를 활용하여 혁신적인 해결책을 개발할 수 있다.
NP 문제의 근본적인 복잡성은 도전적이지만, 동시에 창의적인 알고리즘 설계와 시스템 아키텍처를 통해 이러한 문제를 실용적으로 다루는 방법은 IT 개발 분야에서 끊임없는 혁신의 원천이 되고 있다. NP의 기본 개념 정의 비결정론적 다항 시간(NP)은 비결정론적 튜링 기계(Non-deterministic Turing Machine)에서 다항 시간 내에 해결할 수 있는 결정 문제들의 집합을 의미한다. 좀 더 직관적인 정의로는 “해답이 주어졌을 때 그 해답이 올바른지 다항 시간 내에 검증할 수 있는 문제들의 집합"이라고 할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:28:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 비결정론적 다항 시간(Non-deterministic Polynomial Time, NP)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-computer-science/computational-complexity/time-complexity-classes/np/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mutex</h2></header><div class=entry-content><p>Mutex **뮤텍스 (Mutex)**는 멀티스레드 및 멀티프로세스 환경에서 공유 자원에 대한 동시 접근을 제어하기 위한 핵심 동기화 프리미티브다. 임계 구역 (Critical Section) 에 한 번에 하나의 실행 흐름만 접근하도록 보장하며, 레이스 조건, 데이터 무결성 문제, 교착 상태 등을 예방한다. 스핀 락, 재귀 락, 슬립 락 등 다양한 구현 방식이 존재하며, 우선순위 상속, 데드락 회피, 우선순위 역전 대응 등 고급 기능도 지원된다. 현대 운영체제 및 프로그래밍 언어에서 폭넓게 활용되며, RW-lock, RCU, Lock-Free 구조 등이 대체 기법으로 함께 고려된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 11:00:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;<span>42 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Mutex" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/mutexes-and-locks/mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>조건 변수 (Condition Variables)</h2></header><div class=entry-content><p>조건 변수 (Condition Variable) 조건 변수 (Condition Variable) 는 멀티스레드 환경에서 스레드가 특정 조건이 충족될 때까지 Busy-wait 없이 대기하도록 하는 동기화 메커니즘이다.
반드시 뮤텍스와 함께 사용하여 조건 검사·변경의 원자성을 보장하며, 주요 연산은 wait()(대기), signal()/notify_one()(하나 깨움), broadcast()/notify_all()(모두 깨움) 이다.
대부분 Mesa-style 구현을 따르므로 깨어난 뒤 조건을 while 루프로 재검사해야 하며, 유령 깨움과 신호 손실 방지를 위해 상태 변경 후 락을 잡은 채 신호를 보내야 한다.
생산자 - 소비자, 이벤트 처리, 흐름 제어 등에서 필수적으로 활용되며, POSIX, C++, Java, Go 등 다양한 플랫폼에서 지원된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:54:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;<span>68 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 조건 변수 (Condition Variables)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/condition-variables/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Monitor</h2></header><div class=entry-content><p>Monitor 대표 태그 생성 Synchronization-Primitive Concurrency-Control Mutual-Exclusion 동작-메커니즘 대표 태그 생성 Synchronization-Primitive Thread-Safety Concurrency-Control High-Level-Abstraction 분류 체계 검증 현재 분류: “Computer Science Fundamentals > Concurrency and Parallelism > Synchronization Primitives > Software Level”
검증 결과: 적절한 분류입니다.
근거: 모니터 (Monitor)는 동시성 제어를 위한 소프트웨어 수준의 동기화 기법으로, 뮤텍스 (Mutex)와 조건 변수 (Condition Variables)를 결합한 고수준 추상화 메커니즘입니다. 운영체제나 하드웨어 수준이 아닌 프로그래밍 언어 차원에서 제공되는 동기화 구조이므로 Software Level 분류가 정확합니다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:54:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;<span>100 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Monitor" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency--parallel-computing/concurrency-fundamentals/synchronization-primitives/monitor/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/computer-science-fundamentals/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/computer-science-fundamentals/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>