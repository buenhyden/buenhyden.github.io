<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>DevOps | hyunyoun's Blog</title>
<meta name=keywords content="Software-Development-and-Maintenance,Software-Development,Software-Maintenance,DevOps"><meta name=description content="소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/devops/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="DevOps"><meta property="og:description" content="소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="DevOps"><meta name=twitter:description content="소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DevOps","item":"https://buenhyden.github.io/posts/devops/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a></div><h1>DevOps</h1><div class=post-description>소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론</div></header><div class=post-content><h2 id=devops>DevOps<a hidden class=anchor aria-hidden=true href=#devops>#</a></h2><p>소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론이다.<br>이 접근 방식은 조직의 소프트웨어 제품과 서비스를 빠르게 개발하고 개선하는 능력을 향상시키는 것을 목표로 한다.</p><p>DevOps는 개발팀과 운영팀 간의 협업을 강화하고, 소프트웨어 개발 주기 전반에 걸쳐 자동화와 지속적인 피드백을 통합하는 방식이다.<br>이는 전통적인 소프트웨어 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있게 한다.</p><h3 id=devops의-중요성>DevOps의 중요성<a hidden class=anchor aria-hidden=true href=#devops의-중요성>#</a></h3><ol><li><strong>빠른 시장 출시</strong>: DevOps는 지속적 통합(CI)과 지속적 배포(CD)를 통해 소프트웨어 업데이트와 새로운 기능을 빠르고 안정적으로 제공할 수 있게 한다.</li><li><strong>품질 향상</strong>: 자동화된 테스트와 모니터링을 통해 소프트웨어의 품질과 신뢰성을 높인다.</li><li><strong>고객 만족도 증가</strong>: 빠른 피드백 루프를 통해 고객의 요구사항에 신속하게 대응할 수 있다.</li><li><strong>비용 절감</strong>: 프로세스 자동화와 효율적인 리소스 관리를 통해 운영 비용을 줄일 수 있다.</li></ol><h3 id=devops의-주요-특징>DevOps의 주요 특징<a hidden class=anchor aria-hidden=true href=#devops의-주요-특징>#</a></h3><ol><li><strong>협업</strong>: 개발팀과 운영팀 간의 긴밀한 협력을 촉진한다.</li><li><strong>자동화</strong>: 반복적인 작업을 자동화하여 인적 오류를 줄이고 효율성을 높인다.</li><li><strong>지속적 통합 및 배포(CI/CD)</strong>: 코드 변경사항을 자주 통합하고 자동으로 배포한다.</li><li><strong>모니터링과 피드백</strong>: 실시간으로 애플리케이션 성능을 모니터링하고 빠른 피드백을 제공한다.</li></ol><h3 id=devops의-장점>DevOps의 장점<a hidden class=anchor aria-hidden=true href=#devops의-장점>#</a></h3><ol><li><strong>빠른 제품 출시</strong>: 개발 주기를 단축하여 시장 경쟁력을 높인다.</li><li><strong>안정성 향상</strong>: 자동화된 테스트와 배포로 시스템 안정성이 개선된다.</li><li><strong>팀 생산성 증가</strong>: 협업 강화와 프로세스 최적화로 팀의 생산성이 향상된다.</li><li><strong>비용 효율성</strong>: 자동화와 효율적인 리소스 관리로 운영 비용이 절감된다.</li></ol><h3 id=devops의-단점>DevOps의 단점<a hidden class=anchor aria-hidden=true href=#devops의-단점>#</a></h3><ol><li><strong>문화적 변화의 어려움</strong>: 기존 조직 문화를 변경하는 데 저항이 있을 수 있다.</li><li><strong>초기 투자 비용</strong>: 도구와 프로세스 구축에 상당한 초기 투자가 필요할 수 있다.</li><li><strong>복잡성</strong>: 다양한 도구와 기술을 통합하는 과정에서 복잡성이 증가할 수 있다.</li><li><strong>보안 문제</strong>: 빠른 배포 주기로 인해 보안 검토가 충분히 이루어지지 않을 수 있다.</li></ol><h3 id=devops의-주요-구성-요소>DevOps의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#devops의-주요-구성-요소>#</a></h3><ol><li><strong>지속적 통합(CI)</strong>: 개발자의 코드 변경사항을 정기적으로 통합하고 테스트한다.<ul><li>코드 버전 관리</li><li>자동화된 빌드</li><li>자동화된 테스트</li><li>코드 품질 분석</li></ul></li><li><strong>지속적 배포(CD)</strong>: 코드 변경사항을 자동으로 프로덕션 환경에 배포한다.<ul><li>자동화된 배포 파이프라인</li><li>환경 구성 관리</li><li>릴리스 관리</li><li>롤백 메커니즘</li></ul></li><li><strong>인프라스트럭처 as 코드(IaC)</strong>: 인프라 구성을 코드로 관리하여 일관성과 확장성을 확보한다.</li><li><strong>마이크로서비스</strong>: 애플리케이션을 작은 독립적인 서비스로 분할하여 개발과 배포를 용이하게 한다.</li><li><strong>모니터링 및 로깅</strong>: 시스템 성능과 사용자 행동을 실시간으로 추적하고 분석한다.<ul><li>성능 모니터링</li><li>로그 수집 및 분석</li><li>알림 시스템</li><li>문제 추적</li></ul></li></ol><hr><h2 id=roadmap>Roadmap<a hidden class=anchor aria-hidden=true href=#roadmap>#</a></h2><h2 id=roadmap---devops><a href=https://roadmap.sh/devops>Roadmap - DevOps</a><a hidden class=anchor aria-hidden=true href=#roadmap---devops>#</a></h2><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Infrastructure</h2></header><div class=entry-content><p>Infrastructure Infrastructure(인프라스트럭처)는 조직의 IT 환경을 지원하고 운영하는 데 필요한 기본적인 구성 요소들의 집합이다.
이는 하드웨어, 소프트웨어, 네트워크 리소스 및 서비스를 포함한다.
Infrastructure의 주요 구성 요소 하드웨어
서버: 네트워크 저장소 및 애플리케이션 처리를 제공 스토리지 장치: 하드 드라이브, SSD 등 네트워킹 장비: 라우터, 스위치, 케이블 등 데이터 센터: 중요한 IT 장비와 지원 인프라를 수용하는 시설 소프트웨어
운영 체제: 하드웨어 운영 및 애플리케이션 실행의 기반 데이터베이스: 대량의 데이터를 조직, 저장 및 접근 용이하게 함 미들웨어: 소프트웨어 애플리케이션 간 통신 및 데이터 교환을 위한 연결 계층 네트워크 인프라
...</p></div><footer class=entry-footer><span title='2024-11-10 01:29:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;204 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Infrastructure" href=https://buenhyden.github.io/posts/devops/infrastructure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)</h2></header><div class=entry-content><p>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE) 사이트 신뢰성 엔지니어링(Site Reliability Engineering, SRE)은 IT 운영에 대한 소프트웨어 엔지니어링 접근 방식이다.
이 개념은 Google의 Ben Treynor Sloss가 2003년에 창안했으며, 소프트웨어 시스템의 안정성과 신뢰성을 유지하고 향상시키는 것을 목표로 한다.
예시를 들어, 설명해보면:
온라인 쇼핑몰을 운영하는 회사에서 SRE 팀이 다음과 같은 작업을 수행할 수 있다:
서비스 수준 목표 설정: 웹사이트 가용성 99.99%, 페이지 로드 시간 2초 이내 등의 목표를 정한다. 모니터링 시스템 구축: 실시간으로 웹사이트 트래픽, 서버 성능, 주문 처리 속도 등을 모니터링하는 대시보드를 만든다. 자동화: 서버 프로비저닝, 데이터베이스 백업, 보안 패치 적용 등의 작업을 자동화하는 스크립트를 개발한다. 장애 대응: 블랙프라이데이와 같은 대규모 세일 기간 동안 급증하는 트래픽에 대비한 대응 계획을 수립하고, 실제 장애 발생 시 신속하게 대응한다. 성능 최적화: 데이터베이스 쿼리 최적화, 캐싱 전략 수립, CDN 활용 등을 통해 웹사이트 성능을 지속적으로 개선한다. SRE는 개발팀과 운영팀 사이의 가교 역할을 하며, 소프트웨어의 안정성과 확장성을 보장하는 동시에 새로운 기능의 빠른 출시를 가능하게 한다.
이를 통해 기업은 고객에게 더 나은 서비스를 제공하고 비즈니스 목표를 달성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:18:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;761 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)" href=https://buenhyden.github.io/posts/devops/sre/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>온프레미스(On-Premise)</h2></header><div class=entry-content><p>온프레미스(On-Premise) On-Premise는 기업이 자체적으로 보유한 시설이나 건물에 IT 인프라를 구축하고 운영하는 방식을 의미한다.
‘현장에서’ 또는 ‘사내에서’라는 뜻의 이 용어는, 기업이 서버, 소프트웨어, 네트워크 등의 IT 자원을 직접 소유하고 관리하는 전통적인 방식을 설명한다.
On-Premise의 주요 특징 자체 인프라 구축과 관리
기업은 모든 하드웨어와 소프트웨어를 직접 구매하고 설치한다.
서버실을 운영하고, 네트워크를 구성하며, 필요한 보안 시스템을 구축한다.
이는 완전한 통제권을 가질 수 있다는 장점이 있지만, 동시에 많은 초기 투자와 지속적인 관리가 필요하다.
데이터 보안과 통제
모든 데이터가 기업 내부에 저장되고 관리되므로, 데이터 보안에 대한 완전한 통제권을 갖는다.
특히 금융기관이나 정부기관처럼 높은 수준의 보안이 요구되는 조직에서 선호하는 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-10 10:29:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;282 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 온프레미스(On-Premise)" href=https://buenhyden.github.io/posts/devops/on-premise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Serverless Architecture</h2></header><div class=entry-content><p>Serverless Architecture Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.
Serverless Architecture는 빠른 개발 속도와 비용 효율성으로 스타트업 및 이벤트 기반 애플리케이션에 적합하나, 장기 실행 작업이나 높은 제어력이 필요한 경우에는 EC2 등의 전통적 아키텍처와의 조합이 필요하다.
AWS Lambda + API Gateway + DynamoDB 조합이 가장 널리 사용되며, Serverless Framework를 통해 멀티 클라우드 환경 구축이 가능하다.
...</p></div><footer class=entry-footer><span title='2024-09-27 11:41:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;691 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless Architecture" href=https://buenhyden.github.io/posts/devops/serverless/serverless-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Terraform</h2></header><div class=entry-content><p>Terraform Roadmap Roadmap - Terraform 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-20 15:35:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Terraform" href=https://buenhyden.github.io/posts/devops/provisioning/terraform/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service Mesh</h2></header><div class=entry-content><p>서비스 메시 (Service Mesh) 마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하기 위한 인프라 계층.
현대의 마이크로서비스 아키텍처에서는 수많은 서비스들이 서로 통신하면서 복잡한 네트워크를 형성한다.
이러한 환경에서 서비스 간 통신의 안정성, 보안, 관찰 가능성을 확보하는 것이 매우 중요한 과제가 되었고, 이러한 문제들을 해결하고 애플리케이션 코드 변경 없이 인프라 수준에서 통신을 제어하기 위해 서비스 메시가 등장하였다.
서비스 메시는 사이드카 프록시(Sidecar Proxy)를 사용하여 서비스 간 통신을 처리한다.
각 서비스 인스턴스 옆에 프록시가 배치되어, 마치 오토바이의 사이드카처럼 함께 동작한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 09:47:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;217 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Mesh" href=https://buenhyden.github.io/posts/devops/service-mesh/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud</h2></header><div class=entry-content><p>Cloud 클라우드 컴퓨팅은 컴퓨팅 리소스(서버, 스토리지, 데이터베이스, 네트워킹, 소프트웨어 등)를 인터넷을 통해 필요에 따라 제공하고 사용하는 기술.
사용자는 물리적인 하드웨어나 데이터 센터를 직접 관리할 필요 없이, 필요한 만큼의 리소스를 사용하고 그에 따른 비용만 지불하면 된다.
서비스 유형 IaaS (Infrastructure as a Service) 가상 서버, 스토리지, 네트워크 등 기본적인 컴퓨팅 인프라를 제공 예시: AWS EC2, Google Compute Engine, Azure Virtual Machines 사용자가 운영체제부터 직접 관리 가능하며 가장 유연한 형태의 클라우드 서비스 PaaS (Platform as a Service) 애플리케이션을 개발, 실행, 관리할 수 있는 플랫폼 제공 예시: Heroku, Google App Engine, Azure App Service 개발자가 인프라 걱정 없이 애플리케이션 개발에 집중 가능 SaaS (Software as a Service) 완성된 소프트웨어를 인터넷을 통해 제공 예시: Google Workspace, Microsoft 365, Salesforce 사용자는 소프트웨어를 설치하거나 관리할 필요 없이 바로 사용 가능 클라우드 배포 모델 퍼블릭 클라우드 AWS, Google Cloud, Azure와 같은 공개 클라우드 서비스 누구나 사용 가능하며 리소스를 공유하는 형태 비용 효율적이지만 보안과 규정 준수에 제약이 있을 수 있음 프라이빗 클라우드 조직 내부에서만 사용하는 클라우드 환경 보안과 규정 준수가 중요한 기업에서 선호 직접 구축하고 관리해야 하므로 비용이 높음 하이브리드 클라우드 퍼블릭과 프라이빗 클라우드를 함께 사용 상황에 따라 유연하게 리소스 활용 가능 복잡한 관리가 필요하지만 장점을 최대한 활용 가능 클라우드의 주요 특징 탄력성과 확장성 필요에 따라 리소스를 즉시 확장하거나 축소 가능 자동 확장 기능으로 수요 변화에 대응 예시: 트래픽 급증 시 자동으로 서버 증설 종량제 과금 실제 사용한 리소스에 대해서만 비용 지불 초기 투자 비용 최소화 비즈니스 성장에 따라 유연하게 비용 조절 고가용성 여러 지역에 분산된 데이터 센터 자동 백업과 재해 복구 기능 서비스 중단 위험 최소화 자동화 리소스 프로비저닝 자동화 모니터링과 알림 자동화 운영 효율성 향상 클라우드의 활용 사례 웹 애플리케이션 호스팅
...</p></div><footer class=entry-footer><span title='2024-11-10 06:03:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;457 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud" href=https://buenhyden.github.io/posts/devops/cloud/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CI/CD</h2></header><div class=entry-content><p>CI/CD (Continuous Integration/Continuous Delivery) ![CI/CD Pipeline](CICD_pipelines_work.png “What is CI/CD: Meaning, Definition & Pipeline Concepts_
CI (Continuous Integration, 지속적 통합) 개발자들이 개별적으로 작업한 코드를 주기적으로 공유 저장소에 통합하여, 자동화된 빌드와 테스트를 수행하는 프로세스.
![Continuous Integration (CI)](Continuous_Integration-CI.png “https://www.wallarm.com/what/what-is-ci-cd-concept-how-can-it-work_
주요 구성 요소 공유 코드 저장소 자동화된 빌드 프로세스 자동화된 테스트 suite CI(Continuous Integration)를 구현할 때 필요한 주요 도구 버전 관리 시스템 (Version Control System) Git, SVN, Mercurial 등 코드 변경 사항을 추적하고 관리 CI 서버 Jenkins, GitLab CI, CircleCI, Travis CI 등 자동화된 빌드와 테스트를 실행 빌드 도구 Maven, Gradle, Ant (Java) npm, Webpack (Javascript) MSBuild (.NET) 자동화된 테스트 프레임워크 JUnit, TestNG (Java) Mocha, Jest (Javascript) NUnit (.NET) Selenium (웹 애플리케이션 테스트) 코드 품질 분석 도구 SonarQube, ESLint, Checkstyle 코드 품질 메트릭을 측정하고 보고. 아티팩트 저장소 Nexus, Artifactory 빌드 결과물을 저장하고 관리. 컨테이너화 도구 Docker, Kubernetes 일관된 환경에서 빌드와 테스트 실행 알림 도구 Slack, Email, MS Teams 빌드 결과를 팀원들에게 통지 구성 관리 도구 Ansible, Puppet, Chef 환경 설정을 자동화 모니터링 도구 Grafana, Prometheus CI 파이프라인의 성능을 모니터링 목적 버그를 조기에 발경하고 품질 향상 소프트웨어 품질 향상 개발 주기 단축 장점 리스크 감소: 작은 변경사항을 자주 통합하여 큰 문제 예방 버그 조기 발견: 자동화된 테스트로 빠른 피드백 제공 팀 협업 개선: 투명한 개발 프로세스 촉진 제품 품질 향상: 지속적인 코드 리뷰와 테스트 배포 가능한 소프트웨어 상시 유지 구현 단계 공유 저장소 설정 자동화된 빌드 구축 자동화된 테스트 작성 및 통합 CI 서버 구성 (예: Jenkins, GitLab CI) 팀 작업 흐름 조정 모범 사례 작은 단위로 자주 커밋 모든 커밋에 대해 빌드 실행 빠른 빌드 유지 (10분 이내 권장) 테스트 환경을 프로덕션과 유사하게 유지 모든 테스트가 통과한 빌드만 허용. Source: &lt;https://www.wallarm.com/what/what-is-continuous-integration-ci-explainedby-wallarm
...</p></div><footer class=entry-footer><span title='2024-09-28 18:14:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;19 min&nbsp;·&nbsp;3987 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI/CD" href=https://buenhyden.github.io/posts/devops/ci-and-cd/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Version Control Systems</h2></header><div class=entry-content><p>Version Control Systems 파일의 변경 이력을 시간에 따라 기록하여, 특정 시점의 버전을 다시 꺼내올 수 있는 시스템.
소프트웨어 소스 코드뿐만 아니라, 그래픽 디자이너나 웹 디자이너가 작업하는 이미지나 레이아웃 등 거의 모든 컴퓨터 파일의 버전을 관리할 수 있다.
기능 이전 상태로 되돌리기:각 파일이나 전체 프로젝트를 이전 상태로 복원할 수 있다. 변경 내용 비교: 시간에 따른 수정 내용을 비교하여, 누가 언제 어떤 변경을 했는지 추적할 수 있다. 문제 원인 파악: 문제를 일으킨 변경 사항을 추적하여, 누가 언제 이슈를 발생시켰는지 알 수 있다. 복구 용이성: 파일을 잃어버리거나 잘못 수정했을 때도 쉽게 복구할 수 있다. 종류 로컬 버전관리(Local VCS) 데이터베이스를 사용해서 파일의 변경 정보를 관리하는 시스템
RCS(Revision Control System)은 파일에서 변경되는 부분(Patch)만 기억해 용량 문제를 해결
RCS에서 버전 변경은 해당 버전까지의 일련의 변화들(Patch Set)을 적용/해제하는 식으로 동작
...</p></div><footer class=entry-footer><span title='2024-09-28 15:45:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;515 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Version Control Systems" href=https://buenhyden.github.io/posts/devops/version-control-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IaC</h2></header><div class=entry-content><p>IaC(Infrastructure As Code) Infrastructure as Code(IaC)는 인프라스트럭처를 코드로 관리하고 프로비저닝하는 방식이다.
전통적인 수동 인프라 구성 방식에서 벗어나 프로그래밍 언어를 사용하여 IT 인프라를 자동화하고 관리하는 접근법.
IaC의 핵심 개념 선언적 접근 방식: IaC는 주로 선언적 방식을 사용한다. 즉, “무엇"이 필요한지를 정의하며, 시스템이 그 상태를 달성하는 방법을 결정한다. 버전 관리: 인프라 구성을 코드로 관리함으로써 Git과 같은 버전 관리 시스템을 활용할 수 있다. 자동화: 인프라 구성, 배포, 관리 과정을 자동화하여 인적 오류를 줄이고 효율성을 높인다. 일관성: 동일한 코드로 여러 환경(개발, 테스트, 프로덕션)을 구성하여 일관성을 유지한다. IaC의 주요 이점 속도와 효율성: 인프라 구축 및 변경 과정을 자동화하여 시간과 비용을 절감한다. 일관성과 표준화: 모든 환경에서 동일한 구성을 보장하여 “환경 차이” 문제를 해결한다. 확장성: 코드를 통해 인프라를 쉽게 확장하거나 축소할 수 있다. 문서화: 코드 자체가 인프라 구성의 문서 역할을 한다. 위험 감소: 변경 사항을 코드로 관리하여 추적하고 롤백할 수 있어 위험을 줄일 수 있다. IaC의 구현 방식 선언적 접근 방식: 원하는 최종 상태를 정의하고, 도구가 현재 상태에서 목표 상태로 도달하는 방법을 결정한다. Terraform, AWS CloudFormation 등이 이 방식을 사용합니다. 명령적 접근 방식: 인프라를 구성하기 위한 정확한 단계와 절차를 정의한다. 쉘 스크립트나 Ansible의 일부 기능이 이 방식을 사용한다. 주요 IaC 도구들 Terraform: HashiCorp사의 오픈소스 IaC 도구로, 클라우드 중립적인 접근 방식을 제공한다. HCL(HashiCorp Configuration Language)을 사용하여 인프라를 정의하며, 다양한 클라우드 제공자를 지원한다. AWS CloudFormation: AWS의 네이티브 IaC 서비스로, JSON이나 YAML 형식으로 AWS 리소스를 정의할 수 있다. Ansible: Red Hat의 자동화 도구로, YAML 기반의 Playbook을 사용하여 구성 관리와 애플리케이션 배포를 자동화한다. Puppet/Chef: 구성 관리에 중점을 둔 도구들로, 서버의 상태와 설정을 코드로 관리한다. IaC 구현 모범 사례 모듈화와 재사용:
공통적으로 사용되는 인프라 구성을 모듈화하여 재사용성을 높인다.
이는 코드의 중복을 줄이고 관리를 용이하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 00:16:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;411 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to IaC" href=https://buenhyden.github.io/posts/devops/iac/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>