<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Virtualization | hyunyoun's Blog</title>
<meta name=keywords content="DevOps,Virtualization"><meta name=description content="컴퓨터 리소스의 추상화를 가능하게 하는 기술"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops/virtualization/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/devops/virtualization/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops/virtualization/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops/virtualization/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Virtualization"><meta property="og:description" content="컴퓨터 리소스의 추상화를 가능하게 하는 기술"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Virtualization"><meta name=twitter:description content="컴퓨터 리소스의 추상화를 가능하게 하는 기술"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DevOps","item":"https://buenhyden.github.io/posts/devops/"},{"@type":"ListItem","position":3,"name":"Virtualization","item":"https://buenhyden.github.io/posts/devops/virtualization/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops/>DevOps</a></div><h1>Virtualization</h1><div class=post-description>컴퓨터 리소스의 추상화를 가능하게 하는 기술</div></header><div class=post-content><h2 id=가상화-virtualization>가상화 (virtualization)<a hidden class=anchor aria-hidden=true href=#가상화-virtualization>#</a></h2><p>컴퓨터 리소스의 추상화를 가능하게 하는 기술<br>​가상화는 하나의 물리적 컴퓨팅 자원(예: 서버, 운영 체제, 애플리케이션, 스토리지)을 여러 개의 가상 리소스로 나누거나, 여러 개의 물리적 리소스를 하나의 가상 리소스로 통합하는 기술이다. 이를 통해 하드웨어의 활용도를 높이고, 유연성과 확장성을 제공한다.</p><h3 id=가상화의-유형>가상화의 유형<a hidden class=anchor aria-hidden=true href=#가상화의-유형>#</a></h3><ol><li><p>서버 가상화<br>서버 가상화는 하나의 물리적 서버를 여러 개의 가상 서버로 분할하는 기술.<br>이를 통해 각 가상 서버는 독립적인 운영 체제와 애플리케이션을 실행할 수 있다.</p></li><li><p>데스크톱 가상화<br>데스크톱 가상화는 사용자의 데스크톱 환경을 중앙 서버에서 가상화하여 제공하는 기술.<br>이를 통해 사용자는 어떤 장치에서든 자신의 가상 데스크톱에 접근할 수 있다.</p></li><li><p>애플리케이션 가상화<br>애플리케이션 가상화는 애플리케이션을 로컬 시스템에 설치하지 않고 서버에서 실행하여 사용자에게 제공하는 기술.</p></li><li><p>스토리지 가상화<br>스토리지 가상화는 여러 물리적 저장 장치를 하나의 논리적 저장 장치로 통합하는 기술.<br>이를 통해 스토리지 관리를 단순화하고 효율성을 높일 수 있다.</p></li><li><p>네트워크 가상화<br>네트워크 가상화는 물리적 네트워크 자원을 논리적으로 분할하거나 통합하여 가상 네트워크를 생성하는 기술.</p></li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>자원 활용도 향상: 하나의 물리적 서버에서 여러 가상 시스템을 운영함으로써 하드웨어 자원을 최대한 활용할 수 있다.</li><li>비용 절감: 물리적 서버의 수를 줄임으로써 하드웨어 구매 및 유지보수 비용을 절감할 수 있다.</li><li>관리 효율화: 중앙집중식 관리를 통해 시스템 관리와 유지보수가 용이해진다.</li><li>유연성과 확장성: 필요에 따라 가상 시스템을 쉽게 생성, 삭제, 이동할 수 있어 IT 인프라의 유연성과 확장성이 향상된다.</li><li>재해 복구 및 비즈니스 연속성: 가상화를 통해 백업 및 복구 프로세스가 간소화되어 재해 발생 시 빠른 복구가 가능하다.</li></ol><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><ol><li>초기 구축 비용: 가상화 환경을 구축하기 위한 초기 투자 비용이 높을 수 있다.</li><li>성능 오버헤드: 가상화 레이어로 인해 일부 성능 저하가 발생할 수 있다.</li><li>복잡성: 가상화 환경의 관리와 문제 해결이 더 복잡해질 수 있다.</li><li>보안 위험: 하나의 물리적 서버에 여러 가상 시스템이 존재하므로, 보안 취약점이 발생할 경우 영향 범위가 넓어질 수 있다.</li><li>하드웨어 의존성: 가상화 환경 전체가 물리적 서버에 의존하므로, 하드웨어 장애 시 모든 가상 시스템에 영향을 줄 수 있다.</li></ol><p>가상화 기술은 현대 IT 인프라의 핵심 요소로, 클라우드 컴퓨팅의 기반이 되고 있다.<br>적절히 구현된 가상화는 기업의 IT 효율성을 크게 향상시키고 비용을 절감할 수 있지만, 동시에 신중한 계획과 관리가 필요하다.</p><h4 id=서버-가상화>서버 가상화<a hidden class=anchor aria-hidden=true href=#서버-가상화>#</a></h4><h5 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h5><ol><li>자원 활용도 향상: 하나의 물리적 서버에서 여러 가상 서버를 운영하여 하드웨어 자원을 최대한 활용할 수 있다.</li><li>비용 절감: 물리적 서버의 수를 줄여 하드웨어 구매 및 유지보수 비용을 절감할 수 있다..</li><li>관리 효율화: 중앙집중식 관리를 통해 시스템 관리와 유지보수가 용이해진다.</li><li>유연성과 확장성: 필요에 따라 가상 서버를 쉽게 생성, 삭제, 이동할 수 있어 IT 인프라의 유연성과 확장성이 향상된다.</li><li>재해 복구 및 비즈니스 연속성: 가상화를 통해 백업 및 복구 프로세스가 간소화되어 재해 발생 시 빠른 복구가 가능하다.</li></ol><h5 id=단점-1>단점<a hidden class=anchor aria-hidden=true href=#단점-1>#</a></h5><ol><li>초기 구축 비용: 가상화 환경을 구축하기 위한 초기 투자 비용이 높을 수 있다.</li><li>성능 오버헤드: 가상화 레이어로 인해 일부 성능 저하가 발생할 수 있다.</li><li>복잡성: 가상화 환경의 관리와 문제 해결이 더 복잡해질 수 있다.</li><li>보안 위험: 하나의 물리적 서버에 여러 가상 시스템이 존재하므로, 보안 취약점이 발생할 경우 영향 범위가 넓어질 수 있다.</li></ol><p><figure><img alt="Virtualization architecture" loading=lazy src=/img/virtualization-architecture.png><figcaption>https://v2cloud.com/blog/top-5-virtualization-platforms</figcaption></figure></p><h4 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h4><h5 id=하이퍼바이저-가성화>하이퍼바이저 가성화<a hidden class=anchor aria-hidden=true href=#하이퍼바이저-가성화>#</a></h5><blockquote><p>하이퍼바이저<br>물리적 하드웨어와 가상 머신(VM) 간의 중개 역할을 하는 소프트웨어.</p></blockquote><p>Type 1 하이퍼바이저(베어메탈 하이퍼바이저) 방식에 해당한다.</p><ul><li>물리적 하드웨어 위에 직접 하이퍼바이저가 설치된다.</li><li>하이퍼바이저 위에 여러 게스트 OS가 실행된다.</li></ul><p>하이퍼바이저 가상화는 두 가지로 나눌 수 있다:</p><ol><li>전가상화(Full Virtualization): 하드웨어를 완전히 가상화하여 게스트 OS의 수정 없이 사용 가능하다.</li><li>반가상화(Para-Virtualization): 하드웨어를 부분적으로 가상화하여 성능을 개선하지만, 게스트 OS의 수정이 필요하다.<br><figure><img alt="Para vs Full Virtualization" loading=lazy src=/img/0_2SdhWwLOdbrcH17o.webp></figure></li></ol><h5 id=호스트-가상화>호스트 가상화<a hidden class=anchor aria-hidden=true href=#호스트-가상화>#</a></h5><p>호스트 OS 위에 가상화 소프트웨어를 설치하여 가상 머신을 관리한다.<br>Type 2 하이퍼바이저 방식에 속한다.<br>이 방식은 구현이 간단하지만, 호스트 OS를 거쳐야 하므로 성능 오버헤드가 발생할 수 있다.</p><ul><li>물리적 하드웨어 위에 호스트 운영체제(Host OS)가 설치된다.</li><li>호스트 OS 위에 가상화 소프트웨어(예: VMware Workstation, VirtualBox)가 설치된다.</li><li>가상화 소프트웨어 위에 게스트 운영체제(Guest OS)가 실행된다.</li></ul><h5 id=컨테이너-기반-가상화>컨테이너 기반 가상화<a hidden class=anchor aria-hidden=true href=#컨테이너-기반-가상화>#</a></h5><p>OS 수준의 가상화 방식으로, 별도의 카테고리로 분류된다.</p><p><figure><img alt=Docker loading=lazy src=/img/docker.png><figcaption>Source: https://www.docker.com/resources/what-container/</figcaption></figure></p><ul><li>호스트 OS 위에 컨테이너 관리 소프트웨어(예: Docker)가 설치된다.</li><li>컨테이너는 호스트 OS의 커널을 공유하면서 독립된 사용자 공간을 제공한다.</li><li>각 컨테이너는 애플리케이션과 그 종속성만을 포함하여 매우 경량화되어 있다.</li></ul><h4 id=데스크탑-가상화>데스크탑 가상화<a hidden class=anchor aria-hidden=true href=#데스크탑-가상화>#</a></h4><p>데스크탑 가상화는 운영 체제, 애플리케이션, 사용자 데이터를 포함한 전체 데스크탑 환경을 가상화하여 중앙 서버에서 관리한다. 사용자는 다양한 기기를 통해 이 가상 데스크탑에 원격으로 접속할 수 있다.</p><h5 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h5><ol><li>중앙 서버에서 가상 머신(VM)을 생성하고 관리한다.</li><li>각 VM에는 운영 체제와 필요한 애플리케이션이 설치된다.</li><li>사용자는 원격 디스플레이 프로토콜(RDP)을 통해 가상 데스크탑에 접속한다.</li><li>사용자의 입력(키보드, 마우스)은 서버로 전송되고, 화면 업데이트는 사용자의 기기로 전송된다.</li></ol><h5 id=유형>유형<a hidden class=anchor aria-hidden=true href=#유형>#</a></h5><ol><li>VDI(Virtual Desktop Infrastructure): 각 사용자에게 전용 VM을 제공한다.</li><li>원격 데스크탑 서비스(RDS): 여러 사용자가 하나의 서버 OS 인스턴스를 공유한다.</li><li>DaaS(Desktop-as-a-Service): 클라우드 기반의 가상 데스크탑 서비스이다.</li></ol><h5 id=장점-2>장점<a hidden class=anchor aria-hidden=true href=#장점-2>#</a></h5><ol><li>유연성과 접근성: 어떤 기기에서든 자신의 데스크탑 환경에 접근 가능하다.</li><li>중앙화된 관리: IT 팀이 모든 데스크탑을 중앙에서 관리할 수 있다.</li><li>보안 강화: 데이터가 중앙 서버에 저장되어 정보 유출 위험이 감소한다.</li><li>비용 절감: 하드웨어 구매 및 유지보수 비용을 줄일 수 있다.</li></ol><h5 id=단점-2>단점<a hidden class=anchor aria-hidden=true href=#단점-2>#</a></h5><ol><li>초기 구축 비용이 높을 수 있다.</li><li>네트워크 의존성: 안정적인 인터넷 연결이 필요하다.</li><li>성능 이슈: 네트워크 지연으로 인한 성능 저하가 발생할 수 있다.</li></ol><h4 id=애플리케이션-가상화>애플리케이션 가상화<a hidden class=anchor aria-hidden=true href=#애플리케이션-가상화>#</a></h4><p>애플리케이션 가상화는 애플리케이션을 물리적 하드웨어에 직접 설치하지 않고도 실행할 수 있도록 하는 기술.<br>이 기술은 사용자가 다양한 운영 체제에서 애플리케이션을 실행할 수 있게 해주며, 기업의 IT 관리와 보안을 개선하는 데 중요한 역할을 한다.<br>애플리케이션 가상화는 애플리케이션의 실행 환경을 가상화하여, 사용자가 원래 설계된 운영 체제와는 다른 환경에서도 애플리케이션을 사용할 수 있도록 한다.<br>예를 들어, Windows 애플리케이션을 Linux 환경에서 실행하거나, 특정 버전의 애플리케이션을 여러 사용자에게 제공할 수 있다.</p><h5 id=작동-방식>작동 방식<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h5><ol><li><strong>애플리케이션 스트리밍</strong>:<br>필요한 애플리케이션 코드의 일부만 클라이언트 장치로 전송되어 필요할 때만 실행된다.<br>이를 통해 전체 애플리케이션을 설치하지 않고도 사용할 수 있다.</li><li><strong>서버 기반 애플리케이션 가상화</strong>:<br>사용자는 웹 브라우저나 클라이언트 인터페이스를 통해 원격 서버에서 호스팅되는 애플리케이션에 접근한다.<br>이 방식은 설치가 필요 없으며, 사용자는 인터넷만 있으면 언제 어디서나 애플리케이션을 사용할 수 있다.</li><li><strong>로컬 애플리케이션 가상화</strong>:<br>애플리케이션 코드가 자체 환경에 포함되어 배포되므로, 사용자는 어떤 운영 체제에서도 변경 없이 실행할 수 있다.</li></ol><h5 id=장점-3>장점<a hidden class=anchor aria-hidden=true href=#장점-3>#</a></h5><ul><li><strong>유연성</strong>: 다양한 운영 체제에서 동일한 애플리케이션을 사용할 수 있어, 사용자 환경에 대한 제약이 줄어든다.</li><li><strong>관리 용이성</strong>: IT 관리자는 중앙에서 모든 애플리케이션을 관리하고 업데이트할 수 있으며, 각 사용자에게 필요한 소프트웨어를 일괄적으로 배포할 수 있다.</li><li><strong>비용 절감</strong>: 여러 버전의 애플리케이션을 동시에 운영할 수 있어, 하드웨어 및 라이선스 비용을 절감할 수 있다.</li><li><strong>보안 강화</strong>: 데이터는 중앙 서버에서 관리되므로 정보 유출 위험이 줄어들고, 각 사용자 단말기에서 데이터가 이동하지 않아 보안이 강화된다.</li></ul><h5 id=단점-3>단점<a hidden class=anchor aria-hidden=true href=#단점-3>#</a></h5><ul><li><strong>초기 설정 복잡성</strong>: 가상화 환경을 구축하기 위해서는 초기 설정과 전문 지식이 필요하다.</li><li><strong>네트워크 의존성</strong>: 원격 서버에 의존하므로 안정적인 네트워크 연결이 필수적이며, 네트워크 지연으로 인해 성능 저하가 발생할 수 있다.</li><li><strong>서버 장애 시 영향</strong>: 모든 시스템이 중앙 서버에 의존하기 때문에 서버 장애가 발생하면 모든 사용자에게 영향을 미칠 수 있다.</li></ul><h4 id=스토리지-가상화>스토리지 가상화<a hidden class=anchor aria-hidden=true href=#스토리지-가상화>#</a></h4><p>스토리지 가상화는 물리적 스토리지 자원을 논리적으로 추상화하여 단일 스토리지 풀로 통합 관리하는 기술이다.<br>이를 통해 스토리지 자원을 더욱 효율적으로 활용하고 관리할 수 있다.<br>스토리지 가상화는 여러 대의 이기종 저장 장치를 하나의 논리적 스토리지 풀로 통합하여 관리하는 기술.</p><h5 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h5><ul><li>공유(Sharing): 여러 서버가 동일한 스토리지 자원을 공유할 수 있다.</li><li>단일화(Aggregation): 여러 물리적 스토리지를 하나의 논리적 스토리지로 통합한다.</li><li>에뮬레이션(Emulation): 물리적으로 존재하지 않는 기능을 구현할 수 있다.</li><li>절연(Insulation): 가상화된 자원과 물리적 자원 간의 매핑을 관리한다.</li></ul><h5 id=유형-1>유형<a hidden class=anchor aria-hidden=true href=#유형-1>#</a></h5><ol><li>블록 가상화: 여러 물리적 스토리지의 유휴 공간을 모아 가상 디스크를 생성한다.</li><li>파일 가상화: 이기종 서버 간 파일 공유를 통해 동일한 파일명으로 공통 파일 그룹에 접근할 수 있게 한다.</li><li>테이프 가상화: 디스크를 테이프 드라이브처럼 에뮬레이션하여 고속 백업을 가능하게 한다.</li><li>디스크 컨트롤러 가상화: 하나의 물리적 스토리지 컨트롤러를 여러 개의 가상 컨트롤러로 분할한다.</li></ol><h5 id=구현-방식>구현 방식<a hidden class=anchor aria-hidden=true href=#구현-방식>#</a></h5><ol><li>어플라이언스 형태: IBM SAN Volume Controller (SVC)와 같은 전용 하드웨어를 사용한다.</li><li>지능형 SAN 스위치: EMC의 Invista와 같이 스위치에 가상화 기능을 탑재한다.</li><li>스토리지 컨트롤러 임베디드: 히타치의 TagmaStore처럼 스토리지 컨트롤러에 직접 가상화 기능을 구현한다.</li></ol><h5 id=장점-4>장점<a hidden class=anchor aria-hidden=true href=#장점-4>#</a></h5><ol><li>자원 활용도 향상: 유휴 스토리지 공간을 효율적으로 활용할 수 있다.</li><li>관리 용이성: 중앙집중식 관리를 통해 스토리지 관리가 간소화된다.</li><li>비용 절감: 하드웨어 구매 및 유지보수 비용을 줄일 수 있다.</li><li>유연성과 확장성: 필요에 따라 스토리지를 쉽게 추가하거나 제거할 수 있다.</li><li>가용성 향상: 데이터 복제 및 미러링을 통해 시스템 가용성을 높일 수 있다.</li></ol><h5 id=단점-4>단점<a hidden class=anchor aria-hidden=true href=#단점-4>#</a></h5><ol><li>초기 구축 비용: 가상화 환경 구축을 위한 초기 투자 비용이 발생할 수 있다.</li><li>복잡성: 가상화 환경의 관리와 문제 해결이 더 복잡해질 수 있다.</li><li>성능 오버헤드: 가상화 레이어로 인한 일부 성능 저하가 발생할 수 있다.</li></ol><h4 id=네트워크-가상화>네트워크 가상화<a hidden class=anchor aria-hidden=true href=#네트워크-가상화>#</a></h4><p>네트워크 가상화는 물리적 네트워크 인프라를 소프트웨어 기반으로 추상화하여 논리적인 가상 네트워크를 생성하는 기술이다.<br>이를 통해 하나의 물리적 네트워크를 여러 개의 가상 네트워크로 분할하거나, 여러 물리적 네트워크를 하나의 가상 네트워크로 통합할 수 있다.</p><h5 id=유형-2>유형<a hidden class=anchor aria-hidden=true href=#유형-2>#</a></h5><ol><li><strong>외부 네트워크 가상화</strong>: 물리적으로 동일한 LAN에 연결된 시스템을 여러 개의 VLAN으로 분리하거나, 반대로 여러 개의 LAN을 하나의 VLAN으로 통합하는 방식이다.</li><li><strong>내부 네트워크 가상화</strong>: 단일 서버 내에서 소프트웨어 컨테이너를 사용하여 물리적 네트워크를 에뮬레이션하는 방식이다. 이를 통해 서버의 효율성을 향상시킬 수 있습니다.</li></ol><h5 id=주요-기술>주요 기술<a hidden class=anchor aria-hidden=true href=#주요-기술>#</a></h5><ol><li><strong>VPN (Virtual Private Network)</strong>: 인터넷을 통해 여러 지역의 가상 네트워크를 연결하여 하나의 가상 네트워크를 구성하는 기술.</li><li><strong>VLAN (Virtual Local Area Network)</strong>: 하나의 물리적 스위치를 여러 개의 논리적 스위치로 분할하여 가상 네트워크를 구성하는 기술.</li><li><strong>VXLAN (Virtual Extensible LAN)</strong>: VLAN의 확장된 형태로, 더 큰 규모의 가상 네트워크를 구성할 수 있다.</li></ol><h5 id=장점-5>장점<a hidden class=anchor aria-hidden=true href=#장점-5>#</a></h5><ol><li><strong>자원 활용도 향상</strong>: 물리적 네트워크 자원을 더욱 효율적으로 활용할 수 있다.</li><li><strong>유연성과 확장성</strong>: 필요에 따라 가상 네트워크를 쉽게 생성, 삭제, 이동할 수 있다.</li><li><strong>비용 절감</strong>: 물리적 하드웨어의 수를 줄여 구매 및 유지보수 비용을 절감할 수 있다.</li><li><strong>보안 강화</strong>: 가상 네트워크 간 격리를 통해 보안을 향상시킬 수 있다.</li><li><strong>중앙집중식 관리</strong>: 네트워크 관리와 제어를 중앙에서 효율적으로 수행할 수 있다.</li></ol><h5 id=과제>과제<a hidden class=anchor aria-hidden=true href=#과제>#</a></h5><ol><li><strong>복잡성 증가</strong>: 가상 네트워크 환경의 관리와 문제 해결이 더 복잡해질 수 있다.</li><li><strong>초기 구축 비용</strong>: 가상화 환경을 구축하기 위한 초기 투자 비용이 발생할 수 있다.</li><li><strong>성능 오버헤드</strong>: 가상화 레이어로 인한 일부 성능 저하가 발생할 수 있다.</li><li><strong>전문 인력 확보</strong>: 가상화된 네트워크를 관리할 수 있는 전문 인력이 필요하다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Guest OS</h2></header><div class=entry-content><p>Guest OS 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-15 03:23:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Guest OS" href=https://buenhyden.github.io/posts/devops/virtualization/guest-os/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hypervisor</h2></header><div class=entry-content><p>Hypervisor 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-15 03:23:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hypervisor" href=https://buenhyden.github.io/posts/devops/virtualization/hypervisor/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Host OS</h2></header><div class=entry-content><p>Host OS 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-15 03:22:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Host OS" href=https://buenhyden.github.io/posts/devops/virtualization/host-os/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VM</h2></header><div class=entry-content><p>VM 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-15 03:22:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to VM" href=https://buenhyden.github.io/posts/devops/virtualization/vm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Container</h2></header><div class=entry-content><p>Container 애플리케이션 코드, 라이브러리, 설정 파일 등을 하나의 실행 가능한 패키지로 묶어 다양한 컴퓨팅 환경에서 일관되게 실행할 수 있게 해주는 기술.
컨테이너는 호스트 운영 체제의 커널을 공유하면서 격리된 사용자 공간에서 실행된다.
컨테이너 기술은 Docker, Kubernetes 등의 도구를 통해 구현되며, 현대적인 애플리케이션 개발 및 배포 환경에서 중요한 역할을 하고 있다.
특히 클라우드 네이티브 애플리케이션 개발과 마이크로서비스 아키텍처 구현에 널리 사용되고 있다.
컨테이너의 정의와 작동 방식 컨테이너는 애플리케이션 코드, 라이브러리, 설정 파일 등을 하나의 실행 가능한 패키지로 묶어 다양한 컴퓨팅 환경에서 일관되게 실행할 수 있게 해주는 기술.
컨테이너는 호스트 운영 체제의 커널을 공유하면서 격리된 사용자 공간에서 실행된다.
...</p></div><footer class=entry-footer><span title='2024-11-11 06:14:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;434 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Container" href=https://buenhyden.github.io/posts/devops/virtualization/containerization/container/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Virtualization Tools</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2024-12-15 03:22:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;0 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Virtualization Tools" href=https://buenhyden.github.io/posts/devops/virtualization/tools/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Containerization Tools</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;0 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Containerization Tools" href=https://buenhyden.github.io/posts/devops/virtualization/containerization/tools/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>posts</h2></header><div class=entry-content><p></p></div><footer class=entry-footer>0 min&nbsp;·&nbsp;0 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to posts" href=https://buenhyden.github.io/posts/devops/virtualization/types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kubernetes</h2></header><div class=entry-content><p>Kubernetes 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈소스 컨테이너 오케스트레이션 플랫폼
2014년 Google이 개발하고 2015년 Cloud Native Computing Foundation(CNCF)에 기부한 이 플랫폼은 현재 컨테이너 기반 인프라의 de facto 표준으로 자리잡음.
Source: https://kubernetes.io/ko/docs/concepts/overview/components/
주요 특징 컨테이너 오케스트레이션: Kubernetes는 다수의 컨테이너를 효율적으로 관리하고 조정합니다. 자동화된 배포 및 확장: 애플리케이션의 수요에 따라 자동으로 컨테이너를 배포하고 확장할 수 있습니다. 자가 회복(Self-healing): 장애가 발생한 컨테이너를 자동으로 감지하고 교체하여 서비스의 연속성을 보장합니다. 로드 밸런싱: 트래픽을 여러 컨테이너에 균등하게 분산시켜 서비스 안정성을 유지합니다. 플랫폼 독립성: 온-프레미스, 퍼블릭 클라우드, 하이브리드 환경 등 다양한 인프라에서 실행 가능합니다. 주요 컴포넌트 컨트롤 플레인 컴포넌트 클러스터의 전반적인 관리를 담당합니다.
...</p></div><footer class=entry-footer><span title='2024-11-11 15:44:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1162 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kubernetes" href=https://buenhyden.github.io/posts/devops/virtualization/containerization/orchestration/tools/kubernetes/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>