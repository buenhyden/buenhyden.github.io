<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CI/CD | hyunyoun's Blog</title>
<meta name=keywords content="Software-Development,Software-Maintenance,DevOps,CI-CD"><meta name=description content="기능적인 소프트웨어 제공 시 문제 발생 위험을 줄이고자 코드를 `지속적으로`테스트하고 `배포하는 전술`"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/devops/ci-and-cd/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/devops/ci-and-cd/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/devops/ci-and-cd/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/devops/ci-and-cd/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="CI/CD"><meta property="og:description" content="기능적인 소프트웨어 제공 시 문제 발생 위험을 줄이고자 코드를 `지속적으로`테스트하고 `배포하는 전술`"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="CI/CD"><meta name=twitter:description content="기능적인 소프트웨어 제공 시 문제 발생 위험을 줄이고자 코드를 `지속적으로`테스트하고 `배포하는 전술`"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"DevOps","item":"https://buenhyden.github.io/posts/devops/"},{"@type":"ListItem","position":3,"name":"CI/CD","item":"https://buenhyden.github.io/posts/devops/ci-and-cd/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/devops/>DevOps</a></div><h1>CI/CD</h1><div class=post-description>기능적인 소프트웨어 제공 시 문제 발생 위험을 줄이고자 코드를 <code>지속적으로</code>테스트하고 <code>배포하는 전술</code></div></header><div class=post-content><h2 id=cicd-continuous-integrationcontinuous-delivery>CI/CD (Continuous Integration/Continuous Delivery)<a hidden class=anchor aria-hidden=true href=#cicd-continuous-integrationcontinuous-delivery>#</a></h2><p>![CI/CD Pipeline](CICD_pipelines_work.png &ldquo;<a href=https://www.wallarm.com/what/what-is-ci-cd-concept-how-can-it-work>What is CI/CD: Meaning, Definition & Pipeline Concepts</a>_</p><h3 id=ci-continuous-integration-지속적-통합>CI (Continuous Integration, 지속적 통합)<a hidden class=anchor aria-hidden=true href=#ci-continuous-integration-지속적-통합>#</a></h3><p>개발자들이 개별적으로 작업한 코드를 주기적으로 공유 저장소에 통합하여, 자동화된 빌드와 테스트를 수행하는 프로세스.</p><p>![Continuous Integration (CI)](Continuous_Integration-CI.png &ldquo;<a href=https://www.wallarm.com/what/what-is-ci-cd-concept-how-can-it-work>https://www.wallarm.com/what/what-is-ci-cd-concept-how-can-it-work</a>_</p><h4 id=주요-구성-요소>주요 구성 요소<a hidden class=anchor aria-hidden=true href=#주요-구성-요소>#</a></h4><ul><li>공유 코드 저장소</li><li>자동화된 빌드 프로세스</li><li>자동화된 테스트 suite</li></ul><h5 id=cicontinuous-integration를-구현할-때-필요한-주요-도구>CI(Continuous Integration)를 구현할 때 필요한 주요 도구<a hidden class=anchor aria-hidden=true href=#cicontinuous-integration를-구현할-때-필요한-주요-도구>#</a></h5><ol><li><strong>버전 관리 시스템 (Version Control System)</strong><ul><li>Git, SVN, Mercurial 등</li><li>코드 변경 사항을 추적하고 관리</li></ul></li><li>CI 서버<ul><li>Jenkins, GitLab CI, CircleCI, Travis CI 등</li><li>자동화된 빌드와 테스트를 실행</li></ul></li><li><strong>빌드 도구</strong><ul><li>Maven, Gradle, Ant (Java)</li><li>npm, Webpack (Javascript)</li><li>MSBuild (.NET)</li></ul></li><li><strong>자동화된 테스트 프레임워크</strong><ul><li>JUnit, TestNG (Java)</li><li>Mocha, Jest (Javascript)</li><li>NUnit (.NET)</li><li>Selenium (웹 애플리케이션 테스트)</li></ul></li><li>코드 품질 분석 도구<ul><li>SonarQube, ESLint, Checkstyle</li><li>코드 품질 메트릭을 측정하고 보고.</li></ul></li><li>아티팩트 저장소<ul><li>Nexus, Artifactory</li><li>빌드 결과물을 저장하고 관리.</li></ul></li><li>컨테이너화 도구<ul><li>Docker, Kubernetes</li><li>일관된 환경에서 빌드와 테스트 실행</li></ul></li><li>알림 도구<ul><li>Slack, Email, MS Teams</li><li>빌드 결과를 팀원들에게 통지</li></ul></li><li>구성 관리 도구<ul><li>Ansible, Puppet, Chef</li><li>환경 설정을 자동화</li></ul></li><li>모니터링 도구<ul><li>Grafana, Prometheus</li><li>CI 파이프라인의 성능을 모니터링</li></ul></li></ol><h4 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h4><ul><li>버그를 조기에 발경하고 품질 향상</li><li>소프트웨어 품질 향상</li><li>개발 주기 단축</li></ul><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li>리스크 감소: 작은 변경사항을 자주 통합하여 큰 문제 예방</li><li>버그 조기 발견: 자동화된 테스트로 빠른 피드백 제공</li><li>팀 협업 개선: 투명한 개발 프로세스 촉진</li><li>제품 품질 향상: 지속적인 코드 리뷰와 테스트</li><li>배포 가능한 소프트웨어 상시 유지</li></ul><h4 id=구현-단계>구현 단계<a hidden class=anchor aria-hidden=true href=#구현-단계>#</a></h4><ol><li>공유 저장소 설정</li><li>자동화된 빌드 구축</li><li>자동화된 테스트 작성 및 통합</li><li>CI 서버 구성 (예: Jenkins, GitLab CI)</li><li>팀 작업 흐름 조정</li></ol><h4 id=모범-사례>모범 사례<a hidden class=anchor aria-hidden=true href=#모범-사례>#</a></h4><ul><li>작은 단위로 자주 커밋</li><li>모든 커밋에 대해 빌드 실행</li><li>빠른 빌드 유지 (10분 이내 권장)</li><li>테스트 환경을 프로덕션과 유사하게 유지</li><li>모든 테스트가 통과한 빌드만 허용.</li></ul><p><figure><img alt="Continuous Integration workflow" loading=lazy src=/img/Continuous_Integration_workflow.jpg><figcaption>Source: &lt;https://www.wallarm.com/what/what-is-continuous-integration-ci-explainedby-wallarm</figcaption></figure></p><h4 id=cicontinuous-integration를-구현할-때-가장-중요한-원칙>CI(Continuous Integration)를 구현할 때 가장 중요한 원칙<a hidden class=anchor aria-hidden=true href=#cicontinuous-integration를-구현할-때-가장-중요한-원칙>#</a></h4><ol><li>단일 소스 저장소 사용: 모든 코드와 관련 파일을 하나의 중앙 저장소에서 관리한다.</li><li><strong>자주 커밋하기</strong>: 개발자들이 작은 단위의 변경사항을 자주(하루에 여러 번) 메인 브랜치에 커밋한다.</li><li><strong>자동화된 빌드</strong>: 모든 코드 변경사항에 대해 자동으로 빌드를 수행한다.</li><li><strong>자동화된 테스트</strong>: 빌드 후 자동으로 테스트를 실행하여 변경사항의 품질을 검증한다.</li><li>빠른 피드백: 빌드와 테스트 결과를 신속하게 개발자에게 전달한다.</li><li>메인 브랜치 안정성 유지: 메인 브랜치는 항상 배포 가능한 상태를 유지해야 한다.</li><li>테스트 환경 일관성: 개발, 테스트, 운영 환경을 최대한 유사하게 유지한다.</li><li>가시성 확보: 빌드 상태와 테스트 결과를 팀 전체가 쉽게 확인할 수 있도록 한다.</li><li>지속적인 개선: CI 프로세스를 지속적으로 모니터링하고 개선한다.</li></ol><h4 id=cicontinuous-integration를-통한-코드-품질의-향상>CI(Continuous Integration)를 통한 코드 품질의 향상<a hidden class=anchor aria-hidden=true href=#cicontinuous-integration를-통한-코드-품질의-향상>#</a></h4><ol><li>빠른 버그 발견과 수정:<ul><li>자주 통합하고 테스트함으로써 버그를 조기에 발견하고 수정할 수 있다.</li><li>작은 변경사항 단위로 테스트하므로 문제의 원인을 쉽게 파악할 수 있다.</li></ul></li><li>일관된 코드 스타일 유지<ul><li>자동화된 코드 스타일 검사 도구를 CI 파이프라인에 통합하여 일관된 코딩 표준을 유지할 수 있다.</li></ul></li><li>자동화된 테스트 실행<ul><li>모든 코드 변경에 대해 자동으로 테스트를 실행하여 기능 회귀를 방지한다.</li><li>단위 테스트, 통합 테스트, 성능 테스트 등 다양한 테스트를 자동으로 수행한다.</li></ul></li><li>코드 품질 메트릭 모니터링<ul><li>코드 복잡도, 중복도, 테스트 커버리지 등의 메트릭을 지속적으로 모니터링하고 개선할 수 있다.</li></ul></li><li>코드 리뷰 프로세스 강화<ul><li>CI 시스템과 연동된 코드 리뷰 프로세스를 통해 품질 관리를 강화할 수 있다.</li></ul></li><li>지속적인 통합으로 인한 작은 변경 단위<ul><li>작은 단위의 변경사항을 자주 통합함으로써 대규모 통합에 따른 리스크를 줄일 수 있다.</li></ul></li><li>문서화 및 주석 품질 향상<ul><li>문서화와 주석 작성을 CI 프로세스의 일부로 포함시켜 코드의 가독성과 유지보수성을 향상시킬 수 있다.</li></ul></li><li>보안 취약점 조기 발견<ul><li>보안 검사 도구를 CI 파이프라인에 통합하여 보안 취약점을 조기에 발견하고 수정할 수 있다.</li></ul></li></ol><h4 id=cicontinuous-integration의-도입을-통한-테스트-프로세스의-변화>CI(Continuous Integration)의 도입을 통한 테스트 프로세스의 변화<a hidden class=anchor aria-hidden=true href=#cicontinuous-integration의-도입을-통한-테스트-프로세스의-변화>#</a></h4><ol><li>자동화의 증가<ul><li>수동 테스트에서 자동화된 테스트로 전환.</li><li>단위 테스트, 통합 테스트, 기능 테스트 등이 자동화으로 실행.</li></ul></li><li>빈번한 테스트 실행<ul><li>코드 변경이 있을 때마다 자동으로 테스트가 실행된다.</li><li>일일 또는 더 자주 전체 테스트 스위트가 실행된다.</li></ul></li><li>빠른 피드백<ul><li>개발자들이 코드 변경 후 즉시 테스트 결과를 받는다.</li><li>버그를 조기에 발견하고 수정할 수 있다.</li></ul></li><li>테스트 범위 확대<ul><li>더 많은 종류의 테스트를 포함할 수 있게 된다.</li><li>성능 테스트, 보안 테스트 등도 CI 파이프라인에 통합된다.</li></ul></li><li>테스트 환경 일관성<ul><li>모든 개발자와 CI 서버가 동일한 환경에서 테스트를 실행한다.</li><li>환경 차이로 인한 &ldquo;내 컴퓨터에서는 작동합니다"문제가 줄어든다.</li></ul></li><li>테스트 코드 품질 향상<ul><li>테스트 코드도 버전 관리되고 리뷰된다.</li><li>테스트의 유지보수성과 신뢰성이 향상된다.</li></ul></li><li>회귀 테스트 강화<ul><li>모든 변경사항에 대해 전체 테스트 스위트가 실행되어 회귀 오류를 빠르게 잡아낸다.</li></ul></li><li>테스트 메트릭스 추적<ul><li>테스트 커버리지, 성공률 등의 메트릭스를 지속적으로 모니터링한다.</li></ul></li><li>테스트 우선 개발 촉진<ul><li>TDD(Test-Driven Development) 같은 방법론 적용이 용이해진다.</li></ul></li></ol><h4 id=cicontinuous-integration를-도입할-때-발생할-수-있는-문제들>CI(Continuous Integration)를 도입할 때 발생할 수 있는 문제들<a hidden class=anchor aria-hidden=true href=#cicontinuous-integration를-도입할-때-발생할-수-있는-문제들>#</a></h4><ol><li>문화적 저항<ul><li>팀 구성원들이 새로운 프로세스와 도구 사용을 꺼려할 수 있다.</li><li>해결책: 점진적 도입, 교육 제공, CI의 이점 명확히 설명</li></ul></li><li>테스트 자동화 부족<ul><li>적절한 자동화 테스트 없이 CI를 도입하면 효과가 제한적.</li><li>해결책: 단위 테스트, 통합 테스트 등 자동화 테스트 구축에 투자</li></ul></li><li>빌드 시간 증가<ul><li>CI 프로세스로 인해 빌드 시간이 길어질 수 있다.</li><li>해결책: 병렬 빌드, 증분 빌드 등 최적화 기법 적용</li></ul></li><li>인프라 관리 복잡성<ul><li>CI 서버, 테스트 환경 등 추가 인프라 관리가 필요하다.</li><li>해결책: 클라우드 서비스 활용, 인프라 자동화 도구 사용</li></ul></li><li>보안 문제<ul><li>CI 파이프라인에 민감한 정보가 노출될 위험이 있다.</li><li>해결책: 보안 스캐닝 도구 통합, 비밀 정보 관리 시스템 사용</li></ul></li><li>과도한 알림<ul><li>빈번한 빌드 실패 알림으로 피로도가 증가할 수 있다.</li><li>해결책: 알림 정책 최적화, 중요 알림 필터링</li></ul></li><li>기존 프로젝트 통합 어려움<ul><li>레거시 시스템에 CI를 적용하기 어려울 수 있다.</li><li>해결책: 점진적 리팩토링, 모듈화 접근</li></ul></li><li>리소스 부족<ul><li>CI 구축과 유지에 필요한 시간과 인력이 부족할 수 있다.</li><li>해결책: 경영진의 지원 확보, 우선순위 조정</li></ul></li></ol><h3 id=cd-continuous-deliverydeployment-지속적-전달배포>CD (Continuous Delivery/Deployment, 지속적 전달/배포)<a hidden class=anchor aria-hidden=true href=#cd-continuous-deliverydeployment-지속적-전달배포>#</a></h3><p>![What is the distinction between CI/CD?](What_is_the_distinction_between_CICD.png &ldquo;<a href=https://www.wallarm.com/what/what-is-ci-cd-concept-how-can-it-work>https://www.wallarm.com/what/what-is-ci-cd-concept-how-can-it-work</a>_</p><p>CI(Continuous Integration)의 연장선상에 있는 소프트웨어 개발 방법론이다.<br>Continuous Delivery(지속적 전달)와 Continuous Deployment(지속적 배포) 2가지 의미로 사용된다.</p><h4 id=continuous-delivery지속적-전달>Continuous Delivery(지속적 전달)<a hidden class=anchor aria-hidden=true href=#continuous-delivery지속적-전달>#</a></h4><p>소프트웨어를 언제든지 안정적으로 출시할 수 있는 상태로 유지하는 방법론</p><ul><li>자동화된 테스트와 배포 준비 과정을 거치지만, 최종 프로덕션 배포는 수동으로 진행.</li></ul><h4 id=continuous-deployment지속적-배포>Continuous Deployment(지속적 배포)<a hidden class=anchor aria-hidden=true href=#continuous-deployment지속적-배포>#</a></h4><p>개발자의 변경사항이 자동으로 프로덕션 환경까지 배포되는 방법론</p><ul><li>전체 과정이 완전 자동화되어 있어 수동 개입 없이 프로덕션 배포가 이루어짐.</li></ul><h4 id=주요-구성-요소-1>주요 구성 요소<a hidden class=anchor aria-hidden=true href=#주요-구성-요소-1>#</a></h4><ul><li>자동화된 빌드 및 테스트 프로세스 (CI의 연장)</li><li>자동화된 배포 파이프라인</li><li>환경 설정 자동화</li><li>모니터링 및 로깅 시스템</li></ul><h4 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h4><ul><li>소프트웨어 배포 프로세스의 리스크 감소</li><li>더 빠른 시장 출시 (Time-to-Market) 달성</li><li>지속적인 사용자 피드백 수집 및 반영</li><li>개발팀의 생산성 향상</li></ul><h4 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h4><ul><li>배포 프로세스의 안정성 향상</li><li>사용자에게 더 빠른 가치 전달</li><li>개발자의 생산성 및 만족도 증가</li><li>실험과 혁신을 촉진하는 환경 조성</li><li>운영 부담 감소</li></ul><h4 id=구현-단계-1>구현 단계<a hidden class=anchor aria-hidden=true href=#구현-단계-1>#</a></h4><ol><li>CI 파이프라인 구축 (선행 조건)</li><li>자동화된 테스트 확장 (단위, 통합, 성능, 보안 등)</li><li>환경 설정 자동화 (Infrastructure as Code)</li><li>배포 파이프라인 구축</li><li>모니터링 및 피드백 시스템 통합</li></ol><h4 id=모범-사례-1>모범 사례<a hidden class=anchor aria-hidden=true href=#모범-사례-1>#</a></h4><ul><li>모든 환경에서 동일한 배포 프로세스 사용</li><li>배포를 작은 단위로 자주 수행</li><li>피처 플래그를 사용한 점진적 롤아웃</li><li>블루-그린 배포나 카나리 배포 등의 안전한 배포 전략 사용</li><li>철저한 모니터링 및 로깅 구현</li><li>빠른 롤백 메커니즘 준비</li></ul><h4 id=cd-continuous-deliverydeployment-지속적-전달배포를-구축할-때-가장-중요한-요소>CD (Continuous Delivery/Deployment, 지속적 전달/배포)를 구축할 때 가장 중요한 요소<a hidden class=anchor aria-hidden=true href=#cd-continuous-deliverydeployment-지속적-전달배포를-구축할-때-가장-중요한-요소>#</a></h4><ol><li>자동화<br>CD 파이프라인의 핵심<br>코드 통합부터 테스트, 배포까지 전 과정을 자동화하여 인적 오류를 최소화하고 일관성을 유지해야 한다.</li><li>보안<br>프로덕션 환경의 보안을 최우선으로 고려해야 한다.<br>접근 권한을 제한하고, 민감한 정보는 프로덕션 환경에만 저장하는 등의 보안 조치가 필요하다.</li><li>환경 분리<br>개발, 테스트, 프로덕션 등 각 환경을 분리하여 관리하는 것이 중요하다.</li><li>테스트 자동화<br>다양한 유형의 테스트(단위 테스트, 통합 테스트, 엔드-투-엔드 테스트 등)를 자동화하여 코드 품질을 지속적으로 검증해야 한다.</li><li>모니터링 및 피드백 루프<br>배포된 애플리케이션의 성능과 동작을 실시간으로 모니터링하고, 이를 통해 얻은 인사이트를 개발 프로세스에 반영하는 피드백 루프를 구축해야 한다.</li><li>협업 문화<br>개발자, 운영팀, QA 등 모든 팀 구성원이 CD 파이프라인의 성공에 책임감을 갖고 협업하는 문화를 조성해야 한다.</li><li>지속적인 개선<br>파이프라인의 성능을 정기적으로 모니터링하고 최적화하는 과정이 필요하다.</li><li>적절한 도구 선택<br>팀의 요구사항과 기존 인프라에 적합한 CI/CD 도구를 선택하는 것이 중요하다.</li><li>점진적 배포 전략<br>카나리 배포나 블루-그린 배포 등의 전략을 활용하여 리스크를 최소화하면서 새로운 기능을 안전하게 출시할 수 있는 방법을 고려해야 한다.</li><li>코드 리뷰 프로세스<br>코드 품질을 유지하고 잠재적인 문제를 조기에 발견하기 위해 철저한 코드 리뷰 프로세스를 구축해야 한다.</li></ol><h4 id=cd-continuous-deliverydeployment-지속적-전달배포를-구현할-때-주의해야-할-점>CD (Continuous Delivery/Deployment, 지속적 전달/배포)를 구현할 때 주의해야 할 점<a hidden class=anchor aria-hidden=true href=#cd-continuous-deliverydeployment-지속적-전달배포를-구현할-때-주의해야-할-점>#</a></h4><ol><li>충분한 테스트 자동화:<ul><li>포괄적인 자동화된 테스트 없이는 안전한 배포가 어렵다.</li><li>단위 테스트, 통합 테스트, 성능 테스트 등을 구현해야 한다.</li></ul></li><li>모니터링 및 알림 시스템 구축:<ul><li>배포 과정과 애플리케이션 성능을 실시간으로 모니터링해야 한다.</li><li>문제 발생 시 신속한 대응을 위한 알림 시스템이 필요합니다.</li></ul></li><li>롤백 전략 수립:<ul><li>문제 발생 시 신속하게 이전 버전으로 돌아갈 수 있는 전략이 필요하다.</li></ul></li><li>보안 통합:<ul><li>보안 검사를 CD 파이프라인에 통합하여 취약점을 조기에 발견해야 한다.</li></ul></li><li>인프라 자동화:<ul><li>인프라 구성을 코드로 관리하여 일관성과 재현성을 확보해야 한다.</li></ul></li><li>점진적 배포 전략 사용:<ul><li>블루-그린 배포, 카나리 릴리스 등의 전략을 활용하여 리스크를 최소화해야 한다.</li></ul></li><li>팀 간 협업 강화:<ul><li>개발, 운영, QA 팀 간의 원활한 소통과 협업이 필수적.</li></ul></li><li>지속적인 개선:<ul><li>파이프라인의 성능과 효율성을 지속적으로 모니터링하고 개선해야 한다.</li></ul></li><li>환경 일관성 유지:<ul><li>개발, 테스트, 운영 환경 간의 일관성을 유지해야 한다.</li></ul></li><li>비즈니스 의사결정 프로세스 통합:<ul><li>배포 결정에 비즈니스 요구사항을 반영할 수 있는 프로세스가 필요하다.</li></ul></li></ol><h4 id=cd-continuous-deliverydeployment-지속적-전달배포를-도입할-때-발생할-수-있는-문제들>CD (Continuous Delivery/Deployment, 지속적 전달/배포)를 도입할 때 발생할 수 있는 문제들<a hidden class=anchor aria-hidden=true href=#cd-continuous-deliverydeployment-지속적-전달배포를-도입할-때-발생할-수-있는-문제들>#</a></h4><ol><li>보안 문제<ul><li>빠른 배포로 인한 보안 취약점 발생 가능성 증가</li><li>민감한 데이터 노출 위험</li><li>안전하지 않은 코드나 서드파티 구성요소 사용</li><li>소스 코드 저장소나 빌드 도구에 대한 무단 접근</li></ul></li><li>확장성 문제<ul><li>증가하는 개발 팀과 프로젝트 규모에 대응하기 위한 인프라 확장 필요</li><li>리소스 활용 최적화의 어려움</li><li>성능 이슈 발생 가능성</li></ul></li><li>테스트 자동화 관련 문제<ul><li>테스트 케이스 유지보수의 어려움</li><li>효과적인 테스트 스크립트 작성의 복잡성</li><li>다른 도구들과의 통합 문제</li></ul></li><li>모니터링 문제<ul><li>복잡한 분산 시스템 모니터링의 어려움</li><li>여러 환경에 걸친 애플리케이션 모니터링의 복잡성</li></ul></li><li>문화와 프로세스 관련 문제<ul><li>조직 내 변화에 대한 저항</li><li>이해관계자들의 지지 부족</li><li>기존 프로세스와의 충돌</li></ul></li><li>릴리스 관리 문제<ul><li>배포 일정 관리의 어려움</li><li>롤백 절차 구현의 복잡성</li><li>이해관계자와의 원활한 소통 부족</li></ul></li><li>환경 관리 문제<ul><li>인프라 프로비저닝의 어려움</li><li>환경 간 설정 동기화 문제</li><li>데이터 무결성 보장의 어려움</li></ul></li><li>버전 관리 문제<ul><li>새로운 버전 업데이트로 인한 배포 프로세스 중단</li><li>자동 업데이트로 인한 생산 환경 문제 발생 가능성</li></ul></li><li>성능 저하 문제<ul><li>CD 프로세스가 수동 작업보다 느려질 수 있는 상황 발생</li></ul></li><li>타이트한 마감 기한과 릴리스 일정<ul><li>빠른 개발과 배포로 인한 코드 품질 저하 가능성</li><li>테스트와 품질 보증 과정의 축소로 인한 오류 증가 위험</li></ul></li></ol><h4 id=cd-continuous-deliverydeployment-지속적-전달배포를-구현할-때-주의해야-할-주요-단계>CD (Continuous Delivery/Deployment, 지속적 전달/배포)를 구현할 때 주의해야 할 주요 단계<a hidden class=anchor aria-hidden=true href=#cd-continuous-deliverydeployment-지속적-전달배포를-구현할-때-주의해야-할-주요-단계>#</a></h4><ol><li>보안 강화<ul><li>코드 저장소와 빌드 서버의 보안을 철저히 관리해야 한다.</li><li>민감한 데이터나 API 키가 노출되지 않도록 주의해야 한다.</li><li>취약점이 있는 의존성 라이브러리를 사용하지 않도록 주의해야 한다.</li></ul></li><li>자동화 테스트 구축<ul><li>단위 테스트, 통합 테스트 등 다양한 자동화된 테스트를 구현해야 한다.</li><li>테스트 커버리지를 높여 코드 품질을 유지해야 한다.</li></ul></li><li>환경 일관성 유지<ul><li>개발, 테스트, 프로덕션 환경을 일관되게 유지해야 한다.</li><li>환경 간 설정 차이로 인한 문제를 방지해야 한다.</li></ul></li><li>모니터링 및 로깅 구현<ul><li>배포된 애플리케이션의 성능과 안정성을 실시간으로 모니터링해야 한다.</li><li>문제 발생 시 빠르게 대응할 수 있도록 로깅 시스템을 구축해야 한다.</li></ul></li><li>롤백 전략 수립<ul><li>배포 실패 시 신속하게 이전 버전으로 롤백할 수 있는 전략을 마련해야 한다.</li></ul></li><li>점진적 배포 전략 적용<ul><li>카나리 배포나 블루-그린 배포 등의 전략을 활용하여 리스크를 최소화해야 한다.</li></ul></li><li>인프라 확장성 고려<br>프로젝트 규모가 커질 때를 대비해 확장 가능한 인프라를 설계해야 한다.</li><li>팀 간 커뮤니케이션 강화<ul><li>개발, 운영, QA 팀 간의 원활한 소통을 위한 체계를 구축해야 한다.</li></ul></li><li>문서화<br>CD 파이프라인의 설정과 사용 방법을 명확히 문서화하여 팀원들이 쉽게 이해하고 사용할 수 있도록 해야 한다.</li><li>지속적인 개선<ul><li>파이프라인의 성능을 정기적으로 모니터링하고 최적화하는 과정이 필요하다.</li></ul></li></ol><h3 id=cicontinuous-integration-지속적-통합와-cd-continuous-deliverydeployment-지속적-전달배포-파이프라인의-주요-차이점>CI(Continuous Integration, 지속적 통합)와 CD (Continuous Delivery/Deployment, 지속적 전달/배포) 파이프라인의 주요 차이점<a hidden class=anchor aria-hidden=true href=#cicontinuous-integration-지속적-통합와-cd-continuous-deliverydeployment-지속적-전달배포-파이프라인의-주요-차이점>#</a></h3><p>CI 파이프라인은 코드 통합과 검증에 중점을 두는 반면, CD 파이프라인은 검증된 코드를 실제 운영 환경에 안정적으로 배포하는 데 초점을 맞춘다.</p><ol><li>목적<ul><li>CI (Continuous Integration) 파이프라인:<br>코드 변경사항을 지속적으로 통합하고 테스트하는 것이 주 목적.<br>개발자들이 코드를 자주 병합하고 빌드 및 테스트를 자동화하여 문제를 조기에 발견하는 데 중점을 둔다.</li><li>CD (Continuous Delivery/Deployment) 파이프라인:<br>검증된 코드를 자동으로 릴리즈하고 프로덕션 환경에 배포하는 것이 주 목적.<br>CI의 결과물을 받아 실제 운영 환경에 제공하는 과정을 자동화한다.</li></ul></li><li>프로세스 범위<ul><li>CI 파이프라인: 코드 통합, 빌드, 테스트 단계까지 포함</li><li>CD 파이프라인: CI 단계 이후의 릴리즈, 배포, 모니터링 단계까지 포함</li></ul></li><li>자동화 수준<ul><li>CI 파이프라인: 코드 통합부터 테스트까지 자동화</li><li>CD 파이프라인: CI 단계에 더해 배포 과정까지 자동화. Continuous Delivery는 수동 승인 후 배포, Continuous Deployment는 완전 자동 배포를 의미.</li></ul></li><li>주요 활동<ul><li>CI 파이프라인: 코드 병합, 빌드, 단위 테스트, 통합 테스트 등</li><li>CD 파이프라인: 스테이징 환경 배포, 승인 프로세스, 프로덕션 배포, 모니터링 등</li></ul></li><li>목표<ul><li>CI 파이프라인: 코드 품질 향상, 버그 조기 발견</li><li>CD 파이프라인: 빠른 릴리즈 주기, 안정적인 배포, 사용자 피드백 신속 반영</li></ul></li></ol><h3 id=cicd-파이프라인의-주요-단계별로-수행되는-작업>CI/CD 파이프라인의 주요 단계별로 수행되는 작업<a hidden class=anchor aria-hidden=true href=#cicd-파이프라인의-주요-단계별로-수행되는-작업>#</a></h3><p><figure><img alt="Stages of a CI/CD pipeline" loading=lazy src=/img/cicd-pipeline-introduction-1024x422-1.jpg><figcaption>https://semaphoreci.com/blog/cicd-pipeline</figcaption></figure></p><ol><li>소스 코드 관리 (Source)<ul><li>개발자가 코드를 작성하고 버전 관리 시스템(예: Git)에 커밋.</li><li>코드 변경사항을 추적하고 기록.</li><li>팀 간 협업을 위한 코드 공유가 이루어진다.</li></ul></li><li>빌드 (Build)<ul><li>소스 코드를 컴파일하고 실행 가능한 아티팩트를 생성한다.</li><li>의존성을 해결하고 필요한 라이브러리를 포함시킨다.</li><li>빌드 과정에서 발생하는 오류를 확인한다.</li></ul></li><li>단위 테스트 (Unit Test)<ul><li>개별 코드 단위에 대한 자동화된 테스트를 실행한다.</li><li>새로운 코드 변경이 기존 기능을 손상시키지 않았는지 확인한다.</li><li>테스트 커버리지를 측정하고 보고한다.</li></ul></li><li>코드 품질 분석 (Code Quality Analysis)<ul><li>정적 코드 분석 도구를 사용하여 코드 품질을 검사한다.</li><li>보안 취약점, 코딩 표준 위반 등을 식별한다.</li><li>코드 중복, 복잡도 등의 메트릭을 측정한다.</li></ul></li><li>통합 테스트 (Integration Test)<ul><li>여러 컴포넌트 간의 상호작용을 테스트한다.</li><li>시스템 전체의 기능을 검증한다.</li><li>외부 의존성과의 통합을 확인한다.</li></ul></li><li>패키징 (Packaging)<ul><li>애플리케이션과 필요한 모든 구성 요소를 배포 가능한 형태로 패키징한다.</li><li>컨테이너 이미지 생성 등의 작업이 포함될 수 있다.</li></ul></li><li>스테이징 배포 (Staging Deployment)<ul><li>프로덕션과 유사한 환경에 애플리케이션을 배포한다.</li><li>성능 테스트, 사용자 수용 테스트 등을 수행한다.</li><li>최종 검증을 위한 환경을 제공한다.</li></ul></li><li>승인 (Approval)<ul><li>프로덕션 배포 전 필요한 승인 절차를 거친다.</li><li>자동 또는 수동 승인 프로세스가 포함될 수 있다.</li></ul></li><li>프로덕션 배포 (Production Deployment)<ul><li>검증된 애플리케이션을 실제 운영 환경에 배포한다.</li><li>무중단 배포, 롤백 전략 등을 적용할 수 있다.</li></ul></li><li>모니터링 및 피드백 (Monitoring and Feedback)<ul><li>배포된 애플리케이션의 성능과 안정성을 모니터링한다.</li><li>사용자 피드백을 수집하고 분석한다.</li><li>필요한 경우 빠른 대응과 개선을 위한 정보를 제공한다.</li></ul></li></ol><h3 id=cicd-파이프라인의-build-단계에서-수행되는-작업>CI/CD 파이프라인의 Build 단계에서 수행되는 작업<a hidden class=anchor aria-hidden=true href=#cicd-파이프라인의-build-단계에서-수행되는-작업>#</a></h3><ol><li>코드 컴파일<ul><li>소스 코드를 실행 가능한 형태로 변환</li><li>컴파일 언어의 경우 바이너리 파일을 생성하고, 인터프리터 언어의 경우 필요한 의존성과 도구를 확인</li></ul></li><li>의존성 해결<ul><li>프로젝트에 필요한 라이브러리와 패키지를 다운로드하고 설치</li></ul></li><li>린팅(Linting)<ul><li>코드의 문법적, 스타일적 오류를 검사</li></ul></li><li>정적 코드 분석<ul><li>자동화된 도구를 사용하여 코드 품질을 검사</li><li>보안 취약점, 코딩 표준 위반 등을 식별</li></ul></li><li>아티팩트 생성<ul><li>배포 가능한 형태의 패키지를 생성</li><li>이는 바이너리 파일, 코드 압축 파일, 설치 가능한 패키지, 웹사이트, 컨테이너 이미지 등이 될 수 있다</li></ul></li><li>빌드 환경 설정<ul><li>필요한 도구와 언어 버전을 설정</li><li>예: Java 버전 설정, Maven 또는 Gradle 사용 등</li></ul></li><li>캐싱<ul><li>다운로드한 라이브러리, 중간 파일, 컴파일된 파일 등을 저장하여 향후 빌드 속도를 개선</li></ul></li><li>빌드 결과 검증<ul><li>빌드 과정이 성공적으로 완료되었는지 확인</li><li>실패 시 개발 팀에 알림을 보낸다.</li></ul></li></ol><h3 id=cicd-파이프라인의-test-단계에-포함되는-테스트>CI/CD 파이프라인의 Test 단계에 포함되는 테스트<a hidden class=anchor aria-hidden=true href=#cicd-파이프라인의-test-단계에-포함되는-테스트>#</a></h3><ol><li>단위 테스트 (Unit Testing)<ul><li>개별 코드 단위나 함수의 정확성을 검증.</li><li>빠르고 가벼우며, 주로 개발자가 작성하고 실행.</li><li>높은 테스트 커버리지가 바람직.</li><li>도구: JUnit (Java), NUnit (.NET), pytest (Python) 등</li></ul></li><li>통합 테스트 (Integration Testing)<ul><li>애플리케이션의 다른 모듈이나 서비스 간 상호작용을 검증.</li><li>데이터베이스, API, 외부 시스템과의 상호작용을 테스트.</li><li>단위 테스트보다 복잡하고 시간이 더 걸린다.</li><li>도구: TestNG (Java), pytest (Python), JUnit (Java) 등</li></ul></li><li>기능 테스트 (Functional Testing)<ul><li>애플리케이션의 기능적 요구사항을 평가.</li><li>사용자 시나리오와 워크플로우에 초점을 맞춘다.</li><li>사용자 상호작용을 시뮬레이션하는 도구를 사용하여 자동화.</li><li>도구: Selenium, Cypress, QTP/UFT 등</li></ul></li><li>회귀 테스트 (Regression Testing)<ul><li>새로운 코드 변경이 기존 기능에 부정적인 영향을 미치지 않는지 확인.</li><li>기존 테스트를 재실행하여 이전에 작동하던 기능을 검증.</li></ul></li><li>성능 테스트 (Performance Testing)<ul><li>다양한 조건에서 애플리케이션의 성능을 측정.</li><li>부하 테스트, 스트레스 테스트, 확장성 테스트 등이 포함.</li><li>성능 병목 현상을 식별하고 예상 트래픽을 처리할 수 있는지 확인.</li><li>도구: JMeter, LoadRunner, Gatling 등</li></ul></li><li>보안 테스트 (Security Testing)<ul><li>취약점을 식별하고 잠재적인 공격에 대한 애플리케이션의 견고성을 확인.</li><li>자동화된 보안 스캐닝, 침투 테스트, 취약점 평가 등이 포함.</li><li>도구: OWASP ZAP, SonarQube (보안 규칙) 등</li></ul></li><li>사용자 수용 테스트 (User Acceptance Testing)<ul><li>실제 사용자 시나리오를 기반으로 애플리케이션의 기능과 사용성을 검증.</li><li>일반적으로 파이프라인의 후반부에 수행.</li></ul></li></ol><h4 id=기능-테스트를-자동화할-때-주의해야-할-주요-사항>기능 테스트를 자동화할 때 주의해야 할 주요 사항<a hidden class=anchor aria-hidden=true href=#기능-테스트를-자동화할-때-주의해야-할-주요-사항>#</a></h4><ol><li>명확한 자동화 전략 수립<ul><li>자동화의 목적과 범위를 명확히 정의</li><li>어떤 종류의 테스트를 자동화할지 결정</li></ul></li><li>우선순위 설정<ul><li>자주 실행되고 영향력이 큰 테스트를 우선적으로 자동화</li><li>비용 대비 효과를 고려하여 자동화할 테스트를 선별</li></ul></li><li>적절한 도구 선택<ul><li>프로젝트 요구사항에 맞는 자동화 도구를 선택</li><li>팀의 기술 스택과 호환되는 도구를 고려</li></ul></li><li>모듈화 및 재사용 가능한 테스트 스크립트 설계<ul><li>유지보수가 용이하고 재사용 가능한 테스트 스크립트를 작성</li></ul></li><li>테스트 유지보수 고려<ul><li>자동화된 테스트의 지속적인 유지보수 계획을 수립</li><li>애플리케이션 변경에 따라 테스트 스크립트를 업데이트.</li></ul></li><li>지속적 통합(CI) 구현<ul><li>자동화된 테스트를 CI/CD 파이프라인에 통합</li></ul></li><li>데이터 주도 테스팅 구현<ul><li>다양한 데이터 세트로 테스트를 실행할 수 있도록 설계</li></ul></li><li>병렬 테스팅 활용<ul><li>테스트 실행 시간을 단축하기 위해 병렬 테스팅을 구현</li></ul></li><li>크로스 브라우저 및 크로스 플랫폼 테스팅 보장<ul><li>다양한 브라우저와 플랫폼에서 일관된 동작을 확인</li></ul></li><li>균형 잡힌 테스트 자동화 피라미드 유지<ul><li>단위 테스트, 통합 테스트, E2E 테스트의 적절한 비율을 유지</li></ul></li><li>수동 테스트와의 균형<ul><li>자동화 테스트와 수동 테스트를 적절히 조합하여 사용</li></ul></li></ol><h4 id=성능-테스트를-수행할-때-고려해야할-요소>성능 테스트를 수행할 때 고려해야할 요소<a hidden class=anchor aria-hidden=true href=#성능-테스트를-수행할-때-고려해야할-요소>#</a></h4><ol><li>테스트 목표 및 성능 기준 설정<ul><li>명확한 성능 목표와 허용 가능한 기준을 정의.</li><li>응답 시간, 처리량, 리소스 사용률 등의 주요 성능 지표를 설정.</li></ul></li><li>테스트 환경 구성<ul><li>실제 운영 환경과 최대한 유사한 테스트 환경을 구축.</li><li>하드웨어, 소프트웨어, 네트워크 구성 등을 실제 환경과 일치.</li></ul></li><li>테스트 시나리오 및 데이터 준비<ul><li>실제 사용자 패턴을 반영한 다양한 테스트 시나리오를 설계.</li><li>현실적인 테스트 데이터를 준비.</li></ul></li><li>부하 모델 설계<ul><li>예상 사용자 수, 동시 접속자 수, 트랜잭션 볼륨 등을 고려한 부하 모델을 설계.</li></ul></li><li>모니터링 계획 수립<ul><li>CPU, 메모리, 디스크 I/O, 네트워크 등 시스템 리소스 사용률을 모니터링.</li><li>애플리케이션 성능 지표를 실시간으로 모니터링할 수 있는 도구를 준비.</li></ul></li><li>테스트 도구 선정<ul><li>목적에 맞는 적절한 성능 테스트 도구를 선택.</li><li>도구의 기능, 확장성, 사용 편의성 등을 고려.</li></ul></li><li>점진적 부하 증가<ul><li>낮은 부하에서 시작하여 점진적으로 부하를 증가시키며 테스트를 수행.</li></ul></li><li>다양한 테스트 유형 고려<ul><li>부하 테스트, 스트레스 테스트, 내구성 테스트 등 다양한 유형의 테스트를 수행.</li></ul></li><li>결과 분석 및 보고<ul><li>테스트 결과를 철저히 분석하고 문제점을 식별.</li><li>명확하고 이해하기 쉬운 보고서를 작성.</li></ul></li><li>지속적인 성능 모니터링<ul><li>테스트 후에도 지속적으로 성능을 모니터링하고 최적화.</li></ul></li></ol><h4 id=성능-테스트-시나리오를-다양하게-설정하는-방법>성능 테스트 시나리오를 다양하게 설정하는 방법<a hidden class=anchor aria-hidden=true href=#성능-테스트-시나리오를-다양하게-설정하는-방법>#</a></h4><ol><li>실제 사용자 행동 분석<ul><li>실제 사용자의 행동 패턴을 분석하여 시나리오에 반영.</li><li>가장 자주 사용되는 기능과 사용자 경로를 파악하여 핵심 시나리오를 구성.</li></ul></li><li>다양한 사용자 유형 고려<ul><li>신규 사용자, 기존 사용자, 로그인/비로그인 사용자 등 다양한 유형의 사용자 행동을 시나리오에 포함.</li></ul></li><li>부하 수준 변화<ul><li>정상 부하, 최대 부하, 스트레스 수준 등 다양한 부하 조건을 시나리오에 포함.</li><li>점진적 부하 증가 시나리오를 통해 시스템의 성능 한계를 파악합니다.</li></ul></li><li>시간대별 트래픽 패턴 반영<ul><li>피크 시간대, 평상시, 특정 이벤트 기간 등 시간대별 트래픽 패턴을 시나리오에 반영.</li></ul></li><li>다양한 데이터 세트 사용<ul><li>실제 데이터와 유사한 다양한 테스트 데이터를 준비하여 시나리오에 적용.</li><li>데이터의 크기와 복잡성을 변화시켜 다양한 조건을 테스트.</li></ul></li><li>예외 상황 및 에러 처리 포함<ul><li>시스템 오류, 네트워크 지연, 데이터베이스 락 등 예외 상황을 시나리오에 포함.</li></ul></li><li>동시 사용자 수 변화<ul><li>동시 접속자 수를 다양하게 설정하여 시스템의 확장성을 테스트.</li></ul></li><li>복합 시나리오 구성<ul><li>여러 기능을 연계한 복합적인 시나리오를 구성하여 실제 사용 환경을 모방.</li></ul></li><li>장기 실행 시나리오<ul><li>시스템의 장기적인 안정성을 테스트하기 위한 장시간 실행 시나리오를 포함.</li></ul></li><li>지역별 접속 시뮬레이션<ul><li>다양한 지역에서의 접속을 시뮬레이션하여 글로벌 서비스의 성능을 테스트.</li></ul></li></ol><h4 id=성능-테스트-결과를-효과적으로-피드백하는-방법>성능 테스트 결과를 효과적으로 피드백하는 방법<a hidden class=anchor aria-hidden=true href=#성능-테스트-결과를-효과적으로-피드백하는-방법>#</a></h4><ol><li>명확하고 이해하기 쉬운 형식 선택<ul><li>그래프, 차트, 표 등을 활용하여 데이터를 시각화.</li><li>핵심 정보를 한눈에 파악할 수 있는 대시보드 형태의 보고서를 작성.</li></ul></li><li>관련 핵심 성능 지표(KPI) 포함<ul><li>총 테스트 케이스 수, 실행된 케이스 수, 통과/실패 케이스 수 등의 기본 지표를 포함.</li><li>응답 시간, 리소스 사용률, 부하 및 스트레스 지표 등 성능 관련 핵심 지표를 제시.</li></ul></li><li>대상 독자를 고려한 보고서 작성<ul><li>경영진, 개발자, QA 팀 등 각 대상에 맞는 정보와 상세 수준을 제공.</li><li>기술적 용어는 필요한 경우에만 사용하고, 사용 시 설명을 덧붙인다.</li></ul></li><li>객관적이고 편견 없는 보고<ul><li>정확한 수치와 데이터를 제시하고, 추정이나 가정을 배제.</li><li>&ldquo;우수함&rdquo;, &ldquo;나쁨&rdquo; 등의 주관적 표현을 피하고 실제 결과를 설명.</li></ul></li><li>실행 가능한 인사이트와 권장사항 제시<ul><li>발견된 문제점과 그 심각도를 명확히 설명.</li><li>데이터에 기반한 개선 권장사항을 제시.</li></ul></li><li>요약 및 세부 정보의 균형<ul><li>주요 발견사항과 지표를 포함한 간결한 요약을 제공.</li><li>필요한 경우 상세한 기술적 정보를 첨부합니다.</li></ul></li><li>상호작용적이고 협력적인 접근<ul><li>보고서 설계 단계에서 이해관계자들의 의견을 수렴.</li><li>결과에 대해 토론하고 질문에 답할 수 있는 기회를 제공.</li></ul></li><li>비즈니스 목표와의 연계<ul><li>테스트 결과가 비즈니스 목표에 어떤 영향을 미치는지 설명.</li></ul></li><li>후속 조치 계획 수립<ul><li>발견된 문제점에 대한 구체적인 개선 계획을 제시.</li><li>향후 테스트 계획에 대한 제안을 포함.</li></ul></li></ol><h4 id=성능-테스트에서-리소스-관리>성능 테스트에서 리소스 관리<a hidden class=anchor aria-hidden=true href=#성능-테스트에서-리소스-관리>#</a></h4><ol><li>리소스 사용량 모니터링<ul><li>CPU, 메모리, 네트워크 대역폭, 저장 공간 등 주요 시스템 리소스의 사용량을 지속적으로 모니터링</li><li>모니터링 소프트웨어, 프로파일링 도구, 성능 카운터 등을 활용하여 리소스 사용량을 추적</li></ul></li><li>병목 현상 식별 및 최적화<ul><li>리소스 사용량이 높은 영역을 식별하고 최적화</li><li>코드 최적화, 캐싱, 불필요한 데이터베이스 쿼리 감소 등의 기법을 적용</li></ul></li><li>현실적인 시나리오 사용<ul><li>실제 사용자 행동과 워크로드 패턴을 정확히 시뮬레이션하는 시나리오를 사용</li><li>이를 통해 실제 환경에서의 성능 문제를 식별하고 리소스 활용을 최적화</li></ul></li><li>가상화 기술 활용<ul><li>단일 물리적 머신에서 여러 테스트 환경을 생성하여 리소스 활용도를 극대화하고 하드웨어 비용을 절감</li></ul></li><li>지속적인 모니터링 및 테스트<ul><li>정기적인 성능 테스트를 통해 시간이 지남에 따라 리소스 사용량을 최적화</li><li>지속적인 모니터링을 통해 잠재적인 성능 문제를 조기에 발견하고 해결</li></ul></li><li>리소스 활용도 분석 및 보고<ul><li>리소스 관리 분석 및 보고를 통해 리소스 활용도에 대한 귀중한 통찰력을 얻는다.</li><li>이 정보를 바탕으로 리소스 활용도 개선에 대한 정보에 기반한 결정을 내린다.</li></ul></li><li>자동화 적용<ul><li>자동화 기능을 활용하여 리소스 활용도를 최적화하고 관리 작업을 줄인다.</li></ul></li><li>클라우드 기반 테스트 서비스 고려<ul><li>필요에 따라 리소스를 동적으로 확장하거나 축소할 수 있는 클라우드 기반 테스트 서비스의 사용을 고려한다.</li></ul></li></ol><h4 id=성능-테스트에서-모니터링-도구를-선택할-때-고려해야-할-요소>성능 테스트에서 모니터링 도구를 선택할 때 고려해야 할 요소<a hidden class=anchor aria-hidden=true href=#성능-테스트에서-모니터링-도구를-선택할-때-고려해야-할-요소>#</a></h4><ol><li>확장성 (Scalability)<ul><li>증가하는 부하와 데이터 양을 처리할 수 있는 능력</li><li>대규모 시스템과 분산 환경을 지원하는지 확인</li></ul></li><li>실시간 모니터링 기능<ul><li>성능 데이터를 실시간으로 수집하고 분석하는 능력</li><li>즉각적인 문제 감지와 대응을 위한 실시간 알림 기능</li></ul></li><li>종합적인 메트릭 수집<ul><li>CPU, 메모리, 디스크 I/O, 네트워크 등 다양한 시스템 리소스 모니터링</li><li>응답 시간, 처리량, 오류율 등 애플리케이션 성능 지표 수집</li></ul></li><li>데이터 분석 및 시각화 기능<ul><li>수집된 데이터를 의미 있는 인사이트로 변환하는 분석 도구</li><li>직관적인 대시보드와 보고서 생성 기능</li></ul></li><li>통합 및 호환성<ul><li>기존 인프라 및 도구들과의 통합 용이성</li><li>다양한 플랫폼과 기술 스택 지원</li></ul></li><li>사용 편의성<ul><li>직관적인 사용자 인터페이스</li><li>설정 및 관리의 용이성</li></ul></li><li>비용 효율성<ul><li>라이선스 비용 및 총소유비용(TCO) 고려</li><li>필요한 기능과 예산의 균형</li></ul></li><li>보안 및 규정 준수<ul><li>데이터 암호화 및 접근 제어 기능</li><li>관련 규정 및 표준 준수 여부</li></ul></li><li>커스터마이징 및 확장성<ul><li>사용자 정의 메트릭 및 대시보드 생성 가능성</li><li>API 및 플러그인을 통한 기능 확장 옵션</li></ul></li><li>벤더 지원 및 커뮤니티<ul><li>기술 지원의 품질 및 대응성</li><li>활발한 사용자 커뮤니티 및 문서화 수준</li></ul></li><li>장기 데이터 보존 및 분석<ul><li>과거 성능 데이터의 장기 보관 능력</li><li>트렌드 분석 및 용량 계획을 위한 기능</li></ul></li></ol><h3 id=cicd-파이프라인의-모니터링-단계에서-수집되는-정보들>CI/CD 파이프라인의 모니터링 단계에서 수집되는 정보들<a hidden class=anchor aria-hidden=true href=#cicd-파이프라인의-모니터링-단계에서-수집되는-정보들>#</a></h3><ol><li>배포 빈도 (Deployment Frequency)<ul><li>일/주 단위로 성공적으로 배포된 횟수를 측정.</li><li>이를 통해 개발 팀의 생산성과 파이프라인의 효율성을 파악.</li></ul></li><li>배포 시간 (Deployment Time)<ul><li>각 배포 작업의 실행 시간을 측정.</li><li>개발/테스트 환경에서 프로덕션 환경으로 릴리스를 이동시키는 데 걸리는 시간을 파악.</li></ul></li><li>변경 리드 타임 (Change Lead Time)<ul><li>코드 변경 결정부터 실제 구현 및 배포까지 걸리는 시간을 측정.</li><li>팀의 개발 및 배포 속도를 나타내는 중요한 지표.</li></ul></li><li>평균 복구 시간 (Mean Time to Recovery, MTTR)<ul><li>프로덕션 환경에서 문제 발생 시 수정 사항을 배포하는 데 걸리는 시간을 측정.</li><li>팀의 문제 해결 능력과 파이프라인의 효율성을 나타낸다.</li></ul></li><li>변경 실패율 (Change Failure Rate)<ul><li>배포 시도 중 실패한 비율을 측정.</li><li>테스트나 기타 이유로 성공적으로 배포되지 못한 변경 사항의 비율.</li></ul></li><li>진행 중인 작업량 (Work in Progress)<ul><li>특정 시점에 파이프라인에서 진행 중인 코드 또는 구성 변경 사항의 수를 측정.</li></ul></li><li>빌드 시간 및 테스트 실행 시간<ul><li>각 빌드와 테스트 단계에 소요되는 시간을 측정.</li></ul></li><li>테스트 커버리지 및 성공률<ul><li>자동화된 테스트의 코드 커버리지와 성공/실패율을 측정.</li></ul></li><li>리소스 사용량<ul><li>CPU, 메모리, 디스크 I/O 등 파이프라인 실행에 사용되는 리소스를 모니터링.</li></ul></li><li>오류 및 경고 로그<ul><li>파이프라인 실행 중 발생하는 오류와 경고 메시지를 수집.</li></ul></li></ol><h3 id=cicd-파이프라인의-각-단계별-사용되는-도구>CI/CD 파이프라인의 각 단계별 사용되는 도구<a hidden class=anchor aria-hidden=true href=#cicd-파이프라인의-각-단계별-사용되는-도구>#</a></h3><ol><li>소스 코드 관리 (Source Code Management)<ul><li>Git, GitHub, GitLab, Bitbucket</li><li>SVN (Subversion)</li></ul></li><li>빌드 (Build)<ul><li>Maven, Gradle (Java)</li><li>npm, Webpack (JavaScript)</li><li>MSBuild (.NET)</li><li>Docker (컨테이너화)</li></ul></li><li>단위 테스트 (Unit Testing)<ul><li>JUnit, TestNG (Java)</li><li>Jest, Mocha (JavaScript)</li><li>NUnit (.NET)</li><li>PyTest (Python)</li></ul></li><li>코드 품질 분석 (Code Quality Analysis)<ul><li>SonarQube</li><li>ESLint (JavaScript)</li><li>Checkstyle (Java)</li><li>PMD</li></ul></li><li>통합 테스트 (Integration Testing)<ul><li>Selenium</li><li>Postman</li><li>REST Assured (API 테스팅)</li></ul></li><li>패키징 (Packaging)<ul><li>Docker</li><li>Helm (Kubernetes 패키징)</li><li>Maven, Gradle (Java 애플리케이션 패키징)</li></ul></li><li>배포 (Deployment)<ul><li>Kubernetes</li><li>Docker Swarm</li><li>AWS Elastic Beanstalk</li><li>Heroku</li><li>Ansible, Puppet, Chef (구성 관리)</li></ul></li><li>모니터링 (Monitoring)<ul><li>Prometheus</li><li>Grafana</li><li>ELK Stack (Elasticsearch, Logstash, Kibana)</li><li>New Relic</li></ul></li><li>CI/CD 오케스트레이션 도구<ul><li>Jenkins</li><li>GitLab CI/CD</li><li>CircleCI</li><li>Travis CI</li><li>Azure DevOps</li><li>AWS CodePipeline</li></ul></li><li>보안 검사 (Security Scanning)<ul><li>OWASP ZAP</li><li>SonarQube (보안 규칙)</li><li>Snyk</li></ul></li><li>성능 테스트 (Performance Testing)<ul><li>Apache JMeter</li><li>Gatling</li><li>LoadRunner</li></ul></li></ol><h3 id=cicd-구현을-위한-자동화-도구들>CI/CD 구현을 위한 자동화 도구들<a hidden class=anchor aria-hidden=true href=#cicd-구현을-위한-자동화-도구들>#</a></h3><ol><li>Jenkins<ul><li>가장 널리 사용되는 오픈소스 CI 도구</li><li>다양한 플러그인 지원으로 확장성이 뛰어남</li><li>커스터마이징이 용이하고 다양한 환경에서 사용 가능.</li></ul></li><li>GitLab CI/CD<ul><li>GitLab과 통합된 CI/CD 솔루션</li><li>설정이 간단하고 GitLab 저장소와의 연동이 쉬움.</li><li>컨테이너 기반 실행 환경 제공.</li></ul></li><li>CircleCI<ul><li>클라우드 기반의 CI/CD 서비스</li><li>빠른 빌드 속도와 병령 실행 지원</li><li>GitHub, Bitbucket과의 쉬운 통합</li></ul></li><li>Travis CI<ul><li>오픈소스 프로젝트에 인기 있는 CI 도구</li><li>GitHub와의 연동이 쉽고 설정이 간단함.</li><li>다양한 언어와 환경 지원</li></ul></li><li>TeamCity<ul><li>JetBrains에서 개발한 CI/CD 서버</li><li>사용자 친화적인 인터페이스</li><li>지능형 빌드 구성 기능 제공</li></ul></li><li>Bamboo<ul><li>Atlassian 제품군과 잘 통합되는 CI/CD 도구</li><li>자체 호스팅 및 클라우드 옵션 제공</li><li>복잡한 빌드 및 배포 시나리오 지원</li></ul></li><li>GitHub Actions<ul><li>GitHub와 긴밀히 통합된 CI/CD 도구</li><li>YAML 기반의 워크플로우 정의가 간편함.</li><li>GitHub 생태계 내에서 쉽게 사용 가능</li></ul></li><li>Azure DevOps<ul><li>Microsoft의 종합적인 DevOps 플랫폼으로, CI/CD 기능을 포함.</li><li>Azure 클라우드 서비스와의 긴밀한 통합이 장점.</li></ul></li><li>Codefresh<ul><li>Kubernetes와 컨테이너 기반 애플리케이션에 최적화된 현대적인 CI/CD 플랫폼.</li><li>GitOps 기반의 배포 전략을 지원.</li></ul></li><li>Semaphore<ul><li>빠른 성능을 자랑하는 CI/CD 플랫폼.</li><li>Docker, Kubernetes, iOS 지원 등 다양한 기능을 제공.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=cicd>CI/CD<a hidden class=anchor aria-hidden=true href=#cicd>#</a></h3><p><a href=https://seosh817.tistory.com/104>SH&rsquo;s Devlog</a><br><a href="https://devocean.sk.com/search/techBoardDetail.do?ID=164937&amp;boardType=">Kubernetes 기반의 어플리케이션 배포 시스템 구축 방법</a><br><a href=https://blog.banksalad.com/tech/how-we-have-built-alice/>폐쇄망 환경의 배포 시스템 개발기</a><br><a href=https://aws.amazon.com/ko/devops/continuous-integration/>AWS Amazone CI</a><br><a href=https://seosh817.tistory.com/104>SH&rsquo;s Devlog</a><br><a href=https://yozm.wishket.com/magazine/detail/2010/>깃옵스(GitOps)를 여행하려는 입문자를 위한 안내서</a><br><a href=https://yozm.wishket.com/magazine/detail/2197/>깃허브 액션으로 CI/CD 구현하기</a><br><a href=https://yozm.wishket.com/magazine/detail/2184/>CI/CD 개념과 깃허브 리포지터리 생성하기</a><br><a href="https://devocean.sk.com/blog/techBoardDetail.do?ID=165513&amp;boardType=techBlog&amp;ref=codenary">CI/CD와 Gitflow 그리고 QA</a><br><a href="https://devocean.sk.com/blog/techBoardDetail.do?ID=165211&amp;boardType=techBlog">ArgoCD + AWS EKS + CodeCommmit + CodeBuild 로 CI/CD 구축하기</a><br><a href=https://akuity.io/blog/gitops-best-practices-whitepaper/>GitOps Best Practices Whitepaper</a><br><a href="https://artist-developer.tistory.com/24?category=965473">CI/CD란 무엇인가 (Feat. DevOps 엔지니어)</a><br><a href="https://devocean.sk.com/search/techBoardDetail.do?ID=164937&amp;boardType=">Kubernetes 기반의 어플리케이션 배포 시스템 구축 방법</a><br><a href=https://blog.banksalad.com/tech/how-we-have-built-alice/>폐쇄망 환경의 배포 시스템 개발기</a></p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Jenkins</h2></header><div class=entry-content><p>Jenkins 특징 오픈소스: 무료로 사용 가능하며 커뮤니티의 지원을 받습니다. 플러그인 생태계: 다양한 플러그인을 통해 기능을 확장할 수 있습니다. 분산 빌드: 여러 머신에서 빌드 작업을 분산하여 처리할 수 있습니다. 크로스 플랫폼: Windows, Linux, macOS 등 다양한 운영 체제에서 실행 가능합니다. 웹 인터페이스: 사용하기 쉬운 웹 기반 인터페이스를 제공합니다. 주요 기능 자동화된 빌드 및 테스트 지속적 통합 및 지속적 배포(CI/CD) 코드 품질 분석 배포 자동화 모니터링 및 알림 구성 요소 Jenkins 서버: 중앙 제어 서버로 작업을 조정합니다. 노드(Agents): 실제 작업을 수행하는 워커 머신입니다. 잡(Jobs): 수행할 작업의 단위입니다. 플러그인: Jenkins의 기능을 확장하는 추가 모듈입니다. 파이프라인: 작업의 흐름을 정의하는 스크립트입니다. 장점 유연성과 확장성 광범위한 플러그인 지원 활발한 커뮤니티 지원 무료 오픈소스 단점 초기 설정이 복잡할 수 있음 학습 곡선이 가파름 보안 설정에 주의가 필요함 리소스 소비가 높을 수 있음 Jenkins 설정 방법 Jenkins 설치 초기 설정 및 플러그인 설치 보안 설정 노드 구성 잡 생성 및 파이프라인 설정 예시 간단한 CI/CD 파이프라인 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 pipeline { agent any // 어떤 Jenkins 에이전트에서도 실행 가능하도록 설정 // 환경변수 설정 environment { DOCKER_IMAGE = 'my-app:latest' } // 실행 단계 정의 stages { // 소스 코드 체크아웃 단계 stage('Checkout') { steps { // GitHub 저장소에서 코드 가져오기 git 'https://github.com/your-repo/your-project.git' } } // maven 빌드 단계 stage('Build') { steps { // Maven을 사용하여 프로젝트 빌드 sh 'mvn clean package' } } // 테스트 단계 stage('Test') { steps { // Maven을 사용하여 단위 테스트 실행 sh 'mvn test' } } // Docker 이미지 빌드 단계 stage('Docker Build') { steps { // Dockerfile을 사용하여 Docker 이미지 생성 sh 'docker build -t your-image:${BUILD_NUMBER} .' } } // 배포 단계 stage('Deploy') { steps { // 생성된 Docker 이미지를 레지스트리에 푸시 sh 'docker push your-registry/your-image:${BUILD_NUMBER}' // Kubernetes에 새 이미지 배포 sh 'kubectl set image deployment/your-app your-container=your-registry/your-image:${BUILD_NUMBER}' } } } // 파이프라인 실행 후 작업 post { always { junit '**/target/surefire-reports/*.xml' // 테스트 결과 보고서 생성 } success { // 성공 시 슬랙 알림 slackSend channel: '#deploy', color: 'good', message: "배포 성공: ${env.JOB_NAME} ${env.BUILD_NUMBER}" } failure { // 실패 시 슬랙 알림 slackSend channel: '#deploy', color: 'danger', message: "배포 실패: ${env.JOB_NAME} ${env.BUILD_NUMBER}" } } } Checkout: GitHub에서 소스 코드를 가져옵니다. Build: Maven을 사용하여 프로젝트를 빌드합니다. Test: 단위 테스트를 실행합니다. Docker Build: 애플리케이션의 Docker 이미지를 생성합니다. Deploy: 생성된 Docker 이미지를 레지스트리에 푸시하고 Kubernetes에 배포합니다. 참고 및 출처 Jenkins Jenkins Official Homepage
...</p></div><footer class=entry-footer><span title='2024-09-28 15:44:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;446 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Jenkins" href=https://buenhyden.github.io/posts/devops/ci-and-cd/ci-and-cd-tools/jenkins/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Github Actions</h2></header><div class=entry-content><p>Github Actions GitHub에서 제공하는 CI/CD 자동화 도구로, 코드 저장소에서 직접 소프트웨어 개발 워크플로우를 자동화할 수 있다.
주요 기능 자동화된 워크플로우: 코드 변경, 풀 리퀘스트 생성, 이슈 생성 등 다양한 이벤트에 반응하여 자동으로 워크플로우를 실행할 수 있습니다 CI/CD 파이프라인: 빌드, 테스트, 배포 과정을 자동화하여 지속적 통합 및 배포를 구현할 수 있습니다 다양한 환경 지원: Linux, Windows, macOS 가상 머신에서 워크플로우를 실행할 수 있으며, 자체 호스팅 러너도 지원합니다 재사용 가능한 액션: 복잡하지만 자주 반복되는 작업을 수행하는 사용자 지정 애플리케이션인 ‘액션’을 사용하여 워크플로우를 간소화할 수 있습니다 GitHub 통합: GitHub 저장소와 완벽하게 통합되어 있어 코드 관리와 자동화를 원활하게 연결할 수 있습니다 병렬 작업 실행: 여러 작업을 동시에 실행하여 효율성을 높일 수 있습니다 보안 및 액세스 제어: GitHub의 보안 기능과 통합되어 안전한 워크플로우 실행을 보장합니다 상세한 로깅 및 모니터링: 워크플로우 실행 상태와 결과를 쉽게 확인하고 문제를 진단할 수 있습니다 구성 요소 워크플로우(Workflow): 자동화된 전체 프로세스를 정의하는 가장 상위 개념입니다. YAML 파일로 작성되며 하나 이상의 작업을 포함합니다. 이벤트(Event): 워크플로우를 트리거하는 특정 활동입니다. 예를 들어 push, pull request, issue 생성 등이 있습니다. 작업(Job): 동일한 러너에서 실행되는 단계들의 집합입니다. 기본적으로 병렬로 실행되지만 순차적으로 실행되도록 설정할 수도 있습니다. 단계(Step): 작업 내에서 실행되는 개별 작업 단위입니다. 쉘 명령어를 실행하거나 액션을 사용할 수 있습니다. 액션(Action): 워크플로우에서 자주 반복되는 작업을 재사용 가능한 단위로 만든 것입니다. GitHub Marketplace에서 찾아 사용하거나 직접 만들 수 있습니다. 러너(Runner): 워크플로우 작업이 실행되는 서버입니다. GitHub에서 호스팅하는 러너를 사용하거나 자체 호스팅 러너를 설정할 수 있습니다.
서로 연결되어 GitHub Actions의 자동화된 CI/CD 파이프라인을 구성한다. 장점 자동화: 코드 빌드, 테스트, 배포 등의 워크플로우를 자동화하여 시간과 노력을 절약할 수 있습니다 GitHub와의 통합: GitHub 저장소와 완벽하게 통합되어 있어 개발 프로세스를 원활하게 관리할 수 있습니다 유연성과 사용자 정의: YAML 파일을 사용하여 워크플로우를 쉽게 구성하고 사용자 정의할 수 있습니다 광범위한 액션 생태계: GitHub Marketplace에서 다양한 사전 구축된 액션을 사용하거나 직접 만들 수 있습니다 실시간 피드백: 풀 리퀘스트와 커밋에 대한 워크플로우 상태를 즉시 확인할 수 있습니다 확장성: 다양한 규모의 프로젝트에 적용 가능하며, 여러 운영 체제와 환경에서 실행할 수 있습니다 비용 효율성: 공개 저장소에서는 무료로 사용할 수 있으며, 개인 저장소에서도 일정량의 무료 사용 시간을 제공합니다 커뮤니티 지원: 활발한 커뮤니티를 통해 다양한 액션과 지원을 받을 수 있습니다 단점 복잡한 워크플로우 구성: 복잡한 워크플로우를 설계하고 유지보수하는 것이 어려울 수 있습니다, 특히 초보자에게는 더욱 그렇습니다 리소스 제한: 실행 시간, 디스크 공간 등에 제한이 있어 리소스 집약적인 워크플로우에는 제약이 있을 수 있습니다 GitHub 의존성: GitHub 플랫폼에 강하게 의존하기 때문에, GitHub의 중단이나 장애가 CI/CD 워크플로우에 영향을 줄 수 있습니다 디버깅의 어려움: 워크플로우 실행 중 발생하는 문제를 디버깅하는 것이 어려울 수 있습니다 학습 곡선: YAML 문법과 CI/CD 개념에 익숙하지 않은 사용자에게는 상당한 학습 시간이 필요할 수 있습니다 실행 시간 제한: 각 작업은 최대 6시간까지만 실행할 수 있어, 매우 긴 작업에는 적합하지 않을 수 있습니다 API 요청 제한: 시간당 API 요청 횟수에 제한이 있어, 대규모 프로젝트에서는 문제가 될 수 있습니다 안정성 문제: 때때로 발생하는 중단이나 성능 저하로 인해 작업 시간을 잃을 수 있습니다 워크플로우 설정 방법 워크플로우 파일 생성:
프로젝트의 .github/workflows/ 디렉토리에 YAML 파일을 생성합니다. 이 파일에 워크플로우를 정의합니다. 워크플로우 정의:
YAML 파일에 원하는 자동화 작업을 정의합니다. 주요 구성 요소는 다음과 같습니다: 이벤트 트리거 설정 (예: push, pull request 등) 작업(jobs) 정의 실행 환경 지정 (예: ubuntu-latest) 단계(steps) 정의 커밋 및 푸시:
정의된 워크플로우 파일을 저장소에 커밋하고 푸시합니다. 실행 확인:
GitHub 저장소의 Actions 탭에서 워크플로우 실행 상태를 확인할 수 있습니다. 자주 사용하는 YAML 파일 예시 name: 워크플로우의 이름을 지정합니다. on: 워크플로우를 트리거하는 이벤트를 정의합니다. 여기서는 main 브랜치에 대한 push와 pull request 이벤트에 반응합니다. jobs: 실행할 작업들을 정의합니다. 여기서는 “build"라는 하나의 작업만 있습니다. runs-on: 작업을 실행할 환경을 지정합니다. 여기서는 최신 Ubuntu 환경을 사용합니다. steps: 작업 내에서 실행할 단계들을 정의합니다. 각 단계는 이름, 사용할 액션 또는 실행할 명령어를 포함합니다. uses: 미리 정의된 액션을 사용합니다. 예를 들어, actions/checkout@v2는 저장소의 코드를 체크아웃합니다. run: 직접 셸 명령어를 실행합니다. if: 조건부로 단계를 실행합니다. 여기서는 main 브랜치에 푸시된 경우에만 배포 단계를 실행합니다. env: 환경 변수를 설정합니다. 여기서는 비밀 값을 환경 변수로 사용합니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: CI/CD Pipeline on: push: branches: [ "main" ] pull_request: branches: [ "main" ] jobs: build: runs-on: ubuntu-latest steps: - name: Checkout Repository uses: actions/checkout@v2 - name: Set up Node.js uses: actions/setup-node@v2 with: node-version: '14' - name: Install Dependencies run: npm install - name: Run Tests run: npm test - name: Deploy to Production if: github.ref == 'refs/heads/main' env: PRODUCTION_URL: ${{ secrets.PRODUCTION_URL }} run: | echo "Deploying to production at $PRODUCTION_URL" # 프로덕션 환경에 배포하는 명령어 기본적인 Node.js 프로젝트 CI 워크플로우 여러 Node.js 버전에서 테스트 자동 의존성 설치 및 빌드 테스트 자동 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name: Node.js CI on: # 워크플로우 트리거 설정 push: branches: [ main ] pull_request: branches: [ main ] jobs: build: runs-on: ubuntu-latest # 실행 환경 설정 strategy: matrix: node-version: [14.x, 16.x, 18.x] # 테스트할 Node.js 버전들 steps: - uses: actions/checkout@v3 # 소스코드 체크아웃 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v3 with: node-version: ${{ matrix.node-version }} - run: npm ci # 의존성 설치 - run: npm run build # 빌드 - run: npm test # 테스트 실행 Docker 이미지 빌드 및 배포 워크플로우 Docker Hub 자동 인증 이미지 자동 빌드 및 푸시 보안 자격 증명 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 name: Docker Build and Push on: push: branches: [ main ] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Login to Docker Hub # Docker Hub 로그인 uses: docker/login-action@v2 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build and push # 이미지 빌드 및 푸시 uses: docker/build-push-action@v4 with: push: true tags: user/app:latest 자동화된 릴리스 생성 워크플로우 태그 기반 트리거 자동 릴리스 노트 생성 GitHub 릴리스 자동화 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 name: Create Release on: push: tags: - 'v*' # v로 시작하는 모든 태그에 대해 실행 jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Create Release # GitHub 릴리스 생성 uses: actions/create-release@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tag_name: ${{ github.ref }} release_name: Release ${{ github.ref }} draft: false prerelease: false 스케줄링된 작업 워크플로우 Cron 기반 실행 정기적인 유지보수 작업 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 name: Scheduled Tasks on: schedule: - cron: '0 0 * * *' # 매일 자정에 실행 jobs: cleanup: runs-on: ubuntu-latest steps: - name: Cleanup old artifacts # 오래된 아티팩트 정리 uses: c-hive/gha-remove-artifacts@v1 with: age: '1 week' skip-recent: 5 PR 자동 리뷰 워크플로우 자동 코드 검사 테스트 실행 코드 커버리지 리포트 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 name: PR Review on: pull_request: types: [opened, synchronize] jobs: review: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Run ESLint # ESLint 검사 run: | npm install npm run lint - name: Run tests # 테스트 실행 run: npm test - name: Code Coverage # 코드 커버리지 리포트 uses: codecov/codecov-action@v3 with: token: ${{ secrets.CODECOV_TOKEN }} 프라이빗 컨테이너 레지스트리를 사용하는 워크플로우 설정 방법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 name: Build and Push to Harbor Registry on: push: branches: [ main ] # 특정 태그에 대해서만 실행하고 싶다면 아래처럼 설정 # tags: # - 'v*' env: # Harbor 레지스트리 설정 REGISTRY: harbor.example.com # Harbor 레지스트리 주소 REPOSITORY: project-name/application # Harbor 프로젝트와 이미지명 IMAGE_TAG: ${{ github.sha }} # 이미지 태그 (커밋 해시 사용) jobs: build-and-push: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v3 # QEMU 설정 (다중 아키텍처 빌드시 필요) - name: Set up QEMU uses: docker/setup-qemu-action@v2 # Docker Buildx 설정 - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 # Harbor 레지스트리 로그인 - name: Login to Harbor uses: docker/login-action@v2 with: registry: ${{ env.REGISTRY }} username: ${{ secrets.HARBOR_USERNAME }} password: ${{ secrets.HARBOR_PASSWORD }} # 도커 메타데이터 설정 - name: Extract Docker metadata id: meta uses: docker/metadata-action@v4 with: images: ${{ env.REGISTRY }}/${{ env.REPOSITORY }} tags: | type=raw,value=${{ env.IMAGE_TAG }} type=raw,value=latest type=ref,event=branch type=ref,event=tag # 이미지 빌드 및 푸시 - name: Build and push Docker image uses: docker/build-push-action@v4 with: context: . push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }} platforms: linux/amd64,linux/arm64 # 필요한 플랫폼 지정 cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.REPOSITORY }}:buildcache cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.REPOSITORY }}:buildcache,mode=max # 배포 결과 알림 (선택사항) - name: Notify deployment if: success() run: | echo "Image successfully built and pushed to Harbor:" echo "Registry: ${{ env.REGISTRY }}" echo "Repository: ${{ env.REPOSITORY }}" echo "Tags: ${{ steps.meta.outputs.tags }}" 주요 설정 사항 환경 변수 설정
...</p></div><footer class=entry-footer><span title='2024-09-28 03:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2157 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Github Actions" href=https://buenhyden.github.io/posts/devops/ci-and-cd/ci-and-cd-tools/github-actions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Gitlab CI</h2></header><div class=entry-content><p>Gitlab CI GitLab에 내장된 지속적 통합/배포 도구로, .gitlab-ci.yml 파일을 통해 파이프라인을 정의하고 관리
특징 통합성: GitLab 저장소와 긴밀하게 통합되어 있어 별도의 도구 없이 CI/CD 파이프라인을 구축할 수 있습니다. 유연성: YAML 파일을 통해 파이프라인을 구성할 수 있어 다양한 프로젝트 요구사항에 맞춤 설정이 가능합니다. 확장성: 다양한 Runner 유형을 지원하여 다양한 환경에서 작업을 실행할 수 있습니다. 가시성: 파이프라인 실행 상태와 결과를 GitLab 인터페이스에서 쉽게 확인할 수 있습니다. 기능 자동 빌드 및 테스트: 코드 변경 시 자동으로 빌드 및 테스트를 실행합니다. 환경 배포: 다양한 환경(개발, 스테이징, 프로덕션 등)에 자동으로 배포할 수 있습니다. 아티팩트 관리: 빌드 결과물을 저장하고 관리할 수 있습니다. 병렬 실행: 여러 작업을 동시에 실행하여 파이프라인 속도를 향상시킵니다. 환경 변수 관리: 민감한 정보를 안전하게 저장하고 사용할 수 있습니다. 구성요소 .gitlab-ci.yml: 파이프라인 구성 파일 Runners: 작업을 실행하는 에이전트 Jobs: 실행할 개별 작업 Stages: 작업의 실행 순서를 정의하는 단계 Pipeline: 전체 CI/CD 프로세스 장점 GitLab과의 긴밀한 통합 쉬운 설정과 사용 확장성과 유연성 무료로 사용 가능한 기능이 많음 단점 GitLab에 종속적 복잡한 워크플로우의 경우 설정이 복잡해질 수 있음 일부 고급 기능은 유료 버전에서만 사용 가능 설정 방법 프로젝트 루트에.gitlab-ci.yml 파일 생성 YAML 형식으로 파이프라인 구성 작성 변경사항을 커밋하고 푸시 GitLab에서 파이프라인 실행 확인 .gitlab-ci.yml 파일의 기본 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 stages: - build - test - deploy job1: stage: build script: - echo "Building the project..." job2: stage: test script: - echo "Running tests..." job3: stage: deploy script: - echo "Deploying to production..." 주요 구성 요소 stages: 파이프라인의 실행 단계를 정의합니다. 각 단계는 순차적으로 실행됩니다. jobs: 각 작업을 정의합니다. 작업은 특정 단계에 속하며, 실행할 스크립트를 포함합니다. script: 작업에서 실행할 명령어들을 정의합니다. image: 작업을 실행할 Docker 이미지를 지정합니다. artifacts: 작업 결과물을 저장하고 다른 작업에서 사용할 수 있게 합니다. cache: 작업 간에 공유할 파일이나 디렉토리를 지정합니다. 고급 구성 옵션 only/except: 특정 브랜치나 태그에서만 작업을 실행하거나 제외할 수 있습니다. variables: 파이프라인 전체 또는 특정 작업에서 사용할 변수를 정의합니다. before_script/after_script: 작업 실행 전후에 실행할 스크립트를 정의합니다. environment: 배포 환경을 지정합니다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 파이프라인 단계 정의 stages: - build - test - deploy # 캐시 설정: node_modules 폴더를 캐시하여 빌드 속도 향상 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build image: node:14 # Node.js 14 버전 이미지 사용 script: - npm install # 의존성 설치 - npm run build # 프로젝트 빌드 artifacts: paths: - dist/ # 빌드 결과물 저장 # 테스트 작업 정의 test: stage: test image: node:14 script: - npm install # 의존성 설치 - npm test # 테스트 실행 # 배포 작업 정의 deploy: stage: deploy image: alpine:latest script: - apk add --no-cache rsync openssh # 배포에 필요한 도구 설치 - mkdir -p ~/.ssh - echo "$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_rsa - chmod 600 ~/.ssh/id_rsa - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts - rsync -avz --delete dist/ $DEPLOY_USER@$DEPLOY_SERVER_IP:/path/to/deployment/ only: - master # master 브랜치에 푸시될 때만 실행 stages: 파이프라인의 단계를 정의합니다. 여기서는 build, test, deploy 세 단계로 구성됩니다. cache: node_modules 폴더를 캐시하여 빌드 속도를 향상시킵니다. build 작업: stage: build로 빌드 단계에 할당합니다. Node.js 14 버전 이미지를 사용합니다. npm install로 의존성을 설치하고, npm run build로 프로젝트를 빌드합니다. artifacts를 사용하여 빌드 결과물을 저장합니다. test 작업: stage: test로 테스트 단계에 할당합니다. npm test 명령으로 테스트를 실행합니다. deploy 작업: stage: deploy로 배포 단계에 할당합니다. Alpine Linux 이미지를 사용하여 가벼운 환경을 구성합니다. SSH 키를 설정하고 rsync를 사용하여 빌드 결과물을 서버에 배포합니다. only: - master로 master 브랜치에 푸시될 때만 실행되도록 설정합니다. 기본 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # GitLab CI의 기본 설정 예시 image: node:16 # 기본 Docker 이미지 지정 # 파이프라인 스테이지 정의 stages: - build - test - deploy # 캐시 설정 - node_modules 디렉토리를 캐시 cache: paths: - node_modules/ # 빌드 작업 정의 build: stage: build # 속한 스테이지 지정 script: - npm install # 의존성 설치 - npm run build # 빌드 실행 artifacts: # 빌드 결과물 저장 paths: - dist/ # 테스트 작업 정의 test: stage: test script: - npm run test # 테스트 실행 dependencies: # build 작업의 결과물 사용 - build # 배포 작업 정의 deploy: stage: deploy script: - echo "Deploying application…" - npm run deploy only: # main 브랜치에서만 실행 - main 고급 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 환경변수와 조건부 실행이 포함된 고급 설정 예시 variables: DOCKER_IMAGE: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG # Docker 이미지 태그 정의 # 커스텀 도커 이미지 빌드 build_image: image: docker:20.10.16 services: - docker:20.10.16-dind # Docker-in-Docker 서비스 stage: build script: # Docker 레지스트리 로그인 - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY # Docker 이미지 빌드 및 푸시 - docker build -t $DOCKER_IMAGE . - docker push $DOCKER_IMAGE rules: - if: $CI_COMMIT_BRANCH == "main" # main 브랜치에서만 실행 when: always - when: never # 그 외의 경우 실행하지 않음 # 보안 스캔 작업 security_scan: image: security-scanner stage: test script: - scan-dependencies # 의존성 취약점 검사 - scan-code # 코드 보안 검사 allow_failure: true # 실패해도 파이프라인 계속 진행 # 스테이징 환경 배포 deploy_staging: stage: deploy environment: name: staging script: - deploy-to-kubernetes.sh --env staging rules: - if: $CI_COMMIT_BRANCH == "develop" 환경별 배포 설정 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 환경별 배포 구성 예시 .deploy_template: &amp;deploy_template # 재사용 가능한 배포 템플릿 정의 script: - echo "Deploying to $CI_ENVIRONMENT_NAME" - kubectl apply -f k8s/$CI_ENVIRONMENT_NAME/ deploy_dev: &lt;&lt;: *deploy_template # 템플릿 상속 environment: name: development rules: - if: $CI_COMMIT_BRANCH == "develop" deploy_prod: &lt;&lt;: *deploy_template environment: name: production rules: - if: $CI_COMMIT_BRANCH == "main" when: manual # 수동 승인 후 배포 병렬 작업 실행 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 병렬 테스트 실행 예시 test: parallel: 3 # 3개의 병렬 작업 생성 script: - npm run test -- --split=$CI_NODE_INDEX/$CI_NODE_TOTAL # 매트릭스 작업 정의 test_matrix: parallel: matrix: - NODE_VERSION: ["14", "16", "18"] DB_TYPE: ["mysql", "postgres"] script: - docker-compose run --rm -e NODE_VERSION=$NODE_VERSION -e DB_TYPE=$DB_TYPE test 캐시와 아티팩트 관리 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 캐시와 아티팩트 관리 예시 build: cache: key: ${CI_COMMIT_REF_SLUG} # 브랜치별 캐시 키 paths: - node_modules/ - .npm/ policy: pull-push # 캐시 정책 설정 artifacts: paths: - dist/ # 빌드 결과물 - coverage/ # 테스트 커버리지 리포트 reports: junit: test-results.xml # 테스트 결과 리포트 coverage: coverage/lcov.info # 커버리지 리포트 expire_in: 1 week # 아티팩트 유효 기간 이러한 설정들은 프로젝트의 요구사항과 규모에 따라 적절히 조정하여 사용할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:10:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1165 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Gitlab CI" href=https://buenhyden.github.io/posts/devops/ci-and-cd/ci-and-cd-tools/gitlab-ci/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deployment Strategies</h2></header><div class=entry-content><p>배포 전략 (Deployment Strategies) 배포 전략(Deployment Strategies)은 소프트웨어를 안전하고 효율적으로 업데이트하거나 새로운 버전을 릴리스하는 방법을 말한다.
적절한 배포 전략을 선택하면 서비스 중단을 최소화하고, 새로운 기능을 안전하게 릴리스하며, 롤백을 신속하게 수행할 수 있다.
주요 배포 전략 롤링 업데이트 (Rolling Update): 롤링 업데이트는 서버를 하나씩 또는 작은 그룹으로 순차적으로 업데이트하는 방식.
장점:
무중단 배포 가능 리소스 효율적 사용 점진적인 업데이트로 리스크 감소
단점: 구버전과 신버전이 공존하는 시간 발생 롤백이 복잡할 수 있음 블루/그린 배포 (Blue/Green Deployment): 두 개의 동일한 프로덕션 환경(블루와 그린)을 유지하고, 트래픽을 한 번에 전환하는 방식.
장점:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:13:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;246 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deployment Strategies" href=https://buenhyden.github.io/posts/devops/ci-and-cd/deployment-strategies/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>