<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Observability | hyunyoun's Blog</title>
<meta name=keywords content="Backend-Development,Scalability,Observability,Log,Metric,Trace"><meta name=description content="현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/platform-engineering/observability/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/platform-engineering/observability/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/platform-engineering/observability/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/platform-engineering/observability/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Observability"><meta property="og:description" content="현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Observability"><meta name=twitter:description content="현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Platform Engineering","item":"https://buenhyden.github.io/posts/platform-engineering/"},{"@type":"ListItem","position":3,"name":"Observability","item":"https://buenhyden.github.io/posts/platform-engineering/observability/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/platform-engineering/>Platform Engineering</a></div><h1>Observability</h1><div class=post-description>현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다.</div></header><div class=post-content><h2 id=observability>Observability<a hidden class=anchor aria-hidden=true href=#observability>#</a></h2><p><strong>Observability(관측 가능성)</strong> 은 현대 소프트웨어 개발과 운영에서 필수적인 개념으로, 시스템의 외부 출력(메트릭, 로그, 트레이스 등)을 통해 내부 상태를 이해하고 모니터링하는 능력을 의미한다. 이는 단순한 모니터링을 넘어, 복잡한 시스템의 성능을 분석하고 문제를 예측하며 해결할 수 있는 깊은 통찰력을 제공한다.</p><p>옵저버빌리티와 모니터링의 차이는 다음과 같다:</p><ul><li><strong>모니터링</strong>: 알고 있는 문제와 예상된 실패 모드를 추적한다.</li><li><strong>옵저버빌리티</strong>: 예상하지 못한 문제와 새로운 실패 모드를 발견하고 이해하는 데 중점을 둔다.</li></ul><h3 id=observability의-필요성>Observability의 필요성<a hidden class=anchor aria-hidden=true href=#observability의-필요성>#</a></h3><p>현대 소프트웨어 시스템은 마이크로서비스 아키텍처와 클라우드 네이티브 환경으로 인해 점점 더 복잡해지고 있다.</p><p>이러한 환경에서 Observability는 다음과 같은 이유로 필수적이다:</p><ul><li><strong>문제 예측 및 예방:</strong><ul><li>메트릭과 로그를 분석하여 이상 징후를 조기에 감지하고 문제 발생 전에 대응할 수 있다.</li></ul></li><li><strong>빠른 문제 해결:</strong><ul><li>트레이스를 통해 문제의 근본 원인을 신속히 파악하여 MTTR(Mean Time to Resolution)을 단축한다.</li></ul></li><li><strong>시스템 신뢰성 향상:</strong><ul><li>지속적인 성능 모니터링과 자동화된 알림을 통해 다운타임을 줄이고 사용자 경험을 개선한다.</li></ul></li></ul><h3 id=옵저버빌리티의-세-가지-핵심-요소>옵저버빌리티의 세 가지 핵심 요소<a hidden class=anchor aria-hidden=true href=#옵저버빌리티의-세-가지-핵심-요소>#</a></h3><p>옵저버빌리티는 일반적으로 세 가지 주요 데이터 유형(흔히 &ldquo;세 가지 기둥"이라고 불림)을 중심으로 구축된다:</p><h4 id=메트릭metrics>메트릭(Metrics)<a hidden class=anchor aria-hidden=true href=#메트릭metrics>#</a></h4><ul><li><strong>정의</strong>: 시간 경과에 따른 시스템의 수치적 측정값.</li><li><strong>특징</strong>: 집계하기 쉽고, 저장 공간이 적게 필요하며, 실시간 대시보드 및 알림에 적합하다.</li><li><strong>예시</strong>: CPU 사용률, 메모리 소비, 요청 처리 시간, 오류율 등</li><li><strong>도구</strong>: Prometheus, Grafana, AWS CloudWatch, Datadog</li></ul><p>메트릭은 다음과 같은 유형으로 분류될 수 있다:</p><ul><li><strong>카운터(Counters)</strong>: 증가하기만 하는 누적 측정값(예: 처리된 총 요청 수)</li><li><strong>게이지(Gauges)</strong>: 시간에 따라 증가하거나 감소할 수 있는 값(예: 현재 메모리 사용량)</li><li><strong>히스토그램(Histograms)</strong>: 값의 분포를 측정(예: 응답 시간의 분포)</li><li><strong>요약(Summaries)</strong>: 히스토그램과 유사하지만 서버 측에서 계산된 백분위수 포함</li></ul><h4 id=로그logs>로그(Logs)<a hidden class=anchor aria-hidden=true href=#로그logs>#</a></h4><ul><li><strong>정의</strong>: 시스템 이벤트의 시간순 기록.</li><li><strong>특징</strong>: 상세한 컨텍스트 정보를 제공하며, 문제 진단에 필수적이다.</li><li><strong>유형</strong>: 구조화된 로그(JSON 형식), 비구조화된 로그(텍스트 파일)</li><li><strong>도구</strong>: ELK Stack(Elasticsearch, Logstash, Kibana), Splunk, Datadog, AWS CloudWatch Logs</li></ul><p>효과적인 로깅을 위한 핵심 사항:</p><ul><li>구조화된 로그 형식 사용(JSON 등)</li><li>일관된 로그 레벨 적용(DEBUG, INFO, WARN, ERROR, FATAL)</li><li>상관관계 ID 포함(트랜잭션 또는 요청 ID)</li><li>민감한 정보 제외</li></ul><h4 id=트레이스traces>트레이스(Traces)<a hidden class=anchor aria-hidden=true href=#트레이스traces>#</a></h4><ul><li><strong>정의</strong>: 분산 시스템을 통과하는 요청의 전체 경로를 추적한다.</li><li><strong>특징</strong>: 여러 서비스와 시스템에 걸친 요청 흐름을 시각화한다.</li><li><strong>구성요소</strong>: 스팬(span - 작업의 단위), 트레이스 ID, 스팬 ID, 부모 스팬 ID</li><li><strong>도구</strong>: Jaeger, Zipkin, AWS X-Ray, Datadog APM, New Relic</li></ul><p>분산 트레이싱의 주요 이점:</p><ul><li>서비스 간 통신의 병목 현상 식별</li><li>오류가 발생한 특정 지점 파악</li><li>엔드-투-엔드 성능 분석</li><li>서비스 의존성 맵 생성</li></ul><h3 id=옵저버빌리티-구현-방법>옵저버빌리티 구현 방법<a hidden class=anchor aria-hidden=true href=#옵저버빌리티-구현-방법>#</a></h3><h4 id=1-계측instrumentation>1. 계측(Instrumentation)<a hidden class=anchor aria-hidden=true href=#1-계측instrumentation>#</a></h4><p>계측은 애플리케이션 코드에 모니터링 기능을 추가하는 과정이다. 이는 옵저버빌리티의 기초가 된다.</p><p><strong>계측 유형</strong>:</p><ul><li><strong>수동 계측</strong>: 개발자가 직접 코드에 모니터링 로직을 추가한다.</li><li><strong>자동 계측</strong>: 에이전트나 라이브러리가 자동으로 데이터를 수집한다.</li></ul><p><strong>효과적인 계측을 위한 접근 방식</strong>:</p><ul><li>OpenTelemetry와 같은 표준화된 프레임워크 사용</li><li>중요한 비즈니스 트랜잭션 우선 계측</li><li>코드 경로의 시작과 끝 표시</li><li>중요한 외부 서비스 호출 계측</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># OpenTelemetry를 사용한 Python 계측 예시</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>opentelemetry</span> <span class=kn>import</span> <span class=n>trace</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>opentelemetry.sdk.trace</span> <span class=kn>import</span> <span class=n>TracerProvider</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>opentelemetry.sdk.trace.export</span> <span class=kn>import</span> <span class=n>ConsoleSpanExporter</span><span class=p>,</span> <span class=n>BatchSpanProcessor</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 트레이서 설정</span>
</span></span><span class=line><span class=cl><span class=n>trace</span><span class=o>.</span><span class=n>set_tracer_provider</span><span class=p>(</span><span class=n>TracerProvider</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>tracer</span> <span class=o>=</span> <span class=n>trace</span><span class=o>.</span><span class=n>get_tracer</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>span_processor</span> <span class=o>=</span> <span class=n>BatchSpanProcessor</span><span class=p>(</span><span class=n>ConsoleSpanExporter</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>trace</span><span class=o>.</span><span class=n>get_tracer_provider</span><span class=p>()</span><span class=o>.</span><span class=n>add_span_processor</span><span class=p>(</span><span class=n>span_processor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 함수 계측</span>
</span></span><span class=line><span class=cl><span class=nd>@tracer.start_as_current_span</span><span class=p>(</span><span class=s2>&#34;process_request&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>process_request</span><span class=p>(</span><span class=n>request_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 비즈니스 로직</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>do_something</span><span class=p>(</span><span class=n>request_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 사용자 정의 속성 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>current_span</span> <span class=o>=</span> <span class=n>trace</span><span class=o>.</span><span class=n>get_current_span</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>current_span</span><span class=o>.</span><span class=n>set_attribute</span><span class=p>(</span><span class=s2>&#34;request.size&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>request_data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>current_span</span><span class=o>.</span><span class=n>set_attribute</span><span class=p>(</span><span class=s2>&#34;processing.result&#34;</span><span class=p>,</span> <span class=s2>&#34;success&#34;</span> <span class=k>if</span> <span class=n>result</span> <span class=k>else</span> <span class=s2>&#34;failure&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=데이터-수집-및-저장>데이터 수집 및 저장<a hidden class=anchor aria-hidden=true href=#데이터-수집-및-저장>#</a></h4><p>수집된 텔레메트리 데이터를 효율적으로 저장하고 처리하는 인프라를 구축해야 한다.</p><p><strong>주요 고려사항</strong>:</p><ul><li>확장성 있는 스토리지 솔루션 선택</li><li>데이터 보존 정책 설정</li><li>샘플링 전략 구현(필요한 경우)</li><li>보안 및 개인정보 보호 고려</li></ul><h4 id=시각화-및-분석>시각화 및 분석<a hidden class=anchor aria-hidden=true href=#시각화-및-분석>#</a></h4><p>수집된 데이터를 의미 있는 인사이트로 변환하는 도구와 대시보드를 구축한다.</p><p><strong>효과적인 대시보드 설계 원칙</strong>:</p><ul><li>RED 방법론(Rate, Error, Duration) 또는 USE 방법론(Utilization, Saturation, Errors) 적용</li><li>비즈니스 KPI와 기술 메트릭 모두 표시</li><li>관련 정보 그룹화</li><li>이상치를 빠르게 식별할 수 있는 시각화</li></ul><h4 id=알림-및-이상-탐지>알림 및 이상 탐지<a hidden class=anchor aria-hidden=true href=#알림-및-이상-탐지>#</a></h4><p>문제가 발생하면 적시에 알림을 받고 가능한 경우 자동으로 대응하는 시스템을 구축한다.</p><p><strong>알림 설계의 모범 사례</strong>:</p><ul><li>알림 피로를 줄이기 위한 우선순위 지정</li><li>경고에 문제 해결 가이드 연결</li><li>정적 임계값보다 동적 임계값 선호</li><li>상관관계 알림 구현(관련 알림 그룹화)</li></ul><h3 id=observability-도구>Observability 도구<a hidden class=anchor aria-hidden=true href=#observability-도구>#</a></h3><p>다양한 Observability 도구가 있으며, 각 도구는 특정 목적에 최적화되어 있다.</p><h4 id=datadog>Datadog<a hidden class=anchor aria-hidden=true href=#datadog>#</a></h4><p>Datadog은 통합된 모니터링 및 보안 플랫폼으로, 인프라, 애플리케이션, 로그를 단일 플랫폼에서 관리할 수 있다.</p><p><strong>주요 기능</strong>:</p><ul><li>200개 이상의 기술과의 즉시 통합</li><li>맞춤형 대시보드</li><li>분산 트레이싱</li><li>로그 관리 및 분석</li><li>인프라 모니터링</li><li>실시간 알림</li></ul><h4 id=aws-cloudwatch>AWS CloudWatch<a hidden class=anchor aria-hidden=true href=#aws-cloudwatch>#</a></h4><p>AWS 서비스를 위한 모니터링 및 관찰 서비스로, AWS 리소스와 애플리케이션의 메트릭을 수집하고 추적한다.</p><p><strong>주요 기능</strong>:</p><ul><li>자동화된 대시보드</li><li>이상 탐지</li><li>CloudWatch Logs</li><li>CloudWatch Events</li><li>AWS X-Ray와의 통합</li></ul><h4 id=sentry>Sentry<a hidden class=anchor aria-hidden=true href=#sentry>#</a></h4><p>주로 애플리케이션 오류 추적 및 성능 모니터링에 중점을 둔 도구이다.</p><p><strong>주요 기능</strong>:</p><ul><li>실시간 오류 추적</li><li>릴리스 건전성 모니터링</li><li>성능 모니터링</li><li>이슈 그룹화 및 우선순위 지정</li><li>다양한 프로그래밍 언어 지원</li></ul><h4 id=new-relic>New Relic<a hidden class=anchor aria-hidden=true href=#new-relic>#</a></h4><p>종합적인 옵저버빌리티 플랫폼으로, 애플리케이션 성능 모니터링부터 인프라 모니터링까지 폭넓은 기능을 제공한다.</p><p><strong>주요 기능</strong>:</p><ul><li>APM(애플리케이션 성능 모니터링)</li><li>분산 트레이싱</li><li>인프라 모니터링</li><li>로그 관리</li><li>사용자 경험 모니터링</li></ul><h4 id=오픈소스-솔루션>오픈소스 솔루션<a hidden class=anchor aria-hidden=true href=#오픈소스-솔루션>#</a></h4><p><strong>Prometheus + Grafana</strong>:</p><ul><li>Prometheus: 메트릭 수집 및 알림</li><li>Grafana: 시각화 및 대시보드</li></ul><p><strong>ELK Stack</strong>:</p><ul><li>Elasticsearch: 로그 및 메트릭 저장 및 검색</li><li>Logstash: 데이터 수집 및 변환</li><li>Kibana: 데이터 시각화</li></ul><p><strong>OpenTelemetry</strong>:</p><ul><li>여러 벤더에 구애받지 않는 계측을 위한 표준 API, 라이브러리 및 에이전트</li><li>단일 도구로 메트릭, 로그, 트레이스 수집</li></ul><h3 id=효과적인-옵저버빌리티-구현을-위한-모범-사례>효과적인 옵저버빌리티 구현을 위한 모범 사례<a hidden class=anchor aria-hidden=true href=#효과적인-옵저버빌리티-구현을-위한-모범-사례>#</a></h3><ol><li><p>비즈니스 컨텍스트 포함<br>기술적 메트릭을 비즈니스 성과와 연결한다.<br><strong>예시</strong>:</p><ul><li>트랜잭션당 수익과 API 응답 시간 상관 관계</li><li>사용자 경험 메트릭과 고객 이탈률 연결</li></ul></li><li><p>확장성 있는 아키텍처 설계<br>시스템 성장에 따라 확장될 수 있는 옵저버빌리티 인프라를 구축한다.<br><strong>전략</strong>:</p><ul><li>샘플링 구현</li><li>데이터 압축</li><li>데이터 보존 정책 정의</li><li>클라우드 네이티브 스토리지 솔루션 활용</li></ul></li><li><p>개발자 경험 최적화<br>개발자가 쉽게 코드를 계측하고 옵저버빌리티 데이터를 활용할 수 있도록 한다.<br><strong>접근 방식</strong>:</p><ul><li>표준화된 라이브러리 및 SDK 제공</li><li>자동 계측 활용</li><li>개발 환경에서의 로컬 텔레메트리 시각화</li><li>옵저버빌리티 교육 및 문서화</li></ul></li><li><p>실제 사용자 모니터링(RUM) 구현<br>최종 사용자 관점에서 애플리케이션 성능을 측정한다.<br><strong>측정 항목</strong>:</p><ul><li>페이지 로드 시간</li><li>첫 번째 콘텐츠가 있는 페인트(FCP)</li><li>상호 작용까지의 시간(TTI)</li><li>누적 레이아웃 시프트(CLS)</li></ul></li></ol><h3 id=옵저버빌리티의-미래-동향>옵저버빌리티의 미래 동향<a hidden class=anchor aria-hidden=true href=#옵저버빌리티의-미래-동향>#</a></h3><ol><li><p>AIOps(인공지능 운영)<br>기계 학습 및 AI 기술을 활용하여 옵저버빌리티 데이터에서 인사이트를 도출하고 자동화된 대응을 제공한다.<br><strong>핵심 기능</strong>:</p><ul><li>이상 탐지</li><li>근본 원인 분석</li><li>자동화된 문제 해결</li><li>예측 분석</li></ul></li><li><p>서비스 수준 목표(SLO) 중심 접근 방식<br>기술적 메트릭보다는 비즈니스 성과와 사용자 경험에 초점을 맞춘 모니터링.<br><strong>구성 요소</strong>:</p><ul><li>서비스 수준 지표(SLI)</li><li>서비스 수준 목표(SLO)</li><li>오류 예산</li></ul></li><li><p>eBPF(Extended Berkeley Packet Filter)<br>커널 수준에서 성능 데이터를 안전하게 수집하는 Linux 기술.<br><strong>이점</strong>:</p><ul><li>낮은 오버헤드</li><li>심층적인 시스템 인사이트</li><li>애플리케이션 코드 수정 없이 관찰 가능</li></ul></li><li><p>옵저버빌리티 메시(Mesh)<br>마이크로서비스 환경에서 일관된 텔레메트리 데이터 수집을 제공하는 인프라 레이어이다.<br><strong>특징</strong>:</p><ul><li>서비스 간 통신의 자동 계측</li><li>표준화된 메트릭 및 트레이싱</li><li>정책 기반 트래픽 관리</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Observability vs. Monitoring</h2></header><div class=entry-content><p>Observability vs. Monitoring 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observability vs. Monitoring" href=https://buenhyden.github.io/posts/platform-engineering/observability/observability-vs-monitoring/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Metric</h2></header><div class=entry-content><p>Metric Metric는 시스템의 상태와 성능을 수치화하여 측정하는 중요한 관측 도구이다.
Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값이다.
예를 들어, 웹 서버의 응답 시간, CPU 사용률, 메모리 사용량 등이 Metric가 될 수 있다.
장점 효율적인 저장: 숫자 데이터는 저장 공간을 적게 차지한다. 빠른 쿼리: 시계열 데이터베이스를 사용하여 빠른 검색과 분석이 가능하다. 장기 추세 분석: 오랜 기간 동안의 데이터를 저장하고 분석할 수 있다. 시각화 용이성: 그래프나 대시보드로 쉽게 표현할 수 있다. 단점 초기 설정에 시간과 노력이 필요하다 너무 많은 Metric는 오히려 혼란을 줄 수 있다 저장 공간과 처리 리소스가 필요하다 Metric의 중요성 성능 모니터링: 시스템의 전반적인 성능을 지속적으로 모니터링할 수 있다. 문제 감지: 비정상적인 패턴이나 임계값 초과를 빠르게 감지할 수 있다. 용량 계획: 리소스 사용량 추세를 분석하여 미래의 용량을 계획할 수 있다. 최적화: 성능 병목 현상을 식별하고 최적화할 수 있는 기회를 제공한다. Metric의 구성 요소 일반적인 Metric는 다음 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Metric" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/metrics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Trace</h2></header><div class=entry-content><p>Trace Trace는 분산 시스템에서 요청의 흐름을 추적하고 시각화하는 데 사용된다.
Trace는 분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것이다.
각 Trace는 하나 이상의 span으로 구성되며, 첫 번째 span은 root span이라고 한다.
Trace의 목적 분산 시스템에서의 요청 흐름 이해 성능 병목 지점 식별 서비스 간 의존성 파악 오류 및 지연의 근본 원인 분석 Trace의 구성 요소 트레이스는 다음과 같은 구성 요소들로 이루어진다:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 트레이스 시작 Span rootSpan = tracer.spanBuilder("checkout-process") .setSpanKind(SpanKind.SERVER) .startSpan(); try (Scope scope = rootSpan.makeCurrent()) { // 자식 스팬 생성 Span paymentSpan = tracer.spanBuilder("process-payment") .setParent(Context.current().with(rootSpan)) .startSpan(); try { processPayment(); paymentSpan.setStatus(StatusCode.OK); } catch (Exception e) { paymentSpan.setStatus(StatusCode.ERROR, e.getMessage()); throw e; } finally { paymentSpan.end(); } } finally { rootSpan.end(); } 트레이스 구성의 핵심 요소들:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trace" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/tracing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Log</h2></header><div class=entry-content><p>Log Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.
문제가 발생했을 때 무슨 일이 있었는지 추적할 수 있게 해주며, 시스템의 동작을 이해하는 데 필수적인 정보를 제공한다.
로그 구조를 설계할 때는 다음과 같은 원칙들을 고려해야 한다:
일관성(Consistency): 모든 로그 항목은 동일한 구조와 형식을 따라야 한다. 이는 로그 파싱과 분석을 용이하게 만든다. 검색 가능성(Searchability): 주요 필드들은 쉽게 검색하고 필터링할 수 있는 형태여야 한다. 확장성(Extensibility): 새로운 정보를 추가할 필요가 생겼을 때 기존 구조를 해치지 않고 확장할 수 있어야 한다. 상세도 조절(Verbosity Control): 로그 레벨을 통해 필요한 상세도를 조절할 수 있어야 한다. 로그 구조를 효과적으로 설계하면 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/three-pillars-of-observability/logging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Instrumentation</h2></header><div class=entry-content><p>Instrumentation **Instrumentation(계측)**은 애플리케이션 코드에 특정 로직을 추가하여 메트릭, 로그, 트레이스와 같은 데이터를 수집하고 분석할 수 있도록 만드는 과정이다. 이를 통해 애플리케이션의 성능, 동작, 문제점을 실시간으로 모니터링하고 최적화할 수 있다. Instrumentation은 **Observability(관측 가능성)**의 핵심 요소로, 시스템의 내부 상태를 이해하고 문제를 해결하는 데 필수적이다.
인스트루멘테이션의 기본 개념 인스트루멘테이션(Instrumentation)은 애플리케이션에 코드나 도구를 삽입하여 핵심 메트릭, 로그, 트레이스 등을 수집하는 과정을 의미합니다. 이는 마치 자동차에 속도계, 연료 게이지, 엔진 온도계 등의 계측 장치를 장착하는 것과 유사합니다. 이러한 계측 도구들은 자동차의 상태를 실시간으로 모니터링하고 문제가 발생했을 때 진단하는 데 도움을 주는 것처럼, 소프트웨어 인스트루멘테이션은 애플리케이션의 상태와 성능을 모니터링하고 문제를 진단하는 데 도움을 줍니다.
...</p></div><footer class=entry-footer><span title='2025-03-22 14:35:00 +0000 UTC'>March 22, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Instrumentation" href=https://buenhyden.github.io/posts/platform-engineering/observability/fundamentals/instrumentation/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>