<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>posts | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="posts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="posts"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="posts"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Computer Science and Engineering</h2></header><div class=entry-content><p>Computer Science and Engineering Computer Science (CS) 와 Computer Engineering (CE) 는 서로 연관되어 있지만, 접근 방식과 연구 내용에서 차이가 있다.
Computer Science(CS)는 소프트웨어, 알고리즘, 데이터 구조, 계산 이론 등을 다루는 학문으로 문제를 해결하는 알고리즘의 개발, 데이터 저장 및 처리의 효율성, 언어 설계 등을 연구한다.
Computer Engineering(CE)는 하드웨어와 소프트웨어의 융합을 다루며, 물리적 컴퓨터 시스템과 그 내부 구조, 상호작용 방식을 연구한다. 전자공학과 컴퓨터 과학의 요소를 모두 포함하여 디지털 시스템 설계, 프로세서 설계, 네트워크 등과 같은 물리적 컴퓨터의 구성 요소를 다룬다.
...</p></div><footer class=entry-footer><span title='2024-09-19 15:45:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;740 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Computer Science and Engineering" href=https://buenhyden.github.io/posts/computer-science/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Structures and Algorithms</h2></header><div class=entry-content><p>자료구조와 알고리즘(Data Structures and Algorithms) 자료구조와 알고리즘은 컴퓨터 과학의 핵심 영역으로, 데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문이다.
이 두 가지는 서로 밀접하게 연관되어 있으며, 효율적인 소프트웨어 개발의 기반이 된다.
자료구조와 알고리즘의 관계 자료구조와 알고리즘은 마치 건물과 건축 방법의 관계와 유사하다.
자료구조는 데이터를 저장하는 ‘그릇’이고, 알고리즘은 그 데이터를 처리하는 ‘방법’이다.
적절한 자료구조의 선택은 알고리즘의 효율성에 직접적인 영향을 미치며, 반대로 특정 알고리즘은 특정 자료구조에서 더 효율적으로 작동한다.
예를 들어, 정렬된 배열에서는 이진 탐색 알고리즘이 효율적이지만, 연결 리스트에서는 이진 탐색을 적용하기 어렵다. 이처럼 자료구조와 알고리즘은 서로 상호보완적인 관계에 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 15:45:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;556 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Structures and Algorithms" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backend</h2></header><div class=entry-content><p>Backend 백엔드는 사용자가 직접 보거나 상호작용하지 않는 서버 측(Server-side) 기술과 인프라를 의미한다.
웹사이트나 애플리케이션의 데이터 처리, 비즈니스 로직 실행, 데이터베이스 관리 등을 담당하는 시스템의 뒷단이라고 할 수 있다.
프런트엔드가 사용자 인터페이스를 제공한다면, 백엔드는 이러한 인터페이스가 실제로 작동하는 데 필요한 모든 로직과 데이터 처리를 담당한다.
백엔드의 정의와 역할 백엔드는 다음과 같은 주요 역할을 수행한다:
서버 관리: 웹 서버를 설정하고 관리하여 클라이언트 요청을 처리한다. 데이터 처리: 데이터베이스와 상호작용하여 데이터를 저장, 검색, 관리한다. 비즈니스 로직 구현: 애플리케이션의 핵심 기능과 프로세스를 개발한다. API 개발: 프론트엔드와 백엔드 간의 통신을 위한 API를 설계하고 구현한다. 보안 관리: 사용자 인증, 데이터 암호화 등 보안 관련 기능을 구현한다. 백엔드가 포함하는 주요 분야 서버 사이드 프로그래밍: Java, Python, Ruby, PHP, Node.js 등의 언어를 사용하여 서버 로직을 개발한다. 데이터베이스 관리: MySQL, PostgreSQL, MongoDB 등의 데이터베이스 시스템을 사용하여 데이터를 관리한다. 웹 서버 관리: Apache, Nginx 등의 웹 서버를 설정하고 최적화한다. 클라우드 컴퓨팅: AWS, Azure, Google Cloud 등의 클라우드 플랫폼을 활용하여 서비스를 배포하고 관리한다. 시스템 아키텍처 설계: 확장 가능하고 효율적인 시스템 구조를 설계한다. DevOps: 지속적 통합 및 배포(CI/CD) 파이프라인을 구축하고 관리한다. 성능 최적화: 대규모 트래픽을 처리할 수 있도록 시스템을 최적화한다. Roadmap Roadmap - Backend 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-21 01:29:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;184 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backend" href=https://buenhyden.github.io/posts/backend/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Networking and Communications</h2></header><div class=entry-content><p>Network 연결하는 선이나 장치 같은 물리적인 측면부터 데이터를 주고받는 데에 필요한 메시지나 규약과 같은 비물리적인 측면까지 모두 포함한 통신 과정 전체를 아우르는 개념. 리소스와 정보를 공유하는 상호 연결된 장치의 모음. 영역별 컴퓨터 네트워크 종류 https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC
Nano Network - 나노 네트워크 컴퓨팅, 데이터 저장, 감지 및 작동과 같은 매우 간단한 작업만 수행할 수 있는 상호 연결된 나노머신 (최대 크기가 수백 나노미터 또는 수 마이크로미터인 장치) 의 집합. IEEE P1906.1 에 정의. BAN (Body Area Network) - 인체 통신망, 인체 영역 통신망 착용식 컴퓨팅 장치의 무선 네트워크. PAN (Personal Area Network) - 개인 통신망 개인의 작업 공간을 중심으로 장치들을 서로 연결하기 위한 컴퓨터 네트워크. 원론적으로 개인 통신망은 개인의 주위를 커버하는 컴퓨터 통신망을 의미하므로 데스크톱 환경에서의 주변기기 연결까지도 개인 통신망으로 포함이 가능하지만, 보통의 경우 모바일 컴퓨팅 (Mobile Computing) 이나 웨어러블 컴퓨팅 (Wearable Computing) 적인 성격이 강하고, Bluetooth 나 UWB 등의 기술을 이용하여 개인 휴대 기기 사이에서 구성된 무선 연결망을 의미한다. LAN (Local Area Network) - 근거리 통신망, 로컬 영역 네트워크 네트워크 매체를 이용하여 집, 사무실, 학교 등의 건물과 같은 가까운 지역을 한데 묶는 네트워크. 표준화 기구인 미국 전기전자 기술자협회 (IEEE) 와 국제 표준화 기구 (ISO) 에서는 다음과 같이 정의한다. 한정된 지역에서 컴퓨터를 기본으로 하는 여러 가지 전자기기 사이의 자유로운 정보교환. 구축한 사용자가 직접 관리, 운영함. 서로 다른 밴더의 기기 간에도 통신 가능. CAN (Campus Area Network) - 캠퍼스 통신망 근거리 통신망 간의 데이터 전송을 위해서 구성된 제한된 지역 내의 통신망. MAN (Metropolitan Area Network) - 도시권 통신망 큰 도시 또는 캠퍼스에 퍼져 있는 컴퓨터 네트워크. DSL 전화망, 케이블 TV 네트워크를 통한 인터넷 서비스 제공이 대표적인 예. RAN (Radio Access Network) - 무선접속망 스마트폰과 같은 최종 사용자 기기를 클라우드에 연결하는 모바일 네트워크의 일종. WAN (Wide Area Network) - 광역 통신망 드넓은 지리적 거리/장소를 넘나드는 통신 네트워크 또는 컴퓨터 네트워크. 지역, 국가, 세상 범위까지 구성된 컴퓨터 네트워크로 근거리 통신망 유저들이 다른 지역에 있는 근거리 통신망 사용자들과 데이터 통신을 할 수 있도록 해 준다. SAN (Storage Area Network) - 스토리지 영역 네트워크 블록 수준의 스토리지 공유 네트워크 또는 클라우드 스토리지에 대한 액세스를 제공하는 특수 네트워크. 사용자에게는 컴퓨터에 물리적으로 연결된 스토리지 드라이브처럼 보이고 작동한다. VPN (Virtual Private Network) - 가상 사설망 두 개의 네트워크 엔드포인트를 연결하는 안전한 지점간 연결. 사용자의 신원 및 액세스 자격 증명은 물론 전송되는 모든 데이터를 해커가 액세스할 수 없도록 암호화 채널을 설정한다. Network Topology 네트워크를 배치하는 방식으로, 링크와 노드들이 어떤 식으로 배치되어 서로 연결되는지를 물리적으로 혹은 논리적으로 설명한다. 네트워크가 배치되는 방식은 수없이 많으며, 모두 나름의 장단점이 있고, 특정 상황에 더 유용한 배치 방식이 존재한다. 그러므로 적합한 네트워크 토폴로지를 만들고 관리하기 위한 핵심사항은 목표와 필요조건을 확실히 파악해야 한다. 네트워크 토폴로지의 두가지 범부 물리적 네트워크 토폴로지
- 네트워크가 전선, 케이블 등으로 실제 연결되어 배치된 것을 나타낸다.
- 네트워크 설정, 관리, 권한 설정 작업을 하기 위해서는 물리적 네트워크 토폴로지를 알아야할 필요가 있다. 논리적 네트워크 토폴로지
- 네트워크 설정 방식에 관한 고차원의 개념으로, 어떤 노드가 어떤 방식으로 다른 노드들과 서로 연결되어 있는지, 또한 데이터가 네트워크를 통해 어떻게 전송되는지 등에 의해 결정된다.
- 모든 가상 리소스와 클라우드 리소스가 포함된다. Node (노드)
...</p></div><footer class=entry-footer><span title='2024-10-16 02:03:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1444 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Networking and Communications" href=https://buenhyden.github.io/posts/networking-knowledge/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 (Database)</h2></header><div class=entry-content><p>데이터베이스 (Database) 데이터베이스는 구조화된 정보 또는 데이터의 조직화된 모음으로, 일반적으로 컴퓨터 시스템에 전자적으로 저장된다.
데이터베이스는 데이터를 효율적으로 저장, 관리, 검색할 수 있도록 설계된 시스템으로, 현대 사회에서 정보 관리의 핵심 역할을 담당하고 있다.
특징 데이터 독립성: 물리적 독립성과 논리적 독립성을 제공한다. 데이터 무결성: 데이터의 정확성, 일관성, 유효성을 유지한다. 데이터 보안성: 허가된 사용자만 데이터에 접근할 수 있도록 한다. 데이터 일관성: 데이터의 불일치를 방지한다. 데이터 중복 최소화: 데이터 중복을 줄여 저장 공간을 효율적으로 사용한다. 목적 데이터의 효율적인 저장 및 관리 데이터 접근성 향상 데이터 무결성 보장 데이터 보안 강화 데이터 공유 및 협업 지원 구조 데이터베이스는 일반적으로 다음과 같은 구조를 가진다.
...</p></div><footer class=entry-footer><span title='2024-10-22 19:13:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2095 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 (Database)" href=https://buenhyden.github.io/posts/databases/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DevOps</h2></header><div class=entry-content><p>DevOps 소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론이다.
이 접근 방식은 조직의 소프트웨어 제품과 서비스를 빠르게 개발하고 개선하는 능력을 향상시키는 것을 목표로 한다.
DevOps는 개발팀과 운영팀 간의 협업을 강화하고, 소프트웨어 개발 주기 전반에 걸쳐 자동화와 지속적인 피드백을 통합하는 방식이다.
이는 전통적인 소프트웨어 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있게 한다.
DevOps의 중요성 빠른 시장 출시: DevOps는 지속적 통합(CI)과 지속적 배포(CD)를 통해 소프트웨어 업데이트와 새로운 기능을 빠르고 안정적으로 제공할 수 있게 한다. 품질 향상: 자동화된 테스트와 모니터링을 통해 소프트웨어의 품질과 신뢰성을 높인다. 고객 만족도 증가: 빠른 피드백 루프를 통해 고객의 요구사항에 신속하게 대응할 수 있다. 비용 절감: 프로세스 자동화와 효율적인 리소스 관리를 통해 운영 비용을 줄일 수 있다. DevOps의 주요 특징 협업: 개발팀과 운영팀 간의 긴밀한 협력을 촉진한다. 자동화: 반복적인 작업을 자동화하여 인적 오류를 줄이고 효율성을 높인다. 지속적 통합 및 배포(CI/CD): 코드 변경사항을 자주 통합하고 자동으로 배포한다. 모니터링과 피드백: 실시간으로 애플리케이션 성능을 모니터링하고 빠른 피드백을 제공한다. DevOps의 장점 빠른 제품 출시: 개발 주기를 단축하여 시장 경쟁력을 높인다. 안정성 향상: 자동화된 테스트와 배포로 시스템 안정성이 개선된다. 팀 생산성 증가: 협업 강화와 프로세스 최적화로 팀의 생산성이 향상된다. 비용 효율성: 자동화와 효율적인 리소스 관리로 운영 비용이 절감된다. DevOps의 단점 문화적 변화의 어려움: 기존 조직 문화를 변경하는 데 저항이 있을 수 있다. 초기 투자 비용: 도구와 프로세스 구축에 상당한 초기 투자가 필요할 수 있다. 복잡성: 다양한 도구와 기술을 통합하는 과정에서 복잡성이 증가할 수 있다. 보안 문제: 빠른 배포 주기로 인해 보안 검토가 충분히 이루어지지 않을 수 있다. DevOps의 주요 구성 요소 지속적 통합(CI): 개발자의 코드 변경사항을 정기적으로 통합하고 테스트한다. 코드 버전 관리 자동화된 빌드 자동화된 테스트 코드 품질 분석 지속적 배포(CD): 코드 변경사항을 자동으로 프로덕션 환경에 배포한다. 자동화된 배포 파이프라인 환경 구성 관리 릴리스 관리 롤백 메커니즘 인프라스트럭처 as 코드(IaC): 인프라 구성을 코드로 관리하여 일관성과 확장성을 확보한다. 마이크로서비스: 애플리케이션을 작은 독립적인 서비스로 분할하여 개발과 배포를 용이하게 한다. 모니터링 및 로깅: 시스템 성능과 사용자 행동을 실시간으로 추적하고 분석한다. 성능 모니터링 로그 수집 및 분석 알림 시스템 문제 추적 Roadmap Roadmap - DevOps 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-28 06:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;327 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DevOps" href=https://buenhyden.github.io/posts/devops/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Software Design and Architecture</h2></header><div class=entry-content><p>Software Design and Architecture Software Architecture Software Architecture란 소프트웨어 시스템의 기본적인 구조와 조직을 정의하는 것이다.
이는 시스템의 구성 요소, 그들 간의 관계, 그리고 환경과의 상호작용을 포함한다.
소프트웨어 아키텍처의 기본 개념:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 간단한 계층형 아키텍처 예시 class PresentationLayer: def __init__(self): self.business_layer = BusinessLayer() def handle_user_request(self, request): """사용자 요청을 처리하는 UI 계층""" # 사용자 입력 검증 validated_data = self.validate_input(request) # 비즈니스 계층에 요청 전달 result = self.business_layer.process_request(validated_data) # 결과를 사용자에게 표시 return self.format_response(result) class BusinessLayer: def __init__(self): self.data_layer = DataLayer() def process_request(self, data): """비즈니스 로직을 처리하는 계층""" # 비즈니스 규칙 적용 processed_data = self.apply_business_rules(data) # 데이터 계층과 상호작용 return self.data_layer.store_data(processed_data) class DataLayer: def store_data(self, data): """데이터를 저장하고 관리하는 계층""" # 데이터베이스 작업 수행 return self.save_to_database(data) 아키텍처를 선택할 때 고려해야 할 주요 품질 속성들 확장성 (Scalability)
시스템이 증가하는 부하를 처리할 수 있는 능력: 1 2 3 4 5 6 7 8 9 10 class ScalableService: def __init__(self): self.load_balancer = LoadBalancer() self.service_instances = [] def scale_out(self): """서비스 확장""" new_instance = ServiceInstance() self.service_instances.append(new_instance) self.load_balancer.register(new_instance) 유지보수성 (Maintainability)
시스템을 쉽게 수정하고 확장할 수 있는 능력: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 유지보수가 용이한 모듈식 설계 class PaymentProcessor: def __init__(self): self.payment_methods = {} def register_payment_method(self, method_name, processor): """새로운 결제 방식 추가""" self.payment_methods[method_name] = processor def process_payment(self, method, amount): """결제 처리""" if method in self.payment_methods: return self.payment_methods[method].process(amount) raise ValueError("Unsupported payment method") 성능 (Performance)
시스템의 응답 시간과 처리량: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CachedService: def __init__(self): self.cache = Cache() self.database = Database() def get_data(self, key): """캐시를 통한 성능 최적화""" # 캐시 확인 cached_data = self.cache.get(key) if cached_data: return cached_data # 데이터베이스에서 조회 data = self.database.query(key) self.cache.set(key, data) return data 실제 프로젝트에서 아키텍처를 적용하는 방법 요구사항 분석
시스템의 기능적, 비기능적 요구사항을 파악한다.
...</p></div><footer class=entry-footer><span title='2024-09-20 10:14:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;484 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Design and Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Programming Languages</h2></header><div class=entry-content><p>Programming Languages 프로그래밍 언어는 컴퓨터에게 작업을 지시하기 위한 형식화된 언어.
우리가 일상에서 한국어나 영어를 사용하여 의사소통하는 것처럼, 프로그래머는 프로그래밍 언어를 사용하여 컴퓨터와 ‘대화’한다.
각 프로그래밍 언어는 자신만의 문법 규칙과 구조를 가지고 있으며, 이를 통해 컴퓨터가 수행해야 할 작업을 정확하게 명시할 수 있다.
프로그래밍 언어의 발전 과정 프로그래밍 언어는 컴퓨터의 발전과 함께 진화해왔다.
초기에는 기계어와 어셈블리어같은 저수준 언어만 존재했지만, 시간이 지나면서 인간이 이해하고 작성하기 쉬운 고수준 언어들이 개발되었다.
이는 마치 원시 시대의 단순한 의사소통 방식이 현대의 풍부한 언어 체계로 발전한 것과 유사합니다.
...</p></div><footer class=entry-footer><span title='2024-10-06 10:20:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1066 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Languages" href=https://buenhyden.github.io/posts/programming-languages/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design</h2></header><div class=entry-content><p>System Design 소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정
이는 소프트웨어 개발의 초기 단계에서 이루어지며, 개발자들이 구현할 소프트웨어의 아키텍처, 컴포넌트, 인터페이스, 데이터 모델 및 기타 시스템 구성 요소를 결정하는 데 도움을 준다.
중요성 복잡성 관리: 시스템 디자인은 복잡한 소프트웨어 시스템을 관리 가능한 단위로 분해하고 조직화하는 데 도움을 준다. 유지보수성 향상: 잘 설계된 시스템은 유지보수가 쉽고 변경 사항을 쉽게 적용할 수 있다. 확장성 제공: 좋은 디자인은 시스템이 미래의 요구사항에 맞춰 확장될 수 있도록 한다. 품질 보장: 시스템 디자인은 소프트웨어의 품질 속성(성능, 보안성, 확장성 등)을 고려하여 설계된다. 의사소통 촉진: 시스템 디자인은 개발 팀 간의 의사소통을 돕고, 시스템에 대한 공통된 이해를 제공한다. 소프트웨어 시스템 디자인 원칙 단일 책임 원칙 (SRP): 각 모듈이나 클래스는 하나의 책임만을 가져야 한다. 개방-폐쇄 원칙 (OCP): 소프트웨어 엔티티는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다. 리스코프 치환 원칙 (LSP): 하위 타입은 상위 타입으로 대체 가능해야 한다. 인터페이스 분리 원칙 (ISP): 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다. 의존관계 역전 원칙 (DIP): 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다. 소프트웨어 시스템 디자인의 주요 구성 요소 1. 아키텍처 설계 (Architectural Design) 아키텍처 설계는 소프트웨어의 주요 구조적 요소와 이들 간의 관계를 정의한다.
이는 시스템의 전체적인 구조와 흐름을 묘사하며, 종종 다이어그램을 사용하여 표현된다.
아키텍처 설계는 시스템의 고수준 구조를 결정하고, 주요 컴포넌트들 간의 상호작용 방식을 정의한다.
...</p></div><footer class=entry-footer><span title='2024-11-10 21:24:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;635 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Design" href=https://buenhyden.github.io/posts/system-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IT Security</h2></header><div class=entry-content><p>IT Security 정보 기술 시스템과 데이터를 보호하기 위한 포괄적인 접근 방식으로,조직의 정보 자산을 보호하기 위한 모든 활동과 기술을 포함한다.
정보 보안의 핵심 원칙 기밀성(Confidentiality)
승인되지 않은 사람이 정보를 열람할 수 없도록 하는 원칙. 인가된 사용자만이 정보에 접근할 수 있도록 보장한다. 정보 유출을 방지하는 것이 주요 목표이다. 무결성(Integrity)
승인되지 않은 사람이 정보를 수정할 수 없도록 하는 원칙. 정보가 위변조되거나 손상되지 않도록 보장한다. 정보의 정확성과 완전성을 유지하는 것이 핵심이다. 가용성(Availability)
승인된 사람이 필요할 때 정보를 사용할 수 있도록 하는 원칙. 정보 시스템과 데이터가 필요할 때 접근 가능하도록 보장한다. 서비스 중단이나 데이터 손실을 방지하는 것이 중요하다. 주요 요소 기술적 요소:
...</p></div><footer class=entry-footer><span title='2024-11-06 14:34:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;990 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to IT Security" href=https://buenhyden.github.io/posts/security/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>