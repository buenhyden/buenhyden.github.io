<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>기술 블로그 | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="기술 블로그 - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="기술 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="기술 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>기술 블로그</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Computer Science Fundamentals</h2></header><div class=entry-content><p>Computer Science and Engineering Computer Science (CS) 와 Computer Engineering (CE) 는 서로 연관되어 있지만, 접근 방식과 연구 내용에서 차이가 있다.
Computer Science(CS)는 소프트웨어, 알고리즘, 데이터 구조, 계산 이론 등을 다루는 학문으로 문제를 해결하는 알고리즘의 개발, 데이터 저장 및 처리의 효율성, 언어 설계 등을 연구한다.
Computer Engineering(CE)는 하드웨어와 소프트웨어의 융합을 다루며, 물리적 컴퓨터 시스템과 그 내부 구조, 상호작용 방식을 연구한다. 전자공학과 컴퓨터 과학의 요소를 모두 포함하여 디지털 시스템 설계, 프로세서 설계, 네트워크 등과 같은 물리적 컴퓨터의 구성 요소를 다룬다.
...</p></div><footer class=entry-footer><span title='2024-09-19 01:29:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Computer Science Fundamentals" href=https://buenhyden.github.io/posts/computer-science-fundamentals/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backend Development</h2></header><div class=entry-content><p>Backend Development 백엔드 개발(Backend Development)은 사용자 인터페이스와 직접적으로 상호작용하지 않는 서버 측 애플리케이션 개발을 의미한다. 주로 서버 프로그래밍, 데이터베이스 관리, API 설계 및 구현, 인증/권한 부여, 비즈니스 로직 처리 등을 포함한다.
백엔드 개발자는 프론트엔드와 데이터베이스 사이의 중개자 역할을 수행하며, 시스템의 보안, 확장성, 성능을 관리한다. 다양한 프로그래밍 언어(Java, Python, Node.js 등)와 프레임워크(Spring, Django, Express 등)를 활용하여 안정적이고 효율적인 서버 애플리케이션을 구축한다.
최근에는 클라우드, 마이크로서비스, 서버리스, 인공지능(AI) 등 신기술과 결합해 더욱 복잡하고 확장성 높은 시스템을 구축하는 것이 주요 트렌드이다.
...</p></div><footer class=entry-footer><span title='2024-09-19 01:29:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backend Development" href=https://buenhyden.github.io/posts/backend-development/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Quality Assurance (QA)</h2></header><div class=entry-content><p>Quality Assurance (QA) Quality Assurance(QA)는 소프트웨어 개발 과정에서 제품의 품질을 보장하기 위한 체계적이고 계획된 모든 활동을 의미한다.
IEEE의 공식 정의에 따르면, QA는 “제품이나 서비스가 정의된 품질 요구사항을 충족시킬 것이라는 적절한 신뢰를 제공하기 위해 필요한 모든 계획적이고 체계적인 활동"이다.
QA의 주요 목표 품질 보증
소프트웨어가 요구사항을 충족하고 사용자의 기대에 부응하도록 보장한다.
이는 기능적 요구사항뿐만 아니라 성능, 보안, 사용성 등의 비기능적 요구사항도 포함한다.
결함 예방
개발 초기 단계부터 품질 관리를 시작함으로써, 나중에 발견될 수 있는 심각한 문제들을 사전에 예방한다.
이는 시간과 비용을 절약하는 데 매우 중요하다.
...</p></div><footer class=entry-footer><span title='2024-10-27 19:53:00 +0000 UTC'>October 27, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Quality Assurance (QA)" href=https://buenhyden.github.io/posts/quality-assurance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Software Design and Architecture</h2></header><div class=entry-content><p>Software Design and Architecture Software Architecture Software Architecture란 소프트웨어 시스템의 기본적인 구조와 조직을 정의하는 것이다.
이는 시스템의 구성 요소, 그들 간의 관계, 그리고 환경과의 상호작용을 포함한다.
소프트웨어 아키텍처의 기본 개념:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 간단한 계층형 아키텍처 예시 class PresentationLayer: def __init__(self): self.business_layer = BusinessLayer() def handle_user_request(self, request): """사용자 요청을 처리하는 UI 계층""" # 사용자 입력 검증 validated_data = self.validate_input(request) # 비즈니스 계층에 요청 전달 result = self.business_layer.process_request(validated_data) # 결과를 사용자에게 표시 return self.format_response(result) class BusinessLayer: def __init__(self): self.data_layer = DataLayer() def process_request(self, data): """비즈니스 로직을 처리하는 계층""" # 비즈니스 규칙 적용 processed_data = self.apply_business_rules(data) # 데이터 계층과 상호작용 return self.data_layer.store_data(processed_data) class DataLayer: def store_data(self, data): """데이터를 저장하고 관리하는 계층""" # 데이터베이스 작업 수행 return self.save_to_database(data) 아키텍처를 선택할 때 고려해야 할 주요 품질 속성들 확장성 (Scalability)
시스템이 증가하는 부하를 처리할 수 있는 능력: 1 2 3 4 5 6 7 8 9 10 class ScalableService: def __init__(self): self.load_balancer = LoadBalancer() self.service_instances = [] def scale_out(self): """서비스 확장""" new_instance = ServiceInstance() self.service_instances.append(new_instance) self.load_balancer.register(new_instance) 유지보수성 (Maintainability)
시스템을 쉽게 수정하고 확장할 수 있는 능력: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 유지보수가 용이한 모듈식 설계 class PaymentProcessor: def __init__(self): self.payment_methods = {} def register_payment_method(self, method_name, processor): """새로운 결제 방식 추가""" self.payment_methods[method_name] = processor def process_payment(self, method, amount): """결제 처리""" if method in self.payment_methods: return self.payment_methods[method].process(amount) raise ValueError("Unsupported payment method") 성능 (Performance)
시스템의 응답 시간과 처리량: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class CachedService: def __init__(self): self.cache = Cache() self.database = Database() def get_data(self, key): """캐시를 통한 성능 최적화""" # 캐시 확인 cached_data = self.cache.get(key) if cached_data: return cached_data # 데이터베이스에서 조회 data = self.database.query(key) self.cache.set(key, data) return data 실제 프로젝트에서 아키텍처를 적용하는 방법 요구사항 분석
시스템의 기능적, 비기능적 요구사항을 파악한다.
...</p></div><footer class=entry-footer><span title='2024-09-19 10:14:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Design and Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design</h2></header><div class=entry-content><p>System Design 소프트웨어 시스템 디자인은 소프트웨어의 구조와 동작을 계획하고 정의하는 과정
이는 소프트웨어 개발의 초기 단계에서 이루어지며, 개발자들이 구현할 소프트웨어의 아키텍처, 컴포넌트, 인터페이스, 데이터 모델 및 기타 시스템 구성 요소를 결정하는 데 도움을 준다.
중요성 복잡성 관리: 시스템 디자인은 복잡한 소프트웨어 시스템을 관리 가능한 단위로 분해하고 조직화하는 데 도움을 준다. 유지보수성 향상: 잘 설계된 시스템은 유지보수가 쉽고 변경 사항을 쉽게 적용할 수 있다. 확장성 제공: 좋은 디자인은 시스템이 미래의 요구사항에 맞춰 확장될 수 있도록 한다. 품질 보장: 시스템 디자인은 소프트웨어의 품질 속성(성능, 보안성, 확장성 등)을 고려하여 설계된다. 의사소통 촉진: 시스템 디자인은 개발 팀 간의 의사소통을 돕고, 시스템에 대한 공통된 이해를 제공한다. 소프트웨어 시스템 디자인 원칙 단일 책임 원칙 (SRP): 각 모듈이나 클래스는 하나의 책임만을 가져야 한다. 개방-폐쇄 원칙 (OCP): 소프트웨어 엔티티는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다. 리스코프 치환 원칙 (LSP): 하위 타입은 상위 타입으로 대체 가능해야 한다. 인터페이스 분리 원칙 (ISP): 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다. 의존관계 역전 원칙 (DIP): 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다. 소프트웨어 시스템 디자인의 주요 구성 요소 1. 아키텍처 설계 (Architectural Design) 아키텍처 설계는 소프트웨어의 주요 구조적 요소와 이들 간의 관계를 정의한다.
이는 시스템의 전체적인 구조와 흐름을 묘사하며, 종종 다이어그램을 사용하여 표현된다.
아키텍처 설계는 시스템의 고수준 구조를 결정하고, 주요 컴포넌트들 간의 상호작용 방식을 정의한다.
...</p></div><footer class=entry-footer><span title='2024-09-19 21:24:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Design" href=https://buenhyden.github.io/posts/system-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Programming Languages</h2></header><div class=entry-content><p>Programming Languages 프로그래밍 언어는 컴퓨터에게 작업을 지시하기 위한 형식화된 언어.
우리가 일상에서 한국어나 영어를 사용하여 의사소통하는 것처럼, 프로그래머는 프로그래밍 언어를 사용하여 컴퓨터와 ‘대화’한다.
각 프로그래밍 언어는 자신만의 문법 규칙과 구조를 가지고 있으며, 이를 통해 컴퓨터가 수행해야 할 작업을 정확하게 명시할 수 있다.
프로그래밍 언어의 발전 과정 프로그래밍 언어는 컴퓨터의 발전과 함께 진화해왔다.
초기에는 기계어와 어셈블리어같은 저수준 언어만 존재했지만, 시간이 지나면서 인간이 이해하고 작성하기 쉬운 고수준 언어들이 개발되었다.
이는 마치 원시 시대의 단순한 의사소통 방식이 현대의 풍부한 언어 체계로 발전한 것과 유사합니다.
...</p></div><footer class=entry-footer><span title='2024-09-19 10:20:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Languages" href=https://buenhyden.github.io/posts/programming-languages/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Engineering</h2></header><div class=entry-content><p>Data Engineering Data Engineering은 원시 데이터를 수집, 저장, 처리하여 분석 가능한 형태로 변환하는 과정을 다루는 분야.
이는 데이터 기반 의사결정과 인사이트 도출을 위한 핵심적인 역할을 수행한다.
중요성 비즈니스 의사결정 지원 실시간 데이터 기반 의사결정 예측적 분석 가능 비즈니스 인텔리전스 강화 디지털 트랜스포메이션 촉진 레거시 시스템 현대화 데이터 중심 문화 구축 비즈니스 프로세스 최적화 경쟁 우위 확보 고객 인사이트 발굴 운영 효율성 증대 혁신 기회 포착 발전 방향 기술적 트렌드 클라우드 네이티브: 클라우드 기반 서비스를 활용하여 확장성과 유연성을 높인다. 서버리스 아키텍처 컨테이너화 마이크로서비스 자동화 DataOps MLOps 자동 스케일링 실시간 처리: 데이터를 생성 즉시 분석하여 신속한 대응을 가능하게 한다. 스트림 프로세싱 이벤트 기반 아키텍처 실시간 분석 도메인 트렌드 AI/ML 통합: 인공지능과 머신러닝을 데이터 파이프라인에 통합하여 자동화와 최적화를 강화한다. 자동화된 특성 추출 모델 파이프라인 실시간 예측 데이터 거버넌스: 데이터 보안, 규정 준수, 품질 관리에 대한 중요성이 증가한다. 메타데이터 관리 데이터 카탈로그 규정 준수 데이터 민주화 셀프 서비스 분석 데이터 제품화 데이터 마켓플레이스 데이터 엔지니어링의 주요 구성 요소 . 데이터 아키텍처
...</p></div><footer class=entry-footer><span title='2024-09-19 01:52:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Engineering" href=https://buenhyden.github.io/posts/data-engineering/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>인공지능(Artificial Intelligence, AI)</h2></header><div class=entry-content><p>인공지능(Artificial Intelligence, AI) AI(인공지능)는 인간의 지능을 모방하고 시뮬레이션하는 컴퓨터 시스템과 기계를 만드는 과학 및 기술 분야이다. AI는 학습, 문제 해결, 패턴 인식, 언어 이해 등 인간의 인지 능력을 모방하여 복잡한 작업을 수행할 수 있다.
AI의 정의와 개념 AI는 다음과 같이 정의될 수 있다:
인간의 학습능력, 추론능력, 언어이해능력을 컴퓨터 프로그램으로 구현하는 기술. 인간 지능이 필요하거나 인간이 분석할 수 있는 범위를 벗어난 대규모 데이터를 포함하는 방식으로 추론, 학습 및 행동할 수 있는 컴퓨터와 기계를 만드는 과학. 음성 및 작성된 언어를 확인, 이해, 번역하고 데이터를 분석하며 추천하는 등 다양한 고급 기능을 수행할 수 있게 해주는 기술의 집합. AI의 주요 특징 학습 능력: AI 시스템은 데이터로부터 학습하여 성능을 개선할 수 있다. 추론 및 문제 해결: 복잡한 문제를 분석하고 해결책을 제시할 수 있다. 패턴 인식: 대량의 데이터에서 패턴과 관계를 식별할 수 있다. 자연어 처리: 인간의 언어를 이해하고 생성할 수 있다. 컴퓨터 비전: 이미지와 비디오를 분석하고 이해할 수 있다. AI의 유형 AI는 크게 두 가지 유형으로 분류됩니다:
...</p></div><footer class=entry-footer><span title='2024-09-19 01:29:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인공지능(Artificial Intelligence, AI)" href=https://buenhyden.github.io/posts/ai/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Frontend</h2></header><div class=entry-content><p>Frontend 프론트엔드는 사용자가 직접 보고 상호작용하는 웹사이트나 애플리케이션의 사용자 인터페이스(UI)와 사용자 경험(UX)을 담당하는 부분이다.
쉽게 말해서, 사용자가 화면에서 보고 조작하는 모든 시각적 요소와 상호작용을 구현하는 영역이다.
웹브라우저나 모바일 앱에서 사용자에게 보여지는 모든 것이 프론트엔드의 영역이라고 할 수 있다.
프론트엔드의 정의와 역할 프론트엔드는 다음과 같은 주요 역할을 수행한다:
사용자 인터페이스 구현: 웹사이트의 시각적 요소를 개발한다. 사용자 경험 최적화: 사용하기 쉽고 직관적인 인터페이스를 만든다. 반응형 웹 디자인: 다양한 디바이스에서 일관된 경험을 제공한다. 백엔드와의 통신: API를 통해 서버와 데이터를 주고받는다. 성능 최적화: 웹사이트의 로딩 속도와 반응성을 개선한다. 프론트엔드가 포함하는 주요 분야 HTML: 웹 페이지의 구조를 정의한다. CSS: 웹 페이지의 스타일과 레이아웃을 담당한다. JavaScript: 동적인 기능과 사용자 상호작용을 구현한다. 프레임워크 및 라이브러리: React, Angular, Vue.js 등을 사용하여 개발 효율성을 높인다. 웹 접근성: 모든 사용자가 웹사이트를 이용할 수 있도록 한다. 크로스 브라우징: 다양한 웹 브라우저에서 일관된 경험을 제공한다. 버전 관리: Git 등을 사용하여 코드 변경사항을 관리한다. 테스팅: 사용자 인터페이스의 품질을 보장하기 위한 테스트를 수행한다. 프론트엔드 개발자의 역량 프론트엔드 개발자는 다음과 같은 역량이 필요로 한다:
...</p></div><footer class=entry-footer><span title='2024-09-19 01:30:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Frontend" href=https://buenhyden.github.io/posts/frontend-development/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>