<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>기술 블로그 | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="이 블로그는 인공지능(AI), 백엔드 개발, 클라우드 및 클라우드 네이티브 기술, 컴퓨터 과학 등 다양한 기술 분야에 대한 지식과 통찰을 공유하는 공간입니다. 각 분야의 기초 개념부터 최신 기술 동향, 실무 적용 사례까지 체계적으로 정리되어 있어 학습과 참고 자료로 활용할 수 있습니다. 기술의 이론적 배경뿐만 아니라 실제 구현 방법, 모범 사례, 문제 해결 접근법 등 실용적인 내용도 다루고 있습니다. 끊임없이 발전하는 기술 생태계에서 지속적인 학습과 성장을 위한 지식 허브로 활용하시기 바랍니다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="기술 블로그"><meta property="og:description" content="이 블로그는 인공지능(AI), 백엔드 개발, 클라우드 및 클라우드 네이티브 기술, 컴퓨터 과학 등 다양한 기술 분야에 대한 지식과 통찰을 공유하는 공간입니다. 각 분야의 기초 개념부터 최신 기술 동향, 실무 적용 사례까지 체계적으로 정리되어 있어 학습과 참고 자료로 활용할 수 있습니다. 기술의 이론적 배경뿐만 아니라 실제 구현 방법, 모범 사례, 문제 해결 접근법 등 실용적인 내용도 다루고 있습니다. 끊임없이 발전하는 기술 생태계에서 지속적인 학습과 성장을 위한 지식 허브로 활용하시기 바랍니다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="기술 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>기술 블로그</h1></header><div class=post-content><p>이 블로그는 인공지능(AI), 백엔드 개발, 클라우드 및 클라우드 네이티브 기술, 컴퓨터 과학 등 다양한 기술 분야에 대한 지식과 통찰을 공유하는 공간입니다. 각 분야의 기초 개념부터 최신 기술 동향, 실무 적용 사례까지 체계적으로 정리되어 있어 학습과 참고 자료로 활용할 수 있습니다. 기술의 이론적 배경뿐만 아니라 실제 구현 방법, 모범 사례, 문제 해결 접근법 등 실용적인 내용도 다루고 있습니다. 끊임없이 발전하는 기술 생태계에서 지속적인 학습과 성장을 위한 지식 허브로 활용하시기 바랍니다.</p></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Infrastructure</h2></header><div class=entry-content><p>Infrastructure Infrastructure(인프라스트럭처)는 조직의 IT 환경을 지원하고 운영하는 데 필요한 기본적인 구성 요소들의 집합이다.
이는 하드웨어, 소프트웨어, 네트워크 리소스 및 서비스를 포함한다.
Infrastructure의 주요 구성 요소 하드웨어
서버: 네트워크 저장소 및 애플리케이션 처리를 제공 스토리지 장치: 하드 드라이브, SSD 등 네트워킹 장비: 라우터, 스위치, 케이블 등 데이터 센터: 중요한 IT 장비와 지원 인프라를 수용하는 시설 소프트웨어
운영 체제: 하드웨어 운영 및 애플리케이션 실행의 기반 데이터베이스: 대량의 데이터를 조직, 저장 및 접근 용이하게 함 미들웨어: 소프트웨어 애플리케이션 간 통신 및 데이터 교환을 위한 연결 계층 네트워크 인프라
...</p></div><footer class=entry-footer><span title='2024-11-10 01:29:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Infrastructure" href=https://buenhyden.github.io/posts/cloud-and-devops/fundamentals/infrastructure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)</h2></header><div class=entry-content><p>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE) 사이트 신뢰성 엔지니어링(Site Reliability Engineering, SRE)은 IT 운영에 대한 소프트웨어 엔지니어링 접근 방식이다.
이 개념은 Google의 Ben Treynor Sloss가 2003년에 창안했으며, 소프트웨어 시스템의 안정성과 신뢰성을 유지하고 향상시키는 것을 목표로 한다.
예시를 들어, 설명해보면:
온라인 쇼핑몰을 운영하는 회사에서 SRE 팀이 다음과 같은 작업을 수행할 수 있다:
서비스 수준 목표 설정: 웹사이트 가용성 99.99%, 페이지 로드 시간 2초 이내 등의 목표를 정한다. 모니터링 시스템 구축: 실시간으로 웹사이트 트래픽, 서버 성능, 주문 처리 속도 등을 모니터링하는 대시보드를 만든다. 자동화: 서버 프로비저닝, 데이터베이스 백업, 보안 패치 적용 등의 작업을 자동화하는 스크립트를 개발한다. 장애 대응: 블랙프라이데이와 같은 대규모 세일 기간 동안 급증하는 트래픽에 대비한 대응 계획을 수립하고, 실제 장애 발생 시 신속하게 대응한다. 성능 최적화: 데이터베이스 쿼리 최적화, 캐싱 전략 수립, CDN 활용 등을 통해 웹사이트 성능을 지속적으로 개선한다. SRE는 개발팀과 운영팀 사이의 가교 역할을 하며, 소프트웨어의 안정성과 확장성을 보장하는 동시에 새로운 기능의 빠른 출시를 가능하게 한다.
이를 통해 기업은 고객에게 더 나은 서비스를 제공하고 비즈니스 목표를 달성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:18:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)" href=https://buenhyden.github.io/posts/cloud-and-devops/site-reliability-engineering/sre/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DevOps</h2></header><div class=entry-content><p>DevOps 소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 문화, 철학, 방법론이다.
이 접근 방식은 조직의 소프트웨어 제품과 서비스를 빠르게 개발하고 개선하는 능력을 향상시키는 것을 목표로 한다.
DevOps는 개발팀과 운영팀 간의 협업을 강화하고, 소프트웨어 개발 주기 전반에 걸쳐 자동화와 지속적인 피드백을 통합하는 방식이다.
이는 전통적인 소프트웨어 개발 및 인프라 관리 프로세스를 사용하는 조직보다 제품을 더 빠르게 혁신하고 개선할 수 있게 한다.
DevOps의 중요성 빠른 시장 출시: DevOps는 지속적 통합(CI)과 지속적 배포(CD)를 통해 소프트웨어 업데이트와 새로운 기능을 빠르고 안정적으로 제공할 수 있게 한다. 품질 향상: 자동화된 테스트와 모니터링을 통해 소프트웨어의 품질과 신뢰성을 높인다. 고객 만족도 증가: 빠른 피드백 루프를 통해 고객의 요구사항에 신속하게 대응할 수 있다. 비용 절감: 프로세스 자동화와 효율적인 리소스 관리를 통해 운영 비용을 줄일 수 있다. DevOps의 주요 특징 협업: 개발팀과 운영팀 간의 긴밀한 협력을 촉진한다. 자동화: 반복적인 작업을 자동화하여 인적 오류를 줄이고 효율성을 높인다. 지속적 통합 및 배포(CI/CD): 코드 변경사항을 자주 통합하고 자동으로 배포한다. 모니터링과 피드백: 실시간으로 애플리케이션 성능을 모니터링하고 빠른 피드백을 제공한다. DevOps의 장점 빠른 제품 출시: 개발 주기를 단축하여 시장 경쟁력을 높인다. 안정성 향상: 자동화된 테스트와 배포로 시스템 안정성이 개선된다. 팀 생산성 증가: 협업 강화와 프로세스 최적화로 팀의 생산성이 향상된다. 비용 효율성: 자동화와 효율적인 리소스 관리로 운영 비용이 절감된다. DevOps의 단점 문화적 변화의 어려움: 기존 조직 문화를 변경하는 데 저항이 있을 수 있다. 초기 투자 비용: 도구와 프로세스 구축에 상당한 초기 투자가 필요할 수 있다. 복잡성: 다양한 도구와 기술을 통합하는 과정에서 복잡성이 증가할 수 있다. 보안 문제: 빠른 배포 주기로 인해 보안 검토가 충분히 이루어지지 않을 수 있다. DevOps의 주요 구성 요소 지속적 통합(CI): 개발자의 코드 변경사항을 정기적으로 통합하고 테스트한다. 코드 버전 관리 자동화된 빌드 자동화된 테스트 코드 품질 분석 지속적 배포(CD): 코드 변경사항을 자동으로 프로덕션 환경에 배포한다. 자동화된 배포 파이프라인 환경 구성 관리 릴리스 관리 롤백 메커니즘 인프라스트럭처 as 코드(IaC): 인프라 구성을 코드로 관리하여 일관성과 확장성을 확보한다. 마이크로서비스: 애플리케이션을 작은 독립적인 서비스로 분할하여 개발과 배포를 용이하게 한다. 모니터링 및 로깅: 시스템 성능과 사용자 행동을 실시간으로 추적하고 분석한다. 성능 모니터링 로그 수집 및 분석 알림 시스템 문제 추적 Roadmap Roadmap - DevOps 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-28 06:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DevOps" href=https://buenhyden.github.io/posts/cloud-and-devops/devops/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud vs. On-Premise</h2></header><div class=entry-content><p>Cloud vs. On-Premise Cloud와 On-Premise는 기업의 IT 인프라를 구축하고 관리하는 두 가지 주요 방식을 설명하는 개념이다.
이 두 방식은 데이터 저장, 애플리케이션 호스팅, 그리고 전반적인 IT 리소스 관리에 있어 근본적인 차이를 보인다.
비교 항목 On-Premise 클라우드 초기 구축 비용 - 서버, 네트워크 장비 등 높은 초기 투자 필요
- 데이터센터 구축 비용 발생
- 소프트웨어 라이선스 구매 필요 - 초기 투자 비용 최소화
- 필요한 만큼만 시작 가능
- 하드웨어 구매 불필요 운영 비용 - 예측 가능한 고정 비용
- 전담 IT 인력 필요
- 전기, 냉각 등 관리 비용 발생 - 사용량 기반 과금
- 탄력적인 비용 구조
- 운영 인력 최소화 가능 확장성 - 물리적 인프라 확장 필요
- 확장 시 많은 시간과 비용 소요
- 사전 용량 계획 중요 - 필요에 따라 즉시 확장 가능
- 자동 확장/축소 지원
- 글로벌 확장 용이 보안 - 물리적 보안 직접 통제
- 데이터 위치 완벽 통제
- 자체 보안 정책 수립 가능 - 서비스 제공자의 보안 정책 따름
- 공유 인프라 사용
- 데이터 위치 선택 제한적 유지보수 - 모든 유지보수 직접 담당
- 정기적인 하드웨어 교체 필요
- 패치/업그레이드 직접 관리 - 서비스 제공자가 유지보수 담당
- 자동 업데이트/패치 적용
- 최신 기술 자동 적용 커스터마이징 - 완전한 커스터마이징 자유
- 하드웨어/소프트웨어 직접 선택
- 특수 요구사항 수용 용이 - 제한된 커스터마이징
- 제공되는 서비스 내에서 선택
- 표준화된 서비스 위주 가용성 - 자체 인프라로 안정성 확보
- 인터넷 연결 없이도 운영 가능
- 장애 대응 직접 수행 - 서비스 제공자의 SLA 따름
- 인터넷 연결 필수
- 여러 지역 동시 운영 가능 데이터 주권 - 완벽한 데이터 통제권 보유
- 물리적 데이터 위치 확실
- 규제 준수 용이 - 데이터 주권 일부 제한
- 국가간 데이터 이동 가능
- 규제 준수 확인 필요 접근성 - 내부 네트워크 중심
- 원격 접속 별도 구성 필요
- 물리적 접근 통제 가능 - 언제 어디서나 접근 가능
- 다양한 디바이스 지원
- 글로벌 접근성 우수 재해 복구 - 별도의 재해복구 센터 필요
- 높은 구축/운영 비용
- 복구 절차 직접 수행 - 자동화된 백업/복구
- 여러 지역 복제 용이
- 신속한 재해 복구 적합한 상황 - 높은 보안이 필요한 경우
- 특수한 규제 준수 필요
- 레거시 시스템 운영 - 빠른 시작이 필요한 경우
- 유연한 확장성 필요
- 글로벌 서비스 제공 실제로는 많은 기업들이 두 방식의 장점을 모두 활용하는 하이브리드 형태를 채택하고 있다.
기업의 특성, 요구사항, 예산 등을 종합적으로 고려하여 적절한 방식을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-10 10:33:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud vs. On-Premise" href=https://buenhyden.github.io/posts/cloud-and-devops/fundamentals/cloud-vs-on-premise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>온프레미스(On-Premise)</h2></header><div class=entry-content><p>온프레미스(On-Premise) On-Premise는 기업이 자체적으로 보유한 시설이나 건물에 IT 인프라를 구축하고 운영하는 방식을 의미한다.
‘현장에서’ 또는 ‘사내에서’라는 뜻의 이 용어는, 기업이 서버, 소프트웨어, 네트워크 등의 IT 자원을 직접 소유하고 관리하는 전통적인 방식을 설명한다.
On-Premise의 주요 특징 자체 인프라 구축과 관리
기업은 모든 하드웨어와 소프트웨어를 직접 구매하고 설치한다.
서버실을 운영하고, 네트워크를 구성하며, 필요한 보안 시스템을 구축한다.
이는 완전한 통제권을 가질 수 있다는 장점이 있지만, 동시에 많은 초기 투자와 지속적인 관리가 필요하다.
데이터 보안과 통제
모든 데이터가 기업 내부에 저장되고 관리되므로, 데이터 보안에 대한 완전한 통제권을 갖는다.
특히 금융기관이나 정부기관처럼 높은 수준의 보안이 요구되는 조직에서 선호하는 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-10 10:29:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 온프레미스(On-Premise)" href=https://buenhyden.github.io/posts/cloud-and-devops/fundamentals/on-premise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IaaS and PaaS and SaaS</h2></header><div class=entry-content><p>IaaS and PaaS and SaaS https://macronetservices.com/iaas-vs-paas-vs-saas-the-ultimate-guide-for-2021/
IaaS, PaaS, SaaS는 클라우드 컴퓨팅의 주요 서비스 모델이다.
IaaS (Infrastructure as a Service):
IaaS는 가상화된 컴퓨팅 리소스를 인터넷을 통해 제공한다.
사용자는 서버, 스토리지, 네트워크 등의 IT 인프라를 필요에 따라 사용할 수 있다.
IaaS의 주요 특징은 유연성, 확장성, 비용 효율성이다.
사용자는 필요한 만큼의 리소스를 동적으로 할당받고, 사용한 만큼만 비용을 지불한다.
PaaS (Platform as a Service):
PaaS는 애플리케이션을 개발, 실행, 관리할 수 있는 플랫폼을 제공한다.
개발자는 기본 인프라를 관리할 필요 없이 애플리케이션 개발에 집중할 수 있다.
PaaS는 개발 도구, 데이터베이스 관리, 비즈니스 인텔리전스 서비스 등을 제공하여 개발 프로세스를 간소화한다.
...</p></div><footer class=entry-footer><span title='2024-11-10 06:45:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to IaaS and PaaS and SaaS" href=https://buenhyden.github.io/posts/cloud-and-devops/fundamentals/iaas-paas-saas/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud</h2></header><div class=entry-content><p>Cloud 클라우드 컴퓨팅은 컴퓨팅 리소스(서버, 스토리지, 데이터베이스, 네트워킹, 소프트웨어 등)를 인터넷을 통해 필요에 따라 제공하고 사용하는 기술.
사용자는 물리적인 하드웨어나 데이터 센터를 직접 관리할 필요 없이, 필요한 만큼의 리소스를 사용하고 그에 따른 비용만 지불하면 된다.
서비스 유형 IaaS (Infrastructure as a Service) 가상 서버, 스토리지, 네트워크 등 기본적인 컴퓨팅 인프라를 제공 예시: AWS EC2, Google Compute Engine, Azure Virtual Machines 사용자가 운영체제부터 직접 관리 가능하며 가장 유연한 형태의 클라우드 서비스 PaaS (Platform as a Service) 애플리케이션을 개발, 실행, 관리할 수 있는 플랫폼 제공 예시: Heroku, Google App Engine, Azure App Service 개발자가 인프라 걱정 없이 애플리케이션 개발에 집중 가능 SaaS (Software as a Service) 완성된 소프트웨어를 인터넷을 통해 제공 예시: Google Workspace, Microsoft 365, Salesforce 사용자는 소프트웨어를 설치하거나 관리할 필요 없이 바로 사용 가능 클라우드 배포 모델 퍼블릭 클라우드 AWS, Google Cloud, Azure와 같은 공개 클라우드 서비스 누구나 사용 가능하며 리소스를 공유하는 형태 비용 효율적이지만 보안과 규정 준수에 제약이 있을 수 있음 프라이빗 클라우드 조직 내부에서만 사용하는 클라우드 환경 보안과 규정 준수가 중요한 기업에서 선호 직접 구축하고 관리해야 하므로 비용이 높음 하이브리드 클라우드 퍼블릭과 프라이빗 클라우드를 함께 사용 상황에 따라 유연하게 리소스 활용 가능 복잡한 관리가 필요하지만 장점을 최대한 활용 가능 클라우드의 주요 특징 탄력성과 확장성 필요에 따라 리소스를 즉시 확장하거나 축소 가능 자동 확장 기능으로 수요 변화에 대응 예시: 트래픽 급증 시 자동으로 서버 증설 종량제 과금 실제 사용한 리소스에 대해서만 비용 지불 초기 투자 비용 최소화 비즈니스 성장에 따라 유연하게 비용 조절 고가용성 여러 지역에 분산된 데이터 센터 자동 백업과 재해 복구 기능 서비스 중단 위험 최소화 자동화 리소스 프로비저닝 자동화 모니터링과 알림 자동화 운영 효율성 향상 클라우드의 활용 사례 웹 애플리케이션 호스팅
...</p></div><footer class=entry-footer><span title='2024-11-10 06:03:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud" href=https://buenhyden.github.io/posts/cloud-and-devops/cloud/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Observability vs. Monitoring</h2></header><div class=entry-content><p>Observability vs. Monitoring 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observability vs. Monitoring" href=https://buenhyden.github.io/posts/cloud-and-devops/monitoring-and-observability/observability-vs-monitoring/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Version Control Systems</h2></header><div class=entry-content><p>Version Control Systems 파일의 변경 이력을 시간에 따라 기록하여, 특정 시점의 버전을 다시 꺼내올 수 있는 시스템.
소프트웨어 소스 코드뿐만 아니라, 그래픽 디자이너나 웹 디자이너가 작업하는 이미지나 레이아웃 등 거의 모든 컴퓨터 파일의 버전을 관리할 수 있다.
기능 이전 상태로 되돌리기:각 파일이나 전체 프로젝트를 이전 상태로 복원할 수 있다. 변경 내용 비교: 시간에 따른 수정 내용을 비교하여, 누가 언제 어떤 변경을 했는지 추적할 수 있다. 문제 원인 파악: 문제를 일으킨 변경 사항을 추적하여, 누가 언제 이슈를 발생시켰는지 알 수 있다. 복구 용이성: 파일을 잃어버리거나 잘못 수정했을 때도 쉽게 복구할 수 있다. 종류 로컬 버전관리(Local VCS) 데이터베이스를 사용해서 파일의 변경 정보를 관리하는 시스템
RCS(Revision Control System)은 파일에서 변경되는 부분(Patch)만 기억해 용량 문제를 해결
RCS에서 버전 변경은 해당 버전까지의 일련의 변화들(Patch Set)을 적용/해제하는 식으로 동작
...</p></div><footer class=entry-footer><span title='2024-09-28 15:45:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Version Control Systems" href=https://buenhyden.github.io/posts/cloud-and-devops/version-control-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Structures and Algorithms</h2></header><div class=entry-content><p>자료구조와 알고리즘(Data Structures and Algorithms) 자료구조와 알고리즘은 컴퓨터 과학의 핵심 영역으로, 데이터를 효율적으로 저장, 관리, 처리하는 방법에 관한 학문이다.
이 두 가지는 서로 밀접하게 연관되어 있으며, 효율적인 소프트웨어 개발의 기반이 된다.
자료구조와 알고리즘의 관계 자료구조와 알고리즘은 마치 건물과 건축 방법의 관계와 유사하다.
자료구조는 데이터를 저장하는 ‘그릇’이고, 알고리즘은 그 데이터를 처리하는 ‘방법’이다.
적절한 자료구조의 선택은 알고리즘의 효율성에 직접적인 영향을 미치며, 반대로 특정 알고리즘은 특정 자료구조에서 더 효율적으로 작동한다.
예를 들어, 정렬된 배열에서는 이진 탐색 알고리즘이 효율적이지만, 연결 리스트에서는 이진 탐색을 적용하기 어렵다. 이처럼 자료구조와 알고리즘은 서로 상호보완적인 관계에 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 15:45:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Structures and Algorithms" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>