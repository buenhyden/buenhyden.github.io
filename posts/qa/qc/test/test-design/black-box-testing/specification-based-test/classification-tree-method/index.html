<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>분류 트리 방법 (Classification Tree Method) | hyunyoun's Blog</title>
<meta name=keywords content="Quality-Assurance,Quality-Control,QA,QC,Test,Test-Design,Black-box-Testing,Specification-based-Test,CTM,Classification-Tree-Method"><meta name=description content="CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="분류 트리 방법 (Classification Tree Method)"><meta property="og:description" content="CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-11T09:58:00+00:00"><meta property="article:modified_time" content="2024-12-11T09:58:00+00:00"><meta property="article:tag" content="Quality-Assurance"><meta property="article:tag" content="Quality-Control"><meta property="article:tag" content="QA"><meta property="article:tag" content="QC"><meta property="article:tag" content="Test"><meta property="article:tag" content="Test-Design"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="분류 트리 방법 (Classification Tree Method)"><meta name=twitter:description content="CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Quality Assurance (QA)","item":"https://buenhyden.github.io/posts/qa/"},{"@type":"ListItem","position":3,"name":"Quality Control","item":"https://buenhyden.github.io/posts/qa/qc/"},{"@type":"ListItem","position":4,"name":"Test","item":"https://buenhyden.github.io/posts/qa/qc/test/"},{"@type":"ListItem","position":5,"name":"Test Design","item":"https://buenhyden.github.io/posts/qa/qc/test/test-design/"},{"@type":"ListItem","position":6,"name":"Black-box Testing","item":"https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/"},{"@type":"ListItem","position":7,"name":"Specification-based Test","item":"https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/"},{"@type":"ListItem","position":8,"name":"분류 트리 방법 (Classification Tree Method)","item":"https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"분류 트리 방법 (Classification Tree Method)","name":"분류 트리 방법 (Classification Tree Method)","description":"CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.","keywords":["Quality-Assurance","Quality-Control","QA","QC","Test","Test-Design","Black-box-Testing","Specification-based-Test","CTM","Classification-Tree-Method"],"articleBody":"분류 트리 방법 (Classification Tree Method, CTM) CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.\n분류 트리 방법은 테스트 대상 시스템의 입력 도메인을 여러 분류(Classifications)로 나누고, 각 분류 아래에 클래스(Classes)들을 정의하는 방식으로 작동한다.\n여기서 분류는 테스트할 특성이나 매개변수를 의미하고, 클래스는 그 특성이 가질 수 있는 구체적인 값들을 의미한다.\n예를 들어, 온라인 쇼핑몰의 주문 시스템을 테스트한다고 가정해보자:\n분류: 결제 방법\n클래스: 신용카드, 계좌이체, 휴대폰 결제 분류: 배송 옵션\n클래스: 일반배송, 특급배송, 해외배송 분류: 주문 금액\n클래스: 1만원 미만, 1-5만원, 5만원 이상 주요 단계 분류(Classification): 테스트 관련 측면(classifications)과 해당 값(classes)을 식별한다. 조합(Combination): 다양한 분류의 클래스들을 조합하여 테스트 케이스를 생성한다. 명세(Specification): 생성된 조합을 바탕으로 실제 테스트 케이스를 작성한다. 특징 블랙박스 테스팅 방법으로, 다양한 유형의 시스템에 적용 가능하다. 등가 분할(Equivalence Partitioning)과 경계값 분석(Boundary Value Analysis) 원칙을 활용한다. 그래픽 기반 기법으로, 루트, 브랜치, 리프로 구성된 트리 구조를 사용한다. 테스트 케이스 간의 관계를 시각적으로 표현하여 테스트 커버리지를 쉽게 이해할 수 있다. 장점 체계적인 접근: 테스트 프로세스에 구조화된 접근 방식을 제공한다. 효율성: 테스트 케이스 설계와 생성 과정을 효율적으로 만든다. 가시성: 테스트 케이스 간의 관계를 시각적으로 표현하여 이해도를 높인다. 최근 발전 우선순위 기반 테스트 케이스 생성: 요소에 가중치를 할당하여 테스트 케이스의 우선순위를 결정할 수 있다. 테스트 시퀀스 생성: 클래스 간 유효한 전이를 정의하여 자동으로 테스트 시퀀스를 생성할 수 있다. CTM은 테스트 설계를 체계화하고 효율화하는 강력한 도구이지만, 복잡한 시스템에서는 트리가 매우 복잡해질 수 있다는 점에 유의해야 한다.\n따라서 적절한 수준의 추상화와 분류가 중요하다.\n참고 및 출처 ","wordCount":"238","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-11T09:58:00Z","dateModified":"2024-12-11T09:58:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/qa/>Quality Assurance (QA)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/qa/qc/>Quality Control</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/qa/qc/test/>Test</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/qa/qc/test/test-design/>Test Design</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/>Black-box Testing</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/>Specification-based Test</a></div><h1 class="post-title entry-hint-parent">분류 트리 방법 (Classification Tree Method)</h1><div class=post-description>CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.</div><div class=post-meta><span title='2024-12-11 09:58:00 +0000 UTC'>December 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;238 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#분류-트리-방법-classification-tree-method-ctm>분류 트리 방법 (Classification Tree Method, CTM)</a><ul><li><a href=#주요-단계>주요 단계</a></li><li><a href=#특징>특징</a></li><li><a href=#장점>장점</a></li><li><a href=#최근-발전>최근 발전</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=분류-트리-방법-classification-tree-method-ctm>분류 트리 방법 (Classification Tree Method, CTM)<a hidden class=anchor aria-hidden=true href=#분류-트리-방법-classification-tree-method-ctm>#</a></h2><p>CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.</p><p>분류 트리 방법은 테스트 대상 시스템의 입력 도메인을 여러 분류(Classifications)로 나누고, 각 분류 아래에 클래스(Classes)들을 정의하는 방식으로 작동한다.<br>여기서 분류는 테스트할 특성이나 매개변수를 의미하고, 클래스는 그 특성이 가질 수 있는 구체적인 값들을 의미한다.</p><p>예를 들어, 온라인 쇼핑몰의 주문 시스템을 테스트한다고 가정해보자:</p><ol><li><p>분류: 결제 방법</p><ul><li>클래스: 신용카드, 계좌이체, 휴대폰 결제</li></ul></li><li><p>분류: 배송 옵션</p><ul><li>클래스: 일반배송, 특급배송, 해외배송</li></ul></li><li><p>분류: 주문 금액</p><ul><li>클래스: 1만원 미만, 1-5만원, 5만원 이상</li></ul></li></ol><h3 id=주요-단계>주요 단계<a hidden class=anchor aria-hidden=true href=#주요-단계>#</a></h3><ol><li>분류(Classification): 테스트 관련 측면(classifications)과 해당 값(classes)을 식별한다.</li><li>조합(Combination): 다양한 분류의 클래스들을 조합하여 테스트 케이스를 생성한다.</li><li>명세(Specification): 생성된 조합을 바탕으로 실제 테스트 케이스를 작성한다.</li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>블랙박스 테스팅 방법으로, 다양한 유형의 시스템에 적용 가능하다.</li><li>등가 분할(Equivalence Partitioning)과 경계값 분석(Boundary Value Analysis) 원칙을 활용한다.</li><li>그래픽 기반 기법으로, 루트, 브랜치, 리프로 구성된 트리 구조를 사용한다.</li><li>테스트 케이스 간의 관계를 시각적으로 표현하여 테스트 커버리지를 쉽게 이해할 수 있다.</li></ul><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>체계적인 접근: 테스트 프로세스에 구조화된 접근 방식을 제공한다.</li><li>효율성: 테스트 케이스 설계와 생성 과정을 효율적으로 만든다.</li><li>가시성: 테스트 케이스 간의 관계를 시각적으로 표현하여 이해도를 높인다.</li></ol><h3 id=최근-발전>최근 발전<a hidden class=anchor aria-hidden=true href=#최근-발전>#</a></h3><ol><li>우선순위 기반 테스트 케이스 생성: 요소에 가중치를 할당하여 테스트 케이스의 우선순위를 결정할 수 있다.</li><li>테스트 시퀀스 생성: 클래스 간 유효한 전이를 정의하여 자동으로 테스트 시퀀스를 생성할 수 있다.</li></ol><p>CTM은 테스트 설계를 체계화하고 효율화하는 강력한 도구이지만, 복잡한 시스템에서는 트리가 매우 복잡해질 수 있다는 점에 유의해야 한다.<br>따라서 적절한 수준의 추상화와 분류가 중요하다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/quality-assurance/>Quality-Assurance</a></li><li><a href=https://buenhyden.github.io/tags/quality-control/>Quality-Control</a></li><li><a href=https://buenhyden.github.io/tags/qa/>QA</a></li><li><a href=https://buenhyden.github.io/tags/qc/>QC</a></li><li><a href=https://buenhyden.github.io/tags/test/>Test</a></li><li><a href=https://buenhyden.github.io/tags/test-design/>Test-Design</a></li><li><a href=https://buenhyden.github.io/tags/black-box-testing/>Black-Box-Testing</a></li><li><a href=https://buenhyden.github.io/tags/specification-based-test/>Specification-Based-Test</a></li><li><a href=https://buenhyden.github.io/tags/ctm/>CTM</a></li><li><a href=https://buenhyden.github.io/tags/classification-tree-method/>Classification-Tree-Method</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/metamorphic-testing/><span class=title>« Prev</span><br><span>Metamorphic Testing</span>
</a><a class=next href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/equivalence-partitioning/><span class=title>Next »</span><br><span>Equivalence Partitioning</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>