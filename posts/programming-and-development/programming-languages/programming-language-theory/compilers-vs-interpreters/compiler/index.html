<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>컴파일러(Compiler) | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Compiler"><meta name=description content="우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="컴파일러(Compiler)"><meta property="og:description" content="우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="컴파일러(Compiler)"><meta name=twitter:description content="우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"컴파일러(Compiler)","item":"https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>컴파일러(Compiler)</h1><div class=post-description>우리가 작성한 프로그래밍 언어(고급 언어)를 컴퓨터가 이해할 수 있는 기계어(저급 언어)로 번역해주는 특별한 프로그램</div></header><div class=post-content><h2 id=컴파일러compiler>컴파일러(Compiler)<a hidden class=anchor aria-hidden=true href=#컴파일러compiler>#</a></h2><p>컴파일러는 프로그래밍 언어로 작성된 소스 코드를 다른 프로그래밍 언어나 기계어로 변환하는 소프트웨어이다.<br>특히 고수준 프로그래밍 언어(C, Java, Python 등)를 컴퓨터가 직접 실행할 수 있는 저수준 언어(기계어, 바이트코드)로 변환하는 역할을 한다.<br>컴파일러는 단순 변환 이상의 기능을 수행하며, 코드의 오류 체크, 최적화, 그리고 다양한 시스템에 맞는 코드 생성 등을 담당한다.</p><p>컴파일러는 고수준 언어로 작성된 코드를 효율적인 기계어로 변환하는 복잡한 과정을 수행한다.<br>컴파일러의 설계와 구현은 컴퓨터 과학의 여러 분야(형식 언어 이론, 알고리즘, 최적화 기법 등)를 아우르는 종합적인 주제이다.</p><p>최신 컴파일러는 단순히 코드를 변환하는 것을 넘어 코드 분석, 최적화, 특정 하드웨어를 위한 맞춤형 코드 생성 등 더욱 복잡하고 다양한 기능을 제공한다.<br>LLVM과 같은 현대적인 컴파일러 인프라는 언어와 하드웨어 플랫폼 간의 다리 역할을 하며, 새로운 언어와 하드웨어의 개발을 가속화하고 있다.</p><h3 id=컴파일러의-기본-구조>컴파일러의 기본 구조<a hidden class=anchor aria-hidden=true href=#컴파일러의-기본-구조>#</a></h3><p>컴파일러는 일반적으로 다음과 같은 단계로 작동한다:</p><ol><li><strong>어휘 분석 (Lexical Analysis)</strong>: 소스 코드를 토큰(token)이라 불리는 의미 있는 단위로 분해한다.<br>예: <code>int a = 10;</code> → <code>int</code>, <code>a</code>, <code>=</code>, <code>10</code>, <code>;</code></li><li><strong>구문 분석 (Syntax Analysis)</strong>: 토큰을 언어의 문법에 따라 분석하여 구문 트리(parse tree)를 생성한다.<br>예: <code>if (x > 5) { y = 10; }</code> → 트리 형태로 변환</li><li><strong>의미 분석 (Semantic Analysis)</strong>: 구문적으로 올바른 프로그램이 의미적으로도 올바른지 검사한다.<br>예: <code>int x = "hello";</code> → 타입 오류 감지</li><li><strong>중간 코드 생성 (Intermediate Code Generation)</strong>: 소스 코드의 추상적 표현을 생성한다.<br>예: x86과 ARM 모두에서 실행 가능하도록 중간 코드로 변환</li><li><strong>코드 최적화 (Code Optimization)</strong>: 중간 코드를 개선하여 더 효율적인 코드를 생성한다.<br>예: 불필요한 연산 제거, 루프 최적화</li><li><strong>코드 생성 (Code Generation)</strong>: 최적화된 중간 코드를 대상 언어(기계어)로 변환한다.<br>예: <code>mov eax, 10</code> (x86 어셈블리 코드)</li></ol><table><thead><tr><th>단계</th><th>주요 작업 및 목표</th></tr></thead><tbody><tr><td>어휘 분석 (Lexical Analysis)</td><td>소스 코드를 토큰으로 분해하여 기본 단위를 생성</td></tr><tr><td>구문 분석 (Syntax Analysis)</td><td>토큰들을 문법 규칙에 따라 분석하고 파스 트리(구문 트리)를 생성</td></tr><tr><td>의미 분석 (Semantic Analysis)</td><td>파스 트리의 의미를 해석하고 타입 검사 및 오류 확인 수행</td></tr><tr><td>중간 코드 생성 (Intermediate Code Generation)</td><td>플랫폼 독립적인 중간 표현(IR)로 변환하여 후속 최적화 지원</td></tr><tr><td>코드 최적화 (Code Optimization)</td><td>IR의 효율성을 증대시키기 위해 불필요한 부분 제거 및 개선 작업 수행</td></tr><tr><td>코드 생성 (Code Generation)</td><td>최적화된 IR을 대상 시스템의 기계어 코드로 변환하여 실행 파일 생성</td></tr></tbody></table><h3 id=컴파일러의-아키텍처>컴파일러의 아키텍처<a hidden class=anchor aria-hidden=true href=#컴파일러의-아키텍처>#</a></h3><p>컴파일러 설계는 일반적으로 세 부분으로 구성된다:</p><ul><li><strong>전면부(Front End)</strong>:<br>렉시컬 분석, 구문 분석, 의미 분석을 통해 소스 코드의 문법과 의미를 검증하고, 중간 표현(IR)을 생성한다.</li><li><strong>중간부(Middle End)</strong>:<br>생성된 IR에 대해 플랫폼 독립적인 최적화 작업을 수행하여 코드의 효율성을 높인다.</li><li><strong>후면부(Back End)</strong>:<br>최적화된 IR을 받아 대상 CPU에 특화된 기계어 코드를 생성하고, 레지스터 할당 및 명령어 스케줄링 같은 작업을 진행한다.</li></ul><table><thead><tr><th>단계</th><th>역할 및 주요 작업</th></tr></thead><tbody><tr><td>전면부</td><td>렉시컬, 구문, 의미 분석을 통해 소스 코드 검증 및 IR 생성</td></tr><tr><td>중간부</td><td>IR의 효율적 최적화 작업 수행</td></tr><tr><td>후면부</td><td>대상 시스템에 맞는 기계어 코드 생성 및 CPU 특화 최적화 수행</td></tr></tbody></table><h3 id=컴파일러의-종류>컴파일러의 종류<a hidden class=anchor aria-hidden=true href=#컴파일러의-종류>#</a></h3><ol><li><p>전통적인 컴파일러 (Traditional Compiler)<br>소스 코드를 기계어로 직접 변환하는 컴파일러이다.<br>C, C++, Fortran 등의 언어에서 사용된다.<br>GCC(GNU Compiler Collection)와 Clang이 대표적인 예이다.</p></li><li><p>크로스 컴파일러 (Cross Compiler)<br>한 시스템에서 실행되지만 다른 시스템을 위한 코드를 생성하는 컴파일러이다.<br>임베디드 시스템 개발이나 다양한 플랫폼을 대상으로 하는 개발에서 중요하다.</p></li><li><p>JIT 컴파일러 (Just-In-Time Compiler)<br>런타임에 코드를 컴파일하는 기술로, Java의 JVM, JavaScript 엔진(V8) 등에서 사용된다.<br>프로그램 실행 중에 자주 사용되는 부분을 기계어로 변환하여 성능을 향상시킨다.</p></li><li><p>AOT 컴파일러 (Ahead-Of-Time Compiler)<br>프로그램 실행 전에 미리 컴파일하는 기술로, Android의 ART(Android Runtime)에서 사용된다.<br>JIT보다 초기 실행 속도가 빠르지만, 유연성이 낮다.</p></li><li><p>소스 대 소스 컴파일러 (Source-to-Source Compiler)<br>한 프로그래밍 언어에서 다른 프로그래밍 언어로 변환하는 컴파일러이다.<br>Babel(JavaScript)과 같은 도구가 이 범주에 속한다.</p></li></ol><h3 id=대표적인-컴파일러-및-사용-사례><strong>대표적인 컴파일러 및 사용 사례</strong><a hidden class=anchor aria-hidden=true href=#대표적인-컴파일러-및-사용-사례>#</a></h3><table><thead><tr><th>컴파일러</th><th>지원 언어</th><th>특징</th></tr></thead><tbody><tr><td>GCC (GNU Compiler Collection)</td><td>C, C++, Objective-C, Fortran, Go, Ada 등</td><td>오픈 소스, 다양한 아키텍처 지원</td></tr><tr><td>Clang</td><td>C, C++, Objective-C</td><td>빠른 컴파일 속도, LLVM 기반</td></tr><tr><td>MSVC (Microsoft Visual C++)</td><td>C, C++</td><td>Windows 환경에서 강력한 지원</td></tr><tr><td>Javac</td><td>Java</td><td>Java Bytecode 생성 (JVM에서 실행)</td></tr><tr><td>.NET Roslyn</td><td>C#, VB.NET</td><td>.NET 환경에서 코드 분석 지원</td></tr></tbody></table><h3 id=컴파일러-설계의-주요-기술>컴파일러 설계의 주요 기술<a hidden class=anchor aria-hidden=true href=#컴파일러-설계의-주요-기술>#</a></h3><ol><li><p>정규 표현식 (Regular Expressions)<br>어휘 분석에서 토큰을 인식하는 데 사용된다.</p></li><li><p>문맥 자유 문법 (Context-Free Grammar)<br>프로그래밍 언어의 구문을 정의하는 데 사용된다.</p></li><li><p>파싱 기법 (Parsing Techniques)<br>LL 파서, LR 파서, LALR 파서 등 다양한 파싱 기법이 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// LL 파싱 테이블 예시 (E → T + E | T, T → F * T | F, F → (E) | id)
</span></span><span class=line><span class=cl>//        |  id  |  +   |  *   |  (   |  )   |  $   |
</span></span><span class=line><span class=cl>// --------|------|------|------|------|------|------|
</span></span><span class=line><span class=cl>//    E    | E→T  |      |      | E→T  |      |      |
</span></span><span class=line><span class=cl>//    T    | T→F  |      |      | T→F  |      |      |
</span></span><span class=line><span class=cl>//    F    | F→id |      |      | F→(E)|      |      |
</span></span><span class=line><span class=cl>//    +    |      | +    |      |      |      |      |
</span></span><span class=line><span class=cl>//    *    |      |      | *    |      |      |      |
</span></span><span class=line><span class=cl>//    (    |      |      |      | (    |      |      |
</span></span><span class=line><span class=cl>//    )    |      |      |      |      | )    |      |
</span></span><span class=line><span class=cl>//    $    |      |      |      |      |      | $    |
</span></span></code></pre></td></tr></table></div></div></li><li><p>심볼 테이블 (Symbol Table)<br>변수, 함수, 클래스 등의 식별자 정보를 저장하는 데이터 구조이다.</p></li><li><p>중간 표현 (Intermediate Representation)<br>소스 코드와 목표 코드 사이의 중간 표현으로, 삼중 주소 코드, 정적 단일 할당(SSA) 형식 등이 있다.</p></li><li><p>코드 최적화 기법 (Code Optimization Techniques)</p><ul><li>상수 폴딩 (Constant Folding)</li><li>루프 최적화 (Loop Optimization)</li><li>공통 부분식 제거 (Common Subexpression Elimination)</li><li>사용하지 않는 코드 제거 (Dead Code Elimination)</li><li>인라인 확장 (Inlining)</li></ul></li><li><p>레지스터 할당 (Register Allocation)<br>변수를 레지스터에 효율적으로 할당하는 기술이다.</p></li></ol><h3 id=최신-컴파일러-기술-및-트렌드>최신 컴파일러 기술 및 트렌드<a hidden class=anchor aria-hidden=true href=#최신-컴파일러-기술-및-트렌드>#</a></h3><ol><li><p>LLVM (Low Level Virtual Machine)<br>모듈식 컴파일러 인프라로, 다양한 언어의 프론트엔드와 다양한 타겟을 지원한다.<br>유연하고 확장성이 뛰어나며 최적화 기능이 강력하다.<br>Clang(C/C++/Objective-C), Swift, Rust 등의 컴파일러가 LLVM을 기반으로 한다.</p></li><li><p>JIT (Just-In-Time) 컴파일 기술<br>실행 시점에서 컴파일하여 동적 최적화 수행 (예: Java,.NET)</p></li><li><p>AI 기반 코드 최적화<br>AI 및 머신러닝을 활용하여 코드 실행 성능을 자동 최적화</p></li><li><p>웹 어셈블리(WebAssembly, WASM)<br>브라우저에서 실행 가능한 바이너리 코드 생성</p></li></ol><h3 id=컴파일러-최적화의-주요-기법>컴파일러 최적화의 주요 기법<a hidden class=anchor aria-hidden=true href=#컴파일러-최적화의-주요-기법>#</a></h3><ol><li><p>기본 블록 최적화 (Basic Block Optimization)</p><ul><li>상수 폴딩 (Constant Folding)</li><li>상수 전파 (Constant Propagation)</li><li>복사 전파 (Copy Propagation)</li><li>공통 부분식 제거 (Common Subexpression Elimination)</li></ul></li><li><p>제어 흐름 최적화 (Control Flow Optimization)</p><ul><li>코드 이동 (Code Motion)</li><li>루프 불변 코드 이동 (Loop-Invariant Code Motion)</li><li>루프 언롤링 (Loop Unrolling)</li><li>분기 예측 (Branch Prediction)</li></ul></li><li><p>데이터 흐름 최적화 (Data Flow Optimization)</p><ul><li>도달 정의 분석 (Reaching Definitions Analysis)</li><li>사용-정의 체인 (Use-Def Chains)</li><li>정의-사용 체인 (Def-Use Chains)</li><li>살아있는 변수 분석 (Live Variable Analysis)</li></ul></li><li><p>함수 수준 최적화 (Function-Level Optimization)</p><ul><li>인라인 확장 (Function Inlining)</li><li>꼬리 재귀 최적화 (Tail Recursion Optimization)</li><li>함수 특화 (Function Specialization)</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Low-Level Virtual Machine</h2></header><div class=entry-content><p>Low-Level Virtual Machine (LLVM) LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크이다.
원래 “Low-Level Virtual Machine"의 약자에서 출발했으나, 현재는 그 이름 그대로 하나의 독립적인 프로젝트가 되어 다양한 언어와 플랫폼을 지원하고 있다.
LLVM은 소스 코드 → 중간 표현(IR) 변환부터, 여러 단계의 최적화, 그리고 최종 기계어 코드 생성을 위한 백엔드로 구성되며, 컴파일 타임, 링크 타임, 런타임, 심지어 유휴 시간까지 전반에 걸친 지속적 최적화(Lifelong Optimization) 를 지원한다.
LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 프론트엔드(언어 파싱), 중간표현(IR) 최적화, 백엔드(코드 생성) 단계를 독립적으로 개발하고 재사용할 수 있게 만든 것으로, 컴파일러 개발의 유연성과 효율성을 크게 향상시켰다.
...</p></div><footer class=entry-footer><span title='2024-12-05 03:41:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Low-Level Virtual Machine" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/low-level-virtual-machine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LLVM vs 기존 컴파일러 비교</h2></header><div class=entry-content><p>LLVM vs. 기존 컴파일러 비교 LLVM(Low Level Virtual Machine)은 모듈식 컴파일러 인프라스트럭처로, 다양한 프로그래밍 언어와 하드웨어 플랫폼을 지원하도록 설계되었다.
LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.
전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.
그러나 복잡성, 특수 타겟 지원, 리소스 요구사항 등의 측면에서는 여전히 개선의 여지가 있다. 또한 GCC와 같은 전통적인 컴파일러도 계속 발전하면서 LLVM의 장점을 일부 수용하고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-05 07:28:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to LLVM vs 기존 컴파일러 비교" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Native Compiler vs Cross Compiler</h2></header><div class=entry-content><p>Native Compiler vs. Cross Compiler Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.
Native Compiler는 컴파일러가 실행되는 동일한 시스템의 하드웨어와 운영체제에 최적화된 코드를 생성한다. Cross Compiler는 호스트 시스템에서 실행되지만 다른 플랫폼(즉, 대상 시스템)에서 실행될 코드를 생성한다. 네이티브 컴파일러(Native Compiler)의 이해 네이티브 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 동일한 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자가 사용하는 컴퓨터와 동일한 운영체제 및 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 03:33:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler vs Cross Compiler" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/native-compiler-vs-cross-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JIT Compiler vs AOT Compiler</h2></header><div class=entry-content><p>JIT Compiler vs. AOT Compiler JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다.
JIT와 AOT 컴파일러는 각각 고유한 장단점을 가지고 있으며, 사용 환경과 요구사항에 따라 적합한 접근 방식이 달라진다.
JIT 컴파일러는 런타임 정보를 활용한 최적화와 플랫폼 독립성을 제공하는 반면, AOT 컴파일러는 빠른 시작 시간과 예측 가능한 성능을 제공한다.
현대 소프트웨어 개발에서는 이 두 접근 방식의 장점을 결합한 하이브리드 방식이 점점 더 인기를 얻고 있다.
앞으로는 기계 학습, 특화된 하드웨어 활용, WebAssembly 확산 등의 동향이 컴파일러 기술의 발전을 이끌 것으로 예상된다.
...</p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JIT Compiler vs AOT Compiler" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/jit-compiler-vs-aot-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>types of Compiler</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to types of Compiler" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/types/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>