<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>asyncio | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Python,Advanced,Concurrency,Asynchrony,Async,Await,asyncio"><meta name=description content="Python의 `asyncio`는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, `async/await` 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/advanced/concurrency/asynchrony/asyncio/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/advanced/concurrency/asynchrony/asyncio/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/advanced/concurrency/asynchrony/asyncio/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="asyncio"><meta property="og:description" content="Python의 `asyncio`는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, `async/await` 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-19T06:25:00+00:00"><meta property="article:modified_time" content="2025-01-19T06:25:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Python"><meta property="article:tag" content="Advanced"><meta property="article:tag" content="Concurrency"><meta property="article:tag" content="Asynchrony"><meta property="article:tag" content="Async"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="asyncio"><meta name=twitter:description content="Python의 `asyncio`는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, `async/await` 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"asyncio","item":"https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/advanced/concurrency/asynchrony/asyncio/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"asyncio","name":"asyncio","description":"Python의 `asyncio`는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, `async/await` 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있다.","keywords":["Programming-Languages","Python","Advanced","Concurrency","Asynchrony","Async","Await","asyncio"],"articleBody":"Asyncio Python의 asyncio는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, async/await 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있으며, Python의 GIL(Global Interpreter Lock) 제약을 우회하는 싱글 스레드 기반 동시성 구현이 가능하다.\nPython 3.4부터 도입된 asyncio는 웹 서버, 데이터 수집기, 실시간 애플리케이션 등 I/O 집약적인 작업에서 혁신적인 성능 향상을 제공한다. 그러나 동기식 코드 베이스와의 통합 시 주의가 필요하며, 비동기 지원 라이브러리(aiohttp, asyncpg 등)와의 조합이 효과적이다.\n핵심 개념 이벤트 루프(Event Loop) 모든 비동기 작업의 스케줄링과 실행을 관리하는 중심 메커니즘이다.\nasyncio.run()을 호출하면 내부적으로 이벤트 루프가 생성되고 실행된다.\n기본 작동 원리 이벤트 루프 생성\n1 2 3 4 5 6 7 import asyncio async def main(): print(\"Hello 이벤트 루프!\") # 이벤트 루프 자동 생성 및 실행 asyncio.run(main()) # [6][12] asyncio.run()이 새 이벤트 루프 생성 → 작업 실행 → 종료를 자동 관리 메인 스레드에서 기본적으로 사용되며, 별도 설정 없이 활용 가능 작업 스케줄링 프로세스\n코루틴 등록: create_task()로 코루틴을 태스크로 변환 실행 큐 관리: 준비된 태스크를 순차적으로 실행 I/O 대기 처리: await 발생 시 현재 작업 일시 중지, 다음 태스크로 전환 이벤트 모니터링: I/O 완료 신호 감지 시 해당 태스크 재개 실행 흐름 예시\n1 2 3 4 5 6 7 8 9 10 11 async def task_a(): print(\"A 시작\") await asyncio.sleep(2) print(\"A 완료\") async def task_b(): print(\"B 시작\") await asyncio.sleep(1) print(\"B 완료\") asyncio.run(asyncio.gather(task_a(), task_b())) 출력 결과:\n1 2 3 4 A 시작 B 시작 # I/O 대기 시간 활용 B 완료 # 1초 후 A 완료 # 2초 후 await에서 실행 권한 반환 → 이벤트 루프가 다른 작업 스케줄링 주요 동작 메커니즘 작업 상태 관리 상태 설명 전환 조건 Pending 실행 대기 중 태스크 생성 직후 Running 현재 실행 중 이벤트 루프가 선택 Done 정상 완료 return 실행 Cancelled 취소됨 task.cancel() 호출 Failed 예외 발생 처리되지 않은 에러[4][14] 스케줄링 전략\n준비 상태 검사: selector 모듈로 I/O 이벤트 모니터링 우선순위 큐: 콜백이 등록된 순서대로 처리(call_soon()) 시간 기반 스케줄링: loop.call_later(delay, callback) 실행 모드 비교\n1 2 3 4 5 # 단일 작업 실행 loop.run_until_complete(task) # [1][4] # 무한 실행(서버 등) loop.run_forever() # [1][4] run_until_complete: 지정 작업 완료 시 루프 종료 run_forever: 명시적 loop.stop() 호출 필요 고급 기능 다중 이벤트 루프\n1 2 3 # 새 루프 생성 및 설정 new_loop = asyncio.new_event_loop() asyncio.set_event_loop(new_loop) 스레드별 독립적 루프 운영 가능 주의: 동일 스레드에선 항상 get_event_loop() 사용 권장 에러 핸들링\n1 2 3 4 5 def handle_exception(loop, context): print(f\"에러 발생: {context['exception']}\") loop = asyncio.get_event_loop() loop.set_exception_handler(handle_exception) 성능 모니터링\n1 2 # 디버그 모드 활성화 loop.set_debug(True) 태스크 생성/소멸 추적 느린 콜백 경고 출력 실제 적용 사례 (FastAPI) 1 2 3 4 5 6 7 8 9 10 11 12 13 from fastapi import FastAPI import asyncio app = FastAPI() async def db_query(): await asyncio.sleep(0.5) return \"데이터\" @app.get(\"/\") async def read_data(): result = await db_query() # I/O 대기 시 다른 요청 처리 return {\"data\": result} 요청 수신 → 코루틴 생성 await db_query()에서 I/O 대기 이벤트 루프가 다른 요청 처리로 전환 DB 응답 도착 시 원래 코루틴 재개 주의사항 동기 코드 혼용 금지: time.sleep() 대신 asyncio.sleep() 사용 CPU 바운드 작업 회피: loop.run_in_executor()로 별도 스레드 처리 루프 중복 실행 방지: RuntimeError 발생 가능 이벤트 루프는 Python의 싱글 스레드 병행성을 실현하는 핵심이다.\nI/O 대기 시간을 최대한 활용하여 웹 서버, 실시간 스트리밍, 대규모 연결 관리 등에 효과적이다.\n코루틴(Coroutine) async def로 정의되며 await 키워드로 실행을 일시 중지/재개할 수 있는 함수이다.\n예시:\n1 2 3 async def fetch_data(): await asyncio.sleep(1) return \"데이터 수신 완료\" 태스크(Task) 코루틴을 이벤트 루프에서 실행 가능한 단위로 래핑한다.\nasyncio.create_task()로 생성하며, 여러 태스크를 동시 실행할 수 있다:\n1 2 3 4 5 async def main(): task1 = asyncio.create_task(fetch_data()) task2 = asyncio.create_task(process_data()) await task1 await task2 주요 기능 및 활용 사례 기본 사용 패턴\n1 2 3 4 5 6 7 8 import asyncio async def main(): print(\"시작\") await asyncio.sleep(1) print(\"1초 후 종료\") asyncio.run(main()) asyncio.run()이 이벤트 루프를 시작하고 최상위 코루틴을 실행한다. 병렬 작업 처리\n1 2 3 4 5 6 7 8 9 async def download(url): async with aiohttp.ClientSession() as session: async with session.get(url) as response: return await response.text() async def main(): urls = [\"http://example.com\", \"http://example.org\"] tasks = [download(url) for url in urls] results = await asyncio.gather(*tasks) asyncio.gather()로 여러 코루틴을 동시 실행하고 결과를 수집한다. 타임아웃 제어\n1 2 3 4 5 6 7 8 9 async def long_operation(): await asyncio.sleep(10) return \"완료\" async def main(): try: result = await asyncio.wait_for(long_operation(), timeout=3) except asyncio.TimeoutError: print(\"작업 시간 초과\") wait_for()로 작업 제한 시간을 설정할 수 있다. 장단점 비교 장점 단점 I/O 작업 대기 시간 활용 효율화 CPU 바운드 작업에는 적합하지 않음 싱글 스레드에서 수만 개의 연결 처리 가능 동기식 코드와의 통합 복잡성 기존 스레드/프로세스 방식 대비 리소스 절약[ 디버깅과 예외 추적 어려움 고급 활용 전략 비동기 컨텍스트 관리자\n__aenter__와 __aexit__ 메서드 구현:\n1 2 3 4 5 6 class AsyncDB: async def __aenter__(self): await self.connect() return self async def __aexit__(self, *args): await self.close() 작업 취소 메커니즘\n1 2 3 4 5 6 7 task = asyncio.create_task(long_running_job()) await asyncio.sleep(0.5) task.cancel() try: await task except asyncio.CancelledError: print(\"작업 취소됨\") 이벤트 루프 직접 제어\n1 2 3 4 5 loop = asyncio.new_event_loop() try: loop.run_until_complete(main()) finally: loop.close() Python의 asyncio와 GIL(Global Interpreter Lock) Python의 asyncio와 **GIL(Global Interpreter Lock)**은 동시성 처리 메커니즘에서 상호보완적인 역할을 한다. GIL은 CPython에서 멀티스레딩의 병렬 실행을 제한하지만, asyncio는 싱글 스레드 내에서 비동기 I/O 작업을 최적화함으로써 이 제약을 우회한다.\nasyncio는 GIL의 제약 하에서도 I/O 병목을 해결하는 최적의 도구이지만, CPU 집약적 작업에서는 여전히 GIL의 영향을 받는 Python의 구조적 특성을 이해해야 한다. 이 조합은 웹 서버, 데이터 수집기 등 고성능 I/O 애플리케이션 구축에 효과적이다.\n핵심 관계 분석 GIL의 동작 특성과 Asyncio의 전략\nGIL의 제약: 한 번에 하나의 스레드만 Python 바이트코드 실행 가능. CPU 바운드 작업에서 멀티스레딩의 병렬성 저하. asyncio의 접근: 이벤트 루프 기반으로 단일 스레드 내에서 코루틴 전환을 통해 동시성 구현. I/O 대기 시간에 다른 코루틴을 실행해 CPU 유휴 시간 최소화. 1 2 3 4 # 비동기 I/O 작업 예시 (출처 3) async def fetch_data(): await asyncio.sleep(1) # GIL 해제 후 다른 코루틴 실행 return \"데이터\" 성능 비교: 스레딩 vs. Asyncio\n특성 스레딩 asyncio 실행 단위 OS 스레드 코루틴 GIL 영향 직접적 영향 (멀티코어 X) 간접적 영향 없음[5][15] 적합 작업 I/O + 제한적 CPU 순수 I/O 집약적 컨텍스트 전환 OS 스케줄러 이벤트 루프 자체 관리 GIL 회피 메커니즘 I/O 작업 시 GIL 자동 해제: asyncio.sleep(), 파일/네트워크 I/O에서 다른 코루틴 실행 가능. 코루틴 스케줄링: 이벤트 루프가 실행 큐 관리로 명시적 스레드 전환 불필요. 실제 동작 시나리오 웹 서버가 100개의 동시 요청 처리 각 요청에서 await database.query() 실행 I/O 대기 시간에 이벤트 루프가 다음 코루틴 실행 단일 스레드로 모든 요청 처리 주의사항 및 한계 CPU 바운드 작업: 행렬 연산 등 CPU 집약적 작업에서는 multiprocessing 모듈 필요. 동기 코드 혼합: time.sleep() 대신 asyncio.sleep() 사용 필요. GIL 완전 회피 아님: C 확장 모듈 사용 시 별도 GIL 관리 필요. 참고 및 출처 ","wordCount":"1094","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-19T06:25:00Z","dateModified":"2025-01-19T06:25:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/advanced/concurrency/asynchrony/asyncio/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">asyncio</h1><div class=post-description>Python의 `asyncio`는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, `async/await` 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있다.</div><div class=post-meta><span title='2025-01-19 06:25:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20and%20Development/Programming%20Languages/Core%20Languages/Python/Advanced/Concurrency/Asynchrony/asyncio.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#asyncio>Asyncio</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#주요-기능-및-활용-사례>주요 기능 및 활용 사례</a></li><li><a href=#장단점-비교>장단점 비교</a></li><li><a href=#고급-활용-전략>고급 활용 전략</a></li><li><a href=#python의-asyncio와-gilglobal-interpreter-lock>Python의 <code>asyncio</code>와 <strong>GIL(Global Interpreter Lock)</strong></a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=asyncio>Asyncio<a hidden class=anchor aria-hidden=true href=#asyncio>#</a></h2><p>Python의 <code>asyncio</code>는 <strong>비동기 I/O 프로그래밍</strong>을 지원하는 표준 라이브러리로, <code>async/await</code> 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있으며, Python의 GIL(Global Interpreter Lock) 제약을 우회하는 싱글 스레드 기반 동시성 구현이 가능하다.</p><p>Python 3.4부터 도입된 <code>asyncio</code>는 웹 서버, 데이터 수집기, 실시간 애플리케이션 등 I/O 집약적인 작업에서 혁신적인 성능 향상을 제공한다. 그러나 동기식 코드 베이스와의 통합 시 주의가 필요하며, 비동기 지원 라이브러리(<code>aiohttp</code>, <code>asyncpg</code> 등)와의 조합이 효과적이다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><h4 id=이벤트-루프event-loop>이벤트 루프(Event Loop)<a hidden class=anchor aria-hidden=true href=#이벤트-루프event-loop>#</a></h4><p>모든 비동기 작업의 스케줄링과 실행을 관리하는 중심 메커니즘이다.<br><code>asyncio.run()</code>을 호출하면 내부적으로 이벤트 루프가 생성되고 실행된다.</p><h5 id=기본-작동-원리>기본 작동 원리<a hidden class=anchor aria-hidden=true href=#기본-작동-원리>#</a></h5><ol><li><p>이벤트 루프 생성</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello 이벤트 루프!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 이벤트 루프 자동 생성 및 실행</span>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>  <span class=c1># [6][12]</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>asyncio.run()</code>이 새 이벤트 루프 생성 → 작업 실행 → 종료를 자동 관리</li><li>메인 스레드에서 기본적으로 사용되며, 별도 설정 없이 활용 가능</li></ul></li><li><p>작업 스케줄링 프로세스</p><ol><li><strong>코루틴 등록</strong>: <code>create_task()</code>로 코루틴을 태스크로 변환</li><li><strong>실행 큐 관리</strong>: 준비된 태스크를 순차적으로 실행</li><li><strong>I/O 대기 처리</strong>: <code>await</code> 발생 시 현재 작업 일시 중지, 다음 태스크로 전환</li><li><strong>이벤트 모니터링</strong>: I/O 완료 신호 감지 시 해당 태스크 재개</li></ol></li><li><p>실행 흐름 예시</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>task_a</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;A 시작&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;A 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>task_b</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;B 시작&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;B 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=n>task_a</span><span class=p>(),</span> <span class=n>task_b</span><span class=p>()))</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>출력 결과</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A 시작
</span></span><span class=line><span class=cl>B 시작  # I/O 대기 시간 활용
</span></span><span class=line><span class=cl>B 완료  # 1초 후
</span></span><span class=line><span class=cl>A 완료  # 2초 후
</span></span></code></pre></td></tr></table></div></div><ul><li><code>await</code>에서 실행 권한 반환 → 이벤트 루프가 다른 작업 스케줄링</li></ul></li></ol><h5 id=주요-동작-메커니즘>주요 동작 메커니즘<a hidden class=anchor aria-hidden=true href=#주요-동작-메커니즘>#</a></h5><ol><li>작업 상태 관리</li></ol><table><thead><tr><th>상태</th><th>설명</th><th>전환 조건</th></tr></thead><tbody><tr><td>Pending</td><td>실행 대기 중</td><td>태스크 생성 직후</td></tr><tr><td>Running</td><td>현재 실행 중</td><td>이벤트 루프가 선택</td></tr><tr><td>Done</td><td>정상 완료</td><td><code>return</code> 실행</td></tr><tr><td>Cancelled</td><td>취소됨</td><td><code>task.cancel()</code> 호출</td></tr><tr><td>Failed</td><td>예외 발생</td><td>처리되지 않은 에러[4][14]</td></tr></tbody></table><ol start=2><li><p>스케줄링 전략</p><ol><li><strong>준비 상태 검사</strong>: <code>selector</code> 모듈로 I/O 이벤트 모니터링</li><li><strong>우선순위 큐</strong>: 콜백이 등록된 순서대로 처리(<code>call_soon()</code>)</li><li><strong>시간 기반 스케줄링</strong>: <code>loop.call_later(delay, callback)</code></li></ol></li><li><p>실행 모드 비교</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 단일 작업 실행</span>
</span></span><span class=line><span class=cl><span class=n>loop</span><span class=o>.</span><span class=n>run_until_complete</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>  <span class=c1># [1][4]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 무한 실행(서버 등)</span>
</span></span><span class=line><span class=cl><span class=n>loop</span><span class=o>.</span><span class=n>run_forever</span><span class=p>()</span>  <span class=c1># [1][4]</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>run_until_complete</code>: 지정 작업 완료 시 루프 종료</li><li><code>run_forever</code>: 명시적 <code>loop.stop()</code> 호출 필요</li></ul></li></ol><h5 id=고급-기능>고급 기능<a hidden class=anchor aria-hidden=true href=#고급-기능>#</a></h5><ol><li><p>다중 이벤트 루프</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 새 루프 생성 및 설정</span>
</span></span><span class=line><span class=cl><span class=n>new_loop</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>new_event_loop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>set_event_loop</span><span class=p>(</span><span class=n>new_loop</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>스레드별 독립적 루프 운영 가능</li><li>주의: 동일 스레드에선 항상 <code>get_event_loop()</code> 사용 권장</li></ul></li><li><p>에러 핸들링</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_exception</span><span class=p>(</span><span class=n>loop</span><span class=p>,</span> <span class=n>context</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;에러 발생: </span><span class=si>{</span><span class=n>context</span><span class=p>[</span><span class=s1>&#39;exception&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>loop</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>get_event_loop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>loop</span><span class=o>.</span><span class=n>set_exception_handler</span><span class=p>(</span><span class=n>handle_exception</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>성능 모니터링</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 디버그 모드 활성화</span>
</span></span><span class=line><span class=cl><span class=n>loop</span><span class=o>.</span><span class=n>set_debug</span><span class=p>(</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>태스크 생성/소멸 추적</li><li>느린 콜백 경고 출력</li></ul></li></ol><h5 id=실제-적용-사례-fastapi>실제 적용 사례 (FastAPI)<a hidden class=anchor aria-hidden=true href=#실제-적용-사례-fastapi>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>fastapi</span> <span class=kn>import</span> <span class=n>FastAPI</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>FastAPI</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>db_query</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;데이터&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.get</span><span class=p>(</span><span class=s2>&#34;/&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>read_data</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=k>await</span> <span class=n>db_query</span><span class=p>()</span>  <span class=c1># I/O 대기 시 다른 요청 처리</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;data&#34;</span><span class=p>:</span> <span class=n>result</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>요청 수신 → 코루틴 생성</li><li><code>await db_query()</code>에서 I/O 대기</li><li>이벤트 루프가 다른 요청 처리로 전환</li><li>DB 응답 도착 시 원래 코루틴 재개</li></ol><h5 id=주의사항>주의사항<a hidden class=anchor aria-hidden=true href=#주의사항>#</a></h5><ul><li><strong>동기 코드 혼용 금지</strong>: <code>time.sleep()</code> 대신 <code>asyncio.sleep()</code> 사용</li><li><strong>CPU 바운드 작업 회피</strong>: <code>loop.run_in_executor()</code>로 별도 스레드 처리</li><li><strong>루프 중복 실행 방지</strong>: <code>RuntimeError</code> 발생 가능</li></ul><p>이벤트 루프는 Python의 <strong>싱글 스레드 병행성</strong>을 실현하는 핵심이다.<br>I/O 대기 시간을 최대한 활용하여 웹 서버, 실시간 스트리밍, 대규모 연결 관리 등에 효과적이다.</p><h4 id=코루틴coroutine>코루틴(Coroutine)<a hidden class=anchor aria-hidden=true href=#코루틴coroutine>#</a></h4><p><code>async def</code>로 정의되며 <code>await</code> 키워드로 실행을 일시 중지/재개할 수 있는 함수이다.<br>예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_data</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s2>&#34;데이터 수신 완료&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=태스크task>태스크(Task)<a hidden class=anchor aria-hidden=true href=#태스크task>#</a></h4><p>코루틴을 이벤트 루프에서 실행 가능한 단위로 래핑한다.<br><code>asyncio.create_task()</code>로 생성하며, 여러 태스크를 동시 실행할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=n>task1</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>fetch_data</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=n>task2</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>process_data</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>task1</span>
</span></span><span class=line><span class=cl>  <span class=k>await</span> <span class=n>task2</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=주요-기능-및-활용-사례>주요 기능 및 활용 사례<a hidden class=anchor aria-hidden=true href=#주요-기능-및-활용-사례>#</a></h3><ol start=5><li><p>기본 사용 패턴</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;시작&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;1초 후 종료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>asyncio.run()</code>이 이벤트 루프를 시작하고 최상위 코루틴을 실행한다.</li></ul></li><li><p>병렬 작업 처리</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>download</span><span class=p>(</span><span class=n>url</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>with</span> <span class=n>aiohttp</span><span class=o>.</span><span class=n>ClientSession</span><span class=p>()</span> <span class=k>as</span> <span class=n>session</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>async</span> <span class=k>with</span> <span class=n>session</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>url</span><span class=p>)</span> <span class=k>as</span> <span class=n>response</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>await</span> <span class=n>response</span><span class=o>.</span><span class=n>text</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>urls</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;http://example.com&#34;</span><span class=p>,</span> <span class=s2>&#34;http://example.org&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>tasks</span> <span class=o>=</span> <span class=p>[</span><span class=n>download</span><span class=p>(</span><span class=n>url</span><span class=p>)</span> <span class=k>for</span> <span class=n>url</span> <span class=ow>in</span> <span class=n>urls</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span> <span class=o>=</span> <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=o>*</span><span class=n>tasks</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>asyncio.gather()</code>로 여러 코루틴을 동시 실행하고 결과를 수집한다.</li></ul></li><li><p>타임아웃 제어</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7>7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8>8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>long_operation</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;완료&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>wait_for</span><span class=p>(</span><span class=n>long_operation</span><span class=p>(),</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>TimeoutError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;작업 시간 초과&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>wait_for()</code>로 작업 제한 시간을 설정할 수 있다.</li></ul></li></ol><h3 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h3><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>I/O 작업 대기 시간 활용 효율화</td><td>CPU 바운드 작업에는 적합하지 않음</td></tr><tr><td>싱글 스레드에서 수만 개의 연결 처리 가능</td><td>동기식 코드와의 통합 복잡성</td></tr><tr><td>기존 스레드/프로세스 방식 대비 리소스 절약[</td><td>디버깅과 예외 추적 어려움</td></tr></tbody></table><h3 id=고급-활용-전략>고급 활용 전략<a hidden class=anchor aria-hidden=true href=#고급-활용-전략>#</a></h3><ol start=8><li><p><strong>비동기 컨텍스트 관리자</strong><br><code>__aenter__</code>와 <code>__aexit__</code> 메서드 구현:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>AsyncDB</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aenter__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>connect</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=fm>__aexit__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>작업 취소 메커니즘</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6>6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>task</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>long_running_job</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>task</span><span class=o>.</span><span class=n>cancel</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>task</span>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>CancelledError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;작업 취소됨&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>이벤트 루프 직접 제어</strong></p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>loop</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>new_event_loop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span><span class=o>.</span><span class=n>run_until_complete</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>loop</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=python의-asyncio와-gilglobal-interpreter-lock>Python의 <code>asyncio</code>와 <strong>GIL(Global Interpreter Lock)</strong><a hidden class=anchor aria-hidden=true href=#python의-asyncio와-gilglobal-interpreter-lock>#</a></h3><p>Python의 <code>asyncio</code>와 **GIL(Global Interpreter Lock)**은 동시성 처리 메커니즘에서 상호보완적인 역할을 한다. GIL은 CPython에서 멀티스레딩의 병렬 실행을 제한하지만, <code>asyncio</code>는 <strong>싱글 스레드 내에서 비동기 I/O 작업을 최적화</strong>함으로써 이 제약을 우회한다.</p><p><code>asyncio</code>는 GIL의 제약 하에서도 <strong>I/O 병목을 해결</strong>하는 최적의 도구이지만, CPU 집약적 작업에서는 여전히 GIL의 영향을 받는 Python의 구조적 특성을 이해해야 한다. 이 조합은 웹 서버, 데이터 수집기 등 <strong>고성능 I/O 애플리케이션</strong> 구축에 효과적이다.</p><h4 id=핵심-관계-분석>핵심 관계 분석<a hidden class=anchor aria-hidden=true href=#핵심-관계-분석>#</a></h4><ol start=11><li><p>GIL의 동작 특성과 Asyncio의 전략</p><ul><li><strong>GIL의 제약</strong>: 한 번에 하나의 스레드만 Python 바이트코드 실행 가능. CPU 바운드 작업에서 멀티스레딩의 병렬성 저하.</li><li><strong>asyncio의 접근</strong>:<ul><li>이벤트 루프 기반으로 <strong>단일 스레드 내에서 코루틴 전환</strong>을 통해 동시성 구현.</li><li>I/O 대기 시간에 다른 코루틴을 실행해 CPU 유휴 시간 최소화.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 비동기 I/O 작업 예시 (출처 3)</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>fetch_data</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># GIL 해제 후 다른 코루틴 실행</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;데이터&#34;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>성능 비교: 스레딩 vs. Asyncio</p></li></ol><table><thead><tr><th>특성</th><th>스레딩</th><th>asyncio</th></tr></thead><tbody><tr><td><strong>실행 단위</strong></td><td>OS 스레드</td><td>코루틴</td></tr><tr><td><strong>GIL 영향</strong></td><td>직접적 영향 (멀티코어 X)</td><td>간접적 영향 없음[5][15]</td></tr><tr><td><strong>적합 작업</strong></td><td>I/O + 제한적 CPU</td><td>순수 I/O 집약적</td></tr><tr><td><strong>컨텍스트 전환</strong></td><td>OS 스케줄러</td><td>이벤트 루프 자체 관리</td></tr></tbody></table><ol start=13><li>GIL 회피 메커니즘<ul><li><strong>I/O 작업 시 GIL 자동 해제</strong>: <code>asyncio.sleep()</code>, 파일/네트워크 I/O에서 다른 코루틴 실행 가능.</li><li><strong>코루틴 스케줄링</strong>: 이벤트 루프가 실행 큐 관리로 <strong>명시적 스레드 전환 불필요</strong>.</li></ul></li></ol><h4 id=실제-동작-시나리오>실제 동작 시나리오<a hidden class=anchor aria-hidden=true href=#실제-동작-시나리오>#</a></h4><ol start=14><li>웹 서버가 100개의 동시 요청 처리</li><li>각 요청에서 <code>await database.query()</code> 실행</li><li>I/O 대기 시간에 이벤트 루프가 다음 코루틴 실행</li><li>단일 스레드로 모든 요청 처리</li></ol><h4 id=주의사항-및-한계>주의사항 및 한계<a hidden class=anchor aria-hidden=true href=#주의사항-및-한계>#</a></h4><ul><li><strong>CPU 바운드 작업</strong>: 행렬 연산 등 CPU 집약적 작업에서는 <code>multiprocessing</code> 모듈 필요.</li><li><strong>동기 코드 혼합</strong>: <code>time.sleep()</code> 대신 <code>asyncio.sleep()</code> 사용 필요.</li><li><strong>GIL 완전 회피 아님</strong>: C 확장 모듈 사용 시 별도 GIL 관리 필요.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/python/>Python</a></li><li><a href=https://buenhyden.github.io/tags/advanced/>Advanced</a></li><li><a href=https://buenhyden.github.io/tags/concurrency/>Concurrency</a></li><li><a href=https://buenhyden.github.io/tags/asynchrony/>Asynchrony</a></li><li><a href=https://buenhyden.github.io/tags/async/>Async</a></li><li><a href=https://buenhyden.github.io/tags/await/>Await</a></li><li><a href=https://buenhyden.github.io/tags/asyncio/>Asyncio</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/><span class=title>« Prev</span><br><span>중복되는 하위 문제(Overlapping Subproblems)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/library/concurrency-and-parallel-processing/greenlet-and-gevent/><span class=title>Next »</span><br><span>Greenlet and Gevent</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>