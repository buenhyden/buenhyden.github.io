<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>근사 알고리즘 (Approximation algorithm) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Approximation-algorithm"><meta name=description content="근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 '충분히 가까운' 해답을 찾는 알고리즘이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="근사 알고리즘 (Approximation algorithm)"><meta property="og:description" content="근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 '충분히 가까운' 해답을 찾는 알고리즘이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="근사 알고리즘 (Approximation algorithm)"><meta name=twitter:description content="근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 '충분히 가까운' 해답을 찾는 알고리즘이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"근사 알고리즘 (Approximation algorithm)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a></div><h1>근사 알고리즘 (Approximation algorithm)</h1><div class=post-description>근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 &lsquo;충분히 가까운&rsquo; 해답을 찾는 알고리즘이다.</div></header><div class=post-content><h2 id=근사-알고리즘-approximation-algorithm>근사 알고리즘 (Approximation algorithm)<a hidden class=anchor aria-hidden=true href=#근사-알고리즘-approximation-algorithm>#</a></h2><p>근사 알고리즘은 계산 복잡성 이론과 알고리즘 설계에서 매우 중요한 주제이다.<br>복잡한 문제를 해결하는 실용적인 방법으로, 특히 NP-난해(NP-hard) 문제를 다룰 때 필수적인 접근 방식이다.</p><p>컴퓨터 과학에서 우리가 마주치는 많은 문제들 중에는 정확한 해답을 찾는 것이 현실적으로 매우 어려운 문제들이 있다.</p><p>이런 상황에서 우리는 다음과 같은 선택을 할 수 있다:</p><ol><li>정확한 해답을 찾되 매우 오랜 시간이 걸리는 것을 감수한다</li><li>정확하지는 않지만 &lsquo;충분히 좋은&rsquo; 해답을 빠르게 찾는다<br>근사 알고리즘은 두 번째 접근 방식을 택한다.</li></ol><p>근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 &lsquo;충분히 가까운&rsquo; 해답을 찾는 알고리즘이다.</p><p>여기서 중요한 점은 근사 알고리즘이 얼마나 좋은 해답을 찾을 수 있는지 수학적으로 보장한다는 것이다.<br>예를 들어, &ldquo;이 알고리즘은 항상 최적해의 1.5배 이내의 해답을 찾는다"와 같이 성능을 보장할 수 있다.</p><p>이 기법은 특히 NP-난해(NP-hard) 문제와 같이 정확한 해를 다항 시간 내에 찾기 어려운 문제들을 다룰 때 유용하다.</p><h3 id=근사-알고리즘의-기본-개념>근사 알고리즘의 기본 개념<a hidden class=anchor aria-hidden=true href=#근사-알고리즘의-기본-개념>#</a></h3><h4 id=정의와-필요성>정의와 필요성<a hidden class=anchor aria-hidden=true href=#정의와-필요성>#</a></h4><p>근사 알고리즘이란 최적해를 찾기 어려운 문제에 대해 계산 효율성을 확보하면서 &lsquo;충분히 좋은&rsquo; 해답을 제공하는 알고리즘이다. NP-완전(NP-complete) 또는 NP-난해 문제와 같이 다항 시간 내에 최적해를 구하기 어려운 경우, 근사 알고리즘은 실용적인 대안이 된다.</p><p>최적해를 구하는 것이 현실적으로 불가능한 상황에서,</p><p>근사 알고리즘은:</p><ul><li>합리적인 시간 내에 실행 가능</li><li>일정 수준 이상의 품질을 보장하는 해답 제공</li><li>실제 응용 환경에서 활용 가능한 솔루션 제공</li></ul><h4 id=근사-비율approximation-ratio>근사 비율(Approximation Ratio)<a hidden class=anchor aria-hidden=true href=#근사-비율approximation-ratio>#</a></h4><p>근사 알고리즘의 성능을 평가하는 핵심 지표는 근사 비율(또는 근사 계수)이다:</p><p>α-근사 알고리즘이란, 모든 입력 인스턴스에 대해 알고리즘이 찾은 해답의 값이 최적해의 값과 비교하여 다음 조건을 만족하는 알고리즘이다:</p><ul><li>최대화 문제의 경우: 알고리즘의 해 ≥ 최적해 / α (여기서 α ≥ 1)</li><li>최소화 문제의 경우: 알고리즘의 해 ≤ α × 최적해 (여기서 α ≥ 1)</li></ul><p>α 값이 1에 가까울수록 더 좋은 근사 알고리즘이다.</p><ul><li>α = 1인 경우는 최적해를 찾는 알고리즘과 동일하다.</li></ul><h4 id=근사-방식의-분류>근사 방식의 분류<a hidden class=anchor aria-hidden=true href=#근사-방식의-분류>#</a></h4><p>근사 알고리즘은 다양한 방식으로 분류될 수 있다:</p><ol><li><strong>결정적 근사 알고리즘</strong>: 항상 같은 입력에 대해 같은 결과를 반환</li><li><strong>확률적 근사 알고리즘</strong>: 무작위성을 활용하여 해답 품질과 실행 시간에 확률적 보장을 제공</li><li><strong>다항 시간 근사 방식(PTAS)</strong>: 근사 비율 (1+ε)을 보장하며, 실행 시간은 입력 크기에 대해 다항식이지만 1/ε에 대해 지수적일 수 있음</li><li><strong>완전 다항 시간 근사 방식(FPTAS)</strong>: 근사 비율 (1+ε)을 보장하며, 실행 시간이 입력 크기와 1/ε 모두에 대해 다항식</li></ol><h3 id=대표적인-근사-알고리즘-사례>대표적인 근사 알고리즘 사례<a hidden class=anchor aria-hidden=true href=#대표적인-근사-알고리즘-사례>#</a></h3><h4 id=vertex-cover-문제>Vertex Cover 문제<a hidden class=anchor aria-hidden=true href=#vertex-cover-문제>#</a></h4><p><strong>문제 설명</strong>: 그래프 G = (V, E)에서, 모든 간선을 커버하는 최소 크기의 정점 집합을 찾는 문제</p><p><strong>2-근사 알고리즘</strong>:</p><ol><li>빈 정점 집합 C를 초기화</li><li>임의의 간선 (u, v)를 선택</li><li>u와 v를 C에 추가하고, u와 v에 연결된 모든 간선 제거</li><li>간선이 남아있다면 2단계로 돌아감</li><li>C를 반환</li></ol><p>이 알고리즘은 최적해의 두 배를 넘지 않는 해답을 보장한다.</p><h4 id=traveling-salesman-problem-tsp>Traveling Salesman Problem (TSP)<a hidden class=anchor aria-hidden=true href=#traveling-salesman-problem-tsp>#</a></h4><p><strong>문제 설명</strong>: n개 도시와 각 도시 간 거리가 주어질 때, 모든 도시를 한 번씩 방문하고 출발점으로 돌아오는 최단 경로 찾기</p><p><strong>MST 기반 2-근사 알고리즘</strong> (삼각 부등식이 성립하는 경우):</p><ol><li>최소 신장 트리(MST) 계산</li><li>MST를 전위 순회하여 방문 순서 결정</li><li>중복 방문을 제거하고 순서대로 도시 방문</li></ol><p>이 알고리즘은 최적해의 두 배를 넘지 않는 경로 길이를 보장한다.</p><h3 id=23-bin-packing-문제>2.3 Bin Packing 문제<a hidden class=anchor aria-hidden=true href=#23-bin-packing-문제>#</a></h3><p><strong>문제 설명</strong>: 크기가 다른 n개의 아이템을 동일한 용량의 최소 개수의 빈(bin)에 담는 문제</p><p><strong>First-Fit-Decreasing (FFD) 알고리즘</strong>:</p><ol><li>아이템을 크기 내림차순으로 정렬</li><li>각 아이템에 대해, 들어갈 수 있는 첫 번째 빈에 배치</li><li>맞는 빈이 없으면 새 빈 생성</li></ol><p>FFD는 일반적으로 11/9 · OPT + 6/9 (여기서 OPT는 최적해의 빈 개수)를 넘지 않는 빈 개수를 사용합니다.</p><h3 id=24-set-cover-문제>2.4 Set Cover 문제<a hidden class=anchor aria-hidden=true href=#24-set-cover-문제>#</a></h3><p><strong>문제 설명</strong>: 유니버스 집합 U와 U의 부분집합들 S = {S₁, S₂, …, Sₘ}이 주어질 때, U의 모든 원소를 커버하는 최소 개수의 부분집합을 선택하는 문제</p><p><strong>탐욕적 근사 알고리즘</strong>:</p><ol><li>선택된 집합들의 집합 C를 빈 집합으로 초기화</li><li>아직 커버되지 않은 원소들의 집합 U&rsquo;를 U로 초기화</li><li>U&rsquo;가 비어있지 않은 동안: a. U&rsquo;에서 가장 많은 원소를 커버하는 집합 Sᵢ 선택 b. Sᵢ를 C에 추가 c. U&rsquo;에서 Sᵢ에 포함된 원소들 제거</li><li>C 반환</li></ol><p>이 알고리즘은 ln|U| + 1의 근사 비율을 보장합니다.</p><h2 id=3-근사-알고리즘의-이론적-기반>3. 근사 알고리즘의 이론적 기반<a hidden class=anchor aria-hidden=true href=#3-근사-알고리즘의-이론적-기반>#</a></h2><h3 id=31-근사-난이도-계층approximation-hardness-hierarchy>3.1 근사 난이도 계층(Approximation Hardness Hierarchy)<a hidden class=anchor aria-hidden=true href=#31-근사-난이도-계층approximation-hardness-hierarchy>#</a></h3><p>근사 알고리즘의 이론적 연구는 다양한 난이도 계층을 확립했습니다:</p><ol><li><strong>PTAS (Polynomial-Time Approximation Scheme)</strong>: 임의의 고정된 ε > 0에 대해 (1+ε)-근사 해를 다항 시간 내에 찾을 수 있음</li><li><strong>FPTAS (Fully Polynomial-Time Approximation Scheme)</strong>: PTAS보다 강력하며, 알고리즘 실행 시간이 문제 크기와 1/ε에 대해 다항식임</li><li><strong>APX</strong>: 어떤 상수 c > 1에 대해 c-근사 알고리즘이 존재하는 문제들의 집합</li><li><strong>APX-hard</strong>: APX의 모든 문제가 이 문제로 환원될 수 있는 문제들의 집합</li><li><strong>APX-complete</strong>: APX-hard이면서 APX에 속하는 문제들의 집합</li></ol><p>일부 문제는 특정 비율 이하로 근사하는 것이 P ≠ NP 가정 하에 불가능함이 증명되었습니다.</p><h3 id=32-근사-불가능성inapproximability-결과>3.2 근사 불가능성(Inapproximability) 결과<a hidden class=anchor aria-hidden=true href=#32-근사-불가능성inapproximability-결과>#</a></h3><p>PCP 정리(Probabilistically Checkable Proofs Theorem)와 같은 복잡성 이론의 발전으로 많은 문제에 대한 근사 한계가 증명되었습니다:</p><ul><li><strong>최대 클릭 문제</strong>: n^(1-ε)에 대한 근사가 P ≠ NP 가정 하에 불가능</li><li><strong>집합 커버 문제</strong>: ln(n)보다 나은 근사가 P ≠ NP 가정 하에 불가능</li><li><strong>최대 만족가능성 문제(MAX-SAT)</strong>: 7/8보다 나은 근사가 P ≠ NP 가정 하에 불가능</li></ul><p>이러한 결과는 특정 문제에 대한 근사 알고리즘의 한계를 이해하는 데 중요합니다.</p><h2 id=4-근사-알고리즘-설계-기법>4. 근사 알고리즘 설계 기법<a hidden class=anchor aria-hidden=true href=#4-근사-알고리즘-설계-기법>#</a></h2><h3 id=41-탐욕적-방법greedy-method>4.1 탐욕적 방법(Greedy Method)<a hidden class=anchor aria-hidden=true href=#41-탐욕적-방법greedy-method>#</a></h3><p>탐욕적 방법은 각 단계에서 국소적으로 최선의 선택을 하는 방식입니다:</p><ul><li><strong>장점</strong>: 구현이 간단하고 실행 시간이 빠름</li><li><strong>단점</strong>: 모든 문제에 대해 좋은 근사 비율을 보장하지 않음</li></ul><p>예시: 집합 커버 문제의 ln(n)-근사 알고리즘</p><h3 id=42-lp-완화-및-반올림lp-relaxation-and-rounding>4.2 LP 완화 및 반올림(LP Relaxation and Rounding)<a hidden class=anchor aria-hidden=true href=#42-lp-완화-및-반올림lp-relaxation-and-rounding>#</a></h3><p>정수 선형 계획법(ILP) 문제를 선형 계획법(LP) 문제로 완화한 후, 해결책을 정수 해로 반올림하는 방식입니다:</p><ol><li>정수 제약 조건을 완화하여 LP 문제 해결</li><li>LP 최적해를 정수 해로 변환하는 반올림 전략 적용</li></ol><p>예시: 정점 커버 문제의 2-근사 알고리즘</p><h3 id=43-원시-쌍대-방법primal-dual-method>4.3 원시-쌍대 방법(Primal-Dual Method)<a hidden class=anchor aria-hidden=true href=#43-원시-쌍대-방법primal-dual-method>#</a></h3><p>LP의 원시 문제와 쌍대 문제를 동시에 고려하는 방식입니다:</p><ol><li>쌍대 문제의 실행 가능한 해를 구성</li><li>원시 문제의 해를 쌍대 해에 기반하여 구성</li><li>두 해 사이의 관계를 이용해 근사 비율 증명</li></ol><p>예시: 가중치 정점 커버 문제의 2-근사 알고리즘</p><h3 id=44-로컬-검색local-search>4.4 로컬 검색(Local Search)<a hidden class=anchor aria-hidden=true href=#44-로컬-검색local-search>#</a></h3><p>현재 해답에서 국소적 변형을 통해 더 나은 해를 찾아가는 방식입니다:</p><ol><li>초기 해답 생성</li><li>이웃한 해답들을 탐색하여 개선 가능성 확인</li><li>개선된 해답이 발견되면 이동하고, 그렇지 않으면 현재 해답 반환</li></ol><p>예시: 최대 컷 문제의 0.5-근사 알고리즘</p><h2 id=5-주요-응용-분야>5. 주요 응용 분야<a hidden class=anchor aria-hidden=true href=#5-주요-응용-분야>#</a></h2><h3 id=51-스케줄링-문제>5.1 스케줄링 문제<a hidden class=anchor aria-hidden=true href=#51-스케줄링-문제>#</a></h3><p>작업 스케줄링은 근사 알고리즘이 널리 활용되는 영역입니다:</p><ul><li><strong>단일 기계 스케줄링</strong>: 완료 시간 합 최소화, 가중치 완료 시간 합 최소화 등</li><li><strong>병렬 기계 스케줄링</strong>: 최대 완료 시간(makespan) 최소화</li><li><strong>플로우 샵 스케줄링</strong>: 작업이 여러 기계를 순서대로 거치는 경우</li></ul><p>LPT(Longest Processing Time) 규칙은 병렬 기계 스케줄링에서 (4/3 - 1/3m)-근사를 제공합니다.</p><h3 id=52-네트워크-설계-및-라우팅>5.2 네트워크 설계 및 라우팅<a hidden class=anchor aria-hidden=true href=#52-네트워크-설계-및-라우팅>#</a></h3><p>네트워크 설계 문제는 일반적으로 NP-난해이므로 근사 알고리즘이 필요합니다:</p><ul><li><strong>스타이너 트리 문제</strong>: 주어진 터미널을 연결하는 최소 비용 트리 찾기</li><li><strong>시설 위치 문제</strong>: 서비스 시설의 최적 위치 결정하기</li><li><strong>네트워크 흐름 문제</strong>: 용량 제약 하에 최대 흐름 찾기</li></ul><p>메트로폴리스 알고리즘과 같은 스타이너 트리 문제의 근사 알고리즘은 2-근사를 제공합니다.</p><h3 id=53-클러스터링-및-데이터-마이닝>5.3 클러스터링 및 데이터 마이닝<a hidden class=anchor aria-hidden=true href=#53-클러스터링-및-데이터-마이닝>#</a></h3><p>대규모 데이터셋에서의 패턴 발견은 종종 근사 알고리즘을 필요로 합니다:</p><ul><li><strong>k-means 클러스터링</strong>: 데이터 포인트를 k개 클러스터로 그룹화</li><li><strong>k-center 문제</strong>: 최대 반경을 최소화하는 k개 센터 선택</li><li><strong>k-median 문제</strong>: 각 포인트에서 가장 가까운 센터까지의 거리 합 최소화</li></ul><p>k-center 문제에 대한 탐욕적 알고리즘은 2-근사를 제공합니다.</p><h3 id=54-컴퓨터-비전-및-이미지-처리>5.4 컴퓨터 비전 및 이미지 처리<a hidden class=anchor aria-hidden=true href=#54-컴퓨터-비전-및-이미지-처리>#</a></h3><p>이미지 세그멘테이션, 객체 인식 등의 문제:</p><ul><li><strong>이미지 세그멘테이션</strong>: 그래프 컷 기반 알고리즘</li><li><strong>특징 매칭</strong>: 그래프 매칭 알고리즘</li><li><strong>3D 재구성</strong>: 매니폴드 최적화</li></ul><p>그래프 컷 알고리즘은 이미지 세그멘테이션에서 2-근사를 제공할 수 있습니다.</p><h2 id=6-근사-알고리즘의-최신-동향>6. 근사 알고리즘의 최신 동향<a hidden class=anchor aria-hidden=true href=#6-근사-알고리즘의-최신-동향>#</a></h2><h3 id=61-복잡성-이론과의-연계>6.1 복잡성 이론과의 연계<a hidden class=anchor aria-hidden=true href=#61-복잡성-이론과의-연계>#</a></h3><p>최근 연구는 근사 알고리즘의 한계를 더 정확히 이해하는 데 초점을 맞추고 있습니다:</p><ul><li><strong>고유 게임 이론(Unique Games Conjecture)</strong>: 많은 최적화 문제의 근사 난이도에 대한 더 강력한 하한 증명</li><li><strong>SDP(Semidefinite Programming) 완화</strong>: MAX-CUT과 같은 문제에 대한 개선된 근사 비율 달성</li><li><strong>근사 보존 환원(Approximation-Preserving Reductions)</strong>: 문제 간 근사 난이도 관계 확립</li></ul><h3 id=62-기계-학습-통합>6.2 기계 학습 통합<a hidden class=anchor aria-hidden=true href=#62-기계-학습-통합>#</a></h3><p>기계 학습과 근사 알고리즘의 통합이 새로운 방향으로 발전하고 있습니다:</p><ul><li><strong>학습 기반 알고리즘 선택</strong>: 문제 인스턴스 특성에 따라 최적의 근사 알고리즘 선택</li><li><strong>파라미터 튜닝</strong>: 근사 알고리즘의 파라미터를 기계 학습으로 최적화</li><li><strong>하이브리드 접근 방식</strong>: 전통적인 근사 알고리즘과 딥러닝 모델 결합</li></ul><h3 id=63-분산-및-병렬-근사-알고리즘>6.3 분산 및 병렬 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#63-분산-및-병렬-근사-알고리즘>#</a></h3><p>대규모 데이터에 대응하기 위한 분산 근사 알고리즘이 중요해지고 있습니다:</p><ul><li><strong>MapReduce 기반 근사 알고리즘</strong>: 대규모 그래프 처리에 적합</li><li><strong>스트리밍 알고리즘</strong>: 한 번의 데이터 스캔으로 근사 해 계산</li><li><strong>분산 최적화</strong>: 여러 계산 노드에서 협력적으로 근사 해 계산</li></ul><h2 id=7-근사-알고리즘-설계-및-분석-방법론>7. 근사 알고리즘 설계 및 분석 방법론<a hidden class=anchor aria-hidden=true href=#7-근사-알고리즘-설계-및-분석-방법론>#</a></h2><h3 id=71-근사-비율-분석>7.1 근사 비율 분석<a hidden class=anchor aria-hidden=true href=#71-근사-비율-분석>#</a></h3><p>알고리즘의 근사 비율을 수학적으로 증명하는 방법:</p><ol><li><strong>최악의 경우 분석</strong>: 모든 가능한 입력에 대한 근사 비율의 상한 증명</li><li><strong>평균 경우 분석</strong>: 입력 분포에 대한 평균 성능 분석</li><li><strong>확률적 분석</strong>: 알고리즘의 무작위성을 고려한 성능 분석</li></ol><h3 id=72-하한-증명-기법>7.2 하한 증명 기법<a hidden class=anchor aria-hidden=true href=#72-하한-증명-기법>#</a></h3><p>근사 불가능성 결과를 증명하는 방법:</p><ol><li><strong>환원(Reduction)</strong>: NP-난해 판정 문제로부터의 적절한 환원 구성</li><li><strong>PCP 정리 응용</strong>: 증명 시스템의 속성을 이용한 근사 하한 증명</li><li><strong>고유 게임 기반 하한</strong>: 고유 게임 추측에 기반한 강력한 하한 증명</li></ol><h3 id=73-경험적-평가-방법>7.3 경험적 평가 방법<a hidden class=anchor aria-hidden=true href=#73-경험적-평가-방법>#</a></h3><p>실제 성능 평가 방법:</p><ol><li><strong>벤치마크 데이터셋</strong>: 표준 벤치마크에서의 성능 비교</li><li><strong>시뮬레이션</strong>: 다양한 입력 분포에 대한 성능 시뮬레이션</li><li><strong>경쟁 비율 분석</strong>: 온라인 환경에서의 경쟁 비율 평가</li></ol><h2 id=8-실제-구현-사례와-코드-예제>8. 실제 구현 사례와 코드 예제<a hidden class=anchor aria-hidden=true href=#8-실제-구현-사례와-코드-예제>#</a></h2><h3 id=81-그리디-근사-알고리즘-예제-분수-배낭-문제>8.1 그리디 근사 알고리즘 예제: 분수 배낭 문제<a hidden class=anchor aria-hidden=true href=#81-그리디-근사-알고리즘-예제-분수-배낭-문제>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fractional_knapsack</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    분수 배낭 문제의 그리디 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    items: (가치, 무게) 튜플의 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    capacity: 배낭의 용량
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: 최대 가치
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 가치/무게 비율에 따라 아이템 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items_sorted</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>/</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>total_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_capacity</span> <span class=o>=</span> <span class=n>capacity</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>value</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>items_sorted</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>remaining_capacity</span> <span class=o>&gt;=</span> <span class=n>weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 아이템 전체를 담을 수 있는 경우</span>
</span></span><span class=line><span class=cl>            <span class=n>total_value</span> <span class=o>+=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>remaining_capacity</span> <span class=o>-=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 아이템 일부만 담을 수 있는 경우</span>
</span></span><span class=line><span class=cl>            <span class=n>fraction</span> <span class=o>=</span> <span class=n>remaining_capacity</span> <span class=o>/</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=n>total_value</span> <span class=o>+=</span> <span class=n>value</span> <span class=o>*</span> <span class=n>fraction</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예</span>
</span></span><span class=line><span class=cl><span class=n>items</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>60</span><span class=p>,</span> <span class=mi>10</span><span class=p>),</span> <span class=p>(</span><span class=mi>100</span><span class=p>,</span> <span class=mi>20</span><span class=p>),</span> <span class=p>(</span><span class=mi>120</span><span class=p>,</span> <span class=mi>30</span><span class=p>)]</span>  <span class=c1># (가치, 무게)</span>
</span></span><span class=line><span class=cl><span class=n>capacity</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl><span class=n>max_value</span> <span class=o>=</span> <span class=n>fractional_knapsack</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>capacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;최대 가치: </span><span class=si>{</span><span class=n>max_value</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 출력: 최대 가치: 240.0</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 분수 배낭 문제에 대해 최적해를 제공합니다.</p><h3 id=82-lp-완화-기반-근사-알고리즘-정점-커버-문제>8.2 LP 완화 기반 근사 알고리즘: 정점 커버 문제<a hidden class=anchor aria-hidden=true href=#82-lp-완화-기반-근사-알고리즘-정점-커버-문제>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span><span class=lnt id=hl-1-42><a class=lnlinks href=#hl-1-42>42</a>
</span><span class=lnt id=hl-1-43><a class=lnlinks href=#hl-1-43>43</a>
</span><span class=lnt id=hl-1-44><a class=lnlinks href=#hl-1-44>44</a>
</span><span class=lnt id=hl-1-45><a class=lnlinks href=#hl-1-45>45</a>
</span><span class=lnt id=hl-1-46><a class=lnlinks href=#hl-1-46>46</a>
</span><span class=lnt id=hl-1-47><a class=lnlinks href=#hl-1-47>47</a>
</span><span class=lnt id=hl-1-48><a class=lnlinks href=#hl-1-48>48</a>
</span><span class=lnt id=hl-1-49><a class=lnlinks href=#hl-1-49>49</a>
</span><span class=lnt id=hl-1-50><a class=lnlinks href=#hl-1-50>50</a>
</span><span class=lnt id=hl-1-51><a class=lnlinks href=#hl-1-51>51</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy.optimize</span> <span class=kn>import</span> <span class=n>linprog</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>vertex_cover_approximation</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    정점 커버 문제의 LP 완화 기반 2-근사 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    graph: 인접 리스트로 표현된 그래프
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: 근사 정점 커버
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>  <span class=c1># 정점 수</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 간선 목록 생성</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>u</span> <span class=o>&lt;</span> <span class=n>v</span><span class=p>:</span>  <span class=c1># 중복 방지</span>
</span></span><span class=line><span class=cl>                <span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>  <span class=c1># 간선 수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># LP 완화 문제 설정</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=n>n</span><span class=p>)</span>  <span class=c1># 목적 함수 계수</span>
</span></span><span class=line><span class=cl>    <span class=n>A_ub</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>b_ub</span> <span class=o>=</span> <span class=o>-</span><span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=n>m</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 제약 조건 우변</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 간선에 대한 제약 조건 설정</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>edges</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>A_ub</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>u</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>A_ub</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># bounds: 0 &lt;= x_i &lt;= 1</span>
</span></span><span class=line><span class=cl>    <span class=n>bounds</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># LP 문제 해결</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>linprog</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>A_ub</span><span class=o>=</span><span class=n>A_ub</span><span class=p>,</span> <span class=n>b_ub</span><span class=o>=</span><span class=n>b_ub</span><span class=p>,</span> <span class=n>bounds</span><span class=o>=</span><span class=n>bounds</span><span class=p>,</span> <span class=n>method</span><span class=o>=</span><span class=s1>&#39;highs&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 반올림: x_i &gt;= 0.5인 정점 선택</span>
</span></span><span class=line><span class=cl>    <span class=n>cover</span> <span class=o>=</span> <span class=p>[</span><span class=n>i</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=k>if</span> <span class=n>result</span><span class=o>.</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=mf>0.5</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cover</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>],</span>       <span class=c1># 정점 0의 이웃</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>    <span class=c1># 정점 1의 이웃</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>    <span class=c1># 정점 2의 이웃</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span>        <span class=c1># 정점 3의 이웃</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cover</span> <span class=o>=</span> <span class=n>vertex_cover_approximation</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;근사 정점 커버: </span><span class=si>{</span><span class=n>cover</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1># 예상 출력: [1, 2] 또는 이와 동등한 커버</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 정점 커버 문제에 대해 2-근사 해를 제공합니다.</p><h3 id=83-로컬-검색-근사-알고리즘-max-cut-문제>8.3 로컬 검색 근사 알고리즘: MAX-CUT 문제<a hidden class=anchor aria-hidden=true href=#83-로컬-검색-근사-알고리즘-max-cut-문제>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span><span class=lnt id=hl-2-34><a class=lnlinks href=#hl-2-34>34</a>
</span><span class=lnt id=hl-2-35><a class=lnlinks href=#hl-2-35>35</a>
</span><span class=lnt id=hl-2-36><a class=lnlinks href=#hl-2-36>36</a>
</span><span class=lnt id=hl-2-37><a class=lnlinks href=#hl-2-37>37</a>
</span><span class=lnt id=hl-2-38><a class=lnlinks href=#hl-2-38>38</a>
</span><span class=lnt id=hl-2-39><a class=lnlinks href=#hl-2-39>39</a>
</span><span class=lnt id=hl-2-40><a class=lnlinks href=#hl-2-40>40</a>
</span><span class=lnt id=hl-2-41><a class=lnlinks href=#hl-2-41>41</a>
</span><span class=lnt id=hl-2-42><a class=lnlinks href=#hl-2-42>42</a>
</span><span class=lnt id=hl-2-43><a class=lnlinks href=#hl-2-43>43</a>
</span><span class=lnt id=hl-2-44><a class=lnlinks href=#hl-2-44>44</a>
</span><span class=lnt id=hl-2-45><a class=lnlinks href=#hl-2-45>45</a>
</span><span class=lnt id=hl-2-46><a class=lnlinks href=#hl-2-46>46</a>
</span><span class=lnt id=hl-2-47><a class=lnlinks href=#hl-2-47>47</a>
</span><span class=lnt id=hl-2-48><a class=lnlinks href=#hl-2-48>48</a>
</span><span class=lnt id=hl-2-49><a class=lnlinks href=#hl-2-49>49</a>
</span><span class=lnt id=hl-2-50><a class=lnlinks href=#hl-2-50>50</a>
</span><span class=lnt id=hl-2-51><a class=lnlinks href=#hl-2-51>51</a>
</span><span class=lnt id=hl-2-52><a class=lnlinks href=#hl-2-52>52</a>
</span><span class=lnt id=hl-2-53><a class=lnlinks href=#hl-2-53>53</a>
</span><span class=lnt id=hl-2-54><a class=lnlinks href=#hl-2-54>54</a>
</span><span class=lnt id=hl-2-55><a class=lnlinks href=#hl-2-55>55</a>
</span><span class=lnt id=hl-2-56><a class=lnlinks href=#hl-2-56>56</a>
</span><span class=lnt id=hl-2-57><a class=lnlinks href=#hl-2-57>57</a>
</span><span class=lnt id=hl-2-58><a class=lnlinks href=#hl-2-58>58</a>
</span><span class=lnt id=hl-2-59><a class=lnlinks href=#hl-2-59>59</a>
</span><span class=lnt id=hl-2-60><a class=lnlinks href=#hl-2-60>60</a>
</span><span class=lnt id=hl-2-61><a class=lnlinks href=#hl-2-61>61</a>
</span><span class=lnt id=hl-2-62><a class=lnlinks href=#hl-2-62>62</a>
</span><span class=lnt id=hl-2-63><a class=lnlinks href=#hl-2-63>63</a>
</span><span class=lnt id=hl-2-64><a class=lnlinks href=#hl-2-64>64</a>
</span><span class=lnt id=hl-2-65><a class=lnlinks href=#hl-2-65>65</a>
</span><span class=lnt id=hl-2-66><a class=lnlinks href=#hl-2-66>66</a>
</span><span class=lnt id=hl-2-67><a class=lnlinks href=#hl-2-67>67</a>
</span><span class=lnt id=hl-2-68><a class=lnlinks href=#hl-2-68>68</a>
</span><span class=lnt id=hl-2-69><a class=lnlinks href=#hl-2-69>69</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_cut_local_search</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>max_iterations</span><span class=o>=</span><span class=mi>1000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    MAX-CUT 문제의 로컬 검색 기반 0.5-근사 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    graph: 가중치 있는 인접 리스트로 표현된 그래프
</span></span></span><span class=line><span class=cl><span class=s2>    max_iterations: 최대 반복 횟수
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: (S, T) 분할과 컷 가중치
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 무작위 초기 분할</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=n>n</span><span class=o>//</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span> <span class=o>-</span> <span class=n>S</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>calculate_cut_weight</span><span class=p>(</span><span class=n>S</span><span class=p>,</span> <span class=n>T</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;두 집합 S, T 사이의 컷 가중치 계산&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>u</span> <span class=ow>in</span> <span class=n>S</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>v</span><span class=p>,</span> <span class=n>w</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>T</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>weight</span> <span class=o>+=</span> <span class=n>w</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 현재 컷 가중치</span>
</span></span><span class=line><span class=cl>    <span class=n>current_weight</span> <span class=o>=</span> <span class=n>calculate_cut_weight</span><span class=p>(</span><span class=n>S</span><span class=p>,</span> <span class=n>T</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 로컬 검색</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>max_iterations</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>improved</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 각 정점에 대해 이동 시도</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>S</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># v를 S에서 T로 이동</span>
</span></span><span class=line><span class=cl>                <span class=n>S_new</span> <span class=o>=</span> <span class=n>S</span> <span class=o>-</span> <span class=p>{</span><span class=n>v</span><span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>T_new</span> <span class=o>=</span> <span class=n>T</span> <span class=o>|</span> <span class=p>{</span><span class=n>v</span><span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># v를 T에서 S로 이동</span>
</span></span><span class=line><span class=cl>                <span class=n>S_new</span> <span class=o>=</span> <span class=n>S</span> <span class=o>|</span> <span class=p>{</span><span class=n>v</span><span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>T_new</span> <span class=o>=</span> <span class=n>T</span> <span class=o>-</span> <span class=p>{</span><span class=n>v</span><span class=p>}</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 새 분할의 컷 가중치 계산</span>
</span></span><span class=line><span class=cl>            <span class=n>new_weight</span> <span class=o>=</span> <span class=n>calculate_cut_weight</span><span class=p>(</span><span class=n>S_new</span><span class=p>,</span> <span class=n>T_new</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 개선되면 이동</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>new_weight</span> <span class=o>&gt;</span> <span class=n>current_weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>S</span><span class=p>,</span> <span class=n>T</span> <span class=o>=</span> <span class=n>S_new</span><span class=p>,</span> <span class=n>T_new</span>
</span></span><span class=line><span class=cl>                <span class=n>current_weight</span> <span class=o>=</span> <span class=n>new_weight</span>
</span></span><span class=line><span class=cl>                <span class=n>improved</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 더 이상 개선되지 않으면 종료</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>improved</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>S</span><span class=p>,</span> <span class=n>T</span><span class=p>),</span> <span class=n>current_weight</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예</span>
</span></span><span class=line><span class=cl><span class=c1># 그래프 표현: [[(이웃 정점, 가중치), …], …]</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)],</span>           <span class=c1># 정점 0의 이웃과 가중치</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)],</span>   <span class=c1># 정점 1의 이웃과 가중치</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>)],</span>   <span class=c1># 정점 2의 이웃과 가중치</span>
</span></span><span class=line><span class=cl>    <span class=p>[(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>),</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>5</span><span class=p>)]</span>            <span class=c1># 정점 3의 이웃과 가중치</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=n>S</span><span class=p>,</span> <span class=n>T</span><span class=p>),</span> <span class=n>weight</span> <span class=o>=</span> <span class=n>max_cut_local_search</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;S = </span><span class=si>{</span><span class=n>S</span><span class=si>}</span><span class=s2>, T = </span><span class=si>{</span><span class=n>T</span><span class=si>}</span><span class=s2>, 컷 가중치 = </span><span class=si>{</span><span class=n>weight</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 MAX-CUT 문제에 대해 0.5-근사 해를 제공합니다.</p><h2 id=9-근사-알고리즘의-한계와-대안>9. 근사 알고리즘의 한계와 대안<a hidden class=anchor aria-hidden=true href=#9-근사-알고리즘의-한계와-대안>#</a></h2><h3 id=91-근사-불가능한-문제들>9.1 근사 불가능한 문제들<a hidden class=anchor aria-hidden=true href=#91-근사-불가능한-문제들>#</a></h3><p>일부 문제는 근사하기 매우 어렵거나 불가능합니다:</p><ul><li><strong>최대 클릭 문제</strong>: n^(1-ε)보다 나은 근사가 P ≠ NP 가정 하에 불가능</li><li><strong>최소 색칠 문제</strong>: 그래프 색칠에 대한 n^(1-ε) 근사도 어려움</li><li><strong>최장 경로 문제</strong>: 근사 알고리즘 설계가 매우 어려움</li></ul><h3 id=92-파라미터화-알고리즘parameterized-algorithms>9.2 파라미터화 알고리즘(Parameterized Algorithms)<a hidden class=anchor aria-hidden=true href=#92-파라미터화-알고리즘parameterized-algorithms>#</a></h3><p>근사 알고리즘의 대안으로, 문제의 특정 파라미터를 고정했을 때 효율적인 알고리즘을 설계하는 접근 방식:</p><ul><li><strong>고정 파라미터 다루기(Fixed-Parameter Tractability)</strong>: 파라미터 k에 대해 f(k) · n^O(1) 시간 복잡도</li><li><strong>커널화(Kernelization)</strong>: 문제 인스턴스를 파라미터 k의 함수 크기로 축소</li></ul><h3 id=93-휴리스틱-접근-방식>9.3 휴리스틱 접근 방식<a hidden class=anchor aria-hidden=true href=#93-휴리스틱-접근-방식>#</a></h3><p>엄밀한 성능 보장은 없지만 실제로 잘 작동하는 방법들:</p><ul><li><strong>유전 알고리즘(Genetic Algorithms)</strong>: 진화 과정을 모방한 최적화</li><li><strong>시뮬레이티드 어닐링(Simulated Annealing)</strong>: 열역학적 냉각 과정을 모방한 최적화</li><li><strong>타부 검색(Tabu Search)</strong>: 이미 방문한 해를 기억하여 사이클 방지</li></ul><h3 id=94-하이브리드-접근-방식>9.4 하이브리드 접근 방식<a hidden class=anchor aria-hidden=true href=#94-하이브리드-접근-방식>#</a></h3><p>여러 방법론을 결합하는 접근 방식:</p><ul><li><strong>근사 알고리즘 + 휴리스틱</strong>: 이론적 보장과 실용적 성능 모두 추구</li><li><strong>근사 알고리즘 + 기계 학습</strong>: 문제 인스턴스에 따라 알고리즘 선택 또는 조정</li><li><strong>앙상블 방법</strong>: 여러 근사 알고리즘의 결과를 결합하여 더 나은 해 도출</li></ul><h2 id=10-연구-방향-및-향후-전망>10. 연구 방향 및 향후 전망<a hidden class=anchor aria-hidden=true href=#10-연구-방향-및-향후-전망>#</a></h2><h3 id=101-이론적-발전>10.1 이론적 발전<a hidden class=anchor aria-hidden=true href=#101-이론적-발전>#</a></h3><p>근사 알고리즘 이론의 발전 가능성:</p><ul><li><strong>정확한 근사 한계 확립</strong>: 더 많은 문제에 대한 정확한 근사 가능성과 불가능성 경계 발견</li><li><strong>새로운 알고리즘 패러다임</strong>: 양자 근사 알고리즘, 생물학적 영감을 받은 최적화 등의 새로운 패러다임 개발</li><li><strong>메타 알고리즘</strong>: 문제 구조를 자동으로 분석하여 적절한 근사 방법을 선택하는 접근법</li></ul><h3 id=102-실용적-응용-분야>10.2 실용적 응용 분야<a hidden class=anchor aria-hidden=true href=#102-실용적-응용-분야>#</a></h3><p>근사 알고리즘의 새로운 응용:</p><ul><li><strong>대규모 데이터 분석</strong>: 초대형 데이터셋에 대한 근사 분석 기법</li><li><strong>인공지능과 머신러닝</strong>: 계산 효율적인 신경망 설계, 모델 압축 등에 근사 알고리즘 적용</li><li><strong>생물정보학</strong>: 유전체 시퀀싱, 단백질 접힘 예측 등에 근사 알고리즘 활용</li><li><strong>지속가능한 시스템</strong>: 에너지 효율적인 알고리즘 설계로 컴퓨팅의 탄소 발자국 감소</li></ul><h3 id=103-근사-알고리즘과-딥러닝의-융합>10.3 근사 알고리즘과 딥러닝의 융합<a hidden class=anchor aria-hidden=true href=#103-근사-알고리즘과-딥러닝의-융합>#</a></h3><p>두 영역의 상호보완적 발전:</p><ul><li><strong>학습 가능한 근사 알고리즘</strong>: 문제 인스턴스에 따라 파라미터를 조정하는 자기 학습 알고리즘</li><li><strong>알고리즘 증류(Algorithm Distillation)</strong>: 최적 알고리즘의 결정을 모방하는 신경망 학습</li><li><strong>하이브리드 최적화</strong>: 전통적 근사 알고리즘과 딥러닝을 결합한 새로운 최적화 방법</li></ul><h2 id=11-근사-알고리즘의-평가-및-벤치마킹>11. 근사 알고리즘의 평가 및 벤치마킹<a hidden class=anchor aria-hidden=true href=#11-근사-알고리즘의-평가-및-벤치마킹>#</a></h2><h3 id=111-평가-지표>11.1 평가 지표<a hidden class=anchor aria-hidden=true href=#111-평가-지표>#</a></h3><p>근사 알고리즘 성능 평가를 위한 다양한 지표:</p><ul><li><strong>근사 비율(Approximation Ratio)</strong>: 이론적 성능 보장</li><li><strong>실험적 근사율(Empirical Approximation Ratio)</strong>: 실제 데이터셋에서 측정된 최적해와의 비율</li><li><strong>실행 시간(Running Time)</strong>: 실제 실행 소요 시간</li><li><strong>확장성(Scalability)</strong>: 문제 크기 증가에 따른 성능 변화</li><li><strong>안정성(Stability)</strong>: 입력 변화에 대한 출력 변화 정도</li></ul><h3 id=112-벤치마크-데이터셋>11.2 벤치마크 데이터셋<a hidden class=anchor aria-hidden=true href=#112-벤치마크-데이터셋>#</a></h3><p>근사 알고리즘 평가를 위한 주요 데이터셋:</p><ul><li><strong>TSPLIB</strong>: 외판원 문제를 위한 표준 벤치마크</li><li><strong>DIMACS</strong>: 그래프 문제(최대 클릭, 색칠 등)를 위한 벤치마크</li><li><strong>OR-Library</strong>: 다양한 조합 최적화 문제를 위한 라이브러리</li><li><strong>SNAP</strong>: 대규모 네트워크 데이터셋</li><li><strong>UCI Machine Learning Repository</strong>: 클러스터링 등의 문제를 위한 데이터셋</li></ul><h3 id=113-실험-방법론>11.3 실험 방법론<a hidden class=anchor aria-hidden=true href=#113-실험-방법론>#</a></h3><p>근사 알고리즘의 공정한 평가 방법:</p><ul><li><strong>통제된 환경</strong>: 동일한 하드웨어 및 소프트웨어 환경에서 평가</li><li><strong>다양한 입력 인스턴스</strong>: 다양한 크기와 특성의 입력 사용</li><li><strong>반복 실험</strong>: 확률적 알고리즘의 경우 여러 번 실행하여 평균 및 분산 측정</li><li><strong>시간 제한</strong>: 현실적인 시간 제한 설정</li><li><strong>비교 대상</strong>: 다른 근사 알고리즘, 휴리스틱, 정확한 해법(가능한 경우) 등과 비교</li></ul><h2 id=12-근사-알고리즘-교육-및-학습-자원>12. 근사 알고리즘 교육 및 학습 자원<a hidden class=anchor aria-hidden=true href=#12-근사-알고리즘-교육-및-학습-자원>#</a></h2><h3 id=121-주요-교과서-및-문헌>12.1 주요 교과서 및 문헌<a hidden class=anchor aria-hidden=true href=#121-주요-교과서-및-문헌>#</a></h3><p>근사 알고리즘 학습을 위한 핵심 자료:</p><ul><li><strong>&ldquo;Approximation Algorithms&rdquo;(Vijay V. Vazirani)</strong>: 근사 알고리즘의 기초와 응용</li><li><strong>&ldquo;The Design of Approximation Algorithms&rdquo;(David P. Williamson, David B. Shmoys)</strong>: 근사 알고리즘 설계 방법론</li><li><strong>&ldquo;Algorithmics for Hard Problems&rdquo;(Juraj Hromkovič)</strong>: NP-난해 문제에 대한 근사적 접근법</li><li><strong>&ldquo;Computational Complexity: A Modern Approach&rdquo;(Sanjeev Arora, Boaz Barak)</strong>: 근사 알고리즘과 복잡성 이론의 연결</li></ul><h3 id=122-온라인-교육-자원>12.2 온라인 교육 자원<a hidden class=anchor aria-hidden=true href=#122-온라인-교육-자원>#</a></h3><p>접근 가능한 학습 자료:</p><ul><li><strong>Coursera, edX</strong>: 알고리즘 및 최적화 관련 강좌</li><li><strong>YouTube 채널</strong>: 알고리즘 시각화 및 설명 비디오</li><li><strong>GitHub 저장소</strong>: 근사 알고리즘 구현 예제</li><li><strong>알고리즘 블로그</strong>: 연구자들의 최신 연구 동향 및 설명</li></ul><h3 id=123-실습-플랫폼>12.3 실습 플랫폼<a hidden class=anchor aria-hidden=true href=#123-실습-플랫폼>#</a></h3><p>실습을 통한 학습:</p><ul><li><strong>LeetCode, HackerRank</strong>: 알고리즘 문제 풀이 플랫폼</li><li><strong>Kaggle</strong>: 데이터 분석 및 최적화 경진대회</li><li><strong>GUROBI, CPLEX</strong>: 최적화 문제 풀이 및 모델링 소프트웨어</li><li><strong>Python 라이브러리</strong>: NetworkX, PuLP, SciPy 등을 활용한 최적화 실습</li></ul><h2 id=13-특수-영역의-근사-알고리즘>13. 특수 영역의 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#13-특수-영역의-근사-알고리즘>#</a></h2><h3 id=131-온라인-근사-알고리즘>13.1 온라인 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#131-온라인-근사-알고리즘>#</a></h3><p>미래 입력을 알 수 없는 상황에서의 최적화:</p><ul><li><strong>경쟁 비율(Competitive Ratio)</strong>: 온라인 알고리즘의 성능 지표</li><li><strong>k-서버 문제</strong>: k개 서버의 효율적 이동 계획</li><li><strong>페이징 알고리즘</strong>: 메모리 페이지 교체 전략</li><li><strong>온라인 스케줄링</strong>: 실시간으로 도착하는 작업 처리</li></ul><p>예를 들어, 페이징에서 LRU(Least Recently Used) 알고리즘은 최적 오프라인 알고리즘의 k배 이상 페이지 폴트가 발생하지 않음이 증명되었습니다.</p><h3 id=132-확률적-근사-알고리즘>13.2 확률적 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#132-확률적-근사-알고리즘>#</a></h3><p>무작위성을 활용한 효율적 알고리즘:</p><ul><li><strong>몬테카를로 알고리즘</strong>: 확률적으로 정확한 해 제공</li><li><strong>라스베가스 알고리즘</strong>: 항상 정확한 해를 반환하지만 실행 시간이 확률적</li><li><strong>마코프 체인 몬테카를로(MCMC)</strong>: 복잡한 분포에서 샘플링을 통한 근사</li></ul><p>MIN-CUT 문제에 대한 Karger의 알고리즘은 확률적 근사의 좋은 예입니다.</p><h3 id=133-병렬-및-분산-근사-알고리즘>13.3 병렬 및 분산 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#133-병렬-및-분산-근사-알고리즘>#</a></h3><p>대규모 데이터와 분산 환경을 위한 알고리즘:</p><ul><li><strong>맵리듀스 기반 알고리즘</strong>: 대규모 데이터 처리를 위한 분산 근사</li><li><strong>PRAM 모델 알고리즘</strong>: 이론적 병렬 계산 모델에서의 근사</li><li><strong>GPU 가속 근사</strong>: 그래픽 처리 장치를 활용한 병렬 근사</li><li><strong>양자 근사 알고리즘</strong>: 양자 컴퓨팅을 활용한 새로운 근사 방법</li></ul><p>예를 들어, 병렬 환경에서의 k-means 클러스터링은 정확도를 유지하면서 속도를 크게 향상시킬 수 있습니다.</p><h2 id=14-근사-알고리즘의-철학적-의미>14. 근사 알고리즘의 철학적 의미<a hidden class=anchor aria-hidden=true href=#14-근사-알고리즘의-철학적-의미>#</a></h2><h3 id=141-계산의-본질에-대한-통찰>14.1 계산의 본질에 대한 통찰<a hidden class=anchor aria-hidden=true href=#141-계산의-본질에-대한-통찰>#</a></h3><p>근사 알고리즘은 계산 가능성과 효율성에 대한 깊은 통찰을 제공합니다:</p><ul><li><strong>정확성 vs. 효율성</strong>: 정확한 해에 대한 추구와 실용적 효율성 사이의 균형</li><li><strong>계산적 난이도의 스펙트럼</strong>: P, NP, APX 등 다양한 복잡성 클래스의 의미</li><li><strong>&lsquo;충분히 좋은&rsquo; 해의 개념</strong>: 최적성의 상대적 가치</li></ul><h3 id=142-실용주의적-접근>14.2 실용주의적 접근<a hidden class=anchor aria-hidden=true href=#142-실용주의적-접근>#</a></h3><p>현실 세계의 문제 해결에 대한 철학:</p><ul><li><strong>불확실성 수용</strong>: 모든 문제가 효율적으로 정확히 해결될 수 없다는 인식</li><li><strong>점진적 개선</strong>: 완벽한 해결책보다 지속적 개선의 가치</li><li><strong>적응적 문제 해결</strong>: 문제의 특성과 자원 제약에 맞는 해법 선택</li></ul><h3 id=143-미래-계산-패러다임에의-영향>14.3 미래 계산 패러다임에의 영향<a hidden class=anchor aria-hidden=true href=#143-미래-계산-패러다임에의-영향>#</a></h3><p>새로운 계산 모델에서의 근사 알고리즘:</p><ul><li><strong>양자 계산</strong>: 양자 알고리즘에서의 근사 개념</li><li><strong>생물학적 계산</strong>: 뉴로모픽 컴퓨팅에서의 근사 처리</li><li><strong>혼합 정확성 시스템</strong>: 정확한 계산과 근사 계산이 공존하는 시스템</li></ul><h2 id=15-실제-응용-사례-연구>15. 실제 응용 사례 연구<a hidden class=anchor aria-hidden=true href=#15-실제-응용-사례-연구>#</a></h2><h3 id=151-구글의-pagerank-알고리즘>15.1 구글의 PageRank 알고리즘<a hidden class=anchor aria-hidden=true href=#151-구글의-pagerank-알고리즘>#</a></h3><p>웹 페이지 중요도 평가를 위한 근사 계산:</p><ul><li><strong>대규모 그래프에서의 고유벡터 계산</strong>: 반복적 근사 방법 사용</li><li><strong>분산 계산</strong>: 대규모 웹 그래프를 여러 컴퓨터에 분산하여 계산</li><li><strong>성능과 정확도 균형</strong>: 정확한 계산보다 빠른 반복적 근사 방법 채택</li></ul><h3 id=152-아마존의-추천-시스템>15.2 아마존의 추천 시스템<a hidden class=anchor aria-hidden=true href=#152-아마존의-추천-시스템>#</a></h3><p>방대한 사용자-제품 상호작용 데이터에서의 근사:</p><ul><li><strong>협업 필터링</strong>: 사용자 유사성에 기반한 근사 추천</li><li><strong>차원 축소</strong>: 행렬 분해를 통한 특성 추출 및 근사</li><li><strong>실시간 처리</strong>: 사용자 행동에 즉각 대응하기 위한 효율적 근사</li></ul><h3 id=153-유전체-시퀀싱에서의-응용>15.3 유전체 시퀀싱에서의 응용<a hidden class=anchor aria-hidden=true href=#153-유전체-시퀀싱에서의-응용>#</a></h3><p>생물정보학에서의 근사 알고리즘:</p><ul><li><strong>시퀀스 정렬</strong>: 대규모 유전체 데이터의 효율적 정렬을 위한 휴리스틱</li><li><strong>중복 제거</strong>: 중복 시퀀스 식별을 위한 근사 방법</li><li><strong>계통 트리 구성</strong>: 종 간 관계 추론을 위한 근사 알고리즘</li></ul><p>예를 들어, BLAST 알고리즘은 생물학적 시퀀스 유사성 검색을 위한 휴리스틱 접근법으로, 정확한 정렬보다 훨씬 빠르게 결과를 제공합니다.</p><h2 id=16-근사-알고리즘-구현-도구-및-라이브러리>16. 근사 알고리즘 구현 도구 및 라이브러리<a hidden class=anchor aria-hidden=true href=#16-근사-알고리즘-구현-도구-및-라이브러리>#</a></h2><h3 id=161-파이썬-라이브러리>16.1 파이썬 라이브러리<a hidden class=anchor aria-hidden=true href=#161-파이썬-라이브러리>#</a></h3><p>파이썬 기반 근사 알고리즘 구현 도구:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 주요 라이브러리 및 활용 예시</span>
</span></span><span class=line><span class=cl><span class=c1># 1. NetworkX - 그래프 알고리즘</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>networkx</span> <span class=k>as</span> <span class=nn>nx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 최소 신장 트리(MST) 계산 - TSP 근사에 활용</span>
</span></span><span class=line><span class=cl><span class=n>G</span> <span class=o>=</span> <span class=n>nx</span><span class=o>.</span><span class=n>Graph</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>G</span><span class=o>.</span><span class=n>add_weighted_edges_from</span><span class=p>([(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)])</span>
</span></span><span class=line><span class=cl><span class=n>mst</span> <span class=o>=</span> <span class=n>nx</span><span class=o>.</span><span class=n>minimum_spanning_tree</span><span class=p>(</span><span class=n>G</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. PuLP - 선형 계획법(LP) 문제 모델링</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pulp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># LP 완화를 통한 근사 알고리즘 구현</span>
</span></span><span class=line><span class=cl><span class=n>problem</span> <span class=o>=</span> <span class=n>pulp</span><span class=o>.</span><span class=n>LpProblem</span><span class=p>(</span><span class=s2>&#34;Vertex_Cover_Relaxation&#34;</span><span class=p>,</span> <span class=n>pulp</span><span class=o>.</span><span class=n>LpMinimize</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 변수, 제약조건, 목적함수 설정 코드…</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. Scikit-learn - 클러스터링 알고리즘</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sklearn.cluster</span> <span class=kn>import</span> <span class=n>KMeans</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># k-means 클러스터링(근사 알고리즘의 일종)</span>
</span></span><span class=line><span class=cl><span class=n>kmeans</span> <span class=o>=</span> <span class=n>KMeans</span><span class=p>(</span><span class=n>n_clusters</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>random_state</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>kmeans</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>X</span><span class=p>)</span>  <span class=c1># X는 데이터 포인트 행렬</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=162-c-라이브러리>16.2 C++ 라이브러리<a hidden class=anchor aria-hidden=true href=#162-c-라이브러리>#</a></h3><p>고성능 근사 알고리즘 구현을 위한 C++ 라이브러리:</p><ul><li><strong>LEMON</strong>: 그래프 최적화 문제를 위한 효율적 라이브러리</li><li><strong>CGAL</strong>: 계산 기하학과 관련된 근사 알고리즘</li><li><strong>Boost</strong>: 다양한 그래프 알고리즘 제공</li></ul><h3 id=163-최적화-솔버와의-통합>16.3 최적화 솔버와의 통합<a hidden class=anchor aria-hidden=true href=#163-최적화-솔버와의-통합>#</a></h3><p>상용 및 오픈소스 솔버:</p><ul><li><strong>Gurobi, CPLEX</strong>: 고성능 상용 최적화 솔버, LP 완화 등에 활용</li><li><strong>OR-Tools</strong>: 구글의 오픈소스 최적화 도구 모음</li><li><strong>SCIP</strong>: 혼합 정수 프로그래밍을 위한 오픈소스 프레임워크</li></ul><h2 id=17-특정-문제군에-대한-근사-알고리즘>17. 특정 문제군에 대한 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#17-특정-문제군에-대한-근사-알고리즘>#</a></h2><h3 id=171-그래프-문제의-근사-알고리즘>17.1 그래프 문제의 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#171-그래프-문제의-근사-알고리즘>#</a></h3><p>다양한 그래프 최적화 문제에 대한 근사 기법:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 최대 독립 집합(Maximum Independent Set) 문제를 위한 근사 알고리즘</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_independent_set_approx</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    그래프의 최대 독립 집합을 위한 단순 그리디 근사 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: 근사 최대 독립 집합
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 정점 리스트 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_vertices</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=n>independent_set</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 정점의 현재 차수(degree) 계산 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>current_degree</span><span class=p>(</span><span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=mi>1</span> <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>vertex</span><span class=p>]</span> <span class=k>if</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>remaining_vertices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>remaining_vertices</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 남은 정점 중 가장 낮은 차수를 가진 정점 선택</span>
</span></span><span class=line><span class=cl>        <span class=n>min_degree_vertex</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>remaining_vertices</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=n>current_degree</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 독립 집합에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>independent_set</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>min_degree_vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 선택한 정점과 그 이웃들을 남은 정점 목록에서 제거</span>
</span></span><span class=line><span class=cl>        <span class=n>neighbors</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>min_degree_vertex</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>remaining_vertices</span> <span class=o>=</span> <span class=p>[</span><span class=n>v</span> <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>remaining_vertices</span> 
</span></span><span class=line><span class=cl>                             <span class=k>if</span> <span class=n>v</span> <span class=o>!=</span> <span class=n>min_degree_vertex</span> <span class=ow>and</span> <span class=n>v</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>neighbors</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>independent_set</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=172-기하학적-문제의-근사-알고리즘>17.2 기하학적 문제의 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#172-기하학적-문제의-근사-알고리즘>#</a></h3><p>공간 및 기하학적 최적화:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span><span class=lnt id=hl-5-33><a class=lnlinks href=#hl-5-33>33</a>
</span><span class=lnt id=hl-5-34><a class=lnlinks href=#hl-5-34>34</a>
</span><span class=lnt id=hl-5-35><a class=lnlinks href=#hl-5-35>35</a>
</span><span class=lnt id=hl-5-36><a class=lnlinks href=#hl-5-36>36</a>
</span><span class=lnt id=hl-5-37><a class=lnlinks href=#hl-5-37>37</a>
</span><span class=lnt id=hl-5-38><a class=lnlinks href=#hl-5-38>38</a>
</span><span class=lnt id=hl-5-39><a class=lnlinks href=#hl-5-39>39</a>
</span><span class=lnt id=hl-5-40><a class=lnlinks href=#hl-5-40>40</a>
</span><span class=lnt id=hl-5-41><a class=lnlinks href=#hl-5-41>41</a>
</span><span class=lnt id=hl-5-42><a class=lnlinks href=#hl-5-42>42</a>
</span><span class=lnt id=hl-5-43><a class=lnlinks href=#hl-5-43>43</a>
</span><span class=lnt id=hl-5-44><a class=lnlinks href=#hl-5-44>44</a>
</span><span class=lnt id=hl-5-45><a class=lnlinks href=#hl-5-45>45</a>
</span><span class=lnt id=hl-5-46><a class=lnlinks href=#hl-5-46>46</a>
</span><span class=lnt id=hl-5-47><a class=lnlinks href=#hl-5-47>47</a>
</span><span class=lnt id=hl-5-48><a class=lnlinks href=#hl-5-48>48</a>
</span><span class=lnt id=hl-5-49><a class=lnlinks href=#hl-5-49>49</a>
</span><span class=lnt id=hl-5-50><a class=lnlinks href=#hl-5-50>50</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy.spatial</span> <span class=kn>import</span> <span class=n>ConvexHull</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 기하학적 집합 커버(Geometric Set Cover) 문제를 위한 근사 알고리즘</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>geometric_set_cover_approx</span><span class=p>(</span><span class=n>points</span><span class=p>,</span> <span class=n>radius</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    2D 평면상 점들을 주어진 반경의 원으로 커버하는 근사 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    points: 커버해야 할 점들의 좌표 배열
</span></span></span><span class=line><span class=cl><span class=s2>    radius: 각 원의 반경
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: 선택된 원들의 중심점 좌표 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>points</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 아직 커버되지 않은 점들</span>
</span></span><span class=line><span class=cl>    <span class=n>uncovered</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1># 선택된 원들의 중심점</span>
</span></span><span class=line><span class=cl>    <span class=n>centers</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>uncovered</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 가장 많은 점을 커버하는 원의 중심점 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>best_center</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=n>best_coverage</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 후보 중심점으로 모든 입력 점 고려</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>current_center</span> <span class=o>=</span> <span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 이 중심점으로 커버되는 점들 찾기</span>
</span></span><span class=line><span class=cl>            <span class=n>covered</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>uncovered</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>norm</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>-</span> <span class=n>current_center</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=n>radius</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>covered</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 더 많은 점을 커버하면 갱신</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>covered</span> <span class=o>&gt;</span> <span class=n>best_coverage</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_coverage</span> <span class=o>=</span> <span class=n>covered</span>
</span></span><span class=line><span class=cl>                <span class=n>best_center</span> <span class=o>=</span> <span class=n>current_center</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 최적의 중심점 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>centers</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>best_center</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 커버된 점들 제거</span>
</span></span><span class=line><span class=cl>        <span class=n>new_uncovered</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>uncovered</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>norm</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>-</span> <span class=n>best_center</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>radius</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>new_uncovered</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>uncovered</span> <span class=o>=</span> <span class=n>new_uncovered</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>centers</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=173-스케줄링-문제의-근사-알고리즘>17.3 스케줄링 문제의 근사 알고리즘<a hidden class=anchor aria-hidden=true href=#173-스케줄링-문제의-근사-알고리즘>#</a></h3><p>작업 스케줄링 최적화:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 다중 기계 스케줄링을 위한 LPT(Longest Processing Time) 근사 알고리즘</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>lpt_scheduling</span><span class=p>(</span><span class=n>jobs</span><span class=p>,</span> <span class=n>machines</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    다중 기계 스케줄링을 위한 LPT 근사 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    jobs: 작업 소요 시간 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    machines: 기계 수
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: 각 기계별 할당된 작업 리스트와 총 소요 시간(makespan)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 작업을 소요 시간 내림차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>sorted_jobs</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=nb>enumerate</span><span class=p>(</span><span class=n>jobs</span><span class=p>),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 기계별 할당된 작업과 총 로드</span>
</span></span><span class=line><span class=cl>    <span class=n>machine_loads</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>machines</span>
</span></span><span class=line><span class=cl>    <span class=n>machine_jobs</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>machines</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 작업을 가장 부하가 적은 기계에 할당</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>job_idx</span><span class=p>,</span> <span class=n>processing_time</span> <span class=ow>in</span> <span class=n>sorted_jobs</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 가장 부하가 적은 기계 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>min_load_machine</span> <span class=o>=</span> <span class=n>machine_loads</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>machine_loads</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 작업 할당</span>
</span></span><span class=line><span class=cl>        <span class=n>machine_jobs</span><span class=p>[</span><span class=n>min_load_machine</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>job_idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>machine_loads</span><span class=p>[</span><span class=n>min_load_machine</span><span class=p>]</span> <span class=o>+=</span> <span class=n>processing_time</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최대 소요 시간(makespan) 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>makespan</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>machine_loads</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>machine_jobs</span><span class=p>,</span> <span class=n>makespan</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=18-근사-알고리즘의-실용적-최적화-기법>18. 근사 알고리즘의 실용적 최적화 기법<a hidden class=anchor aria-hidden=true href=#18-근사-알고리즘의-실용적-최적화-기법>#</a></h2><h3 id=181-구현-최적화>18.1 구현 최적화<a hidden class=anchor aria-hidden=true href=#181-구현-최적화>#</a></h3><p>알고리즘 구현 성능 향상:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 다익스트라 알고리즘의 효율적 구현 (근사 문제가 아니지만 구현 최적화 기법 예시)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra_optimized</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    가중치 그래프에서 시작 정점으로부터의 최단 경로 계산
</span></span></span><span class=line><span class=cl><span class=s2>    graph: {u: [(v, weight), …], …} 형태의 인접 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    start: 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>    반환값: 각 정점까지의 최단 거리
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 거리 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span> <span class=o>=</span> <span class=p>{</span><span class=n>vertex</span><span class=p>:</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;infinity&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>vertex</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 우선순위 큐를 사용한 최적화</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_distance</span><span class=p>,</span> <span class=n>current_vertex</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이미 처리된 정점은 건너뛰기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_distance</span> <span class=o>&gt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>current_vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이웃 정점 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>current_vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>distance</span> <span class=o>=</span> <span class=n>current_distance</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 더 짧은 경로를 찾은 경우 갱신</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>distance</span> <span class=o>&lt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=n>distance</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distances</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=182-휴리스틱-조정>18.2 휴리스틱 조정<a hidden class=anchor aria-hidden=true href=#182-휴리스틱-조정>#</a></h3><p>알고리즘 성능 향상을 위한 경험적 방법:</p><ul><li><strong>파라미터 튜닝</strong>: 알고리즘 파라미터를 문제 특성에 맞게 조정</li><li><strong>이웃 구조 정의</strong>: 로컬 검색의 이웃 구조를 효율적으로 설계</li><li><strong>초기 해 생성</strong>: 더 나은 초기 해로 알고리즘 시작</li><li><strong>제약 조건 추가</strong>: 탐색 공간을 효과적으로 줄이는 추가 제약 도입</li></ul><h3 id=183-하이브리드-접근법>18.3 하이브리드 접근법<a hidden class=anchor aria-hidden=true href=#183-하이브리드-접근법>#</a></h3><p>여러 방법의 장점을 결합:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span><span class=lnt id=hl-8-29><a class=lnlinks href=#hl-8-29>29</a>
</span><span class=lnt id=hl-8-30><a class=lnlinks href=#hl-8-30>30</a>
</span><span class=lnt id=hl-8-31><a class=lnlinks href=#hl-8-31>31</a>
</span><span class=lnt id=hl-8-32><a class=lnlinks href=#hl-8-32>32</a>
</span><span class=lnt id=hl-8-33><a class=lnlinks href=#hl-8-33>33</a>
</span><span class=lnt id=hl-8-34><a class=lnlinks href=#hl-8-34>34</a>
</span><span class=lnt id=hl-8-35><a class=lnlinks href=#hl-8-35>35</a>
</span><span class=lnt id=hl-8-36><a class=lnlinks href=#hl-8-36>36</a>
</span><span class=lnt id=hl-8-37><a class=lnlinks href=#hl-8-37>37</a>
</span><span class=lnt id=hl-8-38><a class=lnlinks href=#hl-8-38>38</a>
</span><span class=lnt id=hl-8-39><a class=lnlinks href=#hl-8-39>39</a>
</span><span class=lnt id=hl-8-40><a class=lnlinks href=#hl-8-40>40</a>
</span><span class=lnt id=hl-8-41><a class=lnlinks href=#hl-8-41>41</a>
</span><span class=lnt id=hl-8-42><a class=lnlinks href=#hl-8-42>42</a>
</span><span class=lnt id=hl-8-43><a class=lnlinks href=#hl-8-43>43</a>
</span><span class=lnt id=hl-8-44><a class=lnlinks href=#hl-8-44>44</a>
</span><span class=lnt id=hl-8-45><a class=lnlinks href=#hl-8-45>45</a>
</span><span class=lnt id=hl-8-46><a class=lnlinks href=#hl-8-46>46</a>
</span><span class=lnt id=hl-8-47><a class=lnlinks href=#hl-8-47>47</a>
</span><span class=lnt id=hl-8-48><a class=lnlinks href=#hl-8-48>48</a>
</span><span class=lnt id=hl-8-49><a class=lnlinks href=#hl-8-49>49</a>
</span><span class=lnt id=hl-8-50><a class=lnlinks href=#hl-8-50>50</a>
</span><span class=lnt id=hl-8-51><a class=lnlinks href=#hl-8-51>51</a>
</span><span class=lnt id=hl-8-52><a class=lnlinks href=#hl-8-52>52</a>
</span><span class=lnt id=hl-8-53><a class=lnlinks href=#hl-8-53>53</a>
</span><span class=lnt id=hl-8-54><a class=lnlinks href=#hl-8-54>54</a>
</span><span class=lnt id=hl-8-55><a class=lnlinks href=#hl-8-55>55</a>
</span><span class=lnt id=hl-8-56><a class=lnlinks href=#hl-8-56>56</a>
</span><span class=lnt id=hl-8-57><a class=lnlinks href=#hl-8-57>57</a>
</span><span class=lnt id=hl-8-58><a class=lnlinks href=#hl-8-58>58</a>
</span><span class=lnt id=hl-8-59><a class=lnlinks href=#hl-8-59>59</a>
</span><span class=lnt id=hl-8-60><a class=lnlinks href=#hl-8-60>60</a>
</span><span class=lnt id=hl-8-61><a class=lnlinks href=#hl-8-61>61</a>
</span><span class=lnt id=hl-8-62><a class=lnlinks href=#hl-8-62>62</a>
</span><span class=lnt id=hl-8-63><a class=lnlinks href=#hl-8-63>63</a>
</span><span class=lnt id=hl-8-64><a class=lnlinks href=#hl-8-64>64</a>
</span><span class=lnt id=hl-8-65><a class=lnlinks href=#hl-8-65>65</a>
</span><span class=lnt id=hl-8-66><a class=lnlinks href=#hl-8-66>66</a>
</span><span class=lnt id=hl-8-67><a class=lnlinks href=#hl-8-67>67</a>
</span><span class=lnt id=hl-8-68><a class=lnlinks href=#hl-8-68>68</a>
</span><span class=lnt id=hl-8-69><a class=lnlinks href=#hl-8-69>69</a>
</span><span class=lnt id=hl-8-70><a class=lnlinks href=#hl-8-70>70</a>
</span><span class=lnt id=hl-8-71><a class=lnlinks href=#hl-8-71>71</a>
</span><span class=lnt id=hl-8-72><a class=lnlinks href=#hl-8-72>72</a>
</span><span class=lnt id=hl-8-73><a class=lnlinks href=#hl-8-73>73</a>
</span><span class=lnt id=hl-8-74><a class=lnlinks href=#hl-8-74>74</a>
</span><span class=lnt id=hl-8-75><a class=lnlinks href=#hl-8-75>75</a>
</span><span class=lnt id=hl-8-76><a class=lnlinks href=#hl-8-76>76</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 유전 알고리즘과 로컬 검색을 결합한 하이브리드 TSP 해법</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>hybrid_tsp_solver</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>,</span> <span class=n>population_size</span><span class=o>=</span><span class=mi>50</span><span class=p>,</span> <span class=n>generations</span><span class=o>=</span><span class=mi>100</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                      <span class=n>mutation_rate</span><span class=o>=</span><span class=mf>0.1</span><span class=p>,</span> <span class=n>local_search_steps</span><span class=o>=</span><span class=mi>100</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    유전 알고리즘과 로컬 검색을 결합한 하이브리드 TSP 해법
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 경로 길이 계산 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>path_length</span><span class=p>(</span><span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>[</span><span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=p>]][</span><span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>))</span> <span class=o>+</span> \
</span></span><span class=line><span class=cl>               <span class=n>distance_matrix</span><span class=p>[</span><span class=n>path</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]][</span><span class=n>path</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기 인구 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>population</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>population_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>random</span><span class=o>.</span><span class=n>shuffle</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>population</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 로컬 검색 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>local_search</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>steps</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>best_path</span> <span class=o>=</span> <span class=n>path</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>best_length</span> <span class=o>=</span> <span class=n>path_length</span><span class=p>(</span><span class=n>best_path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>steps</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 두 도시 위치 교환</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>new_path</span> <span class=o>=</span> <span class=n>best_path</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>new_path</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>reversed</span><span class=p>(</span><span class=n>new_path</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>  <span class=c1># 2-opt 이동</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>new_length</span> <span class=o>=</span> <span class=n>path_length</span><span class=p>(</span><span class=n>new_path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>new_length</span> <span class=o>&lt;</span> <span class=n>best_length</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>best_path</span> <span class=o>=</span> <span class=n>new_path</span>
</span></span><span class=line><span class=cl>                <span class=n>best_length</span> <span class=o>=</span> <span class=n>new_length</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>best_path</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 메인 루프</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>generation</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>generations</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 평가 및 정렬</span>
</span></span><span class=line><span class=cl>        <span class=n>population</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=n>path_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 좋은 해답에 로컬 검색 적용</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>population_size</span> <span class=o>//</span> <span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>population</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>local_search</span><span class=p>(</span><span class=n>population</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>local_search_steps</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 다음 세대 생성</span>
</span></span><span class=line><span class=cl>        <span class=n>new_population</span> <span class=o>=</span> <span class=n>population</span><span class=p>[:</span><span class=n>population_size</span><span class=o>//</span><span class=mi>2</span><span class=p>]</span>  <span class=c1># 엘리티즘</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>new_population</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>population_size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 토너먼트 선택</span>
</span></span><span class=line><span class=cl>            <span class=n>parent1</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>key</span><span class=o>=</span><span class=n>path_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>parent2</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span> <span class=n>key</span><span class=o>=</span><span class=n>path_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 교차 연산 (순서 기반 교차)</span>
</span></span><span class=line><span class=cl>            <span class=n>crossover_point</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>child</span> <span class=o>=</span> <span class=n>parent1</span><span class=p>[:</span><span class=n>crossover_point</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>city</span> <span class=ow>in</span> <span class=n>parent2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>city</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>child</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>city</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 돌연변이</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>mutation_rate</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>),</span> <span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>child</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>reversed</span><span class=p>(</span><span class=n>child</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>new_population</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>population</span> <span class=o>=</span> <span class=n>new_population</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최종 해답 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>min</span><span class=p>(</span><span class=n>population</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=n>path_length</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=19-결론-근사-알고리즘의-의의와-전망>19. 결론: 근사 알고리즘의 의의와 전망<a hidden class=anchor aria-hidden=true href=#19-결론-근사-알고리즘의-의의와-전망>#</a></h2><h3 id=191-계산적-현실에서의-역할>19.1 계산적 현실에서의 역할<a hidden class=anchor aria-hidden=true href=#191-계산적-현실에서의-역할>#</a></h3><p>근사 알고리즘은 다음과 같은 이유로 현대 컴퓨팅에서 핵심적인 역할을 합니다:</p><ul><li><strong>계산적 효율성</strong>: 최적해를 찾는 것이 현실적으로 불가능한 대규모 문제에 대한 실용적 해법 제공</li><li><strong>이론과 실제의 연결</strong>: 계산복잡성 이론의 통찰과 실제 응용 사이의 가교 역할</li><li><strong>불확실성 관리</strong>: 데이터의 불확실성이나 모델의 근사성을 고려한 로버스트한 접근법</li></ul><h3 id=192-향후-연구-방향>19.2 향후 연구 방향<a hidden class=anchor aria-hidden=true href=#192-향후-연구-방향>#</a></h3><p>근사 알고리즘 분야의 유망한 연구 방향:</p><ul><li><strong>새로운 근사 기법</strong>: 양자 컴퓨팅, 뉴로모픽 컴퓨팅 등 새로운 계산 패러다임에 적합한 근사 알고리즘</li><li><strong>자동화된 알고리즘 설계</strong>: 기계 학습을 통한 문제 특성에 맞는 근사 알고리즘 자동 설계</li><li><strong>정확한 근사 한계 발견</strong>: 다양한 문제에 대한 근사 가능성의 정확한 경계 확립</li><li><strong>분산 및 병렬 근사</strong>: 초대규모 데이터를 위한 효율적 분산 근사 알고리즘</li></ul><h3 id=193-근사-알고리즘의-확장된-의미>19.3 근사 알고리즘의 확장된 의미<a hidden class=anchor aria-hidden=true href=#193-근사-알고리즘의-확장된-의미>#</a></h3><p>근사 알고리즘의 철학적, 사회적 함의:</p><ul><li><strong>불완전성 수용</strong>: 모든 문제가 효율적으로 완벽히 해결될 수 없다는 인식과 그에 따른 접근법</li><li><strong>실용주의적 문제 해결</strong>: &lsquo;충분히 좋은&rsquo; 해답의 가치와 의미</li><li><strong>학제간 영향</strong>: 인공지능, 의사결정이론, 경제학 등 다양한 분야에 근사적 사고의 영향</li></ul><p>근사 알고리즘은 단순히 계산 기법을 넘어 불확실하고 복잡한 세계에서 효율적으로 문제를 해결하는 보다 보편적인 패러다임으로 발전하고 있습니다. 이론적 깊이와 실용적 가치를 모두 갖춘 이 분야는 컴퓨터 과학의 핵심 영역으로 계속 진화할 것입니다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Approximation-Preserving Reductions</h2></header><div class=entry-content><p>Approximation-Preserving Reductions 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-09 06:22:00 +0000 UTC'>January 9, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approximation-Preserving Reductions" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/approximation-preserving-reductions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Approximation Schemes</h2></header><div class=entry-content><p>Approximation Schemes 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-09 06:21:00 +0000 UTC'>January 9, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approximation Schemes" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/approximation-schemes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Approximation algorithm's types</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2024-12-28 06:58:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;0 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approximation algorithm's types" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-algorithm/types/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>