<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dynamic Programming vs. Divide and Conquer | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Dynamic-Programming"><meta name=description content='Divide and Conquer"와 "Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Dynamic Programming vs. Divide and Conquer"><meta property="og:description" content='Divide and Conquer"와 "Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-09T05:08:00+00:00"><meta property="article:modified_time" content="2024-12-09T05:08:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Dynamic-Programming"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Dynamic Programming vs. Divide and Conquer"><meta name=twitter:description content='Divide and Conquer"와 "Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"동적 계획법 (Dynamic Programming)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/"},{"@type":"ListItem","position":5,"name":"Dynamic Programming vs. Divide and Conquer","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dynamic Programming vs. Divide and Conquer","name":"Dynamic Programming vs. Divide and Conquer","description":"Divide and Conquer\"와 \"Dynamic Programming\"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Dynamic-Programming"],"articleBody":"Divide and Conquer vs. Dynamic Programming “Divide and Conquer\"와 “Dynamic Programming\"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.\n분할 정복은 문제를 독립적인 하위 문제로 나누어 효율성을 높이는 반면, 동적 계획법은 중복되는 하위 문제의 결과를 저장하여 재계산을 방지한다.\n알고리즘 선택은 문제의 성격에 따라 달라져야 한다.\n하위 문제 간 중복이 있는지, 최적 부분 구조가 있는지를 파악하여 적절한 알고리즘을 선택하는 것이 중요하다.\nDivide and Conquer(분할 정복) 알고리즘 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.\n이 알고리즘은 다음과 같은 세 단계로 구성된다:\n분할(Divide): 원래 문제를 더 작은 하위 문제들로 나눈다. 정복(Conquer): 각 하위 문제를 재귀적으로 해결한다. 결합(Combine): 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다. 큰 책장을 조립하는 과정과 유사하다.\n전체 책장(문제)을 여러 개의 선반(하위 문제)으로 나누어 각각 조립(정복)한 다음, 모든 선반을 결합하여 전체 책장을 완성(결합)한다. 각 선반은 독립적으로 조립할 수 있다.\n작동 원리 예시: 병합 정렬(Merge Sort) 병합 정렬은 분할 정복의 대표적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def merge_sort(arr): # 기본 사례: 배열 길이가 1 이하면 이미 정렬된 것으로 간주 if len(arr) \u003c= 1: return arr # 분할 단계: 배열을 두 부분으로 나눔 mid = len(arr) // 2 left = arr[:mid] right = arr[mid:] # 정복 단계: 재귀적으로 각 부분 정렬 left = merge_sort(left) right = merge_sort(right) # 결합 단계: 정렬된 두 부분을 병합 return merge(left, right) def merge(left, right): result = [] i = j = 0 # 두 리스트를 비교하여 작은 것부터 결과에 추가 while i \u003c len(left) and j \u003c len(right): if left[i] \u003c right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 # 남은 요소들을 결과에 추가 result.extend(left[i:]) result.extend(right[j:]) return result 이 알고리즘은 배열을 절반씩 나누어(분할) 각 부분을 재귀적으로 정렬(정복)한 다음, 정렬된 두 부분을 하나로 병합(결합)한다.\nDynamic Programming(동적 계획법) 알고리즘 동적 계획법은 복잡한 문제를 더 작은 하위 문제로 나누고, 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피하는 방법이다.\n이 알고리즘의 핵심 원리는 다음과 같다:\n최적 부분 구조(Optimal Substructure): 문제의 최적 해결책이 하위 문제의 최적 해결책으로 구성된다. 중복되는 하위 문제(Overlapping Subproblems): 동일한 하위 문제가 여러 번 발생하며, 그 결과를 저장해 재사용할 수 있다. 여행 계획을 세우는 과정과 유사하다.\n서울에서 부산까지 가는 최적 경로를 찾을 때, 중간 도시들 간의 최적 경로를 먼저 계산하고 저장해 둡니다. 그리고 이 정보를 활용하여 전체 경로를 구성한다. 만약 대전에서 대구까지의 최적 경로를 이미 계산했다면, 이를 다시 계산하지 않고 저장된 결과를 재사용한다.\n작동 원리 예시: 피보나치 수열 피보나치 수열은 동적 계획법의 기본적인 예:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 재귀적 방식 (비효율적) def fibonacci_recursive(n): if n \u003c= 1: return n return fibonacci_recursive(n-1) + fibonacci_recursive(n-2) # 동적 계획법 방식 (메모이제이션 사용) def fibonacci_dp(n, memo={}): # 이미 계산된 값이 있으면 바로 반환 if n in memo: return memo[n] # 기본 사례 if n \u003c= 1: return n # 결과 계산 및 저장 memo[n] = fibonacci_dp(n-1, memo) + fibonacci_dp(n-2, memo) return memo[n] # 동적 계획법 방식 (상향식 접근) def fibonacci_bottom_up(n): # 결과를 저장할 배열 dp = [0] * (n+1) # 기본 사례 설정 dp[0] = 0 dp[1] = 1 # 하위 문제부터 차례로 해결 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] 동적 계획법은 위 예시에서 볼 수 있듯이 두 가지 접근 방식이 있다:\n하향식(Top-down): 메모이제이션을 활용한 재귀적 접근법 상향식(Bottom-up): 반복문을 사용하여 작은 문제부터 해결해 나가는 접근법 두 알고리즘의 핵심 차이점 문제 해결 접근 방식\n분할 정복: 문제를 독립적인 하위 문제로 나누어 각각 해결한 후 결합한다. 하위 문제 간에는 중복이 없다. 동적 계획법: 문제를 중복되는 하위 문제로 나누고, 각 하위 문제의 결과를 저장하여 재사용한다. 하위 문제의 특성\n분할 정복: 하위 문제가 서로 독립적이다 (중복 없음). 동적 계획법: 하위 문제가 서로 의존적이며 중복된다. 예시로 보는 차이: 피보나치 수열\n피보나치 수열 F(n) = F(n-1) + F(n-2)를 계산할 때:\n분할 정복 접근: F(n)을 F(n-1)과 F(n-2)로 나누어 계산하면, 같은 하위 문제가 여러 번 계산된다. 예: F(5)를 계산하려면 F(4)와 F(3)이 필요, F(4)를 계산하려면 F(3)과 F(2)가 필요 -\u003e F(3)이 중복 계산됨 동적 계획법 접근: F(n-1), F(n-2), … 등을 계산할 때 결과를 저장하고 재사용한다. 예: F(3)의 값을 저장해두면 F(4)와 F(5)를 계산할 때 다시 계산하지 않고 저장된 값을 사용 실제 적용 사례 Divide and Conquer 적용 사례 퀵 정렬(Quick Sort): 배열을 피벗을 기준으로 분할하여 정렬 이진 검색(Binary Search): 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄임 행렬 곱셈(Strassen’s Algorithm): 행렬을 분할하여 곱셈을 효율적으로 수행 최근접 점쌍 찾기(Closest Pair of Points): 평면 상의 점들을 분할하여 최근접 점쌍을 찾음 Dynamic Programming 적용 사례 최장 공통 부분 수열(Longest Common Subsequence): 두 문자열 간의 공통 부분 수열 찾기 배낭 문제(Knapsack Problem): 제한된 무게 내에서 최대 가치의 물건을 선택 최단 경로 문제(Shortest Path Algorithms): 다익스트라, 플로이드-워셜 등의 알고리즘 행렬 연쇄 곱셈(Matrix Chain Multiplication): 여러 행렬의 곱셈 순서 최적화 코드 비교: 이항 계수 계산 이항 계수(Binomial Coefficient) C(n,k)를 계산하는 두 가지 방법을 비교:\n분할 정복 접근법\n1 2 3 4 5 6 7 def binomial_coefficient_dc(n, k): # 기본 사례 if k == 0 or k == n: return 1 # 분할 정복 방식: C(n,k) = C(n-1,k-1) + C(n-1,k) return binomial_coefficient_dc(n-1, k-1) + binomial_coefficient_dc(n-1, k) 동적 계획법 접근법\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def binomial_coefficient_dp(n, k): # DP 테이블 초기화 dp = [[0 for _ in range(k+1)] for _ in range(n+1)] # 기본 사례 채우기 for i in range(n+1): dp[i][0] = 1 # C(i) = 1 for i in range(k+1): if i \u003c= n: dp[i][i] = 1 # C(i,i) = 1 # 나머지 값 계산 for i in range(1, n+1): for j in range(1, min(i, k)+1): dp[i][j] = dp[i-1][j-1] + dp[i-1][j] return dp[n][k] 분할 정복 방식은 중복 계산으로 인해 시간 복잡도가 O(2^n)이 되지만, 동적 계획법 방식은 결과를 저장하고 재사용하여 시간 복잡도가 O(n*k)로 개선된다.\n선택 가이드 Divide and Conquer를 선택해야 할 때 문제가 자연스럽게 독립적인 하위 문제로 나뉠 때 하위 문제 간에 중복이 없을 때 병렬 처리가 필요할 때(독립적인 하위 문제는 병렬로 처리 가능) 정렬, 검색과 같은 기본적인 알고리즘 문제를 해결할 때 Dynamic Programming을 선택해야 할 때 동일한 하위 문제가 반복해서 계산될 때 최적화 문제(최대/최소값 찾기)를 해결할 때 문제에 최적 부분 구조가 있을 때(전체 문제의 최적해가 하위 문제의 최적해로 구성) 그리디 알고리즘으로는 대개 해결할 수 없는 복잡한 최적화 문제를 해결할 때 문제 접근 방법 문제 분석: 문제의 구조를 먼저 이해한다. 하위 문제가 중복되는지 확인한다. 최적 부분 구조가 있는지 확인한다. 알고리즘 선택: 중복 하위 문제와 최적 부분 구조가 있으면 → 동적 계획법 문제가 독립적인 하위 문제로 나뉘면 → 분할 정복 접근 방식 선택 (동적 계획법의 경우): 하향식(메모이제이션): 재귀적 구조가 자연스러울 때 상향식(테이블링): 메모리 효율성이 중요하거나 반복 구조가 자연스러울 때 두 알고리즘 비교 특성 Divide and Conquer Dynamic Programming 기본 원리 문제를 독립적인 하위 문제로 분할하여 해결 중복되는 하위 문제의 결과를 저장하여 재사용 하위 문제 특성 독립적인 하위 문제(중복 없음) 중복되는 하위 문제 메모이제이션 사용하지 않음 적극적으로 사용(결과 저장) 적용 조건 문제가 분할 가능할 때 최적 부분 구조와 중복 하위 문제가 있을 때 접근 방식 주로 하향식(재귀) 하향식(메모이제이션) 또는 상향식(테이블링) 재귀 사용 필수적 선택적(상향식은 반복문 사용) 시간 복잡도 개선 분할을 통해 개선(예: O(n²)→O(n log n)) 중복 계산 제거로 개선(예: O(2ⁿ)→O(n²)) 공간 복잡도 일반적으로 O(log n)(재귀 스택) 일반적으로 O(n) 또는 O(n²)(저장 공간) 대표 알고리즘 병합 정렬, 퀵 정렬, 이진 검색 피보나치, 최장 공통 부분 수열, 배낭 문제 코드 구현 난이도 중간 중간~높음 적합한 문제 유형 정렬, 검색, 행렬 연산 등 최적화 문제, 경로 찾기, 조합 문제 등 병렬화 가능성 높음(독립적 하위 문제) 제한적(하위 문제 간 의존성) 기억해야 할 핵심 포인트 “분할, 정복, 결합” “최적 부분 구조, 중복 하위 문제, 메모이제이션” 참고 및 출처 ","wordCount":"1257","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-09T05:08:00Z","dateModified":"2024-12-09T05:08:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/>동적 계획법 (Dynamic Programming)</a></div><h1 class="post-title entry-hint-parent">Dynamic Programming vs. Divide and Conquer</h1><div class=post-description>Divide and Conquer"와 "Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.</div><div class=post-meta><span title='2024-12-09 05:08:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Dynamic%20Programming/dynamic-programming-vs-divide-and-conquer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#divide-and-conquer-vs-dynamic-programming>Divide and Conquer vs. Dynamic Programming</a><ul><li><a href=#divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘</a></li><li><a href=#dynamic-programming동적-계획법-알고리즘>Dynamic Programming(동적 계획법) 알고리즘</a></li><li><a href=#두-알고리즘의-핵심-차이점>두 알고리즘의 핵심 차이점</a></li><li><a href=#실제-적용-사례>실제 적용 사례</a></li><li><a href=#코드-비교-이항-계수-계산>코드 비교: 이항 계수 계산</a></li><li><a href=#선택-가이드>선택 가이드</a></li><li><a href=#두-알고리즘-비교>두 알고리즘 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=divide-and-conquer-vs-dynamic-programming>Divide and Conquer vs. Dynamic Programming<a hidden class=anchor aria-hidden=true href=#divide-and-conquer-vs-dynamic-programming>#</a></h2><p>&ldquo;Divide and Conquer"와 &ldquo;Dynamic Programming"은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.</p><p>분할 정복은 문제를 독립적인 하위 문제로 나누어 효율성을 높이는 반면, 동적 계획법은 중복되는 하위 문제의 결과를 저장하여 재계산을 방지한다.</p><p>알고리즘 선택은 문제의 성격에 따라 달라져야 한다.<br>하위 문제 간 중복이 있는지, 최적 부분 구조가 있는지를 파악하여 적절한 알고리즘을 선택하는 것이 중요하다.</p><h3 id=divide-and-conquer분할-정복-알고리즘>Divide and Conquer(분할 정복) 알고리즘<a hidden class=anchor aria-hidden=true href=#divide-and-conquer분할-정복-알고리즘>#</a></h3><p>분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.<br>이 알고리즘은 다음과 같은 세 단계로 구성된다:</p><ol><li><strong>분할(Divide)</strong>: 원래 문제를 더 작은 하위 문제들로 나눈다.</li><li><strong>정복(Conquer)</strong>: 각 하위 문제를 재귀적으로 해결한다.</li><li><strong>결합(Combine)</strong>: 하위 문제들의 해결책을 합쳐 원래 문제의 해결책을 만든다.</li></ol><p>큰 책장을 조립하는 과정과 유사하다.<br>전체 책장(문제)을 여러 개의 선반(하위 문제)으로 나누어 각각 조립(정복)한 다음, 모든 선반을 결합하여 전체 책장을 완성(결합)한다. 각 선반은 독립적으로 조립할 수 있다.</p><h4 id=작동-원리-예시-병합-정렬merge-sort>작동 원리 예시: 병합 정렬(Merge Sort)<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-병합-정렬merge-sort>#</a></h4><p>병합 정렬은 분할 정복의 대표적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례: 배열 길이가 1 이하면 이미 정렬된 것으로 간주</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계: 배열을 두 부분으로 나눔</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정복 단계: 재귀적으로 각 부분 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결합 단계: 정렬된 두 부분을 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 리스트를 비교하여 작은 것부터 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들을 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 배열을 절반씩 나누어(분할) 각 부분을 재귀적으로 정렬(정복)한 다음, 정렬된 두 부분을 하나로 병합(결합)한다.</p><h3 id=dynamic-programming동적-계획법-알고리즘>Dynamic Programming(동적 계획법) 알고리즘<a hidden class=anchor aria-hidden=true href=#dynamic-programming동적-계획법-알고리즘>#</a></h3><p>동적 계획법은 복잡한 문제를 더 작은 하위 문제로 나누고, 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피하는 방법이다.<br>이 알고리즘의 핵심 원리는 다음과 같다:</p><ol><li><strong>최적 부분 구조(Optimal Substructure)</strong>: 문제의 최적 해결책이 하위 문제의 최적 해결책으로 구성된다.</li><li><strong>중복되는 하위 문제(Overlapping Subproblems)</strong>: 동일한 하위 문제가 여러 번 발생하며, 그 결과를 저장해 재사용할 수 있다.</li></ol><p>여행 계획을 세우는 과정과 유사하다.<br>서울에서 부산까지 가는 최적 경로를 찾을 때, 중간 도시들 간의 최적 경로를 먼저 계산하고 저장해 둡니다. 그리고 이 정보를 활용하여 전체 경로를 구성한다. 만약 대전에서 대구까지의 최적 경로를 이미 계산했다면, 이를 다시 계산하지 않고 저장된 결과를 재사용한다.</p><h4 id=작동-원리-예시-피보나치-수열>작동 원리 예시: 피보나치 수열<a hidden class=anchor aria-hidden=true href=#작동-원리-예시-피보나치-수열>#</a></h4><p>피보나치 수열은 동적 계획법의 기본적인 예:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 재귀적 방식 (비효율적)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_recursive</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 동적 계획법 방식 (메모이제이션 사용)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_dp</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 이미 계산된 값이 있으면 바로 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 계산 및 저장</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_dp</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_dp</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 동적 계획법 방식 (상향식 접근)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_bottom_up</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 결과를 저장할 배열</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례 설정</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 하위 문제부터 차례로 해결</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>동적 계획법은 위 예시에서 볼 수 있듯이 두 가지 접근 방식이 있다:</p><ul><li><strong>하향식(Top-down)</strong>: 메모이제이션을 활용한 재귀적 접근법</li><li><strong>상향식(Bottom-up)</strong>: 반복문을 사용하여 작은 문제부터 해결해 나가는 접근법</li></ul><h3 id=두-알고리즘의-핵심-차이점>두 알고리즘의 핵심 차이점<a hidden class=anchor aria-hidden=true href=#두-알고리즘의-핵심-차이점>#</a></h3><ol><li><p>문제 해결 접근 방식</p><ul><li><strong>분할 정복</strong>: 문제를 독립적인 하위 문제로 나누어 각각 해결한 후 결합한다. 하위 문제 간에는 중복이 없다.</li><li><strong>동적 계획법</strong>: 문제를 중복되는 하위 문제로 나누고, 각 하위 문제의 결과를 저장하여 재사용한다.</li></ul></li><li><p>하위 문제의 특성</p><ul><li><strong>분할 정복</strong>: 하위 문제가 서로 독립적이다 (중복 없음).</li><li><strong>동적 계획법</strong>: 하위 문제가 서로 의존적이며 중복된다.</li></ul></li><li><p>예시로 보는 차이: 피보나치 수열<br>피보나치 수열 F(n) = F(n-1) + F(n-2)를 계산할 때:</p><ul><li><strong>분할 정복 접근</strong>: F(n)을 F(n-1)과 F(n-2)로 나누어 계산하면, 같은 하위 문제가 여러 번 계산된다.<ul><li>예: F(5)를 계산하려면 F(4)와 F(3)이 필요, F(4)를 계산하려면 F(3)과 F(2)가 필요 -> F(3)이 중복 계산됨</li></ul></li><li><strong>동적 계획법 접근</strong>: F(n-1), F(n-2), … 등을 계산할 때 결과를 저장하고 재사용한다.<ul><li>예: F(3)의 값을 저장해두면 F(4)와 F(5)를 계산할 때 다시 계산하지 않고 저장된 값을 사용</li></ul></li></ul></li></ol><h3 id=실제-적용-사례>실제 적용 사례<a hidden class=anchor aria-hidden=true href=#실제-적용-사례>#</a></h3><ul><li>Divide and Conquer 적용 사례<ol><li><strong>퀵 정렬(Quick Sort)</strong>: 배열을 피벗을 기준으로 분할하여 정렬</li><li><strong>이진 검색(Binary Search)</strong>: 정렬된 배열에서 중간점을 기준으로 검색 범위를 반으로 줄임</li><li><strong>행렬 곱셈(Strassen&rsquo;s Algorithm)</strong>: 행렬을 분할하여 곱셈을 효율적으로 수행</li><li><strong>최근접 점쌍 찾기(Closest Pair of Points)</strong>: 평면 상의 점들을 분할하여 최근접 점쌍을 찾음</li></ol></li><li>Dynamic Programming 적용 사례<ol><li><strong>최장 공통 부분 수열(Longest Common Subsequence)</strong>: 두 문자열 간의 공통 부분 수열 찾기</li><li><strong>배낭 문제(Knapsack Problem)</strong>: 제한된 무게 내에서 최대 가치의 물건을 선택</li><li><strong>최단 경로 문제(Shortest Path Algorithms)</strong>: 다익스트라, 플로이드-워셜 등의 알고리즘</li><li><strong>행렬 연쇄 곱셈(Matrix Chain Multiplication)</strong>: 여러 행렬의 곱셈 순서 최적화</li></ol></li></ul><h3 id=코드-비교-이항-계수-계산>코드 비교: 이항 계수 계산<a hidden class=anchor aria-hidden=true href=#코드-비교-이항-계수-계산>#</a></h3><p>이항 계수(Binomial Coefficient) C(n,k)를 계산하는 두 가지 방법을 비교:</p><ul><li><p>분할 정복 접근법</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binomial_coefficient_dc</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>k</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 분할 정복 방식: C(n,k) = C(n-1,k-1) + C(n-1,k)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>binomial_coefficient_dc</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>binomial_coefficient_dc</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>동적 계획법 접근법</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binomial_coefficient_dp</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># DP 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 사례 채우기</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>  <span class=c1># C(i) = 1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>  <span class=c1># C(i,i) = 1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 나머지 값 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>min</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>k</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>분할 정복 방식은 중복 계산으로 인해 시간 복잡도가 O(2^n)이 되지만, 동적 계획법 방식은 결과를 저장하고 재사용하여 시간 복잡도가 O(n*k)로 개선된다.</p><h3 id=선택-가이드>선택 가이드<a hidden class=anchor aria-hidden=true href=#선택-가이드>#</a></h3><ul><li>Divide and Conquer를 선택해야 할 때<ul><li>문제가 자연스럽게 독립적인 하위 문제로 나뉠 때</li><li>하위 문제 간에 중복이 없을 때</li><li>병렬 처리가 필요할 때(독립적인 하위 문제는 병렬로 처리 가능)</li><li>정렬, 검색과 같은 기본적인 알고리즘 문제를 해결할 때</li></ul></li><li>Dynamic Programming을 선택해야 할 때<ul><li>동일한 하위 문제가 반복해서 계산될 때</li><li>최적화 문제(최대/최소값 찾기)를 해결할 때</li><li>문제에 최적 부분 구조가 있을 때(전체 문제의 최적해가 하위 문제의 최적해로 구성)</li><li>그리디 알고리즘으로는 대개 해결할 수 없는 복잡한 최적화 문제를 해결할 때</li></ul></li><li>문제 접근 방법<ol><li><strong>문제 분석</strong>: 문제의 구조를 먼저 이해한다.<ul><li>하위 문제가 중복되는지 확인한다.</li><li>최적 부분 구조가 있는지 확인한다.</li></ul></li><li><strong>알고리즘 선택</strong>:<ul><li>중복 하위 문제와 최적 부분 구조가 있으면 → 동적 계획법</li><li>문제가 독립적인 하위 문제로 나뉘면 → 분할 정복</li></ul></li><li><strong>접근 방식 선택</strong> (동적 계획법의 경우):<ul><li>하향식(메모이제이션): 재귀적 구조가 자연스러울 때</li><li>상향식(테이블링): 메모리 효율성이 중요하거나 반복 구조가 자연스러울 때</li></ul></li></ol></li></ul><h3 id=두-알고리즘-비교>두 알고리즘 비교<a hidden class=anchor aria-hidden=true href=#두-알고리즘-비교>#</a></h3><table><thead><tr><th>특성</th><th>Divide and Conquer</th><th>Dynamic Programming</th></tr></thead><tbody><tr><td><strong>기본 원리</strong></td><td>문제를 독립적인 하위 문제로 분할하여 해결</td><td>중복되는 하위 문제의 결과를 저장하여 재사용</td></tr><tr><td><strong>하위 문제 특성</strong></td><td>독립적인 하위 문제(중복 없음)</td><td>중복되는 하위 문제</td></tr><tr><td><strong>메모이제이션</strong></td><td>사용하지 않음</td><td>적극적으로 사용(결과 저장)</td></tr><tr><td><strong>적용 조건</strong></td><td>문제가 분할 가능할 때</td><td>최적 부분 구조와 중복 하위 문제가 있을 때</td></tr><tr><td><strong>접근 방식</strong></td><td>주로 하향식(재귀)</td><td>하향식(메모이제이션) 또는 상향식(테이블링)</td></tr><tr><td><strong>재귀 사용</strong></td><td>필수적</td><td>선택적(상향식은 반복문 사용)</td></tr><tr><td><strong>시간 복잡도 개선</strong></td><td>분할을 통해 개선(예: O(n²)→O(n log n))</td><td>중복 계산 제거로 개선(예: O(2ⁿ)→O(n²))</td></tr><tr><td><strong>공간 복잡도</strong></td><td>일반적으로 O(log n)(재귀 스택)</td><td>일반적으로 O(n) 또는 O(n²)(저장 공간)</td></tr><tr><td><strong>대표 알고리즘</strong></td><td>병합 정렬, 퀵 정렬, 이진 검색</td><td>피보나치, 최장 공통 부분 수열, 배낭 문제</td></tr><tr><td><strong>코드 구현 난이도</strong></td><td>중간</td><td>중간~높음</td></tr><tr><td><strong>적합한 문제 유형</strong></td><td>정렬, 검색, 행렬 연산 등</td><td>최적화 문제, 경로 찾기, 조합 문제 등</td></tr><tr><td><strong>병렬화 가능성</strong></td><td>높음(독립적 하위 문제)</td><td>제한적(하위 문제 간 의존성)</td></tr><tr><td><strong>기억해야 할 핵심 포인트</strong></td><td>&ldquo;분할, 정복, 결합&rdquo;</td><td>&ldquo;최적 부분 구조, 중복 하위 문제, 메모이제이션&rdquo;</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/dynamic-programming/>Dynamic-Programming</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/big-endian/><span class=title>« Prev</span><br><span>Big Endian</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/><span class=title>Next »</span><br><span>Collision resolutions</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>