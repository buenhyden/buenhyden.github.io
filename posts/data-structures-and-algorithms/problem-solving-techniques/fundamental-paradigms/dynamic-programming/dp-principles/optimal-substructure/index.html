<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>최적 부분 구조(Optimal Substructure) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Dynamic-Programming,Principles,Optimal-Substructure"><meta name=description content="최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/optimal-substructure/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/optimal-substructure/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/optimal-substructure/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="최적 부분 구조(Optimal Substructure)"><meta property="og:description" content="최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-22T14:02:00+00:00"><meta property="article:modified_time" content="2025-01-22T14:02:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Dynamic-Programming"><meta property="article:tag" content="Principles"><meta property="article:tag" content="Optimal-Substructure"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="최적 부분 구조(Optimal Substructure)"><meta name=twitter:description content="최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":5,"name":"동적 계획법 (Dynamic Programming)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/"},{"@type":"ListItem","position":6,"name":"Principles of Dynamic Programming","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/"},{"@type":"ListItem","position":7,"name":"최적 부분 구조(Optimal Substructure)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/optimal-substructure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"최적 부분 구조(Optimal Substructure)","name":"최적 부분 구조(Optimal Substructure)","description":"최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Dynamic-Programming","Principles","Optimal-Substructure"],"articleBody":"최적 부분 구조(Optimal Substructure) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.\n동적 계획법이 적용되기 위해서는 두 가지 핵심 특성이 필요하다:\n중복되는 하위 문제(Overlapping Subproblems) 최적 부분 구조(Optimal Substructure)\n이다. 최적 부분 구조는 효율적인 알고리즘 설계의 핵심 개념이다.\n문제의 특성을 이해하고 최적 부분 구조를 식별할 수 있다면, 복잡한 문제도 동적 계획법이나 그리디 알고리즘을 통해 효율적으로 해결할 수 있다.\n최적 부분 구조가 없는 문제는 다른 접근 방식(예: 분할 정복, 백트래킹)을 고려해야 한다.\n최적 부분 구조(Optimal Substructure)의 기본 개념 최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.\n다시 말해, 문제의 최적 해결책이 하위 문제들의 최적 해결책으로 구성되어 있다면 해당 문제는 최적 부분 구조를 가진다고 한다.\n최적 부분 구조의 핵심 특성 하위 문제의 최적성: 전체 문제의 최적해에 포함된 하위 문제의 해결책은 그 하위 문제에 대해서도 최적해야 한다. 독립적 최적화: 하위 문제들은 독립적으로 최적화할 수 있어야 한다. 부분 해결책 결합: 하위 문제들의 최적해를 결합하여 전체 문제의 최적해를 구할 수 있어야 한다. 재귀적 정의 가능: 문제를 더 작은 하위 문제들로 재귀적으로 정의할 수 있어야 한다. 수학적 정의 문제 P가 최적 부분 구조를 가진다는 것은 다음과 같이 표현할 수 있다:\n문제 P의 최적해를 OPT(P)라고 한다. P가 하위 문제 P₁, P₂, …, Pₙ으로 분할될 수 있다면, OPT(P) = F(OPT(P₁), OPT(P₂), …, OPT(Pₙ))와 같이 표현할 수 있다. 여기서 F는 하위 문제들의 최적해를 결합하는 함수이다. 최적 부분 구조의 중요성 최적 부분 구조는 동적 계획법을 적용하기 위한 필수 조건이다.\n이 속성이 있어야만 문제를 작은 하위 문제로 분할하고, 그 결과를 저장하여 중복 계산을 피할 수 있다.\n최적 부분 구조가 없다면, 하위 문제의 해결책이 전체 문제의 최적해를 보장하지 않기 때문에 동적 계획법을 적용할 수 없다.\n최적 부분 구조의 판별 및 증명 방법 직관적 접근 문제가 최적 부분 구조를 가지는지 직관적으로 판단하는 방법은 다음과 같다:\n하위 문제 분해: 주어진 문제를 하위 문제로 분해해본다. 최적해 구성 확인: 전체 문제의 최적해가 하위 문제들의 최적해로 구성되는지 확인한다. 독립성 검증: 하위 문제들이 서로 독립적으로 최적화될 수 있는지 확인한다. 증명 방법: 귀류법(Proof by Contradiction) 최적 부분 구조를 증명하는 일반적인 방법은 귀류법을 사용하는 것:\n가정: 문제 P의 최적해 S가 하위 문제 P’의 최적해를 포함하지 않는다고 가정한다. 대체: 하위 문제 P’의 최적해 S’가 존재한다면, S 내의 P’에 대한 해결책을 S’로 대체한다. 모순 찾기: 대체 후의 해결책이 원래의 최적해 S보다 더 나은 결과를 제공한다면, 이는 S가 최적이라는 가정에 모순된다. 결론: 이러한 모순이 발생한다면, 원래 가정이 틀렸다는 것이 증명되므로 문제 P는 최적 부분 구조를 가진다. 최적성 원리(Principle of Optimality) 벨만(Richard Bellman)의 최적성 원리는 최적 부분 구조를 다음과 같이 설명한다:\n“최적 정책(최적해를 구하는 방법)은 다음과 같은 특성을 가진다:\n초기 상태와 초기 결정이 무엇이든, 남은 결정들은 초기 결정의 결과로 발생하는 상태에 대해 최적 정책을 구성해야 한다.” 이 원리는 최적 부분 구조의 핵심적인 이론적 근거가 된다.\n최적 부분 구조 설계 및 분석 방법 상태 정의와 최적 부분 구조 식별 문제 분석: 문제의 특성과 제약 조건을 이해한다. 상태 정의: 문제의 상태를 명확하게 정의한다. 상태는 하위 문제를 구분하는 변수들의 집합이다. 재귀 관계 식별: 현재 상태와 하위 상태 간의 관계를 정의한다. 최적 부분 구조 검증: 정의한 관계가 최적 부분 구조 조건을 만족하는지 확인한다. 최적 부분 구조를 활용한 동적 계획법 설계 단계 상태 정의: 문제의 상태를 정의한다. 점화식 도출: 상태 간의 전이를 나타내는 점화식을 도출한다. 기저 사례 정의: 가장 작은 하위 문제에 대한 해결책을 정의한다. 계산 순서 결정: 상향식(bottom-up) 또는 하향식(top-down) 접근 방식을 선택한다. 구현 및 최적화: 선택한 접근 방식으로 알고리즘을 구현하고 필요시 최적화한다. 최적 부분 구조 활용의 실패 사례와 해결 방법 상태 불충분: 현재 상태 정의가 문제를 완전히 표현하지 못하는 경우 해결: 상태 정의를 확장하여 필요한 정보를 모두 포함시킵니다. 의존성 문제: 하위 문제 간 의존성이 있어 독립적으로 최적화할 수 없는 경우 해결: 의존성을 상태 정의에 포함시키거나, 문제 분해 방식을 변경한다. 제약 조건 충돌: 문제의 제약 조건이 최적 부분 구조를 방해하는 경우 해결: 제약 조건을 상태 정의에 포함시키거나, 제약 조건을 고려한 새로운 하위 문제 구조를 설계한다. 다양한 최적 부분 구조 유형 선형 최적 부분 구조(Linear Optimal Substructure) 가장 단순한 형태로, 문제의 최적해가 하나의 하위 문제의 최적해에만 의존하는 경우.\n예시: 피보나치 수열\n1 2 3 4 5 6 7 8 9 10 11 12 13 def fibonacci_dp(n): if n \u003c= 1: return n # DP 테이블 초기화 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 # 상향식(bottom-up) 접근 for i in range(2, n + 1): dp[i] = dp[i-1] + dp[i-2] # 선형 최적 부분 구조 return dp[n] 분기 최적 부분 구조(Branching Optimal Substructure) 문제의 최적해가 둘 이상의 독립적인 하위 문제의 최적해에 의존하는 경우.\n예시: 행렬 곱셈 연쇄(Matrix Chain Multiplication)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def matrix_chain_multiplication(dimensions): n = len(dimensions) - 1 # 행렬 개수 # m[i][j] = i부터 j까지의 행렬을 곱하는 최소 연산 횟수 m = [[0 for _ in range(n)] for _ in range(n)] # 연쇄 길이 l을 2부터 n까지 증가시키며 계산 for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 m[i][j] = float('inf') # 최적의 분할 지점 k 찾기 (분기 최적 부분 구조) for k in range(i, j): cost = m[i][k] + m[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1] if cost \u003c m[i][j]: m[i][j] = cost return m[0][n-1] 조건부 최적 부분 구조(Conditional Optimal Substructure) 특정 조건이 만족될 때만 최적 부분 구조를 가지는 경우.\n예시: 최장 공통 부분 수열(Longest Common Subsequence)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def longest_common_subsequence(text1, text2): m, n = len(text1), len(text2) # dp[i][j] = text1[:i]와 text2[:j]의 LCS 길이 dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i-1] == text2[j-1]: # 문자가 같으면 대각선 값에 1 더함 (조건부 최적 부분 구조) dp[i][j] = dp[i-1][j-1] + 1 else: # 문자가 다르면 왼쪽 또는 위쪽 값 중 최대값 dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n] 중첩 최적 부분 구조(Nested Optimal Substructure) 하위 문제의 최적해를 구하기 위해 또 다른 최적 부분 구조 문제를 해결해야 하는 경우.\n예시: 최단 경로 문제의 플로이드-워셜 알고리즘(Floyd-Warshall Algorithm)\n1 2 3 4 5 6 7 8 9 10 11 12 def floyd_warshall(graph): n = len(graph) dist = [row[:] for row in graph] # 그래프 복사 # k = 중간 정점, i = 시작 정점, j = 종료 정점 for k in range(n): for i in range(n): for j in range(n): # i에서 j로 가는 최단 경로 업데이트 (중첩 최적 부분 구조) dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist 최적 부분 구조의 일반적인 예시와 증명 최단 경로 문제(Shortest Path Problem) 노드 s에서 노드 t까지의 최단 경로가 u를 통과한다면, s에서 u까지의 부분 경로와 u에서 t까지의 부분 경로도 각각 최단 경로이다.\n증명:\ns에서 t까지의 최단 경로를 P라고 하고, 이 경로가 노드 u를 통과한다고 가정한다. P를 s에서 u까지의 부분 경로 P₁과 u에서 t까지의 부분 경로 P₂로 나눈다. 만약 P₁이 s에서 u까지의 최단 경로가 아니라면, 더 짧은 경로 P₁’이 존재할 것이다. 이 경우 P₁’과 P₂를 합친 경로는 P보다 짧아지므로, P가 최단 경로라는 가정에 모순된다. 같은 방식으로 P₂도 u에서 t까지의 최단 경로임을 증명할 수 있다. 최장 증가 부분 수열(Longest Increasing Subsequence) 배열의 최장 증가 부분 수열(LIS)은 최적 부분 구조를 가진다.\n증명:\n배열 A의 최장 증가 부분 수열을 L이라고 하고, 마지막 요소가 A[j]라고 가정한다. L의 마지막 요소를 제외한 부분 수열 L’은 A[0..j-1]에서의 최장 증가 부분 수열이어야 한다. 만약 L’이 최장이 아니라면, A[0..j-1]에서 더 긴 증가 부분 수열 L’‘이 존재할 것이다. 이 경우 L’‘에 A[j]를 추가하면 L보다 긴 증가 부분 수열이 되므로, L이 최장이라는 가정에 모순된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def longest_increasing_subsequence(nums): if not nums: return 0 n = len(nums) # dp[i] = nums[i]를 마지막 요소로 하는 LIS의 길이 dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] \u003e nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 최적 부분 구조가 없는 문제들 모든 문제가 최적 부분 구조를 가지는 것은 아니다.\n최장 경로 문제(Longest Path Problem, 일반 그래프) 일반 그래프에서의 최장 경로 문제는 최적 부분 구조를 가지지 않는다.\n노드 s에서 t까지의 최장 경로가 노드 u를 통과할 때, s에서 u까지의 부분 경로가 반드시 s에서 u까지의 최장 경로가 아닐 수 있다.\n반례:\n노드 s, u, v, t가 있는 그래프에서 s → u → t의 길이가 10, s → v → u → t의 길이가 15라고 가정한다.\ns에서 t까지의 최장 경로는 s → v → u → t이지만, s에서 u까지의 최장 경로는 s → v → u이다.\n그러나 이 경로를 선택하면 사이클을 형성하게 되어 최장 경로가 될 수 없다. 최대 독립 집합 문제(Maximum Independent Set, 일반 그래프) 일반 그래프에서의 최대 독립 집합 문제는 최적 부분 구조를 가지지 않는다.\n그래프의 일부에 대한 최대 독립 집합이 전체 그래프의 최대 독립 집합의 일부가 아닐 수 있다.\n참고:\n트리(Tree)에서의 최대 독립 집합 문제는 최적 부분 구조를 가지므로 동적 계획법으로 해결할 수 있다. 최장 단순 경로 문제(Longest Simple Path) 두 노드 간의 최장 단순 경로(반복된 노드가 없는 경로) 찾기는 최적 부분 구조를 가지지 않는다.\n경로의 단순성 제약이 하위 문제 간의 독립성을 깨뜨린다.\n실제 응용 사례에서의 최적 부분 구조 다익스트라 알고리즘(Dijkstra’s Algorithm) 다익스트라 알고리즘은 가중치가 있는 그래프에서 한 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘이다.\n이 알고리즘은 최적 부분 구조를 활용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import heapq def dijkstra(graph, start): n = len(graph) dist = [float('inf')] * n dist[start] = 0 # (거리, 노드) 쌍의 우선순위 큐 priority_queue = [(0, start)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) # 이미 처리된 노드는 건너뛰기 if current_dist \u003e dist[current_node]: continue # 인접 노드 탐색 for neighbor, weight in enumerate(graph[current_node]): if weight \u003e 0: # 연결된 노드만 처리 distance = current_dist + weight # 더 짧은 경로 발견 시 업데이트 (최적 부분 구조 활용) if distance \u003c dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist 배낭 문제(Knapsack Problem) 배낭 문제는 제한된 무게 내에서 최대 가치를 가지는 물건들을 선택하는 문제이다.\n0-1 배낭 문제는 최적 부분 구조를 가진다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def knapsack_01(weights, values, capacity): n = len(weights) # dp[i][w] = 처음 i개 물건으로 무게 w를 채울 때의 최대 가치 dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(1, n + 1): for w in range(1, capacity + 1): if weights[i-1] \u003c= w: # i번째 물건을 포함하거나 포함하지 않는 두 경우 중 최대값 선택 (최적 부분 구조) dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w]) else: # i번째 물건이 너무 무거워 포함할 수 없는 경우 dp[i][w] = dp[i-1][w] return dp[n][capacity] 문자열 편집 거리(Edit Distance) 두 문자열 간의 편집 거리는 한 문자열을 다른 문자열로 변환하는 데 필요한 최소 연산(삽입, 삭제, 대체) 횟수.\n이 문제는 최적 부분 구조를 가진다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def edit_distance(word1, word2): m, n = len(word1), len(word2) # dp[i][j] = word1[:i]를 word2[:j]로 변환하는 최소 연산 횟수 dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # 기본 케이스: 빈 문자열로 변환 for i in range(m + 1): dp[i][0] = i # 삭제 연산 for j in range(n + 1): dp[0][j] = j # 삽입 연산 for i in range(1, m + 1): for j in range(1, n + 1): if word1[i-1] == word2[j-1]: # 문자가 같으면 연산 필요 없음 dp[i][j] = dp[i-1][j-1] else: # 삽입, 삭제, 대체 중 최소 비용 선택 (최적 부분 구조) dp[i][j] = 1 + min(dp[i][j-1], # 삽입 dp[i-1][j], # 삭제 dp[i-1][j-1]) # 대체 return dp[m][n] 최적 부분 구조 비교 분석 다양한 알고리즘 문제의 최적 부분 구조 특성\n문제 최적 부분 구조 여부 최적 부분 구조 유형 점화식 시간 복잡도 공간 복잡도 그리디 가능 여부 피보나치 수열 O 선형 F(n) = F(n-1) + F(n-2) O(n) O(n) X 최단 경로(다익스트라) O 선형 d[v] = min(d[v], d[u] + w(u,v)) O(E log V) O(V) O 최장 증가 부분 수열 O 분기 LIS(i) = max(LIS(j) + 1) for j \u003c i and A[j] \u003c A[i] O(n²) O(n) X 배낭 문제(0-1) O 분기 DP[i][w] = max(DP[i-1][w], DP[i-1][w-wᵢ] + vᵢ) O(nW) O(nW) X 행렬 곱셈 연쇄 O 분기 DP[i][j] = min(DP[i][k] + DP[k+1][j] + cost) for i ≤ k \u003c j O(n³) O(n²) X 최장 공통 부분 수열 O 조건부 LCS[i][j] = 1 + LCS[i-1][j-1] if X[i] = Y[j] else max(LCS[i-1][j], LCS[i][j-1]) O(mn) O(mn) X 편집 거리 O 조건부 ED[i][j] = ED[i-1][j-1] if X[i]=Y[j] else 1+min(ED[i-1][j], ED[i][j-1], ED[i-1][j-1]) O(mn) O(mn) X 플로이드-워셜 O 중첩 dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) O(V³) O(V²) X 활동 선택 문제 O 선형 - (그리디 알고리즘으로 해결) O(n log n) O(1) O 허프만 코딩 O 분기 - (그리디 알고리즘으로 해결) O(n log n) O(n) O 최소 신장 트리 O 분기 - (그리디 알고리즘으로 해결) O(E log V) O(V+E) O 최장 경로(일반 그래프) X - - NP-hard - X 최대 독립 집합(일반 그래프) X - - NP-hard - X 최대 독립 집합(트리) O 분기 MIS(v) = max(1 + sum(MIS(grandchild)), sum(MIS(child))) O(n) O(n) X 분할 가능 배낭 문제 O 선형 - (그리디 알고리즘으로 해결) O(n log n) O(1) O 정수 분할 문제 O 분기 P(n, k) = P(n-k, k) + P(n, k-1) O(n²) O(n²) X 파일 합치기 문제 O 분기 DP[i][j] = min(DP[i][k] + DP[k+1][j]) + sum(A[i] to A[j]) O(n³) O(n²) X 최적 이진 검색 트리 O 분기 DP[i][j] = min(DP[i][k-1] + DP[k+1][j]) + sum(freq[i] to freq[j]) O(n³) O(n²) X 최적 부분 구조의 심화 개념 약한 최적 부분 구조와 강한 최적 부분 구조 최적 부분 구조는 그 특성의 강도에 따라 “약한(weak)” 또는 “강한(strong)” 최적 부분 구조로 구분할 수 있다.\n강한 최적 부분 구조: 문제의 최적해가 반드시 모든 하위 문제의 최적해를 포함한다. 하위 문제들의 최적해만 알면 전체 문제의 최적해를 구성할 수 있다. 예시: 최단 경로 문제, 0-1 배낭 문제 약한 최적 부분 구조: 문제의 최적해가 일부 하위 문제의 최적해를 포함할 수 있지만, 항상 그런 것은 아니다. 하위 문제의 최적해 이외에 추가 정보가 필요할 수 있다. 예시: 일부 제약 조건이 있는 최적화 문제 Non-Serial 동적 계획법과 최적 부분 구조 Non-Serial 동적 계획법은 하위 문제 간의 의존성이 복잡한 경우에 사용되는 기법이다.\n이 경우 최적 부분 구조도 더 복잡한 형태를 띠게 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def non_serial_dp_example(graph, weights): n = len(graph) # dp[mask] = mask에 포함된 노드들의 최적 부분 구조 값 dp = [float('inf')] * (1 \u003c\u003c n) dp[0] = 0 # 빈 집합의 값은 0 # 모든 가능한 부분집합에 대해 for mask in range(1, 1 \u003c\u003c n): # 집합 내 각 노드에 대해 for i in range(n): if mask \u0026 (1 \u003c\u003c i): # i가 mask에 포함되어 있다면 # i를 제외한 부분집합 prev_mask = mask \u0026 ~(1 \u003c\u003c i) # 인접한 노드들의 가중치 합산 additional_cost = 0 for j in range(n): if mask \u0026 (1 \u003c\u003c j) and graph[i][j]: additional_cost += weights[i][j] # 최적 부분 구조 활용 dp[mask] = min(dp[mask], dp[prev_mask] + additional_cost) return dp[(1 \u003c\u003c n) - 1] # 모든 노드를 포함한 집합의 값 최적 부분 구조와 상태 공간 축소 일부 문제에서는 상태 공간을 축소함으로써 최적 부분 구조를 더 효율적으로 활용할 수 있다.\n예시: 동전 교환 문제(Coin Change Problem)\n1 2 3 4 5 6 7 8 9 10 11 12 13 def coin_change_optimized(coins, amount): # 무한대로 초기화 dp = [float('inf')] * (amount + 1) dp[0] = 0 # 기본 사례: 금액이 0이면 동전 0개 필요 # 모든 동전에 대해 for coin in coins: # coin 이상의 모든 금액에 대해 for i in range(coin, amount + 1): # 최적 부분 구조: 현재 동전을 사용하거나 사용하지 않는 경우 중 최소값 dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1 이 예제에서는 모든 동전의 모든 조합을 고려하는 대신, 각 금액에 대한 최소 동전 수만 저장함으로써 상태 공간을 크게 축소했다.\n실제 개발 환경에서의 최적 부분 구조 활용 최적 부분 구조 기반 문제 해결 프레임워크 실제 개발 환경에서 최적 부분 구조를 활용한 문제 해결을 위한 일반적인 프레임워크:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class DPSolver: def __init__(self, problem_input): self.input = problem_input self.memo = {} # 메모이제이션을 위한 딕셔너리 def solve(self): # 문제 해결을 위한 진입점 return self._solve_recursive(self._get_initial_state()) def _get_initial_state(self): # 초기 상태 반환 (문제에 따라 구현) pass def _is_base_case(self, state): # 기저 사례 확인 (문제에 따라 구현) pass def _get_base_case_value(self, state): # 기저 사례 값 반환 (문제에 따라 구현) pass def _get_subproblems(self, state): # 현재 상태에서의 하위 문제들 반환 (문제에 따라 구현) pass def _combine_solutions(self, state, subproblem_solutions): # 하위 문제 해결책 결합 (문제에 따라 구현) # 최적 부분 구조 활용 지점 pass def _solve_recursive(self, state): # 이미 계산된 상태인지 확인 if state in self.memo: return self.memo[state] # 기저 사례 확인 if self._is_base_case(state): return self._get_base_case_value(state) # 하위 문제 해결 subproblems = self._get_subproblems(state) subproblem_solutions = [self._solve_recursive(subproblem) for subproblem in subproblems] # 하위 문제 해결책 결합 (최적 부분 구조 활용) result = self._combine_solutions(state, subproblem_solutions) # 메모이제이션 self.memo[state] = result return result 최적 부분 구조 기반 알고리즘의 테스트 및 디버깅 최적 부분 구조를 활용한 알고리즘을 테스트하고 디버깅하는 방법은 다음과 같다:\n작은 입력으로 테스트: 손으로 계산할 수 있는 작은 입력으로 알고리즘을 테스트. 단계별 상태 추적: 각 단계에서의 상태와 하위 문제의 해결책을 추적. 기저 사례 확인: 기저 사례가 올바르게 처리되는지 확인. 점화식 검증: 점화식이 문제의 최적 부분 구조를 정확히 표현하는지 검증. 경계 조건 테스트: 최소값, 최대값, 빈 입력 등 경계 조건을 테스트. 1 2 3 4 5 6 7 8 9 10 def debug_dynamic_programming(dp_function, test_cases): for i, (input_data, expected_output) in enumerate(test_cases): result = dp_function(input_data) print(f\"Test Case {i+1}:\") print(f\"Input: {input_data}\") print(f\"Expected: {expected_output}\") print(f\"Result: {result}\") print(f\"Status: {'PASS' if result == expected_output else 'FAIL'}\") print(\"-\" * 40) 최적화 사례 연구 예시: 최장 증가 부분 수열(LIS) 최적화\n기본 O(n²) 알고리즘에서 O(n log n) 알고리즘으로 최적화하는 과정:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # 기본 O(n²) 알고리즘 def longest_increasing_subsequence_basic(nums): if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] \u003e nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # 최적화된 O(n log n) 알고리즘 def longest_increasing_subsequence_optimized(nums): if not nums: return 0 # tails[i] = 길이가 i+1인 LIS의 마지막 요소 중 가능한 가장 작은 값 tails = [] for num in nums: # 이진 검색으로 num이 들어갈 위치 찾기 idx = bisect.bisect_left(tails, num) if idx == len(tails): # num이 모든 값보다 크면 추가 tails.append(num) else: # 그렇지 않으면 해당 위치의 값 업데이트 tails[idx] = num return len(tails) 이 최적화는 최적 부분 구조를 더 효율적으로 활용하기 위해 다른 방식으로 하위 문제를 정의했다.\n기본 알고리즘은 “인덱스 i까지의 최장 증가 부분 수열의 길이\"를 저장했지만, 최적화된 알고리즘은 “길이가 i인 증가 부분 수열의 마지막 요소 중 가능한 가장 작은 값\"을 저장한다.\n실무 적용 가이드 최적 부분 구조의 핵심 요약\n정의: 문제의 최적해가 하위 문제들의 최적해로 구성되는 특성 조건: 하위 문제의 최적성, 독립적 최적화, 부분 해결책 결합, 재귀적 정의 중요성: 동적 계획법과 그리디 알고리즘 적용의 기반 유형: 선형, 분기, 조건부, 중첩 최적 부분 구조 증명 방법: 귀류법, 최적성 원리를 통한 증명 개발자를 위한 최적 부분 구조 확인 체크리스트\n문제 분해 가능성: 문제가 작은 하위 문제로 분해될 수 있는가? 하위 문제 중복: 동일한 하위 문제가 여러 번 발생하는가? 최적해 구성: 전체 문제의 최적해가 하위 문제들의 최적해로 구성되는가? 독립성: 하위 문제들을 독립적으로 해결할 수 있는가? 결합 가능성: 하위 문제들의 해결책을 효율적으로 결합하여 전체 문제의 해결책을 구성할 수 있는가? 다양한 문제 유형별 최적 부분 구조 활용 지침\n최적화 문제: 하위 문제의 최적해를 저장하고 재사용한다. 점화식이 최적 부분 구조를 정확히 반영하는지 확인한다. 계산 문제: 중복 계산을 피하기 위해 메모이제이션 또는 테이블링을 사용한다. 기저 사례를 명확히 정의한다. 경로 문제: 부분 경로의 최적성을 확인한다. 사이클이 있는 경우 특별한 처리가 필요할 수 있다. 조합 문제: 상태 정의가 문제의 제약 조건을 모두 포함하는지 확인한다. 중복 상태를 효율적으로 처리한다. 참고 및 출처 ","wordCount":"3286","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-22T14:02:00Z","dateModified":"2025-01-22T14:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/optimal-substructure/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/>동적 계획법 (Dynamic Programming)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/>Principles of Dynamic Programming</a></div><h1 class="post-title entry-hint-parent">최적 부분 구조(Optimal Substructure)</h1><div class=post-description>최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.</div><div class=post-meta><span title='2025-01-22 14:02:00 +0000 UTC'>January 22, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Fundamental%20Paradigms/Dynamic%20Programming/DP%20Principles/optimal-substructure.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#최적-부분-구조optimal-substructure>최적 부분 구조(Optimal Substructure)</a><ul><li><a href=#최적-부분-구조optimal-substructure의-기본-개념>최적 부분 구조(Optimal Substructure)의 기본 개념</a></li><li><a href=#최적-부분-구조의-판별-및-증명-방법>최적 부분 구조의 판별 및 증명 방법</a></li><li><a href=#최적-부분-구조-설계-및-분석-방법>최적 부분 구조 설계 및 분석 방법</a></li><li><a href=#다양한-최적-부분-구조-유형>다양한 최적 부분 구조 유형</a></li><li><a href=#최적-부분-구조의-일반적인-예시와-증명>최적 부분 구조의 일반적인 예시와 증명</a></li><li><a href=#최적-부분-구조가-없는-문제들>최적 부분 구조가 없는 문제들</a></li><li><a href=#실제-응용-사례에서의-최적-부분-구조>실제 응용 사례에서의 최적 부분 구조</a></li><li><a href=#최적-부분-구조-비교-분석>최적 부분 구조 비교 분석</a></li><li><a href=#최적-부분-구조의-심화-개념>최적 부분 구조의 심화 개념</a></li><li><a href=#실제-개발-환경에서의-최적-부분-구조-활용>실제 개발 환경에서의 최적 부분 구조 활용</a></li><li><a href=#실무-적용-가이드>실무 적용 가이드</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=최적-부분-구조optimal-substructure>최적 부분 구조(Optimal Substructure)<a hidden class=anchor aria-hidden=true href=#최적-부분-구조optimal-substructure>#</a></h2><p>동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.<br>동적 계획법이 적용되기 위해서는 두 가지 핵심 특성이 필요하다:</p><ul><li>중복되는 하위 문제(Overlapping Subproblems)</li><li>최적 부분 구조(Optimal Substructure)<br>이다.</li></ul><p>최적 부분 구조는 효율적인 알고리즘 설계의 핵심 개념이다.<br>문제의 특성을 이해하고 최적 부분 구조를 식별할 수 있다면, 복잡한 문제도 동적 계획법이나 그리디 알고리즘을 통해 효율적으로 해결할 수 있다.<br>최적 부분 구조가 없는 문제는 다른 접근 방식(예: 분할 정복, 백트래킹)을 고려해야 한다.</p><h3 id=최적-부분-구조optimal-substructure의-기본-개념>최적 부분 구조(Optimal Substructure)의 기본 개념<a hidden class=anchor aria-hidden=true href=#최적-부분-구조optimal-substructure의-기본-개념>#</a></h3><p>최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.<br>다시 말해, 문제의 최적 해결책이 하위 문제들의 최적 해결책으로 구성되어 있다면 해당 문제는 최적 부분 구조를 가진다고 한다.</p><h4 id=최적-부분-구조의-핵심-특성>최적 부분 구조의 핵심 특성<a hidden class=anchor aria-hidden=true href=#최적-부분-구조의-핵심-특성>#</a></h4><ol><li><strong>하위 문제의 최적성</strong>: 전체 문제의 최적해에 포함된 하위 문제의 해결책은 그 하위 문제에 대해서도 최적해야 한다.</li><li><strong>독립적 최적화</strong>: 하위 문제들은 독립적으로 최적화할 수 있어야 한다.</li><li><strong>부분 해결책 결합</strong>: 하위 문제들의 최적해를 결합하여 전체 문제의 최적해를 구할 수 있어야 한다.</li><li><strong>재귀적 정의 가능</strong>: 문제를 더 작은 하위 문제들로 재귀적으로 정의할 수 있어야 한다.</li></ol><h4 id=수학적-정의>수학적 정의<a hidden class=anchor aria-hidden=true href=#수학적-정의>#</a></h4><p>문제 P가 최적 부분 구조를 가진다는 것은 다음과 같이 표현할 수 있다:</p><ul><li>문제 P의 최적해를 OPT(P)라고 한다.</li><li>P가 하위 문제 P₁, P₂, …, Pₙ으로 분할될 수 있다면,</li><li>OPT(P) = F(OPT(P₁), OPT(P₂), …, OPT(Pₙ))와 같이 표현할 수 있다.</li><li>여기서 F는 하위 문제들의 최적해를 결합하는 함수이다.</li></ul><h4 id=최적-부분-구조의-중요성>최적 부분 구조의 중요성<a hidden class=anchor aria-hidden=true href=#최적-부분-구조의-중요성>#</a></h4><p>최적 부분 구조는 동적 계획법을 적용하기 위한 필수 조건이다.<br>이 속성이 있어야만 문제를 작은 하위 문제로 분할하고, 그 결과를 저장하여 중복 계산을 피할 수 있다.<br>최적 부분 구조가 없다면, 하위 문제의 해결책이 전체 문제의 최적해를 보장하지 않기 때문에 동적 계획법을 적용할 수 없다.</p><h3 id=최적-부분-구조의-판별-및-증명-방법>최적 부분 구조의 판별 및 증명 방법<a hidden class=anchor aria-hidden=true href=#최적-부분-구조의-판별-및-증명-방법>#</a></h3><h4 id=직관적-접근>직관적 접근<a hidden class=anchor aria-hidden=true href=#직관적-접근>#</a></h4><p>문제가 최적 부분 구조를 가지는지 직관적으로 판단하는 방법은 다음과 같다:</p><ol><li><strong>하위 문제 분해</strong>: 주어진 문제를 하위 문제로 분해해본다.</li><li><strong>최적해 구성 확인</strong>: 전체 문제의 최적해가 하위 문제들의 최적해로 구성되는지 확인한다.</li><li><strong>독립성 검증</strong>: 하위 문제들이 서로 독립적으로 최적화될 수 있는지 확인한다.</li></ol><h4 id=증명-방법-귀류법proof-by-contradiction>증명 방법: 귀류법(Proof by Contradiction)<a hidden class=anchor aria-hidden=true href=#증명-방법-귀류법proof-by-contradiction>#</a></h4><p>최적 부분 구조를 증명하는 일반적인 방법은 귀류법을 사용하는 것:</p><ol><li><strong>가정</strong>: 문제 P의 최적해 S가 하위 문제 P&rsquo;의 최적해를 포함하지 않는다고 가정한다.</li><li><strong>대체</strong>: 하위 문제 P&rsquo;의 최적해 S&rsquo;가 존재한다면, S 내의 P&rsquo;에 대한 해결책을 S&rsquo;로 대체한다.</li><li><strong>모순 찾기</strong>: 대체 후의 해결책이 원래의 최적해 S보다 더 나은 결과를 제공한다면, 이는 S가 최적이라는 가정에 모순된다.</li><li><strong>결론</strong>: 이러한 모순이 발생한다면, 원래 가정이 틀렸다는 것이 증명되므로 문제 P는 최적 부분 구조를 가진다.</li></ol><h4 id=최적성-원리principle-of-optimality>최적성 원리(Principle of Optimality)<a hidden class=anchor aria-hidden=true href=#최적성-원리principle-of-optimality>#</a></h4><p>벨만(Richard Bellman)의 최적성 원리는 최적 부분 구조를 다음과 같이 설명한다:</p><blockquote><p>&ldquo;최적 정책(최적해를 구하는 방법)은 다음과 같은 특성을 가진다:</p><ul><li>초기 상태와 초기 결정이 무엇이든, 남은 결정들은 초기 결정의 결과로 발생하는 상태에 대해 최적 정책을 구성해야 한다.&rdquo;</li></ul></blockquote><p>이 원리는 최적 부분 구조의 핵심적인 이론적 근거가 된다.</p><h3 id=최적-부분-구조-설계-및-분석-방법>최적 부분 구조 설계 및 분석 방법<a hidden class=anchor aria-hidden=true href=#최적-부분-구조-설계-및-분석-방법>#</a></h3><ol><li>상태 정의와 최적 부분 구조 식별<ol><li><strong>문제 분석</strong>: 문제의 특성과 제약 조건을 이해한다.</li><li><strong>상태 정의</strong>: 문제의 상태를 명확하게 정의한다. 상태는 하위 문제를 구분하는 변수들의 집합이다.</li><li><strong>재귀 관계 식별</strong>: 현재 상태와 하위 상태 간의 관계를 정의한다.</li><li><strong>최적 부분 구조 검증</strong>: 정의한 관계가 최적 부분 구조 조건을 만족하는지 확인한다.</li></ol></li><li>최적 부분 구조를 활용한 동적 계획법 설계 단계<ol><li><strong>상태 정의</strong>: 문제의 상태를 정의한다.</li><li><strong>점화식 도출</strong>: 상태 간의 전이를 나타내는 점화식을 도출한다.</li><li><strong>기저 사례 정의</strong>: 가장 작은 하위 문제에 대한 해결책을 정의한다.</li><li><strong>계산 순서 결정</strong>: 상향식(bottom-up) 또는 하향식(top-down) 접근 방식을 선택한다.</li><li><strong>구현 및 최적화</strong>: 선택한 접근 방식으로 알고리즘을 구현하고 필요시 최적화한다.</li></ol></li><li>최적 부분 구조 활용의 실패 사례와 해결 방법<ol><li><strong>상태 불충분</strong>: 현재 상태 정의가 문제를 완전히 표현하지 못하는 경우<ul><li><strong>해결</strong>: 상태 정의를 확장하여 필요한 정보를 모두 포함시킵니다.</li></ul></li><li><strong>의존성 문제</strong>: 하위 문제 간 의존성이 있어 독립적으로 최적화할 수 없는 경우<ul><li><strong>해결</strong>: 의존성을 상태 정의에 포함시키거나, 문제 분해 방식을 변경한다.</li></ul></li><li><strong>제약 조건 충돌</strong>: 문제의 제약 조건이 최적 부분 구조를 방해하는 경우<ul><li><strong>해결</strong>: 제약 조건을 상태 정의에 포함시키거나, 제약 조건을 고려한 새로운 하위 문제 구조를 설계한다.</li></ul></li></ol></li></ol><h3 id=다양한-최적-부분-구조-유형>다양한 최적 부분 구조 유형<a hidden class=anchor aria-hidden=true href=#다양한-최적-부분-구조-유형>#</a></h3><h4 id=선형-최적-부분-구조linear-optimal-substructure>선형 최적 부분 구조(Linear Optimal Substructure)<a hidden class=anchor aria-hidden=true href=#선형-최적-부분-구조linear-optimal-substructure>#</a></h4><p>가장 단순한 형태로, 문제의 최적해가 하나의 하위 문제의 최적해에만 의존하는 경우.</p><p><strong>예시</strong>: 피보나치 수열</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_dp</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># DP 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상향식(bottom-up) 접근</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>  <span class=c1># 선형 최적 부분 구조</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=분기-최적-부분-구조branching-optimal-substructure>분기 최적 부분 구조(Branching Optimal Substructure)<a hidden class=anchor aria-hidden=true href=#분기-최적-부분-구조branching-optimal-substructure>#</a></h4><p>문제의 최적해가 둘 이상의 독립적인 하위 문제의 최적해에 의존하는 경우.</p><p><strong>예시</strong>: 행렬 곱셈 연쇄(Matrix Chain Multiplication)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>matrix_chain_multiplication</span><span class=p>(</span><span class=n>dimensions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>dimensions</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>  <span class=c1># 행렬 개수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># m[i][j] = i부터 j까지의 행렬을 곱하는 최소 연산 횟수</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 연쇄 길이 l을 2부터 n까지 증가시키며 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>l</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>l</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>l</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 최적의 분할 지점 k 찾기 (분기 최적 부분 구조)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>cost</span> <span class=o>=</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>m</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>dimensions</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>dimensions</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>dimensions</span><span class=p>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>cost</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>cost</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>m</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=조건부-최적-부분-구조conditional-optimal-substructure>조건부 최적 부분 구조(Conditional Optimal Substructure)<a hidden class=anchor aria-hidden=true href=#조건부-최적-부분-구조conditional-optimal-substructure>#</a></h4><p>특정 조건이 만족될 때만 최적 부분 구조를 가지는 경우.</p><p><strong>예시</strong>: 최장 공통 부분 수열(Longest Common Subsequence)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_common_subsequence</span><span class=p>(</span><span class=n>text1</span><span class=p>,</span> <span class=n>text2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>text1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>text2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = text1[:i]와 text2[:j]의 LCS 길이</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>text1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>text2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 문자가 같으면 대각선 값에 1 더함 (조건부 최적 부분 구조)</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 문자가 다르면 왼쪽 또는 위쪽 값 중 최대값</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=중첩-최적-부분-구조nested-optimal-substructure>중첩 최적 부분 구조(Nested Optimal Substructure)<a hidden class=anchor aria-hidden=true href=#중첩-최적-부분-구조nested-optimal-substructure>#</a></h4><p>하위 문제의 최적해를 구하기 위해 또 다른 최적 부분 구조 문제를 해결해야 하는 경우.</p><p><strong>예시</strong>: 최단 경로 문제의 플로이드-워셜 알고리즘(Floyd-Warshall Algorithm)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>floyd_warshall</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[:]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>]</span>  <span class=c1># 그래프 복사</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># k = 중간 정점, i = 시작 정점, j = 종료 정점</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># i에서 j로 가는 최단 경로 업데이트 (중첩 최적 부분 구조)</span>
</span></span><span class=line><span class=cl>                <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dist</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=최적-부분-구조의-일반적인-예시와-증명>최적 부분 구조의 일반적인 예시와 증명<a hidden class=anchor aria-hidden=true href=#최적-부분-구조의-일반적인-예시와-증명>#</a></h3><h4 id=최단-경로-문제shortest-path-problem>최단 경로 문제(Shortest Path Problem)<a hidden class=anchor aria-hidden=true href=#최단-경로-문제shortest-path-problem>#</a></h4><p>노드 s에서 노드 t까지의 최단 경로가 u를 통과한다면, s에서 u까지의 부분 경로와 u에서 t까지의 부분 경로도 각각 최단 경로이다.</p><p><strong>증명</strong>:</p><ul><li>s에서 t까지의 최단 경로를 P라고 하고, 이 경로가 노드 u를 통과한다고 가정한다.</li><li>P를 s에서 u까지의 부분 경로 P₁과 u에서 t까지의 부분 경로 P₂로 나눈다.</li><li>만약 P₁이 s에서 u까지의 최단 경로가 아니라면, 더 짧은 경로 P₁&rsquo;이 존재할 것이다.</li><li>이 경우 P₁&rsquo;과 P₂를 합친 경로는 P보다 짧아지므로, P가 최단 경로라는 가정에 모순된다.</li><li>같은 방식으로 P₂도 u에서 t까지의 최단 경로임을 증명할 수 있다.</li></ul><h4 id=최장-증가-부분-수열longest-increasing-subsequence>최장 증가 부분 수열(Longest Increasing Subsequence)<a hidden class=anchor aria-hidden=true href=#최장-증가-부분-수열longest-increasing-subsequence>#</a></h4><p>배열의 최장 증가 부분 수열(LIS)은 최적 부분 구조를 가진다.</p><p><strong>증명</strong>:</p><ul><li>배열 A의 최장 증가 부분 수열을 L이라고 하고, 마지막 요소가 A[j]라고 가정한다.</li><li>L의 마지막 요소를 제외한 부분 수열 L&rsquo;은 A[0..j-1]에서의 최장 증가 부분 수열이어야 한다.</li><li>만약 L&rsquo;이 최장이 아니라면, A[0..j-1]에서 더 긴 증가 부분 수열 L&rsquo;&lsquo;이 존재할 것이다.</li><li>이 경우 L&rsquo;&lsquo;에 A[j]를 추가하면 L보다 긴 증가 부분 수열이 되므로, L이 최장이라는 가정에 모순된다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i] = nums[i]를 마지막 요소로 하는 LIS의 길이</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=최적-부분-구조가-없는-문제들>최적 부분 구조가 없는 문제들<a hidden class=anchor aria-hidden=true href=#최적-부분-구조가-없는-문제들>#</a></h3><p>모든 문제가 최적 부분 구조를 가지는 것은 아니다.</p><h4 id=최장-경로-문제longest-path-problem-일반-그래프>최장 경로 문제(Longest Path Problem, 일반 그래프)<a hidden class=anchor aria-hidden=true href=#최장-경로-문제longest-path-problem-일반-그래프>#</a></h4><p>일반 그래프에서의 최장 경로 문제는 최적 부분 구조를 가지지 않는다.<br>노드 s에서 t까지의 최장 경로가 노드 u를 통과할 때, s에서 u까지의 부분 경로가 반드시 s에서 u까지의 최장 경로가 아닐 수 있다.</p><ul><li><strong>반례</strong>:<br>노드 s, u, v, t가 있는 그래프에서 s → u → t의 길이가 10, s → v → u → t의 길이가 15라고 가정한다.<br>s에서 t까지의 최장 경로는 s → v → u → t이지만, s에서 u까지의 최장 경로는 s → v → u이다.<br>그러나 이 경로를 선택하면 사이클을 형성하게 되어 최장 경로가 될 수 없다.</li></ul><h4 id=최대-독립-집합-문제maximum-independent-set-일반-그래프>최대 독립 집합 문제(Maximum Independent Set, 일반 그래프)<a hidden class=anchor aria-hidden=true href=#최대-독립-집합-문제maximum-independent-set-일반-그래프>#</a></h4><p>일반 그래프에서의 최대 독립 집합 문제는 최적 부분 구조를 가지지 않는다.<br>그래프의 일부에 대한 최대 독립 집합이 전체 그래프의 최대 독립 집합의 일부가 아닐 수 있다.</p><ul><li><strong>참고</strong>:<br>트리(Tree)에서의 최대 독립 집합 문제는 최적 부분 구조를 가지므로 동적 계획법으로 해결할 수 있다.</li></ul><h4 id=최장-단순-경로-문제longest-simple-path>최장 단순 경로 문제(Longest Simple Path)<a hidden class=anchor aria-hidden=true href=#최장-단순-경로-문제longest-simple-path>#</a></h4><p>두 노드 간의 최장 단순 경로(반복된 노드가 없는 경로) 찾기는 최적 부분 구조를 가지지 않는다.<br>경로의 단순성 제약이 하위 문제 간의 독립성을 깨뜨린다.</p><h3 id=실제-응용-사례에서의-최적-부분-구조>실제 응용 사례에서의 최적 부분 구조<a hidden class=anchor aria-hidden=true href=#실제-응용-사례에서의-최적-부분-구조>#</a></h3><h4 id=다익스트라-알고리즘dijkstras-algorithm>다익스트라 알고리즘(Dijkstra&rsquo;s Algorithm)<a hidden class=anchor aria-hidden=true href=#다익스트라-알고리즘dijkstras-algorithm>#</a></h4><p>다익스트라 알고리즘은 가중치가 있는 그래프에서 한 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘이다.<br>이 알고리즘은 최적 부분 구조를 활용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># (거리, 노드) 쌍의 우선순위 큐</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_dist</span><span class=p>,</span> <span class=n>current_node</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이미 처리된 노드는 건너뛰기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_dist</span> <span class=o>&gt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>current_node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 인접 노드 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>graph</span><span class=p>[</span><span class=n>current_node</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weight</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># 연결된 노드만 처리</span>
</span></span><span class=line><span class=cl>                <span class=n>distance</span> <span class=o>=</span> <span class=n>current_dist</span> <span class=o>+</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 더 짧은 경로 발견 시 업데이트 (최적 부분 구조 활용)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>distance</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dist</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span>
</span></span><span class=line><span class=cl>                    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=n>distance</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dist</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=배낭-문제knapsack-problem>배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#배낭-문제knapsack-problem>#</a></h4><p>배낭 문제는 제한된 무게 내에서 최대 가치를 가지는 물건들을 선택하는 문제이다.<br>0-1 배낭 문제는 최적 부분 구조를 가진다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_01</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][w] = 처음 i개 물건으로 무게 w를 채울 때의 최대 가치</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>w</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>capacity</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>w</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># i번째 물건을 포함하거나 포함하지 않는 두 경우 중 최대값 선택 (최적 부분 구조)</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=o>-</span><span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># i번째 물건이 너무 무거워 포함할 수 없는 경우</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>w</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>capacity</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=문자열-편집-거리edit-distance>문자열 편집 거리(Edit Distance)<a hidden class=anchor aria-hidden=true href=#문자열-편집-거리edit-distance>#</a></h4><p>두 문자열 간의 편집 거리는 한 문자열을 다른 문자열로 변환하는 데 필요한 최소 연산(삽입, 삭제, 대체) 횟수.<br>이 문제는 최적 부분 구조를 가진다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>edit_distance</span><span class=p>(</span><span class=n>word1</span><span class=p>,</span> <span class=n>word2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>word1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>word2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># dp[i][j] = word1[:i]를 word2[:j]로 변환하는 최소 연산 횟수</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 빈 문자열로 변환</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>  <span class=c1># 삭제 연산</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span>  <span class=c1># 삽입 연산</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>word1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>word2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 문자가 같으면 연산 필요 없음</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 삽입, 삭제, 대체 중 최소 비용 선택 (최적 부분 구조)</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span>      <span class=c1># 삽입</span>
</span></span><span class=line><span class=cl>                                   <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span>      <span class=c1># 삭제</span>
</span></span><span class=line><span class=cl>                                   <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>    <span class=c1># 대체</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=최적-부분-구조-비교-분석>최적 부분 구조 비교 분석<a hidden class=anchor aria-hidden=true href=#최적-부분-구조-비교-분석>#</a></h3><p>다양한 알고리즘 문제의 최적 부분 구조 특성</p><table><thead><tr><th>문제</th><th>최적 부분 구조 여부</th><th>최적 부분 구조 유형</th><th>점화식</th><th>시간 복잡도</th><th>공간 복잡도</th><th>그리디 가능 여부</th></tr></thead><tbody><tr><td><strong>피보나치 수열</strong></td><td>O</td><td>선형</td><td>F(n) = F(n-1) + F(n-2)</td><td>O(n)</td><td>O(n)</td><td>X</td></tr><tr><td><strong>최단 경로(다익스트라)</strong></td><td>O</td><td>선형</td><td>d[v] = min(d[v], d[u] + w(u,v))</td><td>O(E log V)</td><td>O(V)</td><td>O</td></tr><tr><td><strong>최장 증가 부분 수열</strong></td><td>O</td><td>분기</td><td>LIS(i) = max(LIS(j) + 1) for j &lt; i and A[j] &lt; A[i]</td><td>O(n²)</td><td>O(n)</td><td>X</td></tr><tr><td><strong>배낭 문제(0-1)</strong></td><td>O</td><td>분기</td><td>DP[i][w] = max(DP[i-1][w], DP[i-1][w-wᵢ] + vᵢ)</td><td>O(nW)</td><td>O(nW)</td><td>X</td></tr><tr><td><strong>행렬 곱셈 연쇄</strong></td><td>O</td><td>분기</td><td>DP[i][j] = min(DP[i][k] + DP[k+1][j] + cost) for i ≤ k &lt; j</td><td>O(n³)</td><td>O(n²)</td><td>X</td></tr><tr><td><strong>최장 공통 부분 수열</strong></td><td>O</td><td>조건부</td><td>LCS[i][j] = 1 + LCS[i-1][j-1] if X[i] = Y[j] else max(LCS[i-1][j], LCS[i][j-1])</td><td>O(mn)</td><td>O(mn)</td><td>X</td></tr><tr><td><strong>편집 거리</strong></td><td>O</td><td>조건부</td><td>ED[i][j] = ED[i-1][j-1] if X[i]=Y[j] else 1+min(ED[i-1][j], ED[i][j-1], ED[i-1][j-1])</td><td>O(mn)</td><td>O(mn)</td><td>X</td></tr><tr><td><strong>플로이드-워셜</strong></td><td>O</td><td>중첩</td><td>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</td><td>O(V³)</td><td>O(V²)</td><td>X</td></tr><tr><td><strong>활동 선택 문제</strong></td><td>O</td><td>선형</td><td>- (그리디 알고리즘으로 해결)</td><td>O(n log n)</td><td>O(1)</td><td>O</td></tr><tr><td><strong>허프만 코딩</strong></td><td>O</td><td>분기</td><td>- (그리디 알고리즘으로 해결)</td><td>O(n log n)</td><td>O(n)</td><td>O</td></tr><tr><td><strong>최소 신장 트리</strong></td><td>O</td><td>분기</td><td>- (그리디 알고리즘으로 해결)</td><td>O(E log V)</td><td>O(V+E)</td><td>O</td></tr><tr><td><strong>최장 경로(일반 그래프)</strong></td><td>X</td><td>-</td><td>-</td><td>NP-hard</td><td>-</td><td>X</td></tr><tr><td><strong>최대 독립 집합(일반 그래프)</strong></td><td>X</td><td>-</td><td>-</td><td>NP-hard</td><td>-</td><td>X</td></tr><tr><td><strong>최대 독립 집합(트리)</strong></td><td>O</td><td>분기</td><td>MIS(v) = max(1 + sum(MIS(grandchild)), sum(MIS(child)))</td><td>O(n)</td><td>O(n)</td><td>X</td></tr><tr><td><strong>분할 가능 배낭 문제</strong></td><td>O</td><td>선형</td><td>- (그리디 알고리즘으로 해결)</td><td>O(n log n)</td><td>O(1)</td><td>O</td></tr><tr><td><strong>정수 분할 문제</strong></td><td>O</td><td>분기</td><td>P(n, k) = P(n-k, k) + P(n, k-1)</td><td>O(n²)</td><td>O(n²)</td><td>X</td></tr><tr><td><strong>파일 합치기 문제</strong></td><td>O</td><td>분기</td><td>DP[i][j] = min(DP[i][k] + DP[k+1][j]) + sum(A[i] to A[j])</td><td>O(n³)</td><td>O(n²)</td><td>X</td></tr><tr><td><strong>최적 이진 검색 트리</strong></td><td>O</td><td>분기</td><td>DP[i][j] = min(DP[i][k-1] + DP[k+1][j]) + sum(freq[i] to freq[j])</td><td>O(n³)</td><td>O(n²)</td><td>X</td></tr></tbody></table><h3 id=최적-부분-구조의-심화-개념>최적 부분 구조의 심화 개념<a hidden class=anchor aria-hidden=true href=#최적-부분-구조의-심화-개념>#</a></h3><h4 id=약한-최적-부분-구조와-강한-최적-부분-구조>약한 최적 부분 구조와 강한 최적 부분 구조<a hidden class=anchor aria-hidden=true href=#약한-최적-부분-구조와-강한-최적-부분-구조>#</a></h4><p>최적 부분 구조는 그 특성의 강도에 따라 &ldquo;약한(weak)&rdquo; 또는 &ldquo;강한(strong)&rdquo; 최적 부분 구조로 구분할 수 있다.</p><ol><li><strong>강한 최적 부분 구조</strong>:<ul><li>문제의 최적해가 반드시 모든 하위 문제의 최적해를 포함한다.</li><li>하위 문제들의 최적해만 알면 전체 문제의 최적해를 구성할 수 있다.</li><li>예시: 최단 경로 문제, 0-1 배낭 문제</li></ul></li><li><strong>약한 최적 부분 구조</strong>:<ul><li>문제의 최적해가 일부 하위 문제의 최적해를 포함할 수 있지만, 항상 그런 것은 아니다.</li><li>하위 문제의 최적해 이외에 추가 정보가 필요할 수 있다.</li><li>예시: 일부 제약 조건이 있는 최적화 문제</li></ul></li></ol><h4 id=non-serial-동적-계획법과-최적-부분-구조>Non-Serial 동적 계획법과 최적 부분 구조<a hidden class=anchor aria-hidden=true href=#non-serial-동적-계획법과-최적-부분-구조>#</a></h4><p>Non-Serial 동적 계획법은 하위 문제 간의 의존성이 복잡한 경우에 사용되는 기법이다.<br>이 경우 최적 부분 구조도 더 복잡한 형태를 띠게 된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>non_serial_dp_example</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>weights</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># dp[mask] = mask에 포함된 노드들의 최적 부분 구조 값</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 빈 집합의 값은 0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 부분집합에 대해</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>mask</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 집합 내 각 노드에 대해</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>):</span>  <span class=c1># i가 mask에 포함되어 있다면</span>
</span></span><span class=line><span class=cl>                <span class=c1># i를 제외한 부분집합</span>
</span></span><span class=line><span class=cl>                <span class=n>prev_mask</span> <span class=o>=</span> <span class=n>mask</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 인접한 노드들의 가중치 합산</span>
</span></span><span class=line><span class=cl>                <span class=n>additional_cost</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>)</span> <span class=ow>and</span> <span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                        <span class=n>additional_cost</span> <span class=o>+=</span> <span class=n>weights</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 최적 부분 구조 활용</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>mask</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>prev_mask</span><span class=p>]</span> <span class=o>+</span> <span class=n>additional_cost</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1># 모든 노드를 포함한 집합의 값</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최적-부분-구조와-상태-공간-축소>최적 부분 구조와 상태 공간 축소<a hidden class=anchor aria-hidden=true href=#최적-부분-구조와-상태-공간-축소>#</a></h4><p>일부 문제에서는 상태 공간을 축소함으로써 최적 부분 구조를 더 효율적으로 활용할 수 있다.</p><p><strong>예시: 동전 교환 문제(Coin Change Problem)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>coin_change_optimized</span><span class=p>(</span><span class=n>coins</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 무한대로 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=p>(</span><span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 기본 사례: 금액이 0이면 동전 0개 필요</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 동전에 대해</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># coin 이상의 모든 금액에 대해</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>coin</span><span class=p>,</span> <span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 최적 부분 구조: 현재 동전을 사용하거나 사용하지 않는 경우 중 최소값</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>coin</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=o>!=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>이 예제에서는 모든 동전의 모든 조합을 고려하는 대신, 각 금액에 대한 최소 동전 수만 저장함으로써 상태 공간을 크게 축소했다.</p><h3 id=실제-개발-환경에서의-최적-부분-구조-활용>실제 개발 환경에서의 최적 부분 구조 활용<a hidden class=anchor aria-hidden=true href=#실제-개발-환경에서의-최적-부분-구조-활용>#</a></h3><h4 id=최적-부분-구조-기반-문제-해결-프레임워크>최적 부분 구조 기반 문제 해결 프레임워크<a hidden class=anchor aria-hidden=true href=#최적-부분-구조-기반-문제-해결-프레임워크>#</a></h4><p>실제 개발 환경에서 최적 부분 구조를 활용한 문제 해결을 위한 일반적인 프레임워크:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span><span class=lnt id=hl-10-32><a class=lnlinks href=#hl-10-32>32</a>
</span><span class=lnt id=hl-10-33><a class=lnlinks href=#hl-10-33>33</a>
</span><span class=lnt id=hl-10-34><a class=lnlinks href=#hl-10-34>34</a>
</span><span class=lnt id=hl-10-35><a class=lnlinks href=#hl-10-35>35</a>
</span><span class=lnt id=hl-10-36><a class=lnlinks href=#hl-10-36>36</a>
</span><span class=lnt id=hl-10-37><a class=lnlinks href=#hl-10-37>37</a>
</span><span class=lnt id=hl-10-38><a class=lnlinks href=#hl-10-38>38</a>
</span><span class=lnt id=hl-10-39><a class=lnlinks href=#hl-10-39>39</a>
</span><span class=lnt id=hl-10-40><a class=lnlinks href=#hl-10-40>40</a>
</span><span class=lnt id=hl-10-41><a class=lnlinks href=#hl-10-41>41</a>
</span><span class=lnt id=hl-10-42><a class=lnlinks href=#hl-10-42>42</a>
</span><span class=lnt id=hl-10-43><a class=lnlinks href=#hl-10-43>43</a>
</span><span class=lnt id=hl-10-44><a class=lnlinks href=#hl-10-44>44</a>
</span><span class=lnt id=hl-10-45><a class=lnlinks href=#hl-10-45>45</a>
</span><span class=lnt id=hl-10-46><a class=lnlinks href=#hl-10-46>46</a>
</span><span class=lnt id=hl-10-47><a class=lnlinks href=#hl-10-47>47</a>
</span><span class=lnt id=hl-10-48><a class=lnlinks href=#hl-10-48>48</a>
</span><span class=lnt id=hl-10-49><a class=lnlinks href=#hl-10-49>49</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>DPSolver</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>problem_input</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>input</span> <span class=o>=</span> <span class=n>problem_input</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>memo</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 메모이제이션을 위한 딕셔너리</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>solve</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 문제 해결을 위한 진입점</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_solve_recursive</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>_get_initial_state</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_get_initial_state</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 초기 상태 반환 (문제에 따라 구현)</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_is_base_case</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 기저 사례 확인 (문제에 따라 구현)</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_get_base_case_value</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 기저 사례 값 반환 (문제에 따라 구현)</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_get_subproblems</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 상태에서의 하위 문제들 반환 (문제에 따라 구현)</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_combine_solutions</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>,</span> <span class=n>subproblem_solutions</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 하위 문제 해결책 결합 (문제에 따라 구현)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 최적 부분 구조 활용 지점</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_solve_recursive</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 이미 계산된 상태인지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>state</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>memo</span><span class=p>[</span><span class=n>state</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 기저 사례 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_is_base_case</span><span class=p>(</span><span class=n>state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_base_case_value</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 하위 문제 해결</span>
</span></span><span class=line><span class=cl>        <span class=n>subproblems</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_get_subproblems</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>subproblem_solutions</span> <span class=o>=</span> <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>_solve_recursive</span><span class=p>(</span><span class=n>subproblem</span><span class=p>)</span> <span class=k>for</span> <span class=n>subproblem</span> <span class=ow>in</span> <span class=n>subproblems</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 하위 문제 해결책 결합 (최적 부분 구조 활용)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_combine_solutions</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>subproblem_solutions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 메모이제이션</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>memo</span><span class=p>[</span><span class=n>state</span><span class=p>]</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최적-부분-구조-기반-알고리즘의-테스트-및-디버깅>최적 부분 구조 기반 알고리즘의 테스트 및 디버깅<a hidden class=anchor aria-hidden=true href=#최적-부분-구조-기반-알고리즘의-테스트-및-디버깅>#</a></h4><p>최적 부분 구조를 활용한 알고리즘을 테스트하고 디버깅하는 방법은 다음과 같다:</p><ol><li><strong>작은 입력으로 테스트</strong>: 손으로 계산할 수 있는 작은 입력으로 알고리즘을 테스트.</li><li><strong>단계별 상태 추적</strong>: 각 단계에서의 상태와 하위 문제의 해결책을 추적.</li><li><strong>기저 사례 확인</strong>: 기저 사례가 올바르게 처리되는지 확인.</li><li><strong>점화식 검증</strong>: 점화식이 문제의 최적 부분 구조를 정확히 표현하는지 검증.</li><li><strong>경계 조건 테스트</strong>: 최소값, 최대값, 빈 입력 등 경계 조건을 테스트.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>debug_dynamic_programming</span><span class=p>(</span><span class=n>dp_function</span><span class=p>,</span> <span class=n>test_cases</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>input_data</span><span class=p>,</span> <span class=n>expected_output</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>test_cases</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>dp_function</span><span class=p>(</span><span class=n>input_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Test Case </span><span class=si>{</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=si>}</span><span class=s2>:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Input: </span><span class=si>{</span><span class=n>input_data</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Expected: </span><span class=si>{</span><span class=n>expected_output</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Result: </span><span class=si>{</span><span class=n>result</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Status: </span><span class=si>{</span><span class=s1>&#39;PASS&#39;</span> <span class=k>if</span> <span class=n>result</span> <span class=o>==</span> <span class=n>expected_output</span> <span class=k>else</span> <span class=s1>&#39;FAIL&#39;</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;-&#34;</span> <span class=o>*</span> <span class=mi>40</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최적화-사례-연구>최적화 사례 연구<a hidden class=anchor aria-hidden=true href=#최적화-사례-연구>#</a></h4><p><strong>예시: 최장 증가 부분 수열(LIS) 최적화</strong></p><p>기본 O(n²) 알고리즘에서 O(n log n) 알고리즘으로 최적화하는 과정:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span><span class=lnt id=hl-12-27><a class=lnlinks href=#hl-12-27>27</a>
</span><span class=lnt id=hl-12-28><a class=lnlinks href=#hl-12-28>28</a>
</span><span class=lnt id=hl-12-29><a class=lnlinks href=#hl-12-29>29</a>
</span><span class=lnt id=hl-12-30><a class=lnlinks href=#hl-12-30>30</a>
</span><span class=lnt id=hl-12-31><a class=lnlinks href=#hl-12-31>31</a>
</span><span class=lnt id=hl-12-32><a class=lnlinks href=#hl-12-32>32</a>
</span><span class=lnt id=hl-12-33><a class=lnlinks href=#hl-12-33>33</a>
</span><span class=lnt id=hl-12-34><a class=lnlinks href=#hl-12-34>34</a>
</span><span class=lnt id=hl-12-35><a class=lnlinks href=#hl-12-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 기본 O(n²) 알고리즘</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence_basic</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 최적화된 O(n log n) 알고리즘</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_increasing_subsequence_optimized</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># tails[i] = 길이가 i+1인 LIS의 마지막 요소 중 가능한 가장 작은 값</span>
</span></span><span class=line><span class=cl>    <span class=n>tails</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 이진 검색으로 num이 들어갈 위치 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>idx</span> <span class=o>=</span> <span class=n>bisect</span><span class=o>.</span><span class=n>bisect_left</span><span class=p>(</span><span class=n>tails</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>idx</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>tails</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># num이 모든 값보다 크면 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>tails</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 그렇지 않으면 해당 위치의 값 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=n>tails</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>num</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>tails</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 최적화는 최적 부분 구조를 더 효율적으로 활용하기 위해 다른 방식으로 하위 문제를 정의했다.<br>기본 알고리즘은 &ldquo;인덱스 i까지의 최장 증가 부분 수열의 길이"를 저장했지만, 최적화된 알고리즘은 &ldquo;길이가 i인 증가 부분 수열의 마지막 요소 중 가능한 가장 작은 값"을 저장한다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><ul><li><p>최적 부분 구조의 핵심 요약</p><ol><li><strong>정의</strong>: 문제의 최적해가 하위 문제들의 최적해로 구성되는 특성</li><li><strong>조건</strong>: 하위 문제의 최적성, 독립적 최적화, 부분 해결책 결합, 재귀적 정의</li><li><strong>중요성</strong>: 동적 계획법과 그리디 알고리즘 적용의 기반</li><li><strong>유형</strong>: 선형, 분기, 조건부, 중첩 최적 부분 구조</li><li><strong>증명 방법</strong>: 귀류법, 최적성 원리를 통한 증명</li></ol></li><li><p>개발자를 위한 최적 부분 구조 확인 체크리스트</p><ol><li><strong>문제 분해 가능성</strong>: 문제가 작은 하위 문제로 분해될 수 있는가?</li><li><strong>하위 문제 중복</strong>: 동일한 하위 문제가 여러 번 발생하는가?</li><li><strong>최적해 구성</strong>: 전체 문제의 최적해가 하위 문제들의 최적해로 구성되는가?</li><li><strong>독립성</strong>: 하위 문제들을 독립적으로 해결할 수 있는가?</li><li><strong>결합 가능성</strong>: 하위 문제들의 해결책을 효율적으로 결합하여 전체 문제의 해결책을 구성할 수 있는가?</li></ol></li><li><p>다양한 문제 유형별 최적 부분 구조 활용 지침</p><ol><li><strong>최적화 문제</strong>:<ul><li>하위 문제의 최적해를 저장하고 재사용한다.</li><li>점화식이 최적 부분 구조를 정확히 반영하는지 확인한다.</li></ul></li><li><strong>계산 문제</strong>:<ul><li>중복 계산을 피하기 위해 메모이제이션 또는 테이블링을 사용한다.</li><li>기저 사례를 명확히 정의한다.</li></ul></li><li><strong>경로 문제</strong>:<ul><li>부분 경로의 최적성을 확인한다.</li><li>사이클이 있는 경우 특별한 처리가 필요할 수 있다.</li></ul></li><li><strong>조합 문제</strong>:<ul><li>상태 정의가 문제의 제약 조건을 모두 포함하는지 확인한다.</li><li>중복 상태를 효율적으로 처리한다.</li></ul></li></ol></li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/dynamic-programming/>Dynamic-Programming</a></li><li><a href=https://buenhyden.github.io/tags/principles/>Principles</a></li><li><a href=https://buenhyden.github.io/tags/optimal-substructure/>Optimal-Substructure</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/><span class=title>« Prev</span><br><span>Divide and Conquer vs. Branch and Bound</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/dynamic-programming/dp-principles/overlapping-subproblems/><span class=title>Next »</span><br><span>중복되는 하위 문제(Overlapping Subproblems)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>