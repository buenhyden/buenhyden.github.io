<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>tail Recursion vs. Non-tail Recursion | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Recursion,Types,Tail-Recursion,Non-tail-Recursion"><meta name=description content="재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion-vs-non-tail-recursion/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion-vs-non-tail-recursion/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion-vs-non-tail-recursion/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="tail Recursion vs. Non-tail Recursion"><meta property="og:description" content="재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-09T00:51:00+00:00"><meta property="article:modified_time" content="2024-12-09T00:51:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Recursion"><meta property="article:tag" content="Types"><meta property="article:tag" content="Tail-Recursion"><meta property="article:tag" content="Non-Tail-Recursion"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="tail Recursion vs. Non-tail Recursion"><meta name=twitter:description content="재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"Recursion","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/"},{"@type":"ListItem","position":5,"name":"Types of Recursion","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/"},{"@type":"ListItem","position":6,"name":"tail Recursion vs. Non-tail Recursion","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion-vs-non-tail-recursion/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"tail Recursion vs. Non-tail Recursion","name":"tail Recursion vs. Non-tail Recursion","description":"재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Recursion","Types","Tail-Recursion","Non-tail-Recursion"],"articleBody":"Tail Recursion vs. Non-tail Recursion 재귀(Recursion)는 문제를 작은 부분 문제로 나누어 해결하는 기법이다.\n특히, 재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀) 과 Non-Tail Recursion(비꼬리 재귀) 으로 구분된다.\n꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.\n사용할 재귀 방식을 선택할 때는 다음 요소를 고려해야 한다:\n사용하는 언어가 TCO를 지원하는지 여부 입력 데이터의 예상 크기 코드의 가독성과 유지보수성 성능 요구사항 특히 대규모 재귀 연산이 필요하고 TCO를 지원하는 언어를 사용한다면 꼬리 재귀를 선택하는 것이 좋다. 그렇지 않은 경우에는 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다. Tail Recursion vs. Non-Tail Recursion 개념 비교 Tail Recursion (꼬리 재귀) 함수의 마지막 연산이 자기 자신을 호출하는 형태 재귀 호출 이후 추가 연산이 없음 Tail Call Optimization (TCO) 을 통해 반복문처럼 실행 가능 Stack Frame을 재사용할 수 있어 메모리 사용량이 적음 예제 (Tail Recursion):\n1 2 3 4 def factorial_tail(n, acc=1): if n == 0: return acc return factorial_tail(n - 1, acc * n) # 재귀 호출이 마지막 연산 메모리 사용이 최적화되며, 반복문으로 쉽게 변환 가능\n✅ 장점\n메모리 사용량이 적고, Stack Overflow 방지 가능 반복문과 유사한 방식으로 최적화 가능 (TCO) 성능이 일반적으로 더 우수 ❌ 단점\nPython, C 등 일부 언어는 Tail Call Optimization(TCO)을 지원하지 않음 모든 문제에서 사용하기 어려움 (예: 병합 정렬, 트리 순회 등) Non-Tail Recursion (비꼬리 재귀) 재귀 호출이 끝난 후에도 추가 연산이 필요 Stack Frame이 계속 쌓이므로, 메모리 사용량이 증가 Tail Call Optimization(TCO)이 적용되지 않음 일반적으로 트리 탐색, 분할 정복(Divide \u0026 Conquer) 알고리즘에서 많이 사용 예제 (Non-Tail Recursion):\n1 2 3 4 5 def factorial_non_tail(n): if n == 0: return 1 result = factorial_non_tail(n - 1) # 재귀 호출 후 return n * result # 추가 연산 수행 재귀 호출 후 추가 연산(n * result)이 수행되므로, 메모리 사용량 증가\n✅ 장점\n문제를 더 직관적으로 해결 가능 트리 탐색, 분할 정복 알고리즘 등 다양한 문제에 적용 가능 ❌ 단점\nStack Overflow 가능성이 존재 메모리 사용량 증가 반복문으로 변환하기 어려움 Tail Recursion vs. Non-Tail Recursion 실행 방식 비교 실행 과정 비교 비꼬리 재귀 (Non-Tail Recursion) factorial(5) → 5 * factorial(4) factorial(4) → 4 * factorial(3) factorial(3) → 3 * factorial(2) factorial(2) → 2 * factorial(1) factorial(1) → 1 * factorial(0) factorial(0) → 1 (Base Case 도달) 스택 프레임이 계속 쌓이므로 메모리 사용량 증가 가능\n꼬리 재귀 (Tail Recursion) factorial(5, 1) → factorial(4, 5) factorial(4, 5) → factorial(3, 20) factorial(3, 20) → factorial(2, 60) factorial(2, 60) → factorial(1, 120) factorial(1, 120) → factorial(0, 120) factorial(0, 120) → 120 (Base Case 도달) Stack Frame을 재사용하며, 메모리 사용량 최적화 가능\nTail Recursion vs. Non-Tail Recursion 비교 분석 특성 꼬리 재귀(Tail Recursion) 비꼬리 재귀(Non-tail Recursion) 정의 마지막 연산이 순수한 재귀 호출 재귀 호출 후 추가 연산 필요 호출 형태 return func(…) return … func(…) … Stack Frame 사용 Stack Frame 재사용 가능 Stack Frame이 계속 증가 스택 사용 TCO 지원 시 상수 공간(O(1)) 입력 크기에 비례(O(n)) 스택 오버플로우 위험 낮음(TCO 지원 시) 높음 컴파일러 최적화 TCO 가능 TCO 불가능 성능 TCO 지원 시 반복문과 유사 일반적으로 더 느림 반복문 변환 가능성 쉬움 (반복문과 유사) 어려움 코드 구조 누산기 매개변수 필요 자연스러운 재귀 구조 가독성 때로 덜 직관적 일반적으로 더 직관적 사용 사례 함수형 프로그래밍, 대용량 재귀 단순한 재귀, 설명적 코드 예제 알고리즘 반복적 피보나치, 반복적 팩토리얼 트리 순회, 분할 정복 언어 지원 일부 언어에서만 TCO 지원 모든 언어에서 지원 디버깅 TCO 적용 시 스택 추적이 불완전할 수 있음 전체 호출 스택 확인 가능 언제 Tail Recursion과 Non-Tail Recursion을 사용할까? Tail Recursion을 사용해야 하는 경우\n반복문처럼 최적화가 필요한 경우 스택 오버플로우를 방지해야 하는 경우 팩토리얼, 피보나치 수열 최적화 등 Non-Tail Recursion을 사용해야 하는 경우\n재귀 호출 후 추가 연산이 필요한 경우 트리 탐색(DFS), 분할 정복(Divide \u0026 Conquer) 알고리즘 등 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort) 등 정리하면:\nTail Recursion은 성능 최적화가 필요한 경우에 적합!\nNon-Tail Recursion은 트리 탐색, 정렬 알고리즘 등 다양한 문제 해결에 적합!\n언어 및 실행 환경에 따라 Tail Call Optimization(TCO)이 지원되지 않을 수도 있으므로, 상황에 맞게 사용해야 한다!\n참고 및 출처 ","wordCount":"671","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-09T00:51:00Z","dateModified":"2024-12-09T00:51:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion-vs-non-tail-recursion/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/>Recursion</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/>Types of Recursion</a></div><h1 class="post-title entry-hint-parent">tail Recursion vs. Non-tail Recursion</h1><div class=post-description>재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다.</div><div class=post-meta><span title='2024-12-09 00:51:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Recursion/Types/tail-recursion-vs-non-tail-recursion.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#tail-recursion-vs-non-tail-recursion>Tail Recursion vs. Non-tail Recursion</a><ul><li><a href=#tail-recursion-vs-non-tail-recursion-개념-비교>Tail Recursion vs. Non-Tail Recursion 개념 비교</a></li><li><a href=#tail-recursion-vs-non-tail-recursion-실행-방식-비교>Tail Recursion vs. Non-Tail Recursion 실행 방식 비교</a></li><li><a href=#실행-과정-비교>실행 과정 비교</a></li><li><a href=#tail-recursion-vs-non-tail-recursion-비교-분석>Tail Recursion vs. Non-Tail Recursion 비교 분석</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=tail-recursion-vs-non-tail-recursion>Tail Recursion vs. Non-tail Recursion<a hidden class=anchor aria-hidden=true href=#tail-recursion-vs-non-tail-recursion>#</a></h2><p>재귀(Recursion)는 <strong>문제를 작은 부분 문제로 나누어 해결하는 기법</strong>이다.<br>특히, 재귀 호출이 함수의 <strong>마지막 연산으로 수행되는지 여부</strong>에 따라 <strong>Tail Recursion(꼬리 재귀)</strong> 과 <strong>Non-Tail Recursion(비꼬리 재귀)</strong> 으로 구분된다.</p><p>꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.</p><p>사용할 재귀 방식을 선택할 때는 다음 요소를 고려해야 한다:</p><ol><li>사용하는 언어가 TCO를 지원하는지 여부</li><li>입력 데이터의 예상 크기</li><li>코드의 가독성과 유지보수성</li><li>성능 요구사항
특히 대규모 재귀 연산이 필요하고 TCO를 지원하는 언어를 사용한다면 꼬리 재귀를 선택하는 것이 좋다. 그렇지 않은 경우에는 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.</li></ol><h3 id=tail-recursion-vs-non-tail-recursion-개념-비교>Tail Recursion vs. Non-Tail Recursion 개념 비교<a hidden class=anchor aria-hidden=true href=#tail-recursion-vs-non-tail-recursion-개념-비교>#</a></h3><h4 id=tail-recursion-꼬리-재귀>Tail Recursion (꼬리 재귀)<a hidden class=anchor aria-hidden=true href=#tail-recursion-꼬리-재귀>#</a></h4><ul><li>함수의 마지막 연산이 <strong>자기 자신을 호출하는 형태</strong></li><li>재귀 호출 이후 <strong>추가 연산이 없음</strong></li><li><strong>Tail Call Optimization (TCO)</strong> 을 통해 <strong>반복문처럼 실행 가능</strong></li><li><strong>Stack Frame을 재사용할 수 있어 메모리 사용량이 적음</strong></li></ul><p>예제 (Tail Recursion):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial_tail</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>acc</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>acc</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>factorial_tail</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>acc</span> <span class=o>*</span> <span class=n>n</span><span class=p>)</span>  <span class=c1># 재귀 호출이 마지막 연산</span>
</span></span></code></pre></td></tr></table></div></div><p>메모리 사용이 최적화되며, 반복문으로 쉽게 변환 가능</p><p>✅ <strong>장점</strong></p><ul><li>메모리 사용량이 적고, Stack Overflow 방지 가능</li><li>반복문과 유사한 방식으로 최적화 가능 (TCO)</li><li>성능이 일반적으로 더 우수</li></ul><p>❌ <strong>단점</strong></p><ul><li>Python, C 등 일부 언어는 Tail Call Optimization(TCO)을 지원하지 않음</li><li>모든 문제에서 사용하기 어려움 (예: 병합 정렬, 트리 순회 등)</li></ul><h4 id=non-tail-recursion-비꼬리-재귀>Non-Tail Recursion (비꼬리 재귀)<a hidden class=anchor aria-hidden=true href=#non-tail-recursion-비꼬리-재귀>#</a></h4><ul><li>재귀 호출이 끝난 후에도 <strong>추가 연산이 필요</strong></li><li><strong>Stack Frame이 계속 쌓이므로, 메모리 사용량이 증가</strong></li><li><strong>Tail Call Optimization(TCO)이 적용되지 않음</strong></li><li>일반적으로 <strong>트리 탐색, 분할 정복(Divide & Conquer) 알고리즘에서 많이 사용</strong></li></ul><p>예제 (Non-Tail Recursion):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>factorial_non_tail</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>factorial_non_tail</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 재귀 호출 후</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>n</span> <span class=o>*</span> <span class=n>result</span>  <span class=c1># 추가 연산 수행</span>
</span></span></code></pre></td></tr></table></div></div><p>재귀 호출 후 추가 연산(<code>n * result</code>)이 수행되므로, 메모리 사용량 증가</p><p>✅ <strong>장점</strong></p><ul><li>문제를 더 직관적으로 해결 가능</li><li>트리 탐색, 분할 정복 알고리즘 등 다양한 문제에 적용 가능</li></ul><p>❌ <strong>단점</strong></p><ul><li>Stack Overflow 가능성이 존재</li><li>메모리 사용량 증가</li><li>반복문으로 변환하기 어려움</li></ul><h3 id=tail-recursion-vs-non-tail-recursion-실행-방식-비교>Tail Recursion vs. Non-Tail Recursion 실행 방식 비교<a hidden class=anchor aria-hidden=true href=#tail-recursion-vs-non-tail-recursion-실행-방식-비교>#</a></h3><h3 id=실행-과정-비교>실행 과정 비교<a hidden class=anchor aria-hidden=true href=#실행-과정-비교>#</a></h3><h4 id=비꼬리-재귀-non-tail-recursion>비꼬리 재귀 (Non-Tail Recursion)<a hidden class=anchor aria-hidden=true href=#비꼬리-재귀-non-tail-recursion>#</a></h4><pre class=mermaid>factorial(5) → 5 * factorial(4)
factorial(4) → 4 * factorial(3)
factorial(3) → 3 * factorial(2)
factorial(2) → 2 * factorial(1)
factorial(1) → 1 * factorial(0)
factorial(0) → 1  (Base Case 도달)
</pre><p><strong>스택 프레임이 계속 쌓이므로 메모리 사용량 증가 가능</strong></p><h4 id=꼬리-재귀-tail-recursion>꼬리 재귀 (Tail Recursion)<a hidden class=anchor aria-hidden=true href=#꼬리-재귀-tail-recursion>#</a></h4><pre class=mermaid>factorial(5, 1) → factorial(4, 5)
factorial(4, 5) → factorial(3, 20)
factorial(3, 20) → factorial(2, 60)
factorial(2, 60) → factorial(1, 120)
factorial(1, 120) → factorial(0, 120)
factorial(0, 120) → 120  (Base Case 도달)
</pre><p><strong>Stack Frame을 재사용하며, 메모리 사용량 최적화 가능</strong></p><h3 id=tail-recursion-vs-non-tail-recursion-비교-분석>Tail Recursion vs. Non-Tail Recursion 비교 분석<a hidden class=anchor aria-hidden=true href=#tail-recursion-vs-non-tail-recursion-비교-분석>#</a></h3><table><thead><tr><th>특성</th><th>꼬리 재귀(Tail Recursion)</th><th>비꼬리 재귀(Non-tail Recursion)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>마지막 연산이 순수한 재귀 호출</td><td>재귀 호출 후 추가 연산 필요</td></tr><tr><td><strong>호출 형태</strong></td><td><code>return func(…)</code></td><td><code>return … func(…) …</code></td></tr><tr><td><strong>Stack Frame 사용</strong></td><td><strong>Stack Frame 재사용 가능</strong></td><td><strong>Stack Frame이 계속 증가</strong></td></tr><tr><td><strong>스택 사용</strong></td><td>TCO 지원 시 상수 공간(O(1))</td><td>입력 크기에 비례(O(n))</td></tr><tr><td><strong>스택 오버플로우 위험</strong></td><td>낮음(TCO 지원 시)</td><td>높음</td></tr><tr><td><strong>컴파일러 최적화</strong></td><td>TCO 가능</td><td>TCO 불가능</td></tr><tr><td><strong>성능</strong></td><td>TCO 지원 시 반복문과 유사</td><td>일반적으로 더 느림</td></tr><tr><td><strong>반복문 변환 가능성</strong></td><td><strong>쉬움</strong> (반복문과 유사)</td><td><strong>어려움</strong></td></tr><tr><td><strong>코드 구조</strong></td><td>누산기 매개변수 필요</td><td>자연스러운 재귀 구조</td></tr><tr><td><strong>가독성</strong></td><td>때로 덜 직관적</td><td>일반적으로 더 직관적</td></tr><tr><td><strong>사용 사례</strong></td><td>함수형 프로그래밍, 대용량 재귀</td><td>단순한 재귀, 설명적 코드</td></tr><tr><td><strong>예제 알고리즘</strong></td><td>반복적 피보나치, 반복적 팩토리얼</td><td>트리 순회, 분할 정복</td></tr><tr><td><strong>언어 지원</strong></td><td>일부 언어에서만 TCO 지원</td><td>모든 언어에서 지원</td></tr><tr><td><strong>디버깅</strong></td><td>TCO 적용 시 스택 추적이 불완전할 수 있음</td><td>전체 호출 스택 확인 가능</td></tr></tbody></table><h4 id=언제-tail-recursion과-non-tail-recursion을-사용할까>언제 Tail Recursion과 Non-Tail Recursion을 사용할까?<a hidden class=anchor aria-hidden=true href=#언제-tail-recursion과-non-tail-recursion을-사용할까>#</a></h4><p><strong>Tail Recursion을 사용해야 하는 경우</strong></p><ul><li>반복문처럼 최적화가 필요한 경우</li><li>스택 오버플로우를 방지해야 하는 경우</li><li>팩토리얼, 피보나치 수열 최적화 등</li></ul><p><strong>Non-Tail Recursion을 사용해야 하는 경우</strong></p><ul><li>재귀 호출 후 추가 연산이 필요한 경우</li><li>트리 탐색(DFS), 분할 정복(Divide & Conquer) 알고리즘 등</li><li>병합 정렬(Merge Sort), 퀵 정렬(Quick Sort) 등</li></ul><p><strong>정리하면:</strong><br><strong>Tail Recursion은 성능 최적화가 필요한 경우에 적합!</strong><br><strong>Non-Tail Recursion은 트리 탐색, 정렬 알고리즘 등 다양한 문제 해결에 적합!</strong></p><p><strong>언어 및 실행 환경에 따라 Tail Call Optimization(TCO)이 지원되지 않을 수도 있으므로, 상황에 맞게 사용해야 한다!</strong></p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/recursion/>Recursion</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/tail-recursion/>Tail-Recursion</a></li><li><a href=https://buenhyden.github.io/tags/non-tail-recursion/>Non-Tail-Recursion</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/><span class=title>« Prev</span><br><span>Back Tracking vs. Brute Force</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/><span class=title>Next »</span><br><span>Adjacency Matrix vs Adjacency List</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>