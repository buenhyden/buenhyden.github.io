<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Two Pointer Technique vs. Sliding Window Technique | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Two-Pointer-Technique,Sliding-Window-Technique"><meta name=description content="투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window)
투 포인터와 슬라이딩 윈도우 기법은 모두 배열이나 문자열과 같은 선형 데이터 구조에서 효율적인 탐색과 연산을 가능하게 하는 강력한 알고리즘 패러다임이다.
이 두 기법은 중첩된 반복문을 사용하는 O(n²) 해법을 O(n) 시간 복잡도로 최적화할 수 있게 해주어, 성능이 중요한 애플리케이션에서 필수적인 도구가 된다.
투 포인터 기법은 더 일반적이고 유연한 접근 방식으로, 두 포인터가 독립적으로 이동할 수 있어 다양한 문제 유형에 적용 가능하다. 반면, 슬라이딩 윈도우 기법은 연속된 요소들의 집합을 효율적으로 처리하는 데 특화되어 있으며, 투 포인터의 특수한 형태로 볼 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/two-pointer-technique-vs-sliding-window-technique/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/two-pointer-technique-vs-sliding-window-technique/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/two-pointer-technique-vs-sliding-window-technique/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Two Pointer Technique vs. Sliding Window Technique"><meta property="og:description" content="투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window) 투 포인터와 슬라이딩 윈도우 기법은 모두 배열이나 문자열과 같은 선형 데이터 구조에서 효율적인 탐색과 연산을 가능하게 하는 강력한 알고리즘 패러다임이다.
이 두 기법은 중첩된 반복문을 사용하는 O(n²) 해법을 O(n) 시간 복잡도로 최적화할 수 있게 해주어, 성능이 중요한 애플리케이션에서 필수적인 도구가 된다.
투 포인터 기법은 더 일반적이고 유연한 접근 방식으로, 두 포인터가 독립적으로 이동할 수 있어 다양한 문제 유형에 적용 가능하다. 반면, 슬라이딩 윈도우 기법은 연속된 요소들의 집합을 효율적으로 처리하는 데 특화되어 있으며, 투 포인터의 특수한 형태로 볼 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T00:46:00+00:00"><meta property="article:modified_time" content="2025-01-24T00:46:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Two-Pointer-Technique"><meta property="article:tag" content="Sliding-Window-Technique"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Two Pointer Technique vs. Sliding Window Technique"><meta name=twitter:description content="투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window)
투 포인터와 슬라이딩 윈도우 기법은 모두 배열이나 문자열과 같은 선형 데이터 구조에서 효율적인 탐색과 연산을 가능하게 하는 강력한 알고리즘 패러다임이다.
이 두 기법은 중첩된 반복문을 사용하는 O(n²) 해법을 O(n) 시간 복잡도로 최적화할 수 있게 해주어, 성능이 중요한 애플리케이션에서 필수적인 도구가 된다.
투 포인터 기법은 더 일반적이고 유연한 접근 방식으로, 두 포인터가 독립적으로 이동할 수 있어 다양한 문제 유형에 적용 가능하다. 반면, 슬라이딩 윈도우 기법은 연속된 요소들의 집합을 효율적으로 처리하는 데 특화되어 있으며, 투 포인터의 특수한 형태로 볼 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"Two Pointer Technique","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/"},{"@type":"ListItem","position":5,"name":"Two Pointer Technique vs. Sliding Window Technique","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/two-pointer-technique-vs-sliding-window-technique/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Two Pointer Technique vs. Sliding Window Technique","name":"Two Pointer Technique vs. Sliding Window Technique","description":"투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window) 투 포인터와 슬라이딩 윈도우 기법은 모두 배열이나 문자열과 같은 선형 데이터 구조에서 효율적인 탐색과 연산을 가능하게 하는 강력한 알고리즘 패러다임이다.\n이 두 기법은 중첩된 반복문을 사용하는 O(n²) 해법을 O(n) 시간 복잡도로 최적화할 수 있게 해주어, 성능이 중요한 애플리케이션에서 필수적인 도구가 된다.\n투 포인터 기법은 더 일반적이고 유연한 접근 방식으로, 두 포인터가 독립적으로 이동할 수 있어 다양한 문제 유형에 적용 가능하다. 반면, 슬라이딩 윈도우 기법은 연속된 요소들의 집합을 효율적으로 처리하는 데 특화되어 있으며, 투 포인터의 특수한 형태로 볼 수 있다.\n","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Two-Pointer-Technique","Sliding-Window-Technique"],"articleBody":"투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window) 투 포인터와 슬라이딩 윈도우 기법은 모두 배열이나 문자열과 같은 선형 데이터 구조에서 효율적인 탐색과 연산을 가능하게 하는 강력한 알고리즘 패러다임이다.\n이 두 기법은 중첩된 반복문을 사용하는 O(n²) 해법을 O(n) 시간 복잡도로 최적화할 수 있게 해주어, 성능이 중요한 애플리케이션에서 필수적인 도구가 된다.\n투 포인터 기법은 더 일반적이고 유연한 접근 방식으로, 두 포인터가 독립적으로 이동할 수 있어 다양한 문제 유형에 적용 가능하다. 반면, 슬라이딩 윈도우 기법은 연속된 요소들의 집합을 효율적으로 처리하는 데 특화되어 있으며, 투 포인터의 특수한 형태로 볼 수 있다.\n개발자는 문제의 특성과 요구 사항을 분석하여 적절한 기법을 선택해야 한다.\n두 요소의 조합을 찾는 문제나 정렬된 배열 탐색에는 투 포인터 기법이, 연속적인 부분 배열/문자열 처리에는 슬라이딩 윈도우 기법이 더 적합할 수 있다.\n개요 및 기본 개념 투 포인터 기법 투 포인터 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 두 개의 포인터를 활용하여 탐색하는 알고리즘 패러다임.\n두 포인터의 위치와 이동 방식에 따라 다양한 문제를 O(n) 시간 복잡도로 해결할 수 있다. 주로 정렬된 배열에서의 검색, 부분 배열 찾기, 팰린드롬 확인 등의 문제에 효과적.\n슬라이딩 윈도우 기법 슬라이딩 윈도우 기법은 고정 또는 가변 크기의 “윈도우”(연속적인 요소들의 부분집합)를 배열이나 문자열에서 슬라이드하면서 문제를 해결하는 기법.\n이 기법은 윈도우 내부의 모든 요소를 매번 다시 계산하지 않고, 추가되는 요소와 제거되는 요소만 고려하여 결과를 업데이트한다.\n기본 원리와 작동 방식 투 포인터 기법 작동 원리 포인터 초기화: 문제에 따라 두 포인터의 시작 위치를 결정. 이동 규칙 정의: 각 포인터의 이동 조건과 방향을 명확히 정의. 종료 조건 설정: 포인터가 언제 이동을 멈출지 결정. 결과 계산: 포인터 위치에 따른 결과를 계산. 슬라이딩 윈도우 작동 원리 윈도우 정의: 고정 크기 또는 가변 크기의 윈도우를 정의. 초기 윈도우 계산: 첫 번째 윈도우에 대한 계산을 수행. 윈도우 이동: 윈도우를 한 칸씩 이동하면서 다음을 수행: 새로 추가되는 요소 처리 제거되는 요소 처리 현재 윈도우 상태 업데이트 결과 계산: 각 윈도우 위치에서의 결과를 계산. 유형 분류 투 포인터 유형 반대 방향 포인터(Opposite Direction): 두 포인터가 배열의 양 끝에서 시작하여 중간으로 이동 예: 두 수의 합, 세 수의 합, 팰린드롬 확인 동일 방향 포인터(Same Direction): 두 포인터가 같은 방향으로 이동하되 서로 다른 속도로 진행 예: 중복 요소 제거, 배열에서 특정 값 찾기 빠른/느린 포인터(Fast/Slow): 한 포인터는 다른 포인터보다 빠르게 이동 예: 연결 리스트의 사이클 감지, 중간 요소 찾기 슬라이딩 윈도우 유형 고정 크기 윈도우(Fixed Size Window): 윈도우 크기가 일정하게 유지 예: K개 요소의 최대/최소 합, 평균 등 계산 가변 크기 윈도우(Variable Size Window): 윈도우 크기가 조건에 따라 변함 예: 합이 특정 값이 되는 최소/최대 길이 부분 배열 찾기 구현 사례 비교 투 포인터: 정렬된 배열에서 두 수의 합 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def two_sum(arr, target): left = 0 right = len(arr) - 1 while left \u003c right: current_sum = arr[left] + arr[right] if current_sum == target: return [left, right] elif current_sum \u003c target: left += 1 # 합이 작으면 왼쪽 포인터를 오른쪽으로 else: right -= 1 # 합이 크면 오른쪽 포인터를 왼쪽으로 return [-1, -1] # 목표값과 일치하는 두 숫자가 없는 경우 슬라이딩 윈도우: 고정 크기 윈도우에서 최대 합 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def max_sum_subarray(arr, k): n = len(arr) if n \u003c k: return None # 첫 번째 윈도우의 합 계산 window_sum = sum(arr[:k]) max_sum = window_sum # 윈도우를 한 칸씩 이동 for i in range(k, n): # 새 요소 추가, 이전 요소 제거 window_sum = window_sum + arr[i] - arr[i - k] max_sum = max(max_sum, window_sum) return max_sum 복잡한 문제 해결 사례 투 포인터: 세 수의 합(3Sum) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def three_sum(nums): result = [] nums.sort() # 배열 정렬 for i in range(len(nums) - 2): # 중복 건너뛰기 if i \u003e 0 and nums[i] == nums[i-1]: continue left = i + 1 right = len(nums) - 1 while left \u003c right: total = nums[i] + nums[left] + nums[right] if total \u003c 0: left += 1 elif total \u003e 0: right -= 1 else: result.append([nums[i], nums[left], nums[right]]) # 중복 건너뛰기 while left \u003c right and nums[left] == nums[left+1]: left += 1 while left \u003c right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 return result 슬라이딩 윈도우: 최소 윈도우 부분 문자열 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from collections import Counter def min_window_substring(s, t): if not s or not t: return \"\" # t의 문자 빈도수 계산 target_counter = Counter(t) required = len(target_counter) # 윈도우 변수 초기화 window_start = 0 formed = 0 # 조건을 만족하는 고유 문자 수 window_counts = {} # 결과 변수 result = float('inf'), 0, 0 for window_end in range(len(s)): # 현재 문자 추가 char = s[window_end] window_counts[char] = window_counts.get(char, 0) + 1 # 현재 문자가 조건을 만족하는지 확인 if char in target_counter and window_counts[char] == target_counter[char]: formed += 1 # 모든 조건이 만족되면 윈도우 축소 시도 while window_start \u003c= window_end and formed == required: char = s[window_start] # 현재 윈도우가 더 작으면 결과 업데이트 if window_end - window_start + 1 \u003c result[0]: result = (window_end - window_start + 1, window_start, window_end) # 왼쪽 문자 제거 window_counts[char] -= 1 if char in target_counter and window_counts[char] \u003c target_counter[char]: formed -= 1 window_start += 1 return \"\" if result[0] == float('inf') else s[result[1]:result[2] + 1] 실제 응용 사례 투 포인터 응용 사례 정렬 알고리즘 병합 정렬의 병합 과정 퀵 정렬의 파티션 과정 연결 리스트 조작 사이클 감지 중간 노드 찾기 컨테이너 최적화 문제 빗물 트래핑(Trapping Rain Water) 컨테이너에 가장 많은 물 담기 슬라이딩 윈도우 응용 사례 문자열 처리 가장 긴 중복 없는 부분 문자열 아나그램 패턴 찾기 데이터 스트림 분석 이동 평균(Moving Average) 계산 시계열 데이터 분석 네트워크 패킷 처리 네트워크 트래픽 모니터링 패킷 흐름 제어(Flow Control) 두 기법의 관계 슬라이딩 윈도우는 실제로 투 포인터 기법의 특수한 경우로 볼 수 있다. 두 기법 모두 두 개의 포인터를 사용하지만, 슬라이딩 윈도우는 두 포인터가 항상 일정한 규칙(고정 거리 유지 또는 특정 조건 충족)을 따라 이동한다. 반면, 일반적인 투 포인터 기법에서는 두 포인터가 더 자유롭게 이동할 수 있다.\n성능 및 최적화 관점 시간 복잡도 투 포인터: 대부분의 경우 O(n) 또는 O(n log n)(정렬이 필요한 경우) 슬라이딩 윈도우: 일반적으로 O(n) 공간 복잡도 투 포인터: 대부분 O(1) 또는 O(k)(결과 저장에 필요한 공간) 슬라이딩 윈도우: 대부분 O(1) 또는 O(k)(윈도우 내 상태 추적에 필요한 공간) 최적화 관점 투 포인터: 중첩된 반복문을 단일 반복문으로 변환하여 O(n²)에서 O(n)으로 최적화 슬라이딩 윈도우: 부분 배열 계산을 증분 방식으로 수행하여 반복 계산 회피 투 포인터와 슬라이딩 윈도우 기법 비교 특성 투 포인터 기법 슬라이딩 윈도우 기법 기본 개념 두 개의 포인터를 사용하여 데이터 구조 탐색 고정 또는 가변 크기의 “윈도우\"를 이동하며 탐색 포인터 이동 독립적으로 또는 특정 규칙에 따라 이동 일반적으로 함께 이동(윈도우 크기 유지 또는 조정) 주요 유형 반대 방향, 동일 방향, 빠른/느린 포인터 고정 크기 윈도우, 가변 크기 윈도우 적합한 문제 두 요소의 조합, 정렬된 배열 검색, 사이클 감지 부분 배열/문자열 연산, 연속 요소의 통계 계산 시간 복잡도 일반적으로 O(n) 또는 O(n log n) 일반적으로 O(n) 공간 복잡도 대부분 O(1) 대부분 O(1) 또는 O(k) 상태 유지 포인터 위치와 관련 변수 윈도우 내용과 관련 통계 구현 복잡성 중간 (포인터 이동 규칙에 따라 다름) 중간~높음 (윈도우 상태 관리가 복잡할 수 있음) 특징 더 유연한 포인터 이동이 가능 연속적인 요소의 집합을 효율적으로 처리 대표적 예제 두 수의 합, 세 수의 합, 팰린드롬 확인 최대 부분 배열 합, 중복 없는 최장 부분 문자열 관계 더 일반적인 패러다임 투 포인터의 특수한 경우로 볼 수 있음 정렬 필요성 많은 문제에서 정렬이 필요 대부분 정렬이 필요하지 않음 최적화 원리 중첩 반복문 → 단일 반복문 반복 계산 → 증분 계산 문제 유형에 따른 기법 선택 가이드 투 포인터 선택 사례 정렬된 배열에서 특정 조건을 만족하는 요소 쌍 찾기 예: 두 수의 합, 세 수의 합, 네 수의 합 특정 조건을 만족하는 부분 배열의 시작과 끝 찾기 예: 합이 특정 값이 되는 부분 배열 데이터 구조의 특성 확인 예: 팰린드롬 확인, 사이클 감지 요소 조작 및 재배치 예: 배열에서 중복 제거, 0을 끝으로 이동 슬라이딩 윈도우 선택 사례 고정 크기의 연속 부분 배열/문자열에 대한 통계 계산 예: K개 요소의 최대/최소 합, 평균 특정 조건을 만족하는 최소/최대 길이의 연속 부분 배열 찾기 예: 합이 S 이상인 최소 길이 부분 배열 문자열 패턴 매칭 및 부분 문자열 문제 예: 모든 아나그램 찾기, 최소 윈도우 부분 문자열 데이터 스트림 분석 예: 이동 평균 계산, 시계열 데이터 분석 참고 및 출처 ","wordCount":"1405","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-24T00:46:00Z","dateModified":"2025-01-24T00:46:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/two-pointer-technique-vs-sliding-window-technique/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/two-pointer-technique/>Two Pointer Technique</a></div><h1 class="post-title entry-hint-parent">Two Pointer Technique vs. Sliding Window Technique</h1><div class=post-meta><span title='2025-01-24 00:46:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1405 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Two%20Pointer%20Technique/two-pointer-technique-vs-sliding-window-technique.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#투-포인터two-pointer와-슬라이딩-윈도우sliding-window>투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window)</a><ul><li><a href=#개요-및-기본-개념>개요 및 기본 개념</a></li><li><a href=#기본-원리와-작동-방식>기본 원리와 작동 방식</a></li><li><a href=#유형-분류>유형 분류</a></li><li><a href=#구현-사례-비교>구현 사례 비교</a></li><li><a href=#복잡한-문제-해결-사례>복잡한 문제 해결 사례</a></li><li><a href=#실제-응용-사례>실제 응용 사례</a></li><li><a href=#두-기법의-관계>두 기법의 관계</a></li><li><a href=#성능-및-최적화-관점>성능 및 최적화 관점</a></li><li><a href=#투-포인터와-슬라이딩-윈도우-기법-비교>투 포인터와 슬라이딩 윈도우 기법 비교</a></li><li><a href=#문제-유형에-따른-기법-선택-가이드>문제 유형에 따른 기법 선택 가이드</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=투-포인터two-pointer와-슬라이딩-윈도우sliding-window>투 포인터(Two Pointer)와 슬라이딩 윈도우(Sliding Window)<a hidden class=anchor aria-hidden=true href=#투-포인터two-pointer와-슬라이딩-윈도우sliding-window>#</a></h2><p>투 포인터와 슬라이딩 윈도우 기법은 모두 배열이나 문자열과 같은 선형 데이터 구조에서 효율적인 탐색과 연산을 가능하게 하는 강력한 알고리즘 패러다임이다.<br>이 두 기법은 중첩된 반복문을 사용하는 O(n²) 해법을 O(n) 시간 복잡도로 최적화할 수 있게 해주어, 성능이 중요한 애플리케이션에서 필수적인 도구가 된다.</p><p>투 포인터 기법은 더 일반적이고 유연한 접근 방식으로, 두 포인터가 독립적으로 이동할 수 있어 다양한 문제 유형에 적용 가능하다. 반면, 슬라이딩 윈도우 기법은 연속된 요소들의 집합을 효율적으로 처리하는 데 특화되어 있으며, 투 포인터의 특수한 형태로 볼 수 있다.</p><p>개발자는 문제의 특성과 요구 사항을 분석하여 적절한 기법을 선택해야 한다.<br>두 요소의 조합을 찾는 문제나 정렬된 배열 탐색에는 투 포인터 기법이, 연속적인 부분 배열/문자열 처리에는 슬라이딩 윈도우 기법이 더 적합할 수 있다.</p><h3 id=개요-및-기본-개념>개요 및 기본 개념<a hidden class=anchor aria-hidden=true href=#개요-및-기본-개념>#</a></h3><h4 id=투-포인터-기법>투 포인터 기법<a hidden class=anchor aria-hidden=true href=#투-포인터-기법>#</a></h4><p>투 포인터 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 두 개의 포인터를 활용하여 탐색하는 알고리즘 패러다임.<br>두 포인터의 위치와 이동 방식에 따라 다양한 문제를 O(n) 시간 복잡도로 해결할 수 있다. 주로 정렬된 배열에서의 검색, 부분 배열 찾기, 팰린드롬 확인 등의 문제에 효과적.</p><h4 id=슬라이딩-윈도우-기법>슬라이딩 윈도우 기법<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-기법>#</a></h4><p>슬라이딩 윈도우 기법은 고정 또는 가변 크기의 &ldquo;윈도우&rdquo;(연속적인 요소들의 부분집합)를 배열이나 문자열에서 슬라이드하면서 문제를 해결하는 기법.<br>이 기법은 윈도우 내부의 모든 요소를 매번 다시 계산하지 않고, 추가되는 요소와 제거되는 요소만 고려하여 결과를 업데이트한다.</p><h3 id=기본-원리와-작동-방식>기본 원리와 작동 방식<a hidden class=anchor aria-hidden=true href=#기본-원리와-작동-방식>#</a></h3><h4 id=투-포인터-기법-작동-원리>투 포인터 기법 작동 원리<a hidden class=anchor aria-hidden=true href=#투-포인터-기법-작동-원리>#</a></h4><ol><li><strong>포인터 초기화</strong>: 문제에 따라 두 포인터의 시작 위치를 결정.</li><li><strong>이동 규칙 정의</strong>: 각 포인터의 이동 조건과 방향을 명확히 정의.</li><li><strong>종료 조건 설정</strong>: 포인터가 언제 이동을 멈출지 결정.</li><li><strong>결과 계산</strong>: 포인터 위치에 따른 결과를 계산.</li></ol><h4 id=슬라이딩-윈도우-작동-원리>슬라이딩 윈도우 작동 원리<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-작동-원리>#</a></h4><ol><li><strong>윈도우 정의</strong>: 고정 크기 또는 가변 크기의 윈도우를 정의.</li><li><strong>초기 윈도우 계산</strong>: 첫 번째 윈도우에 대한 계산을 수행.</li><li><strong>윈도우 이동</strong>: 윈도우를 한 칸씩 이동하면서 다음을 수행:<ul><li>새로 추가되는 요소 처리</li><li>제거되는 요소 처리</li><li>현재 윈도우 상태 업데이트</li></ul></li><li><strong>결과 계산</strong>: 각 윈도우 위치에서의 결과를 계산.</li></ol><h3 id=유형-분류>유형 분류<a hidden class=anchor aria-hidden=true href=#유형-분류>#</a></h3><h4 id=투-포인터-유형>투 포인터 유형<a hidden class=anchor aria-hidden=true href=#투-포인터-유형>#</a></h4><ol><li><strong>반대 방향 포인터(Opposite Direction)</strong>: 두 포인터가 배열의 양 끝에서 시작하여 중간으로 이동<ul><li>예: 두 수의 합, 세 수의 합, 팰린드롬 확인</li></ul></li><li><strong>동일 방향 포인터(Same Direction)</strong>: 두 포인터가 같은 방향으로 이동하되 서로 다른 속도로 진행<ul><li>예: 중복 요소 제거, 배열에서 특정 값 찾기</li></ul></li><li><strong>빠른/느린 포인터(Fast/Slow)</strong>: 한 포인터는 다른 포인터보다 빠르게 이동<ul><li>예: 연결 리스트의 사이클 감지, 중간 요소 찾기</li></ul></li></ol><h4 id=슬라이딩-윈도우-유형>슬라이딩 윈도우 유형<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-유형>#</a></h4><ol><li><strong>고정 크기 윈도우(Fixed Size Window)</strong>: 윈도우 크기가 일정하게 유지<ul><li>예: K개 요소의 최대/최소 합, 평균 등 계산</li></ul></li><li><strong>가변 크기 윈도우(Variable Size Window)</strong>: 윈도우 크기가 조건에 따라 변함<ul><li>예: 합이 특정 값이 되는 최소/최대 길이 부분 배열 찾기</li></ul></li></ol><h3 id=구현-사례-비교>구현 사례 비교<a hidden class=anchor aria-hidden=true href=#구현-사례-비교>#</a></h3><h4 id=투-포인터-정렬된-배열에서-두-수의-합-찾기>투 포인터: 정렬된 배열에서 두 수의 합 찾기<a hidden class=anchor aria-hidden=true href=#투-포인터-정렬된-배열에서-두-수의-합-찾기>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>two_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_sum</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>current_sum</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>  <span class=c1># 합이 작으면 왼쪽 포인터를 오른쪽으로</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>  <span class=c1># 합이 크면 오른쪽 포인터를 왼쪽으로</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>]</span>  <span class=c1># 목표값과 일치하는 두 숫자가 없는 경우</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=슬라이딩-윈도우-고정-크기-윈도우에서-최대-합-찾기>슬라이딩 윈도우: 고정 크기 윈도우에서 최대 합 찾기<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-고정-크기-윈도우에서-최대-합-찾기>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_sum_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 윈도우의 합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>window_sum</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>max_sum</span> <span class=o>=</span> <span class=n>window_sum</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 윈도우를 한 칸씩 이동</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 새 요소 추가, 이전 요소 제거</span>
</span></span><span class=line><span class=cl>        <span class=n>window_sum</span> <span class=o>=</span> <span class=n>window_sum</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>max_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_sum</span><span class=p>,</span> <span class=n>window_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_sum</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=복잡한-문제-해결-사례>복잡한 문제 해결 사례<a hidden class=anchor aria-hidden=true href=#복잡한-문제-해결-사례>#</a></h3><h4 id=투-포인터-세-수의-합3sum>투 포인터: 세 수의 합(3Sum)<a hidden class=anchor aria-hidden=true href=#투-포인터-세-수의-합3sum>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>three_sum</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>nums</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>  <span class=c1># 배열 정렬</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 중복 건너뛰기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>total</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>total</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 중복 건너뛰기</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span> <span class=ow>and</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=o>+</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span> <span class=ow>and</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>==</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=슬라이딩-윈도우-최소-윈도우-부분-문자열>슬라이딩 윈도우: 최소 윈도우 부분 문자열<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-최소-윈도우-부분-문자열>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span><span class=lnt id=hl-3-42><a class=lnlinks href=#hl-3-42>42</a>
</span><span class=lnt id=hl-3-43><a class=lnlinks href=#hl-3-43>43</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>Counter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_window_substring</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>t</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>s</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># t의 문자 빈도수 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>target_counter</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>required</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>target_counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 윈도우 변수 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>window_start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>formed</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 조건을 만족하는 고유 문자 수</span>
</span></span><span class=line><span class=cl>    <span class=n>window_counts</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 변수</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>window_end</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 문자 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>char</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>window_end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>=</span> <span class=n>window_counts</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 문자가 조건을 만족하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>char</span> <span class=ow>in</span> <span class=n>target_counter</span> <span class=ow>and</span> <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>==</span> <span class=n>target_counter</span><span class=p>[</span><span class=n>char</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>formed</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 조건이 만족되면 윈도우 축소 시도</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>window_start</span> <span class=o>&lt;=</span> <span class=n>window_end</span> <span class=ow>and</span> <span class=n>formed</span> <span class=o>==</span> <span class=n>required</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>char</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>window_start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 현재 윈도우가 더 작으면 결과 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>window_start</span><span class=p>,</span> <span class=n>window_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 왼쪽 문자 제거</span>
</span></span><span class=line><span class=cl>            <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>char</span> <span class=ow>in</span> <span class=n>target_counter</span> <span class=ow>and</span> <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target_counter</span><span class=p>[</span><span class=n>char</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>formed</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>window_start</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;&#34;</span> <span class=k>if</span> <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span> <span class=k>else</span> <span class=n>s</span><span class=p>[</span><span class=n>result</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span><span class=n>result</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실제-응용-사례>실제 응용 사례<a hidden class=anchor aria-hidden=true href=#실제-응용-사례>#</a></h3><h4 id=투-포인터-응용-사례>투 포인터 응용 사례<a hidden class=anchor aria-hidden=true href=#투-포인터-응용-사례>#</a></h4><ol><li><strong>정렬 알고리즘</strong><ul><li>병합 정렬의 병합 과정</li><li>퀵 정렬의 파티션 과정</li></ul></li><li><strong>연결 리스트 조작</strong><ul><li>사이클 감지</li><li>중간 노드 찾기</li></ul></li><li><strong>컨테이너 최적화 문제</strong><ul><li>빗물 트래핑(Trapping Rain Water)</li><li>컨테이너에 가장 많은 물 담기</li></ul></li></ol><h4 id=슬라이딩-윈도우-응용-사례>슬라이딩 윈도우 응용 사례<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-응용-사례>#</a></h4><ol><li><strong>문자열 처리</strong><ul><li>가장 긴 중복 없는 부분 문자열</li><li>아나그램 패턴 찾기</li></ul></li><li><strong>데이터 스트림 분석</strong><ul><li>이동 평균(Moving Average) 계산</li><li>시계열 데이터 분석</li></ul></li><li><strong>네트워크 패킷 처리</strong><ul><li>네트워크 트래픽 모니터링</li><li>패킷 흐름 제어(Flow Control)</li></ul></li></ol><h3 id=두-기법의-관계>두 기법의 관계<a hidden class=anchor aria-hidden=true href=#두-기법의-관계>#</a></h3><p>슬라이딩 윈도우는 실제로 투 포인터 기법의 특수한 경우로 볼 수 있다. 두 기법 모두 두 개의 포인터를 사용하지만, 슬라이딩 윈도우는 두 포인터가 항상 일정한 규칙(고정 거리 유지 또는 특정 조건 충족)을 따라 이동한다. 반면, 일반적인 투 포인터 기법에서는 두 포인터가 더 자유롭게 이동할 수 있다.</p><h3 id=성능-및-최적화-관점>성능 및 최적화 관점<a hidden class=anchor aria-hidden=true href=#성능-및-최적화-관점>#</a></h3><ol><li>시간 복잡도<ul><li><strong>투 포인터</strong>: 대부분의 경우 O(n) 또는 O(n log n)(정렬이 필요한 경우)</li><li><strong>슬라이딩 윈도우</strong>: 일반적으로 O(n)</li></ul></li><li>공간 복잡도<ul><li><strong>투 포인터</strong>: 대부분 O(1) 또는 O(k)(결과 저장에 필요한 공간)</li><li><strong>슬라이딩 윈도우</strong>: 대부분 O(1) 또는 O(k)(윈도우 내 상태 추적에 필요한 공간)</li></ul></li><li>최적화 관점<ul><li><strong>투 포인터</strong>: 중첩된 반복문을 단일 반복문으로 변환하여 O(n²)에서 O(n)으로 최적화</li><li><strong>슬라이딩 윈도우</strong>: 부분 배열 계산을 증분 방식으로 수행하여 반복 계산 회피</li></ul></li></ol><h3 id=투-포인터와-슬라이딩-윈도우-기법-비교>투 포인터와 슬라이딩 윈도우 기법 비교<a hidden class=anchor aria-hidden=true href=#투-포인터와-슬라이딩-윈도우-기법-비교>#</a></h3><table><thead><tr><th>특성</th><th>투 포인터 기법</th><th>슬라이딩 윈도우 기법</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>두 개의 포인터를 사용하여 데이터 구조 탐색</td><td>고정 또는 가변 크기의 &ldquo;윈도우"를 이동하며 탐색</td></tr><tr><td><strong>포인터 이동</strong></td><td>독립적으로 또는 특정 규칙에 따라 이동</td><td>일반적으로 함께 이동(윈도우 크기 유지 또는 조정)</td></tr><tr><td><strong>주요 유형</strong></td><td>반대 방향, 동일 방향, 빠른/느린 포인터</td><td>고정 크기 윈도우, 가변 크기 윈도우</td></tr><tr><td><strong>적합한 문제</strong></td><td>두 요소의 조합, 정렬된 배열 검색, 사이클 감지</td><td>부분 배열/문자열 연산, 연속 요소의 통계 계산</td></tr><tr><td><strong>시간 복잡도</strong></td><td>일반적으로 O(n) 또는 O(n log n)</td><td>일반적으로 O(n)</td></tr><tr><td><strong>공간 복잡도</strong></td><td>대부분 O(1)</td><td>대부분 O(1) 또는 O(k)</td></tr><tr><td><strong>상태 유지</strong></td><td>포인터 위치와 관련 변수</td><td>윈도우 내용과 관련 통계</td></tr><tr><td><strong>구현 복잡성</strong></td><td>중간 (포인터 이동 규칙에 따라 다름)</td><td>중간~높음 (윈도우 상태 관리가 복잡할 수 있음)</td></tr><tr><td><strong>특징</strong></td><td>더 유연한 포인터 이동이 가능</td><td>연속적인 요소의 집합을 효율적으로 처리</td></tr><tr><td><strong>대표적 예제</strong></td><td>두 수의 합, 세 수의 합, 팰린드롬 확인</td><td>최대 부분 배열 합, 중복 없는 최장 부분 문자열</td></tr><tr><td><strong>관계</strong></td><td>더 일반적인 패러다임</td><td>투 포인터의 특수한 경우로 볼 수 있음</td></tr><tr><td><strong>정렬 필요성</strong></td><td>많은 문제에서 정렬이 필요</td><td>대부분 정렬이 필요하지 않음</td></tr><tr><td><strong>최적화 원리</strong></td><td>중첩 반복문 → 단일 반복문</td><td>반복 계산 → 증분 계산</td></tr></tbody></table><h3 id=문제-유형에-따른-기법-선택-가이드>문제 유형에 따른 기법 선택 가이드<a hidden class=anchor aria-hidden=true href=#문제-유형에-따른-기법-선택-가이드>#</a></h3><ul><li>투 포인터 선택 사례<ol><li><strong>정렬된 배열에서 특정 조건을 만족하는 요소 쌍 찾기</strong><ul><li>예: 두 수의 합, 세 수의 합, 네 수의 합</li></ul></li><li><strong>특정 조건을 만족하는 부분 배열의 시작과 끝 찾기</strong><ul><li>예: 합이 특정 값이 되는 부분 배열</li></ul></li><li><strong>데이터 구조의 특성 확인</strong><ul><li>예: 팰린드롬 확인, 사이클 감지</li></ul></li><li><strong>요소 조작 및 재배치</strong><ul><li>예: 배열에서 중복 제거, 0을 끝으로 이동</li></ul></li></ol></li><li>슬라이딩 윈도우 선택 사례<ol><li><strong>고정 크기의 연속 부분 배열/문자열에 대한 통계 계산</strong><ul><li>예: K개 요소의 최대/최소 합, 평균</li></ul></li><li><strong>특정 조건을 만족하는 최소/최대 길이의 연속 부분 배열 찾기</strong><ul><li>예: 합이 S 이상인 최소 길이 부분 배열</li></ul></li><li><strong>문자열 패턴 매칭 및 부분 문자열 문제</strong><ul><li>예: 모든 아나그램 찾기, 최소 윈도우 부분 문자열</li></ul></li><li><strong>데이터 스트림 분석</strong><ul><li>예: 이동 평균 계산, 시계열 데이터 분석</li></ul></li></ol></li></ul><hr><h3 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/two-pointer-technique/>Two-Pointer-Technique</a></li><li><a href=https://buenhyden.github.io/tags/sliding-window-technique/>Sliding-Window-Technique</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/><span class=title>« Prev</span><br><span>Divide and Conquer vs. Branch and Bound</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/chaining/><span class=title>Next »</span><br><span>Chaining</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>