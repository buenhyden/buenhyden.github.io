<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Problem Solving Techniques | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques"><meta name=description content="주어진 문제를 효과적으로 분석하고 해결하기 위한 알고리즘 및 자료 구조를 적용하는 방법론"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Problem Solving Techniques"><meta property="og:description" content="주어진 문제를 효과적으로 분석하고 해결하기 위한 알고리즘 및 자료 구조를 적용하는 방법론"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Problem Solving Techniques"><meta name=twitter:description content="주어진 문제를 효과적으로 분석하고 해결하기 위한 알고리즘 및 자료 구조를 적용하는 방법론"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a></div><h1>Problem Solving Techniques</h1><div class=post-description>주어진 문제를 효과적으로 분석하고 해결하기 위한 알고리즘 및 자료 구조를 적용하는 방법론</div></header><div class=post-content><h2 id=문제-해결-기법-problem-solving-techniques>문제 해결 기법 (Problem Solving Techniques)<a hidden class=anchor aria-hidden=true href=#문제-해결-기법-problem-solving-techniques>#</a></h2><p>문제 해결 기법은 데이터 구조와 알고리즘 분야에서 복잡한 문제를 체계적으로 접근하고 효율적으로 해결하기 위한 방법론이다. 이러한 기법들은 컴퓨터 과학뿐만 아니라 실제 업무와 일상에서도 적용될 수 있는 중요한 사고 방식이다.</p><p>문제 해결 기법은 데이터 구조와 알고리즘을 효과적으로 활용하여 복잡한 문제를 체계적으로 해결하는 방법론이다.<br>다양한 기법을 익히고 적절하게 적용함으로써 컴퓨터 과학 문제뿐만 아니라 실생활의 복잡한 문제도 효율적으로 해결할 수 있다. 문제 해결은 단순히 알고리즘을 암기하는 것이 아니라, 문제를 이해하고 적절한 접근 방식을 선택하는 사고 과정을 발전시키는 것이 중요하다.</p><p><strong>문제 해결 기법의 핵심 목표</strong>:</p><ul><li>최적의 알고리즘을 선택하여 문제 해결</li><li>시간 복잡도와 공간 복잡도를 고려한 효율적인 코드 작성</li><li>논리적 사고 및 패턴 인식을 통해 문제를 해결하는 능력 향상</li><li>알고리즘적 사고(Algorithmic Thinking) 훈련</li></ul><p>문제 해결 기법은 컴퓨터 과학의 핵심 요소로, 효율적이고 최적화된 해결책을 개발하는 데 필수적이다.<br>각 기법은 특정 유형의 문제에 적합하며, 문제의 특성과 제약 조건에 따라 적절한 기법을 선택하는 것이 중요하다.</p><p>효과적인 문제 해결자가 되기 위해서는 다양한 기법에 대한 이해와 함께, 문제를 체계적으로 분석하고 적절한 접근 방법을 선택하는 능력이 필요하다. 또한, 실제 응용 사례를 통한 경험과 연습이 이론적 지식을 실용적인 기술로 전환하는 데 중요한 역할을 한다.</p><h3 id=효율적인-문제-해결을-위한-일반적인-접근-방법>효율적인 문제 해결을 위한 일반적인 접근 방법<a hidden class=anchor aria-hidden=true href=#효율적인-문제-해결을-위한-일반적인-접근-방법>#</a></h3><ol><li><p>문제 이해 및 분석</p><ul><li>문제 설명을 주의 깊게 읽고 요구사항을 명확히 이해한다.</li><li>입력과 출력 형식, 제약 조건을 파악한다.</li><li>간단한 예제로 문제의 본질을 파악한다.</li></ul></li><li><p>알고리즘 설계</p><ul><li>문제 유형을 식별하고 적절한 알고리즘 패러다임을 선택한다.</li><li>문제를 더 작은 하위 문제로 분해한다.</li><li>알고리즘을 의사코드(pseudocode)로 표현한다.</li></ul></li><li><p>복잡도 분석</p><ul><li>시간 복잡도와 공간 복잡도를 분석한다.</li><li>최악/평균/최선의 경우 성능을 고려한다.</li><li>필요한 경우 알고리즘을 최적화한다.</li></ul></li><li><p>구현</p><ul><li>선택한 프로그래밍 언어로 알고리즘을 구현한다.</li><li>코드를 모듈화하고 명확하게 작성한다.</li><li>적절한 데이터 구조를 사용한다.</li></ul></li><li><p>테스트 및 디버깅</p><ul><li>경계 조건을 포함한 다양한 테스트 케이스를 만든다.</li><li>알고리즘의 정확성을 검증한다.</li><li>성능 병목 현상을 식별하고 해결한다.</li></ul></li><li><p>최적화 및 개선</p><ul><li>코드 리팩토링을 통해 가독성과 유지 보수성을 향상시킨다.</li><li>추가적인 최적화를 적용한다.</li><li>필요한 경우 다른 알고리즘 접근 방식을 고려한다.</li></ul></li></ol><h3 id=주요-문제-해결-기법>주요 문제 해결 기법<a hidden class=anchor aria-hidden=true href=#주요-문제-해결-기법>#</a></h3><p>문제 해결 기법은 알고리즘과 데이터 구조를 활용하여 복잡한 컴퓨팅 문제를 효율적으로 해결하기 위한 체계적인 접근 방식이다.<br>각 기법은 특정 유형의 문제에 특화되어 있으며, 효율성과 정확성 면에서 서로 다른 장단점을 가지고 있다.</p><h4 id=분할-정복-divide-and-conquer>분할 정복 (Divide and Conquer)<a hidden class=anchor aria-hidden=true href=#분할-정복-divide-and-conquer>#</a></h4><p>분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 패러다임.</p><p>작동 원리:</p><ol><li><strong>분할(Divide)</strong>: 원래 문제를 여러 개의 작은 하위 문제로 나눈다.</li><li><strong>정복(Conquer)</strong>: 하위 문제들을 재귀적으로 해결한다.</li><li><strong>결합(Combine)</strong>: 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 얻는다.</li></ol><p>장점:</p><ul><li>복잡한 문제를 더 간단한 문제로 분해할 수 있다.</li><li>병렬 처리에 적합하다.</li><li>많은 경우 효율적인 시간 복잡도를 제공한다.</li></ul><p>단점:</p><ul><li>재귀 호출로 인한 오버헤드가 발생할 수 있다.</li><li>모든 문제에 적용할 수 있는 것은 아니다.</li></ul><p>대표적인 알고리즘:</p><ul><li>퀵 정렬(Quick Sort): O(n log n) 평균 시간 복잡도</li><li>병합 정렬(Merge Sort): O(n log n) 시간 복잡도</li><li>이진 검색(Binary Search): O(log n) 시간 복잡도</li><li>스트라센(Strassen) 행렬 곱셈 알고리즘: O(n^2.81) 시간 복잡도</li></ul><p>코드 예시 (병합 정렬)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 배열의 길이가 1 이하면 이미 정렬된 것으로 간주</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계: 배열을 중간에서 두 부분으로 나눔</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>])</span>  <span class=c1># 왼쪽 부분 재귀적으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:])</span>  <span class=c1># 오른쪽 부분 재귀적으로 정렬</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결합 단계: 두 정렬된 배열 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 배열의 요소를 비교하여 작은 값부터 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=동적-계획법-dynamic-programming>동적 계획법 (Dynamic Programming)<a hidden class=anchor aria-hidden=true href=#동적-계획법-dynamic-programming>#</a></h4><p>동적 계획법은 큰 문제를 겹치는 하위 문제로 나누고, 각 하위 문제의 해결책을 저장하여 중복 계산을 피하는 기법이다.</p><p>핵심 원칙:</p><ol><li><strong>최적 부분 구조(Optimal Substructure)</strong>: 최적해가 하위 문제의 최적해로 구성된다.</li><li><strong>겹치는 하위 문제(Overlapping Subproblems)</strong>: 같은 하위 문제가 반복해서 나타난다.</li></ol><p>접근 방식:</p><ul><li><strong>하향식(Top-down)</strong>: 메모이제이션(Memoization)을 사용한 재귀적 접근법</li><li><strong>상향식(Bottom-up)</strong>: 테이블에 결과를 채우는 반복적 접근법</li></ul><p>장점:</p><ul><li>중복 계산을 피하여 시간 복잡도를 크게 개선할 수 있다.</li><li>최적화 문제에 특히 유용하다.</li></ul><p>단점:</p><ul><li>메모리 사용량이 증가할 수 있다.</li><li>문제를 DP로 공식화하는 것이 어려울 수 있다.</li></ul><p>대표적인 문제:</p><ul><li>피보나치 수열</li><li>최장 공통 부분 수열(LCS)</li><li>0-1 배낭 문제(Knapsack Problem)</li><li>편집 거리(Edit Distance)</li><li>행렬 연쇄 곱셈(Matrix Chain Multiplication)</li></ul><p>코드 예시 (피보나치 수열):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 하향식 접근법 (메모이제이션)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_top_down</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>  <span class=c1># 이미 계산한 값이 있으면 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>     <span class=c1># 기본 케이스</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 계산 결과를 메모에 저장</span>
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci_top_down</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci_top_down</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 상향식 접근법 (테이블링)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_bottom_up</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 테이블 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 작은 문제부터 큰 문제까지 해결</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=그리디-알고리즘-greedy-algorithm>그리디 알고리즘 (Greedy Algorithm)<a hidden class=anchor aria-hidden=true href=#그리디-알고리즘-greedy-algorithm>#</a></h4><p>그리디 알고리즘은 각 단계에서 지역적으로 최적인 선택을 함으로써 전체적으로 최적의 해결책을 찾는 방법.</p><p>작동 원리:</p><ol><li>현재 상황에서 가장 좋아 보이는 선택을 한다.</li><li>선택한 후에는 이를 번복하지 않는다.</li><li>이 과정을 반복하여 최종 해결책에 도달한다.</li></ol><p>적용 조건:</p><ul><li><strong>탐욕적 선택 속성(Greedy Choice Property)</strong>: 지역적 최적 선택이 전역적 최적 해결책의 일부가 되어야 한다.</li><li><strong>최적 부분 구조(Optimal Substructure)</strong>: 최적해가 하위 문제의 최적해를 포함해야 한다.</li></ul><p>장점:</p><ul><li>구현이 간단하고 효율적.</li><li>일부 문제에서는 최적해를 보장한다.</li></ul><p>단점:</p><ul><li>많은 문제에서 최적해를 보장하지 않는다.</li><li>적용 가능한 문제 유형이 제한적이다.</li></ul><p>대표적인 알고리즘:</p><ul><li>다익스트라(Dijkstra) 최단 경로 알고리즘</li><li>크루스칼(Kruskal) 최소 신장 트리 알고리즘</li><li>프림(Prim) 최소 신장 트리 알고리즘</li><li>허프만(Huffman) 코딩</li><li>활동 선택 문제(Activity Selection Problem)</li></ul><p>코드 예시 (동전 거스름돈 문제):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>greedy_coin_change</span><span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>coins</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 큰 단위의 동전부터 사용하기 위해 내림차순 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>coins</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining</span> <span class=o>=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>coin</span> <span class=ow>in</span> <span class=n>coins</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 동전으로 거스를 수 있는 최대 개수</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=n>remaining</span> <span class=o>//</span> <span class=n>coin</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 해당 동전을 사용한 경우 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>count</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>coin</span><span class=p>,</span> <span class=n>count</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>remaining</span> <span class=o>-=</span> <span class=n>coin</span> <span class=o>*</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1># 모든 금액을 거슬러 줬으면 종료</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>remaining</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 금액을 거슬러 줄 수 있는지 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>remaining</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;거스름돈을 만들 수 없습니다.&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=백트래킹-backtracking>백트래킹 (Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹-backtracking>#</a></h4><p>백트래킹은 가능한 모든 해결책을 탐색하되, 유망하지 않은 경로는 조기에 포기하는 체계적인 방법.</p><p>작동 원리:</p><ol><li>후보 해결책을 점진적으로 구축한다.</li><li>현재 후보가 유망한지(promising) 검사한다.</li><li>유망하지 않으면 해당 경로 탐색을 중단(가지치기)한다.</li><li>유망하면 계속해서 탐색한다.</li></ol><p>장점:</p><ul><li>깊이 우선 탐색(DFS)보다 효율적이다.</li><li>가지치기(pruning)를 통해 탐색 공간을 줄일 수 있다.</li></ul><p>단점:</p><ul><li>최악의 경우 지수 시간 복잡도를 가질 수 있다.</li><li>가지치기 조건을 효율적으로 설계해야 한다. 1</li></ul><p>대표적인 문제:</p><ul><li>N-퀸 문제</li><li>스도쿠</li><li>해밀턴 경로(Hamiltonian Path)</li><li>그래프 색칠 문제(Graph Coloring)</li><li>부분집합의 합(Subset Sum)</li></ul><p>코드 예시 (N-퀸 문제):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>solutions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 체스판 초기화 (각 열에 퀸이 어느 행에 있는지 저장)</span>
</span></span><span class=line><span class=cl>    <span class=n>board</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_safe</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 같은 행, 같은 대각선에 퀸이 있는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>prev_row</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>prev_col</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>prev_row</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=c1># 같은 열이거나 대각선에 있는 경우</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>prev_col</span> <span class=o>==</span> <span class=n>col</span> <span class=ow>or</span> \
</span></span><span class=line><span class=cl>               <span class=nb>abs</span><span class=p>(</span><span class=n>prev_row</span> <span class=o>-</span> <span class=n>row</span><span class=p>)</span> <span class=o>==</span> <span class=nb>abs</span><span class=p>(</span><span class=n>prev_col</span> <span class=o>-</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 행에 퀸을 배치했으면 해결책에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>solution</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># 각 행에서 퀸의 위치를 &#39;.&#39;과 &#39;Q&#39;로 표현</span>
</span></span><span class=line><span class=cl>                <span class=n>line</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;.&#39;</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>                <span class=n>line</span><span class=p>[</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span> <span class=o>=</span> <span class=s1>&#39;Q&#39;</span>
</span></span><span class=line><span class=cl>                <span class=n>solution</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>line</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>solutions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 행의 각 열에 퀸 배치 시도</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_safe</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=n>col</span>  <span class=c1># 퀸 배치</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 다음 행으로 진행</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 백트래킹 (퀸 제거)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>  <span class=c1># 0행부터 시작</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solutions</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=분기-한정법-branch-and-bound>분기 한정법 (Branch and Bound)<a hidden class=anchor aria-hidden=true href=#분기-한정법-branch-and-bound>#</a></h4><p>분기 한정법은 최적화 문제를 해결하기 위해 상태 공간 트리를 체계적으로 탐색하는 방법.</p><p>작동 원리:</p><ol><li><strong>분기(Branch)</strong>: 문제 공간을 작은 하위 공간으로 분할한다.</li><li><strong>한정(Bound)</strong>: 각 하위 공간에 대한 경계값(bound)을 계산한다.</li><li><strong>가지치기(Pruning)</strong>: 최적해를 포함할 가능성이 없는 하위 공간은 탐색하지 않는다.</li></ol><p>탐색 전략:</p><ul><li><strong>깊이 우선 분기 한정법</strong>: 깊이 우선 탐색(DFS) 사용</li><li><strong>너비 우선 분기 한정법</strong>: 너비 우선 탐색(BFS) 사용</li><li><strong>최선 우선 분기 한정법</strong>: 가장 유망한 노드부터 탐색</li></ul><p>장점:</p><ul><li>백트래킹보다 효율적인 가지치기가 가능하다.</li><li>최적해를 보장한다.</li></ul><p>단점:</p><ul><li>구현이 복잡하다.</li><li>적절한 경계 함수 설계가 중요하다.</li></ul><p>대표적인 문제:</p><ul><li>외판원 문제(TSP)</li><li>0-1 배낭 문제</li><li>작업 할당 문제(Job Assignment Problem)</li><li>정수 계획법(Integer Programming)</li></ul><p>코드 예시 (0-1 배낭 문제):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span><span class=lnt id=hl-4-47><a class=lnlinks href=#hl-4-47>47</a>
</span><span class=lnt id=hl-4-48><a class=lnlinks href=#hl-4-48>48</a>
</span><span class=lnt id=hl-4-49><a class=lnlinks href=#hl-4-49>49</a>
</span><span class=lnt id=hl-4-50><a class=lnlinks href=#hl-4-50>50</a>
</span><span class=lnt id=hl-4-51><a class=lnlinks href=#hl-4-51>51</a>
</span><span class=lnt id=hl-4-52><a class=lnlinks href=#hl-4-52>52</a>
</span><span class=lnt id=hl-4-53><a class=lnlinks href=#hl-4-53>53</a>
</span><span class=lnt id=hl-4-54><a class=lnlinks href=#hl-4-54>54</a>
</span><span class=lnt id=hl-4-55><a class=lnlinks href=#hl-4-55>55</a>
</span><span class=lnt id=hl-4-56><a class=lnlinks href=#hl-4-56>56</a>
</span><span class=lnt id=hl-4-57><a class=lnlinks href=#hl-4-57>57</a>
</span><span class=lnt id=hl-4-58><a class=lnlinks href=#hl-4-58>58</a>
</span><span class=lnt id=hl-4-59><a class=lnlinks href=#hl-4-59>59</a>
</span><span class=lnt id=hl-4-60><a class=lnlinks href=#hl-4-60>60</a>
</span><span class=lnt id=hl-4-61><a class=lnlinks href=#hl-4-61>61</a>
</span><span class=lnt id=hl-4-62><a class=lnlinks href=#hl-4-62>62</a>
</span><span class=lnt id=hl-4-63><a class=lnlinks href=#hl-4-63>63</a>
</span><span class=lnt id=hl-4-64><a class=lnlinks href=#hl-4-64>64</a>
</span><span class=lnt id=hl-4-65><a class=lnlinks href=#hl-4-65>65</a>
</span><span class=lnt id=hl-4-66><a class=lnlinks href=#hl-4-66>66</a>
</span><span class=lnt id=hl-4-67><a class=lnlinks href=#hl-4-67>67</a>
</span><span class=lnt id=hl-4-68><a class=lnlinks href=#hl-4-68>68</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Item</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>ratio</span> <span class=o>=</span> <span class=n>value</span> <span class=o>/</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>items</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 가치/무게 비율 기준으로 내림차순 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>items</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>.</span><span class=n>ratio</span><span class=p>,</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최적해 저장 변수</span>
</span></span><span class=line><span class=cl>    <span class=n>max_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>best_solution</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>items</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 경계값(bound) 계산 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bound</span><span class=p>(</span><span class=n>idx</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>&gt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>bound_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>        <span class=n>remaining</span> <span class=o>=</span> <span class=n>capacity</span> <span class=o>-</span> <span class=n>current_weight</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 인덱스부터 아이템 고려</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>idx</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>items</span><span class=p>)</span> <span class=ow>and</span> <span class=n>remaining</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>remaining</span> <span class=o>&gt;=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 아이템 전체를 넣을 수 있는 경우</span>
</span></span><span class=line><span class=cl>                <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>                <span class=n>remaining</span> <span class=o>-=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 아이템 일부만 넣을 수 있는 경우 (분수 아이템)</span>
</span></span><span class=line><span class=cl>                <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>items</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>ratio</span> <span class=o>*</span> <span class=n>remaining</span>
</span></span><span class=line><span class=cl>                <span class=n>remaining</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bound_value</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분기 한정법 재귀 함수</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>branch_and_bound_rec</span><span class=p>(</span><span class=n>idx</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>solution</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>max_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 기본 케이스: 모든 아이템을 고려한 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>idx</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>items</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_value</span> <span class=o>&gt;</span> <span class=n>max_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_value</span> <span class=o>=</span> <span class=n>current_value</span>
</span></span><span class=line><span class=cl>                <span class=n>best_solution</span> <span class=o>=</span> <span class=n>solution</span><span class=p>[:]</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 아이템을 포함하지 않는 경우</span>
</span></span><span class=line><span class=cl>        <span class=c1># 경계값을 계산하여 유망성 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>bound</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>max_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>solution</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=n>branch_and_bound_rec</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span><span class=p>,</span> <span class=n>current_value</span><span class=p>,</span> <span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 아이템을 포함하는 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>bound</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                     <span class=n>current_value</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>value</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>max_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>solution</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=n>branch_and_bound_rec</span><span class=p>(</span><span class=n>idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                    <span class=n>current_weight</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>weight</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                    <span class=n>current_value</span> <span class=o>+</span> <span class=n>items</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                    <span class=n>solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기 호출</span>
</span></span><span class=line><span class=cl>    <span class=n>branch_and_bound_rec</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>items</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_value</span><span class=p>,</span> <span class=n>best_solution</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=해싱-hashing>해싱 (Hashing)<a hidden class=anchor aria-hidden=true href=#해싱-hashing>#</a></h4><p>해싱은 키를 값에 매핑하는 기법으로, 효율적인 검색, 삽입, 삭제 연산을 가능하게 한다.</p><p>핵심 구성 요소:</p><ol><li><strong>해시 함수(Hash Function)</strong>: 키를 해시 테이블의 인덱스로 변환한다.</li><li><strong>해시 테이블(Hash Table)</strong>: 키-값 쌍을 저장하는 데이터 구조이다.</li><li><strong>충돌 해결 방법(Collision Resolution)</strong>: 서로 다른 키가 동일한 인덱스에 매핑될 때 해결하는 방법이다.</li></ol><p>충돌 해결 방법:</p><ul><li><strong>체이닝(Chaining)</strong>: 같은 버킷에 여러 키-값 쌍을 연결 리스트로 저장한다.</li><li><strong>개방 주소법(Open Addressing)</strong>: 충돌 발생 시 다른 버킷을 찾아 저장한다.<ul><li>선형 탐사(Linear Probing)</li><li>이차 탐사(Quadratic Probing)</li><li>더블 해싱(Double Hashing)</li></ul></li></ul><p>장점:</p><ul><li>평균적으로 O(1) 시간 복잡도로 검색, 삽입, 삭제가 가능하다.</li><li>키-값 매핑에 효율적이다.</li></ul><p>단점:</p><ul><li>최악의 경우 O(n) 시간 복잡도가 될 수 있다.</li><li>좋은 해시 함수 설계가 중요하다.</li></ul><p>대표적인 응용:</p><ul><li>데이터베이스 인덱싱</li><li>심볼 테이블</li><li>캐싱</li><li>중복 검사</li></ul><p>코드 예시 (해시 테이블 구현):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span><span class=lnt id=hl-5-33><a class=lnlinks href=#hl-5-33>33</a>
</span><span class=lnt id=hl-5-34><a class=lnlinks href=#hl-5-34>34</a>
</span><span class=lnt id=hl-5-35><a class=lnlinks href=#hl-5-35>35</a>
</span><span class=lnt id=hl-5-36><a class=lnlinks href=#hl-5-36>36</a>
</span><span class=lnt id=hl-5-37><a class=lnlinks href=#hl-5-37>37</a>
</span><span class=lnt id=hl-5-38><a class=lnlinks href=#hl-5-38>38</a>
</span><span class=lnt id=hl-5-39><a class=lnlinks href=#hl-5-39>39</a>
</span><span class=lnt id=hl-5-40><a class=lnlinks href=#hl-5-40>40</a>
</span><span class=lnt id=hl-5-41><a class=lnlinks href=#hl-5-41>41</a>
</span><span class=lnt id=hl-5-42><a class=lnlinks href=#hl-5-42>42</a>
</span><span class=lnt id=hl-5-43><a class=lnlinks href=#hl-5-43>43</a>
</span><span class=lnt id=hl-5-44><a class=lnlinks href=#hl-5-44>44</a>
</span><span class=lnt id=hl-5-45><a class=lnlinks href=#hl-5-45>45</a>
</span><span class=lnt id=hl-5-46><a class=lnlinks href=#hl-5-46>46</a>
</span><span class=lnt id=hl-5-47><a class=lnlinks href=#hl-5-47>47</a>
</span><span class=lnt id=hl-5-48><a class=lnlinks href=#hl-5-48>48</a>
</span><span class=lnt id=hl-5-49><a class=lnlinks href=#hl-5-49>49</a>
</span><span class=lnt id=hl-5-50><a class=lnlinks href=#hl-5-50>50</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>HashTable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=o>=</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>size</span><span class=p>)]</span>  <span class=c1># 체이닝 방식 사용</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_hash_function</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 문자열 키의 각 문자 아스키 값 합계를 테이블 크기로 나눈 나머지</span>
</span></span><span class=line><span class=cl>        <span class=n>hash_value</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>char</span> <span class=ow>in</span> <span class=nb>str</span><span class=p>(</span><span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>hash_value</span> <span class=o>+=</span> <span class=nb>ord</span><span class=p>(</span><span class=n>char</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>hash_value</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 해시 값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>hash_key</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash_function</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키가 이미 존재하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_key</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 키가 있으면 값 업데이트</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_key</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 새 키-값 쌍 추가</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_key</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 해시 값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>hash_key</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash_function</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키 검색</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>k</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_key</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>v</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키가 없으면 None 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>remove</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 해시 값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>hash_key</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash_function</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키 검색 후 제거</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_key</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>k</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_key</span><span class=p>][</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 키가 없으면 False 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=근사-알고리즘-approximation-algorithms>근사 알고리즘 (Approximation Algorithms)<a hidden class=anchor aria-hidden=true href=#근사-알고리즘-approximation-algorithms>#</a></h4><p>근사 알고리즘은 NP-난해(NP-hard) 문제와 같이 최적해를 효율적으로 찾기 어려운 문제에 대해 &ldquo;충분히 좋은&rdquo; 해결책을 찾는 기법.</p><p>핵심 개념:</p><ol><li><strong>근사 비율(Approximation Ratio)</strong>: 알고리즘의 해와 최적해 사이의 비율로, 알고리즘의 품질을 나타낸다.</li><li><strong>성능 보장(Performance Guarantee)</strong>: 알고리즘이 최적해에 얼마나 가까운 해를 제공하는지에 대한 이론적 보장이다.</li></ol><p>장점:</p><ul><li>합리적인 시간 내에 실용적인 해결책을 제공한다.</li><li>최적해와의 차이에 대한 이론적 보장이 있다.</li></ul><p>단점:</p><ul><li>정확한 최적해를 보장하지 않는다.</li><li>모든 NP-난해 문제에 적용할 수 있는 것은 아니다.</li></ul><p>대표적인 알고리즘:</p><ul><li>외판원 문제(TSP)를 위한 2-근사 알고리즘</li><li>정점 덮개(Vertex Cover)를 위한 2-근사 알고리즘</li><li>집합 커버(Set Cover)를 위한 로그 근사 알고리즘</li><li>최대 절단(MAX CUT)을 위한 0.878-근사 알고리즘</li></ul><p>코드 예시 (정점 덮개를 위한 2-근사 알고리즘):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>vertex_cover_approximation</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 그래프는 {정점: [이웃 정점들]} 형태의 딕셔너리로 표현</span>
</span></span><span class=line><span class=cl>    <span class=n>cover</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>  <span class=c1># 정점 덮개</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 간선을 리스트로 변환</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>u</span> <span class=o>&lt;</span> <span class=n>v</span><span class=p>:</span>  <span class=c1># 중복 방지</span>
</span></span><span class=line><span class=cl>                <span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 간선이 남아있는 동안 반복</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 아무 간선이나 선택</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=o>=</span> <span class=n>edges</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 양 끝점을 덮개에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>cover</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cover</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 선택한 정점에 연결된 모든 간선 제거</span>
</span></span><span class=line><span class=cl>        <span class=n>edges</span> <span class=o>=</span> <span class=p>[(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=k>for</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>edges</span> <span class=k>if</span> <span class=n>a</span> <span class=o>!=</span> <span class=n>u</span> <span class=ow>and</span> <span class=n>a</span> <span class=o>!=</span> <span class=n>v</span> <span class=ow>and</span> <span class=n>b</span> <span class=o>!=</span> <span class=n>u</span> <span class=ow>and</span> <span class=n>b</span> <span class=o>!=</span> <span class=n>v</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cover</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=완전-탐색-brute-force>완전 탐색 (Brute Force)<a hidden class=anchor aria-hidden=true href=#완전-탐색-brute-force>#</a></h4><p>완전 탐색은 가능한 모든 해결책을 검사하여 문제를 해결하는 직관적인 방법.</p><p>작동 원리:</p><ol><li>모든 가능한 후보 해결책을 생성한다.</li><li>각 후보가 문제의 해결책인지 검사한다.</li><li>발견된 해결책 중 최적의 것을 선택한다.</li></ol><p>장점:</p><ul><li>구현이 단순하고 직관적.</li><li>정확한 해결책을 보장.</li><li>문제의 규모가 작을 때 효율적.</li></ul><p>단점</p><ul><li>시간 복잡도가 매우 높다(보통 O(2^n) 또는 O(n!)).</li><li>문제 크기가 커질수록 실용적이지 않다.</li></ul><p>대표적인 문제:</p><ul><li>부분집합 생성</li><li>순열 생성</li><li>조합 문제</li><li>문자열 매칭</li><li>암호 해독</li></ul><p>코드 예시 (부분 집합의 합 문제):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>subset_sum_brute_force</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 가능한 부분집합 검사 (2^n)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>subset</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>subset_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># i의 이진 표현에서 1인 비트에 해당하는 요소 선택</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>subset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>subset_sum</span> <span class=o>+=</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 합이 타겟과 일치하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>subset_sum</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>subset</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 해당하는 부분집합이 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>None</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=무작위-알고리즘-randomized-algorithms>무작위 알고리즘 (Randomized Algorithms)<a hidden class=anchor aria-hidden=true href=#무작위-알고리즘-randomized-algorithms>#</a></h4><p>무작위 알고리즘은 결정론적 방법 대신 확률과 무작위성을 활용하여 문제를 해결하는 기법.</p><p>유형:</p><ol><li><strong>몬테카를로 알고리즘(Monte Carlo)</strong>: 항상 종료되지만 결과가 가끔 틀릴 수 있다.</li><li><strong>라스베가스 알고리즘(Las Vegas)</strong>: 항상 올바른 결과를 반환하지만 실행 시간이 확률적.</li></ol><p>장점:</p><ul><li>일부 문제에서 결정론적 알고리즘보다 효율적.</li><li>단순한 구현으로 복잡한 문제를 해결할 수 있다.</li><li>지역 최적해에서 벗어날 가능성이 있다.</li></ul><p>단점:</p><ul><li>결과의 정확성이 확률적일 수 있다.</li><li>실행 시간이 가변적일 수 있다.</li></ul><p>대표적인 알고리즘:</p><ul><li>무작위 퀵 정렬(Randomized Quick Sort)</li><li>밀러-라빈 소수 판별법(Miller-Rabin Primality Test)</li><li>몬테카를로 방법을 이용한 원주율(π) 추정</li><li>무작위 민컷(Randomized Min-Cut) 알고리즘</li><li>유전 알고리즘(Genetic Algorithms)</li></ul><p>코드 예시 (무작위 퀵 정렬):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>randomized_quicksort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 무작위로 피벗 선택</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot_idx</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>pivot_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 피벗보다 작은 요소들</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span> <span class=ow>or</span> <span class=p>(</span><span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span> <span class=ow>and</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>pivot_idx</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 피벗과 같은 요소들 (피벗 제외)</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span> <span class=ow>and</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>pivot_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 피벗보다 큰 요소들</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 재귀적으로 정렬 후 결합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>randomized_quicksort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=p>[</span><span class=n>pivot</span><span class=p>]</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>randomized_quicksort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=재귀-recursion>재귀 (Recursion)<a hidden class=anchor aria-hidden=true href=#재귀-recursion>#</a></h4><p>재귀는 문제를 동일한 형태의 더 작은 하위 문제로 분해하여 해결하는 기법.</p><p>핵심 구성 요소:</p><ol><li><strong>기본 케이스(Base Case)</strong>: 재귀 호출 없이 직접 해결할 수 있는 가장 단순한 경우.</li><li><strong>재귀 케이스(Recursive Case)</strong>: 문제를 더 작은 하위 문제로 분해하여 재귀적으로 해결하는 경우.</li></ol><p>장점:</p><ul><li>복잡한 문제를 간결하고 명확하게 표현할 수 있다.</li><li>자연스러운 문제 분해 방식을 제공한다.</li><li>분할 정복, 동적 계획법, 백트래킹 등 다른 알고리즘의 기초가 된다.</li></ul><p>단점:</p><ul><li>함수 호출 오버헤드로 인해 성능 저하가 발생할 수 있다.</li><li>스택 오버플로우(Stack Overflow) 위험이 있다.</li><li>종료 조건을 잘못 설정하면 무한 재귀에 빠질 수 있다.</li></ul><p>대표적인 문제:</p><ul><li>팩토리얼 계산</li><li>피보나치 수열</li><li>하노이 탑</li><li>이진 트리 순회</li><li>병합 정렬 및 퀵 정렬</li></ul><p>코드 예시 (하노이 탑):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>hanoi_tower</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>source</span><span class=p>,</span> <span class=n>auxiliary</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기본 케이스: 이동할 원판이 1개인 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;원판 1을 </span><span class=si>{</span><span class=n>source</span><span class=si>}</span><span class=s2>에서 </span><span class=si>{</span><span class=n>target</span><span class=si>}</span><span class=s2>으로 이동&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 재귀 케이스:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 1. n-1개의 원판을 source에서 auxiliary로 이동</span>
</span></span><span class=line><span class=cl>    <span class=n>hanoi_tower</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>auxiliary</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 2. 가장 큰 원판을 source에서 target으로 이동</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;원판 </span><span class=si>{</span><span class=n>n</span><span class=si>}</span><span class=s2>을 </span><span class=si>{</span><span class=n>source</span><span class=si>}</span><span class=s2>에서 </span><span class=si>{</span><span class=n>target</span><span class=si>}</span><span class=s2>으로 이동&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 3. n-1개의 원판을 auxiliary에서 target으로 이동</span>
</span></span><span class=line><span class=cl>    <span class=n>hanoi_tower</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>auxiliary</span><span class=p>,</span> <span class=n>source</span><span class=p>,</span> <span class=n>target</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=문제-해결-기법-비교-및-통합>문제 해결 기법 비교 및 통합<a hidden class=anchor aria-hidden=true href=#문제-해결-기법-비교-및-통합>#</a></h3><h4 id=기법-간의-관계>기법 간의 관계<a hidden class=anchor aria-hidden=true href=#기법-간의-관계>#</a></h4><p>여러 문제 해결 기법들은 서로 관련되어 있으며, 때로는 조합하여 사용된다:</p><ol><li><strong>재귀와 분할 정복</strong>: 재귀는 분할 정복의 기초로, 큰 문제를 작은 문제로 나누는 접근 방식을 제공한다.</li><li><strong>동적 계획법과 재귀</strong>: 동적 계획법은 재귀적 해결책에 메모이제이션을 추가하여 중복 계산을 방지한다.</li><li><strong>백트래킹과 분기 한정법</strong>: 둘 다 상태 공간 트리 탐색 방법이지만, 분기 한정법은 백트래킹에 경계값 함수를 추가하여 더 효율적인 가지치기를 수행한다.</li><li><strong>그리디와 근사 알고리즘</strong>: 그리디 알고리즘은 종종 NP-난해 문제에 대한 근사 알고리즘으로 사용된다.</li><li><strong>무작위 알고리즘과 완전 탐색</strong>: 무작위 알고리즘은 완전 탐색의 대안으로, 모든 가능성을 검사하는 대신 무작위 샘플링을 통해 해결책을 찾는다.</li></ol><h4 id=기법-선택-가이드>기법 선택 가이드<a hidden class=anchor aria-hidden=true href=#기법-선택-가이드>#</a></h4><p>문제 특성에 따른 적절한 기법 선택 방법:</p><table><thead><tr><th>문제 유형</th><th>적합한 기법</th><th>적용 조건</th></tr></thead><tbody><tr><td>최적화 문제</td><td>동적 계획법</td><td>겹치는 하위 문제와 최적 부분 구조가 있는 경우</td></tr><tr><td>최적화 문제</td><td>그리디 알고리즘</td><td>지역 최적 선택이 전역 최적해를 보장하는 경우</td></tr><tr><td>최적화 문제</td><td>분기 한정법</td><td>경계 함수를 효율적으로 계산할 수 있는 경우</td></tr><tr><td>NP-난해 문제</td><td>근사 알고리즘</td><td>실용적인 시간 내에 충분히 좋은 해결책이 필요한 경우</td></tr><tr><td>탐색 문제</td><td>백트래킹</td><td>제약 조건이 많은 경우</td></tr><tr><td>배열 정렬/검색</td><td>분할 정복</td><td>문제가 동일한 유형의 하위 문제로 나눌 수 있는 경우</td></tr><tr><td>해시 테이블</td><td>해싱</td><td>빠른 검색/삽입/삭제가 필요한 경우</td></tr><tr><td>모든 가능성 검사</td><td>완전 탐색</td><td>문제 크기가 작은 경우</td></tr><tr><td>복잡한 탐색 공간</td><td>무작위 알고리즘</td><td>확률적 해결책이 허용되는 경우</td></tr><tr><td>자연적 재귀 구조</td><td>재귀</td><td>문제가 자연스럽게 재귀적 정의를 가지는 경우</td></tr></tbody></table><h3 id=알고리즘-복잡도-분석>알고리즘 복잡도 분석<a hidden class=anchor aria-hidden=true href=#알고리즘-복잡도-분석>#</a></h3><p>각 기법의 시간 및 공간 복잡도를 이해하는 것은 적절한 알고리즘 선택에 중요하다:</p><h4 id=시간-복잡도-비교>시간 복잡도 비교<a hidden class=anchor aria-hidden=true href=#시간-복잡도-비교>#</a></h4><table><thead><tr><th>기법</th><th>평균 시간 복잡도</th><th>최악 시간 복잡도</th><th>예시 알고리즘</th></tr></thead><tbody><tr><td>분할 정복</td><td>O(n log n)</td><td>O(n^2)</td><td>퀵 정렬</td></tr><tr><td>동적 계획법</td><td>O(n^2) ~ O(n^k)</td><td>O(n^2) ~ O(n^k)</td><td>최장 공통 부분 수열</td></tr><tr><td>그리디</td><td>O(n log n)</td><td>O(n log n)</td><td>다익스트라 알고리즘</td></tr><tr><td>백트래킹</td><td>O(b^d)</td><td>O(b^d)</td><td>N-퀸 문제</td></tr><tr><td>분기 한정법</td><td>가변적</td><td>지수적</td><td>0-1 배낭 문제</td></tr><tr><td>해싱</td><td>O(1)</td><td>O(n)</td><td>해시 테이블 연산</td></tr><tr><td>근사 알고리즘</td><td>다항식 시간</td><td>다항식 시간</td><td>외판원 문제 근사 알고리즘</td></tr><tr><td>완전 탐색</td><td>O(2^n) or O(n!)</td><td>O(2^n) or O(n!)</td><td>부분집합 생성</td></tr><tr><td>무작위 알고리즘</td><td>가변적</td><td>가변적</td><td>무작위 퀵 정렬</td></tr><tr><td>재귀</td><td>가변적</td><td>가변적</td><td>팩토리얼 계산</td></tr></tbody></table><p>*여기서 b는 분기 인자(branching factor), d는 탐색 깊이(depth).</p><h3 id=문제-유형별-접근-방법>문제 유형별 접근 방법<a hidden class=anchor aria-hidden=true href=#문제-유형별-접근-방법>#</a></h3><h4 id=검색-문제-search-problems>검색 문제 (Search Problems)<a hidden class=anchor aria-hidden=true href=#검색-문제-search-problems>#</a></h4><p>검색 문제는 주어진 데이터 집합에서 특정 항목을 찾는 문제.</p><p><strong>주요 알고리즘</strong>:</p><ul><li>선형 검색(Linear Search): O(n)</li><li>이진 검색(Binary Search): O(log n), 정렬된 배열에서만 사용 가능</li><li>해시 기반 검색: O(1), 평균 시간 복잡도</li></ul><p><strong>접근 방법</strong>:</p><ol><li>데이터가 정렬되어 있으면 이진 검색 고려</li><li>검색 작업이 자주 수행되면 해시 테이블 사용 고려</li><li>검색 공간이 무한하거나 매우 큰 경우 BFS/DFS 같은 그래프 탐색 알고리즘 고려</li></ol><p><strong>유형별 접근 방법</strong>:</p><ul><li>정렬되지 않은 데이터: 선형 검색(O(n))</li><li>정렬된 데이터: 이진 검색(O(log n))</li><li>빈번한 검색 작업: 해시 테이블(평균 O(1))</li><li>문자열 검색: KMP 알고리즘, 보이어-무어 알고리즘</li><li>유사도 검색: 최근접 이웃 알고리즘, 로컬리티 센서티브 해싱(LSH)</li></ul><h4 id=정렬-문제-sorting-problems>정렬 문제 (Sorting Problems)<a hidden class=anchor aria-hidden=true href=#정렬-문제-sorting-problems>#</a></h4><p>데이터를 특정 순서로 재배열하는 문제.</p><p><strong>주요 알고리즘</strong>:</p><ul><li>버블 정렬(Bubble Sort): O(n²)</li><li>선택 정렬(Selection Sort): O(n²)</li><li>삽입 정렬(Insertion Sort): O(n²), 작은 배열이나 거의 정렬된 배열에 효율적</li><li>병합 정렬(Merge Sort): O(n log n), 안정적인 정렬</li><li>퀵 정렬(Quick Sort): O(n log n), 평균적으로 매우 효율적</li><li>힙 정렬(Heap Sort): O(n log n), 최악의 경우에도 보장</li><li>기수 정렬(Radix Sort): O(nk), 비교 기반이 아닌 정렬</li></ul><p><strong>접근 방법</strong>:</p><ol><li>데이터 크기가 작으면 삽입 정렬과 같은 간단한 알고리즘 사용</li><li>안정적인 정렬이 필요하면 병합 정렬 고려</li><li>평균적으로 빠른 성능이 필요하면 퀵 정렬 사용</li><li>메모리가 제한적이면 제자리 정렬 알고리즘(퀵 정렬, 힙 정렬) 선택</li></ol><p><strong>유형별 접근 방법</strong>:</p><ul><li>작은 데이터셋: 삽입 정렬(O(n^2))</li><li>일반적인 경우: 퀵 정렬(평균 O(n log n)), 병합 정렬(O(n log n))</li><li>안정적 정렬 필요: 병합 정렬</li><li>제한된 메모리: 힙 정렬(O(n log n))</li><li>거의 정렬된 데이터: 삽입 정렬</li><li>정수 데이터(제한된 범위): 계수 정렬(O(n+k)), 기수 정렬(O(nk))</li></ul><h4 id=그래프-문제-graph-problems>그래프 문제 (Graph Problems)<a hidden class=anchor aria-hidden=true href=#그래프-문제-graph-problems>#</a></h4><p>노드와 간선으로 구성된 그래프 구조를 다루는 문제.</p><p><strong>주요 알고리즘</strong>:</p><ul><li>너비 우선 탐색(BFS): 최단 경로 문제에 유용</li><li>깊이 우선 탐색(DFS): 연결 성분, 사이클 탐지에 유용</li><li>다익스트라 알고리즘(Dijkstra&rsquo;s Algorithm): 단일 출발점 최단 경로</li><li>벨만-포드 알고리즘(Bellman-Ford Algorithm): 음수 가중치가 있는 그래프에서의 최단 경로</li><li>크루스칼 알고리즘(Kruskal&rsquo;s Algorithm): 최소 신장 트리</li><li>프림 알고리즘(Prim&rsquo;s Algorithm): 최소 신장 트리</li><li>토폴로지 정렬(Topological Sort): 방향성 비순환 그래프(DAG)에서 순서 결정</li></ul><p><strong>접근 방법</strong>:</p><ol><li>그래프 표현 방식 선택(인접 행렬, 인접 리스트)</li><li>문제 유형 식별(경로 찾기, 최소 신장 트리, 사이클 탐지 등)</li><li>적절한 알고리즘 적용</li></ol><p><strong>유형별 접근 방법</strong>:</p><ul><li>최단 경로: 다익스트라 알고리즘(양수 가중치), 벨만-포드(음수 가중치 허용)</li><li>모든 쌍 최단 경로: 플로이드-워셜 알고리즘</li><li>최소 신장 트리: 크루스칼 알고리즘, 프림 알고리즘</li><li>네트워크 흐름: 포드-풀커슨 알고리즘, 에드몬드-카프 알고리즘</li><li>강한 연결 요소: 코사라주 알고리즘, 타잔 알고리즘</li><li>위상 정렬: DFS 기반 알고리즘, 칸 알고리즘</li><li>싸이클 탐지: 유니온-파인드, DFS</li><li>해밀턴 경로/외판원 문제: 동적 계획법, 근사 알고리즘, 분기 한정법</li></ul><h4 id=문자열-문제-string-problems>문자열 문제 (String Problems)<a hidden class=anchor aria-hidden=true href=#문자열-문제-string-problems>#</a></h4><p>문자열 처리와 관련된 다양한 문제를 해결하는 방법.</p><p><strong>주요 알고리즘</strong>:</p><ul><li>문자열 매칭: 브루트 포스, KMP, 라빈-카프, 보이어-무어</li><li>최장 공통 부분 수열(LCS): 동적 계획법</li><li>편집 거리(Edit Distance): 동적 계획법</li><li>트라이(Trie) 데이터 구조: 문자열 검색 최적화</li></ul><p><strong>접근 방법</strong>:</p><ol><li>문자열 특성 파악(길이, 문자 집합 등)</li><li>효율적인 알고리즘 선택(단순 검색 vs 고급 매칭 알고리즘)</li><li>필요시 특수 데이터 구조 사용(트라이, 접미사 배열 등)</li></ol><p><strong>유형별 접근 방법</strong>:</p><ul><li>문자열 매칭: KMP 알고리즘, 라빈-카프 알고리즘, 보이어-무어 알고리즘</li><li>문자열 편집 거리: 동적 계획법(레벤슈타인 거리)</li><li>최장 공통 부분 수열/부분 문자열: 동적 계획법</li><li>접미사 배열 및 트리: 문자열 인덱싱 및 빠른 검색</li><li>회문 탐지: 중앙에서 확장하는 방법, 동적 계획법</li><li>정규 표현식 매칭: 오토마타, 백트래킹</li></ul><h4 id=수학적-문제>수학적 문제<a hidden class=anchor aria-hidden=true href=#수학적-문제>#</a></h4><p>수학적 문제는 수치 계산, 대수학, 기하학 등과 관련된 작업.</p><p><strong>접근 방법</strong>:</p><ul><li>소수 판별: 에라토스테네스의 체, 밀러-라빈 알고리즘</li><li>최대공약수/최소공배수: 유클리드 알고리즘</li><li>행렬 연산: 스트라센 알고리즘(행렬 곱셈)</li><li>다항식 계산: 카라츠바 알고리즘</li><li>기하학적 문제: 볼록 껍질, 선분 교차, 점 포함 여부 등</li></ul><h3 id=효율적인-문제-해결을-위한-팁>효율적인 문제 해결을 위한 팁<a hidden class=anchor aria-hidden=true href=#효율적인-문제-해결을-위한-팁>#</a></h3><ol><li><strong>패턴 인식</strong>: 유사한 문제를 해결한 경험을 활용하여 패턴 인식</li><li><strong>알고리즘 복잡도 분석</strong>: 시간과 공간 복잡도를 고려하여 최적의 알고리즘 선택</li><li><strong>테스트 케이스 활용</strong>: 다양한 테스트 케이스로 해결책의 정확성 검증</li><li><strong>점진적 접근</strong>: 단순한 해결책으로 시작하여 점진적으로 최적화</li><li><strong>문제 변형</strong>: 복잡한 문제를 이미 알고 있는 문제 형태로 변형</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>브루트 포스 (Brute Force)</h2></header><div class=entry-content><p>브루트 포스 (Brute Force) 브루트 포스는 가장 직관적이고 단순한 문제 해결 기법으로, 가능한 모든 경우의 수를 철저하게 조사하여 문제의 해결책을 찾는 방법이다.
“무차별 대입법” 또는 “완전 탐색"이라고도 불리는 이 접근법은 컴퓨터 과학과 알고리즘 설계에서 기본적인 방법론으로 사용된다.
브루트 포스는 가장 직관적이고 단순한 문제 해결 접근법으로, 구현이 쉽고 모든 가능한 해결책을 검사하기 때문에 완전성을 보장한다. 그러나 시간 복잡도가 높아 큰 문제에는 적합하지 않다.
실제 응용에서는 브루트 포스를 단독으로 사용하기보다는 다른 최적화 기법과 함께 사용하거나, 더 효율적인 알고리즘이 없는 경우의 대안으로 활용한다. 또한, 브루트 포스는 문제 해결의 기본 접근법으로서 다른 고급 알고리즘의 기초가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 07:50:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 브루트 포스 (Brute Force)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>슬라이딩 윈도우 기법 (Sliding Window Technique)</h2></header><div class=entry-content><p>슬라이딩 윈도우 기법 (Sliding Window Technique) 슬라이딩 윈도우 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 특정 범위의 요소들을 효율적으로 처리하기 위한 알고리즘 패러다임.
이 기법은 “창문(window)“처럼 움직이는 부분 배열을 이용하여 시간 복잡도를 획기적으로 개선할 수 있는 강력한 문제 해결 방법이다.
슬라이딩 윈도우 기법은 선형 데이터 구조에서 연속된 요소들을 효율적으로 처리하기 위한 강력한 알고리즘 패러다임으로 이 기법을 이해하고 적용하면 중첩 반복문을 사용하는 시간 복잡도를 O(n²)에서 O(n)으로 줄일 수 있어, 성능 개선에 크게 기여할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-24 00:21:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 슬라이딩 윈도우 기법 (Sliding Window Technique)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hashing</h2></header><div class=entry-content><p>Hashing 해싱(Hashing)은 현대 컴퓨터 과학과 프로그래밍에서 가장 중요한 데이터 처리 기법 중 하나이다.
효율적인 데이터 검색과 저장을 가능하게 하는 이 기술은 다양한 애플리케이션에서 핵심적인 역할을 한다.
실제 프로젝트에서는 대부분 언어나 라이브러리에서 제공하는 최적화된 해시 테이블 구현체(파이썬의 딕셔너리나 집합 등)를 사용하게 되지만, 그 내부 동작 원리를 이해하는 것은 여전히 중요하다. 이러한 이해를 바탕으로 더 효율적인 코드를 작성하고, 필요에 따라 커스텀 해싱 솔루션을 개발할 수 있을 것이다.
해싱은 단순한 데이터 구조를 넘어 암호화, 데이터 무결성 검증, 분산 시스템 등 다양한 분야에서 핵심적인 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-12-16 09:35:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hashing" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백트래킹 (Backtracking)</h2></header><div class=entry-content><p>백트래킹 (Backtracking) 백트래킹은 해결책을 찾는 과정에서 후보군을 구축하다가 해당 후보군이 해결책이 될 수 없다고 판단되면, 즉시 이전 단계로 돌아가서(백트랙) 다른 후보군을 탐색하는 문제 해결 전략이다.
알고리즘의 효율성을 높이는 중요한 기법으로, 완전 탐색보다 효율적으로 문제를 해결할 수 있게 해준다.
백트래킹은 조합 최적화 문제를 해결하는 강력한 알고리즘 패러다임이다.
모든 가능한 해결책을 체계적으로 탐색하면서도, 불가능한 경로를 조기에 차단하여 효율성을 높이는 특징이 있다.
N-Queen, 스도쿠, 미로 찾기, 조합 문제 등 다양한 영역에서 활용되며, 복잡한 문제를 해결하는 데 필수적인 도구이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 백트래킹 (Backtracking)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분기 한정법 (Branch and Bound)</h2></header><div class=entry-content><p>분기 한정법 (Branch and Bound) 분기한정법(Branch and Bound)은 최적화 문제를 해결하기 위한 효율적인 알고리즘 설계 패러다임이다.
이 방법은 거대한, 때로는 지수적으로 큰 해공간을 체계적으로 탐색하면서 최적해를 찾아내는 강력한 기법이다.
분기한정법은 다양한 최적화 문제를 해결하기 위한 강력하고 유연한 알고리즘 패러다임이다.
이 방법의 핵심은 문제를 체계적으로 나누고, 각 하위 문제의 한계값을 계산하여 유망하지 않은 경로를 가지치기함으로써 탐색 공간을 효과적으로 줄이는 데 있다.
분기한정법은 외판원 문제, 배낭 문제, 작업 할당 문제 등 다양한 NP-hard 최적화 문제에 성공적으로 적용되어 왔다.
물론 최악의 경우에는 여전히 지수 시간이 필요하지만, 효과적인 한계 함수와 가지치기 전략을 통해 실용적인 시간 내에 최적해 또는 근사 최적해를 찾을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분기 한정법 (Branch and Bound)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분할 정복 (Divide and Conquer)</h2></header><div class=entry-content><p>분할 정복 (Divide and Conquer) 분할 정복은 알고리즘 설계에서 가장 강력하고 널리 사용되는 패러다임 중 하나이다.
복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 이 접근법은 효율적인 알고리즘 설계의 핵심 원리이다.
정의와 원리 분할 정복(Divide and Conquer)은 복잡한 문제를 다음과 같은 세 단계로 해결하는 알고리즘 설계 기법이다:
분할(Divide): 원래 문제를 같은 유형의 더 작은 하위 문제들로 나눈다. 정복(Conquer): 하위 문제들을 재귀적으로 해결한다. 하위 문제가 충분히 작으면 직접 해결한다. 결합(Combine): 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 만든다. 분할 정복은 재귀적 사고에 기반하며, 큰 문제를 동일한 형태의 작은 문제들로 축소하여 해결하는 방식이다.
이 과정은 문제가 충분히 작아질 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분할 정복 (Divide and Conquer)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적 계획법 (Dynamic Programming)</h2></header><div class=entry-content><p>동적 계획법 (Dynamic Programming, DP) 동적 계획법은 컴퓨터 과학과 수학 분야에서 복잡한 문제를 더 간단한 하위 문제로 나누어 해결하는 강력한 알고리즘 설계 기법이다.
이 접근법은 특히 최적화 문제를 해결하는 데 매우 효과적이며, 다양한 응용 분야에서 널리 사용된다.
최적 부분 구조와 중복되는 하위 문제 특성을 가진 문제들에 적용할 수 있으며, 분할 정복과 달리 이미 해결한 하위 문제의 결과를 저장하고 재활용함으로써 계산 효율성을 크게 향상시킨다.
동적 계획법의 기본 개념 동적 계획법(Dynamic Programming, DP)은 복잡한 문제를 여러 개의 겹치는 하위 문제로 나누고, 각 하위 문제를 한 번만 풀어 그 결과를 저장해두고 재활용하는 알고리즘 설계 방법이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적 계획법 (Dynamic Programming)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>탐욕 알고리즘 (Greedy Algorithm)</h2></header><div class=entry-content><p>탐욕 알고리즘 (Greedy Algorithm) 탐욕 알고리즘(Greedy Algorithm)은 최적화 문제를 해결하기 위한 간단하면서도 강력한 알고리즘 패러다임이다.
이 알고리즘은 ‘탐욕적’이라는 이름처럼, 각 단계에서 현재 상황에서 가장 좋아 보이는 선택(locally optimal choice)을 하는 방식으로 동작한다.
즉, 지금 당장 최적의 선택을 하면 전체적으로도 최적의 결과를 얻을 수 있을 것이라는 기대를 바탕으로 한다.
탐욕 알고리즘은 직관적이고 효율적인 알고리즘 설계 패러다임으로, 많은 최적화 문제에서 간단하면서도 강력한 해결책을 제공한다.
각 단계에서 현재 상황에서 가장 좋은 선택을 하는 방식으로 작동하며, 일부 문제에서는 전역 최적해를 보장한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 탐욕 알고리즘 (Greedy Algorithm)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>랜덤화 알고리즘 (Randomized Algorithm)</h2></header><div class=entry-content><p>랜덤화 알고리즘 (Randomized Algorithm) 랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다. 이 무작위성은 알고리즘의 동작이나 결정에 영향을 미치며, 같은 입력에 대해서도 매번 다른 결과를 낼 수 있다.
특성 무작위성: 알고리즘의 핵심 특성으로, 난수를 사용하여 결정을 내린다. 확률적 성능: 알고리즘의 성능이 확률적으로 분석된다. 다양성: 같은 입력에 대해 다양한 출력이 가능하다. 목적과 필요성 복잡한 문제의 간단한 해결책 제공 최악의 경우 성능 개선 결정론적 알고리즘의 한계 극복 평균 실행 시간 단축 장점 단순성: 복잡한 문제에 대해 간단한 해결책 제공 효율성: 많은 경우에 결정론적 알고리즘보다 빠름 유연성: 다양한 문제에 적용 가능 단점 결과의 일관성 부족: 같은 입력에 대해 다른 결과 가능 디버깅의 어려움: 무작위성으로 인해 재현이 어려울 수 있음 최악의 경우 보장 부족: 확률적 성능으로 인해 최악의 경우를 완전히 배제할 수 없음 작동 원리 문제 정의 무작위 선택 요소 식별 난수 생성기 사용 무작위 선택에 기반한 결정 결과 도출 및 분석 좋은 알고리즘의 조건 효율성: 평균적으로 좋은 성능을 보여야 함 정확성: 높은 확률로 정확한 결과를 제공해야 함 단순성: 구현과 이해가 쉬워야 함 확장성: 다양한 입력 크기에 대응할 수 있어야 함 효율적인 구현을 위한 팁 고품질의 난수 생성기 사용 무작위성의 적절한 활용 확률 분석을 통한 성능 최적화 병렬화 가능성 고려 핵심 구성 요소 난수 생성기 무작위 선택 메커니즘 결정 함수 종료 조건 실제 예시 랜덤화된 퀵 정렬 알고리즘
...</p></div><footer class=entry-footer><span title='2024-10-13 05:55:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 랜덤화 알고리즘 (Randomized Algorithm)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/approximation-techniques/randomized-algorithm/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>