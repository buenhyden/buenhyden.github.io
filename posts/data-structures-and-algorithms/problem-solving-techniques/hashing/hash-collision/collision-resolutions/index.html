<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Collision resolutions | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Hashing,Hash-Collision,Collision-resolutions"><meta name=description content="해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.  그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Collision resolutions"><meta property="og:description" content="해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.  그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-08T13:40:00+00:00"><meta property="article:modified_time" content="2024-12-08T13:40:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Hashing"><meta property="article:tag" content="Hash-Collision"><meta property="article:tag" content="Collision-Resolutions"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Collision resolutions"><meta name=twitter:description content="해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.  그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"Hashing","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/"},{"@type":"ListItem","position":5,"name":"Hash Collision","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/"},{"@type":"ListItem","position":6,"name":"Collision resolutions","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Collision resolutions","name":"Collision resolutions","description":"해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.  그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Hashing","Hash-Collision","Collision-resolutions"],"articleBody":"Collision Resolutions 해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.\n그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다.\n해시 함수는 임의 크기의 데이터를 고정된 크기의 값으로 매핑한다. 해시 테이블의 크기가 제한되어 있기 때문에, 서로 다른 키들이 같은 해시 값(버킷 인덱스)을 가지는 ‘충돌’이 불가피하게 발생한다. 이는 ‘비둘기집 원리(Pigeonhole Principle)‘에 의해 증명된다 - 가능한 키의 수가 해시 테이블의 크기보다 크면 충돌은 반드시 발생한다.\n해시 함수를 hash(key) % 5로 정의하고, 아래 데이터를 저장한다고 가정하자.\n1 2 Key1 → hash(Key1) % 5 → Index 2 Key2 → hash(Key2) % 5 → Index 2 (충돌 발생!) Key1과 Key2가 동일한 인덱스(2)에 저장되려 하면 충돌이 발생한다.\n해시 테이블의 충돌 해결 방법은 다양한 상황과 요구사항에 따라 선택할 수 있다. 각 방법은 고유한 장단점을 가지고 있으며, 구현의 복잡성, 메모리 사용량, 성능 특성이 다르다. 응용 프로그램의 특성과 데이터 패턴, 그리고 성능 요구사항을 고려하여 적절한 충돌 해결 방법을 선택하는 것이 중요하다.\n최근 연구에서는 여러 기법을 결합한 하이브리드 접근 방식도 등장하고 있으며, 머신 러닝을 활용하여 데이터 패턴에 맞게 해시 함수를 최적화하는 방법도 연구되고 있다.\nCollision Resolution (충돌 해결 방법) 개요 충돌이 발생할 경우, 데이터를 올바르게 저장하고 검색할 수 있도록 해결하는 방법이 필요하다.\n해시 테이블에서 충돌을 해결하는 방법에는 “체이닝(Chaining)” 과 “오픈 어드레싱(Open Addressing)” 기법이 대표적이다.\n충돌 해결 방법 해시 충돌을 해결하기 위한 다양한 기법들을 크게 두 가지 범주로 나눌 수 있다:\n체이닝(Chaining) 개방 주소법(Open Addressing) 체이닝(Chaining) 체이닝은 각 해시 버킷에 연결 리스트(linked list)나 다른 자료구조를 사용하여 충돌이 발생한 항목들을 저장하는 방법이다.\n작동 방식: 키의 해시 값을 계산한다. 계산된 해시 값(인덱스)에 해당하는 버킷에 키-값 쌍을 저장한다. 충돌이 발생하면, 같은 버킷에 있는 연결 리스트에 새 항목을 추가한다. 구현 예제 (Python): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class HashNode: def __init__(self, key, value): self.key = key self.value = value self.next = None class HashTable: def __init__(self, size): self.size = size self.table = [None] * size def _hash(self, key): # 간단한 해시 함수 return hash(key) % self.size def insert(self, key, value): index = self._hash(key) if self.table[index] is None: self.table[index] = HashNode(key, value) else: # 충돌 발생: 연결 리스트의 시작 부분에 새 노드 추가 current = self.table[index] # 이미 존재하는 키라면 값 업데이트 if current.key == key: current.value = value return while current.next: if current.next.key == key: current.next.value = value return current = current.next # 새 노드 추가 current.next = HashNode(key, value) 체이닝의 변형: 단순 연결 리스트(Singly Linked List): 가장 기본적인 구현 방식. 이중 연결 리스트(Doubly Linked List): 양방향 탐색이 가능. 동적 배열(Dynamic Array): 메모리 지역성이 좋아 캐시 효율이 높다. 균형 이진 트리(Balanced Binary Tree): 최악의 경우 검색 시간을 O(log n)으로 보장. 자체 균형 이진 탐색 트리(Self-balancing BST): AVL 트리나 레드-블랙 트리를 사용. 장점: 구현이 간단. 해시 테이블이 절대 가득 차지 않는다(연결 리스트가 계속 확장될 수 있으므로). 삭제 연산이 비교적 간단하다. 단점: 각 노드마다 포인터를 저장해야 하므로 추가 메모리가 필요하다. 연결 리스트가 길어지면 검색 시간이 O(n)까지 증가할 수 있다. 캐시 지역성(cache locality)이 좋지 않을 수 있다. 개방 주소법(Open Addressing) 개방 주소법은 모든 키-값 쌍을 해시 테이블 배열 자체에 직접 저장하는 방법. 충돌이 발생하면 다른 빈 슬롯을 찾아 데이터를 저장하다.\n주요 탐사(Probing) 방법: 선형 탐사(Linear Probing) 해시 충돌이 발생하면 순차적으로 다음 슬롯을 확인하여 빈 공간을 찾는다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def insert(self, key, value): index = self._hash(key) # 선형 탐사를 사용하여 빈 슬롯 찾기 original_index = index while self.table[index] is not None: # 이미 존재하는 키라면 값 업데이트 if self.table[index].key == key: self.table[index].value = value return # 다음 슬롯으로 이동 index = (index + 1) % self.size # 테이블이 가득 찼거나 모든 슬롯을 확인한 경우 if index == original_index: raise Exception(\"해시 테이블이 가득 찼습니다\") # 빈 슬롯에 새 노드 삽입 self.table[index] = HashNode(key, value) 장점:\n캐시 지역성이 좋아 메모리 효율이 높다. 체이닝보다 메모리 오버헤드가 적다. 단점:\n‘클러스터링(clustering)’ 현상: 연속된 슬롯이 채워져 충돌 가능성 증가 해시 테이블 로드 팩터(load factor)가 증가하면 성능이 급격히 저하된다. 제곱 탐사(Quadratic Probing) 선형 탐사의 클러스터링 문제를 완화하기 위해, 충돌 발생 시 1², 2², 3², … 간격으로 다음 위치를 탐색한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def insert(self, key, value): index = self._hash(key) original_index = index i = 1 while self.table[index] is not None: if self.table[index].key == key: self.table[index].value = value return # 제곱 탐사 index = (original_index + i*i) % self.size i += 1 if i \u003e= self.size: raise Exception(\"해시 테이블이 가득 찼거나 순환이 발생했습니다\") self.table[index] = HashNode(key, value) 장점:\n선형 탐사보다 클러스터링이 적게 발생. 단점:\n여전히 2차 클러스터링(secondary clustering) 문제가 있다. 테이블이 충분히 크지 않으면 모든 슬롯을 탐색하지 못할 수 있다. 이중 해싱(Double Hashing) 충돌 발생 시 두 번째 해시 함수를 사용하여 다음 위치를 결정하는 방법.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def insert(self, key, value): index = self._hash1(key) if self.table[index] is not None and self.table[index].key != key: # 충돌 발생: 두 번째 해시 함수 사용 step = self._hash2(key) original_index = index while True: index = (index + step) % self.size if self.table[index] is None or self.table[index].key == key: break if index == original_index: raise Exception(\"해시 테이블이 가득 찼습니다\") if self.table[index] is not None and self.table[index].key == key: self.table[index].value = value else: self.table[index] = HashNode(key, value) 장점:\n클러스터링 문제를 크게 줄일 수 있다. 충돌이 많이 발생하는 경우 더 효율적. 단점:\n두 번째 해시 함수 계산으로 인한 추가 비용이 발생. 두 번째 해시 함수는 0을 반환하지 않아야 하며, 테이블 크기와 서로소여야 한다. 로빈 후드 해싱(Robin Hood Hashing) 개방 주소법의 변형으로, ‘부자에게서 빼앗아 가난한 자에게 주는’ 원칙에 기반한다. 각 키의 ‘탐색 거리(probe distance)‘를 기록하고, 새 항목이 기존 항목보다 탐색 거리가 더 길면 자리를 바꾼다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def insert(self, key, value): index = self._hash(key) distance = 0 while True: if self.table[index] is None: # 빈 슬롯에 삽입 self.table[index] = HashEntry(key, value, distance) return if self.table[index].key == key: # 기존 키 업데이트 self.table[index].value = value return if self.table[index].distance \u003c distance: # 로빈 후드: 현재 항목보다 더 멀리 이동한 경우 위치 교환 entry = HashEntry(key, value, distance) entry, self.table[index] = self.table[index], entry key, value = entry.key, entry.value distance = entry.distance # 다음 슬롯으로 이동 index = (index + 1) % self.size distance += 1 if distance \u003e= self.size: raise Exception(\"해시 테이블이 가득 찼습니다\") 장점:\n최악의 경우 검색 시간이 개선. 클러스터링을 효과적으로 관리. 단점:\n구현이 더 복잡. 삭제 연산이 까다로울 수 있다. 쿠쿠 해싱(Cuckoo Hashing) 두 개 이상의 해시 함수를 사용하며, 충돌 시 기존 항목을 다른 위치로 강제 이동시키는 방식.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class CuckooHashTable: def __init__(self, size): self.size = size self.table1 = [None] * size self.table2 = [None] * size self.max_recursion = size # 무한 루프 방지 def _hash1(self, key): return hash(key) % self.size def _hash2(self, key): # 다른 해시 함수 return (hash(key) // self.size) % self.size def insert(self, key, value, recursion_depth=0): if recursion_depth \u003e= self.max_recursion: # 재해싱 필요 self._rehash() self.insert(key, value) return h1 = self._hash1(key) # 테이블1 확인 if self.table1[h1] is None: self.table1[h1] = (key, value) return if self.table1[h1][0] == key: self.table1[h1] = (key, value) # 업데이트 return # 테이블1의 항목을 임시 저장 old_key, old_value = self.table1[h1] self.table1[h1] = (key, value) # 이전 항목을 테이블2로 이동 h2 = self._hash2(old_key) if self.table2[h2] is None: self.table2[h2] = (old_key, old_value) return if self.table2[h2][0] == old_key: self.table2[h2] = (old_key, old_value) # 업데이트 return # 테이블2의 항목을 다시 테이블1로 이동 (재귀적) next_key, next_value = self.table2[h2] self.table2[h2] = (old_key, old_value) self.insert(next_key, next_value, recursion_depth + 1) 장점:\n최악의 경우 조회 시간이 O(1). 높은 로드 팩터에서도 좋은 성능을 유지. 단점:\n재해싱이 필요할 수 있으며, 이는 비용이 큰 연산. 해시 함수의 선택이 중요. 로드 팩터는 일반적으로 50% 이하로 유지해야 한다. 점프 해싱(Hopscotch Hashing) 각 키가 자신의 ‘이웃 영역(neighborhood)’ 내에 위치하도록 보장하는 방법. 충돌이 발생하면 이웃 영역 내에서 자리를 바꿔가며 공간을 확보한다.\n장점:\n높은 로드 팩터에서도 좋은 성능을 유지. 캐시 지역성이 좋다. 단점:\n구현이 복잡. 이웃 영역의 크기 선택이 중요. 확장성 관리 해시 테이블이 너무 가득 차면 성능이 저하된다. 이를 관리하기 위한 방법으로는:\n재해싱(Rehashing) 로드 팩터가 특정 임계값을 초과하면 더 큰 테이블을 생성하고 모든 항목을 재삽입한다.\n1 2 3 4 5 6 7 8 9 def _rehash(self): old_size = self.size self.size = old_size * 2 old_table = self.table self.table = [None] * self.size for i in range(old_size): if old_table[i] is not None: self.insert(old_table[i].key, old_table[i].value) 점진적 재해싱(Incremental Rehashing) 전체 테이블을 한 번에 재해싱하는 대신, 작은 단위로 나누어 시간을 분산시킨다. Redis와 같은 시스템에서 사용.\n해시 함수의 선택 좋은 해시 함수는 충돌을 최소화하기 위해 중요하다.\n좋은 해시 함수의 특성:\n균등 분포(Uniform Distribution): 키를 해시 테이블 전체에 고르게 분산시킨다. 계산 효율성: 빠르게 계산할 수 있어야 한다. 결정론적(Deterministic): 같은 키는 항상 같은 해시 값을 가져야 한다. 충돌 최소화: 서로 다른 키가 같은 해시 값을 가질 확률을 최소화해야 한다. 널리 사용되는 해시 함수로는:\n문자열을 위한 djb2, fnv1a 일반 데이터를 위한 MurmurHash, xxHash 암호화 관련 용도의 SHA-256, Blake2 충돌 해결 방법 비교 해결 방법 장점 단점 적합한 상황 평균 성능 최악 성능 체이닝 구현 간단, 삭제 쉬움, 로드 팩터 제한 없음 추가 메모리 필요, 캐시 지역성 낮음 데이터 크기가 가변적이고 예측 불가능한 경우 O(1 + α) O(n) 선형 탐사 캐시 지역성 좋음, 메모리 효율적 클러스터링 발생, 삭제 복잡 작은 크기 해시 테이블, 캐시 성능 중요한 경우 O(1/(1-α)) O(n) 제곱 탐사 클러스터링 감소, 구현 간단 2차 클러스터링 존재, 모든 슬롯 탐색 못할 수 있음 중간 크기 테이블, 선형 탐사보다 일관된 성능 필요한 경우 O(1/(1-α)) O(n) 이중 해싱 클러스터링 최소화, 효율적인 공간 활용 두 번째 해시 계산 비용, 구현 복잡 대규모 해시 테이블, 충돌이 많이 예상되는 경우 O(1/(1-α)) O(n) 로빈 후드 해싱 탐색 시간 분산 효과, 최악 케이스 개선 구현 복잡, 삭제 어려움 검색 성능의 일관성이 중요한 경우 O(log n) O(log n) 쿠쿠 해싱 최악 조회 O(1), 삭제 간단 로드 팩터 제한, 재해싱 필요, 구현 복잡 조회 성능이 중요하고 일정한 경우 O(1) O(1)* 점프 해싱 높은 로드 팩터에서 좋은 성능, 캐시 지역성 구현 매우 복잡, 튜닝 필요 높은 로드 팩터와 일관된 성능이 필요한 경우 O(1) O(1)* *재해싱이 필요한 경우를 제외하고\n여기서 α는 로드 팩터(load factor)로, 해시 테이블에 저장된 항목 수를 테이블 크기로 나눈 값.\n실제 구현 사례 Java HashMap: 체이닝 방식을 사용하며, 버킷당 항목이 많으면 연결 리스트에서 균형 트리로 전환합니다. Python dict: 개방 주소법의 변형을 사용합니다. Redis: 점진적 재해싱을 사용한 체이닝 방식을 구현합니다. Google’s SwissTable/FlatMap: 로빈 후드 해싱의 변형을 사용합니다. 참고 및 출처 ","wordCount":"1767","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-08T13:40:00Z","dateModified":"2024-12-08T13:40:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/>Hashing</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/>Hash Collision</a></div><h1 class="post-title entry-hint-parent">Collision resolutions</h1><div class=post-description>해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다. 그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다.</div><div class=post-meta><span title='2024-12-08 13:40:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1767 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Hashing/Hash%20Collision/Collision-Resolutions.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#collision-resolutions>Collision Resolutions</a><ul><li><a href=#collision-resolution-충돌-해결-방법-개요>Collision Resolution (충돌 해결 방법) 개요</a></li><li><a href=#충돌-해결-방법>충돌 해결 방법</a></li><li><a href=#확장성-관리>확장성 관리</a></li><li><a href=#해시-함수의-선택>해시 함수의 선택</a></li><li><a href=#충돌-해결-방법-비교>충돌 해결 방법 비교</a></li><li><a href=#실제-구현-사례>실제 구현 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=collision-resolutions>Collision Resolutions<a hidden class=anchor aria-hidden=true href=#collision-resolutions>#</a></h2><p>해시 테이블(Hash Table)은 <strong>키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조</strong>이다.<br>그러나 <strong>서로 다른 키가 같은 해시 인덱스로 매핑되는 경우</strong>가 발생할 수 있으며, 이를 <strong>충돌(Collision)</strong> 이라고 한다.</p><p>해시 함수는 임의 크기의 데이터를 고정된 크기의 값으로 매핑한다.
해시 테이블의 크기가 제한되어 있기 때문에, 서로 다른 키들이 같은 해시 값(버킷 인덱스)을 가지는 &lsquo;충돌&rsquo;이 불가피하게 발생한다.
이는 &lsquo;비둘기집 원리(Pigeonhole Principle)&lsquo;에 의해 증명된다 - 가능한 키의 수가 해시 테이블의 크기보다 크면 충돌은 반드시 발생한다.</p><p>해시 함수를 <code>hash(key) % 5</code>로 정의하고, 아래 데이터를 저장한다고 가정하자.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Key1 → hash(Key1) % 5 → Index 2
</span></span><span class=line><span class=cl>Key2 → hash(Key2) % 5 → Index 2  (충돌 발생!)
</span></span></code></pre></td></tr></table></div></div><p><strong>Key1과 Key2가 동일한 인덱스(2)에 저장되려 하면 충돌이 발생</strong>한다.</p><p>해시 테이블의 충돌 해결 방법은 다양한 상황과 요구사항에 따라 선택할 수 있다. 각 방법은 고유한 장단점을 가지고 있으며, 구현의 복잡성, 메모리 사용량, 성능 특성이 다르다.
응용 프로그램의 특성과 데이터 패턴, 그리고 성능 요구사항을 고려하여 적절한 충돌 해결 방법을 선택하는 것이 중요하다.</p><p>최근 연구에서는 여러 기법을 결합한 하이브리드 접근 방식도 등장하고 있으며, 머신 러닝을 활용하여 데이터 패턴에 맞게 해시 함수를 최적화하는 방법도 연구되고 있다.</p><h3 id=collision-resolution-충돌-해결-방법-개요>Collision Resolution (충돌 해결 방법) 개요<a hidden class=anchor aria-hidden=true href=#collision-resolution-충돌-해결-방법-개요>#</a></h3><p>충돌이 발생할 경우, <strong>데이터를 올바르게 저장하고 검색할 수 있도록 해결하는 방법</strong>이 필요하다.<br>해시 테이블에서 충돌을 해결하는 방법에는 <strong>&ldquo;체이닝(Chaining)&rdquo;</strong> 과 <strong>&ldquo;오픈 어드레싱(Open Addressing)&rdquo;</strong> 기법이 대표적이다.</p><h3 id=충돌-해결-방법>충돌 해결 방법<a hidden class=anchor aria-hidden=true href=#충돌-해결-방법>#</a></h3><p>해시 충돌을 해결하기 위한 다양한 기법들을 크게 두 가지 범주로 나눌 수 있다:</p><ol><li><strong>체이닝(Chaining)</strong></li><li><strong>개방 주소법(Open Addressing)</strong></li></ol><h4 id=체이닝chaining>체이닝(Chaining)<a hidden class=anchor aria-hidden=true href=#체이닝chaining>#</a></h4><p>체이닝은 각 해시 버킷에 연결 리스트(linked list)나 다른 자료구조를 사용하여 충돌이 발생한 항목들을 저장하는 방법이다.</p><h5 id=작동-방식>작동 방식:<a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h5><ol><li>키의 해시 값을 계산한다.</li><li>계산된 해시 값(인덱스)에 해당하는 버킷에 키-값 쌍을 저장한다.</li><li>충돌이 발생하면, 같은 버킷에 있는 연결 리스트에 새 항목을 추가한다.</li></ol><h5 id=구현-예제-python>구현 예제 (Python):<a hidden class=anchor aria-hidden=true href=#구현-예제-python>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>HashNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>HashTable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_hash</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 간단한 해시 함수</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>HashNode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 충돌 발생: 연결 리스트의 시작 부분에 새 노드 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 이미 존재하는 키라면 값 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>current</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>current</span><span class=o>.</span><span class=n>next</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span>
</span></span><span class=line><span class=cl>                <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 새 노드 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>HashNode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=체이닝의-변형>체이닝의 변형:<a hidden class=anchor aria-hidden=true href=#체이닝의-변형>#</a></h5><ol><li><strong>단순 연결 리스트(Singly Linked List)</strong>: 가장 기본적인 구현 방식.</li><li><strong>이중 연결 리스트(Doubly Linked List)</strong>: 양방향 탐색이 가능.</li><li><strong>동적 배열(Dynamic Array)</strong>: 메모리 지역성이 좋아 캐시 효율이 높다.</li><li><strong>균형 이진 트리(Balanced Binary Tree)</strong>: 최악의 경우 검색 시간을 O(log n)으로 보장.</li><li><strong>자체 균형 이진 탐색 트리(Self-balancing BST)</strong>: AVL 트리나 레드-블랙 트리를 사용.</li></ol><h5 id=장점>장점:<a hidden class=anchor aria-hidden=true href=#장점>#</a></h5><ul><li>구현이 간단.</li><li>해시 테이블이 절대 가득 차지 않는다(연결 리스트가 계속 확장될 수 있으므로).</li><li>삭제 연산이 비교적 간단하다.</li></ul><h5 id=단점>단점:<a hidden class=anchor aria-hidden=true href=#단점>#</a></h5><ul><li>각 노드마다 포인터를 저장해야 하므로 추가 메모리가 필요하다.</li><li>연결 리스트가 길어지면 검색 시간이 O(n)까지 증가할 수 있다.</li><li>캐시 지역성(cache locality)이 좋지 않을 수 있다.</li></ul><h4 id=개방-주소법open-addressing>개방 주소법(Open Addressing)<a hidden class=anchor aria-hidden=true href=#개방-주소법open-addressing>#</a></h4><p>개방 주소법은 모든 키-값 쌍을 해시 테이블 배열 자체에 직접 저장하는 방법.
충돌이 발생하면 다른 빈 슬롯을 찾아 데이터를 저장하다.</p><h5 id=주요-탐사probing-방법>주요 탐사(Probing) 방법:<a hidden class=anchor aria-hidden=true href=#주요-탐사probing-방법>#</a></h5><h6 id=선형-탐사linear-probing>선형 탐사(Linear Probing)<a hidden class=anchor aria-hidden=true href=#선형-탐사linear-probing>#</a></h6><p>해시 충돌이 발생하면 순차적으로 다음 슬롯을 확인하여 빈 공간을 찾는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 선형 탐사를 사용하여 빈 슬롯 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>original_index</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 이미 존재하는 키라면 값 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 다음 슬롯으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 테이블이 가득 찼거나 모든 슬롯을 확인한 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=n>original_index</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;해시 테이블이 가득 찼습니다&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 빈 슬롯에 새 노드 삽입</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>HashNode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>장점</strong>:</p><ul><li>캐시 지역성이 좋아 메모리 효율이 높다.</li><li>체이닝보다 메모리 오버헤드가 적다.</li></ul><p><strong>단점</strong>:</p><ul><li>&lsquo;클러스터링(clustering)&rsquo; 현상: 연속된 슬롯이 채워져 충돌 가능성 증가</li><li>해시 테이블 로드 팩터(load factor)가 증가하면 성능이 급격히 저하된다.</li></ul><h6 id=제곱-탐사quadratic-probing>제곱 탐사(Quadratic Probing)<a hidden class=anchor aria-hidden=true href=#제곱-탐사quadratic-probing>#</a></h6><p>선형 탐사의 클러스터링 문제를 완화하기 위해, 충돌 발생 시 1², 2², 3², … 간격으로 다음 위치를 탐색한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>original_index</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 제곱 탐사</span>
</span></span><span class=line><span class=cl>        <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>original_index</span> <span class=o>+</span> <span class=n>i</span><span class=o>*</span><span class=n>i</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;해시 테이블이 가득 찼거나 순환이 발생했습니다&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>HashNode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>장점</strong>:</p><ul><li>선형 탐사보다 클러스터링이 적게 발생.</li></ul><p><strong>단점</strong>:</p><ul><li>여전히 2차 클러스터링(secondary clustering) 문제가 있다.</li><li>테이블이 충분히 크지 않으면 모든 슬롯을 탐색하지 못할 수 있다.</li></ul><h6 id=이중-해싱double-hashing>이중 해싱(Double Hashing)<a hidden class=anchor aria-hidden=true href=#이중-해싱double-hashing>#</a></h6><p>충돌 발생 시 두 번째 해시 함수를 사용하여 다음 위치를 결정하는 방법.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash1</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>key</span> <span class=o>!=</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 충돌 발생: 두 번째 해시 함수 사용</span>
</span></span><span class=line><span class=cl>        <span class=n>step</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash2</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>original_index</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=n>step</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>or</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>index</span> <span class=o>==</span> <span class=n>original_index</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;해시 테이블이 가득 찼습니다&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>HashNode</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>장점</strong>:</p><ul><li>클러스터링 문제를 크게 줄일 수 있다.</li><li>충돌이 많이 발생하는 경우 더 효율적.</li></ul><p><strong>단점</strong>:</p><ul><li>두 번째 해시 함수 계산으로 인한 추가 비용이 발생.</li><li>두 번째 해시 함수는 0을 반환하지 않아야 하며, 테이블 크기와 서로소여야 한다.</li></ul><h4 id=로빈-후드-해싱robin-hood-hashing>로빈 후드 해싱(Robin Hood Hashing)<a hidden class=anchor aria-hidden=true href=#로빈-후드-해싱robin-hood-hashing>#</a></h4><p>개방 주소법의 변형으로, &lsquo;부자에게서 빼앗아 가난한 자에게 주는&rsquo; 원칙에 기반한다.
각 키의 &lsquo;탐색 거리(probe distance)&lsquo;를 기록하고, 새 항목이 기존 항목보다 탐색 거리가 더 길면 자리를 바꾼다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 빈 슬롯에 삽입</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=n>HashEntry</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>distance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 기존 키 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=n>distance</span> <span class=o>&lt;</span> <span class=n>distance</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 로빈 후드: 현재 항목보다 더 멀리 이동한 경우 위치 교환</span>
</span></span><span class=line><span class=cl>            <span class=n>entry</span> <span class=o>=</span> <span class=n>HashEntry</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>distance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>entry</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>index</span><span class=p>],</span> <span class=n>entry</span>
</span></span><span class=line><span class=cl>            <span class=n>key</span><span class=p>,</span> <span class=n>value</span> <span class=o>=</span> <span class=n>entry</span><span class=o>.</span><span class=n>key</span><span class=p>,</span> <span class=n>entry</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>distance</span> <span class=o>=</span> <span class=n>entry</span><span class=o>.</span><span class=n>distance</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 다음 슬롯으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>index</span> <span class=o>=</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=n>distance</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>distance</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;해시 테이블이 가득 찼습니다&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>장점</strong>:</p><ul><li>최악의 경우 검색 시간이 개선.</li><li>클러스터링을 효과적으로 관리.</li></ul><p><strong>단점</strong>:</p><ul><li>구현이 더 복잡.</li><li>삭제 연산이 까다로울 수 있다.</li></ul><h4 id=쿠쿠-해싱cuckoo-hashing>쿠쿠 해싱(Cuckoo Hashing)<a hidden class=anchor aria-hidden=true href=#쿠쿠-해싱cuckoo-hashing>#</a></h4><p>두 개 이상의 해시 함수를 사용하며, 충돌 시 기존 항목을 다른 위치로 강제 이동시키는 방식.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span><span class=lnt id=hl-6-33><a class=lnlinks href=#hl-6-33>33</a>
</span><span class=lnt id=hl-6-34><a class=lnlinks href=#hl-6-34>34</a>
</span><span class=lnt id=hl-6-35><a class=lnlinks href=#hl-6-35>35</a>
</span><span class=lnt id=hl-6-36><a class=lnlinks href=#hl-6-36>36</a>
</span><span class=lnt id=hl-6-37><a class=lnlinks href=#hl-6-37>37</a>
</span><span class=lnt id=hl-6-38><a class=lnlinks href=#hl-6-38>38</a>
</span><span class=lnt id=hl-6-39><a class=lnlinks href=#hl-6-39>39</a>
</span><span class=lnt id=hl-6-40><a class=lnlinks href=#hl-6-40>40</a>
</span><span class=lnt id=hl-6-41><a class=lnlinks href=#hl-6-41>41</a>
</span><span class=lnt id=hl-6-42><a class=lnlinks href=#hl-6-42>42</a>
</span><span class=lnt id=hl-6-43><a class=lnlinks href=#hl-6-43>43</a>
</span><span class=lnt id=hl-6-44><a class=lnlinks href=#hl-6-44>44</a>
</span><span class=lnt id=hl-6-45><a class=lnlinks href=#hl-6-45>45</a>
</span><span class=lnt id=hl-6-46><a class=lnlinks href=#hl-6-46>46</a>
</span><span class=lnt id=hl-6-47><a class=lnlinks href=#hl-6-47>47</a>
</span><span class=lnt id=hl-6-48><a class=lnlinks href=#hl-6-48>48</a>
</span><span class=lnt id=hl-6-49><a class=lnlinks href=#hl-6-49>49</a>
</span><span class=lnt id=hl-6-50><a class=lnlinks href=#hl-6-50>50</a>
</span><span class=lnt id=hl-6-51><a class=lnlinks href=#hl-6-51>51</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CuckooHashTable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table1</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table2</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>max_recursion</span> <span class=o>=</span> <span class=n>size</span>  <span class=c1># 무한 루프 방지</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_hash1</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_hash2</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 다른 해시 함수</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=nb>hash</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>//</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>)</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>recursion_depth</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>recursion_depth</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>max_recursion</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 재해싱 필요</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_rehash</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>h1</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash1</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 테이블1 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table1</span><span class=p>[</span><span class=n>h1</span><span class=p>]</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table1</span><span class=p>[</span><span class=n>h1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table1</span><span class=p>[</span><span class=n>h1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table1</span><span class=p>[</span><span class=n>h1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>  <span class=c1># 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 테이블1의 항목을 임시 저장</span>
</span></span><span class=line><span class=cl>        <span class=n>old_key</span><span class=p>,</span> <span class=n>old_value</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table1</span><span class=p>[</span><span class=n>h1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table1</span><span class=p>[</span><span class=n>h1</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 이전 항목을 테이블2로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>h2</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_hash2</span><span class=p>(</span><span class=n>old_key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table2</span><span class=p>[</span><span class=n>h2</span><span class=p>]</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table2</span><span class=p>[</span><span class=n>h2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>old_key</span><span class=p>,</span> <span class=n>old_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table2</span><span class=p>[</span><span class=n>h2</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>old_key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table2</span><span class=p>[</span><span class=n>h2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>old_key</span><span class=p>,</span> <span class=n>old_value</span><span class=p>)</span>  <span class=c1># 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 테이블2의 항목을 다시 테이블1로 이동 (재귀적)</span>
</span></span><span class=line><span class=cl>        <span class=n>next_key</span><span class=p>,</span> <span class=n>next_value</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table2</span><span class=p>[</span><span class=n>h2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table2</span><span class=p>[</span><span class=n>h2</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>old_key</span><span class=p>,</span> <span class=n>old_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>next_key</span><span class=p>,</span> <span class=n>next_value</span><span class=p>,</span> <span class=n>recursion_depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>장점</strong>:</p><ul><li>최악의 경우 조회 시간이 O(1).</li><li>높은 로드 팩터에서도 좋은 성능을 유지.</li></ul><p><strong>단점</strong>:</p><ul><li>재해싱이 필요할 수 있으며, 이는 비용이 큰 연산.</li><li>해시 함수의 선택이 중요.</li><li>로드 팩터는 일반적으로 50% 이하로 유지해야 한다.</li></ul><h4 id=점프-해싱hopscotch-hashing>점프 해싱(Hopscotch Hashing)<a hidden class=anchor aria-hidden=true href=#점프-해싱hopscotch-hashing>#</a></h4><p>각 키가 자신의 &lsquo;이웃 영역(neighborhood)&rsquo; 내에 위치하도록 보장하는 방법.
충돌이 발생하면 이웃 영역 내에서 자리를 바꿔가며 공간을 확보한다.</p><p><strong>장점</strong>:</p><ul><li>높은 로드 팩터에서도 좋은 성능을 유지.</li><li>캐시 지역성이 좋다.</li></ul><p><strong>단점</strong>:</p><ul><li>구현이 복잡.</li><li>이웃 영역의 크기 선택이 중요.</li></ul><h3 id=확장성-관리>확장성 관리<a hidden class=anchor aria-hidden=true href=#확장성-관리>#</a></h3><p>해시 테이블이 너무 가득 차면 성능이 저하된다.
이를 관리하기 위한 방법으로는:</p><ol><li><p>재해싱(Rehashing)
로드 팩터가 특정 임계값을 초과하면 더 큰 테이블을 생성하고 모든 항목을 재삽입한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>_rehash</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>old_size</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>old_size</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>old_table</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span>
</span></span><span class=line><span class=cl>    <span class=bp>self</span><span class=o>.</span><span class=n>table</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>old_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>old_table</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>old_table</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>key</span><span class=p>,</span> <span class=n>old_table</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>점진적 재해싱(Incremental Rehashing)
전체 테이블을 한 번에 재해싱하는 대신, 작은 단위로 나누어 시간을 분산시킨다.
Redis와 같은 시스템에서 사용.</p></li></ol><h3 id=해시-함수의-선택>해시 함수의 선택<a hidden class=anchor aria-hidden=true href=#해시-함수의-선택>#</a></h3><p>좋은 해시 함수는 충돌을 최소화하기 위해 중요하다.</p><p>좋은 해시 함수의 특성:</p><ol><li><strong>균등 분포(Uniform Distribution)</strong>: 키를 해시 테이블 전체에 고르게 분산시킨다.</li><li><strong>계산 효율성</strong>: 빠르게 계산할 수 있어야 한다.</li><li><strong>결정론적(Deterministic)</strong>: 같은 키는 항상 같은 해시 값을 가져야 한다.</li><li><strong>충돌 최소화</strong>: 서로 다른 키가 같은 해시 값을 가질 확률을 최소화해야 한다.</li></ol><p>널리 사용되는 해시 함수로는:</p><ul><li>문자열을 위한 djb2, fnv1a</li><li>일반 데이터를 위한 MurmurHash, xxHash</li><li>암호화 관련 용도의 SHA-256, Blake2</li></ul><h3 id=충돌-해결-방법-비교>충돌 해결 방법 비교<a hidden class=anchor aria-hidden=true href=#충돌-해결-방법-비교>#</a></h3><table><thead><tr><th>해결 방법</th><th>장점</th><th>단점</th><th>적합한 상황</th><th>평균 성능</th><th>최악 성능</th></tr></thead><tbody><tr><td><strong>체이닝</strong></td><td>구현 간단, 삭제 쉬움, 로드 팩터 제한 없음</td><td>추가 메모리 필요, 캐시 지역성 낮음</td><td>데이터 크기가 가변적이고 예측 불가능한 경우</td><td>O(1 + α)</td><td>O(n)</td></tr><tr><td><strong>선형 탐사</strong></td><td>캐시 지역성 좋음, 메모리 효율적</td><td>클러스터링 발생, 삭제 복잡</td><td>작은 크기 해시 테이블, 캐시 성능 중요한 경우</td><td>O(1/(1-α))</td><td>O(n)</td></tr><tr><td><strong>제곱 탐사</strong></td><td>클러스터링 감소, 구현 간단</td><td>2차 클러스터링 존재, 모든 슬롯 탐색 못할 수 있음</td><td>중간 크기 테이블, 선형 탐사보다 일관된 성능 필요한 경우</td><td>O(1/(1-α))</td><td>O(n)</td></tr><tr><td><strong>이중 해싱</strong></td><td>클러스터링 최소화, 효율적인 공간 활용</td><td>두 번째 해시 계산 비용, 구현 복잡</td><td>대규모 해시 테이블, 충돌이 많이 예상되는 경우</td><td>O(1/(1-α))</td><td>O(n)</td></tr><tr><td><strong>로빈 후드 해싱</strong></td><td>탐색 시간 분산 효과, 최악 케이스 개선</td><td>구현 복잡, 삭제 어려움</td><td>검색 성능의 일관성이 중요한 경우</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td><strong>쿠쿠 해싱</strong></td><td>최악 조회 O(1), 삭제 간단</td><td>로드 팩터 제한, 재해싱 필요, 구현 복잡</td><td>조회 성능이 중요하고 일정한 경우</td><td>O(1)</td><td>O(1)*</td></tr><tr><td><strong>점프 해싱</strong></td><td>높은 로드 팩터에서 좋은 성능, 캐시 지역성</td><td>구현 매우 복잡, 튜닝 필요</td><td>높은 로드 팩터와 일관된 성능이 필요한 경우</td><td>O(1)</td><td>O(1)*</td></tr></tbody></table><p>*재해싱이 필요한 경우를 제외하고</p><p>여기서 α는 로드 팩터(load factor)로, 해시 테이블에 저장된 항목 수를 테이블 크기로 나눈 값.</p><h3 id=실제-구현-사례>실제 구현 사례<a hidden class=anchor aria-hidden=true href=#실제-구현-사례>#</a></h3><ol><li><strong>Java HashMap</strong>: 체이닝 방식을 사용하며, 버킷당 항목이 많으면 연결 리스트에서 균형 트리로 전환합니다.</li><li><strong>Python dict</strong>: 개방 주소법의 변형을 사용합니다.</li><li><strong>Redis</strong>: 점진적 재해싱을 사용한 체이닝 방식을 구현합니다.</li><li><strong>Google&rsquo;s SwissTable/FlatMap</strong>: 로빈 후드 해싱의 변형을 사용합니다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/hashing/>Hashing</a></li><li><a href=https://buenhyden.github.io/tags/hash-collision/>Hash-Collision</a></li><li><a href=https://buenhyden.github.io/tags/collision-resolutions/>Collision-Resolutions</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack/stack-vs-linked-list/><span class=title>« Prev</span><br><span>Stack vs. Linked List</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/hash-table/load-factor/><span class=title>Next »</span><br><span>Load Factor</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>