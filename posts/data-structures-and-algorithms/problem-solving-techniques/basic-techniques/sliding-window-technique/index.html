<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>슬라이딩 윈도우 기법 (Sliding Window Technique) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Sliding-Window-Technique"><meta name=description content='슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 "슬라이딩"하면서 문제를 해결한다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="슬라이딩 윈도우 기법 (Sliding Window Technique)"><meta property="og:description" content='슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 "슬라이딩"하면서 문제를 해결한다.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-24T00:21:00+00:00"><meta property="article:modified_time" content="2025-01-24T00:21:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Sliding-Window-Technique"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="슬라이딩 윈도우 기법 (Sliding Window Technique)"><meta name=twitter:description content='슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 "슬라이딩"하면서 문제를 해결한다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"슬라이딩 윈도우 기법 (Sliding Window Technique)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"슬라이딩 윈도우 기법 (Sliding Window Technique)","name":"슬라이딩 윈도우 기법 (Sliding Window Technique)","description":"슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 \"슬라이딩\"하면서 문제를 해결한다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Sliding-Window-Technique"],"articleBody":"슬라이딩 윈도우 기법 (Sliding Window Technique) 슬라이딩 윈도우 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 특정 범위의 요소들을 효율적으로 처리하기 위한 알고리즘 패러다임.\n이 기법은 “창문(window)“처럼 움직이는 부분 배열을 이용하여 시간 복잡도를 획기적으로 개선할 수 있는 강력한 문제 해결 방법이다.\n슬라이딩 윈도우 기법은 선형 데이터 구조에서 연속된 요소들을 효율적으로 처리하기 위한 강력한 알고리즘 패러다임으로 이 기법을 이해하고 적용하면 중첩 반복문을 사용하는 시간 복잡도를 O(n²)에서 O(n)으로 줄일 수 있어, 성능 개선에 크게 기여할 수 있다.\n슬라이딩 윈도우 기법은 문자열 처리, 배열 연산, 데이터 스트림 처리 등 다양한 분야에서 활용된다.\n특히 고정 크기 윈도우와 가변 크기 윈도우 두 가지 유형을 이해하고 상황에 맞게 적용하면, 복잡한 문제도 효율적으로 해결할 수 있다.\n이 기법을 마스터하기 위해서는 다양한 문제를 해결하며 경험을 쌓고, 윈도우 상태 관리와 효율적인 업데이트 방법에 대한 이해를 깊게 하는 것이 중요하다.\n슬라이딩 윈도우의 기본 개념 슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 “슬라이딩\"하면서 문제를 해결한다. 이 과정에서 중요한 점은 윈도우가 이동할 때마다 모든 요소를 다시 계산하지 않고, 새로 추가되는 요소와 제거되는 요소만 고려하여 결과를 업데이트한다는 것이다.\n슬라이딩 윈도우 기법을 사용하면 중첩된 반복문을 사용하는 대신 단일 반복문으로 문제를 해결할 수 있어, O(n²)의 시간 복잡도를 O(n)으로 줄일 수 있다.\n슬라이딩 윈도우의 유형 슬라이딩 윈도우 기법은 크게 두 가지 유형으로 나눌 수 있다:\n고정 크기 윈도우 (Fixed Size Window) 윈도우의 크기가 처음부터 끝까지 일정하게 유지된다.\n예를 들어, “배열에서 연속된 k개 요소의 최대 합 찾기\"와 같은 문제에 적용된다.\n가변 크기 윈도우 (Variable Size Window) 윈도우의 크기가 문제의 조건에 따라 동적으로 변경된다.\n예를 들어, “합이 S 이상이 되는 최소 길이의 연속 부분 배열 찾기\"와 같은 문제에 적용된다.\n슬라이딩 윈도우 알고리즘의 단계 일반적인 슬라이딩 윈도우 알고리즘은 다음과 같은 단계로 구성된다:\n윈도우 정의: 처리할 데이터의 범위를 나타내는 윈도우를 정의한다. 윈도우 초기화: 윈도우의 첫 위치를 설정하고 초기 계산을 수행한다. 윈도우 이동: 윈도우를 한 칸씩 이동하면서 다음을 반복한다: 윈도우에서 빠져나가는 요소 처리 (왼쪽에서 제거) 윈도우로 새로 들어오는 요소 처리 (오른쪽에 추가) 현재 윈도우 상태에 따른 결과 업데이트 최종 결과 반환: 모든 윈도우 위치를 확인한 후 최종 결과를 반환한다. 슬라이딩 윈도우 구현 예제 고정 크기 윈도우 예제: 최대 부분 배열 합 다음은 크기가 k인 연속 부분 배열의 최대 합을 찾는 예제:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def max_sum_subarray(arr, k): n = len(arr) # 입력 검증 if n \u003c k: return \"배열 크기가 윈도우 크기보다 작습니다\" # 첫 번째 윈도우의 합 계산 window_sum = sum(arr[:k]) max_sum = window_sum # 윈도우 슬라이딩 for i in range(k, n): # 새 요소 추가, 이전 요소 제거 window_sum = window_sum + arr[i] - arr[i - k] # 최대값 업데이트 max_sum = max(max_sum, window_sum) return max_sum # 예시 arr = [1, 4, 2, 10, 2, 3, 1, 0, 20] k = 3 print(max_sum_subarray(arr, k)) # 출력: 24 (3, 1, 0, 20 중 최대 합은 20+3+1=24) 위 코드에서 시간 복잡도는 O(n).\n첫 번째 윈도우의 합을 계산하는 데 O(k) 시간이 소요되고, 이후 각 윈도우의 합을 O(1) 시간에 계산한다.\n가변 크기 윈도우 예제: 합이 S 이상인 최소 길이 부분 배열 다음은 합이 S 이상이 되는 최소 길이의 연속 부분 배열을 찾는 예제:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def min_length_subarray_with_sum(arr, S): n = len(arr) # 현재 윈도우의 합과 시작 인덱스 current_sum = 0 window_start = 0 # 최소 길이 (초기값은 무한대) min_length = float('inf') for window_end in range(n): # 현재 요소를 윈도우에 추가 current_sum += arr[window_end] # 현재 윈도우의 합이 S 이상이면, 윈도우 크기를 줄여봄 while current_sum \u003e= S and window_start \u003c= window_end: # 현재 윈도우 길이 계산 및 최소 길이 업데이트 window_length = window_end - window_start + 1 min_length = min(min_length, window_length) # 왼쪽 요소 제거 및 시작 인덱스 이동 current_sum -= arr[window_start] window_start += 1 # 합이 S 이상인 부분 배열이 없는 경우 if min_length == float('inf'): return 0 return min_length # 예시 arr = [2, 3, 1, 2, 4, 3] S = 7 print(min_length_subarray_with_sum(arr, S)) # 출력: 2 (부분 배열 [4, 3]의 길이) 이 알고리즘의 시간 복잡도도 O(n).\n각 요소는 최대 두 번씩만 처리된다 (한 번은 window_end로, 한 번은 window_start로).\n슬라이딩 윈도우 기법의 응용 사례 슬라이딩 윈도우 기법은 다음과 같은 다양한 문제에 적용할 수 있다:\n문자열 처리 문제\n가장 긴 중복 없는 부분 문자열 찾기 특정 문자들을 모두 포함하는 최소 윈도우 부분 문자열 찾기 아나그램 패턴 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def longest_substring_without_repeating_chars(s): char_set = set() # 현재 윈도우의 문자 집합 max_length = 0 window_start = 0 for window_end in range(len(s)): current_char = s[window_end] # 중복 문자가 발견되면 윈도우 시작점 이동 while current_char in char_set: char_set.remove(s[window_start]) window_start += 1 # 현재 문자를 집합에 추가 char_set.add(current_char) # 현재 윈도우 길이 계산 및 최대 길이 업데이트 window_length = window_end - window_start + 1 max_length = max(max_length, window_length) return max_length # 예시 s = \"abcabcbb\" print(longest_substring_without_repeating_chars(s)) # 출력: 3 (\"abc\") 배열 처리 문제\nK개 요소의 최대/최소 합 합이 특정 값이 되는 부분 배열 찾기 최대 평균 부분 배열 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def find_max_average_subarray(arr, k): n = len(arr) # 첫 번째 윈도우의 합 계산 window_sum = sum(arr[:k]) max_sum = window_sum # 윈도우 슬라이딩 for i in range(k, n): window_sum = window_sum + arr[i] - arr[i - k] max_sum = max(max_sum, window_sum) # 평균 반환 return max_sum / k # 예시 arr = [1, 12, -5, -6, 50, 3] k = 4 print(find_max_average_subarray(arr, k)) # 출력: 12.75 데이터 스트림 처리\n이동 평균 (Moving Average) 계산 실시간 데이터 분석 및 이상치 탐지 네트워크 패킷 모니터링 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MovingAverage: def __init__(self, size): self.size = size self.queue = [] self.window_sum = 0 def next(self, val): # 윈도우가 가득 찼으면 가장 오래된 요소 제거 if len(self.queue) == self.size: self.window_sum -= self.queue.pop(0) # 새 요소 추가 self.queue.append(val) self.window_sum += val # 현재 평균 반환 return self.window_sum / len(self.queue) # 예시 mavg = MovingAverage(3) print(mavg.next(1)) # 출력: 1.0 print(mavg.next(10)) # 출력: 5.5 print(mavg.next(3)) # 출력: 4.66… print(mavg.next(5)) # 출력: 6.0 (1이 제거되고 5가 추가됨) 슬라이딩 윈도우 기법의 장단점 장점 효율성: O(n²)의 시간 복잡도를 O(n)으로 줄일 수 있다. 메모리 효율성: 추가 메모리 사용이 최소화된다. 알고리즘 단순화: 복잡한 문제를 간단한 단계로 나눌 수 있다. 증분 계산: 이전 계산 결과를 재사용하여 효율성을 높인다. 단점 적용 제한: 모든 문제에 적용할 수 있는 것은 아니다. 주로 선형 데이터 구조와 관련된 문제에 적합하다. 구현 복잡성: 특히 가변 크기 윈도우는 구현이 복잡할 수 있다. 윈도우 경계 처리: 윈도우의 시작과 끝 부분 처리에 주의가 필요하다. 슬라이딩 윈도우 기법 활용을 위한 팁 문제 유형 파악: 연속된 부분 집합이나 부분 배열을 다루는 문제인지 확인한다. 고정/가변 윈도우 결정: 문제의 조건에 따라 적절한 윈도우 유형을 선택한다. 윈도우 상태 추적: 윈도우의 현재 상태를 효율적으로 추적할 방법을 고민한다. 증분 계산 최적화: 윈도우 이동 시 전체를 다시 계산하지 않고 증분만 계산한다. 경계 조건 처리: 배열의 시작과 끝 부분, 그리고 윈도우 크기가 배열 크기보다 큰 경우 등의 경계 조건을 신중하게 처리한다. 복잡한 슬라이딩 윈도우 문제와 해법 최소 윈도우 부분 문자열 (Minimum Window Substring) 문제: 문자열 S와 문자열 T가 주어졌을 때, S에서 T의 모든 문자를 포함하는 최소 길이의 부분 문자열을 찾는다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from collections import Counter def min_window_substring(s, t): if not s or not t: return \"\" # t의 문자 빈도수 계산 target_counter = Counter(t) required = len(target_counter) # 윈도우 변수 초기화 window_start = 0 formed = 0 # 만족된 고유 문자 수 window_counts = {} # 현재 윈도우의 문자 빈도수 # 결과 변수 (윈도우 길이, 왼쪽 경계, 오른쪽 경계) result = float('inf'), 0, 0 # 윈도우 확장 for window_end in range(len(s)): # 현재 문자를 윈도우에 추가 char = s[window_end] window_counts[char] = window_counts.get(char, 0) + 1 # 현재 문자가 목표에 있고, 빈도수가 일치하면 형성된 문자 수 증가 if char in target_counter and window_counts[char] == target_counter[char]: formed += 1 # 모든 필요 문자가 포함되었으면 윈도우 축소 시도 while window_start \u003c= window_end and formed == required: char = s[window_start] # 현재 윈도우가 더 작으면 결과 업데이트 if window_end - window_start + 1 \u003c result[0]: result = (window_end - window_start + 1, window_start, window_end) # 왼쪽 문자 제거 및 윈도우 시작점 이동 window_counts[char] -= 1 if char in target_counter and window_counts[char] \u003c target_counter[char]: formed -= 1 window_start += 1 # 결과 반환 if result[0] == float('inf'): return \"\" return s[result[1]:result[2] + 1] # 예시 s = \"ADOBECODEBANC\" t = \"ABC\" print(min_window_substring(s, t)) # 출력: \"BANC\" 최대 연속 1의 개수 III (Max Consecutive Ones III) 문제: 0과 1로 이루어진 배열이 주어지고, 최대 k개의 0을 1로 바꿀 수 있을 때, 연속된 1의 최대 개수를 찾는다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def longest_ones(nums, k): window_start = 0 max_consecutive_ones = 0 max_zeros_flipped = 0 # 현재 윈도우에서 1로 바꾼 0의 개수 for window_end in range(len(nums)): # 현재 요소가 0이면 플립 카운트 증가 if nums[window_end] == 0: max_zeros_flipped += 1 # 허용된 플립 횟수를 초과하면 윈도우 축소 while max_zeros_flipped \u003e k: if nums[window_start] == 0: max_zeros_flipped -= 1 window_start += 1 # 현재 윈도우 길이 계산 및 최대값 업데이트 max_consecutive_ones = max(max_consecutive_ones, window_end - window_start + 1) return max_consecutive_ones # 예시 nums = [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0] k = 2 print(longest_ones(nums, k)) # 출력: 6 실전 문제 해결 전략 슬라이딩 윈도우 기법을 효과적으로 활용하기 위한 문제 해결 전략:\n문제 분석: 문제가 연속된 요소의 부분집합을 처리하는가? 연속된 k개 요소를 처리하는 경우 → 고정 크기 윈도우 특정 조건을 만족하는 부분 배열을 찾는 경우 → 가변 크기 윈도우 윈도우 상태 정의: 윈도우 내부 상태를 어떻게 표현할 것인가? 합, 평균, 최대값, 최소값 문자 빈도수, 고유 문자 수 조건 충족 여부 상태 업데이트 전략: 윈도우 이동 시 상태를 어떻게 효율적으로 업데이트할 것인가? 이전 윈도우 → 현재 윈도우로 변경 시 O(1) 시간에 업데이트 방법 고민 제거되는 요소와 추가되는 요소의 영향 계산 결과 업데이트 조건: 어떤 조건에서 최종 결과를 업데이트할 것인가? 최대값/최소값 업데이트 조건 특정 조건 충족 시 결과 기록 참고 및 출처 ","wordCount":"1733","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-24T00:21:00Z","dateModified":"2025-01-24T00:21:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a></div><h1 class="post-title entry-hint-parent">슬라이딩 윈도우 기법 (Sliding Window Technique)</h1><div class=post-description>슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 "슬라이딩"하면서 문제를 해결한다.</div><div class=post-meta><span title='2025-01-24 00:21:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Basic%20Techniques/sliding-window-technique.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#슬라이딩-윈도우-기법-sliding-window-technique>슬라이딩 윈도우 기법 (Sliding Window Technique)</a><ul><li><a href=#슬라이딩-윈도우의-기본-개념>슬라이딩 윈도우의 기본 개념</a></li><li><a href=#슬라이딩-윈도우의-유형>슬라이딩 윈도우의 유형</a></li><li><a href=#슬라이딩-윈도우-알고리즘의-단계>슬라이딩 윈도우 알고리즘의 단계</a></li><li><a href=#슬라이딩-윈도우-구현-예제>슬라이딩 윈도우 구현 예제</a></li><li><a href=#슬라이딩-윈도우-기법의-응용-사례>슬라이딩 윈도우 기법의 응용 사례</a></li><li><a href=#슬라이딩-윈도우-기법의-장단점>슬라이딩 윈도우 기법의 장단점</a></li><li><a href=#슬라이딩-윈도우-기법-활용을-위한-팁>슬라이딩 윈도우 기법 활용을 위한 팁</a></li><li><a href=#복잡한-슬라이딩-윈도우-문제와-해법>복잡한 슬라이딩 윈도우 문제와 해법</a></li><li><a href=#실전-문제-해결-전략>실전 문제 해결 전략</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=슬라이딩-윈도우-기법-sliding-window-technique>슬라이딩 윈도우 기법 (Sliding Window Technique)<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-기법-sliding-window-technique>#</a></h2><p>슬라이딩 윈도우 기법은 배열이나 문자열과 같은 선형 데이터 구조에서 특정 범위의 요소들을 효율적으로 처리하기 위한 알고리즘 패러다임.<br>이 기법은 &ldquo;창문(window)&ldquo;처럼 움직이는 부분 배열을 이용하여 시간 복잡도를 획기적으로 개선할 수 있는 강력한 문제 해결 방법이다.</p><p>슬라이딩 윈도우 기법은 선형 데이터 구조에서 연속된 요소들을 효율적으로 처리하기 위한 강력한 알고리즘 패러다임으로 이 기법을 이해하고 적용하면 중첩 반복문을 사용하는 시간 복잡도를 O(n²)에서 O(n)으로 줄일 수 있어, 성능 개선에 크게 기여할 수 있다.</p><p>슬라이딩 윈도우 기법은 문자열 처리, 배열 연산, 데이터 스트림 처리 등 다양한 분야에서 활용된다.<br>특히 고정 크기 윈도우와 가변 크기 윈도우 두 가지 유형을 이해하고 상황에 맞게 적용하면, 복잡한 문제도 효율적으로 해결할 수 있다.</p><p>이 기법을 마스터하기 위해서는 다양한 문제를 해결하며 경험을 쌓고, 윈도우 상태 관리와 효율적인 업데이트 방법에 대한 이해를 깊게 하는 것이 중요하다.</p><h3 id=슬라이딩-윈도우의-기본-개념>슬라이딩 윈도우의 기본 개념<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우의-기본-개념>#</a></h3><p>슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 &ldquo;슬라이딩"하면서 문제를 해결한다. 이 과정에서 중요한 점은 윈도우가 이동할 때마다 모든 요소를 다시 계산하지 않고, 새로 추가되는 요소와 제거되는 요소만 고려하여 결과를 업데이트한다는 것이다.</p><p>슬라이딩 윈도우 기법을 사용하면 중첩된 반복문을 사용하는 대신 단일 반복문으로 문제를 해결할 수 있어, O(n²)의 시간 복잡도를 O(n)으로 줄일 수 있다.</p><h3 id=슬라이딩-윈도우의-유형>슬라이딩 윈도우의 유형<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우의-유형>#</a></h3><p>슬라이딩 윈도우 기법은 크게 두 가지 유형으로 나눌 수 있다:</p><h4 id=고정-크기-윈도우-fixed-size-window>고정 크기 윈도우 (Fixed Size Window)<a hidden class=anchor aria-hidden=true href=#고정-크기-윈도우-fixed-size-window>#</a></h4><p>윈도우의 크기가 처음부터 끝까지 일정하게 유지된다.<br>예를 들어, &ldquo;배열에서 연속된 k개 요소의 최대 합 찾기"와 같은 문제에 적용된다.</p><h4 id=가변-크기-윈도우-variable-size-window>가변 크기 윈도우 (Variable Size Window)<a hidden class=anchor aria-hidden=true href=#가변-크기-윈도우-variable-size-window>#</a></h4><p>윈도우의 크기가 문제의 조건에 따라 동적으로 변경된다.<br>예를 들어, &ldquo;합이 S 이상이 되는 최소 길이의 연속 부분 배열 찾기"와 같은 문제에 적용된다.</p><h3 id=슬라이딩-윈도우-알고리즘의-단계>슬라이딩 윈도우 알고리즘의 단계<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-알고리즘의-단계>#</a></h3><p>일반적인 슬라이딩 윈도우 알고리즘은 다음과 같은 단계로 구성된다:</p><ol><li><strong>윈도우 정의</strong>: 처리할 데이터의 범위를 나타내는 윈도우를 정의한다.</li><li><strong>윈도우 초기화</strong>: 윈도우의 첫 위치를 설정하고 초기 계산을 수행한다.</li><li><strong>윈도우 이동</strong>: 윈도우를 한 칸씩 이동하면서 다음을 반복한다:<ul><li>윈도우에서 빠져나가는 요소 처리 (왼쪽에서 제거)</li><li>윈도우로 새로 들어오는 요소 처리 (오른쪽에 추가)</li><li>현재 윈도우 상태에 따른 결과 업데이트</li></ul></li><li><strong>최종 결과 반환</strong>: 모든 윈도우 위치를 확인한 후 최종 결과를 반환한다.</li></ol><h3 id=슬라이딩-윈도우-구현-예제>슬라이딩 윈도우 구현 예제<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-구현-예제>#</a></h3><h4 id=고정-크기-윈도우-예제-최대-부분-배열-합>고정 크기 윈도우 예제: 최대 부분 배열 합<a hidden class=anchor aria-hidden=true href=#고정-크기-윈도우-예제-최대-부분-배열-합>#</a></h4><p>다음은 크기가 k인 연속 부분 배열의 최대 합을 찾는 예제:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_sum_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 입력 검증</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;배열 크기가 윈도우 크기보다 작습니다&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 윈도우의 합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>window_sum</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>max_sum</span> <span class=o>=</span> <span class=n>window_sum</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 윈도우 슬라이딩</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 새 요소 추가, 이전 요소 제거</span>
</span></span><span class=line><span class=cl>        <span class=n>window_sum</span> <span class=o>=</span> <span class=n>window_sum</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 최대값 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=n>max_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_sum</span><span class=p>,</span> <span class=n>window_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_sum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>20</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>max_sum_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>))</span>  <span class=c1># 출력: 24 (3, 1, 0, 20 중 최대 합은 20+3+1=24)</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드에서 시간 복잡도는 O(n).<br>첫 번째 윈도우의 합을 계산하는 데 O(k) 시간이 소요되고, 이후 각 윈도우의 합을 O(1) 시간에 계산한다.</p><h4 id=가변-크기-윈도우-예제-합이-s-이상인-최소-길이-부분-배열>가변 크기 윈도우 예제: 합이 S 이상인 최소 길이 부분 배열<a hidden class=anchor aria-hidden=true href=#가변-크기-윈도우-예제-합이-s-이상인-최소-길이-부분-배열>#</a></h4><p>다음은 합이 S 이상이 되는 최소 길이의 연속 부분 배열을 찾는 예제:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_length_subarray_with_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>S</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 현재 윈도우의 합과 시작 인덱스</span>
</span></span><span class=line><span class=cl>    <span class=n>current_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>window_start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최소 길이 (초기값은 무한대)</span>
</span></span><span class=line><span class=cl>    <span class=n>min_length</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>window_end</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 요소를 윈도우에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>current_sum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>window_end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 윈도우의 합이 S 이상이면, 윈도우 크기를 줄여봄</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current_sum</span> <span class=o>&gt;=</span> <span class=n>S</span> <span class=ow>and</span> <span class=n>window_start</span> <span class=o>&lt;=</span> <span class=n>window_end</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재 윈도우 길이 계산 및 최소 길이 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=n>window_length</span> <span class=o>=</span> <span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>min_length</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_length</span><span class=p>,</span> <span class=n>window_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 왼쪽 요소 제거 및 시작 인덱스 이동</span>
</span></span><span class=line><span class=cl>            <span class=n>current_sum</span> <span class=o>-=</span> <span class=n>arr</span><span class=p>[</span><span class=n>window_start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>window_start</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 합이 S 이상인 부분 배열이 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>min_length</span> <span class=o>==</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_length</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>S</span> <span class=o>=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>min_length_subarray_with_sum</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>S</span><span class=p>))</span>  <span class=c1># 출력: 2 (부분 배열 [4, 3]의 길이)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘의 시간 복잡도도 O(n).<br>각 요소는 최대 두 번씩만 처리된다 (한 번은 window_end로, 한 번은 window_start로).</p><h3 id=슬라이딩-윈도우-기법의-응용-사례>슬라이딩 윈도우 기법의 응용 사례<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-기법의-응용-사례>#</a></h3><p>슬라이딩 윈도우 기법은 다음과 같은 다양한 문제에 적용할 수 있다:</p><ol><li><p>문자열 처리 문제</p><ul><li>가장 긴 중복 없는 부분 문자열 찾기</li><li>특정 문자들을 모두 포함하는 최소 윈도우 부분 문자열 찾기</li><li>아나그램 패턴 찾기</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_substring_without_repeating_chars</span><span class=p>(</span><span class=n>s</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>char_set</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>  <span class=c1># 현재 윈도우의 문자 집합</span>
</span></span><span class=line><span class=cl>    <span class=n>max_length</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>window_start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>window_end</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>current_char</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>window_end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 중복 문자가 발견되면 윈도우 시작점 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current_char</span> <span class=ow>in</span> <span class=n>char_set</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>char_set</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>window_start</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>window_start</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 문자를 집합에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>char_set</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>current_char</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 윈도우 길이 계산 및 최대 길이 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=n>window_length</span> <span class=o>=</span> <span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>max_length</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_length</span><span class=p>,</span> <span class=n>window_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_length</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=s2>&#34;abcabcbb&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>longest_substring_without_repeating_chars</span><span class=p>(</span><span class=n>s</span><span class=p>))</span>  <span class=c1># 출력: 3 (&#34;abc&#34;)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>배열 처리 문제</p><ul><li>K개 요소의 최대/최소 합</li><li>합이 특정 값이 되는 부분 배열 찾기</li><li>최대 평균 부분 배열 찾기</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_max_average_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 윈도우의 합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>window_sum</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>max_sum</span> <span class=o>=</span> <span class=n>window_sum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 윈도우 슬라이딩</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>window_sum</span> <span class=o>=</span> <span class=n>window_sum</span> <span class=o>+</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>max_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_sum</span><span class=p>,</span> <span class=n>window_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 평균 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_sum</span> <span class=o>/</span> <span class=n>k</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=o>-</span><span class=mi>5</span><span class=p>,</span> <span class=o>-</span><span class=mi>6</span><span class=p>,</span> <span class=mi>50</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>find_max_average_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>))</span>  <span class=c1># 출력: 12.75</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>데이터 스트림 처리</p><ul><li>이동 평균 (Moving Average) 계산</li><li>실시간 데이터 분석 및 이상치 탐지</li><li>네트워크 패킷 모니터링</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>MovingAverage</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>queue</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>window_sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>next</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 윈도우가 가득 찼으면 가장 오래된 요소 제거</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>)</span> <span class=o>==</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>window_sum</span> <span class=o>-=</span> <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 새 요소 추가</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>window_sum</span> <span class=o>+=</span> <span class=n>val</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 평균 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>window_sum</span> <span class=o>/</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>mavg</span> <span class=o>=</span> <span class=n>MovingAverage</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>mavg</span><span class=o>.</span><span class=n>next</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>  <span class=c1># 출력: 1.0</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>mavg</span><span class=o>.</span><span class=n>next</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># 출력: 5.5</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>mavg</span><span class=o>.</span><span class=n>next</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>  <span class=c1># 출력: 4.66…</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>mavg</span><span class=o>.</span><span class=n>next</span><span class=p>(</span><span class=mi>5</span><span class=p>))</span>  <span class=c1># 출력: 6.0 (1이 제거되고 5가 추가됨)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=슬라이딩-윈도우-기법의-장단점>슬라이딩 윈도우 기법의 장단점<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-기법의-장단점>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ul><li><strong>효율성</strong>: O(n²)의 시간 복잡도를 O(n)으로 줄일 수 있다.</li><li><strong>메모리 효율성</strong>: 추가 메모리 사용이 최소화된다.</li><li><strong>알고리즘 단순화</strong>: 복잡한 문제를 간단한 단계로 나눌 수 있다.</li><li><strong>증분 계산</strong>: 이전 계산 결과를 재사용하여 효율성을 높인다.</li></ul><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li><strong>적용 제한</strong>: 모든 문제에 적용할 수 있는 것은 아니다. 주로 선형 데이터 구조와 관련된 문제에 적합하다.</li><li><strong>구현 복잡성</strong>: 특히 가변 크기 윈도우는 구현이 복잡할 수 있다.</li><li><strong>윈도우 경계 처리</strong>: 윈도우의 시작과 끝 부분 처리에 주의가 필요하다.</li></ul><h3 id=슬라이딩-윈도우-기법-활용을-위한-팁>슬라이딩 윈도우 기법 활용을 위한 팁<a hidden class=anchor aria-hidden=true href=#슬라이딩-윈도우-기법-활용을-위한-팁>#</a></h3><ol><li><strong>문제 유형 파악</strong>: 연속된 부분 집합이나 부분 배열을 다루는 문제인지 확인한다.</li><li><strong>고정/가변 윈도우 결정</strong>: 문제의 조건에 따라 적절한 윈도우 유형을 선택한다.</li><li><strong>윈도우 상태 추적</strong>: 윈도우의 현재 상태를 효율적으로 추적할 방법을 고민한다.</li><li><strong>증분 계산 최적화</strong>: 윈도우 이동 시 전체를 다시 계산하지 않고 증분만 계산한다.</li><li><strong>경계 조건 처리</strong>: 배열의 시작과 끝 부분, 그리고 윈도우 크기가 배열 크기보다 큰 경우 등의 경계 조건을 신중하게 처리한다.</li></ol><h3 id=복잡한-슬라이딩-윈도우-문제와-해법>복잡한 슬라이딩 윈도우 문제와 해법<a hidden class=anchor aria-hidden=true href=#복잡한-슬라이딩-윈도우-문제와-해법>#</a></h3><h4 id=최소-윈도우-부분-문자열-minimum-window-substring>최소 윈도우 부분 문자열 (Minimum Window Substring)<a hidden class=anchor aria-hidden=true href=#최소-윈도우-부분-문자열-minimum-window-substring>#</a></h4><p>문제: 문자열 S와 문자열 T가 주어졌을 때, S에서 T의 모든 문자를 포함하는 최소 길이의 부분 문자열을 찾는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span><span class=lnt id=hl-5-33><a class=lnlinks href=#hl-5-33>33</a>
</span><span class=lnt id=hl-5-34><a class=lnlinks href=#hl-5-34>34</a>
</span><span class=lnt id=hl-5-35><a class=lnlinks href=#hl-5-35>35</a>
</span><span class=lnt id=hl-5-36><a class=lnlinks href=#hl-5-36>36</a>
</span><span class=lnt id=hl-5-37><a class=lnlinks href=#hl-5-37>37</a>
</span><span class=lnt id=hl-5-38><a class=lnlinks href=#hl-5-38>38</a>
</span><span class=lnt id=hl-5-39><a class=lnlinks href=#hl-5-39>39</a>
</span><span class=lnt id=hl-5-40><a class=lnlinks href=#hl-5-40>40</a>
</span><span class=lnt id=hl-5-41><a class=lnlinks href=#hl-5-41>41</a>
</span><span class=lnt id=hl-5-42><a class=lnlinks href=#hl-5-42>42</a>
</span><span class=lnt id=hl-5-43><a class=lnlinks href=#hl-5-43>43</a>
</span><span class=lnt id=hl-5-44><a class=lnlinks href=#hl-5-44>44</a>
</span><span class=lnt id=hl-5-45><a class=lnlinks href=#hl-5-45>45</a>
</span><span class=lnt id=hl-5-46><a class=lnlinks href=#hl-5-46>46</a>
</span><span class=lnt id=hl-5-47><a class=lnlinks href=#hl-5-47>47</a>
</span><span class=lnt id=hl-5-48><a class=lnlinks href=#hl-5-48>48</a>
</span><span class=lnt id=hl-5-49><a class=lnlinks href=#hl-5-49>49</a>
</span><span class=lnt id=hl-5-50><a class=lnlinks href=#hl-5-50>50</a>
</span><span class=lnt id=hl-5-51><a class=lnlinks href=#hl-5-51>51</a>
</span><span class=lnt id=hl-5-52><a class=lnlinks href=#hl-5-52>52</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>Counter</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_window_substring</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>t</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>s</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>t</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># t의 문자 빈도수 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>target_counter</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>required</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>target_counter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 윈도우 변수 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>window_start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>formed</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 만족된 고유 문자 수</span>
</span></span><span class=line><span class=cl>    <span class=n>window_counts</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 현재 윈도우의 문자 빈도수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 변수 (윈도우 길이, 왼쪽 경계, 오른쪽 경계)</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 윈도우 확장</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>window_end</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 문자를 윈도우에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>char</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>window_end</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>=</span> <span class=n>window_counts</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>char</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 문자가 목표에 있고, 빈도수가 일치하면 형성된 문자 수 증가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>char</span> <span class=ow>in</span> <span class=n>target_counter</span> <span class=ow>and</span> <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>==</span> <span class=n>target_counter</span><span class=p>[</span><span class=n>char</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>formed</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 필요 문자가 포함되었으면 윈도우 축소 시도</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>window_start</span> <span class=o>&lt;=</span> <span class=n>window_end</span> <span class=ow>and</span> <span class=n>formed</span> <span class=o>==</span> <span class=n>required</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>char</span> <span class=o>=</span> <span class=n>s</span><span class=p>[</span><span class=n>window_start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 현재 윈도우가 더 작으면 결과 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=p>(</span><span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>window_start</span><span class=p>,</span> <span class=n>window_end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 왼쪽 문자 제거 및 윈도우 시작점 이동</span>
</span></span><span class=line><span class=cl>            <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>char</span> <span class=ow>in</span> <span class=n>target_counter</span> <span class=ow>and</span> <span class=n>window_counts</span><span class=p>[</span><span class=n>char</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target_counter</span><span class=p>[</span><span class=n>char</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>formed</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>window_start</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>[</span><span class=n>result</span><span class=p>[</span><span class=mi>1</span><span class=p>]:</span><span class=n>result</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=s2>&#34;ADOBECODEBANC&#34;</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=s2>&#34;ABC&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>min_window_substring</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>t</span><span class=p>))</span>  <span class=c1># 출력: &#34;BANC&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최대-연속-1의-개수-iii-max-consecutive-ones-iii>최대 연속 1의 개수 III (Max Consecutive Ones III)<a hidden class=anchor aria-hidden=true href=#최대-연속-1의-개수-iii-max-consecutive-ones-iii>#</a></h4><p>문제: 0과 1로 이루어진 배열이 주어지고, 최대 k개의 0을 1로 바꿀 수 있을 때, 연속된 1의 최대 개수를 찾는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>longest_ones</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>window_start</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>max_consecutive_ones</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>max_zeros_flipped</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 현재 윈도우에서 1로 바꾼 0의 개수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>window_end</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 요소가 0이면 플립 카운트 증가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>window_end</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>max_zeros_flipped</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 허용된 플립 횟수를 초과하면 윈도우 축소</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>max_zeros_flipped</span> <span class=o>&gt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>window_start</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_zeros_flipped</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>window_start</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 윈도우 길이 계산 및 최대값 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=n>max_consecutive_ones</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_consecutive_ones</span><span class=p>,</span> <span class=n>window_end</span> <span class=o>-</span> <span class=n>window_start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_consecutive_ones</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시</span>
</span></span><span class=line><span class=cl><span class=n>nums</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>k</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>longest_ones</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>k</span><span class=p>))</span>  <span class=c1># 출력: 6</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실전-문제-해결-전략>실전 문제 해결 전략<a hidden class=anchor aria-hidden=true href=#실전-문제-해결-전략>#</a></h3><p>슬라이딩 윈도우 기법을 효과적으로 활용하기 위한 문제 해결 전략:</p><ol><li><strong>문제 분석</strong>: 문제가 연속된 요소의 부분집합을 처리하는가?<ul><li>연속된 k개 요소를 처리하는 경우 → 고정 크기 윈도우</li><li>특정 조건을 만족하는 부분 배열을 찾는 경우 → 가변 크기 윈도우</li></ul></li><li><strong>윈도우 상태 정의</strong>: 윈도우 내부 상태를 어떻게 표현할 것인가?<ul><li>합, 평균, 최대값, 최소값</li><li>문자 빈도수, 고유 문자 수</li><li>조건 충족 여부</li></ul></li><li><strong>상태 업데이트 전략</strong>: 윈도우 이동 시 상태를 어떻게 효율적으로 업데이트할 것인가?<ul><li>이전 윈도우 → 현재 윈도우로 변경 시 O(1) 시간에 업데이트 방법 고민</li><li>제거되는 요소와 추가되는 요소의 영향 계산</li></ul></li><li><strong>결과 업데이트 조건</strong>: 어떤 조건에서 최종 결과를 업데이트할 것인가?<ul><li>최대값/최소값 업데이트 조건</li><li>특정 조건 충족 시 결과 기록</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/sliding-window-technique/>Sliding-Window-Technique</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/programming-paradigms/object-oriented-programming/interface-vs-abstract-class/><span class=title>« Prev</span><br><span>Interface vs Abstract class</span>
</a><a class=next href=https://buenhyden.github.io/posts/systems-and-infrastructure/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/><span class=title>Next »</span><br><span>Process vs Thread vs Coroutine</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>