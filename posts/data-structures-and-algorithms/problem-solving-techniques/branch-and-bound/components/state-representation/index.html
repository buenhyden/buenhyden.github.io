<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>State Representation | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Branch-and-Bound,Components,State-Representation"><meta name=description content="상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="State Representation"><meta property="og:description" content="상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-21T14:15:00+00:00"><meta property="article:modified_time" content="2025-01-21T14:15:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Branch-and-Bound"><meta property="article:tag" content="Components"><meta property="article:tag" content="State-Representation"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="State Representation"><meta name=twitter:description content="상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"분기 한정법 (Branch and Bound)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/"},{"@type":"ListItem","position":5,"name":"Components of Branch and Bound","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/"},{"@type":"ListItem","position":6,"name":"State Representation","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"State Representation","name":"State Representation","description":"상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Branch-and-Bound","Components","State-Representation"],"articleBody":"상태 표현(State Representation) 상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.\nBranch and Bound 알고리즘에서 상태 표현은 다음과 같은 중요한 역할을 한다:\n문제 공간 표현: 가능한 모든 해결책(solution space)을 체계적으로 표현한다. 탐색 진행 상황 추적: 알고리즘이 문제 공간을 탐색하는 과정에서 현재 위치를 나타낸다. 한계값(bound) 계산 지원: 각 상태에서 가능한 최적값의 상한 또는 하한을 계산할 수 있게 한다. 가지치기(pruning) 결정 기반: 더 이상 탐색할 가치가 없는 상태를 식별하는 데 사용된다. 상태 표현의 주요 특성 및 고려 사항 상태 표현의 완전성(Completeness)\n상태 표현은 문제의 모든 가능한 해결책을 표현할 수 있어야 한다.\n불완전한 상태 표현은 최적해를 놓치게 할 수 있다.\n상태 표현의 간결성(Conciseness)\n효율적인 상태 표현은 불필요한 정보를 제외하고 필수적인 정보만 포함해야 한다.\n상태의 크기가 크면 메모리 사용량이 증가하고 알고리즘의 성능이 저하될 수 있다.\n상태 전이의 효율성(Transition Efficiency)\n한 상태에서 다른 상태로의 전이가 효율적으로 계산될 수 있어야 한다.\n전이 연산이 복잡하면 알고리즘의 실행 시간이 증가한다.\n한계값 계산의 용이성(Bound Calculation)\n상태 표현은 해당 상태에서 가능한 최적값의 상한 또는 하한을 쉽게 계산할 수 있도록 설계되어야 한다.\n정확하고 효율적인 한계값 계산은 가지치기의 효과를 높인다.\n중복 상태 처리(Duplicate State Handling)\n일부 문제에서는 서로 다른 경로로 동일한 상태에 도달할 수 있다.\n효과적인 상태 표현은 이러한 중복을 식별하고 처리할 수 있어야 한다.\n효율적인 상태 표현을 위한 설계 지침 상태 표현 설계 단계 문제 분석: 문제의 특성과 제약조건을 명확히 이해한다. 필수 정보 식별: 문제 해결에 필요한 최소한의 정보를 식별한다. 표현 방식 선택: 문제 특성에 가장 적합한 상태 표현 방식을 선택한다. 한계값 함수 설계: 효율적이고 정확한 한계값 계산 방법을 설계한다. 상태 전이 함수 구현: 한 상태에서 다른 상태로의 전이를 효율적으로 구현한다. 중복 상태 처리 메커니즘 설계: 필요한 경우 중복 상태를 식별하고 처리하는 방법을 구현한다. 효율적인 상태 표현의 특성 최소성(Minimality): 필요한 정보만 포함하고 중복 정보는 제거한다. 구별성(Distinguishability): 서로 다른 해결책은 서로 다른 상태로 표현되어야 한다. 효율성(Efficiency): 상태 표현과 관련된 연산(생성, 전이, 비교 등)이 효율적이어야 한다. 계산 용이성(Computability): 한계값과 같은 중요한 메트릭을 쉽게 계산할 수 있어야 한다. 확장성(Scalability): 문제 크기가 커져도 효율적으로 처리할 수 있어야 한다. 상태 표현 최적화 기법 증분 계산(Incremental Computation): 상태 전이 시 전체를 다시 계산하는 대신 변경된 부분만 업데이트한다. 상태 압축(State Compression): 불필요한 정보를 제거하고 효율적인 자료구조를 사용한다. 해시 기반 중복 탐지(Hash-based Duplicate Detection): 해시 함수를 사용하여 중복 상태를 효율적으로 탐지한다. 지연 계산(Lazy Evaluation): 필요할 때만 계산을 수행하여 계산 비용을 줄인다. 메모이제이션(Memoization): 이전에 계산한 결과를 저장하여 재사용한다. 주요 상태 표현 방식 벡터 기반 상태 표현(Vector-based Representation) 벡터 기반 상태 표현은 여러 변수나 결정 사항을 벡터의 요소로 표현하는 방식.\n1 2 3 4 5 6 7 # 배낭 문제에서의 벡터 기반 상태 표현 예시 class State: def __init__(self, level, weight, value, items_included): self.level = level # 현재 결정 레벨 self.weight = weight # 현재까지의 무게 self.value = value # 현재까지의 가치 self.items_included = items_included.copy() # 포함된 항목 목록(0/1 벡터) 특징:\n직관적이고 구현이 상대적으로 간단. 각 차원이 의사 결정 변수에 해당. 상태 간 전환이 벡터 요소의 변경으로 표현. 예시: 배낭 문제(Knapsack Problem) 배낭 문제에서 각 물건의 포함 여부를 벡터로 표현할 수 있다.\n1 2 3 상태 표현: [x₁, x₂, x₃, …, xₙ] - xᵢ = 1: i번째 물건을 배낭에 포함 - xᵢ = 0: i번째 물건을 배낭에 포함하지 않음 시각화 1 2 3 4 5 6 [0,0,0,0] (초기 상태: 빈 배낭) / \\ [1,0,0,0] (물건1 포함) [0,0,0,0] (물건1 제외) / \\ / \\ [1,1,0,0] [1,0,0,0] [0,1,0,0] [0,0,0,0] (물건1,2 포함) (물건1만) (물건2만) (물건 없음) 이 표현에서 각 노드는 부분 해결책을 나타내며, 리프 노드는 가능한 완전한 해결책을 나타낸다.\n분기 과정에서 상한(bound)을 계산하여 유망하지 않은 노드를 가지치기한다.\n트리 기반 상태 표현(Tree-based Representation) 트리 기반 상태 표현은 결정 트리의 노드로 상태를 표현하며, 각 분기는 다른 결정 경로를 나타낸다.\n1 2 3 4 5 6 7 # 외판원 문제(TSP)에서의 트리 기반 상태 표현 예시 class TSPState: def __init__(self, path, cost, remaining_cities): self.path = path.copy() # 현재까지의 경로 self.cost = cost # 현재까지의 비용 self.remaining_cities = remaining_cities.copy() # 방문해야 할 도시 목록 self.lower_bound = self.calculate_bound() # 하한값 특징:\n계층적 구조로 문제의 분할을 자연스럽게 표현. 부모-자식 관계가 결정의 순서와 의존성을 명확히 보여준다. 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS) 등 다양한 트리 탐색 알고리즘을 적용할 수 있다. 예시: 외판원 문제(TSP) 1 2 상태 표현: (현재 도시, 방문한 도시 집합) 예: (3, {1, 2, 3})은 도시 1, 2를 방문한 후 현재 도시 3에 있음을 의미 시각화 1 2 3 4 5 6 7 (1, {1}) (시작 도시 1) / | \\ (2, {1,2}) (3, {1,3}) (4, {1,4}) / \\ / \\ / \\ (3, {1,2,3}) (4, {1,2,4}) … … … / \\ … … 각 노드는 현재까지의 경로와 방문한 도시들을 나타낸다. 여기서 분기는 다음에 방문할 수 있는 도시들에 대해 이루어지며, 각 경로의 하한(lower bound)을 계산하여 가지치기를 수행한다.\n비트마스크 기반 상태 표현(Bitmask-based Representation) 비트마스크 기반 상태 표현은 이진 비트열을 사용하여 선택/비선택 상태를 효율적으로 표현하는 방식.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 집합 커버링 문제에서의 비트마스크 기반 상태 표현 예시 def set_covering_branch_and_bound(universe, subsets, costs): n = len(subsets) # 상태 표현: (선택된 부분집합의 비트마스크, 커버된 원소의 비트마스크, 비용) initial_state = (0, 0, 0) # 아무것도 선택되지 않은 초기 상태 # 비트마스크를 이용한 집합 연산 def get_coverage(subset_mask): coverage = 0 for i in range(n): if (subset_mask \u0026 (1 \u003c\u003c i)) != 0: # i번째 부분집합이 선택된 경우 coverage |= subsets[i] # 비트 OR 연산으로 커버 업데이트 return coverage 특징:\n메모리 효율적인 표현이 가능(n개 항목을 n비트로 표현). 비트 연산을 통해 집합 연산(합집합, 교집합 등)을 빠르게 수행할 수 있다. 작은 크기의 문제(일반적으로 요소 수가 32개 또는 64개 이하)에 적합. 예시: 집합 커버 문제(Set Cover Problem) 1 2 상태 표현: 정수의 비트 표현 예: 13(10진수) = 1101(2진수)는 첫 번째, 세 번째, 네 번째 요소가 선택됨을 의미 시각화 1 2 3 4 5 6 7 8 9 0 (0000) / \\ 1 (0001) 0 (0000) / \\ / \\ 3 (0011) 1 (0001) 2 (0010) 0 (0000) / \\ 7 (0111) 3 (0011) / \\ 15 (1111) 7 (0111) 각 노드는 비트마스크로 표현된 상태를 나타내며, 1인 비트 위치의 요소가 선택된 상태이다.\n이 표현은 메모리 사용이 효율적이고 집합 연산(합집합, 교집합 등)이 비트 연산으로 빠르게 수행될 수 있다.\n행렬 기반 상태 표현(Matrix-based Representation) 행렬 기반 상태 표현은 2차원 이상의 배열을 사용하여 복잡한 관계와 제약조건을 표현하는 방식.\n1 2 3 4 5 6 # 작업 할당 문제에서의 행렬 기반 상태 표현 예시 class AssignmentState: def __init__(self, assignment_matrix, cost): self.matrix = assignment_matrix.copy() # 할당 행렬(0/1 값) self.cost = cost # 현재까지의 비용 self.next_person = self.find_next_unassigned() # 다음 할당할 사람 특징:\n2차원 이상의 관계를 표현하기에 적합. 행렬 연산을 활용하여 상태 전이나 한계값 계산이 가능. 할당 문제, 스케줄링 문제 등에 자주 사용. 예시: 8-퍼즐 문제(8-Puzzle Problem) 1 2 3 4 5 상태 표현: 3x3 행렬 예: 2 8 3 1 0 4 (0은 빈 공간) 7 6 5 시각화 1 2 3 4 5 6 7 8 9 10 11 12 13 ┌─────────┐ │ 2 8 3 │ 초기 상태 → │ 1 0 4 │ │ 7 6 5 │ └─────────┘ │ ┌─────────┴─────────┐ ↓ ↓ ┌─────────┐ ┌─────────┐ │ 2 8 3 │ │ 2 0 3 │ │ 0 1 4 │ │ 1 8 4 │ ← 가능한 다음 상태들 │ 7 6 5 │ │ 7 6 5 │ └─────────┘ └─────────┘ 각 노드는 퍼즐 보드의 상태를 나타내며, 분기는 빈 공간(0)과 인접한 숫자를 교환하여 생성된다.\n맨해튼 거리와 같은 휴리스틱을 사용하여 목표 상태까지의 하한을 계산한다.\n그래프 기반 상태 표현(Graph-based Representation) 그래프 기반 상태 표현은 노드와 엣지를 사용하여 상태와 상태 간의 전이를 표현하는 방식.\n1 2 3 4 5 6 # 최소 신장 트리 문제에서의 그래프 기반 상태 표현 예시 class MSTState: def __init__(self, selected_edges, total_weight, connected_components): self.selected_edges = selected_edges.copy() # 선택된 엣지 목록 self.total_weight = total_weight # 현재까지의 가중치 합 self.connected_components = connected_components.copy() # 연결 컴포넌트 정보 특징:\n그래프 구조를 가진 문제(최단 경로, 최소 신장 트리 등)에 자연스럽게 적용. 노드와 엣지의 관계를 명시적으로 표현할 수 있다. 그래프 알고리즘과 결합하여 효율적인 탐색이 가능. 예시: 최소 신장 트리(MST) 문제 1 2 상태 표현: (선택된 간선 집합, 연결된 노드 집합) 예: ({(1,2), (2,3)}, {1, 2, 3})은 간선 (1,2)와 (2,3)이 선택되어 노드 1, 2, 3이 연결됨을 의미 시각화 1 2 3 4 5 ({}, {}) (초기 상태: 간선 없음) / \\ ({(1,2)}, {1,2}) ({(1,3)}, {1,3}) / \\ / \\ ({(1,2),(2,3)},{1,2,3}) … … … 각 노드는 현재까지 선택된 간선과 연결된 노드의 집합을 나타낸다.\n분기는 새로 추가할 수 있는 간선에 대해 이루어지며, 최소 신장 트리의 비용에 대한 하한을 계산하여 가지치기를 수행한다.\n상태 표현 방식의 비교 특성 벡터 기반 트리 기반 비트마스크 기반 행렬 기반 그래프 기반 메모리 효율성 중간 낮음 높음 낮음 낮음 구현 복잡성 낮음 중간 중간 중간 높음 계산 효율성 중간 중간 높음 중간 중간 확장성 높음 높음 제한적 높음 높음 중복 상태 탐지 중간 어려움 쉬움 중간 어려움 상태 전이 용이성 높음 높음 높음 중간 중간 한계값 계산 적합성 높음 높음 중간 높음 높음 적합한 문제 유형 일반적인 최적화 문제 계층적 문제 부분집합 선택 문제 할당, 스케줄링 문제 경로, 네트워크 문제 최대 문제 크기 중간 중간~큼 작음~중간(≤64) 중간 중간~큼 병렬화 가능성 중간 높음 낮음 중간 높음 메모리 사용량 O(n) O(n) ~ O(n²) O(1) ~ O(log n) O(n²) O(n + e) 상태 표현 예시 [0,1,0,1,1] 경로 트리 10110 (비트열) 2차원 배열 노드와 엣지 장점 직관적, 유연함 계층 구조 표현에 적합 메모리 효율적, 빠른 연산 복잡한 관계 표현 가능 관계 표현에 자연스러움 단점 큰 문제에서 비효율적 메모리 사용량 많음 크기 제한, 구현 복잡 희소 행렬에서 비효율적 구현 복잡, 메모리 많이 사용 각 상태 표현 방식은 특정 문제 유형에 더 적합할 수 있다:\n벡터 기반: 선택/비선택 결정이 많은 문제 (배낭 문제, 자원 할당) 트리 기반: 계층적 의사결정이 필요한 문제 (게임 트리, 의사결정 트리) 비트마스크 기반: 이진 선택이 많고 집합 연산이 필요한 문제 (부분집합 문제) 행렬 기반: 공간적/지역적 관계가 중요한 문제 (퍼즐, 격자 기반 문제) 그래프 기반: 연결성과 네트워크 구조가 중요한 문제 (경로 찾기, 네트워크 설계) 적절한 상태 표현을 선택하면 문제 해결의 효율성을 크게 향상시킬 수 있으며, 이는 분기한정법을 적용할 때 특히 중요하다. 문제의 특성을 잘 파악하여 가장 적합한 상태 표현 방식을 선택하는 것이 알고리즘 설계의 핵심이다.\n다양한 문제에서의 상태 표현 적용 예시 배낭 문제(Knapsack Problem)의 상태 표현 배낭 문제는 제한된 무게 내에서 최대 가치를 가진 물건들을 선택하는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def knapsack_branch_and_bound(weights, values, capacity): n = len(weights) # 상태 정의: (레벨, 현재 무게, 현재 가치, 포함된 항목 목록) class State: def __init__(self, level, weight, value, includes): self.level = level # 결정 레벨(몇 번째 항목까지 고려했는지) self.weight = weight # 현재까지의 무게 self.value = value # 현재까지의 가치 self.includes = includes.copy() # 포함된 항목 목록(0/1 벡터) # 상한값 계산 self.bound = self.calculate_bound() def calculate_bound(self): if self.weight \u003e capacity: return 0 bound_value = self.value j = self.level total_weight = self.weight # 남은 항목들을 가치/무게 비율이 높은 순으로 최대한 추가 while j \u003c n and total_weight + weights[j] \u003c= capacity: total_weight += weights[j] bound_value += values[j] j += 1 # 마지막 항목은 분수로 추가(분할 가능 가정) if j \u003c n: bound_value += (capacity - total_weight) * (values[j] / weights[j]) return bound_value 이 상태 표현은 현재까지의 결정(어떤 항목을 포함했는지)과 그에 따른 무게와 가치를 추적한다.\n또한 남은 공간에 추가할 수 있는 최대 가치를 상한값으로 계산한다.\n외판원 문제(TSP)의 상태 표현 외판원 문제는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def tsp_branch_and_bound(distance_matrix): n = len(distance_matrix) # 상태 정의: (경로, 비용, 방문하지 않은 도시 목록) class State: def __init__(self, path, cost, unvisited): self.path = path.copy() # 현재까지의 경로 self.cost = cost # 현재까지의 비용 self.unvisited = unvisited.copy() # 방문하지 않은 도시 목록 # 하한값 계산 self.lower_bound = self.calculate_lower_bound() def calculate_lower_bound(self): # 현재까지의 비용 + 방문하지 않은 도시들의 최소 진입 비용 + 최소 탈출 비용 lb = self.cost # 각 미방문 도시의 최소 진입 비용 for city in self.unvisited: min_in = float('inf') for i in range(n): if i != city and (i in self.path or i in self.unvisited): min_in = min(min_in, distance_matrix[i][city]) lb += min_in # 각 미방문 도시의 최소 탈출 비용 for city in self.unvisited: min_out = float('inf') for i in range(n): if i != city and (i in self.path or i in self.unvisited): min_out = min(min_out, distance_matrix[city][i]) lb += min_out return lb / 2 # 각 비용이 두 번 계산되었으므로 2로 나눔 이 상태 표현은 현재까지의 경로, 비용, 그리고 아직 방문하지 않은 도시 목록을 포함한다.\n하한값은 현재까지의 비용과 미방문 도시들의 최소 진입/탈출 비용을 기반으로 계산된다.\n5.3 작업 할당 문제(Job Assignment Problem)의 상태 표현 작업 할당 문제는 n개의 작업을 n명의 작업자에게 최적으로 할당하는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def job_assignment_branch_and_bound(cost_matrix): n = len(cost_matrix) # 상태 정의: (할당된 작업자 목록, 총 비용) class State: def __init__(self, assignments, cost): self.assignments = assignments.copy() # 각 작업별 할당된 작업자(-1은 미할당) self.cost = cost # 현재까지의 총 비용 self.next_job = len([a for a in self.assignments if a != -1]) # 다음 할당할 작업 # 하한값 계산 self.lower_bound = self.calculate_lower_bound() def calculate_lower_bound(self): lb = self.cost # 각 미할당 작업에 대해 최소 비용을 추가 for job in range(self.next_job, n): # 이미 할당된 작업자를 제외한 최소 비용 찾기 min_cost = float('inf') for worker in range(n): if worker not in self.assignments: min_cost = min(min_cost, cost_matrix[job][worker]) lb += min_cost return lb 이 상태 표현은 각 작업별로 할당된 작업자와 현재까지의 총 비용을 추적한다.\n하한값은 현재까지의 비용과 미할당 작업의 최소 비용을 합산하여 계산한다.\n8. 실제 사례 연구: 15-퍼즐 문제의 상태 표현 15-퍼즐은 4x4 그리드에 1부터 15까지의 숫자와 한 개의 빈 칸이 있으며, 빈 칸을 이동하여 숫자를 정렬하는 퍼즐이다.\n이 문제에 대한 Branch and Bound 접근법과 상태 표현.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def solve_15_puzzle(initial_state): # 상태 표현: (보드 배열, 빈 칸 위치, 이동 횟수, 이전 이동 방향) class PuzzleState: def __init__(self, board, empty_pos, moves, prev_dir=None): self.board = board.copy() # 4x4 보드 배열 self.empty_pos = empty_pos # 빈 칸 위치 (row, col) self.moves = moves # 현재까지의 이동 횟수 self.prev_dir = prev_dir # 이전 이동 방향 # 휴리스틱 계산(맨해튼 거리) self.h = self.calculate_heuristic() # f(n) = g(n) + h(n) self.f = self.moves + self.h def calculate_heuristic(self): h = 0 for i in range(4): for j in range(4): if self.board[i][j] != 0: # 빈 칸이 아닌 경우 # 목표 위치 계산 val = self.board[i][j] goal_row, goal_col = (val - 1) // 4, (val - 1) % 4 # 맨해튼 거리 추가 h += abs(i - goal_row) + abs(j - goal_col) return h # 다음 가능한 상태 생성 def generate_next_states(self): next_states = [] row, col = self.empty_pos # 가능한 이동 방향: 상, 하, 좌, 우 directions = [(-1, 0, 'U'), (1, 0, 'D'), (0, -1, 'L'), (0, 1, 'R')] for dr, dc, dir_name in directions: new_row, new_col = row + dr, col + dc # 유효한 위치인지 확인 if 0 \u003c= new_row \u003c 4 and 0 \u003c= new_col \u003c 4: # 반대 방향으로 되돌아가는 것 방지 if (self.prev_dir == 'U' and dir_name == 'D') or \\ (self.prev_dir == 'D' and dir_name == 'U') or \\ (self.prev_dir == 'L' and dir_name == 'R') or \\ (self.prev_dir == 'R' and dir_name == 'L'): continue # 새 보드 상태 생성 new_board = self.board.copy() new_board[row][col] = new_board[new_row][new_col] new_board[new_row][new_col] = 0 # 새 상태 생성 next_state = PuzzleState(new_board, (new_row, new_col), self.moves + 1, dir_name) next_states.append(next_state) return next_states 이 예시에서 상태 표현은 다음 요소를 포함한다:\n보드 배열: 현재 퍼즐 상태를 나타내는 4x4 배열 빈 칸 위치: 빈 칸의 (행, 열) 좌표 이동 횟수: 현재까지 수행한 이동 횟수(g(n)) 이전 이동 방향: 중복 이동을 방지하기 위한 정보 또한 맨해튼 거리 휴리스틱을 사용하여 목표 상태까지의 최소 이동 횟수를 추정하고, 이를 한계값으로 사용한다.\n참고 및 출처 ","wordCount":"2611","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-01-21T14:15:00Z","dateModified":"2025-01-21T14:15:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/>분기 한정법 (Branch and Bound)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/>Components of Branch and Bound</a></div><h1 class="post-title entry-hint-parent">State Representation</h1><div class=post-description>상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.</div><div class=post-meta><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2611 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Branch%20and%20Bound/Components/state-representation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#상태-표현state-representation>상태 표현(State Representation)</a><ul><li><a href=#상태-표현의-주요-특성-및-고려-사항>상태 표현의 주요 특성 및 고려 사항</a></li><li><a href=#효율적인-상태-표현을-위한-설계-지침>효율적인 상태 표현을 위한 설계 지침</a></li><li><a href=#주요-상태-표현-방식>주요 상태 표현 방식</a></li><li><a href=#상태-표현-방식의-비교>상태 표현 방식의 비교</a></li><li><a href=#다양한-문제에서의-상태-표현-적용-예시>다양한 문제에서의 상태 표현 적용 예시</a></li><li><a href=#8-실제-사례-연구-15-퍼즐-문제의-상태-표현>8. 실제 사례 연구: 15-퍼즐 문제의 상태 표현</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=상태-표현state-representation>상태 표현(State Representation)<a hidden class=anchor aria-hidden=true href=#상태-표현state-representation>#</a></h2><p>상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.</p><p>Branch and Bound 알고리즘에서 상태 표현은 다음과 같은 중요한 역할을 한다:</p><ol><li><strong>문제 공간 표현</strong>: 가능한 모든 해결책(solution space)을 체계적으로 표현한다.</li><li><strong>탐색 진행 상황 추적</strong>: 알고리즘이 문제 공간을 탐색하는 과정에서 현재 위치를 나타낸다.</li><li><strong>한계값(bound) 계산 지원</strong>: 각 상태에서 가능한 최적값의 상한 또는 하한을 계산할 수 있게 한다.</li><li><strong>가지치기(pruning) 결정 기반</strong>: 더 이상 탐색할 가치가 없는 상태를 식별하는 데 사용된다.</li></ol><h3 id=상태-표현의-주요-특성-및-고려-사항>상태 표현의 주요 특성 및 고려 사항<a hidden class=anchor aria-hidden=true href=#상태-표현의-주요-특성-및-고려-사항>#</a></h3><ol><li><p>상태 표현의 완전성(Completeness)<br>상태 표현은 문제의 모든 가능한 해결책을 표현할 수 있어야 한다.<br>불완전한 상태 표현은 최적해를 놓치게 할 수 있다.</p></li><li><p>상태 표현의 간결성(Conciseness)<br>효율적인 상태 표현은 불필요한 정보를 제외하고 필수적인 정보만 포함해야 한다.<br>상태의 크기가 크면 메모리 사용량이 증가하고 알고리즘의 성능이 저하될 수 있다.</p></li><li><p>상태 전이의 효율성(Transition Efficiency)<br>한 상태에서 다른 상태로의 전이가 효율적으로 계산될 수 있어야 한다.<br>전이 연산이 복잡하면 알고리즘의 실행 시간이 증가한다.</p></li><li><p>한계값 계산의 용이성(Bound Calculation)<br>상태 표현은 해당 상태에서 가능한 최적값의 상한 또는 하한을 쉽게 계산할 수 있도록 설계되어야 한다.<br>정확하고 효율적인 한계값 계산은 가지치기의 효과를 높인다.</p></li><li><p>중복 상태 처리(Duplicate State Handling)<br>일부 문제에서는 서로 다른 경로로 동일한 상태에 도달할 수 있다.<br>효과적인 상태 표현은 이러한 중복을 식별하고 처리할 수 있어야 한다.</p></li></ol><h3 id=효율적인-상태-표현을-위한-설계-지침>효율적인 상태 표현을 위한 설계 지침<a hidden class=anchor aria-hidden=true href=#효율적인-상태-표현을-위한-설계-지침>#</a></h3><ol><li>상태 표현 설계 단계<ol><li><strong>문제 분석</strong>: 문제의 특성과 제약조건을 명확히 이해한다.</li><li><strong>필수 정보 식별</strong>: 문제 해결에 필요한 최소한의 정보를 식별한다.</li><li><strong>표현 방식 선택</strong>: 문제 특성에 가장 적합한 상태 표현 방식을 선택한다.</li><li><strong>한계값 함수 설계</strong>: 효율적이고 정확한 한계값 계산 방법을 설계한다.</li><li><strong>상태 전이 함수 구현</strong>: 한 상태에서 다른 상태로의 전이를 효율적으로 구현한다.</li><li><strong>중복 상태 처리 메커니즘 설계</strong>: 필요한 경우 중복 상태를 식별하고 처리하는 방법을 구현한다.</li></ol></li><li>효율적인 상태 표현의 특성<ol><li><strong>최소성(Minimality)</strong>: 필요한 정보만 포함하고 중복 정보는 제거한다.</li><li><strong>구별성(Distinguishability)</strong>: 서로 다른 해결책은 서로 다른 상태로 표현되어야 한다.</li><li><strong>효율성(Efficiency)</strong>: 상태 표현과 관련된 연산(생성, 전이, 비교 등)이 효율적이어야 한다.</li><li><strong>계산 용이성(Computability)</strong>: 한계값과 같은 중요한 메트릭을 쉽게 계산할 수 있어야 한다.</li><li><strong>확장성(Scalability)</strong>: 문제 크기가 커져도 효율적으로 처리할 수 있어야 한다.</li></ol></li><li>상태 표현 최적화 기법<ol><li><strong>증분 계산(Incremental Computation)</strong>: 상태 전이 시 전체를 다시 계산하는 대신 변경된 부분만 업데이트한다.</li><li><strong>상태 압축(State Compression)</strong>: 불필요한 정보를 제거하고 효율적인 자료구조를 사용한다.</li><li><strong>해시 기반 중복 탐지(Hash-based Duplicate Detection)</strong>: 해시 함수를 사용하여 중복 상태를 효율적으로 탐지한다.</li><li><strong>지연 계산(Lazy Evaluation)</strong>: 필요할 때만 계산을 수행하여 계산 비용을 줄인다.</li><li><strong>메모이제이션(Memoization)</strong>: 이전에 계산한 결과를 저장하여 재사용한다.</li></ol></li></ol><h3 id=주요-상태-표현-방식>주요 상태 표현 방식<a hidden class=anchor aria-hidden=true href=#주요-상태-표현-방식>#</a></h3><h4 id=벡터-기반-상태-표현vector-based-representation>벡터 기반 상태 표현(Vector-based Representation)<a hidden class=anchor aria-hidden=true href=#벡터-기반-상태-표현vector-based-representation>#</a></h4><p>벡터 기반 상태 표현은 여러 변수나 결정 사항을 벡터의 요소로 표현하는 방식.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 배낭 문제에서의 벡터 기반 상태 표현 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>State</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>items_included</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>level</span> <span class=o>=</span> <span class=n>level</span>               <span class=c1># 현재 결정 레벨</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight</span>             <span class=c1># 현재까지의 무게</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>               <span class=c1># 현재까지의 가치</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>items_included</span> <span class=o>=</span> <span class=n>items_included</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 포함된 항목 목록(0/1 벡터)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>특징</strong>:</p><ul><li>직관적이고 구현이 상대적으로 간단.</li><li>각 차원이 의사 결정 변수에 해당.</li><li>상태 간 전환이 벡터 요소의 변경으로 표현.</li></ul><h5 id=예시-배낭-문제knapsack-problem>예시: 배낭 문제(Knapsack Problem)<a hidden class=anchor aria-hidden=true href=#예시-배낭-문제knapsack-problem>#</a></h5><p>배낭 문제에서 각 물건의 포함 여부를 벡터로 표현할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 표현: [x₁, x₂, x₃, …, xₙ]
</span></span><span class=line><span class=cl>- xᵢ = 1: i번째 물건을 배낭에 포함
</span></span><span class=line><span class=cl>- xᵢ = 0: i번째 물건을 배낭에 포함하지 않음
</span></span></code></pre></td></tr></table></div></div><h5 id=시각화>시각화<a hidden class=anchor aria-hidden=true href=#시각화>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                           [0,0,0,0]  (초기 상태: 빈 배낭)
</span></span><span class=line><span class=cl>                           /        \
</span></span><span class=line><span class=cl>                [1,0,0,0] (물건1 포함)   [0,0,0,0] (물건1 제외)
</span></span><span class=line><span class=cl>                /        \               /        \
</span></span><span class=line><span class=cl>       [1,1,0,0]         [1,0,0,0]  [0,1,0,0]    [0,0,0,0]
</span></span><span class=line><span class=cl>       (물건1,2 포함)      (물건1만)   (물건2만)    (물건 없음)
</span></span></code></pre></td></tr></table></div></div><p>이 표현에서 각 노드는 부분 해결책을 나타내며, 리프 노드는 가능한 완전한 해결책을 나타낸다.<br>분기 과정에서 상한(bound)을 계산하여 유망하지 않은 노드를 가지치기한다.</p><h4 id=트리-기반-상태-표현tree-based-representation>트리 기반 상태 표현(Tree-based Representation)<a hidden class=anchor aria-hidden=true href=#트리-기반-상태-표현tree-based-representation>#</a></h4><p>트리 기반 상태 표현은 결정 트리의 노드로 상태를 표현하며, 각 분기는 다른 결정 경로를 나타낸다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 외판원 문제(TSP)에서의 트리 기반 상태 표현 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TSPState</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>cost</span><span class=p>,</span> <span class=n>remaining_cities</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=o>=</span> <span class=n>path</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>         <span class=c1># 현재까지의 경로</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>                <span class=c1># 현재까지의 비용</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>remaining_cities</span> <span class=o>=</span> <span class=n>remaining_cities</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 방문해야 할 도시 목록</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lower_bound</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>calculate_bound</span><span class=p>()</span>  <span class=c1># 하한값</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>특징</strong>:</p><ul><li>계층적 구조로 문제의 분할을 자연스럽게 표현.</li><li>부모-자식 관계가 결정의 순서와 의존성을 명확히 보여준다.</li><li>깊이 우선 탐색(DFS), 너비 우선 탐색(BFS) 등 다양한 트리 탐색 알고리즘을 적용할 수 있다.</li></ul><h5 id=예시-외판원-문제tsp>예시: 외판원 문제(TSP)<a hidden class=anchor aria-hidden=true href=#예시-외판원-문제tsp>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 표현: (현재 도시, 방문한 도시 집합)
</span></span><span class=line><span class=cl>예: (3, {1, 2, 3})은 도시 1, 2를 방문한 후 현재 도시 3에 있음을 의미
</span></span></code></pre></td></tr></table></div></div><h5 id=시각화-1>시각화<a hidden class=anchor aria-hidden=true href=#시각화-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                           (1, {1})  (시작 도시 1)
</span></span><span class=line><span class=cl>                        /     |      \
</span></span><span class=line><span class=cl>            (2, {1,2})   (3, {1,3})   (4, {1,4})
</span></span><span class=line><span class=cl>            /     \         /    \       /     \
</span></span><span class=line><span class=cl>    (3, {1,2,3}) (4, {1,2,4}) …       …     …
</span></span><span class=line><span class=cl>       /    \
</span></span><span class=line><span class=cl>  …       …
</span></span></code></pre></td></tr></table></div></div><p>각 노드는 현재까지의 경로와 방문한 도시들을 나타낸다. 여기서 분기는 다음에 방문할 수 있는 도시들에 대해 이루어지며, 각 경로의 하한(lower bound)을 계산하여 가지치기를 수행한다.</p><h4 id=비트마스크-기반-상태-표현bitmask-based-representation>비트마스크 기반 상태 표현(Bitmask-based Representation)<a hidden class=anchor aria-hidden=true href=#비트마스크-기반-상태-표현bitmask-based-representation>#</a></h4><p>비트마스크 기반 상태 표현은 이진 비트열을 사용하여 선택/비선택 상태를 효율적으로 표현하는 방식.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 집합 커버링 문제에서의 비트마스크 기반 상태 표현 예시</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>set_covering_branch_and_bound</span><span class=p>(</span><span class=n>universe</span><span class=p>,</span> <span class=n>subsets</span><span class=p>,</span> <span class=n>costs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>subsets</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상태 표현: (선택된 부분집합의 비트마스크, 커버된 원소의 비트마스크, 비용)</span>
</span></span><span class=line><span class=cl>    <span class=n>initial_state</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1># 아무것도 선택되지 않은 초기 상태</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 비트마스크를 이용한 집합 연산</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_coverage</span><span class=p>(</span><span class=n>subset_mask</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>coverage</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>subset_mask</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>i</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># i번째 부분집합이 선택된 경우</span>
</span></span><span class=line><span class=cl>                <span class=n>coverage</span> <span class=o>|=</span> <span class=n>subsets</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>  <span class=c1># 비트 OR 연산으로 커버 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>coverage</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>특징</strong>:</p><ul><li>메모리 효율적인 표현이 가능(n개 항목을 n비트로 표현).</li><li>비트 연산을 통해 집합 연산(합집합, 교집합 등)을 빠르게 수행할 수 있다.</li><li>작은 크기의 문제(일반적으로 요소 수가 32개 또는 64개 이하)에 적합.</li></ul><h5 id=예시-집합-커버-문제set-cover-problem>예시: 집합 커버 문제(Set Cover Problem)<a hidden class=anchor aria-hidden=true href=#예시-집합-커버-문제set-cover-problem>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 표현: 정수의 비트 표현
</span></span><span class=line><span class=cl>예: 13(10진수) = 1101(2진수)는 첫 번째, 세 번째, 네 번째 요소가 선택됨을 의미
</span></span></code></pre></td></tr></table></div></div><h5 id=시각화-2>시각화<a hidden class=anchor aria-hidden=true href=#시각화-2>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8>8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                                0 (0000)
</span></span><span class=line><span class=cl>                          /            \
</span></span><span class=line><span class=cl>                     1 (0001)          0 (0000)
</span></span><span class=line><span class=cl>                   /        \         /        \
</span></span><span class=line><span class=cl>              3 (0011)    1 (0001) 2 (0010)    0 (0000)
</span></span><span class=line><span class=cl>             /      \
</span></span><span class=line><span class=cl>        7 (0111)   3 (0011)
</span></span><span class=line><span class=cl>       /      \
</span></span><span class=line><span class=cl>  15 (1111)  7 (0111)
</span></span></code></pre></td></tr></table></div></div><p>각 노드는 비트마스크로 표현된 상태를 나타내며, 1인 비트 위치의 요소가 선택된 상태이다.<br>이 표현은 메모리 사용이 효율적이고 집합 연산(합집합, 교집합 등)이 비트 연산으로 빠르게 수행될 수 있다.</p><h4 id=행렬-기반-상태-표현matrix-based-representation>행렬 기반 상태 표현(Matrix-based Representation)<a hidden class=anchor aria-hidden=true href=#행렬-기반-상태-표현matrix-based-representation>#</a></h4><p>행렬 기반 상태 표현은 2차원 이상의 배열을 사용하여 복잡한 관계와 제약조건을 표현하는 방식.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 작업 할당 문제에서의 행렬 기반 상태 표현 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AssignmentState</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>assignment_matrix</span><span class=p>,</span> <span class=n>cost</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>matrix</span> <span class=o>=</span> <span class=n>assignment_matrix</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 할당 행렬(0/1 값)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>                       <span class=c1># 현재까지의 비용</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>next_person</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find_next_unassigned</span><span class=p>()</span>  <span class=c1># 다음 할당할 사람</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>특징</strong>:</p><ul><li>2차원 이상의 관계를 표현하기에 적합.</li><li>행렬 연산을 활용하여 상태 전이나 한계값 계산이 가능.</li><li>할당 문제, 스케줄링 문제 등에 자주 사용.</li></ul><h5 id=예시-8-퍼즐-문제8-puzzle-problem>예시: 8-퍼즐 문제(8-Puzzle Problem)<a hidden class=anchor aria-hidden=true href=#예시-8-퍼즐-문제8-puzzle-problem>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 표현: 3x3 행렬
</span></span><span class=line><span class=cl>예:
</span></span><span class=line><span class=cl>2 8 3
</span></span><span class=line><span class=cl>1 0 4  (0은 빈 공간)
</span></span><span class=line><span class=cl>7 6 5
</span></span></code></pre></td></tr></table></div></div><h5 id=시각화-3>시각화<a hidden class=anchor aria-hidden=true href=#시각화-3>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>          ┌─────────┐
</span></span><span class=line><span class=cl>          │ 2 8 3   │
</span></span><span class=line><span class=cl>초기 상태 → │ 1 0 4   │
</span></span><span class=line><span class=cl>          │ 7 6 5   │
</span></span><span class=line><span class=cl>          └─────────┘
</span></span><span class=line><span class=cl>              │
</span></span><span class=line><span class=cl>    ┌─────────┴─────────┐
</span></span><span class=line><span class=cl>    ↓                   ↓
</span></span><span class=line><span class=cl>┌─────────┐       ┌─────────┐
</span></span><span class=line><span class=cl>│ 2 8 3   │       │ 2 0 3   │
</span></span><span class=line><span class=cl>│ 0 1 4   │       │ 1 8 4   │  ← 가능한 다음 상태들
</span></span><span class=line><span class=cl>│ 7 6 5   │       │ 7 6 5   │
</span></span><span class=line><span class=cl>└─────────┘       └─────────┘
</span></span></code></pre></td></tr></table></div></div><p>각 노드는 퍼즐 보드의 상태를 나타내며, 분기는 빈 공간(0)과 인접한 숫자를 교환하여 생성된다.<br>맨해튼 거리와 같은 휴리스틱을 사용하여 목표 상태까지의 하한을 계산한다.</p><h4 id=그래프-기반-상태-표현graph-based-representation>그래프 기반 상태 표현(Graph-based Representation)<a hidden class=anchor aria-hidden=true href=#그래프-기반-상태-표현graph-based-representation>#</a></h4><p>그래프 기반 상태 표현은 노드와 엣지를 사용하여 상태와 상태 간의 전이를 표현하는 방식.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 최소 신장 트리 문제에서의 그래프 기반 상태 표현 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MSTState</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>selected_edges</span><span class=p>,</span> <span class=n>total_weight</span><span class=p>,</span> <span class=n>connected_components</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>selected_edges</span> <span class=o>=</span> <span class=n>selected_edges</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 선택된 엣지 목록</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>total_weight</span> <span class=o>=</span> <span class=n>total_weight</span>           <span class=c1># 현재까지의 가중치 합</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>connected_components</span> <span class=o>=</span> <span class=n>connected_components</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 연결 컴포넌트 정보</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>특징</strong>:</p><ul><li>그래프 구조를 가진 문제(최단 경로, 최소 신장 트리 등)에 자연스럽게 적용.</li><li>노드와 엣지의 관계를 명시적으로 표현할 수 있다.</li><li>그래프 알고리즘과 결합하여 효율적인 탐색이 가능.</li></ul><h5 id=예시-최소-신장-트리mst-문제>예시: 최소 신장 트리(MST) 문제<a hidden class=anchor aria-hidden=true href=#예시-최소-신장-트리mst-문제>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>상태 표현: (선택된 간선 집합, 연결된 노드 집합)
</span></span><span class=line><span class=cl>예: ({(1,2), (2,3)}, {1, 2, 3})은 간선 (1,2)와 (2,3)이 선택되어 노드 1, 2, 3이 연결됨을 의미
</span></span></code></pre></td></tr></table></div></div><h5 id=시각화-4>시각화<a hidden class=anchor aria-hidden=true href=#시각화-4>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                  ({}, {})  (초기 상태: 간선 없음)
</span></span><span class=line><span class=cl>                  /      \
</span></span><span class=line><span class=cl>     ({(1,2)}, {1,2})   ({(1,3)}, {1,3})
</span></span><span class=line><span class=cl>        /     \             /     \
</span></span><span class=line><span class=cl>({(1,2),(2,3)},{1,2,3}) …  …   …
</span></span></code></pre></td></tr></table></div></div><p>각 노드는 현재까지 선택된 간선과 연결된 노드의 집합을 나타낸다.<br>분기는 새로 추가할 수 있는 간선에 대해 이루어지며, 최소 신장 트리의 비용에 대한 하한을 계산하여 가지치기를 수행한다.</p><h3 id=상태-표현-방식의-비교>상태 표현 방식의 비교<a hidden class=anchor aria-hidden=true href=#상태-표현-방식의-비교>#</a></h3><table><thead><tr><th>특성</th><th>벡터 기반</th><th>트리 기반</th><th>비트마스크 기반</th><th>행렬 기반</th><th>그래프 기반</th></tr></thead><tbody><tr><td><strong>메모리 효율성</strong></td><td>중간</td><td>낮음</td><td>높음</td><td>낮음</td><td>낮음</td></tr><tr><td><strong>구현 복잡성</strong></td><td>낮음</td><td>중간</td><td>중간</td><td>중간</td><td>높음</td></tr><tr><td><strong>계산 효율성</strong></td><td>중간</td><td>중간</td><td>높음</td><td>중간</td><td>중간</td></tr><tr><td><strong>확장성</strong></td><td>높음</td><td>높음</td><td>제한적</td><td>높음</td><td>높음</td></tr><tr><td><strong>중복 상태 탐지</strong></td><td>중간</td><td>어려움</td><td>쉬움</td><td>중간</td><td>어려움</td></tr><tr><td><strong>상태 전이 용이성</strong></td><td>높음</td><td>높음</td><td>높음</td><td>중간</td><td>중간</td></tr><tr><td><strong>한계값 계산 적합성</strong></td><td>높음</td><td>높음</td><td>중간</td><td>높음</td><td>높음</td></tr><tr><td><strong>적합한 문제 유형</strong></td><td>일반적인 최적화 문제</td><td>계층적 문제</td><td>부분집합 선택 문제</td><td>할당, 스케줄링 문제</td><td>경로, 네트워크 문제</td></tr><tr><td><strong>최대 문제 크기</strong></td><td>중간</td><td>중간~큼</td><td>작음~중간(≤64)</td><td>중간</td><td>중간~큼</td></tr><tr><td><strong>병렬화 가능성</strong></td><td>중간</td><td>높음</td><td>낮음</td><td>중간</td><td>높음</td></tr><tr><td><strong>메모리 사용량</strong></td><td>O(n)</td><td>O(n) ~ O(n²)</td><td>O(1) ~ O(log n)</td><td>O(n²)</td><td>O(n + e)</td></tr><tr><td><strong>상태 표현 예시</strong></td><td>[0,1,0,1,1]</td><td>경로 트리</td><td>10110 (비트열)</td><td>2차원 배열</td><td>노드와 엣지</td></tr><tr><td><strong>장점</strong></td><td>직관적, 유연함</td><td>계층 구조 표현에 적합</td><td>메모리 효율적, 빠른 연산</td><td>복잡한 관계 표현 가능</td><td>관계 표현에 자연스러움</td></tr><tr><td><strong>단점</strong></td><td>큰 문제에서 비효율적</td><td>메모리 사용량 많음</td><td>크기 제한, 구현 복잡</td><td>희소 행렬에서 비효율적</td><td>구현 복잡, 메모리 많이 사용</td></tr></tbody></table><p>각 상태 표현 방식은 특정 문제 유형에 더 적합할 수 있다:</p><ul><li><strong>벡터 기반</strong>: 선택/비선택 결정이 많은 문제 (배낭 문제, 자원 할당)</li><li><strong>트리 기반</strong>: 계층적 의사결정이 필요한 문제 (게임 트리, 의사결정 트리)</li><li><strong>비트마스크 기반</strong>: 이진 선택이 많고 집합 연산이 필요한 문제 (부분집합 문제)</li><li><strong>행렬 기반</strong>: 공간적/지역적 관계가 중요한 문제 (퍼즐, 격자 기반 문제)</li><li><strong>그래프 기반</strong>: 연결성과 네트워크 구조가 중요한 문제 (경로 찾기, 네트워크 설계)</li></ul><p>적절한 상태 표현을 선택하면 문제 해결의 효율성을 크게 향상시킬 수 있으며, 이는 분기한정법을 적용할 때 특히 중요하다. 문제의 특성을 잘 파악하여 가장 적합한 상태 표현 방식을 선택하는 것이 알고리즘 설계의 핵심이다.</p><h3 id=다양한-문제에서의-상태-표현-적용-예시>다양한 문제에서의 상태 표현 적용 예시<a hidden class=anchor aria-hidden=true href=#다양한-문제에서의-상태-표현-적용-예시>#</a></h3><h4 id=배낭-문제knapsack-problem의-상태-표현>배낭 문제(Knapsack Problem)의 상태 표현<a hidden class=anchor aria-hidden=true href=#배낭-문제knapsack-problem의-상태-표현>#</a></h4><p>배낭 문제는 제한된 무게 내에서 최대 가치를 가진 물건들을 선택하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span><span class=lnt id=hl-15-20><a class=lnlinks href=#hl-15-20>20</a>
</span><span class=lnt id=hl-15-21><a class=lnlinks href=#hl-15-21>21</a>
</span><span class=lnt id=hl-15-22><a class=lnlinks href=#hl-15-22>22</a>
</span><span class=lnt id=hl-15-23><a class=lnlinks href=#hl-15-23>23</a>
</span><span class=lnt id=hl-15-24><a class=lnlinks href=#hl-15-24>24</a>
</span><span class=lnt id=hl-15-25><a class=lnlinks href=#hl-15-25>25</a>
</span><span class=lnt id=hl-15-26><a class=lnlinks href=#hl-15-26>26</a>
</span><span class=lnt id=hl-15-27><a class=lnlinks href=#hl-15-27>27</a>
</span><span class=lnt id=hl-15-28><a class=lnlinks href=#hl-15-28>28</a>
</span><span class=lnt id=hl-15-29><a class=lnlinks href=#hl-15-29>29</a>
</span><span class=lnt id=hl-15-30><a class=lnlinks href=#hl-15-30>30</a>
</span><span class=lnt id=hl-15-31><a class=lnlinks href=#hl-15-31>31</a>
</span><span class=lnt id=hl-15-32><a class=lnlinks href=#hl-15-32>32</a>
</span><span class=lnt id=hl-15-33><a class=lnlinks href=#hl-15-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>knapsack_branch_and_bound</span><span class=p>(</span><span class=n>weights</span><span class=p>,</span> <span class=n>values</span><span class=p>,</span> <span class=n>capacity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상태 정의: (레벨, 현재 무게, 현재 가치, 포함된 항목 목록)</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>State</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>weight</span><span class=p>,</span> <span class=n>value</span><span class=p>,</span> <span class=n>includes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>level</span> <span class=o>=</span> <span class=n>level</span>      <span class=c1># 결정 레벨(몇 번째 항목까지 고려했는지)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>=</span> <span class=n>weight</span>    <span class=c1># 현재까지의 무게</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>      <span class=c1># 현재까지의 가치</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>includes</span> <span class=o>=</span> <span class=n>includes</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 포함된 항목 목록(0/1 벡터)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 상한값 계산</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>bound</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>calculate_bound</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>calculate_bound</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>weight</span> <span class=o>&gt;</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>bound_value</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>level</span>
</span></span><span class=line><span class=cl>            <span class=n>total_weight</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>weight</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 남은 항목들을 가치/무게 비율이 높은 순으로 최대한 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>total_weight</span> <span class=o>+</span> <span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>capacity</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>bound_value</span> <span class=o>+=</span> <span class=n>values</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 마지막 항목은 분수로 추가(분할 가능 가정)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>bound_value</span> <span class=o>+=</span> <span class=p>(</span><span class=n>capacity</span> <span class=o>-</span> <span class=n>total_weight</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>/</span> <span class=n>weights</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>bound_value</span>
</span></span></code></pre></td></tr></table></div></div><p>이 상태 표현은 현재까지의 결정(어떤 항목을 포함했는지)과 그에 따른 무게와 가치를 추적한다.<br>또한 남은 공간에 추가할 수 있는 최대 가치를 상한값으로 계산한다.</p><h4 id=외판원-문제tsp의-상태-표현>외판원 문제(TSP)의 상태 표현<a hidden class=anchor aria-hidden=true href=#외판원-문제tsp의-상태-표현>#</a></h4><p>외판원 문제는 모든 도시를 한 번씩 방문하고 출발 도시로 돌아오는 최단 경로를 찾는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span><span class=lnt id=hl-16-22><a class=lnlinks href=#hl-16-22>22</a>
</span><span class=lnt id=hl-16-23><a class=lnlinks href=#hl-16-23>23</a>
</span><span class=lnt id=hl-16-24><a class=lnlinks href=#hl-16-24>24</a>
</span><span class=lnt id=hl-16-25><a class=lnlinks href=#hl-16-25>25</a>
</span><span class=lnt id=hl-16-26><a class=lnlinks href=#hl-16-26>26</a>
</span><span class=lnt id=hl-16-27><a class=lnlinks href=#hl-16-27>27</a>
</span><span class=lnt id=hl-16-28><a class=lnlinks href=#hl-16-28>28</a>
</span><span class=lnt id=hl-16-29><a class=lnlinks href=#hl-16-29>29</a>
</span><span class=lnt id=hl-16-30><a class=lnlinks href=#hl-16-30>30</a>
</span><span class=lnt id=hl-16-31><a class=lnlinks href=#hl-16-31>31</a>
</span><span class=lnt id=hl-16-32><a class=lnlinks href=#hl-16-32>32</a>
</span><span class=lnt id=hl-16-33><a class=lnlinks href=#hl-16-33>33</a>
</span><span class=lnt id=hl-16-34><a class=lnlinks href=#hl-16-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>tsp_branch_and_bound</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>distance_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상태 정의: (경로, 비용, 방문하지 않은 도시 목록)</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>State</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>path</span><span class=p>,</span> <span class=n>cost</span><span class=p>,</span> <span class=n>unvisited</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=o>=</span> <span class=n>path</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>       <span class=c1># 현재까지의 경로</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>              <span class=c1># 현재까지의 비용</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>unvisited</span> <span class=o>=</span> <span class=n>unvisited</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 방문하지 않은 도시 목록</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 하한값 계산</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>lower_bound</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>calculate_lower_bound</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>calculate_lower_bound</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 현재까지의 비용 + 방문하지 않은 도시들의 최소 진입 비용 + 최소 탈출 비용</span>
</span></span><span class=line><span class=cl>            <span class=n>lb</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>cost</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 각 미방문 도시의 최소 진입 비용</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>city</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>unvisited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_in</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>city</span> <span class=ow>and</span> <span class=p>(</span><span class=n>i</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=ow>or</span> <span class=n>i</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>unvisited</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                        <span class=n>min_in</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_in</span><span class=p>,</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>city</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>lb</span> <span class=o>+=</span> <span class=n>min_in</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 각 미방문 도시의 최소 탈출 비용</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>city</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>unvisited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_out</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>city</span> <span class=ow>and</span> <span class=p>(</span><span class=n>i</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>path</span> <span class=ow>or</span> <span class=n>i</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>unvisited</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                        <span class=n>min_out</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_out</span><span class=p>,</span> <span class=n>distance_matrix</span><span class=p>[</span><span class=n>city</span><span class=p>][</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>lb</span> <span class=o>+=</span> <span class=n>min_out</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>lb</span> <span class=o>/</span> <span class=mi>2</span>  <span class=c1># 각 비용이 두 번 계산되었으므로 2로 나눔</span>
</span></span></code></pre></td></tr></table></div></div><p>이 상태 표현은 현재까지의 경로, 비용, 그리고 아직 방문하지 않은 도시 목록을 포함한다.<br>하한값은 현재까지의 비용과 미방문 도시들의 최소 진입/탈출 비용을 기반으로 계산된다.</p><h4 id=53-작업-할당-문제job-assignment-problem의-상태-표현>5.3 작업 할당 문제(Job Assignment Problem)의 상태 표현<a hidden class=anchor aria-hidden=true href=#53-작업-할당-문제job-assignment-problem의-상태-표현>#</a></h4><p>작업 할당 문제는 n개의 작업을 n명의 작업자에게 최적으로 할당하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span><span class=lnt id=hl-17-26><a class=lnlinks href=#hl-17-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>job_assignment_branch_and_bound</span><span class=p>(</span><span class=n>cost_matrix</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>cost_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상태 정의: (할당된 작업자 목록, 총 비용)</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>State</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>assignments</span><span class=p>,</span> <span class=n>cost</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>assignments</span> <span class=o>=</span> <span class=n>assignments</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 각 작업별 할당된 작업자(-1은 미할당)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>cost</span> <span class=o>=</span> <span class=n>cost</span>                      <span class=c1># 현재까지의 총 비용</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>next_job</span> <span class=o>=</span> <span class=nb>len</span><span class=p>([</span><span class=n>a</span> <span class=k>for</span> <span class=n>a</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>assignments</span> <span class=k>if</span> <span class=n>a</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>])</span>  <span class=c1># 다음 할당할 작업</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 하한값 계산</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>lower_bound</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>calculate_lower_bound</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>calculate_lower_bound</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>lb</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>cost</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 각 미할당 작업에 대해 최소 비용을 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>job</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>next_job</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># 이미 할당된 작업자를 제외한 최소 비용 찾기</span>
</span></span><span class=line><span class=cl>                <span class=n>min_cost</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>worker</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>worker</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>assignments</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>min_cost</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_cost</span><span class=p>,</span> <span class=n>cost_matrix</span><span class=p>[</span><span class=n>job</span><span class=p>][</span><span class=n>worker</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>lb</span> <span class=o>+=</span> <span class=n>min_cost</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>lb</span>
</span></span></code></pre></td></tr></table></div></div><p>이 상태 표현은 각 작업별로 할당된 작업자와 현재까지의 총 비용을 추적한다.<br>하한값은 현재까지의 비용과 미할당 작업의 최소 비용을 합산하여 계산한다.</p><h3 id=8-실제-사례-연구-15-퍼즐-문제의-상태-표현>8. 실제 사례 연구: 15-퍼즐 문제의 상태 표현<a hidden class=anchor aria-hidden=true href=#8-실제-사례-연구-15-퍼즐-문제의-상태-표현>#</a></h3><p>15-퍼즐은 4x4 그리드에 1부터 15까지의 숫자와 한 개의 빈 칸이 있으며, 빈 칸을 이동하여 숫자를 정렬하는 퍼즐이다.<br>이 문제에 대한 Branch and Bound 접근법과 상태 표현.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34>34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35>35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36>36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37>37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38>38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39>39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40>40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41>41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42>42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43>43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44>44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45>45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46>46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47>47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48>48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49>49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50>50</a>
</span><span class=lnt id=hl-18-51><a class=lnlinks href=#hl-18-51>51</a>
</span><span class=lnt id=hl-18-52><a class=lnlinks href=#hl-18-52>52</a>
</span><span class=lnt id=hl-18-53><a class=lnlinks href=#hl-18-53>53</a>
</span><span class=lnt id=hl-18-54><a class=lnlinks href=#hl-18-54>54</a>
</span><span class=lnt id=hl-18-55><a class=lnlinks href=#hl-18-55>55</a>
</span><span class=lnt id=hl-18-56><a class=lnlinks href=#hl-18-56>56</a>
</span><span class=lnt id=hl-18-57><a class=lnlinks href=#hl-18-57>57</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_15_puzzle</span><span class=p>(</span><span class=n>initial_state</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 상태 표현: (보드 배열, 빈 칸 위치, 이동 횟수, 이전 이동 방향)</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>PuzzleState</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>board</span><span class=p>,</span> <span class=n>empty_pos</span><span class=p>,</span> <span class=n>moves</span><span class=p>,</span> <span class=n>prev_dir</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>board</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>     <span class=c1># 4x4 보드 배열</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>empty_pos</span> <span class=o>=</span> <span class=n>empty_pos</span>    <span class=c1># 빈 칸 위치 (row, col)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>moves</span> <span class=o>=</span> <span class=n>moves</span>            <span class=c1># 현재까지의 이동 횟수</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>prev_dir</span> <span class=o>=</span> <span class=n>prev_dir</span>      <span class=c1># 이전 이동 방향</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 휴리스틱 계산(맨해튼 거리)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>h</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>calculate_heuristic</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=c1># f(n) = g(n) + h(n)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>f</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>moves</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>h</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>calculate_heuristic</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>h</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>  <span class=c1># 빈 칸이 아닌 경우</span>
</span></span><span class=line><span class=cl>                        <span class=c1># 목표 위치 계산</span>
</span></span><span class=line><span class=cl>                        <span class=n>val</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                        <span class=n>goal_row</span><span class=p>,</span> <span class=n>goal_col</span> <span class=o>=</span> <span class=p>(</span><span class=n>val</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=mi>4</span><span class=p>,</span> <span class=p>(</span><span class=n>val</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>                        <span class=c1># 맨해튼 거리 추가</span>
</span></span><span class=line><span class=cl>                        <span class=n>h</span> <span class=o>+=</span> <span class=nb>abs</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>goal_row</span><span class=p>)</span> <span class=o>+</span> <span class=nb>abs</span><span class=p>(</span><span class=n>j</span> <span class=o>-</span> <span class=n>goal_col</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>h</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 다음 가능한 상태 생성</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>generate_next_states</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>next_states</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=n>row</span><span class=p>,</span> <span class=n>col</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>empty_pos</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 가능한 이동 방향: 상, 하, 좌, 우</span>
</span></span><span class=line><span class=cl>            <span class=n>directions</span> <span class=o>=</span> <span class=p>[(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=s1>&#39;U&#39;</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=s1>&#39;D&#39;</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;L&#39;</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;R&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>dr</span><span class=p>,</span> <span class=n>dc</span><span class=p>,</span> <span class=n>dir_name</span> <span class=ow>in</span> <span class=n>directions</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>new_row</span><span class=p>,</span> <span class=n>new_col</span> <span class=o>=</span> <span class=n>row</span> <span class=o>+</span> <span class=n>dr</span><span class=p>,</span> <span class=n>col</span> <span class=o>+</span> <span class=n>dc</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 유효한 위치인지 확인</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>new_row</span> <span class=o>&lt;</span> <span class=mi>4</span> <span class=ow>and</span> <span class=mi>0</span> <span class=o>&lt;=</span> <span class=n>new_col</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 반대 방향으로 되돌아가는 것 방지</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>prev_dir</span> <span class=o>==</span> <span class=s1>&#39;U&#39;</span> <span class=ow>and</span> <span class=n>dir_name</span> <span class=o>==</span> <span class=s1>&#39;D&#39;</span><span class=p>)</span> <span class=ow>or</span> \
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>prev_dir</span> <span class=o>==</span> <span class=s1>&#39;D&#39;</span> <span class=ow>and</span> <span class=n>dir_name</span> <span class=o>==</span> <span class=s1>&#39;U&#39;</span><span class=p>)</span> <span class=ow>or</span> \
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>prev_dir</span> <span class=o>==</span> <span class=s1>&#39;L&#39;</span> <span class=ow>and</span> <span class=n>dir_name</span> <span class=o>==</span> <span class=s1>&#39;R&#39;</span><span class=p>)</span> <span class=ow>or</span> \
</span></span><span class=line><span class=cl>                       <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>prev_dir</span> <span class=o>==</span> <span class=s1>&#39;R&#39;</span> <span class=ow>and</span> <span class=n>dir_name</span> <span class=o>==</span> <span class=s1>&#39;L&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 새 보드 상태 생성</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_board</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>board</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_board</span><span class=p>[</span><span class=n>row</span><span class=p>][</span><span class=n>col</span><span class=p>]</span> <span class=o>=</span> <span class=n>new_board</span><span class=p>[</span><span class=n>new_row</span><span class=p>][</span><span class=n>new_col</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_board</span><span class=p>[</span><span class=n>new_row</span><span class=p>][</span><span class=n>new_col</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 새 상태 생성</span>
</span></span><span class=line><span class=cl>                    <span class=n>next_state</span> <span class=o>=</span> <span class=n>PuzzleState</span><span class=p>(</span><span class=n>new_board</span><span class=p>,</span> <span class=p>(</span><span class=n>new_row</span><span class=p>,</span> <span class=n>new_col</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>                                            <span class=bp>self</span><span class=o>.</span><span class=n>moves</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dir_name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>next_states</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>next_state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>next_states</span>
</span></span></code></pre></td></tr></table></div></div><p>이 예시에서 상태 표현은 다음 요소를 포함한다:</p><ol><li><strong>보드 배열</strong>: 현재 퍼즐 상태를 나타내는 4x4 배열</li><li><strong>빈 칸 위치</strong>: 빈 칸의 (행, 열) 좌표</li><li><strong>이동 횟수</strong>: 현재까지 수행한 이동 횟수(g(n))</li><li><strong>이전 이동 방향</strong>: 중복 이동을 방지하기 위한 정보</li></ol><p>또한 맨해튼 거리 휴리스틱을 사용하여 목표 상태까지의 최소 이동 횟수를 추정하고, 이를 한계값으로 사용한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/branch-and-bound/>Branch-and-Bound</a></li><li><a href=https://buenhyden.github.io/tags/components/>Components</a></li><li><a href=https://buenhyden.github.io/tags/state-representation/>State-Representation</a></li></ul><nav class=paginav><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/pruning/><span class=title>Next »</span><br><span>가지치기(Pruning)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>