<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Back Tracking vs. Brute Force | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Back-Tracking,Brute-Force"><meta name=description content="브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Back Tracking vs. Brute Force"><meta property="og:description" content="브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-29T14:02:00+00:00"><meta property="article:modified_time" content="2024-12-29T14:02:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Back-Tracking"><meta property="article:tag" content="Brute-Force"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Back Tracking vs. Brute Force"><meta name=twitter:description content="브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"백트래킹 (Backtracking)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/"},{"@type":"ListItem","position":5,"name":"Back Tracking vs. Brute Force","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Back Tracking vs. Brute Force","name":"Back Tracking vs. Brute Force","description":"브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Back-Tracking","Brute-Force"],"articleBody":"Back Tracking vs. Brute Force 브루트 포스와 백트래킹은 모두 조합 최적화 문제를 해결하는 데 사용되는 중요한 알고리즘 패러다임이다.\n브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.\n브루트 포스(Brute Force) 브루트 포스는 가능한 모든 경우의 수를 전부 확인하는 완전 탐색 알고리즘이다.\n이 방법은 문제 해결을 위해 가능한 모든 후보해를 체계적으로 나열하고 각각을 검사한다.\n브루트 포스의 작동 방식:\n가능한 모든 해결책 후보를 생성한다. 각 후보가 문제의 조건을 만족하는지 확인한다. 조건을 만족하는 해결책을 찾을 때까지 또는 모든 후보를 확인할 때까지 계속한다. 브루트 포스의 특징 단순성: 구현이 매우 간단하고 직관적. 완전성: 해결책이 존재한다면 반드시 찾아낸다. 비효율성: 문제의 크기가 커질수록 연산량이 기하급수적으로 증가. 최적성: 모든 가능한 경우를 확인하기 때문에 최적해를 보장. 브루트 포스 예제: 모든 부분집합 찾기 1 2 3 4 5 6 7 8 9 10 11 12 13 def generate_all_subsets(arr): n = len(arr) # 2^n개의 부분집합 생성 for i in range(2**n): subset = [] for j in range(n): # i의 j번째 비트가 설정되어 있는지 확인 if (i \u0026 (1 \u003c\u003c j)) \u003e 0: subset.append(arr[j]) print(subset) # 예시: [1, 2, 3]의 모든 부분집합 생성 generate_all_subsets([1, 2, 3]) 백트래킹(Backtracking) 백트래킹은 해결책을 찾는 과정에서 더 이상 유망하지 않은 경로를 만나면 즉시 이전 단계로 돌아가(백트랙) 다른 경로를 탐색하는 알고리즘이다.\n백트래킹의 작동 방식:\n해결책의 후보를 단계별로 구성한다. 각 단계에서 현재 후보가 유망한지(promising) 검사한다. 유망하지 않다면 즉시 탐색을 중단하고 이전 단계로 돌아간다(가지치기). 유망하다면 다음 단계로 진행한다. 해결책을 찾거나 모든 가능성을 탐색할 때까지 이 과정을 반복한다. 백트래킹의 특징 효율성: 불필요한 탐색을 줄여 효율성을 높인다. 유망성 테스트: 현재 경로가 해결책으로 이어질 가능성이 있는지 평가한다. 가지치기: 유망하지 않은 경로는 탐색하지 않고 가지치기를 통해 탐색 공간을 줄인다. 재귀적 구현: 대부분 재귀 함수로 구현된다. 백트래킹 예제: N-Queens 문제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solve_n_queens(n): board = [-1] * n # board[i]는 i번째 행에서 퀸의 열 위치 solutions = [] def is_promising(row): for i in range(row): # 같은 열에 있거나 대각선 상에 있는지 확인 if board[i] == board[row] or abs(board[i] - board[row]) == row - i: return False return True def place_queen(row): if row == n: # 모든 퀸을 성공적으로 배치했을 때 solutions.append(board[:]) return for col in range(n): board[row] = col # row번째 행의 col번째 열에 퀸 배치 # 유망성 테스트: 현재 배치가 유망한 경우에만 다음 행으로 진행 if is_promising(row): place_queen(row + 1) place_queen(0) return solutions # 8-Queens 문제 해결 solutions = solve_n_queens(8) print(f\"해결책 수: {len(solutions)}\") 브루트 포스와 백트래킹의 주요 차이점 탐색 방식\n브루트 포스: 가능한 모든 해결책을 빠짐없이 탐색한다. 백트래킹: 유망하지 않은 경로는 조기에 차단하고 유망한 경로만 탐색한다. 효율성\n브루트 포스: 문제 크기에 따라 기하급수적으로 연산량이 증가하여 대규모 문제에서는 비효율적이다. 백트래킹: 가지치기를 통해 탐색 공간을 줄여 브루트 포스보다 효율적이지만, 여전히 최악의 경우 브루트 포스와 같은 시간 복잡도를 가질 수 있다. 구현 복잡성\n브루트 포스: 구현이 매우 간단하고 직관적. 백트래킹: 유망성 테스트와 가지치기 로직이 추가되어 상대적으로 구현이 복잡하다. 성능 개선 가능성\n브루트 포스: 모든 경우를 확인하므로 성능 개선의 여지가 적다. 백트래킹: 더 효과적인 유망성 테스트와 가지치기 전략을 통해 성능을 크게 개선할 수 있다. 실제 적용 사례 비교 스도쿠 퍼즐 해결\n브루트 포스 접근법 각 빈 칸에 1부터 9까지 모든 숫자를 시도. 모든 가능한 조합을 확인하므로 9^n(n은 빈 칸의 수)의 시간 복잡도를 가진다. 규모가 큰 스도쿠(빈 칸이 많은 경우)에서는 비현실적으로 오래 걸린다. 백트래킹 접근법 각 빈 칸에 숫자를 채울 때마다 스도쿠 규칙(행, 열, 3x3 박스에 중복 없음)을 확인한다. 규칙을 위반하면 즉시 이전 단계로 돌아가 다른 숫자를 시도한다. 불가능한 경로를 조기에 차단하여 탐색 공간을 크게 줄인다. 조합 최적화 문제 (예: 배낭 문제)\n브루트 포스 접근법 가능한 모든 물건의 조합(2^n)을 생성하고 각각의 가치와 무게를 계산한다. 제약 조건을 만족하는 조합 중 가장 높은 가치를 가진 조합을 선택한다. 물건의 수가 많아지면 시간 복잡도가 기하급수적으로 증가한다. 백트래킹 접근법 물건을 하나씩 선택하면서 현재까지의 무게와 가치를 추적한다. 무게 제한을 초과하거나, 현재 경로가 이미 찾은 최적해보다 좋을 가능성이 없으면 탐색을 중단한다. 가지치기를 통해 많은 불필요한 경로를 탐색하지 않아 효율성이 높아진다. 백트래킹과 브루트 포스의 비교 특성 브루트 포스 (Brute Force) 백트래킹 (Backtracking) 정의 가능한 모든 경우의 수를 전부 확인하는 방법 불필요한 경로를 조기에 차단하며 해결책을 찾는 방법 탐색 방식 모든 가능한 해결책 후보를 나열하고 각각 검사 단계별로 해결책을 구성하며 유망성 테스트를 통해 가지치기 시간 복잡도 최악의 경우 O(m^n) 또는 O(n!) (m은 선택지 수, n은 단계 수) 최악의 경우 브루트 포스와 동일, 평균적으로 훨씬 우수 공간 복잡도 일반적으로 O(n) 재귀 호출로 인해 O(n)에서 O(m^n)까지 가능 구현 복잡성 매우 간단 상대적으로 복잡 (유망성 테스트 로직 필요) 최적화 가능성 제한적 유망성 테스트 개선, 휴리스틱 적용 등 다양한 최적화 가능 완전성 해결책이 존재한다면 항상 찾음 해결책이 존재한다면 항상 찾음 적합한 문제 유형 문제 크기가 작거나 다른 방법이 없는 경우 제약 조건이 많은 조합 최적화 문제, 결정 문제 핵심 개념 완전 탐색 유망성 테스트와 가지치기 메모리 사용 일반적으로 적음 재귀 호출 스택으로 인해 상대적으로 많음 구현 방식 반복문 또는 재귀 주로 재귀 대표적 문제 부분집합 생성, 순열 생성 N-Queens, 스도쿠, 그래프 색칠 문제 성능 예측성 문제 크기에 따라 정확히 예측 가능 문제 인스턴스와 가지치기 효율성에 따라 가변적 병렬화 용이성 쉬움 (독립적인 작업으로 분할 가능) 상대적으로 어려움 (의존성이 높음) 가지치기 여부 없음 있음 (핵심 특징) 장점 단순함, 구현 용이성, 완전성 효율성, 대규모 문제 해결 가능성 단점 비효율성, 대규모 문제에 부적합 구현 복잡성, 최악의 경우 성능 보장 없음 언제 어떤 방법을 사용해야 할까? 브루트 포스를 선택해야 할 때 문제 크기가 작아 모든 경우를 확인하는 것이 부담이 없을 때 알고리즘의 단순성과 명확성이 성능보다 중요할 때 더 효율적인 알고리즘을 찾기 전 기준선(baseline)을 설정할 때 문제에 대한 이해가 부족하거나 더 나은 해결책이 떠오르지 않을 때 백트래킹을 선택해야 할 때 문제 크기가 커서 브루트 포스가 현실적으로 불가능할 때 문제에 명확한 제약 조건이 있어 가지치기가 효과적일 때 조합 최적화 문제나 결정 문제를 해결할 때 해결책의 효율성이 중요한 실제 응용 프로그램에서 참고 및 출처 ","wordCount":"938","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-29T14:02:00Z","dateModified":"2024-12-29T14:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/>백트래킹 (Backtracking)</a></div><h1 class="post-title entry-hint-parent">Back Tracking vs. Brute Force</h1><div class=post-description>브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.</div><div class=post-meta><span title='2024-12-29 14:02:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Back%20Tracking/back-tracking-vs-brute-force.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#back-tracking-vs-brute-force>Back Tracking vs. Brute Force</a><ul><li><a href=#브루트-포스brute-force>브루트 포스(Brute Force)</a></li><li><a href=#백트래킹backtracking>백트래킹(Backtracking)</a></li><li><a href=#브루트-포스와-백트래킹의-주요-차이점>브루트 포스와 백트래킹의 주요 차이점</a></li><li><a href=#실제-적용-사례-비교>실제 적용 사례 비교</a></li><li><a href=#백트래킹과-브루트-포스의-비교>백트래킹과 브루트 포스의 비교</a></li><li><a href=#언제-어떤-방법을-사용해야-할까>언제 어떤 방법을 사용해야 할까?</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=back-tracking-vs-brute-force>Back Tracking vs. Brute Force<a hidden class=anchor aria-hidden=true href=#back-tracking-vs-brute-force>#</a></h2><p>브루트 포스와 백트래킹은 모두 조합 최적화 문제를 해결하는 데 사용되는 중요한 알고리즘 패러다임이다.</p><p>브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.</p><h3 id=브루트-포스brute-force>브루트 포스(Brute Force)<a hidden class=anchor aria-hidden=true href=#브루트-포스brute-force>#</a></h3><p>브루트 포스는 가능한 모든 경우의 수를 전부 확인하는 완전 탐색 알고리즘이다.<br>이 방법은 문제 해결을 위해 가능한 모든 후보해를 체계적으로 나열하고 각각을 검사한다.</p><p>브루트 포스의 작동 방식:</p><ol><li>가능한 모든 해결책 후보를 생성한다.</li><li>각 후보가 문제의 조건을 만족하는지 확인한다.</li><li>조건을 만족하는 해결책을 찾을 때까지 또는 모든 후보를 확인할 때까지 계속한다.</li></ol><h4 id=브루트-포스의-특징>브루트 포스의 특징<a hidden class=anchor aria-hidden=true href=#브루트-포스의-특징>#</a></h4><ul><li><strong>단순성</strong>: 구현이 매우 간단하고 직관적.</li><li><strong>완전성</strong>: 해결책이 존재한다면 반드시 찾아낸다.</li><li><strong>비효율성</strong>: 문제의 크기가 커질수록 연산량이 기하급수적으로 증가.</li><li><strong>최적성</strong>: 모든 가능한 경우를 확인하기 때문에 최적해를 보장.</li></ul><h4 id=브루트-포스-예제-모든-부분집합-찾기>브루트 포스 예제: 모든 부분집합 찾기<a hidden class=anchor aria-hidden=true href=#브루트-포스-예제-모든-부분집합-찾기>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_all_subsets</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 2^n개의 부분집합 생성</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=o>**</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>subset</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># i의 j번째 비트가 설정되어 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>j</span><span class=p>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>subset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>subset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시: [1, 2, 3]의 모든 부분집합 생성</span>
</span></span><span class=line><span class=cl><span class=n>generate_all_subsets</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=백트래킹backtracking>백트래킹(Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹backtracking>#</a></h3><p>백트래킹은 해결책을 찾는 과정에서 더 이상 유망하지 않은 경로를 만나면 즉시 이전 단계로 돌아가(백트랙) 다른 경로를 탐색하는 알고리즘이다.</p><p>백트래킹의 작동 방식:</p><ol><li>해결책의 후보를 단계별로 구성한다.</li><li>각 단계에서 현재 후보가 유망한지(promising) 검사한다.</li><li>유망하지 않다면 즉시 탐색을 중단하고 이전 단계로 돌아간다(가지치기).</li><li>유망하다면 다음 단계로 진행한다.</li><li>해결책을 찾거나 모든 가능성을 탐색할 때까지 이 과정을 반복한다.</li></ol><h4 id=백트래킹의-특징>백트래킹의 특징<a hidden class=anchor aria-hidden=true href=#백트래킹의-특징>#</a></h4><ul><li><strong>효율성</strong>: 불필요한 탐색을 줄여 효율성을 높인다.</li><li><strong>유망성 테스트</strong>: 현재 경로가 해결책으로 이어질 가능성이 있는지 평가한다.</li><li><strong>가지치기</strong>: 유망하지 않은 경로는 탐색하지 않고 가지치기를 통해 탐색 공간을 줄인다.</li><li><strong>재귀적 구현</strong>: 대부분 재귀 함수로 구현된다.</li></ul><h4 id=백트래킹-예제-n-queens-문제>백트래킹 예제: N-Queens 문제<a hidden class=anchor aria-hidden=true href=#백트래킹-예제-n-queens-문제>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>board</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># board[i]는 i번째 행에서 퀸의 열 위치</span>
</span></span><span class=line><span class=cl>    <span class=n>solutions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_promising</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 같은 열에 있거나 대각선 상에 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=ow>or</span> <span class=nb>abs</span><span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>])</span> <span class=o>==</span> <span class=n>row</span> <span class=o>-</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>place_queen</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>  <span class=c1># 모든 퀸을 성공적으로 배치했을 때</span>
</span></span><span class=line><span class=cl>            <span class=n>solutions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>board</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=n>col</span>  <span class=c1># row번째 행의 col번째 열에 퀸 배치</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 유망성 테스트: 현재 배치가 유망한 경우에만 다음 행으로 진행</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_promising</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>place_queen</span><span class=p>(</span><span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>place_queen</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solutions</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 8-Queens 문제 해결</span>
</span></span><span class=line><span class=cl><span class=n>solutions</span> <span class=o>=</span> <span class=n>solve_n_queens</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;해결책 수: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>solutions</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=브루트-포스와-백트래킹의-주요-차이점>브루트 포스와 백트래킹의 주요 차이점<a hidden class=anchor aria-hidden=true href=#브루트-포스와-백트래킹의-주요-차이점>#</a></h3><ol><li><p>탐색 방식</p><ul><li><strong>브루트 포스</strong>: 가능한 모든 해결책을 빠짐없이 탐색한다.</li><li><strong>백트래킹</strong>: 유망하지 않은 경로는 조기에 차단하고 유망한 경로만 탐색한다.</li></ul></li><li><p>효율성</p><ul><li><strong>브루트 포스</strong>: 문제 크기에 따라 기하급수적으로 연산량이 증가하여 대규모 문제에서는 비효율적이다.</li><li><strong>백트래킹</strong>: 가지치기를 통해 탐색 공간을 줄여 브루트 포스보다 효율적이지만, 여전히 최악의 경우 브루트 포스와 같은 시간 복잡도를 가질 수 있다.</li></ul></li><li><p>구현 복잡성</p><ul><li><strong>브루트 포스</strong>: 구현이 매우 간단하고 직관적.</li><li><strong>백트래킹</strong>: 유망성 테스트와 가지치기 로직이 추가되어 상대적으로 구현이 복잡하다.</li></ul></li><li><p>성능 개선 가능성</p><ul><li><strong>브루트 포스</strong>: 모든 경우를 확인하므로 성능 개선의 여지가 적다.</li><li><strong>백트래킹</strong>: 더 효과적인 유망성 테스트와 가지치기 전략을 통해 성능을 크게 개선할 수 있다.</li></ul></li></ol><h3 id=실제-적용-사례-비교>실제 적용 사례 비교<a hidden class=anchor aria-hidden=true href=#실제-적용-사례-비교>#</a></h3><ol><li><p>스도쿠 퍼즐 해결</p><ol><li>브루트 포스 접근법<ul><li>각 빈 칸에 1부터 9까지 모든 숫자를 시도.</li><li>모든 가능한 조합을 확인하므로 9^n(n은 빈 칸의 수)의 시간 복잡도를 가진다.</li><li>규모가 큰 스도쿠(빈 칸이 많은 경우)에서는 비현실적으로 오래 걸린다.</li></ul></li><li>백트래킹 접근법<ul><li>각 빈 칸에 숫자를 채울 때마다 스도쿠 규칙(행, 열, 3x3 박스에 중복 없음)을 확인한다.</li><li>규칙을 위반하면 즉시 이전 단계로 돌아가 다른 숫자를 시도한다.</li><li>불가능한 경로를 조기에 차단하여 탐색 공간을 크게 줄인다.</li></ul></li></ol></li><li><p>조합 최적화 문제 (예: 배낭 문제)</p><ol><li>브루트 포스 접근법<ul><li>가능한 모든 물건의 조합(2^n)을 생성하고 각각의 가치와 무게를 계산한다.</li><li>제약 조건을 만족하는 조합 중 가장 높은 가치를 가진 조합을 선택한다.</li><li>물건의 수가 많아지면 시간 복잡도가 기하급수적으로 증가한다.</li></ul></li><li>백트래킹 접근법<ul><li>물건을 하나씩 선택하면서 현재까지의 무게와 가치를 추적한다.</li><li>무게 제한을 초과하거나, 현재 경로가 이미 찾은 최적해보다 좋을 가능성이 없으면 탐색을 중단한다.</li><li>가지치기를 통해 많은 불필요한 경로를 탐색하지 않아 효율성이 높아진다.</li></ul></li></ol></li></ol><h3 id=백트래킹과-브루트-포스의-비교>백트래킹과 브루트 포스의 비교<a hidden class=anchor aria-hidden=true href=#백트래킹과-브루트-포스의-비교>#</a></h3><table><thead><tr><th>특성</th><th>브루트 포스 (Brute Force)</th><th>백트래킹 (Backtracking)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>가능한 모든 경우의 수를 전부 확인하는 방법</td><td>불필요한 경로를 조기에 차단하며 해결책을 찾는 방법</td></tr><tr><td><strong>탐색 방식</strong></td><td>모든 가능한 해결책 후보를 나열하고 각각 검사</td><td>단계별로 해결책을 구성하며 유망성 테스트를 통해 가지치기</td></tr><tr><td><strong>시간 복잡도</strong></td><td>최악의 경우 O(m^n) 또는 O(n!) (m은 선택지 수, n은 단계 수)</td><td>최악의 경우 브루트 포스와 동일, 평균적으로 훨씬 우수</td></tr><tr><td><strong>공간 복잡도</strong></td><td>일반적으로 O(n)</td><td>재귀 호출로 인해 O(n)에서 O(m^n)까지 가능</td></tr><tr><td><strong>구현 복잡성</strong></td><td>매우 간단</td><td>상대적으로 복잡 (유망성 테스트 로직 필요)</td></tr><tr><td><strong>최적화 가능성</strong></td><td>제한적</td><td>유망성 테스트 개선, 휴리스틱 적용 등 다양한 최적화 가능</td></tr><tr><td><strong>완전성</strong></td><td>해결책이 존재한다면 항상 찾음</td><td>해결책이 존재한다면 항상 찾음</td></tr><tr><td><strong>적합한 문제 유형</strong></td><td>문제 크기가 작거나 다른 방법이 없는 경우</td><td>제약 조건이 많은 조합 최적화 문제, 결정 문제</td></tr><tr><td><strong>핵심 개념</strong></td><td>완전 탐색</td><td>유망성 테스트와 가지치기</td></tr><tr><td><strong>메모리 사용</strong></td><td>일반적으로 적음</td><td>재귀 호출 스택으로 인해 상대적으로 많음</td></tr><tr><td><strong>구현 방식</strong></td><td>반복문 또는 재귀</td><td>주로 재귀</td></tr><tr><td><strong>대표적 문제</strong></td><td>부분집합 생성, 순열 생성</td><td>N-Queens, 스도쿠, 그래프 색칠 문제</td></tr><tr><td><strong>성능 예측성</strong></td><td>문제 크기에 따라 정확히 예측 가능</td><td>문제 인스턴스와 가지치기 효율성에 따라 가변적</td></tr><tr><td><strong>병렬화 용이성</strong></td><td>쉬움 (독립적인 작업으로 분할 가능)</td><td>상대적으로 어려움 (의존성이 높음)</td></tr><tr><td><strong>가지치기 여부</strong></td><td>없음</td><td>있음 (핵심 특징)</td></tr><tr><td><strong>장점</strong></td><td>단순함, 구현 용이성, 완전성</td><td>효율성, 대규모 문제 해결 가능성</td></tr><tr><td><strong>단점</strong></td><td>비효율성, 대규모 문제에 부적합</td><td>구현 복잡성, 최악의 경우 성능 보장 없음</td></tr></tbody></table><h3 id=언제-어떤-방법을-사용해야-할까>언제 어떤 방법을 사용해야 할까?<a hidden class=anchor aria-hidden=true href=#언제-어떤-방법을-사용해야-할까>#</a></h3><ul><li>브루트 포스를 선택해야 할 때<ol><li>문제 크기가 작아 모든 경우를 확인하는 것이 부담이 없을 때</li><li>알고리즘의 단순성과 명확성이 성능보다 중요할 때</li><li>더 효율적인 알고리즘을 찾기 전 기준선(baseline)을 설정할 때</li><li>문제에 대한 이해가 부족하거나 더 나은 해결책이 떠오르지 않을 때</li></ol></li><li>백트래킹을 선택해야 할 때<ol><li>문제 크기가 커서 브루트 포스가 현실적으로 불가능할 때</li><li>문제에 명확한 제약 조건이 있어 가지치기가 효과적일 때</li><li>조합 최적화 문제나 결정 문제를 해결할 때</li><li>해결책의 효율성이 중요한 실제 응용 프로그램에서</li></ol></li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/back-tracking/>Back-Tracking</a></li><li><a href=https://buenhyden.github.io/tags/brute-force/>Brute-Force</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/python-vs-javascript-vs-typescript-vs-java/><span class=title>« Prev</span><br><span>Python vs Javascript vs Typescript vs Java</span>
</a><a class=next href=https://buenhyden.github.io/posts/systems/networking-and-communication/fundamentals/network-types/network-topologies/><span class=title>Next »</span><br><span>Network Topologies</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>