<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Back Tracking vs. Depth-First Search | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Back-Tracking,Depth-First-Search"><meta name=description content="DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Back Tracking vs. Depth-First Search"><meta property="og:description" content="DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-29T13:55:00+00:00"><meta property="article:modified_time" content="2024-12-29T13:55:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Back-Tracking"><meta property="article:tag" content="Depth-First-Search"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Back Tracking vs. Depth-First Search"><meta name=twitter:description content="DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"백트래킹 (Backtracking)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/"},{"@type":"ListItem","position":5,"name":"Back Tracking vs. Depth-First Search","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Back Tracking vs. Depth-First Search","name":"Back Tracking vs. Depth-First Search","description":"DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Back-Tracking","Depth-First-Search"],"articleBody":"Back Tracking vs. Depth-First Search 백트래킹과 깊이 우선 탐색은 모두 그래프나 트리 구조에서 해결책을 찾기 위한 알고리즘 기법이다.\nDFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.\n백트래킹은 DFS의 개념을 기반으로 하지만, 유망성 테스트와 가지치기라는 중요한 최적화 기법을 추가하여 탐색 공간을 줄이고 효율성을 높인다. 따라서 백트래킹은 DFS의 확장된 형태라고 볼 수 있다.\n깊이 우선 탐색(Depth-First Search, DFS) 깊이 우선 탐색은 그래프 탐색 알고리즘으로, 가능한 한 깊이 들어가면서 모든 노드를 방문하는 방법이다.\nDFS의 작동 방식:\n시작 노드를 스택에 넣고 ‘방문 완료’로 표시한다. 스택이 비어있지 않은 동안 다음을 반복한다: 스택의 최상위 노드를 꺼낸다. 해당 노드의 모든 인접 노드 중 방문하지 않은 노드를 스택에 넣고 ‘방문 완료’로 표시한다. 스택이 비면 탐색이 종료된다. DFS의 특징 완전 탐색: 연결된 모든 노드를 방문한다. 메모리 효율성: 현재 경로 상의 노드만 기억하므로 메모리 사용이 효율적이다. 재귀적 구현: 주로 재귀 함수로 구현되지만, 명시적인 스택을 사용할 수도 있다. 경로 발견: 시작 노드에서 임의의 노드까지의 경로를 찾는 데 유용하다. 사이클 감지: 그래프에서 사이클을 찾는 데 사용될 수 있다. DFS 예제: 그래프 탐색 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def dfs(graph, start, visited=None): if visited is None: visited = set() # 현재 노드를 방문 표시 visited.add(start) print(f\"방문: {start}\") # 인접 노드 탐색 for neighbor in graph[start]: if neighbor not in visited: dfs(graph, neighbor, visited) return visited # 예시 그래프 (인접 리스트 형태) graph = { 'A': ['B', 'C'], 'B': ['A', 'D', 'E'], 'C': ['A', 'F'], 'D': ['B'], 'E': ['B', 'F'], 'F': ['C', 'E'] } # DFS 수행 dfs(graph, 'A') 백트래킹(Backtracking) 백트래킹은 해결책을 찾는 과정에서 더 이상 유망하지 않은 경로를 만나면 즉시 이전 단계로 돌아가(백트랙) 다른 경로를 탐색하는 알고리즘이다.\n백트래킹의 작동 방식:\n해결책의 후보를 단계별로 구성한다. 각 단계에서 현재 후보가 유망한지(promising) 검사한다. 유망하지 않다면 즉시 탐색을 중단하고 이전 단계로 돌아간다(가지치기). 유망하다면 다음 단계로 진행한다. 해결책을 찾거나 모든 가능성을 탐색할 때까지 이 과정을 반복한다. 백트래킹의 특징 가지치기: 유망하지 않은 경로는 탐색하지 않고 가지치기를 통해 탐색 공간을 줄인다. 유망성 테스트: 현재 경로가 해결책으로 이어질 가능성이 있는지 평가한다. 재귀적 구현: 대부분 재귀 함수로 구현된다. 최적화: 불필요한 탐색을 줄여 효율성을 높인다. 제약 충족 문제: 제약 조건이 있는 문제 해결에 적합하다. 백트래킹 예제: N-Queens 문제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solve_n_queens(n): board = [-1] * n # board[i]는 i번째 행에서 퀸의 열 위치 solutions = [] def is_promising(row): for i in range(row): # 같은 열에 있거나 대각선 상에 있는지 확인 if board[i] == board[row] or abs(board[i] - board[row]) == row - i: return False return True def place_queen(row): if row == n: # 모든 퀸을 성공적으로 배치했을 때 solutions.append(board[:]) return for col in range(n): board[row] = col # row번째 행의 col번째 열에 퀸 배치 # 유망성 테스트: 현재 배치가 유망한 경우에만 다음 행으로 진행 if is_promising(row): place_queen(row + 1) place_queen(0) return solutions # 8-Queens 문제 해결 solutions = solve_n_queens(8) print(f\"해결책 수: {len(solutions)}\") DFS와 백트래킹의 주요 차이점 목적과 사용 사례\nDFS: 그래프의 모든 노드를 방문하거나, 특정 노드를 찾는 등 그래프 탐색이 주목적. 백트래킹: 제약 조건을 만족하는 해결책을 찾는 것이 주목적으로, 조합 최적화 문제나 결정 문제 해결에 사용된다. 가지치기(Pruning)\nDFS: 기본적인 DFS는 가지치기를 수행하지 않고 모든 경로를 탐색한다. 백트래킹: 유망성 테스트를 통해 유망하지 않은 경로는 탐색하지 않는 가지치기가 핵심. 효율성\nDFS: 모든 노드를 방문하므로 탐색 공간이 크면 비효율적일 수 있다. 백트래킹: 가지치기를 통해 탐색 공간을 줄여 DFS보다 효율적. 문제 해결 접근 방식\nDFS: 주로 그래프 관련 문제(경로 찾기, 연결 요소 찾기 등)에 사용. 백트래킹: 제약 충족 문제(스도쿠, N-Queens 등)나 조합 최적화 문제에 사용. 구현 차이\nDFS: 방문 여부를 추적하는 데 중점을 둔다. 백트래킹: 유망성 테스트와 상태 관리에 중점을 둔다. 실제 적용 사례 비교 미로 탐색 문제\nDFS 접근법 미로의 각 지점을 노드로, 이동 가능한 경로를 간선으로 표현. 시작점에서 출발하여 모든 가능한 경로를 깊이 우선으로 탐색. 이미 방문한 지점은 다시 방문하지 않는다. 목적지에 도달하면 성공, 모든 경로를 탐색해도 도달하지 못하면 실패. 백트래킹 접근법 DFS와 유사하게 시작하지만, 특정 경로가 유망하지 않다고 판단되면 즉시 탐색을 중단. 예를 들어, 현재까지의 이동 거리가 이미 알려진 최단 경로보다 길다면 해당 경로는 더 이상 탐색하지 않는다. 또는 현재 위치에서 목적지까지의 맨해튼 거리가 남은 이동 횟수보다 크다면 해당 경로는 탐색하지 않는다. 단어 검색 퍼즐(Word Search Puzzle)\nDFS 접근법 격자의 각 셀에서 시작하여 상, 하, 좌, 우, 대각선 방향으로 DFS를 수행. 이미 방문한 셀은 다시 방문하지 않는다. 목표 단어를 찾으면 성공, 모든 가능한 경로를 탐색해도 찾지 못하면 실패. 백트래킹 접근법 DFS와 비슷하게 시작하지만, 현재까지 형성된 문자열이 목표 단어의 접두사가 아니라면 즉시 탐색을 중단. 예를 들어, “APPLE\"을 찾는 중에 “APZ\"가 형성되면, 이는 “APPLE\"의 접두사가 아니므로 해당 경로는 더 이상 탐색하지 않는다. DFS와 백트래킹이 모두 사용되는 사례 일부 문제는 DFS와 백트래킹을 모두 활용하여 해결할 수 있다.\n예를 들어:\n순열/조합 생성 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def generate_permutations(elements): n = len(elements) result = [] used = [False] * n current = [] def backtrack(): if len(current) == n: result.append(current[:]) return for i in range(n): if used[i]: continue # 현재 원소 선택 used[i] = True current.append(elements[i]) # 다음 단계로 재귀 호출 (DFS) backtrack() # 백트래킹: 선택 취소 used[i] = False current.pop() backtrack() return result # 예시: [1, 2, 3]의 모든 순열 생성 permutations = generate_permutations([1, 2, 3]) print(permutations) 이 코드에서는 DFS를 사용하여 가능한 모든 순열을 탐색하면서, 백트래킹 기법(선택한 원소를 다시 취소하는 과정)을 함께 활용한다.\nDFS와 백트래킹을 결합한 고급 알고리즘 두 알고리즘의 장점을 결합한 고급 알고리즘도 존재한다:\n알파-베타 가지치기(Alpha-Beta Pruning) 미니맥스(Minimax) 알고리즘에 가지치기를 적용한 것으로, 게임 트리 탐색에 사용된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def minimax_alpha_beta(node, depth, alpha, beta, maximizing_player): if depth == 0 or is_terminal_node(node): return evaluate(node) if maximizing_player: max_eval = float('-inf') for child in get_children(node): eval = minimax_alpha_beta(child, depth - 1, alpha, beta, False) max_eval = max(max_eval, eval) alpha = max(alpha, eval) if beta \u003c= alpha: break # 베타 컷오프 (가지치기) return max_eval else: min_eval = float('inf') for child in get_children(node): eval = minimax_alpha_beta(child, depth - 1, alpha, beta, True) min_eval = min(min_eval, eval) beta = min(beta, eval) if beta \u003c= alpha: break # 알파 컷오프 (가지치기) return min_eval 분기한정법(Branch And Bound) 최적화 문제를 해결하기 위한 알고리즘으로, DFS에 하한(lower bound)과 상한(upper bound)을 사용한 가지치기를 적용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def branch_and_bound(node, best_solution): if is_leaf(node): if value(node) \u003e value(best_solution): best_solution = node return best_solution # 하한값 계산 lower_bound = calculate_lower_bound(node) # 가지치기: 현재 노드의 하한값이 현재 최적해보다 작으면 탐색 중단 if lower_bound \u003c= value(best_solution): return best_solution # DFS 계속 진행 for child in get_children(node): best_solution = branch_and_bound(child, best_solution) return best_solution DFS와 백트래킹의 관계 백트래킹은 DFS를 기반으로 하지만, 가지치기라는 중요한 최적화 기법이 추가된 알고리즘이다. 따라서 모든 백트래킹 알고리즘은 DFS를 사용하지만, 모든 DFS가 백트래킹인 것은 아니다.\nDFS는 그래프 탐색 알고리즘이라면, 백트래킹은 문제 해결 패러다임이라고 볼 수 있다. 백트래킹은 DFS의 개념을 확장하여 유망성 테스트와 가지치기를 통해 효율성을 높인 알고리즘이다.\n백트래킹과 DFS의 비교 특성 깊이 우선 탐색 (DFS) 백트래킹 (Backtracking) 정의 가능한 한 깊이 들어가면서 모든 노드를 방문하는 그래프 탐색 알고리즘 해결책을 찾는 과정에서 유망하지 않은 경로를 조기에 차단하는 알고리즘 주요 목적 그래프의 모든 노드 방문, 경로 찾기, 연결 요소 찾기 제약 조건을 만족하는 해결책 찾기, 조합 최적화 문제 해결 가지치기(Pruning) 여부 없음 (기본적으로 모든 경로 탐색) 있음 (핵심 특징) 유망성 테스트 없음 (단순히 방문 여부만 확인) 있음 (현재 경로가 해결책으로 이어질 가능성 평가) 시간 복잡도 O(V + E) (V: 노드 수, E: 간선 수) 문제에 따라 다양하지만, 가지치기로 인해 일반적으로 DFS보다 개선됨 공간 복잡도 O(V) (최악의 경우, V: 노드 수) O(d) (d: 최대 재귀 깊이) 활용 분야 그래프 알고리즘, 위상 정렬, 사이클 감지 순열/조합 생성, 스도쿠, N-Queens, 부분집합 합 문제 등 완전성 모든 노드를 방문함 가지치기로 일부 경로를 건너뛰지만, 해결책이 있다면 항상 찾음 구현 방식 재귀 또는 명시적 스택 주로 재귀 상태 관리 방문 여부 관리 현재 상태, 선택 이력, 제약 조건 만족 여부 등 복잡한 상태 관리 최적화 기법 방문 표시를 통한 중복 방문 방지 유망성 테스트, 가지치기, 휴리스틱 활용 등 다양한 최적화 메모리 사용 모든 노드의 방문 여부 기록 현재 경로 상의 노드와 상태 정보만 기록 적합한 문제 유형 그래프 탐색 문제 제약 충족 문제, 조합 최적화 문제 알고리즘 성격 그래프 탐색 알고리즘 문제 해결 패러다임 핵심 동작 스택 또는 재귀를 사용한 깊이 우선 탐색 시도-실패-되돌아가기(try-fail-backtrack) 반복 대표적 예제 그래프 탐색, 미로 찾기 N-Queens, 스도쿠, 부분집합 합 문제 종료 조건 모든 도달 가능한 노드 방문 해결책 발견 또는 모든 가능한 경로 탐색 중간 상태의 유효성 고려하지 않음 핵심적으로 고려 (유망성 테스트) 백트래킹 시점 더 이상 방문할 노드가 없을 때 유망하지 않은 상태에 도달했을 때 해결책 표현 일반적으로 경로 또는 방문 순서 상태 공간에서의 특정 경로 또는 선택 집합 언제 어떤 방법을 사용해야 할까? DFS를 선택해야 할 때 그래프의 모든 노드를 방문해야 할 때 그래프에서 경로를 찾거나 사이클을 감지해야 할 때 위상 정렬이 필요할 때 연결 요소를 찾아야 할 때 문제의 상태 공간이 명확한 그래프 구조를 가질 때 백트래킹을 선택해야 할 때 제약 조건을 만족하는 해결책을 찾아야 할 때 최적화 문제(예: 최소/최대값 찾기)를 해결해야 할 때 가능한 모든 조합을 생성해야 하지만, 제약 조건으로 인해 일부 조합이 불가능할 때 문제의 크기가 커서 효율적인 가지치기가 필요할 때 문제가 명확한 유망성 테스트를 정의할 수 있을 때 참고 및 출처 ","wordCount":"1535","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-29T13:55:00Z","dateModified":"2024-12-29T13:55:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/>백트래킹 (Backtracking)</a></div><h1 class="post-title entry-hint-parent">Back Tracking vs. Depth-First Search</h1><div class=post-description>DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.</div><div class=post-meta><span title='2024-12-29 13:55:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Back%20Tracking/back-tracking-vs-depth-first-search.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#back-tracking-vs-depth-first-search>Back Tracking vs. Depth-First Search</a><ul><li><a href=#깊이-우선-탐색depth-first-search-dfs>깊이 우선 탐색(Depth-First Search, DFS)</a></li><li><a href=#백트래킹backtracking>백트래킹(Backtracking)</a></li><li><a href=#dfs와-백트래킹의-주요-차이점>DFS와 백트래킹의 주요 차이점</a></li><li><a href=#실제-적용-사례-비교>실제 적용 사례 비교</a></li><li><a href=#dfs와-백트래킹이-모두-사용되는-사례>DFS와 백트래킹이 모두 사용되는 사례</a></li><li><a href=#dfs와-백트래킹을-결합한-고급-알고리즘>DFS와 백트래킹을 결합한 고급 알고리즘</a></li><li><a href=#dfs와-백트래킹의-관계>DFS와 백트래킹의 관계</a></li><li><a href=#백트래킹과-dfs의-비교>백트래킹과 DFS의 비교</a></li></ul></li><li><a href=#언제-어떤-방법을-사용해야-할까>언제 어떤 방법을 사용해야 할까?</a><ul><li><a href=#dfs를-선택해야-할-때>DFS를 선택해야 할 때</a></li><li><a href=#백트래킹을-선택해야-할-때>백트래킹을 선택해야 할 때</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=back-tracking-vs-depth-first-search>Back Tracking vs. Depth-First Search<a hidden class=anchor aria-hidden=true href=#back-tracking-vs-depth-first-search>#</a></h2><p>백트래킹과 깊이 우선 탐색은 모두 그래프나 트리 구조에서 해결책을 찾기 위한 알고리즘 기법이다.</p><p>DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.</p><p>백트래킹은 DFS의 개념을 기반으로 하지만, 유망성 테스트와 가지치기라는 중요한 최적화 기법을 추가하여 탐색 공간을 줄이고 효율성을 높인다. 따라서 백트래킹은 DFS의 확장된 형태라고 볼 수 있다.</p><h3 id=깊이-우선-탐색depth-first-search-dfs>깊이 우선 탐색(Depth-First Search, DFS)<a hidden class=anchor aria-hidden=true href=#깊이-우선-탐색depth-first-search-dfs>#</a></h3><p>깊이 우선 탐색은 그래프 탐색 알고리즘으로, 가능한 한 깊이 들어가면서 모든 노드를 방문하는 방법이다.</p><p>DFS의 작동 방식:</p><ol><li>시작 노드를 스택에 넣고 &lsquo;방문 완료&rsquo;로 표시한다.</li><li>스택이 비어있지 않은 동안 다음을 반복한다:<ul><li>스택의 최상위 노드를 꺼낸다.</li><li>해당 노드의 모든 인접 노드 중 방문하지 않은 노드를 스택에 넣고 &lsquo;방문 완료&rsquo;로 표시한다.</li></ul></li><li>스택이 비면 탐색이 종료된다.</li></ol><h4 id=dfs의-특징>DFS의 특징<a hidden class=anchor aria-hidden=true href=#dfs의-특징>#</a></h4><ul><li><strong>완전 탐색</strong>: 연결된 모든 노드를 방문한다.</li><li><strong>메모리 효율성</strong>: 현재 경로 상의 노드만 기억하므로 메모리 사용이 효율적이다.</li><li><strong>재귀적 구현</strong>: 주로 재귀 함수로 구현되지만, 명시적인 스택을 사용할 수도 있다.</li><li><strong>경로 발견</strong>: 시작 노드에서 임의의 노드까지의 경로를 찾는 데 유용하다.</li><li><strong>사이클 감지</strong>: 그래프에서 사이클을 찾는 데 사용될 수 있다.</li></ul><h4 id=dfs-예제-그래프-탐색>DFS 예제: 그래프 탐색<a hidden class=anchor aria-hidden=true href=#dfs-예제-그래프-탐색>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>visited</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>visited</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드를 방문 표시</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;방문: </span><span class=si>{</span><span class=n>start</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 인접 노드 탐색</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>start</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>visited</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시 그래프 (인접 리스트 형태)</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;A&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=s1>&#39;C&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;B&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=s1>&#39;D&#39;</span><span class=p>,</span> <span class=s1>&#39;E&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;C&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=s1>&#39;F&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;D&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;B&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;E&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=s1>&#39;F&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;F&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=s1>&#39;E&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># DFS 수행</span>
</span></span><span class=line><span class=cl><span class=n>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=s1>&#39;A&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=백트래킹backtracking>백트래킹(Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹backtracking>#</a></h3><p>백트래킹은 해결책을 찾는 과정에서 더 이상 유망하지 않은 경로를 만나면 즉시 이전 단계로 돌아가(백트랙) 다른 경로를 탐색하는 알고리즘이다.</p><p>백트래킹의 작동 방식:</p><ol><li>해결책의 후보를 단계별로 구성한다.</li><li>각 단계에서 현재 후보가 유망한지(promising) 검사한다.</li><li>유망하지 않다면 즉시 탐색을 중단하고 이전 단계로 돌아간다(가지치기).</li><li>유망하다면 다음 단계로 진행한다.</li><li>해결책을 찾거나 모든 가능성을 탐색할 때까지 이 과정을 반복한다.</li></ol><h4 id=백트래킹의-특징>백트래킹의 특징<a hidden class=anchor aria-hidden=true href=#백트래킹의-특징>#</a></h4><ul><li><strong>가지치기</strong>: 유망하지 않은 경로는 탐색하지 않고 가지치기를 통해 탐색 공간을 줄인다.</li><li><strong>유망성 테스트</strong>: 현재 경로가 해결책으로 이어질 가능성이 있는지 평가한다.</li><li><strong>재귀적 구현</strong>: 대부분 재귀 함수로 구현된다.</li><li><strong>최적화</strong>: 불필요한 탐색을 줄여 효율성을 높인다.</li><li><strong>제약 충족 문제</strong>: 제약 조건이 있는 문제 해결에 적합하다.</li></ul><h4 id=백트래킹-예제-n-queens-문제>백트래킹 예제: N-Queens 문제<a hidden class=anchor aria-hidden=true href=#백트래킹-예제-n-queens-문제>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>board</span> <span class=o>=</span> <span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># board[i]는 i번째 행에서 퀸의 열 위치</span>
</span></span><span class=line><span class=cl>    <span class=n>solutions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_promising</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 같은 열에 있거나 대각선 상에 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=ow>or</span> <span class=nb>abs</span><span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>])</span> <span class=o>==</span> <span class=n>row</span> <span class=o>-</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>place_queen</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>  <span class=c1># 모든 퀸을 성공적으로 배치했을 때</span>
</span></span><span class=line><span class=cl>            <span class=n>solutions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>board</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=n>col</span>  <span class=c1># row번째 행의 col번째 열에 퀸 배치</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 유망성 테스트: 현재 배치가 유망한 경우에만 다음 행으로 진행</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_promising</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>place_queen</span><span class=p>(</span><span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>place_queen</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solutions</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 8-Queens 문제 해결</span>
</span></span><span class=line><span class=cl><span class=n>solutions</span> <span class=o>=</span> <span class=n>solve_n_queens</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;해결책 수: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>solutions</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=dfs와-백트래킹의-주요-차이점>DFS와 백트래킹의 주요 차이점<a hidden class=anchor aria-hidden=true href=#dfs와-백트래킹의-주요-차이점>#</a></h3><ol><li><p>목적과 사용 사례</p><ul><li><strong>DFS</strong>: 그래프의 모든 노드를 방문하거나, 특정 노드를 찾는 등 그래프 탐색이 주목적.</li><li><strong>백트래킹</strong>: 제약 조건을 만족하는 해결책을 찾는 것이 주목적으로, 조합 최적화 문제나 결정 문제 해결에 사용된다.</li></ul></li><li><p>가지치기(Pruning)</p><ul><li><strong>DFS</strong>: 기본적인 DFS는 가지치기를 수행하지 않고 모든 경로를 탐색한다.</li><li><strong>백트래킹</strong>: 유망성 테스트를 통해 유망하지 않은 경로는 탐색하지 않는 가지치기가 핵심.</li></ul></li><li><p>효율성</p><ul><li><strong>DFS</strong>: 모든 노드를 방문하므로 탐색 공간이 크면 비효율적일 수 있다.</li><li><strong>백트래킹</strong>: 가지치기를 통해 탐색 공간을 줄여 DFS보다 효율적.</li></ul></li><li><p>문제 해결 접근 방식</p><ul><li><strong>DFS</strong>: 주로 그래프 관련 문제(경로 찾기, 연결 요소 찾기 등)에 사용.</li><li><strong>백트래킹</strong>: 제약 충족 문제(스도쿠, N-Queens 등)나 조합 최적화 문제에 사용.</li></ul></li><li><p>구현 차이</p><ul><li><strong>DFS</strong>: 방문 여부를 추적하는 데 중점을 둔다.</li><li><strong>백트래킹</strong>: 유망성 테스트와 상태 관리에 중점을 둔다.</li></ul></li></ol><h3 id=실제-적용-사례-비교>실제 적용 사례 비교<a hidden class=anchor aria-hidden=true href=#실제-적용-사례-비교>#</a></h3><ol><li><p>미로 탐색 문제</p><ol><li>DFS 접근법<ul><li>미로의 각 지점을 노드로, 이동 가능한 경로를 간선으로 표현.</li><li>시작점에서 출발하여 모든 가능한 경로를 깊이 우선으로 탐색.</li><li>이미 방문한 지점은 다시 방문하지 않는다.</li><li>목적지에 도달하면 성공, 모든 경로를 탐색해도 도달하지 못하면 실패.</li></ul></li><li>백트래킹 접근법<ul><li>DFS와 유사하게 시작하지만, 특정 경로가 유망하지 않다고 판단되면 즉시 탐색을 중단.</li><li>예를 들어, 현재까지의 이동 거리가 이미 알려진 최단 경로보다 길다면 해당 경로는 더 이상 탐색하지 않는다.</li><li>또는 현재 위치에서 목적지까지의 맨해튼 거리가 남은 이동 횟수보다 크다면 해당 경로는 탐색하지 않는다.</li></ul></li></ol></li><li><p>단어 검색 퍼즐(Word Search Puzzle)</p><ol><li>DFS 접근법<ul><li>격자의 각 셀에서 시작하여 상, 하, 좌, 우, 대각선 방향으로 DFS를 수행.</li><li>이미 방문한 셀은 다시 방문하지 않는다.</li><li>목표 단어를 찾으면 성공, 모든 가능한 경로를 탐색해도 찾지 못하면 실패.</li></ul></li><li>백트래킹 접근법<ul><li>DFS와 비슷하게 시작하지만, 현재까지 형성된 문자열이 목표 단어의 접두사가 아니라면 즉시 탐색을 중단.</li><li>예를 들어, &ldquo;APPLE"을 찾는 중에 &ldquo;APZ"가 형성되면, 이는 &ldquo;APPLE"의 접두사가 아니므로 해당 경로는 더 이상 탐색하지 않는다.</li></ul></li></ol></li></ol><h3 id=dfs와-백트래킹이-모두-사용되는-사례>DFS와 백트래킹이 모두 사용되는 사례<a hidden class=anchor aria-hidden=true href=#dfs와-백트래킹이-모두-사용되는-사례>#</a></h3><p>일부 문제는 DFS와 백트래킹을 모두 활용하여 해결할 수 있다.</p><p>예를 들어:</p><h4 id=순열조합-생성>순열/조합 생성<a hidden class=anchor aria-hidden=true href=#순열조합-생성>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_permutations</span><span class=p>(</span><span class=n>elements</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>elements</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>used</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>current</span><span class=p>)</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>used</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 현재 원소 선택</span>
</span></span><span class=line><span class=cl>            <span class=n>used</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>elements</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 다음 단계로 재귀 호출 (DFS)</span>
</span></span><span class=line><span class=cl>            <span class=n>backtrack</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 백트래킹: 선택 취소</span>
</span></span><span class=line><span class=cl>            <span class=n>used</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 예시: [1, 2, 3]의 모든 순열 생성</span>
</span></span><span class=line><span class=cl><span class=n>permutations</span> <span class=o>=</span> <span class=n>generate_permutations</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>permutations</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드에서는 DFS를 사용하여 가능한 모든 순열을 탐색하면서, 백트래킹 기법(선택한 원소를 다시 취소하는 과정)을 함께 활용한다.</p><h3 id=dfs와-백트래킹을-결합한-고급-알고리즘>DFS와 백트래킹을 결합한 고급 알고리즘<a hidden class=anchor aria-hidden=true href=#dfs와-백트래킹을-결합한-고급-알고리즘>#</a></h3><p>두 알고리즘의 장점을 결합한 고급 알고리즘도 존재한다:</p><h4 id=알파-베타-가지치기alpha-beta-pruning>알파-베타 가지치기(Alpha-Beta Pruning)<a hidden class=anchor aria-hidden=true href=#알파-베타-가지치기alpha-beta-pruning>#</a></h4><p>미니맥스(Minimax) 알고리즘에 가지치기를 적용한 것으로, 게임 트리 탐색에 사용된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>minimax_alpha_beta</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>depth</span><span class=p>,</span> <span class=n>alpha</span><span class=p>,</span> <span class=n>beta</span><span class=p>,</span> <span class=n>maximizing_player</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>depth</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>is_terminal_node</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>evaluate</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>maximizing_player</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>max_eval</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>get_children</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>eval</span> <span class=o>=</span> <span class=n>minimax_alpha_beta</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>depth</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>alpha</span><span class=p>,</span> <span class=n>beta</span><span class=p>,</span> <span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>max_eval</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_eval</span><span class=p>,</span> <span class=nb>eval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>alpha</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>alpha</span><span class=p>,</span> <span class=nb>eval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>beta</span> <span class=o>&lt;=</span> <span class=n>alpha</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>  <span class=c1># 베타 컷오프 (가지치기)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max_eval</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>min_eval</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>get_children</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>eval</span> <span class=o>=</span> <span class=n>minimax_alpha_beta</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>depth</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>alpha</span><span class=p>,</span> <span class=n>beta</span><span class=p>,</span> <span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>min_eval</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>min_eval</span><span class=p>,</span> <span class=nb>eval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>beta</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>beta</span><span class=p>,</span> <span class=nb>eval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>beta</span> <span class=o>&lt;=</span> <span class=n>alpha</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>  <span class=c1># 알파 컷오프 (가지치기)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>min_eval</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=분기한정법branch-and-bound>분기한정법(Branch And Bound)<a hidden class=anchor aria-hidden=true href=#분기한정법branch-and-bound>#</a></h4><p>최적화 문제를 해결하기 위한 알고리즘으로, DFS에 하한(lower bound)과 상한(upper bound)을 사용한 가지치기를 적용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>branch_and_bound</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>best_solution</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>is_leaf</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>value</span><span class=p>(</span><span class=n>node</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>value</span><span class=p>(</span><span class=n>best_solution</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>best_solution</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>best_solution</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 하한값 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>lower_bound</span> <span class=o>=</span> <span class=n>calculate_lower_bound</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 가지치기: 현재 노드의 하한값이 현재 최적해보다 작으면 탐색 중단</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>lower_bound</span> <span class=o>&lt;=</span> <span class=n>value</span><span class=p>(</span><span class=n>best_solution</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>best_solution</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># DFS 계속 진행</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>get_children</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>best_solution</span> <span class=o>=</span> <span class=n>branch_and_bound</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>best_solution</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>best_solution</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=dfs와-백트래킹의-관계>DFS와 백트래킹의 관계<a hidden class=anchor aria-hidden=true href=#dfs와-백트래킹의-관계>#</a></h3><p>백트래킹은 DFS를 기반으로 하지만, 가지치기라는 중요한 최적화 기법이 추가된 알고리즘이다. 따라서 모든 백트래킹 알고리즘은 DFS를 사용하지만, 모든 DFS가 백트래킹인 것은 아니다.</p><p>DFS는 그래프 탐색 알고리즘이라면, 백트래킹은 문제 해결 패러다임이라고 볼 수 있다. 백트래킹은 DFS의 개념을 확장하여 유망성 테스트와 가지치기를 통해 효율성을 높인 알고리즘이다.</p><h3 id=백트래킹과-dfs의-비교>백트래킹과 DFS의 비교<a hidden class=anchor aria-hidden=true href=#백트래킹과-dfs의-비교>#</a></h3><table><thead><tr><th>특성</th><th>깊이 우선 탐색 (DFS)</th><th>백트래킹 (Backtracking)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>가능한 한 깊이 들어가면서 모든 노드를 방문하는 그래프 탐색 알고리즘</td><td>해결책을 찾는 과정에서 유망하지 않은 경로를 조기에 차단하는 알고리즘</td></tr><tr><td><strong>주요 목적</strong></td><td>그래프의 모든 노드 방문, 경로 찾기, 연결 요소 찾기</td><td>제약 조건을 만족하는 해결책 찾기, 조합 최적화 문제 해결</td></tr><tr><td><strong>가지치기(Pruning) 여부</strong></td><td>없음 (기본적으로 모든 경로 탐색)</td><td>있음 (핵심 특징)</td></tr><tr><td><strong>유망성 테스트</strong></td><td>없음 (단순히 방문 여부만 확인)</td><td>있음 (현재 경로가 해결책으로 이어질 가능성 평가)</td></tr><tr><td><strong>시간 복잡도</strong></td><td>O(V + E) (V: 노드 수, E: 간선 수)</td><td>문제에 따라 다양하지만, 가지치기로 인해 일반적으로 DFS보다 개선됨</td></tr><tr><td><strong>공간 복잡도</strong></td><td>O(V) (최악의 경우, V: 노드 수)</td><td>O(d) (d: 최대 재귀 깊이)</td></tr><tr><td><strong>활용 분야</strong></td><td>그래프 알고리즘, 위상 정렬, 사이클 감지</td><td>순열/조합 생성, 스도쿠, N-Queens, 부분집합 합 문제 등</td></tr><tr><td><strong>완전성</strong></td><td>모든 노드를 방문함</td><td>가지치기로 일부 경로를 건너뛰지만, 해결책이 있다면 항상 찾음</td></tr><tr><td><strong>구현 방식</strong></td><td>재귀 또는 명시적 스택</td><td>주로 재귀</td></tr><tr><td><strong>상태 관리</strong></td><td>방문 여부 관리</td><td>현재 상태, 선택 이력, 제약 조건 만족 여부 등 복잡한 상태 관리</td></tr><tr><td><strong>최적화 기법</strong></td><td>방문 표시를 통한 중복 방문 방지</td><td>유망성 테스트, 가지치기, 휴리스틱 활용 등 다양한 최적화</td></tr><tr><td><strong>메모리 사용</strong></td><td>모든 노드의 방문 여부 기록</td><td>현재 경로 상의 노드와 상태 정보만 기록</td></tr><tr><td><strong>적합한 문제 유형</strong></td><td>그래프 탐색 문제</td><td>제약 충족 문제, 조합 최적화 문제</td></tr><tr><td><strong>알고리즘 성격</strong></td><td>그래프 탐색 알고리즘</td><td>문제 해결 패러다임</td></tr><tr><td><strong>핵심 동작</strong></td><td>스택 또는 재귀를 사용한 깊이 우선 탐색</td><td>시도-실패-되돌아가기(try-fail-backtrack) 반복</td></tr><tr><td><strong>대표적 예제</strong></td><td>그래프 탐색, 미로 찾기</td><td>N-Queens, 스도쿠, 부분집합 합 문제</td></tr><tr><td><strong>종료 조건</strong></td><td>모든 도달 가능한 노드 방문</td><td>해결책 발견 또는 모든 가능한 경로 탐색</td></tr><tr><td><strong>중간 상태의 유효성</strong></td><td>고려하지 않음</td><td>핵심적으로 고려 (유망성 테스트)</td></tr><tr><td><strong>백트래킹 시점</strong></td><td>더 이상 방문할 노드가 없을 때</td><td>유망하지 않은 상태에 도달했을 때</td></tr><tr><td><strong>해결책 표현</strong></td><td>일반적으로 경로 또는 방문 순서</td><td>상태 공간에서의 특정 경로 또는 선택 집합</td></tr></tbody></table><h2 id=언제-어떤-방법을-사용해야-할까>언제 어떤 방법을 사용해야 할까?<a hidden class=anchor aria-hidden=true href=#언제-어떤-방법을-사용해야-할까>#</a></h2><h3 id=dfs를-선택해야-할-때>DFS를 선택해야 할 때<a hidden class=anchor aria-hidden=true href=#dfs를-선택해야-할-때>#</a></h3><ol><li>그래프의 모든 노드를 방문해야 할 때</li><li>그래프에서 경로를 찾거나 사이클을 감지해야 할 때</li><li>위상 정렬이 필요할 때</li><li>연결 요소를 찾아야 할 때</li><li>문제의 상태 공간이 명확한 그래프 구조를 가질 때</li></ol><h3 id=백트래킹을-선택해야-할-때>백트래킹을 선택해야 할 때<a hidden class=anchor aria-hidden=true href=#백트래킹을-선택해야-할-때>#</a></h3><ol><li>제약 조건을 만족하는 해결책을 찾아야 할 때</li><li>최적화 문제(예: 최소/최대값 찾기)를 해결해야 할 때</li><li>가능한 모든 조합을 생성해야 하지만, 제약 조건으로 인해 일부 조합이 불가능할 때</li><li>문제의 크기가 커서 효율적인 가지치기가 필요할 때</li><li>문제가 명확한 유망성 테스트를 정의할 수 있을 때</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/back-tracking/>Back-Tracking</a></li><li><a href=https://buenhyden.github.io/tags/depth-first-search/>Depth-First-Search</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/system-design/architecture/system-design-and-architecture/><span class=title>« Prev</span><br><span>System Design and Architecture</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/><span class=title>Next »</span><br><span>Traversal 방법 비교</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>