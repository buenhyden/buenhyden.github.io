<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Back Tracking vs. Traversal | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Backtracking,Traversal"><meta name=description content="백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Back Tracking vs. Traversal"><meta property="og:description" content="백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-09T14:55:00+00:00"><meta property="article:modified_time" content="2024-12-09T14:55:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Problem-Solving-Techniques"><meta property="article:tag" content="Backtracking"><meta property="article:tag" content="Traversal"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Back Tracking vs. Traversal"><meta name=twitter:description content="백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"백트래킹 (Backtracking)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/"},{"@type":"ListItem","position":5,"name":"Back Tracking vs. Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Back Tracking vs. Traversal","name":"Back Tracking vs. Traversal","description":"백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.","keywords":["Data-Structures-and-Algorithms","Problem-Solving-Techniques","Backtracking","Traversal"],"articleBody":"Back Tracking vs. Traversal 백트래킹과 트래버설은 컴퓨터 과학에서 문제 해결과 데이터 구조 탐색에 사용되는 중요한 알고리즘 패러다임이다.\n두 기법은 겉보기에 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.\n백트래킹과 트래버설은 서로 다른 목적과 접근 방식을 가지고 있지만, 많은 복잡한 문제 해결에서 상호 보완적으로 사용된다.\n트래버설은 데이터 구조의 모든 요소를 효율적으로 방문하는 체계적인 방법을 제공하고, 백트래킹은 방대한 해결책 공간에서 효율적으로 유망한 해결책을 찾는 전략을 제공한다.\n실제 문제 해결에서는 두 개념의 장점을 결합하여 사용하는 것이 효과적이다.\n예를 들어, 그래프에서 특정 조건을 만족하는 경로를 찾기 위해 DFS나 BFS와 같은 트래버설 알고리즘으로 그래프를 탐색하면서, 백트래킹 기법을 활용하여 유망하지 않은 경로는 조기에 포기하는 방식이다.\n두 알고리즘 패러다임의 핵심 차이점을 이해하고, 문제의 특성에 맞게 적절히 선택하거나 결합하여 사용하는 것이 효과적인 알고리즘 설계의 중요한 부분이다. 백트래킹은 ‘해결책 탐색’에, 트래버설은 ‘체계적 방문’에 초점을 맞추고 있음을 기억하면, 두 개념의 역할과 적용 상황을 명확하게 구분할 수 있다.\n백트래킹(Backtracking) 백트래킹은 가능한 모든 해결책을 탐색하는 알고리즘적 패러다임으로, 현재 해결책이 유망하지 않다고 판단되면 이전 상태로 돌아가(백트랙) 다른 가능성을 탐색한다.\n백트래킹은 일종의 “시행착오” 방법으로, 문제의 해결책을 찾기 위해 점진적으로 후보군을 구축하되, 후보가 해결책의 조건을 만족시키지 못할 경우 이를 포기하고 다른 후보를 탐색한다.\n기본적인 백트래킹 알고리즘의 형태는 다음과 같다:\n현재 상태가 해결책인지 확인(기저 조건) 그렇다면 해결책 반환 그렇지 않다면:\na. 가능한 모든 후보 선택지 생성\nb. 각 후보에 대해:\ni. 해당 후보가 유망한지(promising) 확인\nii. 유망하다면 해당 후보를 선택하고 재귀적으로 탐색 계속\niii. 해결책을 찾지 못했다면 해당 선택을 취소(백트랙)하고 다음 후보 시도 트래버설(Traversal) 트래버설은 데이터 구조의 모든 요소를 체계적으로 방문하는 과정을 의미한다.\n특히 트리, 그래프와 같은 비선형 데이터 구조에서 모든 노드를 방문하는 방법을 정의한다.\n트래버설의 목적은 데이터 구조의 모든 요소를 빠짐없이 접근하여 처리하는 것.\n트래버설의 주요 유형:\n깊이 우선 탐색(DFS, Depth-First Search): 가능한 한 깊이 탐색한 후 백트래킹 너비 우선 탐색(BFS, Breadth-First Search): 같은 레벨의 노드를 모두 방문한 후 다음 레벨로 이동 트리 특화 트래버설: 전위(pre-order), 중위(in-order), 후위(post-order) 등 주요 차이점 목적과 용도\n백트래킹:\n주 목적: 조합적 문제에 대한 해결책 탐색 주요 용도: 제약 만족 문제, 순열과 조합 생성, 최적화 문제 특징: 가능한 모든 해결책을 체계적으로 탐색하되, 유망하지 않은 경로는 조기에 차단(가지치기)\n트래버설: 주 목적: 데이터 구조의 모든 요소 방문 주요 용도: 데이터 수집, 검색, 처리 특징: 데이터 구조의 모든 요소를 빠짐없이 방문하며, 일반적으로 모든 노드를 한 번씩 방문 동작 방식\n백트래킹:\n유망성 검사(promising test)가 핵심: 현재 경로가 해결책으로 이어질 가능성이 있는지 평가 가지치기(pruning)를 통해 탐색 공간 축소 결정 취소와 대안 탐색이 빈번하게 발생\n트래버설: 방문 순서와 방법이 핵심: 어떤 순서로 노드를 방문할지 결정 일반적으로 모든 노드를 방문하므로 가지치기가 없음 대개 단방향으로 진행(백트래킹은 선택적으로 발생) 구현 관점\n백트래킹:\n일반적으로 재귀 함수로 구현 상태 관리와 상태 변경 취소(undo) 메커니즘 필요 제약 조건과 유망성 검사 로직이 중요\n트래버설: 재귀 또는 반복(큐/스택 사용) 구현 가능 방문 여부를 추적하는 메커니즘 필요 다음 방문 노드 선택 로직이 중요 알고리즘 구조 비교 백트래킹 알고리즘 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def backtrack(candidate, depth): # 종료 조건 확인 if is_solution(candidate, depth): # 해결책 발견 process_solution(candidate) return True # 다음 단계에서 가능한 선택지 탐색 for next_candidate in get_candidates(candidate, depth): # 유망성 검사 if is_promising(next_candidate, depth): # 선택한 후보를 해결책에 추가 candidate.append(next_candidate) # 다음 단계 재귀 호출 if backtrack(candidate, depth + 1): return True # 해결책 찾음 # 백트래킹: 해당 후보를 제거하고 다른 후보 탐색 candidate.pop() return False # 해결책 못 찾음 트래버설 알고리즘 구조 (DFS 예시) 1 2 3 4 5 6 7 8 9 10 11 12 def dfs_traversal(node, visited=None): if visited is None: visited = set() # 노드 방문 처리 visited.add(node) process_node(node) # 인접 노드 방문 for neighbor in get_neighbors(node): if neighbor not in visited: dfs_traversal(neighbor, visited) 트래버설 알고리즘 구조 (BFS 예시) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from collections import deque def bfs_traversal(start_node): visited = set([start_node]) queue = deque([start_node]) while queue: node = queue.popleft() process_node(node) for neighbor in get_neighbors(node): if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) 주요 응용 사례 비교 백트래킹 응용 사례 N-Queen 문제: N x N 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제 스도쿠 풀이: 9x9 격자에 1~9까지의 숫자를 중복 없이 배치하는 문제 부분집합의 합(Subset Sum): 주어진 집합에서 특정 합을 만드는 부분집합 찾기 해밀턴 경로/사이클: 그래프에서 모든 정점을 정확히 한 번씩 방문하는 경로/사이클 찾기 조합 최적화 문제: 배낭 문제(Knapsack Problem), 외판원 문제(TSP) 등 트래버설 응용 사례 파일 시스템 탐색: 디렉토리와 파일 구조 순회 웹 크롤링: 웹 페이지와 링크 구조 탐색 그래프 알고리즘: 최단 경로, 연결 컴포넌트 찾기 트리 연산: 이진 트리의 전위/중위/후위 순회 직렬화/역직렬화: 트리나 그래프 구조의 직렬화 시간 및 공간 복잡도 비교 백트래킹\n시간 복잡도:\n최악의 경우: O(b^d), 여기서 b는 각 단계에서의 분기 수, d는 최대 깊이 실제로는 가지치기로 인해 이보다 훨씬 효율적일 수 있음\n공간 복잡도: O(d), 재귀 호출 스택의 깊이 트래버설\n시간 복잡도:\nDFS/BFS: O(V + E), 여기서 V는 정점(노드) 수, E는 간선 수 트리 트래버설: O(n), 여기서 n은 노드 수\n공간 복잡도: DFS: O(h) 또는 O(V), 여기서 h는 트리/그래프의 높이 BFS: O(w) 또는 O(V), 여기서 w는 트리/그래프의 최대 너비 구체적인 구현 예시 비교 백트래킹 예시: N-Queen 문제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def solve_n_queens(n): def is_safe(board, row, col): # 같은 열에 퀸이 있는지 확인 for i in range(row): if board[i] == col: return False # 대각선 위치에 퀸이 있는지 확인 if abs(board[i] - col) == abs(i - row): return False return True def backtrack(board, row): # 모든 퀸을 배치했으면 해결책 추가 if row == n: solutions.append(board[:]) return # 현재 행의 각 열에 퀸 배치 시도 for col in range(n): if is_safe(board, row, col): board[row] = col # 퀸 배치 backtrack(board, row + 1) # 다음 행으로 진행 # 백트래킹 (명시적으로 할 필요는 없지만 개념상 이 위치) solutions = [] backtrack([-1] * n, 0) return solutions 트래버설 예시: 이진 트리 순회 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # 전위 순회 (Pre-order Traversal) def preorder_traversal(root): result = [] def dfs(node): if not node: return # 현재 노드 처리 (전위: 노드 -\u003e 왼쪽 -\u003e 오른쪽) result.append(node.val) # 왼쪽 서브트리 순회 dfs(node.left) # 오른쪽 서브트리 순회 dfs(node.right) dfs(root) return result # 중위 순회 (In-order Traversal) def inorder_traversal(root): result = [] def dfs(node): if not node: return # 왼쪽 서브트리 순회 dfs(node.left) # 현재 노드 처리 (중위: 왼쪽 -\u003e 노드 -\u003e 오른쪽) result.append(node.val) # 오른쪽 서브트리 순회 dfs(node.right) dfs(root) return result # 후위 순회 (Post-order Traversal) def postorder_traversal(root): result = [] def dfs(node): if not node: return # 왼쪽 서브트리 순회 dfs(node.left) # 오른쪽 서브트리 순회 dfs(node.right) # 현재 노드 처리 (후위: 왼쪽 -\u003e 오른쪽 -\u003e 노드) result.append(node.val) dfs(root) return result 실제 문제 해결에서의 차이점 백트래킹 적용 시나리오 스도쿠 풀이를 예로 들면:\n빈 칸에 1~9 중 하나의 숫자를 시도 해당 숫자가 행, 열, 3x3 박스에서 유효한지 확인(유망성 검사) 유효하면 다음 빈 칸으로 진행, 그렇지 않으면 다른 숫자 시도 모든 숫자가 유효하지 않으면 이전 빈 칸으로 돌아가 다른 숫자 시도(백트래킹) 트래버설 적용 시나리오 파일 시스템 탐색을 예로 들면:\n루트 디렉토리에서 시작하여 모든 파일과 폴더를 방문 DFS 방식: 각 폴더를 발견하면 즉시 해당 폴더로 들어가 탐색 BFS 방식: 현재 레벨의 모든 파일과 폴더를 먼저 처리한 후 다음 레벨의 폴더로 이동 각 파일이나 폴더를 발견하면 필요한 작업 수행(예: 파일 크기 계산, 검색 등) 관계성 및 결합 사용 백트래킹과 트래버설은 서로 독립적인 개념이지만, 많은 경우 함께 사용되거나 겹치는 부분이 있다:\nDFS와 백트래킹: 깊이 우선 탐색은 백트래킹의 기본 구조로 사용된다. 백트래킹은 DFS에 ‘유망성 검사’와 ‘가지치기’를 추가한 개념으로 볼 수 있다.\n그래프 문제에서의 결합: 그래프에서 특정 조건을 만족하는 경로를 찾는 문제는 트래버설 방식으로 그래프를 탐색하면서 백트래킹을 활용하여 유망하지 않은 경로를 제외한다.\n트리 기반 백트래킹: 결정 트리를 탐색하는 많은 백트래킹 알고리즘은 본질적으로 트리 트래버설 알고리즘이기도 하다.\n효율성 개선 기법 비교 백트래킹의 효율성 개선 지능적인 가지치기: 더 강력한 유망성 검사를 통해 빨리 무의미한 경로 제거 순서 최적화: 더 유망한 후보를 먼저 시도하여 해결책을 빨리 찾기 메모이제이션(Memoization): 이미 계산된 상태 저장하여 중복 계산 방지 제약 전파(Constraint Propagation): 하나의 선택이 다른 선택에 미치는 영향을 미리 계산 트래버설의 효율성 개선 방문 여부 최적화: 효율적인 방문 여부 체크 메커니즘 사용 방문 순서 최적화: 특정 애플리케이션에 맞는 방문 순서 선택 반복적 구현: 재귀보다 반복적 구현으로 콜 스택 오버플로우 방지 병렬 처리: 독립적인 서브트리나 컴포넌트를 병렬로 처리 백트래킹(Backtracking)과 트래버설(Traversal) 비교 분석표 개념적 차이: 백트래킹은 “문제 해결 전략” 트래버설은 “데이터 구조 탐색 방법” 활용 목적: 백트래킹: 특정 조건을 만족하는 해결책 탐색 트래버설: 데이터 구조의 모든 요소 방문 및 처리 효율성 관점: 백트래킹: 가지치기를 통해 불필요한 탐색 제거 트래버설: 모든 요소 방문이 목적이므로 가지치기 개념 없음 구현 관점: 백트래킹: 상태 관리와 복원이 복잡 트래버설: 비교적 단순한 구현 구조 적용 분야: 백트래킹: 조합 최적화, 퍼즐 해결, 게임 이론 트래버설: 데이터 수집, 처리, 검색, 직렬화 비교 항목 백트래킹(Backtracking) 트래버설(Traversal) 기본 개념 가능한 모든 해결책을 탐색하며, 유망하지 않은 경로는 포기하고 이전 상태로 돌아가는 알고리즘적 패러다임 데이터 구조의 모든 요소를 체계적으로 방문하는 과정 주요 목적 조합적 문제의 해결책 탐색, 제약 만족 문제 해결 데이터 구조의 모든 요소 접근 및 처리 핵심 특징 유망성 검사(promising test)와 가지치기(pruning) 방문 순서와 방법(전략) 탐색 방식 깊이 우선 탐색 기반, 필요시 이전 상태로 돌아감 깊이 우선(DFS) 또는 너비 우선(BFS) 방식 가능 모든 요소 방문 반드시 모든 요소를 방문하지 않음(가지치기) 일반적으로 모든 요소를 방문 시간 복잡도 최악의 경우 O(b^d), 실제로는 가지치기로 개선 DFS/BFS: O(V+E), 트리: O(n) 공간 복잡도 O(d), 재귀 호출 스택의 깊이 DFS: O(h), BFS: O(w) 구현 방식 일반적으로 재귀 함수 사용 재귀 또는 반복(스택/큐) 구현 가능 상태 관리 상태 변경 및 변경 취소(undo) 필요 주로 방문 여부만 추적 적용 데이터 구조 상태 공간 트리, 그래프 트리, 그래프, 다차원 배열 등 대표적 문제 N-Queen, 스도쿠, 조합 최적화 문제 파일 시스템 탐색, 웹 크롤링, 트리 순회 주요 변형 분기 한정법(Branch and Bound), 제약 만족 문제(CSP) 전위(pre-order), 중위(in-order), 후위(post-order), 레벨 순회 결정 취소 명시적 백트래킹 필요 (상태 복원) 일반적으로 필요 없음 최적화 기법 지능적 가지치기, 순서 최적화, 메모이제이션 효율적 방문 체크, 방문 순서 최적화, 병렬 처리 완전성 모든 가능한 해결책 탐색 가능 모든 요소 방문 보장 DFS와의 관계 DFS에 유망성 검사와 가지치기를 추가한 개념 DFS는 트래버설의 한 유형 종료 조건 해결책 발견 또는 모든 가능성 소진 모든 요소 방문 완료 반환 값 일반적으로 해결책 또는 해결책 목록 방문한 요소 목록 또는 처리 결과 수행 동작 선택 → 검사 → 진행/백트랙 → 반복 방문 → 처리 → 다음 요소로 이동 → 반복 실행 과정 시각화 결정 트리에서 가능한 경로 탐색 데이터 구조를 따라 순차적 이동 참고 및 출처 ","wordCount":"1751","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-09T14:55:00Z","dateModified":"2024-12-09T14:55:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/>백트래킹 (Backtracking)</a></div><h1 class="post-title entry-hint-parent">Back Tracking vs. Traversal</h1><div class=post-description>백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.</div><div class=post-meta><span title='2024-12-09 14:55:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Problem%20Solving%20Techniques/Back%20Tracking/back-tracking-vs-Traversal.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#back-tracking-vs-traversal>Back Tracking vs. Traversal</a><ul><li><a href=#백트래킹backtracking>백트래킹(Backtracking)</a></li><li><a href=#트래버설traversal>트래버설(Traversal)</a></li><li><a href=#주요-차이점>주요 차이점</a></li><li><a href=#알고리즘-구조-비교>알고리즘 구조 비교</a></li><li><a href=#주요-응용-사례-비교>주요 응용 사례 비교</a></li><li><a href=#시간-및-공간-복잡도-비교>시간 및 공간 복잡도 비교</a></li><li><a href=#구체적인-구현-예시-비교>구체적인 구현 예시 비교</a></li><li><a href=#실제-문제-해결에서의-차이점>실제 문제 해결에서의 차이점</a></li><li><a href=#관계성-및-결합-사용>관계성 및 결합 사용</a></li><li><a href=#효율성-개선-기법-비교>효율성 개선 기법 비교</a></li><li><a href=#백트래킹backtracking과-트래버설traversal-비교-분석표>백트래킹(Backtracking)과 트래버설(Traversal) 비교 분석표</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=back-tracking-vs-traversal>Back Tracking vs. Traversal<a hidden class=anchor aria-hidden=true href=#back-tracking-vs-traversal>#</a></h2><p>백트래킹과 트래버설은 컴퓨터 과학에서 문제 해결과 데이터 구조 탐색에 사용되는 중요한 알고리즘 패러다임이다.<br>두 기법은 겉보기에 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.</p><p>백트래킹과 트래버설은 서로 다른 목적과 접근 방식을 가지고 있지만, 많은 복잡한 문제 해결에서 상호 보완적으로 사용된다.<br>트래버설은 데이터 구조의 모든 요소를 효율적으로 방문하는 체계적인 방법을 제공하고, 백트래킹은 방대한 해결책 공간에서 효율적으로 유망한 해결책을 찾는 전략을 제공한다.</p><p>실제 문제 해결에서는 두 개념의 장점을 결합하여 사용하는 것이 효과적이다.<br>예를 들어, 그래프에서 특정 조건을 만족하는 경로를 찾기 위해 DFS나 BFS와 같은 트래버설 알고리즘으로 그래프를 탐색하면서, 백트래킹 기법을 활용하여 유망하지 않은 경로는 조기에 포기하는 방식이다.</p><p>두 알고리즘 패러다임의 핵심 차이점을 이해하고, 문제의 특성에 맞게 적절히 선택하거나 결합하여 사용하는 것이 효과적인 알고리즘 설계의 중요한 부분이다. 백트래킹은 &lsquo;해결책 탐색&rsquo;에, 트래버설은 &lsquo;체계적 방문&rsquo;에 초점을 맞추고 있음을 기억하면, 두 개념의 역할과 적용 상황을 명확하게 구분할 수 있다.</p><h3 id=백트래킹backtracking>백트래킹(Backtracking)<a hidden class=anchor aria-hidden=true href=#백트래킹backtracking>#</a></h3><p>백트래킹은 가능한 모든 해결책을 탐색하는 알고리즘적 패러다임으로, 현재 해결책이 유망하지 않다고 판단되면 이전 상태로 돌아가(백트랙) 다른 가능성을 탐색한다.<br>백트래킹은 일종의 &ldquo;시행착오&rdquo; 방법으로, 문제의 해결책을 찾기 위해 점진적으로 후보군을 구축하되, 후보가 해결책의 조건을 만족시키지 못할 경우 이를 포기하고 다른 후보를 탐색한다.</p><p>기본적인 백트래킹 알고리즘의 형태는 다음과 같다:</p><ol><li>현재 상태가 해결책인지 확인(기저 조건)</li><li>그렇다면 해결책 반환</li><li>그렇지 않다면:<br>a. 가능한 모든 후보 선택지 생성<br>b. 각 후보에 대해:<br>i. 해당 후보가 유망한지(promising) 확인<br>ii. 유망하다면 해당 후보를 선택하고 재귀적으로 탐색 계속<br>iii. 해결책을 찾지 못했다면 해당 선택을 취소(백트랙)하고 다음 후보 시도</li></ol><h3 id=트래버설traversal>트래버설(Traversal)<a hidden class=anchor aria-hidden=true href=#트래버설traversal>#</a></h3><p>트래버설은 데이터 구조의 모든 요소를 체계적으로 방문하는 과정을 의미한다.<br>특히 트리, 그래프와 같은 비선형 데이터 구조에서 모든 노드를 방문하는 방법을 정의한다.<br>트래버설의 목적은 데이터 구조의 모든 요소를 빠짐없이 접근하여 처리하는 것.</p><p>트래버설의 주요 유형:</p><ol><li>깊이 우선 탐색(DFS, Depth-First Search): 가능한 한 깊이 탐색한 후 백트래킹</li><li>너비 우선 탐색(BFS, Breadth-First Search): 같은 레벨의 노드를 모두 방문한 후 다음 레벨로 이동</li><li>트리 특화 트래버설: 전위(pre-order), 중위(in-order), 후위(post-order) 등</li></ol><h3 id=주요-차이점>주요 차이점<a hidden class=anchor aria-hidden=true href=#주요-차이점>#</a></h3><ol><li><p>목적과 용도<br><strong>백트래킹</strong>:</p><ul><li>주 목적: 조합적 문제에 대한 해결책 탐색</li><li>주요 용도: 제약 만족 문제, 순열과 조합 생성, 최적화 문제</li><li>특징: 가능한 모든 해결책을 체계적으로 탐색하되, 유망하지 않은 경로는 조기에 차단(가지치기)<br><strong>트래버설</strong>:</li><li>주 목적: 데이터 구조의 모든 요소 방문</li><li>주요 용도: 데이터 수집, 검색, 처리</li><li>특징: 데이터 구조의 모든 요소를 빠짐없이 방문하며, 일반적으로 모든 노드를 한 번씩 방문</li></ul></li><li><p>동작 방식<br><strong>백트래킹</strong>:</p><ul><li>유망성 검사(promising test)가 핵심: 현재 경로가 해결책으로 이어질 가능성이 있는지 평가</li><li>가지치기(pruning)를 통해 탐색 공간 축소</li><li>결정 취소와 대안 탐색이 빈번하게 발생<br><strong>트래버설</strong>:</li><li>방문 순서와 방법이 핵심: 어떤 순서로 노드를 방문할지 결정</li><li>일반적으로 모든 노드를 방문하므로 가지치기가 없음</li><li>대개 단방향으로 진행(백트래킹은 선택적으로 발생)</li></ul></li><li><p>구현 관점<br><strong>백트래킹</strong>:</p><ul><li>일반적으로 재귀 함수로 구현</li><li>상태 관리와 상태 변경 취소(undo) 메커니즘 필요</li><li>제약 조건과 유망성 검사 로직이 중요<br><strong>트래버설</strong>:</li><li>재귀 또는 반복(큐/스택 사용) 구현 가능</li><li>방문 여부를 추적하는 메커니즘 필요</li><li>다음 방문 노드 선택 로직이 중요</li></ul></li></ol><h3 id=알고리즘-구조-비교>알고리즘 구조 비교<a hidden class=anchor aria-hidden=true href=#알고리즘-구조-비교>#</a></h3><h4 id=백트래킹-알고리즘-구조>백트래킹 알고리즘 구조<a hidden class=anchor aria-hidden=true href=#백트래킹-알고리즘-구조>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 종료 조건 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>is_solution</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 해결책 발견</span>
</span></span><span class=line><span class=cl>        <span class=n>process_solution</span><span class=p>(</span><span class=n>candidate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 다음 단계에서 가능한 선택지 탐색</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>next_candidate</span> <span class=ow>in</span> <span class=n>get_candidates</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 유망성 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_promising</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>,</span> <span class=n>depth</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 선택한 후보를 해결책에 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>candidate</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>next_candidate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 다음 단계 재귀 호출</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>backtrack</span><span class=p>(</span><span class=n>candidate</span><span class=p>,</span> <span class=n>depth</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>  <span class=c1># 해결책 찾음</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 백트래킹: 해당 후보를 제거하고 다른 후보 탐색</span>
</span></span><span class=line><span class=cl>            <span class=n>candidate</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>  <span class=c1># 해결책 못 찾음</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=트래버설-알고리즘-구조-dfs-예시>트래버설 알고리즘 구조 (DFS 예시)<a hidden class=anchor aria-hidden=true href=#트래버설-알고리즘-구조-dfs-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs_traversal</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>visited</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>visited</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 노드 방문 처리</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>process_node</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 인접 노드 방문</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>get_neighbors</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs_traversal</span><span class=p>(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=트래버설-알고리즘-구조-bfs-예시>트래버설 알고리즘 구조 (BFS 예시)<a hidden class=anchor aria-hidden=true href=#트래버설-알고리즘-구조-bfs-예시>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfs_traversal</span><span class=p>(</span><span class=n>start_node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>([</span><span class=n>start_node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>start_node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>process_node</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>get_neighbors</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=주요-응용-사례-비교>주요 응용 사례 비교<a hidden class=anchor aria-hidden=true href=#주요-응용-사례-비교>#</a></h3><h4 id=백트래킹-응용-사례>백트래킹 응용 사례<a hidden class=anchor aria-hidden=true href=#백트래킹-응용-사례>#</a></h4><ol><li><strong>N-Queen 문제</strong>: N x N 체스판에 N개의 퀸을 서로 공격할 수 없게 배치하는 문제</li><li><strong>스도쿠 풀이</strong>: 9x9 격자에 1~9까지의 숫자를 중복 없이 배치하는 문제</li><li><strong>부분집합의 합(Subset Sum)</strong>: 주어진 집합에서 특정 합을 만드는 부분집합 찾기</li><li><strong>해밀턴 경로/사이클</strong>: 그래프에서 모든 정점을 정확히 한 번씩 방문하는 경로/사이클 찾기</li><li><strong>조합 최적화 문제</strong>: 배낭 문제(Knapsack Problem), 외판원 문제(TSP) 등</li></ol><h4 id=트래버설-응용-사례>트래버설 응용 사례<a hidden class=anchor aria-hidden=true href=#트래버설-응용-사례>#</a></h4><ol><li><strong>파일 시스템 탐색</strong>: 디렉토리와 파일 구조 순회</li><li><strong>웹 크롤링</strong>: 웹 페이지와 링크 구조 탐색</li><li><strong>그래프 알고리즘</strong>: 최단 경로, 연결 컴포넌트 찾기</li><li><strong>트리 연산</strong>: 이진 트리의 전위/중위/후위 순회</li><li><strong>직렬화/역직렬화</strong>: 트리나 그래프 구조의 직렬화</li></ol><h3 id=시간-및-공간-복잡도-비교>시간 및 공간 복잡도 비교<a hidden class=anchor aria-hidden=true href=#시간-및-공간-복잡도-비교>#</a></h3><ol><li><p>백트래킹<br><strong>시간 복잡도</strong>:</p><ul><li>최악의 경우: O(b^d), 여기서 b는 각 단계에서의 분기 수, d는 최대 깊이</li><li>실제로는 가지치기로 인해 이보다 훨씬 효율적일 수 있음<br><strong>공간 복잡도</strong>:</li><li>O(d), 재귀 호출 스택의 깊이</li></ul></li><li><p>트래버설<br><strong>시간 복잡도</strong>:</p><ul><li>DFS/BFS: O(V + E), 여기서 V는 정점(노드) 수, E는 간선 수</li><li>트리 트래버설: O(n), 여기서 n은 노드 수<br><strong>공간 복잡도</strong>:</li><li>DFS: O(h) 또는 O(V), 여기서 h는 트리/그래프의 높이</li><li>BFS: O(w) 또는 O(V), 여기서 w는 트리/그래프의 최대 너비</li></ul></li></ol><h3 id=구체적인-구현-예시-비교>구체적인 구현 예시 비교<a hidden class=anchor aria-hidden=true href=#구체적인-구현-예시-비교>#</a></h3><h4 id=백트래킹-예시-n-queen-문제>백트래킹 예시: N-Queen 문제<a hidden class=anchor aria-hidden=true href=#백트래킹-예시-n-queen-문제>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_n_queens</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_safe</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 같은 열에 퀸이 있는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>col</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 대각선 위치에 퀸이 있는지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>abs</span><span class=p>(</span><span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>col</span><span class=p>)</span> <span class=o>==</span> <span class=nb>abs</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 퀸을 배치했으면 해결책 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row</span> <span class=o>==</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>solutions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>board</span><span class=p>[:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 행의 각 열에 퀸 배치 시도</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>col</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>is_safe</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>board</span><span class=p>[</span><span class=n>row</span><span class=p>]</span> <span class=o>=</span> <span class=n>col</span>  <span class=c1># 퀸 배치</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>board</span><span class=p>,</span> <span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 다음 행으로 진행</span>
</span></span><span class=line><span class=cl>                <span class=c1># 백트래킹 (명시적으로 할 필요는 없지만 개념상 이 위치)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=n>solutions</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>backtrack</span><span class=p>([</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solutions</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=트래버설-예시-이진-트리-순회>트래버설 예시: 이진 트리 순회<a hidden class=anchor aria-hidden=true href=#트래버설-예시-이진-트리-순회>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span><span class=lnt id=hl-4-47><a class=lnlinks href=#hl-4-47>47</a>
</span><span class=lnt id=hl-4-48><a class=lnlinks href=#hl-4-48>48</a>
</span><span class=lnt id=hl-4-49><a class=lnlinks href=#hl-4-49>49</a>
</span><span class=lnt id=hl-4-50><a class=lnlinks href=#hl-4-50>50</a>
</span><span class=lnt id=hl-4-51><a class=lnlinks href=#hl-4-51>51</a>
</span><span class=lnt id=hl-4-52><a class=lnlinks href=#hl-4-52>52</a>
</span><span class=lnt id=hl-4-53><a class=lnlinks href=#hl-4-53>53</a>
</span><span class=lnt id=hl-4-54><a class=lnlinks href=#hl-4-54>54</a>
</span><span class=lnt id=hl-4-55><a class=lnlinks href=#hl-4-55>55</a>
</span><span class=lnt id=hl-4-56><a class=lnlinks href=#hl-4-56>56</a>
</span><span class=lnt id=hl-4-57><a class=lnlinks href=#hl-4-57>57</a>
</span><span class=lnt id=hl-4-58><a class=lnlinks href=#hl-4-58>58</a>
</span><span class=lnt id=hl-4-59><a class=lnlinks href=#hl-4-59>59</a>
</span><span class=lnt id=hl-4-60><a class=lnlinks href=#hl-4-60>60</a>
</span><span class=lnt id=hl-4-61><a class=lnlinks href=#hl-4-61>61</a>
</span><span class=lnt id=hl-4-62><a class=lnlinks href=#hl-4-62>62</a>
</span><span class=lnt id=hl-4-63><a class=lnlinks href=#hl-4-63>63</a>
</span><span class=lnt id=hl-4-64><a class=lnlinks href=#hl-4-64>64</a>
</span><span class=lnt id=hl-4-65><a class=lnlinks href=#hl-4-65>65</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>TreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>left</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>right</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>val</span> <span class=o>=</span> <span class=n>val</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 전위 순회 (Pre-order Traversal)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>preorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 처리 (전위: 노드 -&gt; 왼쪽 -&gt; 오른쪽)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 중위 순회 (In-order Traversal)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 처리 (중위: 왼쪽 -&gt; 노드 -&gt; 오른쪽)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 후위 순회 (Post-order Traversal)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 처리 (후위: 왼쪽 -&gt; 오른쪽 -&gt; 노드)</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실제-문제-해결에서의-차이점>실제 문제 해결에서의 차이점<a hidden class=anchor aria-hidden=true href=#실제-문제-해결에서의-차이점>#</a></h3><h4 id=백트래킹-적용-시나리오>백트래킹 적용 시나리오<a hidden class=anchor aria-hidden=true href=#백트래킹-적용-시나리오>#</a></h4><p>스도쿠 풀이를 예로 들면:</p><ol><li>빈 칸에 1~9 중 하나의 숫자를 시도</li><li>해당 숫자가 행, 열, 3x3 박스에서 유효한지 확인(유망성 검사)</li><li>유효하면 다음 빈 칸으로 진행, 그렇지 않으면 다른 숫자 시도</li><li>모든 숫자가 유효하지 않으면 이전 빈 칸으로 돌아가 다른 숫자 시도(백트래킹)</li></ol><h4 id=트래버설-적용-시나리오>트래버설 적용 시나리오<a hidden class=anchor aria-hidden=true href=#트래버설-적용-시나리오>#</a></h4><p>파일 시스템 탐색을 예로 들면:</p><ol><li>루트 디렉토리에서 시작하여 모든 파일과 폴더를 방문</li><li>DFS 방식: 각 폴더를 발견하면 즉시 해당 폴더로 들어가 탐색</li><li>BFS 방식: 현재 레벨의 모든 파일과 폴더를 먼저 처리한 후 다음 레벨의 폴더로 이동</li><li>각 파일이나 폴더를 발견하면 필요한 작업 수행(예: 파일 크기 계산, 검색 등)</li></ol><h3 id=관계성-및-결합-사용>관계성 및 결합 사용<a hidden class=anchor aria-hidden=true href=#관계성-및-결합-사용>#</a></h3><p>백트래킹과 트래버설은 서로 독립적인 개념이지만, 많은 경우 함께 사용되거나 겹치는 부분이 있다:</p><ol><li><p><strong>DFS와 백트래킹</strong>: 깊이 우선 탐색은 백트래킹의 기본 구조로 사용된다. 백트래킹은 DFS에 &lsquo;유망성 검사&rsquo;와 &lsquo;가지치기&rsquo;를 추가한 개념으로 볼 수 있다.</p></li><li><p><strong>그래프 문제에서의 결합</strong>: 그래프에서 특정 조건을 만족하는 경로를 찾는 문제는 트래버설 방식으로 그래프를 탐색하면서 백트래킹을 활용하여 유망하지 않은 경로를 제외한다.</p></li><li><p><strong>트리 기반 백트래킹</strong>: 결정 트리를 탐색하는 많은 백트래킹 알고리즘은 본질적으로 트리 트래버설 알고리즘이기도 하다.</p></li></ol><h3 id=효율성-개선-기법-비교>효율성 개선 기법 비교<a hidden class=anchor aria-hidden=true href=#효율성-개선-기법-비교>#</a></h3><h4 id=백트래킹의-효율성-개선>백트래킹의 효율성 개선<a hidden class=anchor aria-hidden=true href=#백트래킹의-효율성-개선>#</a></h4><ol><li><strong>지능적인 가지치기</strong>: 더 강력한 유망성 검사를 통해 빨리 무의미한 경로 제거</li><li><strong>순서 최적화</strong>: 더 유망한 후보를 먼저 시도하여 해결책을 빨리 찾기</li><li><strong>메모이제이션(Memoization)</strong>: 이미 계산된 상태 저장하여 중복 계산 방지</li><li><strong>제약 전파(Constraint Propagation)</strong>: 하나의 선택이 다른 선택에 미치는 영향을 미리 계산</li></ol><h4 id=트래버설의-효율성-개선>트래버설의 효율성 개선<a hidden class=anchor aria-hidden=true href=#트래버설의-효율성-개선>#</a></h4><ol><li><strong>방문 여부 최적화</strong>: 효율적인 방문 여부 체크 메커니즘 사용</li><li><strong>방문 순서 최적화</strong>: 특정 애플리케이션에 맞는 방문 순서 선택</li><li><strong>반복적 구현</strong>: 재귀보다 반복적 구현으로 콜 스택 오버플로우 방지</li><li><strong>병렬 처리</strong>: 독립적인 서브트리나 컴포넌트를 병렬로 처리</li></ol><h3 id=백트래킹backtracking과-트래버설traversal-비교-분석표>백트래킹(Backtracking)과 트래버설(Traversal) 비교 분석표<a hidden class=anchor aria-hidden=true href=#백트래킹backtracking과-트래버설traversal-비교-분석표>#</a></h3><ol><li><strong>개념적 차이</strong>:<ul><li>백트래킹은 &ldquo;문제 해결 전략&rdquo;</li><li>트래버설은 &ldquo;데이터 구조 탐색 방법&rdquo;</li></ul></li><li><strong>활용 목적</strong>:<ul><li>백트래킹: 특정 조건을 만족하는 해결책 탐색</li><li>트래버설: 데이터 구조의 모든 요소 방문 및 처리</li></ul></li><li><strong>효율성 관점</strong>:<ul><li>백트래킹: 가지치기를 통해 불필요한 탐색 제거</li><li>트래버설: 모든 요소 방문이 목적이므로 가지치기 개념 없음</li></ul></li><li><strong>구현 관점</strong>:<ul><li>백트래킹: 상태 관리와 복원이 복잡</li><li>트래버설: 비교적 단순한 구현 구조</li></ul></li><li><strong>적용 분야</strong>:<ul><li>백트래킹: 조합 최적화, 퍼즐 해결, 게임 이론</li><li>트래버설: 데이터 수집, 처리, 검색, 직렬화</li></ul></li></ol><table><thead><tr><th>비교 항목</th><th>백트래킹(Backtracking)</th><th>트래버설(Traversal)</th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>가능한 모든 해결책을 탐색하며, 유망하지 않은 경로는 포기하고 이전 상태로 돌아가는 알고리즘적 패러다임</td><td>데이터 구조의 모든 요소를 체계적으로 방문하는 과정</td></tr><tr><td><strong>주요 목적</strong></td><td>조합적 문제의 해결책 탐색, 제약 만족 문제 해결</td><td>데이터 구조의 모든 요소 접근 및 처리</td></tr><tr><td><strong>핵심 특징</strong></td><td>유망성 검사(promising test)와 가지치기(pruning)</td><td>방문 순서와 방법(전략)</td></tr><tr><td><strong>탐색 방식</strong></td><td>깊이 우선 탐색 기반, 필요시 이전 상태로 돌아감</td><td>깊이 우선(DFS) 또는 너비 우선(BFS) 방식 가능</td></tr><tr><td><strong>모든 요소 방문</strong></td><td>반드시 모든 요소를 방문하지 않음(가지치기)</td><td>일반적으로 모든 요소를 방문</td></tr><tr><td><strong>시간 복잡도</strong></td><td>최악의 경우 O(b^d), 실제로는 가지치기로 개선</td><td>DFS/BFS: O(V+E), 트리: O(n)</td></tr><tr><td><strong>공간 복잡도</strong></td><td>O(d), 재귀 호출 스택의 깊이</td><td>DFS: O(h), BFS: O(w)</td></tr><tr><td><strong>구현 방식</strong></td><td>일반적으로 재귀 함수 사용</td><td>재귀 또는 반복(스택/큐) 구현 가능</td></tr><tr><td><strong>상태 관리</strong></td><td>상태 변경 및 변경 취소(undo) 필요</td><td>주로 방문 여부만 추적</td></tr><tr><td><strong>적용 데이터 구조</strong></td><td>상태 공간 트리, 그래프</td><td>트리, 그래프, 다차원 배열 등</td></tr><tr><td><strong>대표적 문제</strong></td><td>N-Queen, 스도쿠, 조합 최적화 문제</td><td>파일 시스템 탐색, 웹 크롤링, 트리 순회</td></tr><tr><td><strong>주요 변형</strong></td><td>분기 한정법(Branch and Bound), 제약 만족 문제(CSP)</td><td>전위(pre-order), 중위(in-order), 후위(post-order), 레벨 순회</td></tr><tr><td><strong>결정 취소</strong></td><td>명시적 백트래킹 필요 (상태 복원)</td><td>일반적으로 필요 없음</td></tr><tr><td><strong>최적화 기법</strong></td><td>지능적 가지치기, 순서 최적화, 메모이제이션</td><td>효율적 방문 체크, 방문 순서 최적화, 병렬 처리</td></tr><tr><td><strong>완전성</strong></td><td>모든 가능한 해결책 탐색 가능</td><td>모든 요소 방문 보장</td></tr><tr><td><strong>DFS와의 관계</strong></td><td>DFS에 유망성 검사와 가지치기를 추가한 개념</td><td>DFS는 트래버설의 한 유형</td></tr><tr><td><strong>종료 조건</strong></td><td>해결책 발견 또는 모든 가능성 소진</td><td>모든 요소 방문 완료</td></tr><tr><td><strong>반환 값</strong></td><td>일반적으로 해결책 또는 해결책 목록</td><td>방문한 요소 목록 또는 처리 결과</td></tr><tr><td><strong>수행 동작</strong></td><td>선택 → 검사 → 진행/백트랙 → 반복</td><td>방문 → 처리 → 다음 요소로 이동 → 반복</td></tr><tr><td><strong>실행 과정 시각화</strong></td><td>결정 트리에서 가능한 경로 탐색</td><td>데이터 구조를 따라 순차적 이동</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/problem-solving-techniques/>Problem-Solving-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/backtracking/>Backtracking</a></li><li><a href=https://buenhyden.github.io/tags/traversal/>Traversal</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/fundamentals/encoding-and-decoding/character/types/euc-kr/><span class=title>« Prev</span><br><span>EUC-KR</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/level-order-traversal/><span class=title>Next »</span><br><span>Level Order Traversal</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>