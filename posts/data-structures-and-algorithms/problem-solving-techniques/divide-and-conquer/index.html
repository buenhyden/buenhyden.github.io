<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>분할 정복 (Divide and Conquer) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Problem-Solving-Techniques,Divide-and-Conquer"><meta name=description content="분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="분할 정복 (Divide and Conquer)"><meta property="og:description" content="분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="분할 정복 (Divide and Conquer)"><meta name=twitter:description content="분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Problem Solving Techniques","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/"},{"@type":"ListItem","position":4,"name":"분할 정복 (Divide and Conquer)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/>Problem Solving Techniques</a></div><h1>분할 정복 (Divide and Conquer)</h1><div class=post-description>분할 정복(Divide and Conquer)은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제로 나누어 해결하는 알고리즘 설계 기법이다.</div></header><div class=post-content><h2 id=분할-정복-divide-and-conquer>분할 정복 (Divide and Conquer)<a hidden class=anchor aria-hidden=true href=#분할-정복-divide-and-conquer>#</a></h2><p>분할 정복은 알고리즘 설계에서 가장 강력하고 널리 사용되는 패러다임 중 하나이다.<br>복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 이 접근법은 효율적인 알고리즘 설계의 핵심 원리이다.</p><h3 id=정의와-원리>정의와 원리<a hidden class=anchor aria-hidden=true href=#정의와-원리>#</a></h3><p>분할 정복(Divide and Conquer)은 복잡한 문제를 다음과 같은 세 단계로 해결하는 알고리즘 설계 기법이다:</p><ol><li><strong>분할(Divide)</strong>: 원래 문제를 같은 유형의 더 작은 하위 문제들로 나눈다.</li><li><strong>정복(Conquer)</strong>: 하위 문제들을 재귀적으로 해결한다. 하위 문제가 충분히 작으면 직접 해결한다.</li><li><strong>결합(Combine)</strong>: 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 만든다.</li></ol><p>분할 정복은 재귀적 사고에 기반하며, 큰 문제를 동일한 형태의 작은 문제들로 축소하여 해결하는 방식이다.<br>이 과정은 문제가 충분히 작아질 때까지 계속된다.</p><h4 id=1-분할divide>1. 분할(Divide)<a hidden class=anchor aria-hidden=true href=#1-분할divide>#</a></h4><p>분할 단계는 원래 문제를 더 작은 하위 문제들로 나누는 과정이다.<br>이 단계에서는 다음과 같은 중요한 고려사항들이 있다:</p><h5 id=분할의-핵심-원칙>분할의 핵심 원칙<a hidden class=anchor aria-hidden=true href=#분할의-핵심-원칙>#</a></h5><ul><li><strong>크기 축소</strong>: 각 하위 문제는 원래 문제보다 규모가 작아야 한다. 이는 재귀적 접근의 핵심으로, 종료 조건에 도달할 수 있게 한다.</li><li><strong>유형 유지</strong>: 하위 문제들은 원래 문제와 동일한 형태여야 한다. 이렇게 하면 같은 알고리즘을 재귀적으로 적용할 수 있다.</li><li><strong>독립성</strong>: 이상적으로는, 하위 문제들이 서로 독립적이어야 효율적인 병렬 처리가 가능하다.</li></ul><h5 id=분할-전략의-종류>분할 전략의 종류<a hidden class=anchor aria-hidden=true href=#분할-전략의-종류>#</a></h5><ul><li><strong>균등 분할</strong>: 문제를 거의 동일한 크기의 하위 문제들로 나눈다(예: 머지 소트에서 배열을 반으로 나누기).</li><li><strong>불균등 분할</strong>: 문제를 다양한 크기의 하위 문제들로 나눈다(예: 퀵 소트에서 피벗을 기준으로 나누기).</li><li><strong>차원 감소</strong>: 다차원 문제를 더 낮은 차원의 문제로 변환한다(예: 스트라센 행렬 곱셈 알고리즘).</li></ul><h4 id=2-정복conquer>2. 정복(Conquer)<a hidden class=anchor aria-hidden=true href=#2-정복conquer>#</a></h4><p>정복 단계에서는 나누어진 하위 문제들을 해결한다.<br>분할된 문제가 충분히 작으면 직접 해결하고, 그렇지 않으면 재귀적으로 분할 정복 알고리즘을 적용한다.</p><h5 id=정복의-핵심-원칙>정복의 핵심 원칙<a hidden class=anchor aria-hidden=true href=#정복의-핵심-원칙>#</a></h5><ul><li><strong>기저 사례(Base Case) 처리</strong>: 더 이상 나눌 수 없는 가장 작은 하위 문제에 도달했을 때의 해결 방법을 정의한다.</li><li><strong>재귀적 해결</strong>: 기저 사례가 아니면, 같은 알고리즘을 하위 문제에 재귀적으로 적용한다.</li><li><strong>독립적 해결</strong>: 각 하위 문제는 다른 하위 문제의 해결에 영향을 주지 않고 독립적으로 해결된다.</li></ul><h5 id=정복-과정의-특징>정복 과정의 특징<a hidden class=anchor aria-hidden=true href=#정복-과정의-특징>#</a></h5><ul><li><strong>깊이 우선 탐색</strong>: 재귀 호출을 통해 문제 해결이 깊이 우선으로 진행된다.</li><li><strong>병렬화 가능성</strong>: 독립적인 하위 문제들은 병렬로 처리될 수 있어 다중 프로세서 환경에서 효율성을 높일 수 있다.</li><li><strong>메모리 사용</strong>: 재귀 호출 스택으로 인해 일정 수준의 메모리 오버헤드가 발생한다.</li></ul><h4 id=3-결합combine>3. 결합(Combine)<a hidden class=anchor aria-hidden=true href=#3-결합combine>#</a></h4><p>결합 단계에서는 하위 문제들의 해결책을 통합하여 원래 문제의 해결책을 만든다.<br>이 단계는 분할 정복 알고리즘의 효율성과 정확성에 중요한 영향을 미친다.</p><h5 id=결합의-핵심-원칙>결합의 핵심 원칙<a hidden class=anchor aria-hidden=true href=#결합의-핵심-원칙>#</a></h5><ul><li><strong>효율적 통합</strong>: 하위 문제들의 해결책을 효율적으로 결합하는 방법이 중요하다.</li><li><strong>전체 최적성 보장</strong>: 결합 과정이 하위 문제 해결책들을 결합하여 전체 문제의 최적해를 제공해야 한다.</li><li><strong>정보 보존</strong>: 하위 문제의 해결책을 결합할 때 중요한 정보가 손실되지 않아야 한다.</li></ul><h5 id=결합-방법의-종류>결합 방법의 종류<a hidden class=anchor aria-hidden=true href=#결합-방법의-종류>#</a></h5><ul><li><strong>단순 결합</strong>: 하위 문제의 해결책을 직접 이어 붙이는 방식(예: 배열 연결).</li><li><strong>병합 결합</strong>: 두 개 이상의 정렬된 하위 문제 해결책을 병합하는 방식(예: 머지 소트의 병합 단계).</li><li><strong>수학적 결합</strong>: 하위 문제의 해결책에 수학적 연산을 적용하는 방식(예: 카라츠바 알고리즘의 곱셈 결과 결합).</li><li><strong>선택적 결합</strong>: 하위 문제 해결책 중 조건에 맞는 것만 선택하는 방식(예: 최댓값/최솟값 찾기).</li></ul><h4 id=분할-정복의-세-단계가-함께-작동하는-방식>분할 정복의 세 단계가 함께 작동하는 방식<a hidden class=anchor aria-hidden=true href=#분할-정복의-세-단계가-함께-작동하는-방식>#</a></h4><p>세 단계는 서로 밀접하게 연결되어 전체 알고리즘의 성능과 정확성을 결정한다:</p><ol><li><strong>분할 단계</strong>에서 문제를 얼마나 효과적으로 나누는지가 알고리즘의 깊이와 효율성에 영향을 미친다.</li><li><strong>정복 단계</strong>에서 기저 사례의 선택과 재귀적 해결 방식이 알고리즘의 정확성을 보장한다.</li><li><strong>결합 단계</strong>의 효율성이 전체 알고리즘의 시간 복잡도에 중요한 영향을 미친다.</li></ol><p><figure><img alt="Working of Divide and Conquer" loading=lazy src=/img/Working-of-Divide-and-Conquer-Algorithm.webp><figcaption>Source: https://www.geeksforgeeks.org/introduction-to-divide-and-conquer-algorithm/</figcaption></figure></p><h3 id=분할-정복의-특징>분할 정복의 특징<a hidden class=anchor aria-hidden=true href=#분할-정복의-특징>#</a></h3><p>분할 정복 알고리즘의 주요 특징은 다음과 같다:</p><ul><li><strong>재귀적 구조</strong>: 대부분의 분할 정복 알고리즘은 재귀 함수로 구현된다.</li><li><strong>하위 문제의 독립성</strong>: 보통 하위 문제들은 서로 독립적이어야 효율적이다.</li><li><strong>베이스 케이스</strong>: 재귀의 종료 조건으로, 더 이상 분할할 수 없는 가장 작은 문제이다.</li><li><strong>최적 부분 구조</strong>: 큰 문제의 최적해가 하위 문제들의 최적해로부터 구성된다.</li></ul><h3 id=분할-정복-알고리즘-설계-방법론>분할 정복 알고리즘 설계 방법론<a hidden class=anchor aria-hidden=true href=#분할-정복-알고리즘-설계-방법론>#</a></h3><ol><li>문제 분석 및 분할 전략<br>효과적인 분할 정복 알고리즘을 설계하기 위한 단계:<ol><li><strong>문제의 재귀적 구조 파악</strong>: 문제가 어떻게 더 작은 동일 유형의 하위 문제로 나눠질 수 있는지 분석한다.</li><li><strong>분할 지점 선택</strong>: 문제를 어떤 기준으로 분할할지 결정한다(예: 배열의 중간, 특정 피벗 등).</li><li><strong>독립성 확인</strong>: 하위 문제들이 독립적으로 해결 가능한지 확인한다.</li><li><strong>베이스 케이스 정의</strong>: 재귀의 종료 조건이 될 가장 작은 문제 크기를 결정한다.</li><li><strong>결합 방법 설계</strong>: 하위 문제의 해결책들을 어떻게 결합하여 원래 문제의 해결책을 만들지 결정한다.</li></ol></li><li>알고리즘 분석 및 최적화<br>분할 정복 알고리즘의 성능을 분석하고 최적화하는 방법:<ol><li><strong>재귀 관계식 도출</strong>: T(n) = aT(n/b) + f(n) 형태의 관계식을 세운다.</li><li><strong>마스터 정리 적용</strong>: 시간 복잡도의 점근적 상한을 결정한다.</li><li><strong>병목 지점 식별</strong>: 알고리즘에서 가장 비용이 많이 드는 부분을 찾는다.</li><li><strong>분할 균형성 평가</strong>: 분할이 얼마나 균형잡혀 있는지 분석한다.</li><li><strong>하이브리드 접근법 고려</strong>: 다른 알고리즘 패러다임과의 결합 가능성을 탐색한다.</li></ol></li><li>재귀 구현 최적화<br>재귀적으로 구현된 분할 정복 알고리즘의 성능을 향상시키는 기법:<ol><li><strong>꼬리 재귀 최적화</strong>: 재귀 호출이 함수의 마지막 연산인 경우, 컴파일러가 이를 반복문으로 최적화할 수 있다.</li><li><strong>메모이제이션 적용</strong>: 이미 계산된 하위 문제의 결과를 저장하여 재계산을 방지한다.</li><li><strong>하위 문제 크기 최적화</strong>: 작은 하위 문제는 재귀 대신 직접적인 방법으로 해결한다.</li><li><strong>스택 메모리 관리</strong>: 깊은 재귀를 피하고 스택 오버플로를 방지하는 전략을 적용한다.</li></ol></li><li>병렬 구현 전략<br>분할 정복 알고리즘을 효과적으로 병렬화하는 방법:<ol><li><strong>작업 크기 조정</strong>: 병렬화할 가치가 있는 최소 하위 문제 크기를 결정한다.</li><li><strong>작업 풀 관리</strong>: 스레드 풀을 사용하여 스레드 생성 오버헤드를 줄인다.</li><li><strong>로드 밸런싱</strong>: 작업 훔치기(work stealing) 등의 기법으로 프로세서 간 부하를 균등하게 분배한다.</li><li><strong>동기화 최소화</strong>: 불필요한 동기화를 줄여 병렬 효율성을 높인다.</li><li><strong>메모리 지역성 고려</strong>: 캐시 효율성을 높이는 메모리 접근 패턴을 설계한다.</li></ol></li></ol><h3 id=분할-정복의-수학적-분석>분할 정복의 수학적 분석<a hidden class=anchor aria-hidden=true href=#분할-정복의-수학적-분석>#</a></h3><ol><li><p>시간 복잡도 분석<br>분할 정복 알고리즘의 시간 복잡도는 주로 마스터 정리(Master Theorem)를 사용하여 분석된다.<br>일반적인 재귀 관계식은 다음과 같다:<br><code>T(n) = aT(n/b) + f(n)</code><br>여기서:</p><ul><li><code>T(n)</code>은 크기가 n인 문제를 해결하는 데 필요한 시간</li><li><code>a</code>는 생성되는 하위 문제의 수</li><li><code>b</code>는 하위 문제의 크기가 얼마나 감소하는지를 나타내는 요소</li><li><code>f(n)</code>은 분할과 결합 단계에 드는 추가 작업의 비용</li></ul><p>마스터 정리는 이 재귀 관계식을 <code>n</code>의 함수로 표현된 폐쇄형(closed form)으로 해결한다.</p></li><li><p>공간 복잡도 분석<br>분할 정복 알고리즘의 공간 복잡도는 주로 재귀 호출 스택의 깊이와 각 단계에서 필요한 추가 공간에 의해 결정된다. 일반적으로 다음과 같은 요소를 고려한다:</p><ul><li>재귀 호출 스택의 최대 깊이</li><li>각 재귀 호출에서 필요한 추가 메모리</li><li>결과를 저장하기 위한 공간</li></ul></li><li><p>재귀 관계식 해결<br>분할 정복 알고리즘의 성능을 분석하려면 재귀 관계식을 해결해야 한다.<br>마스터 정리는 세 가지 경우로 분류된다:</p><ol><li><code>f(n) = O(n^c)</code> 이고 <code>c &lt; log_b(a)</code>인 경우: <code>T(n) = Θ(n^(log_b(a)))</code></li><li><code>f(n) = Θ(n^c)</code> 이고 <code>c = log_b(a)</code>인 경우: <code>T(n) = Θ(n^c * log n)</code></li><li><code>f(n) = Ω(n^c)</code> 이고 <code>c > log_b(a)</code>인 경우: <code>T(n) = Θ(f(n))</code><br>이 분류를 통해 많은 분할 정복 알고리즘의 복잡도를 쉽게 결정할 수 있다.</li></ol></li></ol><h3 id=분할-정복의-구현-기법>분할 정복의 구현 기법<a hidden class=anchor aria-hidden=true href=#분할-정복의-구현-기법>#</a></h3><h4 id=재귀-구현-vs-반복-구현>재귀 구현 vs. 반복 구현<a hidden class=anchor aria-hidden=true href=#재귀-구현-vs-반복-구현>#</a></h4><p>분할 정복 알고리즘은 대부분 자연스럽게 재귀적으로 구현되지만, 스택 오버플로를 방지하거나 성능을 개선하기 위해 반복적으로 구현할 수도 있다.</p><p><strong>재귀 구현의 장단점:</strong></p><ul><li><strong>장점</strong>: 알고리즘의 논리를 더 명확하게 표현할 수 있다.</li><li><strong>단점</strong>: 함수 호출 오버헤드와 스택 오버플로 위험이 있다.</li></ul><p><strong>반복 구현의 장단점:</strong></p><ul><li><strong>장점</strong>: 함수 호출 오버헤드가 없고 스택 오버플로 위험이 없다.</li><li><strong>단점</strong>: 코드가 더 복잡해질 수 있다.</li></ul><p><strong>이진 검색의 반복 구현 예시:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search_iterative</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 타겟을 찾지 못함</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=메모이제이션과의-결합>메모이제이션과의 결합<a hidden class=anchor aria-hidden=true href=#메모이제이션과의-결합>#</a></h4><p>분할 정복 알고리즘이 중복된 하위 문제를 해결해야 할 경우, 동적 프로그래밍의 메모이제이션 기법을 결합하여 효율성을 크게 향상시킬 수 있다.</p><p><strong>피보나치 수열 계산 예시:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>memo</span><span class=o>=</span><span class=p>{}):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 메모이제이션을 활용한 분할 정복</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>memo</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span> <span class=o>+</span> <span class=n>fibonacci</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>,</span> <span class=n>memo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 순수한 분할 정복(O(2^n))보다 훨씬 효율적인 O(n) 시간 복잡도를 제공한다.</p><h4 id=병렬-처리와-분할-정복>병렬 처리와 분할 정복<a hidden class=anchor aria-hidden=true href=#병렬-처리와-분할-정복>#</a></h4><p>분할 정복 알고리즘은 본질적으로 병렬화에 적합하다.<br>독립적인 하위 문제들을 서로 다른 프로세서나 스레드에서 동시에 처리할 수 있기 때문이다.</p><p><strong>병렬 병합 정렬 개념:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parallel_merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>num_threads</span><span class=o>=</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 충분히 작은 배열에 대해서는 일반 병합 정렬 사용</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>1000</span> <span class=ow>or</span> <span class=n>num_threads</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 하위 문제를 병렬로 처리</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>concurrent.futures</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>concurrent</span><span class=o>.</span><span class=n>futures</span><span class=o>.</span><span class=n>ThreadPoolExecutor</span><span class=p>()</span> <span class=k>as</span> <span class=n>executor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>left_future</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=n>parallel_merge_sort</span><span class=p>,</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>],</span> <span class=n>num_threads</span> <span class=o>//</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=n>parallel_merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:],</span> <span class=n>num_threads</span> <span class=o>//</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>=</span> <span class=n>left_future</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>실제 구현에서는 스레드 생성 오버헤드와 병렬화 이득 사이의 균형을 고려해야 한다.</p><h4 id=분할-정복의-최적화-기법>분할 정복의 최적화 기법<a hidden class=anchor aria-hidden=true href=#분할-정복의-최적화-기법>#</a></h4><p>분할 정복 알고리즘의 성능을 향상시키는 다양한 최적화 기법이 있다:</p><ol><li><strong>하위 문제 크기 최적화</strong>: 작은 크기의 하위 문제에 대해서는 더 단순하고 효율적인 알고리즘 사용</li><li><strong>균형 잡힌 분할</strong>: 가능한 한 균등하게 문제를 분할하여 최악의 경우 성능 개선</li><li><strong>캐시 효율성 고려</strong>: 메모리 접근 패턴을 최적화하여 캐시 적중률 향상</li><li><strong>데이터 구조 선택</strong>: 문제에 적합한 데이터 구조를 사용하여 연산 효율성 증가</li><li><strong>하드웨어 최적화</strong>: SIMD(Single Instruction Multiple Data) 명령어 등을 활용한 하드웨어 수준 최적화</li></ol><h3 id=분할-정복의-고급-응용>분할 정복의 고급 응용<a hidden class=anchor aria-hidden=true href=#분할-정복의-고급-응용>#</a></h3><ol><li><p>정렬 알고리즘의 확장<br><strong>병합 정렬의 변형:</strong></p><ul><li><strong>외부 정렬(External Sort)</strong>: 메인 메모리에 담기 어려운 대용량 데이터를 정렬하는 기법으로, 분할 정복 원리를 확장한다.</li><li><strong>병렬 병합 정렬(Parallel Merge Sort)</strong>: 여러 프로세서나 스레드를 활용하여 병합 정렬을 병렬화한다.</li></ul><p><strong>퀵 정렬의 최적화:</strong></p><ul><li><strong>피벗 선택 전략</strong>: 중앙값의 중앙값(Median of Medians) 등의 방법으로 좋은 피벗을 선택하여 최악의 경우 성능을 개선한다.</li><li><strong>삽입 정렬 하이브리드</strong>: 작은 부분 배열에 대해서는 삽입 정렬을 사용하여 재귀 오버헤드를 줄인다.</li><li><strong>3-way 퀵 정렬</strong>: 동일한 값이 많은 경우 성능을 향상시키는 방법이다.</li></ul></li><li><p>계산 기하학에서의 응용</p><ul><li><strong>가장 가까운 점 쌍 찾기(Closest Pair of Points):</strong> 분할 정복을 사용하여 2D 평면상의 n개 점들 중 가장 가까운 두 점을 O(n log n) 시간에 찾을 수 있다.<ul><li><strong>알고리즘 개요:</strong><ol><li>점들을 x좌표에 따라 정렬한다.</li><li>점 집합을 중간에서 두 부분으로 나눈다.</li><li>각 부분에서 재귀적으로 가장 가까운 점 쌍을 찾는다.</li><li>두 부분에 걸쳐 있는(중간선 근처의) 점들 사이에서 가장 가까운 쌍을 찾는다.</li><li>세 경우 중 최소 거리를 반환한다.</li></ol></li></ul></li><li><strong>볼록 껍질(Convex Hull):</strong> 2D 점 집합의 볼록 껍질을 찾는 문제도 분할 정복 접근법을 사용할 수 있다.</li></ul></li><li><p>FFT(Fast Fourier Transform)<br>FFT는 신호 처리와 다항식 곱셈에 매우 중요한 알고리즘으로, 분할 정복의 원리를 사용한다.</p><ul><li><strong>알고리즘 개요:</strong><ol><li>짝수 인덱스와 홀수 인덱스의 샘플로 신호를 분할한다.</li><li>각 부분에 대해 재귀적으로 FFT를 계산한다.</li><li>이 결과들을 결합하여 전체 FFT를 구성한다.</li></ol></li></ul><p>FFT는 O(n log n) 시간 복잡도를 가지며, 이는 고전적인 O(n²) 방법보다 훨씬 효율적이다.</p></li><li><p>정수 곱셈 알고리즘<br>카라츠바 알고리즘(Karatsuba algorithm)은 큰 정수의 곱셈을 더 효율적으로 수행하는 분할 정복 알고리즘이다.</p><ul><li>알고리즘 개요: 두 n자리 수 x와 y가 있을 때:<ol><li>x = a × 10^(n/2) + b와 y = c × 10^(n/2) + d로 분할한다.</li><li>x × y = (a × 10^(n/2) + b) × (c × 10^(n/2) + d) 로 표현된다.</li><li>이를 전개하는 대신, 3번의 곱셈(일반적인 방법은 4번 필요)만으로 계산한다:<ul><li>ac = a × c</li><li>bd = b × d</li><li>(a+b)(c+d) = ac + bd + (ad + bc)에서 (ad + bc)를 계산한다.</li></ul></li></ol></li></ul><p><strong>시간 복잡도:</strong></p><ul><li>표준 곱셈: O(n²)</li><li>카라츠바 알고리즘: O(n^log_2(3)) ≈ O(n^1.58)</li></ul></li></ol><h3 id=분할-정복의-한계와-대안>분할 정복의 한계와 대안<a hidden class=anchor aria-hidden=true href=#분할-정복의-한계와-대안>#</a></h3><ol><li><p>재귀적 오버헤드<br>분할 정복 알고리즘의 재귀적 구현은 다음과 같은 오버헤드를 발생시킬 수 있다:</p><ul><li>함수 호출 스택 관리 비용</li><li>스택 오버플로 위험</li><li>캐시 지역성(cache locality) 저하 가능성<br><strong>대안 및 해결책:</strong></li><li>작은 크기의 입력에 대해서는 직접적인 방법 사용(하이브리드 접근법)</li><li>꼬리 재귀(tail recursion) 최적화</li><li>반복적 구현으로 전환</li></ul></li><li><p>분할 균형성 문제<br>불균형한 분할은 분할 정복 알고리즘의 성능을 크게 저하시킬 수 있다.</p><ul><li><strong>예시:</strong> 퀵 정렬에서 이미 정렬된 배열에 대해 항상 첫 번째 원소를 피벗으로 선택하면, 매 단계에서 n-1과 0으로 불균형하게 분할되어 O(n²) 시간이 소요된다.</li><li><strong>대안 및 해결책:</strong><ul><li>랜덤 피벗 선택</li><li>중앙값의 중앙값 알고리즘을 통한 좋은 피벗 선택</li><li>다양한 피벗 선택 전략(첫 번째, 중간, 마지막 원소의 중앙값 등)</li></ul></li></ul></li><li><p>메모리 사용량<br>일부 분할 정복 알고리즘은 상당한 메모리를 필요로 한다:</p><ul><li>재귀 호출 스택에 필요한 메모리</li><li>합병 정렬과 같은 알고리즘에서 추가 배열에 필요한 메모리</li><li><strong>대안 및 해결책:</strong><ul><li>제자리 정렬 알고리즘(in-place sorting algorithms) 사용</li><li>반복적 구현으로 스택 메모리 사용 감소</li><li>외부 정렬(external sorting) 기법 적용</li></ul></li></ul></li><li><p>병렬화의 어려움<br>이론적으로 분할 정복은 병렬화에 적합하지만, 실제로는 다음과 같은 어려움이 있을 수 있다:</p><ul><li>작업 분배의 불균형</li><li>스레드/프로세스 생성 및 관리 오버헤드</li><li>결합 단계에서의 동기화 비용</li><li><strong>대안 및 해결책:</strong><ul><li>작업 훔치기(work stealing) 스케줄링</li><li>균형 잡힌 분할을 위한 전처리</li><li>일정 크기 이하의 하위 문제는 순차적으로 처리</li></ul></li></ul></li></ol><h3 id=대표적인-분할-정복-알고리즘>대표적인 분할 정복 알고리즘<a hidden class=anchor aria-hidden=true href=#대표적인-분할-정복-알고리즘>#</a></h3><h4 id=합병-정렬merge-sort>합병 정렬(Merge Sort)<a hidden class=anchor aria-hidden=true href=#합병-정렬merge-sort>#</a></h4><p>합병 정렬은 분할 정복 패러다임을 잘 보여주는 대표적인 정렬 알고리즘이다.</p><p><strong>알고리즘 개요:</strong></p><ol><li><strong>분할</strong>: 배열을 중간에서 두 부분으로 나눈다.</li><li><strong>정복</strong>: 두 부분 배열을 재귀적으로 정렬한다.</li><li><strong>결합</strong>: 정렬된 두 부분 배열을 합병하여 하나의 정렬된 배열을 만든다.</li></ol><p><strong>Python 구현:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 베이스 케이스: 배열의 길이가 1 이하면 이미 정렬된 것으로 간주</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계: 배열을 중간에서 두 부분으로 나눔</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정복 단계: 두 부분 배열을 재귀적으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결합 단계: 정렬된 두 부분 배열을 합병</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 배열의 요소를 비교하여 작은 것부터 결과 배열에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들을 결과 배열에 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도:</strong></p><ul><li>최악 및 평균 케이스: O(n log n)</li><li>최선 케이스: O(n log n)</li></ul><p><strong>공간 복잡도:</strong> O(n)</p><p>합병 정렬의 주요 장점은 안정적인 정렬이며 최악의 경우에도 O(n log n)의 성능을 보장한다는 점이다.<br>단점은 추가 메모리가 필요하다는 것이다.</p><h4 id=퀵-정렬quick-sort>퀵 정렬(Quick Sort)<a hidden class=anchor aria-hidden=true href=#퀵-정렬quick-sort>#</a></h4><p>퀵 정렬은 평균적으로 매우 효율적인 분할 정복 정렬 알고리즘이다.</p><p><strong>알고리즘 개요:</strong></p><ol><li><strong>분할</strong>: 피벗을 선택하고 배열을 피벗보다 작은 요소들과 큰 요소들로 분할한다.</li><li><strong>정복</strong>: 분할된 두 부분 배열을 재귀적으로 정렬한다.</li><li><strong>결합</strong>: 정렬된 부분 배열들은 이미 전체 배열의 순서에 맞게 있으므로 별도의 결합 과정이 필요 없다.</li></ol><p><strong>Python 구현:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>]</span>  <span class=c1># 피벗 선택 (중간 요소)</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>]</span>  <span class=c1># 피벗보다 작은 요소들</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span><span class=p>]</span>  <span class=c1># 피벗과 같은 요소들</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>  <span class=c1># 피벗보다 큰 요소들</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할된 부분 배열들을 재귀적으로 정렬하고 결합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도:</strong></p><ul><li>최선 및 평균 케이스: O(n log n)</li><li>최악 케이스: O(n²) (이미 정렬된 배열이나 역순으로 정렬된 배열에서 발생)</li></ul><p><strong>공간 복잡도:</strong></p><ul><li>평균: O(log n) (재귀 호출 스택)</li><li>최악: O(n)</li></ul><p>퀵 정렬의 주요 장점은 평균적으로 매우 빠르고 추가 메모리가 적게 필요하다는 점이다.<br>단점은 최악의 경우 O(n²)의 시간 복잡도를 가질 수 있다는 것이다.</p><h4 id=이진-검색binary-search>이진 검색(Binary Search)<a hidden class=anchor aria-hidden=true href=#이진-검색binary-search>#</a></h4><p>이진 검색은 정렬된 배열에서 특정 요소의 위치를 찾는 효율적인 알고리즘이다.</p><p><strong>알고리즘 개요:</strong></p><ol><li><strong>분할</strong>: 배열의 중간 요소를 확인하고, 찾고자 하는 값과 비교한다.</li><li><strong>정복</strong>: 찾고자 하는 값이 중간 요소보다 작으면 왼쪽 절반을, 크면 오른쪽 절반을 재귀적으로 검색한다.</li><li><strong>결합</strong>: 이진 검색에서는 별도의 결합 단계가 필요 없다.</li></ol><p><strong>Python 구현:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>left</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>right</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>right</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 베이스 케이스: 검색 범위가 비어 있으면 타겟이 없음</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>left</span> <span class=o>&gt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 중간 인덱스 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 중간 요소와 타겟 비교</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mid</span>  <span class=c1># 타겟을 찾음</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 타겟이 중간 요소보다 작으면 왼쪽 절반 검색</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 타겟이 중간 요소보다 크면 오른쪽 절반 검색</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도:</strong> O(log n)</p><p><strong>공간 복잡도:</strong></p><ul><li>재귀 구현: O(log n) (재귀 호출 스택)</li><li>반복 구현: O(1)</li></ul><p>이진 검색의 주요 장점은 매우 효율적인 O(log n) 시간 복잡도이다.<br>그러나 배열이 정렬되어 있어야 한다는 전제 조건이 있다.</p><h4 id=최대-부분-배열-문제maximum-subarray-problem>최대 부분 배열 문제(Maximum Subarray Problem)<a hidden class=anchor aria-hidden=true href=#최대-부분-배열-문제maximum-subarray-problem>#</a></h4><p>최대 부분 배열 문제는 배열에서 합이 최대가 되는 연속적인 부분 배열을 찾는 문제.</p><p><strong>분할 정복 접근법:</strong></p><ol><li><strong>분할</strong>: 배열을 중간에서 두 부분으로 나눈다.</li><li><strong>정복</strong>: 왼쪽 부분 배열의 최대 부분 배열과 오른쪽 부분 배열의 최대 부분 배열을 재귀적으로 찾는다.</li><li><strong>결합</strong>: 왼쪽 부분의 최대값, 오른쪽 부분의 최대값, 그리고 중간을 가로지르는 부분의 최대값 중에서 가장 큰 값을 선택한다.</li></ol><p><strong>Python 구현:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span><span class=lnt id=hl-6-33><a class=lnlinks href=#hl-6-33>33</a>
</span><span class=lnt id=hl-6-34><a class=lnlinks href=#hl-6-34>34</a>
</span><span class=lnt id=hl-6-35><a class=lnlinks href=#hl-6-35>35</a>
</span><span class=lnt id=hl-6-36><a class=lnlinks href=#hl-6-36>36</a>
</span><span class=lnt id=hl-6-37><a class=lnlinks href=#hl-6-37>37</a>
</span><span class=lnt id=hl-6-38><a class=lnlinks href=#hl-6-38>38</a>
</span><span class=lnt id=hl-6-39><a class=lnlinks href=#hl-6-39>39</a>
</span><span class=lnt id=hl-6-40><a class=lnlinks href=#hl-6-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>high</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>high</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>high</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 베이스 케이스: 원소가 하나뿐인 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>low</span> <span class=o>==</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 배열을 중간에서 분할</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 부분의 최대 부분 배열 합 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>left_max</span> <span class=o>=</span> <span class=n>max_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 부분의 최대 부분 배열 합 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>right_max</span> <span class=o>=</span> <span class=n>max_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 중간을 가로지르는 최대 부분 배열 합 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>cross_max</span> <span class=o>=</span> <span class=n>max_crossing_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 세 가지 경우 중 최대값 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_max</span><span class=p>,</span> <span class=n>right_max</span><span class=p>,</span> <span class=n>cross_max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_crossing_subarray</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 중간에서 왼쪽으로의 최대 합 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>left_sum</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>mid</span><span class=p>,</span> <span class=n>low</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>sum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>left_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=nb>sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 중간에서 오른쪽으로의 최대 합 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>right_sum</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>sum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>sum</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>right_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>right_sum</span><span class=p>,</span> <span class=nb>sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽과 오른쪽 합 결합</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>left_sum</span> <span class=o>+</span> <span class=n>right_sum</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시간 복잡도:</strong> O(n log n)</p><p>Kadane의 알고리즘을 사용하면 이 문제를 O(n) 시간에 해결할 수 있지만, 분할 정복 접근법은 문제에 대한 다른 시각과 이해를 제공한다.</p><h4 id=행렬-곱셈matrix-multiplication>행렬 곱셈(Matrix Multiplication)<a hidden class=anchor aria-hidden=true href=#행렬-곱셈matrix-multiplication>#</a></h4><p>스트라센 알고리즘(Strassen&rsquo;s Algorithm)은, n×n 행렬의 표준 곱셈보다 더 효율적인 분할 정복 방식의 행렬 곱셈 알고리즘이다.</p><p><strong>알고리즘 개요:</strong></p><ol><li><strong>분할</strong>: 각 n×n 행렬을 4개의 n/2 × n/2 부분 행렬로 나눈다.</li><li><strong>정복</strong>: 7개의 특별한 곱셈(표준 방식은 8개 필요)을 통해 부분 행렬 곱을 계산한다.</li><li><strong>결합</strong>: 이 곱셈 결과를 조합하여 최종 결과 행렬을 생성한다.</li></ol><p><strong>시간 복잡도:</strong></p><ul><li>표준 행렬 곱셈: O(n³)</li><li>스트라센 알고리즘: O(n^log_2(7)) ≈ O(n^2.81)</li></ul><p>이 알고리즘은 이론적으로 큰 행렬에 대해 더 효율적이지만, 실제로는 상수 요소와 구현 복잡성으로 인해 중간 크기 이상의 행렬에서만 이점이 있다.</p><h3 id=분할-정복의-실제-응용-사례>분할 정복의 실제 응용 사례<a hidden class=anchor aria-hidden=true href=#분할-정복의-실제-응용-사례>#</a></h3><ol><li><p>데이터베이스 시스템에서의 응용</p><ol><li><strong>인덱싱 및 검색:</strong><ul><li>B-트리와 B+트리는 분할 정복의 원리를 활용한 데이터베이스 인덱싱 구조.</li><li>대용량 데이터에서의 효율적인 범위 검색에 활용된다.</li></ul></li><li><strong>쿼리 최적화:</strong><ul><li>복잡한 SQL 쿼리를 더 작고 효율적인 하위 쿼리로 분해하는 최적화 기법에 분할 정복 원리가 적용된다.</li></ul></li></ol></li><li><p>분산 컴퓨팅에서의 분할 정복</p><ol><li><strong>맵리듀스(MapReduce) 패러다임:</strong><ul><li>구글에서 개발한 대규모 데이터 처리 프레임워크로, 분할 정복의 원리를 분산 환경에 적용한다.</li><li>Map 단계에서는 데이터를 작은 청크로 분할하여 독립적으로 처리한다.</li><li>Reduce 단계에서는 Map의 결과들을 결합하여 최종 결과를 생성한다.</li><li>Hadoop, Spark 등의 빅데이터 프레임워크가 이 패러다임을 구현한다.</li></ul></li><li><strong>분산 정렬:</strong><ul><li>TeraSort는 대용량 데이터를 분산 환경에서 정렬하는 알고리즘으로, 분할 정복 원리를 활용한다.</li><li>데이터를 여러 노드에 분산시키고, 각 노드에서 독립적으로 정렬한 후, 최종적으로 병합한다.</li></ul></li></ol></li><li><p>컴퓨터 그래픽스에서의 응용</p><ol><li><strong>레이 트레이싱(Ray Tracing):</strong><ul><li>3D 렌더링 기술인 레이 트레이싱은 공간을 계층적으로 분할하여 광선-객체 교차 계산을 최적화한다.</li><li>이를 위해 BSP 트리(Binary Space Partitioning Tree), 옥트리(Octree) 등의 공간 분할 자료구조를 사용한다.</li></ul></li><li><strong>이미지 압축:</strong><ul><li>쿼드트리(Quadtree)를 사용한 이미지 압축은 이미지를 재귀적으로 4개의 사분면으로 분할하여 유사한 영역을 효율적으로 인코딩한다.</li><li>JPEG 2000과 같은 웨이블릿 기반 압축 알고리즘도 분할 정복 원리를 활용한다.</li></ul></li></ol></li><li><p>머신러닝에서의 분할 정복</p><ol><li><strong>결정 트리(Decision Tree):</strong><ul><li>결정 트리 학습 알고리즘은 데이터셋을 특성에 따라 재귀적으로 분할하여 분류 또는 회귀 모델을 구축한다.</li><li>ID3, C4.5, CART 등의 알고리즘이 이러한 접근법을 사용한다.</li></ul></li><li><strong>군집화(Clustering):</strong><ul><li>계층적 군집화 알고리즘은 분할 정복 방식으로 데이터 포인트들을 그룹화한다.</li><li>상향식(Bottom-up) 접근법에서는 각 포인트를 개별 클러스터로 시작하여 점진적으로 병합한다.</li><li>하향식(Top-down) 접근법에서는 전체 데이터셋에서 시작하여 재귀적으로 분할한다.</li></ul></li></ol></li></ol><h3 id=7-분할-정복의-변형과-확장>7. 분할 정복의 변형과 확장<a hidden class=anchor aria-hidden=true href=#7-분할-정복의-변형과-확장>#</a></h3><ol><li><p>분할과 정복(Split and Conquer)<br>분할과 정복은 분할 정복의 변형으로, 문제를 여러 개의 독립적인 하위 문제로 나누지만, 원래 문제와 다른 형태의 하위 문제로 변환할 수 있다.<br><strong>예시: 선형 시간 선택 알고리즘(Linear-time Selection Algorithm)</strong>:</p><ul><li>중앙값의 중앙값(Median of Medians) 알고리즘은 배열에서 k번째 작은 원소를 O(n) 시간에 찾을 수 있는 알고리즘이다:<ol><li>배열을 5개 원소씩의 그룹으로 나눈다.</li><li>각 그룹에서 중앙값을 찾는다(삽입 정렬 등의 간단한 방법 사용).</li><li>이 중앙값들의 중앙값(피벗)을 재귀적으로 찾는다.</li><li>피벗을 기준으로 배열을 분할한다.</li><li>분할된 부분 중 하나를 선택하여 재귀적으로 탐색한다.</li></ol></li><li>이 알고리즘은 최악의 경우에도 O(n) 시간 복잡도를 보장한다.</li></ul></li><li><p>동적 프로그래밍과의 결합<br>분할 정복과 동적 프로그래밍은 모두 문제를 더 작은 하위 문제로 나누지만, 하위 문제의 중복 여부에 따라 다른 접근법을 취한다:</p><ul><li><strong>분할 정복</strong>: 일반적으로 중복되지 않는 하위 문제들을 해결</li><li><strong>동적 프로그래밍</strong>: 중복되는 하위 문제들의 해결책을 저장하고 재사용<br>그러나 이 두 패러다임은 종종 결합될 수 있다.<br>예를 들어:</li><li><strong>예시: 최적 이진 검색 트리(Optimal Binary Search Tree)</strong><ul><li>주어진 검색 키와 각 키의 검색 빈도에 대해 평균 검색 시간을 최소화하는 이진 검색 트리를 구성하는 문제:<ol><li>문제를 하위 문제로 분할: 서브트리를 구성하는 문제</li><li>중복되는 하위 문제 해결책을 테이블에 저장</li><li>최적 해를 상향식으로 구성</li></ol></li><li>이는 분할 정복의 재귀적 구조와 동적 프로그래밍의 메모이제이션을 결합한 접근법이다.</li></ul></li></ul></li><li><p>확률적 분할 정복<br>랜덤화를 분할 정복과 결합하여 평균적으로 더 효율적인 알고리즘을 만들 수 있다.</p><ul><li><p><strong>예시: 랜덤화된 퀵 정렬(Randomized Quicksort)</strong></p><ul><li>피벗을 무작위로 선택하는 퀵 정렬 변형이다:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>randomized_quicksort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 랜덤 피벗 선택</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot_idx</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>pivot_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>randomized_quicksort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>randomized_quicksort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 최악의 경우 O(n²) 시간 복잡도를 가질 수 있지만, 평균적으로 O(n log n)을 보장하며 실제로 매우 효율적이다.</p></li></ul></li><li><p>다차원 분할 정복<br>분할 정복은 다차원 문제에도 효과적으로 적용될 수 있다.</p><ul><li><strong>예시: k-d 트리(k-dimensional tree)</strong><ul><li>k-d 트리는 k차원 공간에서의 점들을 효율적으로 검색하기 위한 공간 분할 자료구조:<ol><li>차원을 번갈아가며 공간을 분할합니다.</li><li>각 분할 단계에서 현재 차원의 중앙값을 기준으로 분할합니다.</li><li>이를 재귀적으로 반복하여 트리를 구성합니다.</li></ol></li><li>k-d 트리는 근접 이웃 검색, 범위 검색 등 많은 공간 쿼리에 유용하다.</li></ul></li></ul></li></ol><h3 id=분할-정복의-미래-동향>분할 정복의 미래 동향<a hidden class=anchor aria-hidden=true href=#분할-정복의-미래-동향>#</a></h3><ol><li><p>양자 컴퓨팅과 분할 정복<br>양자 컴퓨팅은 분할 정복 알고리즘에 새로운 가능성을 제공한다:</p><ul><li><strong>양자 검색 알고리즘</strong>: Grover의 알고리즘은 정렬되지 않은 데이터베이스에서 O(√n) 시간에 검색할 수 있다.</li><li><strong>양자 푸리에 변환</strong>: 고전적인 FFT를 더욱 효율적으로 구현할 수 있는 가능성을 제공한다.</li><li><strong>양자 병렬성</strong>: 양자 중첩을 통해 여러 하위 문제를 동시에 처리할 수 있는 잠재력이 있다.</li></ul></li><li><p>인공지능과의 결합<br>분할 정복과 인공지능 기술의 통합은 흥미로운 발전을 보이고 있다:</p><ul><li><strong>학습 기반 분할 전략</strong>: 머신러닝을 사용하여 최적의 분할 지점과 전략을 결정한다.</li><li><strong>신경망 가지치기</strong>: 대규모 신경망을 더 작은 하위 네트워크로 분할하여 효율적으로 학습 및 추론한다.</li><li><strong>자동 알고리즘 설계</strong>: AI가 문제에 최적화된 분할 정복 알고리즘을 자동으로 설계한다.</li></ul></li><li><p>분산 및 병렬 컴퓨팅의 발전<br>분산 환경에서의 분할 정복 알고리즘 발전:</p><ul><li><strong>엣지 컴퓨팅 최적화</strong>: 엣지 디바이스에서 효율적으로 실행할 수 있는 분할 정복 알고리즘</li><li><strong>이기종 컴퓨팅</strong>: CPU, GPU, TPU 등 다양한 프로세서에 최적화된 분할 정복 구현</li><li><strong>탄력적 확장성</strong>: 클라우드 환경에서 가용 자원에 따라 동적으로 조정되는 분할 정복 알고리즘</li></ul></li><li><p>새로운 응용 분야<br>분할 정복이 활용될 수 있는 신흥 응용 분야:</p><ul><li><strong>양자 역학 시뮬레이션</strong>: 복잡한 양자 시스템을 하위 시스템으로 분할하여 시뮬레이션</li><li><strong>생물정보학</strong>: 대규모 유전체 분석 및 단백질 구조 예측에서의 응용</li><li><strong>자율 시스템</strong>: 자율 주행 차량, 로봇 등에서의 복잡한 의사결정 문제 해결</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Brute Force</h2></header><div class=entry-content><p>Divide and Conquer vs. Brute Force 알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.
두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.
먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.
Divide and Conquer(분할 정복) 알고리즘 기본 개념 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 세 가지 주요 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-01-24 07:17:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Brute Force" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Branch and Bound</h2></header><div class=entry-content><p>Divide and Conquer vs. Branch and Bound “Divide and Conquer(분할 정복)“과 “Branch and Bound(분기 한정)“은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.
“Divide and Conquer"와 “Branch and Bound"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.
분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.
두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-24 02:16:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Branch and Bound" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>