<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>검색 알고리즘 (Search Algorithms) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Algorithms,Searching"><meta name=description content="데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="검색 알고리즘 (Search Algorithms)"><meta property="og:description" content="데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="검색 알고리즘 (Search Algorithms)"><meta name=twitter:description content="데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/"},{"@type":"ListItem","position":4,"name":"검색 알고리즘 (Search Algorithms)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/>Algorithms</a></div><h1>검색 알고리즘 (Search Algorithms)</h1><div class=post-description>데이터 집합에서 특정 항목을 찾는 방법을 정의하는 알고리즘</div></header><div class=post-content><h2 id=검색-알고리즘-searching-algorithms>검색 알고리즘 (Searching Algorithms)<a hidden class=anchor aria-hidden=true href=#검색-알고리즘-searching-algorithms>#</a></h2><p>검색 알고리즘은 데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 알고리즘이다<br>이러한 알고리즘은 컴퓨터 과학의 핵심 요소로, 우리가 디지털 세계에서 정보를 찾고 처리하는 방식의 기반이 된다.<br>검색 알고리즘의 효율성은 데이터베이스, 웹 검색 엔진, 인공지능 등 현대 기술의 성능에 직접적인 영향을 미친다.</p><p>검색 알고리즘은 컴퓨터 과학의 핵심 요소로, 데이터를 효율적으로 찾고 처리하는 기초가 된다.<br>순차 검색부터 이진 검색, 해시 기반 검색, 트리 기반 검색, 그래프 검색 등 다양한 검색 알고리즘이 있으며, 각각은 특정 상황과 데이터 유형에 적합한 장단점을 가지고 있다.</p><p>현대 사회에서 검색 알고리즘은 웹 검색 엔진, 데이터베이스 시스템, 추천 시스템 등 다양한 응용 분야에서 핵심적인 역할을 한다.<br>인공지능, 양자 컴퓨팅, 분산 컴퓨팅 등 새로운 기술의 발전과 함께 검색 알고리즘도 계속해서 진화하고 있다.</p><p>효율적인 검색 알고리즘의 선택과 구현은 소프트웨어의 성능과 사용자 경험에 직접적인 영향을 미치므로, 데이터의 특성, 검색 패턴, 자원 제약 등을 고려하여 최적의 알고리즘을 선택하는 것이 중요하다. 또한, 복잡한 문제에 대해서는 여러 검색 알고리즘을 조합하거나 특정 상황에 맞게 최적화하는 접근 방식이 효과적일 수 있다.</p><h3 id=주요-검색-알고리즘>주요 검색 알고리즘<a hidden class=anchor aria-hidden=true href=#주요-검색-알고리즘>#</a></h3><table><thead><tr><th>알고리즘</th><th>작동 원리</th><th>시간 복잡도</th><th>공간 복잡도</th><th>장점</th><th>단점</th><th>적합한 사용 상황</th></tr></thead><tbody><tr><td><strong>순차 검색<br>(Linear Search)</strong></td><td>배열의 처음부터 끝까지 순차적으로 탐색</td><td>평균: O(n)<br>최악: O(n)</td><td>O(1)</td><td>• 구현이 매우 간단<br>• 정렬되지 않은 데이터에도 적용 가능<br>• 작은 배열에서 효율적</td><td>• 대규모 데이터에서 비효율적<br>• 데이터 크기에 비례하여 시간 증가</td><td>• 작은 데이터 집합<br>• 정렬되지 않은 데이터<br>• 한 번만 검색하는 경우</td></tr><tr><td><strong>이진 검색<br>(Binary Search)</strong></td><td>정렬된 배열의 중간 지점을 기준으로 검색 범위를 반씩 줄여감</td><td>평균: O(log n)<br>최악: O(log n)</td><td>반복: O(1)<br>재귀: O(log n)</td><td>• 대규모 정렬 데이터에서 매우 효율적<br>• 검색 속도가 빠름</td><td>• 데이터가 정렬되어 있어야 함<br>• 동적 데이터에 추가 비용 발생</td><td>• 정렬된 대규모 데이터<br>• 반복적 검색이 필요한 경우<br>• 메모리 제약이 있는 환경</td></tr><tr><td><strong>해시 기반 검색<br>(Hash-based Search)</strong></td><td>해시 함수로 데이터 위치를 직접 계산</td><td>평균: O(1)<br>최악: O(n)</td><td>O(n)</td><td>• 평균적으로 매우 빠른 검색 속도<br>• 키 기반 검색에 이상적</td><td>• 해시 충돌 처리 필요<br>• 추가 메모리 사용<br>• 순서 보존 안 됨</td><td>• 키-값 룩업이 빈번한 경우<br>• 메모리가 충분한 환경<br>• 순서가 중요하지 않은 경우</td></tr><tr><td><strong>보간 검색<br>(Interpolation Search)</strong></td><td>값 분포를 기반으로 다음 검색 위치를 예측</td><td>평균: O(log log n)<br>최악: O(n)</td><td>O(1)</td><td>• 균등 분포 데이터에서 이진 검색보다 효율적<br>• 지능적인 위치 선택</td><td>• 불규칙한 분포에서는 성능 저하<br>• 계산이 더 복잡함</td><td>• 균등하게 분포된 정렬 데이터<br>• 대규모 데이터베이스 검색</td></tr><tr><td><strong>점프 검색<br>(Jump Search)</strong></td><td>고정 크기 블록을 건너뛰며 검색</td><td>평균: O(√n)<br>최악: O(√n)</td><td>O(1)</td><td>• 이진 검색보다 단순<br>• 선형 검색보다 효율적<br>• 뒤로 이동(백트래킹) 불필요</td><td>• 이진 검색보다는 느림<br>• 최적의 점프 크기 결정 필요</td><td>• 정렬된 중간 규모 데이터<br>• 백트래킹이 비싼 환경</td></tr><tr><td><strong>지수 검색<br>(Exponential Search)</strong></td><td>범위를 2의 지수 승으로 확장하다가 이진 검색 적용</td><td>평균: O(log n)<br>최악: O(log n)</td><td>O(1)</td><td>• 무한 배열에 적합<br>• 값이 앞에 있을 때 효율적</td><td>• 구현이 약간 복잡<br>• 정렬된 데이터 필요</td><td>• 무한 또는 매우 큰 정렬 배열<br>• 목표값이 배열 앞부분에 있을 가능성이 높은 경우</td></tr><tr><td><strong>피보나치 검색<br>(Fibonacci Search)</strong></td><td>피보나치 수열로 배열을 불균등하게 분할</td><td>평균: O(log n)<br>최악: O(log n)</td><td>O(1)</td><td>• 메모리 접근 비용이 높은 환경에 효율적<br>• 나눗셈 연산 회피</td><td>• 구현이 복잡함<br>• 실제 이점은 상황별로 다름</td><td>• 메모리 접근이 비싼 환경<br>• 나눗셈 연산이 비싼 환경</td></tr><tr><td><strong>이진 검색 트리<br>(BST Search)</strong></td><td>트리 구조를 순회하며 키 비교</td><td>평균: O(log n)<br>최악: O(n)</td><td>O(n)</td><td>• 동적 데이터에 효율적<br>• 검색, 삽입, 삭제 모두 효율적<br>• 범위 쿼리 효율적</td><td>• 불균형 트리에서 성능 저하<br>• 구현이 복잡함</td><td>• 동적으로 변경되는 데이터<br>• 삽입/삭제가 빈번한 경우<br>• 범위 기반 검색이 필요한 경우</td></tr><tr><td><strong>균형 이진 검색 트리<br>(AVL/Red-Black)</strong></td><td>자가 균형 조정 트리 구조를 통한 검색</td><td>평균: O(log n)<br>최악: O(log n)</td><td>O(n)</td><td>• 항상 균형을 유지하여 최악의 경우도 O(log n)<br>• 동적 데이터에 안정적인 성능</td><td>• 구현이 매우 복잡<br>• 균형 유지 오버헤드</td><td>• 동적 데이터의 안정적인 성능이 중요한 경우<br>• 최악의 경우 성능 보장이 필요할 때</td></tr><tr><td><strong>너비 우선 검색<br>(BFS)</strong></td><td>그래프에서 인접 노드를 먼저 방문</td><td>O(V + E)</td><td>O(V)</td><td>• 최단 경로 찾기에 적합<br>• 연결 컴포넌트 탐색에 유용</td><td>• 메모리 사용량이 많음<br>• 깊은 그래프에서 비효율적</td><td>• 최단 경로 문제<br>• 연결성 분석<br>• 레벨 순회가 필요한 경우</td></tr><tr><td><strong>깊이 우선 검색<br>(DFS)</strong></td><td>그래프에서 가능한 한 깊이 탐색 후 백트래킹</td><td>O(V + E)</td><td>O(V)</td><td>• 메모리 효율적<br>• 사이클 탐지, 위상 정렬에 유용</td><td>• 최단 경로를 보장하지 않음<br>• 무한 그래프에서 문제 발생 가능</td><td>• 미로 탐색<br>• 사이클 감지<br>• 위상 정렬<br>• 연결 컴포넌트 분석</td></tr><tr><td><em><em>A</em> 검색<br>(A</em> Search)**</td><td>휴리스틱을 사용한 최단 경로 탐색</td><td>O(b^d)</td><td>O(b^d)</td><td>• 최적의 경로 보장<br>• 효율적인 탐색 공간 감소</td><td>• 좋은 휴리스틱 함수 필요<br>• 메모리 사용량이 많을 수 있음</td><td>• 경로 탐색 문제<br>• 인공지능 게임<br>• 로봇 경로 계획</td></tr></tbody></table><h4 id=순차-검색-linear-search>순차 검색 (Linear Search)<a hidden class=anchor aria-hidden=true href=#순차-검색-linear-search>#</a></h4><p>순차 검색은 가장 단순한 검색 알고리즘으로, 데이터 집합의 처음부터 끝까지 순서대로 탐색하며 원하는 값을 찾는다.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 배열이나 리스트의 첫 번째 요소부터 시작하여 각 요소를 차례대로 확인한다.</li><li><strong>시간 복잡도</strong>: 평균 및 최악의 경우 O(n), 여기서 n은 데이터 크기.</li><li><strong>공간 복잡도</strong>: O(1), 추가 메모리가 거의 필요하지 않는다.</li><li><strong>적용 상황</strong>: 작은 데이터 세트나 정렬되지 않은 데이터에 적합하다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>linear_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 배열의 각 요소를 순차적으로 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 요소가 찾는 값과 일치하면 해당 인덱스 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 배열에 없는 경우 -1 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 구현이 매우 간단하고, 정렬되지 않은 데이터에도 적용 가능.</li><li><strong>단점</strong>: 대규모 데이터에서는 매우 비효율적이며, 데이터 크기에 비례하여 시간이 증가.</li></ul><h4 id=이진-검색-binary-search>이진 검색 (Binary Search)<a hidden class=anchor aria-hidden=true href=#이진-검색-binary-search>#</a></h4><p>이진 검색은 정렬된 데이터에서 사용되는 효율적인 알고리즘으로, 중간 지점을 기준으로 범위를 반씩 줄여가며 검색한다.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 정렬된 배열에서 중간 요소를 확인하고, 찾는 값이 중간값보다 작으면 왼쪽 절반에서, 크면 오른쪽 절반에서 검색을 계속한다.</li><li><strong>시간 복잡도</strong>: 평균 및 최악의 경우 O(log n), 데이터 크기가 두 배로 증가할 때마다 한 단계만 추가된다.</li><li><strong>공간 복잡도</strong>: 반복적 구현은 O(1), 재귀적 구현은 O(log n)의 공간을 사용한다.</li><li><strong>적용 상황</strong>: 정렬된 대규모 데이터에서 매우 효율적이다.</li></ul><p>구현 (Python):</p><ul><li><p>반복적 방법</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>low</span><span class=p>,</span> <span class=n>high</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 중간 인덱스 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 중간 요소가 찾는 값인 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>        <span class=c1># 찾는 값이 중간 요소보다 작은 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>high</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=c1># 찾는 값이 중간 요소보다 큰 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>low</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 배열에 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>재귀적 방법</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search_recursive</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 기저 조건: 검색 범위가 더 이상 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>low</span> <span class=o>&gt;</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 중간 인덱스 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 중간 요소가 찾는 값인 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 중간 요소보다 작은 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>binary_search_recursive</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 중간 요소보다 큰 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>binary_search_recursive</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>high</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>장점</strong>: 대규모 정렬된 데이터에서 매우 효율적이며, 검색 속도가 빠르다.</p></li><li><p><strong>단점</strong>: 데이터가 정렬되어 있어야 하고, 동적으로 변경되는 데이터에는 추가 비용(정렬 유지)이 발생한다.</p></li></ul><h4 id=해시-기반-검색-hash-based-search>해시 기반 검색 (Hash-based Search)<a hidden class=anchor aria-hidden=true href=#해시-기반-검색-hash-based-search>#</a></h4><p>해시 기반 검색은 해시 함수를 사용하여 데이터를 저장하고 검색하는 방법이다.<br>이상적인 조건에서 상수 시간에 검색이 가능하다.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 해시 함수를 통해 데이터를 해시 테이블에 저장하고, 같은 해시 함수를 사용하여 검색할 값의 위치를 직접 계산한다.</li><li><strong>시간 복잡도</strong>: 평균적으로 O(1), 최악의 경우(해시 충돌 발생 시) O(n)이다.</li><li><strong>공간 복잡도</strong>: O(n), 해시 테이블을 저장하기 위한 추가 공간이 필요하다.</li><li><strong>적용 상황</strong>: 빠른 검색이 필요하고 메모리 사용이 중요하지 않은 경우에 적합하다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>HashTable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>hash_function</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 간단한 해시 함수: 키 값을 테이블 크기로 나눈 나머지</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>key</span> <span class=o>%</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 키의 해시 값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>hash_index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>hash_function</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 해당 위치에 데이터 저장 (충돌 처리는 단순화)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_index</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 키의 해시 값 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>hash_index</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>hash_function</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 해당 위치에 데이터가 있고, 키가 일치하는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_index</span><span class=p>]</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span> <span class=ow>and</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_index</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>hash_index</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 이상적인 조건에서 매우 빠른 검색 속도(O(1))를 제공합니다.</li><li><strong>단점</strong>: 해시 충돌 처리가 필요하고, 추가 메모리를 사용하며, 데이터 순서가 보존되지 않습니다.</li></ul><h4 id=보간-검색-interpolation-search>보간 검색 (Interpolation Search)<a hidden class=anchor aria-hidden=true href=#보간-검색-interpolation-search>#</a></h4><p>보간 검색은 이진 검색의 개선된 버전으로, 균등하게 분포된 데이터에서 검색 위치를 더 지능적으로 선택한다.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 찾으려는 값과 현재 검색 범위의 값을 기반으로 다음 검색 위치를 계산한다. 마치 숫자가 고르게 분포된 책에서 페이지를 찾는 방식과 유사하다.</li><li><strong>시간 복잡도</strong>: 균등 분포된 데이터에서 평균 O(log log n), 최악의 경우 O(n)이다.</li><li><strong>공간 복잡도</strong>: O(1), 추가 메모리가 거의 필요하지 않다.</li><li><strong>적용 상황</strong>: 균등하게 분포된 정렬된 데이터에서 가장 효율적이다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>interpolation_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>low</span><span class=p>,</span> <span class=n>high</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>high</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>target</span> <span class=o>&lt;=</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 예상 위치 계산</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]</span> <span class=o>==</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>]:</span>  <span class=c1># 모든 요소가 동일한 경우</span>
</span></span><span class=line><span class=cl>            <span class=n>pos</span> <span class=o>=</span> <span class=n>low</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>pos</span> <span class=o>=</span> <span class=n>low</span> <span class=o>+</span> <span class=p>((</span><span class=n>target</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>])</span> <span class=o>*</span> <span class=p>(</span><span class=n>high</span> <span class=o>-</span> <span class=n>low</span><span class=p>))</span> <span class=o>//</span> <span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>high</span><span class=p>]</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>low</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 예상 위치의 요소가 찾는 값인 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>pos</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>pos</span>
</span></span><span class=line><span class=cl>        <span class=c1># 찾는 값이 예상 위치의 요소보다 작은 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>pos</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>high</span> <span class=o>=</span> <span class=n>pos</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=c1># 찾는 값이 예상 위치의 요소보다 큰 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>low</span> <span class=o>=</span> <span class=n>pos</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 배열에 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 균등 분포 데이터에서 이진 검색보다 효율적이며, 검색 위치 선택이 더 지능적.</li><li><strong>단점</strong>: 분포가 균등하지 않은 데이터에서는 성능이 떨어질 수 있으며, 계산이 더 복잡합니다.</li></ul><h4 id=점프-검색-jump-search>점프 검색 (Jump Search)<a hidden class=anchor aria-hidden=true href=#점프-검색-jump-search>#</a></h4><p>점프 검색은 정렬된 배열에서 일정한 간격으로 점프하며 검색하는 알고리즘이다.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 정렬된 배열에서 일정한 크기의 블록을 건너뛰며 검색하고, 목표값이 있을 만한 블록을 찾으면 그 블록 내에서 선형 검색을 수행한다.</li><li><strong>시간 복잡도</strong>: O(√n), 여기서 n은 데이터 크기.</li><li><strong>공간 복잡도</strong>: O(1), 추가 메모리가 거의 필요하지 않다.</li><li><strong>적용 상황</strong>: 이진 검색보다 간단하면서도 선형 검색보다 효율적인 중간 규모의 정렬된 데이터에 적합하다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>math</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>jump_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 최적의 점프 크기는 제곱근(n)</span>
</span></span><span class=line><span class=cl>    <span class=n>step</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=n>math</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 목표값이 있을 수 있는 블록 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>arr</span><span class=p>[</span><span class=nb>min</span><span class=p>(</span><span class=n>step</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span> <span class=o>=</span> <span class=n>step</span>
</span></span><span class=line><span class=cl>        <span class=n>step</span> <span class=o>+=</span> <span class=nb>int</span><span class=p>(</span><span class=n>math</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>prev</span> <span class=o>&gt;=</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 해당 블록에서 선형 검색</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>arr</span><span class=p>[</span><span class=n>prev</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>prev</span> <span class=o>==</span> <span class=nb>min</span><span class=p>(</span><span class=n>step</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 목표값 찾음</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>prev</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>prev</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 이진 검색보다 단순하고 선형 검색보다 효율적이며, 백트래킹이 필요하지 않습니다.</li><li><strong>단점</strong>: 이진 검색보다는 느리며, 최적의 점프 크기를 결정해야 합니다.</li></ul><h4 id=지수-검색-exponential-search>지수 검색 (Exponential Search)<a hidden class=anchor aria-hidden=true href=#지수-검색-exponential-search>#</a></h4><p>지수 검색은 먼저 가능한 범위를 빠르게 찾은 다음, 그 범위 내에서 이진 검색을 수행하는 알고리즘.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 먼저 배열의 크기를 2의 지수 승으로 증가시키며 범위를 확장하고, 목표값이 있을 범위를 찾으면 그 범위 내에서 이진 검색을 수행한다.</li><li><strong>시간 복잡도</strong>: O(log n), 여기서 n은 데이터 크기.</li><li><strong>공간 복잡도</strong>: O(1) (반복 구현 시)</li><li><strong>적용 상황</strong>: 무한 또는 매우 큰 정렬된 배열에서 효율적이며, 목표값이 배열의 앞부분에 있을 가능성이 높을 때 유용하다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>low</span> <span class=o>+</span> <span class=n>high</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>high</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>low</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>exponential_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 배열이 비어있는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 요소가 목표값인 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 범위 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 범위 내에서 이진 검색</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>i</span> <span class=o>//</span> <span class=mi>2</span><span class=p>,</span> <span class=nb>min</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 무한 배열이나 크기를 모르는 배열에 적합하며, 목표값이 배열의 앞부분에 있을 때 효율적.</li><li><strong>단점</strong>: 구현이 약간 복잡하고, 이진 검색을 사용하므로 정렬된 데이터가 필요.</li></ul><h4 id=피보나치-검색-fibonacci-search>피보나치 검색 (Fibonacci Search)<a hidden class=anchor aria-hidden=true href=#피보나치-검색-fibonacci-search>#</a></h4><p>피보나치 검색은 피보나치 수열을 사용하여 검색 범위를 나누는 알고리즘.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 피보나치 수열을 사용하여 배열을 불균등하게 분할하고, 분할된 부분에서 검색을 계속한다.</li><li><strong>시간 복잡도</strong>: O(log n), 여기서 n은 데이터 크기.</li><li><strong>공간 복잡도</strong>: O(1), 추가 메모리가 거의 필요하지 않다.</li><li><strong>적용 상황</strong>: 메모리 접근이 비싼 환경에서 이진 검색의 대안으로 사용할 수 있다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span><span class=lnt id=hl-7-36><a class=lnlinks href=#hl-7-36>36</a>
</span><span class=lnt id=hl-7-37><a class=lnlinks href=#hl-7-37>37</a>
</span><span class=lnt id=hl-7-38><a class=lnlinks href=#hl-7-38>38</a>
</span><span class=lnt id=hl-7-39><a class=lnlinks href=#hl-7-39>39</a>
</span><span class=lnt id=hl-7-40><a class=lnlinks href=#hl-7-40>40</a>
</span><span class=lnt id=hl-7-41><a class=lnlinks href=#hl-7-41>41</a>
</span><span class=lnt id=hl-7-42><a class=lnlinks href=#hl-7-42>42</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>fibonacci_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 피보나치 수열 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>fib2</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># (m-2)번째 피보나치 수</span>
</span></span><span class=line><span class=cl>    <span class=n>fib1</span> <span class=o>=</span> <span class=mi>1</span>  <span class=c1># (m-1)번째 피보나치 수</span>
</span></span><span class=line><span class=cl>    <span class=n>fib</span> <span class=o>=</span> <span class=n>fib1</span> <span class=o>+</span> <span class=n>fib2</span>  <span class=c1># m번째 피보나치 수</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 배열 크기보다 크거나 같은 가장 작은 피보나치 수 찾기</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>fib</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>fib2</span> <span class=o>=</span> <span class=n>fib1</span>
</span></span><span class=line><span class=cl>        <span class=n>fib1</span> <span class=o>=</span> <span class=n>fib</span>
</span></span><span class=line><span class=cl>        <span class=n>fib</span> <span class=o>=</span> <span class=n>fib1</span> <span class=o>+</span> <span class=n>fib2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오프셋 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>offset</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>fib</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 유효한 인덱스 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>offset</span> <span class=o>+</span> <span class=n>fib2</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 목표값이 i 위치의 요소보다 큰 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>fib</span> <span class=o>=</span> <span class=n>fib1</span>
</span></span><span class=line><span class=cl>            <span class=n>fib1</span> <span class=o>=</span> <span class=n>fib2</span>
</span></span><span class=line><span class=cl>            <span class=n>fib2</span> <span class=o>=</span> <span class=n>fib</span> <span class=o>-</span> <span class=n>fib1</span>
</span></span><span class=line><span class=cl>            <span class=n>offset</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=c1># 목표값이 i 위치의 요소보다 작은 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>fib</span> <span class=o>=</span> <span class=n>fib2</span>
</span></span><span class=line><span class=cl>            <span class=n>fib1</span> <span class=o>=</span> <span class=n>fib1</span> <span class=o>-</span> <span class=n>fib2</span>
</span></span><span class=line><span class=cl>            <span class=n>fib2</span> <span class=o>=</span> <span class=n>fib</span> <span class=o>-</span> <span class=n>fib1</span>
</span></span><span class=line><span class=cl>        <span class=c1># 목표값 찾음</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 마지막 요소 확인</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>fib1</span> <span class=ow>and</span> <span class=n>offset</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>offset</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>offset</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 찾는 값이 배열에 없는 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 이진 검색보다 메모리 접근 횟수가 적을 수 있으며, 나눗셈 연산을 사용하지 않습니다.</li><li><strong>단점</strong>: 구현이 복잡하고, 실제 성능 이점은 상황에 따라 다를 수 있습니다.</li></ul><h4 id=트리-기반-검색-tree-based-search>트리 기반 검색 (Tree-based Search)<a hidden class=anchor aria-hidden=true href=#트리-기반-검색-tree-based-search>#</a></h4><p>트리 기반 검색 알고리즘은 트리 자료구조를 사용하여 데이터를 저장하고 검색한다.<br>이진 검색 트리(BST), AVL 트리, 레드-블랙 트리 등이 대표적이다.</p><p>특징:</p><ul><li><strong>작동 원리</strong>: 트리 구조에서 노드를 따라 이동하며 원하는 값을 검색한다.</li><li><strong>시간 복잡도</strong>: 균형 잡힌 트리에서 O(log n), 최악의 경우(불균형 트리) O(n)이다.</li><li><strong>공간 복잡도</strong>: O(n), 트리 구조를 저장하기 위한 공간이 필요하다.</li><li><strong>적용 상황</strong>: 동적으로 변경되는 데이터에 효율적이며, 검색뿐만 아니라 삽입, 삭제도 빠르게 수행할 수 있다.</li></ul><p>구현 (Python - 이진 검색 트리):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span><span class=lnt id=hl-8-29><a class=lnlinks href=#hl-8-29>29</a>
</span><span class=lnt id=hl-8-30><a class=lnlinks href=#hl-8-30>30</a>
</span><span class=lnt id=hl-8-31><a class=lnlinks href=#hl-8-31>31</a>
</span><span class=lnt id=hl-8-32><a class=lnlinks href=#hl-8-32>32</a>
</span><span class=lnt id=hl-8-33><a class=lnlinks href=#hl-8-33>33</a>
</span><span class=lnt id=hl-8-34><a class=lnlinks href=#hl-8-34>34</a>
</span><span class=lnt id=hl-8-35><a class=lnlinks href=#hl-8-35>35</a>
</span><span class=lnt id=hl-8-36><a class=lnlinks href=#hl-8-36>36</a>
</span><span class=lnt id=hl-8-37><a class=lnlinks href=#hl-8-37>37</a>
</span><span class=lnt id=hl-8-38><a class=lnlinks href=#hl-8-38>38</a>
</span><span class=lnt id=hl-8-39><a class=lnlinks href=#hl-8-39>39</a>
</span><span class=lnt id=hl-8-40><a class=lnlinks href=#hl-8-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>key</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BinarySearchTree</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_insert_recursive</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_insert_recursive</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 비어있는 트리에 삽입</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>Node</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 트리를 순회하며 적절한 위치에 삽입</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>key</span> <span class=o>&lt;</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_insert_recursive</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>key</span> <span class=o>&gt;</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_insert_recursive</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_search_recursive</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_search_recursive</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>key</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 기저 조건: 트리가 비어있거나 키를 찾은 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>or</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span> <span class=o>==</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 검색</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>key</span> <span class=o>&lt;</span> <span class=n>root</span><span class=o>.</span><span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_search_recursive</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 검색</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_search_recursive</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>key</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 동적 데이터에 효율적이며, 검색, 삽입, 삭제 연산이 모두 빠릅니다(균형 트리의 경우).</li><li><strong>단점</strong>: 구현이 복잡하고, 불균형 트리에서는 성능이 저하될 수 있습니다.</li></ul><h4 id=그래프-검색-알고리즘>그래프 검색 알고리즘<a hidden class=anchor aria-hidden=true href=#그래프-검색-알고리즘>#</a></h4><p>그래프 검색 알고리즘은 그래프 구조에서 특정 노드나 경로를 찾는 알고리즘으로, 너비 우선 검색(BFS)과 깊이 우선 검색(DFS)이 대표적.</p><h5 id=너비-우선-검색-breadth-first-search-bfs>너비 우선 검색 (Breadth-First Search, BFS)<a hidden class=anchor aria-hidden=true href=#너비-우선-검색-breadth-first-search-bfs>#</a></h5><p>특징:</p><ul><li><strong>작동 원리</strong>: 시작 노드에서 인접한 모든 노드를 먼저 탐색한 후, 다음 레벨의 노드로 이동.</li><li><strong>시간 복잡도</strong>: O(V + E), 여기서 V는 노드 수, E는 간선 수.</li><li><strong>공간 복잡도</strong>: O(V), 큐에 저장되는 노드 수.</li><li><strong>적용 상황</strong>: 최단 경로 문제, 연결 컴포넌트 찾기 등에 사용.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 방문한 노드 추적</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 큐 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>start</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 큐에서 노드 꺼내기</span>
</span></span><span class=line><span class=cl>        <span class=n>vertex</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>vertex</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>  <span class=c1># 방문 노드 출력</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 인접 노드 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=깊이-우선-검색-depth-first-search-dfs>깊이 우선 검색 (Depth-First Search, DFS)<a hidden class=anchor aria-hidden=true href=#깊이-우선-검색-depth-first-search-dfs>#</a></h5><p>특징:</p><ul><li><strong>작동 원리</strong>: 시작 노드에서 가능한 한 깊게 탐색한 후, 더 이상 진행할 수 없으면 백트래킹한다.</li><li><strong>시간 복잡도</strong>: O(V + E), 여기서 V는 노드 수, E는 간선 수.</li><li><strong>공간 복잡도</strong>: O(V), 재귀 호출 스택에 저장되는 노드 수.</li><li><strong>적용 상황</strong>: 사이클 감지, 위상 정렬, 연결 컴포넌트 분석 등에 사용된다.</li></ul><p>구현 (Python):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>visited</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>visited</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>start</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>  <span class=c1># 방문 노드 출력</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 인접 노드 탐색</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>start</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>장점</strong>: 그래프 구조에서 효율적으로 노드를 탐색할 수 있으며, 다양한 그래프 문제 해결에 활용됩니다.</li><li><strong>단점</strong>: 그래프 크기가 매우 크거나 사이클이 많은 경우 효율성이 떨어질 수 있습니다.</li></ul><h3 id=현대적-검색-알고리즘과-응용>현대적 검색 알고리즘과 응용<a hidden class=anchor aria-hidden=true href=#현대적-검색-알고리즘과-응용>#</a></h3><ol><li><p>전문 검색 엔진 (Full-Text Search)<br>전문 검색 엔진은 대량의 텍스트 데이터에서 특정 단어나 구문을 효율적으로 검색하는 시스템.<br>주요 기술:</p><ul><li><strong>역색인(Inverted Index)</strong>: 단어와 해당 단어가 등장하는 문서의 관계를 미리 인덱싱.</li><li><strong>토큰화(Tokenization)</strong>: 텍스트를 검색 가능한 토큰으로 분리.</li><li><strong>스템밍(Stemming)</strong>: 단어의 어근을 추출하여 다양한 형태의 단어를 매칭.</li><li><strong>랭킹 알고리즘</strong>: 검색 결과의 관련성을 평가하고 순위를 매긴다.<br>응용:</li><li>Elasticsearch, Solr, Lucene 등의 검색 엔진</li><li>웹 검색, 데이터베이스 검색 시스템</li></ul></li><li><p>기계 학습 기반 검색<br>기계 학습 알고리즘을 활용하여 사용자의 의도를 이해하고 더 관련성 높은 결과를 제공하는 검색 방법.<br>주요 기술:</p><ul><li><strong>추천 시스템</strong>: 사용자의 과거 행동을 기반으로 관련 항목을 추천.</li><li><strong>자연어 처리(NLP)</strong>: 검색 쿼리의 의미를 이해.</li><li><strong>딥러닝 모델</strong>: 이미지, 음성, 텍스트 등 다양한 형태의 데이터 검색에 활용.<br>응용:</li><li>Google의 검색 알고리즘</li><li>Netflix, Amazon 등의 추천 시스템</li><li>이미지 검색, 음성 검색 시스템</li></ul></li><li><p>분산 검색 시스템<br>대규모 데이터를 여러 서버에 분산하여 병렬적으로 검색하는 시스템.<br>주요 기술:</p><ul><li><strong>샤딩(Sharding)</strong>: 데이터를 여러 노드에 분산 저장.</li><li><strong>맵리듀스(MapReduce)</strong>: 분산 환경에서 데이터를 병렬적으로 처리.</li><li><strong>일관성 및 가용성 관리</strong>: 분산 시스템에서의 데이터 일관성과 가용성을 보장.<br>응용:</li><li>빅데이터 검색 시스템</li><li>클라우드 기반 검색 서비스</li><li>대규모 웹 크롤링 및 인덱싱 시스템</li></ul></li></ol><h3 id=검색-알고리즘-선택-가이드>검색 알고리즘 선택 가이드<a hidden class=anchor aria-hidden=true href=#검색-알고리즘-선택-가이드>#</a></h3><p>적절한 검색 알고리즘 선택은 데이터의 특성, 검색 빈도, 메모리 제약 등 여러 요소에 의해 결정된다.</p><ol><li><p>데이터가 정렬되어 있는 경우</p><ul><li><strong>작은 데이터 세트</strong>: 선형 검색도 충분히 효율적일 수 있다.</li><li><strong>중간 크기 데이터</strong>: 이진 검색, 점프 검색이 좋은 선택.</li><li><strong>대규모 데이터</strong>: 이진 검색, 보간 검색(균등 분포 시)이 효율적.</li><li><strong>무한 또는 매우 큰 데이터</strong>: 지수 검색이 유용하다.</li></ul></li><li><p>데이터가 정렬되어 있지 않은 경우</p><ul><li><strong>작은 데이터 세트</strong>: 선형 검색</li><li><strong>자주 검색하는 대규모 데이터</strong>: 해시 테이블을 구축하는 것이 효율적.</li><li><strong>동적으로 변경되는 데이터</strong>: 이진 검색 트리, AVL 트리, 레드-블랙 트리 등의 트리 구조가 적합.</li></ul></li><li><p>그래프 구조 데이터의 경우</p><ul><li><strong>최단 경로 찾기</strong>: BFS가 적합(가중치 없는 그래프).</li><li><strong>깊이 우선 탐색이 필요한 경우</strong>: DFS가 적합(미로 찾기, 위상 정렬 등).</li><li><strong>가중치 그래프의 최단 경로</strong>: 다익스트라 알고리즘, A* 알고리즘 등이 적합.</li></ul></li><li><p>메모리 제약이 있는 경우</p><ul><li><strong>메모리가 제한적인 환경</strong>: 선형 검색, 점프 검색이 간단하고 메모리 효율적.</li><li><strong>외부 저장 장치</strong>: B-트리, B+ 트리 등의 구조가 적합.</li></ul></li></ol><h3 id=검색-알고리즘의-최적화-기법>검색 알고리즘의 최적화 기법<a hidden class=anchor aria-hidden=true href=#검색-알고리즘의-최적화-기법>#</a></h3><p>검색 알고리즘의 성능을 향상시키기 위한 다양한 최적화 기법이 있다.</p><ol><li><p>캐싱 (Caching)<br>자주 검색하는 항목을 메모리에 저장하여 검색 속도를 높이는 기법.<br>구현 방법:<br>- <strong>LRU (Least Recently Used) 캐시</strong>: 가장 오래전에 사용된 항목을 제거.<br>- <strong>LFU (Least Frequently Used) 캐시</strong>: 가장 적게 사용된 항목을 제거.<br>- <strong>메모이제이션(Memoization)</strong>: 이전에 계산된 결과를 저장하여 재사용.<br>이점:<br>- 반복적인 검색에서 성능이 크게 향상된다.<br>- 비용이 많이 드는 연산을 줄일 수 있다.</p></li><li><p>병렬 검색 (Parallel Search)<br>여러 코어나 프로세서를 활용하여 동시에 검색을 수행하는 기법.<br>구현 방법:<br>- <strong>데이터 분할</strong>: 데이터를 여러 부분으로 나누어 각 부분을 병렬로 검색.<br>- <strong>맵리듀스(MapReduce)</strong>: 대규모 데이터를 병렬로 처리하는 프로그래밍 모델.<br>- <strong>멀티스레딩(Multithreading)</strong>: 여러 스레드를 사용하여 동시에 검색.<br>이점:<br>- 대규모 데이터에서 검색 속도가 크게 향상된다.<br>- 여러 검색 작업을 동시에 처리할 수 있다.</p></li><li><p>인덱싱 (Indexing)<br>데이터에 대한 인덱스를 미리 구축하여 검색 속도를 높이는 기법.<br>구현 방법:<br>- <strong>B-트리, B+ 트리</strong>: 데이터베이스 시스템에서 널리 사용되는 인덱싱 구조.<br>- <strong>역색인(Inverted Index)</strong>: 전문 검색 엔진에서 사용하는 인덱싱 방식.<br>- <strong>공간 인덱싱(Spatial Indexing)</strong>: 지리적 데이터를 효율적으로 검색하기 위한 구조.<br>이점:<br>- 검색 속도가 크게 향상된다.<br>- 복잡한 쿼리를 효율적으로 처리할 수 있다.</p></li><li><p>근사 검색 (Approximate Search)<br>정확한 결과 대신 근사한 결과를 빠르게 제공하는 기법.<br>구현 방법:<br>- <strong>LSH (Locality-Sensitive Hashing)</strong>: 유사한 항목을 같은 버킷에 매핑하는 해싱 기법.<br>- <strong>랜덤 프로젝션(Random Projection)</strong>: 고차원 데이터를 저차원으로 투영하여 검색.<br>- <strong>스킵 리스트(Skip List)</strong>: 확률적 데이터 구조로, 빠른 검색을 위한 여러 레벨의 링크를 제공.<br>이점:<br>- 매우 대규모 데이터에서 효율적.<br>- 정확한 일치가 필요하지 않은 응용 프로그램에 적합.</p></li></ol><h3 id=검색-알고리즘의-실제-응용-사례>검색 알고리즘의 실제 응용 사례<a hidden class=anchor aria-hidden=true href=#검색-알고리즘의-실제-응용-사례>#</a></h3><p>검색 알고리즘은 다양한 실생활 및 산업 분야에서 활용되고 있다.</p><ol><li><p>웹 검색 엔진: 웹 검색 엔진은 인터넷에서 정보를 찾는 핵심 도구.<br>적용 기술:<br>- <strong>크롤링(Crawling)</strong>: 웹 페이지를 수집하고 인덱싱한다.<br>- <strong>페이지랭크(PageRank)</strong>: 웹 페이지의 중요도를 평가한다.<br>- <strong>전문 검색(Full-Text Search)</strong>: 페이지 내용을 인덱싱하고 검색한다.<br>- <strong>머신러닝 기반 랭킹</strong>: 사용자의 관심사와 쿼리의 의도를 분석하여 결과 순위를 매긴다.<br>예시:<br>- Google, Bing, Yahoo 등의 검색 엔진</p></li><li><p>데이터베이스 시스템<br>데이터베이스 시스템은 대량의 데이터를 저장하고 빠르게 검색하는 시스템.<br>적용 기술:<br>- <strong>인덱싱</strong>: B-트리, 해시 인덱스 등을 사용하여 검색 속도를 높인다.<br>- <strong>쿼리 최적화(Query Optimization)</strong>: 가장 효율적인 검색 방법을 선택한다.<br>- <strong>트랜잭션 관리</strong>: 데이터 일관성을 유지하면서 검색을 수행한다.</p><p>예시:<br>- MySQL, PostgreSQL, Oracle 등의 관계형 데이터베이스<br>- MongoDB, Cassandra 등의 NoSQL 데이터베이스</p></li><li><p>추천 시스템<br>사용자의 선호도를 분석하여 관련 항목을 추천하는 시스템.<br>적용 기술:<br>- <strong>협업 필터링(Collaborative Filtering)</strong>: 유사한 사용자의 선호도를 기반으로 추천.<br>- <strong>콘텐츠 기반 필터링(Content-Based Filtering)</strong>: 항목의 특성을 분석하여 유사한 항목을 추천.<br>- <strong>하이브리드 접근법</strong>: 여러 방법을 결합하여 더 정확한 추천을 제공.<br>예시:<br>- Amazon의 상품 추천 시스템<br>- Netflix, YouTube의 콘텐츠 추천 알고리즘<br>- Spotify의 음악 추천 시스템</p></li><li><p>바이오인포매틱스<br>유전체 서열, 단백질 구조 등 생물학적 데이터를 분석하는 분야.<br>적용 기술:<br>- <strong>서열 정렬(Sequence Alignment)</strong>: DNA, RNA, 단백질 서열의 유사성을 검색.<br>- <strong>패턴 매칭(Pattern Matching)</strong>: 생물학적 패턴을 효율적으로 검색.<br>- <strong>구조 검색(Structure Search)</strong>: 단백질, RNA 등의 3D 구조를 비교.<br>예시:<br>- BLAST(Basic Local Alignment Search Tool)<br>- 단백질 구조 데이터베이스 검색 시스템<br>- 약물 발견 및 설계를 위한 분자 검색 시스템</p></li><li><p>컴퓨터 비전 및 이미지 검색<br>이미지나 비디오에서 특정 객체나 패턴을 검색하는 기술.<br>적용 기술:<br>- <strong>특징 추출(Feature Extraction)</strong>: 이미지에서 중요한 특징을 추출.<br>- <strong>유사도 측정(Similarity Measurement)</strong>: 이미지 간의 유사성을 계산.<br>- <strong>객체 인식(Object Recognition)</strong>: 이미지 내의 객체를 식별.<br>예시:<br>- Google 이미지 검색<br>- 얼굴 인식 시스템<br>- 의료 영상에서의 병변 검출 시스템</p></li></ol><h3 id=검색-알고리즘의-미래-동향>검색 알고리즘의 미래 동향<a hidden class=anchor aria-hidden=true href=#검색-알고리즘의-미래-동향>#</a></h3><p>검색 알고리즘 분야는 계속해서 발전하고 있으며, 몇 가지 주요 동향이 관찰된다.</p><ol><li><p>인공지능과 검색의 통합<br>머신러닝과 딥러닝 기술이 검색 알고리즘을 더 지능적으로 만들고 있다.<br>주요 발전:<br>- <strong>자연어 이해(Natural Language Understanding)</strong>: 검색 쿼리의 의미를 더 정확하게 이해한다.<br>- <strong>맥락 인식 검색(Context-Aware Search)</strong>: 사용자의 상황, 이전 검색 이력, 선호도 등을 고려한다.<br>- <strong>멀티모달 검색(Multimodal Search)</strong>: 텍스트, 이미지, 음성 등 다양한 형태의 데이터를 통합하여 검색한다.</p></li><li><p>양자 검색 알고리즘<br>양자 컴퓨팅의 발전으로 새로운 검색 알고리즘이 개발되고 있다.<br>주요 발전:<br>- <strong>그로버 알고리즘(Grover&rsquo;s Algorithm)</strong>: 정렬되지 않은 데이터베이스에서 O(√n) 시간에 검색할 수 있는 양자 알고리즘.<br>- <strong>양자 병렬 처리(Quantum Parallelism)</strong>: 양자 중첩을 활용하여 여러 검색을 동시에 수행.<br>- <strong>양자 인덱싱(Quantum Indexing)</strong>: 양자 상태를 활용한 새로운 인덱싱 방법이 연구되고 있다.</p></li><li><p>분산 및 엣지 컴퓨팅 검색<br>데이터와 컴퓨팅 리소스가 분산되는 트렌드에 맞춰 검색 알고리즘도 변화하고 있다.<br>주요 발전:<br>- <strong>분산 인덱싱(Distributed Indexing)</strong>: 여러 노드에 분산된 인덱스를 효율적으로 관리.<br>- <strong>엣지 검색(Edge Search)</strong>: 데이터 소스 가까이에서 검색을 수행하여 지연 시간을 줄인다.<br>- <strong>연합 검색(Federated Search)</strong>: 여러 독립적인 데이터 소스에서 통합된 검색 결과를 제공.</p></li><li><p>프라이버시 보존 검색<br>개인 정보 보호가 중요해지면서 프라이버시를 보존하는 검색 방법이 발전하고 있다.<br>주요 발전:<br>- <strong>동형 암호화(Homomorphic Encryption)</strong>: 암호화된 상태에서 검색을 수행.<br>- <strong>차등 프라이버시(Differential Privacy)</strong>: 개인 정보를 보호하면서도 유용한 검색 결과를 제공.<br>- <strong>탈중앙화 검색(Decentralized Search)</strong>: 중앙 서버 없이 분산된 환경에서 검색을 수행.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>