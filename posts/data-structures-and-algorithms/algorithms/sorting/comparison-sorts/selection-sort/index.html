<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>선택 정렬 (Selection Sort) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Algorithms,Sorting,Types,Selection-Sort"><meta name=description content="선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.  전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="선택 정렬 (Selection Sort)"><meta property="og:description" content="선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.  전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-15T08:38:00+00:00"><meta property="article:modified_time" content="2024-10-15T08:38:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Sorting"><meta property="article:tag" content="Types"><meta property="article:tag" content="Selection-Sort"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="선택 정렬 (Selection Sort)"><meta name=twitter:description content="선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.  전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/"},{"@type":"ListItem","position":4,"name":"정렬 알고리즘 (Sorting Algorithms)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/"},{"@type":"ListItem","position":5,"name":"Types of Sorting Algorithm","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/"},{"@type":"ListItem","position":6,"name":"선택 정렬 (Selection Sort)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"선택 정렬 (Selection Sort)","name":"선택 정렬 (Selection Sort)","description":"선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.  전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.","keywords":["Data-Structures-and-Algorithms","Algorithms","Sorting","Types","Selection-Sort"],"articleBody":"선택 정렬 (Selection Sort) 선택 정렬은 가장 직관적이고 이해하기 쉬운 정렬 알고리즘 중 하나이다.\n선택 정렬은 개념적으로 가장 단순한 정렬 알고리즘 중 하나로, 알고리즘을 처음 배우는 사람들에게 좋은 시작점이 된다. 비록 대규모 데이터에서는 효율적이지 않지만, 특정 상황에서는 실용적인 선택이 될 수 있다.\n선택 정렬의 핵심 특징은 다음과 같다:\n구현이 매우 간단합니다. 교환 연산의 수가 적습니다(최대 n-1번). 메모리 사용이 최소화된다. 입력 데이터의 상태와 관계없이 일정한 성능을 보인다. 더 효율적인 정렬 알고리즘이 많이 존재하지만, 선택 정렬은 그 단순함과 직관적인 접근 방식으로 알고리즘 학습에 중요한 역할을 한다. 또한 작은 데이터셋이나 특정 제약 조건이 있는 환경에서는 여전히 유용한 알고리즘이다.\nhttps://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw\n선택 정렬의 기본 원리 선택 정렬은 다음과 같은 간단한 아이디어에 기반한다:\n정렬되지 않은 부분에서 최솟값(또는 최댓값)을 찾는다. 이 값을 정렬되지 않은 부분의 첫 번째 요소와 교환한다. 정렬된 부분의 경계를 한 칸 오른쪽으로 이동시킨다. 배열 전체가 정렬될 때까지 위 과정을 반복한다. 이 과정을 거치면 배열의 왼쪽부터 차례대로 정렬된 요소들이 쌓이게 된다.\n선택 정렬의 시각화 과정 [64, 25, 12, 22, 11] 배열을 선택 정렬로 정렬하는 과정을 단계별로 시각화:\n전체 배열에서 최솟값 11을 찾아 첫 번째 위치(인덱스 0)와 교환\n1 2 3 4 [64, 25, 12, 22, 11] → [11, 25, 12, 22, 64] ^ ^ ^-----------------\u003e 정렬된 부분 | | +---------------+ 교환 나머지 배열 [25, 12, 22, 64]에서 최솟값 12를 찾아 두 번째 위치(인덱스 1)와 교환\n1 2 3 4 [11, 25, 12, 22, 64] → [11, 12, 25, 22, 64] ^ ^ ^-------------\u003e 정렬된 부분 | | +---+ 교환 나머지 배열 [25, 22, 64]에서 최솟값 22를 찾아 세 번째 위치(인덱스 2)와 교환\n1 2 3 4 [11, 12, 25, 22, 64] → [11, 12, 22, 25, 64] ^ ^ ^----------\u003e 정렬된 부분 | | +---+ 교환 나머지 배열 [25, 64]에서 최솟값 25는 이미 네 번째 위치(인덱스 3)에 있으므로 교환 필요 없음\n1 2 3 4 [11, 12, 22, 25, 64] → [11, 12, 22, 25, 64] ^ ^-------\u003e 정렬된 부분 | + 이미 최솟값 마지막 요소 64는 이미 올바른 위치에 있으므로 정렬 완료\n1 2 3 [11, 12, 22, 25, 64] ^ + 정렬 완료 이렇게 매 단계마다 정렬되지 않은 부분에서 최솟값을 찾아 정렬된 부분의 끝에 추가하는 방식으로 정렬이 진행된다.\n선택 정렬의 구현 아래는 Python으로 구현한 선택 정렬 알고리즘:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def selection_sort(arr): n = len(arr) # 배열의 각 위치에 대해 반복 for i in range(n): # 현재 위치를 최솟값의 인덱스로 초기화 min_idx = i # i부터 끝까지 탐색하여 최솟값 찾기 for j in range(i + 1, n): if arr[j] \u003c arr[min_idx]: min_idx = j # 찾은 최솟값을 현재 위치와 교환 arr[i], arr[min_idx] = arr[min_idx], arr[i] return arr # 사용 예시 arr = [64, 25, 12, 22, 11] sorted_arr = selection_sort(arr) print(sorted_arr) # [11, 12, 22, 25, 64] 이 코드는 모든 단계에서 배열의 일부분에서 최솟값을 찾아 적절한 위치로 이동시키는 과정을 명확히 보여준다.\n선택 정렬의 특징 시간 복잡도\n최선의 경우: O(n²) - 이미 정렬되어 있는 경우에도 모든 요소를 비교 평균적인 경우: O(n²) 최악의 경우: O(n²)\n선택 정렬의 가장 큰 특징은 입력 배열의 상태와 관계없이 항상 동일한 시간 복잡도를 가진다. 이는 항상 모든 요소를 비교해야 하기 때문이다. 공간 복잡도\nO(1) - 추가 메모리가 거의 필요 없는 제자리(in-place) 정렬 알고리즘 안정성\n선택 정렬은 기본적으로 불안정(unstable) 정렬이다. 같은 값을 가진 요소들의 상대적 순서가 정렬 과정에서 바뀔 수 있다.\n예를 들어, [4, 2, 3, 4', 1]이라는 배열이 있다고 가정해 보면(4’는 첫 번째 4와 구분하기 위한 표시). 선택 정렬 후에는 [1, 2, 3, 4', 4] 또는 [1, 2, 3, 4, 4']와 같이 두 개의 4의 순서가 바뀔 수 있다. 선택 정렬의 성능 개선 방법 양방향 선택 정렬(Bidirectional Selection Sort)\n한 번의 반복에서 최솟값과 최댓값을 동시에 찾아 양쪽 끝에 배치하는 방식:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def bidirectional_selection_sort(arr): n = len(arr) left, right = 0, n - 1 while left \u003c right: min_idx = left max_idx = left # 현재 범위에서 최솟값과 최댓값 찾기 for i in range(left, right + 1): if arr[i] \u003c arr[min_idx]: min_idx = i elif arr[i] \u003e arr[max_idx]: max_idx = i # 최솟값을 왼쪽 끝으로 이동 if min_idx != left: arr[left], arr[min_idx] = arr[min_idx], arr[left] # 만약 최댓값이 최솟값의 위치에 있었다면 인덱스 조정 if max_idx == left: max_idx = min_idx # 최댓값을 오른쪽 끝으로 이동 if max_idx != right: arr[right], arr[max_idx] = arr[max_idx], arr[right] # 범위 좁히기 left += 1 right -= 1 return arr 이 방식은 비교 횟수는 동일하지만, 교환 횟수를 줄여 약간의 성능 향상을 기대할 수 있다.\n힙 정렬(Heap Sort)로의 확장\n선택 정렬의 아이디어를 확장하여 힙 자료구조를 활용하면 O(n log n)의 시간 복잡도를 가진 힙 정렬이 된다.\n힙을 사용하면 최솟값(또는 최댓값)을 O(log n) 시간에 찾을 수 있어 전체 시간 복잡도가 개선된다.\n6. 선택 정렬의 실제 적용 적합한 사용 상황\n선택 정렬은 다음과 같은 상황에서 고려할 수 있다: 간단한 구현이 필요할 때: 코드가 짧고 이해하기 쉬움 작은 크기의 배열: 요소 수가 적은 배열에서는 준수한 성능 교환 연산이 비싼 경우: 선택 정렬은 최대 n번의 교환만 수행 실제 사용 예시 교육용 목적: 알고리즘의 기본 개념 이해 임베디드 시스템: 메모리가 제한적인 환경 이미 거의 정렬된 배열에서 몇 개의 요소만 올바른 위치에 넣어야 할 때 실제 코드 분석 - 선택 정렬의 변형들 최솟값과 최댓값을 동시에 찾는 변형 이 변형은 각 반복에서 최솟값과 최댓값을 동시에 찾아 양쪽에서 정렬하는 방식으로, 비교 횟수를 줄일 수 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def min_max_selection_sort(arr): n = len(arr) left = 0 right = n - 1 while left \u003c right: # 최솟값과 최댓값의 초기 인덱스 min_idx = left max_idx = left for i in range(left + 1, right + 1): if arr[i] \u003c arr[min_idx]: min_idx = i elif arr[i] \u003e arr[max_idx]: max_idx = i # 최솟값을 왼쪽에 배치 arr[left], arr[min_idx] = arr[min_idx], arr[left] # 만약 최댓값이 최솟값 위치에 있었다면 인덱스 업데이트 if max_idx == left: max_idx = min_idx # 최댓값을 오른쪽에 배치 arr[right], arr[max_idx] = arr[max_idx], arr[right] # 포인터 이동 left += 1 right -= 1 return arr 재귀적 구현 선택 정렬을 재귀적으로 구현할 수도 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def recursive_selection_sort(arr, start_idx=0): # 종료 조건 if start_idx \u003e= len(arr) - 1: return # 최솟값 찾기 min_idx = start_idx for i in range(start_idx + 1, len(arr)): if arr[i] \u003c arr[min_idx]: min_idx = i # 최솟값을 현재 위치와 교환 if min_idx != start_idx: arr[start_idx], arr[min_idx] = arr[min_idx], arr[start_idx] # 다음 위치부터 재귀적으로 정렬 recursive_selection_sort(arr, start_idx + 1) return arr 참고 및 출처 ","wordCount":"1093","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-15T08:38:00Z","dateModified":"2024-10-15T08:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/>Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/>정렬 알고리즘 (Sorting Algorithms)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/>Types of Sorting Algorithm</a></div><h1 class="post-title entry-hint-parent">선택 정렬 (Selection Sort)</h1><div class=post-description>선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다. 전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.</div><div class=post-meta><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Algorithms/Sorting/Comparison%20Sorts/Selection-Sort.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#선택-정렬-selection-sort>선택 정렬 (Selection Sort)</a><ul><li><a href=#선택-정렬의-기본-원리>선택 정렬의 기본 원리</a></li><li><a href=#선택-정렬의-시각화-과정>선택 정렬의 시각화 과정</a></li><li><a href=#선택-정렬의-구현>선택 정렬의 구현</a></li><li><a href=#선택-정렬의-특징>선택 정렬의 특징</a></li><li><a href=#선택-정렬의-성능-개선-방법>선택 정렬의 성능 개선 방법</a></li><li><a href=#6-선택-정렬의-실제-적용>6. 선택 정렬의 실제 적용</a></li><li><a href=#실제-코드-분석---선택-정렬의-변형들>실제 코드 분석 - 선택 정렬의 변형들</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=선택-정렬-selection-sort>선택 정렬 (Selection Sort)<a hidden class=anchor aria-hidden=true href=#선택-정렬-selection-sort>#</a></h2><p>선택 정렬은 가장 직관적이고 이해하기 쉬운 정렬 알고리즘 중 하나이다.</p><p>선택 정렬은 개념적으로 가장 단순한 정렬 알고리즘 중 하나로, 알고리즘을 처음 배우는 사람들에게 좋은 시작점이 된다. 비록 대규모 데이터에서는 효율적이지 않지만, 특정 상황에서는 실용적인 선택이 될 수 있다.</p><p>선택 정렬의 핵심 특징은 다음과 같다:</p><ul><li>구현이 매우 간단합니다.</li><li>교환 연산의 수가 적습니다(최대 n-1번).</li><li>메모리 사용이 최소화된다.</li><li>입력 데이터의 상태와 관계없이 일정한 성능을 보인다.</li></ul><p>더 효율적인 정렬 알고리즘이 많이 존재하지만, 선택 정렬은 그 단순함과 직관적인 접근 방식으로 알고리즘 학습에 중요한 역할을 한다. 또한 작은 데이터셋이나 특정 제약 조건이 있는 환경에서는 여전히 유용한 알고리즘이다.</p><p><figure><img alt="Selection Sort" loading=lazy src=/img/Selection-sort.png><figcaption>https://www.perplexity.ai/search/computer-architecture-eseo-cac-DTWMIKIVRnOtdnLMm0Ydrw</figcaption></figure></p><h3 id=선택-정렬의-기본-원리>선택 정렬의 기본 원리<a hidden class=anchor aria-hidden=true href=#선택-정렬의-기본-원리>#</a></h3><p>선택 정렬은 다음과 같은 간단한 아이디어에 기반한다:</p><ol><li>정렬되지 않은 부분에서 최솟값(또는 최댓값)을 찾는다.</li><li>이 값을 정렬되지 않은 부분의 첫 번째 요소와 교환한다.</li><li>정렬된 부분의 경계를 한 칸 오른쪽으로 이동시킨다.</li><li>배열 전체가 정렬될 때까지 위 과정을 반복한다.</li></ol><p>이 과정을 거치면 배열의 왼쪽부터 차례대로 정렬된 요소들이 쌓이게 된다.</p><h3 id=선택-정렬의-시각화-과정>선택 정렬의 시각화 과정<a hidden class=anchor aria-hidden=true href=#선택-정렬의-시각화-과정>#</a></h3><p><code>[64, 25, 12, 22, 11]</code> 배열을 선택 정렬로 정렬하는 과정을 단계별로 시각화:</p><ol><li><p>전체 배열에서 최솟값 11을 찾아 첫 번째 위치(인덱스 0)와 교환</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[64, 25, 12, 22, 11] → [11, 25, 12, 22, 64]
</span></span><span class=line><span class=cl>  ^               ^      ^-----------------&gt; 정렬된 부분
</span></span><span class=line><span class=cl>  |               |
</span></span><span class=line><span class=cl>  +---------------+ 교환
</span></span></code></pre></td></tr></table></div></div></li><li><p>나머지 배열 <code>[25, 12, 22, 64]</code>에서 최솟값 12를 찾아 두 번째 위치(인덱스 1)와 교환</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[11, 25, 12, 22, 64] → [11, 12, 25, 22, 64]
</span></span><span class=line><span class=cl>      ^   ^                ^-------------&gt; 정렬된 부분
</span></span><span class=line><span class=cl>      |   |
</span></span><span class=line><span class=cl>      +---+ 교환
</span></span></code></pre></td></tr></table></div></div></li><li><p>나머지 배열 <code>[25, 22, 64]</code>에서 최솟값 22를 찾아 세 번째 위치(인덱스 2)와 교환</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[11, 12, 25, 22, 64] → [11, 12, 22, 25, 64]
</span></span><span class=line><span class=cl>          ^   ^            ^----------&gt; 정렬된 부분
</span></span><span class=line><span class=cl>          |   |
</span></span><span class=line><span class=cl>          +---+ 교환
</span></span></code></pre></td></tr></table></div></div></li><li><p>나머지 배열 <code>[25, 64]</code>에서 최솟값 25는 이미 네 번째 위치(인덱스 3)에 있으므로 교환 필요 없음</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[11, 12, 22, 25, 64] → [11, 12, 22, 25, 64]
</span></span><span class=line><span class=cl>              ^                ^-------&gt; 정렬된 부분
</span></span><span class=line><span class=cl>              |
</span></span><span class=line><span class=cl>              + 이미 최솟값
</span></span></code></pre></td></tr></table></div></div></li><li><p>마지막 요소 64는 이미 올바른 위치에 있으므로 정렬 완료</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[11, 12, 22, 25, 64]
</span></span><span class=line><span class=cl>                  ^
</span></span><span class=line><span class=cl>                  + 정렬 완료
</span></span></code></pre></td></tr></table></div></div></li></ol><p>이렇게 매 단계마다 정렬되지 않은 부분에서 최솟값을 찾아 정렬된 부분의 끝에 추가하는 방식으로 정렬이 진행된다.</p><h3 id=선택-정렬의-구현>선택 정렬의 구현<a hidden class=anchor aria-hidden=true href=#선택-정렬의-구현>#</a></h3><p>아래는 Python으로 구현한 선택 정렬 알고리즘:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 배열의 각 위치에 대해 반복</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 위치를 최솟값의 인덱스로 초기화</span>
</span></span><span class=line><span class=cl>        <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># i부터 끝까지 탐색하여 최솟값 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_idx</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>        <span class=c1># 찾은 최솟값을 현재 위치와 교환</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>64</span><span class=p>,</span> <span class=mi>25</span><span class=p>,</span> <span class=mi>12</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>11</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>sorted_arr</span> <span class=o>=</span> <span class=n>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sorted_arr</span><span class=p>)</span>  <span class=c1># [11, 12, 22, 25, 64]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드는 모든 단계에서 배열의 일부분에서 최솟값을 찾아 적절한 위치로 이동시키는 과정을 명확히 보여준다.</p><h3 id=선택-정렬의-특징>선택 정렬의 특징<a hidden class=anchor aria-hidden=true href=#선택-정렬의-특징>#</a></h3><ol><li><p>시간 복잡도</p><ul><li><strong>최선의 경우</strong>: O(n²) - 이미 정렬되어 있는 경우에도 모든 요소를 비교</li><li><strong>평균적인 경우</strong>: O(n²)</li><li><strong>최악의 경우</strong>: O(n²)<br>선택 정렬의 가장 큰 특징은 입력 배열의 상태와 관계없이 항상 동일한 시간 복잡도를 가진다. 이는 항상 모든 요소를 비교해야 하기 때문이다.</li></ul></li><li><p>공간 복잡도</p><ul><li>O(1) - 추가 메모리가 거의 필요 없는 제자리(in-place) 정렬 알고리즘</li></ul></li><li><p>안정성</p><ul><li>선택 정렬은 기본적으로 불안정(unstable) 정렬이다. 같은 값을 가진 요소들의 상대적 순서가 정렬 과정에서 바뀔 수 있다.<br>예를 들어, <code>[4, 2, 3, 4', 1]</code>이라는 배열이 있다고 가정해 보면(4&rsquo;는 첫 번째 4와 구분하기 위한 표시). 선택 정렬 후에는 <code>[1, 2, 3, 4', 4]</code> 또는 <code>[1, 2, 3, 4, 4']</code>와 같이 두 개의 4의 순서가 바뀔 수 있다.</li></ul></li></ol><h3 id=선택-정렬의-성능-개선-방법>선택 정렬의 성능 개선 방법<a hidden class=anchor aria-hidden=true href=#선택-정렬의-성능-개선-방법>#</a></h3><ol><li><p>양방향 선택 정렬(Bidirectional Selection Sort)<br>한 번의 반복에서 최솟값과 최댓값을 동시에 찾아 양쪽 끝에 배치하는 방식:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>bidirectional_selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>min_idx</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=n>max_idx</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 범위에서 최솟값과 최댓값 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>max_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 최솟값을 왼쪽 끝으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>min_idx</span> <span class=o>!=</span> <span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 만약 최댓값이 최솟값의 위치에 있었다면 인덱스 조정</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>max_idx</span> <span class=o>==</span> <span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_idx</span> <span class=o>=</span> <span class=n>min_idx</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 최댓값을 오른쪽 끝으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>max_idx</span> <span class=o>!=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>max_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>max_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 범위 좁히기</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 비교 횟수는 동일하지만, 교환 횟수를 줄여 약간의 성능 향상을 기대할 수 있다.</p></li><li><p>힙 정렬(Heap Sort)로의 확장<br>선택 정렬의 아이디어를 확장하여 힙 자료구조를 활용하면 O(n log n)의 시간 복잡도를 가진 힙 정렬이 된다.<br>힙을 사용하면 최솟값(또는 최댓값)을 O(log n) 시간에 찾을 수 있어 전체 시간 복잡도가 개선된다.</p></li></ol><h3 id=6-선택-정렬의-실제-적용>6. 선택 정렬의 실제 적용<a hidden class=anchor aria-hidden=true href=#6-선택-정렬의-실제-적용>#</a></h3><ol><li>적합한 사용 상황<br>선택 정렬은 다음과 같은 상황에서 고려할 수 있다:<ol><li><strong>간단한 구현이 필요할 때</strong>: 코드가 짧고 이해하기 쉬움</li><li><strong>작은 크기의 배열</strong>: 요소 수가 적은 배열에서는 준수한 성능</li><li><strong>교환 연산이 비싼 경우</strong>: 선택 정렬은 최대 n번의 교환만 수행</li></ol></li><li>실제 사용 예시<ul><li>교육용 목적: 알고리즘의 기본 개념 이해</li><li>임베디드 시스템: 메모리가 제한적인 환경</li><li>이미 거의 정렬된 배열에서 몇 개의 요소만 올바른 위치에 넣어야 할 때</li></ul></li></ol><h3 id=실제-코드-분석---선택-정렬의-변형들>실제 코드 분석 - 선택 정렬의 변형들<a hidden class=anchor aria-hidden=true href=#실제-코드-분석---선택-정렬의-변형들>#</a></h3><h4 id=최솟값과-최댓값을-동시에-찾는-변형>최솟값과 최댓값을 동시에 찾는 변형<a hidden class=anchor aria-hidden=true href=#최솟값과-최댓값을-동시에-찾는-변형>#</a></h4><p>이 변형은 각 반복에서 최솟값과 최댓값을 동시에 찾아 양쪽에서 정렬하는 방식으로, 비교 횟수를 줄일 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>min_max_selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 최솟값과 최댓값의 초기 인덱스</span>
</span></span><span class=line><span class=cl>        <span class=n>min_idx</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=n>max_idx</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>right</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>max_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 최솟값을 왼쪽에 배치</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 만약 최댓값이 최솟값 위치에 있었다면 인덱스 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>max_idx</span> <span class=o>==</span> <span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>max_idx</span> <span class=o>=</span> <span class=n>min_idx</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 최댓값을 오른쪽에 배치</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>max_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>max_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 포인터 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=재귀적-구현>재귀적 구현<a hidden class=anchor aria-hidden=true href=#재귀적-구현>#</a></h4><p>선택 정렬을 재귀적으로 구현할 수도 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>recursive_selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>start_idx</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 종료 조건</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>start_idx</span> <span class=o>&gt;=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최솟값 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>min_idx</span> <span class=o>=</span> <span class=n>start_idx</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>start_idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최솟값을 현재 위치와 교환</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>min_idx</span> <span class=o>!=</span> <span class=n>start_idx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>start_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>start_idx</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 다음 위치부터 재귀적으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>recursive_selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>start_idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/algorithms/>Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/sorting/>Sorting</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/selection-sort/>Selection-Sort</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-science-and-engineering/data-pipeline-pattern/><span class=title>« Prev</span><br><span>Data Pipeline Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/searching/types/binary-search/><span class=title>Next »</span><br><span>이진 검색 (Binary Search)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>