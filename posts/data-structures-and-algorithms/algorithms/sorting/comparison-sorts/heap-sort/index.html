<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>힙 정렬 (Heap Sort) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Algorithms,Sorting,Types,Heap-Sort"><meta name=description content="힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="힙 정렬 (Heap Sort)"><meta property="og:description" content="힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-15T08:38:00+00:00"><meta property="article:modified_time" content="2024-10-15T08:38:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Sorting"><meta property="article:tag" content="Types"><meta property="article:tag" content="Heap-Sort"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="힙 정렬 (Heap Sort)"><meta name=twitter:description content="힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/"},{"@type":"ListItem","position":4,"name":"정렬 알고리즘 (Sorting Algorithms)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/"},{"@type":"ListItem","position":5,"name":"Types of Sorting Algorithm","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/"},{"@type":"ListItem","position":6,"name":"힙 정렬 (Heap Sort)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"힙 정렬 (Heap Sort)","name":"힙 정렬 (Heap Sort)","description":"힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.","keywords":["Data-Structures-and-Algorithms","Algorithms","Sorting","Types","Heap-Sort"],"articleBody":"힙 정렬 (Heap Sort) 힙 정렬은 비교 기반 정렬 알고리즘으로, 이진 힙 자료구조를 활용하여 효율적인 정렬을 수행한다.\n시간 복잡도가 안정적이고 추가 메모리를 거의 사용하지 않는 특징을 가지고 있어 많은 시스템에서 널리 사용된다.\n힙 정렬은 비교 기반 정렬 알고리즘 중에서 시간 복잡도가 보장되고 추가 메모리를 거의 사용하지 않는 효율적인 알고리즘이다.\n최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지며, 특히 메모리 제약이 있는 환경에서 유용하다.\n불안정 정렬이라는 단점이 있지만, 안정성이 중요하지 않은 많은 응용 분야에서 여전히 강력한 선택지이다. 힙 자료구조의 이해는 우선순위 큐, 그래프 알고리즘 등 컴퓨터 과학의 다른 영역에도 도움이 된다.\n힙(Heap) 자료구조의 이해 힙 정렬을 이해하기 위해서는 먼저 힙 자료구조에 대한 이해가 필요하다.\n힙의 정의 힙은 다음 두 가지 특성을 만족하는 완전 이진 트리이다:\n완전 이진 트리(Complete Binary Tree): 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드들은 왼쪽부터 채워져 있다. 힙 속성(Heap Property): 최대 힙(Max Heap): 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같음 최소 힙(Min Heap): 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같음 힙의 표현 힙은 일반적으로 배열을 사용하여 표현한다.\n이진 트리의 레벨 순서 탐색(level-order traversal)과 같은 방식으로 배열에 저장된다.\n배열에서 인덱스 i의 노드에 대해:\n부모 노드 인덱스: (i-1) // 2 (파이썬 기준) 왼쪽 자식 노드 인덱스: 2*i + 1 오른쪽 자식 노드 인덱스: 2*i + 2 이러한 규칙을 통해 포인터 없이도 트리 구조를 효율적으로 표현할 수 있다.\n힙 정렬 알고리즘의 원리 힙 정렬은 힙의 특성을 활용하여 정렬을 수행한다.\n주요 단계는 다음과 같다:\n힙 구성(Heapify): 주어진 배열을 힙으로 변환한다. 주어진 배열을 힙(Heap) 구조로 변환 Heapify 연산을 수행하여 최대 힙(또는 최소 힙) 구성 정렬: 힙에서 원소를 하나씩 제거하여 정렬된 배열을 구성한다. 루트(최댓값 또는 최솟값)를 제거하고, 힙을 재정렬 반복적으로 수행하여 정렬된 배열 생성 힙 정렬 과정 예제 정렬할 배열:\n1 [4, 10, 3, 5, 1] 최대 힙(Max Heap) 구성\n1 2 3 4 5 10 / \\ 5 3 / \\ 4 1 루트(최대값 10)를 제거하고 배열 끝으로 이동\n1 2 3 4 5 5 / \\ 4 3 / 1 → 정렬된 배열: [10]\nHeapify 수행 후 최대 힙 유지\n1 2 3 4 5 5 / \\ 4 3 / 1 다시 루트(최대값 5)를 제거하고 배열 끝으로 이동\n1 2 3 4 / \\ 1 3 → 정렬된 배열: [5, 10]\n반복 수행하여 전체 정렬 완료\n1 [1, 3, 4, 5, 10] 결과적으로 오름차순 정렬이 수행됨\n최대 힙 구성 과정 초기 배열: [4, 10, 3, 5, 1] 마지막 비단말 노드(인덱스 1, 값 10)부터 시작: 인덱스 1은 이미 최대 힙 속성을 만족 인덱스 0(값 4)에 대한 heapify: 자식 노드들과 비교하여 최댓값(10)을 찾음 4와 10을 교환: [10, 4, 3, 5, 1] 인덱스 1에 대해 heapify 재귀 호출: 자식 노드들과 비교하여 최댓값(5)을 찾음 4와 5를 교환: [10, 5, 3, 4, 1]\n최종 최대 힙: [10, 5, 3, 4, 1] 정렬 과정 루트(10)와 마지막 요소(1) 교환: [1, 5, 3, 4, 10] 힙 크기를 4로 줄이고 heapify 수행 결과: [5, 4, 3, 1 | 10] (막대는 힙과 정렬된 부분의 경계) 루트(5)와 마지막 요소(1) 교환: [1, 4, 3, 5 | 10] 힙 크기를 3으로 줄이고 heapify 수행 결과: [4, 1, 3 | 5, 10] 루트(4)와 마지막 요소(3) 교환: [3, 1, 4 | 5, 10] 힙 크기를 2로 줄이고 heapify 수행 결과: [3, 1 | 4, 5, 10] 루트(3)와 마지막 요소(1) 교환: [1, 3 | 4, 5, 10] 힙 크기를 1로 줄이면 정렬 완료 최대 힙을 이용한 오름차순 정렬 배열을 최대 힙으로 구성한다. 루트(최댓값)를 배열의 마지막 요소와 교환한다. 힙의 크기를 1 감소시키고 루트에서 힙 속성을 복구한다(heapify). 힙의 크기가 1이 될 때까지 2~3 단계를 반복한다. 최소 힙을 이용한 내림차순 정렬 배열을 최소 힙으로 구성한다. 루트(최솟값)를 배열의 마지막 요소와 교환한다. 힙의 크기를 1 감소시키고 루트에서 힙 속성을 복구한다. 힙의 크기가 1이 될 때까지 2~3 단계를 반복한다. 힙 정렬 알고리즘의 구현 파이썬으로 구현한 힙 정렬 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def heapify(arr, n, i): \"\"\" 주어진 배열 arr에서 인덱스 i를 루트로 하는 부분 트리를 최대 힙으로 만듭니다. n은 배열의 크기입니다. \"\"\" # 여기서 `i`는 현재 검사 중인 루트 노드의 인덱스이다. # 이진 트리에서 노드 `i`의 자식 노드들은 # 배열에서 `2*i+1`(왼쪽)과 `2*i+2`(오른쪽) 위치에 저장된다. largest = i # 루트를 가장 큰 값으로 초기화 left = 2 * i + 1 # 왼쪽 자식 right = 2 * i + 2 # 오른쪽 자식 # 왼쪽 자식이 루트보다 크면 largest 갱신 # 왼쪽 자식이 배열 범위 내에 있는지(`left \u003c n`) 확인하고, # 그 값이 현재 `largest`보다 큰지 확인합니다. if left \u003c n and arr[left] \u003e arr[largest]: largest = left # 오른쪽 자식이 현재까지의 largest보다 크면 갱신 # 오른 자식이 배열 범위 내에 있는지(`right \u003c n`) 확인하고, # 그 값이 현재 `largest`보다 큰지 확인합니다. if right \u003c n and arr[right] \u003e arr[largest]: largest = right # 이 과정을 통해 루트, 왼쪽 자식, 오른쪽 자식 중에서 가장 큰 값의 인덱스를 `largest`에 저장한다. # largest가 루트가 아니면 교환하고 재귀적으로 heapify 호출 # 만약 `largest`가 현재 루트 `i`와 다르다면, 최대 힙 속성을 만족시키기 위해 두 값을 교환한다. # 교환 후, 교환된 위치(이전 `largest` 위치)에서 다시 `heapify`를 호출한다. # 이는 교환으로 인해 해당 위치에서 최대 힙 속성이 깨졌을 수 있기 때문이다. # 이 재귀 과정은 리프 노드(자식이 없는 노드)에 도달하거나 최대 힙 속성이 만족될 때까지 계속된다. if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) def heap_sort(arr): \"\"\" 힙 정렬을 사용하여 배열을 정렬합니다. \"\"\" n = len(arr) # 배열을 최대 힙으로 구성 # 마지막 비단말 노드부터 루트까지 거꾸로 진행 # 힙 정렬의 첫 단계는 주어진 배열을 최대 힙으로 변환하는 것. # 리프 노드는 자식이 없으므로 이미 최대 힙 속성을 만족한다. # 따라서 마지막 비단말 노드(인덱스 `n//2-1`)부터 시작하여 루트(인덱스 0)까지 거꾸로 진행하며 각 노드에 대해 `heapify`를 수행한다. # 이 과정은 상향식(bottom-up) 접근법으로, 각 서브트리를 최대 힙으로 만들어 최종적으로 전체 트리를 최대 힙으로 변환한다. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # 힙이 구성된 후, 최대 힙의 루트는 항상 배열의 최댓값. # 루트(인덱스 0)와 현재 힙의 마지막 요소(인덱스 `i`)를 교환하면, 최댓값이 배열의 올바른 정렬 위치로 이동한다. # 교환 후에는 마지막 요소(이제 정렬됨)를 제외한 나머지 부분에 대해 다시 `heapify`를 수행하여 최대 힙 속성을 복원한다. # 이 과정을 배열의 모든 요소에 대해 반복하면, 배열이 오름차순으로 정렬된다. # 힙에서 요소를 하나씩 추출 for i in range(n - 1, 0, -1): # 현재 루트(최댓값)를 마지막 요소와 교환 arr[i], arr[0] = arr[0], arr[i] # 크기가 줄어든 힙에 대해 heapify 수행 heapify(arr, i, 0) return arr 자바스크립트로 구현한 힙 정렬 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 function heapify(arr, n, i) { let largest = i; const left = 2 * i + 1; const right = 2 * i + 2; // 왼쪽 자식이 루트보다 크면 largest 갱신 if (left \u003c n \u0026\u0026 arr[left] \u003e arr[largest]) { largest = left; } // 오른쪽 자식이 현재까지의 largest보다 크면 갱신 if (right \u003c n \u0026\u0026 arr[right] \u003e arr[largest]) { largest = right; } // largest가 루트가 아니면 교환하고 재귀적으로 heapify 호출 if (largest !== i) { [arr[i], arr[largest]] = [arr[largest], arr[i]]; heapify(arr, n, largest); } } function heapSort(arr) { const n = arr.length; // 배열을 최대 힙으로 구성 for (let i = Math.floor(n / 2) - 1; i \u003e= 0; i--) { heapify(arr, n, i); } // 힙에서 요소를 하나씩 추출 for (let i = n - 1; i \u003e 0; i--) { // 현재 루트(최댓값)를 마지막 요소와 교환 [arr[0], arr[i]] = [arr[i], arr[0]]; // 크기가 줄어든 힙에 대해 heapify 수행 heapify(arr, i, 0); } return arr; } 힙 정렬의 성능 분석 시간 복잡도\n힙 구성(Build Heap): O(n) (일반적으로 O(n log n)으로 생각할 수 있지만, 더 정확한 상한은 O(n)입니다) 정렬 과정: O(n log n) 전체 시간 복잡도: O(n log n)\n힙 정렬의 시간 복잡도는 입력 배열의 초기 상태와 관계없이 항상 O(n log n)이다.\n이는 최선, 평균, 최악의 경우 모두 동일하다. 공간 복잡도\n힙 정렬은 추가 배열 없이 입력 배열 내에서 정렬을 수행하므로 공간 복잡도는 O(1)이다.\n재귀 호출로 인한 스택 공간을 고려하면 최악의 경우 O(log n)이 될 수 있다.\n안정성\n힙 정렬은 불안정(unstable) 정렬 알고리즘이다.\n동일한 값을 가진 요소들의 상대적 순서가 정렬 과정에서 바뀔 수 있다. 이는 힙을 구성하는 과정과 요소를 추출하는 과정에서 발생할 수 있다.\n힙 정렬의 최적화 기법 반복적 Heapify\n재귀 대신 반복문을 사용하여 heapify를 구현하면 스택 오버플로우를 방지하고 성능을 향상시킬 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def heapify_iterative(arr, n, i): while True: largest = i left = 2 * i + 1 right = 2 * i + 2 if left \u003c n and arr[left] \u003e arr[largest]: largest = left if right \u003c n and arr[right] \u003e arr[largest]: largest = right if largest == i: break arr[i], arr[largest] = arr[largest], arr[i] i = largest 병렬 처리\n힙 정렬의 일부 단계(특히 초기 힙 구성)는 병렬화가 가능하여 다중 코어 환경에서 성능을 향상시킬 수 있다.\n캐시 최적화\n메모리 액세스 패턴을 개선하여 캐시 효율성을 높이는 방법도 있다. 배열 요소 간의 간격을 줄이거나 지역성(locality)을 높이는 기법이 활용된다.\n힙 정렬의 응용 분야 K 개의 가장 큰/작은 요소 찾기\n힙 자료구조를 활용하면 대용량 데이터에서 상위 K개 요소를 효율적으로 찾을 수 있다.\n이는 빅데이터 처리, 데이터 마이닝 등에서 유용하게 활용된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 def find_k_largest(arr, k): # 최소 힙으로 k개 요소 유지 import heapq min_heap = [] for num in arr: if len(min_heap) \u003c k: heapq.heappush(min_heap, num) elif num \u003e min_heap[0]: heapq.heappop(min_heap) heapq.heappush(min_heap, num) return min_heap 우선순위 큐 구현\n힙은 우선순위 큐를 구현하는 데 가장 적합한 자료구조이다. 이를 활용한 응용 프로그램으로는 다음과 같은 것들이 있다:\n다익스트라 알고리즘: 최단 경로 찾기 프림 알고리즘: 최소 신장 트리 구성 허프만 코딩: 데이터 압축 작업 스케줄링: 우선순위에 따른 작업 할당 외부 정렬\n대용량 데이터를 메모리에 모두 로드할 수 없을 때 사용하는 외부 정렬에서도 힙 정렬이 활용된다.\n여러 파일에서 데이터를 병합할 때 우선순위 큐로 힙을 사용하는 방식이다.\n힙 정렬의 변형 스무시 정렬(Smoothsort)\n힙 정렬의 변형으로, 이미 정렬된 데이터에 대해 O(n) 시간 복잡도를 가지도록 최적화된 알고리즘이다.\n레오나르도 수를 기반으로 한 특수한 힙 구조를 사용한다.\n인트로 정렬(Introsort)\n퀵 정렬, 힙 정렬, 삽입 정렬을 혼합한 하이브리드 정렬 알고리즘이다.\n퀵 정렬의 파티션 깊이가 너무 깊어지면 힙 정렬로 전환하여 최악의 경우 성능을 보장한다.\n제자리 병합 정렬(In-place Merge Sort)\n힙을 사용하여 병합 정렬을 제자리(in-place)에서 수행하는 방식으로, 추가 메모리 사용을 최소화한다.\n참고 및 출처 ","wordCount":"1735","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-15T08:38:00Z","dateModified":"2024-10-15T08:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/>Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/>정렬 알고리즘 (Sorting Algorithms)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/>Types of Sorting Algorithm</a></div><h1 class="post-title entry-hint-parent">힙 정렬 (Heap Sort)</h1><div class=post-description>힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.</div><div class=post-meta><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Algorithms/Sorting/Comparison%20Sorts/Heap-Sort.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#힙-정렬-heap-sort>힙 정렬 (Heap Sort)</a><ul><li><a href=#힙heap-자료구조의-이해>힙(Heap) 자료구조의 이해</a></li><li><a href=#힙-정렬-알고리즘의-원리>힙 정렬 알고리즘의 원리</a></li><li><a href=#힙-정렬-알고리즘의-구현>힙 정렬 알고리즘의 구현</a></li><li><a href=#힙-정렬의-성능-분석>힙 정렬의 성능 분석</a></li><li><a href=#힙-정렬의-최적화-기법>힙 정렬의 최적화 기법</a></li><li><a href=#힙-정렬의-응용-분야>힙 정렬의 응용 분야</a></li><li><a href=#힙-정렬의-변형>힙 정렬의 변형</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=힙-정렬-heap-sort>힙 정렬 (Heap Sort)<a hidden class=anchor aria-hidden=true href=#힙-정렬-heap-sort>#</a></h2><p>힙 정렬은 비교 기반 정렬 알고리즘으로, 이진 힙 자료구조를 활용하여 효율적인 정렬을 수행한다.<br>시간 복잡도가 안정적이고 추가 메모리를 거의 사용하지 않는 특징을 가지고 있어 많은 시스템에서 널리 사용된다.</p><p>힙 정렬은 비교 기반 정렬 알고리즘 중에서 시간 복잡도가 보장되고 추가 메모리를 거의 사용하지 않는 효율적인 알고리즘이다.<br>최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지며, 특히 메모리 제약이 있는 환경에서 유용하다.</p><p>불안정 정렬이라는 단점이 있지만, 안정성이 중요하지 않은 많은 응용 분야에서 여전히 강력한 선택지이다. 힙 자료구조의 이해는 우선순위 큐, 그래프 알고리즘 등 컴퓨터 과학의 다른 영역에도 도움이 된다.</p><h3 id=힙heap-자료구조의-이해>힙(Heap) 자료구조의 이해<a hidden class=anchor aria-hidden=true href=#힙heap-자료구조의-이해>#</a></h3><p>힙 정렬을 이해하기 위해서는 먼저 힙 자료구조에 대한 이해가 필요하다.</p><h4 id=힙의-정의>힙의 정의<a hidden class=anchor aria-hidden=true href=#힙의-정의>#</a></h4><p>힙은 다음 두 가지 특성을 만족하는 완전 이진 트리이다:</p><ol><li><strong>완전 이진 트리(Complete Binary Tree)</strong>: 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 노드들은 왼쪽부터 채워져 있다.</li><li><strong>힙 속성(Heap Property)</strong>:<ul><li>최대 힙(Max Heap): 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같음</li><li>최소 힙(Min Heap): 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같음</li></ul></li></ol><h4 id=힙의-표현>힙의 표현<a hidden class=anchor aria-hidden=true href=#힙의-표현>#</a></h4><p>힙은 일반적으로 배열을 사용하여 표현한다.<br>이진 트리의 레벨 순서 탐색(level-order traversal)과 같은 방식으로 배열에 저장된다.</p><p>배열에서 인덱스 <code>i</code>의 노드에 대해:</p><ul><li>부모 노드 인덱스: <code>(i-1) // 2</code> (파이썬 기준)</li><li>왼쪽 자식 노드 인덱스: <code>2*i + 1</code></li><li>오른쪽 자식 노드 인덱스: <code>2*i + 2</code></li></ul><p>이러한 규칙을 통해 포인터 없이도 트리 구조를 효율적으로 표현할 수 있다.</p><h3 id=힙-정렬-알고리즘의-원리>힙 정렬 알고리즘의 원리<a hidden class=anchor aria-hidden=true href=#힙-정렬-알고리즘의-원리>#</a></h3><p>힙 정렬은 힙의 특성을 활용하여 정렬을 수행한다.</p><p>주요 단계는 다음과 같다:</p><ol><li><strong>힙 구성(Heapify)</strong>: 주어진 배열을 힙으로 변환한다.<ul><li><strong>주어진 배열을 힙(Heap) 구조로 변환</strong></li><li><strong>Heapify 연산을 수행하여 최대 힙(또는 최소 힙) 구성</strong></li></ul></li><li><strong>정렬</strong>: 힙에서 원소를 하나씩 제거하여 정렬된 배열을 구성한다.<ul><li><strong>루트(최댓값 또는 최솟값)를 제거하고, 힙을 재정렬</strong></li><li><strong>반복적으로 수행하여 정렬된 배열 생성</strong></li></ul></li></ol><h4 id=힙-정렬-과정-예제>힙 정렬 과정 예제<a hidden class=anchor aria-hidden=true href=#힙-정렬-과정-예제>#</a></h4><p>정렬할 배열:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>[4, 10, 3, 5, 1]
</span></span></code></pre></td></tr></table></div></div><ol><li><p>최대 힙(Max Heap) 구성</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>       10
</span></span><span class=line><span class=cl>      /  \
</span></span><span class=line><span class=cl>     5    3
</span></span><span class=line><span class=cl>    / \
</span></span><span class=line><span class=cl>   4   1
</span></span></code></pre></td></tr></table></div></div></li><li><p>루트(최대값 10)를 제거하고 배열 끝으로 이동</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>       5
</span></span><span class=line><span class=cl>      /  \
</span></span><span class=line><span class=cl>     4    3
</span></span><span class=line><span class=cl>    /  
</span></span><span class=line><span class=cl>   1   
</span></span></code></pre></td></tr></table></div></div><p>→ 정렬된 배열: <code>[10]</code></p></li><li><p>Heapify 수행 후 최대 힙 유지</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>       5
</span></span><span class=line><span class=cl>      /  \
</span></span><span class=line><span class=cl>     4    3
</span></span><span class=line><span class=cl>    /  
</span></span><span class=line><span class=cl>   1   
</span></span></code></pre></td></tr></table></div></div></li><li><p>다시 루트(최대값 5)를 제거하고 배열 끝으로 이동</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>       4
</span></span><span class=line><span class=cl>      /  \
</span></span><span class=line><span class=cl>     1    3
</span></span></code></pre></td></tr></table></div></div><p>→ 정렬된 배열: <code>[5, 10]</code></p></li><li><p>반복 수행하여 전체 정렬 완료</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>[1, 3, 4, 5, 10]
</span></span></code></pre></td></tr></table></div></div></li></ol><p>결과적으로 오름차순 정렬이 수행됨</p><h5 id=최대-힙-구성-과정>최대 힙 구성 과정<a hidden class=anchor aria-hidden=true href=#최대-힙-구성-과정>#</a></h5><ol><li>초기 배열: <code>[4, 10, 3, 5, 1]</code></li><li>마지막 비단말 노드(인덱스 1, 값 10)부터 시작:<ul><li>인덱스 1은 이미 최대 힙 속성을 만족</li></ul></li><li>인덱스 0(값 4)에 대한 heapify:<ul><li>자식 노드들과 비교하여 최댓값(10)을 찾음</li><li>4와 10을 교환: <code>[10, 4, 3, 5, 1]</code></li><li>인덱스 1에 대해 heapify 재귀 호출:<ul><li>자식 노드들과 비교하여 최댓값(5)을 찾음</li><li>4와 5를 교환: <code>[10, 5, 3, 4, 1]</code><br>최종 최대 힙: <code>[10, 5, 3, 4, 1]</code></li></ul></li></ul></li></ol><h5 id=정렬-과정>정렬 과정<a hidden class=anchor aria-hidden=true href=#정렬-과정>#</a></h5><ol><li>루트(10)와 마지막 요소(1) 교환: <code>[1, 5, 3, 4, 10]</code><ul><li>힙 크기를 4로 줄이고 heapify 수행</li><li>결과: <code>[5, 4, 3, 1 | 10]</code> (막대는 힙과 정렬된 부분의 경계)</li></ul></li><li>루트(5)와 마지막 요소(1) 교환: <code>[1, 4, 3, 5 | 10]</code><ul><li>힙 크기를 3으로 줄이고 heapify 수행</li><li>결과: <code>[4, 1, 3 | 5, 10]</code></li></ul></li><li>루트(4)와 마지막 요소(3) 교환: <code>[3, 1, 4 | 5, 10]</code><ul><li>힙 크기를 2로 줄이고 heapify 수행</li><li>결과: <code>[3, 1 | 4, 5, 10]</code></li></ul></li><li>루트(3)와 마지막 요소(1) 교환: <code>[1, 3 | 4, 5, 10]</code><ul><li>힙 크기를 1로 줄이면 정렬 완료</li></ul></li></ol><h4 id=최대-힙을-이용한-오름차순-정렬>최대 힙을 이용한 오름차순 정렬<a hidden class=anchor aria-hidden=true href=#최대-힙을-이용한-오름차순-정렬>#</a></h4><ol><li>배열을 최대 힙으로 구성한다.</li><li>루트(최댓값)를 배열의 마지막 요소와 교환한다.</li><li>힙의 크기를 1 감소시키고 루트에서 힙 속성을 복구한다(heapify).</li><li>힙의 크기가 1이 될 때까지 2~3 단계를 반복한다.</li></ol><h4 id=최소-힙을-이용한-내림차순-정렬>최소 힙을 이용한 내림차순 정렬<a hidden class=anchor aria-hidden=true href=#최소-힙을-이용한-내림차순-정렬>#</a></h4><ol><li>배열을 최소 힙으로 구성한다.</li><li>루트(최솟값)를 배열의 마지막 요소와 교환한다.</li><li>힙의 크기를 1 감소시키고 루트에서 힙 속성을 복구한다.</li><li>힙의 크기가 1이 될 때까지 2~3 단계를 반복한다.</li></ol><h3 id=힙-정렬-알고리즘의-구현>힙 정렬 알고리즘의 구현<a hidden class=anchor aria-hidden=true href=#힙-정렬-알고리즘의-구현>#</a></h3><h4 id=파이썬으로-구현한-힙-정렬>파이썬으로 구현한 힙 정렬<a hidden class=anchor aria-hidden=true href=#파이썬으로-구현한-힙-정렬>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span><span class=lnt id=hl-6-33><a class=lnlinks href=#hl-6-33>33</a>
</span><span class=lnt id=hl-6-34><a class=lnlinks href=#hl-6-34>34</a>
</span><span class=lnt id=hl-6-35><a class=lnlinks href=#hl-6-35>35</a>
</span><span class=lnt id=hl-6-36><a class=lnlinks href=#hl-6-36>36</a>
</span><span class=lnt id=hl-6-37><a class=lnlinks href=#hl-6-37>37</a>
</span><span class=lnt id=hl-6-38><a class=lnlinks href=#hl-6-38>38</a>
</span><span class=lnt id=hl-6-39><a class=lnlinks href=#hl-6-39>39</a>
</span><span class=lnt id=hl-6-40><a class=lnlinks href=#hl-6-40>40</a>
</span><span class=lnt id=hl-6-41><a class=lnlinks href=#hl-6-41>41</a>
</span><span class=lnt id=hl-6-42><a class=lnlinks href=#hl-6-42>42</a>
</span><span class=lnt id=hl-6-43><a class=lnlinks href=#hl-6-43>43</a>
</span><span class=lnt id=hl-6-44><a class=lnlinks href=#hl-6-44>44</a>
</span><span class=lnt id=hl-6-45><a class=lnlinks href=#hl-6-45>45</a>
</span><span class=lnt id=hl-6-46><a class=lnlinks href=#hl-6-46>46</a>
</span><span class=lnt id=hl-6-47><a class=lnlinks href=#hl-6-47>47</a>
</span><span class=lnt id=hl-6-48><a class=lnlinks href=#hl-6-48>48</a>
</span><span class=lnt id=hl-6-49><a class=lnlinks href=#hl-6-49>49</a>
</span><span class=lnt id=hl-6-50><a class=lnlinks href=#hl-6-50>50</a>
</span><span class=lnt id=hl-6-51><a class=lnlinks href=#hl-6-51>51</a>
</span><span class=lnt id=hl-6-52><a class=lnlinks href=#hl-6-52>52</a>
</span><span class=lnt id=hl-6-53><a class=lnlinks href=#hl-6-53>53</a>
</span><span class=lnt id=hl-6-54><a class=lnlinks href=#hl-6-54>54</a>
</span><span class=lnt id=hl-6-55><a class=lnlinks href=#hl-6-55>55</a>
</span><span class=lnt id=hl-6-56><a class=lnlinks href=#hl-6-56>56</a>
</span><span class=lnt id=hl-6-57><a class=lnlinks href=#hl-6-57>57</a>
</span><span class=lnt id=hl-6-58><a class=lnlinks href=#hl-6-58>58</a>
</span><span class=lnt id=hl-6-59><a class=lnlinks href=#hl-6-59>59</a>
</span><span class=lnt id=hl-6-60><a class=lnlinks href=#hl-6-60>60</a>
</span><span class=lnt id=hl-6-61><a class=lnlinks href=#hl-6-61>61</a>
</span><span class=lnt id=hl-6-62><a class=lnlinks href=#hl-6-62>62</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    주어진 배열 arr에서 인덱스 i를 루트로 하는 부분 트리를 최대 힙으로 만듭니다.
</span></span></span><span class=line><span class=cl><span class=s2>    n은 배열의 크기입니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 여기서 `i`는 현재 검사 중인 루트 노드의 인덱스이다. </span>
</span></span><span class=line><span class=cl>    <span class=c1># 이진 트리에서 노드 `i`의 자식 노드들은 </span>
</span></span><span class=line><span class=cl>    <span class=c1># 배열에서 `2*i+1`(왼쪽)과 `2*i+2`(오른쪽) 위치에 저장된다. </span>
</span></span><span class=line><span class=cl>    <span class=n>largest</span> <span class=o>=</span> <span class=n>i</span>  <span class=c1># 루트를 가장 큰 값으로 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>  <span class=c1># 왼쪽 자식</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span>  <span class=c1># 오른쪽 자식</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 자식이 루트보다 크면 largest 갱신</span>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 자식이 배열 범위 내에 있는지(`left &lt; n`) 확인하고,</span>
</span></span><span class=line><span class=cl>    <span class=c1># 그 값이 현재 `largest`보다 큰지 확인합니다.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 자식이 현재까지의 largest보다 크면 갱신</span>
</span></span><span class=line><span class=cl>    <span class=c1># 오른 자식이 배열 범위 내에 있는지(`right &lt; n`) 확인하고,</span>
</span></span><span class=line><span class=cl>    <span class=c1># 그 값이 현재 `largest`보다 큰지 확인합니다.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>right</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>    <span class=c1># 이 과정을 통해 루트, 왼쪽 자식, 오른쪽 자식 중에서 가장 큰 값의 인덱스를 `largest`에 저장한다. </span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># largest가 루트가 아니면 교환하고 재귀적으로 heapify 호출</span>
</span></span><span class=line><span class=cl>    <span class=c1># 만약 `largest`가 현재 루트 `i`와 다르다면, 최대 힙 속성을 만족시키기 위해 두 값을 교환한다. </span>
</span></span><span class=line><span class=cl>    <span class=c1># 교환 후, 교환된 위치(이전 `largest` 위치)에서 다시 `heapify`를 호출한다. </span>
</span></span><span class=line><span class=cl>    <span class=c1># 이는 교환으로 인해 해당 위치에서 최대 힙 속성이 깨졌을 수 있기 때문이다. </span>
</span></span><span class=line><span class=cl>    <span class=c1># 이 재귀 과정은 리프 노드(자식이 없는 노드)에 도달하거나 최대 힙 속성이 만족될 때까지 계속된다.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>largest</span> <span class=o>!=</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>largest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>heap_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    힙 정렬을 사용하여 배열을 정렬합니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 배열을 최대 힙으로 구성</span>
</span></span><span class=line><span class=cl>    <span class=c1># 마지막 비단말 노드부터 루트까지 거꾸로 진행</span>
</span></span><span class=line><span class=cl>    <span class=c1># 힙 정렬의 첫 단계는 주어진 배열을 최대 힙으로 변환하는 것.</span>
</span></span><span class=line><span class=cl>    <span class=c1># 리프 노드는 자식이 없으므로 이미 최대 힙 속성을 만족한다. </span>
</span></span><span class=line><span class=cl>    <span class=c1># 따라서 마지막 비단말 노드(인덱스 `n//2-1`)부터 시작하여 루트(인덱스 0)까지 거꾸로 진행하며 각 노드에 대해 `heapify`를 수행한다. </span>
</span></span><span class=line><span class=cl>    <span class=c1># 이 과정은 상향식(bottom-up) 접근법으로, 각 서브트리를 최대 힙으로 만들어 최종적으로 전체 트리를 최대 힙으로 변환한다. </span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>//</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># 힙이 구성된 후, 최대 힙의 루트는 항상 배열의 최댓값.</span>
</span></span><span class=line><span class=cl>	<span class=c1># 루트(인덱스 0)와 현재 힙의 마지막 요소(인덱스 `i`)를 교환하면, 최댓값이 배열의 올바른 정렬 위치로 이동한다. </span>
</span></span><span class=line><span class=cl>	<span class=c1># 교환 후에는 마지막 요소(이제 정렬됨)를 제외한 나머지 부분에 대해 다시 `heapify`를 수행하여 최대 힙 속성을 복원한다. </span>
</span></span><span class=line><span class=cl>	<span class=c1># 이 과정을 배열의 모든 요소에 대해 반복하면, 배열이 오름차순으로 정렬된다.</span>
</span></span><span class=line><span class=cl>    <span class=c1># 힙에서 요소를 하나씩 추출</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 루트(최댓값)를 마지막 요소와 교환</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 크기가 줄어든 힙에 대해 heapify 수행</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=자바스크립트로-구현한-힙-정렬>자바스크립트로 구현한 힙 정렬<a hidden class=anchor aria-hidden=true href=#자바스크립트로-구현한-힙-정렬>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span><span class=lnt id=hl-7-36><a class=lnlinks href=#hl-7-36>36</a>
</span><span class=lnt id=hl-7-37><a class=lnlinks href=#hl-7-37>37</a>
</span><span class=lnt id=hl-7-38><a class=lnlinks href=#hl-7-38>38</a>
</span><span class=lnt id=hl-7-39><a class=lnlinks href=#hl-7-39>39</a>
</span><span class=lnt id=hl-7-40><a class=lnlinks href=#hl-7-40>40</a>
</span><span class=lnt id=hl-7-41><a class=lnlinks href=#hl-7-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>largest</span> <span class=o>=</span> <span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>left</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>right</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 왼쪽 자식이 루트보다 크면 largest 갱신
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>left</span> <span class=o>&lt;</span> <span class=nx>n</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>largest</span> <span class=o>=</span> <span class=nx>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 오른쪽 자식이 현재까지의 largest보다 크면 갱신
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>right</span> <span class=o>&lt;</span> <span class=nx>n</span> <span class=o>&amp;&amp;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>right</span><span class=p>]</span> <span class=o>&gt;</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>largest</span> <span class=o>=</span> <span class=nx>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// largest가 루트가 아니면 교환하고 재귀적으로 heapify 호출
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nx>largest</span> <span class=o>!==</span> <span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span><span class=nx>arr</span><span class=p>[</span><span class=nx>largest</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>        <span class=nx>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>largest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>heapSort</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>n</span> <span class=o>=</span> <span class=nx>arr</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 배열을 최대 힙으로 구성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>(</span><span class=nx>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>n</span><span class=p>,</span> <span class=nx>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 힙에서 요소를 하나씩 추출
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 현재 루트(최댓값)를 마지막 요소와 교환
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>[</span><span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span><span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 크기가 줄어든 힙에 대해 heapify 수행
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>heapify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=힙-정렬의-성능-분석>힙 정렬의 성능 분석<a hidden class=anchor aria-hidden=true href=#힙-정렬의-성능-분석>#</a></h3><ol><li><p>시간 복잡도</p><ul><li><strong>힙 구성(Build Heap)</strong>: O(n) (일반적으로 O(n log n)으로 생각할 수 있지만, 더 정확한 상한은 O(n)입니다)</li><li><strong>정렬 과정</strong>: O(n log n)</li><li><strong>전체 시간 복잡도</strong>: O(n log n)<br>힙 정렬의 시간 복잡도는 입력 배열의 초기 상태와 관계없이 항상 O(n log n)이다.<br>이는 최선, 평균, 최악의 경우 모두 동일하다.</li></ul></li><li><p>공간 복잡도<br>힙 정렬은 추가 배열 없이 입력 배열 내에서 정렬을 수행하므로 공간 복잡도는 O(1)이다.<br>재귀 호출로 인한 스택 공간을 고려하면 최악의 경우 O(log n)이 될 수 있다.</p></li><li><p>안정성<br>힙 정렬은 <strong>불안정(unstable)</strong> 정렬 알고리즘이다.<br>동일한 값을 가진 요소들의 상대적 순서가 정렬 과정에서 바뀔 수 있다. 이는 힙을 구성하는 과정과 요소를 추출하는 과정에서 발생할 수 있다.</p></li></ol><h3 id=힙-정렬의-최적화-기법>힙 정렬의 최적화 기법<a hidden class=anchor aria-hidden=true href=#힙-정렬의-최적화-기법>#</a></h3><ol><li><p>반복적 Heapify<br>재귀 대신 반복문을 사용하여 heapify를 구현하면 스택 오버플로우를 방지하고 성능을 향상시킬 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapify_iterative</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        <span class=n>left</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>right</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>largest</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>right</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>largest</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>largest</span> <span class=o>==</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>=</span> <span class=n>largest</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>병렬 처리<br>힙 정렬의 일부 단계(특히 초기 힙 구성)는 병렬화가 가능하여 다중 코어 환경에서 성능을 향상시킬 수 있다.</p></li><li><p>캐시 최적화<br>메모리 액세스 패턴을 개선하여 캐시 효율성을 높이는 방법도 있다. 배열 요소 간의 간격을 줄이거나 지역성(locality)을 높이는 기법이 활용된다.</p></li></ol><h3 id=힙-정렬의-응용-분야>힙 정렬의 응용 분야<a hidden class=anchor aria-hidden=true href=#힙-정렬의-응용-분야>#</a></h3><ol><li><p>K 개의 가장 큰/작은 요소 찾기<br>힙 자료구조를 활용하면 대용량 데이터에서 상위 K개 요소를 효율적으로 찾을 수 있다.<br>이는 빅데이터 처리, 데이터 마이닝 등에서 유용하게 활용된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>find_k_largest</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 최소 힙으로 k개 요소 유지</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>    <span class=n>min_heap</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>arr</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>min_heap</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>min_heap</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>num</span> <span class=o>&gt;</span> <span class=n>min_heap</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>min_heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>min_heap</span><span class=p>,</span> <span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>min_heap</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>우선순위 큐 구현<br>힙은 우선순위 큐를 구현하는 데 가장 적합한 자료구조이다. 이를 활용한 응용 프로그램으로는 다음과 같은 것들이 있다:</p><ul><li><strong>다익스트라 알고리즘</strong>: 최단 경로 찾기</li><li><strong>프림 알고리즘</strong>: 최소 신장 트리 구성</li><li><strong>허프만 코딩</strong>: 데이터 압축</li><li><strong>작업 스케줄링</strong>: 우선순위에 따른 작업 할당</li></ul></li><li><p>외부 정렬<br>대용량 데이터를 메모리에 모두 로드할 수 없을 때 사용하는 외부 정렬에서도 힙 정렬이 활용된다.<br>여러 파일에서 데이터를 병합할 때 우선순위 큐로 힙을 사용하는 방식이다.</p></li></ol><h3 id=힙-정렬의-변형>힙 정렬의 변형<a hidden class=anchor aria-hidden=true href=#힙-정렬의-변형>#</a></h3><ol><li><p>스무시 정렬(Smoothsort)<br>힙 정렬의 변형으로, 이미 정렬된 데이터에 대해 O(n) 시간 복잡도를 가지도록 최적화된 알고리즘이다.<br>레오나르도 수를 기반으로 한 특수한 힙 구조를 사용한다.</p></li><li><p>인트로 정렬(Introsort)<br>퀵 정렬, 힙 정렬, 삽입 정렬을 혼합한 하이브리드 정렬 알고리즘이다.<br>퀵 정렬의 파티션 깊이가 너무 깊어지면 힙 정렬로 전환하여 최악의 경우 성능을 보장한다.</p></li><li><p>제자리 병합 정렬(In-place Merge Sort)<br>힙을 사용하여 병합 정렬을 제자리(in-place)에서 수행하는 방식으로, 추가 메모리 사용을 최소화한다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/algorithms/>Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/sorting/>Sorting</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/heap-sort/>Heap-Sort</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/application-development/search-and-discovery/search-engine/><span class=title>« Prev</span><br><span>Search Engines</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/><span class=title>Next »</span><br><span>Linear Data Structure vs Non-Linear Data Structure</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>