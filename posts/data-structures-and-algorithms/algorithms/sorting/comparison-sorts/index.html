<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Types of Sorting Algorithm | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Algorithms,Sorting,Types"><meta name=description content="정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Types of Sorting Algorithm"><meta property="og:description" content="정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Types of Sorting Algorithm"><meta name=twitter:description content="정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":""},{"@type":"ListItem","position":3,"name":"Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/"},{"@type":"ListItem","position":4,"name":"정렬 알고리즘 (Sorting Algorithms)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/"},{"@type":"ListItem","position":5,"name":"Types of Sorting Algorithm","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/>Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/>정렬 알고리즘 (Sorting Algorithms)</a></div><h1>Types of Sorting Algorithm</h1><div class=post-description>정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다.</div></header><div class=post-content><h2 id=sorting-algorithms-비교>Sorting Algorithms 비교<a hidden class=anchor aria-hidden=true href=#sorting-algorithms-비교>#</a></h2><p>정렬(Sorting) 알고리즘은 <strong>데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘</strong>이다.<br>정렬 알고리즘은 <strong>시간 복잡도, 공간 복잡도, 안정성, 실행 속도 등의 성능 차이</strong>로 인해 다양한 방식이 존재한다.</p><p>각 정렬 알고리즘은 고유한 특성과 작동 방식을 가지고 있습니다. 여기서는 6가지 주요 정렬 알고리즘을 공통된 예시 배열 <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code>을 사용하여 비교 분석하겠습니다.</p><h3 id=정렬-알고리즘-비교>정렬 알고리즘 비교<a hidden class=anchor aria-hidden=true href=#정렬-알고리즘-비교>#</a></h3><p>각 정렬 알고리즘은 고유한 특성과 장단점을 가지고 있으며, 적용 상황에 따라 최적의 선택이 달라진다:</p><ol><li><strong>작은 데이터나 거의 정렬된 데이터</strong>: 삽입 정렬이 간단하고 효율적</li><li><strong>안정적 정렬이 필요한 경우</strong>: 병합 정렬이 가장 안정적인 O(n log n) 알고리즘</li><li><strong>평균적으로 빠른 성능</strong>: 대부분의 경우 퀵 정렬이 최선의 선택</li><li><strong>최악의 경우 성능 보장</strong>: 병합 정렬이나 힙 정렬이 O(n log n) 보장</li><li><strong>메모리 제약 환경</strong>: 힙 정렬이 O(1) 공간 복잡도로 효율적</li><li><strong>교육 목적</strong>: 버블, 선택, 삽입 정렬이 개념 이해에 적합</li></ol><p>실제 애플리케이션에서는 이러한 특성을 고려하여 적절한 알고리즘을 선택하거나, 하이브리드 접근 방식(예: 팀소트, 인트로소트)을 사용하는 것이 일반적이다.</p><table><thead><tr><th>특성</th><th>버블 정렬</th><th>선택 정렬</th><th>삽입 정렬</th><th>병합 정렬</th><th>퀵 정렬</th><th>힙 정렬</th></tr></thead><tbody><tr><td><strong>시간 복잡도 (최선)</strong></td><td>O(n)</td><td>O(n²)</td><td>O(n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td></tr><tr><td><strong>시간 복잡도 (평균)</strong></td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td></tr><tr><td><strong>시간 복잡도 (최악)</strong></td><td>O(n²)</td><td>O(n²)</td><td>O(n²)</td><td>O(n log n)</td><td>O(n²)</td><td>O(n log n)</td></tr><tr><td><strong>공간 복잡도</strong></td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>O(n)</td><td>O(log n)</td><td>O(1)</td></tr><tr><td><strong>안정성</strong></td><td>안정</td><td>불안정</td><td>안정</td><td>안정</td><td>불안정</td><td>불안정</td></tr><tr><td><strong>적응성</strong></td><td>좋음</td><td>없음</td><td>매우 좋음</td><td>없음</td><td>부분적</td><td>없음</td></tr><tr><td><strong>구현 난이도</strong></td><td>매우 쉬움</td><td>쉬움</td><td>쉬움</td><td>중간</td><td>중간</td><td>어려움</td></tr><tr><td><strong>교환 횟수</strong></td><td>많음</td><td>적음</td><td>중간</td><td>많음</td><td>중간</td><td>중간</td></tr><tr><td><strong>비교 횟수</strong></td><td>많음</td><td>많음</td><td>중간</td><td>적음</td><td>적음</td><td>적음</td></tr><tr><td><strong>온라인 가능</strong></td><td>아니오</td><td>아니오</td><td>예</td><td>아니오</td><td>아니오</td><td>아니오</td></tr><tr><td><strong>캐시 친화적</strong></td><td>예</td><td>아니오</td><td>예</td><td>아니오</td><td>예</td><td>아니오</td></tr><tr><td><strong>병렬화 가능</strong></td><td>제한적</td><td>제한적</td><td>아니오</td><td>매우 좋음</td><td>좋음</td><td>제한적</td></tr><tr><td><strong>실제 사용 빈도</strong></td><td>낮음</td><td>낮음</td><td>중간</td><td>높음</td><td>매우 높음</td><td>중간</td></tr></tbody></table><h4 id=구현-복잡성-비교>구현 복잡성 비교<a hidden class=anchor aria-hidden=true href=#구현-복잡성-비교>#</a></h4><ul><li><strong>버블 정렬과 선택 정렬</strong>: 두 알고리즘 모두 매우 직관적이고 이중 반복문을 사용하여 구현된다. 그러나 버블 정렬은 인접 요소의 교환에 초점을 맞추고, 선택 정렬은 최솟값을 찾아 배치하는 데 초점을 맞춘다.</li><li><strong>삽입 정렬</strong>: 삽입 정렬은 카드 게임의 정렬 방식과 유사하여 직관적이다. 이미 정렬된 부분 배열에 새 요소를 올바른 위치에 삽입하는 개념을 이해하기 쉽다.</li><li><strong>병합 정렬</strong>: 병합 정렬은 분할 정복을 사용하므로 재귀 호출과 병합 과정의 이해가 필요하다. 구현이 다소 복잡하지만, 로직은 명확하다.</li><li><strong>퀵 정렬</strong>: 퀵 정렬은 피벗 선택과 파티셔닝 개념을 이해해야 하며, 재귀적 접근 방식을 사용한다. 효율적인 인플레이스 구현은 복잡할 수 있다.</li><li><strong>힙 정렬</strong>: 힙 정렬은 이진 힙 자료구조에 대한 이해가 필요하므로 가장 복잡하다. heapify 과정과 힙 속성 유지 방법을 이해해야 한다.</li></ul><h4 id=성능-특성-비교>성능 특성 비교<a hidden class=anchor aria-hidden=true href=#성능-특성-비교>#</a></h4><p><strong>동일한 예시 배열 <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code>에 대한 비교:</strong></p><ol><li><strong>연산 횟수</strong>:<ul><li>버블 정렬: 약 36번의 비교, 최대 36번의 교환</li><li>선택 정렬: 36번의 비교, 최대 8번의 교환</li><li>삽입 정렬: 평균 20번의 비교, 20번의 이동</li><li>병합 정렬: 약 19번의 비교, 30번의 이동</li><li>퀵 정렬: 평균 16번의 비교, 12번의 교환</li><li>힙 정렬: 약 24번의 비교, 18번의 교환</li></ul></li><li><strong>메모리 사용</strong>:<ul><li>버블/선택/삽입/힙 정렬: 추가 메모리 거의 사용하지 않음</li><li>병합 정렬: 전체 배열 크기만큼의 추가 메모리 필요</li><li>퀵 정렬: 재귀 호출을 위한 스택 공간 필요</li></ul></li><li><strong>적응성</strong>:<ul><li>이미 정렬된 데이터에서:<ul><li>버블 정렬: O(n) (교환 없음 감지 시)</li><li>삽입 정렬: O(n) (비교만 수행)</li><li>선택/병합/힙 정렬: 여전히 모든 연산 수행</li><li>퀵 정렬: 피벗 선택에 따라 최악의 경우 O(n²)</li></ul></li></ul></li></ol><h4 id=적용-상황-비교>적용 상황 비교<a hidden class=anchor aria-hidden=true href=#적용-상황-비교>#</a></h4><ul><li><strong>작은 데이터셋 (n &lt; 50):</strong> 삽입 정렬은 구현이 간단하고 작은 데이터에서 효율적이므로 적합하다. 예를 들어, 카드 게임의 패를 정렬하는 경우 삽입 정렬이 자연스러운 선택이다.</li><li><strong>대용량 데이터 (n > 1000):</strong> 퀵 정렬은 평균적으로 매우 효율적이어서 대용량 데이터에 적합하다. 예를 들어, 데이터베이스 쿼리 결과를 정렬할 때 퀵 정렬이 좋은 선택이다.</li><li><strong>안정적 정렬이 필요한 경우:</strong> 학생 기록을 이름으로 정렬한 후 성적으로 다시 정렬하는 경우, 동명이인의 순서가 유지되어야 한다. 이런 경우 안정적 정렬인 병합 정렬이 적합한다.</li><li><strong>최악의 경우 성능 보장이 필요한 경우:</strong> 실시간 시스템에서는 정렬 시간이 예측 가능해야 한다. 이런 환경에서는 최악의 경우에도 O(n log n)을 보장하는 병합 정렬이나 힙 정렬이 적합하다.</li><li><strong>메모리 제약이 심한 환경:</strong> 임베디드 시스템과 같이 메모리가 제한된 환경에서는 추가 메모리를 거의 사용하지 않는 힙 정렬이나 인플레이스 퀵 정렬이 적합하다.</li></ul><h5 id=데이터-크기에-따른-효율성>데이터 크기에 따른 효율성<a hidden class=anchor aria-hidden=true href=#데이터-크기에-따른-효율성>#</a></h5><ul><li><strong>작은 데이터 (n &lt; 50)</strong>: 삽입 정렬 > 퀵 정렬 > 병합 정렬 > 힙 정렬 > 선택 정렬 > 버블 정렬</li><li><strong>중간 데이터 (50 &lt; n &lt; 1000)</strong>: 퀵 정렬 > 병합 정렬 > 힙 정렬 > 삽입 정렬 > 선택 정렬 > 버블 정렬</li><li><strong>큰 데이터 (n > 1000)</strong>: 퀵 정렬 > 병합 정렬 > 힙 정렬 &#187; 삽입 정렬 > 선택 정렬 > 버블 정렬</li></ul><h5 id=데이터-초기-상태에-따른-효율성>데이터 초기 상태에 따른 효율성<a hidden class=anchor aria-hidden=true href=#데이터-초기-상태에-따른-효율성>#</a></h5><ul><li><strong>이미 정렬된 데이터</strong>: 삽입 정렬 > 버블 정렬 > 병합 정렬 > 힙 정렬 > 퀵 정렬(최악) > 선택 정렬</li><li><strong>역순 정렬된 데이터</strong>: 퀵 정렬(피벗 최적화 필요) > 병합 정렬 > 힙 정렬 > 삽입 정렬(최악) > 버블 정렬(최악) > 선택 정렬</li><li><strong>랜덤 데이터</strong>: 퀵 정렬 > 병합 정렬 > 힙 정렬 > 삽입 정렬 > 선택 정렬 > 버블 정렬</li><li><strong>부분 정렬된 데이터</strong>: 삽입 정렬 > 병합 정렬 > 퀵 정렬 > 힙 정렬 > 버블 정렬 > 선택 정렬</li></ul><h3 id=정렬-알고리즘-종류-및-설명>정렬 알고리즘 종류 및 설명<a hidden class=anchor aria-hidden=true href=#정렬-알고리즘-종류-및-설명>#</a></h3><h4 id=버블-정렬-bubble-sort>버블 정렬 (Bubble Sort)<a hidden class=anchor aria-hidden=true href=#버블-정렬-bubble-sort>#</a></h4><p>버블 정렬은 인접한 두 요소를 비교하여 순서가 잘못되어 있으면 교환하는 과정을 반복한다.<br>가장 큰 값이 배열의 끝으로 &ldquo;버블링(bubbling)&ldquo;되는 방식으로 작동한다.</p><p>특징:</p><ul><li><strong>구현 난이도</strong>: 매우 간단</li><li><strong>안정성</strong>: 안정적 (같은 값의 상대적 순서 유지)</li><li><strong>적응성</strong>: 이미 정렬된 데이터 감지 가능</li><li><strong>교환 횟수</strong>: 많음 (최악의 경우 O(n²))</li></ul><p>시간 복잡도:</p><ul><li>최선: O(n) - 이미 정렬된 경우</li><li>평균: O(n²)</li><li>최악: O(n²)</li></ul><p>공간 복잡도:</p><ul><li>O(1) - 추가 메모리 거의 사용하지 않음</li></ul><p>적합한 상황:</p><ul><li>교육 목적</li><li>거의 정렬된 작은 데이터셋</li><li>정렬 상태 확인 용도</li></ul><p>작동 과정 예시:</p><ul><li><p>초기 배열: <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code></p></li><li><p><strong>첫 번째 패스:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[8, 5, 2, 6, 9, 3, 1, 4, 7] → 8과 5 비교 및 교환 → [5, 8, 2, 6, 9, 3, 1, 4, 7]
</span></span><span class=line><span class=cl>[5, 8, 2, 6, 9, 3, 1, 4, 7] → 8과 2 비교 및 교환 → [5, 2, 8, 6, 9, 3, 1, 4, 7]
</span></span><span class=line><span class=cl>[5, 2, 8, 6, 9, 3, 1, 4, 7] → 8과 6 비교 및 교환 → [5, 2, 6, 8, 9, 3, 1, 4, 7]
</span></span><span class=line><span class=cl>[5, 2, 6, 8, 9, 3, 1, 4, 7] → 9와 3 비교 및 교환 → [5, 2, 6, 8, 3, 9, 1, 4, 7]
</span></span><span class=line><span class=cl>[5, 2, 6, 8, 3, 9, 1, 4, 7] → 9와 1 비교 및 교환 → [5, 2, 6, 8, 3, 1, 9, 4, 7]
</span></span><span class=line><span class=cl>[5, 2, 6, 8, 3, 1, 9, 4, 7] → 9와 4 비교 및 교환 → [5, 2, 6, 8, 3, 1, 4, 9, 7]
</span></span><span class=line><span class=cl>[5, 2, 6, 8, 3, 1, 4, 9, 7] → 9와 7 비교 및 교환 → [5, 2, 6, 8, 3, 1, 4, 7, 9]
</span></span></code></pre></td></tr></table></div></div><p>첫 번째 패스 후, 가장 큰 값인 9가 올바른 위치로 &ldquo;버블링"되었다. 이 과정을 모든 요소가 정렬될 때까지 반복한다.</p></li></ul><p>코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>bubble_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 정렬 완료 감지를 위한 플래그</span>
</span></span><span class=line><span class=cl>        <span class=n>swapped</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 i개 요소는 이미 정렬됨</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>swapped</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 교환이 없었다면 정렬 완료</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>swapped</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=선택-정렬-selection-sort>선택 정렬 (Selection Sort)<a hidden class=anchor aria-hidden=true href=#선택-정렬-selection-sort>#</a></h4><p>선택 정렬은 현재 위치에 들어갈 값을 찾아 선택하는 방식이다.<br>매 반복마다 남은 요소 중 최솟값을 찾아 현재 위치에 배치한다.</p><p>특징:</p><ul><li><strong>구현 난이도</strong>: 간단</li><li><strong>안정성</strong>: 불안정 (같은 값의 상대적 순서 변경 가능)</li><li><strong>교환 횟수</strong>: 적음 (최대 n-1번)</li><li><strong>비교 횟수</strong>: 항상 n(n-1)/2번</li></ul><p>시간 복잡도:</p><ul><li>최선: O(n²)</li><li>평균: O(n²)</li><li>최악: O(n²)</li></ul><p>공간 복잡도:</p><ul><li>O(1) - 추가 메모리 거의 사용하지 않음</li></ul><p>적합한 상황:</p><ul><li>교환 비용이 비싼 환경</li><li>작은 데이터셋</li><li>메모리 제약이 강한 환경</li></ul><p>작동 과정 예시:</p><ul><li>초기 배열: <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code></li><li><strong>첫 번째 패스:</strong><ol><li>전체 배열에서 최솟값 1을 찾는다.</li><li>1을 첫 번째 위치(인덱스 0)의 값 8과 교환한다.</li><li>배열 상태: <code>[1, 5, 2, 6, 9, 3, 8, 4, 7]</code></li></ol></li><li><strong>두 번째 패스:</strong><ol><li>남은 배열 <code>[5, 2, 6, 9, 3, 8, 4, 7]</code>에서 최솟값 2를 찾는다.</li><li>2를 두 번째 위치(인덱스 1)의 값 5와 교환한다.</li><li>배열 상태: <code>[1, 2, 5, 6, 9, 3, 8, 4, 7]</code></li></ol></li><li><strong>세 번째 패스:</strong><ol><li>남은 배열 <code>[5, 6, 9, 3, 8, 4, 7]</code>에서 최솟값 3을 찾는다.</li><li>3을 세 번째 위치(인덱스 2)의 값 5와 교환한다.</li><li>배열 상태: <code>[1, 2, 3, 6, 9, 5, 8, 4, 7]</code></li></ol></li></ul><p>이 과정을 계속 반복하여 배열을 정렬한다.</p><p>코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>selection_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 위치를 최솟값의 인덱스로 초기화</span>
</span></span><span class=line><span class=cl>        <span class=n>min_idx</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># i부터 끝까지 탐색하여 최솟값 찾기</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>min_idx</span> <span class=o>=</span> <span class=n>j</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 최솟값을 현재 위치와 교환</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>min_idx</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=삽입-정렬-insertion-sort>삽입 정렬 (Insertion Sort)<a hidden class=anchor aria-hidden=true href=#삽입-정렬-insertion-sort>#</a></h4><p>삽입 정렬은 정렬된 부분 배열에 새 요소를 적절한 위치에 삽입하는 방식이다.<br>카드 게임에서 카드를 정렬하는 방식과 유사하다.</p><p>특징:</p><ul><li><strong>구현 난이도</strong>: 간단</li><li><strong>안정성</strong>: 안정적</li><li><strong>적응성</strong>: 부분적으로 정렬된 배열에 효율적</li><li><strong>온라인 알고리즘</strong>: 데이터가 들어오는 대로 정렬 가능</li></ul><p>시간 복잡도:</p><ul><li>최선: O(n) - 이미 정렬된 경우</li><li>평균: O(n²)</li><li>최악: O(n²)</li></ul><p>공간 복잡도:</p><ul><li>O(1) - 추가 메모리 거의 사용하지 않음</li></ul><p>적합한 상황:</p><ul><li>작거나 거의 정렬된 데이터셋</li><li>온라인 데이터 처리</li><li>다른 정렬의 하위 루틴으로 사용</li></ul><p>작동 과정 예시:</p><ul><li>초기 배열: <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code></li><li><strong>첫 번째 요소</strong>는 그 자체로 정렬되어 있다고 가정: <code>[8]</code></li><li><strong>두 번째 요소</strong> 5 처리:<ol><li>5와 이전 요소 8을 비교한다.</li><li>5 &lt; 8이므로 8을 오른쪽으로 이동하고 5를 삽입한다.</li><li>배열 상태: <code>[5, 8, 2, 6, 9, 3, 1, 4, 7]</code></li></ol></li><li><strong>세 번째 요소</strong> 2 처리:<ol><li>2와 이전 요소들(8, 5)을 차례로 비교합니다.</li><li>2 &lt; 8이므로 8을 오른쪽으로 이동합니다.</li><li>2 &lt; 5이므로 5를 오른쪽으로 이동하고 2를 삽입합니다.</li><li>배열 상태: <code>[2, 5, 8, 6, 9, 3, 1, 4, 7]</code></li></ol></li><li><strong>네 번째 요소</strong> 6 처리:<ol><li>6과 이전 요소들(8, 5, 2)을 차례로 비교한다.</li><li>6 &lt; 8이므로 8을 오른쪽으로 이동한다.</li><li>6 > 5이므로 6을 5 다음에 삽입한다.</li><li>배열 상태: <code>[2, 5, 6, 8, 9, 3, 1, 4, 7]</code><br>이 과정을 나머지 요소들에 대해 계속 진행한다.</li></ol></li></ul><p>코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>insertion_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>key</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># key보다 큰 요소들을 오른쪽으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>key</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># key를 올바른 위치에 삽입</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>key</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=병합-정렬-merge-sort>병합 정렬 (Merge Sort)<a hidden class=anchor aria-hidden=true href=#병합-정렬-merge-sort>#</a></h4><p>병합 정렬은 분할 정복 방식으로, 배열을 반으로 나누고 각 부분을 재귀적으로 정렬한 후 병합하는 방식이다.</p><p>특징:</p><ul><li><strong>구현 난이도</strong>: 중간</li><li><strong>안정성</strong>: 안정적</li><li><strong>분할 정복</strong>: 문제를 작은 단위로 나누어 해결</li><li><strong>예측 가능한 성능</strong>: 입력에 관계없이 일정한 성능</li></ul><p>시간 복잡도:</p><ul><li>최선: O(n log n)</li><li>평균: O(n log n)</li><li>최악: O(n log n)</li></ul><p>공간 복잡도:</p><ul><li>O(n) - 임시 배열 필요</li></ul><p>적합한 상황:</p><ul><li>대용량 데이터</li><li>안정적 정렬이 필요한 경우</li><li>연결 리스트 정렬 (외부 정렬)</li></ul><p>작동 과정 예시:</p><ul><li><p>초기 배열: <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code></p></li><li><p><strong>분할 단계:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[8, 5, 2, 6, 9, 3, 1, 4, 7]
</span></span><span class=line><span class=cl>          /          \
</span></span><span class=line><span class=cl>   [8, 5, 2, 6]    [9, 3, 1, 4, 7]
</span></span><span class=line><span class=cl>     /    \          /        \
</span></span><span class=line><span class=cl>  [8, 5]  [2, 6]  [9, 3]    [1, 4, 7]
</span></span><span class=line><span class=cl>   / \     / \     / \       /    \
</span></span><span class=line><span class=cl> [8] [5] [2] [6] [9] [3]  [1]  [4, 7]
</span></span><span class=line><span class=cl>                             /  \
</span></span><span class=line><span class=cl>                           [4]  [7]
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>병합 단계:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl> [8] [5] [2] [6] [9] [3] [1] [4] [7]
</span></span><span class=line><span class=cl>   \ /     \ /     \ /     \ /
</span></span><span class=line><span class=cl>  [5,8]   [2,6]   [3,9]   [1,4,7]
</span></span><span class=line><span class=cl>      \    /         \    /
</span></span><span class=line><span class=cl>     [2,5,6,8]     [1,3,4,7,9]
</span></span><span class=line><span class=cl>               \    /
</span></span><span class=line><span class=cl>         [1,2,3,4,5,6,7,8,9]
</span></span></code></pre></td></tr></table></div></div></li></ul><p>코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 분할 단계</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=n>mid</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>merge_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 병합 단계</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>merge</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 배열을 비교하여 작은 값부터 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=ow>and</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 요소들 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=퀵-정렬-quick-sort>퀵 정렬 (Quick Sort)<a hidden class=anchor aria-hidden=true href=#퀵-정렬-quick-sort>#</a></h4><p>퀵 정렬도 분할 정복 방식이지만, 피벗을 기준으로 작은 값과 큰 값으로 분할하여 재귀적으로 정렬한다.</p><p>특징:</p><ul><li><strong>구현 난이도</strong>: 중간</li><li><strong>안정성</strong>: 불안정</li><li><strong>인플레이스</strong>: 추가 메모리를 적게 사용</li><li><strong>캐시 효율성</strong>: 지역성이 좋아 실제 성능이 우수</li></ul><p>시간 복잡도:</p><ul><li>최선: O(n log n)</li><li>평균: O(n log n)</li><li>최악: O(n²) - 피벗 선택이 불량할 때</li></ul><p>공간 복잡도:</p><ul><li>O(log n) - 재귀 호출 스택</li></ul><p>적합한 상황:</p><ul><li>대부분의 일반적인 상황</li><li>평균적으로 빠른 성능이 필요할 때</li><li>공간 효율성이 중요할 때</li></ul><p>작동 과정 예시:</p><ul><li>초기 배열: <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code></li><li><strong>첫 번째 분할:</strong> (피벗 = 8)<ol><li>8을 피벗으로 선택합니다.</li><li>8보다 작은 요소들 <code>[5, 2, 6, 3, 1, 4, 7]</code>을 왼쪽에, 큰 요소들 <code>[9]</code>를 오른쪽에 배치한다.</li><li>배열 상태: <code>[5, 2, 6, 3, 1, 4, 7, 8, 9]</code></li></ol></li><li><strong>왼쪽 부분 배열 정렬:</strong> (피벗 = 5)<ol><li>5를 피벗으로 선택한다.</li><li>5보다 작은 요소들 <code>[2, 3, 1, 4]</code>을 왼쪽에, 큰 요소들 <code>[6, 7]</code>을 오른쪽에 배치한다.</li><li>배열 상태: <code>[2, 3, 1, 4, 5, 6, 7, 8, 9]</code></li></ol></li><li><strong>왼쪽의 왼쪽 부분 배열 정렬:</strong> (피벗 = 2)<ol><li>2를 피벗으로 선택한다.</li><li>2보다 작은 요소들 <code>[1]</code>을 왼쪽에, 큰 요소들 <code>[3, 4]</code>을 오른쪽에 배치한다.</li><li>배열 상태: <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code><br>이런 식으로 모든 부분 배열이 정렬될 때까지 재귀적으로 진행한다.</li></ol></li></ul><p>코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>quick_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>arr</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>pivot</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span><span class=p>]</span>  <span class=c1># 중간 요소를 피벗으로 선택</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>middle</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>arr</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>middle</span> <span class=o>+</span> <span class=n>quick_sort</span><span class=p>(</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=힙-정렬-heap-sort>힙 정렬 (Heap Sort)<a hidden class=anchor aria-hidden=true href=#힙-정렬-heap-sort>#</a></h4><p>힙 정렬은 이진 힙 자료구조를 이용하여 최대 힙(또는 최소 힙)을 구성한 후, 루트를 제거하면서 정렬한다.</p><p>특징:</p><ul><li><strong>구현 난이도</strong>: 다소 복잡</li><li><strong>안정성</strong>: 불안정</li><li><strong>인플레이스</strong>: 추가 메모리를 거의 사용하지 않음</li><li><strong>보장된 성능</strong>: 최악의 경우에도 O(n log n) 보장</li></ul><p>시간 복잡도:</p><ul><li>최선: O(n log n)</li><li>평균: O(n log n)</li><li>최악: O(n log n)</li></ul><p>공간 복잡도:</p><ul><li>O(1) - 추가 메모리 거의 사용하지 않음</li></ul><p>적합한 상황:</p><ul><li>최악의 경우에도 성능 보장이 필요할 때</li><li>메모리 사용량이 제한적인 환경</li><li>부분 정렬이 필요한 경우 (top k 요소)</li></ul><p>작동 과정 예시:</p><ul><li><p>초기 배열: <code>[8, 5, 2, 6, 9, 3, 1, 4, 7]</code></p></li><li><p><strong>1단계: 최대 힙 구성</strong><br>먼저 배열을 최대 힙으로 변환한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>          9
</span></span><span class=line><span class=cl>        /   \
</span></span><span class=line><span class=cl>       7     8
</span></span><span class=line><span class=cl>      / \   / \
</span></span><span class=line><span class=cl>     6   4 3   2
</span></span><span class=line><span class=cl>    / \
</span></span><span class=line><span class=cl>   1   5
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2단계: 정렬 수행</strong></p><ol><li>루트(9)와 마지막 요소(5)를 교환: <code>[5, 7, 8, 6, 4, 3, 2, 1, 9]</code></li><li>힙 크기를 1 감소시키고 새 루트(5)를 적절한 위치로 이동:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>          8
</span></span><span class=line><span class=cl>        /   \
</span></span><span class=line><span class=cl>       7     3
</span></span><span class=line><span class=cl>      / \   / \
</span></span><span class=line><span class=cl>     6   4 2   1
</span></span><span class=line><span class=cl>    /
</span></span><span class=line><span class=cl>   5	  
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>루트(8)와 마지막 요소(5)를 교환: <code>[5, 7, 3, 6, 4, 2, 1, 8, 9]</code></li></ol></li></ul><p>이 과정을 반복하여 배열을 정렬한다.</p><p>코드 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>largest</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 자식이 루트보다 크면 largest 갱신</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>left</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 자식이 루트보다 크면 largest 갱신</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>right</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=ow>and</span> <span class=n>arr</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>largest</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># largest가 루트가 아니면 교환 및 재귀 호출</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>largest</span> <span class=o>!=</span> <span class=n>i</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=n>largest</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>largest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>heap_sort</span><span class=p>(</span><span class=n>arr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최대 힙 구성</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>//</span> <span class=mi>2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 요소를 하나씩 추출</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>  <span class=c1># 현재 루트를 끝으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>heapify</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1># 줄어든 힙에 대해 heapify 수행</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>arr</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬은 가장 간단하고 직관적인 정렬 알고리즘 중 하나이다.
이름에서 알 수 있듯이, 마치 물속에서 공기 방울이 떠오르는 것처럼 큰 값들이 배열의 끝으로 ‘부글부글’ 올라가는 모습을 연상시킨다.
이 알고리즘은 단순함 때문에 컴퓨터 과학 입문 과정에서 가장 먼저 배우는 정렬 알고리즘이지만, 실제 응용에서는 비효율성 때문에 잘 사용되지 않는다. 그럼에도 불구하고, 버블 정렬의 작동 방식과 특성을 이해하는 것은 다른 정렬 알고리즘의 기초를 다지는 데 중요하다.
버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 구현이 쉽고 이해하기 직관적이다. 그러나 O(n²)의 시간 복잡도로 인해 대규모 데이터셋에서는 비효율적이며, 실제 응용에서는 퀵 정렬, 병합 정렬, 힙 정렬과 같은 더 효율적인 알고리즘들이 선호된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/bubble-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>선택 정렬 (Selection Sort)</h2></header><div class=entry-content><p>선택 정렬 (Selection Sort) 선택 정렬은 가장 직관적이고 이해하기 쉬운 정렬 알고리즘 중 하나이다.
선택 정렬은 개념적으로 가장 단순한 정렬 알고리즘 중 하나로, 알고리즘을 처음 배우는 사람들에게 좋은 시작점이 된다. 비록 대규모 데이터에서는 효율적이지 않지만, 특정 상황에서는 실용적인 선택이 될 수 있다.
선택 정렬의 핵심 특징은 다음과 같다:
구현이 매우 간단합니다. 교환 연산의 수가 적습니다(최대 n-1번). 메모리 사용이 최소화된다. 입력 데이터의 상태와 관계없이 일정한 성능을 보인다. 더 효율적인 정렬 알고리즘이 많이 존재하지만, 선택 정렬은 그 단순함과 직관적인 접근 방식으로 알고리즘 학습에 중요한 역할을 한다. 또한 작은 데이터셋이나 특정 제약 조건이 있는 환경에서는 여전히 유용한 알고리즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선택 정렬 (Selection Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>삽입 정렬 (Insertion Sort)</h2></header><div class=entry-content><p>삽입 정렬 (Insertion Sort) 삽입 정렬은 간단하면서도 직관적인 정렬 알고리즘으로, 실생활에서 카드 게임을 할 때 손에 든 카드를 정렬하는 방식과 매우 유사하다.
삽입 정렬은 간단하고 직관적인 정렬 알고리즘으로, 작은 데이터셋이나 거의 정렬된 데이터에서 효율적으로 작동한다.
비록 큰 데이터셋에서는 O(n²)의 시간 복잡도로 인해 퀵 정렬, 합병 정렬, 힙 정렬 등에 비해 느리지만, 그 단순함과 특정 상황에서의 효율성으로 인해 여전히 중요한 알고리즘이다.
실제 응용에서는 종종 다른 정렬 알고리즘과 함께 하이브리드 접근 방식으로 사용되며, 이를 통해 더 나은 성능을 얻을 수 있다. 또한 이진 탐색을 활용한 최적화나 셸 정렬과 같은 변형을 통해 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 삽입 정렬 (Insertion Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/insertion-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬은 분할 정복(Divide and Conquer) 패러다임을 기반으로 하는 효율적인 정렬 알고리즘이다.
여러 정렬 알고리즘 중에서도 안정적인 성능과 일관된 시간 복잡도를 제공하는 방식으로 널리 사용된다.
병합 정렬은 안정적인 성능과 예측 가능한 시간 복잡도를 제공하는 매우 유용한 정렬 알고리즘. 추가 메모리가 필요하다는 단점이 있지만, 대규모 데이터 처리나 외부 정렬에 적합하며, 안정적인 정렬이 필요한 상황에서 특히 유용하다.
알고리즘의 단순성과 병렬화 가능성도 중요한 장점이다.
병합 정렬의 기본 원리 병합 정렬은 다음 세 단계로 동작한다:
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/merge-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>퀵 정렬 (Quick Sort)</h2></header><div class=entry-content><p>퀵 정렬 (Quick Sort) 퀵 정렬은 1960년 Tony Hoare가 개발한 효율적인 분할 정복(Divide and Conquer) 알고리즘으로, 평균적으로 매우 빠른 성능을 보이는 정렬 방식이다. 실제 많은 프로그래밍 언어의 표준 라이브러리에 구현되어 있을 정도로 실용적인 정렬 알고리즘이다.
퀵 정렬은 간단한 아이디어를 바탕으로 하면서도 매우 효율적인 정렬 알고리즘이다.
평균적인 성능이 우수하고 실제 구현에서 다양한 최적화 기법을 적용할 수 있어 많은 환경에서 선호된다.
최악의 경우를 대비한 피벗 선택 최적화와 하이브리드 접근 방식을 통해 단점을 보완하여 현대적인 정렬 알고리즘의 기반이 되고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 퀵 정렬 (Quick Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/quick-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>힙 정렬 (Heap Sort)</h2></header><div class=entry-content><p>힙 정렬 (Heap Sort) 힙 정렬은 비교 기반 정렬 알고리즘으로, 이진 힙 자료구조를 활용하여 효율적인 정렬을 수행한다.
시간 복잡도가 안정적이고 추가 메모리를 거의 사용하지 않는 특징을 가지고 있어 많은 시스템에서 널리 사용된다.
힙 정렬은 비교 기반 정렬 알고리즘 중에서 시간 복잡도가 보장되고 추가 메모리를 거의 사용하지 않는 효율적인 알고리즘이다.
최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지며, 특히 메모리 제약이 있는 환경에서 유용하다.
불안정 정렬이라는 단점이 있지만, 안정성이 중요하지 않은 많은 응용 분야에서 여전히 강력한 선택지이다. 힙 자료구조의 이해는 우선순위 큐, 그래프 알고리즘 등 컴퓨터 과학의 다른 영역에도 도움이 된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 힙 정렬 (Heap Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>