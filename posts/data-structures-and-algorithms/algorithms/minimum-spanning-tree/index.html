<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>최소 신장 트리(Minimum Spanning Tree, MST) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Algorithms,Minimum-Spanning-Tree"><meta name=description content="최소 신장 트리(Minimum Spanning Tree, MST)
MST는 단순한 개념이지만 강력한 응용 가능성을 가진 알고리즘이다.
다양한 실제 문제에서 MST의 원리를 적용하면 효율적인 해결책을 찾을 수 있을 것이다.
신장 트리(Spanning Tree)란?
신장 트리는 주어진 그래프의 모든 정점을 포함하면서, 사이클을 형성하지 않는 부분 그래프이다.
즉, 다음 조건을 만족한다:

원래 그래프의 모든 정점을 포함한다.
정확히 (n-1)개의 간선을 가진다(n은 정점의 수).
어떤 사이클도 포함하지 않는다(트리 구조).
그래프의 모든 정점이 연결되어 있다.

예를 들어, 5개의 정점을 가진 연결된 그래프의 신장 트리는 정확히 4개의 간선을 가지며, 모든 정점이 연결되어 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="최소 신장 트리(Minimum Spanning Tree, MST)"><meta property="og:description" content="최소 신장 트리(Minimum Spanning Tree, MST) MST는 단순한 개념이지만 강력한 응용 가능성을 가진 알고리즘이다.
다양한 실제 문제에서 MST의 원리를 적용하면 효율적인 해결책을 찾을 수 있을 것이다.
신장 트리(Spanning Tree)란? 신장 트리는 주어진 그래프의 모든 정점을 포함하면서, 사이클을 형성하지 않는 부분 그래프이다.
즉, 다음 조건을 만족한다:
원래 그래프의 모든 정점을 포함한다. 정확히 (n-1)개의 간선을 가진다(n은 정점의 수). 어떤 사이클도 포함하지 않는다(트리 구조). 그래프의 모든 정점이 연결되어 있다. 예를 들어, 5개의 정점을 가진 연결된 그래프의 신장 트리는 정확히 4개의 간선을 가지며, 모든 정점이 연결되어 있다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="최소 신장 트리(Minimum Spanning Tree, MST)"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/"},{"@type":"ListItem","position":4,"name":"최소 신장 트리(Minimum Spanning Tree, MST)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/>Algorithms</a></div><h1>최소 신장 트리(Minimum Spanning Tree, MST)</h1></header><div class=post-content><h2 id=최소-신장-트리minimum-spanning-tree-mst>최소 신장 트리(Minimum Spanning Tree, MST)<a hidden class=anchor aria-hidden=true href=#최소-신장-트리minimum-spanning-tree-mst>#</a></h2><p>MST는 단순한 개념이지만 강력한 응용 가능성을 가진 알고리즘이다.<br>다양한 실제 문제에서 MST의 원리를 적용하면 효율적인 해결책을 찾을 수 있을 것이다.</p><h3 id=신장-트리spanning-tree란>신장 트리(Spanning Tree)란?<a hidden class=anchor aria-hidden=true href=#신장-트리spanning-tree란>#</a></h3><p>신장 트리는 주어진 그래프의 모든 정점을 포함하면서, 사이클을 형성하지 않는 부분 그래프이다.<br>즉, 다음 조건을 만족한다:</p><ol><li>원래 그래프의 모든 정점을 포함한다.</li><li>정확히 (n-1)개의 간선을 가진다(n은 정점의 수).</li><li>어떤 사이클도 포함하지 않는다(트리 구조).</li><li>그래프의 모든 정점이 연결되어 있다.</li></ol><p>예를 들어, 5개의 정점을 가진 연결된 그래프의 신장 트리는 정확히 4개의 간선을 가지며, 모든 정점이 연결되어 있다.</p><h3 id=최소-신장-트리mst의-정의>최소 신장 트리(MST)의 정의<a hidden class=anchor aria-hidden=true href=#최소-신장-트리mst의-정의>#</a></h3><p>최소 신장 트리는 가중치가 있는 무방향 그래프에서, 가능한 모든 신장 트리 중에서 간선의 가중치 합이 최소인 신장 트리를 말한다.</p><p>가중치가 있는 그래프에서는 여러 개의 서로 다른 신장 트리가 존재할 수 있다. 이들 중에서 간선의 가중치 합이 최소인 트리를 선택하는 것이 MST의 목표이다.</p><h3 id=mst의-특성>MST의 특성<a hidden class=anchor aria-hidden=true href=#mst의-특성>#</a></h3><p>MST는 다음과 같은 중요한 특성을 가진다:</p><ol><li><strong>유일성</strong>: 그래프의 모든 간선의 가중치가 서로 다르다면, MST는 유일하다.</li><li><strong>사이클 제거</strong>: MST는 항상 사이클을 제거하여 트리 구조를 형성한다.</li><li><strong>최적 부분 구조</strong>: MST의 부분 트리도 해당 부분 그래프의 MST이다.</li><li><strong>간선 수</strong>: n개의 정점을 가진 그래프의 MST는 항상 (n-1)개의 간선을 가진다.</li><li><strong>연결성</strong>: MST는 그래프의 모든 정점을 연결한다.</li></ol><h3 id=mst의-응용-분야>MST의 응용 분야<a hidden class=anchor aria-hidden=true href=#mst의-응용-분야>#</a></h3><p>MST는 다양한 실제 응용 분야에서 활용된다:</p><ol><li>네트워크 설계<ul><li><strong>통신 네트워크</strong>: 모든 지점을 연결하는 최소 비용의 케이블 네트워크 구축</li><li><strong>전력망 설계</strong>: 최소 비용으로 모든 지역에 전력을 공급하는 전력선 네트워크 설계</li><li><strong>파이프라인 설계</strong>: 모든 지점을 연결하는 최소 비용의 파이프라인 시스템 설계</li></ul></li><li>클러스터링 및 데이터 분석<ul><li><strong>클러스터링 알고리즘</strong>: 데이터 포인트를 그룹화하는 과정에서 MST 활용</li><li><strong>이미지 세그멘테이션</strong>: 이미지의 픽셀을 의미 있는 영역으로 분할</li><li><strong>계층적 클러스터링</strong>: 데이터의 계층 구조를 찾는 데 MST 활용</li></ul></li><li>근사 알고리즘<ul><li><strong>외판원 문제(TSP)의 근사 해법</strong>: MST를 활용한 TSP의 2-근사 알고리즘</li><li><strong>스타이너 트리 문제의 근사</strong>: 필수 정점을 모두 연결하는 최소 비용 트리 찾기</li></ul></li><li>기타 응용<ul><li><strong>컴퓨터 네트워크 라우팅</strong>: 효율적인 네트워크 라우팅 프로토콜 설계</li><li><strong>회로 설계</strong>: 전자 회로의 최적 연결 구조 설계</li><li><strong>진화 분류학</strong>: 종 간의 진화적 관계를 나타내는 계통수 구성</li></ul></li></ol><h3 id=mst-알고리즘>MST 알고리즘<a hidden class=anchor aria-hidden=true href=#mst-알고리즘>#</a></h3><p>MST를 찾기 위한 여러 알고리즘이 있으며, 가장 유명한 두 가지는 크루스칼(Kruskal)과 프림(Prim) 알고리즘이다.</p><h4 id=크루스칼kruskal-알고리즘>크루스칼(Kruskal) 알고리즘<a hidden class=anchor aria-hidden=true href=#크루스칼kruskal-알고리즘>#</a></h4><p>크루스칼 알고리즘은 &lsquo;탐욕(Greedy)&rsquo; 방식으로 MST를 구축한다:</p><h5 id=알고리즘-단계>알고리즘 단계<a hidden class=anchor aria-hidden=true href=#알고리즘-단계>#</a></h5><ol><li>그래프의 모든 간선을 가중치의 오름차순으로 정렬한다.</li><li>MST를 빈 집합으로 초기화한다.</li><li>정렬된 간선 목록에서 가장 가중치가 작은 간선부터 차례로 검사한다:<ul><li>현재 간선이 MST에 추가될 때 사이클을 형성하지 않는다면 MST에 추가한다.</li><li>사이클을 형성한다면 해당 간선은 무시한다.</li></ul></li><li>MST에 (n-1)개의 간선이 추가될 때까지(또는 모든 간선을 검사할 때까지) 3단계를 반복한다.</li></ol><h5 id=시간-복잡도>시간 복잡도<a hidden class=anchor aria-hidden=true href=#시간-복잡도>#</a></h5><ul><li>간선 정렬: O(E log E)</li><li>사이클 검사 및 간선 추가: O(E log V) (Union-Find 자료구조 사용)</li><li>전체 시간 복잡도: O(E log E) 또는 O(E log V)<ul><li>E는 간선의 수, V는 정점의 수</li><li>대부분의 경우 E &lt; V²이므로 O(E log V)로 표현 가능</li></ul></li></ul><h5 id=크루스칼-알고리즘-구현>크루스칼 알고리즘 구현<a hidden class=anchor aria-hidden=true href=#크루스칼-알고리즘-구현>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>kruskal</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    크루스칼 알고리즘을 사용하여 MST를 찾는 함수
</span></span></span><span class=line><span class=cl><span class=s2>    입력: 
</span></span></span><span class=line><span class=cl><span class=s2>      graph: (u, v, weight) 형태의 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    출력: 
</span></span></span><span class=line><span class=cl><span class=s2>      MST를 구성하는 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 정점의 수 (가장 큰 정점 번호 + 1)</span>
</span></span><span class=line><span class=cl>    <span class=n>vertices</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Union-Find를 위한 부모 배열 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>parent</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>vertices</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Find 연산 (경로 압축 적용)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>!=</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Union 연산</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>[</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>)]</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 간선을 가중치 기준으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>edge</span><span class=p>:</span> <span class=n>edge</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mst</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 최소 신장 트리</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 간선에 대해 처리</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 두 정점이 서로 다른 집합에 속해 있으면 (사이클이 형성되지 않으면)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span> <span class=o>!=</span> <span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>union</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>  <span class=c1># 두 집합을 합침</span>
</span></span><span class=line><span class=cl>            <span class=n>mst</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>  <span class=c1># MST에 간선 추가</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># MST가 완성되면 종료 (정점 수 - 1개의 간선)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>mst</span><span class=p>)</span> <span class=o>==</span> <span class=n>vertices</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mst</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=프림prim-알고리즘>프림(Prim) 알고리즘<a hidden class=anchor aria-hidden=true href=#프림prim-알고리즘>#</a></h4><p>프림 알고리즘도 &lsquo;탐욕(Greedy)&rsquo; 방식을 사용하지만, 노드 중심으로 MST를 구축한다.</p><h5 id=알고리즘-단계-1>알고리즘 단계<a hidden class=anchor aria-hidden=true href=#알고리즘-단계-1>#</a></h5><ol><li>시작 정점을 선택하고, 이 정점만 포함하는 부분 트리를 초기화한다.</li><li>현재 부분 트리에 있는 정점과 트리 외부의 정점을 연결하는 모든 간선 중에서 가중치가 가장 작은 간선을 선택한다.</li><li>선택한 간선과 연결된 외부 정점을 부분 트리에 추가한다.</li><li>모든 정점이 트리에 포함될 때까지 2-3단계를 반복한다.</li></ol><h5 id=시간-복잡도-1>시간 복잡도<a hidden class=anchor aria-hidden=true href=#시간-복잡도-1>#</a></h5><ul><li>인접 행렬 구현: O(V²)</li><li>이진 힙을 사용한 구현: O(E log V)</li><li>피보나치 힙을 사용한 이론적 최적 구현: O(E + V log V)</li></ul><p>일반적으로는 이진 힙을 사용한 O(E log V) 구현이 가장 널리 사용된다.</p><h5 id=프림-알고리즘-구현>프림 알고리즘 구현<a hidden class=anchor aria-hidden=true href=#프림-알고리즘-구현>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span><span class=lnt id=hl-1-29><a class=lnlinks href=#hl-1-29>29</a>
</span><span class=lnt id=hl-1-30><a class=lnlinks href=#hl-1-30>30</a>
</span><span class=lnt id=hl-1-31><a class=lnlinks href=#hl-1-31>31</a>
</span><span class=lnt id=hl-1-32><a class=lnlinks href=#hl-1-32>32</a>
</span><span class=lnt id=hl-1-33><a class=lnlinks href=#hl-1-33>33</a>
</span><span class=lnt id=hl-1-34><a class=lnlinks href=#hl-1-34>34</a>
</span><span class=lnt id=hl-1-35><a class=lnlinks href=#hl-1-35>35</a>
</span><span class=lnt id=hl-1-36><a class=lnlinks href=#hl-1-36>36</a>
</span><span class=lnt id=hl-1-37><a class=lnlinks href=#hl-1-37>37</a>
</span><span class=lnt id=hl-1-38><a class=lnlinks href=#hl-1-38>38</a>
</span><span class=lnt id=hl-1-39><a class=lnlinks href=#hl-1-39>39</a>
</span><span class=lnt id=hl-1-40><a class=lnlinks href=#hl-1-40>40</a>
</span><span class=lnt id=hl-1-41><a class=lnlinks href=#hl-1-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>prim</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>start_vertex</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    프림 알고리즘을 사용하여 MST를 찾는 함수
</span></span></span><span class=line><span class=cl><span class=s2>    입력: 
</span></span></span><span class=line><span class=cl><span class=s2>      graph: 인접 리스트 형태의 그래프 ({정점: [(이웃 정점, 가중치), …], …})
</span></span></span><span class=line><span class=cl><span class=s2>      start_vertex: 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>    출력: 
</span></span></span><span class=line><span class=cl><span class=s2>      MST를 구성하는 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 방문한 정점 집합</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>{</span><span class=n>start_vertex</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># (가중치, 시작 정점, 도착 정점) 형태의 간선을 저장할 우선순위 큐</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[(</span><span class=n>weight</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>             <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heapify</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>  <span class=c1># 우선순위 큐로 변환</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>mst</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 최소 신장 트리</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 정점을 방문할 때까지 반복</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>edges</span> <span class=ow>and</span> <span class=nb>len</span><span class=p>(</span><span class=n>visited</span><span class=p>)</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 가장 가중치가 작은 간선 선택</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span><span class=p>,</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 도착 정점이 이미 방문한 정점이면 스킵</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1># 정점 방문 표시</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># MST에 간선 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>mst</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 새로 추가된 정점과 연결된 모든 간선을 우선순위 큐에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>edge_weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>edges</span><span class=p>,</span> <span class=p>(</span><span class=n>edge_weight</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mst</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=크루스칼-vs-프림-알고리즘-비교>크루스칼 Vs 프림: 알고리즘 비교<a hidden class=anchor aria-hidden=true href=#크루스칼-vs-프림-알고리즘-비교>#</a></h4><p>두 알고리즘은 모두 MST를 찾기 위한 정확한 방법이지만, 상황에 따라 각각의 장단점이 있다:</p><table><thead><tr><th>특성</th><th>크루스칼</th><th>프림</th></tr></thead><tbody><tr><td>접근 방식</td><td>간선 중심(Edge-based)</td><td>정점 중심(Vertex-based)</td></tr><tr><td>시간 복잡도</td><td>O(E log E) 또는 O(E log V)</td><td>O(E log V) (이진 힙 구현)</td></tr><tr><td>희소 그래프(E ≈ V)</td><td>더 효율적</td><td>약간 덜 효율적</td></tr><tr><td>밀집 그래프(E ≈ V²)</td><td>약간 덜 효율적</td><td>더 효율적 (특히 인접 행렬 구현 시)</td></tr><tr><td>구현 난이도</td><td>Union-Find 자료구조 필요</td><td>우선순위 큐/힙 필요</td></tr><tr><td>부분 MST 계산</td><td>어려움 (전체 간선 정렬 필요)</td><td>쉬움 (특정 정점 집합에서 시작 가능)</td></tr><tr><td>병렬화 가능성</td><td>제한적</td><td>더 어려움</td></tr></tbody></table><h3 id=mst의-고급-주제-및-변형>MST의 고급 주제 및 변형<a hidden class=anchor aria-hidden=true href=#mst의-고급-주제-및-변형>#</a></h3><ol><li>역최소 신장 트리(Maximum Spanning Tree)<br>역최소 신장 트리는 간선의 가중치 합이 최대가 되는 신장 트리이다.<br>기존 MST 알고리즘을 약간 수정하여 구할 수 있다:<ul><li>크루스칼: 간선을 가중치 내림차순으로 정렬</li><li>프림: 최소 힙 대신 최대 힙 사용</li></ul></li><li>차선 최소 신장 트리(Second Best MST)<br>MST 다음으로 가중치 합이 작은 신장 트리를 찾는 문제입니다.<ul><li>접근 방법:<ol><li>첫 번째 MST를 찾는다.</li><li>MST의 각 간선을 제거하고, 제거한 간선 대신 포함하지 않은 다른 간선으로 대체한다.</li><li>이렇게 얻은 여러 후보 트리 중에서 가중치 합이 최소인 트리를 선택한다.</li></ol></li></ul></li><li>병렬 MST 알고리즘<br>대규모 그래프에서는 병렬 MST 알고리즘이 필요할 수 있다:<ul><li>Boruvka 알고리즘: 자연스럽게 병렬화 가능한 MST 알고리즘</li><li>필터링 기법: 그래프의 크기를 줄인 후 MST를 계산</li><li>분할 정복 접근법: 그래프를 여러 부분으로 나누어 각각 MST를 계산한 후 병합</li></ul></li><li>동적 MST<br>그래프의 간선이나 정점이 추가/제거되는 동적 환경에서 MST를 효율적으로 유지하는 문제:<ul><li>간선 삽입: 새 간선이 MST의 사이클에서 최대 가중치를 가진 간선보다 가중치가 작으면 대체</li><li>간선 삭제: 삭제된 간선이 MST에 속하면 남은 그래프에서 두 개의 컴포넌트를 연결하는 최소 가중치 간선을 찾아 추가</li></ul></li></ol><h3 id=mst-구현-최적화-및-성능-고려사항>MST 구현 최적화 및 성능 고려사항<a hidden class=anchor aria-hidden=true href=#mst-구현-최적화-및-성능-고려사항>#</a></h3><ol><li><p>자료구조 최적화<br>MST 알고리즘의 성능은 사용하는 자료구조에 크게 영향을 받는다:</p><ul><li><p>Union-Find 최적화 (크루스칼 알고리즘)</p><ul><li><strong>경로 압축(Path Compression)</strong>: <code>find</code> 연산 시 부모를 루트로 바로 연결</li><li><strong>랭크 기반 합치기(Union by Rank)</strong>: 트리의 높이를 최소화</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 최적화된 Union-Find 구현</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UnionFind</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rank</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>!=</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>])</span>  <span class=c1># 경로 압축</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>root_x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>root_y</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>root_x</span> <span class=o>==</span> <span class=n>root_y</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 랭크 기반 합치기</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>root_x</span><span class=p>]</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>root_y</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>root_x</span><span class=p>]</span> <span class=o>=</span> <span class=n>root_y</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>root_x</span><span class=p>]</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>root_y</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>root_y</span><span class=p>]</span> <span class=o>=</span> <span class=n>root_x</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>[</span><span class=n>root_y</span><span class=p>]</span> <span class=o>=</span> <span class=n>root_x</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rank</span><span class=p>[</span><span class=n>root_x</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>우선순위 큐 최적화 (프림 알고리즘)</p><ul><li><strong>이진 힙</strong>: 일반적인 구현에 사용, O(log n) 삽입/삭제</li><li><strong>d-heap</strong>: 이진 힙의 일반화, 각 노드가 d개의 자식을 가짐</li><li><strong>피보나치 힙</strong>: 더 효율적인 이론적 성능(감소 연산에 분할상환 O(1) 시간)</li></ul></li></ul></li><li><p>그래프 표현 방식<br>그래프 표현 방식에 따라 알고리즘의 효율성이 달라진다:</p><ul><li><strong>인접 행렬</strong>: 밀집 그래프에 적합, O(V²) 공간</li><li><strong>인접 리스트</strong>: 희소 그래프에 적합, O(V+E) 공간</li><li><strong>간선 리스트</strong>: 크루스칼 알고리즘에 적합, O(E) 공간</li></ul></li><li><p>대규모 그래프 처리<br>매우 큰 그래프에서 MST를 계산할 때 고려할 사항:</p><ul><li><strong>외부 메모리 알고리즘</strong>: 모든 데이터를 메모리에 로드할 수 없을 때 사용</li><li><strong>그래프 압축</strong>: 불필요한 간선이나 정점을 제거하여 크기 축소</li><li><strong>근사 알고리즘</strong>: 정확한 MST 대신 근사 해를 계산하여 시간 단축</li><li><strong>분산 MST 알고리즘</strong>: 여러 머신에 계산을 분산하여 처리</li></ul></li></ol><h3 id=실제-구현-및-사용-예제>실제 구현 및 사용 예제<a hidden class=anchor aria-hidden=true href=#실제-구현-및-사용-예제>#</a></h3><h4 id=네트워크-설계-사례>네트워크 설계 사례<a hidden class=anchor aria-hidden=true href=#네트워크-설계-사례>#</a></h4><p>통신 네트워크 설계 문제를 MST로 해결하는 예제:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>design_network</span><span class=p>(</span><span class=n>cities</span><span class=p>,</span> <span class=n>connection_costs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    도시 간 통신 네트워크를 최소 비용으로 설계
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      cities: 도시 목록
</span></span></span><span class=line><span class=cl><span class=s2>      connection_costs: [(도시1, 도시2, 비용), …] 형태의 연결 비용 목록
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      설치할 통신선 목록
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 도시 인덱스 매핑</span>
</span></span><span class=line><span class=cl>    <span class=n>city_to_idx</span> <span class=o>=</span> <span class=p>{</span><span class=n>city</span><span class=p>:</span> <span class=n>idx</span> <span class=k>for</span> <span class=n>idx</span><span class=p>,</span> <span class=n>city</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>cities</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 간선 리스트 변환</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[(</span><span class=n>city_to_idx</span><span class=p>[</span><span class=n>city1</span><span class=p>],</span> <span class=n>city_to_idx</span><span class=p>[</span><span class=n>city2</span><span class=p>],</span> <span class=n>cost</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>             <span class=k>for</span> <span class=n>city1</span><span class=p>,</span> <span class=n>city2</span><span class=p>,</span> <span class=n>cost</span> <span class=ow>in</span> <span class=n>connection_costs</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 크루스칼 알고리즘으로 MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 인덱스를 도시 이름으로 다시 변환</span>
</span></span><span class=line><span class=cl>    <span class=n>result_network</span> <span class=o>=</span> <span class=p>[(</span><span class=n>cities</span><span class=p>[</span><span class=n>u</span><span class=p>],</span> <span class=n>cities</span><span class=p>[</span><span class=n>v</span><span class=p>],</span> <span class=n>cost</span><span class=p>)</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>cost</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 총 비용 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>total_cost</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>cost</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>cost</span> <span class=ow>in</span> <span class=n>result_network</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result_network</span><span class=p>,</span> <span class=n>total_cost</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예</span>
</span></span><span class=line><span class=cl><span class=n>cities</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;서울&#34;</span><span class=p>,</span> <span class=s2>&#34;부산&#34;</span><span class=p>,</span> <span class=s2>&#34;대구&#34;</span><span class=p>,</span> <span class=s2>&#34;인천&#34;</span><span class=p>,</span> <span class=s2>&#34;광주&#34;</span><span class=p>,</span> <span class=s2>&#34;대전&#34;</span><span class=p>,</span> <span class=s2>&#34;울산&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>costs</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s2>&#34;서울&#34;</span><span class=p>,</span> <span class=s2>&#34;인천&#34;</span><span class=p>,</span> <span class=mi>27</span><span class=p>),</span> <span class=p>(</span><span class=s2>&#34;서울&#34;</span><span class=p>,</span> <span class=s2>&#34;대전&#34;</span><span class=p>,</span> <span class=mi>140</span><span class=p>),</span> <span class=p>(</span><span class=s2>&#34;인천&#34;</span><span class=p>,</span> <span class=s2>&#34;대전&#34;</span><span class=p>,</span> <span class=mi>170</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s2>&#34;대전&#34;</span><span class=p>,</span> <span class=s2>&#34;대구&#34;</span><span class=p>,</span> <span class=mi>88</span><span class=p>),</span> <span class=p>(</span><span class=s2>&#34;대전&#34;</span><span class=p>,</span> <span class=s2>&#34;광주&#34;</span><span class=p>,</span> <span class=mi>146</span><span class=p>),</span> <span class=p>(</span><span class=s2>&#34;대구&#34;</span><span class=p>,</span> <span class=s2>&#34;울산&#34;</span><span class=p>,</span> <span class=mi>80</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s2>&#34;대구&#34;</span><span class=p>,</span> <span class=s2>&#34;부산&#34;</span><span class=p>,</span> <span class=mi>88</span><span class=p>),</span> <span class=p>(</span><span class=s2>&#34;울산&#34;</span><span class=p>,</span> <span class=s2>&#34;부산&#34;</span><span class=p>,</span> <span class=mi>34</span><span class=p>),</span> <span class=p>(</span><span class=s2>&#34;광주&#34;</span><span class=p>,</span> <span class=s2>&#34;부산&#34;</span><span class=p>,</span> <span class=mi>268</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>network</span><span class=p>,</span> <span class=n>total_cost</span> <span class=o>=</span> <span class=n>design_network</span><span class=p>(</span><span class=n>cities</span><span class=p>,</span> <span class=n>costs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;최소 비용 네트워크 설계 (총 비용: </span><span class=si>{</span><span class=n>total_cost</span><span class=si>}</span><span class=s2>):&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>city1</span><span class=p>,</span> <span class=n>city2</span><span class=p>,</span> <span class=n>cost</span> <span class=ow>in</span> <span class=n>network</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>city1</span><span class=si>}</span><span class=s2> -- </span><span class=si>{</span><span class=n>city2</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>cost</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=클러스터링-알고리즘-구현>클러스터링 알고리즘 구현<a hidden class=anchor aria-hidden=true href=#클러스터링-알고리즘-구현>#</a></h4><p>MST를 기반으로 한 클러스터링 알고리즘 구현:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span><span class=lnt id=hl-4-36><a class=lnlinks href=#hl-4-36>36</a>
</span><span class=lnt id=hl-4-37><a class=lnlinks href=#hl-4-37>37</a>
</span><span class=lnt id=hl-4-38><a class=lnlinks href=#hl-4-38>38</a>
</span><span class=lnt id=hl-4-39><a class=lnlinks href=#hl-4-39>39</a>
</span><span class=lnt id=hl-4-40><a class=lnlinks href=#hl-4-40>40</a>
</span><span class=lnt id=hl-4-41><a class=lnlinks href=#hl-4-41>41</a>
</span><span class=lnt id=hl-4-42><a class=lnlinks href=#hl-4-42>42</a>
</span><span class=lnt id=hl-4-43><a class=lnlinks href=#hl-4-43>43</a>
</span><span class=lnt id=hl-4-44><a class=lnlinks href=#hl-4-44>44</a>
</span><span class=lnt id=hl-4-45><a class=lnlinks href=#hl-4-45>45</a>
</span><span class=lnt id=hl-4-46><a class=lnlinks href=#hl-4-46>46</a>
</span><span class=lnt id=hl-4-47><a class=lnlinks href=#hl-4-47>47</a>
</span><span class=lnt id=hl-4-48><a class=lnlinks href=#hl-4-48>48</a>
</span><span class=lnt id=hl-4-49><a class=lnlinks href=#hl-4-49>49</a>
</span><span class=lnt id=hl-4-50><a class=lnlinks href=#hl-4-50>50</a>
</span><span class=lnt id=hl-4-51><a class=lnlinks href=#hl-4-51>51</a>
</span><span class=lnt id=hl-4-52><a class=lnlinks href=#hl-4-52>52</a>
</span><span class=lnt id=hl-4-53><a class=lnlinks href=#hl-4-53>53</a>
</span><span class=lnt id=hl-4-54><a class=lnlinks href=#hl-4-54>54</a>
</span><span class=lnt id=hl-4-55><a class=lnlinks href=#hl-4-55>55</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>mst_clustering</span><span class=p>(</span><span class=n>points</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    MST 기반 데이터 포인트 클러스터링
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      points: [(x1, y1), (x2, y2), …] 형태의 2D 데이터 포인트
</span></span></span><span class=line><span class=cl><span class=s2>      k: 클러스터 수
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      k개의 클러스터 (각 클러스터는 포인트 인덱스 리스트)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 포인트 쌍 간의 거리 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>distance</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>((</span><span class=n>p1</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>-</span> <span class=n>p2</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>**</span><span class=mi>2</span> <span class=o>+</span> <span class=p>(</span><span class=n>p1</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>p2</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>**</span><span class=mi>2</span><span class=p>)</span><span class=o>**</span><span class=mf>0.5</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>distance</span><span class=p>(</span><span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>points</span><span class=p>[</span><span class=n>j</span><span class=p>])))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># MST 간선을 가중치 내림차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 상위 k-1개 간선 제거 (k개의 컴포넌트 생성)</span>
</span></span><span class=line><span class=cl>    <span class=n>edges_to_remove</span> <span class=o>=</span> <span class=n>mst_edges</span><span class=p>[:</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 간선으로 그래프 구성</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span><span class=p>:</span> <span class=p>[]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>:]:</span>
</span></span><span class=line><span class=cl>        <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 연결 컴포넌트(클러스터) 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>clusters</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>cluster</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>cluster</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dfs</span><span class=p>(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>cluster</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>cluster</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>cluster</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>clusters</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>cluster</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>clusters</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=네트워크-라우팅-최적화>네트워크 라우팅 최적화<a hidden class=anchor aria-hidden=true href=#네트워크-라우팅-최적화>#</a></h4><p>MST를 활용한 네트워크 라우팅 프로토콜:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span><span class=lnt id=hl-5-27><a class=lnlinks href=#hl-5-27>27</a>
</span><span class=lnt id=hl-5-28><a class=lnlinks href=#hl-5-28>28</a>
</span><span class=lnt id=hl-5-29><a class=lnlinks href=#hl-5-29>29</a>
</span><span class=lnt id=hl-5-30><a class=lnlinks href=#hl-5-30>30</a>
</span><span class=lnt id=hl-5-31><a class=lnlinks href=#hl-5-31>31</a>
</span><span class=lnt id=hl-5-32><a class=lnlinks href=#hl-5-32>32</a>
</span><span class=lnt id=hl-5-33><a class=lnlinks href=#hl-5-33>33</a>
</span><span class=lnt id=hl-5-34><a class=lnlinks href=#hl-5-34>34</a>
</span><span class=lnt id=hl-5-35><a class=lnlinks href=#hl-5-35>35</a>
</span><span class=lnt id=hl-5-36><a class=lnlinks href=#hl-5-36>36</a>
</span><span class=lnt id=hl-5-37><a class=lnlinks href=#hl-5-37>37</a>
</span><span class=lnt id=hl-5-38><a class=lnlinks href=#hl-5-38>38</a>
</span><span class=lnt id=hl-5-39><a class=lnlinks href=#hl-5-39>39</a>
</span><span class=lnt id=hl-5-40><a class=lnlinks href=#hl-5-40>40</a>
</span><span class=lnt id=hl-5-41><a class=lnlinks href=#hl-5-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>optimize_routing</span><span class=p>(</span><span class=n>network</span><span class=p>,</span> <span class=n>source</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    MST 기반 네트워크 라우팅 최적화
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      network: {노드: [(이웃 노드, 대역폭, 지연 시간), …], …} 형태의 네트워크
</span></span></span><span class=line><span class=cl><span class=s2>      source: 출발 노드
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      {노드: (다음 홉, 총 지연 시간), …} 형태의 라우팅 테이블
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 그래프 변환 (지연 시간을 가중치로 사용)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=p>[(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>delay</span><span class=p>)</span> <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>delay</span> <span class=ow>in</span> <span class=n>connections</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>             <span class=k>for</span> <span class=n>node</span><span class=p>,</span> <span class=n>connections</span> <span class=ow>in</span> <span class=n>network</span><span class=o>.</span><span class=n>items</span><span class=p>()}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 프림 알고리즘으로 MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=n>prim</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>source</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># MST에서 라우팅 트리 구성</span>
</span></span><span class=line><span class=cl>    <span class=n>routing_tree</span> <span class=o>=</span> <span class=p>{</span><span class=n>node</span><span class=p>:</span> <span class=p>[]</span> <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>network</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>routing_tree</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>routing_tree</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 각 노드에 대한 경로 및 지연 시간 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>routing_table</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=n>delay</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span> <span class=o>!=</span> <span class=n>source</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>routing_table</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>parent</span><span class=p>,</span> <span class=n>delay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>routing_tree</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>child</span> <span class=o>!=</span> <span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 다음 홉으로 가는 지연 시간 찾기</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>next_delay</span> <span class=ow>in</span> <span class=n>network</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>neighbor</span> <span class=o>==</span> <span class=n>child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>dfs</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>delay</span> <span class=o>+</span> <span class=n>next_delay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>routing_table</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=mst-알고리즘의-변형-및-확장>MST 알고리즘의 변형 및 확장<a hidden class=anchor aria-hidden=true href=#mst-알고리즘의-변형-및-확장>#</a></h3><h4 id=반올림이-있는-mst>반올림이 있는 MST<a hidden class=anchor aria-hidden=true href=#반올림이-있는-mst>#</a></h4><p>실제 문제에서는 간선 가중치가 정확하지 않을 수 있다.<br>이런 경우 반올림이 있는 MST를 구하는 알고리즘:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>mst_with_rounding</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>precision</span><span class=o>=</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    가중치 반올림을 고려한 MST 계산
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      graph: [(u, v, weight), …] 형태의 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>      precision: 반올림할 소수 자릿수
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      MST와 오차 범위
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 가중치 반올림</span>
</span></span><span class=line><span class=cl>    <span class=n>rounded_graph</span> <span class=o>=</span> <span class=p>[(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=nb>round</span><span class=p>(</span><span class=n>weight</span><span class=p>,</span> <span class=n>precision</span><span class=p>))</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 반올림된 가중치로 MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst</span> <span class=o>=</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>rounded_graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 원래 가중치로 총합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>original_weights</span> <span class=o>=</span> <span class=p>{(</span><span class=nb>min</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)):</span> <span class=n>weight</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>total_original</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>original_weights</span><span class=p>[(</span><span class=nb>min</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))]</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>mst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 반올림된 가중치로 총합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>total_rounded</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>weight</span> <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>mst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 최대 오차 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>max_error</span> <span class=o>=</span> <span class=nb>abs</span><span class=p>(</span><span class=n>total_original</span> <span class=o>-</span> <span class=n>total_rounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mst</span><span class=p>,</span> <span class=n>max_error</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=다중-제약-mst>다중 제약 MST<a hidden class=anchor aria-hidden=true href=#다중-제약-mst>#</a></h4><p>여러 제약 조건이 있는 MST 문제:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span><span class=lnt id=hl-7-36><a class=lnlinks href=#hl-7-36>36</a>
</span><span class=lnt id=hl-7-37><a class=lnlinks href=#hl-7-37>37</a>
</span><span class=lnt id=hl-7-38><a class=lnlinks href=#hl-7-38>38</a>
</span><span class=lnt id=hl-7-39><a class=lnlinks href=#hl-7-39>39</a>
</span><span class=lnt id=hl-7-40><a class=lnlinks href=#hl-7-40>40</a>
</span><span class=lnt id=hl-7-41><a class=lnlinks href=#hl-7-41>41</a>
</span><span class=lnt id=hl-7-42><a class=lnlinks href=#hl-7-42>42</a>
</span><span class=lnt id=hl-7-43><a class=lnlinks href=#hl-7-43>43</a>
</span><span class=lnt id=hl-7-44><a class=lnlinks href=#hl-7-44>44</a>
</span><span class=lnt id=hl-7-45><a class=lnlinks href=#hl-7-45>45</a>
</span><span class=lnt id=hl-7-46><a class=lnlinks href=#hl-7-46>46</a>
</span><span class=lnt id=hl-7-47><a class=lnlinks href=#hl-7-47>47</a>
</span><span class=lnt id=hl-7-48><a class=lnlinks href=#hl-7-48>48</a>
</span><span class=lnt id=hl-7-49><a class=lnlinks href=#hl-7-49>49</a>
</span><span class=lnt id=hl-7-50><a class=lnlinks href=#hl-7-50>50</a>
</span><span class=lnt id=hl-7-51><a class=lnlinks href=#hl-7-51>51</a>
</span><span class=lnt id=hl-7-52><a class=lnlinks href=#hl-7-52>52</a>
</span><span class=lnt id=hl-7-53><a class=lnlinks href=#hl-7-53>53</a>
</span><span class=lnt id=hl-7-54><a class=lnlinks href=#hl-7-54>54</a>
</span><span class=lnt id=hl-7-55><a class=lnlinks href=#hl-7-55>55</a>
</span><span class=lnt id=hl-7-56><a class=lnlinks href=#hl-7-56>56</a>
</span><span class=lnt id=hl-7-57><a class=lnlinks href=#hl-7-57>57</a>
</span><span class=lnt id=hl-7-58><a class=lnlinks href=#hl-7-58>58</a>
</span><span class=lnt id=hl-7-59><a class=lnlinks href=#hl-7-59>59</a>
</span><span class=lnt id=hl-7-60><a class=lnlinks href=#hl-7-60>60</a>
</span><span class=lnt id=hl-7-61><a class=lnlinks href=#hl-7-61>61</a>
</span><span class=lnt id=hl-7-62><a class=lnlinks href=#hl-7-62>62</a>
</span><span class=lnt id=hl-7-63><a class=lnlinks href=#hl-7-63>63</a>
</span><span class=lnt id=hl-7-64><a class=lnlinks href=#hl-7-64>64</a>
</span><span class=lnt id=hl-7-65><a class=lnlinks href=#hl-7-65>65</a>
</span><span class=lnt id=hl-7-66><a class=lnlinks href=#hl-7-66>66</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>constrained_mst</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>constraints</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    제약 조건이 있는 MST 계산
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      graph: [(u, v, weight), …] 형태의 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>      constraints: [(u, v, True/False), …] 형태의 제약 조건
</span></span></span><span class=line><span class=cl><span class=s2>                   True면 반드시 포함, False면 반드시 제외
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      제약을 만족하는 MST 또는 불가능하면 None
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 그래프의 정점 수 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>vertices</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 반드시 포함해야 하는 간선</span>
</span></span><span class=line><span class=cl>    <span class=n>must_include</span> <span class=o>=</span> <span class=p>[(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>include</span> <span class=ow>in</span> <span class=n>constraints</span> <span class=k>if</span> <span class=n>include</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 반드시 제외해야 하는 간선</span>
</span></span><span class=line><span class=cl>    <span class=n>must_exclude</span> <span class=o>=</span> <span class=p>[(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>include</span> <span class=ow>in</span> <span class=n>constraints</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>include</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 제약 조건 검증</span>
</span></span><span class=line><span class=cl>    <span class=c1># 포함 간선들이 사이클을 형성하는지 확인</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=n>vertices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>must_include</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span> <span class=o>==</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>  <span class=c1># 사이클 발생: 불가능</span>
</span></span><span class=line><span class=cl>        <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 필수 포함 간선들을 결과에 미리 추가</span>
</span></span><span class=line><span class=cl>    <span class=n>result_mst</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=o>=</span> <span class=n>edge</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=ow>in</span> <span class=n>must_include</span> <span class=ow>or</span> <span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>u</span><span class=p>)</span> <span class=ow>in</span> <span class=n>must_include</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result_mst</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 필수 제외 간선과 이미 포함된 간선을 제외한 나머지 간선에 대해 MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=o>=</span> <span class=n>edge</span>
</span></span><span class=line><span class=cl>        <span class=n>u_min</span><span class=p>,</span> <span class=n>v_min</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>u_min</span><span class=p>,</span> <span class=n>v_min</span><span class=p>)</span> <span class=ow>not</span> <span class=ow>in</span> <span class=p>[(</span><span class=nb>min</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>))</span> <span class=k>for</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>must_include</span><span class=p>]</span> <span class=ow>and</span> \
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>must_exclude</span> <span class=ow>and</span> <span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>u</span><span class=p>)</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>must_exclude</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>remaining_edges</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 남은 간선으로 MST 계산 (이미 포함된 간선을 고려하여)</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=n>vertices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>result_mst</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 가중치 오름차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_edges</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># MST 완성</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>remaining_edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span> <span class=o>!=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>result_mst</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 모든 정점이 연결되었는지 확인</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>!=</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>  <span class=c1># 연결 불가능</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result_mst</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=근사-스타이너-트리>근사 스타이너 트리<a hidden class=anchor aria-hidden=true href=#근사-스타이너-트리>#</a></h4><p>스타이너 트리는 주어진 필수 정점을 모두 연결하는 최소 비용 트리이며, MST를 기반으로 근사할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span><span class=lnt id=hl-8-29><a class=lnlinks href=#hl-8-29>29</a>
</span><span class=lnt id=hl-8-30><a class=lnlinks href=#hl-8-30>30</a>
</span><span class=lnt id=hl-8-31><a class=lnlinks href=#hl-8-31>31</a>
</span><span class=lnt id=hl-8-32><a class=lnlinks href=#hl-8-32>32</a>
</span><span class=lnt id=hl-8-33><a class=lnlinks href=#hl-8-33>33</a>
</span><span class=lnt id=hl-8-34><a class=lnlinks href=#hl-8-34>34</a>
</span><span class=lnt id=hl-8-35><a class=lnlinks href=#hl-8-35>35</a>
</span><span class=lnt id=hl-8-36><a class=lnlinks href=#hl-8-36>36</a>
</span><span class=lnt id=hl-8-37><a class=lnlinks href=#hl-8-37>37</a>
</span><span class=lnt id=hl-8-38><a class=lnlinks href=#hl-8-38>38</a>
</span><span class=lnt id=hl-8-39><a class=lnlinks href=#hl-8-39>39</a>
</span><span class=lnt id=hl-8-40><a class=lnlinks href=#hl-8-40>40</a>
</span><span class=lnt id=hl-8-41><a class=lnlinks href=#hl-8-41>41</a>
</span><span class=lnt id=hl-8-42><a class=lnlinks href=#hl-8-42>42</a>
</span><span class=lnt id=hl-8-43><a class=lnlinks href=#hl-8-43>43</a>
</span><span class=lnt id=hl-8-44><a class=lnlinks href=#hl-8-44>44</a>
</span><span class=lnt id=hl-8-45><a class=lnlinks href=#hl-8-45>45</a>
</span><span class=lnt id=hl-8-46><a class=lnlinks href=#hl-8-46>46</a>
</span><span class=lnt id=hl-8-47><a class=lnlinks href=#hl-8-47>47</a>
</span><span class=lnt id=hl-8-48><a class=lnlinks href=#hl-8-48>48</a>
</span><span class=lnt id=hl-8-49><a class=lnlinks href=#hl-8-49>49</a>
</span><span class=lnt id=hl-8-50><a class=lnlinks href=#hl-8-50>50</a>
</span><span class=lnt id=hl-8-51><a class=lnlinks href=#hl-8-51>51</a>
</span><span class=lnt id=hl-8-52><a class=lnlinks href=#hl-8-52>52</a>
</span><span class=lnt id=hl-8-53><a class=lnlinks href=#hl-8-53>53</a>
</span><span class=lnt id=hl-8-54><a class=lnlinks href=#hl-8-54>54</a>
</span><span class=lnt id=hl-8-55><a class=lnlinks href=#hl-8-55>55</a>
</span><span class=lnt id=hl-8-56><a class=lnlinks href=#hl-8-56>56</a>
</span><span class=lnt id=hl-8-57><a class=lnlinks href=#hl-8-57>57</a>
</span><span class=lnt id=hl-8-58><a class=lnlinks href=#hl-8-58>58</a>
</span><span class=lnt id=hl-8-59><a class=lnlinks href=#hl-8-59>59</a>
</span><span class=lnt id=hl-8-60><a class=lnlinks href=#hl-8-60>60</a>
</span><span class=lnt id=hl-8-61><a class=lnlinks href=#hl-8-61>61</a>
</span><span class=lnt id=hl-8-62><a class=lnlinks href=#hl-8-62>62</a>
</span><span class=lnt id=hl-8-63><a class=lnlinks href=#hl-8-63>63</a>
</span><span class=lnt id=hl-8-64><a class=lnlinks href=#hl-8-64>64</a>
</span><span class=lnt id=hl-8-65><a class=lnlinks href=#hl-8-65>65</a>
</span><span class=lnt id=hl-8-66><a class=lnlinks href=#hl-8-66>66</a>
</span><span class=lnt id=hl-8-67><a class=lnlinks href=#hl-8-67>67</a>
</span><span class=lnt id=hl-8-68><a class=lnlinks href=#hl-8-68>68</a>
</span><span class=lnt id=hl-8-69><a class=lnlinks href=#hl-8-69>69</a>
</span><span class=lnt id=hl-8-70><a class=lnlinks href=#hl-8-70>70</a>
</span><span class=lnt id=hl-8-71><a class=lnlinks href=#hl-8-71>71</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>steiner_tree_approximation</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>required_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    스타이너 트리 근사 알고리즘
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      graph: {정점: [(이웃 정점, 가중치), …], …} 형태의 그래프
</span></span></span><span class=line><span class=cl><span class=s2>      required_vertices: 반드시 연결되어야 하는 정점 집합
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      스타이너 트리 (근사)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 필수 정점 간의 최단 경로 계산 (플로이드-워셜 알고리즘)</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dist</span> <span class=o>=</span> <span class=p>[[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=n>n</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=n>next_hop</span> <span class=o>=</span> <span class=p>[[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 초기화</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>dist</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>u</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>            <span class=n>next_hop</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 플로이드-워셜</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>dist</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                    <span class=n>next_hop</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>next_hop</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 필수 정점만으로 완전 그래프 구성</span>
</span></span><span class=line><span class=cl>    <span class=n>complete_graph</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>required_vertices</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>required_vertices</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>complete_graph</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>complete_graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 실제 경로로 확장</span>
</span></span><span class=line><span class=cl>    <span class=n>steiner_tree</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># u에서 v까지의 경로 추적</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>u</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current</span> <span class=o>!=</span> <span class=n>v</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>next_vertex</span> <span class=o>=</span> <span class=n>next_hop</span><span class=p>[</span><span class=n>current</span><span class=p>][</span><span class=n>v</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>current</span><span class=p>,</span> <span class=n>next_vertex</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>next_vertex</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 경로 상의 모든 간선 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>a</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>edge</span>
</span></span><span class=line><span class=cl>            <span class=c1># 그래프에서 가중치 찾기</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>neighbor</span> <span class=o>==</span> <span class=n>b</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>steiner_tree</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 중복 제거</span>
</span></span><span class=line><span class=cl>    <span class=n>unique_edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>seen</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>steiner_tree</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>edge</span> <span class=o>=</span> <span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>edge</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>seen</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>seen</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>unique_edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>unique_edges</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=병렬-mst-알고리즘>병렬 MST 알고리즘<a hidden class=anchor aria-hidden=true href=#병렬-mst-알고리즘>#</a></h4><p>대규모 그래프에서는 병렬 MST 알고리즘이 필요할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>  1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>  2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>  3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>  4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>  5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>  6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>  7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8>  8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9>  9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10> 10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11> 11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12> 12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13> 13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14> 14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15> 15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16> 16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17> 17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18> 18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19> 19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20> 20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21> 21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22> 22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23> 23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24> 24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25> 25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26> 26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27> 27</a>
</span><span class=lnt id=hl-9-28><a class=lnlinks href=#hl-9-28> 28</a>
</span><span class=lnt id=hl-9-29><a class=lnlinks href=#hl-9-29> 29</a>
</span><span class=lnt id=hl-9-30><a class=lnlinks href=#hl-9-30> 30</a>
</span><span class=lnt id=hl-9-31><a class=lnlinks href=#hl-9-31> 31</a>
</span><span class=lnt id=hl-9-32><a class=lnlinks href=#hl-9-32> 32</a>
</span><span class=lnt id=hl-9-33><a class=lnlinks href=#hl-9-33> 33</a>
</span><span class=lnt id=hl-9-34><a class=lnlinks href=#hl-9-34> 34</a>
</span><span class=lnt id=hl-9-35><a class=lnlinks href=#hl-9-35> 35</a>
</span><span class=lnt id=hl-9-36><a class=lnlinks href=#hl-9-36> 36</a>
</span><span class=lnt id=hl-9-37><a class=lnlinks href=#hl-9-37> 37</a>
</span><span class=lnt id=hl-9-38><a class=lnlinks href=#hl-9-38> 38</a>
</span><span class=lnt id=hl-9-39><a class=lnlinks href=#hl-9-39> 39</a>
</span><span class=lnt id=hl-9-40><a class=lnlinks href=#hl-9-40> 40</a>
</span><span class=lnt id=hl-9-41><a class=lnlinks href=#hl-9-41> 41</a>
</span><span class=lnt id=hl-9-42><a class=lnlinks href=#hl-9-42> 42</a>
</span><span class=lnt id=hl-9-43><a class=lnlinks href=#hl-9-43> 43</a>
</span><span class=lnt id=hl-9-44><a class=lnlinks href=#hl-9-44> 44</a>
</span><span class=lnt id=hl-9-45><a class=lnlinks href=#hl-9-45> 45</a>
</span><span class=lnt id=hl-9-46><a class=lnlinks href=#hl-9-46> 46</a>
</span><span class=lnt id=hl-9-47><a class=lnlinks href=#hl-9-47> 47</a>
</span><span class=lnt id=hl-9-48><a class=lnlinks href=#hl-9-48> 48</a>
</span><span class=lnt id=hl-9-49><a class=lnlinks href=#hl-9-49> 49</a>
</span><span class=lnt id=hl-9-50><a class=lnlinks href=#hl-9-50> 50</a>
</span><span class=lnt id=hl-9-51><a class=lnlinks href=#hl-9-51> 51</a>
</span><span class=lnt id=hl-9-52><a class=lnlinks href=#hl-9-52> 52</a>
</span><span class=lnt id=hl-9-53><a class=lnlinks href=#hl-9-53> 53</a>
</span><span class=lnt id=hl-9-54><a class=lnlinks href=#hl-9-54> 54</a>
</span><span class=lnt id=hl-9-55><a class=lnlinks href=#hl-9-55> 55</a>
</span><span class=lnt id=hl-9-56><a class=lnlinks href=#hl-9-56> 56</a>
</span><span class=lnt id=hl-9-57><a class=lnlinks href=#hl-9-57> 57</a>
</span><span class=lnt id=hl-9-58><a class=lnlinks href=#hl-9-58> 58</a>
</span><span class=lnt id=hl-9-59><a class=lnlinks href=#hl-9-59> 59</a>
</span><span class=lnt id=hl-9-60><a class=lnlinks href=#hl-9-60> 60</a>
</span><span class=lnt id=hl-9-61><a class=lnlinks href=#hl-9-61> 61</a>
</span><span class=lnt id=hl-9-62><a class=lnlinks href=#hl-9-62> 62</a>
</span><span class=lnt id=hl-9-63><a class=lnlinks href=#hl-9-63> 63</a>
</span><span class=lnt id=hl-9-64><a class=lnlinks href=#hl-9-64> 64</a>
</span><span class=lnt id=hl-9-65><a class=lnlinks href=#hl-9-65> 65</a>
</span><span class=lnt id=hl-9-66><a class=lnlinks href=#hl-9-66> 66</a>
</span><span class=lnt id=hl-9-67><a class=lnlinks href=#hl-9-67> 67</a>
</span><span class=lnt id=hl-9-68><a class=lnlinks href=#hl-9-68> 68</a>
</span><span class=lnt id=hl-9-69><a class=lnlinks href=#hl-9-69> 69</a>
</span><span class=lnt id=hl-9-70><a class=lnlinks href=#hl-9-70> 70</a>
</span><span class=lnt id=hl-9-71><a class=lnlinks href=#hl-9-71> 71</a>
</span><span class=lnt id=hl-9-72><a class=lnlinks href=#hl-9-72> 72</a>
</span><span class=lnt id=hl-9-73><a class=lnlinks href=#hl-9-73> 73</a>
</span><span class=lnt id=hl-9-74><a class=lnlinks href=#hl-9-74> 74</a>
</span><span class=lnt id=hl-9-75><a class=lnlinks href=#hl-9-75> 75</a>
</span><span class=lnt id=hl-9-76><a class=lnlinks href=#hl-9-76> 76</a>
</span><span class=lnt id=hl-9-77><a class=lnlinks href=#hl-9-77> 77</a>
</span><span class=lnt id=hl-9-78><a class=lnlinks href=#hl-9-78> 78</a>
</span><span class=lnt id=hl-9-79><a class=lnlinks href=#hl-9-79> 79</a>
</span><span class=lnt id=hl-9-80><a class=lnlinks href=#hl-9-80> 80</a>
</span><span class=lnt id=hl-9-81><a class=lnlinks href=#hl-9-81> 81</a>
</span><span class=lnt id=hl-9-82><a class=lnlinks href=#hl-9-82> 82</a>
</span><span class=lnt id=hl-9-83><a class=lnlinks href=#hl-9-83> 83</a>
</span><span class=lnt id=hl-9-84><a class=lnlinks href=#hl-9-84> 84</a>
</span><span class=lnt id=hl-9-85><a class=lnlinks href=#hl-9-85> 85</a>
</span><span class=lnt id=hl-9-86><a class=lnlinks href=#hl-9-86> 86</a>
</span><span class=lnt id=hl-9-87><a class=lnlinks href=#hl-9-87> 87</a>
</span><span class=lnt id=hl-9-88><a class=lnlinks href=#hl-9-88> 88</a>
</span><span class=lnt id=hl-9-89><a class=lnlinks href=#hl-9-89> 89</a>
</span><span class=lnt id=hl-9-90><a class=lnlinks href=#hl-9-90> 90</a>
</span><span class=lnt id=hl-9-91><a class=lnlinks href=#hl-9-91> 91</a>
</span><span class=lnt id=hl-9-92><a class=lnlinks href=#hl-9-92> 92</a>
</span><span class=lnt id=hl-9-93><a class=lnlinks href=#hl-9-93> 93</a>
</span><span class=lnt id=hl-9-94><a class=lnlinks href=#hl-9-94> 94</a>
</span><span class=lnt id=hl-9-95><a class=lnlinks href=#hl-9-95> 95</a>
</span><span class=lnt id=hl-9-96><a class=lnlinks href=#hl-9-96> 96</a>
</span><span class=lnt id=hl-9-97><a class=lnlinks href=#hl-9-97> 97</a>
</span><span class=lnt id=hl-9-98><a class=lnlinks href=#hl-9-98> 98</a>
</span><span class=lnt id=hl-9-99><a class=lnlinks href=#hl-9-99> 99</a>
</span><span class=lnt id=hl-9-100><a class=lnlinks href=#hl-9-100>100</a>
</span><span class=lnt id=hl-9-101><a class=lnlinks href=#hl-9-101>101</a>
</span><span class=lnt id=hl-9-102><a class=lnlinks href=#hl-9-102>102</a>
</span><span class=lnt id=hl-9-103><a class=lnlinks href=#hl-9-103>103</a>
</span><span class=lnt id=hl-9-104><a class=lnlinks href=#hl-9-104>104</a>
</span><span class=lnt id=hl-9-105><a class=lnlinks href=#hl-9-105>105</a>
</span><span class=lnt id=hl-9-106><a class=lnlinks href=#hl-9-106>106</a>
</span><span class=lnt id=hl-9-107><a class=lnlinks href=#hl-9-107>107</a>
</span><span class=lnt id=hl-9-108><a class=lnlinks href=#hl-9-108>108</a>
</span><span class=lnt id=hl-9-109><a class=lnlinks href=#hl-9-109>109</a>
</span><span class=lnt id=hl-9-110><a class=lnlinks href=#hl-9-110>110</a>
</span><span class=lnt id=hl-9-111><a class=lnlinks href=#hl-9-111>111</a>
</span><span class=lnt id=hl-9-112><a class=lnlinks href=#hl-9-112>112</a>
</span><span class=lnt id=hl-9-113><a class=lnlinks href=#hl-9-113>113</a>
</span><span class=lnt id=hl-9-114><a class=lnlinks href=#hl-9-114>114</a>
</span><span class=lnt id=hl-9-115><a class=lnlinks href=#hl-9-115>115</a>
</span><span class=lnt id=hl-9-116><a class=lnlinks href=#hl-9-116>116</a>
</span><span class=lnt id=hl-9-117><a class=lnlinks href=#hl-9-117>117</a>
</span><span class=lnt id=hl-9-118><a class=lnlinks href=#hl-9-118>118</a>
</span><span class=lnt id=hl-9-119><a class=lnlinks href=#hl-9-119>119</a>
</span><span class=lnt id=hl-9-120><a class=lnlinks href=#hl-9-120>120</a>
</span><span class=lnt id=hl-9-121><a class=lnlinks href=#hl-9-121>121</a>
</span><span class=lnt id=hl-9-122><a class=lnlinks href=#hl-9-122>122</a>
</span><span class=lnt id=hl-9-123><a class=lnlinks href=#hl-9-123>123</a>
</span><span class=lnt id=hl-9-124><a class=lnlinks href=#hl-9-124>124</a>
</span><span class=lnt id=hl-9-125><a class=lnlinks href=#hl-9-125>125</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>parallel_mst</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>num_threads</span><span class=o>=</span><span class=mi>4</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    병렬 MST 계산 (Boruvka 알고리즘 기반)
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      graph: [(u, v, weight), …] 형태의 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>      num_threads: 사용할 스레드 수
</span></span></span><span class=line><span class=cl><span class=s2>    
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      MST 간선 리스트
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl>    <span class=kn>from</span> <span class=nn>queue</span> <span class=kn>import</span> <span class=n>Queue</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정점 수 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>vertices</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 정점 별 인접 간선 구성</span>
</span></span><span class=line><span class=cl>    <span class=n>adjacency</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>vertices</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>adjacency</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>v</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>adjacency</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 컴포넌트 관리를 위한 Union-Find</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=n>vertices</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 결과 MST</span>
</span></span><span class=line><span class=cl>    <span class=n>result_mst</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>result_lock</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 종료 플래그</span>
</span></span><span class=line><span class=cl>    <span class=n>done</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>worker_thread</span><span class=p>(</span><span class=n>thread_id</span><span class=p>,</span> <span class=n>work_queue</span><span class=p>,</span> <span class=n>result</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>done</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=ow>not</span> <span class=n>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 작업 대기</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>task_range</span> <span class=o>=</span> <span class=n>work_queue</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>block</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>except</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 작업이 없으면 대기</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>done</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>start</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=n>task_range</span>
</span></span><span class=line><span class=cl>            <span class=n>local_edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 각 컴포넌트에서 가장 가중치가 작은 간선 찾기</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>component</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>component</span> <span class=o>&gt;=</span> <span class=n>vertices</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=n>root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>component</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>root</span> <span class=o>!=</span> <span class=n>component</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>  <span class=c1># 다른 컴포넌트의 대표가 처리</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 이 컴포넌트에 속한 모든 정점 찾기</span>
</span></span><span class=line><span class=cl>                <span class=n>component_vertices</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=n>component_vertices</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 컴포넌트 외부로 연결되는 가장 가중치가 작은 간선 찾기</span>
</span></span><span class=line><span class=cl>                <span class=n>min_edge</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>                <span class=n>min_weight</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>component_vertices</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>adjacency</span><span class=p>[</span><span class=n>v</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                        <span class=n>neighbor_root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=n>neighbor_root</span> <span class=o>!=</span> <span class=n>root</span> <span class=ow>and</span> <span class=n>weight</span> <span class=o>&lt;</span> <span class=n>min_weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                            <span class=n>min_weight</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>                            <span class=n>min_edge</span> <span class=o>=</span> <span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>,</span> <span class=n>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>min_edge</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>local_edges</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>min_edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 찾은 간선 결과에 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>with</span> <span class=n>result_lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>local_edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span> <span class=o>!=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                        <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>work_queue</span><span class=o>.</span><span class=n>task_done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 작업 큐</span>
</span></span><span class=line><span class=cl>    <span class=n>work_queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 스레드 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>threads</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_threads</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>worker_thread</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>work_queue</span><span class=p>,</span> <span class=n>result_mst</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=n>daemon</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>threads</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>thread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># Boruvka 알고리즘 반복</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 작업 큐에 컴포넌트 범위 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>chunk_size</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>vertices</span> <span class=o>//</span> <span class=n>num_threads</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>vertices</span><span class=p>,</span> <span class=n>chunk_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>work_queue</span><span class=o>.</span><span class=n>put</span><span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=nb>min</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>chunk_size</span><span class=p>,</span> <span class=n>vertices</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 작업 완료 대기</span>
</span></span><span class=line><span class=cl>        <span class=n>work_queue</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 모든 정점이 연결되었는지 확인</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>all_connected</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>!=</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>all_connected</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>all_connected</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 스레드 종료</span>
</span></span><span class=line><span class=cl>    <span class=n>done</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>thread</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result_mst</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실세계-응용-및-사례-연구>실세계 응용 및 사례 연구<a hidden class=anchor aria-hidden=true href=#실세계-응용-및-사례-연구>#</a></h3><ol><li><p>컴퓨터 네트워크 설계<br>MST는 최소 비용으로 모든 네트워크 노드를 연결하는 물리적 토폴로지를 설계하는 데 사용된다.</p><ul><li><strong>사례 연구</strong>: 대학 캠퍼스 네트워크 설계<br>이 대학은 캠퍼스 내 15개 건물을 연결하는 통신 네트워크를 설계해야 한다. 각 건물 사이에 케이블을 설치하는 비용은 거리에 비례한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span><span class=lnt id=hl-10-32><a class=lnlinks href=#hl-10-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>design_campus_network</span><span class=p>(</span><span class=n>buildings</span><span class=p>,</span> <span class=n>distances</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    캠퍼스 네트워크 설계
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      buildings: 건물 목록
</span></span></span><span class=line><span class=cl><span class=s2>      distances: [(건물1, 건물2, 거리), …] 형태의 거리 정보
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      최적 네트워크 설계
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 건물 인덱스 매핑</span>
</span></span><span class=line><span class=cl>    <span class=n>building_to_idx</span> <span class=o>=</span> <span class=p>{</span><span class=n>building</span><span class=p>:</span> <span class=n>idx</span> <span class=k>for</span> <span class=n>idx</span><span class=p>,</span> <span class=n>building</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>buildings</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 간선 리스트 변환</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[(</span><span class=n>building_to_idx</span><span class=p>[</span><span class=n>b1</span><span class=p>],</span> <span class=n>building_to_idx</span><span class=p>[</span><span class=n>b2</span><span class=p>],</span> <span class=n>dist</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>             <span class=k>for</span> <span class=n>b1</span><span class=p>,</span> <span class=n>b2</span><span class=p>,</span> <span class=n>dist</span> <span class=ow>in</span> <span class=n>distances</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 케이블 설치 계획 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>installation_plan</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>total_length</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>dist</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>building1</span> <span class=o>=</span> <span class=n>buildings</span><span class=p>[</span><span class=n>u</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>building2</span> <span class=o>=</span> <span class=n>buildings</span><span class=p>[</span><span class=n>v</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>installation_plan</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>building1</span><span class=p>,</span> <span class=n>building2</span><span class=p>,</span> <span class=n>dist</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>total_length</span> <span class=o>+=</span> <span class=n>dist</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>installation_plan</span><span class=p>,</span> <span class=n>total_length</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>이미지 분할<br>MST 기반 알고리즘은 이미지 처리에서 중요한 역할을 한다.<br>특히, MST의 사이클 속성을 활용한 이미지 분할 알고리즘은 객체 인식에 효과적이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20>20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21>21</a>
</span><span class=lnt id=hl-11-22><a class=lnlinks href=#hl-11-22>22</a>
</span><span class=lnt id=hl-11-23><a class=lnlinks href=#hl-11-23>23</a>
</span><span class=lnt id=hl-11-24><a class=lnlinks href=#hl-11-24>24</a>
</span><span class=lnt id=hl-11-25><a class=lnlinks href=#hl-11-25>25</a>
</span><span class=lnt id=hl-11-26><a class=lnlinks href=#hl-11-26>26</a>
</span><span class=lnt id=hl-11-27><a class=lnlinks href=#hl-11-27>27</a>
</span><span class=lnt id=hl-11-28><a class=lnlinks href=#hl-11-28>28</a>
</span><span class=lnt id=hl-11-29><a class=lnlinks href=#hl-11-29>29</a>
</span><span class=lnt id=hl-11-30><a class=lnlinks href=#hl-11-30>30</a>
</span><span class=lnt id=hl-11-31><a class=lnlinks href=#hl-11-31>31</a>
</span><span class=lnt id=hl-11-32><a class=lnlinks href=#hl-11-32>32</a>
</span><span class=lnt id=hl-11-33><a class=lnlinks href=#hl-11-33>33</a>
</span><span class=lnt id=hl-11-34><a class=lnlinks href=#hl-11-34>34</a>
</span><span class=lnt id=hl-11-35><a class=lnlinks href=#hl-11-35>35</a>
</span><span class=lnt id=hl-11-36><a class=lnlinks href=#hl-11-36>36</a>
</span><span class=lnt id=hl-11-37><a class=lnlinks href=#hl-11-37>37</a>
</span><span class=lnt id=hl-11-38><a class=lnlinks href=#hl-11-38>38</a>
</span><span class=lnt id=hl-11-39><a class=lnlinks href=#hl-11-39>39</a>
</span><span class=lnt id=hl-11-40><a class=lnlinks href=#hl-11-40>40</a>
</span><span class=lnt id=hl-11-41><a class=lnlinks href=#hl-11-41>41</a>
</span><span class=lnt id=hl-11-42><a class=lnlinks href=#hl-11-42>42</a>
</span><span class=lnt id=hl-11-43><a class=lnlinks href=#hl-11-43>43</a>
</span><span class=lnt id=hl-11-44><a class=lnlinks href=#hl-11-44>44</a>
</span><span class=lnt id=hl-11-45><a class=lnlinks href=#hl-11-45>45</a>
</span><span class=lnt id=hl-11-46><a class=lnlinks href=#hl-11-46>46</a>
</span><span class=lnt id=hl-11-47><a class=lnlinks href=#hl-11-47>47</a>
</span><span class=lnt id=hl-11-48><a class=lnlinks href=#hl-11-48>48</a>
</span><span class=lnt id=hl-11-49><a class=lnlinks href=#hl-11-49>49</a>
</span><span class=lnt id=hl-11-50><a class=lnlinks href=#hl-11-50>50</a>
</span><span class=lnt id=hl-11-51><a class=lnlinks href=#hl-11-51>51</a>
</span><span class=lnt id=hl-11-52><a class=lnlinks href=#hl-11-52>52</a>
</span><span class=lnt id=hl-11-53><a class=lnlinks href=#hl-11-53>53</a>
</span><span class=lnt id=hl-11-54><a class=lnlinks href=#hl-11-54>54</a>
</span><span class=lnt id=hl-11-55><a class=lnlinks href=#hl-11-55>55</a>
</span><span class=lnt id=hl-11-56><a class=lnlinks href=#hl-11-56>56</a>
</span><span class=lnt id=hl-11-57><a class=lnlinks href=#hl-11-57>57</a>
</span><span class=lnt id=hl-11-58><a class=lnlinks href=#hl-11-58>58</a>
</span><span class=lnt id=hl-11-59><a class=lnlinks href=#hl-11-59>59</a>
</span><span class=lnt id=hl-11-60><a class=lnlinks href=#hl-11-60>60</a>
</span><span class=lnt id=hl-11-61><a class=lnlinks href=#hl-11-61>61</a>
</span><span class=lnt id=hl-11-62><a class=lnlinks href=#hl-11-62>62</a>
</span><span class=lnt id=hl-11-63><a class=lnlinks href=#hl-11-63>63</a>
</span><span class=lnt id=hl-11-64><a class=lnlinks href=#hl-11-64>64</a>
</span><span class=lnt id=hl-11-65><a class=lnlinks href=#hl-11-65>65</a>
</span><span class=lnt id=hl-11-66><a class=lnlinks href=#hl-11-66>66</a>
</span><span class=lnt id=hl-11-67><a class=lnlinks href=#hl-11-67>67</a>
</span><span class=lnt id=hl-11-68><a class=lnlinks href=#hl-11-68>68</a>
</span><span class=lnt id=hl-11-69><a class=lnlinks href=#hl-11-69>69</a>
</span><span class=lnt id=hl-11-70><a class=lnlinks href=#hl-11-70>70</a>
</span><span class=lnt id=hl-11-71><a class=lnlinks href=#hl-11-71>71</a>
</span><span class=lnt id=hl-11-72><a class=lnlinks href=#hl-11-72>72</a>
</span><span class=lnt id=hl-11-73><a class=lnlinks href=#hl-11-73>73</a>
</span><span class=lnt id=hl-11-74><a class=lnlinks href=#hl-11-74>74</a>
</span><span class=lnt id=hl-11-75><a class=lnlinks href=#hl-11-75>75</a>
</span><span class=lnt id=hl-11-76><a class=lnlinks href=#hl-11-76>76</a>
</span><span class=lnt id=hl-11-77><a class=lnlinks href=#hl-11-77>77</a>
</span><span class=lnt id=hl-11-78><a class=lnlinks href=#hl-11-78>78</a>
</span><span class=lnt id=hl-11-79><a class=lnlinks href=#hl-11-79>79</a>
</span><span class=lnt id=hl-11-80><a class=lnlinks href=#hl-11-80>80</a>
</span><span class=lnt id=hl-11-81><a class=lnlinks href=#hl-11-81>81</a>
</span><span class=lnt id=hl-11-82><a class=lnlinks href=#hl-11-82>82</a>
</span><span class=lnt id=hl-11-83><a class=lnlinks href=#hl-11-83>83</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>segment_image</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    MST 기반 이미지 분할
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      image: 이미지 픽셀 배열
</span></span></span><span class=line><span class=cl><span class=s2>      k: 분할 강도 매개변수
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      분할된 이미지
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>height</span><span class=p>,</span> <span class=n>width</span> <span class=o>=</span> <span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 픽셀 간 차이 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>pixel_diff</span><span class=p>(</span><span class=n>img</span><span class=p>,</span> <span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>,</span> <span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>img</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>:</span>  <span class=c1># 컬러 이미지</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=nb>abs</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>img</span><span class=p>[</span><span class=n>y1</span><span class=p>,</span> <span class=n>x1</span><span class=p>,</span> <span class=n>i</span><span class=p>])</span> <span class=o>-</span> <span class=nb>int</span><span class=p>(</span><span class=n>img</span><span class=p>[</span><span class=n>y2</span><span class=p>,</span> <span class=n>x2</span><span class=p>,</span> <span class=n>i</span><span class=p>]))</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>  <span class=c1># 그레이스케일 이미지</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>abs</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>img</span><span class=p>[</span><span class=n>y1</span><span class=p>,</span> <span class=n>x1</span><span class=p>])</span> <span class=o>-</span> <span class=nb>int</span><span class=p>(</span><span class=n>img</span><span class=p>[</span><span class=n>y2</span><span class=p>,</span> <span class=n>x2</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 그래프 구성 (각 픽셀을 정점으로, 인접 픽셀 간 차이를 간선 가중치로)</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>y</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>height</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>width</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>pixel_idx</span> <span class=o>=</span> <span class=n>y</span> <span class=o>*</span> <span class=n>width</span> <span class=o>+</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 오른쪽 픽셀과의 간선</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>diff</span> <span class=o>=</span> <span class=n>pixel_diff</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>pixel_idx</span><span class=p>,</span> <span class=n>pixel_idx</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>diff</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 아래쪽 픽셀과의 간선</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>y</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>diff</span> <span class=o>=</span> <span class=n>pixel_diff</span><span class=p>(</span><span class=n>image</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>pixel_idx</span><span class=p>,</span> <span class=n>pixel_idx</span> <span class=o>+</span> <span class=n>width</span><span class=p>,</span> <span class=n>diff</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 간선을 가중치 오름차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 각 컴포넌트(영역)의 크기와 내부 최대 가중치 추적</span>
</span></span><span class=line><span class=cl>    <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>(</span><span class=n>width</span> <span class=o>*</span> <span class=n>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>component_size</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>width</span> <span class=o>*</span> <span class=n>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>internal_diff</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>width</span> <span class=o>*</span> <span class=n>height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 간선을 순회하며 컴포넌트 병합</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>u_root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>v_root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>u_root</span> <span class=o>!=</span> <span class=n>v_root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 병합 조건: 간선 가중치가 각 컴포넌트의 내부 최대 가중치 + k/컴포넌트 크기보다 작을 때</span>
</span></span><span class=line><span class=cl>            <span class=n>threshold1</span> <span class=o>=</span> <span class=n>internal_diff</span><span class=p>[</span><span class=n>u_root</span><span class=p>]</span> <span class=o>+</span> <span class=n>k</span> <span class=o>/</span> <span class=n>component_size</span><span class=p>[</span><span class=n>u_root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>threshold2</span> <span class=o>=</span> <span class=n>internal_diff</span><span class=p>[</span><span class=n>v_root</span><span class=p>]</span> <span class=o>+</span> <span class=n>k</span> <span class=o>/</span> <span class=n>component_size</span><span class=p>[</span><span class=n>v_root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weight</span> <span class=o>&lt;=</span> <span class=nb>min</span><span class=p>(</span><span class=n>threshold1</span><span class=p>,</span> <span class=n>threshold2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>u_root</span><span class=p>,</span> <span class=n>v_root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 병합 후 루트 찾기</span>
</span></span><span class=line><span class=cl>                <span class=n>new_root</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 컴포넌트 정보 업데이트</span>
</span></span><span class=line><span class=cl>                <span class=n>component_size</span><span class=p>[</span><span class=n>new_root</span><span class=p>]</span> <span class=o>=</span> <span class=n>component_size</span><span class=p>[</span><span class=n>u_root</span><span class=p>]</span> <span class=o>+</span> <span class=n>component_size</span><span class=p>[</span><span class=n>v_root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=n>internal_diff</span><span class=p>[</span><span class=n>new_root</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>internal_diff</span><span class=p>[</span><span class=n>u_root</span><span class=p>],</span> <span class=n>internal_diff</span><span class=p>[</span><span class=n>v_root</span><span class=p>],</span> <span class=n>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 결과 이미지 생성</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros_like</span><span class=p>(</span><span class=n>image</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 각 컴포넌트에 색상 할당</span>
</span></span><span class=line><span class=cl>    <span class=n>component_colors</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>y</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>height</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>width</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>pixel_idx</span> <span class=o>=</span> <span class=n>y</span> <span class=o>*</span> <span class=n>width</span> <span class=o>+</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>            <span class=n>component</span> <span class=o>=</span> <span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>pixel_idx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>component</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>component_colors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>image</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span> <span class=o>==</span> <span class=mi>3</span><span class=p>:</span>  <span class=c1># 컬러 이미지</span>
</span></span><span class=line><span class=cl>                    <span class=n>component_colors</span><span class=p>[</span><span class=n>component</span><span class=p>]</span> <span class=o>=</span> <span class=n>image</span><span class=p>[</span><span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=p>]</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>  <span class=c1># 그레이스케일 이미지</span>
</span></span><span class=line><span class=cl>                    <span class=n>component_colors</span><span class=p>[</span><span class=n>component</span><span class=p>]</span> <span class=o>=</span> <span class=n>image</span><span class=p>[</span><span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>[</span><span class=n>y</span><span class=p>,</span> <span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>component_colors</span><span class=p>[</span><span class=n>component</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>클러스터링 알고리즘<br>MST는 데이터 클러스터링에 활용할 수 있다. 특히, 계층적 클러스터링에서 MST를 구성한 후 가장 가중치가 큰 간선부터 제거하여 클러스터를 형성하는 방법이 널리 사용된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span><span class=lnt id=hl-12-27><a class=lnlinks href=#hl-12-27>27</a>
</span><span class=lnt id=hl-12-28><a class=lnlinks href=#hl-12-28>28</a>
</span><span class=lnt id=hl-12-29><a class=lnlinks href=#hl-12-29>29</a>
</span><span class=lnt id=hl-12-30><a class=lnlinks href=#hl-12-30>30</a>
</span><span class=lnt id=hl-12-31><a class=lnlinks href=#hl-12-31>31</a>
</span><span class=lnt id=hl-12-32><a class=lnlinks href=#hl-12-32>32</a>
</span><span class=lnt id=hl-12-33><a class=lnlinks href=#hl-12-33>33</a>
</span><span class=lnt id=hl-12-34><a class=lnlinks href=#hl-12-34>34</a>
</span><span class=lnt id=hl-12-35><a class=lnlinks href=#hl-12-35>35</a>
</span><span class=lnt id=hl-12-36><a class=lnlinks href=#hl-12-36>36</a>
</span><span class=lnt id=hl-12-37><a class=lnlinks href=#hl-12-37>37</a>
</span><span class=lnt id=hl-12-38><a class=lnlinks href=#hl-12-38>38</a>
</span><span class=lnt id=hl-12-39><a class=lnlinks href=#hl-12-39>39</a>
</span><span class=lnt id=hl-12-40><a class=lnlinks href=#hl-12-40>40</a>
</span><span class=lnt id=hl-12-41><a class=lnlinks href=#hl-12-41>41</a>
</span><span class=lnt id=hl-12-42><a class=lnlinks href=#hl-12-42>42</a>
</span><span class=lnt id=hl-12-43><a class=lnlinks href=#hl-12-43>43</a>
</span><span class=lnt id=hl-12-44><a class=lnlinks href=#hl-12-44>44</a>
</span><span class=lnt id=hl-12-45><a class=lnlinks href=#hl-12-45>45</a>
</span><span class=lnt id=hl-12-46><a class=lnlinks href=#hl-12-46>46</a>
</span><span class=lnt id=hl-12-47><a class=lnlinks href=#hl-12-47>47</a>
</span><span class=lnt id=hl-12-48><a class=lnlinks href=#hl-12-48>48</a>
</span><span class=lnt id=hl-12-49><a class=lnlinks href=#hl-12-49>49</a>
</span><span class=lnt id=hl-12-50><a class=lnlinks href=#hl-12-50>50</a>
</span><span class=lnt id=hl-12-51><a class=lnlinks href=#hl-12-51>51</a>
</span><span class=lnt id=hl-12-52><a class=lnlinks href=#hl-12-52>52</a>
</span><span class=lnt id=hl-12-53><a class=lnlinks href=#hl-12-53>53</a>
</span><span class=lnt id=hl-12-54><a class=lnlinks href=#hl-12-54>54</a>
</span><span class=lnt id=hl-12-55><a class=lnlinks href=#hl-12-55>55</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>hierarchical_clustering</span><span class=p>(</span><span class=n>data_points</span><span class=p>,</span> <span class=n>distance_metric</span><span class=p>,</span> <span class=n>n_clusters</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    MST 기반 계층적 클러스터링
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    입력:
</span></span></span><span class=line><span class=cl><span class=s2>      data_points: 데이터 포인트 리스트
</span></span></span><span class=line><span class=cl><span class=s2>      distance_metric: 두 데이터 포인트 간 거리 계산 함수
</span></span></span><span class=line><span class=cl><span class=s2>      n_clusters: 생성할 클러스터 수
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    출력:
</span></span></span><span class=line><span class=cl><span class=s2>      n_clusters개의 클러스터 (각 클러스터는 데이터 포인트 인덱스 리스트)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>data_points</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 데이터 포인트 쌍 간의 거리 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>dist</span> <span class=o>=</span> <span class=n>distance_metric</span><span class=p>(</span><span class=n>data_points</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>data_points</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>edges</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>dist</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># MST 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span> <span class=o>=</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>edges</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># MST 간선을 가중치 내림차순으로 정렬</span>
</span></span><span class=line><span class=cl>    <span class=n>mst_edges</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>2</span><span class=p>],</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 상위 (n_clusters-1)개 간선 제거</span>
</span></span><span class=line><span class=cl>    <span class=n>edges_to_remove</span> <span class=o>=</span> <span class=nb>set</span><span class=p>((</span><span class=nb>min</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span> <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>[:</span><span class=n>n_clusters</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 남은 간선으로 그래프 구성</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>{</span><span class=n>i</span><span class=p>:</span> <span class=p>[]</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>mst_edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>),</span> <span class=nb>max</span><span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>))</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>edges_to_remove</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>u</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>graph</span><span class=p>[</span><span class=n>v</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 연결된 컴포넌트(클러스터) 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>clusters</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>cluster</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>cluster</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dfs</span><span class=p>(</span><span class=n>neighbor</span><span class=p>,</span> <span class=n>cluster</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>cluster</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>cluster</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>clusters</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>cluster</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>clusters</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=최신-연구-및-향후-방향>최신 연구 및 향후 방향<a hidden class=anchor aria-hidden=true href=#최신-연구-및-향후-방향>#</a></h3><ol><li>대규모 그래프를 위한 분산 알고리즘<br>빅데이터 시대에 맞춰 대규모 그래프에 대한 MST 알고리즘이 연구되고 있다:<ol><li><strong>MapReduce 기반 MST</strong>: Hadoop이나 Spark와 같은 분산 프레임워크에서 실행할 수 있는 MST 알고리즘</li><li><strong>프라그마틱 알고리즘</strong>: 근사해를 통해 대규모 그래프에서도 효율적으로 동작하는 알고리즘</li><li><strong>그래프 요약</strong>: 그래프 규모를 줄인 후 MST를 계산하고 결과를 원래 그래프로 매핑</li></ol></li><li>동적 환경에서의 MST<br>그래프가 동적으로 변화하는 환경에서 MST를 효율적으로 유지하는 연구:<ol><li><strong>점진적 업데이트</strong>: 간선이 추가/삭제될 때 MST를 효율적으로 업데이트하는 알고리즘</li><li><strong>대화형 MST</strong>: 사용자의 입력에 따라 실시간으로 MST를 조정하는 시스템</li><li><strong>스트림 기반 MST</strong>: 데이터 스트림 환경에서 MST를 점진적으로 계산하는 알고리즘</li></ol></li><li>다중 목적 최적화<br>여러 목표를 동시에 최적화하는 MST 변형:<ol><li><strong>다중 가중치 MST</strong>: 간선에 여러 유형의 가중치가 있는 경우 (예: 비용, 신뢰성, 지연 시간)</li><li><strong>제약 기반 MST</strong>: 다양한 제약 조건 하에서 MST를 계산</li><li><strong>견고한 MST</strong>: 불확실성과 오류에 강한 MST 알고리즘</li></ol></li><li>양자 컴퓨팅과 MST<br>향후 양자 컴퓨팅 환경에서 MST를 계산하는 알고리즘도 연구되고 있다:<ol><li><strong>양자 최적화</strong>: 양자 어닐링을 활용한 MST 계산</li><li><strong>양자 병렬 처리</strong>: 양자 병렬성을 활용한 고속 MST 알고리즘</li><li><strong>하이브리드 접근법</strong>: 기존 알고리즘과 양자 알고리즘을 조합한 방식</li></ol></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kruskal’s Algorithm</h2></header><div class=entry-content><p>Kruskal’s Algorithm 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-10 04:08:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kruskal’s Algorithm" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/kruskals-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prim’s Algorithm</h2></header><div class=entry-content><p>Prim’s Algorithm 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-10 04:08:00 +0000 UTC'>December 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prim’s Algorithm" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/minimum-spanning-tree/prims-algorithm/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>