<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>인접 행렬(Adjacency Matrix) | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Graph,Representation,Adjacency-Matrix"><meta name=description content="수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.  행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="인접 행렬(Adjacency Matrix)"><meta property="og:description" content="수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.  행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-07T03:04:00+00:00"><meta property="article:modified_time" content="2024-12-07T03:04:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Graph"><meta property="article:tag" content="Representation"><meta property="article:tag" content="Adjacency-Matrix"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="인접 행렬(Adjacency Matrix)"><meta name=twitter:description content="수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.  행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Data Structures","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":4,"name":"그래프 (Graph)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/"},{"@type":"ListItem","position":5,"name":"Representation","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/"},{"@type":"ListItem","position":6,"name":"인접 행렬(Adjacency Matrix)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"인접 행렬(Adjacency Matrix)","name":"인접 행렬(Adjacency Matrix)","description":"수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.  행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Graph","Representation","Adjacency-Matrix"],"articleBody":"인접 행렬(Adjacency Matrix) 인접 행렬은 그래프를 표현하는 가장 기본적인 방법 중 하나로, 수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.\n행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.\n인접 행렬은 그래프를 표현하는 직관적이고 효율적인 방법이다. 특히 간선의 존재 여부를 빠르게 확인해야 하거나, 간선이 많은 밀집 그래프를 다룰 때 유용하다. 또한, 행렬 연산을 통해 그래프의 다양한 속성을 분석할 수 있다는 장점이 있다.\n하지만 정점이 많고 간선이 적은 희소 그래프에서는 메모리 사용량이 많아지는 단점이 있다. 이러한 경우에는 인접 리스트나 희소 행렬 표현과 같은 대안을 고려할 필요가 있다.\n인접 행렬의 기본 개념 인접 행렬 A는 n×n 크기의 2차원 배열로, n은 그래프의 정점 수이다.\n행렬의 각 원소 A[i][j]는 다음과 같이 정의된다:\n무가중치 그래프의 경우 A[i][j] = 1: 정점 i에서 정점 j로 가는 간선이 존재 A[i][j] = 0: 정점 i에서 정점 j로 가는 간선이 없음 가중치 그래프의 경우 A[i][j] = w: 정점 i에서 정점 j로 가는 간선의 가중치가 w A[i][j] = ∞ (또는 매우 큰 값): 정점 i에서 정점 j로 가는 간선이 없음 때로는 A[i][j] = 0을 간선이 없음을 나타내는 데 사용하기도 한다. 인접 행렬의 특성 무방향 그래프에서의 인접 행렬 무방향 그래프에서는 i에서 j로 가는 간선이 있다면, j에서 i로 가는 간선도 있다.\n따라서:\nA[i][j] = A[j][i]가 항상 성립한다. 인접 행렬이 대칭 행렬(symmetric matrix)이 된다. 자기 자신으로의 간선(자기 루프)이 없는 경우, 대각선 원소들은 모두 0이다. Adjacency Matrix for Undirected and Unweighted graph\nhttps://www.geeksforgeeks.org/adjacency-matrix/\nAdjacency Matrix for Undirected and Weighted graph\nhttps://www.geeksforgeeks.org/adjacency-matrix/\n방향 그래프에서의 인접 행렬 방향 그래프에서는 i에서 j로 가는 간선이 있더라도, j에서 i로 가는 간선이 없을 수 있다:\nA[i][j]와 A[j][i]가 다를 수 있다. 인접 행렬이 비대칭 행렬일 수 있다. Adjacency Matrix for Directed and Unweighted graph\nhttps://www.geeksforgeeks.org/adjacency-matrix/\nAdjacency Matrix for Directed and Weighted graph\nhttps://www.geeksforgeeks.org/adjacency-matrix/\n인접 행렬의 장단점 구분 장점 단점 빠른 간선 탐색 O(1)의 시간 복잡도로 특정 두 정점이 연결되었는지 즉시 확인 가능 메모리 사용량이 많음 (O(V²)) 간단한 구현 2차원 배열을 사용하여 구현이 쉬움 희소 그래프(Sparse Graph)에서는 비효율적 모든 간선 확인 행렬의 모든 요소를 순회하며 간선 정보 확인 가능 (O(V²)) 연결된 노드 탐색 시 불필요한 0값까지 검사해야 함 인접 행렬은 간선 정보를 빠르게 조회해야 하는 경우 적합하지만, 간선이 적은 희소 그래프(Sparse Graph)에서는 비효율적이다.\n간선 개수가 많고 밀집된 그래프(Dense Graph)에서 더 유용하게 사용된다.\n장점 간단한 구현: 2차원 배열만 있으면 쉽게 구현할 수 있다. 간선 확인의 효율성: 두 정점 사이의 간선 존재 여부를 O(1) 시간에 확인할 수 있다. 간선 추가/제거의 효율성: 간선 추가 및 제거가 O(1) 시간에 가능하다. 밀집 그래프(Dense Graph)에서의 효율성: 간선이 많은 그래프에서는 메모리 효율이 좋을 수 있다. 행렬 연산 활용: 그래프 이론의 많은 부분을 행렬 연산으로 처리할 수 있다. 단점 공간 복잡도: O(V²) 공간을 차지하므로, 정점이 많은 그래프에서는 메모리 사용량이 많다. 희소 그래프(Sparse Graph)에서의 비효율성: 간선이 적은 그래프에서는 많은 메모리가 낭비된다. 모든 간선 순회: 특정 정점의 모든 인접 정점을 찾기 위해 O(V) 시간이 필요하다. 인접 리스트를 사용하면 인접한 정점의 수에 비례하는 시간만 필요하다. 인접 행렬의 수학적 특성 행렬의 거듭제곱\n그래프의 인접 행렬 A에 대해, A^k[i][j]는 정점 i에서 정점 j로 가는 길이가 정확히 k인 경로의 수를 나타낸다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import numpy as np def count_paths_of_length_k(adj_matrix, k): \"\"\" 길이가 정확히 k인 경로의 수를 계산합니다. Args: adj_matrix (list of list): 인접 행렬 k (int): 경로의 길이 Returns: numpy.ndarray: 결과 행렬 (A^k) \"\"\" A = np.array(adj_matrix) return np.linalg.matrix_power(A, k) 이 속성은 그래프 분석에서 매우 유용하게 활용된다.\n예를 들어, 소셜 네트워크에서 A^2[i][j]는 사용자 i와 사용자 j가 공통으로 아는 친구의 수를 나타낸다.\n인접 행렬과 그래프 특성\n연결 그래프 판별: A + A² + A³ + … + A^(n-1)의 모든 원소가 0이 아니면, 그래프는 연결 그래프이다. 정점의 중심성(Centrality): 인접 행렬의 고유벡터(eigenvector)가 정점의 중심성을 나타낼 수 있다. 이는 PageRank 알고리즘의 기본 원리이다. 그래프 정규화(Regularization): 정규화된 인접 행렬 D^(-1/2)AD^(-1/2) (여기서 D는 대각 행렬로, D[i][i]는 정점 i의 차수)는 그래프 신호 처리와 기계 학습에서 중요하게 사용된다. 인접 행렬의 구조 무방향 그래프 (Undirected Graph)의 인접 행렬 무방향 그래프에서는 간선이 양방향이므로, 대칭 행렬(Symmetric Matrix) 형태를 가진다.\n예제 그래프\nA - B | | C - D 인접 행렬 표현\nA B C D A 0 1 1 0 B 1 0 0 1 C 1 0 0 1 D 0 1 1 0 방향 그래프 (Directed Graph)의 인접 행렬 방향 그래프는 간선이 **한쪽 방향으로만 연결되므로, 비대칭 행렬(Asymmetric Matrix)이 될 수 있다.\n예제 그래프\nA → B ↓ C → D 인접 행렬 표현\nA B C D A 0 1 1 0 B 0 0 0 0 C 0 0 0 1 D 0 0 0 0 가중치 그래프 (Weighted Graph)의 인접 행렬 가중치 그래프에서는 0과 1 대신, 간선의 가중치(Weight)를 저장한다.\n예제 그래프\nA --(4)--\u003e B | | (2) (3) | | C --(1)--\u003e D 인접 행렬 표현\nA B C D A 0 4 2 0 B 0 0 0 3 C 0 0 0 1 D 0 0 0 0 Python을 이용한 인접 행렬 구현 예시 기본 인접 행렬 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 그래프의 노드 수 V = 4 # 4 x 4 크기의 인접 행렬 생성 (초기값 0) adj_matrix = [[0] * V for _ in range(V)] # 간선 추가 (A=0, B=1, C=2, D=3) edges = [(0, 1), (0, 2), (2, 3)] # 간선 정보를 인접 행렬에 반영 for u, v in edges: adj_matrix[u][v] = 1 # 방향 그래프 (무방향 그래프라면 adj_matrix[v][u] = 1도 추가) # 인접 행렬 출력 for row in adj_matrix: print(row) 출력 결과\n[0, 1, 1, 0] [0, 0, 0, 0] [0, 0, 0, 1] [0, 0, 0, 0] 가중치 그래프 인접 행렬 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 V = 4 INF = float('inf') # 간선이 없는 경우를 무한대(INF)로 표시 # 4 x 4 크기의 가중치 인접 행렬 생성 (초기값 INF) adj_matrix = [[INF] * V for _ in range(V)] # 자기 자신으로 가는 간선은 0으로 설정 for i in range(V): adj_matrix[i][i] = 0 # 간선 추가 (A=0, B=1, C=2, D=3) - (출발, 도착, 가중치) edges = [(0, 1, 4), (0, 2, 2), (2, 3, 1), (1, 3, 3)] for u, v, weight in edges: adj_matrix[u][v] = weight # 방향 그래프 # 인접 행렬 출력 for row in adj_matrix: print(row) 출력 결과\n[0, 4, 2, INF] [INF, 0, INF, 3] [INF, INF, 0, 1] [INF, INF, INF, 0] 인접 행렬 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Graph: def __init__(self, num_vertices, directed=False): \"\"\" 그래프의 정점 수를 받아 인접 행렬을 초기화합니다. Args: num_vertices (int): 정점의 개수 directed (bool): 방향 그래프 여부 (기본값: False) \"\"\" self.num_vertices = num_vertices self.directed = directed # 인접 행렬 초기화 (모든 원소를 0으로 설정) self.adj_matrix = [[0 for _ in range(num_vertices)] for _ in range(num_vertices)] def add_edge(self, v1, v2, weight=1): \"\"\" 그래프에 간선을 추가합니다. Args: v1 (int): 시작 정점 v2 (int): 도착 정점 weight (int/float): 간선의 가중치 (기본값: 1) \"\"\" if v1 \u003e= self.num_vertices or v2 \u003e= self.num_vertices or v1 \u003c 0 or v2 \u003c 0: print(\"유효하지 않은 정점입니다.\") return self.adj_matrix[v1][v2] = weight # 무방향 그래프인 경우 대칭적으로 간선 추가 if not self.directed: self.adj_matrix[v2][v1] = weight def remove_edge(self, v1, v2): \"\"\" 그래프에서 간선을 제거합니다. Args: v1 (int): 시작 정점 v2 (int): 도착 정점 \"\"\" if v1 \u003e= self.num_vertices or v2 \u003e= self.num_vertices or v1 \u003c 0 or v2 \u003c 0: print(\"유효하지 않은 정점입니다.\") return self.adj_matrix[v1][v2] = 0 # 무방향 그래프인 경우 대칭적으로 간선 제거 if not self.directed: self.adj_matrix[v2][v1] = 0 def print_graph(self): \"\"\" 인접 행렬을 출력합니다. \"\"\" for i in range(self.num_vertices): for j in range(self.num_vertices): print(self.adj_matrix[i][j], end=\" \") print() def get_neighbors(self, vertex): \"\"\" 특정 정점에 인접한 정점들을 반환합니다. Args: vertex (int): 정점 Returns: list: 인접한 정점들의 리스트 \"\"\" if vertex \u003e= self.num_vertices or vertex \u003c 0: print(\"유효하지 않은 정점입니다.\") return [] neighbors = [] for i in range(self.num_vertices): if self.adj_matrix[vertex][i] != 0: neighbors.append(i) return neighbors 인접 행렬을 이용한 그래프 연산 인접한 정점 찾기 1 2 3 4 5 6 7 # vertex의 모든 인접 정점 찾기 def get_neighbors(adj_matrix, vertex): neighbors = [] for i in range(len(adj_matrix)): if adj_matrix[vertex][i] != 0: neighbors.append(i) return neighbors 간선의 존재 여부 확인 1 2 3 # v1에서 v2로 가는 간선이 있는지 확인 def is_edge(adj_matrix, v1, v2): return adj_matrix[v1][v2] != 0 정점의 차수(degree) 계산 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 무방향 그래프에서 vertex의 차수 계산 def get_degree(adj_matrix, vertex): degree = 0 for i in range(len(adj_matrix)): if adj_matrix[vertex][i] != 0: degree += 1 return degree # 방향 그래프에서 정점의 진입 차수(in-degree) 계산 def get_in_degree(adj_matrix, vertex): in_degree = 0 for i in range(len(adj_matrix)): if adj_matrix[i][vertex] != 0: in_degree += 1 return in_degree # 방향 그래프에서 정점의 진출 차수(out-degree) 계산 def get_out_degree(adj_matrix, vertex): out_degree = 0 for i in range(len(adj_matrix)): if adj_matrix[vertex][i] != 0: out_degree += 1 return out_degree 인접 행렬을 이용한 그래프 알고리즘 깊이 우선 탐색(DFS)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def dfs_adjacency_matrix(adj_matrix, start_vertex): \"\"\" 인접 행렬로 표현된 그래프에서 DFS 수행 Args: adj_matrix (list of list): 인접 행렬 start_vertex (int): 시작 정점 Returns: list: 방문한 정점들의 순서 \"\"\" n = len(adj_matrix) visited = [False] * n result = [] def dfs_recursive(vertex): # 현재 정점을 방문 처리 visited[vertex] = True result.append(vertex) # 인접한 정점들을 방문 for i in range(n): if adj_matrix[vertex][i] != 0 and not visited[i]: dfs_recursive(i) dfs_recursive(start_vertex) return result 너비 우선 탐색(BFS)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from collections import deque def bfs_adjacency_matrix(adj_matrix, start_vertex): \"\"\" 인접 행렬로 표현된 그래프에서 BFS 수행 Args: adj_matrix (list of list): 인접 행렬 start_vertex (int): 시작 정점 Returns: list: 방문한 정점들의 순서 \"\"\" n = len(adj_matrix) visited = [False] * n result = [] # 시작 정점을 큐에 넣고 방문 처리 queue = deque([start_vertex]) visited[start_vertex] = True while queue: # 큐에서 정점을 하나 꺼내서 결과에 추가 vertex = queue.popleft() result.append(vertex) # 인접한 정점들을 큐에 추가 for i in range(n): if adj_matrix[vertex][i] != 0 and not visited[i]: visited[i] = True queue.append(i) return result 다익스트라(Dijkstra) 알고리즘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import heapq def dijkstra_adjacency_matrix(adj_matrix, start_vertex): \"\"\" 인접 행렬로 표현된 그래프에서 다익스트라 알고리즘 수행 Args: adj_matrix (list of list): 인접 행렬 start_vertex (int): 시작 정점 Returns: list: 시작 정점에서 각 정점까지의 최단 거리 \"\"\" n = len(adj_matrix) distances = [float('inf')] * n # 최단 거리를 저장할 배열 distances[start_vertex] = 0 # 시작 정점의 거리는 0 # (현재까지의 거리, 정점) 튜플을 원소로 하는 최소 힙 priority_queue = [(0, start_vertex)] while priority_queue: # 가장 거리가 짧은 정점 선택 current_distance, current_vertex = heapq.heappop(priority_queue) # 이미 처리된 정점이면 스킵 if current_distance \u003e distances[current_vertex]: continue # 인접한 정점들의 거리 갱신 for neighbor in range(n): # 간선이 존재하는 경우에만 처리 if adj_matrix[current_vertex][neighbor] != 0: distance = current_distance + adj_matrix[current_vertex][neighbor] # 더 짧은 경로를 발견한 경우 갱신 if distance \u003c distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances 인접 행렬의 실제 활용 사례 소셜 네트워크 분석\n페이스북, 트위터와 같은 소셜 미디어 플랫폼에서는 사용자 간의 관계를 인접 행렬로 표현할 수 있다:\nA[i][j] = 1: 사용자 i가 사용자 j를 팔로우하거나 친구인 경우 A[i][j] = 0: 그렇지 않은 경우\n이를 통해 다음과 같은 분석이 가능하다: 공통 친구 수 계산 (A²[i][j]) 영향력 있는 사용자 식별 (중심성 분석) 커뮤니티 감지 (군집 분석) 웹 그래프와 검색 엔진\n웹 페이지들을 정점으로, 하이퍼링크를 간선으로 표현하는 웹 그래프에서:\nPageRank 알고리즘은 인접 행렬의 고유벡터를 계산하여 페이지의 중요도를 결정한다. HITS(Hyperlink-Induced Topic Search) 알고리즘은 인접 행렬과 그 전치 행렬을 사용하여 허브(hub)와 권위(authority) 페이지를 식별한다. 네트워크 라우팅\n컴퓨터 네트워크에서 라우터 간의 연결을 나타내는 인접 행렬:\n플로이드-워셜(Floyd-Warshall) 알고리즘을 사용하여 모든 라우터 쌍 간의 최단 경로를 계산한다. 스패닝 트리 프로토콜(STP)은 최소 신장 트리를 구성하여 루프를 방지한다. 생물학적 네트워크\n단백질 상호작용 네트워크나 유전자 조절 네트워크:\n인접 행렬을 통해 생물학적 경로와 기능적 모듈을 식별한다. 네트워크 모티프(motif) 분석을 통해 반복적으로 나타나는 패턴을 찾는다. 인접 행렬 최적화 기법 희소 행렬(Sparse Matrix) 표현\n정점은 많지만 간선이 적은 희소 그래프의 경우, 희소 행렬 자료구조를 사용하여 메모리 사용량을 줄일 수 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from scipy.sparse import csr_matrix # 희소 인접 행렬 생성 def create_sparse_adjacency_matrix(edges, num_vertices): \"\"\" 희소 인접 행렬을 생성합니다. Args: edges (list of tuple): (시작 정점, 끝 정점, 가중치) 형태의 간선 목록 num_vertices (int): 정점의 수 Returns: scipy.sparse.csr_matrix: 희소 인접 행렬 \"\"\" row = [edge[0] for edge in edges] col = [edge[1] for edge in edges] data = [edge[2] for edge in edges] return csr_matrix((data, (row, col)), shape=(num_vertices, num_vertices)) 블록 행렬(Block Matrix) 표현\n큰 그래프를 여러 개의 작은 블록으로 나누어 처리할 수 있다.\n이는 분산 시스템에서 유용하다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def create_block_adjacency_matrix(adj_matrix, block_size): \"\"\" 인접 행렬을 블록 단위로 나눕니다. Args: adj_matrix (list of list): 인접 행렬 block_size (int): 블록의 크기 Returns: list of list of list: 블록 인접 행렬 \"\"\" n = len(adj_matrix) num_blocks = (n + block_size - 1) // block_size block_matrix = [[[] for _ in range(num_blocks)] for _ in range(num_blocks)] for i in range(num_blocks): for j in range(num_blocks): # 블록의 범위 계산 row_start = i * block_size row_end = min((i + 1) * block_size, n) col_start = j * block_size col_end = min((j + 1) * block_size, n) # 블록 생성 block = [] for r in range(row_start, row_end): row = [] for c in range(col_start, col_end): row.append(adj_matrix[r][c]) block.append(row) block_matrix[i][j] = block return block_matrix 참고 및 출처 ","wordCount":"2335","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-07T03:04:00Z","dateModified":"2024-12-07T03:04:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/>그래프 (Graph)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/>Representation</a></div><h1 class="post-title entry-hint-parent">인접 행렬(Adjacency Matrix)</h1><div class=post-description>수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다. 행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.</div><div class=post-meta><span title='2024-12-07 03:04:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Data%20Structures/Graph/Representation/adjacency-matrix.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#인접-행렬adjacency-matrix>인접 행렬(Adjacency Matrix)</a><ul><li><a href=#인접-행렬의-기본-개념>인접 행렬의 기본 개념</a></li><li><a href=#인접-행렬의-특성>인접 행렬의 특성</a></li><li><a href=#인접-행렬의-장단점>인접 행렬의 장단점</a></li><li><a href=#인접-행렬의-수학적-특성>인접 행렬의 수학적 특성</a></li><li><a href=#인접-행렬의-구조>인접 행렬의 구조</a></li><li><a href=#python을-이용한-인접-행렬-구현-예시>Python을 이용한 인접 행렬 구현 예시</a></li><li><a href=#인접-행렬을-이용한-그래프-연산>인접 행렬을 이용한 그래프 연산</a></li><li><a href=#인접-행렬을-이용한-그래프-알고리즘>인접 행렬을 이용한 그래프 알고리즘</a></li><li><a href=#인접-행렬의-실제-활용-사례>인접 행렬의 실제 활용 사례</a></li><li><a href=#인접-행렬-최적화-기법>인접 행렬 최적화 기법</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=인접-행렬adjacency-matrix>인접 행렬(Adjacency Matrix)<a hidden class=anchor aria-hidden=true href=#인접-행렬adjacency-matrix>#</a></h2><p>인접 행렬은 그래프를 표현하는 가장 기본적인 방법 중 하나로, 수학적 행렬을 사용하여 그래프의 정점들 간의 연결 관계를 나타낸다.<br>행렬의 각 원소는 두 정점 사이의 간선 존재 여부나 가중치를 표시한다.</p><p>인접 행렬은 그래프를 표현하는 직관적이고 효율적인 방법이다. 특히 간선의 존재 여부를 빠르게 확인해야 하거나, 간선이 많은 밀집 그래프를 다룰 때 유용하다. 또한, 행렬 연산을 통해 그래프의 다양한 속성을 분석할 수 있다는 장점이 있다.</p><p>하지만 정점이 많고 간선이 적은 희소 그래프에서는 메모리 사용량이 많아지는 단점이 있다. 이러한 경우에는 인접 리스트나 희소 행렬 표현과 같은 대안을 고려할 필요가 있다.</p><h3 id=인접-행렬의-기본-개념>인접 행렬의 기본 개념<a hidden class=anchor aria-hidden=true href=#인접-행렬의-기본-개념>#</a></h3><p>인접 행렬 A는 n×n 크기의 2차원 배열로, n은 그래프의 정점 수이다.</p><p>행렬의 각 원소 <code>A[i][j]</code>는 다음과 같이 정의된다:</p><ul><li>무가중치 그래프의 경우<ul><li><code>A[i][j] = 1</code>: 정점 i에서 정점 j로 가는 간선이 존재</li><li><code>A[i][j] = 0</code>: 정점 i에서 정점 j로 가는 간선이 없음</li></ul></li><li>가중치 그래프의 경우<ul><li><code>A[i][j] = w</code>: 정점 i에서 정점 j로 가는 간선의 가중치가 w</li><li><code>A[i][j] = ∞ (또는 매우 큰 값)</code>: 정점 i에서 정점 j로 가는 간선이 없음</li><li>때로는 <code>A[i][j] = 0</code>을 간선이 없음을 나타내는 데 사용하기도 한다.</li></ul></li></ul><h3 id=인접-행렬의-특성>인접 행렬의 특성<a hidden class=anchor aria-hidden=true href=#인접-행렬의-특성>#</a></h3><h4 id=무방향-그래프에서의-인접-행렬>무방향 그래프에서의 인접 행렬<a hidden class=anchor aria-hidden=true href=#무방향-그래프에서의-인접-행렬>#</a></h4><p>무방향 그래프에서는 i에서 j로 가는 간선이 있다면, j에서 i로 가는 간선도 있다.<br>따라서:</p><ul><li><code>A[i][j] = A[j][i]</code>가 항상 성립한다.</li><li>인접 행렬이 대칭 행렬(symmetric matrix)이 된다.</li><li>자기 자신으로의 간선(자기 루프)이 없는 경우, 대각선 원소들은 모두 0이다.</li></ul><p>Adjacency Matrix for Undirected and Unweighted graph<br><figure><img alt="Adjacency Matrix for Undirected and Unweighted graph" loading=lazy src=/img/Adjacency-Matrix-for-Undirected-and-Unweighted-graph.webp><figcaption>https://www.geeksforgeeks.org/adjacency-matrix/</figcaption></figure></p><p>Adjacency Matrix for Undirected and Weighted graph<br><figure><img alt="Adjacency Matrix for Undirected and Weighted graph" loading=lazy src=/img/Adjacency-Matrix-for-Undirected-and-Weighted-graph-1024.webp><figcaption>https://www.geeksforgeeks.org/adjacency-matrix/</figcaption></figure></p><h4 id=방향-그래프에서의-인접-행렬>방향 그래프에서의 인접 행렬<a hidden class=anchor aria-hidden=true href=#방향-그래프에서의-인접-행렬>#</a></h4><p>방향 그래프에서는 i에서 j로 가는 간선이 있더라도, j에서 i로 가는 간선이 없을 수 있다:</p><ul><li><code>A[i][j]</code>와 <code>A[j][i]</code>가 다를 수 있다.</li><li>인접 행렬이 비대칭 행렬일 수 있다.</li></ul><p>Adjacency Matrix for Directed and Unweighted graph<br><figure><img alt="Adjacency Matrix for Directed and Unweighted graph" loading=lazy src=/img/Adjacency-Matrix-for-Directed-and-Unweighted-graph-1024.webp><figcaption>https://www.geeksforgeeks.org/adjacency-matrix/</figcaption></figure></p><p>Adjacency Matrix for Directed and Weighted graph<br><figure><img alt="Adjacency Matrix for Directed and Weighted graph" loading=lazy src=/img/Adjacency-Matrix-for-Directed-and-Weighted-graph-1024.webp><figcaption>https://www.geeksforgeeks.org/adjacency-matrix/</figcaption></figure></p><h3 id=인접-행렬의-장단점>인접 행렬의 장단점<a hidden class=anchor aria-hidden=true href=#인접-행렬의-장단점>#</a></h3><table><thead><tr><th><strong>구분</strong></th><th><strong>장점</strong></th><th><strong>단점</strong></th></tr></thead><tbody><tr><td><strong>빠른 간선 탐색</strong></td><td><code>O(1)</code>의 시간 복잡도로 특정 두 정점이 연결되었는지 즉시 확인 가능</td><td>메모리 사용량이 많음 (<code>O(V²)</code>)</td></tr><tr><td><strong>간단한 구현</strong></td><td>2차원 배열을 사용하여 구현이 쉬움</td><td>희소 그래프(Sparse Graph)에서는 비효율적</td></tr><tr><td><strong>모든 간선 확인</strong></td><td>행렬의 모든 요소를 순회하며 간선 정보 확인 가능 (<code>O(V²)</code>)</td><td>연결된 노드 탐색 시 불필요한 0값까지 검사해야 함</td></tr></tbody></table><p>인접 행렬은 간선 정보를 빠르게 조회해야 하는 경우 적합하지만, 간선이 적은 희소 그래프(Sparse Graph)에서는 비효율적이다.<br>간선 개수가 많고 밀집된 그래프(Dense Graph)에서 더 유용하게 사용된다.</p><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ol><li><strong>간단한 구현</strong>: 2차원 배열만 있으면 쉽게 구현할 수 있다.</li><li><strong>간선 확인의 효율성</strong>: 두 정점 사이의 간선 존재 여부를 O(1) 시간에 확인할 수 있다.</li><li><strong>간선 추가/제거의 효율성</strong>: 간선 추가 및 제거가 O(1) 시간에 가능하다.</li><li><strong>밀집 그래프(Dense Graph)에서의 효율성</strong>: 간선이 많은 그래프에서는 메모리 효율이 좋을 수 있다.</li><li><strong>행렬 연산 활용</strong>: 그래프 이론의 많은 부분을 행렬 연산으로 처리할 수 있다.</li></ol><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ol><li><strong>공간 복잡도</strong>: O(V²) 공간을 차지하므로, 정점이 많은 그래프에서는 메모리 사용량이 많다.</li><li><strong>희소 그래프(Sparse Graph)에서의 비효율성</strong>: 간선이 적은 그래프에서는 많은 메모리가 낭비된다.</li><li><strong>모든 간선 순회</strong>: 특정 정점의 모든 인접 정점을 찾기 위해 O(V) 시간이 필요하다. 인접 리스트를 사용하면 인접한 정점의 수에 비례하는 시간만 필요하다.</li></ol><h3 id=인접-행렬의-수학적-특성>인접 행렬의 수학적 특성<a hidden class=anchor aria-hidden=true href=#인접-행렬의-수학적-특성>#</a></h3><ol><li><p>행렬의 거듭제곱<br>그래프의 인접 행렬 A에 대해, <code>A^k[i][j]</code>는 정점 i에서 정점 j로 가는 길이가 정확히 k인 경로의 수를 나타낸다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>count_paths_of_length_k</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    길이가 정확히 k인 경로의 수를 계산합니다.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        adj_matrix (list of list): 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>        k (int): 경로의 길이
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        numpy.ndarray: 결과 행렬 (A^k)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>linalg</span><span class=o>.</span><span class=n>matrix_power</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 속성은 그래프 분석에서 매우 유용하게 활용된다.<br>예를 들어, 소셜 네트워크에서 <code>A^2[i][j]</code>는 사용자 i와 사용자 j가 공통으로 아는 친구의 수를 나타낸다.</p></li><li><p>인접 행렬과 그래프 특성</p><ol><li><strong>연결 그래프 판별</strong>: <code>A + A² + A³ + … + A^(n-1)</code>의 모든 원소가 0이 아니면, 그래프는 연결 그래프이다.</li><li><strong>정점의 중심성(Centrality)</strong>: 인접 행렬의 고유벡터(eigenvector)가 정점의 중심성을 나타낼 수 있다. 이는 PageRank 알고리즘의 기본 원리이다.</li><li><strong>그래프 정규화(Regularization)</strong>: 정규화된 인접 행렬 <code>D^(-1/2)AD^(-1/2)</code> (여기서 D는 대각 행렬로, <code>D[i][i]</code>는 정점 i의 차수)는 그래프 신호 처리와 기계 학습에서 중요하게 사용된다.</li></ol></li></ol><h3 id=인접-행렬의-구조>인접 행렬의 구조<a hidden class=anchor aria-hidden=true href=#인접-행렬의-구조>#</a></h3><h4 id=무방향-그래프-undirected-graph의-인접-행렬>무방향 그래프 (Undirected Graph)의 인접 행렬<a hidden class=anchor aria-hidden=true href=#무방향-그래프-undirected-graph의-인접-행렬>#</a></h4><p>무방향 그래프에서는 간선이 <strong>양방향</strong>이므로, <strong>대칭 행렬(Symmetric Matrix) 형태</strong>를 가진다.</p><p><strong>예제 그래프</strong></p><pre class=mermaid>  A - B
  |   |
  C - D
</pre><p><strong>인접 행렬 표현</strong></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>B</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>C</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h4 id=방향-그래프-directed-graph의-인접-행렬>방향 그래프 (Directed Graph)의 인접 행렬<a hidden class=anchor aria-hidden=true href=#방향-그래프-directed-graph의-인접-행렬>#</a></h4><p>방향 그래프는 간선이 **한쪽 방향으로만 연결되므로, 비대칭 행렬(Asymmetric Matrix)이 될 수 있다.</p><p><strong>예제 그래프</strong></p><pre class=mermaid>  A → B
  ↓   
  C → D
</pre><p><strong>인접 행렬 표현</strong></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id=가중치-그래프-weighted-graph의-인접-행렬>가중치 그래프 (Weighted Graph)의 인접 행렬<a hidden class=anchor aria-hidden=true href=#가중치-그래프-weighted-graph의-인접-행렬>#</a></h4><p>가중치 그래프에서는 <strong>0과 1 대신, 간선의 가중치(Weight)를 저장</strong>한다.</p><p><strong>예제 그래프</strong></p><pre class=mermaid>  A --(4)--&gt; B
  |         |
 (2)       (3)
  |         |
  C --(1)--&gt; D
</pre><p><strong>인접 행렬 표현</strong></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>4</td><td>2</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>0</td><td>3</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h3 id=python을-이용한-인접-행렬-구현-예시>Python을 이용한 인접 행렬 구현 예시<a hidden class=anchor aria-hidden=true href=#python을-이용한-인접-행렬-구현-예시>#</a></h3><h4 id=기본-인접-행렬-구현>기본 인접 행렬 구현<a hidden class=anchor aria-hidden=true href=#기본-인접-행렬-구현>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 그래프의 노드 수</span>
</span></span><span class=line><span class=cl><span class=n>V</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4 x 4 크기의 인접 행렬 생성 (초기값 0)</span>
</span></span><span class=line><span class=cl><span class=n>adj_matrix</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>V</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 간선 추가 (A=0, B=1, C=2, D=3)</span>
</span></span><span class=line><span class=cl><span class=n>edges</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 간선 정보를 인접 행렬에 반영</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>adj_matrix</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>  <span class=c1># 방향 그래프 (무방향 그래프라면 adj_matrix[v][u] = 1도 추가)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 인접 행렬 출력</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>adj_matrix</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>출력 결과</strong></p><pre class=mermaid>[0, 1, 1, 0]
[0, 0, 0, 0]
[0, 0, 0, 1]
[0, 0, 0, 0]
</pre><h4 id=가중치-그래프-인접-행렬-구현>가중치 그래프 인접 행렬 구현<a hidden class=anchor aria-hidden=true href=#가중치-그래프-인접-행렬-구현>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>V</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=n>INF</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>  <span class=c1># 간선이 없는 경우를 무한대(INF)로 표시</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4 x 4 크기의 가중치 인접 행렬 생성 (초기값 INF)</span>
</span></span><span class=line><span class=cl><span class=n>adj_matrix</span> <span class=o>=</span> <span class=p>[[</span><span class=n>INF</span><span class=p>]</span> <span class=o>*</span> <span class=n>V</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 자기 자신으로 가는 간선은 0으로 설정</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>adj_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 간선 추가 (A=0, B=1, C=2, D=3) - (출발, 도착, 가중치)</span>
</span></span><span class=line><span class=cl><span class=n>edges</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>3</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>adj_matrix</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>  <span class=c1># 방향 그래프</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 인접 행렬 출력</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>adj_matrix</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>출력 결과</strong></p><pre class=mermaid>[0, 4, 2, INF]
[INF, 0, INF, 3]
[INF, INF, 0, 1]
[INF, INF, INF, 0]
</pre><h4 id=인접-행렬-구현>인접 행렬 구현<a hidden class=anchor aria-hidden=true href=#인접-행렬-구현>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span><span class=lnt id=hl-8-29><a class=lnlinks href=#hl-8-29>29</a>
</span><span class=lnt id=hl-8-30><a class=lnlinks href=#hl-8-30>30</a>
</span><span class=lnt id=hl-8-31><a class=lnlinks href=#hl-8-31>31</a>
</span><span class=lnt id=hl-8-32><a class=lnlinks href=#hl-8-32>32</a>
</span><span class=lnt id=hl-8-33><a class=lnlinks href=#hl-8-33>33</a>
</span><span class=lnt id=hl-8-34><a class=lnlinks href=#hl-8-34>34</a>
</span><span class=lnt id=hl-8-35><a class=lnlinks href=#hl-8-35>35</a>
</span><span class=lnt id=hl-8-36><a class=lnlinks href=#hl-8-36>36</a>
</span><span class=lnt id=hl-8-37><a class=lnlinks href=#hl-8-37>37</a>
</span><span class=lnt id=hl-8-38><a class=lnlinks href=#hl-8-38>38</a>
</span><span class=lnt id=hl-8-39><a class=lnlinks href=#hl-8-39>39</a>
</span><span class=lnt id=hl-8-40><a class=lnlinks href=#hl-8-40>40</a>
</span><span class=lnt id=hl-8-41><a class=lnlinks href=#hl-8-41>41</a>
</span><span class=lnt id=hl-8-42><a class=lnlinks href=#hl-8-42>42</a>
</span><span class=lnt id=hl-8-43><a class=lnlinks href=#hl-8-43>43</a>
</span><span class=lnt id=hl-8-44><a class=lnlinks href=#hl-8-44>44</a>
</span><span class=lnt id=hl-8-45><a class=lnlinks href=#hl-8-45>45</a>
</span><span class=lnt id=hl-8-46><a class=lnlinks href=#hl-8-46>46</a>
</span><span class=lnt id=hl-8-47><a class=lnlinks href=#hl-8-47>47</a>
</span><span class=lnt id=hl-8-48><a class=lnlinks href=#hl-8-48>48</a>
</span><span class=lnt id=hl-8-49><a class=lnlinks href=#hl-8-49>49</a>
</span><span class=lnt id=hl-8-50><a class=lnlinks href=#hl-8-50>50</a>
</span><span class=lnt id=hl-8-51><a class=lnlinks href=#hl-8-51>51</a>
</span><span class=lnt id=hl-8-52><a class=lnlinks href=#hl-8-52>52</a>
</span><span class=lnt id=hl-8-53><a class=lnlinks href=#hl-8-53>53</a>
</span><span class=lnt id=hl-8-54><a class=lnlinks href=#hl-8-54>54</a>
</span><span class=lnt id=hl-8-55><a class=lnlinks href=#hl-8-55>55</a>
</span><span class=lnt id=hl-8-56><a class=lnlinks href=#hl-8-56>56</a>
</span><span class=lnt id=hl-8-57><a class=lnlinks href=#hl-8-57>57</a>
</span><span class=lnt id=hl-8-58><a class=lnlinks href=#hl-8-58>58</a>
</span><span class=lnt id=hl-8-59><a class=lnlinks href=#hl-8-59>59</a>
</span><span class=lnt id=hl-8-60><a class=lnlinks href=#hl-8-60>60</a>
</span><span class=lnt id=hl-8-61><a class=lnlinks href=#hl-8-61>61</a>
</span><span class=lnt id=hl-8-62><a class=lnlinks href=#hl-8-62>62</a>
</span><span class=lnt id=hl-8-63><a class=lnlinks href=#hl-8-63>63</a>
</span><span class=lnt id=hl-8-64><a class=lnlinks href=#hl-8-64>64</a>
</span><span class=lnt id=hl-8-65><a class=lnlinks href=#hl-8-65>65</a>
</span><span class=lnt id=hl-8-66><a class=lnlinks href=#hl-8-66>66</a>
</span><span class=lnt id=hl-8-67><a class=lnlinks href=#hl-8-67>67</a>
</span><span class=lnt id=hl-8-68><a class=lnlinks href=#hl-8-68>68</a>
</span><span class=lnt id=hl-8-69><a class=lnlinks href=#hl-8-69>69</a>
</span><span class=lnt id=hl-8-70><a class=lnlinks href=#hl-8-70>70</a>
</span><span class=lnt id=hl-8-71><a class=lnlinks href=#hl-8-71>71</a>
</span><span class=lnt id=hl-8-72><a class=lnlinks href=#hl-8-72>72</a>
</span><span class=lnt id=hl-8-73><a class=lnlinks href=#hl-8-73>73</a>
</span><span class=lnt id=hl-8-74><a class=lnlinks href=#hl-8-74>74</a>
</span><span class=lnt id=hl-8-75><a class=lnlinks href=#hl-8-75>75</a>
</span><span class=lnt id=hl-8-76><a class=lnlinks href=#hl-8-76>76</a>
</span><span class=lnt id=hl-8-77><a class=lnlinks href=#hl-8-77>77</a>
</span><span class=lnt id=hl-8-78><a class=lnlinks href=#hl-8-78>78</a>
</span><span class=lnt id=hl-8-79><a class=lnlinks href=#hl-8-79>79</a>
</span><span class=lnt id=hl-8-80><a class=lnlinks href=#hl-8-80>80</a>
</span><span class=lnt id=hl-8-81><a class=lnlinks href=#hl-8-81>81</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>num_vertices</span><span class=p>,</span> <span class=n>directed</span><span class=o>=</span><span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        그래프의 정점 수를 받아 인접 행렬을 초기화합니다.
</span></span></span><span class=line><span class=cl><span class=s2>        
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            num_vertices (int): 정점의 개수
</span></span></span><span class=line><span class=cl><span class=s2>            directed (bool): 방향 그래프 여부 (기본값: False)
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=o>=</span> <span class=n>num_vertices</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>directed</span> <span class=o>=</span> <span class=n>directed</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 인접 행렬 초기화 (모든 원소를 0으로 설정)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        그래프에 간선을 추가합니다.
</span></span></span><span class=line><span class=cl><span class=s2>        
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            v1 (int): 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>            v2 (int): 도착 정점
</span></span></span><span class=line><span class=cl><span class=s2>            weight (int/float): 간선의 가중치 (기본값: 1)
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>v1</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=ow>or</span> <span class=n>v2</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=ow>or</span> <span class=n>v1</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>v2</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;유효하지 않은 정점입니다.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>v1</span><span class=p>][</span><span class=n>v2</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 무방향 그래프인 경우 대칭적으로 간선 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>directed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>v2</span><span class=p>][</span><span class=n>v1</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>remove_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        그래프에서 간선을 제거합니다.
</span></span></span><span class=line><span class=cl><span class=s2>        
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            v1 (int): 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>            v2 (int): 도착 정점
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>v1</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=ow>or</span> <span class=n>v2</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=ow>or</span> <span class=n>v1</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>v2</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;유효하지 않은 정점입니다.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>v1</span><span class=p>][</span><span class=n>v2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 무방향 그래프인 경우 대칭적으로 간선 제거</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>directed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>v2</span><span class=p>][</span><span class=n>v1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_graph</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        인접 행렬을 출력합니다.
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_neighbors</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        특정 정점에 인접한 정점들을 반환합니다.
</span></span></span><span class=line><span class=cl><span class=s2>        
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            vertex (int): 정점
</span></span></span><span class=line><span class=cl><span class=s2>            
</span></span></span><span class=line><span class=cl><span class=s2>        Returns:
</span></span></span><span class=line><span class=cl><span class=s2>            list: 인접한 정점들의 리스트
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>vertex</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=ow>or</span> <span class=n>vertex</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;유효하지 않은 정점입니다.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=n>neighbors</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>vertex</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>neighbors</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>neighbors</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=인접-행렬을-이용한-그래프-연산>인접 행렬을 이용한 그래프 연산<a hidden class=anchor aria-hidden=true href=#인접-행렬을-이용한-그래프-연산>#</a></h3><h4 id=인접한-정점-찾기>인접한 정점 찾기<a hidden class=anchor aria-hidden=true href=#인접한-정점-찾기>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># vertex의 모든 인접 정점 찾기</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_neighbors</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>neighbors</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>vertex</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>neighbors</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>neighbors</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=간선의-존재-여부-확인>간선의 존재 여부 확인<a hidden class=anchor aria-hidden=true href=#간선의-존재-여부-확인>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># v1에서 v2로 가는 간선이 있는지 확인</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_edge</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>v1</span><span class=p>][</span><span class=n>v2</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=정점의-차수degree-계산>정점의 차수(degree) 계산<a hidden class=anchor aria-hidden=true href=#정점의-차수degree-계산>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20>20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21>21</a>
</span><span class=lnt id=hl-11-22><a class=lnlinks href=#hl-11-22>22</a>
</span><span class=lnt id=hl-11-23><a class=lnlinks href=#hl-11-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 무방향 그래프에서 vertex의 차수 계산</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_degree</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>degree</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>vertex</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>degree</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>degree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 방향 그래프에서 정점의 진입 차수(in-degree) 계산</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_in_degree</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>in_degree</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>vertex</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>in_degree</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>in_degree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 방향 그래프에서 정점의 진출 차수(out-degree) 계산</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_out_degree</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>out_degree</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>vertex</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>out_degree</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>out_degree</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=인접-행렬을-이용한-그래프-알고리즘>인접 행렬을 이용한 그래프 알고리즘<a hidden class=anchor aria-hidden=true href=#인접-행렬을-이용한-그래프-알고리즘>#</a></h3><ol><li><p>깊이 우선 탐색(DFS)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span><span class=lnt id=hl-12-27><a class=lnlinks href=#hl-12-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs_adjacency_matrix</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    인접 행렬로 표현된 그래프에서 DFS 수행
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        adj_matrix (list of list): 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>        start_vertex (int): 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        list: 방문한 정점들의 순서
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs_recursive</span><span class=p>(</span><span class=n>vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 정점을 방문 처리</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=p>[</span><span class=n>vertex</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 인접한 정점들을 방문</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>vertex</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>dfs_recursive</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dfs_recursive</span><span class=p>(</span><span class=n>start_vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>너비 우선 탐색(BFS)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span><span class=lnt id=hl-13-25><a class=lnlinks href=#hl-13-25>25</a>
</span><span class=lnt id=hl-13-26><a class=lnlinks href=#hl-13-26>26</a>
</span><span class=lnt id=hl-13-27><a class=lnlinks href=#hl-13-27>27</a>
</span><span class=lnt id=hl-13-28><a class=lnlinks href=#hl-13-28>28</a>
</span><span class=lnt id=hl-13-29><a class=lnlinks href=#hl-13-29>29</a>
</span><span class=lnt id=hl-13-30><a class=lnlinks href=#hl-13-30>30</a>
</span><span class=lnt id=hl-13-31><a class=lnlinks href=#hl-13-31>31</a>
</span><span class=lnt id=hl-13-32><a class=lnlinks href=#hl-13-32>32</a>
</span><span class=lnt id=hl-13-33><a class=lnlinks href=#hl-13-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bfs_adjacency_matrix</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    인접 행렬로 표현된 그래프에서 BFS 수행
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        adj_matrix (list of list): 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>        start_vertex (int): 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        list: 방문한 정점들의 순서
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 시작 정점을 큐에 넣고 방문 처리</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>start_vertex</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 큐에서 정점을 하나 꺼내서 결과에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>vertex</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 인접한 정점들을 큐에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>vertex</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>다익스트라(Dijkstra) 알고리즘</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span><span class=lnt id=hl-14-24><a class=lnlinks href=#hl-14-24>24</a>
</span><span class=lnt id=hl-14-25><a class=lnlinks href=#hl-14-25>25</a>
</span><span class=lnt id=hl-14-26><a class=lnlinks href=#hl-14-26>26</a>
</span><span class=lnt id=hl-14-27><a class=lnlinks href=#hl-14-27>27</a>
</span><span class=lnt id=hl-14-28><a class=lnlinks href=#hl-14-28>28</a>
</span><span class=lnt id=hl-14-29><a class=lnlinks href=#hl-14-29>29</a>
</span><span class=lnt id=hl-14-30><a class=lnlinks href=#hl-14-30>30</a>
</span><span class=lnt id=hl-14-31><a class=lnlinks href=#hl-14-31>31</a>
</span><span class=lnt id=hl-14-32><a class=lnlinks href=#hl-14-32>32</a>
</span><span class=lnt id=hl-14-33><a class=lnlinks href=#hl-14-33>33</a>
</span><span class=lnt id=hl-14-34><a class=lnlinks href=#hl-14-34>34</a>
</span><span class=lnt id=hl-14-35><a class=lnlinks href=#hl-14-35>35</a>
</span><span class=lnt id=hl-14-36><a class=lnlinks href=#hl-14-36>36</a>
</span><span class=lnt id=hl-14-37><a class=lnlinks href=#hl-14-37>37</a>
</span><span class=lnt id=hl-14-38><a class=lnlinks href=#hl-14-38>38</a>
</span><span class=lnt id=hl-14-39><a class=lnlinks href=#hl-14-39>39</a>
</span><span class=lnt id=hl-14-40><a class=lnlinks href=#hl-14-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>dijkstra_adjacency_matrix</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    인접 행렬로 표현된 그래프에서 다익스트라 알고리즘 수행
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        adj_matrix (list of list): 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>        start_vertex (int): 시작 정점
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        list: 시작 정점에서 각 정점까지의 최단 거리
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)]</span> <span class=o>*</span> <span class=n>n</span>  <span class=c1># 최단 거리를 저장할 배열</span>
</span></span><span class=line><span class=cl>    <span class=n>distances</span><span class=p>[</span><span class=n>start_vertex</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 시작 정점의 거리는 0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># (현재까지의 거리, 정점) 튜플을 원소로 하는 최소 힙</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>0</span><span class=p>,</span> <span class=n>start_vertex</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 가장 거리가 짧은 정점 선택</span>
</span></span><span class=line><span class=cl>        <span class=n>current_distance</span><span class=p>,</span> <span class=n>current_vertex</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 이미 처리된 정점이면 스킵</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_distance</span> <span class=o>&gt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>current_vertex</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 인접한 정점들의 거리 갱신</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 간선이 존재하는 경우에만 처리</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>current_vertex</span><span class=p>][</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>distance</span> <span class=o>=</span> <span class=n>current_distance</span> <span class=o>+</span> <span class=n>adj_matrix</span><span class=p>[</span><span class=n>current_vertex</span><span class=p>][</span><span class=n>neighbor</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 더 짧은 경로를 발견한 경우 갱신</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>distance</span> <span class=o>&lt;</span> <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>distances</span><span class=p>[</span><span class=n>neighbor</span><span class=p>]</span> <span class=o>=</span> <span class=n>distance</span>
</span></span><span class=line><span class=cl>                    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>priority_queue</span><span class=p>,</span> <span class=p>(</span><span class=n>distance</span><span class=p>,</span> <span class=n>neighbor</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>distances</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=인접-행렬의-실제-활용-사례>인접 행렬의 실제 활용 사례<a hidden class=anchor aria-hidden=true href=#인접-행렬의-실제-활용-사례>#</a></h3><ol><li><p>소셜 네트워크 분석<br>페이스북, 트위터와 같은 소셜 미디어 플랫폼에서는 사용자 간의 관계를 인접 행렬로 표현할 수 있다:</p><ul><li><code>A[i][j] = 1</code>: 사용자 i가 사용자 j를 팔로우하거나 친구인 경우</li><li><code>A[i][j] = 0</code>: 그렇지 않은 경우<br>이를 통해 다음과 같은 분석이 가능하다:</li><li>공통 친구 수 계산 (<code>A²[i][j]</code>)</li><li>영향력 있는 사용자 식별 (중심성 분석)</li><li>커뮤니티 감지 (군집 분석)</li></ul></li><li><p>웹 그래프와 검색 엔진<br>웹 페이지들을 정점으로, 하이퍼링크를 간선으로 표현하는 웹 그래프에서:</p><ul><li>PageRank 알고리즘은 인접 행렬의 고유벡터를 계산하여 페이지의 중요도를 결정한다.</li><li>HITS(Hyperlink-Induced Topic Search) 알고리즘은 인접 행렬과 그 전치 행렬을 사용하여 허브(hub)와 권위(authority) 페이지를 식별한다.</li></ul></li><li><p>네트워크 라우팅<br>컴퓨터 네트워크에서 라우터 간의 연결을 나타내는 인접 행렬:</p><ul><li>플로이드-워셜(Floyd-Warshall) 알고리즘을 사용하여 모든 라우터 쌍 간의 최단 경로를 계산한다.</li><li>스패닝 트리 프로토콜(STP)은 최소 신장 트리를 구성하여 루프를 방지한다.</li></ul></li><li><p>생물학적 네트워크<br>단백질 상호작용 네트워크나 유전자 조절 네트워크:</p><ul><li>인접 행렬을 통해 생물학적 경로와 기능적 모듈을 식별한다.</li><li>네트워크 모티프(motif) 분석을 통해 반복적으로 나타나는 패턴을 찾는다.</li></ul></li></ol><h3 id=인접-행렬-최적화-기법>인접 행렬 최적화 기법<a hidden class=anchor aria-hidden=true href=#인접-행렬-최적화-기법>#</a></h3><ol><li><p>희소 행렬(Sparse Matrix) 표현<br>정점은 많지만 간선이 적은 희소 그래프의 경우, 희소 행렬 자료구조를 사용하여 메모리 사용량을 줄일 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>scipy.sparse</span> <span class=kn>import</span> <span class=n>csr_matrix</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 희소 인접 행렬 생성</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_sparse_adjacency_matrix</span><span class=p>(</span><span class=n>edges</span><span class=p>,</span> <span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    희소 인접 행렬을 생성합니다.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        edges (list of tuple): (시작 정점, 끝 정점, 가중치) 형태의 간선 목록
</span></span></span><span class=line><span class=cl><span class=s2>        num_vertices (int): 정점의 수
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        scipy.sparse.csr_matrix: 희소 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>row</span> <span class=o>=</span> <span class=p>[</span><span class=n>edge</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>col</span> <span class=o>=</span> <span class=p>[</span><span class=n>edge</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=p>[</span><span class=n>edge</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>csr_matrix</span><span class=p>((</span><span class=n>data</span><span class=p>,</span> <span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>)),</span> <span class=n>shape</span><span class=o>=</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>,</span> <span class=n>num_vertices</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>블록 행렬(Block Matrix) 표현<br>큰 그래프를 여러 개의 작은 블록으로 나누어 처리할 수 있다.<br>이는 분산 시스템에서 유용하다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span><span class=lnt id=hl-16-22><a class=lnlinks href=#hl-16-22>22</a>
</span><span class=lnt id=hl-16-23><a class=lnlinks href=#hl-16-23>23</a>
</span><span class=lnt id=hl-16-24><a class=lnlinks href=#hl-16-24>24</a>
</span><span class=lnt id=hl-16-25><a class=lnlinks href=#hl-16-25>25</a>
</span><span class=lnt id=hl-16-26><a class=lnlinks href=#hl-16-26>26</a>
</span><span class=lnt id=hl-16-27><a class=lnlinks href=#hl-16-27>27</a>
</span><span class=lnt id=hl-16-28><a class=lnlinks href=#hl-16-28>28</a>
</span><span class=lnt id=hl-16-29><a class=lnlinks href=#hl-16-29>29</a>
</span><span class=lnt id=hl-16-30><a class=lnlinks href=#hl-16-30>30</a>
</span><span class=lnt id=hl-16-31><a class=lnlinks href=#hl-16-31>31</a>
</span><span class=lnt id=hl-16-32><a class=lnlinks href=#hl-16-32>32</a>
</span><span class=lnt id=hl-16-33><a class=lnlinks href=#hl-16-33>33</a>
</span><span class=lnt id=hl-16-34><a class=lnlinks href=#hl-16-34>34</a>
</span><span class=lnt id=hl-16-35><a class=lnlinks href=#hl-16-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_block_adjacency_matrix</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>,</span> <span class=n>block_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    인접 행렬을 블록 단위로 나눕니다.
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Args:
</span></span></span><span class=line><span class=cl><span class=s2>        adj_matrix (list of list): 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>        block_size (int): 블록의 크기
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    Returns:
</span></span></span><span class=line><span class=cl><span class=s2>        list of list of list: 블록 인접 행렬
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>num_blocks</span> <span class=o>=</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=n>block_size</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=n>block_size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>block_matrix</span> <span class=o>=</span> <span class=p>[[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_blocks</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_blocks</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_blocks</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_blocks</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 블록의 범위 계산</span>
</span></span><span class=line><span class=cl>            <span class=n>row_start</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>block_size</span>
</span></span><span class=line><span class=cl>            <span class=n>row_end</span> <span class=o>=</span> <span class=nb>min</span><span class=p>((</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>block_size</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>col_start</span> <span class=o>=</span> <span class=n>j</span> <span class=o>*</span> <span class=n>block_size</span>
</span></span><span class=line><span class=cl>            <span class=n>col_end</span> <span class=o>=</span> <span class=nb>min</span><span class=p>((</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>block_size</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 블록 생성</span>
</span></span><span class=line><span class=cl>            <span class=n>block</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>row_start</span><span class=p>,</span> <span class=n>row_end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>row</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>c</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>col_start</span><span class=p>,</span> <span class=n>col_end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=n>row</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>adj_matrix</span><span class=p>[</span><span class=n>r</span><span class=p>][</span><span class=n>c</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>block</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>block_matrix</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>block</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>block_matrix</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/graph/>Graph</a></li><li><a href=https://buenhyden.github.io/tags/representation/>Representation</a></li><li><a href=https://buenhyden.github.io/tags/adjacency-matrix/>Adjacency-Matrix</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/tail-recursion/><span class=title>« Prev</span><br><span>꼬리 재귀(Tail Recursion)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/preorder-traversal/><span class=title>Next »</span><br><span>Preorder Traversal</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>