<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Adjacency Matrix vs Adjacency List | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Graph,Representation,Adjacency-Matrix,Adjacency-List"><meta name=description content="간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Adjacency Matrix vs Adjacency List"><meta property="og:description" content="간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-07T15:31:00+00:00"><meta property="article:modified_time" content="2024-12-07T15:31:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Graph"><meta property="article:tag" content="Representation"><meta property="article:tag" content="Adjacency-Matrix"><meta property="article:tag" content="Adjacency-List"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Adjacency Matrix vs Adjacency List"><meta name=twitter:description content="간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Data Structures","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":4,"name":"그래프 (Graph)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/"},{"@type":"ListItem","position":5,"name":"Representation","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/"},{"@type":"ListItem","position":6,"name":"Adjacency Matrix vs Adjacency List","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Adjacency Matrix vs Adjacency List","name":"Adjacency Matrix vs Adjacency List","description":"간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Graph","Representation","Adjacency-Matrix","Adjacency-List"],"articleBody":"그래프 표현 방법: 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List) 비교 그래프는 컴퓨터 과학에서 매우 중요한 자료구조로, 데이터 간의 관계를 효과적으로 표현할 수 있다.\n그래프를 표현하는 방법을 선택할 때는 해결하려는 문제의 특성과 그래프의 구조를 고려해야 한다.\n간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.\n실제로는 두 방법을 혼합하거나 응용한 자료구조를 사용하기도 한다. 많은 실제 응용 사례(소셜 네트워크, 웹 페이지 연결 등)에서는 정점 수에 비해 간선 수가 적은 희소 그래프의 특성을 가지므로 인접 리스트가 더 많이 사용되는 경향이 있다.\n인접 행렬(Adjacency Matrix) 인접 행렬은 2차원 배열을 사용하여 그래프의 연결 관계를 표현하는 방법.\n기본 개념 n개의 정점이 있다면 n×n 크기의 2차원 배열을 생성한다. 행렬의 각 원소 M[i][j]는 정점 i에서 정점 j로 가는 간선이 있으면 1(또는 가중치), 없으면 0을 저장한다. 무방향 그래프의 경우 인접 행렬은 대칭 행렬이 된다. 인접 행렬의 예시 무방향 그래프 (Undirected Graph) 1 2 3 A — B | | C — D 인접 행렬 표현\nA B C D A 0 1 1 0 B 1 0 0 1 C 1 0 0 1 D 0 1 1 0 방향 그래프 (Directed Graph) 1 2 3 A → B ↓ C → D 인접 행렬 표현\nA B C D A 0 1 1 0 B 0 0 0 0 C 0 0 0 1 D 0 0 0 0 구현 예시 (Python) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class GraphMatrix: def __init__(self, num_vertices): self.num_vertices = num_vertices # 모든 값을 0으로 초기화한 2차원 배열 생성 self.matrix = [[0 for _ in range(num_vertices)] for _ in range(num_vertices)] def add_edge(self, v1, v2, weight=1): # 정점 v1에서 v2로 가는 간선 추가 self.matrix[v1][v2] = weight # 무방향 그래프인 경우 양방향 연결 # self.matrix[v2][v1] = weight def remove_edge(self, v1, v2): # 정점 v1에서 v2로 가는 간선 제거 self.matrix[v1][v2] = 0 # 무방향 그래프인 경우 양방향 연결 제거 # self.matrix[v2][v1] = 0 def print_graph(self): for row in self.matrix: print(row) 인접 행렬이 유리한 경우 그래프의 간선 밀도가 높은 경우 (밀집 그래프) 두 정점 간 간선 존재 여부를 자주 확인해야 하는 경우 가중치 정보를 쉽게 표현하고 접근해야 하는 경우 알고리즘이 행렬 연산을 기반으로 하는 경우 (예: 플로이드-워셜 알고리즘) 인접 행렬 활용 분야 플로이드-워셜 알고리즘 (모든 정점 간 최단 경로) 네트워크 연결 상태 분석 이미지 및 그래픽 처리 (픽셀 연결성 분석) 완전 그래프(Complete Graph)처럼 간선이 많은 경우 인접 리스트(Adjacency List) 인접 리스트는 각 정점마다 해당 정점과 인접한 정점들의 리스트를 저장하는 방법이다.\n기본 개념 모든 정점에 대해 해당 정점과 연결된 다른 정점들의 리스트를 유지한다. 정점 수만큼의 리스트 배열이 필요하다. 가중치 그래프의 경우, 연결된 정점과 함께 가중치도 저장한다. 인접 리스트의 예시 무방향 그래프 (Undirected Graph) 1 2 3 A — B | | C — D 인접 리스트 표현\n1 2 3 4 A: B, C B: A, D C: A, D D: B, C 방향 그래프 (Directed Graph) 1 2 3 A → B ↓ C → D 인접 리스트 표현\n1 2 3 4 A: B, C B: C: D D: 구현 예시 (Python) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GraphList: def __init__(self, num_vertices): self.num_vertices = num_vertices # 각 정점마다 빈 리스트 생성 self.adj_list = [[] for _ in range(num_vertices)] def add_edge(self, v1, v2, weight=1): # 정점 v1에서 v2로 가는 간선 추가 (가중치 포함) self.adj_list[v1].append((v2, weight)) # 무방향 그래프인 경우 양방향 연결 # self.adj_list[v2].append((v1, weight)) def remove_edge(self, v1, v2): # v1에서 v2로 가는 간선 제거 self.adj_list[v1] = [(vertex, weight) for vertex, weight in self.adj_list[v1] if vertex != v2] # 무방향 그래프인 경우 v2에서 v1로 가는 간선도 제거 # self.adj_list[v2] = [(vertex, weight) for vertex, weight in self.adj_list[v2] if vertex != v1] def print_graph(self): for i in range(self.num_vertices): print(f\"정점 {i}:\", end=\" \") for j, weight in self.adj_list[i]: print(f\"({j}, 가중치: {weight})\", end=\" \") print() 인접 리스트가 유리한 경우 그래프의 간선 밀도가 낮은 경우 (희소 그래프) 메모리 사용량이 중요한 경우 모든 간선을 순회해야 하는 경우 특정 정점에서 출발하는 모든 간선을 자주 찾아야 하는 경우 그래프 탐색 알고리즘(BFS, DFS)을 구현할 때 인접 리스트 활용 분야 다익스트라 알고리즘 (최단 경로 탐색) 소셜 네트워크 분석 (Facebook, Twitter) 추천 시스템 (Netflix, YouTube) 네트워크 라우팅 (인터넷 패킷 경로 탐색) 웹 크롤링 (페이지 간 링크 분석) 인접 행렬과 인접 리스트 비교 특성 인접 행렬 (Adjacency Matrix) 인접 리스트 (Adjacency List) 메모리 사용량 O(V²) - 정점 수의 제곱에 비례 O(V + E) - 정점 수와 간선 수의 합에 비례 간선 존재 확인 O(1) - 상수 시간 O(degree(V)) - 정점의 차수에 비례 모든 간선 순회 O(V²) - 행렬 전체 순회 필요 O(V + E) - 모든 정점과 간선 순회 특정 정점의 모든 인접 정점 찾기 O(V) - 해당 행 전체 확인 필요 O(degree(V)) - 해당 정점의 리스트만 확인 간선 추가 O(1) - 배열 원소 변경 O(1) - 리스트에 추가 간선 제거 O(1) - 배열 원소 변경 O(degree(V)) - 리스트에서 검색 후 제거 그래프 밀집도에 따른 효율성 밀집 그래프에 효율적 희소 그래프에 효율적 구현 복잡도 간단함 약간 복잡함 공간 효율성 희소 그래프에서 비효율적 메모리 사용이 최적화됨 특정 두 정점 간 연결 확인 O(1) - 즉시 확인 가능 O(degree(V)) - 리스트 검색 필요 그래프 순회 알고리즘 구현 복잡하고 느림 간단하고 빠름 적합한 그래프 유형 작은 그래프, 완전 그래프 큰 그래프, 희소 그래프 웹 그래프와 같은 대규모 그래프 비실용적 실용적 동적 그래프(변화가 많은) 비효율적 효율적 참고 및 출처 ","wordCount":"891","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-07T15:31:00Z","dateModified":"2024-12-07T15:31:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/adjacency-matrix-vs-adjacency-list/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/>그래프 (Graph)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/>Representation</a></div><h1 class="post-title entry-hint-parent">Adjacency Matrix vs Adjacency List</h1><div class=post-description>간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.</div><div class=post-meta><span title='2024-12-07 15:31:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;891 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Data%20Structures/Graph/Representation/adjacency-matrix-vs-adjacency-list.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#그래프-표현-방법-인접-행렬adjacency-matrix과-인접-리스트adjacency-list-비교>그래프 표현 방법: 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List) 비교</a><ul><li><a href=#인접-행렬adjacency-matrix>인접 행렬(Adjacency Matrix)</a></li><li><a href=#인접-리스트adjacency-list>인접 리스트(Adjacency List)</a></li><li><a href=#인접-행렬과-인접-리스트-비교>인접 행렬과 인접 리스트 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=그래프-표현-방법-인접-행렬adjacency-matrix과-인접-리스트adjacency-list-비교>그래프 표현 방법: 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List) 비교<a hidden class=anchor aria-hidden=true href=#그래프-표현-방법-인접-행렬adjacency-matrix과-인접-리스트adjacency-list-비교>#</a></h2><p>그래프는 컴퓨터 과학에서 매우 중요한 자료구조로, 데이터 간의 관계를 효과적으로 표현할 수 있다.</p><p>그래프를 표현하는 방법을 선택할 때는 해결하려는 문제의 특성과 그래프의 구조를 고려해야 한다.</p><ul><li>간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수</li><li>간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.<br>실제로는 두 방법을 혼합하거나 응용한 자료구조를 사용하기도 한다.</li></ul><p>많은 실제 응용 사례(소셜 네트워크, 웹 페이지 연결 등)에서는 정점 수에 비해 간선 수가 적은 희소 그래프의 특성을 가지므로 인접 리스트가 더 많이 사용되는 경향이 있다.</p><h3 id=인접-행렬adjacency-matrix>인접 행렬(Adjacency Matrix)<a hidden class=anchor aria-hidden=true href=#인접-행렬adjacency-matrix>#</a></h3><p>인접 행렬은 2차원 배열을 사용하여 그래프의 연결 관계를 표현하는 방법.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><ul><li>n개의 정점이 있다면 n×n 크기의 2차원 배열을 생성한다.</li><li>행렬의 각 원소 M[i][j]는 정점 i에서 정점 j로 가는 간선이 있으면 1(또는 가중치), 없으면 0을 저장한다.</li><li>무방향 그래프의 경우 인접 행렬은 대칭 행렬이 된다.</li></ul><h4 id=인접-행렬의-예시>인접 행렬의 예시<a hidden class=anchor aria-hidden=true href=#인접-행렬의-예시>#</a></h4><h5 id=무방향-그래프-undirected-graph>무방향 그래프 (Undirected Graph)<a hidden class=anchor aria-hidden=true href=#무방향-그래프-undirected-graph>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  A — B
</span></span><span class=line><span class=cl>  |   |
</span></span><span class=line><span class=cl>  C — D
</span></span></code></pre></td></tr></table></div></div><p><strong>인접 행렬 표현</strong></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>B</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>C</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><h5 id=방향-그래프-directed-graph>방향 그래프 (Directed Graph)<a hidden class=anchor aria-hidden=true href=#방향-그래프-directed-graph>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  A → B
</span></span><span class=line><span class=cl>  ↓   
</span></span><span class=line><span class=cl>  C → D
</span></span></code></pre></td></tr></table></div></div><p><strong>인접 행렬 표현</strong></p><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>A</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>B</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>C</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>D</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id=구현-예시-python>구현 예시 (Python)<a hidden class=anchor aria-hidden=true href=#구현-예시-python>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GraphMatrix</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=o>=</span> <span class=n>num_vertices</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 값을 0으로 초기화한 2차원 배열 생성</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>matrix</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 정점 v1에서 v2로 가는 간선 추가</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>matrix</span><span class=p>[</span><span class=n>v1</span><span class=p>][</span><span class=n>v2</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 무방향 그래프인 경우 양방향 연결</span>
</span></span><span class=line><span class=cl>        <span class=c1># self.matrix[v2][v1] = weight</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>remove_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 정점 v1에서 v2로 가는 간선 제거</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>matrix</span><span class=p>[</span><span class=n>v1</span><span class=p>][</span><span class=n>v2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 무방향 그래프인 경우 양방향 연결 제거</span>
</span></span><span class=line><span class=cl>        <span class=c1># self.matrix[v2][v1] = 0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_graph</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>matrix</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=인접-행렬이-유리한-경우>인접 행렬이 유리한 경우<a hidden class=anchor aria-hidden=true href=#인접-행렬이-유리한-경우>#</a></h4><ol><li>그래프의 간선 밀도가 높은 경우 (밀집 그래프)</li><li>두 정점 간 간선 존재 여부를 자주 확인해야 하는 경우</li><li>가중치 정보를 쉽게 표현하고 접근해야 하는 경우</li><li>알고리즘이 행렬 연산을 기반으로 하는 경우 (예: 플로이드-워셜 알고리즘)</li></ol><h4 id=인접-행렬-활용-분야>인접 행렬 활용 분야<a hidden class=anchor aria-hidden=true href=#인접-행렬-활용-분야>#</a></h4><ul><li><strong>플로이드-워셜 알고리즘 (모든 정점 간 최단 경로)</strong></li><li><strong>네트워크 연결 상태 분석</strong></li><li><strong>이미지 및 그래픽 처리 (픽셀 연결성 분석)</strong></li><li><strong>완전 그래프(Complete Graph)처럼 간선이 많은 경우</strong></li></ul><h3 id=인접-리스트adjacency-list>인접 리스트(Adjacency List)<a hidden class=anchor aria-hidden=true href=#인접-리스트adjacency-list>#</a></h3><p>인접 리스트는 각 정점마다 해당 정점과 인접한 정점들의 리스트를 저장하는 방법이다.</p><h4 id=기본-개념-1>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념-1>#</a></h4><ul><li>모든 정점에 대해 해당 정점과 연결된 다른 정점들의 리스트를 유지한다.</li><li>정점 수만큼의 리스트 배열이 필요하다.</li><li>가중치 그래프의 경우, 연결된 정점과 함께 가중치도 저장한다.</li></ul><h4 id=인접-리스트의-예시>인접 리스트의 예시<a hidden class=anchor aria-hidden=true href=#인접-리스트의-예시>#</a></h4><h5 id=무방향-그래프-undirected-graph-1>무방향 그래프 (Undirected Graph)<a hidden class=anchor aria-hidden=true href=#무방향-그래프-undirected-graph-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  A — B
</span></span><span class=line><span class=cl>  |   |
</span></span><span class=line><span class=cl>  C — D
</span></span></code></pre></td></tr></table></div></div><p><strong>인접 리스트 표현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A: B, C
</span></span><span class=line><span class=cl>B: A, D
</span></span><span class=line><span class=cl>C: A, D
</span></span><span class=line><span class=cl>D: B, C
</span></span></code></pre></td></tr></table></div></div><h5 id=방향-그래프-directed-graph-1>방향 그래프 (Directed Graph)<a hidden class=anchor aria-hidden=true href=#방향-그래프-directed-graph-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  A → B
</span></span><span class=line><span class=cl>  ↓   
</span></span><span class=line><span class=cl>  C → D
</span></span></code></pre></td></tr></table></div></div><p><strong>인접 리스트 표현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>A: B, C
</span></span><span class=line><span class=cl>B: 
</span></span><span class=line><span class=cl>C: D
</span></span><span class=line><span class=cl>D:
</span></span></code></pre></td></tr></table></div></div><h4 id=구현-예시-python-1>구현 예시 (Python)<a hidden class=anchor aria-hidden=true href=#구현-예시-python-1>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>GraphList</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span> <span class=o>=</span> <span class=n>num_vertices</span>
</span></span><span class=line><span class=cl>        <span class=c1># 각 정점마다 빈 리스트 생성</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adj_list</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_vertices</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 정점 v1에서 v2로 가는 간선 추가 (가중치 포함)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adj_list</span><span class=p>[</span><span class=n>v1</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>v2</span><span class=p>,</span> <span class=n>weight</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 무방향 그래프인 경우 양방향 연결</span>
</span></span><span class=line><span class=cl>        <span class=c1># self.adj_list[v2].append((v1, weight))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>remove_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># v1에서 v2로 가는 간선 제거</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adj_list</span><span class=p>[</span><span class=n>v1</span><span class=p>]</span> <span class=o>=</span> <span class=p>[(</span><span class=n>vertex</span><span class=p>,</span> <span class=n>weight</span><span class=p>)</span> <span class=k>for</span> <span class=n>vertex</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>adj_list</span><span class=p>[</span><span class=n>v1</span><span class=p>]</span> <span class=k>if</span> <span class=n>vertex</span> <span class=o>!=</span> <span class=n>v2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 무방향 그래프인 경우 v2에서 v1로 가는 간선도 제거</span>
</span></span><span class=line><span class=cl>        <span class=c1># self.adj_list[v2] = [(vertex, weight) for vertex, weight in self.adj_list[v2] if vertex != v1]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_graph</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>num_vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;정점 </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>:&#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>adj_list</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;(</span><span class=si>{</span><span class=n>j</span><span class=si>}</span><span class=s2>, 가중치: </span><span class=si>{</span><span class=n>weight</span><span class=si>}</span><span class=s2>)&#34;</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=인접-리스트가-유리한-경우>인접 리스트가 유리한 경우<a hidden class=anchor aria-hidden=true href=#인접-리스트가-유리한-경우>#</a></h4><ol><li>그래프의 간선 밀도가 낮은 경우 (희소 그래프)</li><li>메모리 사용량이 중요한 경우</li><li>모든 간선을 순회해야 하는 경우</li><li>특정 정점에서 출발하는 모든 간선을 자주 찾아야 하는 경우</li><li>그래프 탐색 알고리즘(BFS, DFS)을 구현할 때</li></ol><h4 id=인접-리스트-활용-분야>인접 리스트 활용 분야<a hidden class=anchor aria-hidden=true href=#인접-리스트-활용-분야>#</a></h4><ul><li><strong>다익스트라 알고리즘 (최단 경로 탐색)</strong></li><li><strong>소셜 네트워크 분석 (Facebook, Twitter)</strong></li><li><strong>추천 시스템 (Netflix, YouTube)</strong></li><li><strong>네트워크 라우팅 (인터넷 패킷 경로 탐색)</strong></li><li><strong>웹 크롤링 (페이지 간 링크 분석)</strong></li></ul><h3 id=인접-행렬과-인접-리스트-비교>인접 행렬과 인접 리스트 비교<a hidden class=anchor aria-hidden=true href=#인접-행렬과-인접-리스트-비교>#</a></h3><table><thead><tr><th>특성</th><th>인접 행렬 (Adjacency Matrix)</th><th>인접 리스트 (Adjacency List)</th></tr></thead><tbody><tr><td><strong>메모리 사용량</strong></td><td>O(V²) - 정점 수의 제곱에 비례</td><td>O(V + E) - 정점 수와 간선 수의 합에 비례</td></tr><tr><td><strong>간선 존재 확인</strong></td><td>O(1) - 상수 시간</td><td>O(degree(V)) - 정점의 차수에 비례</td></tr><tr><td><strong>모든 간선 순회</strong></td><td>O(V²) - 행렬 전체 순회 필요</td><td>O(V + E) - 모든 정점과 간선 순회</td></tr><tr><td><strong>특정 정점의 모든 인접 정점 찾기</strong></td><td>O(V) - 해당 행 전체 확인 필요</td><td>O(degree(V)) - 해당 정점의 리스트만 확인</td></tr><tr><td><strong>간선 추가</strong></td><td>O(1) - 배열 원소 변경</td><td>O(1) - 리스트에 추가</td></tr><tr><td><strong>간선 제거</strong></td><td>O(1) - 배열 원소 변경</td><td>O(degree(V)) - 리스트에서 검색 후 제거</td></tr><tr><td><strong>그래프 밀집도에 따른 효율성</strong></td><td>밀집 그래프에 효율적</td><td>희소 그래프에 효율적</td></tr><tr><td><strong>구현 복잡도</strong></td><td>간단함</td><td>약간 복잡함</td></tr><tr><td><strong>공간 효율성</strong></td><td>희소 그래프에서 비효율적</td><td>메모리 사용이 최적화됨</td></tr><tr><td><strong>특정 두 정점 간 연결 확인</strong></td><td>O(1) - 즉시 확인 가능</td><td>O(degree(V)) - 리스트 검색 필요</td></tr><tr><td><strong>그래프 순회 알고리즘 구현</strong></td><td>복잡하고 느림</td><td>간단하고 빠름</td></tr><tr><td><strong>적합한 그래프 유형</strong></td><td>작은 그래프, 완전 그래프</td><td>큰 그래프, 희소 그래프</td></tr><tr><td><strong>웹 그래프와 같은 대규모 그래프</strong></td><td>비실용적</td><td>실용적</td></tr><tr><td><strong>동적 그래프(변화가 많은)</strong></td><td>비효율적</td><td>효율적</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/graph/>Graph</a></li><li><a href=https://buenhyden.github.io/tags/representation/>Representation</a></li><li><a href=https://buenhyden.github.io/tags/adjacency-matrix/>Adjacency-Matrix</a></li><li><a href=https://buenhyden.github.io/tags/adjacency-list/>Adjacency-List</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/data-types/object/prototypes/><span class=title>« Prev</span><br><span>Prototypes</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/spanning-tree/><span class=title>Next »</span><br><span>Spanning Tree</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>