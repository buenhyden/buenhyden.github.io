<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linked List vs. Array | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Linked-List,Array"><meta name=description content="배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/linked-list-vs-array/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/linked-list-vs-array/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/linked-list-vs-array/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Linked List vs. Array"><meta property="og:description" content="배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-07T16:32:00+00:00"><meta property="article:modified_time" content="2024-10-07T16:32:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Linked-List"><meta property="article:tag" content="Array"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Linked List vs. Array"><meta name=twitter:description content="배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Data Structures","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":4,"name":"연결 리스트 (Linked List)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/"},{"@type":"ListItem","position":5,"name":"Linked List vs. Array","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/linked-list-vs-array/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linked List vs. Array","name":"Linked List vs. Array","description":"배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Linked-List","Array"],"articleBody":"Array vs. Linked List 데이터 구조는 프로그래밍에서 데이터를 효율적으로 저장하고 관리하기 위한 방법을 제공합니다. 이 중에서도 배열과 연결 리스트는 가장 기본적이면서도 중요한 데이터 구조이다.\n두 구조는 서로 다른 특성과 장단점을 가지고 있어 적절한 상황에 맞게 선택해 사용해야 한다.\n배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.\n반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.\n적절한 상황에 맞는 자료구조 선택은 효율적인 프로그램 개발의 핵심이다. 따라서 문제의 특성과 요구사항을 잘 분석하여 최적의 자료구조를 선택해야 한다. 때로는 두 자료구조의 장점을 결합한 하이브리드 접근 방식이나 다른 고급 자료구조를 활용하는 것이 더 나은 해결책이 될 수도 있다.\n연결 리스트(Linked List) 연결 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성된 선형 데이터 구조이다.\n노드들은 메모리 상에 연속적으로 위치하지 않고, 포인터를 통해 연결된다.\n연결 리스트의 특징\n메모리 구조: 노드들이 메모리상에 불연속적으로 위치한다. 접근 방식: 헤드(시작 노드)부터 순차적으로 탐색해야 한다. 크기: 동적으로 크기가 변할 수 있다. 구성 요소: 각 노드는 데이터와 다음 노드를 가리키는 포인터(및 이전 노드를 가리키는 포인터)로 구성된다. 연결 리스트의 종류\n단일 연결 리스트(Singly Linked List): 각 노드가 다음 노드만을 가리킨다. 이중 연결 리스트(Doubly Linked List): 각 노드가 이전 노드와 다음 노드 모두를 가리킨다. 원형 연결 리스트(Circular Linked List): 마지막 노드가 첫 번째 노드를 가리켜 원형을 형성한다. 연결 리스트의 구현 예제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # Python에서의 단일 연결 리스트 구현 class Node: def __init__(self, data): self.data = data self.next = None class SinglyLinkedList: def __init__(self): self.head = None # 리스트 끝에 노드 추가 def append(self, data): new_node = Node(data) # 리스트가 비어있는 경우 if self.head is None: self.head = new_node return # 마지막 노드 찾기 last = self.head while last.next: last = last.next # 마지막 노드의 다음을 새 노드로 설정 last.next = new_node # 리스트 출력 def print_list(self): current = self.head while current: print(current.data, end=\" -\u003e \") current = current.next print(\"None\") # 연결 리스트 사용 예 linked_list = SinglyLinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) linked_list.print_list() # 출력: 1 -\u003e 2 -\u003e 3 -\u003e None 장점:\n동적 크기 조정 가능 중간 삽입/삭제가 효율적(노드 포인터만 변경) 메모리 사용의 유연성 데이터의 재배치 없이 요소 추가/삭제 가능 단점:\n임의 접근 불가능(순차적 접근 필요) 추가 메모리 사용(포인터 저장 공간 필요) 캐시 지역성 활용이 어려움 역방향 탐색이 어려움(단일 연결 리스트의 경우) 배열(Array) 배열은 같은 타입의 요소들을 연속된 메모리 공간에 저장하는 자료구조이다.\n각 요소는 인덱스를 통해 직접 접근할 수 있다.\n배열의 특징\n메모리 구조: 요소들이 메모리상에 연속적으로 저장된다. 인덱스 접근: 인덱스를 통해 O(1) 시간에 요소에 직접 접근 가능하다. 크기: 많은 언어에서 배열은 생성 시 크기가 고정되며, 변경이 불가능하다(정적 배열). 그러나 동적 배열은 크기가 가변적이다. 데이터 타입: 일반적으로 모든 요소는 동일한 데이터 타입을 가진다. 배열의 종류\n1차원 배열: 하나의 인덱스로 요소에 접근한다. 다차원 배열: 여러 인덱스를 사용하여 요소에 접근한다(예: 행렬). 정적 배열: 크기가 고정된 배열이다. 동적 배열: 크기가 가변적인 배열로, 내부적으로 크기 조정을 자동으로 처리한다. 배열의 구현 예제\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Python에서의 배열 (리스트) 사용 예 # 1차원 배열 생성 arr = [1, 2, 3, 4, 5] # 요소 접근 print(arr[2]) # 출력: 3 # 요소 변경 arr[2] = 10 print(arr) # 출력: [1, 2, 10, 4, 5] # 배열 끝에 요소 추가 arr.append(6) print(arr) # 출력: [1, 2, 10, 4, 5, 6] # 특정 위치에 요소 삽입 arr.insert(1, 7) print(arr) # 출력: [1, 7, 2, 10, 4, 5, 6] # 요소 삭제 arr.remove(10) print(arr) # 출력: [1, 7, 2, 4, 5, 6] 장점:\n인덱스를 통한 빠른 접근(O(1)) 간단한 구현과 사용법 메모리 효율성(연속된 메모리 블록 사용) 캐시 지역성(Cache Locality) 활용으로 성능 향상 단점:\n크기가 고정되어 있는 경우가 많음(정적 배열) 중간 삽입/삭제가 비효율적(O(n)) 크기 조정 시 모든 요소 복사 필요(동적 배열) 메모리 사용의 비효율성(사용하지 않는 공간 발생 가능) 배열과 연결 리스트 비교 분석 특성 배열(Array) 연결 리스트(Linked List) 메모리 할당 연속적 불연속적 크기 대부분 고정(정적 배열) 가변적 메모리 효율성 데이터만 저장(효율적) 데이터 + 포인터 저장(덜 효율적) 요소 접근 인덱스로 직접 접근 O(1) 순차적 접근 O(n) 시작 부분 삽입 O(n) O(1) 끝 부분 삽입 O(1)* O(n)/O(1)** 중간 삽입 O(n) O(n)*** 시작 부분 삭제 O(n) O(1) 끝 부분 삭제 O(1) O(n)/O(1)** 중간 삭제 O(n) O(n)*** 메모리 오버헤드 낮음 높음(포인터 저장) 캐시 지역성 좋음 나쁨 구현 복잡성 간단 상대적으로 복잡 주요 장점 빠른 접근, 간단한 구현 동적 크기, 효율적인 삽입/삭제 주요 단점 크기 제한, 비효율적인 삽입/삭제 느린 접근, 추가 메모리 사용 적합한 사용 사례 임의 접근이 빈번한 경우\n크기가 고정된 경우\n인덱스 기반 연산이 많은 경우 삽입/삭제가 빈번한 경우\n크기가 가변적인 경우\n메모리 할당이 유동적이어야 하는 경우 * 동적 배열의 경우 재할당이 필요할 수 있음\n** 이중 연결 리스트에서 테일 포인터를 사용하는 경우\n*** 위치를 찾는 데 O(n)이 소요되지만, 실제 삽입/삭제 연산은 O(1)\n메모리 사용량 비교 배열과 연결 리스트는 데이터 저장 방식에 따라 메모리 사용 측면에서 상당한 차이를 보인다.\n각각의 자료구조는 할당 방식, 오버헤드, 그리고 동적 확장성 등에서 서로 다른 특성을 가지며, 이를 이해하는 것은 시스템 성능과 메모리 효율을 극대화하는 데 도움이 된다.\n배열의 메모리 사용량\n배열은 연속된 메모리 블록에 요소들을 저장하므로, 각 요소는 자료형에 필요한 만큼의 메모리(예: 정수형의 경우 4바이트)를 정확하게 차지한다. 미리 배열의 크기를 할당하면 추가적인 포인터나 메타데이터 없이 순수 데이터만 저장되므로, 동일한 수의 요소를 저장할 때 최소한의 메모리 오버헤드로 운영된다. 다만, 동적 크기 조정을 지원하는 배열 기반 자료구조(예: Java의 ArrayList)는 요소 추가를 위해 미리 여유 공간을 확보하거나 크기를 재할당할 때 일부 메모리가 낭비될 수 있다. 연결 리스트의 메모리 사용량\n연결 리스트는 각 요소를 노드 단위로 저장하며, 각 노드는 데이터 외에 하나 이상의 포인터(예: 단일 연결 리스트는 다음 노드에 대한 참조, 이중 연결 리스트는 이전과 다음 모두에 대한 참조)를 포함한다. 특히 JVM과 같이 객체 오버헤드가 존재하는 언어에서는 각 노드에 객체 헤더와 메모리 정렬을 위한 추가 바이트가 필요하므로, 단일 연결 리스트의 경우 데이터 하나당 24바이트까지 사용될 수 있다. 결과적으로 동일한 양의 데이터를 저장할 때, 연결 리스트는 배열보다 최소 2배 이상의 메모리를 사용하며, 자바 같은 환경에서는 최대 6배까지 메모리 사용량이 늘어날 수 있다. 특징 배열 (Array) 연결 리스트 (Linked List) 메모리 할당 방식 연속된 메모리 블록에 할당하여 요소별로 정확한 크기만 사용함. 각 요소별로 동적 노드 할당, 데이터와 함께 포인터 및 추가 헤더 오버헤드 발생. 메모리 오버헤드 요소별 오버헤드가 거의 없으며, 동적 배열의 경우 여분 메모리(빈 공간)가 존재할 수 있음. 노드당 데이터 외, 하나 이상의 포인터와 (JVM 등의 경우) 객체 헤더로 인한 추가 오버헤드 발생. 메모리 효율성 고정 크기의 배열은 최소 메모리 사용, 단 데이터 개수가 미리 결정될 때 최적임. 요소 추가 시마다 필요한 만큼의 메모리를 할당하므로 동적 크기 변화에 유리하나, 오버헤드로 인해 메모리 효율성이 낮음. 동적 확장 고려 크기 변경 시 전체 배열 크기 재할당 및 복사 필요, 잘못된 크기 추정 시 메모리 낭비 발생 가능. 요소 삽입/삭제에 유리하며, 필요한 시점에만 메모리를 할당하지만, 많은 포인터 저장으로 전체 메모리 사용량이 증가함. 요약하면, 배열은 일관되고 연속적인 메모리 할당 덕분에 요소 저장에 최소의 오버헤드를 가지며, 메모리 활용 측면에서 효율적이이다. 반면, 연결 리스트는 데이터의 동적 관리와 삽입·삭제가 용이하지만, 각 노드에 추가적인 포인터와 헤더 정보가 포함되므로 같은 데이터를 저장할 때 배열보다 훨씬 많은 메모리를 필요로 한다.\n언제 어떤 자료구조를 사용할까? 배열을 선택해야 할 때\n요소에 빠르게 접근해야 할 때(인덱스 기반 접근) 데이터 크기가 미리 알려져 있고 변경이 적을 때 메모리 사용을 최소화해야 할 때 캐시 효율성이 중요할 때 단순한 데이터 구조가 필요할 때 연결 리스트를 선택해야 할 때\n데이터의 삽입과 삭제가 빈번할 때 데이터의 크기가 동적으로 변할 때 메모리 할당에 제약이 있어 유연성이 필요할 때 요소 접근보다 삽입/삭제 성능이 중요할 때 다른 자료구조(스택, 큐 등)의 기반 구조로 사용할 때 실제 응용 사례 배열 응용 사례\n행렬 연산 및 이미지 처리 해시 테이블의 기반 구조 정렬 알고리즘(퀵 정렬, 병합 정렬 등) 동적 프로그래밍 테이블 캐시 구현 연결 리스트 응용 사례\n스택 및 큐 구현 메모리 관리(메모리 할당 및 가비지 컬렉션) 해시 테이블의 체이닝 방식 그래프의 인접 리스트 표현 LRU(Least Recently Used) 캐시 구현 참고 및 출처 ","wordCount":"1282","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-07T16:32:00Z","dateModified":"2024-10-07T16:32:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/linked-list-vs-array/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/>연결 리스트 (Linked List)</a></div><h1 class="post-title entry-hint-parent">Linked List vs. Array</h1><div class=post-description>배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다. 반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.</div><div class=post-meta><span title='2024-10-07 16:32:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Data%20Structures/Linked%20List/linked-list-vs-array.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#array-vs-linked-list>Array vs. Linked List</a><ul><li><a href=#연결-리스트linked-list>연결 리스트(Linked List)</a></li><li><a href=#배열array>배열(Array)</a></li><li><a href=#배열과-연결-리스트-비교-분석>배열과 연결 리스트 비교 분석</a></li><li><a href=#언제-어떤-자료구조를-사용할까>언제 어떤 자료구조를 사용할까?</a></li><li><a href=#실제-응용-사례>실제 응용 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=array-vs-linked-list>Array vs. Linked List<a hidden class=anchor aria-hidden=true href=#array-vs-linked-list>#</a></h2><p>데이터 구조는 프로그래밍에서 데이터를 효율적으로 저장하고 관리하기 위한 방법을 제공합니다. 이 중에서도 배열과 연결 리스트는 가장 기본적이면서도 중요한 데이터 구조이다.<br>두 구조는 서로 다른 특성과 장단점을 가지고 있어 적절한 상황에 맞게 선택해 사용해야 한다.</p><p>배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.<br>반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.</p><p>적절한 상황에 맞는 자료구조 선택은 효율적인 프로그램 개발의 핵심이다. 따라서 문제의 특성과 요구사항을 잘 분석하여 최적의 자료구조를 선택해야 한다. 때로는 두 자료구조의 장점을 결합한 하이브리드 접근 방식이나 다른 고급 자료구조를 활용하는 것이 더 나은 해결책이 될 수도 있다.</p><h3 id=연결-리스트linked-list>연결 리스트(Linked List)<a hidden class=anchor aria-hidden=true href=#연결-리스트linked-list>#</a></h3><p>연결 리스트는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 구성된 선형 데이터 구조이다.<br>노드들은 메모리 상에 연속적으로 위치하지 않고, 포인터를 통해 연결된다.</p><ol><li><p>연결 리스트의 특징</p><ul><li><strong>메모리 구조</strong>: 노드들이 메모리상에 불연속적으로 위치한다.</li><li><strong>접근 방식</strong>: 헤드(시작 노드)부터 순차적으로 탐색해야 한다.</li><li><strong>크기</strong>: 동적으로 크기가 변할 수 있다.</li><li><strong>구성 요소</strong>: 각 노드는 데이터와 다음 노드를 가리키는 포인터(및 이전 노드를 가리키는 포인터)로 구성된다.</li></ul></li><li><p>연결 리스트의 종류</p><ul><li><strong>단일 연결 리스트(Singly Linked List)</strong>: 각 노드가 다음 노드만을 가리킨다.</li><li><strong>이중 연결 리스트(Doubly Linked List)</strong>: 각 노드가 이전 노드와 다음 노드 모두를 가리킨다.</li><li><strong>원형 연결 리스트(Circular Linked List)</strong>: 마지막 노드가 첫 번째 노드를 가리켜 원형을 형성한다.</li></ul></li><li><p>연결 리스트의 구현 예제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 단일 연결 리스트 구현</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SinglyLinkedList</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 리스트 끝에 노드 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>append</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>new_node</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 리스트가 비어있는 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>head</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 노드 찾기</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>last</span><span class=o>.</span><span class=n>next</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>last</span> <span class=o>=</span> <span class=n>last</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 마지막 노드의 다음을 새 노드로 설정</span>
</span></span><span class=line><span class=cl>        <span class=n>last</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 리스트 출력</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_list</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>head</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; -&gt; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;None&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 연결 리스트 사용 예</span>
</span></span><span class=line><span class=cl><span class=n>linked_list</span> <span class=o>=</span> <span class=n>SinglyLinkedList</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>linked_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>linked_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>linked_list</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>linked_list</span><span class=o>.</span><span class=n>print_list</span><span class=p>()</span>  <span class=c1># 출력: 1 -&gt; 2 -&gt; 3 -&gt; None</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><p><strong>장점:</strong></p><ul><li>동적 크기 조정 가능</li><li>중간 삽입/삭제가 효율적(노드 포인터만 변경)</li><li>메모리 사용의 유연성</li><li>데이터의 재배치 없이 요소 추가/삭제 가능</li></ul><p><strong>단점:</strong></p><ul><li>임의 접근 불가능(순차적 접근 필요)</li><li>추가 메모리 사용(포인터 저장 공간 필요)</li><li>캐시 지역성 활용이 어려움</li><li>역방향 탐색이 어려움(단일 연결 리스트의 경우)</li></ul><h3 id=배열array>배열(Array)<a hidden class=anchor aria-hidden=true href=#배열array>#</a></h3><p>배열은 같은 타입의 요소들을 연속된 메모리 공간에 저장하는 자료구조이다.<br>각 요소는 인덱스를 통해 직접 접근할 수 있다.</p><ol><li><p>배열의 특징</p><ul><li><strong>메모리 구조</strong>: 요소들이 메모리상에 연속적으로 저장된다.</li><li><strong>인덱스 접근</strong>: 인덱스를 통해 O(1) 시간에 요소에 직접 접근 가능하다.</li><li><strong>크기</strong>: 많은 언어에서 배열은 생성 시 크기가 고정되며, 변경이 불가능하다(정적 배열). 그러나 동적 배열은 크기가 가변적이다.</li><li><strong>데이터 타입</strong>: 일반적으로 모든 요소는 동일한 데이터 타입을 가진다.</li></ul></li><li><p>배열의 종류</p><ul><li><strong>1차원 배열</strong>: 하나의 인덱스로 요소에 접근한다.</li><li><strong>다차원 배열</strong>: 여러 인덱스를 사용하여 요소에 접근한다(예: 행렬).</li><li><strong>정적 배열</strong>: 크기가 고정된 배열이다.</li><li><strong>동적 배열</strong>: 크기가 가변적인 배열로, 내부적으로 크기 조정을 자동으로 처리한다.</li></ul></li><li><p>배열의 구현 예제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 배열 (리스트) 사용 예</span>
</span></span><span class=line><span class=cl><span class=c1># 1차원 배열 생성</span>
</span></span><span class=line><span class=cl><span class=n>arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 요소 접근</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>])</span>  <span class=c1># 출력: 3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 요소 변경</span>
</span></span><span class=line><span class=cl><span class=n>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>  <span class=c1># 출력: [1, 2, 10, 4, 5]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 배열 끝에 요소 추가</span>
</span></span><span class=line><span class=cl><span class=n>arr</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>  <span class=c1># 출력: [1, 2, 10, 4, 5, 6]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 특정 위치에 요소 삽입</span>
</span></span><span class=line><span class=cl><span class=n>arr</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>  <span class=c1># 출력: [1, 7, 2, 10, 4, 5, 6]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 요소 삭제</span>
</span></span><span class=line><span class=cl><span class=n>arr</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span>  <span class=c1># 출력: [1, 7, 2, 4, 5, 6]</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><p><strong>장점:</strong></p><ul><li>인덱스를 통한 빠른 접근(O(1))</li><li>간단한 구현과 사용법</li><li>메모리 효율성(연속된 메모리 블록 사용)</li><li>캐시 지역성(Cache Locality) 활용으로 성능 향상</li></ul><p><strong>단점:</strong></p><ul><li>크기가 고정되어 있는 경우가 많음(정적 배열)</li><li>중간 삽입/삭제가 비효율적(O(n))</li><li>크기 조정 시 모든 요소 복사 필요(동적 배열)</li><li>메모리 사용의 비효율성(사용하지 않는 공간 발생 가능)</li></ul><h3 id=배열과-연결-리스트-비교-분석>배열과 연결 리스트 비교 분석<a hidden class=anchor aria-hidden=true href=#배열과-연결-리스트-비교-분석>#</a></h3><table><thead><tr><th>특성</th><th>배열(Array)</th><th>연결 리스트(Linked List)</th></tr></thead><tbody><tr><td><strong>메모리 할당</strong></td><td>연속적</td><td>불연속적</td></tr><tr><td><strong>크기</strong></td><td>대부분 고정(정적 배열)</td><td>가변적</td></tr><tr><td><strong>메모리 효율성</strong></td><td>데이터만 저장(효율적)</td><td>데이터 + 포인터 저장(덜 효율적)</td></tr><tr><td><strong>요소 접근</strong></td><td>인덱스로 직접 접근 O(1)</td><td>순차적 접근 O(n)</td></tr><tr><td><strong>시작 부분 삽입</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>끝 부분 삽입</strong></td><td>O(1)*</td><td>O(n)/O(1)**</td></tr><tr><td><strong>중간 삽입</strong></td><td>O(n)</td><td>O(n)***</td></tr><tr><td><strong>시작 부분 삭제</strong></td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>끝 부분 삭제</strong></td><td>O(1)</td><td>O(n)/O(1)**</td></tr><tr><td><strong>중간 삭제</strong></td><td>O(n)</td><td>O(n)***</td></tr><tr><td><strong>메모리 오버헤드</strong></td><td>낮음</td><td>높음(포인터 저장)</td></tr><tr><td><strong>캐시 지역성</strong></td><td>좋음</td><td>나쁨</td></tr><tr><td><strong>구현 복잡성</strong></td><td>간단</td><td>상대적으로 복잡</td></tr><tr><td><strong>주요 장점</strong></td><td>빠른 접근, 간단한 구현</td><td>동적 크기, 효율적인 삽입/삭제</td></tr><tr><td><strong>주요 단점</strong></td><td>크기 제한, 비효율적인 삽입/삭제</td><td>느린 접근, 추가 메모리 사용</td></tr><tr><td><strong>적합한 사용 사례</strong></td><td>임의 접근이 빈번한 경우<br>크기가 고정된 경우<br>인덱스 기반 연산이 많은 경우</td><td>삽입/삭제가 빈번한 경우<br>크기가 가변적인 경우<br>메모리 할당이 유동적이어야 하는 경우</td></tr></tbody></table><p>* 동적 배열의 경우 재할당이 필요할 수 있음<br>** 이중 연결 리스트에서 테일 포인터를 사용하는 경우<br>*** 위치를 찾는 데 O(n)이 소요되지만, 실제 삽입/삭제 연산은 O(1)</p><h4 id=메모리-사용량-비교>메모리 사용량 비교<a hidden class=anchor aria-hidden=true href=#메모리-사용량-비교>#</a></h4><p>배열과 연결 리스트는 데이터 저장 방식에 따라 메모리 사용 측면에서 상당한 차이를 보인다.<br>각각의 자료구조는 할당 방식, 오버헤드, 그리고 동적 확장성 등에서 서로 다른 특성을 가지며, 이를 이해하는 것은 시스템 성능과 메모리 효율을 극대화하는 데 도움이 된다.</p><ol><li><p>배열의 메모리 사용량</p><ul><li>배열은 <strong>연속된 메모리 블록</strong>에 요소들을 저장하므로, 각 요소는 자료형에 필요한 만큼의 메모리(예: 정수형의 경우 4바이트)를 정확하게 차지한다.</li><li>미리 배열의 크기를 할당하면 추가적인 포인터나 메타데이터 없이 순수 데이터만 저장되므로, 동일한 수의 요소를 저장할 때 최소한의 메모리 오버헤드로 운영된다.</li><li>다만, 동적 크기 조정을 지원하는 배열 기반 자료구조(예: Java의 <code>ArrayList</code>)는 요소 추가를 위해 미리 여유 공간을 확보하거나 크기를 재할당할 때 일부 메모리가 낭비될 수 있다.</li></ul></li><li><p>연결 리스트의 메모리 사용량</p><ul><li>연결 리스트는 각 요소를 <strong>노드 단위</strong>로 저장하며, 각 노드는 데이터 외에 하나 이상의 포인터(예: 단일 연결 리스트는 다음 노드에 대한 참조, 이중 연결 리스트는 이전과 다음 모두에 대한 참조)를 포함한다.</li><li>특히 JVM과 같이 객체 오버헤드가 존재하는 언어에서는 각 노드에 객체 헤더와 메모리 정렬을 위한 추가 바이트가 필요하므로, 단일 연결 리스트의 경우 데이터 하나당 24바이트까지 사용될 수 있다.</li><li>결과적으로 동일한 양의 데이터를 저장할 때, 연결 리스트는 배열보다 최소 2배 이상의 메모리를 사용하며, 자바 같은 환경에서는 최대 6배까지 메모리 사용량이 늘어날 수 있다.</li></ul></li></ol><table><thead><tr><th>특징</th><th>배열 (Array)</th><th>연결 리스트 (Linked List)</th></tr></thead><tbody><tr><td><strong>메모리 할당 방식</strong></td><td>연속된 메모리 블록에 할당하여 요소별로 정확한 크기만 사용함.</td><td>각 요소별로 동적 노드 할당, 데이터와 함께 포인터 및 추가 헤더 오버헤드 발생.</td></tr><tr><td><strong>메모리 오버헤드</strong></td><td>요소별 오버헤드가 거의 없으며, 동적 배열의 경우 여분 메모리(빈 공간)가 존재할 수 있음.</td><td>노드당 데이터 외, 하나 이상의 포인터와 (JVM 등의 경우) 객체 헤더로 인한 추가 오버헤드 발생.</td></tr><tr><td><strong>메모리 효율성</strong></td><td>고정 크기의 배열은 최소 메모리 사용, 단 데이터 개수가 미리 결정될 때 최적임.</td><td>요소 추가 시마다 필요한 만큼의 메모리를 할당하므로 동적 크기 변화에 유리하나, 오버헤드로 인해 메모리 효율성이 낮음.</td></tr><tr><td><strong>동적 확장 고려</strong></td><td>크기 변경 시 전체 배열 크기 재할당 및 복사 필요, 잘못된 크기 추정 시 메모리 낭비 발생 가능.</td><td>요소 삽입/삭제에 유리하며, 필요한 시점에만 메모리를 할당하지만, 많은 포인터 저장으로 전체 메모리 사용량이 증가함.</td></tr></tbody></table><p>요약하면, 배열은 일관되고 연속적인 메모리 할당 덕분에 요소 저장에 최소의 오버헤드를 가지며, 메모리 활용 측면에서 효율적이이다. 반면, 연결 리스트는 데이터의 동적 관리와 삽입·삭제가 용이하지만, 각 노드에 추가적인 포인터와 헤더 정보가 포함되므로 같은 데이터를 저장할 때 배열보다 훨씬 많은 메모리를 필요로 한다.</p><h3 id=언제-어떤-자료구조를-사용할까>언제 어떤 자료구조를 사용할까?<a hidden class=anchor aria-hidden=true href=#언제-어떤-자료구조를-사용할까>#</a></h3><ol><li><p>배열을 선택해야 할 때</p><ul><li>요소에 빠르게 접근해야 할 때(인덱스 기반 접근)</li><li>데이터 크기가 미리 알려져 있고 변경이 적을 때</li><li>메모리 사용을 최소화해야 할 때</li><li>캐시 효율성이 중요할 때</li><li>단순한 데이터 구조가 필요할 때</li></ul></li><li><p>연결 리스트를 선택해야 할 때</p><ul><li>데이터의 삽입과 삭제가 빈번할 때</li><li>데이터의 크기가 동적으로 변할 때</li><li>메모리 할당에 제약이 있어 유연성이 필요할 때</li><li>요소 접근보다 삽입/삭제 성능이 중요할 때</li><li>다른 자료구조(스택, 큐 등)의 기반 구조로 사용할 때</li></ul></li></ol><h3 id=실제-응용-사례>실제 응용 사례<a hidden class=anchor aria-hidden=true href=#실제-응용-사례>#</a></h3><ol><li><p>배열 응용 사례</p><ul><li>행렬 연산 및 이미지 처리</li><li>해시 테이블의 기반 구조</li><li>정렬 알고리즘(퀵 정렬, 병합 정렬 등)</li><li>동적 프로그래밍 테이블</li><li>캐시 구현</li></ul></li><li><p>연결 리스트 응용 사례</p><ul><li>스택 및 큐 구현</li><li>메모리 관리(메모리 할당 및 가비지 컬렉션)</li><li>해시 테이블의 체이닝 방식</li><li>그래프의 인접 리스트 표현</li><li>LRU(Least Recently Used) 캐시 구현</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/linked-list/>Linked-List</a></li><li><a href=https://buenhyden.github.io/tags/array/>Array</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/complex/skip-list/><span class=title>« Prev</span><br><span>Skip List</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science/computer-system/computer-architecture/components/memory/memory-protection-and-safety/><span class=title>Next »</span><br><span>메모리 보호와 안전 (Memory Protection and Safety)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>