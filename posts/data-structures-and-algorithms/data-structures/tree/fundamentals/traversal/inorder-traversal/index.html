<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Inorder Traversal | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Tree,Fundamentals,Traversal,Inorder-Traversal"><meta name=description content="왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/inorder-traversal/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/inorder-traversal/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/inorder-traversal/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Inorder Traversal"><meta property="og:description" content="왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-06T09:59:00+00:00"><meta property="article:modified_time" content="2024-12-06T09:59:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Tree"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Traversal"><meta property="article:tag" content="Inorder-Traversal"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Inorder Traversal"><meta name=twitter:description content="왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Data Structures","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":4,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/"},{"@type":"ListItem","position":5,"name":"Fundamentals of Tree","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/"},{"@type":"ListItem","position":6,"name":"Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/"},{"@type":"ListItem","position":7,"name":"Inorder Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/inorder-traversal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Inorder Traversal","name":"Inorder Traversal","description":"왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Tree","Fundamentals","Traversal","Inorder-Traversal"],"articleBody":"중위 순회(Inorder Traversal) 중위 순회(Inorder Traversal)는 트리 자료구조, 특히 이진 트리를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나이다. 이 순회 방식은 특유의 방문 순서 때문에 특별한 의미와 활용 가치를 지니고 있다.\n왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.\n이진 검색 트리에서 중위 순회를 수행하면 노드 값이 오름차순으로 방문되는 특성은 검색, 삽입, 삭제, 범위 쿼리 등 많은 작업에서 핵심적인 역할을 한다. 또한 표현식 트리에서 중위 표기법을 생성하거나 트리의 유효성을 검사하는 데에도 널리 사용된다.\n재귀적 구현이 가장 간단하고 직관적이지만, 스택을 사용한 반복적 구현이나 모리스 순회와 같은 최적화된 알고리즘을 통해 성능과 공간 효율성을 개선할 수 있다.\n중위 순회의 기본 개념 중위 순회는 이진 트리를 탐색할 때 다음과 같은 순서로 노드를 방문하는 방법이다:\n왼쪽 서브트리를 중위 순회한다. 현재 노드(루트)를 방문한다. 오른쪽 서브트리를 중위 순회한다. “중위(Inorder)“라는 이름은 현재 노드가 왼쪽과 오른쪽 서브트리 “사이(in order)“에 방문된다는 의미를 담고 있다. 이 순회 방식은 깊이 우선 탐색(DFS)의 한 형태로, 트리의 가장 왼쪽 노드부터 시작하여 점차 오른쪽으로 이동하는 특성을 가진다.\n중위 순회의 알고리즘 아래 이진 트리를 예로 들어 중위 순회 과정을 단계별로 살펴보면:\n1 / \\ 2 3 / \\ / \\ 4 5 6 7 중위 순회 순서: 4 → 2 → 5 → 1 → 6 → 3 → 7\n이 순서를 단계별로 설명하면:\n가장 왼쪽 경로를 따라 내려가 노드 4에 도달한다. 노드 4를 방문한다 (왼쪽 자식이 없음). 노드 4의 부모인 노드 2로 돌아가 방문한다. 노드 2의 오른쪽 자식인 노드 5를 방문한다. 노드 5의 부모의 부모인 노드 1로 돌아가 방문한다. 노드 1의 오른쪽 서브트리로 이동하여 노드 6, 3, 7을 순서대로 방문한다. A / \\ B C / \\ \\ D E F 중위 순회(Inorder Traversal)의 과정은 다음과 같다.\nD 방문 (B의 왼쪽 자식) → 출력: D B 방문 (B의 루트) → 출력: D B E 방문 (B의 오른쪽 자식) → 출력: D B E A 방문 (A의 루트) → 출력: D B E A C 방문 (A의 오른쪽 자식) → 출력: D B E A C F 방문 (C의 오른쪽 자식) → 출력: D B E A C F 재귀적 구현 중위 순회의 재귀적 구현은 직관적이고 간결하다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Node: def __init__(self, value): self.value = value self.left = None self.right = None def inorder_traversal(node): if node is None: return # 왼쪽 서브트리 탐색 inorder_traversal(node.left) # 현재 노드 방문 print(node.value, end=\" \") # 오른쪽 서브트리 탐색 inorder_traversal(node.right) # 트리 생성 root = Node('A') root.left = Node('B') root.right = Node('C') root.left.left = Node('D') root.left.right = Node('E') root.right.right = Node('F') # 중위 순회 실행 inorder_traversal(root) 실행결과\nD B E A C F 반복적(비재귀적) 구현 스택을 사용한 반복적 구현도 가능하다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def inorder_traversal_iterative(root): stack = [] current = root while True: if current is not None: stack.append(current) current = current.left # 왼쪽 서브트리 탐색 elif stack: current = stack.pop() print(current.value, end=\" \") # 현재 노드 방문 current = current.right # 오른쪽 서브트리 탐색 else: break # 실행 inorder_traversal_iterative(root) 실행 결과\nD B E A C F 이 알고리즘은 먼저 현재 노드부터 시작하여 왼쪽 자식 노드를 따라 내려가며 모든 노드를 스택에 추가한다.\n그런 다음 스택에서 노드를 꺼내서 방문하고, 오른쪽 자식으로 이동하여 프로세스를 반복한다.\n다양한 트리 구조에서의 중위 순회 이진 검색 트리(Binary Search Tree)\n이진 검색 트리는 각 노드에 대해 왼쪽 서브트리의 모든 노드 값이 현재 노드보다 작고, 오른쪽 서브트리의 모든 노드 값이 현재 노드보다 큰 특성을 가진 이진 트리이다.\n8 / \\ 3 10 / \\ \\ 1 6 14 / \\ / 4 7 13 중위 순회 순서: 1 → 3 → 4 → 6 → 7 → 8 → 10 → 13 → 14\n이진 검색 트리에서 중위 순회를 수행하면 노드 값이 정렬된 순서로 방문된다. 이 특성은 정렬된 배열이 필요한 많은 알고리즘에서 활용된다.\n편향 트리(Skewed Tree)\n한쪽으로만 자식 노드가 있는 트리이다.\n왼쪽 편향 트리:\n1 / 2 / 3 / 4 중위 순회 순서: 4 → 3 → 2 → 1\n오른쪽 편향 트리:\n1 \\ 2 \\ 3 \\ 4 중위 순회 순서: 1 → 2 → 3 → 4\n완전 이진 트리(Complete Binary Tree)\n완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 채워진 트리이다.\n1 / \\ 2 3 / \\ / 4 5 6 중위 순회 순서: 4 → 2 → 5 → 1 → 6 → 3\n중위 순회의 활용 사례 이진 검색 트리 검증\n이진 검색 트리의 유효성을 검사할 때 중위 순회가 유용하다.\n중위 순회 결과가 오름차순으로 정렬되어 있다면 유효한 이진 검색 트리이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def is_valid_bst(root): prev = [float('-inf')] # 이전 값을 추적하기 위한 리스트 def inorder(node): if not node: return True # 왼쪽 서브트리 검사 if not inorder(node.left): return False # 현재 노드 값 검사 if node.value \u003c= prev[0]: return False prev[0] = node.value # 오른쪽 서브트리 검사 return inorder(node.right) return inorder(root) 중위 표기법 생성\n표현식 트리에서 중위 순회를 수행하면 중위 표기법(infix notation)의 수식을 얻을 수 있다.\n중위 표기법은 우리가 일상적으로 사용하는 수식 표기법이다(예: a + b * c).\n+ / \\ a * / \\ b c 중위 순회 결과: a + b * c\n이진 검색 트리에서의 검색, 삽입, 삭제\n이진 검색 트리에서 중위 순회는 정렬된 데이터를 얻는 데 사용된다.\n이는 범위 쿼리(range query)나 정렬된 데이터가 필요한 작업에 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def kth_smallest(root, k): \"\"\"이진 검색 트리에서 k번째로 작은 요소를 찾습니다.\"\"\" count = [0] result = [None] def inorder(node): if not node or count[0] \u003e= k: return inorder(node.left) count[0] += 1 if count[0] == k: result[0] = node.value return inorder(node.right) inorder(root) return result[0] 모리스 중위 순회(Morris Inorder Traversal)\n모리스 순회는 추가 공간을 사용하지 않고(O(1) 공간 복잡도) 트리를 순회하는 고급 기법이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def morris_inorder_traversal(root): result = [] current = root while current: if not current.left: # 왼쪽 자식이 없으면 현재 노드를 방문하고 오른쪽으로 이동 result.append(current.value) current = current.right else: # 중위 순회에서 현재 노드의 선행자(왼쪽 서브트리에서 가장 오른쪽 노드) 찾기 predecessor = current.left while predecessor.right and predecessor.right != current: predecessor = predecessor.right if not predecessor.right: # 선행자의 오른쪽이 없으면 현재 노드로 연결하고 왼쪽으로 이동 predecessor.right = current current = current.left else: # 선행자의 오른쪽이 현재 노드를 가리키면 그 연결을 끊고 현재 노드를 방문한 후 오른쪽으로 이동 predecessor.right = None result.append(current.value) current = current.right return result 이 알고리즘은 트리의 구조를 일시적으로 수정하여 스택이나 재귀 없이 순회를 가능하게 한다.\n중위 순회의 시간 및 공간 복잡도 시간 복잡도\n중위 순회는 트리의 모든 노드를 한 번씩 방문하므로 시간 복잡도는 O(n)이다. 여기서 n은 트리의 노드 수이다.\n공간 복잡도\n재귀적 구현: 재귀 호출 스택의 크기는 트리의 높이 h에 비례하므로 공간 복잡도는 O(h)이다. 최악의 경우(편향 트리)에는 O(n)이 될 수 있다. 반복적 구현: 명시적 스택을 사용하는 경우에도 공간 복잡도는 O(h)이다. 마찬가지로 최악의 경우에는 O(n)이 될 수 있다. 모리스 순회: 추가 공간을 사용하지 않으므로 공간 복잡도는 O(1)이다. 중위 순회와 다른 순회 방법 비교 중위 순회 vs 전위 순회(Preorder Traversal)\n중위 순회: 왼쪽 → 루트 → 오른쪽 전위 순회: 루트 → 왼쪽 → 오른쪽\n전위 순회는 루트 노드를 먼저 방문하므로 트리의 복제나 전위 표기법 생성에 유용하다. 중위 순회 vs 후위 순회(Postorder Traversal)\n중위 순회: 왼쪽 → 루트 → 오른쪽 후위 순회: 왼쪽 → 오른쪽 → 루트\n후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하므로 트리 삭제나 후위 표기법 생성에 유용하다. 중위 순회 vs 레벨 순회(Level Order Traversal)\n중위 순회: 깊이 우선(DFS) 방식으로 왼쪽 가지를 먼저 완전히 탐색한다. 레벨 순회: 너비 우선(BFS) 방식으로 각 레벨의 노드를 순서대로 방문한다.\n레벨 순회는 트리의 레벨별 특성을 분석하거나 최단 경로 문제에 유용합니다. 실제 코드 예제: 이진 트리의 중위 순회 구현 아래는 Python으로 이진 트리 노드 클래스와 중위 순회 메서드를 구현한 예제:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def inorder_traversal_recursive(root): result = [] def dfs(node): if not node: return # 왼쪽 서브트리 순회 dfs(node.left) # 현재 노드 방문 result.append(node.value) # 오른쪽 서브트리 순회 dfs(node.right) dfs(root) return result def inorder_traversal_iterative(root): result = [] stack = [] current = root while current or stack: # 왼쪽 경로의 모든 노드를 스택에 추가 while current: stack.append(current) current = current.left # 스택에서 노드를 꺼내서 방문 current = stack.pop() result.append(current.value) # 오른쪽 자식으로 이동 current = current.right return result # 다음과 같은 이진 트리 생성: # 1 # / \\ # 2 3 # / \\ / \\ # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # 재귀적 방법으로 중위 순회 print(\"재귀적 중위 순회:\", inorder_traversal_recursive(root)) # [4, 2, 5, 1, 6, 3, 7] # 반복적 방법으로 중위 순회 print(\"반복적 중위 순회:\", inorder_traversal_iterative(root)) # [4, 2, 5, 1, 6, 3, 7] 중위 순회의 응용 문제 이진 검색 트리의 두 노드 값 교환 복구\n이진 검색 트리에서 두 노드의 값이 실수로 교환되었을 때, 트리를 복구하는 문제이다.\n중위 순회를 사용하면 값이 정렬되지 않은 노드를 찾을 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def recover_bst(root): first = second = prev = None def inorder(node): nonlocal first, second, prev if not node: return # 왼쪽 서브트리 순회 inorder(node.left) # 현재 노드 검사 if prev and prev.value \u003e node.value: if not first: first = prev second = node prev = node # 오른쪽 서브트리 순회 inorder(node.right) inorder(root) # 발견한 두 노드의 값 교환 first.value, second.value = second.value, first.value 중위 순회 결과로부터 트리 재구성\n중위 순회의 결과와 전위 순회의 결과가 주어졌을 때, 원래 이진 트리를 재구성하는 문제이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def build_tree(inorder, preorder): if not inorder or not preorder: return None # 전위 순회의 첫 번째 요소는 루트 root_value = preorder[0] root = TreeNode(root_value) # 중위 순회에서 루트의 위치 찾기 root_index = inorder.index(root_value) # 왼쪽 서브트리와 오른쪽 서브트리로 분할 root.left = build_tree(inorder[:root_index], preorder[1:1+root_index]) root.right = build_tree(inorder[root_index+1:], preorder[1+root_index:]) return root 중위 순회의 고급 응용 중위 순회를 사용한 이진 트리 균형 검사\n이진 검색 트리가 균형 잡혀 있는지 검사하는 방법 중 하나는 중위 순회를 사용하는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def is_balanced(root): balanced = [True] def get_height(node): if not node or not balanced[0]: return 0 left_height = get_height(node.left) right_height = get_height(node.right) # 왼쪽과 오른쪽 서브트리의 높이 차이가 1보다 크면 균형이 맞지 않음 if abs(left_height - right_height) \u003e 1: balanced[0] = False return max(left_height, right_height) + 1 get_height(root) return balanced[0] 중위 순회를 사용한 스레드 이진 트리(Threaded Binary Tree) 구현\n스레드 이진 트리는 null 포인터를 사용하는 대신 중위 순회에서 선행자나 후속자를 가리키는 “스레드\"를 사용하여 공간을 절약하는 특수한 이진 트리이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class ThreadedTreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None self.is_threaded_right = False # 오른쪽 포인터가 스레드인지 여부 def create_inorder_threaded_tree(root): if not root: return prev = [None] def inorder(node): if not node: return # 왼쪽 서브트리 순회 inorder(node.left) # 이전 노드의 오른쪽이 없으면 현재 노드를 가리키는 스레드 생성 if prev[0] and not prev[0].right: prev[0].right = node prev[0].is_threaded_right = True prev[0] = node # 오른쪽 서브트리 순회 if not node.is_threaded_right: inorder(node.right) inorder(root) 트리 순회의 실제 응용 사례 컴파일러에서의 표현식 파싱\n컴파일러에서 중위 표기법으로 작성된 표현식을 파싱할 때 중위 순회가 사용된다.\n표현식은 구문 분석 트리(parse tree)로 변환된 후, 중위 순회를 통해 원래 표현식을 재구성하거나 다른 표기법으로 변환할 수 있다.\n데이터베이스 인덱싱\nB-트리나 B+ 트리와 같은 자기 균형 이진 검색 트리는 데이터베이스 시스템의 인덱싱에 널리 사용된다.\n이러한 트리의 중위 순회는 정렬된 순서로 레코드를 검색하는 데 사용된다.\n기계 학습에서의 결정 트리\n결정 트리 알고리즘에서 트리 구조를 시각화하거나 규칙을 추출할 때 중위 순회가 사용될 수 있다.\n중위 순회의 변형 역중위 순회(Reverse Inorder Traversal)\n역중위 순회는 오른쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 왼쪽 서브트리를 방문한다. 이진 검색 트리에서 역중위 순회를 수행하면 노드 값이 내림차순으로 방문된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def reverse_inorder_traversal(root): result = [] def dfs(node): if not node: return # 오른쪽 서브트리 순회 dfs(node.right) # 현재 노드 방문 result.append(node.value) # 왼쪽 서브트리 순회 dfs(node.left) dfs(root) return result 대칭 중위 순회(Symmetric Inorder Traversal)\n대칭 중위 순회는 트리의 대칭성을 검사하는 데 사용된다. 왼쪽 서브트리는 중위 순회로, 오른쪽 서브트리는 역중위 순회로 방문하여 결과를 비교한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def is_symmetric(root): if not root: return True def is_mirror(left, right): if not left and not right: return True if not left or not right: return False return (left.value == right.value and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)) return is_mirror(root.left, root.right) 중위 순회를 사용한 실제 문제 해결 예시 이진 검색 트리의 범위 합(Range Sum) 주어진 범위 [low, high] 내에 있는 이진 검색 트리의 모든 노드 값의 합을 구하는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def range_sum_bst(root, low, high): result = [0] def inorder(node): if not node: return # 현재 노드 값이 low보다 크거나 같으면 왼쪽 서브트리 탐색 if node.value \u003e= low: inorder(node.left) # 현재 노드 값이 범위 내에 있으면 결과에 추가 if low \u003c= node.value \u003c= high: result[0] += node.value # 현재 노드 값이 high보다 작거나 같으면 오른쪽 서브트리 탐색 if node.value \u003c= high: inorder(node.right) inorder(root) return result[0] 이 문제는 중위 순회의 특성을 활용하여 효율적으로 해결할 수 있다.\n불필요한 서브트리 탐색을 피하기 위해 현재 노드 값을 범위와 비교하여 조건부로 탐색한다.\n참고 및 출처 ","wordCount":"2355","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-06T09:59:00Z","dateModified":"2024-12-06T09:59:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/inorder-traversal/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/>Fundamentals of Tree</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/fundamentals/traversal/>Traversal</a></div><h1 class="post-title entry-hint-parent">Inorder Traversal</h1><div class=post-description>왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.</div><div class=post-meta><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Data%20Structures/Tree/Fundamentals/Traversal/inorder-traversal.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#중위-순회inorder-traversal>중위 순회(Inorder Traversal)</a><ul><li><a href=#중위-순회의-기본-개념>중위 순회의 기본 개념</a></li><li><a href=#중위-순회의-알고리즘>중위 순회의 알고리즘</a></li><li><a href=#다양한-트리-구조에서의-중위-순회>다양한 트리 구조에서의 중위 순회</a></li><li><a href=#중위-순회의-활용-사례>중위 순회의 활용 사례</a></li><li><a href=#중위-순회의-시간-및-공간-복잡도>중위 순회의 시간 및 공간 복잡도</a></li><li><a href=#중위-순회와-다른-순회-방법-비교>중위 순회와 다른 순회 방법 비교</a></li><li><a href=#실제-코드-예제-이진-트리의-중위-순회-구현>실제 코드 예제: 이진 트리의 중위 순회 구현</a></li><li><a href=#중위-순회의-응용-문제>중위 순회의 응용 문제</a></li><li><a href=#중위-순회의-고급-응용>중위 순회의 고급 응용</a></li><li><a href=#트리-순회의-실제-응용-사례>트리 순회의 실제 응용 사례</a></li><li><a href=#중위-순회의-변형>중위 순회의 변형</a></li><li><a href=#중위-순회를-사용한-실제-문제-해결-예시>중위 순회를 사용한 실제 문제 해결 예시</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=중위-순회inorder-traversal>중위 순회(Inorder Traversal)<a hidden class=anchor aria-hidden=true href=#중위-순회inorder-traversal>#</a></h2><p>중위 순회(Inorder Traversal)는 트리 자료구조, 특히 이진 트리를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나이다.
이 순회 방식은 특유의 방문 순서 때문에 특별한 의미와 활용 가치를 지니고 있다.</p><p>왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.</p><p>이진 검색 트리에서 중위 순회를 수행하면 노드 값이 오름차순으로 방문되는 특성은 검색, 삽입, 삭제, 범위 쿼리 등 많은 작업에서 핵심적인 역할을 한다. 또한 표현식 트리에서 중위 표기법을 생성하거나 트리의 유효성을 검사하는 데에도 널리 사용된다.</p><p>재귀적 구현이 가장 간단하고 직관적이지만, 스택을 사용한 반복적 구현이나 모리스 순회와 같은 최적화된 알고리즘을 통해 성능과 공간 효율성을 개선할 수 있다.</p><h3 id=중위-순회의-기본-개념>중위 순회의 기본 개념<a hidden class=anchor aria-hidden=true href=#중위-순회의-기본-개념>#</a></h3><p>중위 순회는 이진 트리를 탐색할 때 다음과 같은 순서로 노드를 방문하는 방법이다:</p><ol><li>왼쪽 서브트리를 중위 순회한다.</li><li>현재 노드(루트)를 방문한다.</li><li>오른쪽 서브트리를 중위 순회한다.</li></ol><p>&ldquo;중위(Inorder)&ldquo;라는 이름은 현재 노드가 왼쪽과 오른쪽 서브트리 &ldquo;사이(in order)&ldquo;에 방문된다는 의미를 담고 있다. 이 순회 방식은 깊이 우선 탐색(DFS)의 한 형태로, 트리의 가장 왼쪽 노드부터 시작하여 점차 오른쪽으로 이동하는 특성을 가진다.</p><h3 id=중위-순회의-알고리즘>중위 순회의 알고리즘<a hidden class=anchor aria-hidden=true href=#중위-순회의-알고리즘>#</a></h3><p>아래 이진 트리를 예로 들어 중위 순회 과정을 단계별로 살펴보면:</p><pre class=mermaid>       1
     /   \
    2     3
   / \   / \
  4   5 6   7
</pre><p>중위 순회 순서: 4 → 2 → 5 → 1 → 6 → 3 → 7</p><p>이 순서를 단계별로 설명하면:</p><ol><li>가장 왼쪽 경로를 따라 내려가 노드 4에 도달한다.</li><li>노드 4를 방문한다 (왼쪽 자식이 없음).</li><li>노드 4의 부모인 노드 2로 돌아가 방문한다.</li><li>노드 2의 오른쪽 자식인 노드 5를 방문한다.</li><li>노드 5의 부모의 부모인 노드 1로 돌아가 방문한다.</li><li>노드 1의 오른쪽 서브트리로 이동하여 노드 6, 3, 7을 순서대로 방문한다.</li></ol><pre class=mermaid>        A
       / \
      B   C
     / \   \
    D   E   F
</pre><p><strong>중위 순회(Inorder Traversal)의 과정</strong>은 다음과 같다.</p><ol><li><strong>D 방문</strong> (B의 왼쪽 자식) → 출력: <code>D</code></li><li><strong>B 방문</strong> (B의 루트) → 출력: <code>D B</code></li><li><strong>E 방문</strong> (B의 오른쪽 자식) → 출력: <code>D B E</code></li><li><strong>A 방문</strong> (A의 루트) → 출력: <code>D B E A</code></li><li><strong>C 방문</strong> (A의 오른쪽 자식) → 출력: <code>D B E A C</code></li><li><strong>F 방문</strong> (C의 오른쪽 자식) → 출력: <code>D B E A C F</code></li></ol><h4 id=재귀적-구현>재귀적 구현<a hidden class=anchor aria-hidden=true href=#재귀적-구현>#</a></h4><p>중위 순회의 재귀적 구현은 직관적이고 간결하다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>    <span class=n>inorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드 방문</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>    <span class=n>inorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 트리 생성</span>
</span></span><span class=line><span class=cl><span class=n>root</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;C&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;D&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;E&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>Node</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 중위 순회 실행</span>
</span></span><span class=line><span class=cl><span class=n>inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>실행결과</p><pre class=mermaid>D B E A C F
</pre><h4 id=반복적비재귀적-구현>반복적(비재귀적) 구현<a hidden class=anchor aria-hidden=true href=#반복적비재귀적-구현>#</a></h4><p>스택을 사용한 반복적 구현도 가능하다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>  <span class=c1># 왼쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>  <span class=c1># 현재 노드 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>  <span class=c1># 오른쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행</span>
</span></span><span class=line><span class=cl><span class=n>inorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>실행 결과</p><pre class=mermaid>D B E A C F
</pre><p>이 알고리즘은 먼저 현재 노드부터 시작하여 왼쪽 자식 노드를 따라 내려가며 모든 노드를 스택에 추가한다.<br>그런 다음 스택에서 노드를 꺼내서 방문하고, 오른쪽 자식으로 이동하여 프로세스를 반복한다.</p><h3 id=다양한-트리-구조에서의-중위-순회>다양한 트리 구조에서의 중위 순회<a hidden class=anchor aria-hidden=true href=#다양한-트리-구조에서의-중위-순회>#</a></h3><ol><li><p>이진 검색 트리(Binary Search Tree)<br>이진 검색 트리는 각 노드에 대해 왼쪽 서브트리의 모든 노드 값이 현재 노드보다 작고, 오른쪽 서브트리의 모든 노드 값이 현재 노드보다 큰 특성을 가진 이진 트리이다.</p><pre class=mermaid>       8
     /   \
    3    10
   / \     \
  1   6    14
     / \   /
    4   7 13
</pre><p>중위 순회 순서: 1 → 3 → 4 → 6 → 7 → 8 → 10 → 13 → 14</p><p>이진 검색 트리에서 중위 순회를 수행하면 노드 값이 정렬된 순서로 방문된다. 이 특성은 정렬된 배열이 필요한 많은 알고리즘에서 활용된다.</p></li><li><p>편향 트리(Skewed Tree)<br>한쪽으로만 자식 노드가 있는 트리이다.</p><p>왼쪽 편향 트리:</p><pre class=mermaid>  1
 /
2
/
3
/
4
</pre><p>중위 순회 순서: 4 → 3 → 2 → 1</p><p>오른쪽 편향 트리:</p><pre class=mermaid>1
 \
  2
   \
    3
     \
      4
</pre><p>중위 순회 순서: 1 → 2 → 3 → 4</p></li><li><p>완전 이진 트리(Complete Binary Tree)<br>완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 채워진 트리이다.</p><pre class=mermaid>       1
     /   \
    2     3
   / \   / 
  4   5 6   
</pre><p>중위 순회 순서: 4 → 2 → 5 → 1 → 6 → 3</p></li></ol><h3 id=중위-순회의-활용-사례>중위 순회의 활용 사례<a hidden class=anchor aria-hidden=true href=#중위-순회의-활용-사례>#</a></h3><ol><li><p>이진 검색 트리 검증<br>이진 검색 트리의 유효성을 검사할 때 중위 순회가 유용하다.<br>중위 순회 결과가 오름차순으로 정렬되어 있다면 유효한 이진 검색 트리이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_valid_bst</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)]</span>  <span class=c1># 이전 값을 추적하기 위한 리스트</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 값 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&lt;=</span> <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>중위 표기법 생성<br>표현식 트리에서 중위 순회를 수행하면 중위 표기법(infix notation)의 수식을 얻을 수 있다.<br>중위 표기법은 우리가 일상적으로 사용하는 수식 표기법이다(예: a + b * c).</p><pre class=mermaid>    +
   / \
  a   *
     / \
    b   c
</pre><p>중위 순회 결과: a + b * c</p></li><li><p>이진 검색 트리에서의 검색, 삽입, 삭제<br>이진 검색 트리에서 중위 순회는 정렬된 데이터를 얻는 데 사용된다.<br>이는 범위 쿼리(range query)나 정렬된 데이터가 필요한 작업에 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>kth_smallest</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;이진 검색 트리에서 k번째로 작은 요소를 찾습니다.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>count</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span> <span class=ow>or</span> <span class=n>count</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>count</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>모리스 중위 순회(Morris Inorder Traversal)<br>모리스 순회는 추가 공간을 사용하지 않고(O(1) 공간 복잡도) 트리를 순회하는 고급 기법이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span><span class=lnt id=hl-13-25><a class=lnlinks href=#hl-13-25>25</a>
</span><span class=lnt id=hl-13-26><a class=lnlinks href=#hl-13-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>morris_inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 왼쪽 자식이 없으면 현재 노드를 방문하고 오른쪽으로 이동</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 중위 순회에서 현재 노드의 선행자(왼쪽 서브트리에서 가장 오른쪽 노드) 찾기</span>
</span></span><span class=line><span class=cl>            <span class=n>predecessor</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=ow>and</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=o>!=</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span> <span class=o>=</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 선행자의 오른쪽이 없으면 현재 노드로 연결하고 왼쪽으로 이동</span>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>current</span>
</span></span><span class=line><span class=cl>                <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 선행자의 오른쪽이 현재 노드를 가리키면 그 연결을 끊고 현재 노드를 방문한 후 오른쪽으로 이동</span>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 트리의 구조를 일시적으로 수정하여 스택이나 재귀 없이 순회를 가능하게 한다.</p></li></ol><h3 id=중위-순회의-시간-및-공간-복잡도>중위 순회의 시간 및 공간 복잡도<a hidden class=anchor aria-hidden=true href=#중위-순회의-시간-및-공간-복잡도>#</a></h3><ol><li><p>시간 복잡도<br>중위 순회는 트리의 모든 노드를 한 번씩 방문하므로 시간 복잡도는 O(n)이다. 여기서 n은 트리의 노드 수이다.</p></li><li><p>공간 복잡도</p><ul><li><strong>재귀적 구현</strong>: 재귀 호출 스택의 크기는 트리의 높이 h에 비례하므로 공간 복잡도는 O(h)이다. 최악의 경우(편향 트리)에는 O(n)이 될 수 있다.</li><li><strong>반복적 구현</strong>: 명시적 스택을 사용하는 경우에도 공간 복잡도는 O(h)이다. 마찬가지로 최악의 경우에는 O(n)이 될 수 있다.</li><li><strong>모리스 순회</strong>: 추가 공간을 사용하지 않으므로 공간 복잡도는 O(1)이다.</li></ul></li></ol><h3 id=중위-순회와-다른-순회-방법-비교>중위 순회와 다른 순회 방법 비교<a hidden class=anchor aria-hidden=true href=#중위-순회와-다른-순회-방법-비교>#</a></h3><ol><li><p>중위 순회 vs 전위 순회(Preorder Traversal)</p><ul><li><strong>중위 순회</strong>: 왼쪽 → 루트 → 오른쪽</li><li><strong>전위 순회</strong>: 루트 → 왼쪽 → 오른쪽<br>전위 순회는 루트 노드를 먼저 방문하므로 트리의 복제나 전위 표기법 생성에 유용하다.</li></ul></li><li><p>중위 순회 vs 후위 순회(Postorder Traversal)</p><ul><li><strong>중위 순회</strong>: 왼쪽 → 루트 → 오른쪽</li><li><strong>후위 순회</strong>: 왼쪽 → 오른쪽 → 루트<br>후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하므로 트리 삭제나 후위 표기법 생성에 유용하다.</li></ul></li><li><p>중위 순회 vs 레벨 순회(Level Order Traversal)</p><ul><li><strong>중위 순회</strong>: 깊이 우선(DFS) 방식으로 왼쪽 가지를 먼저 완전히 탐색한다.</li><li><strong>레벨 순회</strong>: 너비 우선(BFS) 방식으로 각 레벨의 노드를 순서대로 방문한다.<br>레벨 순회는 트리의 레벨별 특성을 분석하거나 최단 경로 문제에 유용합니다.</li></ul></li></ol><h3 id=실제-코드-예제-이진-트리의-중위-순회-구현>실제 코드 예제: 이진 트리의 중위 순회 구현<a hidden class=anchor aria-hidden=true href=#실제-코드-예제-이진-트리의-중위-순회-구현>#</a></h3><p>아래는 Python으로 이진 트리 노드 클래스와 중위 순회 메서드를 구현한 예제:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span><span class=lnt id=hl-14-24><a class=lnlinks href=#hl-14-24>24</a>
</span><span class=lnt id=hl-14-25><a class=lnlinks href=#hl-14-25>25</a>
</span><span class=lnt id=hl-14-26><a class=lnlinks href=#hl-14-26>26</a>
</span><span class=lnt id=hl-14-27><a class=lnlinks href=#hl-14-27>27</a>
</span><span class=lnt id=hl-14-28><a class=lnlinks href=#hl-14-28>28</a>
</span><span class=lnt id=hl-14-29><a class=lnlinks href=#hl-14-29>29</a>
</span><span class=lnt id=hl-14-30><a class=lnlinks href=#hl-14-30>30</a>
</span><span class=lnt id=hl-14-31><a class=lnlinks href=#hl-14-31>31</a>
</span><span class=lnt id=hl-14-32><a class=lnlinks href=#hl-14-32>32</a>
</span><span class=lnt id=hl-14-33><a class=lnlinks href=#hl-14-33>33</a>
</span><span class=lnt id=hl-14-34><a class=lnlinks href=#hl-14-34>34</a>
</span><span class=lnt id=hl-14-35><a class=lnlinks href=#hl-14-35>35</a>
</span><span class=lnt id=hl-14-36><a class=lnlinks href=#hl-14-36>36</a>
</span><span class=lnt id=hl-14-37><a class=lnlinks href=#hl-14-37>37</a>
</span><span class=lnt id=hl-14-38><a class=lnlinks href=#hl-14-38>38</a>
</span><span class=lnt id=hl-14-39><a class=lnlinks href=#hl-14-39>39</a>
</span><span class=lnt id=hl-14-40><a class=lnlinks href=#hl-14-40>40</a>
</span><span class=lnt id=hl-14-41><a class=lnlinks href=#hl-14-41>41</a>
</span><span class=lnt id=hl-14-42><a class=lnlinks href=#hl-14-42>42</a>
</span><span class=lnt id=hl-14-43><a class=lnlinks href=#hl-14-43>43</a>
</span><span class=lnt id=hl-14-44><a class=lnlinks href=#hl-14-44>44</a>
</span><span class=lnt id=hl-14-45><a class=lnlinks href=#hl-14-45>45</a>
</span><span class=lnt id=hl-14-46><a class=lnlinks href=#hl-14-46>46</a>
</span><span class=lnt id=hl-14-47><a class=lnlinks href=#hl-14-47>47</a>
</span><span class=lnt id=hl-14-48><a class=lnlinks href=#hl-14-48>48</a>
</span><span class=lnt id=hl-14-49><a class=lnlinks href=#hl-14-49>49</a>
</span><span class=lnt id=hl-14-50><a class=lnlinks href=#hl-14-50>50</a>
</span><span class=lnt id=hl-14-51><a class=lnlinks href=#hl-14-51>51</a>
</span><span class=lnt id=hl-14-52><a class=lnlinks href=#hl-14-52>52</a>
</span><span class=lnt id=hl-14-53><a class=lnlinks href=#hl-14-53>53</a>
</span><span class=lnt id=hl-14-54><a class=lnlinks href=#hl-14-54>54</a>
</span><span class=lnt id=hl-14-55><a class=lnlinks href=#hl-14-55>55</a>
</span><span class=lnt id=hl-14-56><a class=lnlinks href=#hl-14-56>56</a>
</span><span class=lnt id=hl-14-57><a class=lnlinks href=#hl-14-57>57</a>
</span><span class=lnt id=hl-14-58><a class=lnlinks href=#hl-14-58>58</a>
</span><span class=lnt id=hl-14-59><a class=lnlinks href=#hl-14-59>59</a>
</span><span class=lnt id=hl-14-60><a class=lnlinks href=#hl-14-60>60</a>
</span><span class=lnt id=hl-14-61><a class=lnlinks href=#hl-14-61>61</a>
</span><span class=lnt id=hl-14-62><a class=lnlinks href=#hl-14-62>62</a>
</span><span class=lnt id=hl-14-63><a class=lnlinks href=#hl-14-63>63</a>
</span><span class=lnt id=hl-14-64><a class=lnlinks href=#hl-14-64>64</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>TreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>left</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>right</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal_recursive</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>current</span> <span class=ow>or</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 경로의 모든 노드를 스택에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 스택에서 노드를 꺼내서 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 자식으로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 다음과 같은 이진 트리 생성:</span>
</span></span><span class=line><span class=cl><span class=c1>#       1</span>
</span></span><span class=line><span class=cl><span class=c1>#     /   \</span>
</span></span><span class=line><span class=cl><span class=c1>#    2     3</span>
</span></span><span class=line><span class=cl><span class=c1>#   / \   / \</span>
</span></span><span class=line><span class=cl><span class=c1>#  4   5 6   7</span>
</span></span><span class=line><span class=cl><span class=n>root</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 재귀적 방법으로 중위 순회</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;재귀적 중위 순회:&#34;</span><span class=p>,</span> <span class=n>inorder_traversal_recursive</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>  <span class=c1># [4, 2, 5, 1, 6, 3, 7]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 반복적 방법으로 중위 순회</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;반복적 중위 순회:&#34;</span><span class=p>,</span> <span class=n>inorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>  <span class=c1># [4, 2, 5, 1, 6, 3, 7]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=중위-순회의-응용-문제>중위 순회의 응용 문제<a hidden class=anchor aria-hidden=true href=#중위-순회의-응용-문제>#</a></h3><ol><li><p>이진 검색 트리의 두 노드 값 교환 복구<br>이진 검색 트리에서 두 노드의 값이 실수로 교환되었을 때, 트리를 복구하는 문제이다.<br>중위 순회를 사용하면 값이 정렬되지 않은 노드를 찾을 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span><span class=lnt id=hl-15-20><a class=lnlinks href=#hl-15-20>20</a>
</span><span class=lnt id=hl-15-21><a class=lnlinks href=#hl-15-21>21</a>
</span><span class=lnt id=hl-15-22><a class=lnlinks href=#hl-15-22>22</a>
</span><span class=lnt id=hl-15-23><a class=lnlinks href=#hl-15-23>23</a>
</span><span class=lnt id=hl-15-24><a class=lnlinks href=#hl-15-24>24</a>
</span><span class=lnt id=hl-15-25><a class=lnlinks href=#hl-15-25>25</a>
</span><span class=lnt id=hl-15-26><a class=lnlinks href=#hl-15-26>26</a>
</span><span class=lnt id=hl-15-27><a class=lnlinks href=#hl-15-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>recover_bst</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>first</span> <span class=o>=</span> <span class=n>second</span> <span class=o>=</span> <span class=n>prev</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>nonlocal</span> <span class=n>first</span><span class=p>,</span> <span class=n>second</span><span class=p>,</span> <span class=n>prev</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 검사</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>prev</span> <span class=ow>and</span> <span class=n>prev</span><span class=o>.</span><span class=n>value</span> <span class=o>&gt;</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>first</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>first</span> <span class=o>=</span> <span class=n>prev</span>
</span></span><span class=line><span class=cl>            <span class=n>second</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>prev</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 발견한 두 노드의 값 교환</span>
</span></span><span class=line><span class=cl>    <span class=n>first</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>second</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>second</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>first</span><span class=o>.</span><span class=n>value</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>중위 순회 결과로부터 트리 재구성<br>중위 순회의 결과와 전위 순회의 결과가 주어졌을 때, 원래 이진 트리를 재구성하는 문제이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>build_tree</span><span class=p>(</span><span class=n>inorder</span><span class=p>,</span> <span class=n>preorder</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>inorder</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>preorder</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 전위 순회의 첫 번째 요소는 루트</span>
</span></span><span class=line><span class=cl>    <span class=n>root_value</span> <span class=o>=</span> <span class=n>preorder</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>root_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 중위 순회에서 루트의 위치 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>root_index</span> <span class=o>=</span> <span class=n>inorder</span><span class=o>.</span><span class=n>index</span><span class=p>(</span><span class=n>root_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리와 오른쪽 서브트리로 분할</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>build_tree</span><span class=p>(</span><span class=n>inorder</span><span class=p>[:</span><span class=n>root_index</span><span class=p>],</span> <span class=n>preorder</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>1</span><span class=o>+</span><span class=n>root_index</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>build_tree</span><span class=p>(</span><span class=n>inorder</span><span class=p>[</span><span class=n>root_index</span><span class=o>+</span><span class=mi>1</span><span class=p>:],</span> <span class=n>preorder</span><span class=p>[</span><span class=mi>1</span><span class=o>+</span><span class=n>root_index</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>root</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=중위-순회의-고급-응용>중위 순회의 고급 응용<a hidden class=anchor aria-hidden=true href=#중위-순회의-고급-응용>#</a></h3><ol><li><p>중위 순회를 사용한 이진 트리 균형 검사<br>이진 검색 트리가 균형 잡혀 있는지 검사하는 방법 중 하나는 중위 순회를 사용하는 것이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_balanced</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>balanced</span> <span class=o>=</span> <span class=p>[</span><span class=kc>True</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_height</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>balanced</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>left_height</span> <span class=o>=</span> <span class=n>get_height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>right_height</span> <span class=o>=</span> <span class=n>get_height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽과 오른쪽 서브트리의 높이 차이가 1보다 크면 균형이 맞지 않음</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>abs</span><span class=p>(</span><span class=n>left_height</span> <span class=o>-</span> <span class=n>right_height</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>balanced</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_height</span><span class=p>,</span> <span class=n>right_height</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>get_height</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>balanced</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>중위 순회를 사용한 스레드 이진 트리(Threaded Binary Tree) 구현<br>스레드 이진 트리는 null 포인터를 사용하는 대신 중위 순회에서 선행자나 후속자를 가리키는 &ldquo;스레드"를 사용하여 공간을 절약하는 특수한 이진 트리이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>ThreadedTreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=o>=</span><span class=mi>0</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>is_threaded_right</span> <span class=o>=</span> <span class=kc>False</span>  <span class=c1># 오른쪽 포인터가 스레드인지 여부</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>create_inorder_threaded_tree</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 이전 노드의 오른쪽이 없으면 현재 노드를 가리키는 스레드 생성</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>            <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>.</span><span class=n>is_threaded_right</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>prev</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>is_threaded_right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=트리-순회의-실제-응용-사례>트리 순회의 실제 응용 사례<a hidden class=anchor aria-hidden=true href=#트리-순회의-실제-응용-사례>#</a></h3><ol><li><p>컴파일러에서의 표현식 파싱<br>컴파일러에서 중위 표기법으로 작성된 표현식을 파싱할 때 중위 순회가 사용된다.<br>표현식은 구문 분석 트리(parse tree)로 변환된 후, 중위 순회를 통해 원래 표현식을 재구성하거나 다른 표기법으로 변환할 수 있다.</p></li><li><p>데이터베이스 인덱싱<br>B-트리나 B+ 트리와 같은 자기 균형 이진 검색 트리는 데이터베이스 시스템의 인덱싱에 널리 사용된다.<br>이러한 트리의 중위 순회는 정렬된 순서로 레코드를 검색하는 데 사용된다.</p></li><li><p>기계 학습에서의 결정 트리<br>결정 트리 알고리즘에서 트리 구조를 시각화하거나 규칙을 추출할 때 중위 순회가 사용될 수 있다.</p></li></ol><h3 id=중위-순회의-변형>중위 순회의 변형<a hidden class=anchor aria-hidden=true href=#중위-순회의-변형>#</a></h3><ol><li><p>역중위 순회(Reverse Inorder Traversal)<br>역중위 순회는 오른쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 왼쪽 서브트리를 방문한다. 이진 검색 트리에서 역중위 순회를 수행하면 노드 값이 내림차순으로 방문된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span><span class=lnt id=hl-19-15><a class=lnlinks href=#hl-19-15>15</a>
</span><span class=lnt id=hl-19-16><a class=lnlinks href=#hl-19-16>16</a>
</span><span class=lnt id=hl-19-17><a class=lnlinks href=#hl-19-17>17</a>
</span><span class=lnt id=hl-19-18><a class=lnlinks href=#hl-19-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>reverse_inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>대칭 중위 순회(Symmetric Inorder Traversal)<br>대칭 중위 순회는 트리의 대칭성을 검사하는 데 사용된다. 왼쪽 서브트리는 중위 순회로, 오른쪽 서브트리는 역중위 순회로 방문하여 결과를 비교한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_symmetric</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>is_mirror</span><span class=p>(</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>left</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>left</span> <span class=ow>or</span> <span class=ow>not</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>left</span><span class=o>.</span><span class=n>value</span> <span class=o>==</span> <span class=n>right</span><span class=o>.</span><span class=n>value</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>                <span class=n>is_mirror</span><span class=p>(</span><span class=n>left</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=o>.</span><span class=n>right</span><span class=p>)</span> <span class=ow>and</span>
</span></span><span class=line><span class=cl>                <span class=n>is_mirror</span><span class=p>(</span><span class=n>left</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>right</span><span class=o>.</span><span class=n>left</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>is_mirror</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=중위-순회를-사용한-실제-문제-해결-예시>중위 순회를 사용한 실제 문제 해결 예시<a hidden class=anchor aria-hidden=true href=#중위-순회를-사용한-실제-문제-해결-예시>#</a></h3><h4 id=이진-검색-트리의-범위-합range-sum>이진 검색 트리의 범위 합(Range Sum)<a hidden class=anchor aria-hidden=true href=#이진-검색-트리의-범위-합range-sum>#</a></h4><p>주어진 범위 [low, high] 내에 있는 이진 검색 트리의 모든 노드 값의 합을 구하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19>19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20>20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>range_sum_bst</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>low</span><span class=p>,</span> <span class=n>high</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 값이 low보다 크거나 같으면 왼쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&gt;=</span> <span class=n>low</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 값이 범위 내에 있으면 결과에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>low</span> <span class=o>&lt;=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+=</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 값이 high보다 작거나 같으면 오른쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>&lt;=</span> <span class=n>high</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 문제는 중위 순회의 특성을 활용하여 효율적으로 해결할 수 있다.<br>불필요한 서브트리 탐색을 피하기 위해 현재 노드 값을 범위와 비교하여 조건부로 탐색한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/tree/>Tree</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/traversal/>Traversal</a></li><li><a href=https://buenhyden.github.io/tags/inorder-traversal/>Inorder-Traversal</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/types/non-tail-recursion/><span class=title>« Prev</span><br><span>비꼬리 재귀(Non-tail Recursion)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/low-level-virtual-machine/><span class=title>Next »</span><br><span>Low-Level Virtual Machine</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>