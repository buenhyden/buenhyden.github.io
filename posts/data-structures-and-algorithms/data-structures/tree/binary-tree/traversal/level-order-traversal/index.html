<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Level Order Traversal | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Tree,Binary-Tree,Traversal,Level-Order-Traversal"><meta name=description content="레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/level-order-traversal/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/level-order-traversal/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/level-order-traversal/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Level Order Traversal"><meta property="og:description" content="레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-06T09:59:00+00:00"><meta property="article:modified_time" content="2024-12-06T09:59:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Tree"><meta property="article:tag" content="Binary-Tree"><meta property="article:tag" content="Traversal"><meta property="article:tag" content="Level-Order-Traversal"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Level Order Traversal"><meta name=twitter:description content="레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structure and Algorithm","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Data Structures","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":4,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/"},{"@type":"ListItem","position":5,"name":"이진 트리 (Binary Tree)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/"},{"@type":"ListItem","position":6,"name":"Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/"},{"@type":"ListItem","position":7,"name":"Level Order Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/level-order-traversal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Level Order Traversal","name":"Level Order Traversal","description":"레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Tree","Binary-Tree","Traversal","Level-Order-Traversal"],"articleBody":"레벨 순서 순회 (Level Order Traversal) 트리 자료구조에서 레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.\n이 순회 방식은 너비 우선 탐색(Breadth-First Search, BFS)의 일종으로 볼 수 있다.\n레벨 순서 순회는 트리를 레벨별로 탐색하는 강력한 기법이다.\n큐를 사용한 반복적 접근법이 가장 효율적인 구현 방식이며, 다양한 트리 문제를 해결하는 데 활용할 수 있다.\n특히 트리의 구조적 특성을 분석하거나 레벨별 작업을 수행할 때 매우 유용하다.\n레벨 순서 순회의 개념 트리에서 레벨이란 루트 노드로부터의 거리를 의미한다:\n레벨 0: 루트 노드 레벨 1: 루트 노드의 자식 노드들 레벨 2: 레벨 1 노드들의 자식 노드들 이런 식으로 계속된다.\n레벨 순서 순회는 모든 레벨 0 노드(루트)를 방문한 다음, 모든 레벨 1 노드, 모든 레벨 2 노드… 식으로 진행된다. 레벨 순서 순회의 구현 방법 레벨 순서 순회를 구현하는 가장 일반적인 방법은 큐(Queue) 자료구조를 사용하는 것이다.\n알고리즘은 다음과 같다:\n루트 노드를 큐에 넣는다. 큐가 비어있지 않은 동안: 큐에서 노드를 하나 꺼낸다. 해당 노드를 방문(처리)한다. 해당 노드의 모든 자식 노드를 큐에 넣는다(보통 왼쪽에서 오른쪽 순서로). 파이썬으로 구현한 레벨 순서 순회 다음은 이진 트리에서의 레벨 순서 순회를 파이썬으로 구현한 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root): if not root: return [] result = [] # 결과를 저장할 리스트 queue = deque([root]) # 큐 초기화: 루트 노드로 시작 while queue: level_size = len(queue) # 현재 레벨의 노드 수 current_level = [] # 현재 레벨의 노드 값들을 저장 for _ in range(level_size): node = queue.popleft() # 큐에서 첫 번째 노드를 꺼냄 current_level.append(node.val) # 현재 노드 값을 현재 레벨 리스트에 추가 # 왼쪽 자식이 있으면 큐에 추가 if node.left: queue.append(node.left) # 오른쪽 자식이 있으면 큐에 추가 if node.right: queue.append(node.right) result.append(current_level) # 현재 레벨의 노드 값들을 결과 리스트에 추가 return result # 트리 생성 예시: # 1 # / \\ # 2 3 # / \\ \\ # 4 5 6 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) # 레벨 순서 순회 실행 print(levelOrderTraversal(root)) # 출력: [[1], [2, 3], [4, 5, 6]] 이 코드는 각 레벨의 노드들을 별도의 하위 리스트로 구분하여 반환한다.\n출력 결과인 [[1], [2, 3], [4, 5, 6]]는 레벨 0에 노드 1, 레벨 1에 노드 2와 3, 레벨 2에 노드 4, 5, 6이 있음을 보여준다.\n레벨 순서 순회의 활용 레벨 순서 순회는 다음과 같은 상황에서 유용하다:\n트리의 너비 계산: 각 레벨의 노드 수를 세어 트리의 최대 너비를 계산할 수 있다. 트리의 높이 계산: 레벨 순서 순회로 방문한 레벨의 수가 트리의 높이가 된다. 특정 레벨의 노드 찾기: 특정 레벨의 모든 노드를 쉽게 식별할 수 있다. 이진 트리가 완전 이진 트리(Complete Binary Tree)인지 확인: 레벨 순서 순회를 사용하여 빈 자리가 있는지 검사할 수 있다. 다른 구현 방식: 재귀를 사용한 레벨 순서 순회 재귀를 사용하여 레벨 순서 순회를 구현할 수도 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def levelOrderTraversalRecursive(root): if not root: return [] result = [] def height(node): if not node: return 0 return max(height(node.left), height(node.right)) + 1 def getCurrentLevel(node, level): if not node: return if level == 1: result.append(node.val) elif level \u003e 1: getCurrentLevel(node.left, level - 1) getCurrentLevel(node.right, level - 1) h = height(root) for i in range(1, h + 1): getCurrentLevel(root, i) return result # 위의 트리 예시를 사용하여 실행 print(levelOrderTraversalRecursive(root)) # 출력: [1, 2, 3, 4, 5, 6] 이 재귀 방식은 모든 노드 값을 단일 리스트로 반환하며, 시간 복잡도는 O(n²)로 큐를 사용한 방식(O(n))보다 효율성이 떨어진다.\n시간 복잡도와 공간 복잡도 큐를 사용한 레벨 순서 순회의 경우:\n시간 복잡도: O(n), 여기서 n은 트리의 노드 수입니다. 각 노드는 정확히 한 번씩 방문됩니다. 공간 복잡도: O(w), 여기서 w는 트리의 최대 너비입니다. 이진 트리의 경우 최악의 경우 O(n/2), 즉 O(n)이 됩니다. 재귀를 사용한 레벨 순서 순회의 경우:\n시간 복잡도: O(n²), 트리의 높이가 h일 때 각 레벨마다 O(n)의 작업을 수행하기 때문입니다. 공간 복잡도: O(h), 재귀 호출 스택의 최대 깊이는 트리의 높이입니다. 참고 및 출처 ","wordCount":"707","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-06T09:59:00Z","dateModified":"2024-12-06T09:59:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/level-order-traversal/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structure and Algorithm</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/>이진 트리 (Binary Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/>Traversal</a></div><h1 class="post-title entry-hint-parent">Level Order Traversal</h1><div class=post-description>레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.</div><div class=post-meta><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;707 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Data%20Structures/Tree/Binary%20Tree/Traversal/level-order-traversal.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#레벨-순서-순회-level-order-traversal>레벨 순서 순회 (Level Order Traversal)</a><ul><li><a href=#레벨-순서-순회의-개념>레벨 순서 순회의 개념</a></li><li><a href=#레벨-순서-순회의-구현-방법>레벨 순서 순회의 구현 방법</a></li><li><a href=#파이썬으로-구현한-레벨-순서-순회>파이썬으로 구현한 레벨 순서 순회</a></li><li><a href=#레벨-순서-순회의-활용>레벨 순서 순회의 활용</a></li><li><a href=#다른-구현-방식-재귀를-사용한-레벨-순서-순회>다른 구현 방식: 재귀를 사용한 레벨 순서 순회</a></li><li><a href=#시간-복잡도와-공간-복잡도>시간 복잡도와 공간 복잡도</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=레벨-순서-순회-level-order-traversal>레벨 순서 순회 (Level Order Traversal)<a hidden class=anchor aria-hidden=true href=#레벨-순서-순회-level-order-traversal>#</a></h2><p>트리 자료구조에서 레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.<br>이 순회 방식은 너비 우선 탐색(Breadth-First Search, BFS)의 일종으로 볼 수 있다.</p><p>레벨 순서 순회는 트리를 레벨별로 탐색하는 강력한 기법이다.<br>큐를 사용한 반복적 접근법이 가장 효율적인 구현 방식이며, 다양한 트리 문제를 해결하는 데 활용할 수 있다.<br>특히 트리의 구조적 특성을 분석하거나 레벨별 작업을 수행할 때 매우 유용하다.</p><h3 id=레벨-순서-순회의-개념>레벨 순서 순회의 개념<a hidden class=anchor aria-hidden=true href=#레벨-순서-순회의-개념>#</a></h3><p>트리에서 레벨이란 루트 노드로부터의 거리를 의미한다:</p><ul><li>레벨 0: 루트 노드</li><li>레벨 1: 루트 노드의 자식 노드들</li><li>레벨 2: 레벨 1 노드들의 자식 노드들</li><li>이런 식으로 계속된다.<br>레벨 순서 순회는 모든 레벨 0 노드(루트)를 방문한 다음, 모든 레벨 1 노드, 모든 레벨 2 노드… 식으로 진행된다.</li></ul><h3 id=레벨-순서-순회의-구현-방법>레벨 순서 순회의 구현 방법<a hidden class=anchor aria-hidden=true href=#레벨-순서-순회의-구현-방법>#</a></h3><p>레벨 순서 순회를 구현하는 가장 일반적인 방법은 큐(Queue) 자료구조를 사용하는 것이다.</p><p>알고리즘은 다음과 같다:</p><ol><li>루트 노드를 큐에 넣는다.</li><li>큐가 비어있지 않은 동안:<ol><li>큐에서 노드를 하나 꺼낸다.</li><li>해당 노드를 방문(처리)한다.</li><li>해당 노드의 모든 자식 노드를 큐에 넣는다(보통 왼쪽에서 오른쪽 순서로).</li></ol></li></ol><h3 id=파이썬으로-구현한-레벨-순서-순회>파이썬으로 구현한 레벨 순서 순회<a hidden class=anchor aria-hidden=true href=#파이썬으로-구현한-레벨-순서-순회>#</a></h3><p>다음은 이진 트리에서의 레벨 순서 순회를 파이썬으로 구현한 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span><span class=lnt id=hl-0-42><a class=lnlinks href=#hl-0-42>42</a>
</span><span class=lnt id=hl-0-43><a class=lnlinks href=#hl-0-43>43</a>
</span><span class=lnt id=hl-0-44><a class=lnlinks href=#hl-0-44>44</a>
</span><span class=lnt id=hl-0-45><a class=lnlinks href=#hl-0-45>45</a>
</span><span class=lnt id=hl-0-46><a class=lnlinks href=#hl-0-46>46</a>
</span><span class=lnt id=hl-0-47><a class=lnlinks href=#hl-0-47>47</a>
</span><span class=lnt id=hl-0-48><a class=lnlinks href=#hl-0-48>48</a>
</span><span class=lnt id=hl-0-49><a class=lnlinks href=#hl-0-49>49</a>
</span><span class=lnt id=hl-0-50><a class=lnlinks href=#hl-0-50>50</a>
</span><span class=lnt id=hl-0-51><a class=lnlinks href=#hl-0-51>51</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>val</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>left</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>right</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>val</span> <span class=o>=</span> <span class=n>val</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>levelOrderTraversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 결과를 저장할 리스트</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>root</span><span class=p>])</span>  <span class=c1># 큐 초기화: 루트 노드로 시작</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>level_size</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span>  <span class=c1># 현재 레벨의 노드 수</span>
</span></span><span class=line><span class=cl>        <span class=n>current_level</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 현재 레벨의 노드 값들을 저장</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>level_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>  <span class=c1># 큐에서 첫 번째 노드를 꺼냄</span>
</span></span><span class=line><span class=cl>            <span class=n>current_level</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>  <span class=c1># 현재 노드 값을 현재 레벨 리스트에 추가</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 왼쪽 자식이 있으면 큐에 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 오른쪽 자식이 있으면 큐에 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current_level</span><span class=p>)</span>  <span class=c1># 현재 레벨의 노드 값들을 결과 리스트에 추가</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 트리 생성 예시:</span>
</span></span><span class=line><span class=cl><span class=c1>#      1</span>
</span></span><span class=line><span class=cl><span class=c1>#     / \</span>
</span></span><span class=line><span class=cl><span class=c1>#    2   3</span>
</span></span><span class=line><span class=cl><span class=c1>#   / \   \</span>
</span></span><span class=line><span class=cl><span class=c1>#  4   5   6</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>root</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 레벨 순서 순회 실행</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>levelOrderTraversal</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>  <span class=c1># 출력: [[1], [2, 3], [4, 5, 6]]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드는 각 레벨의 노드들을 별도의 하위 리스트로 구분하여 반환한다.<br>출력 결과인 <code>[[1], [2, 3], [4, 5, 6]]</code>는 레벨 0에 노드 1, 레벨 1에 노드 2와 3, 레벨 2에 노드 4, 5, 6이 있음을 보여준다.</p><h3 id=레벨-순서-순회의-활용>레벨 순서 순회의 활용<a hidden class=anchor aria-hidden=true href=#레벨-순서-순회의-활용>#</a></h3><p>레벨 순서 순회는 다음과 같은 상황에서 유용하다:</p><ol><li><strong>트리의 너비 계산</strong>: 각 레벨의 노드 수를 세어 트리의 최대 너비를 계산할 수 있다.</li><li><strong>트리의 높이 계산</strong>: 레벨 순서 순회로 방문한 레벨의 수가 트리의 높이가 된다.</li><li><strong>특정 레벨의 노드 찾기</strong>: 특정 레벨의 모든 노드를 쉽게 식별할 수 있다.</li><li><strong>이진 트리가 완전 이진 트리(Complete Binary Tree)인지 확인</strong>: 레벨 순서 순회를 사용하여 빈 자리가 있는지 검사할 수 있다.</li></ol><h3 id=다른-구현-방식-재귀를-사용한-레벨-순서-순회>다른 구현 방식: 재귀를 사용한 레벨 순서 순회<a hidden class=anchor aria-hidden=true href=#다른-구현-방식-재귀를-사용한-레벨-순서-순회>#</a></h3><p>재귀를 사용하여 레벨 순서 순회를 구현할 수도 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span><span class=lnt id=hl-1-18><a class=lnlinks href=#hl-1-18>18</a>
</span><span class=lnt id=hl-1-19><a class=lnlinks href=#hl-1-19>19</a>
</span><span class=lnt id=hl-1-20><a class=lnlinks href=#hl-1-20>20</a>
</span><span class=lnt id=hl-1-21><a class=lnlinks href=#hl-1-21>21</a>
</span><span class=lnt id=hl-1-22><a class=lnlinks href=#hl-1-22>22</a>
</span><span class=lnt id=hl-1-23><a class=lnlinks href=#hl-1-23>23</a>
</span><span class=lnt id=hl-1-24><a class=lnlinks href=#hl-1-24>24</a>
</span><span class=lnt id=hl-1-25><a class=lnlinks href=#hl-1-25>25</a>
</span><span class=lnt id=hl-1-26><a class=lnlinks href=#hl-1-26>26</a>
</span><span class=lnt id=hl-1-27><a class=lnlinks href=#hl-1-27>27</a>
</span><span class=lnt id=hl-1-28><a class=lnlinks href=#hl-1-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>levelOrderTraversalRecursive</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>height</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>),</span> <span class=n>height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>))</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>getCurrentLevel</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>level</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>level</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>level</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>getCurrentLevel</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>level</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>getCurrentLevel</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>level</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>h</span> <span class=o>=</span> <span class=n>height</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>h</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>getCurrentLevel</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 위의 트리 예시를 사용하여 실행</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>levelOrderTraversalRecursive</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>  <span class=c1># 출력: [1, 2, 3, 4, 5, 6]</span>
</span></span></code></pre></td></tr></table></div></div><p>이 재귀 방식은 모든 노드 값을 단일 리스트로 반환하며, 시간 복잡도는 O(n²)로 큐를 사용한 방식(O(n))보다 효율성이 떨어진다.</p><h3 id=시간-복잡도와-공간-복잡도>시간 복잡도와 공간 복잡도<a hidden class=anchor aria-hidden=true href=#시간-복잡도와-공간-복잡도>#</a></h3><p>큐를 사용한 레벨 순서 순회의 경우:</p><ul><li><strong>시간 복잡도</strong>: O(n), 여기서 n은 트리의 노드 수입니다. 각 노드는 정확히 한 번씩 방문됩니다.</li><li><strong>공간 복잡도</strong>: O(w), 여기서 w는 트리의 최대 너비입니다. 이진 트리의 경우 최악의 경우 O(n/2), 즉 O(n)이 됩니다.</li></ul><p>재귀를 사용한 레벨 순서 순회의 경우:</p><ul><li><strong>시간 복잡도</strong>: O(n²), 트리의 높이가 h일 때 각 레벨마다 O(n)의 작업을 수행하기 때문입니다.</li><li><strong>공간 복잡도</strong>: O(h), 재귀 호출 스택의 최대 깊이는 트리의 높이입니다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/tree/>Tree</a></li><li><a href=https://buenhyden.github.io/tags/binary-tree/>Binary-Tree</a></li><li><a href=https://buenhyden.github.io/tags/traversal/>Traversal</a></li><li><a href=https://buenhyden.github.io/tags/level-order-traversal/>Level-Order-Traversal</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/qa/sdlc/2-requirements-gathering-and-analysis/><span class=title>« Prev</span><br><span>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler-vs-interpreter-vs-assembler/><span class=title>Next »</span><br><span>Compiler vs Interpreter vs Assembler</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>