<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Postorder Traversal | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Tree,Binary-Tree,Traversal,PostOrder-Traversal"><meta name=description content="후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/postorder-traversal/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/postorder-traversal/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/postorder-traversal/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Postorder Traversal"><meta property="og:description" content="후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-06T09:59:00+00:00"><meta property="article:modified_time" content="2024-12-06T09:59:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Tree"><meta property="article:tag" content="Binary-Tree"><meta property="article:tag" content="Traversal"><meta property="article:tag" content="PostOrder-Traversal"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Postorder Traversal"><meta name=twitter:description content="후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"Data Structures","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":4,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/"},{"@type":"ListItem","position":5,"name":"이진 트리 (Binary Tree)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/"},{"@type":"ListItem","position":6,"name":"Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/"},{"@type":"ListItem","position":7,"name":"Postorder Traversal","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/postorder-traversal/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Postorder Traversal","name":"Postorder Traversal","description":"후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Tree","Binary-Tree","Traversal","PostOrder-Traversal"],"articleBody":"후위 순회(Postorder Traversal) 후위 순회(Postorder Traversal)는 트리 자료구조를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나로, 특별한 방문 순서와 특성을 가지고 있다.\n후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.\n트리 삭제, 표현식 평가, 디렉토리 크기 계산과 같은 작업에서 후위 순회의 특성이 자연스럽게 활용된다.\n재귀적 구현이 가장 직관적이지만, 스택을 사용한 반복적 구현이나 모리스 순회와 같은 고급 기법을 통해 성능과 공간 효율성을 개선할 수 있다. 각 구현 방법은 상황에 따라 장단점이 있으므로, 문제의 성격과 제약 조건을 고려하여 적절한 방법을 선택해야 한다.\n후위 순회의 기본 개념 후위 순회는 이진 트리를 탐색할 때 다음과 같은 순서로 노드를 방문하는 방법이다:\n왼쪽 서브트리를 후위 순회한다. 오른쪽 서브트리를 후위 순회한다. 현재 노드(루트)를 방문한다. “후위(Postorder)“라는 이름은 현재 노드가 왼쪽과 오른쪽 서브트리를 방문한 “후(post)“에 방문된다는 의미를 담고 있다. 이 순회 방식도 깊이 우선 탐색(DFS)의 한 형태로, 트리의 가장 깊은 레벨부터 처리하여 상위 노드로 올라가는 상향식(bottom-up) 접근법을 취한다.\n후위 순회의 알고리즘 아래 이진 트리를 예로 들어 후위 순회 과정을 단계별로 살펴보자:\n1 2 3 4 5 1 / \\ 2 3 / \\ / \\ 4 5 6 7 후위 순회 순서: 4 → 5 → 2 → 6 → 7 → 3 → 1\n이 순서를 단계별로 설명하면:\n가장 왼쪽 경로를 따라 내려가 노드 4에 도달하고 방문한다 (왼쪽, 오른쪽 자식이 없음). 노드 4의 부모인 노드 2의 오른쪽 자식인 노드 5로 이동하여 방문한다. 노드 5의 왼쪽, 오른쪽 자식을 모두 방문했으므로(또는 자식이 없으므로), 노드 2를 방문한다. 노드 2의 부모인 노드 1의 오른쪽 자식인 노드 3으로 이동한다. 노드 3의 왼쪽 자식인 노드 6을 방문한다. 노드 3의 오른쪽 자식인 노드 7을 방문한다. 노드 6과 7을 모두 방문했으므로, 노드 3을 방문한다. 마지막으로, 모든 자식(노드 2와 3)을 방문했으므로 루트 노드 1을 방문한다. 1 2 3 4 5 A / \\ B C / \\ \\ D E F 후위 순회(Postorder Traversal)의 과정은 다음과 같다.\nD 방문 (B의 왼쪽 자식) → 출력: D E 방문 (B의 오른쪽 자식) → 출력: D E B 방문 (B의 루트) → 출력: D E B F 방문 (C의 오른쪽 자식) → 출력: D E B F C 방문 (C의 루트) → 출력: D E B F C A 방문 (A의 루트) → 출력: D E B F C A 재귀적 구현 후위 순회의 재귀적 구현은 직관적이고 간결하다:\n1 2 3 4 5 6 7 8 9 10 11 12 def postorder_traversal(node): if node is None: return # 1. 왼쪽 서브트리 순회 postorder_traversal(node.left) # 2. 오른쪽 서브트리 순회 postorder_traversal(node.right) # 3. 현재 노드 방문 print(node.value) 후위 순회의 재귀적 성질은 “자식 노드를 먼저 처리한 후에 부모 노드를 처리한다\"는 점에서 많은 문제 해결에 유용하다.\n반복적(비재귀적) 구현 후위 순회의 반복적 구현은 전위나 중위 순회보다 조금 더 복잡하다. 두 개의 스택을 사용하거나, 노드의 방문 상태를 추적해야 한다:\n두 개의 스택을 사용한 방법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def postorder_traversal_iterative(root): if root is None: return [] result = [] stack1 = [root] stack2 = [] # 첫 번째 스택에서 노드를 꺼내 두 번째 스택에 넣음 while stack1: node = stack1.pop() stack2.append(node) # 전위 순회의 반대 순서로 자식 노드를 첫 번째 스택에 추가 if node.left: stack1.append(node.left) if node.right: stack1.append(node.right) # 두 번째 스택에서 노드를 꺼내서 결과에 추가 while stack2: node = stack2.pop() result.append(node.value) return result 방문 상태를 추적하는 방법 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def postorder_traversal_iterative_single_stack(root): if root is None: return [] result = [] stack = [] current = root last_visited = None while current or stack: # 왼쪽 경로의 모든 노드를 스택에 추가 while current: stack.append(current) current = current.left # 스택의 맨 위 노드 확인 peek = stack[-1] # 오른쪽 자식이 없거나 이미 방문했으면 현재 노드 방문 if not peek.right or peek.right == last_visited: result.append(peek.value) last_visited = stack.pop() current = None else: # 오른쪽 자식으로 이동 current = peek.right return result 이 방법은 노드의 왼쪽 자식과 오른쪽 자식이 모두 방문되었는지 확인한 후에만 노드를 방문한다.\n다양한 트리 구조에서의 후위 순회 이진 검색 트리(Binary Search Tree)\n이진 검색 트리에서 후위 순회는 하위 트리부터 처리하는 특성이 있어, 트리 삭제와 같은 작업에 유용하다.\n1 2 3 4 5 6 7 8 / \\ 3 10 / \\ \\ 1 6 14 / \\ / 4 7 13 후위 순회 순서: 1 → 4 → 7 → 6 → 3 → 13 → 14 → 10 → 8\n편향 트리(Skewed Tree)\n한쪽으로만 자식 노드가 있는 트리이다.\n왼쪽 편향 트리:\n1 2 3 4 5 6 7 1 / 2 / 3 / 4 후위 순회 순서: 4 → 3 → 2 → 1\n오른쪽 편향 트리:\n1 2 3 4 5 6 7 1 \\ 2 \\ 3 \\ 4 후위 순회 순서: 4 → 3 → 2 → 1\n후위 순회에서는 편향 트리의 방향에 관계없이 항상 리프 노드부터 루트 노드까지 아래에서 위로 방문한다.\n완전 이진 트리(Complete Binary Tree)\n완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 채워진 트리이다.\n1 2 3 4 5 1 / \\ 2 3 / \\ / 4 5 6 후위 순회 순서: 4 → 5 → 2 → 6 → 3 → 1\n일반 트리(N-ary Tree)\n각 노드가 0개 이상의 자식 노드를 가질 수 있는 트리이다.\n1 2 3 4 5 1 / | \\ 2 3 4 /\\ | /\\ 5 6 7 8 9 일반 트리에서의 후위 순회:\n각 자식 노드를 왼쪽에서 오른쪽 순서로 후위 순회합니다. 현재 노드를 방문합니다. 후위 순회 순서: 5 → 6 → 2 → 7 → 3 → 8 → 9 → 4 → 1\n후위 순회의 활용 사례 트리 삭제(Tree Deletion)\n후위 순회는 트리를 삭제할 때 자연스러운 방법이다.\n자식 노드를 먼저 삭제한 후에 부모 노드를 삭제하는 방식이기 때문에 메모리 관리 측면에서 효율적이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 def delete_tree(node): if node is None: return # 왼쪽 서브트리 삭제 delete_tree(node.left) # 오른쪽 서브트리 삭제 delete_tree(node.right) # 현재 노드 삭제 print(f\"노드 {node.value} 삭제\") del node 디렉토리 크기 계산\n파일 시스템에서 디렉토리의 총 크기를 계산할 때 후위 순회가 유용하다. 각 하위 디렉토리와 파일의 크기를 먼저 계산한 후, 현재 디렉토리의 크기를 구할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def calculate_directory_size(path): if os.path.isfile(path): return os.path.getsize(path) total_size = 0 # 하위 항목의 크기 계산 for item in os.listdir(path): item_path = os.path.join(path, item) total_size += calculate_directory_size(item_path) # 현재 디렉토리 자체의 크기 추가 (메타데이터 등) total_size += os.path.getsize(path) print(f\"디렉토리 {path}의 크기: {total_size} 바이트\") return total_size 표현식 트리의 후위 표기법(Postfix Notation) 변환\n표현식 트리에서 후위 순회를 수행하면 후위 표기법(postfix notation 또는 Reverse Polish notation)의 수식을 얻을 수 있다.\n예를 들어, 중위 표기법 a + b * c를 표현하는 트리는 다음과 같습니다:\n1 2 3 4 5 + / \\ a * / \\ b c 후위 순회를 수행하면 a b c * +라는 후위 표기법을 얻을 수 있다.\n후위 표기법은 스택을 사용하여 효율적으로 계산할 수 있으며, 괄호가 필요 없다는 장점이 있다.\n표현식 트리 평가(Expression Tree Evaluation)\n후위 순회는 표현식 트리를 평가(계산)하는 데 자연스럽게 사용된다.\n왼쪽과 오른쪽 서브트리를 먼저 평가한 후, 현재 노드의 연산자를 적용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def evaluate_expression_tree(node): if node is None: return 0 # 리프 노드는 숫자를 나타냄 if not node.left and not node.right: return node.value # 왼쪽 서브트리 평가 left_value = evaluate_expression_tree(node.left) # 오른쪽 서브트리 평가 right_value = evaluate_expression_tree(node.right) # 현재 노드의 연산자 적용 if node.value == '+': return left_value + right_value elif node.value == '-': return left_value - right_value elif node.value == '*': return left_value * right_value elif node.value == '/': return left_value / right_value 이진 트리의 깊이 계산\n후위 순회를 사용하여 이진 트리의 깊이(또는 높이)를 계산할 수 있다.\n왼쪽과 오른쪽 서브트리의 깊이를 먼저 계산한 후, 더 큰 값에 1을 더하면 현재 노드를 루트로 하는 서브트리의 깊이가 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 def calculate_tree_depth(node): if node is None: return 0 # 왼쪽 서브트리의 깊이 계산 left_depth = calculate_tree_depth(node.left) # 오른쪽 서브트리의 깊이 계산 right_depth = calculate_tree_depth(node.right) # 더 깊은 서브트리의 깊이 + 1 반환 return max(left_depth, right_depth) + 1 후위 순회의 시간 및 공간 복잡도 시간 복잡도\n후위 순회는 트리의 모든 노드를 한 번씩 방문하므로 시간 복잡도는 O(n)이다. 여기서 n은 트리의 노드 수이다.\n공간 복잡도\n재귀적 구현: 재귀 호출 스택의 크기는 트리의 높이 h에 비례하므로 공간 복잡도는 O(h)이다. 최악의 경우(편향 트리)에는 O(n)이 될 수 있다. 반복적 구현(두 개의 스택): 두 개의 스택을 사용하는 경우 공간 복잡도는 O(n)이다. 반복적 구현(한 개의 스택): 한 개의 스택과 방문 상태를 추적하는 경우 공간 복잡도는 O(h)이다. 최악의 경우에는 O(n)이 될 수 있다. 실제 코드 예제: 이진 트리의 후위 순회 구현 아래는 Python으로 이진 트리 노드 클래스와 후위 순회 메서드를 구현한 예제:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def postorder_traversal_recursive(root): result = [] def dfs(node): if not node: return # 왼쪽 서브트리 순회 dfs(node.left) # 오른쪽 서브트리 순회 dfs(node.right) # 현재 노드 방문 result.append(node.value) dfs(root) return result def postorder_traversal_iterative_two_stacks(root): if not root: return [] result = [] stack1 = [root] stack2 = [] while stack1: node = stack1.pop() stack2.append(node) if node.left: stack1.append(node.left) if node.right: stack1.append(node.right) while stack2: node = stack2.pop() result.append(node.value) return result # 다음과 같은 이진 트리 생성: # 1 # / \\ # 2 3 # / \\ / \\ # 4 5 6 7 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) # 재귀적 방법으로 후위 순회 print(\"재귀적 후위 순회:\", postorder_traversal_recursive(root)) # [4, 5, 2, 6, 7, 3, 1] # 반복적 방법으로 후위 순회 (두 개의 스택 사용) print(\"반복적 후위 순회 (두 개의 스택):\", postorder_traversal_iterative_two_stacks(root)) # [4, 5, 2, 6, 7, 3, 1] 후위 순회의 응용 문제 이진 트리의 최대 경로 합(Maximum Path Sum)\n이진 트리에서 임의의 두 노드 사이의 경로 중 노드 값의 합이 가장 큰 경로를 찾는 문제.\n후위 순회를 사용하면 각 서브트리의 최대 경로 합을 계산할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def max_path_sum(root): max_sum = [float('-inf')] # 최대 경로 합을 저장할 리스트 (전역 변수 대신 사용) def postorder(node): if not node: return 0 # 왼쪽 서브트리의 최대 합 계산 (음수면 0으로 처리) left_sum = max(0, postorder(node.left)) # 오른쪽 서브트리의 최대 합 계산 (음수면 0으로 처리) right_sum = max(0, postorder(node.right)) # 현재 노드를 포함하는 경로의 최대 합 갱신 max_sum[0] = max(max_sum[0], node.value + left_sum + right_sum) # 상위 경로에 기여할 수 있는 최대 합 반환 (현재 노드 + 왼쪽 또는 오른쪽 중 더 큰 값) return node.value + max(left_sum, right_sum) postorder(root) return max_sum[0] 이진 트리의 직렬화 및 역직렬화(Serialization and Deserialization)\n이진 트리를 문자열로 변환하는 직렬화와 그 문자열로부터 원래 트리를 복원하는 역직렬화 과정에서 후위 순회를 활용할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def serialize(root): \"\"\"이진 트리를 후위 순회 방식으로 직렬화합니다.\"\"\" if not root: return \"null,\" # 왼쪽 서브트리 직렬화 left_serialized = serialize(root.left) # 오른쪽 서브트리 직렬화 right_serialized = serialize(root.right) # 현재 노드의 값을 추가 return left_serialized + right_serialized + str(root.value) + \",\" def deserialize(data): \"\"\"후위 순회 방식으로 직렬화된 문자열에서 이진 트리를 복원합니다.\"\"\" def build_tree(tokens): value = tokens.pop() if value == \"null\": return None node = TreeNode(int(value)) # 후위 순회에서는 오른쪽 서브트리가 먼저 나옴 node.right = build_tree(tokens) node.left = build_tree(tokens) return node tokens = data.split(\",\") tokens = [token for token in tokens if token] # 빈 문자열 제거 tokens.pop() # 마지막 쉼표로 인한 빈 토큰 제거 return build_tree(tokens) 이진 트리의 후위 순회 검증(Validate Postorder Sequence)\n주어진 정수 배열이 이진 검색 트리의 유효한 후위 순회 결과인지 확인하는 문제.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def verify_postorder(postorder): \"\"\" 이진 검색 트리의 후위 순회 결과가 유효한지 확인합니다. \"\"\" if not postorder: return True root_value = postorder[-1] # 후위 순회의 마지막 값은 루트 # 왼쪽 서브트리와 오른쪽 서브트리의 경계 찾기 i = 0 while i \u003c len(postorder) - 1 and postorder[i] \u003c root_value: i += 1 # 오른쪽 서브트리의 모든 값이 루트보다 커야 함 for j in range(i, len(postorder) - 1): if postorder[j] \u003c root_value: return False # 왼쪽 서브트리와 오른쪽 서브트리 각각 검증 left_valid = True if i \u003e 0: left_valid = verify_postorder(postorder[:i]) right_valid = True if i \u003c len(postorder) - 1: right_valid = verify_postorder(postorder[i:-1]) return left_valid and right_valid 후위 순회의 고급 응용 트리의 최소 공통 조상(Lowest Common Ancestor) 찾기\n두 노드의 최소 공통 조상(LCA)을 찾는 문제는 후위 순회를 사용하여 효율적으로 해결할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def lowest_common_ancestor(root, p, q): if not root or root == p or root == q: return root # 왼쪽 서브트리에서 p 또는 q 찾기 left = lowest_common_ancestor(root.left, p, q) # 오른쪽 서브트리에서 p 또는 q 찾기 right = lowest_common_ancestor(root.right, p, q) # 왼쪽과 오른쪽 서브트리에서 각각 하나씩 찾았다면, 현재 노드가 LCA if left and right: return root # 왼쪽 또는 오른쪽 서브트리에서만 찾았다면, 그 서브트리에 LCA가 있음 return left if left else right 트리의 직경(Diameter) 계산\n트리의 직경은 트리에서 가장 먼 두 노드 사이의 경로 길이이다.\n후위 순회를 사용하여 각 노드를 루트로 하는 서브트리의 높이를 계산하면서 직경을 구할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def diameter_of_binary_tree(root): diameter = [0] # 최대 직경을 저장할 리스트 def height(node): if not node: return 0 # 왼쪽 서브트리의 높이 left_height = height(node.left) # 오른쪽 서브트리의 높이 right_height = height(node.right) # 현재 노드를 지나는 경로의 길이로 직경 갱신 diameter[0] = max(diameter[0], left_height + right_height) # 현재 노드를 루트로 하는 서브트리의 높이 반환 return max(left_height, right_height) + 1 height(root) return diameter[0] 이진 트리의 모든 경로 출력\n루트에서 리프까지의 모든 경로를 출력하는 문제도 후위 순회의 변형을 사용하여 해결할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def binary_tree_paths(root): if not root: return [] paths = [] def dfs(node, path): # 현재 노드를 경로에 추가 path.append(str(node.value)) # 리프 노드에 도달하면 경로를 결과에 추가 if not node.left and not node.right: paths.append(\"-\u003e\".join(path)) path.pop() # 백트래킹 return # 왼쪽 서브트리 탐색 if node.left: dfs(node.left, path) # 오른쪽 서브트리 탐색 if node.right: dfs(node.right, path) # 현재 경로에서 노드 제거 (백트래킹) path.pop() dfs(root, []) return paths 이 함수는 전위 순회와 백트래킹을 결합하여 모든 경로를 찾는다. 후위 순회의 특성인 “자식 노드를 모두 처리한 후 부모 노드 처리\"는 백트래킹 단계(path.pop())에서 활용된다.\n후위 순회를 이용한 이진 트리 구조 검증\n이진 트리가 특정 구조적 속성을 만족하는지 확인하는 데 후위 순회가 유용한다.\n예를 들어, 이진 트리가 균형 잡혀 있는지 확인하는 문제를 살펴보면:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def is_balanced(root): \"\"\" 이진 트리가 균형 잡혀 있는지 확인합니다. 균형 잡힌 트리란 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하인 트리입니다. \"\"\" def check_height(node): if not node: return 0 # 왼쪽 서브트리의 높이 확인 left_height = check_height(node.left) if left_height == -1: return -1 # 이미 불균형이 발견됨 # 오른쪽 서브트리의 높이 확인 right_height = check_height(node.right) if right_height == -1: return -1 # 이미 불균형이 발견됨 # 현재 노드에서 높이 차이 확인 if abs(left_height - right_height) \u003e 1: return -1 # 불균형 발견 # 현재 노드를 루트로 하는 서브트리의 높이 반환 return max(left_height, right_height) + 1 return check_height(root) != -1 이 알고리즘은 트리의 높이를 계산하면서 동시에 균형 조건을 검사한다. 후위 순회의 상향식 접근법이 이 작업에 매우 적합하다.\n트리 순회의 실제 응용 사례 컴파일러 설계에서의 후위 순회\n컴파일러에서 추상 구문 트리(AST)를 처리할 때 후위 순회가 중요한 역할을 한다.\n표현식을 계산하거나 코드를 생성할 때, 자식 노드(피연산자 또는 하위 표현식)를 먼저 처리한 후 부모 노드(연산자 또는 상위 표현식)를 처리하는 방식을 사용한다.\n예를 들어, 다음과 같은 C 언어 표현식이 있다고 가정해보면:\n1 a = b + c * d; 이 표현식의 AST는 다음과 같을 수 있다:\n1 2 3 4 5 6 7 = / \\ a + / \\ b * / \\ c d 후위 순회 순서: a → b → c → d → * → + → =\n컴파일러는 이 순서대로 코드를 생성할 수 있다:\n변수 a에 접근 변수 b에 접근 변수 c에 접근 변수 d에 접근 c와 d를 곱하기 b와 (c*d)의 결과를 더하기 a에 (b+(c*d))의 결과를 할당 게임 AI에서의 미니맥스 알고리즘(Minimax Algorithm)\n체스, 오델로, 틱택토와 같은 게임의 AI에서는 미니맥스 알고리즘이 사용되는데, 이 알고리즘은 게임 트리를 후위 순회하는 방식으로 동작한다.\n리프 노드(게임의 종료 상태)의 값을 평가한 후, 그 값을 상위 노드로 전파한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def minimax(node, depth, is_maximizing_player): # 리프 노드에 도달하거나 게임이 종료된 경우 if depth == 0 or node.is_terminal(): return node.evaluate() if is_maximizing_player: value = float('-inf') for child in node.get_children(): value = max(value, minimax(child, depth - 1, False)) return value else: value = float('inf') for child in node.get_children(): value = min(value, minimax(child, depth - 1, True)) return value 이 알고리즘은 게임 트리의 리프 노드부터 시작하여 각 레벨에서 최선의 선택을 결정해 나가는 상향식 접근법을 사용한다.\n네트워크 토폴로지 분석\n컴퓨터 네트워크의 토폴로지를 트리로 모델링할 때, 후위 순회를 사용하여 네트워크 지연, 대역폭, 신뢰성 등을 분석할 수 있다. 각 하위 네트워크의 특성을 먼저 계산한 후, 상위 네트워크의 특성을 결정한다.\nXML/HTML 문서 처리\nXML이나 HTML 문서는 트리 구조로 표현될 수 있으며, 문서를 렌더링하거나 처리할 때 후위 순회가 사용된다. 예를 들어, DOM(Document Object Model) 트리를 처리할 때 자식 요소를 먼저 처리한 후 부모 요소를 처리한다.\n후위 순회의 변형 역후위 순회(Reverse Postorder Traversal)\n역후위 순회는 오른쪽 서브트리를 먼저 방문한 후 왼쪽 서브트리를 방문하고 마지막으로 루트를 방문하는 방식이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def reverse_postorder_traversal(root): result = [] def dfs(node): if not node: return # 오른쪽 서브트리 순회 dfs(node.right) # 왼쪽 서브트리 순회 dfs(node.left) # 현재 노드 방문 result.append(node.value) dfs(root) return result 이 방법은 그래프의 깊이 우선 탐색(DFS)에서 후위 순회의 역순으로 위상 정렬(topological sort)을 구현할 때 사용될 수 있다.\n모리스 후위 순회(Morris Postorder Traversal)\n모리스 후위 순회는 추가 공간을 사용하지 않고(O(1) 공간 복잡도) 트리를 후위 순회하는 알고리즘이다.\n이 방법은 복잡하지만 공간 효율성이 중요한 경우에 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def morris_postorder_traversal(root): result = [] dummy = TreeNode(0) dummy.left = root current = dummy while current: if not current.left: current = current.right else: predecessor = current.left while predecessor.right and predecessor.right != current: predecessor = predecessor.right if not predecessor.right: predecessor.right = current current = current.left else: # 중요한 부분: 왼쪽 서브트리에서 올라오는 경로를 역순으로 기록 temp = [] p = current.left while p != current: temp.append(p.value) p = predecessor.right # 역순으로 결과에 추가 result.extend(reversed(temp)) predecessor.right = None current = current.right return result 이 구현은 복잡하지만, 트리를 일시적으로 수정하여 추가 공간 없이 후위 순회를 가능하게 한다.\n후위 순회를 사용한 실제 문제 해결 예시 이진 트리의 섬세한 연산: 서브트리 제거 이진 트리에서 특정 값을 가진 모든 서브트리를 제거하는 문제를 생각해봅보면: 후위 순회는 이러한 상향식 연산에 이상적이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def remove_subtrees_with_value(root, target_value): \"\"\" 주어진 값을 가진 모든 서브트리를 트리에서 제거합니다. \"\"\" if not root: return None # 왼쪽 서브트리 처리 root.left = remove_subtrees_with_value(root.left, target_value) # 오른쪽 서브트리 처리 root.right = remove_subtrees_with_value(root.right, target_value) # 현재 노드 값이 대상 값이면 현재 서브트리 제거 if root.value == target_value: return None return root 이진 트리 노드의 총합 계산 이진 트리에서 각 노드 값의 총합을 계산하는 문제도 후위 순회로 효율적으로 해결할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def sum_of_nodes(root): \"\"\" 이진 트리의 모든 노드 값의 합을 계산합니다. \"\"\" if not root: return 0 # 왼쪽 서브트리의 합 계산 left_sum = sum_of_nodes(root.left) # 오른쪽 서브트리의 합 계산 right_sum = sum_of_nodes(root.right) # 현재 노드 값을 포함한 총합 반환 return left_sum + right_sum + root.value 효율적인 후위 순회 구현을 위한 최적화 기법 제네레이터를 사용한 지연 평가(Lazy Evaluation) Python에서는 제네레이터를 사용하여 메모리 효율적인 후위 순회를 구현할 수 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def postorder_traversal_generator(root): \"\"\" 이진 트리의 후위 순회를 위한 제네레이터 함수입니다. 메모리 효율적으로 노드를 하나씩 생성합니다. \"\"\" if not root: return # 제네레이터를 재귀적으로 호출하고 yield from으로 연결 yield from postorder_traversal_generator(root.left) yield from postorder_traversal_generator(root.right) yield root.value # 사용 예시 for value in postorder_traversal_generator(root): print(value) 이 방법은 전체 결과 리스트를 메모리에 저장하지 않고, 필요할 때마다 다음 노드를 생성한다.\n꼬리 재귀 최적화(Tail Recursion Optimization) 후위 순회의 기본 재귀 구현은 꼬리 재귀가 아니지만, 약간 수정하여 꼬리 재귀 형태로 변환할 수 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 def postorder_traversal_tail_recursive(root): result = [] def postorder(node, result, cont): if not node: return cont(result) def process_right(result): return postorder(node.right, result, lambda r: cont(r + [node.value])) return postorder(node.left, result, process_right) return postorder(root, result, lambda x: x) 이 구현은 복잡하지만, 꼬리 재귀 최적화를 지원하는 언어나 컴파일러에서는 스택 오버플로우 위험 없이 효율적으로 실행될 수 있다.\n참고 및 출처 ","wordCount":"3595","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-06T09:59:00Z","dateModified":"2024-12-06T09:59:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/postorder-traversal/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/>이진 트리 (Binary Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/>Traversal</a></div><h1 class="post-title entry-hint-parent">Postorder Traversal</h1><div class=post-description>후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.</div><div class=post-meta><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3595 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Data%20Structures/Tree/Binary%20Tree/Traversal/postorder-traversal.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#후위-순회postorder-traversal>후위 순회(Postorder Traversal)</a><ul><li><a href=#후위-순회의-기본-개념>후위 순회의 기본 개념</a></li><li><a href=#후위-순회의-알고리즘>후위 순회의 알고리즘</a></li><li><a href=#다양한-트리-구조에서의-후위-순회>다양한 트리 구조에서의 후위 순회</a></li><li><a href=#후위-순회의-활용-사례>후위 순회의 활용 사례</a></li><li><a href=#후위-순회의-시간-및-공간-복잡도>후위 순회의 시간 및 공간 복잡도</a></li><li><a href=#실제-코드-예제-이진-트리의-후위-순회-구현>실제 코드 예제: 이진 트리의 후위 순회 구현</a></li><li><a href=#후위-순회의-응용-문제>후위 순회의 응용 문제</a></li><li><a href=#후위-순회의-고급-응용>후위 순회의 고급 응용</a></li><li><a href=#트리-순회의-실제-응용-사례>트리 순회의 실제 응용 사례</a></li><li><a href=#후위-순회의-변형>후위 순회의 변형</a></li><li><a href=#후위-순회를-사용한-실제-문제-해결-예시>후위 순회를 사용한 실제 문제 해결 예시</a></li><li><a href=#효율적인-후위-순회-구현을-위한-최적화-기법>효율적인 후위 순회 구현을 위한 최적화 기법</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=후위-순회postorder-traversal>후위 순회(Postorder Traversal)<a hidden class=anchor aria-hidden=true href=#후위-순회postorder-traversal>#</a></h2><p>후위 순회(Postorder Traversal)는 트리 자료구조를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나로, 특별한 방문 순서와 특성을 가지고 있다.</p><p>후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.<br>트리 삭제, 표현식 평가, 디렉토리 크기 계산과 같은 작업에서 후위 순회의 특성이 자연스럽게 활용된다.</p><p>재귀적 구현이 가장 직관적이지만, 스택을 사용한 반복적 구현이나 모리스 순회와 같은 고급 기법을 통해 성능과 공간 효율성을 개선할 수 있다. 각 구현 방법은 상황에 따라 장단점이 있으므로, 문제의 성격과 제약 조건을 고려하여 적절한 방법을 선택해야 한다.</p><h3 id=후위-순회의-기본-개념>후위 순회의 기본 개념<a hidden class=anchor aria-hidden=true href=#후위-순회의-기본-개념>#</a></h3><p>후위 순회는 이진 트리를 탐색할 때 다음과 같은 순서로 노드를 방문하는 방법이다:</p><ol><li>왼쪽 서브트리를 후위 순회한다.</li><li>오른쪽 서브트리를 후위 순회한다.</li><li>현재 노드(루트)를 방문한다.</li></ol><p>&ldquo;후위(Postorder)&ldquo;라는 이름은 현재 노드가 왼쪽과 오른쪽 서브트리를 방문한 &ldquo;후(post)&ldquo;에 방문된다는 의미를 담고 있다. 이 순회 방식도 깊이 우선 탐색(DFS)의 한 형태로, 트리의 가장 깊은 레벨부터 처리하여 상위 노드로 올라가는 상향식(bottom-up) 접근법을 취한다.</p><h3 id=후위-순회의-알고리즘>후위 순회의 알고리즘<a hidden class=anchor aria-hidden=true href=#후위-순회의-알고리즘>#</a></h3><p>아래 이진 트리를 예로 들어 후위 순회 과정을 단계별로 살펴보자:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       1
</span></span><span class=line><span class=cl>     /   \
</span></span><span class=line><span class=cl>    2     3
</span></span><span class=line><span class=cl>   / \   / \
</span></span><span class=line><span class=cl>  4   5 6   7
</span></span></code></pre></td></tr></table></div></div><p>후위 순회 순서: 4 → 5 → 2 → 6 → 7 → 3 → 1</p><p>이 순서를 단계별로 설명하면:</p><ol><li>가장 왼쪽 경로를 따라 내려가 노드 4에 도달하고 방문한다 (왼쪽, 오른쪽 자식이 없음).</li><li>노드 4의 부모인 노드 2의 오른쪽 자식인 노드 5로 이동하여 방문한다.</li><li>노드 5의 왼쪽, 오른쪽 자식을 모두 방문했으므로(또는 자식이 없으므로), 노드 2를 방문한다.</li><li>노드 2의 부모인 노드 1의 오른쪽 자식인 노드 3으로 이동한다.</li><li>노드 3의 왼쪽 자식인 노드 6을 방문한다.</li><li>노드 3의 오른쪽 자식인 노드 7을 방문한다.</li><li>노드 6과 7을 모두 방문했으므로, 노드 3을 방문한다.</li><li>마지막으로, 모든 자식(노드 2와 3)을 방문했으므로 루트 노드 1을 방문한다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        A
</span></span><span class=line><span class=cl>       / \
</span></span><span class=line><span class=cl>      B   C
</span></span><span class=line><span class=cl>     / \   \
</span></span><span class=line><span class=cl>    D   E   F
</span></span></code></pre></td></tr></table></div></div><p><strong>후위 순회(Postorder Traversal)의 과정</strong>은 다음과 같다.</p><ol><li><strong>D 방문</strong> (B의 왼쪽 자식) → 출력: <code>D</code></li><li><strong>E 방문</strong> (B의 오른쪽 자식) → 출력: <code>D E</code></li><li><strong>B 방문</strong> (B의 루트) → 출력: <code>D E B</code></li><li><strong>F 방문</strong> (C의 오른쪽 자식) → 출력: <code>D E B F</code></li><li><strong>C 방문</strong> (C의 루트) → 출력: <code>D E B F C</code></li><li><strong>A 방문</strong> (A의 루트) → 출력: <code>D E B F C A</code></li></ol><h4 id=재귀적-구현>재귀적 구현<a hidden class=anchor aria-hidden=true href=#재귀적-구현>#</a></h4><p>후위 순회의 재귀적 구현은 직관적이고 간결하다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 1. 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>    <span class=n>postorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 2. 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>    <span class=n>postorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 3. 현재 노드 방문</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>후위 순회의 재귀적 성질은 &ldquo;자식 노드를 먼저 처리한 후에 부모 노드를 처리한다"는 점에서 많은 문제 해결에 유용하다.</p><h4 id=반복적비재귀적-구현>반복적(비재귀적) 구현<a hidden class=anchor aria-hidden=true href=#반복적비재귀적-구현>#</a></h4><p>후위 순회의 반복적 구현은 전위나 중위 순회보다 조금 더 복잡하다. 두 개의 스택을 사용하거나, 노드의 방문 상태를 추적해야 한다:</p><h5 id=두-개의-스택을-사용한-방법>두 개의 스택을 사용한 방법<a hidden class=anchor aria-hidden=true href=#두-개의-스택을-사용한-방법>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack1</span> <span class=o>=</span> <span class=p>[</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack2</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 첫 번째 스택에서 노드를 꺼내 두 번째 스택에 넣음</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>stack1</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>stack2</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 전위 순회의 반대 순서로 자식 노드를 첫 번째 스택에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack1</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack1</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 두 번째 스택에서 노드를 꺼내서 결과에 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>stack2</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=방문-상태를-추적하는-방법>방문 상태를 추적하는 방법<a hidden class=anchor aria-hidden=true href=#방문-상태를-추적하는-방법>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_iterative_single_stack</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    <span class=n>last_visited</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>current</span> <span class=ow>or</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 경로의 모든 노드를 스택에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 스택의 맨 위 노드 확인</span>
</span></span><span class=line><span class=cl>        <span class=n>peek</span> <span class=o>=</span> <span class=n>stack</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 자식이 없거나 이미 방문했으면 현재 노드 방문</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>peek</span><span class=o>.</span><span class=n>right</span> <span class=ow>or</span> <span class=n>peek</span><span class=o>.</span><span class=n>right</span> <span class=o>==</span> <span class=n>last_visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>peek</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>last_visited</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 오른쪽 자식으로 이동</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>peek</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방법은 노드의 왼쪽 자식과 오른쪽 자식이 모두 방문되었는지 확인한 후에만 노드를 방문한다.</p><h3 id=다양한-트리-구조에서의-후위-순회>다양한 트리 구조에서의 후위 순회<a hidden class=anchor aria-hidden=true href=#다양한-트리-구조에서의-후위-순회>#</a></h3><ol><li><p>이진 검색 트리(Binary Search Tree)<br>이진 검색 트리에서 후위 순회는 하위 트리부터 처리하는 특성이 있어, 트리 삭제와 같은 작업에 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       8
</span></span><span class=line><span class=cl>     /   \
</span></span><span class=line><span class=cl>    3    10
</span></span><span class=line><span class=cl>   / \     \
</span></span><span class=line><span class=cl>  1   6    14
</span></span><span class=line><span class=cl>     / \   /
</span></span><span class=line><span class=cl>    4   7 13
</span></span></code></pre></td></tr></table></div></div><p>후위 순회 순서: 1 → 4 → 7 → 6 → 3 → 13 → 14 → 10 → 8</p></li><li><p>편향 트리(Skewed Tree)<br>한쪽으로만 자식 노드가 있는 트리이다.</p><p>왼쪽 편향 트리:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  1
</span></span><span class=line><span class=cl> /
</span></span><span class=line><span class=cl>2
</span></span><span class=line><span class=cl>/
</span></span><span class=line><span class=cl>3
</span></span><span class=line><span class=cl>/
</span></span><span class=line><span class=cl>4
</span></span></code></pre></td></tr></table></div></div><p>후위 순회 순서: 4 → 3 → 2 → 1</p><p>오른쪽 편향 트리:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1
</span></span><span class=line><span class=cl> \
</span></span><span class=line><span class=cl>  2
</span></span><span class=line><span class=cl>   \
</span></span><span class=line><span class=cl>    3
</span></span><span class=line><span class=cl>     \
</span></span><span class=line><span class=cl>      4
</span></span></code></pre></td></tr></table></div></div><p>후위 순회 순서: 4 → 3 → 2 → 1</p><p>후위 순회에서는 편향 트리의 방향에 관계없이 항상 리프 노드부터 루트 노드까지 아래에서 위로 방문한다.</p></li><li><p>완전 이진 트리(Complete Binary Tree)<br>완전 이진 트리는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있고, 마지막 레벨의 노드들은 왼쪽부터 채워진 트리이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       1
</span></span><span class=line><span class=cl>     /   \
</span></span><span class=line><span class=cl>    2     3
</span></span><span class=line><span class=cl>   / \   / 
</span></span><span class=line><span class=cl>  4   5 6   
</span></span></code></pre></td></tr></table></div></div><p>후위 순회 순서: 4 → 5 → 2 → 6 → 3 → 1</p></li><li><p>일반 트리(N-ary Tree)<br>각 노드가 0개 이상의 자식 노드를 가질 수 있는 트리이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       1
</span></span><span class=line><span class=cl>     / | \
</span></span><span class=line><span class=cl>    2  3  4
</span></span><span class=line><span class=cl>   /\  |  /\
</span></span><span class=line><span class=cl>  5  6 7 8  9
</span></span></code></pre></td></tr></table></div></div><p>일반 트리에서의 후위 순회:</p><ol><li>각 자식 노드를 왼쪽에서 오른쪽 순서로 후위 순회합니다.</li><li>현재 노드를 방문합니다.</li></ol><p>후위 순회 순서: 5 → 6 → 2 → 7 → 3 → 8 → 9 → 4 → 1</p></li></ol><h3 id=후위-순회의-활용-사례>후위 순회의 활용 사례<a hidden class=anchor aria-hidden=true href=#후위-순회의-활용-사례>#</a></h3><ol><li><p>트리 삭제(Tree Deletion)<br>후위 순회는 트리를 삭제할 때 자연스러운 방법이다.<br>자식 노드를 먼저 삭제한 후에 부모 노드를 삭제하는 방식이기 때문에 메모리 관리 측면에서 효율적이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>delete_tree</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리 삭제</span>
</span></span><span class=line><span class=cl>    <span class=n>delete_tree</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리 삭제</span>
</span></span><span class=line><span class=cl>    <span class=n>delete_tree</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드 삭제</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;노드 </span><span class=si>{</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=si>}</span><span class=s2> 삭제&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>del</span> <span class=n>node</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>디렉토리 크기 계산<br>파일 시스템에서 디렉토리의 총 크기를 계산할 때 후위 순회가 유용하다. 각 하위 디렉토리와 파일의 크기를 먼저 계산한 후, 현재 디렉토리의 크기를 구할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_directory_size</span><span class=p>(</span><span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>isfile</span><span class=p>(</span><span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>getsize</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>total_size</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 하위 항목의 크기 계산</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>item</span> <span class=ow>in</span> <span class=n>os</span><span class=o>.</span><span class=n>listdir</span><span class=p>(</span><span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>item_path</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>path</span><span class=p>,</span> <span class=n>item</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>total_size</span> <span class=o>+=</span> <span class=n>calculate_directory_size</span><span class=p>(</span><span class=n>item_path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 디렉토리 자체의 크기 추가 (메타데이터 등)</span>
</span></span><span class=line><span class=cl>    <span class=n>total_size</span> <span class=o>+=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>getsize</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;디렉토리 </span><span class=si>{</span><span class=n>path</span><span class=si>}</span><span class=s2>의 크기: </span><span class=si>{</span><span class=n>total_size</span><span class=si>}</span><span class=s2> 바이트&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_size</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>표현식 트리의 후위 표기법(Postfix Notation) 변환<br>표현식 트리에서 후위 순회를 수행하면 후위 표기법(postfix notation 또는 Reverse Polish notation)의 수식을 얻을 수 있다.</p><p>예를 들어, 중위 표기법 <code>a + b * c</code>를 표현하는 트리는 다음과 같습니다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    +
</span></span><span class=line><span class=cl>   / \
</span></span><span class=line><span class=cl>  a   *
</span></span><span class=line><span class=cl>     / \
</span></span><span class=line><span class=cl>    b   c
</span></span></code></pre></td></tr></table></div></div><p>후위 순회를 수행하면 <code>a b c * +</code>라는 후위 표기법을 얻을 수 있다.<br>후위 표기법은 스택을 사용하여 효율적으로 계산할 수 있으며, 괄호가 필요 없다는 장점이 있다.</p></li><li><p>표현식 트리 평가(Expression Tree Evaluation)<br>후위 순회는 표현식 트리를 평가(계산)하는 데 자연스럽게 사용된다.<br>왼쪽과 오른쪽 서브트리를 먼저 평가한 후, 현재 노드의 연산자를 적용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>evaluate_expression_tree</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 리프 노드는 숫자를 나타냄</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리 평가</span>
</span></span><span class=line><span class=cl>    <span class=n>left_value</span> <span class=o>=</span> <span class=n>evaluate_expression_tree</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리 평가</span>
</span></span><span class=line><span class=cl>    <span class=n>right_value</span> <span class=o>=</span> <span class=n>evaluate_expression_tree</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드의 연산자 적용</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>==</span> <span class=s1>&#39;+&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>left_value</span> <span class=o>+</span> <span class=n>right_value</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>==</span> <span class=s1>&#39;-&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>left_value</span> <span class=o>-</span> <span class=n>right_value</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>==</span> <span class=s1>&#39;*&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>left_value</span> <span class=o>*</span> <span class=n>right_value</span>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>==</span> <span class=s1>&#39;/&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>left_value</span> <span class=o>/</span> <span class=n>right_value</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>이진 트리의 깊이 계산<br>후위 순회를 사용하여 이진 트리의 깊이(또는 높이)를 계산할 수 있다.<br>왼쪽과 오른쪽 서브트리의 깊이를 먼저 계산한 후, 더 큰 값에 1을 더하면 현재 노드를 루트로 하는 서브트리의 깊이가 된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_tree_depth</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리의 깊이 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>left_depth</span> <span class=o>=</span> <span class=n>calculate_tree_depth</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리의 깊이 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>right_depth</span> <span class=o>=</span> <span class=n>calculate_tree_depth</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 더 깊은 서브트리의 깊이 + 1 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_depth</span><span class=p>,</span> <span class=n>right_depth</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=후위-순회의-시간-및-공간-복잡도>후위 순회의 시간 및 공간 복잡도<a hidden class=anchor aria-hidden=true href=#후위-순회의-시간-및-공간-복잡도>#</a></h3><ol><li><p>시간 복잡도<br>후위 순회는 트리의 모든 노드를 한 번씩 방문하므로 시간 복잡도는 O(n)이다. 여기서 n은 트리의 노드 수이다.</p></li><li><p>공간 복잡도</p><ul><li><strong>재귀적 구현</strong>: 재귀 호출 스택의 크기는 트리의 높이 h에 비례하므로 공간 복잡도는 O(h)이다. 최악의 경우(편향 트리)에는 O(n)이 될 수 있다.</li><li><strong>반복적 구현(두 개의 스택)</strong>: 두 개의 스택을 사용하는 경우 공간 복잡도는 O(n)이다.</li><li><strong>반복적 구현(한 개의 스택)</strong>: 한 개의 스택과 방문 상태를 추적하는 경우 공간 복잡도는 O(h)이다. 최악의 경우에는 O(n)이 될 수 있다.</li></ul></li></ol><h3 id=실제-코드-예제-이진-트리의-후위-순회-구현>실제 코드 예제: 이진 트리의 후위 순회 구현<a hidden class=anchor aria-hidden=true href=#실제-코드-예제-이진-트리의-후위-순회-구현>#</a></h3><p>아래는 Python으로 이진 트리 노드 클래스와 후위 순회 메서드를 구현한 예제:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span><span class=lnt id=hl-15-20><a class=lnlinks href=#hl-15-20>20</a>
</span><span class=lnt id=hl-15-21><a class=lnlinks href=#hl-15-21>21</a>
</span><span class=lnt id=hl-15-22><a class=lnlinks href=#hl-15-22>22</a>
</span><span class=lnt id=hl-15-23><a class=lnlinks href=#hl-15-23>23</a>
</span><span class=lnt id=hl-15-24><a class=lnlinks href=#hl-15-24>24</a>
</span><span class=lnt id=hl-15-25><a class=lnlinks href=#hl-15-25>25</a>
</span><span class=lnt id=hl-15-26><a class=lnlinks href=#hl-15-26>26</a>
</span><span class=lnt id=hl-15-27><a class=lnlinks href=#hl-15-27>27</a>
</span><span class=lnt id=hl-15-28><a class=lnlinks href=#hl-15-28>28</a>
</span><span class=lnt id=hl-15-29><a class=lnlinks href=#hl-15-29>29</a>
</span><span class=lnt id=hl-15-30><a class=lnlinks href=#hl-15-30>30</a>
</span><span class=lnt id=hl-15-31><a class=lnlinks href=#hl-15-31>31</a>
</span><span class=lnt id=hl-15-32><a class=lnlinks href=#hl-15-32>32</a>
</span><span class=lnt id=hl-15-33><a class=lnlinks href=#hl-15-33>33</a>
</span><span class=lnt id=hl-15-34><a class=lnlinks href=#hl-15-34>34</a>
</span><span class=lnt id=hl-15-35><a class=lnlinks href=#hl-15-35>35</a>
</span><span class=lnt id=hl-15-36><a class=lnlinks href=#hl-15-36>36</a>
</span><span class=lnt id=hl-15-37><a class=lnlinks href=#hl-15-37>37</a>
</span><span class=lnt id=hl-15-38><a class=lnlinks href=#hl-15-38>38</a>
</span><span class=lnt id=hl-15-39><a class=lnlinks href=#hl-15-39>39</a>
</span><span class=lnt id=hl-15-40><a class=lnlinks href=#hl-15-40>40</a>
</span><span class=lnt id=hl-15-41><a class=lnlinks href=#hl-15-41>41</a>
</span><span class=lnt id=hl-15-42><a class=lnlinks href=#hl-15-42>42</a>
</span><span class=lnt id=hl-15-43><a class=lnlinks href=#hl-15-43>43</a>
</span><span class=lnt id=hl-15-44><a class=lnlinks href=#hl-15-44>44</a>
</span><span class=lnt id=hl-15-45><a class=lnlinks href=#hl-15-45>45</a>
</span><span class=lnt id=hl-15-46><a class=lnlinks href=#hl-15-46>46</a>
</span><span class=lnt id=hl-15-47><a class=lnlinks href=#hl-15-47>47</a>
</span><span class=lnt id=hl-15-48><a class=lnlinks href=#hl-15-48>48</a>
</span><span class=lnt id=hl-15-49><a class=lnlinks href=#hl-15-49>49</a>
</span><span class=lnt id=hl-15-50><a class=lnlinks href=#hl-15-50>50</a>
</span><span class=lnt id=hl-15-51><a class=lnlinks href=#hl-15-51>51</a>
</span><span class=lnt id=hl-15-52><a class=lnlinks href=#hl-15-52>52</a>
</span><span class=lnt id=hl-15-53><a class=lnlinks href=#hl-15-53>53</a>
</span><span class=lnt id=hl-15-54><a class=lnlinks href=#hl-15-54>54</a>
</span><span class=lnt id=hl-15-55><a class=lnlinks href=#hl-15-55>55</a>
</span><span class=lnt id=hl-15-56><a class=lnlinks href=#hl-15-56>56</a>
</span><span class=lnt id=hl-15-57><a class=lnlinks href=#hl-15-57>57</a>
</span><span class=lnt id=hl-15-58><a class=lnlinks href=#hl-15-58>58</a>
</span><span class=lnt id=hl-15-59><a class=lnlinks href=#hl-15-59>59</a>
</span><span class=lnt id=hl-15-60><a class=lnlinks href=#hl-15-60>60</a>
</span><span class=lnt id=hl-15-61><a class=lnlinks href=#hl-15-61>61</a>
</span><span class=lnt id=hl-15-62><a class=lnlinks href=#hl-15-62>62</a>
</span><span class=lnt id=hl-15-63><a class=lnlinks href=#hl-15-63>63</a>
</span><span class=lnt id=hl-15-64><a class=lnlinks href=#hl-15-64>64</a>
</span><span class=lnt id=hl-15-65><a class=lnlinks href=#hl-15-65>65</a>
</span><span class=lnt id=hl-15-66><a class=lnlinks href=#hl-15-66>66</a>
</span><span class=lnt id=hl-15-67><a class=lnlinks href=#hl-15-67>67</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>TreeNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>left</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>right</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_recursive</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_iterative_two_stacks</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack1</span> <span class=o>=</span> <span class=p>[</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack2</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>stack1</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>stack2</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack1</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack1</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>stack2</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 다음과 같은 이진 트리 생성:</span>
</span></span><span class=line><span class=cl><span class=c1>#       1</span>
</span></span><span class=line><span class=cl><span class=c1>#     /   \</span>
</span></span><span class=line><span class=cl><span class=c1>#    2     3</span>
</span></span><span class=line><span class=cl><span class=c1>#   / \   / \</span>
</span></span><span class=line><span class=cl><span class=c1>#  4   5 6   7</span>
</span></span><span class=line><span class=cl><span class=n>root</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 재귀적 방법으로 후위 순회</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;재귀적 후위 순회:&#34;</span><span class=p>,</span> <span class=n>postorder_traversal_recursive</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>  <span class=c1># [4, 5, 2, 6, 7, 3, 1]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 반복적 방법으로 후위 순회 (두 개의 스택 사용)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;반복적 후위 순회 (두 개의 스택):&#34;</span><span class=p>,</span> <span class=n>postorder_traversal_iterative_two_stacks</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>  <span class=c1># [4, 5, 2, 6, 7, 3, 1]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=후위-순회의-응용-문제>후위 순회의 응용 문제<a hidden class=anchor aria-hidden=true href=#후위-순회의-응용-문제>#</a></h3><ol><li><p>이진 트리의 최대 경로 합(Maximum Path Sum)<br>이진 트리에서 임의의 두 노드 사이의 경로 중 노드 값의 합이 가장 큰 경로를 찾는 문제.<br>후위 순회를 사용하면 각 서브트리의 최대 경로 합을 계산할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>max_path_sum</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>max_sum</span> <span class=o>=</span> <span class=p>[</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)]</span>  <span class=c1># 최대 경로 합을 저장할 리스트 (전역 변수 대신 사용)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>postorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리의 최대 합 계산 (음수면 0으로 처리)</span>
</span></span><span class=line><span class=cl>        <span class=n>left_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리의 최대 합 계산 (음수면 0으로 처리)</span>
</span></span><span class=line><span class=cl>        <span class=n>right_sum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드를 포함하는 경로의 최대 합 갱신</span>
</span></span><span class=line><span class=cl>        <span class=n>max_sum</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>max_sum</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>+</span> <span class=n>left_sum</span> <span class=o>+</span> <span class=n>right_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 상위 경로에 기여할 수 있는 최대 합 반환 (현재 노드 + 왼쪽 또는 오른쪽 중 더 큰 값)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>.</span><span class=n>value</span> <span class=o>+</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_sum</span><span class=p>,</span> <span class=n>right_sum</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>postorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>max_sum</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>이진 트리의 직렬화 및 역직렬화(Serialization and Deserialization)<br>이진 트리를 문자열로 변환하는 직렬화와 그 문자열로부터 원래 트리를 복원하는 역직렬화 과정에서 후위 순회를 활용할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span><span class=lnt id=hl-17-26><a class=lnlinks href=#hl-17-26>26</a>
</span><span class=lnt id=hl-17-27><a class=lnlinks href=#hl-17-27>27</a>
</span><span class=lnt id=hl-17-28><a class=lnlinks href=#hl-17-28>28</a>
</span><span class=lnt id=hl-17-29><a class=lnlinks href=#hl-17-29>29</a>
</span><span class=lnt id=hl-17-30><a class=lnlinks href=#hl-17-30>30</a>
</span><span class=lnt id=hl-17-31><a class=lnlinks href=#hl-17-31>31</a>
</span><span class=lnt id=hl-17-32><a class=lnlinks href=#hl-17-32>32</a>
</span><span class=lnt id=hl-17-33><a class=lnlinks href=#hl-17-33>33</a>
</span><span class=lnt id=hl-17-34><a class=lnlinks href=#hl-17-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>serialize</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;이진 트리를 후위 순회 방식으로 직렬화합니다.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;null,&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리 직렬화</span>
</span></span><span class=line><span class=cl>    <span class=n>left_serialized</span> <span class=o>=</span> <span class=n>serialize</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리 직렬화</span>
</span></span><span class=line><span class=cl>    <span class=n>right_serialized</span> <span class=o>=</span> <span class=n>serialize</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드의 값을 추가</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>left_serialized</span> <span class=o>+</span> <span class=n>right_serialized</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>value</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;,&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>deserialize</span><span class=p>(</span><span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;후위 순회 방식으로 직렬화된 문자열에서 이진 트리를 복원합니다.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>build_tree</span><span class=p>(</span><span class=n>tokens</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=n>tokens</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>value</span> <span class=o>==</span> <span class=s2>&#34;null&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=nb>int</span><span class=p>(</span><span class=n>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 후위 순회에서는 오른쪽 서브트리가 먼저 나옴</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>build_tree</span><span class=p>(</span><span class=n>tokens</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>build_tree</span><span class=p>(</span><span class=n>tokens</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tokens</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s2>&#34;,&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>tokens</span> <span class=o>=</span> <span class=p>[</span><span class=n>token</span> <span class=k>for</span> <span class=n>token</span> <span class=ow>in</span> <span class=n>tokens</span> <span class=k>if</span> <span class=n>token</span><span class=p>]</span>  <span class=c1># 빈 문자열 제거</span>
</span></span><span class=line><span class=cl>    <span class=n>tokens</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 마지막 쉼표로 인한 빈 토큰 제거</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>build_tree</span><span class=p>(</span><span class=n>tokens</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>이진 트리의 후위 순회 검증(Validate Postorder Sequence)<br>주어진 정수 배열이 이진 검색 트리의 유효한 후위 순회 결과인지 확인하는 문제.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>verify_postorder</span><span class=p>(</span><span class=n>postorder</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이진 검색 트리의 후위 순회 결과가 유효한지 확인합니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>postorder</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>root_value</span> <span class=o>=</span> <span class=n>postorder</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>  <span class=c1># 후위 순회의 마지막 값은 루트</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리와 오른쪽 서브트리의 경계 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>postorder</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span> <span class=ow>and</span> <span class=n>postorder</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>root_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리의 모든 값이 루트보다 커야 함</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>postorder</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>postorder</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>root_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리와 오른쪽 서브트리 각각 검증</span>
</span></span><span class=line><span class=cl>    <span class=n>left_valid</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>left_valid</span> <span class=o>=</span> <span class=n>verify_postorder</span><span class=p>(</span><span class=n>postorder</span><span class=p>[:</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>right_valid</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>postorder</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>right_valid</span> <span class=o>=</span> <span class=n>verify_postorder</span><span class=p>(</span><span class=n>postorder</span><span class=p>[</span><span class=n>i</span><span class=p>:</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>left_valid</span> <span class=ow>and</span> <span class=n>right_valid</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=후위-순회의-고급-응용>후위 순회의 고급 응용<a hidden class=anchor aria-hidden=true href=#후위-순회의-고급-응용>#</a></h3><ol><li><p>트리의 최소 공통 조상(Lowest Common Ancestor) 찾기<br>두 노드의 최소 공통 조상(LCA)을 찾는 문제는 후위 순회를 사용하여 효율적으로 해결할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span><span class=lnt id=hl-19-15><a class=lnlinks href=#hl-19-15>15</a>
</span><span class=lnt id=hl-19-16><a class=lnlinks href=#hl-19-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>lowest_common_ancestor</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span> <span class=ow>or</span> <span class=n>root</span> <span class=o>==</span> <span class=n>p</span> <span class=ow>or</span> <span class=n>root</span> <span class=o>==</span> <span class=n>q</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리에서 p 또는 q 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span> <span class=o>=</span> <span class=n>lowest_common_ancestor</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리에서 p 또는 q 찾기</span>
</span></span><span class=line><span class=cl>    <span class=n>right</span> <span class=o>=</span> <span class=n>lowest_common_ancestor</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽과 오른쪽 서브트리에서 각각 하나씩 찾았다면, 현재 노드가 LCA</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>left</span> <span class=ow>and</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 또는 오른쪽 서브트리에서만 찾았다면, 그 서브트리에 LCA가 있음</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>left</span> <span class=k>if</span> <span class=n>left</span> <span class=k>else</span> <span class=n>right</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>트리의 직경(Diameter) 계산<br>트리의 직경은 트리에서 가장 먼 두 노드 사이의 경로 길이이다.<br>후위 순회를 사용하여 각 노드를 루트로 하는 서브트리의 높이를 계산하면서 직경을 구할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span><span class=lnt id=hl-20-16><a class=lnlinks href=#hl-20-16>16</a>
</span><span class=lnt id=hl-20-17><a class=lnlinks href=#hl-20-17>17</a>
</span><span class=lnt id=hl-20-18><a class=lnlinks href=#hl-20-18>18</a>
</span><span class=lnt id=hl-20-19><a class=lnlinks href=#hl-20-19>19</a>
</span><span class=lnt id=hl-20-20><a class=lnlinks href=#hl-20-20>20</a>
</span><span class=lnt id=hl-20-21><a class=lnlinks href=#hl-20-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>diameter_of_binary_tree</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>diameter</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span>  <span class=c1># 최대 직경을 저장할 리스트</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>height</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리의 높이</span>
</span></span><span class=line><span class=cl>        <span class=n>left_height</span> <span class=o>=</span> <span class=n>height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리의 높이</span>
</span></span><span class=line><span class=cl>        <span class=n>right_height</span> <span class=o>=</span> <span class=n>height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드를 지나는 경로의 길이로 직경 갱신</span>
</span></span><span class=line><span class=cl>        <span class=n>diameter</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>diameter</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>left_height</span> <span class=o>+</span> <span class=n>right_height</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드를 루트로 하는 서브트리의 높이 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_height</span><span class=p>,</span> <span class=n>right_height</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>height</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>diameter</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>이진 트리의 모든 경로 출력<br>루트에서 리프까지의 모든 경로를 출력하는 문제도 후위 순회의 변형을 사용하여 해결할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19>19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20>20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21>21</a>
</span><span class=lnt id=hl-21-22><a class=lnlinks href=#hl-21-22>22</a>
</span><span class=lnt id=hl-21-23><a class=lnlinks href=#hl-21-23>23</a>
</span><span class=lnt id=hl-21-24><a class=lnlinks href=#hl-21-24>24</a>
</span><span class=lnt id=hl-21-25><a class=lnlinks href=#hl-21-25>25</a>
</span><span class=lnt id=hl-21-26><a class=lnlinks href=#hl-21-26>26</a>
</span><span class=lnt id=hl-21-27><a class=lnlinks href=#hl-21-27>27</a>
</span><span class=lnt id=hl-21-28><a class=lnlinks href=#hl-21-28>28</a>
</span><span class=lnt id=hl-21-29><a class=lnlinks href=#hl-21-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_tree_paths</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>paths</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>path</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드를 경로에 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 리프 노드에 도달하면 경로를 결과에 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>paths</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=s2>&#34;-&gt;&#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>path</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>path</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 백트래킹</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 탐색</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 경로에서 노드 제거 (백트래킹)</span>
</span></span><span class=line><span class=cl>        <span class=n>path</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>paths</span>
</span></span></code></pre></td></tr></table></div></div><p>이 함수는 전위 순회와 백트래킹을 결합하여 모든 경로를 찾는다. 후위 순회의 특성인 &ldquo;자식 노드를 모두 처리한 후 부모 노드 처리"는 백트래킹 단계(path.pop())에서 활용된다.</p></li><li><p>후위 순회를 이용한 이진 트리 구조 검증<br>이진 트리가 특정 구조적 속성을 만족하는지 확인하는 데 후위 순회가 유용한다.<br>예를 들어, 이진 트리가 균형 잡혀 있는지 확인하는 문제를 살펴보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12>12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13>13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14>14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15>15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16>16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17>17</a>
</span><span class=lnt id=hl-22-18><a class=lnlinks href=#hl-22-18>18</a>
</span><span class=lnt id=hl-22-19><a class=lnlinks href=#hl-22-19>19</a>
</span><span class=lnt id=hl-22-20><a class=lnlinks href=#hl-22-20>20</a>
</span><span class=lnt id=hl-22-21><a class=lnlinks href=#hl-22-21>21</a>
</span><span class=lnt id=hl-22-22><a class=lnlinks href=#hl-22-22>22</a>
</span><span class=lnt id=hl-22-23><a class=lnlinks href=#hl-22-23>23</a>
</span><span class=lnt id=hl-22-24><a class=lnlinks href=#hl-22-24>24</a>
</span><span class=lnt id=hl-22-25><a class=lnlinks href=#hl-22-25>25</a>
</span><span class=lnt id=hl-22-26><a class=lnlinks href=#hl-22-26>26</a>
</span><span class=lnt id=hl-22-27><a class=lnlinks href=#hl-22-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_balanced</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이진 트리가 균형 잡혀 있는지 확인합니다. 
</span></span></span><span class=line><span class=cl><span class=s2>    균형 잡힌 트리란 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이가 1 이하인 트리입니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>check_height</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리의 높이 확인</span>
</span></span><span class=line><span class=cl>        <span class=n>left_height</span> <span class=o>=</span> <span class=n>check_height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>left_height</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 이미 불균형이 발견됨</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리의 높이 확인</span>
</span></span><span class=line><span class=cl>        <span class=n>right_height</span> <span class=o>=</span> <span class=n>check_height</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>right_height</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 이미 불균형이 발견됨</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드에서 높이 차이 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>abs</span><span class=p>(</span><span class=n>left_height</span> <span class=o>-</span> <span class=n>right_height</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 불균형 발견</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드를 루트로 하는 서브트리의 높이 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>left_height</span><span class=p>,</span> <span class=n>right_height</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>check_height</span><span class=p>(</span><span class=n>root</span><span class=p>)</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 트리의 높이를 계산하면서 동시에 균형 조건을 검사한다. 후위 순회의 상향식 접근법이 이 작업에 매우 적합하다.</p></li></ol><h3 id=트리-순회의-실제-응용-사례>트리 순회의 실제 응용 사례<a hidden class=anchor aria-hidden=true href=#트리-순회의-실제-응용-사례>#</a></h3><ol><li><p>컴파일러 설계에서의 후위 순회<br>컴파일러에서 추상 구문 트리(AST)를 처리할 때 후위 순회가 중요한 역할을 한다.<br>표현식을 계산하거나 코드를 생성할 때, 자식 노드(피연산자 또는 하위 표현식)를 먼저 처리한 후 부모 노드(연산자 또는 상위 표현식)를 처리하는 방식을 사용한다.</p><p>예를 들어, 다음과 같은 C 언어 표현식이 있다고 가정해보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=n>b</span> <span class=o>+</span> <span class=n>c</span> <span class=o>*</span> <span class=n>d</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>이 표현식의 AST는 다음과 같을 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5>5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6>6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    =
</span></span><span class=line><span class=cl>   / \
</span></span><span class=line><span class=cl>  a   +
</span></span><span class=line><span class=cl>     / \
</span></span><span class=line><span class=cl>    b   *
</span></span><span class=line><span class=cl>       / \
</span></span><span class=line><span class=cl>      c   d
</span></span></code></pre></td></tr></table></div></div><p>후위 순회 순서: a → b → c → d → * → + → =</p><p>컴파일러는 이 순서대로 코드를 생성할 수 있다:</p><ol><li>변수 a에 접근</li><li>변수 b에 접근</li><li>변수 c에 접근</li><li>변수 d에 접근</li><li>c와 d를 곱하기</li><li>b와 (c*d)의 결과를 더하기</li><li>a에 (b+(c*d))의 결과를 할당</li></ol></li><li><p>게임 AI에서의 미니맥스 알고리즘(Minimax Algorithm)<br>체스, 오델로, 틱택토와 같은 게임의 AI에서는 미니맥스 알고리즘이 사용되는데, 이 알고리즘은 게임 트리를 후위 순회하는 방식으로 동작한다.<br>리프 노드(게임의 종료 상태)의 값을 평가한 후, 그 값을 상위 노드로 전파한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1> 1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2> 2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3> 3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4> 4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5> 5</a>
</span><span class=lnt id=hl-25-6><a class=lnlinks href=#hl-25-6> 6</a>
</span><span class=lnt id=hl-25-7><a class=lnlinks href=#hl-25-7> 7</a>
</span><span class=lnt id=hl-25-8><a class=lnlinks href=#hl-25-8> 8</a>
</span><span class=lnt id=hl-25-9><a class=lnlinks href=#hl-25-9> 9</a>
</span><span class=lnt id=hl-25-10><a class=lnlinks href=#hl-25-10>10</a>
</span><span class=lnt id=hl-25-11><a class=lnlinks href=#hl-25-11>11</a>
</span><span class=lnt id=hl-25-12><a class=lnlinks href=#hl-25-12>12</a>
</span><span class=lnt id=hl-25-13><a class=lnlinks href=#hl-25-13>13</a>
</span><span class=lnt id=hl-25-14><a class=lnlinks href=#hl-25-14>14</a>
</span><span class=lnt id=hl-25-15><a class=lnlinks href=#hl-25-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>minimax</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>depth</span><span class=p>,</span> <span class=n>is_maximizing_player</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 리프 노드에 도달하거나 게임이 종료된 경우</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>depth</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>node</span><span class=o>.</span><span class=n>is_terminal</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>node</span><span class=o>.</span><span class=n>evaluate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>is_maximizing_player</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;-inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>node</span><span class=o>.</span><span class=n>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>value</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>minimax</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>depth</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=kc>False</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>node</span><span class=o>.</span><span class=n>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>value</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>value</span><span class=p>,</span> <span class=n>minimax</span><span class=p>(</span><span class=n>child</span><span class=p>,</span> <span class=n>depth</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=kc>True</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>value</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 게임 트리의 리프 노드부터 시작하여 각 레벨에서 최선의 선택을 결정해 나가는 상향식 접근법을 사용한다.</p></li><li><p>네트워크 토폴로지 분석<br>컴퓨터 네트워크의 토폴로지를 트리로 모델링할 때, 후위 순회를 사용하여 네트워크 지연, 대역폭, 신뢰성 등을 분석할 수 있다. 각 하위 네트워크의 특성을 먼저 계산한 후, 상위 네트워크의 특성을 결정한다.</p></li><li><p>XML/HTML 문서 처리<br>XML이나 HTML 문서는 트리 구조로 표현될 수 있으며, 문서를 렌더링하거나 처리할 때 후위 순회가 사용된다. 예를 들어, DOM(Document Object Model) 트리를 처리할 때 자식 요소를 먼저 처리한 후 부모 요소를 처리한다.</p></li></ol><h3 id=후위-순회의-변형>후위 순회의 변형<a hidden class=anchor aria-hidden=true href=#후위-순회의-변형>#</a></h3><ol><li><p>역후위 순회(Reverse Postorder Traversal)<br>역후위 순회는 오른쪽 서브트리를 먼저 방문한 후 왼쪽 서브트리를 방문하고 마지막으로 루트를 방문하는 방식이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1> 1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2> 2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3> 3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4> 4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5> 5</a>
</span><span class=lnt id=hl-26-6><a class=lnlinks href=#hl-26-6> 6</a>
</span><span class=lnt id=hl-26-7><a class=lnlinks href=#hl-26-7> 7</a>
</span><span class=lnt id=hl-26-8><a class=lnlinks href=#hl-26-8> 8</a>
</span><span class=lnt id=hl-26-9><a class=lnlinks href=#hl-26-9> 9</a>
</span><span class=lnt id=hl-26-10><a class=lnlinks href=#hl-26-10>10</a>
</span><span class=lnt id=hl-26-11><a class=lnlinks href=#hl-26-11>11</a>
</span><span class=lnt id=hl-26-12><a class=lnlinks href=#hl-26-12>12</a>
</span><span class=lnt id=hl-26-13><a class=lnlinks href=#hl-26-13>13</a>
</span><span class=lnt id=hl-26-14><a class=lnlinks href=#hl-26-14>14</a>
</span><span class=lnt id=hl-26-15><a class=lnlinks href=#hl-26-15>15</a>
</span><span class=lnt id=hl-26-16><a class=lnlinks href=#hl-26-16>16</a>
</span><span class=lnt id=hl-26-17><a class=lnlinks href=#hl-26-17>17</a>
</span><span class=lnt id=hl-26-18><a class=lnlinks href=#hl-26-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>reverse_postorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 왼쪽 서브트리 순회</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 현재 노드 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방법은 그래프의 깊이 우선 탐색(DFS)에서 후위 순회의 역순으로 위상 정렬(topological sort)을 구현할 때 사용될 수 있다.</p></li><li><p>모리스 후위 순회(Morris Postorder Traversal)<br>모리스 후위 순회는 추가 공간을 사용하지 않고(O(1) 공간 복잡도) 트리를 후위 순회하는 알고리즘이다.<br>이 방법은 복잡하지만 공간 효율성이 중요한 경우에 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1> 1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2> 2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3> 3</a>
</span><span class=lnt id=hl-27-4><a class=lnlinks href=#hl-27-4> 4</a>
</span><span class=lnt id=hl-27-5><a class=lnlinks href=#hl-27-5> 5</a>
</span><span class=lnt id=hl-27-6><a class=lnlinks href=#hl-27-6> 6</a>
</span><span class=lnt id=hl-27-7><a class=lnlinks href=#hl-27-7> 7</a>
</span><span class=lnt id=hl-27-8><a class=lnlinks href=#hl-27-8> 8</a>
</span><span class=lnt id=hl-27-9><a class=lnlinks href=#hl-27-9> 9</a>
</span><span class=lnt id=hl-27-10><a class=lnlinks href=#hl-27-10>10</a>
</span><span class=lnt id=hl-27-11><a class=lnlinks href=#hl-27-11>11</a>
</span><span class=lnt id=hl-27-12><a class=lnlinks href=#hl-27-12>12</a>
</span><span class=lnt id=hl-27-13><a class=lnlinks href=#hl-27-13>13</a>
</span><span class=lnt id=hl-27-14><a class=lnlinks href=#hl-27-14>14</a>
</span><span class=lnt id=hl-27-15><a class=lnlinks href=#hl-27-15>15</a>
</span><span class=lnt id=hl-27-16><a class=lnlinks href=#hl-27-16>16</a>
</span><span class=lnt id=hl-27-17><a class=lnlinks href=#hl-27-17>17</a>
</span><span class=lnt id=hl-27-18><a class=lnlinks href=#hl-27-18>18</a>
</span><span class=lnt id=hl-27-19><a class=lnlinks href=#hl-27-19>19</a>
</span><span class=lnt id=hl-27-20><a class=lnlinks href=#hl-27-20>20</a>
</span><span class=lnt id=hl-27-21><a class=lnlinks href=#hl-27-21>21</a>
</span><span class=lnt id=hl-27-22><a class=lnlinks href=#hl-27-22>22</a>
</span><span class=lnt id=hl-27-23><a class=lnlinks href=#hl-27-23>23</a>
</span><span class=lnt id=hl-27-24><a class=lnlinks href=#hl-27-24>24</a>
</span><span class=lnt id=hl-27-25><a class=lnlinks href=#hl-27-25>25</a>
</span><span class=lnt id=hl-27-26><a class=lnlinks href=#hl-27-26>26</a>
</span><span class=lnt id=hl-27-27><a class=lnlinks href=#hl-27-27>27</a>
</span><span class=lnt id=hl-27-28><a class=lnlinks href=#hl-27-28>28</a>
</span><span class=lnt id=hl-27-29><a class=lnlinks href=#hl-27-29>29</a>
</span><span class=lnt id=hl-27-30><a class=lnlinks href=#hl-27-30>30</a>
</span><span class=lnt id=hl-27-31><a class=lnlinks href=#hl-27-31>31</a>
</span><span class=lnt id=hl-27-32><a class=lnlinks href=#hl-27-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>morris_postorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>dummy</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dummy</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>dummy</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>predecessor</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=ow>and</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=o>!=</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span> <span class=o>=</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>current</span>
</span></span><span class=line><span class=cl>                <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 중요한 부분: 왼쪽 서브트리에서 올라오는 경로를 역순으로 기록</span>
</span></span><span class=line><span class=cl>                <span class=n>temp</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=n>p</span> <span class=o>!=</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>temp</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>p</span><span class=o>.</span><span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span> <span class=o>=</span> <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 역순으로 결과에 추가</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span><span class=o>.</span><span class=n>extend</span><span class=p>(</span><span class=nb>reversed</span><span class=p>(</span><span class=n>temp</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>predecessor</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>                <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>이 구현은 복잡하지만, 트리를 일시적으로 수정하여 추가 공간 없이 후위 순회를 가능하게 한다.</p></li></ol><h3 id=후위-순회를-사용한-실제-문제-해결-예시>후위 순회를 사용한 실제 문제 해결 예시<a hidden class=anchor aria-hidden=true href=#후위-순회를-사용한-실제-문제-해결-예시>#</a></h3><ol><li><p>이진 트리의 섬세한 연산: 서브트리 제거
이진 트리에서 특정 값을 가진 모든 서브트리를 제거하는 문제를 생각해봅보면:
후위 순회는 이러한 상향식 연산에 이상적이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1> 1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2> 2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3> 3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4> 4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5> 5</a>
</span><span class=lnt id=hl-28-6><a class=lnlinks href=#hl-28-6> 6</a>
</span><span class=lnt id=hl-28-7><a class=lnlinks href=#hl-28-7> 7</a>
</span><span class=lnt id=hl-28-8><a class=lnlinks href=#hl-28-8> 8</a>
</span><span class=lnt id=hl-28-9><a class=lnlinks href=#hl-28-9> 9</a>
</span><span class=lnt id=hl-28-10><a class=lnlinks href=#hl-28-10>10</a>
</span><span class=lnt id=hl-28-11><a class=lnlinks href=#hl-28-11>11</a>
</span><span class=lnt id=hl-28-12><a class=lnlinks href=#hl-28-12>12</a>
</span><span class=lnt id=hl-28-13><a class=lnlinks href=#hl-28-13>13</a>
</span><span class=lnt id=hl-28-14><a class=lnlinks href=#hl-28-14>14</a>
</span><span class=lnt id=hl-28-15><a class=lnlinks href=#hl-28-15>15</a>
</span><span class=lnt id=hl-28-16><a class=lnlinks href=#hl-28-16>16</a>
</span><span class=lnt id=hl-28-17><a class=lnlinks href=#hl-28-17>17</a>
</span><span class=lnt id=hl-28-18><a class=lnlinks href=#hl-28-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>remove_subtrees_with_value</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>target_value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    주어진 값을 가진 모든 서브트리를 트리에서 제거합니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리 처리</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>remove_subtrees_with_value</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>target_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리 처리</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>remove_subtrees_with_value</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>target_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드 값이 대상 값이면 현재 서브트리 제거</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span><span class=o>.</span><span class=n>value</span> <span class=o>==</span> <span class=n>target_value</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>root</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>이진 트리 노드의 총합 계산
이진 트리에서 각 노드 값의 총합을 계산하는 문제도 후위 순회로 효율적으로 해결할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1> 1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2> 2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3> 3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4> 4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5> 5</a>
</span><span class=lnt id=hl-29-6><a class=lnlinks href=#hl-29-6> 6</a>
</span><span class=lnt id=hl-29-7><a class=lnlinks href=#hl-29-7> 7</a>
</span><span class=lnt id=hl-29-8><a class=lnlinks href=#hl-29-8> 8</a>
</span><span class=lnt id=hl-29-9><a class=lnlinks href=#hl-29-9> 9</a>
</span><span class=lnt id=hl-29-10><a class=lnlinks href=#hl-29-10>10</a>
</span><span class=lnt id=hl-29-11><a class=lnlinks href=#hl-29-11>11</a>
</span><span class=lnt id=hl-29-12><a class=lnlinks href=#hl-29-12>12</a>
</span><span class=lnt id=hl-29-13><a class=lnlinks href=#hl-29-13>13</a>
</span><span class=lnt id=hl-29-14><a class=lnlinks href=#hl-29-14>14</a>
</span><span class=lnt id=hl-29-15><a class=lnlinks href=#hl-29-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>sum_of_nodes</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이진 트리의 모든 노드 값의 합을 계산합니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 왼쪽 서브트리의 합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>left_sum</span> <span class=o>=</span> <span class=n>sum_of_nodes</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 오른쪽 서브트리의 합 계산</span>
</span></span><span class=line><span class=cl>    <span class=n>right_sum</span> <span class=o>=</span> <span class=n>sum_of_nodes</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 현재 노드 값을 포함한 총합 반환</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>left_sum</span> <span class=o>+</span> <span class=n>right_sum</span> <span class=o>+</span> <span class=n>root</span><span class=o>.</span><span class=n>value</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=효율적인-후위-순회-구현을-위한-최적화-기법>효율적인 후위 순회 구현을 위한 최적화 기법<a hidden class=anchor aria-hidden=true href=#효율적인-후위-순회-구현을-위한-최적화-기법>#</a></h3><ol><li><p>제네레이터를 사용한 지연 평가(Lazy Evaluation)
Python에서는 제네레이터를 사용하여 메모리 효율적인 후위 순회를 구현할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1> 1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2> 2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3> 3</a>
</span><span class=lnt id=hl-30-4><a class=lnlinks href=#hl-30-4> 4</a>
</span><span class=lnt id=hl-30-5><a class=lnlinks href=#hl-30-5> 5</a>
</span><span class=lnt id=hl-30-6><a class=lnlinks href=#hl-30-6> 6</a>
</span><span class=lnt id=hl-30-7><a class=lnlinks href=#hl-30-7> 7</a>
</span><span class=lnt id=hl-30-8><a class=lnlinks href=#hl-30-8> 8</a>
</span><span class=lnt id=hl-30-9><a class=lnlinks href=#hl-30-9> 9</a>
</span><span class=lnt id=hl-30-10><a class=lnlinks href=#hl-30-10>10</a>
</span><span class=lnt id=hl-30-11><a class=lnlinks href=#hl-30-11>11</a>
</span><span class=lnt id=hl-30-12><a class=lnlinks href=#hl-30-12>12</a>
</span><span class=lnt id=hl-30-13><a class=lnlinks href=#hl-30-13>13</a>
</span><span class=lnt id=hl-30-14><a class=lnlinks href=#hl-30-14>14</a>
</span><span class=lnt id=hl-30-15><a class=lnlinks href=#hl-30-15>15</a>
</span><span class=lnt id=hl-30-16><a class=lnlinks href=#hl-30-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_generator</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    이진 트리의 후위 순회를 위한 제네레이터 함수입니다.
</span></span></span><span class=line><span class=cl><span class=s2>    메모리 효율적으로 노드를 하나씩 생성합니다.
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 제네레이터를 재귀적으로 호출하고 yield from으로 연결</span>
</span></span><span class=line><span class=cl>    <span class=k>yield from</span> <span class=n>postorder_traversal_generator</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>yield from</span> <span class=n>postorder_traversal_generator</span><span class=p>(</span><span class=n>root</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>yield</span> <span class=n>root</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>value</span> <span class=ow>in</span> <span class=n>postorder_traversal_generator</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 방법은 전체 결과 리스트를 메모리에 저장하지 않고, 필요할 때마다 다음 노드를 생성한다.</p></li><li><p>꼬리 재귀 최적화(Tail Recursion Optimization)
후위 순회의 기본 재귀 구현은 꼬리 재귀가 아니지만, 약간 수정하여 꼬리 재귀 형태로 변환할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1> 1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2> 2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3> 3</a>
</span><span class=lnt id=hl-31-4><a class=lnlinks href=#hl-31-4> 4</a>
</span><span class=lnt id=hl-31-5><a class=lnlinks href=#hl-31-5> 5</a>
</span><span class=lnt id=hl-31-6><a class=lnlinks href=#hl-31-6> 6</a>
</span><span class=lnt id=hl-31-7><a class=lnlinks href=#hl-31-7> 7</a>
</span><span class=lnt id=hl-31-8><a class=lnlinks href=#hl-31-8> 8</a>
</span><span class=lnt id=hl-31-9><a class=lnlinks href=#hl-31-9> 9</a>
</span><span class=lnt id=hl-31-10><a class=lnlinks href=#hl-31-10>10</a>
</span><span class=lnt id=hl-31-11><a class=lnlinks href=#hl-31-11>11</a>
</span><span class=lnt id=hl-31-12><a class=lnlinks href=#hl-31-12>12</a>
</span><span class=lnt id=hl-31-13><a class=lnlinks href=#hl-31-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_tail_recursive</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>postorder</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>result</span><span class=p>,</span> <span class=n>cont</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>cont</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>process_right</span><span class=p>(</span><span class=n>result</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>,</span> <span class=n>result</span><span class=p>,</span> <span class=k>lambda</span> <span class=n>r</span><span class=p>:</span> <span class=n>cont</span><span class=p>(</span><span class=n>r</span> <span class=o>+</span> <span class=p>[</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>,</span> <span class=n>result</span><span class=p>,</span> <span class=n>process_right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>postorder</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>result</span><span class=p>,</span> <span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 구현은 복잡하지만, 꼬리 재귀 최적화를 지원하는 언어나 컴파일러에서는 스택 오버플로우 위험 없이 효율적으로 실행될 수 있다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/tree/>Tree</a></li><li><a href=https://buenhyden.github.io/tags/binary-tree/>Binary-Tree</a></li><li><a href=https://buenhyden.github.io/tags/traversal/>Traversal</a></li><li><a href=https://buenhyden.github.io/tags/postorder-traversal/>PostOrder-Traversal</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/qa/sdlc/1-planning/><span class=title>« Prev</span><br><span>1. 계획 (Planning)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/><span class=title>Next »</span><br><span>LLVM vs 기존 컴파일러 비교</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>