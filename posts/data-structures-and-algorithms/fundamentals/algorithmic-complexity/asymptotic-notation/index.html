<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Asymptotic Notation | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Fundamentals,Algorithmic-Complexity,Asymptotic-Notation"><meta name=description content="점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/asymptotic-notation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/asymptotic-notation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/asymptotic-notation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Asymptotic Notation"><meta property="og:description" content="점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-06T10:59:00+00:00"><meta property="article:modified_time" content="2024-12-06T10:59:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Algorithmic-Complexity"><meta property="article:tag" content="Asymptotic-Notation"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Asymptotic Notation"><meta name=twitter:description content="점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"자료구조와 알고리즘 기초","item":""},{"@type":"ListItem","position":4,"name":"Algorithmic Complexity","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/"},{"@type":"ListItem","position":5,"name":"Asymptotic Notation","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/asymptotic-notation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Asymptotic Notation","name":"Asymptotic Notation","description":"점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.","keywords":["Data-Structures-and-Algorithms","Fundamentals","Algorithmic-Complexity","Asymptotic-Notation"],"articleBody":"점근적 표기법(Asymptotic Notation) 점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.\n알고리즘 분석에서 가장 중요한 도구 중 하나로, 알고리즘의 시간 복잡도와 공간 복잡도를 표현하는 데 사용된다.\n점근적 표기법은 알고리즘의 효율성을 분석하고 비교하는 강력한 도구이다.\n빅오, 빅오메가, 빅세타 등의 표기법을 통해 알고리즘의 시간 복잡도와 공간 복잡도를 표현할 수 있으며, 이는 효율적인 알고리즘을 설계하고 선택하는 데 필수적이다.\n그러나 점근적 표기법은 입력 크기가 무한히 커질 때의 동작만을 고려하며, 상수 인수나 낮은 차수의 항을 무시한다.\n따라서 실제 응용에서는 점근적 분석과 함께 구체적인 성능 테스트와 프로파일링을 병행하는 것이 중요하다.\n결국, 점근적 표기법은 알고리즘의 효율성을 이해하고 비교하는 데 필수적인 도구이지만, 이것만으로 모든 성능 문제를 해결할 수는 없으며, 실제 상황에 맞는 다양한 요소들을 종합적으로 고려해야 한다.\n점근적 표기법의 기본 개념 점근적 표기법은 함수의 증가율에 초점을 맞춘다.\n여기서 ‘함수’란 알고리즘의 수행 시간이나 필요한 메모리 양을 입력 크기의 함수로 표현한 것이다.\n점근적 표기법은 상수 인수나 낮은 차수의 항을 무시하고, 함수의 ‘증가 경향’만을 고려한다.\n예를 들어, 알고리즘의 수행 시간이 T(n) = 3n² + 2n + 1이라면, 입력 크기 n이 매우 큰 경우 이 함수는 n²에 비례하여 증가한다.\n이때 상수 계수 3과 낮은 차수 항인 2n, 1은 전체 증가율에 큰 영향을 미치지 않으므로 무시할 수 있다.\n주요 점근적 표기법 알고리즘 분석에서는 주로 세 가지 표기법이 사용된다.\nBig-O 표기법은 알고리즘의 최악의 상황을 보장하기 위해 주로 사용되며, 여기서 상수 계수나 낮은 차수 항들은 무시된다. Big-Omega 표기법은 알고리즘이 반드시 어느 정도 이상의 성능을 보여야 한다는 하한을 제공한다. Big-Theta 표기법은 Big-O와 Big-Omega가 동시에 만족될 때 사용되며, 알고리즘의 평균적 또는 정확한 실행 시간 성능을 나타낸다. 빅오 표기법(Big O Notation) - O(f(n)) 빅오 표기법은 알고리즘의 최악의 경우 또는 **상한선(upper bound)**을 나타낸다.\n함수 g(n)이 O(f(n))이라는 것은 충분히 큰 n에 대해 g(n)이 f(n)보다 빠르게 증가하지 않는다는 의미이다.\n수학적 정의:\ng(n) = O(f(n)) ⟺ ∃ c \u003e 0, ∃ n₀ \u003e 0 such that 0 ≤ g(n) ≤ c × f(n) for all n ≥ n₀\n즉, 어떤 양의 상수 c와 n₀가 존재하여, n₀보다 큰 모든 n에 대해 g(n)이 c × f(n)보다 작거나 같다면, g(n) = O(f(n))이다.\n예시:\n3n² + 2n + 1 = O(n²), 왜냐하면 n이 충분히 크면 3n² + 2n + 1 ≤ 4n²이기 때문이다. n + log n = O(n), 왜냐하면 n이 충분히 크면 log n \u003c n이므로 n + log n \u003c 2n이기 때문이다. 빅오메가 표기법(Big Omega Notation) - Ω(f(n)) 빅오메가 표기법은 알고리즘의 최선의 경우 또는 **하한선(lower bound)**을 나타낸다.\n함수 g(n)이 Ω(f(n))이라는 것은 충분히 큰 n에 대해 g(n)이 f(n)보다 느리게 증가하지 않는다는 의미이다.\n수학적 정의:\ng(n) = Ω(f(n)) ⟺ ∃ c \u003e 0, ∃ n₀ \u003e 0 such that 0 ≤ c × f(n) ≤ g(n) for all n ≥ n₀\n즉, 어떤 양의 상수 c와 n₀가 존재하여, n₀보다 큰 모든 n에 대해 g(n)이 c × f(n)보다 크거나 같다면, g(n) = Ω(f(n))이다.\n예시:\n3n² + 2n + 1 = Ω(n²), 왜냐하면 n이 충분히 크면 3n² + 2n + 1 ≥ 3n²이기 때문이다. n² + n = Ω(n²), 왜냐하면 n이 충분히 크면 n² + n ≥ n²이기 때문이다. 빅세타 표기법(Big Theta Notation) - Θ(f(n)) 빅세타 표기법은 알고리즘의 평균적인 경우 또는 **점근적으로 정확한 경계(asymptotically tight bound)**를 나타낸다.\n함수 g(n)이 Θ(f(n))이라는 것은 g(n)이 f(n)과 같은 증가율을 가진다는 의미이다.\n수학적 정의:\ng(n) = Θ(f(n)) ⟺ g(n) = O(f(n)) and g(n) = Ω(f(n))\n즉, g(n)이 f(n)의 상한선이면서 동시에 하한선이라면, g(n) = Θ(f(n))이다.\n예시:\n3n² + 2n + 1 = Θ(n²), 왜냐하면 이 함수는 O(n²)이면서 동시에 Ω(n²)이기 때문이다. 5n log n + 3n = Θ(n log n), 왜냐하면 이 함수는 O(n log n)이면서 동시에 Ω(n log n)이기 때문이다. 추가적인 점근적 표기법 소빅오 표기법(Little O Notation) - o(f(n)) 소빅오 표기법은 **엄격한 상한선(strict upper bound)**을 나타낸다.\n빅오 표기법과 달리, 같은 증가율을 허용하지 않고 반드시 더 느리게 증가해야 한다.\n수학적 정의:\ng(n) = o(f(n)) ⟺ limn→∞ g(n)/f(n) = 0\n즉, n이 무한대로 갈 때 g(n)/f(n)의 극한이 0이면, g(n) = o(f(n))이다.\n예시:\nn = o(n²), 왜냐하면 limn→∞ n/n² = limn→∞ 1/n = 0이기 때문이다. log n = o(n), 왜냐하면 limn→∞ log n/n = 0이기 때문이다. 소빅오메가 표기법(Little Omega Notation) - ω(f(n)) 소빅오메가 표기법은 **엄격한 하한선(strict lower bound)**을 나타낸다.\n빅오메가 표기법과 달리, 같은 증가율을 허용하지 않고 반드시 더 빠르게 증가해야 한다.\n수학적 정의:\ng(n) = ω(f(n)) ⟺ limn→∞ g(n)/f(n) = ∞\n즉, n이 무한대로 갈 때 g(n)/f(n)의 극한이 무한대이면, g(n) = ω(f(n))이다.\n예시:\nn² = ω(n), 왜냐하면 limn→∞ n²/n = limn→∞ n = ∞이기 때문이다. n log n = ω(n), 왜냐하면 limn→∞ n log n/n = limn→∞ log n = ∞이기 때문이다. 점근적 표기법의 성질 전이성(Transitivity):\n점근적 표기법은 전이성을 가진다:\n만약 f(n) = O(g(n))이고 g(n) = O(h(n))이면, f(n) = O(h(n)). 만약 f(n) = Ω(g(n))이고 g(n) = Ω(h(n))이면, f(n) = Ω(h(n)). 만약 f(n) = Θ(g(n))이고 g(n) = Θ(h(n))이면, f(n) = Θ(h(n)). 만약 f(n) = o(g(n))이고 g(n) = o(h(n))이면, f(n) = o(h(n)). 만약 f(n) = ω(g(n))이고 g(n) = ω(h(n))이면, f(n) = ω(h(n)). 반사성(Reflexivity):\n일부 점근적 표기법은 반사성을 가진다:\nf(n) = O(f(n)) f(n) = Ω(f(n)) f(n) = Θ(f(n))\n그러나 소빅오와 소빅오메가는 반사성을 가지지 않는다: f(n) ≠ o(f(n)) f(n) ≠ ω(f(n)) 대칭성(Symmetry)\n빅세타만이 대칭성을 가진다:\n만약 f(n) = Θ(g(n))이면, g(n) = Θ(f(n)).\n다른 표기법들은 대칭성을 가지지 않는다. 가산성(Additivity)\n점근적 표기법은 다음과 같은 가산성을 가진다:\nO(f(n)) + O(g(n)) = O(max(f(n), g(n))) Ω(f(n)) + Ω(g(n)) = Ω(max(f(n), g(n))) Θ(f(n)) + Θ(g(n)) = Θ(max(f(n), g(n))) 곱셈성(Multiplicativity)\n점근적 표기법은 다음과 같은 곱셈성을 가진다:\nO(f(n)) × O(g(n)) = O(f(n) × g(n)) Ω(f(n)) × Ω(g(n)) = Ω(f(n) × g(n)) Θ(f(n)) × Θ(g(n)) = Θ(f(n) × g(n)) 점근적 표기법의 이해와 적용 상수 인수 무시\n점근적 표기법에서는 상수 인수를 무시한다:\nO(c × f(n)) = O(f(n)), 여기서 c \u003e 0 Ω(c × f(n)) = Ω(f(n)), 여기서 c \u003e 0 Θ(c × f(n)) = Θ(f(n)), 여기서 c \u003e 0\n예: O(5n²) = O(n²), Ω(3n) = Ω(n), Θ(2n log n) = Θ(n log n)\n이것은 입력 크기가 무한히 커질 때, 상수 인수가 전체 증가율에 미치는 영향이 무시할 만큼 작아지기 때문이다. 낮은 차수 항 무시\n점근적 표기법에서는 낮은 차수의 항을 무시한다:\nO(f(n) + g(n)) = O(f(n)), 여기서 f(n)이 g(n)보다 더 빠르게 증가하는 경우 Ω(f(n) + g(n)) = Ω(f(n)), 여기서 f(n)이 g(n)보다 더 빠르게 증가하는 경우 Θ(f(n) + g(n)) = Θ(f(n)), 여기서 f(n)이 g(n)보다 더 빠르게 증가하는 경우\n예: O(n² + n) = O(n²), Ω(n log n + n) = Ω(n log n), Θ(2^n + n²) = Θ(2^n)\n이것은 입력 크기가 무한히 커질 때, 낮은 차수의 항이 전체 증가율에 미치는 영향이 무시할 만큼 작아지기 때문이다. 로그의 밑 무시\n점근적 표기법에서는 로그의 밑을 무시한다:\nO(loga n) = O(logb n), 여기서 a, b \u003e 1 Ω(loga n) = Ω(logb n), 여기서 a, b \u003e 1 Θ(loga n) = Θ(logb n), 여기서 a, b \u003e 1\n예: O(log2 n) = O(log10 n) = O(ln n) = O(log n)\n이것은 서로 다른 밑을 가진 로그 함수들이 상수 배 차이만 날 뿐, 증가율은 동일하기 때문이다 (loga n = logb n / logb a). 점근적 표기법의 잘못된 이해와 오류 빅오는 정확한 증가율이 아닌 상한선\n흔한 오해 중 하나는 빅오 표기법이 알고리즘의 정확한 증가율을 나타낸다고 생각하는 것이다. 실제로 빅오는 상한선만을 나타냅니다.\n예를 들어, 선형 검색 알고리즘은 O(n)이지만, 이것이 항상 n번의 연산을 수행한다는 의미는 아니다. 최선의 경우(찾는 원소가 배열의 첫 번째 위치에 있는 경우) O(1)만에 완료될 수 있다.\n점근적 표기법의 남용\n점근적 표기법은 입력 크기가 무한히 커질 때의 동작을 분석하기 위한 것이다.\n작은 입력 크기에 대해서는 실제 성능이 점근적 표기법과 크게 다를 수 있다.\n예를 들어, 알고리즘 A가 T(n) = 1,000n이고 알고리즘 B가 T(n) = n²인 경우, 점근적으로는 알고리즘 A가 더 효율적이다(O(n) vs O(n²)). 하지만 n \u003c 1,000인 작은 입력에 대해서는, 알고리즘 B가 더 빠를 수 있다.\n상수 인수의 중요성 실제 응용에서는 상수 인수가 중요한 영향을 미칠 수 있다. 점근적 표기법은 이러한 상수 인수를 무시하기 때문에, 실제 성능을 정확히 예측하기 위해서는 추가적인 분석이 필요하다.\n예를 들어, 두 알고리즘 모두 O(n)이지만, 하나는 2n, 다른 하나는 100n의 시간이 필요하다면, 첫 번째 알고리즘이 실제로는 50배 더 빠르다.\n알고리즘 분석에서의 점근적 표기법 활용 알고리즘 비교 점근적 표기법은 다양한 알고리즘의 효율성을 비교하는 데 유용하다.\n예를 들어, 정렬 알고리즘을 비교할 때:\n버블 정렬: O(n²) 퀵 정렬: O(n log n) (평균적인 경우) 계수 정렬: O(n + k), 여기서 k는 입력 범위\n일반적으로, 낮은 시간 복잡도를 가진 알고리즘이 더 효율적이라고 볼 수 있다.\n그러나 때로는 공간 복잡도, 구현의 용이성, 안정성 등 다른 요소들도 고려해야 한다. 최적화 결정 점근적 표기법은 코드 최적화의 필요성을 결정하는 데 도움이 된다.\n만약 알고리즘이 이미 최적의 시간 복잡도(예: O(n log n)의 정렬)를 가지고 있다면, 상수 인수를 줄이기 위한 최적화에 시간을 투자할 수 있다.\n반면, 시간 복잡도가 높은 알고리즘(예: O(n²)의 정렬)은 더 효율적인 알고리즘으로 교체하는 것이 더 큰 성능 향상을 가져올 수 있다.\n스케일링 예측 점근적 표기법은 입력 크기가 증가할 때 알고리즘의 성능이 어떻게 변화할지 예측하는 데 유용하다. 예를 들어, O(n²) 알고리즘에서 입력 크기가 2배로 증가하면 실행 시간은 약 4배로 증가한다. 이러한 예측은 시스템의 확장성(scalability)을 계획하는 데 중요하다.\n복잡한 알고리즘의 점근적 분석 재귀 알고리즘 재귀 알고리즘의 시간 복잡도는 주로 재귀 호출의 수와 각 호출당 수행되는 작업량을 분석하여 결정된다.\n이를 분석하기 위해 점화식(recurrence relation)을 사용하고, 이를 해결하여 점근적 표기법을 얻는다.\n예를 들어, 병합 정렬의 시간 복잡도는 다음 점화식으로 표현됩니다: T(n) = 2T(n/2) + O(n)\n이를 해결하면 T(n) = O(n log n)이 된다.\n마스터 정리(Master Theorem) 마스터 정리는 많은 분할 정복(divide-and-conquer) 알고리즘의 시간 복잡도를 분석하는 데 유용한 도구이다.\n다음 형태의 점화식에 적용할 수 있다:\nT(n) = aT(n/b) + f(n) 여기서 a ≥ 1, b \u003e 1이고, f(n)은 점근적으로 양의 함수이다.\n마스터 정리는 세 가지 경우로 나눠 해결책을 제시한다:\n만약 f(n) = O(n^(logb a - ε))이면, 어떤 ε \u003e 0에 대해, T(n) = Θ(n^(logb a)) 만약 f(n) = Θ(n^(logb a))이면, T(n) = Θ(n^(logb a) log n) 만약 f(n) = Ω(n^(logb a + ε))이면, 어떤 ε \u003e 0에 대해, 그리고 af(n/b) ≤ cf(n)을 만족하는 c \u003c 1이 존재한다면, T(n) = Θ(f(n))\n이 정리를 사용하면 복잡한 분할 정복 알고리즘의 시간 복잡도를 쉽게 결정할 수 있다. 복잡한 알고리즘 예시 트리 기반 알고리즘, 그래프 알고리즘, 동적 프로그래밍 등 복잡한 알고리즘의 시간 복잡도를 분석할 때도 점근적 표기법이 유용하다:\n예를 들어, 다익스트라 알고리즘의 시간 복잡도는 구현 방법에 따라 다를 수 있다:\n기본 구현: O(V²), 여기서 V는 정점의 수 우선순위 큐 구현: O(E log V), 여기서 E는 간선의 수, V는 정점의 수 이러한 분석은 알고리즘의 효율성을 평가하고, 특정 문제에 가장 적합한 알고리즘을 선택하는 데 도움이 된다.\n실제 응용에서의 점근적 표기법 알고리즘 설계\n점근적 표기법은 알고리즘 설계 단계에서 효율성 목표를 설정하는 데 도움이 된다.\n예를 들어, 대규모 데이터셋을 처리해야 한다면, O(n²) 이상의 시간 복잡도를 가진 알고리즘은 피해야 한다.\n성능 최적화\n점근적 표기법은 코드의 어떤 부분을 최적화해야 하는지 우선순위를 정하는 데 도움이 된다.\n중첩된 루프(O(n²))는 단일 루프(O(n))보다 최적화의 우선순위가 높다.\n시스템 설계\n대규모 시스템을 설계할 때, 점근적 표기법은 각 구성 요소의 확장성을 평가하는 데 도움이 된다.\n예를 들어, 데이터베이스 쿼리의 복잡도, 네트워크 프로토콜의 효율성 등을 분석할 수 있다.\n참고 및 출처 ","wordCount":"1711","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-06T10:59:00Z","dateModified":"2024-12-06T10:59:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/asymptotic-notation/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href>자료구조와 알고리즘 기초</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/algorithmic-complexity/>Algorithmic Complexity</a></div><h1 class="post-title entry-hint-parent">Asymptotic Notation</h1><div class=post-description>점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.</div><div class=post-meta><span title='2024-12-06 10:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Fundamentals/Algorithmic%20Complexity/Asymptotic-Notation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#점근적-표기법asymptotic-notation>점근적 표기법(Asymptotic Notation)</a><ul><li><a href=#점근적-표기법의-기본-개념>점근적 표기법의 기본 개념</a></li><li><a href=#주요-점근적-표기법>주요 점근적 표기법</a></li><li><a href=#추가적인-점근적-표기법>추가적인 점근적 표기법</a></li><li><a href=#점근적-표기법의-성질>점근적 표기법의 성질</a></li><li><a href=#점근적-표기법의-이해와-적용>점근적 표기법의 이해와 적용</a></li><li><a href=#점근적-표기법의-잘못된-이해와-오류>점근적 표기법의 잘못된 이해와 오류</a></li><li><a href=#알고리즘-분석에서의-점근적-표기법-활용>알고리즘 분석에서의 점근적 표기법 활용</a></li><li><a href=#복잡한-알고리즘의-점근적-분석>복잡한 알고리즘의 점근적 분석</a></li><li><a href=#실제-응용에서의-점근적-표기법>실제 응용에서의 점근적 표기법</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=점근적-표기법asymptotic-notation>점근적 표기법(Asymptotic Notation)<a hidden class=anchor aria-hidden=true href=#점근적-표기법asymptotic-notation>#</a></h2><p>점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.<br>알고리즘 분석에서 가장 중요한 도구 중 하나로, 알고리즘의 시간 복잡도와 공간 복잡도를 표현하는 데 사용된다.</p><p>점근적 표기법은 알고리즘의 효율성을 분석하고 비교하는 강력한 도구이다.<br>빅오, 빅오메가, 빅세타 등의 표기법을 통해 알고리즘의 시간 복잡도와 공간 복잡도를 표현할 수 있으며, 이는 효율적인 알고리즘을 설계하고 선택하는 데 필수적이다.</p><p>그러나 점근적 표기법은 입력 크기가 무한히 커질 때의 동작만을 고려하며, 상수 인수나 낮은 차수의 항을 무시한다.<br>따라서 실제 응용에서는 점근적 분석과 함께 구체적인 성능 테스트와 프로파일링을 병행하는 것이 중요하다.</p><p>결국, 점근적 표기법은 알고리즘의 효율성을 이해하고 비교하는 데 필수적인 도구이지만, 이것만으로 모든 성능 문제를 해결할 수는 없으며, 실제 상황에 맞는 다양한 요소들을 종합적으로 고려해야 한다.</p><h3 id=점근적-표기법의-기본-개념>점근적 표기법의 기본 개념<a hidden class=anchor aria-hidden=true href=#점근적-표기법의-기본-개념>#</a></h3><p>점근적 표기법은 함수의 증가율에 초점을 맞춘다.<br>여기서 &lsquo;함수&rsquo;란 알고리즘의 수행 시간이나 필요한 메모리 양을 입력 크기의 함수로 표현한 것이다.<br>점근적 표기법은 상수 인수나 낮은 차수의 항을 무시하고, 함수의 &lsquo;증가 경향&rsquo;만을 고려한다.</p><p>예를 들어, 알고리즘의 수행 시간이 <code>T(n) = 3n² + 2n + 1</code>이라면, 입력 크기 n이 매우 큰 경우 이 함수는 <code>n²</code>에 비례하여 증가한다.<br>이때 상수 계수 3과 낮은 차수 항인 2n, 1은 전체 증가율에 큰 영향을 미치지 않으므로 무시할 수 있다.</p><h3 id=주요-점근적-표기법>주요 점근적 표기법<a hidden class=anchor aria-hidden=true href=#주요-점근적-표기법>#</a></h3><p>알고리즘 분석에서는 주로 세 가지 표기법이 사용된다.</p><ul><li><strong>Big-O 표기법</strong>은 알고리즘의 최악의 상황을 보장하기 위해 주로 사용되며, 여기서 상수 계수나 낮은 차수 항들은 무시된다.</li><li><strong>Big-Omega 표기법</strong>은 알고리즘이 반드시 어느 정도 이상의 성능을 보여야 한다는 하한을 제공한다.</li><li><strong>Big-Theta 표기법</strong>은 Big-O와 Big-Omega가 동시에 만족될 때 사용되며, 알고리즘의 평균적 또는 정확한 실행 시간 성능을 나타낸다.</li></ul><h4 id=빅오-표기법big-o-notation---ofn>빅오 표기법(Big O Notation) - O(f(n))<a hidden class=anchor aria-hidden=true href=#빅오-표기법big-o-notation---ofn>#</a></h4><p>빅오 표기법은 알고리즘의 <strong>최악의 경우</strong> 또는 **상한선(upper bound)**을 나타낸다.<br>함수 g(n)이 O(f(n))이라는 것은 충분히 큰 n에 대해 g(n)이 f(n)보다 빠르게 증가하지 않는다는 의미이다.</p><p>수학적 정의:<br>g(n) = O(f(n)) ⟺ ∃ c > 0, ∃ n₀ > 0 such that 0 ≤ g(n) ≤ c × f(n) for all n ≥ n₀</p><p>즉, 어떤 양의 상수 c와 n₀가 존재하여, n₀보다 큰 모든 n에 대해 g(n)이 c × f(n)보다 작거나 같다면, g(n) = O(f(n))이다.</p><p>예시:</p><ul><li>3n² + 2n + 1 = O(n²), 왜냐하면 n이 충분히 크면 3n² + 2n + 1 ≤ 4n²이기 때문이다.</li><li>n + log n = O(n), 왜냐하면 n이 충분히 크면 log n &lt; n이므로 n + log n &lt; 2n이기 때문이다.</li></ul><h4 id=빅오메가-표기법big-omega-notation---ωfn>빅오메가 표기법(Big Omega Notation) - Ω(f(n))<a hidden class=anchor aria-hidden=true href=#빅오메가-표기법big-omega-notation---ωfn>#</a></h4><p>빅오메가 표기법은 알고리즘의 <strong>최선의 경우</strong> 또는 **하한선(lower bound)**을 나타낸다.<br>함수 g(n)이 Ω(f(n))이라는 것은 충분히 큰 n에 대해 g(n)이 f(n)보다 느리게 증가하지 않는다는 의미이다.</p><p>수학적 정의:<br>g(n) = Ω(f(n)) ⟺ ∃ c > 0, ∃ n₀ > 0 such that 0 ≤ c × f(n) ≤ g(n) for all n ≥ n₀</p><p>즉, 어떤 양의 상수 c와 n₀가 존재하여, n₀보다 큰 모든 n에 대해 g(n)이 c × f(n)보다 크거나 같다면, g(n) = Ω(f(n))이다.</p><p>예시:</p><ul><li>3n² + 2n + 1 = Ω(n²), 왜냐하면 n이 충분히 크면 3n² + 2n + 1 ≥ 3n²이기 때문이다.</li><li>n² + n = Ω(n²), 왜냐하면 n이 충분히 크면 n² + n ≥ n²이기 때문이다.</li></ul><h4 id=빅세타-표기법big-theta-notation---θfn>빅세타 표기법(Big Theta Notation) - Θ(f(n))<a hidden class=anchor aria-hidden=true href=#빅세타-표기법big-theta-notation---θfn>#</a></h4><p>빅세타 표기법은 알고리즘의 <strong>평균적인 경우</strong> 또는 **점근적으로 정확한 경계(asymptotically tight bound)**를 나타낸다.<br>함수 g(n)이 Θ(f(n))이라는 것은 g(n)이 f(n)과 같은 증가율을 가진다는 의미이다.</p><p>수학적 정의:<br>g(n) = Θ(f(n)) ⟺ g(n) = O(f(n)) and g(n) = Ω(f(n))</p><p>즉, g(n)이 f(n)의 상한선이면서 동시에 하한선이라면, g(n) = Θ(f(n))이다.</p><p>예시:</p><ul><li>3n² + 2n + 1 = Θ(n²), 왜냐하면 이 함수는 O(n²)이면서 동시에 Ω(n²)이기 때문이다.</li><li>5n log n + 3n = Θ(n log n), 왜냐하면 이 함수는 O(n log n)이면서 동시에 Ω(n log n)이기 때문이다.</li></ul><h3 id=추가적인-점근적-표기법>추가적인 점근적 표기법<a hidden class=anchor aria-hidden=true href=#추가적인-점근적-표기법>#</a></h3><h4 id=소빅오-표기법little-o-notation---ofn>소빅오 표기법(Little O Notation) - o(f(n))<a hidden class=anchor aria-hidden=true href=#소빅오-표기법little-o-notation---ofn>#</a></h4><p>소빅오 표기법은 **엄격한 상한선(strict upper bound)**을 나타낸다.<br>빅오 표기법과 달리, 같은 증가율을 허용하지 않고 반드시 더 느리게 증가해야 한다.</p><p>수학적 정의:<br>g(n) = o(f(n)) ⟺ lim<sub>n→∞</sub> g(n)/f(n) = 0</p><p>즉, n이 무한대로 갈 때 g(n)/f(n)의 극한이 0이면, g(n) = o(f(n))이다.</p><p>예시:</p><ul><li>n = o(n²), 왜냐하면 lim<sub>n→∞</sub> n/n² = lim<sub>n→∞</sub> 1/n = 0이기 때문이다.</li><li>log n = o(n), 왜냐하면 lim<sub>n→∞</sub> log n/n = 0이기 때문이다.</li></ul><h4 id=소빅오메가-표기법little-omega-notation---ωfn>소빅오메가 표기법(Little Omega Notation) - ω(f(n))<a hidden class=anchor aria-hidden=true href=#소빅오메가-표기법little-omega-notation---ωfn>#</a></h4><p>소빅오메가 표기법은 **엄격한 하한선(strict lower bound)**을 나타낸다.<br>빅오메가 표기법과 달리, 같은 증가율을 허용하지 않고 반드시 더 빠르게 증가해야 한다.</p><p>수학적 정의:<br>g(n) = ω(f(n)) ⟺ lim<sub>n→∞</sub> g(n)/f(n) = ∞</p><p>즉, n이 무한대로 갈 때 g(n)/f(n)의 극한이 무한대이면, g(n) = ω(f(n))이다.</p><p>예시:</p><ul><li>n² = ω(n), 왜냐하면 lim<sub>n→∞</sub> n²/n = lim<sub>n→∞</sub> n = ∞이기 때문이다.</li><li>n log n = ω(n), 왜냐하면 lim<sub>n→∞</sub> n log n/n = lim<sub>n→∞</sub> log n = ∞이기 때문이다.</li></ul><h3 id=점근적-표기법의-성질>점근적 표기법의 성질<a hidden class=anchor aria-hidden=true href=#점근적-표기법의-성질>#</a></h3><ol><li><p>전이성(Transitivity):<br>점근적 표기법은 전이성을 가진다:</p><ul><li>만약 f(n) = O(g(n))이고 g(n) = O(h(n))이면, f(n) = O(h(n)).</li><li>만약 f(n) = Ω(g(n))이고 g(n) = Ω(h(n))이면, f(n) = Ω(h(n)).</li><li>만약 f(n) = Θ(g(n))이고 g(n) = Θ(h(n))이면, f(n) = Θ(h(n)).</li><li>만약 f(n) = o(g(n))이고 g(n) = o(h(n))이면, f(n) = o(h(n)).</li><li>만약 f(n) = ω(g(n))이고 g(n) = ω(h(n))이면, f(n) = ω(h(n)).</li></ul></li><li><p>반사성(Reflexivity):<br>일부 점근적 표기법은 반사성을 가진다:</p><ul><li>f(n) = O(f(n))</li><li>f(n) = Ω(f(n))</li><li>f(n) = Θ(f(n))<br>그러나 소빅오와 소빅오메가는 반사성을 가지지 않는다:</li><li>f(n) ≠ o(f(n))</li><li>f(n) ≠ ω(f(n))</li></ul></li><li><p>대칭성(Symmetry)<br>빅세타만이 대칭성을 가진다:</p><ul><li>만약 f(n) = Θ(g(n))이면, g(n) = Θ(f(n)).<br>다른 표기법들은 대칭성을 가지지 않는다.</li></ul></li><li><p>가산성(Additivity)<br>점근적 표기법은 다음과 같은 가산성을 가진다:</p><ul><li>O(f(n)) + O(g(n)) = O(max(f(n), g(n)))</li><li>Ω(f(n)) + Ω(g(n)) = Ω(max(f(n), g(n)))</li><li>Θ(f(n)) + Θ(g(n)) = Θ(max(f(n), g(n)))</li></ul></li><li><p>곱셈성(Multiplicativity)<br>점근적 표기법은 다음과 같은 곱셈성을 가진다:</p><ul><li>O(f(n)) × O(g(n)) = O(f(n) × g(n))</li><li>Ω(f(n)) × Ω(g(n)) = Ω(f(n) × g(n))</li><li>Θ(f(n)) × Θ(g(n)) = Θ(f(n) × g(n))</li></ul></li></ol><h3 id=점근적-표기법의-이해와-적용>점근적 표기법의 이해와 적용<a hidden class=anchor aria-hidden=true href=#점근적-표기법의-이해와-적용>#</a></h3><ol><li><p>상수 인수 무시<br>점근적 표기법에서는 상수 인수를 무시한다:</p><ul><li>O(c × f(n)) = O(f(n)), 여기서 c > 0</li><li>Ω(c × f(n)) = Ω(f(n)), 여기서 c > 0</li><li>Θ(c × f(n)) = Θ(f(n)), 여기서 c > 0<br>예: O(5n²) = O(n²), Ω(3n) = Ω(n), Θ(2n log n) = Θ(n log n)<br>이것은 입력 크기가 무한히 커질 때, 상수 인수가 전체 증가율에 미치는 영향이 무시할 만큼 작아지기 때문이다.</li></ul></li><li><p>낮은 차수 항 무시<br>점근적 표기법에서는 낮은 차수의 항을 무시한다:</p><ul><li>O(f(n) + g(n)) = O(f(n)), 여기서 f(n)이 g(n)보다 더 빠르게 증가하는 경우</li><li>Ω(f(n) + g(n)) = Ω(f(n)), 여기서 f(n)이 g(n)보다 더 빠르게 증가하는 경우</li><li>Θ(f(n) + g(n)) = Θ(f(n)), 여기서 f(n)이 g(n)보다 더 빠르게 증가하는 경우<br>예: O(n² + n) = O(n²), Ω(n log n + n) = Ω(n log n), Θ(2^n + n²) = Θ(2^n)<br>이것은 입력 크기가 무한히 커질 때, 낮은 차수의 항이 전체 증가율에 미치는 영향이 무시할 만큼 작아지기 때문이다.</li></ul></li><li><p>로그의 밑 무시<br>점근적 표기법에서는 로그의 밑을 무시한다:</p><ul><li>O(log<sub>a</sub> n) = O(log<sub>b</sub> n), 여기서 a, b > 1</li><li>Ω(log<sub>a</sub> n) = Ω(log<sub>b</sub> n), 여기서 a, b > 1</li><li>Θ(log<sub>a</sub> n) = Θ(log<sub>b</sub> n), 여기서 a, b > 1<br>예: O(log<sub>2</sub> n) = O(log<sub>10</sub> n) = O(ln n) = O(log n)<br>이것은 서로 다른 밑을 가진 로그 함수들이 상수 배 차이만 날 뿐, 증가율은 동일하기 때문이다 (log<sub>a</sub> n = log<sub>b</sub> n / log<sub>b</sub> a).</li></ul></li></ol><h3 id=점근적-표기법의-잘못된-이해와-오류>점근적 표기법의 잘못된 이해와 오류<a hidden class=anchor aria-hidden=true href=#점근적-표기법의-잘못된-이해와-오류>#</a></h3><ol><li><p>빅오는 정확한 증가율이 아닌 상한선<br>흔한 오해 중 하나는 빅오 표기법이 알고리즘의 정확한 증가율을 나타낸다고 생각하는 것이다. 실제로 빅오는 상한선만을 나타냅니다.<br>예를 들어, 선형 검색 알고리즘은 O(n)이지만, 이것이 항상 n번의 연산을 수행한다는 의미는 아니다. 최선의 경우(찾는 원소가 배열의 첫 번째 위치에 있는 경우) O(1)만에 완료될 수 있다.</p></li><li><p>점근적 표기법의 남용<br>점근적 표기법은 입력 크기가 무한히 커질 때의 동작을 분석하기 위한 것이다.<br>작은 입력 크기에 대해서는 실제 성능이 점근적 표기법과 크게 다를 수 있다.<br>예를 들어, 알고리즘 A가 T(n) = 1,000n이고 알고리즘 B가 T(n) = n²인 경우, 점근적으로는 알고리즘 A가 더 효율적이다(O(n) vs O(n²)). 하지만 n &lt; 1,000인 작은 입력에 대해서는, 알고리즘 B가 더 빠를 수 있다.</p></li><li><p>상수 인수의 중요성
실제 응용에서는 상수 인수가 중요한 영향을 미칠 수 있다. 점근적 표기법은 이러한 상수 인수를 무시하기 때문에, 실제 성능을 정확히 예측하기 위해서는 추가적인 분석이 필요하다.<br>예를 들어, 두 알고리즘 모두 O(n)이지만, 하나는 2n, 다른 하나는 100n의 시간이 필요하다면, 첫 번째 알고리즘이 실제로는 50배 더 빠르다.</p></li></ol><h3 id=알고리즘-분석에서의-점근적-표기법-활용>알고리즘 분석에서의 점근적 표기법 활용<a hidden class=anchor aria-hidden=true href=#알고리즘-분석에서의-점근적-표기법-활용>#</a></h3><h4 id=알고리즘-비교>알고리즘 비교<a hidden class=anchor aria-hidden=true href=#알고리즘-비교>#</a></h4><p>점근적 표기법은 다양한 알고리즘의 효율성을 비교하는 데 유용하다.</p><p>예를 들어, 정렬 알고리즘을 비교할 때:</p><ul><li>버블 정렬: O(n²)</li><li>퀵 정렬: O(n log n) (평균적인 경우)</li><li>계수 정렬: O(n + k), 여기서 k는 입력 범위<br>일반적으로, 낮은 시간 복잡도를 가진 알고리즘이 더 효율적이라고 볼 수 있다.<br>그러나 때로는 공간 복잡도, 구현의 용이성, 안정성 등 다른 요소들도 고려해야 한다.</li></ul><h4 id=최적화-결정>최적화 결정<a hidden class=anchor aria-hidden=true href=#최적화-결정>#</a></h4><p>점근적 표기법은 코드 최적화의 필요성을 결정하는 데 도움이 된다.<br>만약 알고리즘이 이미 최적의 시간 복잡도(예: O(n log n)의 정렬)를 가지고 있다면, 상수 인수를 줄이기 위한 최적화에 시간을 투자할 수 있다.<br>반면, 시간 복잡도가 높은 알고리즘(예: O(n²)의 정렬)은 더 효율적인 알고리즘으로 교체하는 것이 더 큰 성능 향상을 가져올 수 있다.</p><h4 id=스케일링-예측>스케일링 예측<a hidden class=anchor aria-hidden=true href=#스케일링-예측>#</a></h4><p>점근적 표기법은 입력 크기가 증가할 때 알고리즘의 성능이 어떻게 변화할지 예측하는 데 유용하다. 예를 들어, O(n²) 알고리즘에서 입력 크기가 2배로 증가하면 실행 시간은 약 4배로 증가한다. 이러한 예측은 시스템의 확장성(scalability)을 계획하는 데 중요하다.</p><h3 id=복잡한-알고리즘의-점근적-분석>복잡한 알고리즘의 점근적 분석<a hidden class=anchor aria-hidden=true href=#복잡한-알고리즘의-점근적-분석>#</a></h3><h4 id=재귀-알고리즘>재귀 알고리즘<a hidden class=anchor aria-hidden=true href=#재귀-알고리즘>#</a></h4><p>재귀 알고리즘의 시간 복잡도는 주로 재귀 호출의 수와 각 호출당 수행되는 작업량을 분석하여 결정된다.<br>이를 분석하기 위해 점화식(recurrence relation)을 사용하고, 이를 해결하여 점근적 표기법을 얻는다.</p><p>예를 들어, 병합 정렬의 시간 복잡도는 다음 점화식으로 표현됩니다: T(n) = 2T(n/2) + O(n)</p><p>이를 해결하면 T(n) = O(n log n)이 된다.</p><h4 id=마스터-정리master-theorem>마스터 정리(Master Theorem)<a hidden class=anchor aria-hidden=true href=#마스터-정리master-theorem>#</a></h4><p>마스터 정리는 많은 분할 정복(divide-and-conquer) 알고리즘의 시간 복잡도를 분석하는 데 유용한 도구이다.</p><p>다음 형태의 점화식에 적용할 수 있다:</p><pre class=mermaid>T(n) = aT(n/b) + f(n)
</pre><p>여기서 a ≥ 1, b > 1이고, f(n)은 점근적으로 양의 함수이다.</p><p>마스터 정리는 세 가지 경우로 나눠 해결책을 제시한다:</p><ol><li>만약 f(n) = O(n^(log<sub>b</sub> a - ε))이면, 어떤 ε > 0에 대해, T(n) = Θ(n^(log<sub>b</sub> a))</li><li>만약 f(n) = Θ(n^(log<sub>b</sub> a))이면, T(n) = Θ(n^(log<sub>b</sub> a) log n)</li><li>만약 f(n) = Ω(n^(log<sub>b</sub> a + ε))이면, 어떤 ε > 0에 대해, 그리고 af(n/b) ≤ cf(n)을 만족하는 c &lt; 1이 존재한다면, T(n) = Θ(f(n))<br>이 정리를 사용하면 복잡한 분할 정복 알고리즘의 시간 복잡도를 쉽게 결정할 수 있다.</li></ol><h4 id=복잡한-알고리즘-예시>복잡한 알고리즘 예시<a hidden class=anchor aria-hidden=true href=#복잡한-알고리즘-예시>#</a></h4><p>트리 기반 알고리즘, 그래프 알고리즘, 동적 프로그래밍 등 복잡한 알고리즘의 시간 복잡도를 분석할 때도 점근적 표기법이 유용하다:</p><p>예를 들어, 다익스트라 알고리즘의 시간 복잡도는 구현 방법에 따라 다를 수 있다:</p><ul><li>기본 구현: O(V²), 여기서 V는 정점의 수</li><li>우선순위 큐 구현: O(E log V), 여기서 E는 간선의 수, V는 정점의 수</li></ul><p>이러한 분석은 알고리즘의 효율성을 평가하고, 특정 문제에 가장 적합한 알고리즘을 선택하는 데 도움이 된다.</p><h3 id=실제-응용에서의-점근적-표기법>실제 응용에서의 점근적 표기법<a hidden class=anchor aria-hidden=true href=#실제-응용에서의-점근적-표기법>#</a></h3><ol><li><p>알고리즘 설계<br>점근적 표기법은 알고리즘 설계 단계에서 효율성 목표를 설정하는 데 도움이 된다.<br>예를 들어, 대규모 데이터셋을 처리해야 한다면, O(n²) 이상의 시간 복잡도를 가진 알고리즘은 피해야 한다.</p></li><li><p>성능 최적화<br>점근적 표기법은 코드의 어떤 부분을 최적화해야 하는지 우선순위를 정하는 데 도움이 된다.<br>중첩된 루프(O(n²))는 단일 루프(O(n))보다 최적화의 우선순위가 높다.</p></li><li><p>시스템 설계<br>대규모 시스템을 설계할 때, 점근적 표기법은 각 구성 요소의 확장성을 평가하는 데 도움이 된다.<br>예를 들어, 데이터베이스 쿼리의 복잡도, 네트워크 프로토콜의 효율성 등을 분석할 수 있다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/algorithmic-complexity/>Algorithmic-Complexity</a></li><li><a href=https://buenhyden.github.io/tags/asymptotic-notation/>Asymptotic-Notation</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack/stack-vs-queue/><span class=title>« Prev</span><br><span>Stack vs Queue</span>
</a><a class=next href=https://buenhyden.github.io/posts/frontend/html/seo/><span class=title>Next »</span><br><span>SEO(Search Engine Optimization)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>