<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deterministic vs. Nondeterministic computation | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Fundamentals,Complexity-Classes,Deterministic-vs-Nondeterministic-computation,Deterministic-computation,Nondeterministic-computation"><meta name=description content="결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Deterministic vs. Nondeterministic computation"><meta property="og:description" content="결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-27T08:29:00+00:00"><meta property="article:modified_time" content="2024-12-27T08:29:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Complexity-Classes"><meta property="article:tag" content="Deterministic-vs-Nondeterministic-Computation"><meta property="article:tag" content="Deterministic-Computation"><meta property="article:tag" content="Nondeterministic-Computation"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Deterministic vs. Nondeterministic computation"><meta name=twitter:description content="결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/"},{"@type":"ListItem","position":3,"name":"자료구조와 알고리즘 기초","item":""},{"@type":"ListItem","position":4,"name":"복잡도 클래스(Complexity Classes)","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/"},{"@type":"ListItem","position":5,"name":"Deterministic vs. Nondeterministic computation","item":"https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deterministic vs. Nondeterministic computation","name":"Deterministic vs. Nondeterministic computation","description":"결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.","keywords":["Data-Structures-and-Algorithms","Fundamentals","Complexity-Classes","Deterministic-vs-Nondeterministic-computation","Deterministic-computation","Nondeterministic-computation"],"articleBody":"Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.\n결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.\n이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.\nP = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.\n현대 컴퓨팅에서는 양자 컴퓨팅, 확률적 알고리즘, 병렬 처리 등을 통해 비결정론적 계산의 일부 장점을 활용하려는 연구가 활발히 진행되고 있으며, 이러한 연구는 복잡한 문제를 더 효율적으로 해결할 수 있는 새로운 가능성을 열어주고 있다.\n결정론적 계산(Deterministic Computation)이란 계산 과정의 각 단계에서 다음에 수행할 작업이 현재 상태에 의해 유일하게 결정되는 계산 방식이다. 즉, 주어진 입력에 대해 항상 동일한 경로를 따라 실행되며, 실행 경로가 단 하나만 존재한다.\n결정론적 계산 모델에서는 현재 상태와 입력 심볼에 대해 정확히 하나의 다음 상태와 작업만이 존재한다. 다시 말하면 어떤 상태와 입력이 주어지면, 다음에 무엇을 할지가 완전히 정해져 있다. 마치 열차가 정해진 철로를 따라가는 것과 같다.\n예를 들어, 최대값 찾기 알고리즘은 항상 같은 최대값을 반환한다.\n비결정론적 계산(Nondeterministic Computation)은 계산 과정의 각 단계에서 가능한 다음 작업이 여러 개일 수 있는 계산 방식이다. 즉, 동일한 입력에 대해서도 여러 실행 경로가 존재할 수 있으며, 이론적으로는 이 모든 경로를 동시에 탐색하는 것처럼 작동한다.\n비결정론적 계산 모델에서는 현재 상태와 입력 심볼에 대해 여러 가능한 다음 상태와 작업이 존재할 수 있다. 마치 여러 갈래로 나뉘는 길에서 모든 길을 동시에 탐색할 수 있는 능력이 있는 것과 같다.\n예를 들어, 리스트에서 무작위로 원소를 선택하고 그것이 최대값인지 확인하는 알고리즘을 들 수 있다.\n계산 모델에서의 비교 오토마타 이론과 형식 언어 결정론적 유한 오토마톤(DFA)은 아래와 같은 특징을 가진다.\n각 상태에서 각 입력 기호에 대해 정확히 하나의 다음 상태가 존재한다. 현재 상태와 입력에 따라 다음 상태가 유일하게 결정된다. 상태 변화를 위해서는 반드시 입력이 필요하다. 수학적으로 (Q, Σ, δ, q0, F)의 5-튜플로 정의된다.\n결정론적 유한 오토마톤(DFA)에서는 각 상태와 입력 심볼에 대해 정확히 하나의 다음 상태만 존재합니다.\n전이 함수는 δ: Q × Σ → Q로 정의된다. Q: 모든 가능한 상태의 집합 Σ: 입력 알파벳(가능한 모든 입력 심볼의 집합) ×: 카티션 곱(두 집합의 모든 가능한 조합)\n현재 상태(Q의 원소)와 입력 심볼(Σ의 원소)의 모든 조합에 대해, 정확히 하나의 다음 상태(Q의 원소)가 결정된다. 비결정론적 유한 오토마톤(NFA)는 다음과 같은 특징을 가진다:\n한 상태에서 같은 입력 기호에 대해 여러 개의 가능한 다음 상태가 존재할 수 있다. ε-전이(입력 없이 상태 변화)가 가능하다. 수학적으로 (Q, Σ, s0, δ, F)의 5-튜플로 정의된다.\n비결정론적 유한 오토마톤(NFA)에서는 각 상태와 입력 심볼에 대해 여러 가능한 다음 상태가 존재할 수 있다.\n전이 함수는 δ: Q × Σ → P(Q)로 정의된다(여기서 P(Q)는 Q의 멱집합). Q: 모든 가능한 상태의 집합 Σ: 입력 알파벳(가능한 모든 입력 심볼의 집합) ×: 카티션 곱(두 집합의 모든 가능한 조합) P(Q): Q의 멱집합(Q의 모든 부분집합의 집합)\n현재 상태와 입력 심볼의 조합에 대해, 가능한 다음 상태들의 집합이 결정된다. 중요한 결과: 모든 NFA는 동등한 DFA로 변환될 수 있다(상태 수는 증가할 수 있음). 따라서 DFA와 NFA는 정규 언어라는 동일한 언어 클래스를 인식합한다.\n튜링 기계 결정론적 튜링 기계(DTM)에서는 각 상태와 테이프 심볼에 대해 정확히 하나의 다음 단계(새 상태, 쓸 심볼, 헤드 이동 방향)만 정의된다.\n전이 함수는 δ: Q × Γ → Q × Γ × {L, R, S}로 정의된다.\nQ: 모든 가능한 상태의 집합 Γ: 테이프 알파벳 (테이프에 쓸 수 있는 모든 기호의 집합) {L, R, S}: 헤드의 이동 방향 (L: 왼쪽, R: 오른쪽, S: 정지)\n현재 상태와 테이프에서 읽은 기호에 따라, 다음 상태, 테이프에 쓸 새 기호, 그리고 헤드의 이동 방향이 유일하게 결정된다. 비결정론적 튜링 기계(NTM)에서는 각 상태와 테이프 심볼에 대해 여러 가능한 다음 단계가 정의될 수 있다.\n전이 함수는 δ: Q × Γ → P(Q × Γ × {L, R, S})로 정의된다.\nQ: 모든 가능한 상태의 집합 Γ: 테이프 알파벳 (테이프에 쓸 수 있는 모든 기호의 집합) {L, R, S}: 헤드의 이동 방향 (L: 왼쪽, R: 오른쪽, S: 정지) P(Q × Γ × {L, R, S}): (Q × Γ × {L, R, S})의 멱집합\n현재 상태와 테이프에서 읽은 기호에 따라, 여러 가지 가능한 다음 동작들의 집합이 결정된다. 중요한 결과: 모든 NTM은 동등한 DTM으로 변환될 수 있다. 그러나 이 변환은 실행 시간에 지수적 증가를 가져올 수 있다(즉, NTM이 t 단계에서 문제를 해결하면, 동등한 DTM은 O(2^t) 단계가 필요할 수 있다).\n계산 복잡도 이론에서의 비교 복잡도 클래스에서\n결정론적 튜링 기계는 P (Polynomial Time) 를 정의하는데 사용된다.\n결정론적 튜링 기계에서 다항 시간 내에 해결할 수 있는, 즉 O(n^k)의 시간 복잡도를 갖는 문제들의 집합(여기서 n은 입력 크기, k는 상수).\n비결정론적 튜링 기계는 **NP (Nondeterministic Polynomial Time)**를 정의하는데 사용된다.\n비결정론적 튜링 기계에서 다항 시간 내에 해결할 수 있는 문제들의 집합이며, 다른 관점에서는, 해답의 정확성을 다항 시간 내에 검증할 수 있는 문제들의 집합으로도 정의된다.\n중요한 미해결 문제: P = NP? 이 문제는 “모든 효율적으로 검증 가능한 문제가 효율적으로 해결 가능한가?“를 묻는 컴퓨터 과학의 가장 중요한 미해결 문제 중 하나이다.\n다항식 시간 축소(Polynomial-time Reduction) P와 NP의 관계에서 중요한 개념은 NP-완전성(NP-completeness)이다. NP-완전 문제는 NP에 속하며, NP의 모든 문제가 다항 시간 내에 이 문제로 축소될 수 있는 문제들이다.\n이는 만약 어떤 NP-완전 문제에 대한 다항 시간 알고리즘이 발견된다면, P = NP가 증명됨을 의미한다.\n실제 구현과 시뮬레이션 결정론적 계산의 구현\n결정론적 계산 모델은 직접적으로 현대 컴퓨터에 구현된다.\n일반적인 프로그래밍 언어(C, Java, Python 등)로 작성된 프로그램은 기본적으로 결정론적이다.\n같은 입력에 대해 항상 동일한 출력을 생성(난수 생성기와 같은 외부 요소가 없다면).\n비결정론적 계산의 시뮬레이션\n실제 물리적 컴퓨터는 기본적으로 결정론적이기 때문에, 비결정론적 계산을 직접 구현하는 것은 어렵다.\n비결정론적 계산은 일반적으로 다음과 같은 방식으로 시뮬레이션된다:\n백트래킹(Backtracking): 가능한 모든 경로를 순차적으로 탐색하며, 필요시 이전 결정 지점으로 돌아가 다른 경로를 탐색. 병렬 처리(Parallel Processing): 여러 처리 단위가 각각 다른 실행 경로를 동시에 탐색. 확률적 알고리즘(Probabilistic Algorithms): 무작위성을 활용하여 가능한 경로 중 하나를 선택. 결정론적 vs. 비결정론적 계산 과정에서의 차이 두 접근 방식의 핵심 차이는 계산 과정에서 선택지와 경로를 처리하는 방식에 있다.\n미로 찾기 예시 미로를 통과하는 문제를 생각해 보면:\nS ########### # # # # # # ##### # # # # # # # # ##### # # # # # # # ######### # # # # # # ######### # # E ############# 여기서 S는 시작점, E는 출구.\n결정론적 접근 결정론적 알고리즘(예: 깊이 우선 탐색)은 다음과 같이 작동한다:\n현재 위치에서 가능한 이동 방향(위, 아래, 왼쪽, 오른쪽)을 확인한다. 미리 정해진 우선순위(예: 오른쪽→아래→왼쪽→위)에 따라 한 방향을 선택한다. 선택한 방향으로 이동한다. 막다른 길에 도달하면 이전 교차점으로 돌아가 다른 방향을 시도한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def dfs_maze(maze, start, end): stack = [start] visited = set([start]) while stack: current = stack.pop() # 한 번에 하나의 경로만 탐색 if current == end: return True # 출구 발견 # 가능한 모든 이동 방향 확인 for neighbor in get_neighbors(current, maze): if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) return False # 출구를 찾을 수 없음 이 알고리즘은 한 번에 하나의 경로만 탐색하며, 필요한 경우 백트래킹(다시 되돌아가기)을 수행한다.\n비결정론적 접근 비결정론적 알고리즘은 이론적으로 다음과 같이 작동할 수 있다:\n현재 위치에서 가능한 모든 이동 방향을 동시에 시도한다. 각 방향으로 동시에 탐색을 계속한다. 어느 하나라도 출구에 도달하면 성공이다. 이를 의사 코드로 표현하면:\nfunction nondeterministic_solve_maze(maze, position): if position is exit: return SUCCESS // 다음과 같은 \"마법의\" 연산자가 있다고 가정 direction = CHOOSE(up, down, left, right) new_position = move(position, direction) if new_position is valid: return nondeterministic_solve_maze(maze, new_position) else: return FAIL 여기서 CHOOSE 연산자는 모든 가능한 선택을 동시에 시도한다고 가정한다.\n실제로는 이런 마법의 연산자는 존재하지 않으므로, 실제 구현에서는 백트래킹이나 병렬 처리를 통해 시뮬레이션해야 한다.\n문자열 수용 예시: 정규 표현식 일치 정규 표현식 일치 문제를 생각해 봅시다. 다음 정규 표현식이 주어졌다고 가정하면:\na(b|c)*d 이 표현식은 ‘a’로 시작하고, ’d’로 끝나며, 중간에 ‘b’와 ‘c’가 0번 이상 반복되는 문자열과 일치한다.\n결정론적 접근 (DFA) 결정론적 유한 오토마톤(DFA)으로 구현하면:\n상태 0: 시작 상태 상태 1: 'a'를 읽은 후 상태 2: 'b' 또는 'c'를 읽은 후 상태 3: 'd'를 읽은 후 (종료 상태) 전이 함수: δ(0, 'a') = 1 δ(1, 'b') = 2 δ(1, 'c') = 2 δ(1, 'd') = 3 δ(2, 'b') = 2 δ(2, 'c') = 2 δ(2, 'd') = 3 이 DFA는 항상 정확히 하나의 경로를 따라 상태를 전이한다.\n비결정론적 접근 (NFA) 비결정론적 유한 오토마톤(NFA)으로 구현하면:\n상태 0: 시작 상태 상태 1: 'a'를 읽은 후 상태 2: 'b' 또는 'c'를 읽은 후 상태 3: 'd'를 읽은 후 (종료 상태) 전이 함수: δ(0, 'a') = {1} δ(1, 'b') = {1, 2} // 'b'를 읽고 상태 1 또는 2로 갈 수 있음 δ(1, 'c') = {1, 2} // 'c'를 읽고 상태 1 또는 2로 갈 수 있음 δ(1, 'd') = {3} δ(2, 'b') = {2} δ(2, 'c') = {2} δ(2, 'd') = {3} NFA는 “마법적으로” 여러 상태에 동시에 있을 수 있다.\n어떤 경로든 종료 상태에 도달하면 문자열이 수용된다.\n계산 복잡도 예시: SAT 문제 Boolean 만족가능성 문제(SAT)를 생각해 보면.\n이 문제는 주어진 Boolean 식이 참이 되도록 하는 변수 할당이 존재하는지 확인하는 문제이다.\n예: (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)\n결정론적 접근 결정론적 알고리즘은 모든 가능한 변수 할당을 하나씩 시도해야 한다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solve_sat_deterministic(formula, variables): if len(variables) == 0: return evaluate(formula, {}) # 모든 변수가 할당됐는지 확인 var = variables[0] remaining_vars = variables[1:] # var를 True로 설정하고 재귀적으로 시도 assignment = {var: True} if solve_sat_deterministic(formula, remaining_vars): return True # var를 False로 설정하고 재귀적으로 시도 assignment = {var: False} return solve_sat_deterministic(formula, remaining_vars) 이 접근법은 모든 가능한 할당(2^n개, n은 변수 수)을 순차적으로 시도한다.\n비결정론적 접근 비결정론적 튜링 기계는 다음과 같이 작동할 수 있다:\n각 변수에 대해 True 또는 False 값을 “비결정론적으로 선택\"한다. 이 할당으로 공식을 평가한다. 공식이 참이면 “예\"를 반환하고, 그렇지 않으면 “아니오\"를 반환한다. 의사 코드로 표현하면:\nfunction nondeterministic_solve_sat(formula, variables): assignment = {} for each var in variables: assignment[var] = CHOOSE(True, False) // 비결정론적 선택 if evaluate(formula, assignment): return YES else: return NO 이론적으로 비결정론적 기계는 단 한 번의 “마법적인 추측\"으로 정답을 찾을 수 있다. 이것이 SAT 문제가 NP 클래스에 속하는 이유이다.\n장단점 분석 결정론적 계산의 장단점 장점:\n예측 가능성과 재현성이 높음 디버깅이 상대적으로 용이함 직접적인 하드웨어 구현이 가능함 시간 및 공간 복잡도 분석이 명확함 단점:\n일부 문제에서는 효율적인 해결책을 찾기 어려움 복잡한 탐색 공간에서 최적해를 찾는 데 비효율적일 수 있음 병렬화가 제한적일 수 있음 비결정론적 계산의 장단점 장점:\n이론적으로 특정 문제에서 더 효율적인 해결책을 제공할 수 있음 복잡한 탐색 공간에서 최적해를 더 빠르게 찾을 수 있는 이론적 가능성 본질적으로 병렬화에 적합함 단점:\n실제 구현이 어려움 결과의 재현성이 낮을 수 있음 시뮬레이션 시 자원 소모가 큼 디버깅이 복잡함 응용 분야 결정론적 계산의 응용 일상적인 컴퓨터 프로그램과 알고리즘 데이터베이스 시스템 운영 체제 실시간 제어 시스템 금융 거래 시스템 비결정론적 계산의 응용 인공지능과 기계 학습 최적화 문제 해결 자연어 처리 게임 이론 양자 컴퓨팅(양자 시스템은 본질적으로 비결정론적 특성을 갖음) 현대적 발전과 연구 동향 양자 컴퓨팅(Quantum Computing)\n양자 컴퓨팅은 양자 역학적 현상을 이용하여 특정 문제를 효율적으로 해결할 수 있는 가능성을 제공합니다. 양자 컴퓨터는 양자 중첩과 얽힘을 통해 특정 연산을 병렬로 수행할 수 있으며, 이는 비결정론적 계산의 일종으로 볼 수 있습니다.\n확률적 알고리즘(Probabilistic Algorithms)\n확률적 알고리즘은 무작위성을 활용하여 결정론적 알고리즘보다 더 효율적으로 문제를 해결할 수 있는 가능성을 제공한다. 예를 들어, 몬테카를로 알고리즘은 무작위 샘플링을 통해 복잡한 수학적 문제의 근사 해를 효율적으로 찾을 수 있다.\n병렬 및 분산 컴퓨팅(Parallel and Distributed Computing)\n현대의 병렬 및 분산 컴퓨팅 시스템은 비결정론적 계산의 일부 장점을 활용하려는 시도이다.\n여러 계산 단위가 동시에 서로 다른 실행 경로를 탐색함으로써 특정 문제에 대한 해결 시간을 단축할 수 있다.\n비교 요약표 특성 결정론적 계산(Deterministic) 비결정론적 계산(Nondeterministic) 기본 정의 각 단계에서 다음 작업이 유일하게 결정됨 각 단계에서 여러 가능한 다음 작업이 존재할 수 있음 실행 경로 입력마다 단 하나의 실행 경로만 존재 입력마다 여러 실행 경로가 존재할 수 있음 유한 오토마톤 DFA: δ: Q × Σ → Q NFA: δ: Q × Σ → P(Q) 튜링 기계 DTM: δ: Q × Γ → Q × Γ × {L, R, S} NTM: δ: Q × Γ → P(Q × Γ × {L, R, S}) 계산 능력 재귀적 가산 언어를 인식 DTM과 동일한 계산 능력 (단, 효율성은 다를 수 있음) 복잡도 클래스 P (Polynomial Time) NP (Nondeterministic Polynomial Time) P vs NP 결정론적 다항 시간 알고리즘이 존재 비결정론적 다항 시간 알고리즘이 존재 구현 방식 직접적인 하드웨어 구현 가능 백트래킹, 병렬 처리, 확률적 방법으로 시뮬레이션 결과 예측성 높음 (동일 입력 = 동일 출력) 낮음 (동일 입력 ≠ 항상 동일 출력) 디버깅 용이성 상대적으로 용이함 복잡하고 어려움 효율성 일부 문제에서 비효율적일 수 있음 이론적으로 특정 문제에서 더 효율적일 수 있음 자원 요구 일반적으로 낮음 시뮬레이션 시 높음 주요 응용 분야 일반 컴퓨터 프로그램, 데이터베이스, 운영체제 AI, 최적화, 자연어 처리, 양자 컴퓨팅 현실 세계 구현 대부분의 현대 컴퓨터 시스템 양자 컴퓨터, 확률적 알고리즘, 병렬 컴퓨팅 참고 및 출처 ","wordCount":"2019","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-27T08:29:00Z","dateModified":"2024-12-27T08:29:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/deterministic-vs-nondeterministic-computation/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href>자료구조와 알고리즘 기초</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/>복잡도 클래스(Complexity Classes)</a></div><h1 class="post-title entry-hint-parent">Deterministic vs. Nondeterministic computation</h1><div class=post-description>결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.</div><div class=post-meta><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20Structures%20and%20Algorithms/Fundamentals/Complexity%20Classes/deterministic-vs-nondeterministic-computation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#deterministic-vs-nondeterministic-computation>Deterministic vs. Nondeterministic Computation</a><ul><li><a href=#계산-모델에서의-비교>계산 모델에서의 비교</a></li><li><a href=#계산-복잡도-이론에서의-비교>계산 복잡도 이론에서의 비교</a></li><li><a href=#다항식-시간-축소polynomial-time-reduction>다항식 시간 축소(Polynomial-time Reduction)</a></li><li><a href=#실제-구현과-시뮬레이션>실제 구현과 시뮬레이션</a></li><li><a href=#결정론적-vs-비결정론적-계산-과정에서의-차이>결정론적 vs. 비결정론적 계산 과정에서의 차이</a></li><li><a href=#장단점-분석>장단점 분석</a></li><li><a href=#응용-분야>응용 분야</a></li><li><a href=#현대적-발전과-연구-동향>현대적 발전과 연구 동향</a></li><li><a href=#비교-요약표>비교 요약표</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=deterministic-vs-nondeterministic-computation>Deterministic vs. Nondeterministic Computation<a hidden class=anchor aria-hidden=true href=#deterministic-vs-nondeterministic-computation>#</a></h2><p>결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.<br>결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.</p><p>이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.<br>P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.</p><p>현대 컴퓨팅에서는 양자 컴퓨팅, 확률적 알고리즘, 병렬 처리 등을 통해 비결정론적 계산의 일부 장점을 활용하려는 연구가 활발히 진행되고 있으며, 이러한 연구는 복잡한 문제를 더 효율적으로 해결할 수 있는 새로운 가능성을 열어주고 있다.</p><p>결정론적 계산(Deterministic Computation)이란 계산 과정의 각 단계에서 다음에 수행할 작업이 현재 상태에 의해 유일하게 결정되는 계산 방식이다. 즉, 주어진 입력에 대해 항상 동일한 경로를 따라 실행되며, 실행 경로가 단 하나만 존재한다.</p><p>결정론적 계산 모델에서는 현재 상태와 입력 심볼에 대해 정확히 하나의 다음 상태와 작업만이 존재한다. 다시 말하면 어떤 상태와 입력이 주어지면, 다음에 무엇을 할지가 완전히 정해져 있다. 마치 열차가 정해진 철로를 따라가는 것과 같다.<br>예를 들어, 최대값 찾기 알고리즘은 항상 같은 최대값을 반환한다.</p><p>비결정론적 계산(Nondeterministic Computation)은 계산 과정의 각 단계에서 가능한 다음 작업이 여러 개일 수 있는 계산 방식이다. 즉, 동일한 입력에 대해서도 여러 실행 경로가 존재할 수 있으며, 이론적으로는 이 모든 경로를 동시에 탐색하는 것처럼 작동한다.</p><p>비결정론적 계산 모델에서는 현재 상태와 입력 심볼에 대해 여러 가능한 다음 상태와 작업이 존재할 수 있다. 마치 여러 갈래로 나뉘는 길에서 모든 길을 동시에 탐색할 수 있는 능력이 있는 것과 같다.<br>예를 들어, 리스트에서 무작위로 원소를 선택하고 그것이 최대값인지 확인하는 알고리즘을 들 수 있다.</p><h3 id=계산-모델에서의-비교>계산 모델에서의 비교<a hidden class=anchor aria-hidden=true href=#계산-모델에서의-비교>#</a></h3><h4 id=오토마타-이론과-형식-언어>오토마타 이론과 형식 언어<a hidden class=anchor aria-hidden=true href=#오토마타-이론과-형식-언어>#</a></h4><p>결정론적 유한 오토마톤(DFA)은 아래와 같은 특징을 가진다.</p><ol><li>각 상태에서 각 입력 기호에 대해 정확히 하나의 다음 상태가 존재한다.</li><li>현재 상태와 입력에 따라 다음 상태가 유일하게 결정된다.</li><li>상태 변화를 위해서는 반드시 입력이 필요하다.</li><li>수학적으로 (Q, Σ, δ, q0, F)의 5-튜플로 정의된다.<br>결정론적 유한 오토마톤(DFA)에서는 각 상태와 입력 심볼에 대해 정확히 하나의 다음 상태만 존재합니다.<br>전이 함수는 <code>δ: Q × Σ → Q</code>로 정의된다.</li></ol><ul><li>Q: 모든 가능한 상태의 집합</li><li>Σ: 입력 알파벳(가능한 모든 입력 심볼의 집합)</li><li>×: 카티션 곱(두 집합의 모든 가능한 조합)<br>현재 상태(Q의 원소)와 입력 심볼(Σ의 원소)의 모든 조합에 대해, 정확히 하나의 다음 상태(Q의 원소)가 결정된다.</li></ul><p>비결정론적 유한 오토마톤(NFA)는 다음과 같은 특징을 가진다:</p><ol><li>한 상태에서 같은 입력 기호에 대해 여러 개의 가능한 다음 상태가 존재할 수 있다.</li><li>ε-전이(입력 없이 상태 변화)가 가능하다.</li><li>수학적으로 (Q, Σ, s0, δ, F)의 5-튜플로 정의된다.<br>비결정론적 유한 오토마톤(NFA)에서는 각 상태와 입력 심볼에 대해 여러 가능한 다음 상태가 존재할 수 있다.<br>전이 함수는 <code>δ: Q × Σ → P(Q)</code>로 정의된다(여기서 P(Q)는 Q의 멱집합).</li></ol><ul><li>Q: 모든 가능한 상태의 집합</li><li>Σ: 입력 알파벳(가능한 모든 입력 심볼의 집합)</li><li>×: 카티션 곱(두 집합의 모든 가능한 조합)</li><li>P(Q): Q의 멱집합(Q의 모든 부분집합의 집합)<br>현재 상태와 입력 심볼의 조합에 대해, 가능한 다음 상태들의 집합이 결정된다.</li></ul><p>중요한 결과: 모든 NFA는 동등한 DFA로 변환될 수 있다(상태 수는 증가할 수 있음). 따라서 DFA와 NFA는 정규 언어라는 동일한 언어 클래스를 인식합한다.</p><h4 id=튜링-기계>튜링 기계<a hidden class=anchor aria-hidden=true href=#튜링-기계>#</a></h4><p>결정론적 튜링 기계(DTM)에서는 각 상태와 테이프 심볼에 대해 정확히 하나의 다음 단계(새 상태, 쓸 심볼, 헤드 이동 방향)만 정의된다.<br>전이 함수는 <code>δ: Q × Γ → Q × Γ × {L, R, S}</code>로 정의된다.</p><ul><li>Q: 모든 가능한 상태의 집합</li><li>Γ: 테이프 알파벳 (테이프에 쓸 수 있는 모든 기호의 집합)</li><li>{L, R, S}: 헤드의 이동 방향 (L: 왼쪽, R: 오른쪽, S: 정지)<br>현재 상태와 테이프에서 읽은 기호에 따라, 다음 상태, 테이프에 쓸 새 기호, 그리고 헤드의 이동 방향이 유일하게 결정된다.</li></ul><p>비결정론적 튜링 기계(NTM)에서는 각 상태와 테이프 심볼에 대해 여러 가능한 다음 단계가 정의될 수 있다.<br>전이 함수는 <code>δ: Q × Γ → P(Q × Γ × {L, R, S})</code>로 정의된다.</p><ul><li>Q: 모든 가능한 상태의 집합</li><li>Γ: 테이프 알파벳 (테이프에 쓸 수 있는 모든 기호의 집합)</li><li>{L, R, S}: 헤드의 이동 방향 (L: 왼쪽, R: 오른쪽, S: 정지)</li><li>P(Q × Γ × {L, R, S}): (Q × Γ × {L, R, S})의 멱집합<br>현재 상태와 테이프에서 읽은 기호에 따라, 여러 가지 가능한 다음 동작들의 집합이 결정된다.</li></ul><p>중요한 결과: 모든 NTM은 동등한 DTM으로 변환될 수 있다. 그러나 이 변환은 실행 시간에 지수적 증가를 가져올 수 있다(즉, NTM이 t 단계에서 문제를 해결하면, 동등한 DTM은 O(2^t) 단계가 필요할 수 있다).</p><h3 id=계산-복잡도-이론에서의-비교>계산 복잡도 이론에서의 비교<a hidden class=anchor aria-hidden=true href=#계산-복잡도-이론에서의-비교>#</a></h3><p>복잡도 클래스에서<br>결정론적 튜링 기계는 <strong>P (Polynomial Time)</strong> 를 정의하는데 사용된다.<br>결정론적 튜링 기계에서 다항 시간 내에 해결할 수 있는, 즉 O(n^k)의 시간 복잡도를 갖는 문제들의 집합(여기서 n은 입력 크기, k는 상수).</p><p>비결정론적 튜링 기계는 **NP (Nondeterministic Polynomial Time)**를 정의하는데 사용된다.<br>비결정론적 튜링 기계에서 다항 시간 내에 해결할 수 있는 문제들의 집합이며, 다른 관점에서는, 해답의 정확성을 다항 시간 내에 검증할 수 있는 문제들의 집합으로도 정의된다.</p><p>중요한 미해결 문제: P = NP? 이 문제는 &ldquo;모든 효율적으로 검증 가능한 문제가 효율적으로 해결 가능한가?&ldquo;를 묻는 컴퓨터 과학의 가장 중요한 미해결 문제 중 하나이다.</p><h3 id=다항식-시간-축소polynomial-time-reduction>다항식 시간 축소(Polynomial-time Reduction)<a hidden class=anchor aria-hidden=true href=#다항식-시간-축소polynomial-time-reduction>#</a></h3><p>P와 NP의 관계에서 중요한 개념은 NP-완전성(NP-completeness)이다. NP-완전 문제는 NP에 속하며, NP의 모든 문제가 다항 시간 내에 이 문제로 축소될 수 있는 문제들이다.<br>이는 만약 어떤 NP-완전 문제에 대한 다항 시간 알고리즘이 발견된다면, P = NP가 증명됨을 의미한다.</p><h3 id=실제-구현과-시뮬레이션>실제 구현과 시뮬레이션<a hidden class=anchor aria-hidden=true href=#실제-구현과-시뮬레이션>#</a></h3><ol><li><p>결정론적 계산의 구현<br>결정론적 계산 모델은 직접적으로 현대 컴퓨터에 구현된다.<br>일반적인 프로그래밍 언어(C, Java, Python 등)로 작성된 프로그램은 기본적으로 결정론적이다.<br>같은 입력에 대해 항상 동일한 출력을 생성(난수 생성기와 같은 외부 요소가 없다면).</p></li><li><p>비결정론적 계산의 시뮬레이션<br>실제 물리적 컴퓨터는 기본적으로 결정론적이기 때문에, 비결정론적 계산을 직접 구현하는 것은 어렵다.<br>비결정론적 계산은 일반적으로 다음과 같은 방식으로 시뮬레이션된다:</p><ol><li><strong>백트래킹(Backtracking)</strong>: 가능한 모든 경로를 순차적으로 탐색하며, 필요시 이전 결정 지점으로 돌아가 다른 경로를 탐색.</li><li><strong>병렬 처리(Parallel Processing)</strong>: 여러 처리 단위가 각각 다른 실행 경로를 동시에 탐색.</li><li><strong>확률적 알고리즘(Probabilistic Algorithms)</strong>: 무작위성을 활용하여 가능한 경로 중 하나를 선택.</li></ol></li></ol><h3 id=결정론적-vs-비결정론적-계산-과정에서의-차이>결정론적 vs. 비결정론적 계산 과정에서의 차이<a hidden class=anchor aria-hidden=true href=#결정론적-vs-비결정론적-계산-과정에서의-차이>#</a></h3><p>두 접근 방식의 핵심 차이는 계산 과정에서 선택지와 경로를 처리하는 방식에 있다.</p><h4 id=미로-찾기-예시>미로 찾기 예시<a hidden class=anchor aria-hidden=true href=#미로-찾기-예시>#</a></h4><p>미로를 통과하는 문제를 생각해 보면:</p><pre class=mermaid>S ###########
# #       # #
# # ##### # #
# #     # # #
# ##### # # #
#       # # #
######### # #
#         # #
# ######### #
#           E
#############
</pre><p>여기서 S는 시작점, E는 출구.</p><h5 id=결정론적-접근>결정론적 접근<a hidden class=anchor aria-hidden=true href=#결정론적-접근>#</a></h5><p>결정론적 알고리즘(예: 깊이 우선 탐색)은 다음과 같이 작동한다:</p><ol><li>현재 위치에서 가능한 이동 방향(위, 아래, 왼쪽, 오른쪽)을 확인한다.</li><li>미리 정해진 우선순위(예: 오른쪽→아래→왼쪽→위)에 따라 한 방향을 선택한다.</li><li>선택한 방향으로 이동한다.</li><li>막다른 길에 도달하면 이전 교차점으로 돌아가 다른 방향을 시도한다.</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span><span class=lnt id=hl-1-14><a class=lnlinks href=#hl-1-14>14</a>
</span><span class=lnt id=hl-1-15><a class=lnlinks href=#hl-1-15>15</a>
</span><span class=lnt id=hl-1-16><a class=lnlinks href=#hl-1-16>16</a>
</span><span class=lnt id=hl-1-17><a class=lnlinks href=#hl-1-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>dfs_maze</span><span class=p>(</span><span class=n>maze</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[</span><span class=n>start</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=nb>set</span><span class=p>([</span><span class=n>start</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>  <span class=c1># 한 번에 하나의 경로만 탐색</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current</span> <span class=o>==</span> <span class=n>end</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>  <span class=c1># 출구 발견</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 가능한 모든 이동 방향 확인</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>get_neighbors</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=n>maze</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>neighbor</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>neighbor</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>False</span>  <span class=c1># 출구를 찾을 수 없음</span>
</span></span></code></pre></td></tr></table></div></div><p>이 알고리즘은 한 번에 하나의 경로만 탐색하며, 필요한 경우 백트래킹(다시 되돌아가기)을 수행한다.</p><h5 id=비결정론적-접근>비결정론적 접근<a hidden class=anchor aria-hidden=true href=#비결정론적-접근>#</a></h5><p>비결정론적 알고리즘은 이론적으로 다음과 같이 작동할 수 있다:</p><ol><li>현재 위치에서 가능한 모든 이동 방향을 동시에 시도한다.</li><li>각 방향으로 동시에 탐색을 계속한다.</li><li>어느 하나라도 출구에 도달하면 성공이다.</li></ol><p>이를 의사 코드로 표현하면:</p><pre class=mermaid>function nondeterministic_solve_maze(maze, position):
    if position is exit:
        return SUCCESS
    
    // 다음과 같은 &#34;마법의&#34; 연산자가 있다고 가정
    direction = CHOOSE(up, down, left, right)
    
    new_position = move(position, direction)
    if new_position is valid:
        return nondeterministic_solve_maze(maze, new_position)
    else:
        return FAIL
</pre><p>여기서 <code>CHOOSE</code> 연산자는 모든 가능한 선택을 동시에 시도한다고 가정한다.<br>실제로는 이런 마법의 연산자는 존재하지 않으므로, 실제 구현에서는 백트래킹이나 병렬 처리를 통해 시뮬레이션해야 한다.</p><h4 id=문자열-수용-예시-정규-표현식-일치>문자열 수용 예시: 정규 표현식 일치<a hidden class=anchor aria-hidden=true href=#문자열-수용-예시-정규-표현식-일치>#</a></h4><p>정규 표현식 일치 문제를 생각해 봅시다. 다음 정규 표현식이 주어졌다고 가정하면:</p><pre class=mermaid>a(b|c)*d
</pre><p>이 표현식은 &lsquo;a&rsquo;로 시작하고, &rsquo;d&rsquo;로 끝나며, 중간에 &lsquo;b&rsquo;와 &lsquo;c&rsquo;가 0번 이상 반복되는 문자열과 일치한다.</p><h5 id=결정론적-접근-dfa>결정론적 접근 (DFA)<a hidden class=anchor aria-hidden=true href=#결정론적-접근-dfa>#</a></h5><p>결정론적 유한 오토마톤(DFA)으로 구현하면:</p><pre class=mermaid>상태 0: 시작 상태
상태 1: &#39;a&#39;를 읽은 후
상태 2: &#39;b&#39; 또는 &#39;c&#39;를 읽은 후
상태 3: &#39;d&#39;를 읽은 후 (종료 상태)

전이 함수:
δ(0, &#39;a&#39;) = 1
δ(1, &#39;b&#39;) = 2
δ(1, &#39;c&#39;) = 2
δ(1, &#39;d&#39;) = 3
δ(2, &#39;b&#39;) = 2
δ(2, &#39;c&#39;) = 2
δ(2, &#39;d&#39;) = 3
</pre><p>이 DFA는 항상 정확히 하나의 경로를 따라 상태를 전이한다.</p><h5 id=비결정론적-접근-nfa>비결정론적 접근 (NFA)<a hidden class=anchor aria-hidden=true href=#비결정론적-접근-nfa>#</a></h5><p>비결정론적 유한 오토마톤(NFA)으로 구현하면:</p><pre class=mermaid>상태 0: 시작 상태
상태 1: &#39;a&#39;를 읽은 후
상태 2: &#39;b&#39; 또는 &#39;c&#39;를 읽은 후
상태 3: &#39;d&#39;를 읽은 후 (종료 상태)

전이 함수:
δ(0, &#39;a&#39;) = {1}
δ(1, &#39;b&#39;) = {1, 2}  // &#39;b&#39;를 읽고 상태 1 또는 2로 갈 수 있음
δ(1, &#39;c&#39;) = {1, 2}  // &#39;c&#39;를 읽고 상태 1 또는 2로 갈 수 있음
δ(1, &#39;d&#39;) = {3}
δ(2, &#39;b&#39;) = {2}
δ(2, &#39;c&#39;) = {2}
δ(2, &#39;d&#39;) = {3}
</pre><p>NFA는 &ldquo;마법적으로&rdquo; 여러 상태에 동시에 있을 수 있다.<br>어떤 경로든 종료 상태에 도달하면 문자열이 수용된다.</p><h4 id=계산-복잡도-예시-sat-문제>계산 복잡도 예시: SAT 문제<a hidden class=anchor aria-hidden=true href=#계산-복잡도-예시-sat-문제>#</a></h4><p>Boolean 만족가능성 문제(SAT)를 생각해 보면.</p><p>이 문제는 주어진 Boolean 식이 참이 되도록 하는 변수 할당이 존재하는지 확인하는 문제이다.<br>예: <code>(x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)</code></p><h5 id=결정론적-접근-1>결정론적 접근<a hidden class=anchor aria-hidden=true href=#결정론적-접근-1>#</a></h5><p>결정론적 알고리즘은 모든 가능한 변수 할당을 하나씩 시도해야 한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>solve_sat_deterministic</span><span class=p>(</span><span class=n>formula</span><span class=p>,</span> <span class=n>variables</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>variables</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>evaluate</span><span class=p>(</span><span class=n>formula</span><span class=p>,</span> <span class=p>{})</span>  <span class=c1># 모든 변수가 할당됐는지 확인</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=o>=</span> <span class=n>variables</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>remaining_vars</span> <span class=o>=</span> <span class=n>variables</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># var를 True로 설정하고 재귀적으로 시도</span>
</span></span><span class=line><span class=cl>    <span class=n>assignment</span> <span class=o>=</span> <span class=p>{</span><span class=n>var</span><span class=p>:</span> <span class=kc>True</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>solve_sat_deterministic</span><span class=p>(</span><span class=n>formula</span><span class=p>,</span> <span class=n>remaining_vars</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># var를 False로 설정하고 재귀적으로 시도</span>
</span></span><span class=line><span class=cl>    <span class=n>assignment</span> <span class=o>=</span> <span class=p>{</span><span class=n>var</span><span class=p>:</span> <span class=kc>False</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>solve_sat_deterministic</span><span class=p>(</span><span class=n>formula</span><span class=p>,</span> <span class=n>remaining_vars</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>이 접근법은 모든 가능한 할당(2^n개, n은 변수 수)을 순차적으로 시도한다.</p><h5 id=비결정론적-접근-1>비결정론적 접근<a hidden class=anchor aria-hidden=true href=#비결정론적-접근-1>#</a></h5><p>비결정론적 튜링 기계는 다음과 같이 작동할 수 있다:</p><ol><li>각 변수에 대해 True 또는 False 값을 &ldquo;비결정론적으로 선택"한다.</li><li>이 할당으로 공식을 평가한다.</li><li>공식이 참이면 &ldquo;예"를 반환하고, 그렇지 않으면 &ldquo;아니오"를 반환한다.</li></ol><p>의사 코드로 표현하면:</p><pre class=mermaid>function nondeterministic_solve_sat(formula, variables):
    assignment = {}
    for each var in variables:
        assignment[var] = CHOOSE(True, False)  // 비결정론적 선택
    
    if evaluate(formula, assignment):
        return YES
    else:
        return NO
</pre><p>이론적으로 비결정론적 기계는 단 한 번의 &ldquo;마법적인 추측"으로 정답을 찾을 수 있다. 이것이 SAT 문제가 NP 클래스에 속하는 이유이다.</p><h3 id=장단점-분석>장단점 분석<a hidden class=anchor aria-hidden=true href=#장단점-분석>#</a></h3><h4 id=결정론적-계산의-장단점>결정론적 계산의 장단점<a hidden class=anchor aria-hidden=true href=#결정론적-계산의-장단점>#</a></h4><p><strong>장점</strong>:</p><ul><li>예측 가능성과 재현성이 높음</li><li>디버깅이 상대적으로 용이함</li><li>직접적인 하드웨어 구현이 가능함</li><li>시간 및 공간 복잡도 분석이 명확함</li></ul><p><strong>단점</strong>:</p><ul><li>일부 문제에서는 효율적인 해결책을 찾기 어려움</li><li>복잡한 탐색 공간에서 최적해를 찾는 데 비효율적일 수 있음</li><li>병렬화가 제한적일 수 있음</li></ul><h4 id=비결정론적-계산의-장단점>비결정론적 계산의 장단점<a hidden class=anchor aria-hidden=true href=#비결정론적-계산의-장단점>#</a></h4><p><strong>장점</strong>:</p><ul><li>이론적으로 특정 문제에서 더 효율적인 해결책을 제공할 수 있음</li><li>복잡한 탐색 공간에서 최적해를 더 빠르게 찾을 수 있는 이론적 가능성</li><li>본질적으로 병렬화에 적합함</li></ul><p><strong>단점</strong>:</p><ul><li>실제 구현이 어려움</li><li>결과의 재현성이 낮을 수 있음</li><li>시뮬레이션 시 자원 소모가 큼</li><li>디버깅이 복잡함</li></ul><h3 id=응용-분야>응용 분야<a hidden class=anchor aria-hidden=true href=#응용-분야>#</a></h3><h4 id=결정론적-계산의-응용>결정론적 계산의 응용<a hidden class=anchor aria-hidden=true href=#결정론적-계산의-응용>#</a></h4><ul><li>일상적인 컴퓨터 프로그램과 알고리즘</li><li>데이터베이스 시스템</li><li>운영 체제</li><li>실시간 제어 시스템</li><li>금융 거래 시스템</li></ul><h4 id=비결정론적-계산의-응용>비결정론적 계산의 응용<a hidden class=anchor aria-hidden=true href=#비결정론적-계산의-응용>#</a></h4><ul><li>인공지능과 기계 학습</li><li>최적화 문제 해결</li><li>자연어 처리</li><li>게임 이론</li><li>양자 컴퓨팅(양자 시스템은 본질적으로 비결정론적 특성을 갖음)</li></ul><h3 id=현대적-발전과-연구-동향>현대적 발전과 연구 동향<a hidden class=anchor aria-hidden=true href=#현대적-발전과-연구-동향>#</a></h3><ol><li><p>양자 컴퓨팅(Quantum Computing)<br>양자 컴퓨팅은 양자 역학적 현상을 이용하여 특정 문제를 효율적으로 해결할 수 있는 가능성을 제공합니다. 양자 컴퓨터는 양자 중첩과 얽힘을 통해 특정 연산을 병렬로 수행할 수 있으며, 이는 비결정론적 계산의 일종으로 볼 수 있습니다.</p></li><li><p>확률적 알고리즘(Probabilistic Algorithms)<br>확률적 알고리즘은 무작위성을 활용하여 결정론적 알고리즘보다 더 효율적으로 문제를 해결할 수 있는 가능성을 제공한다. 예를 들어, 몬테카를로 알고리즘은 무작위 샘플링을 통해 복잡한 수학적 문제의 근사 해를 효율적으로 찾을 수 있다.</p></li><li><p>병렬 및 분산 컴퓨팅(Parallel and Distributed Computing)<br>현대의 병렬 및 분산 컴퓨팅 시스템은 비결정론적 계산의 일부 장점을 활용하려는 시도이다.<br>여러 계산 단위가 동시에 서로 다른 실행 경로를 탐색함으로써 특정 문제에 대한 해결 시간을 단축할 수 있다.</p></li></ol><h3 id=비교-요약표>비교 요약표<a hidden class=anchor aria-hidden=true href=#비교-요약표>#</a></h3><table><thead><tr><th>특성</th><th>결정론적 계산(Deterministic)</th><th>비결정론적 계산(Nondeterministic)</th></tr></thead><tbody><tr><td><strong>기본 정의</strong></td><td>각 단계에서 다음 작업이 유일하게 결정됨</td><td>각 단계에서 여러 가능한 다음 작업이 존재할 수 있음</td></tr><tr><td><strong>실행 경로</strong></td><td>입력마다 단 하나의 실행 경로만 존재</td><td>입력마다 여러 실행 경로가 존재할 수 있음</td></tr><tr><td><strong>유한 오토마톤</strong></td><td>DFA: δ: Q × Σ → Q</td><td>NFA: δ: Q × Σ → P(Q)</td></tr><tr><td><strong>튜링 기계</strong></td><td>DTM: δ: Q × Γ → Q × Γ × {L, R, S}</td><td>NTM: δ: Q × Γ → P(Q × Γ × {L, R, S})</td></tr><tr><td><strong>계산 능력</strong></td><td>재귀적 가산 언어를 인식</td><td>DTM과 동일한 계산 능력 (단, 효율성은 다를 수 있음)</td></tr><tr><td><strong>복잡도 클래스</strong></td><td>P (Polynomial Time)</td><td>NP (Nondeterministic Polynomial Time)</td></tr><tr><td><strong>P vs NP</strong></td><td>결정론적 다항 시간 알고리즘이 존재</td><td>비결정론적 다항 시간 알고리즘이 존재</td></tr><tr><td><strong>구현 방식</strong></td><td>직접적인 하드웨어 구현 가능</td><td>백트래킹, 병렬 처리, 확률적 방법으로 시뮬레이션</td></tr><tr><td><strong>결과 예측성</strong></td><td>높음 (동일 입력 = 동일 출력)</td><td>낮음 (동일 입력 ≠ 항상 동일 출력)</td></tr><tr><td><strong>디버깅 용이성</strong></td><td>상대적으로 용이함</td><td>복잡하고 어려움</td></tr><tr><td><strong>효율성</strong></td><td>일부 문제에서 비효율적일 수 있음</td><td>이론적으로 특정 문제에서 더 효율적일 수 있음</td></tr><tr><td><strong>자원 요구</strong></td><td>일반적으로 낮음</td><td>시뮬레이션 시 높음</td></tr><tr><td><strong>주요 응용 분야</strong></td><td>일반 컴퓨터 프로그램, 데이터베이스, 운영체제</td><td>AI, 최적화, 자연어 처리, 양자 컴퓨팅</td></tr><tr><td><strong>현실 세계 구현</strong></td><td>대부분의 현대 컴퓨터 시스템</td><td>양자 컴퓨터, 확률적 알고리즘, 병렬 컴퓨팅</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/complexity-classes/>Complexity-Classes</a></li><li><a href=https://buenhyden.github.io/tags/deterministic-vs-nondeterministic-computation/>Deterministic-vs-Nondeterministic-Computation</a></li><li><a href=https://buenhyden.github.io/tags/deterministic-computation/>Deterministic-Computation</a></li><li><a href=https://buenhyden.github.io/tags/nondeterministic-computation/>Nondeterministic-Computation</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-styles/messaging/event-driven/event-driven-pattern/><span class=title>« Prev</span><br><span>Event-Driven Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/p-vs-np-problem/><span class=title>Next »</span><br><span>P vs NP problem</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>