<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript Engines | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Javascript,Javascript-Engines"><meta name=description content="JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램으로, 웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Javascript Engines"><meta property="og:description" content="JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램으로, 웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-24T09:46:00+00:00"><meta property="article:modified_time" content="2025-02-24T09:46:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Javascript-Engines"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Javascript Engines"><meta name=twitter:description content="JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램으로, 웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Javascript Engines","item":"https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Javascript Engines","name":"Javascript Engines","description":"JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램으로, 웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.","keywords":["Programming-Languages","Javascript","Javascript-Engines"],"articleBody":"Javascript Engines JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램이다.\n웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.\nJavaScript는 원래 인터프리터 언어로 설계되었지만, 현대의 JavaScript 엔진들은 성능 향상을 위해 다양한 최적화 기술을 사용한다.\nJavaScript 엔진의 주요 역할:\nJavaScript 코드를 읽고 구문 분석(파싱) 코드를 기계어 또는 중간 표현으로 변환 코드 실행 메모리 관리 (가비지 컬렉션 포함) 최적화 수행 JavaScript 엔진은 현대 웹의 핵심 구성 요소로, 웹 브라우저와 서버 측 애플리케이션 모두에서 JavaScript 코드를 실행하는 데 필수적이다. Google의 V8, Mozilla의 SpiderMonkey, Apple의 JavaScriptCore와 같은 주요 엔진들은 계속해서 발전하며, 성능을 향상시키고 새로운 언어 기능을 지원하고 있다.\nJavaScript 엔진이 어떻게 작동하는지 이해하면 더 효율적인 코드를 작성하고, 성능 병목 현상을 진단하고, 최신 웹 개발 기술을 더 잘 활용할 수 있다. 앞으로도 JavaScript 엔진은 WebAssembly 통합, 병렬 처리 개선, 메모리 효율성 향상 등을 통해 계속 발전할 것으로 예상된다.\n주요 JavaScript 엔진들 V8 (Google) Google에서 개발한 V8은 Chrome 브라우저와 Node.js에서 사용되는 오픈 소스 JavaScript 엔진.\n주요 특징:\nC++로 작성되었다. JIT(Just-In-Time) 컴파일을 사용하여 JavaScript를 직접 기계어 코드로 컴파일한다. Ignition이라는 인터프리터와 TurboFan이라는 최적화 컴파일러로 구성된다. 높은 성능과 효율적인 메모리 관리를 제공한다. 독립적인 힙 메모리를 가지며 효율적인 가비지 컬렉션 메커니즘을 구현한다. V8 엔진 심층 분석 V8은 가장 널리 사용되는 JavaScript 엔진 중 하나로, 많은 현대적인 최적화 기술을 통합하고 있다.\nV8의 주요 구성 요소 Ignition (인터프리터): AST를 바이트코드로 변환한다. 바이트코드는 컴팩트하고 실행이 빠르다. 프로파일링 데이터를 수집하여 “핫” 함수를 식별한다. TurboFan (최적화 컴파일러): Ignition에서 수집한 타입 정보와 실행 통계를 사용한다. 고도로 최적화된 기계어 코드를 생성한다. 타입 전문화, 인라이닝, 데드 코드 제거 등의 최적화를 수행한다. Orinoco (가비지 컬렉터): 여러 가비지 컬렉션 알고리즘의 조합을 사용한다. 병렬, 증분, 동시 수집을 지원한다. 짧은 일시 중지 시간을 목표로 한다. V8의 최적화 기법 인라인 캐싱(Inline Caching): 객체 속성 접근과 같은 작업의 성능을 향상시킨다. 이전에 액세스한 속성의 위치를 캐시하여 반복적인 조회를 최적화한다. 숨겨진 클래스(Hidden Classes): 동적 속성을 가진 객체를 효율적으로 처리한다. 내부적으로 유사한 구조의 객체를 그룹화하여 속성 접근을 최적화한다. 타입 피드백(Type Feedback): 실행 중 타입 정보를 수집한다. 이 정보를 사용하여 타입에 특화된 최적화를 적용한다. 함수 인라이닝(Function Inlining): 작은 함수의 본문을 호출 사이트에 직접 통합한다. 함수 호출 오버헤드를 줄인다. 배열 최적화(Array Optimizations): 배열 작업을 위한 특수 최적화를 제공한다. 특히 동질적인 배열(같은 타입의 요소만 포함)에 대해 효율적이다. SpiderMonkey (Mozilla) Mozilla에서 개발한 최초의 JavaScript 엔진으로, Firefox 브라우저에서 사용된다.\n주요 특징:\nC와 C++로 작성되었다. JägerMonkey와 IonMonkey라는 JIT 컴파일러를 사용한다. 인터프리터 모드와 JIT 컴파일 모드를 결합한다. 가비지 컬렉션을 위한 다양한 알고리즘을 사용한다. JavaScriptCore (Apple) Apple에서 개발한 WebKit 프로젝트의 일부로, Safari 브라우저에서 사용된다.\nNitro 엔진으로도 알려져 있다.\n주요 특징:\nC와 C++로 작성되었다. LLInt(Low-Level Interpreter), Baseline JIT, DFG JIT(Data Flow Graph JIT), FTL JIT(Faster Than Light JIT)의 4단계 컴파일 파이프라인을 사용한다. 적응형 최적화 전략을 채택하여 코드 실행을 점진적으로 최적화한다. Chakra (Microsoft) Microsoft에서 개발한 엔진으로, 이전 버전의 Edge 브라우저와 Internet Explorer에서 사용되었다.\n주요 특징:\nJIT 컴파일을 사용한다. 부분적인 컴파일을 통해 시작 시간을 최적화한다. 병렬 JIT 컴파일을 지원한다. Microsoft는 현재 Edge 브라우저를 Chromium 기반으로 전환하여 V8 엔진을 사용하고 있다. Hermes (Facebook) Facebook에서 React Native 애플리케이션을 위해 개발한 오픈 소스 JavaScript 엔진.\n주요 특징:\n모바일 앱에 최적화되어 있다. 시작 시간 단축과 메모리 사용량 감소에 중점을 둔다. JIT 컴파일 대신 AOT(Ahead-of-Time) 컴파일 접근 방식을 사용한다. 경량화되어 모바일 기기에서 효율적으로 작동한다. JavaScript 엔진의 작동 원리 파싱 (Parsing) JavaScript 엔진이 코드를 처리하는 첫 번째 단계는 소스 코드를 파싱하는 것이다.\n이 과정은 두 단계로 나뉜다:\n렉싱(Lexing)/토큰화(Tokenizing): 소스 코드를 토큰이라는 의미 있는 조각으로 분해한다. 구문 분석(Syntactic Analysis): 토큰을 분석하여 추상 구문 트리(AST, Abstract Syntax Tree)를 생성한다. AST는 코드의 구조적 표현으로, 프로그램의 논리적 구조를 나타낸다. 파싱 과정에서 문법 오류가 발견되면, 엔진은 오류를 보고하고 실행을 중단한다.\n컴파일 (Compilation) 현대 JavaScript 엔진은 다양한 컴파일 전략을 사용한다:\n인터프리터(Interpreter): AST를 바이트코드로 변환하고 즉시 실행한다. 예를 들어, V8의 Ignition 인터프리터는 AST를 바이트코드로 변환한다. JIT 컴파일(Just-In-Time Compilation): 실행 시간에 코드를 기계어로 컴파일한다. 자주 실행되는 코드(“핫 코드”)를 식별하고 최적화한다. 최적화 컴파일러(Optimizing Compiler): V8의 TurboFan과 같은 최적화 컴파일러는 런타임 데이터를 기반으로 코드를 더 효율적인 기계어로 재컴파일한다. 최적화 해제(Deoptimization): 코드가 예상과 다르게 동작하면(예: 예상하지 못한 타입 변화), 엔진은 최적화를 해제하고 다시 인터프리터나 덜 최적화된 코드로 돌아간다. 실행 (Execution) 컴파일된 코드는 JavaScript 엔진의 실행 환경에서 실행된다.\n이 과정에서 몇 가지 중요한 개념이 있다:\n콜 스택(Call Stack): 함수 호출을 추적한다. 함수가 호출되면 스택에 추가되고, 완료되면 스택에서 제거된다. 힙(Heap): 객체, 문자열, 클로저 등의 데이터가 저장되는 메모리 영역이다. 이벤트 루프(Event Loop): 비동기 작업을 관리한다. 이벤트 루프는 JavaScript 엔진의 일부는 아니지만, Node.js나 브라우저와 같은 호스트 환경에서 JavaScript 엔진과 상호작용한다. 메모리 관리와 가비지 컬렉션 (Memory Management \u0026 Garbage Collection) JavaScript는 자동 메모리 관리를 제공한다.\n가비지 컬렉터(Garbage Collector)는 더 이상 접근할 수 없는 객체를 식별하고 메모리를 해제한다.\n주요 가비지 컬렉션 알고리즘:\n표시-청소(Mark-and-Sweep): 도달 가능한 객체를 모두 표시하고, 표시되지 않은 객체를 메모리에서 해제한다. 세대별 수집(Generational Collection): 객체를 생존 시간에 따라 다른 “세대\"로 분류하고, 다른 빈도로 수집한다. 새로운 객체는 더 자주 검사된다. 증분 수집(Incremental Collection): 가비지 컬렉션을 작은 단계로 나누어 실행하여 일시 중지 시간을 줄인다. 병렬 수집(Concurrent Collection): 메인 스레드를 차단하지 않고 백그라운드에서 가비지 컬렉션을 수행한다. JavaScript 엔진 성능 비교 다양한 JavaScript 엔진들은 서로 다른 벤치마크에서 각기 다른 성능 특성을 보인다.\n일반적으로 사용되는 벤치마크로는 Octane, JetStream, Kraken, SunSpider 등이 있다.\n최근 벤치마크 결과에 따르면:\nV8은 일반적으로 계산 집약적인 작업에서 뛰어난 성능을 보인다. JavaScriptCore는 메모리 사용량 최적화에 강점이 있다. SpiderMonkey는 특정 타입의 배열 작업에서 좋은 성능을 보인다. 그러나 성능 비교는 테스트 방법론, 벤치마크의 특성, 하드웨어 환경 등에 따라 달라질 수 있다.\nJavaScript 엔진의 미래 동향 WebAssembly (WASM) 통합\n모든 주요 JavaScript 엔진은 WebAssembly를 지원하도록 발전하고 있다. WebAssembly는 웹에서 거의 네이티브 속도로 실행되는 바이너리 형식으로, JavaScript와 함께 작동하여 성능 집약적인 작업을 처리할 수 있다.\n병렬 처리 개선\nJavaScript는 전통적으로 단일 스레드 모델을 따르지만, Web Workers와 SharedArrayBuffer와 같은 기능을 통해 병렬 처리 기능이 향상되고 있다. JavaScript 엔진은 이러한 병렬 처리 기능을 더 효율적으로 지원하기 위해 발전하고 있다.\n메모리 효율성\n모바일 기기와 IoT 장치에서의 JavaScript 사용이 증가함에 따라, 메모리 효율성은 JavaScript 엔진 개발의 중요한 초점이 되고 있다. Facebook의 Hermes 엔진은 이러한 추세의 좋은 예.\n시작 시간 최적화\n특히 모바일 환경에서는 빠른 시작 시간이 중요하다. JavaScript 엔진은 초기 파싱 및 컴파일 단계를 최적화하여 애플리케이션 시작 시간을 단축하는 방향으로 발전하고 있다.\nTypeScript 및 정적 타입 지원\nTypeScript와 같은 정적 타입 언어의 인기가 높아짐에 따라, JavaScript 엔진은 타입 정보를 활용하여 더 나은 최적화를 수행하는 방향으로 발전할 수 있다.\nJavaScript 엔진 디버깅 및 프로파일링 도구 Chrome DevTools Google Chrome의 개발자 도구는 V8 엔진에서 실행되는 JavaScript 코드를 디버깅하고 프로파일링하기 위한 강력한 도구를 제공한다.\n주요 기능:\nJavaScript 디버거: 코드 실행을 단계별로 추적하고 변수 값을 검사. 메모리 프로파일러: 메모리 사용량을 분석하고 메모리 누수를 식별. CPU 프로파일러: 성능 병목 현상을 식별하고 최적화 기회를 찾는다. 타임라인: 렌더링, 스크립팅, 페인팅 등의 타이밍을 시각화. Firefox DevTools Firefox의 개발자 도구는 SpiderMonkey 엔진에 대한 유사한 기능을 제공.\nNode.js 디버깅 도구 Node.js 환경에서는 다양한 디버깅 및 프로파일링 도구를 사용할 수 있다:\nnode –inspect: Chrome DevTools와 통합된 디버깅을 제공합니다. ndb: Google에서 개발한 향상된 디버깅 환경입니다. 0x: CPU 프로파일링을 위한 시각화 도구입니다. clinic.js: Node.js 애플리케이션의 성능 문제를 진단하는 도구 모음입니다. 효율적인 JavaScript 코드 작성을 위한 엔진 최적화 팁 JavaScript 엔진이 어떻게 작동하는지 이해하면 성능을 최적화하는 코드를 작성하는 데 도움이 된다.\n객체 및 배열 최적화 객체 구조 일관성 유지:\n1 2 3 4 5 6 7 8 9 10 11 // 좋은 예시 const users = [ { id: 1, name: \"김철수\", age: 30 }, { id: 2, name: \"이영희\", age: 25 } ]; // 나쁜 예시 (구조가 일관되지 않음) const users = [ { id: 1, name: \"김철수\", age: 30 }, { id: 2, name: \"이영희\" } // age 속성 누락 ]; 배열에 동일한 타입의 요소 사용:\n1 2 3 4 5 // 좋은 예시 (숫자만 포함) const numbers = [1, 2, 3, 4, 5]; // 나쁜 예시 (혼합된 타입) const mixed = [1, \"two\", { three: 3 }, [4]]; 함수 최적화 함수 재사용:\n1 2 3 4 5 6 7 8 // 좋은 예시 function add(a, b) { return a + b; } const sum1 = add(1, 2); const sum2 = add(3, 4); // 나쁜 예시 const sum1 = new Function('a', 'b', 'return a + b')(1, 2); const sum2 = new Function('a', 'b', 'return a + b')(3, 4); 메서드 인라이닝 고려:\n1 2 // 자주 호출되는 작은 함수는 인라이닝될 가능성이 높습니다 function square(x) { return x * x; } 타입 안정성 변수의 타입 일관성 유지:\n1 2 3 4 5 6 7 // 좋은 예시 let value = 42; value = 43; // 나쁜 예시 (타입 변경) let value = 42; value = \"43\"; // 숫자에서 문자열로 변경 조건부 타입 검사 최소화:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 좋은 예시 function processNumbers(numbers) { let sum = 0; for (let i = 0; i \u003c numbers.length; i++) { sum += numbers[i]; } return sum; } // 나쁜 예시 (매번 타입 검사) function processValues(values) { let sum = 0; for (let i = 0; i \u003c values.length; i++) { if (typeof values[i] === 'number') { sum += values[i]; } } return sum; } 메모리 사용 최적화 불필요한 객체 생성 방지:\n1 2 3 4 5 6 7 8 9 10 // 좋은 예시 (루프 외부에서 객체 생성) const options = { maxIterations: 1000 }; for (let i = 0; i \u003c 1000; i++) { processWithOptions(options); } // 나쁜 예시 (매 반복마다 새 객체 생성) for (let i = 0; i \u003c 1000; i++) { processWithOptions({ maxIterations: 1000 }); } 메모리 누수 방지:\n1 2 3 4 5 6 7 8 9 // 잠재적 메모리 누수 function createLargeArray() { const largeArray = new Array(1000000).fill(0); // 클로저는 largeArray에 대한 참조를 유지합니다 return function() { return largeArray.length; }; } JavaScript 엔진 딥다이브: 실제 사례 연구 V8의 Ignition과 TurboFan 파이프라인 다음 코드가 V8에서 어떻게 처리되는지 살펴보면:\n1 2 3 4 5 6 7 8 9 10 function sumArray(arr) { let sum = 0; for (let i = 0; i \u003c arr.length; i++) { sum += arr[i]; } return sum; } const numbers = [1, 2, 3, 4, 5]; console.log(sumArray(numbers)); 파싱: V8은 코드를 파싱하여 AST를 생성한다.\nIgnition: AST가 바이트코드로 변환된다. 예를 들어, 함수의 바이트코드는 다음과 같을 수 있다 (단순화됨):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 LdaZero // sum = 0 Star r0 // 레지스터 r0에 저장 LdaZero // i = 0 Star r1 // 레지스터 r1에 저장 JumpLoop loop_check loop_start: Ldar r1 // 레지스터 r1 로드 (i) LdaNamedProperty a0, [length] // a0.length 로드 TestLessThan // i \u003c arr.length 테스트 JumpIfFalse exit // false면 종료로 점프 Ldar r0 // 레지스터 r0 로드 (sum) Ldar a0 // 배열 a0 로드 LdaByIndex r1 // a0[i] 로드 Add // sum + a0[i] Star r0 // 결과를 r0에 저장 Ldar r1 // i 로드 Inc // i++ Star r1 // 레지스터 r1에 저장 Jump loop_start // 루프 시작으로 점프 exit: Ldar r0 // sum 로드 Return // 반환 프로파일링: 함수가 여러 번 호출되면, V8은 실행 통계를 수집한다. sumArray 함수가 항상 숫자 배열로 호출되는 것을 발견하면, 이 정보는 최적화에 사용된다.\nTurboFan 최적화: 함수가 “핫\"해지면(자주 실행됨), TurboFan이 바이트코드를 최적화된 기계어로 변환한다. 최적화에는 다음이 포함될 수 있다:\n배열 바운드 체크 제거 (가능한 경우) 숫자 더하기 연산을 네이티브 정수 더하기로 특화 루프 언롤링 인덱스 체크 최적화 최적화 코드 실행: 이후 sumArray 호출은 최적화된 버전을 사용한다.\n가능한 최적화 해제: 나중에 문자열 배열과 같은 다른 유형의 배열로 함수를 호출하면, V8은 최적화를 해제하고 보다 일반적인 코드로 돌아간다.\nJavaScript 엔진 관련 FAQ JavaScript는 인터프리터 언어인가요, 컴파일 언어인가요?\nA: 현대적인 관점에서 JavaScript는 “Just-In-Time” 컴파일되는 언어입니다. 처음에는 인터프리터에 의해 실행되지만, 자주 실행되는 코드는 최적화된 기계어 코드로 컴파일됩니다.\nJavaScript가 느리다고 들었는데, 사실인가요?\nA: 초기 JavaScript 엔진은 상대적으로 느렸지만, V8과 같은 현대 엔진은 매우 효율적입니다. 오늘날 JavaScript는 많은 작업에서 매우 빠르며, 특히 웹 애플리케이션에 적합합니다. 그러나 특정 계산 집약적인 작업에서는 C++나 Rust와 같은 저수준 언어보다는 느릴 수 있습니다.\nJavaScript 엔진마다 코드가 다르게 작동할 수 있나요?\nA: 네, 가능합니다. 모든 JavaScript 엔진은 ECMAScript 표준을 준수해야 하지만, 표준에 명시되지 않은 동작이나 최적화 전략은 엔진마다 다를 수 있습니다. 또한, 다양한 엔진은 최신 JavaScript 기능을 다른 시점에 구현할 수 있습니다.\nNode.js는 어떤 JavaScript 엔진을 사용하나요?\nA: Node.js는 Google의 V8 JavaScript 엔진을 사용합니다. 이는 Chrome 브라우저에서 사용되는 것과 동일한 엔진입니다.\nJavaScript 엔진을 직접 확장하거나 수정할 수 있나요?\nA: 네, 대부분의 주요 JavaScript 엔진은 오픈 소스입니다. V8, SpiderMonkey, JavaScriptCore는 모두 수정하고 확장할 수 있는 오픈 소스 프로젝트입니다. 그러나 JavaScript 엔진은 복잡한 소프트웨어로, 수정하려면 상당한 C++ 지식이 필요합니다.\n참고 및 출처 ","wordCount":"1980","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-02-24T09:46:00Z","dateModified":"2025-02-24T09:46:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Javascript Engines</h1><div class=post-description>JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램으로, 웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.</div><div class=post-meta><span title='2025-02-24 09:46:00 +0000 UTC'>February 24, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/JavaScript%20and%20TypeScript/JavaScript/Fundamentals/javascript-engines.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#javascript-engines>Javascript Engines</a><ul><li><a href=#주요-javascript-엔진들>주요 JavaScript 엔진들</a></li><li><a href=#javascript-엔진의-작동-원리>JavaScript 엔진의 작동 원리</a></li><li><a href=#javascript-엔진-성능-비교>JavaScript 엔진 성능 비교</a></li><li><a href=#javascript-엔진의-미래-동향>JavaScript 엔진의 미래 동향</a></li><li><a href=#javascript-엔진-디버깅-및-프로파일링-도구>JavaScript 엔진 디버깅 및 프로파일링 도구</a></li><li><a href=#효율적인-javascript-코드-작성을-위한-엔진-최적화-팁>효율적인 JavaScript 코드 작성을 위한 엔진 최적화 팁</a></li><li><a href=#javascript-엔진-딥다이브-실제-사례-연구>JavaScript 엔진 딥다이브: 실제 사례 연구</a></li><li><a href=#javascript-엔진-관련-faq>JavaScript 엔진 관련 FAQ</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=javascript-engines>Javascript Engines<a hidden class=anchor aria-hidden=true href=#javascript-engines>#</a></h2><p>JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램이다.<br>웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.<br>JavaScript는 원래 인터프리터 언어로 설계되었지만, 현대의 JavaScript 엔진들은 성능 향상을 위해 다양한 최적화 기술을 사용한다.</p><p>JavaScript 엔진의 주요 역할:</p><ul><li>JavaScript 코드를 읽고 구문 분석(파싱)</li><li>코드를 기계어 또는 중간 표현으로 변환</li><li>코드 실행</li><li>메모리 관리 (가비지 컬렉션 포함)</li><li>최적화 수행</li></ul><p>JavaScript 엔진은 현대 웹의 핵심 구성 요소로, 웹 브라우저와 서버 측 애플리케이션 모두에서 JavaScript 코드를 실행하는 데 필수적이다. Google의 V8, Mozilla의 SpiderMonkey, Apple의 JavaScriptCore와 같은 주요 엔진들은 계속해서 발전하며, 성능을 향상시키고 새로운 언어 기능을 지원하고 있다.</p><p>JavaScript 엔진이 어떻게 작동하는지 이해하면 더 효율적인 코드를 작성하고, 성능 병목 현상을 진단하고, 최신 웹 개발 기술을 더 잘 활용할 수 있다. 앞으로도 JavaScript 엔진은 WebAssembly 통합, 병렬 처리 개선, 메모리 효율성 향상 등을 통해 계속 발전할 것으로 예상된다.</p><h3 id=주요-javascript-엔진들>주요 JavaScript 엔진들<a hidden class=anchor aria-hidden=true href=#주요-javascript-엔진들>#</a></h3><h4 id=v8-google>V8 (Google)<a hidden class=anchor aria-hidden=true href=#v8-google>#</a></h4><p>Google에서 개발한 V8은 Chrome 브라우저와 Node.js에서 사용되는 오픈 소스 JavaScript 엔진.</p><p>주요 특징:</p><ul><li>C++로 작성되었다.</li><li>JIT(Just-In-Time) 컴파일을 사용하여 JavaScript를 직접 기계어 코드로 컴파일한다.</li><li>Ignition이라는 인터프리터와 TurboFan이라는 최적화 컴파일러로 구성된다.</li><li>높은 성능과 효율적인 메모리 관리를 제공한다.</li><li>독립적인 힙 메모리를 가지며 효율적인 가비지 컬렉션 메커니즘을 구현한다.</li></ul><h5 id=v8-엔진-심층-분석>V8 엔진 심층 분석<a hidden class=anchor aria-hidden=true href=#v8-엔진-심층-분석>#</a></h5><p>V8은 가장 널리 사용되는 JavaScript 엔진 중 하나로, 많은 현대적인 최적화 기술을 통합하고 있다.</p><h6 id=v8의-주요-구성-요소>V8의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#v8의-주요-구성-요소>#</a></h6><ol><li><strong>Ignition (인터프리터)</strong>:<ul><li>AST를 바이트코드로 변환한다.</li><li>바이트코드는 컴팩트하고 실행이 빠르다.</li><li>프로파일링 데이터를 수집하여 &ldquo;핫&rdquo; 함수를 식별한다.</li></ul></li><li><strong>TurboFan (최적화 컴파일러)</strong>:<ul><li>Ignition에서 수집한 타입 정보와 실행 통계를 사용한다.</li><li>고도로 최적화된 기계어 코드를 생성한다.</li><li>타입 전문화, 인라이닝, 데드 코드 제거 등의 최적화를 수행한다.</li></ul></li><li><strong>Orinoco (가비지 컬렉터)</strong>:<ul><li>여러 가비지 컬렉션 알고리즘의 조합을 사용한다.</li><li>병렬, 증분, 동시 수집을 지원한다.</li><li>짧은 일시 중지 시간을 목표로 한다.</li></ul></li></ol><h6 id=v8의-최적화-기법>V8의 최적화 기법<a hidden class=anchor aria-hidden=true href=#v8의-최적화-기법>#</a></h6><ol><li><strong>인라인 캐싱(Inline Caching)</strong>:<ul><li>객체 속성 접근과 같은 작업의 성능을 향상시킨다.</li><li>이전에 액세스한 속성의 위치를 캐시하여 반복적인 조회를 최적화한다.</li></ul></li><li><strong>숨겨진 클래스(Hidden Classes)</strong>:<ul><li>동적 속성을 가진 객체를 효율적으로 처리한다.</li><li>내부적으로 유사한 구조의 객체를 그룹화하여 속성 접근을 최적화한다.</li></ul></li><li><strong>타입 피드백(Type Feedback)</strong>:<ul><li>실행 중 타입 정보를 수집한다.</li><li>이 정보를 사용하여 타입에 특화된 최적화를 적용한다.</li></ul></li><li><strong>함수 인라이닝(Function Inlining)</strong>:<ul><li>작은 함수의 본문을 호출 사이트에 직접 통합한다.</li><li>함수 호출 오버헤드를 줄인다.</li></ul></li><li><strong>배열 최적화(Array Optimizations)</strong>:<ul><li>배열 작업을 위한 특수 최적화를 제공한다.</li><li>특히 동질적인 배열(같은 타입의 요소만 포함)에 대해 효율적이다.</li></ul></li></ol><h4 id=spidermonkey-mozilla>SpiderMonkey (Mozilla)<a hidden class=anchor aria-hidden=true href=#spidermonkey-mozilla>#</a></h4><p>Mozilla에서 개발한 최초의 JavaScript 엔진으로, Firefox 브라우저에서 사용된다.</p><p>주요 특징:</p><ul><li>C와 C++로 작성되었다.</li><li>JägerMonkey와 IonMonkey라는 JIT 컴파일러를 사용한다.</li><li>인터프리터 모드와 JIT 컴파일 모드를 결합한다.</li><li>가비지 컬렉션을 위한 다양한 알고리즘을 사용한다.</li></ul><h4 id=javascriptcore-apple>JavaScriptCore (Apple)<a hidden class=anchor aria-hidden=true href=#javascriptcore-apple>#</a></h4><p>Apple에서 개발한 WebKit 프로젝트의 일부로, Safari 브라우저에서 사용된다.<br>Nitro 엔진으로도 알려져 있다.</p><p>주요 특징:</p><ul><li>C와 C++로 작성되었다.</li><li>LLInt(Low-Level Interpreter), Baseline JIT, DFG JIT(Data Flow Graph JIT), FTL JIT(Faster Than Light JIT)의 4단계 컴파일 파이프라인을 사용한다.</li><li>적응형 최적화 전략을 채택하여 코드 실행을 점진적으로 최적화한다.</li></ul><h4 id=chakra-microsoft>Chakra (Microsoft)<a hidden class=anchor aria-hidden=true href=#chakra-microsoft>#</a></h4><p>Microsoft에서 개발한 엔진으로, 이전 버전의 Edge 브라우저와 Internet Explorer에서 사용되었다.</p><p>주요 특징:</p><ul><li>JIT 컴파일을 사용한다.</li><li>부분적인 컴파일을 통해 시작 시간을 최적화한다.</li><li>병렬 JIT 컴파일을 지원한다.</li><li>Microsoft는 현재 Edge 브라우저를 Chromium 기반으로 전환하여 V8 엔진을 사용하고 있다.</li></ul><h4 id=hermes-facebook>Hermes (Facebook)<a hidden class=anchor aria-hidden=true href=#hermes-facebook>#</a></h4><p>Facebook에서 React Native 애플리케이션을 위해 개발한 오픈 소스 JavaScript 엔진.</p><p>주요 특징:</p><ul><li>모바일 앱에 최적화되어 있다.</li><li>시작 시간 단축과 메모리 사용량 감소에 중점을 둔다.</li><li>JIT 컴파일 대신 AOT(Ahead-of-Time) 컴파일 접근 방식을 사용한다.</li><li>경량화되어 모바일 기기에서 효율적으로 작동한다.</li></ul><h3 id=javascript-엔진의-작동-원리>JavaScript 엔진의 작동 원리<a hidden class=anchor aria-hidden=true href=#javascript-엔진의-작동-원리>#</a></h3><h4 id=파싱-parsing>파싱 (Parsing)<a hidden class=anchor aria-hidden=true href=#파싱-parsing>#</a></h4><p>JavaScript 엔진이 코드를 처리하는 첫 번째 단계는 소스 코드를 파싱하는 것이다.</p><p>이 과정은 두 단계로 나뉜다:</p><ol><li><strong>렉싱(Lexing)/토큰화(Tokenizing)</strong>: 소스 코드를 토큰이라는 의미 있는 조각으로 분해한다.</li><li><strong>구문 분석(Syntactic Analysis)</strong>: 토큰을 분석하여 추상 구문 트리(AST, Abstract Syntax Tree)를 생성한다. AST는 코드의 구조적 표현으로, 프로그램의 논리적 구조를 나타낸다.</li></ol><p>파싱 과정에서 문법 오류가 발견되면, 엔진은 오류를 보고하고 실행을 중단한다.</p><h4 id=컴파일-compilation>컴파일 (Compilation)<a hidden class=anchor aria-hidden=true href=#컴파일-compilation>#</a></h4><p>현대 JavaScript 엔진은 다양한 컴파일 전략을 사용한다:</p><ol><li><strong>인터프리터(Interpreter)</strong>: AST를 바이트코드로 변환하고 즉시 실행한다. 예를 들어, V8의 Ignition 인터프리터는 AST를 바이트코드로 변환한다.</li><li><strong>JIT 컴파일(Just-In-Time Compilation)</strong>: 실행 시간에 코드를 기계어로 컴파일한다. 자주 실행되는 코드(&ldquo;핫 코드&rdquo;)를 식별하고 최적화한다.</li><li><strong>최적화 컴파일러(Optimizing Compiler)</strong>: V8의 TurboFan과 같은 최적화 컴파일러는 런타임 데이터를 기반으로 코드를 더 효율적인 기계어로 재컴파일한다.</li><li><strong>최적화 해제(Deoptimization)</strong>: 코드가 예상과 다르게 동작하면(예: 예상하지 못한 타입 변화), 엔진은 최적화를 해제하고 다시 인터프리터나 덜 최적화된 코드로 돌아간다.</li></ol><h4 id=실행-execution>실행 (Execution)<a hidden class=anchor aria-hidden=true href=#실행-execution>#</a></h4><p>컴파일된 코드는 JavaScript 엔진의 실행 환경에서 실행된다.</p><p>이 과정에서 몇 가지 중요한 개념이 있다:</p><ol><li><strong>콜 스택(Call Stack)</strong>: 함수 호출을 추적한다. 함수가 호출되면 스택에 추가되고, 완료되면 스택에서 제거된다.</li><li><strong>힙(Heap)</strong>: 객체, 문자열, 클로저 등의 데이터가 저장되는 메모리 영역이다.</li><li><strong>이벤트 루프(Event Loop)</strong>: 비동기 작업을 관리한다. 이벤트 루프는 JavaScript 엔진의 일부는 아니지만, Node.js나 브라우저와 같은 호스트 환경에서 JavaScript 엔진과 상호작용한다.</li></ol><h4 id=메모리-관리와-가비지-컬렉션-memory-management--garbage-collection>메모리 관리와 가비지 컬렉션 (Memory Management & Garbage Collection)<a hidden class=anchor aria-hidden=true href=#메모리-관리와-가비지-컬렉션-memory-management--garbage-collection>#</a></h4><p>JavaScript는 자동 메모리 관리를 제공한다.<br>가비지 컬렉터(Garbage Collector)는 더 이상 접근할 수 없는 객체를 식별하고 메모리를 해제한다.</p><p>주요 가비지 컬렉션 알고리즘:</p><ol><li><strong>표시-청소(Mark-and-Sweep)</strong>: 도달 가능한 객체를 모두 표시하고, 표시되지 않은 객체를 메모리에서 해제한다.</li><li><strong>세대별 수집(Generational Collection)</strong>: 객체를 생존 시간에 따라 다른 &ldquo;세대"로 분류하고, 다른 빈도로 수집한다. 새로운 객체는 더 자주 검사된다.</li><li><strong>증분 수집(Incremental Collection)</strong>: 가비지 컬렉션을 작은 단계로 나누어 실행하여 일시 중지 시간을 줄인다.</li><li><strong>병렬 수집(Concurrent Collection)</strong>: 메인 스레드를 차단하지 않고 백그라운드에서 가비지 컬렉션을 수행한다.</li></ol><h3 id=javascript-엔진-성능-비교>JavaScript 엔진 성능 비교<a hidden class=anchor aria-hidden=true href=#javascript-엔진-성능-비교>#</a></h3><p>다양한 JavaScript 엔진들은 서로 다른 벤치마크에서 각기 다른 성능 특성을 보인다.<br>일반적으로 사용되는 벤치마크로는 Octane, JetStream, Kraken, SunSpider 등이 있다.</p><p>최근 벤치마크 결과에 따르면:</p><ul><li>V8은 일반적으로 계산 집약적인 작업에서 뛰어난 성능을 보인다.</li><li>JavaScriptCore는 메모리 사용량 최적화에 강점이 있다.</li><li>SpiderMonkey는 특정 타입의 배열 작업에서 좋은 성능을 보인다.</li></ul><p>그러나 성능 비교는 테스트 방법론, 벤치마크의 특성, 하드웨어 환경 등에 따라 달라질 수 있다.</p><h3 id=javascript-엔진의-미래-동향>JavaScript 엔진의 미래 동향<a hidden class=anchor aria-hidden=true href=#javascript-엔진의-미래-동향>#</a></h3><ol><li><p>WebAssembly (WASM) 통합<br>모든 주요 JavaScript 엔진은 WebAssembly를 지원하도록 발전하고 있다. WebAssembly는 웹에서 거의 네이티브 속도로 실행되는 바이너리 형식으로, JavaScript와 함께 작동하여 성능 집약적인 작업을 처리할 수 있다.</p></li><li><p>병렬 처리 개선<br>JavaScript는 전통적으로 단일 스레드 모델을 따르지만, Web Workers와 SharedArrayBuffer와 같은 기능을 통해 병렬 처리 기능이 향상되고 있다. JavaScript 엔진은 이러한 병렬 처리 기능을 더 효율적으로 지원하기 위해 발전하고 있다.</p></li><li><p>메모리 효율성<br>모바일 기기와 IoT 장치에서의 JavaScript 사용이 증가함에 따라, 메모리 효율성은 JavaScript 엔진 개발의 중요한 초점이 되고 있다. Facebook의 Hermes 엔진은 이러한 추세의 좋은 예.</p></li><li><p>시작 시간 최적화<br>특히 모바일 환경에서는 빠른 시작 시간이 중요하다. JavaScript 엔진은 초기 파싱 및 컴파일 단계를 최적화하여 애플리케이션 시작 시간을 단축하는 방향으로 발전하고 있다.</p></li><li><p>TypeScript 및 정적 타입 지원<br>TypeScript와 같은 정적 타입 언어의 인기가 높아짐에 따라, JavaScript 엔진은 타입 정보를 활용하여 더 나은 최적화를 수행하는 방향으로 발전할 수 있다.</p></li></ol><h3 id=javascript-엔진-디버깅-및-프로파일링-도구>JavaScript 엔진 디버깅 및 프로파일링 도구<a hidden class=anchor aria-hidden=true href=#javascript-엔진-디버깅-및-프로파일링-도구>#</a></h3><h4 id=chrome-devtools>Chrome DevTools<a hidden class=anchor aria-hidden=true href=#chrome-devtools>#</a></h4><p>Google Chrome의 개발자 도구는 V8 엔진에서 실행되는 JavaScript 코드를 디버깅하고 프로파일링하기 위한 강력한 도구를 제공한다.</p><p>주요 기능:</p><ul><li>JavaScript 디버거: 코드 실행을 단계별로 추적하고 변수 값을 검사.</li><li>메모리 프로파일러: 메모리 사용량을 분석하고 메모리 누수를 식별.</li><li>CPU 프로파일러: 성능 병목 현상을 식별하고 최적화 기회를 찾는다.</li><li>타임라인: 렌더링, 스크립팅, 페인팅 등의 타이밍을 시각화.</li></ul><h4 id=firefox-devtools>Firefox DevTools<a hidden class=anchor aria-hidden=true href=#firefox-devtools>#</a></h4><p>Firefox의 개발자 도구는 SpiderMonkey 엔진에 대한 유사한 기능을 제공.</p><h4 id=nodejs-디버깅-도구>Node.js 디버깅 도구<a hidden class=anchor aria-hidden=true href=#nodejs-디버깅-도구>#</a></h4><p>Node.js 환경에서는 다양한 디버깅 및 프로파일링 도구를 사용할 수 있다:</p><ul><li>node &ndash;inspect: Chrome DevTools와 통합된 디버깅을 제공합니다.</li><li>ndb: Google에서 개발한 향상된 디버깅 환경입니다.</li><li>0x: CPU 프로파일링을 위한 시각화 도구입니다.</li><li>clinic.js: Node.js 애플리케이션의 성능 문제를 진단하는 도구 모음입니다.</li></ul><h3 id=효율적인-javascript-코드-작성을-위한-엔진-최적화-팁>효율적인 JavaScript 코드 작성을 위한 엔진 최적화 팁<a hidden class=anchor aria-hidden=true href=#효율적인-javascript-코드-작성을-위한-엔진-최적화-팁>#</a></h3><p>JavaScript 엔진이 어떻게 작동하는지 이해하면 성능을 최적화하는 코드를 작성하는 데 도움이 된다.</p><h4 id=객체-및-배열-최적화>객체 및 배열 최적화<a hidden class=anchor aria-hidden=true href=#객체-및-배열-최적화>#</a></h4><ol><li><p><strong>객체 구조 일관성 유지</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 좋은 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>users</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>id</span><span class=o>:</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;김철수&#34;</span><span class=p>,</span> <span class=nx>age</span><span class=o>:</span> <span class=mi>30</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>id</span><span class=o>:</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;이영희&#34;</span><span class=p>,</span> <span class=nx>age</span><span class=o>:</span> <span class=mi>25</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁜 예시 (구조가 일관되지 않음)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>users</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>id</span><span class=o>:</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;김철수&#34;</span><span class=p>,</span> <span class=nx>age</span><span class=o>:</span> <span class=mi>30</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span> <span class=nx>id</span><span class=o>:</span> <span class=mi>2</span><span class=p>,</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;이영희&#34;</span> <span class=p>}</span> <span class=c1>// age 속성 누락
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>];</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>배열에 동일한 타입의 요소 사용</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 좋은 예시 (숫자만 포함)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁜 예시 (혼합된 타입)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>mixed</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;two&#34;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>three</span><span class=o>:</span> <span class=mi>3</span> <span class=p>},</span> <span class=p>[</span><span class=mi>4</span><span class=p>]];</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=함수-최적화>함수 최적화<a hidden class=anchor aria-hidden=true href=#함수-최적화>#</a></h4><ol><li><p><strong>함수 재사용</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 좋은 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sum1</span> <span class=o>=</span> <span class=nx>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sum2</span> <span class=o>=</span> <span class=nx>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁜 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>sum1</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Function</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;return a + b&#39;</span><span class=p>)(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sum2</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Function</span><span class=p>(</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>,</span> <span class=s1>&#39;return a + b&#39;</span><span class=p>)(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>메서드 인라이닝 고려</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 자주 호출되는 작은 함수는 인라이닝될 가능성이 높습니다
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>square</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>x</span> <span class=o>*</span> <span class=nx>x</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=타입-안정성>타입 안정성<a hidden class=anchor aria-hidden=true href=#타입-안정성>#</a></h4><ol><li><p><strong>변수의 타입 일관성 유지</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 좋은 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>value</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>value</span> <span class=o>=</span> <span class=mi>43</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁜 예시 (타입 변경)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>value</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>value</span> <span class=o>=</span> <span class=s2>&#34;43&#34;</span><span class=p>;</span> <span class=c1>// 숫자에서 문자열로 변경
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>조건부 타입 검사 최소화</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 좋은 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>processNumbers</span><span class=p>(</span><span class=nx>numbers</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>numbers</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>numbers</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁜 예시 (매번 타입 검사)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>processValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>values</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>values</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>===</span> <span class=s1>&#39;number&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>values</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=메모리-사용-최적화>메모리 사용 최적화<a hidden class=anchor aria-hidden=true href=#메모리-사용-최적화>#</a></h4><ol><li><p><strong>불필요한 객체 생성 방지</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 좋은 예시 (루프 외부에서 객체 생성)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>options</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>maxIterations</span><span class=o>:</span> <span class=mi>1000</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>processWithOptions</span><span class=p>(</span><span class=nx>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 나쁜 예시 (매 반복마다 새 객체 생성)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>processWithOptions</span><span class=p>({</span> <span class=nx>maxIterations</span><span class=o>:</span> <span class=mi>1000</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>메모리 누수 방지</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 잠재적 메모리 누수
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>createLargeArray</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>largeArray</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Array</span><span class=p>(</span><span class=mi>1000000</span><span class=p>).</span><span class=nx>fill</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 클로저는 largeArray에 대한 참조를 유지합니다
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>largeArray</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=javascript-엔진-딥다이브-실제-사례-연구>JavaScript 엔진 딥다이브: 실제 사례 연구<a hidden class=anchor aria-hidden=true href=#javascript-엔진-딥다이브-실제-사례-연구>#</a></h3><h4 id=v8의-ignition과-turbofan-파이프라인>V8의 Ignition과 TurboFan 파이프라인<a hidden class=anchor aria-hidden=true href=#v8의-ignition과-turbofan-파이프라인>#</a></h4><p>다음 코드가 V8에서 어떻게 처리되는지 살펴보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>sumArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>arr</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>arr</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>sumArray</span><span class=p>(</span><span class=nx>numbers</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><ol><li><p><strong>파싱</strong>: V8은 코드를 파싱하여 AST를 생성한다.</p></li><li><p><strong>Ignition</strong>: AST가 바이트코드로 변환된다. 예를 들어, 함수의 바이트코드는 다음과 같을 수 있다 (단순화됨):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LdaZero           // sum = 0
</span></span><span class=line><span class=cl>Star r0           // 레지스터 r0에 저장
</span></span><span class=line><span class=cl>LdaZero           // i = 0
</span></span><span class=line><span class=cl>Star r1           // 레지스터 r1에 저장
</span></span><span class=line><span class=cl>JumpLoop loop_check
</span></span><span class=line><span class=cl>loop_start:
</span></span><span class=line><span class=cl>Ldar r1           // 레지스터 r1 로드 (i)
</span></span><span class=line><span class=cl>LdaNamedProperty a0, [length]  // a0.length 로드
</span></span><span class=line><span class=cl>TestLessThan      // i &lt; arr.length 테스트
</span></span><span class=line><span class=cl>JumpIfFalse exit  // false면 종료로 점프
</span></span><span class=line><span class=cl>Ldar r0           // 레지스터 r0 로드 (sum)
</span></span><span class=line><span class=cl>Ldar a0           // 배열 a0 로드
</span></span><span class=line><span class=cl>LdaByIndex r1     // a0[i] 로드
</span></span><span class=line><span class=cl>Add               // sum + a0[i]
</span></span><span class=line><span class=cl>Star r0           // 결과를 r0에 저장
</span></span><span class=line><span class=cl>Ldar r1           // i 로드
</span></span><span class=line><span class=cl>Inc               // i++
</span></span><span class=line><span class=cl>Star r1           // 레지스터 r1에 저장
</span></span><span class=line><span class=cl>Jump loop_start   // 루프 시작으로 점프
</span></span><span class=line><span class=cl>exit:
</span></span><span class=line><span class=cl>Ldar r0           // sum 로드
</span></span><span class=line><span class=cl>Return            // 반환
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>프로파일링</strong>: 함수가 여러 번 호출되면, V8은 실행 통계를 수집한다. <code>sumArray</code> 함수가 항상 숫자 배열로 호출되는 것을 발견하면, 이 정보는 최적화에 사용된다.</p></li><li><p><strong>TurboFan 최적화</strong>: 함수가 &ldquo;핫"해지면(자주 실행됨), TurboFan이 바이트코드를 최적화된 기계어로 변환한다. 최적화에는 다음이 포함될 수 있다:</p><ul><li>배열 바운드 체크 제거 (가능한 경우)</li><li>숫자 더하기 연산을 네이티브 정수 더하기로 특화</li><li>루프 언롤링</li><li>인덱스 체크 최적화</li></ul></li><li><p><strong>최적화 코드 실행</strong>: 이후 <code>sumArray</code> 호출은 최적화된 버전을 사용한다.</p></li><li><p><strong>가능한 최적화 해제</strong>: 나중에 문자열 배열과 같은 다른 유형의 배열로 함수를 호출하면, V8은 최적화를 해제하고 보다 일반적인 코드로 돌아간다.</p></li></ol><h3 id=javascript-엔진-관련-faq>JavaScript 엔진 관련 FAQ<a hidden class=anchor aria-hidden=true href=#javascript-엔진-관련-faq>#</a></h3><ol><li><p>JavaScript는 인터프리터 언어인가요, 컴파일 언어인가요?<br><strong>A</strong>: 현대적인 관점에서 JavaScript는 &ldquo;Just-In-Time&rdquo; 컴파일되는 언어입니다. 처음에는 인터프리터에 의해 실행되지만, 자주 실행되는 코드는 최적화된 기계어 코드로 컴파일됩니다.</p></li><li><p>JavaScript가 느리다고 들었는데, 사실인가요?<br><strong>A</strong>: 초기 JavaScript 엔진은 상대적으로 느렸지만, V8과 같은 현대 엔진은 매우 효율적입니다. 오늘날 JavaScript는 많은 작업에서 매우 빠르며, 특히 웹 애플리케이션에 적합합니다. 그러나 특정 계산 집약적인 작업에서는 C++나 Rust와 같은 저수준 언어보다는 느릴 수 있습니다.</p></li><li><p>JavaScript 엔진마다 코드가 다르게 작동할 수 있나요?<br><strong>A</strong>: 네, 가능합니다. 모든 JavaScript 엔진은 ECMAScript 표준을 준수해야 하지만, 표준에 명시되지 않은 동작이나 최적화 전략은 엔진마다 다를 수 있습니다. 또한, 다양한 엔진은 최신 JavaScript 기능을 다른 시점에 구현할 수 있습니다.</p></li><li><p>Node.js는 어떤 JavaScript 엔진을 사용하나요?<br><strong>A</strong>: Node.js는 Google의 V8 JavaScript 엔진을 사용합니다. 이는 Chrome 브라우저에서 사용되는 것과 동일한 엔진입니다.</p></li><li><p>JavaScript 엔진을 직접 확장하거나 수정할 수 있나요?<br><strong>A</strong>: 네, 대부분의 주요 JavaScript 엔진은 오픈 소스입니다. V8, SpiderMonkey, JavaScriptCore는 모두 수정하고 확장할 수 있는 오픈 소스 프로젝트입니다. 그러나 JavaScript 엔진은 복잡한 소프트웨어로, 수정하려면 상당한 C++ 지식이 필요합니다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/javascript/>Javascript</a></li><li><a href=https://buenhyden.github.io/tags/javascript-engines/>Javascript-Engines</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/ai-and-machine-learning/ai-vs-agi/><span class=title>« Prev</span><br><span>AI vs. AGI</span>
</a><a class=next href=https://buenhyden.github.io/posts/systems/networking-and-communication/real-time-communication/types-of-real-time-apis/><span class=title>Next »</span><br><span>Types of Real-time APIs</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>