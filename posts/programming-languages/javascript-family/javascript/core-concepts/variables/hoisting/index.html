<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hoisting | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Javascript,Basic-Syntax,Variables,Hoisting"><meta name=description content="JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 '끌어올린다(hoist)'는 의미를 가진다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/hoisting/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/hoisting/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/hoisting/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hoisting"><meta property="og:description" content="JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 '끌어올린다(hoist)'는 의미를 가진다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-25T14:17:00+00:00"><meta property="article:modified_time" content="2024-12-25T14:17:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Basic-Syntax"><meta property="article:tag" content="Variables"><meta property="article:tag" content="Hoisting"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hoisting"><meta name=twitter:description content="JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 '끌어올린다(hoist)'는 의미를 가진다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"JavaScript and TypeScript","item":"https://buenhyden.github.io/posts/programming-languages/javascript-family/"},{"@type":"ListItem","position":4,"name":"자바스크립트(JavaScript)","item":""},{"@type":"ListItem","position":6,"name":"Variables","item":"https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/"},{"@type":"ListItem","position":7,"name":"Hoisting","item":"https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/hoisting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hoisting","name":"Hoisting","description":"JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 '끌어올린다(hoist)'는 의미를 가진다.","keywords":["Programming-Languages","Javascript","Basic-Syntax","Variables","Hoisting"],"articleBody":"Hoisting 호이스팅(Hoisting)은 JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 ‘끌어올린다(hoist)‘는 의미를 가진다.\n그러나 실제로 코드가 물리적으로 재배치되는 것은 아니다. 이는 JavaScript 엔진의 컴파일 과정에서 일어나는 일종의 추상적 개념이다.\n호이스팅은 JavaScript의 핵심 메커니즘 중 하나로, 코드의 실행 방식에 영향을 미친다.\n효과적인 JavaScript 개발자가 되기 위해서는 호이스팅의 개념과 다양한 선언 방식에 따른 차이점을 이해하는 것이 중요하다.\n모던 JavaScript에서는 let과 const를 사용하여 변수를 선언하고, 함수 표현식을 활용하는 것이 호이스팅으로 인한 예기치 않은 동작을 방지하는 데 도움이 된다. 또한, 모든 변수를 스코프의 최상단에서 선언하는 습관을 들이면 호이스팅으로 인한 혼란을 최소화할 수 있다.\n호이스팅의 역사와 배경 호이스팅은 JavaScript가 처음 설계될 때부터 존재했던 특성이다.\n이는 Brendan Eich가 10일 만에 JavaScript를 만들면서 다른 언어(특히 Scheme)에서 영향을 받았기 때문이다.\n함수의 호이스팅은 프로그램 구조를 더 유연하게 만들고, 상호 재귀적인 함수를 쉽게 정의할 수 있게 한다.\n그러나 var의 호이스팅 동작은 많은 혼란을 야기했고, ES6에서 let과 const를 도입할 때 TDZ 개념을 함께 도입하여 더 예측 가능한 동작을 제공하게 되었다.\n호이스팅이 작동하는 방식 JavaScript 코드가 실행되기 전에 JavaScript 엔진은 두 가지 단계를 거친다:\n생성 단계(Creation Phase): 이 단계에서 엔진은 코드를 스캔하여 변수와 함수의 선언을 메모리에 저장한다. 실행 단계(Execution Phase): 이 단계에서 코드가 실제로 한 줄씩 실행된다.\n호이스팅은 생성 단계에서 발생하는 현상으로, 선언된 것들이 메모리에 저장되어 마치 코드의 최상단으로 ‘끌어올려진’ 것처럼 동작한다. 변수 호이스팅 변수 호이스팅은 변수 선언이 해당 스코프의 최상단으로 끌어올려지는 현상이다.\n변수 호이스팅은 사용된 선언 키워드(var, let, const)에 따라 다르게 동작한다.\nVar 변수의 호이스팅 var로 선언된 변수는 함수 스코프를 가진다. 선언과 초기화가 동시에 이루어지며, 초기 값은 undefined이다. 선언 이전에 변수를 참조하면 undefined를 반환한다. 1 2 console.log(varVariable); // undefined (에러가 아님) var varVariable = \"Hello, var!\"; 위 코드는 내부적으로 다음과 같이 해석된다:\n1 2 3 var varVariable; // 선언이 최상단으로 호이스팅되고, undefined로 초기화됨 console.log(varVariable); // undefined varVariable = \"Hello, var!\"; // 실제 할당은 원래 위치에서 실행 Let과 Const 변수의 호이스팅 let과 const로 선언된 변수는 블록 스코프를 가진다. 선언은 호이스팅되지만, 초기화는 실제 코드에 도달했을 때 이루어진다. 선언 이전에 변수를 참조하면 ReferenceError가 발생한다. (일시적 사각지대, Temporal Dead Zone, TDZ) 1 2 3 4 5 // console.log(letVariable); // ReferenceError: letVariable is not defined let letVariable = \"Hello, let!\"; // console.log(constVariable); // ReferenceError: constVariable is not defined const constVariable = \"Hello, const!\"; TDZ는 변수가 선언된 위치부터 해당 선언이 실행되기 전까지의 코드 영역을 의미한다.\n이 영역에서 변수에 접근하려고 하면 ReferenceError가 발생한다.\n내부적으로 이를 시각화하면:\n1 2 3 4 5 // 호이스팅은 되지만 초기화되지 않음 (TDZ 시작) // letVariable 선언은 인식되나 접근 불가 console.log(letVariable); // ReferenceError: letVariable is not defined let letVariable; // TDZ 종료, undefined로 초기화 letVariable = \"Hello, let!\"; // 값 할당 블록 스코프 내의 let과 const:\n1 2 3 4 5 6 7 8 { // TDZ 시작 // console.log(blockVar); // ReferenceError let blockVar = \"블록 스코프 변수\"; console.log(blockVar); // \"블록 스코프 변수\" } // 블록 스코프 종료 // console.log(blockVar); // ReferenceError: blockVar is not defined 함수 호이스팅 함수는 선언 방식에 따라 호이스팅 동작이 다르다.\n함수 선언문(Function Declaration)의 호이스팅 함수 선언문은 전체가 호이스팅된다. 이는 함수를 선언하기 전에 호출할 수 있다는 것을 의미한다.\n1 2 3 4 5 sayHello(); // \"Hello, World!\" (에러 없이 작동) function sayHello() { console.log(\"Hello, World!\"); } 함수 내부의 중첩 함수 선언문도 호이스팅된다:\n1 2 3 4 5 6 7 function outer() { inner(); // \"내부 함수입니다.\" function inner() { console.log(\"내부 함수입니다.\"); } } 함수 표현식(Function Expression)의 호이스팅 함수 표현식은 변수의 호이스팅 규칙을 따른다.\nvar로 선언된 함수 표현식은 undefined로 초기화되지만, 함수 자체는 호이스팅되지 않는다.\n1 2 3 4 5 6 console.log(varFunction); // undefined (함수가 아님) varFunction(); // TypeError: varFunction is not a function var varFunction = function() { console.log(\"I'm a function expression using var\"); }; let이나 const로 선언된 함수 표현식은 TDZ의 영향을 받는다:\n1 2 3 4 5 6 // console.log(letFunction); // ReferenceError: letFunction is not defined // letFunction(); // ReferenceError: letFunction is not defined let letFunction = function() { console.log(\"I'm a function expression using let\"); }; 화살표 함수(Arrow Function)의 호이스팅 화살표 함수도 함수 표현식과 마찬가지로 변수의 호이스팅 규칙을 따른다:\n1 2 3 4 5 6 // console.log(arrowFunction); // 변수 선언 방식에 따라 다름 // arrowFunction(); // 변수 선언 방식에 따라 다름 const arrowFunction = () =\u003e { console.log(\"I'm an arrow function\"); }; 클래스 호이스팅 ES6에서 도입된 클래스도 호이스팅의 영향을 받지만, let과 const처럼 TDZ가 적용된다:\n클래스 선언문 호이스팅 1 2 3 4 5 6 7 8 9 // const instance = new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization class MyClass { constructor() { this.property = \"값\"; } } const instance = new MyClass(); // 정상 작동 클래스 표현식 호이스팅 클래스 표현식도 변수 호이스팅 규칙을 따른다:\n1 2 3 4 5 6 7 8 9 // const instance = new MyClassExpression(); // ReferenceError: Cannot access 'MyClassExpression' before initialization const MyClassExpression = class { constructor() { this.property = \"값\"; } }; const instance = new MyClassExpression(); // 정상 작동 임포트 호이스팅 (Import Hoisting) ES6 모듈의 import 문도 호이스팅된다. 모듈 내에서는 import 선언이 코드 최상단으로 호이스팅된다.\n1 2 3 4 // myFunction(); // 이 함수는 import된 함수로, 호이스팅된 import 덕분에 사용 가능 // import와 export는 모듈의 최상단으로 호이스팅됨 import { myFunction } from './myModule.js'; 블록 레벨 함수 호이스팅 (Block-level Function Hoisting) ES6 이전에는 함수 선언문이 블록 내에 있을 때의 동작이 브라우저마다 달랐다. ES6부터는 엄격 모드(‘use strict’)에서 블록 레벨 함수가 블록 스코프 내로 호이스팅된다.\n1 2 3 4 5 6 7 8 9 10 11 12 'use strict'; { // 블록 내에서만 사용 가능 function blockFunc() { return \"블록 내 함수\"; } console.log(blockFunc()); // \"블록 내 함수\" } // console.log(blockFunc()); // ReferenceError: blockFunc is not defined 비엄격 모드에서는 블록 레벨 함수가 함수 스코프나 전역 스코프로 호이스팅되는데, 이 동작은 명확히 정의되어 있지 않아 권장되지 않는다.\n호이스팅의 실제 사례와 문제점 호이스팅은 때때로 예상치 못한 동작과 버그를 유발할 수 있다. 몇 가지 실제 사례를 살펴보자:\n함수와 변수 이름 충돌 같은 이름의 변수와 함수가 선언될 때 호이스팅이 어떻게 작동하는지 살펴보자:\n1 2 3 4 5 6 7 8 console.log(typeof myFunction); // \"function\" (함수 선언이 우선함) var myFunction = \"I am a string\"; function myFunction() { return \"I am a function\"; } console.log(typeof myFunction); // \"string\" (변수 선언이 함수 선언을 덮어씀) 이 경우 변수 선언이 함수 선언을 덮어써서, myFunction은 함수가 아닌 문자열이 된다.\n조건부 함수 선언 조건부 함수 선언은 호이스팅에 예측하기 어려운 영향을 미친다:\n1 2 3 4 5 6 7 8 9 10 11 12 if (true) { function conditionalFunc() { return \"조건 A\"; } } else { function conditionalFunc() { return \"조건 B\"; } } // 결과는 브라우저 및 JavaScript 엔진에 따라 다를 수 있음 console.log(conditionalFunc()); // 일반적으로 \"조건 A\"이지만 명확한 표준이 없음 이러한 코드는 브라우저마다 다른 결과를 보일 수 있으며, 명확한 표준이 없어 피해야 한다.\n대신 함수 표현식을 사용하는 것이 좋다:\n1 2 3 4 5 6 7 8 9 10 11 let conditionalFunc; if (true) { conditionalFunc = function() { return \"조건 A\"; }; } else { conditionalFunc = function() { return \"조건 B\"; }; } 변수 가려짐(Variable Shadowing) 1 2 3 4 5 6 7 8 9 var x = 10; function test() { console.log(x); // undefined (지역 변수 x가 호이스팅됨) var x = 20; console.log(x); // 20 } test(); 이 코드에서 함수 내부의 var x는 호이스팅되어, 전역 변수 x를 가리키는 것이 아니라 함수 스코프 내의 undefined 값을 출력한다.\n호이스팅의 내부 메커니즘 JavaScript 엔진이 코드를 어떻게 실행하는지 이해하려면 실행 컨텍스트(Execution Context)와 렉시컬 환경(Lexical Environment)이라는 두 가지 개념을 이해해야 한다.\n이 두 메커니즘은 JavaScript의 스코프, 클로저, 호이스팅과 같은 중요한 특성의 기반이 된다.\n실행 컨텍스트의 생성 단계에서 환경 레코드에 변수와 함수 선언이 등록되기 때문에 변수와 함수 선언이 코드의 최상단으로 “끌어올려진” 것처럼 동작하도록 한다.\n1 2 3 4 5 6 7 console.log(a); // undefined (에러가 아님) var a = 5; sayHello(); // \"Hello!\" (정상 작동) function sayHello() { console.log(\"Hello!\"); } 위 코드에서 a는 undefined로 출력되지만 에러가 발생하지 않는다. 이는 var 선언이 호이스팅되어 환경 레코드에 등록되고 undefined로 초기화되기 때문이다.\n마찬가지로 sayHello 함수도 호이스팅되어 선언 전에 호출할 수 있습니다.\nlet과 const의 경우는 다르다:\n1 2 console.log(b); // ReferenceError: Cannot access 'b' before initialization let b = 5; let과 const도 호이스팅되지만, 초기화되기 전에는 “일시적 사각지대(Temporal Dead Zone)“에 있어서 접근할 수 없다. 이는 변수가 렉시컬 환경에 등록되지만 아직 초기화되지 않았음을 의미한다.\n실행 컨텍스트(Execution Context) 실행 컨텍스트는 JavaScript 코드가 평가되고 실행되는 환경을 추상화한 개념이다. 쉽게 말해, JavaScript 엔진이 코드를 실행하기 위해 필요한 모든 정보를 담고 있는 환경이라고 생각할 수 있다.\n코드를 실행하는 데 필요한 모든 정보를 담고 있는 객체이다. 스코프, 호이스팅, this, 함수, 클로저 등의 동작 원리를 포함한다. 콜 스택에 쌓이며, 가장 위에 있는 컨텍스트와 관련된 코드가 실행된다. 함수가 실행될 때마다 새로운 실행 컨텍스트가 생성된다. JavaScript 엔진은 코드를 실행하기 위해 다음과 같은 세 가지 유형의 실행 컨텍스트를 생성한다:\n전역 실행 컨텍스트(Global Execution Context): 코드가 처음 실행될 때 생성되는 기본 컨텍스트이다. 브라우저에서는 window 객체가, Node.js에서는 global 객체가 이에 해당한다. 함수 실행 컨텍스트(Function Execution Context): 함수가 호출될 때마다 해당 함수에 대한 새로운 실행 컨텍스트가 생성된다. Eval 실행 컨텍스트(Eval Execution Context): eval() 함수 내에서 실행되는 코드에 대한 컨텍스트이다. 현대 JavaScript에서는 보안상의 이유로 잘 사용되지 않는다. 실행 컨텍스트의 구성 요소 실행 컨텍스트는 다음과 같은 주요 구성 요소를 가진다:\n렉시컬 환경(Lexical Environment): 변수와 함수 선언을 저장하는 곳이다. 변수 환경(Variable Environment): ES6부터 도입된 개념으로, 기본적으로 렉시컬 환경과 같지만 var 선언만 저장한다. this 바인딩(This Binding): 현재 컨텍스트에서 this 키워드가 참조하는 값을 결정한다. 외부 환경 참조(Outer Environment Reference): 외부 렉시컬 환경에 대한 참조이다. 실행 컨텍스트 스택(Execution Context Stack) JavaScript 엔진은 실행 컨텍스트 스택(호출 스택이라고도 함)을 사용하여 코드 실행 순서를 관리한다. 이 스택은 LIFO(Last In, First Out) 원칙에 따라 작동한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function first() { console.log('첫 번째 함수'); second(); } function second() { console.log('두 번째 함수'); third(); } function third() { console.log('세 번째 함수'); } first(); 위 코드가 실행될 때 실행 컨텍스트 스택은 다음과 같이 변화한다:\n전역 실행 컨텍스트가 스택에 추가된다. first() 함수가 호출되면 first 실행 컨텍스트가 스택에 추가된다. first 내부에서 second()가 호출되면 second 실행 컨텍스트가 스택에 추가된다. second 내부에서 third()가 호출되면 third 실행 컨텍스트가 스택에 추가된다. third 함수가 완료되면 해당 컨텍스트가 스택에서 제거된다. second 함수가 완료되면 해당 컨텍스트가 스택에서 제거된다. first 함수가 완료되면 해당 컨텍스트가 스택에서 제거된다. 마지막으로 전역 실행 컨텍스트가 남는다(프로그램이 종료될 때까지). 실행 컨텍스트의 생성 과정 실행 컨텍스트는 두 단계를 거쳐 생성된다:\n생성 단계(Creation Phase): 렉시컬 환경 컴포넌트 생성 변수 환경 컴포넌트 생성 this 바인딩 결정 실행 단계(Execution Phase): 코드를 한 줄씩 실행 변수에 값 할당 렉시컬 환경(Lexical Environment) 렉시컬 환경은 JavaScript 코드에서 변수와 함수가 어디에서 어떻게 접근 가능한지를 정의하는 구조이다.\n이는 식별자(변수명, 함수명 등)와 해당 식별자가 참조하는 값 사이의 연관 관계를 저장한다.\n렉시컬 환경의 구성 요소 렉시컬 환경은 다음 두 가지 주요 구성 요소로 이루어져 있다:\n환경 레코드(Environment Record): 현재 스코프 내의 변수, 함수 선언 등을 저장하는 저장소이다. 두 가지 유형이 있다:\n선언적 환경 레코드(Declarative Environment Record): 변수, 함수 선언, 매개변수 등을 저장한다. 객체 환경 레코드(Object Environment Record): 전역 코드의 경우 전역 객체(window, global)의 프로퍼티를 저장한다. 외부 렉시컬 환경 참조(Outer Lexical Environment Reference): 외부 스코프(상위 스코프)의 렉시컬 환경을 참조한다. 이를 통해 스코프 체인이 형성된다.\n렉시컬 스코핑(Lexical Scoping) JavaScript는 렉시컬 스코핑(정적 스코핑)을 사용한다. 이는 변수의 스코프가 코드를 작성하는 시점(즉, 어디에 작성되었는지)에 결정된다는 의미이다. 이것이 바로 ‘렉시컬(lexical)‘이라는 용어가 사용되는 이유이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const globalVariable = \"전역 변수\"; function outerFunction() { const outerVariable = \"외부 함수 변수\"; function innerFunction() { const innerVariable = \"내부 함수 변수\"; console.log(innerVariable); // \"내부 함수 변수\" console.log(outerVariable); // \"외부 함수 변수\" console.log(globalVariable); // \"전역 변수\" } innerFunction(); } outerFunction(); 위 코드에서 innerFunction이 outerVariable과 globalVariable에 접근할 수 있는 이유는 렉시컬 스코핑 때문이다. innerFunction의 렉시컬 환경은 외부 렉시컬 환경 참조를 통해 outerFunction의 렉시컬 환경에 접근할 수 있고, 이어서 전역 렉시컬 환경에도 접근할 수 있다.\n실행 컨텍스트와 렉시컬 환경의 상호작용 실행 컨텍스트와 렉시컬 환경이 어떻게 상호작용하는지 더 자세히 살펴보자.\n예제를 통한 이해 1 2 3 4 5 6 7 8 9 10 let a = 10; function fn1() { let b = 20; function fn2() { let c = 30; console.log(a + b + c); } fn2(); } fn1(); 이 코드가 실행될 때 발생하는 일을 단계별로 살펴보면:\n전역 실행 컨텍스트 생성:\n전역 렉시컬 환경 생성 환경 레코드에 변수 a와 함수 fn1 등록 a에 10 할당 fn1 호출:\nfn1의 실행 컨텍스트 생성 fn1의 렉시컬 환경 생성 환경 레코드에 변수 b와 함수 fn2 등록 외부 렉시컬 환경 참조는 전역 렉시컬 환경을 가리킴 b에 20 할당 fn2 호출:\nfn2의 실행 컨텍스트 생성 fn2의 렉시컬 환경 생성 환경 레코드에 변수 c 등록 외부 렉시컬 환경 참조는 fn1의 렉시컬 환경을 가리킴 c에 30 할당 console.log(a + b + c) 실행:\nc는 현재 렉시컬 환경에서 찾음 b는 외부 렉시컬 환경(fn1)에서 찾음 a는 더 외부의 렉시컬 환경(전역)에서 찾음 60 출력 (10 + 20 + 30) fn2 실행 완료:\nfn2의 실행 컨텍스트가 스택에서 제거됨 fn1 실행 완료:\nfn1의 실행 컨텍스트가 스택에서 제거됨 이 과정에서 볼 수 있듯이, 각 함수가 호출될 때마다 새로운 실행 컨텍스트와 렉시컬 환경이 생성된다. 그리고 변수를 찾을 때는 현재 렉시컬 환경에서 시작하여 외부 렉시컬 환경 참조를 따라 상위 환경을 차례로 탐색한다.\n클로저(Closure)와 렉시컬 환경 클로저는 렉시컬 환경과 깊은 관련이 있다. 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 function createCounter() { let count = 0; return function increment() { count++; return count; }; } const counter = createCounter(); console.log(counter()); // 1 console.log(counter()); // 2 console.log(counter()); // 3 이 예제에서 increment 함수는 createCounter의 렉시컬 환경에 있는 count 변수에 계속 접근할 수 있다. 이는 increment 함수가 생성될 때 외부 렉시컬 환경 참조를 통해 createCounter의 렉시컬 환경을 참조하기 때문이다. 이 참조는 createCounter 함수의 실행이 완료된 후에도 유지된다.\n블록 스코프와 렉시컬 환경 ES6부터 도입된 let과 const는 블록 스코프를 가진다. 이는 중괄호({}) 내에서 선언된 변수가 해당 블록 내에서만 유효하다는 의미이다.\n1 2 3 4 5 6 7 { let blockVar = \"블록 내부\"; var functionVar = \"함수 스코프\"; } console.log(functionVar); // \"함수 스코프\" console.log(blockVar); // ReferenceError: blockVar is not defined JavaScript 엔진은 블록 스코프를 구현하기 위해 블록마다 별도의 렉시컬 환경을 생성한다.\n블록이 실행될 때 새로운 렉시컬 환경이 생성되고, 블록이 종료되면 해당 환경은 참조가 없어져 가비지 컬렉션의 대상이 된다.\nThis 바인딩과 실행 컨텍스트 this 키워드의 값은 함수가 어떻게 호출되는지에 따라 결정된다.\n이는 실행 컨텍스트가 생성될 때 this 바인딩 컴포넌트에 저장된다.\n1 2 3 4 5 6 7 8 9 10 11 const person = { name: \"홍길동\", sayHello: function() { console.log(`안녕하세요, ${this.name}입니다.`); } }; person.sayHello(); // \"안녕하세요, 홍길동입니다.\" const greet = person.sayHello; greet(); // \"안녕하세요, undefined입니다.\" (this가 전역 객체를 가리킴) 여기서 person.sayHello()를 호출할 때 this는 person 객체를 가리키지만, greet()를 호출할 때는 this가 전역 객체(브라우저에서는 window)를 가리킨다. 이는 함수를 어떻게 호출하는지에 따라 실행 컨텍스트의 this 바인딩이 다르게 설정되기 때문이다.\n함수의 종류에 따른 실행 컨텍스트와 렉시컬 환경의 차이 JavaScript에는 여러 종류의 함수가 있으며, 각각 실행 컨텍스트와 렉시컬 환경에 영향을 미치는 방식이 다르다.\n일반 함수(Function Declaration \u0026 Expression) 일반 함수는 자신만의 this, arguments, 그리고 새로운 실행 컨텍스트를 가진다.\n1 2 3 function regularFunction() { console.log(this); // 호출 방식에 따라 달라짐 } 화살표 함수(Arrow Function) 화살표 함수는 자신의 this와 arguments를 갖지 않으며, 상위 스코프의 것을 사용한다.\n1 2 3 const arrowFunction = () =\u003e { console.log(this); // 항상 상위 스코프의 this를 사용 }; 이는 화살표 함수가 생성될 때 렉시컬 환경의 외부 환경 참조를 통해 상위 스코프의 this를 캡처하기 때문이다.\n실행 컨텍스트와 렉시컬 환경의 응용 이 개념들을 이해하면 JavaScript의 많은 고급 패턴과 기법을 더 잘 이해할 수 있다.\n모듈 패턴(Module Pattern) 모듈 패턴은 클로저를 이용하여 private 변수와 메서드를 구현하는 방법.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const counter = (function() { let count = 0; // private 변수 return { increment: function() { count++; return count; }, decrement: function() { count--; return count; }, getValue: function() { return count; } }; })(); console.log(counter.increment()); // 1 console.log(counter.increment()); // 2 console.log(counter.getValue()); // 2 console.log(counter.count); // undefined (private 변수에 직접 접근 불가) 이 패턴은 즉시 실행 함수 표현식(IIFE)의 렉시컬 환경에 count 변수를 캡슐화하여, 외부에서 직접 접근할 수 없게 한다.\n커링(Currying) 커링은 여러 인자를 받는 함수를 인자 하나씩 받는 함수들의 체인으로 변환하는 기법.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function curry(fn) { return function curried(...args) { if (args.length \u003e= fn.length) { return fn.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); }; } }; } function add(a, b, c) { return a + b + c; } const curriedAdd = curry(add); console.log(curriedAdd(1)(2)(3)); // 6 console.log(curriedAdd(1, 2)(3)); // 6 console.log(curriedAdd(1)(2, 3)); // 6 이 패턴은, 각 단계에서 새로운 실행 컨텍스트와 렉시컬 환경이 생성되고, 클로저를 통해 이전 단계의 인자가 유지되는 방식으로 작동한다.\n실제 개발에서의 호이스팅 활용 및 주의사항 호이스팅을 활용한 코드 구성 함수 호이스팅을 활용하면 코드의 가독성을 높일 수 있다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 메인 함수 먼저 배치 function main() { helper1(); helper2(); } // 보조 함수는 아래에 배치 function helper1() { console.log(\"보조 함수 1\"); } function helper2() { console.log(\"보조 함수 2\"); } main(); // 정상 작동 이렇게 하면 중요한 코드를 먼저 보여주고 세부 구현은 나중에 배치할 수 있다.\n호이스팅 관련 모범 사례 호이스팅으로 인한 문제를 방지하기 위한 몇 가지 모범 사례:\n명확한 초기화 패턴 사용하기 1 2 3 4 5 6 7 8 let config = null; // 명시적으로 초기값 설정 function initConfig() { config = { theme: 'dark', language: 'ko' }; } 변수는 항상 스코프의 최상단에서 선언하기 1 2 3 4 5 6 7 8 function goodExample() { // 모든 변수를 함수 시작 부분에 선언 let a = 1; let b = 2; // 이후 로직 작성 return a + b; } Let과 Const 사용하기 var 대신 let과 const를 사용하면 TDZ 덕분에 호이스팅 관련 버그를 더 일찍 발견할 수 있다.\n1 2 3 4 5 6 7 function betterExample() { // 이 줄에서 에러가 발생하므로 버그를 일찍 찾을 수 있음 // console.log(x); // ReferenceError: x is not defined const x = 10; return x; } 함수 표현식 사용하기 함수 선언문 대신 함수 표현식을 사용하면 호이스팅을 제한할 수 있다.\n1 2 3 4 5 6 7 8 9 // 함수 선언문 (전체가 호이스팅됨) function declaredFunction() { return \"I am hoisted entirely\"; } // 함수 표현식 (변수 호이스팅 규칙을 따름) const expressionFunction = function() { return \"I follow variable hoisting rules\"; }; 다양한 유형의 호이스팅 비교 선언 유형 호이스팅 초기화 TDZ 예시 var 변수 예 undefined 아니오 var x = 5; let 변수 예 아니오 예 let x = 5; const 변수 예 아니오 예 const x = 5; 함수 선언문 예 전체 함수 아니오 function x() {} 함수 표현식(var) 변수만 undefined 아니오 var x = function() {}; 함수 표현식(let/const) 변수만 아니오 예 const x = function() {}; 클래스 선언 예 아니오 예 class X {} 클래스 표현식 변수만 아니오 예 const X = class {}; 호이스팅의 주의사항 코드의 가독성과 유지보수성을 위해 변수와 함수는 사용하기 전에 선언하는 것이 좋다. let과 const를 사용하여 예측 가능한 스코프 동작을 만들어내는 것이 권장된다. 함수 표현식보다는 함수 선언문을 사용하면 호이스팅으로 인한 혼란을 줄일 수 있다. 다양한 JavaScript 환경에서의 호이스팅 브라우저 환경에서의 호이스팅 브라우저에서는 전역 스코프가 window 객체와 연결된다:\n1 2 3 4 5 6 var globalVar = \"전역 변수\"; console.log(window.globalVar); // \"전역 변수\" // let과 const는 window 객체에 추가되지 않음 let globalLet = \"전역 let 변수\"; console.log(window.globalLet); // undefined Node.js 환경에서의 호이스팅 Node.js에서는 모듈 패턴으로 인해 전역 스코프가 다르게 동작한다:\n1 2 3 4 var moduleVar = \"모듈 변수\"; console.log(global.moduleVar); // undefined (Node.js에서는 var가 global에 자동 추가되지 않음) // CommonJS 모듈에서는 각 파일이 자체 스코프를 가짐 ES 모듈에서의 호이스팅 ES 모듈은 자체적인 스코프를 가지며, import와 export가 호이스팅된다:\n1 2 3 4 5 6 7 8 9 // 이 import는 실행 전에 처리됨 import { helper } from './helper.js'; // 사용 전에 export됨 helper(); export function myFunction() { // … } 참고 및 출처 ","wordCount":"3196","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-25T14:17:00Z","dateModified":"2024-12-25T14:17:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/hoisting/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/javascript-family/>JavaScript and TypeScript</a>&nbsp;»&nbsp;<a href>자바스크립트(JavaScript)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/>Variables</a></div><h1 class="post-title entry-hint-parent">Hoisting</h1><div class=post-description>JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 '끌어올린다(hoist)'는 의미를 가진다.</div><div class=post-meta><span title='2024-12-25 14:17:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/JavaScript%20Family/JavaScript/Core%20Concepts/Variables/hoisting.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#hoisting>Hoisting</a><ul><li><a href=#호이스팅의-역사와-배경>호이스팅의 역사와 배경</a></li><li><a href=#호이스팅이-작동하는-방식>호이스팅이 작동하는 방식</a></li><li><a href=#변수-호이스팅>변수 호이스팅</a></li><li><a href=#함수-호이스팅>함수 호이스팅</a></li><li><a href=#클래스-호이스팅>클래스 호이스팅</a></li><li><a href=#임포트-호이스팅-import-hoisting>임포트 호이스팅 (Import Hoisting)</a></li><li><a href=#블록-레벨-함수-호이스팅-block-level-function-hoisting>블록 레벨 함수 호이스팅 (Block-level Function Hoisting)</a></li><li><a href=#호이스팅의-실제-사례와-문제점>호이스팅의 실제 사례와 문제점</a></li><li><a href=#호이스팅의-내부-메커니즘>호이스팅의 내부 메커니즘</a></li><li><a href=#실제-개발에서의-호이스팅-활용-및-주의사항>실제 개발에서의 호이스팅 활용 및 주의사항</a></li><li><a href=#다양한-유형의-호이스팅-비교>다양한 유형의 호이스팅 비교</a></li><li><a href=#호이스팅의-주의사항>호이스팅의 주의사항</a></li><li><a href=#다양한-javascript-환경에서의-호이스팅>다양한 JavaScript 환경에서의 호이스팅</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=hoisting>Hoisting<a hidden class=anchor aria-hidden=true href=#hoisting>#</a></h2><p>호이스팅(Hoisting)은 JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 &lsquo;끌어올린다(hoist)&lsquo;는 의미를 가진다.<br>그러나 실제로 코드가 물리적으로 재배치되는 것은 아니다. 이는 JavaScript 엔진의 컴파일 과정에서 일어나는 일종의 추상적 개념이다.</p><p>호이스팅은 JavaScript의 핵심 메커니즘 중 하나로, 코드의 실행 방식에 영향을 미친다.<br>효과적인 JavaScript 개발자가 되기 위해서는 호이스팅의 개념과 다양한 선언 방식에 따른 차이점을 이해하는 것이 중요하다.</p><p>모던 JavaScript에서는 <code>let</code>과 <code>const</code>를 사용하여 변수를 선언하고, 함수 표현식을 활용하는 것이 호이스팅으로 인한 예기치 않은 동작을 방지하는 데 도움이 된다. 또한, 모든 변수를 스코프의 최상단에서 선언하는 습관을 들이면 호이스팅으로 인한 혼란을 최소화할 수 있다.</p><h3 id=호이스팅의-역사와-배경>호이스팅의 역사와 배경<a hidden class=anchor aria-hidden=true href=#호이스팅의-역사와-배경>#</a></h3><p>호이스팅은 JavaScript가 처음 설계될 때부터 존재했던 특성이다.<br>이는 Brendan Eich가 10일 만에 JavaScript를 만들면서 다른 언어(특히 Scheme)에서 영향을 받았기 때문이다.<br>함수의 호이스팅은 프로그램 구조를 더 유연하게 만들고, 상호 재귀적인 함수를 쉽게 정의할 수 있게 한다.<br>그러나 <code>var</code>의 호이스팅 동작은 많은 혼란을 야기했고, ES6에서 <code>let</code>과 <code>const</code>를 도입할 때 TDZ 개념을 함께 도입하여 더 예측 가능한 동작을 제공하게 되었다.</p><h3 id=호이스팅이-작동하는-방식>호이스팅이 작동하는 방식<a hidden class=anchor aria-hidden=true href=#호이스팅이-작동하는-방식>#</a></h3><p>JavaScript 코드가 실행되기 전에 JavaScript 엔진은 두 가지 단계를 거친다:</p><ol><li><strong>생성 단계(Creation Phase)</strong>: 이 단계에서 엔진은 코드를 스캔하여 변수와 함수의 선언을 메모리에 저장한다.</li><li><strong>실행 단계(Execution Phase)</strong>: 이 단계에서 코드가 실제로 한 줄씩 실행된다.<br>호이스팅은 생성 단계에서 발생하는 현상으로, 선언된 것들이 메모리에 저장되어 마치 코드의 최상단으로 &lsquo;끌어올려진&rsquo; 것처럼 동작한다.</li></ol><h3 id=변수-호이스팅>변수 호이스팅<a hidden class=anchor aria-hidden=true href=#변수-호이스팅>#</a></h3><p>변수 호이스팅은 변수 선언이 해당 스코프의 최상단으로 끌어올려지는 현상이다.<br>변수 호이스팅은 사용된 선언 키워드(<code>var</code>, <code>let</code>, <code>const</code>)에 따라 다르게 동작한다.</p><h4 id=var-변수의-호이스팅>Var 변수의 호이스팅<a hidden class=anchor aria-hidden=true href=#var-변수의-호이스팅>#</a></h4><ul><li><code>var</code>로 선언된 변수는 <strong>함수 스코프</strong>를 가진다.</li><li>선언과 초기화가 동시에 이루어지며, 초기 값은 <code>undefined</code>이다.</li><li>선언 이전에 변수를 참조하면 <code>undefined</code>를 반환한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>varVariable</span><span class=p>);</span> <span class=c1>// undefined (에러가 아님)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>varVariable</span> <span class=o>=</span> <span class=s2>&#34;Hello, var!&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드는 내부적으로 다음과 같이 해석된다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>varVariable</span><span class=p>;</span> <span class=c1>// 선언이 최상단으로 호이스팅되고, undefined로 초기화됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>varVariable</span><span class=p>);</span> <span class=c1>// undefined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>varVariable</span> <span class=o>=</span> <span class=s2>&#34;Hello, var!&#34;</span><span class=p>;</span> <span class=c1>// 실제 할당은 원래 위치에서 실행
</span></span></span></code></pre></td></tr></table></div></div><h4 id=let과-const-변수의-호이스팅>Let과 Const 변수의 호이스팅<a hidden class=anchor aria-hidden=true href=#let과-const-변수의-호이스팅>#</a></h4><ul><li><code>let</code>과 <code>const</code>로 선언된 변수는 <strong>블록 스코프</strong>를 가진다.</li><li>선언은 호이스팅되지만, 초기화는 실제 코드에 도달했을 때 이루어진다.</li><li>선언 이전에 변수를 참조하면 <code>ReferenceError</code>가 발생한다.  (일시적 사각지대, Temporal Dead Zone, TDZ)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// console.log(letVariable); // ReferenceError: letVariable is not defined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>letVariable</span> <span class=o>=</span> <span class=s2>&#34;Hello, let!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// console.log(constVariable); // ReferenceError: constVariable is not defined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>constVariable</span> <span class=o>=</span> <span class=s2>&#34;Hello, const!&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>TDZ는 변수가 선언된 위치부터 해당 선언이 실행되기 전까지의 코드 영역을 의미한다.<br>이 영역에서 변수에 접근하려고 하면 <code>ReferenceError</code>가 발생한다.</p><p>내부적으로 이를 시각화하면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 호이스팅은 되지만 초기화되지 않음 (TDZ 시작)
</span></span></span><span class=line><span class=cl><span class=c1>// letVariable 선언은 인식되나 접근 불가
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>letVariable</span><span class=p>);</span> <span class=c1>// ReferenceError: letVariable is not defined
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>letVariable</span><span class=p>;</span> <span class=c1>// TDZ 종료, undefined로 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>letVariable</span> <span class=o>=</span> <span class=s2>&#34;Hello, let!&#34;</span><span class=p>;</span> <span class=c1>// 값 할당
</span></span></span></code></pre></td></tr></table></div></div><p>블록 스코프 내의 <code>let</code>과 <code>const</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// TDZ 시작
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// console.log(blockVar); // ReferenceError
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>let</span> <span class=nx>blockVar</span> <span class=o>=</span> <span class=s2>&#34;블록 스코프 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>blockVar</span><span class=p>);</span> <span class=c1>// &#34;블록 스코프 변수&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=c1>// 블록 스코프 종료
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// console.log(blockVar); // ReferenceError: blockVar is not defined
</span></span></span></code></pre></td></tr></table></div></div><h3 id=함수-호이스팅>함수 호이스팅<a hidden class=anchor aria-hidden=true href=#함수-호이스팅>#</a></h3><p>함수는 선언 방식에 따라 호이스팅 동작이 다르다.</p><h4 id=함수-선언문function-declaration의-호이스팅>함수 선언문(Function Declaration)의 호이스팅<a hidden class=anchor aria-hidden=true href=#함수-선언문function-declaration의-호이스팅>#</a></h4><p>함수 선언문은 전체가 호이스팅된다. 이는 함수를 선언하기 전에 호출할 수 있다는 것을 의미한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>sayHello</span><span class=p>();</span> <span class=c1>// &#34;Hello, World!&#34; (에러 없이 작동)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>sayHello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hello, World!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>함수 내부의 중첩 함수 선언문도 호이스팅된다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>inner</span><span class=p>();</span> <span class=c1>// &#34;내부 함수입니다.&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>inner</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;내부 함수입니다.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=함수-표현식function-expression의-호이스팅>함수 표현식(Function Expression)의 호이스팅<a hidden class=anchor aria-hidden=true href=#함수-표현식function-expression의-호이스팅>#</a></h4><p>함수 표현식은 변수의 호이스팅 규칙을 따른다.<br><code>var</code>로 선언된 함수 표현식은 <code>undefined</code>로 초기화되지만, 함수 자체는 호이스팅되지 않는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>varFunction</span><span class=p>);</span> <span class=c1>// undefined (함수가 아님)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>varFunction</span><span class=p>();</span> <span class=c1>// TypeError: varFunction is not a function
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>varFunction</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;I&#39;m a function expression using var&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p><code>let</code>이나 <code>const</code>로 선언된 함수 표현식은 TDZ의 영향을 받는다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// console.log(letFunction); // ReferenceError: letFunction is not defined
</span></span></span><span class=line><span class=cl><span class=c1>// letFunction(); // ReferenceError: letFunction is not defined
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>letFunction</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;I&#39;m a function expression using let&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=화살표-함수arrow-function의-호이스팅>화살표 함수(Arrow Function)의 호이스팅<a hidden class=anchor aria-hidden=true href=#화살표-함수arrow-function의-호이스팅>#</a></h4><p>화살표 함수도 함수 표현식과 마찬가지로 변수의 호이스팅 규칙을 따른다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// console.log(arrowFunction); // 변수 선언 방식에 따라 다름
</span></span></span><span class=line><span class=cl><span class=c1>// arrowFunction(); // 변수 선언 방식에 따라 다름
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>arrowFunction</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;I&#39;m an arrow function&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=클래스-호이스팅>클래스 호이스팅<a hidden class=anchor aria-hidden=true href=#클래스-호이스팅>#</a></h3><p>ES6에서 도입된 클래스도 호이스팅의 영향을 받지만, <code>let</code>과 <code>const</code>처럼 TDZ가 적용된다:</p><h4 id=클래스-선언문-호이스팅>클래스 선언문 호이스팅<a hidden class=anchor aria-hidden=true href=#클래스-선언문-호이스팅>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8>8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// const instance = new MyClass(); // ReferenceError: Cannot access &#39;MyClass&#39; before initialization
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>MyClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>property</span> <span class=o>=</span> <span class=s2>&#34;값&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>MyClass</span><span class=p>();</span> <span class=c1>// 정상 작동
</span></span></span></code></pre></td></tr></table></div></div><h4 id=클래스-표현식-호이스팅>클래스 표현식 호이스팅<a hidden class=anchor aria-hidden=true href=#클래스-표현식-호이스팅>#</a></h4><p>클래스 표현식도 변수 호이스팅 규칙을 따른다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// const instance = new MyClassExpression(); // ReferenceError: Cannot access &#39;MyClassExpression&#39; before initialization
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>MyClassExpression</span> <span class=o>=</span> <span class=kr>class</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>property</span> <span class=o>=</span> <span class=s2>&#34;값&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>instance</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>MyClassExpression</span><span class=p>();</span> <span class=c1>// 정상 작동
</span></span></span></code></pre></td></tr></table></div></div><h3 id=임포트-호이스팅-import-hoisting>임포트 호이스팅 (Import Hoisting)<a hidden class=anchor aria-hidden=true href=#임포트-호이스팅-import-hoisting>#</a></h3><p>ES6 모듈의 <code>import</code> 문도 호이스팅된다. 모듈 내에서는 <code>import</code> 선언이 코드 최상단으로 호이스팅된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// myFunction(); // 이 함수는 import된 함수로, 호이스팅된 import 덕분에 사용 가능
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// import와 export는 모듈의 최상단으로 호이스팅됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>myFunction</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./myModule.js&#39;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=블록-레벨-함수-호이스팅-block-level-function-hoisting>블록 레벨 함수 호이스팅 (Block-level Function Hoisting)<a hidden class=anchor aria-hidden=true href=#블록-레벨-함수-호이스팅-block-level-function-hoisting>#</a></h3><p>ES6 이전에는 함수 선언문이 블록 내에 있을 때의 동작이 브라우저마다 달랐다. ES6부터는 엄격 모드(&lsquo;use strict&rsquo;)에서 블록 레벨 함수가 블록 스코프 내로 호이스팅된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=s1>&#39;use strict&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 블록 내에서만 사용 가능
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>function</span> <span class=nx>blockFunc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;블록 내 함수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>blockFunc</span><span class=p>());</span> <span class=c1>// &#34;블록 내 함수&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// console.log(blockFunc()); // ReferenceError: blockFunc is not defined
</span></span></span></code></pre></td></tr></table></div></div><p>비엄격 모드에서는 블록 레벨 함수가 함수 스코프나 전역 스코프로 호이스팅되는데, 이 동작은 명확히 정의되어 있지 않아 권장되지 않는다.</p><h3 id=호이스팅의-실제-사례와-문제점>호이스팅의 실제 사례와 문제점<a hidden class=anchor aria-hidden=true href=#호이스팅의-실제-사례와-문제점>#</a></h3><p>호이스팅은 때때로 예상치 못한 동작과 버그를 유발할 수 있다. 몇 가지 실제 사례를 살펴보자:</p><h4 id=함수와-변수-이름-충돌>함수와 변수 이름 충돌<a hidden class=anchor aria-hidden=true href=#함수와-변수-이름-충돌>#</a></h4><p>같은 이름의 변수와 함수가 선언될 때 호이스팅이 어떻게 작동하는지 살펴보자:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6>6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7>7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>typeof</span> <span class=nx>myFunction</span><span class=p>);</span> <span class=c1>// &#34;function&#34; (함수 선언이 우선함)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>myFunction</span> <span class=o>=</span> <span class=s2>&#34;I am a string&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>myFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s2>&#34;I am a function&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>typeof</span> <span class=nx>myFunction</span><span class=p>);</span> <span class=c1>// &#34;string&#34; (변수 선언이 함수 선언을 덮어씀)
</span></span></span></code></pre></td></tr></table></div></div><p>이 경우 변수 선언이 함수 선언을 덮어써서, <code>myFunction</code>은 함수가 아닌 문자열이 된다.</p><h4 id=조건부-함수-선언>조건부 함수 선언<a hidden class=anchor aria-hidden=true href=#조건부-함수-선언>#</a></h4><p>조건부 함수 선언은 호이스팅에 예측하기 어려운 영향을 미친다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>conditionalFunc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;조건 A&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>conditionalFunc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;조건 B&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 결과는 브라우저 및 JavaScript 엔진에 따라 다를 수 있음
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>conditionalFunc</span><span class=p>());</span> <span class=c1>// 일반적으로 &#34;조건 A&#34;이지만 명확한 표준이 없음
</span></span></span></code></pre></td></tr></table></div></div><p>이러한 코드는 브라우저마다 다른 결과를 보일 수 있으며, 명확한 표준이 없어 피해야 한다.<br>대신 함수 표현식을 사용하는 것이 좋다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>conditionalFunc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>conditionalFunc</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;조건 A&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>conditionalFunc</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;조건 B&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=변수-가려짐variable-shadowing>변수 가려짐(Variable Shadowing)<a hidden class=anchor aria-hidden=true href=#변수-가려짐variable-shadowing>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6>6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7>7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8>8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>test</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span> <span class=c1>// undefined (지역 변수 x가 호이스팅됨)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>var</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span> <span class=c1>// 20
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드에서 함수 내부의 <code>var x</code>는 호이스팅되어, 전역 변수 <code>x</code>를 가리키는 것이 아니라 함수 스코프 내의 <code>undefined</code> 값을 출력한다.</p><h3 id=호이스팅의-내부-메커니즘>호이스팅의 내부 메커니즘<a hidden class=anchor aria-hidden=true href=#호이스팅의-내부-메커니즘>#</a></h3><p>JavaScript 엔진이 코드를 어떻게 실행하는지 이해하려면 실행 컨텍스트(Execution Context)와 렉시컬 환경(Lexical Environment)이라는 두 가지 개념을 이해해야 한다.<br>이 두 메커니즘은 JavaScript의 스코프, 클로저, 호이스팅과 같은 중요한 특성의 기반이 된다.</p><p>실행 컨텍스트의 생성 단계에서 환경 레코드에 변수와 함수 선언이 등록되기 때문에 변수와 함수 선언이 코드의 최상단으로 &ldquo;끌어올려진&rdquo; 것처럼 동작하도록 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6>6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span><span class=p>);</span> <span class=c1>// undefined (에러가 아님)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>sayHello</span><span class=p>();</span> <span class=c1>// &#34;Hello!&#34; (정상 작동)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>sayHello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hello!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드에서 <code>a</code>는 <code>undefined</code>로 출력되지만 에러가 발생하지 않는다. 이는 <code>var</code> 선언이 호이스팅되어 환경 레코드에 등록되고 <code>undefined</code>로 초기화되기 때문이다.<br>마찬가지로 <code>sayHello</code> 함수도 호이스팅되어 선언 전에 호출할 수 있습니다.</p><p><code>let</code>과 <code>const</code>의 경우는 다르다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>b</span><span class=p>);</span> <span class=c1>// ReferenceError: Cannot access &#39;b&#39; before initialization
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>let</code>과 <code>const</code>도 호이스팅되지만, 초기화되기 전에는 &ldquo;일시적 사각지대(Temporal Dead Zone)&ldquo;에 있어서 접근할 수 없다. 이는 변수가 렉시컬 환경에 등록되지만 아직 초기화되지 않았음을 의미한다.</p><h4 id=실행-컨텍스트execution-context>실행 컨텍스트(Execution Context)<a hidden class=anchor aria-hidden=true href=#실행-컨텍스트execution-context>#</a></h4><p>실행 컨텍스트는 JavaScript 코드가 평가되고 실행되는 환경을 추상화한 개념이다. 쉽게 말해, JavaScript 엔진이 코드를 실행하기 위해 필요한 모든 정보를 담고 있는 환경이라고 생각할 수 있다.</p><ul><li>코드를 실행하는 데 필요한 모든 정보를 담고 있는 객체이다.</li><li>스코프, 호이스팅, this, 함수, 클로저 등의 동작 원리를 포함한다.</li><li>콜 스택에 쌓이며, 가장 위에 있는 컨텍스트와 관련된 코드가 실행된다.</li><li>함수가 실행될 때마다 새로운 실행 컨텍스트가 생성된다.</li></ul><p>JavaScript 엔진은 코드를 실행하기 위해 다음과 같은 세 가지 유형의 실행 컨텍스트를 생성한다:</p><ol><li><strong>전역 실행 컨텍스트(Global Execution Context)</strong>: 코드가 처음 실행될 때 생성되는 기본 컨텍스트이다. 브라우저에서는 <code>window</code> 객체가, Node.js에서는 <code>global</code> 객체가 이에 해당한다.</li><li><strong>함수 실행 컨텍스트(Function Execution Context)</strong>: 함수가 호출될 때마다 해당 함수에 대한 새로운 실행 컨텍스트가 생성된다.</li><li><strong>Eval 실행 컨텍스트(Eval Execution Context)</strong>: <code>eval()</code> 함수 내에서 실행되는 코드에 대한 컨텍스트이다. 현대 JavaScript에서는 보안상의 이유로 잘 사용되지 않는다.</li></ol><h5 id=실행-컨텍스트의-구성-요소>실행 컨텍스트의 구성 요소<a hidden class=anchor aria-hidden=true href=#실행-컨텍스트의-구성-요소>#</a></h5><p>실행 컨텍스트는 다음과 같은 주요 구성 요소를 가진다:</p><ol><li><strong>렉시컬 환경(Lexical Environment)</strong>: 변수와 함수 선언을 저장하는 곳이다.</li><li><strong>변수 환경(Variable Environment)</strong>: ES6부터 도입된 개념으로, 기본적으로 렉시컬 환경과 같지만 <code>var</code> 선언만 저장한다.</li><li><strong>this 바인딩(This Binding)</strong>: 현재 컨텍스트에서 <code>this</code> 키워드가 참조하는 값을 결정한다.</li><li><strong>외부 환경 참조(Outer Environment Reference)</strong>: 외부 렉시컬 환경에 대한 참조이다.</li></ol><h5 id=실행-컨텍스트-스택execution-context-stack>실행 컨텍스트 스택(Execution Context Stack)<a hidden class=anchor aria-hidden=true href=#실행-컨텍스트-스택execution-context-stack>#</a></h5><p>JavaScript 엔진은 실행 컨텍스트 스택(호출 스택이라고도 함)을 사용하여 코드 실행 순서를 관리한다. 이 스택은 LIFO(Last In, First Out) 원칙에 따라 작동한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>first</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;첫 번째 함수&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>second</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>second</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;두 번째 함수&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>third</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>third</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;세 번째 함수&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>first</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드가 실행될 때 실행 컨텍스트 스택은 다음과 같이 변화한다:</p><ol><li>전역 실행 컨텍스트가 스택에 추가된다.</li><li><code>first()</code> 함수가 호출되면 <code>first</code> 실행 컨텍스트가 스택에 추가된다.</li><li><code>first</code> 내부에서 <code>second()</code>가 호출되면 <code>second</code> 실행 컨텍스트가 스택에 추가된다.</li><li><code>second</code> 내부에서 <code>third()</code>가 호출되면 <code>third</code> 실행 컨텍스트가 스택에 추가된다.</li><li><code>third</code> 함수가 완료되면 해당 컨텍스트가 스택에서 제거된다.</li><li><code>second</code> 함수가 완료되면 해당 컨텍스트가 스택에서 제거된다.</li><li><code>first</code> 함수가 완료되면 해당 컨텍스트가 스택에서 제거된다.</li><li>마지막으로 전역 실행 컨텍스트가 남는다(프로그램이 종료될 때까지).</li></ol><h5 id=실행-컨텍스트의-생성-과정>실행 컨텍스트의 생성 과정<a hidden class=anchor aria-hidden=true href=#실행-컨텍스트의-생성-과정>#</a></h5><p>실행 컨텍스트는 두 단계를 거쳐 생성된다:</p><ol><li><strong>생성 단계(Creation Phase)</strong>:<ul><li>렉시컬 환경 컴포넌트 생성</li><li>변수 환경 컴포넌트 생성</li><li><code>this</code> 바인딩 결정</li></ul></li><li><strong>실행 단계(Execution Phase)</strong>:<ul><li>코드를 한 줄씩 실행</li><li>변수에 값 할당</li></ul></li></ol><h4 id=렉시컬-환경lexical-environment>렉시컬 환경(Lexical Environment)<a hidden class=anchor aria-hidden=true href=#렉시컬-환경lexical-environment>#</a></h4><p>렉시컬 환경은 JavaScript 코드에서 변수와 함수가 어디에서 어떻게 접근 가능한지를 정의하는 구조이다.<br>이는 식별자(변수명, 함수명 등)와 해당 식별자가 참조하는 값 사이의 연관 관계를 저장한다.</p><h5 id=렉시컬-환경의-구성-요소>렉시컬 환경의 구성 요소<a hidden class=anchor aria-hidden=true href=#렉시컬-환경의-구성-요소>#</a></h5><p>렉시컬 환경은 다음 두 가지 주요 구성 요소로 이루어져 있다:</p><ol><li><p><strong>환경 레코드(Environment Record)</strong>: 현재 스코프 내의 변수, 함수 선언 등을 저장하는 저장소이다. 두 가지 유형이 있다:</p><ul><li><strong>선언적 환경 레코드(Declarative Environment Record)</strong>: 변수, 함수 선언, 매개변수 등을 저장한다.</li><li><strong>객체 환경 레코드(Object Environment Record)</strong>: 전역 코드의 경우 전역 객체(window, global)의 프로퍼티를 저장한다.</li></ul></li><li><p><strong>외부 렉시컬 환경 참조(Outer Lexical Environment Reference)</strong>: 외부 스코프(상위 스코프)의 렉시컬 환경을 참조한다. 이를 통해 스코프 체인이 형성된다.</p></li></ol><h5 id=렉시컬-스코핑lexical-scoping>렉시컬 스코핑(Lexical Scoping)<a hidden class=anchor aria-hidden=true href=#렉시컬-스코핑lexical-scoping>#</a></h5><p>JavaScript는 렉시컬 스코핑(정적 스코핑)을 사용한다. 이는 변수의 스코프가 코드를 작성하는 시점(즉, 어디에 작성되었는지)에 결정된다는 의미이다. 이것이 바로 &lsquo;렉시컬(lexical)&lsquo;이라는 용어가 사용되는 이유이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>globalVariable</span> <span class=o>=</span> <span class=s2>&#34;전역 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outerFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>outerVariable</span> <span class=o>=</span> <span class=s2>&#34;외부 함수 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>innerFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>innerVariable</span> <span class=o>=</span> <span class=s2>&#34;내부 함수 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>innerVariable</span><span class=p>);</span>    <span class=c1>// &#34;내부 함수 변수&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>outerVariable</span><span class=p>);</span>    <span class=c1>// &#34;외부 함수 변수&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>globalVariable</span><span class=p>);</span>   <span class=c1>// &#34;전역 변수&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nx>innerFunction</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>outerFunction</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>위 코드에서 <code>innerFunction</code>이 <code>outerVariable</code>과 <code>globalVariable</code>에 접근할 수 있는 이유는 렉시컬 스코핑 때문이다. <code>innerFunction</code>의 렉시컬 환경은 외부 렉시컬 환경 참조를 통해 <code>outerFunction</code>의 렉시컬 환경에 접근할 수 있고, 이어서 전역 렉시컬 환경에도 접근할 수 있다.</p><h4 id=실행-컨텍스트와-렉시컬-환경의-상호작용>실행 컨텍스트와 렉시컬 환경의 상호작용<a hidden class=anchor aria-hidden=true href=#실행-컨텍스트와-렉시컬-환경의-상호작용>#</a></h4><p>실행 컨텍스트와 렉시컬 환경이 어떻게 상호작용하는지 더 자세히 살펴보자.</p><h5 id=예제를-통한-이해>예제를 통한 이해<a hidden class=anchor aria-hidden=true href=#예제를-통한-이해>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>fn1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>function</span> <span class=nx>fn2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>c</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span> <span class=o>+</span> <span class=nx>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>fn2</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fn1</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><p>이 코드가 실행될 때 발생하는 일을 단계별로 살펴보면:</p><ol><li><p><strong>전역 실행 컨텍스트 생성</strong>:</p><ul><li>전역 렉시컬 환경 생성</li><li>환경 레코드에 변수 <code>a</code>와 함수 <code>fn1</code> 등록</li><li><code>a</code>에 10 할당</li></ul></li><li><p><strong><code>fn1</code> 호출</strong>:</p><ul><li><code>fn1</code>의 실행 컨텍스트 생성</li><li><code>fn1</code>의 렉시컬 환경 생성</li><li>환경 레코드에 변수 <code>b</code>와 함수 <code>fn2</code> 등록</li><li>외부 렉시컬 환경 참조는 전역 렉시컬 환경을 가리킴</li><li><code>b</code>에 20 할당</li></ul></li><li><p><strong><code>fn2</code> 호출</strong>:</p><ul><li><code>fn2</code>의 실행 컨텍스트 생성</li><li><code>fn2</code>의 렉시컬 환경 생성</li><li>환경 레코드에 변수 <code>c</code> 등록</li><li>외부 렉시컬 환경 참조는 <code>fn1</code>의 렉시컬 환경을 가리킴</li><li><code>c</code>에 30 할당</li></ul></li><li><p><strong><code>console.log(a + b + c)</code> 실행</strong>:</p><ul><li><code>c</code>는 현재 렉시컬 환경에서 찾음</li><li><code>b</code>는 외부 렉시컬 환경(fn1)에서 찾음</li><li><code>a</code>는 더 외부의 렉시컬 환경(전역)에서 찾음</li><li>60 출력 (10 + 20 + 30)</li></ul></li><li><p><strong><code>fn2</code> 실행 완료</strong>:</p><ul><li><code>fn2</code>의 실행 컨텍스트가 스택에서 제거됨</li></ul></li><li><p><strong><code>fn1</code> 실행 완료</strong>:</p><ul><li><code>fn1</code>의 실행 컨텍스트가 스택에서 제거됨</li></ul></li></ol><p>이 과정에서 볼 수 있듯이, 각 함수가 호출될 때마다 새로운 실행 컨텍스트와 렉시컬 환경이 생성된다. 그리고 변수를 찾을 때는 현재 렉시컬 환경에서 시작하여 외부 렉시컬 환경 참조를 따라 상위 환경을 차례로 탐색한다.</p><h4 id=클로저closure와-렉시컬-환경>클로저(Closure)와 렉시컬 환경<a hidden class=anchor aria-hidden=true href=#클로저closure와-렉시컬-환경>#</a></h4><p>클로저는 렉시컬 환경과 깊은 관련이 있다. 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>createCounter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>function</span> <span class=nx>increment</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter</span> <span class=o>=</span> <span class=nx>createCounter</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>());</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>());</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>());</span> <span class=c1>// 3
</span></span></span></code></pre></td></tr></table></div></div><p>이 예제에서 <code>increment</code> 함수는 <code>createCounter</code>의 렉시컬 환경에 있는 <code>count</code> 변수에 계속 접근할 수 있다. 이는 <code>increment</code> 함수가 생성될 때 외부 렉시컬 환경 참조를 통해 <code>createCounter</code>의 렉시컬 환경을 참조하기 때문이다. 이 참조는 <code>createCounter</code> 함수의 실행이 완료된 후에도 유지된다.</p><h4 id=블록-스코프와-렉시컬-환경>블록 스코프와 렉시컬 환경<a hidden class=anchor aria-hidden=true href=#블록-스코프와-렉시컬-환경>#</a></h4><p>ES6부터 도입된 <code>let</code>과 <code>const</code>는 블록 스코프를 가진다. 이는 중괄호(<code>{}</code>) 내에서 선언된 변수가 해당 블록 내에서만 유효하다는 의미이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5>5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6>6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>blockVar</span> <span class=o>=</span> <span class=s2>&#34;블록 내부&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>var</span> <span class=nx>functionVar</span> <span class=o>=</span> <span class=s2>&#34;함수 스코프&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>functionVar</span><span class=p>);</span> <span class=c1>// &#34;함수 스코프&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>blockVar</span><span class=p>);</span>    <span class=c1>// ReferenceError: blockVar is not defined
</span></span></span></code></pre></td></tr></table></div></div><p>JavaScript 엔진은 블록 스코프를 구현하기 위해 블록마다 별도의 렉시컬 환경을 생성한다.<br>블록이 실행될 때 새로운 렉시컬 환경이 생성되고, 블록이 종료되면 해당 환경은 참조가 없어져 가비지 컬렉션의 대상이 된다.</p><h4 id=this-바인딩과-실행-컨텍스트>This 바인딩과 실행 컨텍스트<a hidden class=anchor aria-hidden=true href=#this-바인딩과-실행-컨텍스트>#</a></h4><p><code>this</code> 키워드의 값은 함수가 어떻게 호출되는지에 따라 결정된다.<br>이는 실행 컨텍스트가 생성될 때 <code>this</code> 바인딩 컴포넌트에 저장된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1> 1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2> 2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3> 3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4> 4</a>
</span><span class=lnt id=hl-25-5><a class=lnlinks href=#hl-25-5> 5</a>
</span><span class=lnt id=hl-25-6><a class=lnlinks href=#hl-25-6> 6</a>
</span><span class=lnt id=hl-25-7><a class=lnlinks href=#hl-25-7> 7</a>
</span><span class=lnt id=hl-25-8><a class=lnlinks href=#hl-25-8> 8</a>
</span><span class=lnt id=hl-25-9><a class=lnlinks href=#hl-25-9> 9</a>
</span><span class=lnt id=hl-25-10><a class=lnlinks href=#hl-25-10>10</a>
</span><span class=lnt id=hl-25-11><a class=lnlinks href=#hl-25-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>person</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;홍길동&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nx>sayHello</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`안녕하세요, </span><span class=si>${</span><span class=k>this</span><span class=p>.</span><span class=nx>name</span><span class=si>}</span><span class=sb>입니다.`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>person</span><span class=p>.</span><span class=nx>sayHello</span><span class=p>();</span> <span class=c1>// &#34;안녕하세요, 홍길동입니다.&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>greet</span> <span class=o>=</span> <span class=nx>person</span><span class=p>.</span><span class=nx>sayHello</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>greet</span><span class=p>();</span> <span class=c1>// &#34;안녕하세요, undefined입니다.&#34; (this가 전역 객체를 가리킴)
</span></span></span></code></pre></td></tr></table></div></div><p>여기서 <code>person.sayHello()</code>를 호출할 때 <code>this</code>는 <code>person</code> 객체를 가리키지만, <code>greet()</code>를 호출할 때는 <code>this</code>가 전역 객체(브라우저에서는 <code>window</code>)를 가리킨다. 이는 함수를 어떻게 호출하는지에 따라 실행 컨텍스트의 <code>this</code> 바인딩이 다르게 설정되기 때문이다.</p><h4 id=함수의-종류에-따른-실행-컨텍스트와-렉시컬-환경의-차이>함수의 종류에 따른 실행 컨텍스트와 렉시컬 환경의 차이<a hidden class=anchor aria-hidden=true href=#함수의-종류에-따른-실행-컨텍스트와-렉시컬-환경의-차이>#</a></h4><p>JavaScript에는 여러 종류의 함수가 있으며, 각각 실행 컨텍스트와 렉시컬 환경에 영향을 미치는 방식이 다르다.</p><h5 id=일반-함수function-declaration--expression>일반 함수(Function Declaration & Expression)<a hidden class=anchor aria-hidden=true href=#일반-함수function-declaration--expression>#</a></h5><p>일반 함수는 자신만의 <code>this</code>, <code>arguments</code>, 그리고 새로운 실행 컨텍스트를 가진다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>regularFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=c1>// 호출 방식에 따라 달라짐
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=화살표-함수arrow-function>화살표 함수(Arrow Function)<a hidden class=anchor aria-hidden=true href=#화살표-함수arrow-function>#</a></h5><p>화살표 함수는 자신의 <code>this</code>와 <code>arguments</code>를 갖지 않으며, 상위 스코프의 것을 사용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2>2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>arrowFunction</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=k>this</span><span class=p>);</span> <span class=c1>// 항상 상위 스코프의 this를 사용
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>이는 화살표 함수가 생성될 때 렉시컬 환경의 외부 환경 참조를 통해 상위 스코프의 <code>this</code>를 캡처하기 때문이다.</p><h4 id=실행-컨텍스트와-렉시컬-환경의-응용>실행 컨텍스트와 렉시컬 환경의 응용<a hidden class=anchor aria-hidden=true href=#실행-컨텍스트와-렉시컬-환경의-응용>#</a></h4><p>이 개념들을 이해하면 JavaScript의 많은 고급 패턴과 기법을 더 잘 이해할 수 있다.</p><h5 id=모듈-패턴module-pattern>모듈 패턴(Module Pattern)<a hidden class=anchor aria-hidden=true href=#모듈-패턴module-pattern>#</a></h5><p>모듈 패턴은 클로저를 이용하여 private 변수와 메서드를 구현하는 방법.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1> 1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2> 2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3> 3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4> 4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5> 5</a>
</span><span class=lnt id=hl-28-6><a class=lnlinks href=#hl-28-6> 6</a>
</span><span class=lnt id=hl-28-7><a class=lnlinks href=#hl-28-7> 7</a>
</span><span class=lnt id=hl-28-8><a class=lnlinks href=#hl-28-8> 8</a>
</span><span class=lnt id=hl-28-9><a class=lnlinks href=#hl-28-9> 9</a>
</span><span class=lnt id=hl-28-10><a class=lnlinks href=#hl-28-10>10</a>
</span><span class=lnt id=hl-28-11><a class=lnlinks href=#hl-28-11>11</a>
</span><span class=lnt id=hl-28-12><a class=lnlinks href=#hl-28-12>12</a>
</span><span class=lnt id=hl-28-13><a class=lnlinks href=#hl-28-13>13</a>
</span><span class=lnt id=hl-28-14><a class=lnlinks href=#hl-28-14>14</a>
</span><span class=lnt id=hl-28-15><a class=lnlinks href=#hl-28-15>15</a>
</span><span class=lnt id=hl-28-16><a class=lnlinks href=#hl-28-16>16</a>
</span><span class=lnt id=hl-28-17><a class=lnlinks href=#hl-28-17>17</a>
</span><span class=lnt id=hl-28-18><a class=lnlinks href=#hl-28-18>18</a>
</span><span class=lnt id=hl-28-19><a class=lnlinks href=#hl-28-19>19</a>
</span><span class=lnt id=hl-28-20><a class=lnlinks href=#hl-28-20>20</a>
</span><span class=lnt id=hl-28-21><a class=lnlinks href=#hl-28-21>21</a>
</span><span class=lnt id=hl-28-22><a class=lnlinks href=#hl-28-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>counter</span> <span class=o>=</span> <span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// private 변수
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>increment</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>decrement</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>count</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nx>getValue</span><span class=o>:</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>})();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>());</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nx>increment</span><span class=p>());</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nx>getValue</span><span class=p>());</span>  <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>counter</span><span class=p>.</span><span class=nx>count</span><span class=p>);</span>       <span class=c1>// undefined (private 변수에 직접 접근 불가)
</span></span></span></code></pre></td></tr></table></div></div><p>이 패턴은 즉시 실행 함수 표현식(IIFE)의 렉시컬 환경에 <code>count</code> 변수를 캡슐화하여, 외부에서 직접 접근할 수 없게 한다.</p><h5 id=커링currying>커링(Currying)<a hidden class=anchor aria-hidden=true href=#커링currying>#</a></h5><p>커링은 여러 인자를 받는 함수를 인자 하나씩 받는 함수들의 체인으로 변환하는 기법.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1> 1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2> 2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3> 3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4> 4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5> 5</a>
</span><span class=lnt id=hl-29-6><a class=lnlinks href=#hl-29-6> 6</a>
</span><span class=lnt id=hl-29-7><a class=lnlinks href=#hl-29-7> 7</a>
</span><span class=lnt id=hl-29-8><a class=lnlinks href=#hl-29-8> 8</a>
</span><span class=lnt id=hl-29-9><a class=lnlinks href=#hl-29-9> 9</a>
</span><span class=lnt id=hl-29-10><a class=lnlinks href=#hl-29-10>10</a>
</span><span class=lnt id=hl-29-11><a class=lnlinks href=#hl-29-11>11</a>
</span><span class=lnt id=hl-29-12><a class=lnlinks href=#hl-29-12>12</a>
</span><span class=lnt id=hl-29-13><a class=lnlinks href=#hl-29-13>13</a>
</span><span class=lnt id=hl-29-14><a class=lnlinks href=#hl-29-14>14</a>
</span><span class=lnt id=hl-29-15><a class=lnlinks href=#hl-29-15>15</a>
</span><span class=lnt id=hl-29-16><a class=lnlinks href=#hl-29-16>16</a>
</span><span class=lnt id=hl-29-17><a class=lnlinks href=#hl-29-17>17</a>
</span><span class=lnt id=hl-29-18><a class=lnlinks href=#hl-29-18>18</a>
</span><span class=lnt id=hl-29-19><a class=lnlinks href=#hl-29-19>19</a>
</span><span class=lnt id=hl-29-20><a class=lnlinks href=#hl-29-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>curry</span><span class=p>(</span><span class=nx>fn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>function</span> <span class=nx>curried</span><span class=p>(...</span><span class=nx>args</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>args</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;=</span> <span class=nx>fn</span><span class=p>.</span><span class=nx>length</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>fn</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=kd>function</span><span class=p>(...</span><span class=nx>args2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>curried</span><span class=p>.</span><span class=nx>apply</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=nx>args</span><span class=p>.</span><span class=nx>concat</span><span class=p>(</span><span class=nx>args2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>      <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span> <span class=o>+</span> <span class=nx>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>curriedAdd</span> <span class=o>=</span> <span class=nx>curry</span><span class=p>(</span><span class=nx>add</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>curriedAdd</span><span class=p>(</span><span class=mi>1</span><span class=p>)(</span><span class=mi>2</span><span class=p>)(</span><span class=mi>3</span><span class=p>));</span> <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>curriedAdd</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)(</span><span class=mi>3</span><span class=p>));</span> <span class=c1>// 6
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>curriedAdd</span><span class=p>(</span><span class=mi>1</span><span class=p>)(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>));</span> <span class=c1>// 6
</span></span></span></code></pre></td></tr></table></div></div><p>이 패턴은, 각 단계에서 새로운 실행 컨텍스트와 렉시컬 환경이 생성되고, 클로저를 통해 이전 단계의 인자가 유지되는 방식으로 작동한다.</p><h3 id=실제-개발에서의-호이스팅-활용-및-주의사항>실제 개발에서의 호이스팅 활용 및 주의사항<a hidden class=anchor aria-hidden=true href=#실제-개발에서의-호이스팅-활용-및-주의사항>#</a></h3><h4 id=호이스팅을-활용한-코드-구성>호이스팅을 활용한 코드 구성<a hidden class=anchor aria-hidden=true href=#호이스팅을-활용한-코드-구성>#</a></h4><p>함수 호이스팅을 활용하면 코드의 가독성을 높일 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1> 1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2> 2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3> 3</a>
</span><span class=lnt id=hl-30-4><a class=lnlinks href=#hl-30-4> 4</a>
</span><span class=lnt id=hl-30-5><a class=lnlinks href=#hl-30-5> 5</a>
</span><span class=lnt id=hl-30-6><a class=lnlinks href=#hl-30-6> 6</a>
</span><span class=lnt id=hl-30-7><a class=lnlinks href=#hl-30-7> 7</a>
</span><span class=lnt id=hl-30-8><a class=lnlinks href=#hl-30-8> 8</a>
</span><span class=lnt id=hl-30-9><a class=lnlinks href=#hl-30-9> 9</a>
</span><span class=lnt id=hl-30-10><a class=lnlinks href=#hl-30-10>10</a>
</span><span class=lnt id=hl-30-11><a class=lnlinks href=#hl-30-11>11</a>
</span><span class=lnt id=hl-30-12><a class=lnlinks href=#hl-30-12>12</a>
</span><span class=lnt id=hl-30-13><a class=lnlinks href=#hl-30-13>13</a>
</span><span class=lnt id=hl-30-14><a class=lnlinks href=#hl-30-14>14</a>
</span><span class=lnt id=hl-30-15><a class=lnlinks href=#hl-30-15>15</a>
</span><span class=lnt id=hl-30-16><a class=lnlinks href=#hl-30-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 메인 함수 먼저 배치
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>helper1</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>helper2</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 보조 함수는 아래에 배치
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>helper1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;보조 함수 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>helper2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;보조 함수 2&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>main</span><span class=p>();</span> <span class=c1>// 정상 작동
</span></span></span></code></pre></td></tr></table></div></div><p>이렇게 하면 중요한 코드를 먼저 보여주고 세부 구현은 나중에 배치할 수 있다.</p><h4 id=호이스팅-관련-모범-사례>호이스팅 관련 모범 사례<a hidden class=anchor aria-hidden=true href=#호이스팅-관련-모범-사례>#</a></h4><p>호이스팅으로 인한 문제를 방지하기 위한 몇 가지 모범 사례:</p><h5 id=명확한-초기화-패턴-사용하기>명확한 초기화 패턴 사용하기<a hidden class=anchor aria-hidden=true href=#명확한-초기화-패턴-사용하기>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span><span class=lnt id=hl-31-4><a class=lnlinks href=#hl-31-4>4</a>
</span><span class=lnt id=hl-31-5><a class=lnlinks href=#hl-31-5>5</a>
</span><span class=lnt id=hl-31-6><a class=lnlinks href=#hl-31-6>6</a>
</span><span class=lnt id=hl-31-7><a class=lnlinks href=#hl-31-7>7</a>
</span><span class=lnt id=hl-31-8><a class=lnlinks href=#hl-31-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>config</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// 명시적으로 초기값 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>initConfig</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>config</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>theme</span><span class=o>:</span> <span class=s1>&#39;dark&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>language</span><span class=o>:</span> <span class=s1>&#39;ko&#39;</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=변수는-항상-스코프의-최상단에서-선언하기>변수는 항상 스코프의 최상단에서 선언하기<a hidden class=anchor aria-hidden=true href=#변수는-항상-스코프의-최상단에서-선언하기>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1>1</a>
</span><span class=lnt id=hl-32-2><a class=lnlinks href=#hl-32-2>2</a>
</span><span class=lnt id=hl-32-3><a class=lnlinks href=#hl-32-3>3</a>
</span><span class=lnt id=hl-32-4><a class=lnlinks href=#hl-32-4>4</a>
</span><span class=lnt id=hl-32-5><a class=lnlinks href=#hl-32-5>5</a>
</span><span class=lnt id=hl-32-6><a class=lnlinks href=#hl-32-6>6</a>
</span><span class=lnt id=hl-32-7><a class=lnlinks href=#hl-32-7>7</a>
</span><span class=lnt id=hl-32-8><a class=lnlinks href=#hl-32-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>goodExample</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 모든 변수를 함수 시작 부분에 선언
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kd>let</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>b</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1>// 이후 로직 작성
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=let과-const-사용하기>Let과 Const 사용하기<a hidden class=anchor aria-hidden=true href=#let과-const-사용하기>#</a></h5><p><code>var</code> 대신 <code>let</code>과 <code>const</code>를 사용하면 TDZ 덕분에 호이스팅 관련 버그를 더 일찍 발견할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1>1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2>2</a>
</span><span class=lnt id=hl-33-3><a class=lnlinks href=#hl-33-3>3</a>
</span><span class=lnt id=hl-33-4><a class=lnlinks href=#hl-33-4>4</a>
</span><span class=lnt id=hl-33-5><a class=lnlinks href=#hl-33-5>5</a>
</span><span class=lnt id=hl-33-6><a class=lnlinks href=#hl-33-6>6</a>
</span><span class=lnt id=hl-33-7><a class=lnlinks href=#hl-33-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>betterExample</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 이 줄에서 에러가 발생하므로 버그를 일찍 찾을 수 있음
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// console.log(x); // ReferenceError: x is not defined
</span></span></span><span class=line><span class=cl><span class=c1></span>  
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=함수-표현식-사용하기>함수 표현식 사용하기<a hidden class=anchor aria-hidden=true href=#함수-표현식-사용하기>#</a></h5><p>함수 선언문 대신 함수 표현식을 사용하면 호이스팅을 제한할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span><span class=lnt id=hl-34-3><a class=lnlinks href=#hl-34-3>3</a>
</span><span class=lnt id=hl-34-4><a class=lnlinks href=#hl-34-4>4</a>
</span><span class=lnt id=hl-34-5><a class=lnlinks href=#hl-34-5>5</a>
</span><span class=lnt id=hl-34-6><a class=lnlinks href=#hl-34-6>6</a>
</span><span class=lnt id=hl-34-7><a class=lnlinks href=#hl-34-7>7</a>
</span><span class=lnt id=hl-34-8><a class=lnlinks href=#hl-34-8>8</a>
</span><span class=lnt id=hl-34-9><a class=lnlinks href=#hl-34-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 함수 선언문 (전체가 호이스팅됨)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>function</span> <span class=nx>declaredFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s2>&#34;I am hoisted entirely&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 함수 표현식 (변수 호이스팅 규칙을 따름)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>expressionFunction</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=s2>&#34;I follow variable hoisting rules&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=다양한-유형의-호이스팅-비교>다양한 유형의 호이스팅 비교<a hidden class=anchor aria-hidden=true href=#다양한-유형의-호이스팅-비교>#</a></h3><table><thead><tr><th>선언 유형</th><th>호이스팅</th><th>초기화</th><th>TDZ</th><th>예시</th></tr></thead><tbody><tr><td>var 변수</td><td>예</td><td>undefined</td><td>아니오</td><td><code>var x = 5;</code></td></tr><tr><td>let 변수</td><td>예</td><td>아니오</td><td>예</td><td><code>let x = 5;</code></td></tr><tr><td>const 변수</td><td>예</td><td>아니오</td><td>예</td><td><code>const x = 5;</code></td></tr><tr><td>함수 선언문</td><td>예</td><td>전체 함수</td><td>아니오</td><td><code>function x() {}</code></td></tr><tr><td>함수 표현식(var)</td><td>변수만</td><td>undefined</td><td>아니오</td><td><code>var x = function() {};</code></td></tr><tr><td>함수 표현식(let/const)</td><td>변수만</td><td>아니오</td><td>예</td><td><code>const x = function() {};</code></td></tr><tr><td>클래스 선언</td><td>예</td><td>아니오</td><td>예</td><td><code>class X {}</code></td></tr><tr><td>클래스 표현식</td><td>변수만</td><td>아니오</td><td>예</td><td><code>const X = class {};</code></td></tr></tbody></table><h3 id=호이스팅의-주의사항>호이스팅의 주의사항<a hidden class=anchor aria-hidden=true href=#호이스팅의-주의사항>#</a></h3><ol><li>코드의 가독성과 유지보수성을 위해 변수와 함수는 사용하기 전에 선언하는 것이 좋다.</li><li>let과 const를 사용하여 예측 가능한 스코프 동작을 만들어내는 것이 권장된다.</li><li>함수 표현식보다는 함수 선언문을 사용하면 호이스팅으로 인한 혼란을 줄일 수 있다.</li></ol><h3 id=다양한-javascript-환경에서의-호이스팅>다양한 JavaScript 환경에서의 호이스팅<a hidden class=anchor aria-hidden=true href=#다양한-javascript-환경에서의-호이스팅>#</a></h3><h4 id=브라우저-환경에서의-호이스팅>브라우저 환경에서의 호이스팅<a hidden class=anchor aria-hidden=true href=#브라우저-환경에서의-호이스팅>#</a></h4><p>브라우저에서는 전역 스코프가 <code>window</code> 객체와 연결된다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span><span class=lnt id=hl-35-2><a class=lnlinks href=#hl-35-2>2</a>
</span><span class=lnt id=hl-35-3><a class=lnlinks href=#hl-35-3>3</a>
</span><span class=lnt id=hl-35-4><a class=lnlinks href=#hl-35-4>4</a>
</span><span class=lnt id=hl-35-5><a class=lnlinks href=#hl-35-5>5</a>
</span><span class=lnt id=hl-35-6><a class=lnlinks href=#hl-35-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>globalVar</span> <span class=o>=</span> <span class=s2>&#34;전역 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>globalVar</span><span class=p>);</span> <span class=c1>// &#34;전역 변수&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// let과 const는 window 객체에 추가되지 않음
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>globalLet</span> <span class=o>=</span> <span class=s2>&#34;전역 let 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>globalLet</span><span class=p>);</span> <span class=c1>// undefined
</span></span></span></code></pre></td></tr></table></div></div><h4 id=nodejs-환경에서의-호이스팅>Node.js 환경에서의 호이스팅<a hidden class=anchor aria-hidden=true href=#nodejs-환경에서의-호이스팅>#</a></h4><p>Node.js에서는 모듈 패턴으로 인해 전역 스코프가 다르게 동작한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1>1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2>2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3>3</a>
</span><span class=lnt id=hl-36-4><a class=lnlinks href=#hl-36-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>moduleVar</span> <span class=o>=</span> <span class=s2>&#34;모듈 변수&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>global</span><span class=p>.</span><span class=nx>moduleVar</span><span class=p>);</span> <span class=c1>// undefined (Node.js에서는 var가 global에 자동 추가되지 않음)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// CommonJS 모듈에서는 각 파일이 자체 스코프를 가짐
</span></span></span></code></pre></td></tr></table></div></div><h4 id=es-모듈에서의-호이스팅>ES 모듈에서의 호이스팅<a hidden class=anchor aria-hidden=true href=#es-모듈에서의-호이스팅>#</a></h4><p>ES 모듈은 자체적인 스코프를 가지며, <code>import</code>와 <code>export</code>가 호이스팅된다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1>1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2>2</a>
</span><span class=lnt id=hl-37-3><a class=lnlinks href=#hl-37-3>3</a>
</span><span class=lnt id=hl-37-4><a class=lnlinks href=#hl-37-4>4</a>
</span><span class=lnt id=hl-37-5><a class=lnlinks href=#hl-37-5>5</a>
</span><span class=lnt id=hl-37-6><a class=lnlinks href=#hl-37-6>6</a>
</span><span class=lnt id=hl-37-7><a class=lnlinks href=#hl-37-7>7</a>
</span><span class=lnt id=hl-37-8><a class=lnlinks href=#hl-37-8>8</a>
</span><span class=lnt id=hl-37-9><a class=lnlinks href=#hl-37-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 이 import는 실행 전에 처리됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>import</span> <span class=p>{</span> <span class=nx>helper</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;./helper.js&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 사용 전에 export됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>helper</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>export</span> <span class=kd>function</span> <span class=nx>myFunction</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/javascript/>Javascript</a></li><li><a href=https://buenhyden.github.io/tags/basic-syntax/>Basic-Syntax</a></li><li><a href=https://buenhyden.github.io/tags/variables/>Variables</a></li><li><a href=https://buenhyden.github.io/tags/hoisting/>Hoisting</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/scopes/global/><span class=title>« Prev</span><br><span>Global</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-concepts/variables/variable-declarations/><span class=title>Next »</span><br><span>Variable Declarations</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>