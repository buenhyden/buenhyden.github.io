<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Language Syntax | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Language-Syntax"><meta name=description content="프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/language-syntax/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/language-syntax/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/language-syntax/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Language Syntax"><meta property="og:description" content="프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-04T03:22:00+00:00"><meta property="article:modified_time" content="2024-10-04T03:22:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Language-Syntax"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Language Syntax"><meta name=twitter:description content="프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/"},{"@type":"ListItem","position":4,"name":"Language Syntax","item":"https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/language-syntax/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Language Syntax","name":"Language Syntax","description":"프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다.","keywords":["Programming-Languages","Fundamentals","Language-Syntax"],"articleBody":"Language Syntax 프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다.\n이 규칙은 변수 선언, 함수 호출, 제어 흐름 구조 등 모든 코드 구성 요소에 대해 일관된 형식과 조직 원리를 제공하며, 컴파일러나 인터프리터가 코드를 이해하고 실행할 수 있도록 한다.\n프로그래밍 언어의 구문은 단순한 규칙의 집합을 넘어서, 효율적이고 오류 없는 코드 작성을 위한 기반이며, 코드를 읽고 이해하기 쉽게 만드는 중요한 역할을 한다.\n각 언어의 구문을 정확하게 이해하고 준수하는 것은 프로그램의 안정적인 실행과 협업에 있어 필수적이다.\n종합하면, 올바른 구문 사용은 프로그램의 구조, 가독성, 그리고 실행 오류 방지에 결정적인 역할을 하며, 이를 제대로 이해하는 것은 프로그래밍 기초를 다지는 데 큰 도움이 된다.\n구문의 정의와 역할 프로그래밍 언어의 구문은 컴퓨터와 소통할 수 있도록 텍스트 또는 기호의 올바른 배열을 정의한다. 구문 규칙을 따르지 않으면 컴파일러나 인터프리터가 코드를 해석하지 못하여 실행 오류가 발생한다. 자연어의 문법과 유사하게, 올바른 구문은 코드의 가독성을 높이고 유지보수를 쉽게 하며, 협업 환경에서 통일성을 제공한다. 구문의 기능 및 중요성 프로그램 구조 정의: 구문은 프로그램의 전체적인 구조를 조직화하여, 코드가 명확하고 체계적으로 작성되도록 돕는다. 정확성: 올바른 구문은 프로그램이 의도한 대로 동작하게 한다. 가독성: 일관된 구문은 코드의 가독성을 높여 유지보수를 용이하게 한다. 코드 검증: 컴파일러나 인터프리터가 구문을 통해 코드의 올바름을 판단하며, 구문 오류가 발견되면 실행되지 않는다. 실행 가능성: 구문 오류가 있으면 프로그램이 컴파일되거나 실행되지 않는다. 커뮤니케이션 도구: 프로그래머 간의 협업에서 코드의 의미와 동작 방식을 명확히 전달하는 역할을 한다. 구문의 구성 요소 구문은 여러 계층으로 나뉘어 체계적으로 정의된다:\n어휘 수준: 문자들이 어떤 식으로 토큰(token)으로 구성되는지를 결정하며, 키워드, 식별자, 연산자, 구분자, 리터럴 등이 포함된다. 문법 수준: 토큰들이 어떻게 결합되어 문장이나 표현식을 이루는지 결정하며, BNF(Backus-Naur Form)나 EBNF 같은 형식 문법 표기법이 사용된다. 문맥 수준: 변수나 객체가 무엇을 참조하는지, 타입이 올바른지 등 코드의 의미와 관련된 부분을 다룬다. 어휘 수준 프로그래밍 언어의 구문은 여러 요소로 구성된다:\n키워드: 언어에서 특별한 의미를 가진 예약어(예: if, else, for). 식별자: 변수, 함수, 클래스 등의 이름을 지정하는 데 사용된다. 연산자: 수학적 또는 논리적 연산을 수행합니다 (예: +, -, *, /). 구분자: 코드의 다른 부분을 구분한다 (예: 세미콜론, 괄호). 리터럴: 고정된 값을 나타낸다 (예: 숫자, 문자열). 문법 수준 프로그래밍 문법 수준에서 언어의 구조를 기술하기 위한 여러 표기법들이 존재하며, 각 표기법은 표현력과 사용 목적에 따라 서로 다른 특성을 가진다.\n각 표기법은 표현력, 가독성, 사용 목적 면에서 차별화되며, 프로그래밍 언어 및 형식 언어의 구문을 명확히 기술하는 데 기여한다.\nBNF와 EBNF는 기본적인 컨텍스트 자유 문법을 표현하는 반면, ABNF는 네트워크 프로토콜 등 표준 문법에 특화되어 있고, Wirth Syntax Notation은 명시적인 반복 및 선택적 요소 표기로 간결성을 제공한다.\nVan Wijngaarden 문법은 문맥 의존적 조건을 표현하는 데 유용하며, DCG는 논리 프로그래밍 환경에서 직접 파싱 가능한 문법 기술 방식을 제시한다.\n마지막으로 MBNF는 이러한 표기법들을 기반으로 더 확장되고 응용된 형태로, 문서화나 사양서에서 자주 채택되는 방식이다.\n각 표기법은 특정 요구 사항과 구현 환경에 맞게 채택되며, 이들의 이해는 언어 설계, 컴파일러 구현 및 다양한 형식 언어의 개발에 있어 중요한 역할을 한다.\nBNF (Backus–Naur Form) 정의 및 기본 구조\nBNF는 컨텍스트 자유 문법을 기술하기 위한 메타문법으로, 언어의 구문을 비단말 기호(예: )와 단말 기호, 그리고 이들을 조합하는 생성 규칙으로 표현한다.\n예를 들어, 산술식을 다음과 같이 정의할 수 있다.\n1 2 3 ::= | \"+\" ::= | \"*\" ::= | \"(\" \")\" 이와 같이 BNF는 각 비단말 기호가 어떤 식으로 다른 기호들로 대체될 수 있는지를 명시하여 문법 전체를 기술한다.\nEBNF (Extended Backus–Naur Form) 확장된 표현력\nEBNF는 BNF에 추가 메타 기호를 도입하여 선택, 옵션, 반복 등을 보다 간결하게 표현할 수 있다.\n반복: 중괄호 {... }를 사용하여 0번 이상 반복됨을 나타낸다. 선택적 요소: 대괄호 [...]를 사용하여 해당 구문이 있을 수도, 없을 수도 있음을 나타낸다.\n예를 들어 산술 표현식을 EBNF로 정의하면 다음과 같다. 1 2 3 4 5 expression = term { (\"+\" | \"-\") term } ; term = factor { (\"*\" | \"/\") factor } ; factor = number | \"(\" expression \")\" ; number = digit { digit } ; digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ; EBNF는 이러한 확장 기능 덕분에 큰 문법도 보다 읽기 쉽고 간결하게 표현할 수 있다.\nABNF (Augmented Backus–Naur Form) 프로토콜 및 표준 문법에의 활용\nABNF는 BNF의 변형으로, 주로 IETF RFC(예: RFC 5234)에서 프로토콜이나 형식적 언어의 구문을 정의할 때 사용된다. 규칙 이름은 대소문자를 구분하지 않고, 하이픈도 허용된다. 각 규칙은 name = elements CRLF와 같이 작성되며, 연속 줄에 대한 처리 규칙이 있다.\nABNF는 명확하고 엄격한 규칙 서술 방식으로 네트워크 프로토콜, 데이터 포맷 등을 정의하는 데 적합하다. Wirth Syntax Notation (WSN) Niklaus Wirth가 제안한 대안 표기법\nWSN은 BNF의 단점을 보완하고자 1977년에 제안되었으며, 반복과 선택적 요소를 보다 명시적으로 표현할 수 있도록 설계되었다.\n반복: 중괄호 {... }를 사용하여 0번 이상 반복을 나타낸다. (예: { a }는 빈 문자열부터 “a”, “aa”,…까지 가능한 패턴을 의미) 선택적 요소: 대괄호 [...]를 사용하여 해당 요소의 존재가 선택적임을 표현한다. 그룹화: 소괄호 (...)를 사용하여 여러 요소를 하나의 그룹으로 묶는다.\n예를 들어, WSN으로 문법을 정의하면 다음과 같이 나타낼 수 있다. 1 2 3 4 5 SYNTAX = { PRODUCTION }. PRODUCTION = IDENTIFIER \"=\" EXPRESSION \".\". EXPRESSION = TERM { \"|\" TERM }. TERM = FACTOR { FACTOR }. FACTOR = IDENTIFIER | LITERAL | \"[\" EXPRESSION \"]\" | \"(\" EXPRESSION \")\" | \"{\" EXPRESSION \"}\". WSN은 이러한 명시적 기호들 덕분에 문법 규칙이 직관적이고 간결하게 나타나도록 돕는다.\nVan Wijngaarden 문법 문맥 의존적 규칙 표현\nVan Wijngaarden 문법은 단순한 컨텍스트 자유 문법으로 표현하기 어려운 문맥 의존적 규칙을 기술하기 위해 고안되었다. 두 단계 체계: 첫 단계에서는 하이퍼문법(hypergrammar)을, 두 번째 단계에서는 메타문법(metagrammar)을 사용하여 문법 규칙을 완성한다. 이를 통해 변수의 일관성, 수 일치와 같은 복잡한 조건들을 자연스럽게 표현할 수 있다.\nVan Wijngaarden 문법은 ALGOL 68의 정의에 사용되었으며, 그 표현력이 매우 뛰어나지만 구현과 파서 작성에 복잡성을 동반한다. Definite Clause Grammar (DCG) 논리 프로그래밍 기반 문법\nDCG는 주로 Prolog에서 사용되며, 문법 규칙을 논리 단정(clause) 형식으로 기술한다.\nProlog의 --\u003e 연산자를 사용하여 문법 규칙을 정의하며, 자연어 처리나 형식 언어의 파싱에 유용하게 활용된다.\n예를 들어, 간단한 문장을 다음과 같이 기술할 수 있다. 1 2 3 4 5 6 7 8 9 sentence --\u003e noun_phrase, verb_phrase. noun_phrase --\u003e det, noun. verb_phrase --\u003e verb, noun_phrase. det --\u003e [the]. det --\u003e [a]. noun --\u003e [cat]. noun --\u003e [fish]. verb --\u003e [eats]. DCG는 이러한 방식으로 문법 규칙을 기술하면, Prolog의 증명 엔진을 통해 직접 파싱할 수 있어 매우 강력한 도구로 평가된다.\nMBNF (Meta/Modified Backus–Naur Form) BNF의 변형 및 확장\nMBNF는 BNF의 변형으로, 일부 표기법에서는 “Meta-BNF” 또는 “Modified BNF\"라 불리며, 기존 BNF에 비해 더 간결하거나 확장된 표현 방식을 제공하기 위해 고안되었다. 특징: 추가 메타 기호나 서술 방식이 도입되어, 선택이나 반복, 그룹화 등의 표현을 보다 자연스럽게 기술할 수 있다. MBNF는 때때로 문법 내에서 주석이나 특정 조건, 혹은 문맥 정보를 포함하는 등 문서화가 강화된 형태로 사용된다. 사용 예시:\n언어 사양서나 표준 문서에서 MBNF 형식을 채택하는 경우, 생산 규칙을 단순화시키고, 복잡한 구문을 보다 읽기 쉽도록 설명하는 데 도움이 된다. MBNF가 구체적으로 어떻게 표현되는지는 사용 환경에 따라 다르지만, 기본적인 아이디어는 BNF와 유사하면서도 추가적인 문법적 편의성을 제공하는 것이다. 람다 계산법(Lambda Calculus) 문법\nMBNF를 사용해 람다 계산법의 문법을 다음과 같이 정의할 수 있다.\n여기서\nx는 변수, **(λ x. e)**는 람다 추상화, **(e₁ @ e₂)**는 함수 적용을 나타낸다. 1 e = x ∪ (λ x . e) ∪ (e @ e) 이 정의에서\n등호(=)는 “정의된다\"를 의미하고, 합집합 기호(∪)는 여러 대안을 나열하여 _e_가 변수 _x_이거나, 람다 추상화, 또는 두 표현식의 함수 적용일 수 있음을 나타낸다. 산술 표현식 문법\n산술식을 MBNF 스타일로 기술하는 예제는 아래와 같이 작성할 수 있다.\n여기서\nE는 전체 표현식(expression), T는 항(term), F는 인수(factor), n은 숫자(terminal symbol)를 나타낸다. 1 2 3 E = T ∪ (E + T) ∪ (E - T) T = F ∪ (T × F) ∪ (T ÷ F) F = n ∪ (E) 이 문법에서는\n등호(=)를 사용해 각 비터미널 기호의 정의를 명시하고, 합집합 기호(∪)를 사용해 해당 항이 여러 가지 가능성을 가진다는 점(예를 들어, _E_가 단순 term일 수도 있고, term 사이에 덧셈이나 뺄셈이 추가될 수도 있음을) 나타낸다. 구문 분석 과정 언어의 구문은 컴파일 단계에서 여러 단계를 거쳐 분석되며, 일반적으로 다음 과정이 포함된다:\n어휘 분석: 소스 코드를 문자 단위로 읽어 토큰으로 분리한다. 구문 분석: 토큰들의 계층적 구조(구문 트리 또는 AST)를 생성하여 코드가 문법 규칙에 맞는지 확인한다. 의미 분석: 생성된 구문 구조에 의미를 부여하여, 코드가 실제로 올바른 작업을 수행하는지 검증한다. 다양한 언어에서의 구문 예시 각 프로그래밍 언어는 고유의 구문 규칙을 가지며, 이는 서로 다른 스타일과 특징을 보인다:\nJavaScript: 변수 선언 시 let이나 const를 사용하며, 함수 호출과 끝에 세미콜론을 추가한다.\n1 2 let message = \"Hello, World!\"; console.log(message); 이 예시는 JavaScript의 기본 구문 규칙을 보여준다.\nC 언어: 모든 명령문은 세미콜론(;)으로 끝나며, main() 함수로 시작하여 중괄호 {}로 코드 블록을 감싼다.\n1 2 3 4 5 #include int main() { printf(\"My first line of code\"); return 0; } C 언어의 구문은 프로그램 시작과 종료, 출력 함수의 사용을 엄격하게 규정한다.\nLisp: 괄호를 이용해 모든 표현식을 감싸며, 리스트 기반의 구문 구조를 가진다.\n고급 주제 및 최신 동향 형식 문법과 파서 생성기: BNF 및 EBNF와 같은 표기법을 이용해 언어의 구문을 명세하며, yacc, ANTLR과 같은 도구로 파서를 자동 생성할 수 있다. 정적 분석 도구의 활용: ESLint, Prettier, Clang AST 등의 도구는 구문 오류를 미리 발견하고 코드 스타일을 개선하는 데 도움을 준다. DSL과 패턴 매칭: 도메인 특화 언어(DSL)나 최신 언어의 패턴 매칭 구문은 전통적인 구문 규칙을 확장하여 더 직관적인 프로그래밍 방식을 지원한다. 참고 및 출처 ","wordCount":"1476","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-04T03:22:00Z","dateModified":"2024-10-04T03:22:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/language-syntax/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/>Fundamentals of Programming Languages</a></div><h1 class="post-title entry-hint-parent">Language Syntax</h1><div class=post-description>프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다.</div><div class=post-meta><span title='2024-10-04 03:22:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Programming%20Fundamentals/Language-Syntax.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#language-syntax>Language Syntax</a><ul><li><a href=#구문의-정의와-역할>구문의 정의와 역할</a></li><li><a href=#구문의-기능-및-중요성>구문의 기능 및 중요성</a></li><li><a href=#구문의-구성-요소>구문의 구성 요소</a></li><li><a href=#구문-분석-과정>구문 분석 과정</a></li><li><a href=#다양한-언어에서의-구문-예시>다양한 언어에서의 구문 예시</a></li></ul></li><li><a href=#고급-주제-및-최신-동향>고급 주제 및 최신 동향</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=language-syntax>Language Syntax<a hidden class=anchor aria-hidden=true href=#language-syntax>#</a></h2><p>프로그래밍 언어의 구문(Language Syntax)은 코드의 구조와 형식을 결정하는 규칙 집합으로, 코드가 올바르게 실행되기 위한 기초 역할을 한다.<br>이 규칙은 변수 선언, 함수 호출, 제어 흐름 구조 등 모든 코드 구성 요소에 대해 일관된 형식과 조직 원리를 제공하며, 컴파일러나 인터프리터가 코드를 이해하고 실행할 수 있도록 한다.</p><p>프로그래밍 언어의 구문은 단순한 규칙의 집합을 넘어서, 효율적이고 오류 없는 코드 작성을 위한 기반이며, 코드를 읽고 이해하기 쉽게 만드는 중요한 역할을 한다.<br>각 언어의 구문을 정확하게 이해하고 준수하는 것은 프로그램의 안정적인 실행과 협업에 있어 필수적이다.</p><p>종합하면, 올바른 구문 사용은 프로그램의 구조, 가독성, 그리고 실행 오류 방지에 결정적인 역할을 하며, 이를 제대로 이해하는 것은 프로그래밍 기초를 다지는 데 큰 도움이 된다.</p><h3 id=구문의-정의와-역할>구문의 정의와 역할<a hidden class=anchor aria-hidden=true href=#구문의-정의와-역할>#</a></h3><ul><li>프로그래밍 언어의 구문은 컴퓨터와 소통할 수 있도록 텍스트 또는 기호의 올바른 배열을 정의한다.</li><li>구문 규칙을 따르지 않으면 컴파일러나 인터프리터가 코드를 해석하지 못하여 실행 오류가 발생한다.</li><li>자연어의 문법과 유사하게, 올바른 구문은 코드의 가독성을 높이고 유지보수를 쉽게 하며, 협업 환경에서 통일성을 제공한다.</li></ul><h3 id=구문의-기능-및-중요성>구문의 기능 및 중요성<a hidden class=anchor aria-hidden=true href=#구문의-기능-및-중요성>#</a></h3><ul><li><strong>프로그램 구조 정의</strong>: 구문은 프로그램의 전체적인 구조를 조직화하여, 코드가 명확하고 체계적으로 작성되도록 돕는다.<ul><li><strong>정확성</strong>: 올바른 구문은 프로그램이 의도한 대로 동작하게 한다.</li><li><strong>가독성</strong>: 일관된 구문은 코드의 가독성을 높여 유지보수를 용이하게 한다.</li></ul></li><li><strong>코드 검증</strong>: 컴파일러나 인터프리터가 구문을 통해 코드의 올바름을 판단하며, 구문 오류가 발견되면 실행되지 않는다.<ul><li><strong>실행 가능성</strong>: 구문 오류가 있으면 프로그램이 컴파일되거나 실행되지 않는다.</li></ul></li><li><strong>커뮤니케이션 도구</strong>: 프로그래머 간의 협업에서 코드의 의미와 동작 방식을 명확히 전달하는 역할을 한다.</li></ul><h3 id=구문의-구성-요소>구문의 구성 요소<a hidden class=anchor aria-hidden=true href=#구문의-구성-요소>#</a></h3><p>구문은 여러 계층으로 나뉘어 체계적으로 정의된다:</p><ul><li><strong>어휘 수준</strong>: 문자들이 어떤 식으로 토큰(token)으로 구성되는지를 결정하며, 키워드, 식별자, 연산자, 구분자, 리터럴 등이 포함된다.</li><li><strong>문법 수준</strong>: 토큰들이 어떻게 결합되어 문장이나 표현식을 이루는지 결정하며, BNF(Backus-Naur Form)나 EBNF 같은 형식 문법 표기법이 사용된다.</li><li><strong>문맥 수준</strong>: 변수나 객체가 무엇을 참조하는지, 타입이 올바른지 등 코드의 의미와 관련된 부분을 다룬다.</li></ul><h4 id=어휘-수준>어휘 수준<a hidden class=anchor aria-hidden=true href=#어휘-수준>#</a></h4><p>프로그래밍 언어의 구문은 여러 요소로 구성된다:</p><ol><li><strong>키워드</strong>: 언어에서 특별한 의미를 가진 예약어(예: if, else, for).</li><li><strong>식별자</strong>: 변수, 함수, 클래스 등의 이름을 지정하는 데 사용된다.</li><li><strong>연산자</strong>: 수학적 또는 논리적 연산을 수행합니다 (예: +, -, *, /).</li><li><strong>구분자</strong>: 코드의 다른 부분을 구분한다 (예: 세미콜론, 괄호).</li><li><strong>리터럴</strong>: 고정된 값을 나타낸다 (예: 숫자, 문자열).</li></ol><h4 id=문법-수준>문법 수준<a hidden class=anchor aria-hidden=true href=#문법-수준>#</a></h4><p>프로그래밍 문법 수준에서 언어의 구조를 기술하기 위한 여러 표기법들이 존재하며, 각 표기법은 표현력과 사용 목적에 따라 서로 다른 특성을 가진다.</p><p>각 표기법은 표현력, 가독성, 사용 목적 면에서 차별화되며, 프로그래밍 언어 및 형식 언어의 구문을 명확히 기술하는 데 기여한다.<br>BNF와 EBNF는 기본적인 컨텍스트 자유 문법을 표현하는 반면, ABNF는 네트워크 프로토콜 등 표준 문법에 특화되어 있고, Wirth Syntax Notation은 명시적인 반복 및 선택적 요소 표기로 간결성을 제공한다.<br>Van Wijngaarden 문법은 문맥 의존적 조건을 표현하는 데 유용하며, DCG는 논리 프로그래밍 환경에서 직접 파싱 가능한 문법 기술 방식을 제시한다.<br>마지막으로 MBNF는 이러한 표기법들을 기반으로 더 확장되고 응용된 형태로, 문서화나 사양서에서 자주 채택되는 방식이다.</p><p>각 표기법은 특정 요구 사항과 구현 환경에 맞게 채택되며, 이들의 이해는 언어 설계, 컴파일러 구현 및 다양한 형식 언어의 개발에 있어 중요한 역할을 한다.</p><h5 id=bnf-backusnaur-form>BNF (Backus–Naur Form)<a hidden class=anchor aria-hidden=true href=#bnf-backusnaur-form>#</a></h5><ul><li><p>정의 및 기본 구조<br>BNF는 컨텍스트 자유 문법을 기술하기 위한 메타문법으로, 언어의 구문을 비단말 기호(예: <code>&lt;expression></code>)와 단말 기호, 그리고 이들을 조합하는 생성 규칙으로 표현한다.<br>예를 들어, 산술식을 다음과 같이 정의할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>&lt;expression&gt; ::= &lt;term&gt; | &lt;expression&gt; &#34;+&#34; &lt;term&gt;
</span></span><span class=line><span class=cl>&lt;term&gt;       ::= &lt;factor&gt; | &lt;term&gt; &#34;*&#34; &lt;factor&gt;
</span></span><span class=line><span class=cl>&lt;factor&gt;     ::= &lt;number&gt; | &#34;(&#34; &lt;expression&gt; &#34;)&#34;
</span></span></code></pre></td></tr></table></div></div><p>이와 같이 BNF는 각 비단말 기호가 어떤 식으로 다른 기호들로 대체될 수 있는지를 명시하여 문법 전체를 기술한다.</p></li></ul><h5 id=ebnf-extended-backusnaur-form>EBNF (Extended Backus–Naur Form)<a hidden class=anchor aria-hidden=true href=#ebnf-extended-backusnaur-form>#</a></h5><ul><li><p>확장된 표현력<br>EBNF는 BNF에 추가 메타 기호를 도입하여 선택, 옵션, 반복 등을 보다 간결하게 표현할 수 있다.</p><ul><li>반복: 중괄호 <code>{... }</code>를 사용하여 0번 이상 반복됨을 나타낸다.</li><li>선택적 요소: 대괄호 <code>[...]</code>를 사용하여 해당 구문이 있을 수도, 없을 수도 있음을 나타낸다.<br>예를 들어 산술 표현식을 EBNF로 정의하면 다음과 같다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>expression = term { (&#34;+&#34; | &#34;-&#34;) term } ;
</span></span><span class=line><span class=cl>term       = factor { (&#34;*&#34; | &#34;/&#34;) factor } ;
</span></span><span class=line><span class=cl>factor     = number | &#34;(&#34; expression &#34;)&#34; ;
</span></span><span class=line><span class=cl>number     = digit { digit } ;
</span></span><span class=line><span class=cl>digit      = &#34;0&#34; | &#34;1&#34; | &#34;2&#34; | &#34;3&#34; | &#34;4&#34; | &#34;5&#34; | &#34;6&#34; | &#34;7&#34; | &#34;8&#34; | &#34;9&#34; ;
</span></span></code></pre></td></tr></table></div></div><p>EBNF는 이러한 확장 기능 덕분에 큰 문법도 보다 읽기 쉽고 간결하게 표현할 수 있다.</p></li></ul><h5 id=abnf-augmented-backusnaur-form>ABNF (Augmented Backus–Naur Form)<a hidden class=anchor aria-hidden=true href=#abnf-augmented-backusnaur-form>#</a></h5><ul><li>프로토콜 및 표준 문법에의 활용<br>ABNF는 BNF의 변형으로, 주로 IETF RFC(예: RFC 5234)에서 <strong>프로토콜이나 형식적 언어의 구문을 정의</strong>할 때 사용된다.<ul><li>규칙 이름은 대소문자를 구분하지 않고, 하이픈도 허용된다.</li><li>각 규칙은 <code>name = elements CRLF</code>와 같이 작성되며, 연속 줄에 대한 처리 규칙이 있다.<br>ABNF는 명확하고 엄격한 규칙 서술 방식으로 네트워크 프로토콜, 데이터 포맷 등을 정의하는 데 적합하다.</li></ul></li></ul><h5 id=wirth-syntax-notation-wsn>Wirth Syntax Notation (WSN)<a hidden class=anchor aria-hidden=true href=#wirth-syntax-notation-wsn>#</a></h5><ul><li><p>Niklaus Wirth가 제안한 대안 표기법<br>WSN은 BNF의 단점을 보완하고자 1977년에 제안되었으며, 반복과 선택적 요소를 보다 명시적으로 표현할 수 있도록 설계되었다.</p><ul><li>반복: 중괄호 <code>{... }</code>를 사용하여 0번 이상 반복을 나타낸다. (예: <code>{ a }</code>는 빈 문자열부터 &ldquo;a&rdquo;, &ldquo;aa&rdquo;,&mldr;까지 가능한 패턴을 의미)</li><li>선택적 요소: 대괄호 <code>[...]</code>를 사용하여 해당 요소의 존재가 선택적임을 표현한다.</li><li>그룹화: 소괄호 <code>(...)</code>를 사용하여 여러 요소를 하나의 그룹으로 묶는다.<br>예를 들어, WSN으로 문법을 정의하면 다음과 같이 나타낼 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SYNTAX     = { PRODUCTION }.
</span></span><span class=line><span class=cl>PRODUCTION = IDENTIFIER &#34;=&#34; EXPRESSION &#34;.&#34;.
</span></span><span class=line><span class=cl>EXPRESSION = TERM { &#34;|&#34; TERM }.
</span></span><span class=line><span class=cl>TERM       = FACTOR { FACTOR }.
</span></span><span class=line><span class=cl>FACTOR     = IDENTIFIER | LITERAL | &#34;[&#34; EXPRESSION &#34;]&#34; | &#34;(&#34; EXPRESSION &#34;)&#34; | &#34;{&#34; EXPRESSION &#34;}&#34;.
</span></span></code></pre></td></tr></table></div></div><p>WSN은 이러한 명시적 기호들 덕분에 문법 규칙이 직관적이고 간결하게 나타나도록 돕는다.</p></li></ul><h5 id=van-wijngaarden-문법>Van Wijngaarden 문법<a hidden class=anchor aria-hidden=true href=#van-wijngaarden-문법>#</a></h5><ul><li>문맥 의존적 규칙 표현<br>Van Wijngaarden 문법은 단순한 컨텍스트 자유 문법으로 표현하기 어려운 문맥 의존적 규칙을 기술하기 위해 고안되었다.<ul><li>두 단계 체계: 첫 단계에서는 하이퍼문법(hypergrammar)을, 두 번째 단계에서는 메타문법(metagrammar)을 사용하여 문법 규칙을 완성한다.</li><li>이를 통해 변수의 일관성, 수 일치와 같은 복잡한 조건들을 자연스럽게 표현할 수 있다.<br>Van Wijngaarden 문법은 ALGOL 68의 정의에 사용되었으며, 그 표현력이 매우 뛰어나지만 구현과 파서 작성에 복잡성을 동반한다.</li></ul></li></ul><h5 id=definite-clause-grammar-dcg>Definite Clause Grammar (DCG)<a hidden class=anchor aria-hidden=true href=#definite-clause-grammar-dcg>#</a></h5><ul><li><p>논리 프로그래밍 기반 문법<br>DCG는 주로 Prolog에서 사용되며, 문법 규칙을 논리 단정(clause) 형식으로 기술한다.</p><ul><li>Prolog의 <code>--></code> 연산자를 사용하여 문법 규칙을 정의하며, 자연어 처리나 형식 언어의 파싱에 유용하게 활용된다.<br>예를 들어, 간단한 문장을 다음과 같이 기술할 수 있다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-prolog data-lang=prolog><span class=line><span class=cl><span class=nf>sentence</span> <span class=o>--&gt;</span> <span class=s>noun_phrase</span><span class=p>,</span> <span class=s>verb_phrase</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=nf>noun_phrase</span> <span class=o>--&gt;</span> <span class=s>det</span><span class=p>,</span> <span class=s>noun</span><span class=p>.</span>
</span></span><span class=line><span class=cl><span class=nf>verb_phrase</span> <span class=o>--&gt;</span> <span class=s>verb</span><span class=p>,</span> <span class=s>noun_phrase</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>det</span> <span class=o>--&gt;</span> <span class=p>[</span><span class=s>the</span><span class=p>].</span>
</span></span><span class=line><span class=cl><span class=nf>det</span> <span class=o>--&gt;</span> <span class=p>[</span><span class=s>a</span><span class=p>].</span>
</span></span><span class=line><span class=cl><span class=nf>noun</span> <span class=o>--&gt;</span> <span class=p>[</span><span class=s>cat</span><span class=p>].</span>
</span></span><span class=line><span class=cl><span class=nf>noun</span> <span class=o>--&gt;</span> <span class=p>[</span><span class=s>fish</span><span class=p>].</span>
</span></span><span class=line><span class=cl><span class=nf>verb</span> <span class=o>--&gt;</span> <span class=p>[</span><span class=s>eats</span><span class=p>].</span>
</span></span></code></pre></td></tr></table></div></div><p>DCG는 이러한 방식으로 문법 규칙을 기술하면, Prolog의 증명 엔진을 통해 직접 파싱할 수 있어 매우 강력한 도구로 평가된다.</p></li></ul><h5 id=mbnf-metamodified-backusnaur-form>MBNF (Meta/Modified Backus–Naur Form)<a hidden class=anchor aria-hidden=true href=#mbnf-metamodified-backusnaur-form>#</a></h5><ul><li>BNF의 변형 및 확장<br>MBNF는 BNF의 변형으로, 일부 표기법에서는 &ldquo;Meta-BNF&rdquo; 또는 &ldquo;Modified BNF"라 불리며, 기존 BNF에 비해 더 간결하거나 확장된 표현 방식을 제공하기 위해 고안되었다.<ul><li>특징:<ul><li>추가 메타 기호나 서술 방식이 도입되어, 선택이나 반복, 그룹화 등의 표현을 보다 자연스럽게 기술할 수 있다.</li><li>MBNF는 때때로 문법 내에서 주석이나 특정 조건, 혹은 문맥 정보를 포함하는 등 문서화가 강화된 형태로 사용된다.</li></ul></li><li><strong>사용 예시</strong>:<br>언어 사양서나 표준 문서에서 MBNF 형식을 채택하는 경우, 생산 규칙을 단순화시키고, 복잡한 구문을 보다 읽기 쉽도록 설명하는 데 도움이 된다. MBNF가 구체적으로 어떻게 표현되는지는 사용 환경에 따라 다르지만, 기본적인 아이디어는 BNF와 유사하면서도 추가적인 문법적 편의성을 제공하는 것이다.</li></ul></li></ul><ol><li><p>람다 계산법(Lambda Calculus) 문법<br>MBNF를 사용해 람다 계산법의 문법을 다음과 같이 정의할 수 있다.<br>여기서</p><ul><li><strong>x</strong>는 변수,</li><li>**(λ x. e)**는 람다 추상화,</li><li>**(e₁ @ e₂)**는 함수 적용을 나타낸다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>e = x ∪ (λ x . e) ∪ (e @ e)
</span></span></code></pre></td></tr></table></div></div><p>이 정의에서</p><ul><li>등호(=)는 &ldquo;정의된다"를 의미하고,</li><li>합집합 기호(∪)는 여러 대안을 나열하여 _e_가 변수 _x_이거나, 람다 추상화, 또는 두 표현식의 함수 적용일 수 있음을 나타낸다.</li></ul></li><li><p>산술 표현식 문법<br>산술식을 MBNF 스타일로 기술하는 예제는 아래와 같이 작성할 수 있다.<br>여기서</p><ul><li><strong>E</strong>는 전체 표현식(expression),</li><li><strong>T</strong>는 항(term),</li><li><strong>F</strong>는 인수(factor),</li><li><strong>n</strong>은 숫자(terminal symbol)를 나타낸다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>E = T ∪ (E + T) ∪ (E - T)
</span></span><span class=line><span class=cl>T = F ∪ (T × F) ∪ (T ÷ F)
</span></span><span class=line><span class=cl>F = n ∪ (E)
</span></span></code></pre></td></tr></table></div></div><p>이 문법에서는</p><ul><li>등호(=)를 사용해 각 비터미널 기호의 정의를 명시하고,</li><li>합집합 기호(∪)를 사용해 해당 항이 여러 가지 가능성을 가진다는 점(예를 들어, _E_가 단순 term일 수도 있고, term 사이에 덧셈이나 뺄셈이 추가될 수도 있음을) 나타낸다.</li></ul></li></ol><h3 id=구문-분석-과정>구문 분석 과정<a hidden class=anchor aria-hidden=true href=#구문-분석-과정>#</a></h3><p>언어의 구문은 컴파일 단계에서 여러 단계를 거쳐 분석되며, 일반적으로 다음 과정이 포함된다:</p><ul><li><strong>어휘 분석</strong>: 소스 코드를 문자 단위로 읽어 토큰으로 분리한다.</li><li><strong>구문 분석</strong>: 토큰들의 계층적 구조(구문 트리 또는 AST)를 생성하여 코드가 문법 규칙에 맞는지 확인한다.</li><li><strong>의미 분석</strong>: 생성된 구문 구조에 의미를 부여하여, 코드가 실제로 올바른 작업을 수행하는지 검증한다.</li></ul><h3 id=다양한-언어에서의-구문-예시>다양한 언어에서의 구문 예시<a hidden class=anchor aria-hidden=true href=#다양한-언어에서의-구문-예시>#</a></h3><p>각 프로그래밍 언어는 고유의 구문 규칙을 가지며, 이는 서로 다른 스타일과 특징을 보인다:</p><ul><li><p><strong>JavaScript</strong>: 변수 선언 시 <code>let</code>이나 <code>const</code>를 사용하며, 함수 호출과 끝에 세미콜론을 추가한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>message</span> <span class=o>=</span> <span class=s2>&#34;Hello, World!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><p>이 예시는 JavaScript의 기본 구문 규칙을 보여준다.</p></li><li><p><strong>C 언어</strong>: 모든 명령문은 세미콜론(;)으로 끝나며, <code>main()</code> 함수로 시작하여 중괄호 <code>{}</code>로 코드 블록을 감싼다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;My first line of code&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>C 언어의 구문은 프로그램 시작과 종료, 출력 함수의 사용을 엄격하게 규정한다.</p></li><li><p><strong>Lisp</strong>: 괄호를 이용해 모든 표현식을 감싸며, 리스트 기반의 구문 구조를 가진다.</p></li></ul><h2 id=고급-주제-및-최신-동향>고급 주제 및 최신 동향<a hidden class=anchor aria-hidden=true href=#고급-주제-및-최신-동향>#</a></h2><ul><li><strong>형식 문법과 파서 생성기</strong>: BNF 및 EBNF와 같은 표기법을 이용해 언어의 구문을 명세하며, yacc, ANTLR과 같은 도구로 파서를 자동 생성할 수 있다.</li><li><strong>정적 분석 도구의 활용</strong>: ESLint, Prettier, Clang AST 등의 도구는 구문 오류를 미리 발견하고 코드 스타일을 개선하는 데 도움을 준다.</li><li><strong>DSL과 패턴 매칭</strong>: 도메인 특화 언어(DSL)나 최신 언어의 패턴 매칭 구문은 전통적인 구문 규칙을 확장하여 더 직관적인 프로그래밍 방식을 지원한다.</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/language-syntax/>Language-Syntax</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/boolean/><span class=title>« Prev</span><br><span>논리값 (Boolean)</span>
</a><a class=next href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/git-workflow/branch-strategies/git-flow/><span class=title>Next »</span><br><span>Git Flow</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>