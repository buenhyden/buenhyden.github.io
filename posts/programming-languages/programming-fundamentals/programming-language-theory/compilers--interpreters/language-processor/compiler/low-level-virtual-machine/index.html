<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Low-Level Virtual Machine | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Compiler,Low-Level-Virtual-Machine"><meta name=description content="LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Low-Level Virtual Machine"><meta property="og:description" content="LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-05T03:41:00+00:00"><meta property="article:modified_time" content="2024-12-05T03:41:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="Low-Level-Virtual-Machine"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Low-Level Virtual Machine"><meta name=twitter:description content="LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/"},{"@type":"ListItem","position":4,"name":"Programming Language Theory","item":""},{"@type":"ListItem","position":8,"name":"Low-Level Virtual Machine","item":"https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Low-Level Virtual Machine","name":"Low-Level Virtual Machine","description":"LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크","keywords":["Programming-Languages","Fundamentals","Compiler","Low-Level-Virtual-Machine"],"articleBody":"Low-Level Virtual Machine (LLVM) LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크이다.\n원래 “Low-Level Virtual Machine\"의 약자에서 출발했으나, 현재는 그 이름 그대로 하나의 독립적인 프로젝트가 되어 다양한 언어와 플랫폼을 지원하고 있다.\nLLVM은 소스 코드 → 중간 표현(IR) 변환부터, 여러 단계의 최적화, 그리고 최종 기계어 코드 생성을 위한 백엔드로 구성되며, 컴파일 타임, 링크 타임, 런타임, 심지어 유휴 시간까지 전반에 걸친 지속적 최적화(Lifelong Optimization) 를 지원한다.\nLLVM의 핵심 아이디어는 컴파일러를 모듈화하여 프론트엔드(언어 파싱), 중간표현(IR) 최적화, 백엔드(코드 생성) 단계를 독립적으로 개발하고 재사용할 수 있게 만든 것으로, 컴파일러 개발의 유연성과 효율성을 크게 향상시켰다.\nLLVM의 정의 및 주요 특징 언어 및 플랫폼 독립성:\nLLVM은 언어에 구애받지 않고 여러 프로그래밍 언어로부터 IR을 생성할 수 있으며, 다양한 하드웨어 아키텍처(예: x86, ARM, RISC-V 등)에 대해 백엔드를 제공하여 플랫폼 독립적인 최적화를 수행한다. 중간 표현(Intermediate Representation, IR):\nLLVM은 SSA(Static Single Assignment) 형태의 IR을 사용한다. 이 방식은 각 변수에 한 번만 값을 할당하여 데이터 종속성 분석과 최적화를 단순화하며, 컴파일의 여러 단계에서 동일한 IR이 재사용될 수 있도록 한다. 모듈식 설계:\nLLVM은 프론트엔드, 최적화 라이브러리, 백엔드 등 여러 개별 모듈로 구성되어 있다. 이 구조 덕분에 각 구성 요소를 독립적으로 개선하거나 교체할 수 있으며, 새로운 언어나 플랫폼에 대한 확장이 용이하다. 지속적 최적화:\n컴파일 시점뿐만 아니라 링크 타임, 런타임, 그리고 프로그램의 유휴 시간에도 최적화 및 분석을 수행할 수 있어 실행 파일의 성능을 극대화할 수 있다. 유연한 타입 시스템 및 주소 산술 지원:\nLLVM은 단순하고 언어 독립적인 타입 시스템을 갖추고 있으며, 정밀한 메모리 주소 조작을 위한 Typed Address Arithmetic 명령어를 제공하여 안전하고 효율적인 메모리 접근을 보장한다. SSA(Static Single Assignment)\nSSA의 정의 SSA는 각 변수가 정확히 한 번만 할당되는 중간 표현 형식이다. 변수에 새 값을 할당할 때마다 새로운 버전의 변수가 생성된다. SSA의 특징 모든 LLVM 명령어는 SSA 형식으로 표현된다. 변수는 한 번만 할당될 수 있어, 최적화와 분석이 용이해진다. 제어 흐름에 따라 변수 값이 달라질 수 있는 경우, PHI(Φ) 노드를 사용한다. SSA의 장점 최적화 분석이 더 쉬워진다. 변수 사용 시 값이 할당된 곳이 단 한 곳이기 때문이다. 대부분의 최적화 기법이 SSA 형식을 유지할 수 있어, 연속적인 최적화 수행이 가능하다. SSA 기반 최적화는 일반적으로 더 효율적이고 강력하다. LLVM에서의 SSA 활용 LLVM은 모든 스칼라 레지스터 값에 대해 SSA 형식을 사용한다. 레지스터 할당이 이루어지는 컴파일 과정 후반부까지 SSA 형식이 유지된다. LLVM 사용의 이점 모듈성: 프론트엔드, 중간층, 백엔드의 분리로 개발과 유지보수 용이 재사용성: 새로운 언어 또는 타겟 추가 시 전체 파이프라인 재개발 필요 없음 확장성: 커스텀 패스와 플러그인을 통한 기능 확장 가능 호환성: 다양한 플랫폼과 아키텍처 지원 최적화: 강력한 최적화 기능으로 고성능 코드 생성 다양한 언어 지원 → Rust, Swift, Kotlin, Julia 등 현대적 언어에 사용 LLVM의 한계와 도전 과제 복잡성: 완전한 LLVM 스택은 학습 곡선이 가파름 디버깅 난이도: 최적화된 코드의 디버깅이 어려울 수 있음 리소스 요구사항: 메모리와 CPU 사용량이 많을 수 있음 특정 언어 최적화: 일부 언어별 최적화는 일반적인 IR에서 표현하기 어려움 GCC에 비해 성숙도가 낮음 → 일부 플랫폼에서는 GCC가 더 안정적 컴파일러가 너무 세분화됨 → 여러 도구(Clang, LLD, LLDB 등)를 조합해야 함 LLVM의 주요 컴포넌트 LLVM 코어\nLLVM의 핵심 부분으로, 중간표현(IR)과 이를 위한 최적화 패스를 포함한다.\nLLVM IR은 정적 단일 할당(SSA) 형식을 사용하며, 다양한 소스 언어와 하드웨어 플랫폼을 연결하는 중간 단계 역할을 한다.\nClang\nC, C++, Objective-C를 위한 LLVM 프론트엔드로, 소스 코드를 분석하고 LLVM IR로 변환한다.\nGCC보다 빠른 컴파일 속도와 더 명확한 오류 메시지로 널리 사용된다.\n컴파일러-RT\n컴파일 시간과 런타임에 필요한 저수준 지원 라이브러리이다. 예를 들어 sanitizer들과 프로파일링 기능을 제공한다.\nLLDB\nLLVM 기반 디버거로, Clang과 통합되어 C, C++, Objective-C 프로그램의 디버깅을 지원한다.\nlld\nLLVM의 링커로, 여러 객체 파일과 라이브러리를 최종 실행 파일로 결합한다.\n구성 요소 역할 LLVM IR (Intermediate Representation) 언어 독립적인 중간 표현 Clang LLVM 기반의 C, C++ 컴파일러 LLVM Optimizer (opt) 코드 최적화 수행 LLVM Code Generator (llc) LLVM IR을 기계어로 변환 LLVM JIT Compiler 실행 중에 코드 최적화 및 변환 LLVM Linker (lld) 실행 파일 및 라이브러리 링크 수행 LLVM Debugger (lldb) LLVM 기반 디버거 LLVM의 동작 방식 LLVM 컴파일 파이프라인은 다음과 같은 단계로 진행된다:\n소스 코드 파싱: 프론트엔드(예: Clang, Swift 컴파일러 등)가 소스 코드를 파싱하여 추상 구문 트리(AST)를 생성한다. LLVM IR 생성: AST가 LLVM IR로 변환된다. 최적화: LLVM 옵티마이저가 IR에 다양한 최적화 패스를 적용한다.\n불필요한 연산 제거, 루프 최적화, 메모리 접근 최적화 등이 포함된다. 코드 생성: 백엔드가 최적화된 IR을 타겟 머신 코드로 변환한다. 링킹: 여러 객체 파일과 라이브러리가 최종 실행 파일로 링크된다. LLVM의 중간표현(IR)\nLLVM IR은 세 가지 동등한 형태로 존재한다. 메모리 내 표현 (컴파일러 내부 사용) 비트코드 (.bc 파일, 직렬화된 이진 형식) 텍스트 형식 (.ll 파일, 사람이 읽을 수 있는 어셈블리와 유사) LLVM IR의 주요 특징: 정적 단일 할당(SSA) 형식 타입 시스템 내장 명시적인 제어 흐름 그래프 하드웨어에 독립적인 명령어 세트 LLVM은 다양한 최적화 패스를 제공한다:\n인라인화: 함수 호출을 함수 본문으로 대체 상수 폴딩: 컴파일 시간에 계산할 수 있는 표현식 평가 루프 최적화: 루프 언롤링, 벡터화, 루프 불변 코드 이동 등 명령어 스케줄링: CPU 파이프라인을 최적으로 사용 데드 코드 제거: 도달할 수 없거나 사용되지 않는 코드 제거 전역 값 번호 매기기(GVN): 중복 계산 제거 백엔드와 코드 생성\nLLVM 백엔드는 다양한 하드웨어 아키텍처에 대한 코드 생성을 담당한다: - x86, x86-64 - ARM, AArch64 - MIPS, PowerPC - WebAssembly - RISC-V 등\n백엔드 프로세스:\n명령어 선택: IR 명령을 타겟 머신 명령으로 매핑 레지스터 할당: 변수를 물리적 레지스터에 할당 명령어 스케줄링: 하드웨어 특성을 고려한 최적 명령어 순서 결정 프레임 관리: 스택 프레임 레이아웃 결정 LLVM vs. 기존 컴파일러 비교 LLVM은 기존의 전통적인 컴파일러와 비교할 때 더 많은 유연성과 확장성을 제공한다.\n비교 항목 LLVM GCC (GNU Compiler Collection) MSVC (Microsoft Visual C++) 설계 방식 모듈형, 라이브러리 기반 단일 패키지, 일체형 Windows 전용 통합 환경 지원 언어 C, C++, Rust, Swift, Kotlin 등 C, C++ C, C++ 지원 플랫폼 Windows, macOS, Linux, Android, iOS Windows, macOS, Linux Windows 최적화 성능 강력한 IR 기반 최적화 다양한 최적화 옵션 지원 MS 환경에 최적화 컴파일 속도 빠름 상대적으로 느림 빠름 JIT 지원 지원 (LLVM JIT) 지원하지 않음 지원하지 않음 확장성 매우 높음 (다양한 언어 및 백엔드 추가 가능) 제한적 Windows 환경에 특화 LLVM의 활용 분야 활용 분야 설명 C/C++ 컴파일러 (Clang) GCC 대체로 빠르고 최적화된 코드 생성 Rust, Swift, Julia 등 언어 개발 Rust, Swift, Julia의 백엔드 컴파일러 WebAssembly (WASM) 지원 웹에서 고성능 네이티브 코드 실행 가능 JIT 컴파일러 런타임에서 코드 최적화 및 실행 성능 개선 임베디드 시스템 ARM, RISC-V 기반 마이크로컨트롤러 개발 LLVM의 실용적 응용 정적 분석 도구: Clang Static Analyzer와 같은 도구는 LLVM/Clang 인프라를 사용하여 코드의 버그와 취약점을 찾는다. Just-In-Time(JIT) 컴파일: LLVM의 JIT 컴파일 기능은 런타임에 코드를 생성하고 실행할 수 있게 해준다. 이는 성능 중심 애플리케이션과 동적 언어 구현에 유용하다. 크로스 컴파일: LLVM의 모듈식 설계는 다양한 플랫폼을 위한 크로스 컴파일을 단순화한다. 하드웨어 가속기 타겟팅: LLVM은 GPU나 FPGA와 같은 특수 하드웨어를 위한 코드 생성을 지원한다. LLVM 기반 언어 및 프로젝트 LLVM은 여러 언어 및 프로젝트에서 핵심 기술로 사용된다.\n언어 설명 Clang C, C++ 컴파일러 (GCC 대체) Swift Apple의 프로그래밍 언어 Rust 메모리 안전성을 보장하는 시스템 프로그래밍 언어 Kotlin/Native JVM 없이 실행 가능한 Kotlin Julia 과학 컴퓨팅 및 데이터 과학용 언어 WebAssembly (WASM) 웹에서 네이티브 성능을 제공하는 실행 환경 TensorFlow 머신러닝 프레임워크의 XLA 컴파일러 WebKit 애플의 웹 브라우저 엔진의 자바스크립트 엔진(JavaScriptCore) LLVM은 단순한 컴파일러가 아니라, 다양한 프로그래밍 언어와 하드웨어를 지원하는 강력한 프레임워크로 발전 중이다.\n참고 및 출처 ","wordCount":"1138","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-05T03:41:00Z","dateModified":"2024-12-05T03:41:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/>Fundamentals of Programming Languages</a>&nbsp;»&nbsp;<a href>Programming Language Theory</a></div><h1 class="post-title entry-hint-parent">Low-Level Virtual Machine</h1><div class=post-description>LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크</div><div class=post-meta><span title='2024-12-05 03:41:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Programming%20Fundamentals/Programming%20Language%20Theory/Compilers%20&%20Interpreters/Language%20Processor/Compiler/low-level-virtual-machine.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#low-level-virtual-machine-llvm>Low-Level Virtual Machine (LLVM)</a><ul><li><a href=#llvm의-정의-및-주요-특징>LLVM의 정의 및 주요 특징</a></li></ul></li><li><a href=#ssa의-정의>SSA의 정의</a></li><li><a href=#ssa의-특징>SSA의 특징</a></li><li><a href=#ssa의-장점>SSA의 장점</a></li><li><a href=#llvm에서의-ssa-활용>LLVM에서의 SSA 활용</a><ul><li><a href=#llvm-사용의-이점>LLVM 사용의 이점</a></li><li><a href=#llvm의-한계와-도전-과제>LLVM의 한계와 도전 과제</a></li><li><a href=#llvm의-주요-컴포넌트>LLVM의 주요 컴포넌트</a></li><li><a href=#llvm의-동작-방식>LLVM의 동작 방식</a></li><li><a href=#llvm-vs-기존-컴파일러-비교>LLVM vs. 기존 컴파일러 비교</a></li><li><a href=#llvm의-활용-분야>LLVM의 활용 분야</a></li><li><a href=#llvm-기반-언어-및-프로젝트>LLVM 기반 언어 및 프로젝트</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=low-level-virtual-machine-llvm>Low-Level Virtual Machine (LLVM)<a hidden class=anchor aria-hidden=true href=#low-level-virtual-machine-llvm>#</a></h2><p>LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크이다.<br>원래 &ldquo;Low-Level Virtual Machine"의 약자에서 출발했으나, 현재는 그 이름 그대로 하나의 독립적인 프로젝트가 되어 다양한 언어와 플랫폼을 지원하고 있다.<br>LLVM은 소스 코드 → 중간 표현(IR) 변환부터, 여러 단계의 최적화, 그리고 최종 기계어 코드 생성을 위한 백엔드로 구성되며, 컴파일 타임, 링크 타임, 런타임, 심지어 유휴 시간까지 전반에 걸친 <strong>지속적 최적화(Lifelong Optimization)</strong> 를 지원한다.</p><p>LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 프론트엔드(언어 파싱), 중간표현(IR) 최적화, 백엔드(코드 생성) 단계를 독립적으로 개발하고 재사용할 수 있게 만든 것으로, 컴파일러 개발의 유연성과 효율성을 크게 향상시켰다.</p><h3 id=llvm의-정의-및-주요-특징>LLVM의 정의 및 주요 특징<a hidden class=anchor aria-hidden=true href=#llvm의-정의-및-주요-특징>#</a></h3><ul><li><strong>언어 및 플랫폼 독립성</strong>:<br>LLVM은 언어에 구애받지 않고 여러 프로그래밍 언어로부터 IR을 생성할 수 있으며, 다양한 하드웨어 아키텍처(예: x86, ARM, RISC-V 등)에 대해 백엔드를 제공하여 플랫폼 독립적인 최적화를 수행한다.</li><li><strong>중간 표현(Intermediate Representation, IR)</strong>:<br>LLVM은 SSA(Static Single Assignment) 형태의 IR을 사용한다. 이 방식은 각 변수에 한 번만 값을 할당하여 데이터 종속성 분석과 최적화를 단순화하며, 컴파일의 여러 단계에서 동일한 IR이 재사용될 수 있도록 한다.</li><li><strong>모듈식 설계</strong>:<br>LLVM은 프론트엔드, 최적화 라이브러리, 백엔드 등 여러 개별 모듈로 구성되어 있다. 이 구조 덕분에 각 구성 요소를 독립적으로 개선하거나 교체할 수 있으며, 새로운 언어나 플랫폼에 대한 확장이 용이하다.</li><li><strong>지속적 최적화</strong>:<br>컴파일 시점뿐만 아니라 링크 타임, 런타임, 그리고 프로그램의 유휴 시간에도 최적화 및 분석을 수행할 수 있어 실행 파일의 성능을 극대화할 수 있다.</li><li><strong>유연한 타입 시스템 및 주소 산술 지원</strong>:<br>LLVM은 단순하고 언어 독립적인 타입 시스템을 갖추고 있으며, 정밀한 메모리 주소 조작을 위한 <strong>Typed Address Arithmetic</strong> 명령어를 제공하여 안전하고 효율적인 메모리 접근을 보장한다.</li></ul><blockquote><p>SSA(Static Single Assignment)</p><h2 id=ssa의-정의>SSA의 정의<a hidden class=anchor aria-hidden=true href=#ssa의-정의>#</a></h2><ul><li>SSA는 각 변수가 정확히 한 번만 할당되는 중간 표현 형식이다.</li><li>변수에 새 값을 할당할 때마다 새로운 버전의 변수가 생성된다.</li></ul><h2 id=ssa의-특징>SSA의 특징<a hidden class=anchor aria-hidden=true href=#ssa의-특징>#</a></h2><ul><li>모든 LLVM 명령어는 SSA 형식으로 표현된다.</li><li>변수는 한 번만 할당될 수 있어, 최적화와 분석이 용이해진다.</li><li>제어 흐름에 따라 변수 값이 달라질 수 있는 경우, PHI(Φ) 노드를 사용한다.</li></ul><h2 id=ssa의-장점>SSA의 장점<a hidden class=anchor aria-hidden=true href=#ssa의-장점>#</a></h2><ul><li>최적화 분석이 더 쉬워진다. 변수 사용 시 값이 할당된 곳이 단 한 곳이기 때문이다.</li><li>대부분의 최적화 기법이 SSA 형식을 유지할 수 있어, 연속적인 최적화 수행이 가능하다.</li><li>SSA 기반 최적화는 일반적으로 더 효율적이고 강력하다.</li></ul><h2 id=llvm에서의-ssa-활용>LLVM에서의 SSA 활용<a hidden class=anchor aria-hidden=true href=#llvm에서의-ssa-활용>#</a></h2><ul><li>LLVM은 모든 스칼라 레지스터 값에 대해 SSA 형식을 사용한다.</li><li>레지스터 할당이 이루어지는 컴파일 과정 후반부까지 SSA 형식이 유지된다.</li></ul></blockquote><h3 id=llvm-사용의-이점>LLVM 사용의 이점<a hidden class=anchor aria-hidden=true href=#llvm-사용의-이점>#</a></h3><ol><li><strong>모듈성</strong>: 프론트엔드, 중간층, 백엔드의 분리로 개발과 유지보수 용이</li><li><strong>재사용성</strong>: 새로운 언어 또는 타겟 추가 시 전체 파이프라인 재개발 필요 없음</li><li><strong>확장성</strong>: 커스텀 패스와 플러그인을 통한 기능 확장 가능</li><li><strong>호환성</strong>: 다양한 플랫폼과 아키텍처 지원</li><li><strong>최적화</strong>: 강력한 최적화 기능으로 고성능 코드 생성</li><li><strong>다양한 언어 지원</strong> → Rust, Swift, Kotlin, Julia 등 현대적 언어에 사용</li></ol><h3 id=llvm의-한계와-도전-과제>LLVM의 한계와 도전 과제<a hidden class=anchor aria-hidden=true href=#llvm의-한계와-도전-과제>#</a></h3><ol><li><strong>복잡성</strong>: 완전한 LLVM 스택은 학습 곡선이 가파름</li><li><strong>디버깅 난이도</strong>: 최적화된 코드의 디버깅이 어려울 수 있음</li><li><strong>리소스 요구사항</strong>: 메모리와 CPU 사용량이 많을 수 있음</li><li><strong>특정 언어 최적화</strong>: 일부 언어별 최적화는 일반적인 IR에서 표현하기 어려움</li><li><strong>GCC에 비해 성숙도가 낮음</strong> → 일부 플랫폼에서는 GCC가 더 안정적</li><li><strong>컴파일러가 너무 세분화됨</strong> → 여러 도구(Clang, LLD, LLDB 등)를 조합해야 함</li></ol><h3 id=llvm의-주요-컴포넌트>LLVM의 주요 컴포넌트<a hidden class=anchor aria-hidden=true href=#llvm의-주요-컴포넌트>#</a></h3><ol><li><p>LLVM 코어<br>LLVM의 핵심 부분으로, 중간표현(IR)과 이를 위한 최적화 패스를 포함한다.<br>LLVM IR은 정적 단일 할당(SSA) 형식을 사용하며, 다양한 소스 언어와 하드웨어 플랫폼을 연결하는 중간 단계 역할을 한다.</p></li><li><p>Clang<br>C, C++, Objective-C를 위한 LLVM 프론트엔드로, 소스 코드를 분석하고 LLVM IR로 변환한다.<br>GCC보다 빠른 컴파일 속도와 더 명확한 오류 메시지로 널리 사용된다.</p></li><li><p>컴파일러-RT<br>컴파일 시간과 런타임에 필요한 저수준 지원 라이브러리이다. 예를 들어 sanitizer들과 프로파일링 기능을 제공한다.</p></li><li><p>LLDB<br>LLVM 기반 디버거로, Clang과 통합되어 C, C++, Objective-C 프로그램의 디버깅을 지원한다.</p></li><li><p>lld<br>LLVM의 링커로, 여러 객체 파일과 라이브러리를 최종 실행 파일로 결합한다.</p></li></ol><table><thead><tr><th>구성 요소</th><th>역할</th></tr></thead><tbody><tr><td><strong>LLVM IR (Intermediate Representation)</strong></td><td>언어 독립적인 중간 표현</td></tr><tr><td><strong>Clang</strong></td><td>LLVM 기반의 C, C++ 컴파일러</td></tr><tr><td><strong>LLVM Optimizer (<code>opt</code>)</strong></td><td>코드 최적화 수행</td></tr><tr><td><strong>LLVM Code Generator (<code>llc</code>)</strong></td><td>LLVM IR을 기계어로 변환</td></tr><tr><td><strong>LLVM JIT Compiler</strong></td><td>실행 중에 코드 최적화 및 변환</td></tr><tr><td><strong>LLVM Linker (<code>lld</code>)</strong></td><td>실행 파일 및 라이브러리 링크 수행</td></tr><tr><td><strong>LLVM Debugger (<code>lldb</code>)</strong></td><td>LLVM 기반 디버거</td></tr></tbody></table><h3 id=llvm의-동작-방식>LLVM의 동작 방식<a hidden class=anchor aria-hidden=true href=#llvm의-동작-방식>#</a></h3><p>LLVM 컴파일 파이프라인은 다음과 같은 단계로 진행된다:</p><ol><li><strong>소스 코드 파싱</strong>: 프론트엔드(예: Clang, Swift 컴파일러 등)가 소스 코드를 파싱하여 추상 구문 트리(AST)를 생성한다.</li><li><strong>LLVM IR 생성</strong>: AST가 LLVM IR로 변환된다.</li><li><strong>최적화</strong>: LLVM 옵티마이저가 IR에 다양한 최적화 패스를 적용한다.<br>불필요한 연산 제거, 루프 최적화, 메모리 접근 최적화 등이 포함된다.</li><li><strong>코드 생성</strong>: 백엔드가 최적화된 IR을 타겟 머신 코드로 변환한다.</li><li><strong>링킹</strong>: 여러 객체 파일과 라이브러리가 최종 실행 파일로 링크된다.</li></ol><blockquote><p>LLVM의 중간표현(IR)</p><ul><li>LLVM IR은 세 가지 동등한 형태로 존재한다.<ul><li>메모리 내 표현 (컴파일러 내부 사용)</li><li>비트코드 (.bc 파일, 직렬화된 이진 형식)</li><li>텍스트 형식 (.ll 파일, 사람이 읽을 수 있는 어셈블리와 유사)</li></ul></li><li>LLVM IR의 주요 특징:<ul><li>정적 단일 할당(SSA) 형식</li><li>타입 시스템 내장</li><li>명시적인 제어 흐름 그래프</li><li>하드웨어에 독립적인 명령어 세트</li></ul></li></ul></blockquote><blockquote><p>LLVM은 다양한 최적화 패스를 제공한다:</p><ol><li><strong>인라인화</strong>: 함수 호출을 함수 본문으로 대체</li><li><strong>상수 폴딩</strong>: 컴파일 시간에 계산할 수 있는 표현식 평가</li><li><strong>루프 최적화</strong>: 루프 언롤링, 벡터화, 루프 불변 코드 이동 등</li><li><strong>명령어 스케줄링</strong>: CPU 파이프라인을 최적으로 사용</li><li><strong>데드 코드 제거</strong>: 도달할 수 없거나 사용되지 않는 코드 제거</li><li><strong>전역 값 번호 매기기(GVN)</strong>: 중복 계산 제거</li></ol></blockquote><blockquote><p>백엔드와 코드 생성<br>LLVM 백엔드는 다양한 하드웨어 아키텍처에 대한 코드 생성을 담당한다:
- x86, x86-64
- ARM, AArch64
- MIPS, PowerPC
- WebAssembly
- RISC-V 등</p><p>백엔드 프로세스:</p><ol><li>명령어 선택: IR 명령을 타겟 머신 명령으로 매핑</li><li>레지스터 할당: 변수를 물리적 레지스터에 할당</li><li>명령어 스케줄링: 하드웨어 특성을 고려한 최적 명령어 순서 결정</li><li>프레임 관리: 스택 프레임 레이아웃 결정</li></ol></blockquote><h3 id=llvm-vs-기존-컴파일러-비교>LLVM vs. 기존 컴파일러 비교<a hidden class=anchor aria-hidden=true href=#llvm-vs-기존-컴파일러-비교>#</a></h3><p>LLVM은 기존의 전통적인 컴파일러와 비교할 때 <strong>더 많은 유연성과 확장성을 제공</strong>한다.</p><table><thead><tr><th>비교 항목</th><th><strong>LLVM</strong></th><th><strong>GCC (GNU Compiler Collection)</strong></th><th><strong>MSVC (Microsoft Visual C++)</strong></th></tr></thead><tbody><tr><td><strong>설계 방식</strong></td><td>모듈형, 라이브러리 기반</td><td>단일 패키지, 일체형</td><td>Windows 전용 통합 환경</td></tr><tr><td><strong>지원 언어</strong></td><td>C, C++, Rust, Swift, Kotlin 등</td><td>C, C++</td><td>C, C++</td></tr><tr><td><strong>지원 플랫폼</strong></td><td>Windows, macOS, Linux, Android, iOS</td><td>Windows, macOS, Linux</td><td>Windows</td></tr><tr><td><strong>최적화 성능</strong></td><td>강력한 IR 기반 최적화</td><td>다양한 최적화 옵션 지원</td><td>MS 환경에 최적화</td></tr><tr><td><strong>컴파일 속도</strong></td><td>빠름</td><td>상대적으로 느림</td><td>빠름</td></tr><tr><td><strong>JIT 지원</strong></td><td>지원 (LLVM JIT)</td><td>지원하지 않음</td><td>지원하지 않음</td></tr><tr><td><strong>확장성</strong></td><td>매우 높음 (다양한 언어 및 백엔드 추가 가능)</td><td>제한적</td><td>Windows 환경에 특화</td></tr></tbody></table><h3 id=llvm의-활용-분야>LLVM의 활용 분야<a hidden class=anchor aria-hidden=true href=#llvm의-활용-분야>#</a></h3><table><thead><tr><th>활용 분야</th><th>설명</th></tr></thead><tbody><tr><td><strong>C/C++ 컴파일러 (Clang)</strong></td><td>GCC 대체로 빠르고 최적화된 코드 생성</td></tr><tr><td><strong>Rust, Swift, Julia 등 언어 개발</strong></td><td>Rust, Swift, Julia의 백엔드 컴파일러</td></tr><tr><td><strong>WebAssembly (WASM) 지원</strong></td><td>웹에서 고성능 네이티브 코드 실행 가능</td></tr><tr><td><strong>JIT 컴파일러</strong></td><td>런타임에서 코드 최적화 및 실행 성능 개선</td></tr><tr><td><strong>임베디드 시스템</strong></td><td>ARM, RISC-V 기반 마이크로컨트롤러 개발</td></tr></tbody></table><h4 id=llvm의-실용적-응용>LLVM의 실용적 응용<a hidden class=anchor aria-hidden=true href=#llvm의-실용적-응용>#</a></h4><ol><li>정적 분석 도구: Clang Static Analyzer와 같은 도구는 LLVM/Clang 인프라를 사용하여 코드의 버그와 취약점을 찾는다.</li><li>Just-In-Time(JIT) 컴파일: LLVM의 JIT 컴파일 기능은 런타임에 코드를 생성하고 실행할 수 있게 해준다. 이는 성능 중심 애플리케이션과 동적 언어 구현에 유용하다.</li><li>크로스 컴파일: LLVM의 모듈식 설계는 다양한 플랫폼을 위한 크로스 컴파일을 단순화한다.</li><li>하드웨어 가속기 타겟팅: LLVM은 GPU나 FPGA와 같은 특수 하드웨어를 위한 코드 생성을 지원한다.</li></ol><h3 id=llvm-기반-언어-및-프로젝트>LLVM 기반 언어 및 프로젝트<a hidden class=anchor aria-hidden=true href=#llvm-기반-언어-및-프로젝트>#</a></h3><p>LLVM은 여러 언어 및 프로젝트에서 핵심 기술로 사용된다.</p><table><thead><tr><th><strong>언어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>Clang</strong></td><td>C, C++ 컴파일러 (GCC 대체)</td></tr><tr><td><strong>Swift</strong></td><td>Apple의 프로그래밍 언어</td></tr><tr><td><strong>Rust</strong></td><td>메모리 안전성을 보장하는 시스템 프로그래밍 언어</td></tr><tr><td><strong>Kotlin/Native</strong></td><td>JVM 없이 실행 가능한 Kotlin</td></tr><tr><td><strong>Julia</strong></td><td>과학 컴퓨팅 및 데이터 과학용 언어</td></tr><tr><td><strong>WebAssembly (WASM)</strong></td><td>웹에서 네이티브 성능을 제공하는 실행 환경</td></tr><tr><td><strong>TensorFlow</strong></td><td>머신러닝 프레임워크의 XLA 컴파일러</td></tr><tr><td><strong>WebKit</strong></td><td>애플의 웹 브라우저 엔진의 자바스크립트 엔진(JavaScriptCore)</td></tr></tbody></table><p>LLVM은 <strong>단순한 컴파일러가 아니라, 다양한 프로그래밍 언어와 하드웨어를 지원하는 강력한 프레임워크</strong>로 발전 중이다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/low-level-virtual-machine/>Low-Level-Virtual-Machine</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/><span class=title>« Prev</span><br><span>Inorder Traversal</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/functions/><span class=title>Next »</span><br><span>Functions</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>