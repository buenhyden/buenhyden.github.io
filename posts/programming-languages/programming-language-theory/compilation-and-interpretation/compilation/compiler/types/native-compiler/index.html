<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Native Compiler | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Compiler,Types,Native-Compiler"><meta name=description content="Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/native-compiler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/native-compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/native-compiler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Native Compiler"><meta property="og:description" content="Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-14T15:30:00+00:00"><meta property="article:modified_time" content="2024-10-14T15:30:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="Types"><meta property="article:tag" content="Native-Compiler"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Native Compiler"><meta name=twitter:description content="Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Programming Language Theory","item":""},{"@type":"ListItem","position":6,"name":"컴파일러(Compiler)","item":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/"},{"@type":"ListItem","position":7,"name":"types of Compiler","item":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/"},{"@type":"ListItem","position":8,"name":"Native Compiler","item":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/native-compiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Native Compiler","name":"Native Compiler","description":"Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러","keywords":["Programming-Languages","Fundamentals","Compiler","Types","Native-Compiler"],"articleBody":"Native Compiler Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.\n네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.\n다양한 최적화 기능, 디버깅 도구와의 통합, 빌드 시스템과의 연계를 통해 개발자는 효율적인 코드를 작성하고 테스트할 수 있다. 특히 GCC, Clang, Visual C++ 등 주요 네이티브 컴파일러는 지속적인 발전을 통해 더 나은 성능과 개발자 경험을 제공하고 있다.\n최근에는 모듈식 아키텍처, 병렬 컴파일, 머신 러닝 기반 최적화 등 다양한 기술적 발전이 이루어지고 있으며, 이는 더 빠른 컴파일 시간과 더 효율적인 코드 생성으로 이어지고 있다. 또한 크로스 컴파일러와의 기술 공유를 통해 다양한 플랫폼 지원도 강화되고 있다.\n네이티브 컴파일러의 정의 네이티브 컴파일러는 코드가 실행될 예정인 것과 동일한 컴퓨팅 환경(동일한 운영체제, 프로세서 아키텍처)에서 실행되는 컴파일러이다.\n간단히 말해, 소스 코드를 컴파일하는 시스템과 컴파일된 프로그램이 실행될 시스템이 같은 경우에 사용하는 컴파일러이다. 예를 들어, x86_64 아키텍처의 Linux 시스템에서 실행되는 컴파일러가 같은 x86_64 Linux 시스템에서 실행될 바이너리를 생성한다면, 이는 네이티브 컴파일러이다.\n네이티브 컴파일러의 작동 원리 네이티브 컴파일러의 기본 작동 과정은 다음과 같다:\n전처리(Preprocessing): 소스 코드의 전처리 지시문(#include, #define 등) 처리 및 매크로 확장 컴파일(Compilation): 소스 코드를 현재 플랫폼에 맞는 어셈블리어로 변환 어셈블(Assembly): 어셈블리 코드를 현재 플랫폼의 기계어로 변환 링킹(Linking): 현재 시스템의 라이브러리와 목적 파일들을 연결하여 최종 실행 파일 생성 이 과정에서 컴파일러는 현재 시스템의 명령어 세트 아키텍처(ISA), 메모리 모델, 바이트 순서(endianness), ABI(Application Binary Interface) 등을 자동으로 고려한다.\n1 [소스 코드] → [전처리기] → [컴파일러] → [어셈블러] → [링커] → [실행 파일] 네이티브 컴파일러의 장점 간편한 설정\n추가적인 설정이나 툴체인 없이 기본 환경에서 즉시 사용 가능하다.\n대부분의 운영체제는 해당 시스템에 최적화된 컴파일러를 기본적으로 제공하거나 쉽게 설치할 수 있다.\n직접적인 디버깅\n컴파일된 프로그램이 동일한 환경에서 실행되므로, 디버깅 과정이 간단하고 직관적이다.\n로컬 디버거를 사용하여 실시간으로 코드 실행을 분석할 수 있다.\n최적화된 성능\n현재 시스템의 아키텍처와 특성을 정확히 파악하여 최적화된 코드를 생성할 수 있다.\n프로세서 특화 명령어 세트나 하드웨어 기능을 활용한 최적화가 가능하다.\n라이브러리 호환성\n현재 시스템의 라이브러리를 직접 활용할 수 있어, 라이브러리 의존성 관리가 단순하다.\n네이티브 컴파일러의 주요 종류 GCC (GNU Compiler Collection)\n오픈 소스 컴파일러 모음으로, C, C++, Fortran, Ada 등 다양한 언어를 지원한다.\nLinux, macOS, Windows(MinGW) 등 여러 플랫폼에서 사용 가능하다.\nClang/LLVM\n모듈식 컴파일러 인프라로, C, C++, Objective-C 등을 지원한다. Apple 제품에서 기본 컴파일러로 사용되며, 뛰어난 에러 메시지와 정적 분석 도구를 제공합니다.\nMicrosoft Visual C++ 컴파일러\nWindows 환경에서 C/C++ 개발을 위한 마이크로소프트의 네이티브 컴파일러로, Visual Studio IDE와 통합되어 있다.\n인텔 C++ 컴파일러\n인텔 프로세서에 최적화된 성능을 제공하는 상용 컴파일러이다.\nOracle Solaris Studio\nSolaris, Linux 환경에서 C, C++, Fortran을 지원하는 Oracle의 컴파일러 제품군이다.\n주요 네이티브 컴파일러 비교 컴파일러 지원 플랫폼 지원 언어 최적화 수준 특징 라이센스 주요 사용 환경 GCC Linux, macOS, Windows(MinGW), 다양한 유닉스 계열 C, C++, Fortran, Ada, Go 등 높음 광범위한 플랫폼 지원, 많은 최적화 옵션 GPL 오픈소스 프로젝트, 리눅스 개발 Clang/LLVM Linux, macOS, Windows C, C++, Objective-C 높음 우수한 진단 메시지, 모듈식 설계 Apache 2.0 macOS/iOS 개발, 정적 분석 도구 Microsoft Visual C++ Windows C, C++ 높음 Visual Studio와 통합, Windows API 지원 상용 Windows 애플리케이션 개발 Intel C++ Compiler Linux, macOS, Windows C, C++ 매우 높음 Intel 프로세서 최적화 상용 고성능 컴퓨팅, 과학 계산 Oracle Solaris Studio Solaris, Linux C, C++, Fortran 높음 SPARC 및 x86 최적화 상용/무료 등록 엔터프라이즈 애플리케이션 IBM XL C/C++ AIX, Linux C, C++ 높음 IBM Power 아키텍처 최적화 상용 엔터프라이즈 시스템, 슈퍼컴퓨터 PGI Compiler Linux, macOS, Windows C, C++, Fortran 높음 HPC 및 GPU 컴퓨팅 최적화 상용 과학 계산, 병렬 컴퓨팅 Arm Compiler Linux, Windows C, C++ 높음 Arm 프로세서 최적화 상용 Arm 기반 시스템 개발 TinyCC (TCC) Linux, Windows C 낮음 컴파일 속도 매우 빠름, 작은 크기 LGPL 스크립트 통합, 빠른 컴파일 필요 시 Digital Mars C/C++ Windows C, C++ 중간 빠른 컴파일, 작은 실행 파일 무료/상용 윈도우 개발 네이티브 컴파일러 사용 예제 GCC를 사용한 C 프로그램 컴파일\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 간단한 C 프로그램 작성 echo '#include int main() { printf(\"Hello, Native Compiler!\\n\"); return 0; }' \u003e hello.c # 컴파일 gcc -o hello hello.c # 실행 ./hello # 출력: Hello, Native Compiler! Clang을 사용한 C++ 프로그램 컴파일\n1 2 3 4 5 6 7 8 9 10 11 12 13 # C++ 프로그램 작성 echo '#include int main() { std::cout \u003c\u003c \"Compiled with Clang\" \u003c\u003c std::endl; return 0; }' \u003e hello.cpp # Clang으로 컴파일 clang++ -o hello_clang hello.cpp # 실행 ./hello_clang # 출력: Compiled with Clang Visual C++를 사용한 Windows 애플리케이션 컴파일 (명령줄)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 REM 명령 프롬프트에서 Visual C++ 환경 설정 call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\" REM C++ 파일 생성 echo #include \u003ciostream\u003e \u003e hello.cpp echo int main() { \u003e\u003e hello.cpp echo std::cout \u003c\u003c \"Compiled with MSVC\" \u003c\u003c std::endl; \u003e\u003e hello.cpp echo return 0; \u003e\u003e hello.cpp echo } \u003e\u003e hello.cpp REM 컴파일 cl /EHsc hello.cpp REM 실행 hello.exe REM 출력: Compiled with MSVC 네이티브 컴파일러의 최적화 기능 컴파일러 최적화 레벨 대부분의 네이티브 컴파일러는 다양한 최적화 레벨을 제공한다:\n-O0: 최적화 없음 (디버깅에 유용) -O1: 기본 최적화 -O2: 더 강력한 최적화 (일반적으로 권장됨) -O3: 최대 최적화 (실행 속도 중심) -Os: 크기 최적화 (실행 파일 크기 축소) 1 2 # GCC로 최적화 수준 지정 예 gcc -O2 -o optimized_program source.c 프로파일 기반 최적화(PGO) 프로그램의 실제 실행 패턴을 분석하여 최적화하는 기능이다:\n1 2 3 4 5 6 7 8 9 # GCC PGO 예제 # 1. 프로파일 정보 생성을 위한 컴파일 gcc -fprofile-generate -o program source.c # 2. 프로그램 실행하여 프로파일 데이터 수집 ./program # 3. 수집된 프로파일을 기반으로 최종 컴파일 gcc -fprofile-use -o optimized_program source.c 자동 벡터화 SIMD(Single Instruction, Multiple Data) 명령어를 자동으로 사용하여 성능을 향상시키는 기능이다.\n1 2 # GCC 자동 벡터화 예제 gcc -O3 -ftree-vectorize -o vectorized_program source.c 링크 시간 최적화(LTO) 컴파일 단위 간의 전역 최적화를 수행하는 기능이다:\n1 2 # GCC LTO 예제 gcc -flto -o lto_program source1.c source2.c 네이티브 컴파일러와 빌드 시스템 Make 가장 기본적인 빌드 자동화 도구로, 의존성 트리를 기반으로 필요한 파일만 재컴파일한다:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Makefile 예제 CC = gcc CFLAGS = -Wall -O2 program: main.o utils.o $(CC) $(CFLAGS) -o program main.o utils.o main.o: main.c $(CC) $(CFLAGS) -c main.c utils.o: utils.c $(CC) $(CFLAGS) -c utils.c clean: rm -f *.o program CMake 크로스 플랫폼 빌드 시스템 생성기로, 다양한 네이티브 컴파일러와 통합된다:\n1 2 3 4 5 6 # CMakeLists.txt 예제 cmake_minimum_required(VERSION 3.10) project(MyProject) set(CMAKE_CXX_STANDARD 17) add_executable(program main.cpp utils.cpp) 1 2 3 4 # CMake 사용 mkdir build \u0026\u0026 cd build cmake .. make Ninja 빠른 속도에 최적화된 빌드 시스템이다:\n1 2 3 4 # CMake와 Ninja 함께 사용 mkdir build \u0026\u0026 cd build cmake -G Ninja .. ninja Bazel 구글에서 개발한 대규모 프로젝트를 위한 빌드 시스템입니다:\n1 2 3 4 5 6 # BUILD 파일 예제 cc_binary( name = \"program\", srcs = [\"main.cpp\", \"utils.cpp\"], copts = [\"-Wall\", \"-O2\"], ) 네이티브 컴파일러의 발전 동향 모듈식 컴파일러 아키텍처\nLLVM과 같은 모듈식 컴파일러 인프라가 인기를 얻고 있으며, 프론트엔드와 백엔드를 분리하여 다양한 언어와 타겟을 지원한다.\nJIT(Just-In-Time) 컴파일 통합\n정적 컴파일과 JIT 컴파일을 결합한 하이브리드 접근 방식이 등장하고 있다.\n머신 러닝 기반 최적화\n컴파일러 최적화에 머신 러닝 기술을 적용하여 코드 성능을 향상시키는 연구가 진행 중이다.\n병렬 컴파일\n멀티코어 프로세서를 활용한 병렬 컴파일로 빌드 시간을 단축하는 기능이 발전하고 있다:\n1 2 # GCC 병렬 컴파일 예제 make -j8 # 8개 코어 활용 네이티브 컴파일러 관련 고급 개념 컴파일러 확장과 내장 함수\n많은 네이티브 컴파일러는 표준을 넘어서는 확장 기능과 최적화된 내장 함수를 제공한다.\n1 2 // GCC 내장 함수 예제 int count_bits = __builtin_popcount(value); // 비트 카운팅 최적화 인라인 어셈블리\n성능 최적화나 하드웨어 접근을 위해 C/C++ 코드 내에 어셈블리 코드를 직접 작성할 수 있다:\n1 2 3 4 5 6 // x86 인라인 어셈블리 예제 int a = 10, b = 20, result; asm (\"addl %1, %2\\n\" \"movl %2, %0\" : \"=r\" (result) : \"r\" (a), \"r\" (b)); 링커 스크립트\n링킹 과정을 세밀하게 제어하여 메모리 레이아웃을 사용자가 정의할 수 있다. 이는 임베디드 시스템이나 운영체제 개발에서 중요하다.\n교차 언어 최적화\n다양한 프로그래밍 언어로 작성된 코드 간의 최적화를 지원하는 컴파일러가 증가하고 있다.\n네이티브 컴파일과 인터프리터 방식 비교 네이티브 컴파일러는 소스 코드를 기계어로 직접 변환하지만, 인터프리터는 코드를 실행 시간에 해석합니다. 다음은 두 접근 방식의 비교입니다:\n특성 네이티브 컴파일 인터프리터 방식 실행 속도 일반적으로 빠름 (사전 최적화) 일반적으로 느림 (실시간 해석) 개발 사이클 컴파일-링크-실행 단계 필요 즉시 실행 가능 (더 빠른 반복) 메모리 사용 최적화된 메모리 사용 인터프리터 오버헤드 발생 플랫폼 의존성 플랫폼별 바이너리 생성 필요 인터프리터만 있으면 실행 가능 배포 컴파일된 바이너리 배포 소스 코드 또는 중간 코드 배포 디버깅 실제 바이너리 디버깅 (복잡할 수 있음) 소스 레벨 디버깅 (보통 더 쉬움) 최적화 수준 높음 (정적 최적화) 제한적 (런타임 최적화) 대표적 언어 C, C++, Rust, Go Python, JavaScript, Ruby 네이티브 컴파일러와 크로스 컴파일러 비교 특성 네이티브 컴파일러 크로스 컴파일러 실행 환경 코드가 실행될 시스템과 동일한 환경에서 실행 호스트 시스템에서 실행, 타겟 시스템용 코드 생성 타겟 플랫폼 컴파일러가 실행되는 것과 동일한 플랫폼 호스트와 다른 아키텍처, OS, CPU 등 설정 복잡성 낮음 (대부분 기본 설정으로 작동) 높음 (타겟 시스템 정보, 라이브러리, 헤더 파일 등 설정 필요) 디버깅 난이도 낮음 (로컬 환경에서 직접 디버깅 가능) 높음 (원격 디버깅 또는 에뮬레이터 필요) 라이브러리 관리 단순함 (호스트 시스템의 라이브러리 사용) 복잡함 (타겟 플랫폼의 라이브러리 필요) 주요 사용 사례 데스크톱 애플리케이션, 로컬 서버 개발 임베디드 시스템, 모바일 앱, 게임 콘솔, IoT 기기 개발 빌드 환경 간단한 컴파일러 설치로 충분 툴체인, sysroot, SDK 등 특별한 환경 설정 필요 성능 최적화 호스트 시스템에 맞는 최적화 자동 적용 타겟 플랫폼에 맞는 특별한 최적화 고려 필요 빌드 속도 빠름 (네이티브 환경에 최적화됨) 일반적으로 느림 (추가적인 설정과 변환 과정 필요) 설치 용이성 높음 (OS에서 기본 제공하거나 쉽게 설치) 낮음 (특수한 설정과 도구 필요) 접근성 높음 (초보 개발자도 쉽게 사용) 낮음 (전문 지식 필요) 참고 및 출처 ","wordCount":"1620","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-14T15:30:00Z","dateModified":"2024-10-14T15:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/native-compiler/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href>Programming Language Theory</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/>컴파일러(Compiler)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/>types of Compiler</a></div><h1 class="post-title entry-hint-parent">Native Compiler</h1><div class=post-description>Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러</div><div class=post-meta><span title='2024-10-14 15:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Programming%20Language%20Theory/Compilation%20and%20Interpretation/Compilation/Compiler/Types/native-compiler.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#native-compiler>Native Compiler</a><ul><li><a href=#네이티브-컴파일러의-정의>네이티브 컴파일러의 정의</a></li><li><a href=#네이티브-컴파일러의-작동-원리>네이티브 컴파일러의 작동 원리</a></li><li><a href=#네이티브-컴파일러의-장점>네이티브 컴파일러의 장점</a></li><li><a href=#네이티브-컴파일러의-주요-종류>네이티브 컴파일러의 주요 종류</a></li><li><a href=#네이티브-컴파일러-사용-예제>네이티브 컴파일러 사용 예제</a></li><li><a href=#네이티브-컴파일러의-최적화-기능>네이티브 컴파일러의 최적화 기능</a></li><li><a href=#네이티브-컴파일러와-빌드-시스템>네이티브 컴파일러와 빌드 시스템</a></li><li><a href=#네이티브-컴파일러의-발전-동향>네이티브 컴파일러의 발전 동향</a></li><li><a href=#네이티브-컴파일러-관련-고급-개념>네이티브 컴파일러 관련 고급 개념</a></li><li><a href=#네이티브-컴파일과-인터프리터-방식-비교>네이티브 컴파일과 인터프리터 방식 비교</a></li><li><a href=#네이티브-컴파일러와-크로스-컴파일러-비교>네이티브 컴파일러와 크로스 컴파일러 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=native-compiler>Native Compiler<a hidden class=anchor aria-hidden=true href=#native-compiler>#</a></h2><p>Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.</p><p>네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.</p><p>다양한 최적화 기능, 디버깅 도구와의 통합, 빌드 시스템과의 연계를 통해 개발자는 효율적인 코드를 작성하고 테스트할 수 있다. 특히 GCC, Clang, Visual C++ 등 주요 네이티브 컴파일러는 지속적인 발전을 통해 더 나은 성능과 개발자 경험을 제공하고 있다.</p><p>최근에는 모듈식 아키텍처, 병렬 컴파일, 머신 러닝 기반 최적화 등 다양한 기술적 발전이 이루어지고 있으며, 이는 더 빠른 컴파일 시간과 더 효율적인 코드 생성으로 이어지고 있다. 또한 크로스 컴파일러와의 기술 공유를 통해 다양한 플랫폼 지원도 강화되고 있다.</p><h3 id=네이티브-컴파일러의-정의>네이티브 컴파일러의 정의<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-정의>#</a></h3><p>네이티브 컴파일러는 코드가 실행될 예정인 것과 동일한 컴퓨팅 환경(동일한 운영체제, 프로세서 아키텍처)에서 실행되는 컴파일러이다.<br>간단히 말해, 소스 코드를 컴파일하는 시스템과 컴파일된 프로그램이 실행될 시스템이 같은 경우에 사용하는 컴파일러이다. 예를 들어, x86_64 아키텍처의 Linux 시스템에서 실행되는 컴파일러가 같은 x86_64 Linux 시스템에서 실행될 바이너리를 생성한다면, 이는 네이티브 컴파일러이다.</p><h3 id=네이티브-컴파일러의-작동-원리>네이티브 컴파일러의 작동 원리<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-작동-원리>#</a></h3><p>네이티브 컴파일러의 기본 작동 과정은 다음과 같다:</p><ol><li><strong>전처리(Preprocessing)</strong>: 소스 코드의 전처리 지시문(<code>#include</code>, <code>#define</code> 등) 처리 및 매크로 확장</li><li><strong>컴파일(Compilation)</strong>: 소스 코드를 현재 플랫폼에 맞는 어셈블리어로 변환</li><li><strong>어셈블(Assembly)</strong>: 어셈블리 코드를 현재 플랫폼의 기계어로 변환</li><li><strong>링킹(Linking)</strong>: 현재 시스템의 라이브러리와 목적 파일들을 연결하여 최종 실행 파일 생성</li></ol><p>이 과정에서 컴파일러는 현재 시스템의 명령어 세트 아키텍처(ISA), 메모리 모델, 바이트 순서(endianness), ABI(Application Binary Interface) 등을 자동으로 고려한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[소스 코드] → [전처리기] → [컴파일러] → [어셈블러] → [링커] → [실행 파일]
</span></span></code></pre></td></tr></table></div></div><h3 id=네이티브-컴파일러의-장점>네이티브 컴파일러의 장점<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-장점>#</a></h3><ol><li><p>간편한 설정<br>추가적인 설정이나 툴체인 없이 기본 환경에서 즉시 사용 가능하다.<br>대부분의 운영체제는 해당 시스템에 최적화된 컴파일러를 기본적으로 제공하거나 쉽게 설치할 수 있다.</p></li><li><p>직접적인 디버깅<br>컴파일된 프로그램이 동일한 환경에서 실행되므로, 디버깅 과정이 간단하고 직관적이다.<br>로컬 디버거를 사용하여 실시간으로 코드 실행을 분석할 수 있다.</p></li><li><p>최적화된 성능<br>현재 시스템의 아키텍처와 특성을 정확히 파악하여 최적화된 코드를 생성할 수 있다.<br>프로세서 특화 명령어 세트나 하드웨어 기능을 활용한 최적화가 가능하다.</p></li><li><p>라이브러리 호환성<br>현재 시스템의 라이브러리를 직접 활용할 수 있어, 라이브러리 의존성 관리가 단순하다.</p></li></ol><h3 id=네이티브-컴파일러의-주요-종류>네이티브 컴파일러의 주요 종류<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-주요-종류>#</a></h3><ol><li><p>GCC (GNU Compiler Collection)<br>오픈 소스 컴파일러 모음으로, C, C++, Fortran, Ada 등 다양한 언어를 지원한다.<br>Linux, macOS, Windows(MinGW) 등 여러 플랫폼에서 사용 가능하다.</p></li><li><p>Clang/LLVM<br>모듈식 컴파일러 인프라로, C, C++, Objective-C 등을 지원한다. Apple 제품에서 기본 컴파일러로 사용되며, 뛰어난 에러 메시지와 정적 분석 도구를 제공합니다.</p></li><li><p>Microsoft Visual C++ 컴파일러<br>Windows 환경에서 C/C++ 개발을 위한 마이크로소프트의 네이티브 컴파일러로, Visual Studio IDE와 통합되어 있다.</p></li><li><p>인텔 C++ 컴파일러<br>인텔 프로세서에 최적화된 성능을 제공하는 상용 컴파일러이다.</p></li><li><p>Oracle Solaris Studio<br>Solaris, Linux 환경에서 C, C++, Fortran을 지원하는 Oracle의 컴파일러 제품군이다.</p></li></ol><h4 id=주요-네이티브-컴파일러-비교>주요 네이티브 컴파일러 비교<a hidden class=anchor aria-hidden=true href=#주요-네이티브-컴파일러-비교>#</a></h4><table><thead><tr><th>컴파일러</th><th>지원 플랫폼</th><th>지원 언어</th><th>최적화 수준</th><th>특징</th><th>라이센스</th><th>주요 사용 환경</th></tr></thead><tbody><tr><td><strong>GCC</strong></td><td>Linux, macOS, Windows(MinGW), 다양한 유닉스 계열</td><td>C, C++, Fortran, Ada, Go 등</td><td>높음</td><td>광범위한 플랫폼 지원, 많은 최적화 옵션</td><td>GPL</td><td>오픈소스 프로젝트, 리눅스 개발</td></tr><tr><td><strong>Clang/LLVM</strong></td><td>Linux, macOS, Windows</td><td>C, C++, Objective-C</td><td>높음</td><td>우수한 진단 메시지, 모듈식 설계</td><td>Apache 2.0</td><td>macOS/iOS 개발, 정적 분석 도구</td></tr><tr><td><strong>Microsoft Visual C++</strong></td><td>Windows</td><td>C, C++</td><td>높음</td><td>Visual Studio와 통합, Windows API 지원</td><td>상용</td><td>Windows 애플리케이션 개발</td></tr><tr><td><strong>Intel C++ Compiler</strong></td><td>Linux, macOS, Windows</td><td>C, C++</td><td>매우 높음</td><td>Intel 프로세서 최적화</td><td>상용</td><td>고성능 컴퓨팅, 과학 계산</td></tr><tr><td><strong>Oracle Solaris Studio</strong></td><td>Solaris, Linux</td><td>C, C++, Fortran</td><td>높음</td><td>SPARC 및 x86 최적화</td><td>상용/무료 등록</td><td>엔터프라이즈 애플리케이션</td></tr><tr><td><strong>IBM XL C/C++</strong></td><td>AIX, Linux</td><td>C, C++</td><td>높음</td><td>IBM Power 아키텍처 최적화</td><td>상용</td><td>엔터프라이즈 시스템, 슈퍼컴퓨터</td></tr><tr><td><strong>PGI Compiler</strong></td><td>Linux, macOS, Windows</td><td>C, C++, Fortran</td><td>높음</td><td>HPC 및 GPU 컴퓨팅 최적화</td><td>상용</td><td>과학 계산, 병렬 컴퓨팅</td></tr><tr><td><strong>Arm Compiler</strong></td><td>Linux, Windows</td><td>C, C++</td><td>높음</td><td>Arm 프로세서 최적화</td><td>상용</td><td>Arm 기반 시스템 개발</td></tr><tr><td><strong>TinyCC (TCC)</strong></td><td>Linux, Windows</td><td>C</td><td>낮음</td><td>컴파일 속도 매우 빠름, 작은 크기</td><td>LGPL</td><td>스크립트 통합, 빠른 컴파일 필요 시</td></tr><tr><td><strong>Digital Mars C/C++</strong></td><td>Windows</td><td>C, C++</td><td>중간</td><td>빠른 컴파일, 작은 실행 파일</td><td>무료/상용</td><td>윈도우 개발</td></tr></tbody></table><h3 id=네이티브-컴파일러-사용-예제>네이티브 컴파일러 사용 예제<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러-사용-예제>#</a></h3><ol><li><p>GCC를 사용한 C 프로그램 컴파일</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span><span class=lnt id=hl-1-13><a class=lnlinks href=#hl-1-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 간단한 C 프로그램 작성</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;#include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=s1>int main() {
</span></span></span><span class=line><span class=cl><span class=s1>    printf(&#34;Hello, Native Compiler!\n&#34;);
</span></span></span><span class=line><span class=cl><span class=s1>    return 0;
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> &gt; hello.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 컴파일</span>
</span></span><span class=line><span class=cl>gcc -o hello hello.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행</span>
</span></span><span class=line><span class=cl>./hello
</span></span><span class=line><span class=cl><span class=c1># 출력: Hello, Native Compiler!</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Clang을 사용한 C++ 프로그램 컴파일</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># C++ 프로그램 작성</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;#include &lt;iostream&gt;
</span></span></span><span class=line><span class=cl><span class=s1>int main() {
</span></span></span><span class=line><span class=cl><span class=s1>    std::cout &lt;&lt; &#34;Compiled with Clang&#34; &lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=s1>    return 0;
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> &gt; hello.cpp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Clang으로 컴파일</span>
</span></span><span class=line><span class=cl>clang++ -o hello_clang hello.cpp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행</span>
</span></span><span class=line><span class=cl>./hello_clang
</span></span><span class=line><span class=cl><span class=c1># 출력: Compiled with Clang</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Visual C++를 사용한 Windows 애플리케이션 컴파일 (명령줄)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cmd data-lang=cmd><span class=line><span class=cl><span class=c1>REM 명령 프롬프트에서 Visual C++ 환경 설정</span>
</span></span><span class=line><span class=cl><span class=k>call</span> <span class=s2>&#34;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>REM C++ 파일 생성</span>
</span></span><span class=line><span class=cl><span class=k>echo</span> #include <span class=p>&lt;</span>iostream<span class=p>&gt;</span> &gt; hello.cpp
</span></span><span class=line><span class=cl><span class=k>echo</span> int main() { <span class=p>&gt;&gt;</span> hello.cpp
</span></span><span class=line><span class=cl><span class=k>echo</span>     std::cout <span class=p>&lt;</span>&lt; <span class=s2>&#34;Compiled with MSVC&#34;</span> <span class=p>&lt;</span>&lt; std::endl; <span class=p>&gt;&gt;</span> hello.cpp
</span></span><span class=line><span class=cl><span class=k>echo</span>     return 0; <span class=p>&gt;&gt;</span> hello.cpp
</span></span><span class=line><span class=cl><span class=k>echo</span> } <span class=p>&gt;&gt;</span> hello.cpp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>REM 컴파일</span>
</span></span><span class=line><span class=cl>cl /EHsc hello.cpp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>REM 실행</span>
</span></span><span class=line><span class=cl>hello.exe
</span></span><span class=line><span class=cl><span class=c1>REM 출력: Compiled with MSVC</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=네이티브-컴파일러의-최적화-기능>네이티브 컴파일러의 최적화 기능<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-최적화-기능>#</a></h3><h4 id=컴파일러-최적화-레벨>컴파일러 최적화 레벨<a hidden class=anchor aria-hidden=true href=#컴파일러-최적화-레벨>#</a></h4><p>대부분의 네이티브 컴파일러는 다양한 최적화 레벨을 제공한다:</p><ul><li><strong>-O0</strong>: 최적화 없음 (디버깅에 유용)</li><li><strong>-O1</strong>: 기본 최적화</li><li><strong>-O2</strong>: 더 강력한 최적화 (일반적으로 권장됨)</li><li><strong>-O3</strong>: 최대 최적화 (실행 속도 중심)</li><li><strong>-Os</strong>: 크기 최적화 (실행 파일 크기 축소)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># GCC로 최적화 수준 지정 예</span>
</span></span><span class=line><span class=cl>gcc -O2 -o optimized_program source.c
</span></span></code></pre></td></tr></table></div></div><h4 id=프로파일-기반-최적화pgo>프로파일 기반 최적화(PGO)<a hidden class=anchor aria-hidden=true href=#프로파일-기반-최적화pgo>#</a></h4><p>프로그램의 실제 실행 패턴을 분석하여 최적화하는 기능이다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># GCC PGO 예제</span>
</span></span><span class=line><span class=cl><span class=c1># 1. 프로파일 정보 생성을 위한 컴파일</span>
</span></span><span class=line><span class=cl>gcc -fprofile-generate -o program source.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 프로그램 실행하여 프로파일 데이터 수집</span>
</span></span><span class=line><span class=cl>./program
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 수집된 프로파일을 기반으로 최종 컴파일</span>
</span></span><span class=line><span class=cl>gcc -fprofile-use -o optimized_program source.c
</span></span></code></pre></td></tr></table></div></div><h4 id=자동-벡터화>자동 벡터화<a hidden class=anchor aria-hidden=true href=#자동-벡터화>#</a></h4><p>SIMD(Single Instruction, Multiple Data) 명령어를 자동으로 사용하여 성능을 향상시키는 기능이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># GCC 자동 벡터화 예제</span>
</span></span><span class=line><span class=cl>gcc -O3 -ftree-vectorize -o vectorized_program source.c
</span></span></code></pre></td></tr></table></div></div><h4 id=링크-시간-최적화lto>링크 시간 최적화(LTO)<a hidden class=anchor aria-hidden=true href=#링크-시간-최적화lto>#</a></h4><p>컴파일 단위 간의 전역 최적화를 수행하는 기능이다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># GCC LTO 예제</span>
</span></span><span class=line><span class=cl>gcc -flto -o lto_program source1.c source2.c
</span></span></code></pre></td></tr></table></div></div><h3 id=네이티브-컴파일러와-빌드-시스템>네이티브 컴파일러와 빌드 시스템<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러와-빌드-시스템>#</a></h3><h4 id=make>Make<a hidden class=anchor aria-hidden=true href=#make>#</a></h4><p>가장 기본적인 빌드 자동화 도구로, 의존성 트리를 기반으로 필요한 파일만 재컴파일한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># Makefile 예제
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>CC</span> <span class=o>=</span> gcc
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>=</span> -Wall -O2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>program</span><span class=o>:</span> <span class=n>main</span>.<span class=n>o</span> <span class=n>utils</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -o program main.o utils.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>main.o</span><span class=o>:</span> <span class=n>main</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c main.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>utils.o</span><span class=o>:</span> <span class=n>utils</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>	<span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c utils.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	rm -f *.o program
</span></span></code></pre></td></tr></table></div></div><h4 id=cmake>CMake<a hidden class=anchor aria-hidden=true href=#cmake>#</a></h4><p>크로스 플랫폼 빌드 시스템 생성기로, 다양한 네이티브 컴파일러와 통합된다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=c># CMakeLists.txt 예제
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>cmake_minimum_required</span><span class=p>(</span><span class=s>VERSION</span> <span class=s>3.10</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>project</span><span class=p>(</span><span class=s>MyProject</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_CXX_STANDARD</span> <span class=s>17</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>add_executable</span><span class=p>(</span><span class=s>program</span> <span class=s>main.cpp</span> <span class=s>utils.cpp</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># CMake 사용</span>
</span></span><span class=line><span class=cl>mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build
</span></span><span class=line><span class=cl>cmake ..
</span></span><span class=line><span class=cl>make
</span></span></code></pre></td></tr></table></div></div><h4 id=ninja>Ninja<a hidden class=anchor aria-hidden=true href=#ninja>#</a></h4><p>빠른 속도에 최적화된 빌드 시스템이다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># CMake와 Ninja 함께 사용</span>
</span></span><span class=line><span class=cl>mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build
</span></span><span class=line><span class=cl>cmake -G Ninja ..
</span></span><span class=line><span class=cl>ninja
</span></span></code></pre></td></tr></table></div></div><h4 id=bazel>Bazel<a hidden class=anchor aria-hidden=true href=#bazel>#</a></h4><p>구글에서 개발한 대규모 프로젝트를 위한 빌드 시스템입니다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># BUILD 파일 예제</span>
</span></span><span class=line><span class=cl><span class=n>cc_binary</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;program&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>srcs</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;main.cpp&#34;</span><span class=p>,</span> <span class=s2>&#34;utils.cpp&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>copts</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;-Wall&#34;</span><span class=p>,</span> <span class=s2>&#34;-O2&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=네이티브-컴파일러의-발전-동향>네이티브 컴파일러의 발전 동향<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-발전-동향>#</a></h3><ol><li><p>모듈식 컴파일러 아키텍처<br>LLVM과 같은 모듈식 컴파일러 인프라가 인기를 얻고 있으며, 프론트엔드와 백엔드를 분리하여 다양한 언어와 타겟을 지원한다.</p></li><li><p>JIT(Just-In-Time) 컴파일 통합<br>정적 컴파일과 JIT 컴파일을 결합한 하이브리드 접근 방식이 등장하고 있다.</p></li><li><p>머신 러닝 기반 최적화<br>컴파일러 최적화에 머신 러닝 기술을 적용하여 코드 성능을 향상시키는 연구가 진행 중이다.</p></li><li><p>병렬 컴파일<br>멀티코어 프로세서를 활용한 병렬 컴파일로 빌드 시간을 단축하는 기능이 발전하고 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># GCC 병렬 컴파일 예제</span>
</span></span><span class=line><span class=cl>make -j8  <span class=c1># 8개 코어 활용</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=네이티브-컴파일러-관련-고급-개념>네이티브 컴파일러 관련 고급 개념<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러-관련-고급-개념>#</a></h3><ol><li><p>컴파일러 확장과 내장 함수<br>많은 네이티브 컴파일러는 표준을 넘어서는 확장 기능과 최적화된 내장 함수를 제공한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// GCC 내장 함수 예제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>count_bits</span> <span class=o>=</span> <span class=nf>__builtin_popcount</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>  <span class=c1>// 비트 카운팅 최적화
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>인라인 어셈블리<br>성능 최적화나 하드웨어 접근을 위해 C/C++ 코드 내에 어셈블리 코드를 직접 작성할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// x86 인라인 어셈블리 예제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>,</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>asm</span> <span class=p>(</span><span class=s>&#34;addl %1, %2</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>     <span class=s>&#34;movl %2, %0&#34;</span>
</span></span><span class=line><span class=cl>     <span class=o>:</span> <span class=s>&#34;=r&#34;</span> <span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=o>:</span> <span class=s>&#34;r&#34;</span> <span class=p>(</span><span class=n>a</span><span class=p>),</span> <span class=s>&#34;r&#34;</span> <span class=p>(</span><span class=n>b</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>링커 스크립트<br>링킹 과정을 세밀하게 제어하여 메모리 레이아웃을 사용자가 정의할 수 있다. 이는 임베디드 시스템이나 운영체제 개발에서 중요하다.</p></li><li><p>교차 언어 최적화<br>다양한 프로그래밍 언어로 작성된 코드 간의 최적화를 지원하는 컴파일러가 증가하고 있다.</p></li></ol><h3 id=네이티브-컴파일과-인터프리터-방식-비교>네이티브 컴파일과 인터프리터 방식 비교<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일과-인터프리터-방식-비교>#</a></h3><p>네이티브 컴파일러는 소스 코드를 기계어로 직접 변환하지만, 인터프리터는 코드를 실행 시간에 해석합니다. 다음은 두 접근 방식의 비교입니다:</p><table><thead><tr><th>특성</th><th>네이티브 컴파일</th><th>인터프리터 방식</th></tr></thead><tbody><tr><td><strong>실행 속도</strong></td><td>일반적으로 빠름 (사전 최적화)</td><td>일반적으로 느림 (실시간 해석)</td></tr><tr><td><strong>개발 사이클</strong></td><td>컴파일-링크-실행 단계 필요</td><td>즉시 실행 가능 (더 빠른 반복)</td></tr><tr><td><strong>메모리 사용</strong></td><td>최적화된 메모리 사용</td><td>인터프리터 오버헤드 발생</td></tr><tr><td><strong>플랫폼 의존성</strong></td><td>플랫폼별 바이너리 생성 필요</td><td>인터프리터만 있으면 실행 가능</td></tr><tr><td><strong>배포</strong></td><td>컴파일된 바이너리 배포</td><td>소스 코드 또는 중간 코드 배포</td></tr><tr><td><strong>디버깅</strong></td><td>실제 바이너리 디버깅 (복잡할 수 있음)</td><td>소스 레벨 디버깅 (보통 더 쉬움)</td></tr><tr><td><strong>최적화 수준</strong></td><td>높음 (정적 최적화)</td><td>제한적 (런타임 최적화)</td></tr><tr><td><strong>대표적 언어</strong></td><td>C, C++, Rust, Go</td><td>Python, JavaScript, Ruby</td></tr></tbody></table><h3 id=네이티브-컴파일러와-크로스-컴파일러-비교>네이티브 컴파일러와 크로스 컴파일러 비교<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러와-크로스-컴파일러-비교>#</a></h3><table><thead><tr><th>특성</th><th>네이티브 컴파일러</th><th>크로스 컴파일러</th></tr></thead><tbody><tr><td><strong>실행 환경</strong></td><td>코드가 실행될 시스템과 동일한 환경에서 실행</td><td>호스트 시스템에서 실행, 타겟 시스템용 코드 생성</td></tr><tr><td><strong>타겟 플랫폼</strong></td><td>컴파일러가 실행되는 것과 동일한 플랫폼</td><td>호스트와 다른 아키텍처, OS, CPU 등</td></tr><tr><td><strong>설정 복잡성</strong></td><td>낮음 (대부분 기본 설정으로 작동)</td><td>높음 (타겟 시스템 정보, 라이브러리, 헤더 파일 등 설정 필요)</td></tr><tr><td><strong>디버깅 난이도</strong></td><td>낮음 (로컬 환경에서 직접 디버깅 가능)</td><td>높음 (원격 디버깅 또는 에뮬레이터 필요)</td></tr><tr><td><strong>라이브러리 관리</strong></td><td>단순함 (호스트 시스템의 라이브러리 사용)</td><td>복잡함 (타겟 플랫폼의 라이브러리 필요)</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>데스크톱 애플리케이션, 로컬 서버 개발</td><td>임베디드 시스템, 모바일 앱, 게임 콘솔, IoT 기기 개발</td></tr><tr><td><strong>빌드 환경</strong></td><td>간단한 컴파일러 설치로 충분</td><td>툴체인, sysroot, SDK 등 특별한 환경 설정 필요</td></tr><tr><td><strong>성능 최적화</strong></td><td>호스트 시스템에 맞는 최적화 자동 적용</td><td>타겟 플랫폼에 맞는 특별한 최적화 고려 필요</td></tr><tr><td><strong>빌드 속도</strong></td><td>빠름 (네이티브 환경에 최적화됨)</td><td>일반적으로 느림 (추가적인 설정과 변환 과정 필요)</td></tr><tr><td><strong>설치 용이성</strong></td><td>높음 (OS에서 기본 제공하거나 쉽게 설치)</td><td>낮음 (특수한 설정과 도구 필요)</td></tr><tr><td><strong>접근성</strong></td><td>높음 (초보 개발자도 쉽게 사용)</td><td>낮음 (전문 지식 필요)</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/native-compiler/>Native-Compiler</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/simple-sorts/bubble-sort/><span class=title>« Prev</span><br><span>버블 정렬 (Bubble Sort)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/sorting-algorithms/><span class=title>Next »</span><br><span>정렬 알고리즘 (Sorting Algorithms)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>