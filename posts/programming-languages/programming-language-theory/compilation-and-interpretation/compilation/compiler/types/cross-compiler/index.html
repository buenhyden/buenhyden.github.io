<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cross Compiler | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Compiler,Types,Cross-Compiler"><meta name=description content="크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/cross-compiler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/cross-compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/cross-compiler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Cross Compiler"><meta property="og:description" content="크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-14T15:29:00+00:00"><meta property="article:modified_time" content="2024-10-14T15:29:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="Types"><meta property="article:tag" content="Cross-Compiler"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Cross Compiler"><meta name=twitter:description content="크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Programming Language Theory","item":""},{"@type":"ListItem","position":6,"name":"컴파일러(Compiler)","item":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/"},{"@type":"ListItem","position":7,"name":"types of Compiler","item":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/"},{"@type":"ListItem","position":8,"name":"Cross Compiler","item":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/cross-compiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cross Compiler","name":"Cross Compiler","description":"크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러","keywords":["Programming-Languages","Fundamentals","Compiler","Types","Cross-Compiler"],"articleBody":"Cross Compiler 크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러이다. 이는 임베디드 시스템이나 운영체제 개발처럼 대상 시스템이 컴파일러를 직접 실행하기에 부적합한 경우에 자주 사용되며, 한 개발 환경에서 여러 플랫폼용 소프트웨어를 동시에 개발할 수 있게 해준다.\n크로스 컴파일러는 소프트웨어 개발의 다양한 분야, 특히 임베디드 시스템, 모바일 애플리케이션, 게임 콘솔, IoT 기기 개발에서 필수적인 도구이다. 이 기술은 개발자가 한 시스템에서 개발하면서 다양한 타겟 플랫폼용 코드를 생성할 수 있게 해준다.\n복잡한 설정과 추가적인 도구가 필요하지만, 크로스 컴파일러의 사용은 다양한 하드웨어와 소프트웨어 환경을 지원하는 현대적인 소프트웨어 개발에 있어 필수적이다. 특히 제한된 컴퓨팅 자원을 가진 임베디드 시스템이나 IoT 기기와 같은 환경에서는 크로스 컴파일러가 없다면 효율적인 개발이 거의 불가능할 것이다.\nLLVM과 같은 모듈식 컴파일러 인프라의 발전, 컨테이너 기술을 활용한 빌드 환경의 간소화, 클라우드 기반 빌드 서비스 등의 등장으로 크로스 컴파일 환경은 점점 더 접근성이 높아지고 있다.\n크로스 컴파일러의 정의 크로스 컴파일러는 한 컴퓨팅 환경(호스트 플랫폼)에서 실행되지만, 생성된 실행 파일은 다른 컴퓨팅 환경(타겟 플랫폼)에서 실행되도록 설계된 특수한 컴파일러이다.\n일반 컴파일러와 달리, 크로스 컴파일러는 소스 코드를 호스트 시스템과 다른 아키텍처, 운영체제, 또는 CPU를 가진 타겟 시스템에서 실행할 수 있는 바이너리로 변환한다.\n크로스 컴파일러의 주요 특징 Host System vs. Target System\nHost System (호스트 시스템): 컴파일이 수행되는 환경 Target System (타겟 시스템): 컴파일된 실행 파일이 실행될 환경\n크로스 컴파일러는 호스트 시스템에서 타겟 시스템에 맞는 실행 파일을 생성한다. 크로스 컴파일 과정\n크로스 컴파일을 위해서는 다음과 같은 요소들이 필요하다.\n크로스 컴파일러: 타겟 시스템용 바이너리를 생성할 수 있는 컴파일러 (예: arm-linux-gcc) 라이브러리 및 헤더 파일: 타겟 시스템에서 사용하는 라이브러리 (예: glibc, musl) 링커 및 빌드 도구: 타겟 시스템용 실행 파일을 생성하는 도구 (ld, make, CMake 등) 크로스 컴파일러의 작동 원리 크로스 컴파일러의 작동 과정은 다음과 같다:\n전처리(Preprocessing): 소스 코드의 전처리 지시문 처리 및 매크로 확장 컴파일(Compilation): 소스 코드를 타겟 플랫폼에 맞는 어셈블리어로 변환 어셈블(Assembly): 어셈블리 코드를 타겟 플랫폼의 기계어로 변환 링킹(Linking): 타겟 플랫폼에 맞는 라이브러리와 목적 파일들을 연결하여 최종 실행 파일 생성 이 과정에서 컴파일러는 타겟 시스템의 명령어 세트 아키텍처(ISA), 메모리 모델, 바이트 순서(endianness), ABI(Application Binary Interface) 등을 고려한다.\n1 [소스 코드] → [전처리기] → [컴파일러] → [어셈블러] → [링커] → [타겟 실행 파일] 크로스 컴파일러의 필요성과 활용 분야 임베디드 시스템 개발\n임베디드 디바이스는 일반적으로 저전력, 제한된 자원을 가지고 있어 자체적으로 코드를 컴파일하기에 적합하지 않다. 따라서 PC에서 크로스 컴파일러를 사용하여 코드를 컴파일한 후, 결과물을 임베디드 시스템에 배포한다.\n모바일 애플리케이션 개발\nAndroid, iOS 애플리케이션을 개발할 때, 개발자는 자신의 PC에서 코드를 작성하고 크로스 컴파일하여 모바일 디바이스에서 실행 가능한 앱을 생성한다.\n다양한 플랫폼 지원\n멀티플랫폼 소프트웨어를 개발할 때, 크로스 컴파일러를 사용하여 하나의 소스 코드를 여러 타겟 플랫폼(Windows, macOS, Linux, 다양한 CPU 아키텍처 등)에서 실행 가능한 바이너리로 컴파일할 수 있다.\n게임 콘솔 개발\nPlayStation, Xbox, Nintendo Switch 등의 게임 콘솔용 소프트웨어 개발 시 크로스 컴파일러가 필수적이다.\nIoT(사물인터넷) 기기 개발\n다양한 IoT 기기들은 제한된 컴퓨팅 능력을 가지고 있어, PC에서 크로스 컴파일된 코드를 사용한다.\n크로스 컴파일 환경 구축 크로스 컴파일 환경을 구축하는 데는 다음과 같은 요소들이 필요하다:\n크로스 컴파일러 툴체인\n타겟 플랫폼에 맞는 컴파일러, 어셈블러, 링커 등의 도구 모음.\n1 2 # ARM 아키텍처용 GCC 크로스 컴파일러 설치 예(Ubuntu) sudo apt-get install gcc-arm-linux-gnueabi 타겟 플랫폼의 라이브러리 및 헤더 파일\n타겟 시스템의 표준 라이브러리와 헤더 파일들이 필요하다. 이를 “sysroot\"라고도 한다.\n1 2 # ARM용 라이브러리 및 헤더 설치 예 sudo apt-get install libc6-dev-armel-cross 빌드 시스템 설정\nCMake, Autotools, Make 등의 빌드 시스템을 크로스 컴파일을 위해 설정해야 한다.\n1 2 3 4 5 # CMake에서 크로스 컴파일 설정 예 set(CMAKE_SYSTEM_NAME Linux) set(CMAKE_SYSTEM_PROCESSOR arm) set(CMAKE_C_COMPILER arm-linux-gnueabi-gcc) set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++) 통합 개발 환경(IDE) 설정\n많은 IDE는 크로스 컴파일을 위한 설정 옵션을 제공한다.\n크로스 컴파일러의 종류 GCC 크로스 컴파일러\nGNU Compiler Collection(GCC)는 다양한 프로그래밍 언어와 타겟 플랫폼을 지원하는 대표적인 크로스 컴파일러이다. 예를 들어, arm-linux-gnueabi-gcc는 ARM 프로세서용 리눅스 시스템을 타겟으로 한다.\nLLVM/Clang\nLLVM 프로젝트의 Clang 컴파일러는 모듈식 설계로 다양한 타겟 플랫폼을 지원한다. 특히 Apple 생태계(iOS, macOS)와의 통합이 뛰어나다.\nMicrosoft Visual C++ 크로스 컴파일러\nWindows 플랫폼에서 다양한 아키텍처(x86, x64, ARM, ARM64 등)를 타겟으로 하는 크로스 컴파일러를 제공한다.\n인텔 C++ 컴파일러\n인텔 프로세서 최적화에 특화된 크로스 컴파일러로, 다양한 플랫폼을 지원한다.\n특정 임베디드 시스템용 컴파일러\n특정 마이크로컨트롤러나 임베디드 시스템을 위한 전용 크로스 컴파일러도 존재한다(예: 아두이노 IDE의 AVR GCC, TI의 Code Composer Studio 등).\n크로스 컴파일러 툴체인 비교 툴체인 주요 대상 플랫폼 지원 언어 특징 라이센스 주요 사용 분야 GCC 크로스 컴파일러 ARM, MIPS, PowerPC, x86, RISC-V 등 다양한 아키텍처 C, C++, Fortran, Ada, D 등 광범위한 타겟 지원, 오픈소스 커뮤니티 GPL 임베디드 리눅스, 오픈소스 프로젝트 LLVM/Clang x86, ARM, AArch64, MIPS, PowerPC, WebAssembly 등 C, C++, Objective-C, Swift, Rust 등 모듈식 설계, 최적화 기능, Apple 생태계 통합 Apache 2.0 iOS/macOS 앱, WebAssembly, 크로스 플랫폼 앱 Android NDK ARM, ARM64, x86, x86_64 (Android 기기) C, C++ Google 제공, Android 앱 개발 최적화 혼합 라이센스 Android 네이티브 앱, 게임 개발 Microsoft Visual C++ Cross x86, x64, ARM, ARM64 (Windows 플랫폼) C, C++ Windows 생태계 통합, 강력한 IDE 지원 상용 라이센스 Windows 데스크톱/모바일/IoT 앱 Xcode 툴체인 ARM64 (iOS, watchOS, tvOS), x86_64/ARM64 (macOS) C, C++, Objective-C, Swift Apple 생태계 최적화, 완벽한 IDE 통합 혼합 라이센스 iOS, macOS 앱 개발 Buildroot ARM, MIPS, PowerPC, x86 등 (임베디드 리눅스) C, C++ 완전한 임베디드 리눅스 시스템 빌드, 자동화 GPL, 혼합 임베디드 리눅스 시스템, IoT 기기 Yocto Project 다양한 임베디드 플랫폼 C, C++, 기타 사용자 정의 리눅스 배포판 생성, 복잡한 설정 가능 MIT, GPL 상업용 임베디드 시스템, IoT 플랫폼 ARM DS-5/Keil MDK ARM 프로세서 (베어메탈, RTOS) C, C++ ARM 공식 지원, 임베디드 최적화 상용 라이센스 ARM 마이크로컨트롤러, 베어메탈 프로그래밍 Emscripten WebAssembly, asm.js (웹 브라우저) C, C++ C/C++ 코드를 웹용으로 컴파일 MIT 웹 기반 애플리케이션, 게임 포팅 MinGW/MinGW-w64 Windows (x86, x64) C, C++ 리눅스에서 Windows 바이너리 생성 혼합 (주로 MIT) 크로스 플랫폼 윈도우 애플리케이션 크로스 컴파일러의 주요 과제와 해결 방법 라이브러리 의존성 관리: 타겟 플랫폼에서 사용 가능한 라이브러리가 호스트 시스템과 다를 수 있다.\n해결 방법:\n정적 링킹 사용 타겟 플랫폼의 라이브러리를 호스트 시스템에 설치 컨테이너 또는 가상 환경 사용 플랫폼 특화 코드 처리: 운영체제 API, 하드웨어 접근 등에서 플랫폼별 차이가 있을 수 있다.\n해결 방법:\n조건부 컴파일 사용 (#ifdef, #if defined 등) 플랫폼 추상화 레이어 구현 크로스 플랫폼 라이브러리 활용 디버깅 문제: 타겟 플랫폼에서 실행되는 코드를 호스트 시스템에서 디버깅하는 것은 복잡할 수 있다.\n해결 방법:\n원격 디버깅 설정 에뮬레이터 또는 시뮬레이터 사용 QEMU와 같은 하드웨어 가상화 도구 사용 성능 최적화: 타겟 플랫폼의 특성에 맞는 최적화가 필요하다.\n해결 방법:\n타겟 특화 컴파일러 플래그 사용 프로파일 기반 최적화(PGO) 활용 타겟 아키텍처별 어셈블리 코드 제공 크로스 컴파일러 사용 예제 GCC를 사용한 ARM 타겟 크로스 컴파일 예제\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 간단한 C 프로그램 작성 echo '#include int main() { printf(\"Hello from ARM!\\n\"); return 0; }' \u003e hello.c # ARM용으로 크로스 컴파일 arm-linux-gnueabi-gcc -o hello_arm hello.c # 결과 확인 file hello_arm # 출력: hello_arm: ELF 32-bit LSB executable, ARM, version 1 (SYSV), dynamically linked, … CMake를 사용한 크로스 컴파일 프로젝트 설정\n1 2 3 4 5 6 7 8 9 # 크로스 컴파일 설정 파일 (arm-linux.cmake) set(CMAKE_SYSTEM_NAME Linux) set(CMAKE_SYSTEM_PROCESSOR arm) set(CMAKE_C_COMPILER arm-linux-gnueabi-gcc) set(CMAKE_CXX_COMPILER arm-linux-gnueabi-g++) set(CMAKE_FIND_ROOT_PATH /usr/arm-linux-gnueabi) set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) 1 2 3 4 # CMake를 사용한 빌드 mkdir build \u0026\u0026 cd build cmake -DCMAKE_TOOLCHAIN_FILE=../arm-linux.cmake .. make Docker를 활용한 크로스 컴파일 환경\n1 2 3 4 5 6 7 8 9 10 11 # Dockerfile FROM ubuntu:20.04 RUN apt-get update \u0026\u0026 apt-get install -y \\ gcc-arm-linux-gnueabi \\ g++-arm-linux-gnueabi \\ libc6-dev-armel-cross \\ make \\ cmake WORKDIR /src 1 2 3 # Docker 컨테이너에서 크로스 컴파일 docker build -t arm-cross-compiler . docker run -v $(pwd):/src arm-cross-compiler arm-linux-gnueabi-gcc -o hello_arm hello.c 크로스 컴파일러와 관련 기술 에뮬레이터와 시뮬레이터\nQEMU, Bochs 등의 에뮬레이터는 타겟 하드웨어를 소프트웨어적으로 모방하여 크로스 컴파일된 코드를 호스트 시스템에서 테스트할 수 있게 해준다.\n가상화 기술\nVMware, VirtualBox, Hyper-V 등의 가상화 솔루션은 다양한 운영체제 환경을 시뮬레이션하여 크로스 컴파일러와 함께 사용될 수 있다.\n컨테이너화\nDocker, Podman 등의 컨테이너 기술은 크로스 컴파일 환경을 간편하게 구축하고 공유할 수 있게 해준다.\n웹어셈블리(WebAssembly)\n다양한 언어로 작성된 코드를 웹 브라우저에서 실행할 수 있는 바이너리 형식으로 변환하는 크로스 컴파일 기술이다.\n크로스 컴파일러의 발전 동향 LLVM 기반 컴파일러의 확산\n모듈화된 아키텍처와 다양한 프론트엔드/백엔드 지원으로 LLVM 기반 컴파일러의 인기가 높아지고 있다.\n클라우드 기반 크로스 컴파일\n원격 빌드 서비스를 통해 다양한 타겟 플랫폼에 대한 크로스 컴파일 환경을 제공하는 클라우드 서비스가 등장하고 있다.\n9.3 자동화된 크로스 컴파일 도구\nBuildroot, Yocto Project와 같은 도구는 복잡한 임베디드 시스템을 위한, 자동화된 크로스 컴파일 환경을 제공한다.\n컨테이너 기반 크로스 컴파일 환경\nDocker, Podman 등의 컨테이너 기술은 크로스 컴파일 환경을 쉽게 구축하고 공유할 수 있게 한다.\n크로스 컴파일러와 일반 컴파일러 비교 다음은 크로스 컴파일러와 일반(네이티브) 컴파일러의 주요 특징을 비교한 표.\n특성 크로스 컴파일러 일반(네이티브) 컴파일러 실행 환경 호스트 시스템에서 실행, 타겟 시스템용 코드 생성 코드가 실행될 시스템과 동일한 환경에서 실행 타겟 플랫폼 호스트와 다른 아키텍처, OS, CPU 등 컴파일러가 실행되는 것과 동일한 플랫폼 설정 복잡성 높음 (타겟 시스템 정보, 라이브러리, 헤더 파일 등 설정 필요) 낮음 (대부분 기본 설정으로 작동) 디버깅 난이도 높음 (원격 디버깅 또는 에뮬레이터 필요) 낮음 (로컬 환경에서 직접 디버깅 가능) 라이브러리 관리 복잡함 (타겟 플랫폼의 라이브러리 필요) 단순함 (호스트 시스템의 라이브러리 사용) 주요 사용 사례 임베디드 시스템, 모바일 앱, 게임 콘솔, IoT 기기 개발 데스크톱 애플리케이션, 로컬 서버 개발 빌드 환경 툴체인, sysroot, SDK 등 특별한 환경 설정 필요 간단한 컴파일러 설치로 충분 성능 최적화 타겟 플랫폼에 맞는 특별한 최적화 고려 필요 주로 컴파일러의 기본 최적화 사용 빌드 속도 일반적으로 느림 (추가적인 설정과 변환 과정 필요) 빠름 (네이티브 환경에 최적화됨) 대표적 도구 GCC 크로스 컴파일러, LLVM/Clang, NDK, 각종 SDK GCC, Visual C++, Clang, 각종 언어별 컴파일러 참고 및 출처 ","wordCount":"1523","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-14T15:29:00Z","dateModified":"2024-10-14T15:29:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/cross-compiler/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href>Programming Language Theory</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/>컴파일러(Compiler)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilation-and-interpretation/compilation/compiler/types/>types of Compiler</a></div><h1 class="post-title entry-hint-parent">Cross Compiler</h1><div class=post-description>크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러</div><div class=post-meta><span title='2024-10-14 15:29:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Programming%20Language%20Theory/Compilation%20and%20Interpretation/Compilation/Compiler/Types/cross-compiler.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cross-compiler>Cross Compiler</a><ul><li><a href=#크로스-컴파일러의-정의>크로스 컴파일러의 정의</a></li><li><a href=#크로스-컴파일러의-주요-특징>크로스 컴파일러의 주요 특징</a></li><li><a href=#크로스-컴파일러의-작동-원리>크로스 컴파일러의 작동 원리</a></li><li><a href=#크로스-컴파일러의-필요성과-활용-분야>크로스 컴파일러의 필요성과 활용 분야</a></li><li><a href=#크로스-컴파일-환경-구축>크로스 컴파일 환경 구축</a></li><li><a href=#크로스-컴파일러의-종류>크로스 컴파일러의 종류</a></li><li><a href=#크로스-컴파일러의-주요-과제와-해결-방법>크로스 컴파일러의 주요 과제와 해결 방법</a></li><li><a href=#크로스-컴파일러-사용-예제>크로스 컴파일러 사용 예제</a></li><li><a href=#크로스-컴파일러와-관련-기술>크로스 컴파일러와 관련 기술</a></li><li><a href=#크로스-컴파일러의-발전-동향>크로스 컴파일러의 발전 동향</a></li><li><a href=#크로스-컴파일러와-일반-컴파일러-비교>크로스 컴파일러와 일반 컴파일러 비교</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=cross-compiler>Cross Compiler<a hidden class=anchor aria-hidden=true href=#cross-compiler>#</a></h2><p>크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러이다. 이는 임베디드 시스템이나 운영체제 개발처럼 대상 시스템이 컴파일러를 직접 실행하기에 부적합한 경우에 자주 사용되며, 한 개발 환경에서 여러 플랫폼용 소프트웨어를 동시에 개발할 수 있게 해준다.</p><p>크로스 컴파일러는 소프트웨어 개발의 다양한 분야, 특히 임베디드 시스템, 모바일 애플리케이션, 게임 콘솔, IoT 기기 개발에서 필수적인 도구이다. 이 기술은 개발자가 한 시스템에서 개발하면서 다양한 타겟 플랫폼용 코드를 생성할 수 있게 해준다.</p><p>복잡한 설정과 추가적인 도구가 필요하지만, 크로스 컴파일러의 사용은 다양한 하드웨어와 소프트웨어 환경을 지원하는 현대적인 소프트웨어 개발에 있어 필수적이다. 특히 제한된 컴퓨팅 자원을 가진 임베디드 시스템이나 IoT 기기와 같은 환경에서는 크로스 컴파일러가 없다면 효율적인 개발이 거의 불가능할 것이다.</p><p>LLVM과 같은 모듈식 컴파일러 인프라의 발전, 컨테이너 기술을 활용한 빌드 환경의 간소화, 클라우드 기반 빌드 서비스 등의 등장으로 크로스 컴파일 환경은 점점 더 접근성이 높아지고 있다.</p><h3 id=크로스-컴파일러의-정의>크로스 컴파일러의 정의<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-정의>#</a></h3><p>크로스 컴파일러는 한 컴퓨팅 환경(호스트 플랫폼)에서 실행되지만, 생성된 실행 파일은 다른 컴퓨팅 환경(타겟 플랫폼)에서 실행되도록 설계된 특수한 컴파일러이다.<br>일반 컴파일러와 달리, 크로스 컴파일러는 소스 코드를 호스트 시스템과 다른 아키텍처, 운영체제, 또는 CPU를 가진 타겟 시스템에서 실행할 수 있는 바이너리로 변환한다.</p><h3 id=크로스-컴파일러의-주요-특징>크로스 컴파일러의 주요 특징<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-주요-특징>#</a></h3><ol><li><p>Host System vs. Target System</p><ul><li><strong>Host System (호스트 시스템)</strong>: 컴파일이 수행되는 환경</li><li><strong>Target System (타겟 시스템)</strong>: 컴파일된 실행 파일이 실행될 환경<br>크로스 컴파일러는 <strong>호스트 시스템에서 타겟 시스템에 맞는 실행 파일을 생성</strong>한다.</li></ul></li><li><p>크로스 컴파일 과정<br>크로스 컴파일을 위해서는 다음과 같은 요소들이 필요하다.</p><ol><li><strong>크로스 컴파일러</strong>: 타겟 시스템용 바이너리를 생성할 수 있는 컴파일러 (예: <code>arm-linux-gcc</code>)</li><li><strong>라이브러리 및 헤더 파일</strong>: 타겟 시스템에서 사용하는 라이브러리 (예: <code>glibc</code>, <code>musl</code>)</li><li><strong>링커 및 빌드 도구</strong>: 타겟 시스템용 실행 파일을 생성하는 도구 (<code>ld</code>, <code>make</code>, <code>CMake</code> 등)</li></ol></li></ol><h3 id=크로스-컴파일러의-작동-원리>크로스 컴파일러의 작동 원리<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-작동-원리>#</a></h3><p>크로스 컴파일러의 작동 과정은 다음과 같다:</p><ol><li><strong>전처리(Preprocessing)</strong>: 소스 코드의 전처리 지시문 처리 및 매크로 확장</li><li><strong>컴파일(Compilation)</strong>: 소스 코드를 타겟 플랫폼에 맞는 어셈블리어로 변환</li><li><strong>어셈블(Assembly)</strong>: 어셈블리 코드를 타겟 플랫폼의 기계어로 변환</li><li><strong>링킹(Linking)</strong>: 타겟 플랫폼에 맞는 라이브러리와 목적 파일들을 연결하여 최종 실행 파일 생성</li></ol><p>이 과정에서 컴파일러는 타겟 시스템의 명령어 세트 아키텍처(ISA), 메모리 모델, 바이트 순서(endianness), ABI(Application Binary Interface) 등을 고려한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[소스 코드] → [전처리기] → [컴파일러] → [어셈블러] → [링커] → [타겟 실행 파일]
</span></span></code></pre></td></tr></table></div></div><h3 id=크로스-컴파일러의-필요성과-활용-분야>크로스 컴파일러의 필요성과 활용 분야<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-필요성과-활용-분야>#</a></h3><ol><li><p>임베디드 시스템 개발<br>임베디드 디바이스는 일반적으로 저전력, 제한된 자원을 가지고 있어 자체적으로 코드를 컴파일하기에 적합하지 않다. 따라서 PC에서 크로스 컴파일러를 사용하여 코드를 컴파일한 후, 결과물을 임베디드 시스템에 배포한다.</p></li><li><p>모바일 애플리케이션 개발<br>Android, iOS 애플리케이션을 개발할 때, 개발자는 자신의 PC에서 코드를 작성하고 크로스 컴파일하여 모바일 디바이스에서 실행 가능한 앱을 생성한다.</p></li><li><p>다양한 플랫폼 지원<br>멀티플랫폼 소프트웨어를 개발할 때, 크로스 컴파일러를 사용하여 하나의 소스 코드를 여러 타겟 플랫폼(Windows, macOS, Linux, 다양한 CPU 아키텍처 등)에서 실행 가능한 바이너리로 컴파일할 수 있다.</p></li><li><p>게임 콘솔 개발<br>PlayStation, Xbox, Nintendo Switch 등의 게임 콘솔용 소프트웨어 개발 시 크로스 컴파일러가 필수적이다.</p></li><li><p>IoT(사물인터넷) 기기 개발<br>다양한 IoT 기기들은 제한된 컴퓨팅 능력을 가지고 있어, PC에서 크로스 컴파일된 코드를 사용한다.</p></li></ol><h3 id=크로스-컴파일-환경-구축>크로스 컴파일 환경 구축<a hidden class=anchor aria-hidden=true href=#크로스-컴파일-환경-구축>#</a></h3><p>크로스 컴파일 환경을 구축하는 데는 다음과 같은 요소들이 필요하다:</p><ol><li><p>크로스 컴파일러 툴체인<br>타겟 플랫폼에 맞는 컴파일러, 어셈블러, 링커 등의 도구 모음.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># ARM 아키텍처용 GCC 크로스 컴파일러 설치 예(Ubuntu)</span>
</span></span><span class=line><span class=cl>sudo apt-get install gcc-arm-linux-gnueabi
</span></span></code></pre></td></tr></table></div></div></li><li><p>타겟 플랫폼의 라이브러리 및 헤더 파일<br>타겟 시스템의 표준 라이브러리와 헤더 파일들이 필요하다. 이를 &ldquo;sysroot"라고도 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># ARM용 라이브러리 및 헤더 설치 예</span>
</span></span><span class=line><span class=cl>sudo apt-get install libc6-dev-armel-cross
</span></span></code></pre></td></tr></table></div></div></li><li><p>빌드 시스템 설정<br>CMake, Autotools, Make 등의 빌드 시스템을 크로스 컴파일을 위해 설정해야 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=c># CMake에서 크로스 컴파일 설정 예
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_SYSTEM_NAME</span> <span class=s>Linux</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_SYSTEM_PROCESSOR</span> <span class=s>arm</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_C_COMPILER</span> <span class=s>arm-linux-gnueabi-gcc</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_CXX_COMPILER</span> <span class=s>arm-linux-gnueabi-g++</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>통합 개발 환경(IDE) 설정<br>많은 IDE는 크로스 컴파일을 위한 설정 옵션을 제공한다.</p></li></ol><h3 id=크로스-컴파일러의-종류>크로스 컴파일러의 종류<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-종류>#</a></h3><ol><li><p>GCC 크로스 컴파일러<br>GNU Compiler Collection(GCC)는 다양한 프로그래밍 언어와 타겟 플랫폼을 지원하는 대표적인 크로스 컴파일러이다. 예를 들어, <code>arm-linux-gnueabi-gcc</code>는 ARM 프로세서용 리눅스 시스템을 타겟으로 한다.</p></li><li><p>LLVM/Clang<br>LLVM 프로젝트의 Clang 컴파일러는 모듈식 설계로 다양한 타겟 플랫폼을 지원한다. 특히 Apple 생태계(iOS, macOS)와의 통합이 뛰어나다.</p></li><li><p>Microsoft Visual C++ 크로스 컴파일러<br>Windows 플랫폼에서 다양한 아키텍처(x86, x64, ARM, ARM64 등)를 타겟으로 하는 크로스 컴파일러를 제공한다.</p></li><li><p>인텔 C++ 컴파일러<br>인텔 프로세서 최적화에 특화된 크로스 컴파일러로, 다양한 플랫폼을 지원한다.</p></li><li><p>특정 임베디드 시스템용 컴파일러<br>특정 마이크로컨트롤러나 임베디드 시스템을 위한 전용 크로스 컴파일러도 존재한다(예: 아두이노 IDE의 AVR GCC, TI의 Code Composer Studio 등).</p></li></ol><h4 id=크로스-컴파일러-툴체인-비교>크로스 컴파일러 툴체인 비교<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러-툴체인-비교>#</a></h4><table><thead><tr><th>툴체인</th><th>주요 대상 플랫폼</th><th>지원 언어</th><th>특징</th><th>라이센스</th><th>주요 사용 분야</th></tr></thead><tbody><tr><td><strong>GCC 크로스 컴파일러</strong></td><td>ARM, MIPS, PowerPC, x86, RISC-V 등 다양한 아키텍처</td><td>C, C++, Fortran, Ada, D 등</td><td>광범위한 타겟 지원, 오픈소스 커뮤니티</td><td>GPL</td><td>임베디드 리눅스, 오픈소스 프로젝트</td></tr><tr><td><strong>LLVM/Clang</strong></td><td>x86, ARM, AArch64, MIPS, PowerPC, WebAssembly 등</td><td>C, C++, Objective-C, Swift, Rust 등</td><td>모듈식 설계, 최적화 기능, Apple 생태계 통합</td><td>Apache 2.0</td><td>iOS/macOS 앱, WebAssembly, 크로스 플랫폼 앱</td></tr><tr><td><strong>Android NDK</strong></td><td>ARM, ARM64, x86, x86_64 (Android 기기)</td><td>C, C++</td><td>Google 제공, Android 앱 개발 최적화</td><td>혼합 라이센스</td><td>Android 네이티브 앱, 게임 개발</td></tr><tr><td><strong>Microsoft Visual C++ Cross</strong></td><td>x86, x64, ARM, ARM64 (Windows 플랫폼)</td><td>C, C++</td><td>Windows 생태계 통합, 강력한 IDE 지원</td><td>상용 라이센스</td><td>Windows 데스크톱/모바일/IoT 앱</td></tr><tr><td><strong>Xcode 툴체인</strong></td><td>ARM64 (iOS, watchOS, tvOS), x86_64/ARM64 (macOS)</td><td>C, C++, Objective-C, Swift</td><td>Apple 생태계 최적화, 완벽한 IDE 통합</td><td>혼합 라이센스</td><td>iOS, macOS 앱 개발</td></tr><tr><td><strong>Buildroot</strong></td><td>ARM, MIPS, PowerPC, x86 등 (임베디드 리눅스)</td><td>C, C++</td><td>완전한 임베디드 리눅스 시스템 빌드, 자동화</td><td>GPL, 혼합</td><td>임베디드 리눅스 시스템, IoT 기기</td></tr><tr><td><strong>Yocto Project</strong></td><td>다양한 임베디드 플랫폼</td><td>C, C++, 기타</td><td>사용자 정의 리눅스 배포판 생성, 복잡한 설정 가능</td><td>MIT, GPL</td><td>상업용 임베디드 시스템, IoT 플랫폼</td></tr><tr><td><strong>ARM DS-5/Keil MDK</strong></td><td>ARM 프로세서 (베어메탈, RTOS)</td><td>C, C++</td><td>ARM 공식 지원, 임베디드 최적화</td><td>상용 라이센스</td><td>ARM 마이크로컨트롤러, 베어메탈 프로그래밍</td></tr><tr><td><strong>Emscripten</strong></td><td>WebAssembly, asm.js (웹 브라우저)</td><td>C, C++</td><td>C/C++ 코드를 웹용으로 컴파일</td><td>MIT</td><td>웹 기반 애플리케이션, 게임 포팅</td></tr><tr><td><strong>MinGW/MinGW-w64</strong></td><td>Windows (x86, x64)</td><td>C, C++</td><td>리눅스에서 Windows 바이너리 생성</td><td>혼합 (주로 MIT)</td><td>크로스 플랫폼 윈도우 애플리케이션</td></tr></tbody></table><h3 id=크로스-컴파일러의-주요-과제와-해결-방법>크로스 컴파일러의 주요 과제와 해결 방법<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-주요-과제와-해결-방법>#</a></h3><ol><li><p>라이브러리 의존성 관리: 타겟 플랫폼에서 사용 가능한 라이브러리가 호스트 시스템과 다를 수 있다.<br><strong>해결 방법</strong>:</p><ul><li>정적 링킹 사용</li><li>타겟 플랫폼의 라이브러리를 호스트 시스템에 설치</li><li>컨테이너 또는 가상 환경 사용</li></ul></li><li><p>플랫폼 특화 코드 처리: 운영체제 API, 하드웨어 접근 등에서 플랫폼별 차이가 있을 수 있다.<br><strong>해결 방법</strong>:</p><ul><li>조건부 컴파일 사용 (<code>#ifdef</code>, <code>#if defined</code> 등)</li><li>플랫폼 추상화 레이어 구현</li><li>크로스 플랫폼 라이브러리 활용</li></ul></li><li><p>디버깅 문제: 타겟 플랫폼에서 실행되는 코드를 호스트 시스템에서 디버깅하는 것은 복잡할 수 있다.<br><strong>해결 방법</strong>:</p><ul><li>원격 디버깅 설정</li><li>에뮬레이터 또는 시뮬레이터 사용</li><li>QEMU와 같은 하드웨어 가상화 도구 사용</li></ul></li><li><p>성능 최적화: 타겟 플랫폼의 특성에 맞는 최적화가 필요하다.<br><strong>해결 방법</strong>:</p><ul><li>타겟 특화 컴파일러 플래그 사용</li><li>프로파일 기반 최적화(PGO) 활용</li><li>타겟 아키텍처별 어셈블리 코드 제공</li></ul></li></ol><h3 id=크로스-컴파일러-사용-예제>크로스 컴파일러 사용 예제<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러-사용-예제>#</a></h3><ol><li><p>GCC를 사용한 ARM 타겟 크로스 컴파일 예제</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 간단한 C 프로그램 작성</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s1>&#39;#include &lt;stdio.h&gt;
</span></span></span><span class=line><span class=cl><span class=s1>int main() {
</span></span></span><span class=line><span class=cl><span class=s1>    printf(&#34;Hello from ARM!\n&#34;);
</span></span></span><span class=line><span class=cl><span class=s1>    return 0;
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> &gt; hello.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ARM용으로 크로스 컴파일</span>
</span></span><span class=line><span class=cl>arm-linux-gnueabi-gcc -o hello_arm hello.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 결과 확인</span>
</span></span><span class=line><span class=cl>file hello_arm
</span></span><span class=line><span class=cl><span class=c1># 출력: hello_arm: ELF 32-bit LSB executable, ARM, version 1 (SYSV), dynamically linked, …</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>CMake를 사용한 크로스 컴파일 프로젝트 설정</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=c># 크로스 컴파일 설정 파일 (arm-linux.cmake)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_SYSTEM_NAME</span> <span class=s>Linux</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_SYSTEM_PROCESSOR</span> <span class=s>arm</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_C_COMPILER</span> <span class=s>arm-linux-gnueabi-gcc</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_CXX_COMPILER</span> <span class=s>arm-linux-gnueabi-g++</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_FIND_ROOT_PATH</span> <span class=s>/usr/arm-linux-gnueabi</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_FIND_ROOT_PATH_MODE_PROGRAM</span> <span class=s>NEVER</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_FIND_ROOT_PATH_MODE_LIBRARY</span> <span class=s>ONLY</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_FIND_ROOT_PATH_MODE_INCLUDE</span> <span class=s>ONLY</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># CMake를 사용한 빌드</span>
</span></span><span class=line><span class=cl>mkdir build <span class=o>&amp;&amp;</span> <span class=nb>cd</span> build
</span></span><span class=line><span class=cl>cmake -DCMAKE_TOOLCHAIN_FILE<span class=o>=</span>../arm-linux.cmake ..
</span></span><span class=line><span class=cl>make
</span></span></code></pre></td></tr></table></div></div></li><li><p>Docker를 활용한 크로스 컴파일 환경</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Dockerfile</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> ubuntu:20.04</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install -y <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    gcc-arm-linux-gnueabi <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    g++-arm-linux-gnueabi <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    libc6-dev-armel-cross <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    make <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    cmake<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /src</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Docker 컨테이너에서 크로스 컴파일</span>
</span></span><span class=line><span class=cl>docker build -t arm-cross-compiler .
</span></span><span class=line><span class=cl>docker run -v <span class=k>$(</span><span class=nb>pwd</span><span class=k>)</span>:/src arm-cross-compiler arm-linux-gnueabi-gcc -o hello_arm hello.c
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=크로스-컴파일러와-관련-기술>크로스 컴파일러와 관련 기술<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러와-관련-기술>#</a></h3><ol><li><p>에뮬레이터와 시뮬레이터<br>QEMU, Bochs 등의 에뮬레이터는 타겟 하드웨어를 소프트웨어적으로 모방하여 크로스 컴파일된 코드를 호스트 시스템에서 테스트할 수 있게 해준다.</p></li><li><p>가상화 기술<br>VMware, VirtualBox, Hyper-V 등의 가상화 솔루션은 다양한 운영체제 환경을 시뮬레이션하여 크로스 컴파일러와 함께 사용될 수 있다.</p></li><li><p>컨테이너화<br>Docker, Podman 등의 컨테이너 기술은 크로스 컴파일 환경을 간편하게 구축하고 공유할 수 있게 해준다.</p></li><li><p>웹어셈블리(WebAssembly)<br>다양한 언어로 작성된 코드를 웹 브라우저에서 실행할 수 있는 바이너리 형식으로 변환하는 크로스 컴파일 기술이다.</p></li></ol><h3 id=크로스-컴파일러의-발전-동향>크로스 컴파일러의 발전 동향<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-발전-동향>#</a></h3><ol><li><p>LLVM 기반 컴파일러의 확산<br>모듈화된 아키텍처와 다양한 프론트엔드/백엔드 지원으로 LLVM 기반 컴파일러의 인기가 높아지고 있다.</p></li><li><p>클라우드 기반 크로스 컴파일<br>원격 빌드 서비스를 통해 다양한 타겟 플랫폼에 대한 크로스 컴파일 환경을 제공하는 클라우드 서비스가 등장하고 있다.</p></li><li><p>9.3 자동화된 크로스 컴파일 도구<br>Buildroot, Yocto Project와 같은 도구는 복잡한 임베디드 시스템을 위한, 자동화된 크로스 컴파일 환경을 제공한다.</p></li><li><p>컨테이너 기반 크로스 컴파일 환경<br>Docker, Podman 등의 컨테이너 기술은 크로스 컴파일 환경을 쉽게 구축하고 공유할 수 있게 한다.</p></li></ol><h3 id=크로스-컴파일러와-일반-컴파일러-비교>크로스 컴파일러와 일반 컴파일러 비교<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러와-일반-컴파일러-비교>#</a></h3><p>다음은 크로스 컴파일러와 일반(네이티브) 컴파일러의 주요 특징을 비교한 표.</p><table><thead><tr><th>특성</th><th>크로스 컴파일러</th><th>일반(네이티브) 컴파일러</th></tr></thead><tbody><tr><td><strong>실행 환경</strong></td><td>호스트 시스템에서 실행, 타겟 시스템용 코드 생성</td><td>코드가 실행될 시스템과 동일한 환경에서 실행</td></tr><tr><td><strong>타겟 플랫폼</strong></td><td>호스트와 다른 아키텍처, OS, CPU 등</td><td>컴파일러가 실행되는 것과 동일한 플랫폼</td></tr><tr><td><strong>설정 복잡성</strong></td><td>높음 (타겟 시스템 정보, 라이브러리, 헤더 파일 등 설정 필요)</td><td>낮음 (대부분 기본 설정으로 작동)</td></tr><tr><td><strong>디버깅 난이도</strong></td><td>높음 (원격 디버깅 또는 에뮬레이터 필요)</td><td>낮음 (로컬 환경에서 직접 디버깅 가능)</td></tr><tr><td><strong>라이브러리 관리</strong></td><td>복잡함 (타겟 플랫폼의 라이브러리 필요)</td><td>단순함 (호스트 시스템의 라이브러리 사용)</td></tr><tr><td><strong>주요 사용 사례</strong></td><td>임베디드 시스템, 모바일 앱, 게임 콘솔, IoT 기기 개발</td><td>데스크톱 애플리케이션, 로컬 서버 개발</td></tr><tr><td><strong>빌드 환경</strong></td><td>툴체인, sysroot, SDK 등 특별한 환경 설정 필요</td><td>간단한 컴파일러 설치로 충분</td></tr><tr><td><strong>성능 최적화</strong></td><td>타겟 플랫폼에 맞는 특별한 최적화 고려 필요</td><td>주로 컴파일러의 기본 최적화 사용</td></tr><tr><td><strong>빌드 속도</strong></td><td>일반적으로 느림 (추가적인 설정과 변환 과정 필요)</td><td>빠름 (네이티브 환경에 최적화됨)</td></tr><tr><td><strong>대표적 도구</strong></td><td>GCC 크로스 컴파일러, LLVM/Clang, NDK, 각종 SDK</td><td>GCC, Visual C++, Clang, 각종 언어별 컴파일러</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/cross-compiler/>Cross-Compiler</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/comparison-based-sorting/simple-sorts/selection-sort/><span class=title>« Prev</span><br><span>선택 정렬 (Selection Sort)</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures--algorithms/algorithms/sorting-and-searching/search-algorithms/><span class=title>Next »</span><br><span>검색 알고리즘 (Search Algorithms)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>