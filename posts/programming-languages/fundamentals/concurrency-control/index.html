<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>동시성 제어 (Concurrency Control) | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Concurrency-Control"><meta name=description content="동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="동시성 제어 (Concurrency Control)"><meta property="og:description" content="동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="동시성 제어 (Concurrency Control)"><meta name=twitter:description content="동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/"},{"@type":"ListItem","position":4,"name":"동시성 제어 (Concurrency Control)","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/>Fundamentals of Programming Languages</a></div><h1>동시성 제어 (Concurrency Control)</h1><div class=post-description>동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘</div></header><div class=post-content><h2 id=동시성-제어-concurrency-control>동시성 제어 (Concurrency Control)<a hidden class=anchor aria-hidden=true href=#동시성-제어-concurrency-control>#</a></h2><p>동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘.<br>다중 사용자 환경에서 필수적으로 지원해야 하는 기능으로, 병행제어라고도 한다.</p><h3 id=동시성-제어의-중요성>동시성 제어의 중요성<a hidden class=anchor aria-hidden=true href=#동시성-제어의-중요성>#</a></h3><p>동시성 제어는 다음과 같은 문제를 방지하여 데이터베이스의 무결성을 유지한다:</p><ul><li>갱신 손실: 동시에 수행된 갱신 작업으로 인한 데이터 손실</li><li>모순성: 일관성 없는 데이터 읽기</li><li>연쇄 복귀: 하나의 트랜잭션 실패로 인한 다른 트랜잭션들의 복귀</li></ul><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><ol><li>트랜잭션의 직렬성 보장</li><li>데이터의 무결성 및 일관성 유지</li><li>시스템 활용도 최대화 (공유도 최대, 응답 시간 최소, 처리량 최대화)</li></ol><h3 id=주요-동시성-제어-기법>주요 동시성 제어 기법<a hidden class=anchor aria-hidden=true href=#주요-동시성-제어-기법>#</a></h3><h4 id=락킹locking-기법>락킹(Locking) 기법<a hidden class=anchor aria-hidden=true href=#락킹locking-기법>#</a></h4><p>락킹은 가장 기본적인 동시성 제어 방법으로, 데이터에 접근할 때 잠금을 설정하여 다른 프로세스의 접근을 제한한다.</p><h5 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h5><p>공유 락(Shared Lock):</p><ul><li>읽기 작업을 위한 락</li><li>여러 프로세스가 동시에 획득 가능</li><li>데이터 읽기만 허용됨</li></ul><p>배타적 락(Exclusive Lock):</p><ul><li>쓰기 작업을 위한 락</li><li>한 번에 하나의 프로세스만 획득 가능</li><li>데이터 읽기와 쓰기 모두 가능</li></ul><h4 id=타임스탬프-기반-기법timestamp-based-protocol>타임스탬프 기반 기법(Timestamp-based Protocol)<a hidden class=anchor aria-hidden=true href=#타임스탬프-기반-기법timestamp-based-protocol>#</a></h4><p>각 트랜잭션에 고유한 타임스탬프를 부여하여 실행 순서를 결정하는 방식.</p><h5 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h5><ul><li>트랜잭션 시작 시 타임스탬프 부여</li><li>읽기/쓰기 타임스탬프 관리</li><li>충돌 발생 시 타임스탬프 비교하여 처리</li></ul><h5 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h5><ul><li>교착상태 발생하지 않음</li><li>우선순위 기반 처리 가능</li></ul><h4 id=낙관적-병행-제어optimistic-concurrency-control>낙관적 병행 제어(Optimistic Concurrency Control)<a hidden class=anchor aria-hidden=true href=#낙관적-병행-제어optimistic-concurrency-control>#</a></h4><p>충돌이 적을 것이라 가정하고, 검증 단계에서 충돌을 확인하는 방식.</p><h5 id=처리-단계>처리 단계<a hidden class=anchor aria-hidden=true href=#처리-단계>#</a></h5><ul><li>읽기 단계: 데이터 읽기와 로컬 복사본 생성</li><li>수행 단계: 로컬 복사본에서 작업 수행</li><li>검증 단계: 충돌 여부 확인</li><li>쓰기 단계: 검증 성공 시 결과 반영</li></ul><h4 id=다중버전-병행-제어multiversion-concurrency-control-mvcc>다중버전 병행 제어(Multiversion Concurrency Control, MVCC)<a hidden class=anchor aria-hidden=true href=#다중버전-병행-제어multiversion-concurrency-control-mvcc>#</a></h4><p>데이터의 여러 버전을 유지하여 읽기 작업의 병행성을 향상시키는 기법.</p><h5 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h5><ul><li>각 쓰기 작업마다 새로운 버전 생성</li><li>읽기 작업은 특정 시점의 버전을 참조</li><li>트랜잭션의 일관성 보장</li></ul><h5 id=실제-적용-예시>실제 적용 예시<a hidden class=anchor aria-hidden=true href=#실제-적용-예시>#</a></h5><p>PostgreSQL이나 Oracle 같은 데이터베이스 시스템에서 MVCC를 사용하여 읽기 작업의 성능을 향상시킨다.</p><h3 id=동시성-제어의-구현-시-고려사항>동시성 제어의 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#동시성-제어의-구현-시-고려사항>#</a></h3><ol><li><p>성능과 확장성</p><ul><li>락의 세분성 조절</li><li>데드락 방지 메커니즘</li><li>캐시 일관성 유지</li></ul></li><li><p>일관성 수준</p><ul><li>직렬성(Serializability)</li><li>스냅샷 격리(Snapshot Isolation)</li><li>읽기 일관성(Read Consistency)</li></ul></li><li><p>장애 복구</p><ul><li>롤백 메커니즘</li><li>복구 로그 관리</li><li>체크포인트 설정</li></ul></li></ol><h3 id=동시성-제어의-발전-방향>동시성 제어의 발전 방향<a hidden class=anchor aria-hidden=true href=#동시성-제어의-발전-방향>#</a></h3><ol><li><p>분산 시스템에서의 동시성 제어</p><ul><li>분산 락 관리</li><li>합의(Consensus) 알고리즘</li><li>최종 일관성(Eventual Consistency)</li></ul></li><li><p>새로운 하드웨어 지원</p><ul><li>하드웨어 트랜잭션 메모리</li><li>원자적 명령어 활용</li><li>멀티코어 최적화</li></ul></li><li><p>인메모리 데이터베이스</p><ul><li>락-프리 알고리즘</li><li>비동기 복제</li><li>실시간 동시성 제어</li></ul></li></ol><h3 id=실제-구현-시-주의사항>실제 구현 시 주의사항<a hidden class=anchor aria-hidden=true href=#실제-구현-시-주의사항>#</a></h3><ol><li><p>데드락 예방</p><ul><li>타임아웃 설정</li><li>자원 순서화</li><li>데드락 감지 알고리즘 구현</li></ul></li><li><p>성능 최적화</p><ul><li>락 경합(Lock Contention) 최소화</li><li>트랜잭션 분할</li><li>캐시 활용</li></ul></li><li><p>모니터링과 디버깅</p><ul><li>락 획득/해제 로깅</li><li>성능 메트릭 수집</li><li>병목 지점 분석</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock and Mutex</h2></header><div class=entry-content><p>Lock and Mutex Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.
특성 Mutex Lock 기본 개념 상호 배제를 위한 동기화 객체로, 소유권 개념이 있음 일반적인 동기화 메커니즘으로, 단순한 잠금/해제 기능 소유권 소유권 개념이 있어 획득한 스레드만 해제 가능 소유권 개념이 없어 다른 스레드도 해제 가능 재진입성 보통 재진입 가능 (같은 스레드가 여러 번 획득 가능) 구현에 따라 재진입 가능할 수 있음 용도 스레드 간 엄격한 상호 배제가 필요한 경우 간단한 동기화가 필요한 일반적인 상황 성능 소유권 검사 등으로 인한 오버헤드 존재 상대적으로 가벼운 오버헤드, 단 구현에 따라 다름 에러 처리 소유권 위반 시 예외 발생 가능 단순한 실패/성공 여부만 반환 구현 복잡도 상대적으로 복잡한 구현 단순한 구현, 그러나 고급 기능 추가 시 복잡해질 수 있음 적용 범위 프로세스 내 스레드 간 동기화 프로세스 내 또는 프로세스 간 동기화에 사용 가능 우선순위 상속 우선순위 상속 지원 가능 일반적으로 지원하지 않음, 구현에 따라 다를 수 있음 교착상태 처리 소유권 추적으로 교착상태 감지 용이 기본적인 교착상태 감지만 가능 에러 검사 상세한 에러 검사 및 보고 기능 기본적인 에러 검사, 구현에 따라 확장 가능 메모리 사용 소유권 정보 저장으로 추가 메모리 필요 최소한의 메모리 사용 유연성 엄격한 규칙으로 유연성 제한 상대적으로 유연한 사용 가능 디버깅 소유권 정보로 디버깅 용이 디버깅이 상대적으로 어려움, 구현에 따라 다를 수 있음 사용 예시 데이터베이스 트랜잭션, 파일 시스템 접근 간단한 공유 자원 보호, 카운터 타임아웃 지원 보통 타임아웃 기능 내장 구현에 따라 타임아웃 지원 가능 복구 기능 비정상 종료 시 자동 복구 지원 구현에 따라 자동 복구 기능 추가 가능 중첩 사용 재진입성으로 중첩 사용 가능 구현에 따라 중첩 사용 가능, 주의 필요 시스템 수준 주로 커널 수준에서 구현 사용자 수준 및 커널 수준 모두에서 구현 가능 표준화 POSIX 표준으로 잘 정의됨 구현에 따라 동작이 다를 수 있음 성능 특성 경쟁 상황에서 성능 저하 가능 스핀락 구현 시 짧은 대기 시간에 효율적 공정성 일반적으로 공정성 메커니즘 내장 구현에 따라 공정성 보장 여부가 다름 실제 구현 시에는 고려할 사항 동시성 요구사항 (얼마나 많은 스레드가 동시에 접근하는가) 성능 요구사항 (응답 시간, 처리량 등) 리소스 사용량 (메모리, CPU 사용률) 오류 처리 및 복구 요구사항 데드록 방지 필요성 플랫폼 및 운영체제의 지원 여부 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-05 11:25:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock and Mutex" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/lock-and-mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동시성 (Concurrency)</h2></header><div class=entry-content><p>동시성 (Concurrency) 동시성 (Concurrency)은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 매우 빠르게 작업 간 전환을 하면서 처리하는 방식이다. 예를 들어, 하나의 CPU 코어에서 여러 작업을 빠르게 번갈아가며 실행하여 마치 동시에 여러 작업이 처리되는 것처럼 보이게 만든다.
Source: https://dynamogeeks.com/blog/concurrency-vs-parallelism-a-simplified-explanation
동시성의 특징 논리적 개념: 동시성은 물리적으로 동시에 실행되는 것이 아닌, 논리적으로 동시에 실행되는 것처럼 보이게 하는 개념이다. 자원 효율성: CPU가 유휴 상태로 있지 않고 계속해서 작업을 처리하므로 시스템 자원을 효율적으로 사용할 수 있다. 응답성 향상: 여러 작업을 번갈아가며 처리하므로 전체적인 시스템의 응답성이 향상된다. 동시성의 구현 방법 멀티스레딩: 하나의 프로세스 내에서 여러 스레드를 사용하여 작업을 동시에 처리한다. 비동기 프로그래밍: 작업을 비동기적으로 처리하여 한 작업이 완료되기를 기다리지 않고 다른 작업을 수행할 수 있게 한다. 동시성의 장점 성능 향상: 여러 작업을 동시에 처리함으로써 전체적인 처리 속도를 높일 수 있다. 자원 활용 최적화: CPU와 같은 시스템 자원을 최대한 활용할 수 있다. 사용자 경험 개선: 특히 UI 애플리케이션에서 동시성을 활용하면 사용자 반응성을 크게 향상시킬 수 있다. 동시성의 주의점 복잡성 증가: 동시성 프로그래밍은 일반적인 순차적 프로그래밍보다 복잡할 수 있다. 동기화 문제: 여러 작업이 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 주의해야 한다. 디버깅의 어려움: 동시에 실행되는 작업들 간의 상호작용으로 인해 버그를 찾고 수정하기가 어려울 수 있다. 동시성의 실제 예시 웹 브라우저: 여러 탭을 동시에 열어 각각 다른 웹페이지를 로드하면서 사용자 입력을 받는 것은 동시성의 좋은 예이다. 데이터베이스 시스템: 여러 사용자의 쿼리를 동시에 처리하는 데이터베이스 시스템도 동시성을 활용한다. 동시성은 현대 프로그래밍에서 매우 중요한 개념으로, 시스템의 성능을 향상시키고 사용자 경험을 개선하는 데 크게 기여한다.
...</p></div><footer class=entry-footer><span title='2024-10-04 06:51:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 (Concurrency)" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/concurrency/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>