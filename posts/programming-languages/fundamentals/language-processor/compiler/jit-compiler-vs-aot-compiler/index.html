<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JIT Compiler vs AOT Compiler | hyunyoun's Blog</title>
<meta name=keywords content="Programming-Languages,Fundamentals,Compiler,JIT-Compiler,AOT-Compiler"><meta name=description content="JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/jit-compiler-vs-aot-compiler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/jit-compiler-vs-aot-compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/jit-compiler-vs-aot-compiler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="JIT Compiler vs AOT Compiler"><meta property="og:description" content="JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-14T18:02:00+00:00"><meta property="article:modified_time" content="2024-10-14T18:02:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="JIT-Compiler"><meta property="article:tag" content="AOT-Compiler"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="JIT Compiler vs AOT Compiler"><meta name=twitter:description content="JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/"},{"@type":"ListItem","position":4,"name":"언어 프로세서(Language Processor)","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/"},{"@type":"ListItem","position":5,"name":"컴파일러(Compiler)","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/"},{"@type":"ListItem","position":6,"name":"JIT Compiler vs AOT Compiler","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/jit-compiler-vs-aot-compiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JIT Compiler vs AOT Compiler","name":"JIT Compiler vs AOT Compiler","description":"JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다","keywords":["Programming-Languages","Fundamentals","Compiler","JIT-Compiler","AOT-Compiler"],"articleBody":"JIT Compiler vs. AOT Compiler JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다.\nJIT와 AOT 컴파일러는 각각 고유한 장단점을 가지고 있으며, 사용 환경과 요구사항에 따라 적합한 접근 방식이 달라진다.\nJIT 컴파일러는 런타임 정보를 활용한 최적화와 플랫폼 독립성을 제공하는 반면, AOT 컴파일러는 빠른 시작 시간과 예측 가능한 성능을 제공한다.\n현대 소프트웨어 개발에서는 이 두 접근 방식의 장점을 결합한 하이브리드 방식이 점점 더 인기를 얻고 있다.\n앞으로는 기계 학습, 특화된 하드웨어 활용, WebAssembly 확산 등의 동향이 컴파일러 기술의 발전을 이끌 것으로 예상된다.\nJIT 컴파일러 (Just-In-Time Compiler) JIT 컴파일러는 프로그램 실행 중에 필요한 부분을 동적으로 컴파일하는 방식이다. 이는 “필요한 시점에(Just-In-Time)” 컴파일이 이루어진다는 의미이다.\nJIT 컴파일러의 작동 원리 프로그램이 처음 실행될 때는 인터프리터 방식으로 동작하다가, 반복적으로 실행되는 “핫스팟” 코드 영역을 감지하면 해당 부분을 네이티브 머신 코드로 변환한다. 이때 런타임 프로파일링 정보를 기반으로 최적화(예를 들어 함수 인라인, 불필요한 코드 제거 등)를 수행할 수 있다.\nJIT 컴파일의 기본 과정은 다음과 같다:\n중간 코드 생성: 소스 코드는 먼저 바이트코드나 중간 표현(IR)으로 변환된다. 인터프리터 실행: 처음에는 이 중간 코드가 인터프리터에 의해 한 명령어씩 실행된다. 프로파일링: 런타임 시스템이 코드 실행을 모니터링하면서 자주 실행되는 코드 영역(핫스팟)을 식별한다. 동적 컴파일: 식별된 핫스팟 코드는 네이티브 기계어로 컴파일된다. 최적화 적용: 런타임 정보(타입 정보, 실행 패턴 등)를 활용하여 다양한 최적화를 적용한다. 코드 캐싱: 컴파일된 네이티브 코드는 코드 캐시에 저장되어 재사용된다. JIT 컴파일러의 장단점 장점 런타임 정보 활용: 실제 실행 패턴에 기반한 최적화가 가능하다. 플랫폼 독립성: 중간 코드는 플랫폼 독립적이어서 “한 번 작성하고 어디서나 실행” 패러다임이 가능하다. 동적 기능 지원: 리플렉션, 동적 클래스 로딩 등의 동적 기능을 완전히 지원한다. 적응형 최적화: 애플리케이션의 실행 패턴에 따라 최적화 전략을 조정할 수 있다. 작은 배포 크기: 중간 코드는 네이티브 코드보다 일반적으로 크기가 작다. 단점 시작 지연: 초기 컴파일로 인해 프로그램 시작이 느릴 수 있다. 메모리 사용량 증가: JIT 컴파일러 자체, 프로파일링 데이터, 코드 캐시 등으로 메모리 사용량이 증가한다. 예측 불가능한 성능: 컴파일 타이밍에 따라 성능이 변동될 수 있다. 배터리 소모: 모바일 환경에서 컴파일 작업은 추가 전력을 소모한다. JIT 컴파일러 구현 사례 Java의 HotSpot JVM: 클라이언트 컴파일러(C1)와 서버 컴파일러(C2)를 조합한 계층적 컴파일 방식을 사용한다. V8 JavaScript 엔진: Ignition 인터프리터와 TurboFan 최적화 컴파일러를 사용한다. PyPy: 메타 추적 JIT를 사용하여 Python 코드를 최적화한다. .NET의 RyuJIT: C#, F#, VB.NET 등을 위한 JIT 컴파일러이다. AOT 컴파일러 (Ahead-Of-Time Compiler) AOT 컴파일러는 프로그램 실행 전에, 즉 빌드 타임에 전체 코드를 미리 네이티브 머신 코드로 번역한다.\nAOT 컴파일러의 작동 원리 소스 코드 또는 바이트코드를 전체적으로 분석하고, 정적 최적화를 수행한 후 대상 플랫폼에 최적화된 기계어 코드로 변환한다. 런타임에 추가적인 컴파일 과정을 거치지 않으므로 즉시 실행이 가능하며, 예측 가능한 성능을 제공한다.\nAOT 컴파일의 기본 과정은 다음과 같다:\n소스 코드 분석: 소스 코드를 파싱하고 구문 분석한다. 중간 표현 생성: 언어 중립적인 중간 표현(IR)으로 코드를 변환한다. 정적 최적화: 다양한 최적화 패스를 통해 코드를 개선한다. 타겟 코드 생성: 특정 대상 아키텍처의 네이티브 기계어로 코드를 변환한다. 링킹: 생성된 목적 파일을 라이브러리 및 다른 목적 파일과 연결하여 최종 실행 파일을 생성한다. 장단점 장점 빠른 시작 시간: 실행 파일이 이미 네이티브 코드로 컴파일되어 있어 시작이 빠르다. 예측 가능한 성능: 컴파일 시간에 최적화가 완료되어 일관된 성능을 제공한다. 낮은 메모리 사용량: 런타임에 컴파일러가 필요 없어 메모리 사용량이 감소한다. 향상된 보안: 소스 코드나 중간 표현이 배포되지 않아 역공학이 더 어렵다. 배터리 수명 향상: 컴파일 작업이 없어 CPU 사용량이 감소하며, 이는 모바일 기기의 배터리 수명 연장으로 이어진다. 단점 증가된 파일 크기: 네이티브 코드는 중간 표현보다 일반적으로 크기가 크다. 플랫폼 의존성: 각 목표 플랫폼/아키텍처별로 별도 컴파일이 필요하다. 동적 최적화 부재: 런타임 정보를 활용한 최적화가 제한적이다. 컴파일 시간 증가: 개발-빌드-테스트 주기에 시간이 추가된다. 리플렉션 및 동적 기능 제한: 리플렉션, 동적 클래스 로딩과 같은 동적 기능이 제한된다. AOT 컴파일러 구현 사례 GCC/Clang: C, C++, Objective-C 등을 위한 표준 AOT 컴파일러. Rust 컴파일러(rustc): Rust 언어를 위한 LLVM 기반 컴파일러. Go 컴파일러: Go 언어를 위한 AOT 컴파일러. Swift 컴파일러: Swift 코드를 네이티브 코드로 컴파일한다. NativeAOT(.NET):.NET 애플리케이션을 네이티브 코드로 컴파일한다. Graal Native Image: Java 애플리케이션을 독립 실행형 네이티브 실행 파일로 컴파일한다. 하이브리드 접근법: AOT와 JIT의 결합 최근에는 AOT와 JIT의 장점을 결합한 하이브리드 접근법이 인기를 얻고 있다:\nAndroid Runtime (ART)\nAndroid 7.0(Nougat)부터는 AOT, JIT, 프로필 기반 컴파일을 혼합하여 사용한다:\n앱 설치 시: 일부 AOT 컴파일 첫 실행 시: JIT 컴파일 + 사용 패턴 프로파일링 기기 유휴 상태 + 충전 중: 프로파일 기반으로 자주 사용되는 코드 AOT 컴파일 .NET Native/CoreRT\n.NET 애플리케이션을 네이티브 코드로 컴파일하지만, 리플렉션과 같은 동적 기능을 지원하기 위해 제한된 JIT 컴파일을 포함한다.\nGraalVM Native Image\nJava 애플리케이션을 네이티브 이미지로 컴파일하지만, 동적 기능을 위한 런타임 지원을 포함한다.\n실제 사용 사례 분석 모바일 애플리케이션\n모바일 환경에서는 시작 시간, 메모리 사용량, 배터리 수명이 중요하다:\niOS: Swift와 Objective-C는 AOT 컴파일을 사용하여 빠른 시작과 효율적인 전력 사용을 제공한다. Android: 하이브리드 접근법(ART)을 사용하여 시작 시간과 장기 실행 성능의 균형을 맞춘다. Flutter: AOT 컴파일(릴리스 모드)과 JIT 컴파일(개발 모드)을 모두 지원한다. 웹 애플리케이션\n웹 브라우저에서 JavaScript 실행은 JIT 컴파일에 크게 의존한다:\nV8(Chrome): 여러 단계의 JIT 컴파일을 사용하여 JavaScript 성능을 최적화한다. WebAssembly: C/C++, Rust 등으로 작성된 코드를 AOT 컴파일하여 웹에서 네이티브에 가까운 성능을 제공한다. 서버 애플리케이션\n서버 환경에서는 장기 실행 성능이 중요하다:\nJava: 전통적으로 JIT 컴파일을 사용하지만, GraalVM Native Image와 같은 AOT 옵션도 있다. Go: AOT 컴파일을 사용하여 빠른 시작과 예측 가능한 성능을 제공한다. Node.js: V8 JIT를 사용하여 JavaScript 서버 코드를 최적화한다. 임베디드 시스템\n제한된 리소스를 가진 임베디드 환경에서는 AOT 컴파일이 선호된다:\nC/C++: 메모리와 성능 제약이 있는 임베디드 시스템에서 AOT 컴파일이 표준이다. MicroPython: 제한된 리소스를 위해 인터프리터와 AOT 컴파일의 혼합을 사용한다. JIT와 AOT 컴파일러 비교 분석 특성 JIT 컴파일러 (Just-In-Time) AOT 컴파일러 (Ahead-Of-Time) 컴파일 시점 프로그램 실행 중에 컴파일 프로그램 실행 전에 컴파일 동작 방식 초기엔 인터프리터 방식 → 핫스팟 코드를 감지하여 동적 컴파일 전체 코드를 미리 분석, 정적 최적화 후 기계어로 변환 코드 변환 과정 바이트코드/중간 코드 → 프로파일링 → 필요한 부분만 네이티브 코드로 컴파일 소스 코드/중간 코드 → 전체 코드를 네이티브 코드로 컴파일 → 실행 성능 초기 실행은 느리지만, 핫스팟 컴파일 후 반복 실행 시 높은 성능 제공 프로그램 시작 즉시 최적화된 코드 실행, 예측 가능한 성능 제공 시작 시간 느림 (첫 실행 시 컴파일 오버헤드) 빠름 (이미 컴파일되어 있음) 장기 실행 성능 매우 높음 (런타임 프로파일링 기반 최적화) 높음 (정적 최적화) 메모리 사용량 높음 (컴파일러, 프로파일러, 코드 캐시 필요) 낮음 (런타임에 컴파일러 불필요) 최적화 수준 실행 패턴 기반 적응형 최적화 가능 정적 분석 기반 최적화, 일부 PGO(Profile-Guided Optimization) 가능 최적화 런타임 프로파일링 기반의 동적 최적화 (함수 인라인, 불필요한 코드 제거 등) 빌드 타임에 전 범위 최적화를 적용하지만 런타임 정보 반영은 어려움 코드 최적화 범위 핫스팟 위주 (자주 실행되는 코드) 전체 코드 (균일한 최적화) 런타임 정보 활용 가능 (타입 정보, 실행 빈도, 분기 패턴 등) 제한적 (PGO로 일부 가능) 플랫폼 독립성 높음 (각 플랫폼에서 JIT 컴파일) 낮음 (각 플랫폼별 별도 컴파일 필요) 배포 파일 크기 작음 (바이트코드/중간 코드 배포) 큼 (네이티브 코드 배포) 보안 측면 약간 취약 (코드 변조 가능성) 상대적으로 안전 (역공학이 어려움) 백그라운드 CPU 사용 높음 (런타임 컴파일 작업) 낮음 (컴파일 작업 없음) 배터리 영향 (모바일) 높음 (컴파일 작업으로 인한 CPU 사용) 낮음 (실행만 수행) 핫 리로딩 지원 용이 (동적 코드 로딩 및 컴파일) 어려움 (재컴파일 필요) 예측 가능성 낮음 (컴파일 타이밍에 따른 성능 변동) 높음 (일관된 실행 성능) 동적 언어 지원 우수 (런타임 타입 정보 활용) 제한적 (정적 분석의 한계) 실시간 시스템 적합성 낮음 (예측 불가능한 컴파일 지연) 높음 (예측 가능한 실행) 개발 주기 영향 최소 (빠른 컴파일-실행 사이클) 높음 (컴파일 대기 시간) 리플렉션/동적 기능 완전 지원 제한적 지원 (특별한 처리 필요) 장점 동적 최적화로 장기간 실행 시 성능 상승, 실행 환경에 따른 최적화 가능 빠른 시작, 예측 가능한 성능, 런타임 오버헤드 제거 단점 초기 오버헤드 발생, 런타임 중 추가 컴파일로 인한 CPU/메모리 사용 증가 빌드 시간이 길어짐, 플랫폼 종속성 존재, 동적 최적화 부족 사용 사례 Java,.NET, 웹 브라우저의 JavaScript 엔진 등 동적 환경에 적합 임베디드 시스템, 모바일 애플리케이션, 실시간 시스템 등 빠른 시작과 안정적인 성능이 필요할 때 주요 사용 예시 Java, JavaScript, C#, Python(PyPy) C, C++, Rust, Go, Swift 하이브리드 접근 ART(Android),.NET Native, GraalVM ART(Android),.NET Native, GraalVM 참고 및 출처 ","wordCount":"1268","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-14T18:02:00Z","dateModified":"2024-10-14T18:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/jit-compiler-vs-aot-compiler/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/>Fundamentals of Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/>언어 프로세서(Language Processor)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/>컴파일러(Compiler)</a></div><h1 class="post-title entry-hint-parent">JIT Compiler vs AOT Compiler</h1><div class=post-description>JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다</div><div class=post-meta><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Fundamentals/Language%20Processor/Compiler/JIT-Compiler-vs-AOT-Compiler.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#jit-compiler-vs-aot-compiler>JIT Compiler vs. AOT Compiler</a><ul><li><a href=#jit-컴파일러-just-in-time-compiler>JIT 컴파일러 (Just-In-Time Compiler)</a></li><li><a href=#aot-컴파일러-ahead-of-time-compiler>AOT 컴파일러 (Ahead-Of-Time Compiler)</a></li><li><a href=#하이브리드-접근법-aot와-jit의-결합>하이브리드 접근법: AOT와 JIT의 결합</a></li><li><a href=#실제-사용-사례-분석>실제 사용 사례 분석</a></li><li><a href=#jit와-aot-컴파일러-비교-분석>JIT와 AOT 컴파일러 비교 분석</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=jit-compiler-vs-aot-compiler>JIT Compiler vs. AOT Compiler<a hidden class=anchor aria-hidden=true href=#jit-compiler-vs-aot-compiler>#</a></h2><p>JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다.</p><p>JIT와 AOT 컴파일러는 각각 고유한 장단점을 가지고 있으며, 사용 환경과 요구사항에 따라 적합한 접근 방식이 달라진다.<br>JIT 컴파일러는 런타임 정보를 활용한 최적화와 플랫폼 독립성을 제공하는 반면, AOT 컴파일러는 빠른 시작 시간과 예측 가능한 성능을 제공한다.</p><p>현대 소프트웨어 개발에서는 이 두 접근 방식의 장점을 결합한 하이브리드 방식이 점점 더 인기를 얻고 있다.<br>앞으로는 기계 학습, 특화된 하드웨어 활용, WebAssembly 확산 등의 동향이 컴파일러 기술의 발전을 이끌 것으로 예상된다.</p><h3 id=jit-컴파일러-just-in-time-compiler>JIT 컴파일러 (Just-In-Time Compiler)<a hidden class=anchor aria-hidden=true href=#jit-컴파일러-just-in-time-compiler>#</a></h3><p>JIT 컴파일러는 프로그램 실행 중에 필요한 부분을 동적으로 컴파일하는 방식이다. 이는 &ldquo;필요한 시점에(Just-In-Time)&rdquo; 컴파일이 이루어진다는 의미이다.</p><h4 id=jit-컴파일러의-작동-원리>JIT 컴파일러의 작동 원리<a hidden class=anchor aria-hidden=true href=#jit-컴파일러의-작동-원리>#</a></h4><p>프로그램이 처음 실행될 때는 인터프리터 방식으로 동작하다가, 반복적으로 실행되는 &ldquo;핫스팟&rdquo; 코드 영역을 감지하면 해당 부분을 네이티브 머신 코드로 변환한다. 이때 런타임 프로파일링 정보를 기반으로 최적화(예를 들어 함수 인라인, 불필요한 코드 제거 등)를 수행할 수 있다.</p><p>JIT 컴파일의 기본 과정은 다음과 같다:</p><ol><li><strong>중간 코드 생성</strong>: 소스 코드는 먼저 바이트코드나 중간 표현(IR)으로 변환된다.</li><li><strong>인터프리터 실행</strong>: 처음에는 이 중간 코드가 인터프리터에 의해 한 명령어씩 실행된다.</li><li><strong>프로파일링</strong>: 런타임 시스템이 코드 실행을 모니터링하면서 자주 실행되는 코드 영역(핫스팟)을 식별한다.</li><li><strong>동적 컴파일</strong>: 식별된 핫스팟 코드는 네이티브 기계어로 컴파일된다.</li><li><strong>최적화 적용</strong>: 런타임 정보(타입 정보, 실행 패턴 등)를 활용하여 다양한 최적화를 적용한다.</li><li><strong>코드 캐싱</strong>: 컴파일된 네이티브 코드는 코드 캐시에 저장되어 재사용된다.</li></ol><h4 id=jit-컴파일러의-장단점>JIT 컴파일러의 장단점<a hidden class=anchor aria-hidden=true href=#jit-컴파일러의-장단점>#</a></h4><h5 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h5><ol><li><strong>런타임 정보 활용</strong>: 실제 실행 패턴에 기반한 최적화가 가능하다.</li><li><strong>플랫폼 독립성</strong>: 중간 코드는 플랫폼 독립적이어서 &ldquo;한 번 작성하고 어디서나 실행&rdquo; 패러다임이 가능하다.</li><li><strong>동적 기능 지원</strong>: 리플렉션, 동적 클래스 로딩 등의 동적 기능을 완전히 지원한다.</li><li><strong>적응형 최적화</strong>: 애플리케이션의 실행 패턴에 따라 최적화 전략을 조정할 수 있다.</li><li><strong>작은 배포 크기</strong>: 중간 코드는 네이티브 코드보다 일반적으로 크기가 작다.</li></ol><h5 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h5><ol><li><strong>시작 지연</strong>: 초기 컴파일로 인해 프로그램 시작이 느릴 수 있다.</li><li><strong>메모리 사용량 증가</strong>: JIT 컴파일러 자체, 프로파일링 데이터, 코드 캐시 등으로 메모리 사용량이 증가한다.</li><li><strong>예측 불가능한 성능</strong>: 컴파일 타이밍에 따라 성능이 변동될 수 있다.</li><li><strong>배터리 소모</strong>: 모바일 환경에서 컴파일 작업은 추가 전력을 소모한다.</li></ol><h4 id=jit-컴파일러-구현-사례>JIT 컴파일러 구현 사례<a hidden class=anchor aria-hidden=true href=#jit-컴파일러-구현-사례>#</a></h4><ol><li><strong>Java의 HotSpot JVM</strong>: 클라이언트 컴파일러(C1)와 서버 컴파일러(C2)를 조합한 계층적 컴파일 방식을 사용한다.</li><li><strong>V8 JavaScript 엔진</strong>: Ignition 인터프리터와 TurboFan 최적화 컴파일러를 사용한다.</li><li><strong>PyPy</strong>: 메타 추적 JIT를 사용하여 Python 코드를 최적화한다.</li><li><strong>.NET의 RyuJIT</strong>: C#, F#, VB.NET 등을 위한 JIT 컴파일러이다.</li></ol><h3 id=aot-컴파일러-ahead-of-time-compiler>AOT 컴파일러 (Ahead-Of-Time Compiler)<a hidden class=anchor aria-hidden=true href=#aot-컴파일러-ahead-of-time-compiler>#</a></h3><p>AOT 컴파일러는 프로그램 실행 전에, 즉 빌드 타임에 전체 코드를 미리 네이티브 머신 코드로 번역한다.</p><h4 id=aot-컴파일러의-작동-원리>AOT 컴파일러의 작동 원리<a hidden class=anchor aria-hidden=true href=#aot-컴파일러의-작동-원리>#</a></h4><p>소스 코드 또는 바이트코드를 전체적으로 분석하고, 정적 최적화를 수행한 후 대상 플랫폼에 최적화된 기계어 코드로 변환한다. 런타임에 추가적인 컴파일 과정을 거치지 않으므로 즉시 실행이 가능하며, 예측 가능한 성능을 제공한다.</p><p>AOT 컴파일의 기본 과정은 다음과 같다:</p><ol><li><strong>소스 코드 분석</strong>: 소스 코드를 파싱하고 구문 분석한다.</li><li><strong>중간 표현 생성</strong>: 언어 중립적인 중간 표현(IR)으로 코드를 변환한다.</li><li><strong>정적 최적화</strong>: 다양한 최적화 패스를 통해 코드를 개선한다.</li><li><strong>타겟 코드 생성</strong>: 특정 대상 아키텍처의 네이티브 기계어로 코드를 변환한다.</li><li><strong>링킹</strong>: 생성된 목적 파일을 라이브러리 및 다른 목적 파일과 연결하여 최종 실행 파일을 생성한다.</li></ol><h4 id=장단점>장단점<a hidden class=anchor aria-hidden=true href=#장단점>#</a></h4><h5 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h5><ol><li><strong>빠른 시작 시간</strong>: 실행 파일이 이미 네이티브 코드로 컴파일되어 있어 시작이 빠르다.</li><li><strong>예측 가능한 성능</strong>: 컴파일 시간에 최적화가 완료되어 일관된 성능을 제공한다.</li><li><strong>낮은 메모리 사용량</strong>: 런타임에 컴파일러가 필요 없어 메모리 사용량이 감소한다.</li><li><strong>향상된 보안</strong>: 소스 코드나 중간 표현이 배포되지 않아 역공학이 더 어렵다.</li><li><strong>배터리 수명 향상</strong>: 컴파일 작업이 없어 CPU 사용량이 감소하며, 이는 모바일 기기의 배터리 수명 연장으로 이어진다.</li></ol><h5 id=단점-1>단점<a hidden class=anchor aria-hidden=true href=#단점-1>#</a></h5><ol><li><strong>증가된 파일 크기</strong>: 네이티브 코드는 중간 표현보다 일반적으로 크기가 크다.</li><li><strong>플랫폼 의존성</strong>: 각 목표 플랫폼/아키텍처별로 별도 컴파일이 필요하다.</li><li><strong>동적 최적화 부재</strong>: 런타임 정보를 활용한 최적화가 제한적이다.</li><li><strong>컴파일 시간 증가</strong>: 개발-빌드-테스트 주기에 시간이 추가된다.</li><li><strong>리플렉션 및 동적 기능 제한</strong>: 리플렉션, 동적 클래스 로딩과 같은 동적 기능이 제한된다.</li></ol><h4 id=aot-컴파일러-구현-사례>AOT 컴파일러 구현 사례<a hidden class=anchor aria-hidden=true href=#aot-컴파일러-구현-사례>#</a></h4><ol><li><strong>GCC/Clang</strong>: C, C++, Objective-C 등을 위한 표준 AOT 컴파일러.</li><li><strong>Rust 컴파일러(rustc)</strong>: Rust 언어를 위한 LLVM 기반 컴파일러.</li><li><strong>Go 컴파일러</strong>: Go 언어를 위한 AOT 컴파일러.</li><li><strong>Swift 컴파일러</strong>: Swift 코드를 네이티브 코드로 컴파일한다.</li><li><strong>NativeAOT(.NET)</strong>:.NET 애플리케이션을 네이티브 코드로 컴파일한다.</li><li><strong>Graal Native Image</strong>: Java 애플리케이션을 독립 실행형 네이티브 실행 파일로 컴파일한다.</li></ol><h3 id=하이브리드-접근법-aot와-jit의-결합>하이브리드 접근법: AOT와 JIT의 결합<a hidden class=anchor aria-hidden=true href=#하이브리드-접근법-aot와-jit의-결합>#</a></h3><p>최근에는 AOT와 JIT의 장점을 결합한 하이브리드 접근법이 인기를 얻고 있다:</p><ol><li><p>Android Runtime (ART)<br>Android 7.0(Nougat)부터는 AOT, JIT, 프로필 기반 컴파일을 혼합하여 사용한다:</p><ul><li>앱 설치 시: 일부 AOT 컴파일</li><li>첫 실행 시: JIT 컴파일 + 사용 패턴 프로파일링</li><li>기기 유휴 상태 + 충전 중: 프로파일 기반으로 자주 사용되는 코드 AOT 컴파일</li></ul></li><li><p>.NET Native/CoreRT<br><code>.NET</code> 애플리케이션을 네이티브 코드로 컴파일하지만, 리플렉션과 같은 동적 기능을 지원하기 위해 제한된 JIT 컴파일을 포함한다.</p></li><li><p>GraalVM Native Image<br>Java 애플리케이션을 네이티브 이미지로 컴파일하지만, 동적 기능을 위한 런타임 지원을 포함한다.</p></li></ol><h3 id=실제-사용-사례-분석>실제 사용 사례 분석<a hidden class=anchor aria-hidden=true href=#실제-사용-사례-분석>#</a></h3><ol><li><p>모바일 애플리케이션<br>모바일 환경에서는 시작 시간, 메모리 사용량, 배터리 수명이 중요하다:</p><ul><li><strong>iOS</strong>: Swift와 Objective-C는 AOT 컴파일을 사용하여 빠른 시작과 효율적인 전력 사용을 제공한다.</li><li><strong>Android</strong>: 하이브리드 접근법(ART)을 사용하여 시작 시간과 장기 실행 성능의 균형을 맞춘다.</li><li><strong>Flutter</strong>: AOT 컴파일(릴리스 모드)과 JIT 컴파일(개발 모드)을 모두 지원한다.</li></ul></li><li><p>웹 애플리케이션<br>웹 브라우저에서 JavaScript 실행은 JIT 컴파일에 크게 의존한다:</p><ul><li><strong>V8(Chrome)</strong>: 여러 단계의 JIT 컴파일을 사용하여 JavaScript 성능을 최적화한다.</li><li><strong>WebAssembly</strong>: C/C++, Rust 등으로 작성된 코드를 AOT 컴파일하여 웹에서 네이티브에 가까운 성능을 제공한다.</li></ul></li><li><p>서버 애플리케이션<br>서버 환경에서는 장기 실행 성능이 중요하다:</p><ul><li><strong>Java</strong>: 전통적으로 JIT 컴파일을 사용하지만, GraalVM Native Image와 같은 AOT 옵션도 있다.</li><li><strong>Go</strong>: AOT 컴파일을 사용하여 빠른 시작과 예측 가능한 성능을 제공한다.</li><li><strong>Node.js</strong>: V8 JIT를 사용하여 JavaScript 서버 코드를 최적화한다.</li></ul></li><li><p>임베디드 시스템<br>제한된 리소스를 가진 임베디드 환경에서는 AOT 컴파일이 선호된다:</p><ul><li><strong>C/C++</strong>: 메모리와 성능 제약이 있는 임베디드 시스템에서 AOT 컴파일이 표준이다.</li><li><strong>MicroPython</strong>: 제한된 리소스를 위해 인터프리터와 AOT 컴파일의 혼합을 사용한다.</li></ul></li></ol><h3 id=jit와-aot-컴파일러-비교-분석>JIT와 AOT 컴파일러 비교 분석<a hidden class=anchor aria-hidden=true href=#jit와-aot-컴파일러-비교-분석>#</a></h3><table><thead><tr><th>특성</th><th>JIT 컴파일러 (Just-In-Time)</th><th>AOT 컴파일러 (Ahead-Of-Time)</th></tr></thead><tbody><tr><td><strong>컴파일 시점</strong></td><td>프로그램 실행 중에 컴파일</td><td>프로그램 실행 전에 컴파일</td></tr><tr><td><strong>동작 방식</strong></td><td>초기엔 인터프리터 방식 → 핫스팟 코드를 감지하여 동적 컴파일</td><td>전체 코드를 미리 분석, 정적 최적화 후 기계어로 변환</td></tr><tr><td><strong>코드 변환 과정</strong></td><td>바이트코드/중간 코드 → 프로파일링 → 필요한 부분만 네이티브 코드로 컴파일</td><td>소스 코드/중간 코드 → 전체 코드를 네이티브 코드로 컴파일 → 실행</td></tr><tr><td><strong>성능</strong></td><td>초기 실행은 느리지만, 핫스팟 컴파일 후 반복 실행 시 높은 성능 제공</td><td>프로그램 시작 즉시 최적화된 코드 실행, 예측 가능한 성능 제공</td></tr><tr><td><strong>시작 시간</strong></td><td>느림 (첫 실행 시 컴파일 오버헤드)</td><td>빠름 (이미 컴파일되어 있음)</td></tr><tr><td><strong>장기 실행 성능</strong></td><td>매우 높음 (런타임 프로파일링 기반 최적화)</td><td>높음 (정적 최적화)</td></tr><tr><td><strong>메모리 사용량</strong></td><td>높음 (컴파일러, 프로파일러, 코드 캐시 필요)</td><td>낮음 (런타임에 컴파일러 불필요)</td></tr><tr><td><strong>최적화 수준</strong></td><td>실행 패턴 기반 적응형 최적화 가능</td><td>정적 분석 기반 최적화, 일부 PGO(Profile-Guided Optimization) 가능</td></tr><tr><td><strong>최적화</strong></td><td>런타임 프로파일링 기반의 동적 최적화 (함수 인라인, 불필요한 코드 제거 등)</td><td>빌드 타임에 전 범위 최적화를 적용하지만 런타임 정보 반영은 어려움</td></tr><tr><td><strong>코드 최적화 범위</strong></td><td>핫스팟 위주 (자주 실행되는 코드)</td><td>전체 코드 (균일한 최적화)</td></tr><tr><td><strong>런타임 정보 활용</strong></td><td>가능 (타입 정보, 실행 빈도, 분기 패턴 등)</td><td>제한적 (PGO로 일부 가능)</td></tr><tr><td><strong>플랫폼 독립성</strong></td><td>높음 (각 플랫폼에서 JIT 컴파일)</td><td>낮음 (각 플랫폼별 별도 컴파일 필요)</td></tr><tr><td><strong>배포 파일 크기</strong></td><td>작음 (바이트코드/중간 코드 배포)</td><td>큼 (네이티브 코드 배포)</td></tr><tr><td><strong>보안 측면</strong></td><td>약간 취약 (코드 변조 가능성)</td><td>상대적으로 안전 (역공학이 어려움)</td></tr><tr><td><strong>백그라운드 CPU 사용</strong></td><td>높음 (런타임 컴파일 작업)</td><td>낮음 (컴파일 작업 없음)</td></tr><tr><td><strong>배터리 영향 (모바일)</strong></td><td>높음 (컴파일 작업으로 인한 CPU 사용)</td><td>낮음 (실행만 수행)</td></tr><tr><td><strong>핫 리로딩 지원</strong></td><td>용이 (동적 코드 로딩 및 컴파일)</td><td>어려움 (재컴파일 필요)</td></tr><tr><td><strong>예측 가능성</strong></td><td>낮음 (컴파일 타이밍에 따른 성능 변동)</td><td>높음 (일관된 실행 성능)</td></tr><tr><td><strong>동적 언어 지원</strong></td><td>우수 (런타임 타입 정보 활용)</td><td>제한적 (정적 분석의 한계)</td></tr><tr><td><strong>실시간 시스템 적합성</strong></td><td>낮음 (예측 불가능한 컴파일 지연)</td><td>높음 (예측 가능한 실행)</td></tr><tr><td><strong>개발 주기 영향</strong></td><td>최소 (빠른 컴파일-실행 사이클)</td><td>높음 (컴파일 대기 시간)</td></tr><tr><td><strong>리플렉션/동적 기능</strong></td><td>완전 지원</td><td>제한적 지원 (특별한 처리 필요)</td></tr><tr><td><strong>장점</strong></td><td>동적 최적화로 장기간 실행 시 성능 상승, 실행 환경에 따른 최적화 가능</td><td>빠른 시작, 예측 가능한 성능, 런타임 오버헤드 제거</td></tr><tr><td><strong>단점</strong></td><td>초기 오버헤드 발생, 런타임 중 추가 컴파일로 인한 CPU/메모리 사용 증가</td><td>빌드 시간이 길어짐, 플랫폼 종속성 존재, 동적 최적화 부족</td></tr><tr><td><strong>사용 사례</strong></td><td>Java,.NET, 웹 브라우저의 JavaScript 엔진 등 동적 환경에 적합</td><td>임베디드 시스템, 모바일 애플리케이션, 실시간 시스템 등 빠른 시작과 안정적인 성능이 필요할 때</td></tr><tr><td><strong>주요 사용 예시</strong></td><td>Java, JavaScript, C#, Python(PyPy)</td><td>C, C++, Rust, Go, Swift</td></tr><tr><td><strong>하이브리드 접근</strong></td><td>ART(Android),.NET Native, GraalVM</td><td>ART(Android),.NET Native, GraalVM</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/jit-compiler/>JIT-Compiler</a></li><li><a href=https://buenhyden.github.io/tags/aot-compiler/>AOT-Compiler</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/types/quick-sort/><span class=title>« Prev</span><br><span>퀵 정렬 (Quick Sort)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/aot-vs-jit-vs-interpreter/><span class=title>Next »</span><br><span>AOT vs. JIT vs. Interpreter</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>