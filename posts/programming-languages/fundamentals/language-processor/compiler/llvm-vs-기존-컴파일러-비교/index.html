<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LLVM vs 기존 컴파일러 비교 | hyunyoun's Blog</title>
<meta name=keywords content="Programming-Languages,Fundamentals,Language-Processor,Compiler,LLVM,Low-Level-Virtual-Machine"><meta name=description content="LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="LLVM vs 기존 컴파일러 비교"><meta property="og:description" content="LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-05T07:28:00+00:00"><meta property="article:modified_time" content="2024-12-05T07:28:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Language-Processor"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="LLVM"><meta property="article:tag" content="Low-Level-Virtual-Machine"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="LLVM vs 기존 컴파일러 비교"><meta name=twitter:description content="LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Programming Languages's Fundamentals","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/"},{"@type":"ListItem","position":4,"name":"언어 프로세서(Language Processor)","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/"},{"@type":"ListItem","position":5,"name":"컴파일러(Compiler)","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/"},{"@type":"ListItem","position":6,"name":"LLVM vs 기존 컴파일러 비교","item":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LLVM vs 기존 컴파일러 비교","name":"LLVM vs 기존 컴파일러 비교","description":"LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.","keywords":["Programming-Languages","Fundamentals","Language-Processor","Compiler","LLVM","Low-Level-Virtual-Machine"],"articleBody":"LLVM Vs 기존 컴파일러 비교 LLVM(Low Level Virtual Machine)은 모듈식 컴파일러 인프라스트럭처로, 다양한 프로그래밍 언어와 하드웨어 플랫폼을 지원하도록 설계되었다.\nLLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.\n전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.\n그러나 복잡성, 특수 타겟 지원, 리소스 요구사항 등의 측면에서는 여전히 개선의 여지가 있다. 또한 GCC와 같은 전통적인 컴파일러도 계속 발전하면서 LLVM의 장점을 일부 수용하고 있다.\n미래에는 MLIR, 머신러닝 통합, 양자 컴퓨팅 지원 등을 통해 LLVM이 더욱 발전할 것으로 예상되며, 컴파일러 기술 전반이 더욱 다양하고 전문화될 것으로 보인다.\nLLVM의 개념과 구조 LLVM(Low Level Virtual Machine)은 현대적인 컴파일러 인프라스트럭처로, 2000년대 초반 크리스 래트너(Chris Lattner)에 의해 개발이 시작되었습니다. LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 다양한 프로그래밍 언어와 하드웨어 아키텍처를 효율적으로 지원하는 것입니다.\nLLVM의 3단계 구조 LLVM은 다음과 같은 3단계 구조로 설계되었다:\n프론트엔드: 소스 코드를 파싱하여 LLVM IR(중간 표현)으로 변환한다. 대표적인 프론트엔드로는 C, C++, Objective-C를 위한 Clang이 있다. 최적화기(Optimizer): 언어와 타겟에 독립적인 다양한 최적화를 LLVM IR에 적용한다. 이 단계에서 인라인화, 루프 최적화, 상수 폴딩 등 수많은 최적화 패스가 수행된다. 백엔드(코드 생성기): 최적화된 LLVM IR을 특정 하드웨어 아키텍처의 기계어로 변환한다. x86, ARM, MIPS, RISC-V 등 다양한 타겟이 지원된다.\n이러한 구조는 새로운 언어 지원을 위해 프론트엔드만 개발하거나, 새로운 하드웨어 지원을 위해 백엔드만 개발할 수 있게 해주며, 최적화는 공통으로 사용할 수 있다. 1.2 LLVM IR(중간 표현) LLVM IR은 LLVM의 핵심 요소로, 다음과 같은 특징을 가집니다:\n정적 단일 할당(SSA) 형식: 각 변수는 정확히 한 번만 할당되어 최적화를 용이하게 합니다. 타입 시스템: 강력한 타입 시스템을 가지고 있어 타입 안전성을 보장합니다. 세 가지 동등한 형태: 메모리 내 표현, 비트코드(.bc), 사람이 읽을 수 있는 텍스트 형식(.ll)이 있습니다. LLVM IR의 예시:\n1 2 3 4 5 define i32 @add(i32 %a, i32 %b) { entry: %sum = add i32 %a, %b ret i32 %sum } LLVM 프로젝트의 주요 구성 요소 LLVM 프로젝트는 다음과 같은 주요 구성 요소를 포함한다:\nLLVM Core: 중간 표현, 최적화 패스, 코드 생성기 등의 핵심 기능을 제공한다. Clang: C, C++, Objective-C를 위한 프론트엔드이다. lld: 다양한 형식의 목적 파일을 링크하는 링커이다. LLDB: LLVM 기반의 디버거이다. libc++: C++ 표준 라이브러리 구현이다. 컴파일러-RT: 컴파일 시간과 런타임에 필요한 저수준 지원 라이브러리이다. LLVM의 한계와 도전 과제 LLVM이 많은 장점을 가지고 있지만, 몇 가지 한계와 도전 과제도 존재한다:\n복잡성\nLLVM은 강력하지만 학습 곡선이 가파르다. 방대한 코드베이스와 문서로 인해 완전히 이해하기 어려울 수 있다. 효과적인 백엔드 개발은 상당한 전문 지식을 요구한다. 특수 타겟 지원\n일부 특수한 하드웨어 아키텍처에서는 GCC가 더 나은 지원을 제공할 수 있다. 오래된 아키텍처나 비주류 아키텍처의 경우 LLVM 지원이 제한적일 수 있다. 최적화 안정성\n일부 최적화는 예상치 못한 동작 변화를 일으킬 수 있다. 최적화 수준이 높을수록 디버깅이 더 어려워질 수 있다. 리소스 요구사항\nLLVM 기반 도구는 메모리와 CPU 사용량이 상당할 수 있다. 제한된 리소스 환경에서는 부담이 될 수 있다. 전통적인 컴파일러의 구조와 특징 전통적인 컴파일러(예: GCC)는 일반적으로 다음과 같은 단계로 구성된다:\n전처리기(Preprocessor): 매크로 확장, 헤더 파일 포함 등의 작업을 수행한다. 파서(Parser): 소스 코드를 구문 분석하여 추상 구문 트리(AST)를 생성한다. 의미 분석기(Semantic Analyzer): AST를 분석하여 타입 체크 등 의미적 정확성을 검증한다. 중간 코드 생성기: 중간 표현을 생성한다. 최적화기: 중간 코드에 다양한 최적화를 적용한다. 코드 생성기: 타겟 기계어를 생성한다. 어셈블러/링커: 목적 파일을 생성하고 링크한다. 전통적인 컴파일러의 특징:\n일체형 구조: 여러 단계가 밀접하게 결합되어 있어 모듈화 수준이 낮다. 특정 언어/타겟 중심: 특정 언어나 타겟 아키텍처에 최적화되어 있다. 커스터마이징 제한: 컴파일러의 내부 동작을 변경하거나 확장하기 어렵다. GCC(GNU Compiler Collection) GCC는 가장 널리 사용되는 전통적 컴파일러 중 하나이다:\n다양한 언어 지원: C, C++, Objective-C, Fortran, Ada 등을 지원한다. 다양한 타겟 지원: 수많은 프로세서 아키텍처를 지원한다. GPL 라이센스: 오픈 소스지만 GPL 라이센스로 배포되어 일부 상업적 이용에 제약이 있다. 발전 중인 구조: 최근 버전에서는 GIMPLE과 RTL이라는 중간 표현을 사용하며 모듈화가 개선되고 있다. 기타 전통적 컴파일러 Microsoft Visual C++ Compiler: Windows 환경에서 널리 사용되는 C/C++ 컴파일러. Intel C++ Compiler: Intel 프로세서에 최적화된 코드를 생성하는 컴파일러. IBM XL C/C++: IBM 시스템을 위한 최적화된 컴파일러. LLVM과 기존 컴파일러의 주요 차이점 아키텍처와 모듈성 LLVM:\n모듈화된 3단계 구조로 각 컴포넌트를 독립적으로 개발하고 사용할 수 있다. 공통 LLVM IR을 중심으로 여러 프론트엔드와 백엔드가 통합된다. 라이브러리 형태로 설계되어 다른 도구나 애플리케이션에 쉽게 통합될 수 있다. 전통적 컴파일러:\n일체형 구조로 컴포넌트 간 강한 결합을 가진다. 각 컴파일러마다 다른 중간 표현을 사용한다. 주로 독립 실행형 프로그램으로 설계되어 외부 통합이 어렵다. 최적화 접근 방식 LLVM:\n언어와 타겟에 독립적인 최적화를 IR 수준에서 적용한다. 패스 매니저를 통해 최적화 패스를 유연하게 구성할 수 있다. 링크 시간 최적화(LTO)가 설계부터 고려되었다. 전통적 컴파일러:\n최적화가 특정 언어나 타겟에 더 밀접하게 결합되어 있다. 최적화 순서가 더 고정적인 경향이 있다. 링크 시간 최적화가 후기에 추가된 경우가 많다. 확장성과 재사용성 LLVM:\n새로운 언어 지원을 위해 프론트엔드만 개발하면 기존 최적화와 코드 생성을 재사용할 수 있다. 새로운 타겟 지원을 위해 백엔드만 개발하면 모든 LLVM 기반 언어가 해당 타겟을 지원할 수 있다. TableGen 도구를 사용하여 타겟 설명을 자동화할 수 있다. 전통적 컴파일러:\n새로운 언어나 타겟 지원을 위해 컴파일러 전체를 수정해야 하는 경우가 많다. 컴포넌트 재사용이 제한적이다. 확장 메커니즘이 덜 체계적이다. JIT 컴파일 지원 LLVM:\n처음부터 JIT 컴파일을 고려하여 설계되었다. MCJIT, ORC JIT 등 다양한 JIT 컴파일 프레임워크를 제공한다. 인터프리터, 동적 언어, REPL 환경 등을 쉽게 구현할 수 있다. 전통적 컴파일러:\n대부분 정적 컴파일에 중점을 둔다. JIT 컴파일 지원이 제한적이거나 없는 경우가 많다. 라이센스와 생태계 LLVM:\nApache 2.0 라이센스로 상업적 이용에 제한이 없다. 애플, 구글, 마이크로소프트 등 대기업의 지원을 받는다. 활발한 커뮤니티와 다양한 도구 생태계를 가지고 있다. 전통적 컴파일러(예: GCC):\nGPL 라이센스로 상업적 이용에 일부 제약이 있다. FSF(자유 소프트웨어 재단)와 커뮤니티 주도로 개발된다. 오랜 역사와 안정성을 가지고 있다. LLVM 기반 컴파일러와 도구 LLVM 인프라스트럭처는 다양한 언어와 도구의 기반이 되고 있다:\n프론트엔드 (언어)\nClang: C, C++, Objective-C를 위한 컴파일러 Swift: 애플의 iOS/macOS 프로그래밍 언어 Rust: 안전한 시스템 프로그래밍 언어 Julia: 과학 컴퓨팅을 위한 동적 언어 Kotlin Native: JVM 외부에서 실행되는 Kotlin 컴파일러 도구 및 프레임워크\nLLDB: 디버깅 도구 lld: 링커 Polly: 다면체 최적화 프레임워크 MLIR: 머신러닝 컴파일러 인프라스트럭처 Sanitizers: AddressSanitizer, ThreadSanitizer 등 다양한 검증 도구 clang-tidy: 정적 분석 도구 clang-format: 코드 포맷팅 도구 Just-In-Time 컴파일\nMCJIT: 기존 JIT 컴파일러 ORC JIT: 최신 JIT 컴파일 프레임워크 WebAssembly: 웹 브라우저에서 네이티브 코드 실행을 위한 기술의 기반 실제 사용 사례와 성능 비교 컴파일 속도\nLLVM(Clang)은 일반적으로 GCC보다 빠른 컴파일 속도를 보인다:\n증분 컴파일에서 특히 효율적 메모리 사용량도 일반적으로 더 효율적 대규모 C++ 프로젝트에서 현저한 속도 차이를 보이는 경우가 많음 생성된 코드 품질\n코드 품질 측면에서는 상황에 따라 차이가 있다:\n일반적인 경우 LLVM과 GCC는 비슷한 수준의 최적화를 제공 특정 벤치마크에서는 GCC가 더 나은 성능을 보이는 경우도 있음 LLVM은 Polly와 같은 고급 최적화 프레임워크를 통해 특수한 경우에 우수한 성능을 발휘 에러 메시지와 진단\nLLVM(Clang)은 개발자 경험 측면에서 큰 강점을 가진다:\n더 명확하고 이해하기 쉬운 에러 메시지 정확한 소스 위치 표시와 오류 수정 제안 컴파일 시간 경고와 정적 분석 도구의 강력한 통합 산업 채택 사례\n애플: macOS, iOS 개발에 LLVM/Clang을 기본 컴파일러로 사용하며, Swift 언어도 LLVM 기반 구글: Android NDK에서 Clang을 기본 컴파일러로 채택, Chrome에서도 Clang 사용 마이크로소프트: Visual Studio에서 Clang 지원, Windows용 LLVM 개발에 기여 퀄컴, ARM, Intel: 자사 프로세서를 위한 LLVM 백엔드 개발 및 지원 미래 전망 LLVM의 발전 방향 MLIR(Multi-Level IR): 더 높은 수준의 추상화와 도메인 특화 컴파일을 지원하는 새로운 IR 시스템 병렬 컴파일: 멀티코어 활용을 더욱 개선하여 컴파일 속도 향상 머신러닝 통합: 컴파일러 최적화 결정에 ML 기술 적용 양자 컴퓨팅 지원: 양자 컴퓨터를 위한 컴파일러 인프라 개발 컴파일러 생태계의 변화 GCC와 같은 전통적 컴파일러도 모듈화와 현대적 기능 도입을 통해 발전하고 있다. 특수 목적 컴파일러와 도메인 특화 언어(DSL)의 증가로 컴파일러 다양성이 확대되고 있다. WebAssembly와 같은 기술로 플랫폼 간 경계가 흐려지고 있다. LLVM과 기존 컴파일러 비교 분석 특성 LLVM 전통적인 컴파일러 (GCC 등) 아키텍처 모듈화된 3단계 구조 (프론트엔드, 최적화기, 백엔드) 일체형 구조 또는 덜 모듈화된 구조 중간 표현 (IR) 통합된 LLVM IR 사용 (SSA 기반) 컴파일러마다 다른 중간 표현 사용 모듈성 높음 (각 컴포넌트를 독립적으로 개발/사용 가능) 낮음 (컴포넌트 간 강한 결합) 재사용성 높음 (다양한 언어와 타겟에 동일 최적화 사용) 제한적 (특정 언어나 타겟에 특화) 확장성 높음 (패스 형태로 새 최적화 추가 용이) 제한적 (기존 코드 수정 필요) 최적화 단계 소스/IR/타겟 레벨 최적화 분리 전통적으로 단일화된 최적화 과정 지원 언어 다양함 (C, C++, Swift, Rust, Julia 등) 제한적 (GCC는 주로 C, C++, Objective-C 등) 타겟 지원 광범위 (x86, ARM, MIPS, WebAssembly 등) 일반적으로 제한적 (특정 컴파일러마다 다름) JIT 컴파일 내장 지원 (MCJIT, ORC JIT) 일반적으로 제한적이거나 없음 툴체인 통합 높음 (clang, lld, LLDB 등 일관된 도구) 제한적 (도구 간 통합 수준 낮음) API 접근성 높음 (라이브러리로 설계됨) 낮음 (많은 경우 독립 실행형 프로그램) 라이센스 Apache 2.0 (상업적 이용 자유로움) 주로 GPL (GCC 등, 상업적 이용 제한) 디버깅 정보 표준화된 디버깅 정보 생성 (DWARF) 컴파일러마다 다양한 형식 사용 컴파일 속도 빠름 (특히 증분 컴파일) 일반적으로 느림 (개선 중) 최적화 수준 매우 높음 (광범위한 최적화 패스) 높음 (일부 경우 LLVM보다 나은 최적화) 개발 활동 활발함 (대기업들의 지원) 다양함 (GCC는 활발, 다른 것들은 덜함) 크로스 컴파일 쉬움 (설계부터 고려됨) 복잡함 (일부 컴파일러) 링크 시간 최적화 강력함 (설계부터 고려됨) 제한적 (후기에 추가된 기능) 정적 분석 도구 다양함 (clang-tidy, analyzer 등) 제한적 (컴파일러마다 다름) 에러 메시지 품질 우수함 (특히 Clang) 다양함 (개선 중) 새로운 언어 개발용이성 높음 (많은 새 언어가 LLVM 기반) 낮음 (새 언어 프론트엔드 개발 어려움) 지속적 통합 친화성 높음 (API 기반으로 도구 통합 용이) 제한적 (주로 명령줄 도구) 플러그인 시스템 강력하고 문서화 잘됨 제한적이거나 문서화 부족 커뮤니티 생태계 활발함 (다양한 언어와 프로젝트) 다양함 (컴파일러마다 다름) 참고 및 출처 ","wordCount":"1491","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-05T07:28:00Z","dateModified":"2024-12-05T07:28:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/>Programming Languages's Fundamentals</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/>언어 프로세서(Language Processor)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/>컴파일러(Compiler)</a></div><h1 class="post-title entry-hint-parent">LLVM vs 기존 컴파일러 비교</h1><div class=post-description>LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다. 전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.</div><div class=post-meta><span title='2024-12-05 07:28:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1491 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Fundamentals/Language%20Processor/Compiler/llvm-vs-%ea%b8%b0%ec%a1%b4-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac-%eb%b9%84%ea%b5%90.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#llvm-vs-기존-컴파일러-비교>LLVM Vs 기존 컴파일러 비교</a><ul><li><a href=#llvm의-개념과-구조>LLVM의 개념과 구조</a></li><li><a href=#llvm의-한계와-도전-과제>LLVM의 한계와 도전 과제</a></li><li><a href=#전통적인-컴파일러의-구조와-특징>전통적인 컴파일러의 구조와 특징</a></li><li><a href=#llvm과-기존-컴파일러의-주요-차이점>LLVM과 기존 컴파일러의 주요 차이점</a></li><li><a href=#llvm-기반-컴파일러와-도구>LLVM 기반 컴파일러와 도구</a></li><li><a href=#실제-사용-사례와-성능-비교>실제 사용 사례와 성능 비교</a></li><li><a href=#미래-전망>미래 전망</a></li><li><a href=#llvm과-기존-컴파일러-비교-분석>LLVM과 기존 컴파일러 비교 분석</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=llvm-vs-기존-컴파일러-비교>LLVM Vs 기존 컴파일러 비교<a hidden class=anchor aria-hidden=true href=#llvm-vs-기존-컴파일러-비교>#</a></h2><p>LLVM(Low Level Virtual Machine)은 모듈식 컴파일러 인프라스트럭처로, 다양한 프로그래밍 언어와 하드웨어 플랫폼을 지원하도록 설계되었다.</p><p>LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.<br>전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.</p><p>그러나 복잡성, 특수 타겟 지원, 리소스 요구사항 등의 측면에서는 여전히 개선의 여지가 있다. 또한 GCC와 같은 전통적인 컴파일러도 계속 발전하면서 LLVM의 장점을 일부 수용하고 있다.</p><p>미래에는 MLIR, 머신러닝 통합, 양자 컴퓨팅 지원 등을 통해 LLVM이 더욱 발전할 것으로 예상되며, 컴파일러 기술 전반이 더욱 다양하고 전문화될 것으로 보인다.</p><h3 id=llvm의-개념과-구조>LLVM의 개념과 구조<a hidden class=anchor aria-hidden=true href=#llvm의-개념과-구조>#</a></h3><p>LLVM(Low Level Virtual Machine)은 현대적인 컴파일러 인프라스트럭처로, 2000년대 초반 크리스 래트너(Chris Lattner)에 의해 개발이 시작되었습니다. LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 다양한 프로그래밍 언어와 하드웨어 아키텍처를 효율적으로 지원하는 것입니다.</p><h4 id=llvm의-3단계-구조>LLVM의 3단계 구조<a hidden class=anchor aria-hidden=true href=#llvm의-3단계-구조>#</a></h4><p>LLVM은 다음과 같은 3단계 구조로 설계되었다:</p><ol><li><strong>프론트엔드</strong>: 소스 코드를 파싱하여 LLVM IR(중간 표현)으로 변환한다. 대표적인 프론트엔드로는 C, C++, Objective-C를 위한 Clang이 있다.</li><li><strong>최적화기(Optimizer)</strong>: 언어와 타겟에 독립적인 다양한 최적화를 LLVM IR에 적용한다. 이 단계에서 인라인화, 루프 최적화, 상수 폴딩 등 수많은 최적화 패스가 수행된다.</li><li><strong>백엔드(코드 생성기)</strong>: 최적화된 LLVM IR을 특정 하드웨어 아키텍처의 기계어로 변환한다. x86, ARM, MIPS, RISC-V 등 다양한 타겟이 지원된다.<br>이러한 구조는 새로운 언어 지원을 위해 프론트엔드만 개발하거나, 새로운 하드웨어 지원을 위해 백엔드만 개발할 수 있게 해주며, 최적화는 공통으로 사용할 수 있다.</li></ol><h4 id=12-llvm-ir중간-표현>1.2 LLVM IR(중간 표현)<a hidden class=anchor aria-hidden=true href=#12-llvm-ir중간-표현>#</a></h4><p>LLVM IR은 LLVM의 핵심 요소로, 다음과 같은 특징을 가집니다:</p><ul><li><strong>정적 단일 할당(SSA) 형식</strong>: 각 변수는 정확히 한 번만 할당되어 최적화를 용이하게 합니다.</li><li><strong>타입 시스템</strong>: 강력한 타입 시스템을 가지고 있어 타입 안전성을 보장합니다.</li><li><strong>세 가지 동등한 형태</strong>: 메모리 내 표현, 비트코드(.bc), 사람이 읽을 수 있는 텍스트 형식(.ll)이 있습니다.</li></ul><p>LLVM IR의 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-llvm data-lang=llvm><span class=line><span class=cl><span class=k>define</span> <span class=k>i32</span> <span class=vg>@add</span><span class=p>(</span><span class=k>i32</span> <span class=nv>%a</span><span class=p>,</span> <span class=k>i32</span> <span class=nv>%b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>entry:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%sum</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i32</span> <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span><span class=line><span class=cl>  <span class=k>ret</span> <span class=k>i32</span> <span class=nv>%sum</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=llvm-프로젝트의-주요-구성-요소>LLVM 프로젝트의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#llvm-프로젝트의-주요-구성-요소>#</a></h4><p>LLVM 프로젝트는 다음과 같은 주요 구성 요소를 포함한다:</p><ul><li><strong>LLVM Core</strong>: 중간 표현, 최적화 패스, 코드 생성기 등의 핵심 기능을 제공한다.</li><li><strong>Clang</strong>: C, C++, Objective-C를 위한 프론트엔드이다.</li><li><strong>lld</strong>: 다양한 형식의 목적 파일을 링크하는 링커이다.</li><li><strong>LLDB</strong>: LLVM 기반의 디버거이다.</li><li><strong>libc++</strong>: C++ 표준 라이브러리 구현이다.</li><li><strong>컴파일러-RT</strong>: 컴파일 시간과 런타임에 필요한 저수준 지원 라이브러리이다.</li></ul><h3 id=llvm의-한계와-도전-과제>LLVM의 한계와 도전 과제<a hidden class=anchor aria-hidden=true href=#llvm의-한계와-도전-과제>#</a></h3><p>LLVM이 많은 장점을 가지고 있지만, 몇 가지 한계와 도전 과제도 존재한다:</p><ol><li><p>복잡성</p><ul><li>LLVM은 강력하지만 학습 곡선이 가파르다.</li><li>방대한 코드베이스와 문서로 인해 완전히 이해하기 어려울 수 있다.</li><li>효과적인 백엔드 개발은 상당한 전문 지식을 요구한다.</li></ul></li><li><p>특수 타겟 지원</p><ul><li>일부 특수한 하드웨어 아키텍처에서는 GCC가 더 나은 지원을 제공할 수 있다.</li><li>오래된 아키텍처나 비주류 아키텍처의 경우 LLVM 지원이 제한적일 수 있다.</li></ul></li><li><p>최적화 안정성</p><ul><li>일부 최적화는 예상치 못한 동작 변화를 일으킬 수 있다.</li><li>최적화 수준이 높을수록 디버깅이 더 어려워질 수 있다.</li></ul></li><li><p>리소스 요구사항</p><ul><li>LLVM 기반 도구는 메모리와 CPU 사용량이 상당할 수 있다.</li><li>제한된 리소스 환경에서는 부담이 될 수 있다.</li></ul></li></ol><h3 id=전통적인-컴파일러의-구조와-특징>전통적인 컴파일러의 구조와 특징<a hidden class=anchor aria-hidden=true href=#전통적인-컴파일러의-구조와-특징>#</a></h3><p>전통적인 컴파일러(예: GCC)는 일반적으로 다음과 같은 단계로 구성된다:</p><ol><li><strong>전처리기(Preprocessor)</strong>: 매크로 확장, 헤더 파일 포함 등의 작업을 수행한다.</li><li><strong>파서(Parser)</strong>: 소스 코드를 구문 분석하여 추상 구문 트리(AST)를 생성한다.</li><li><strong>의미 분석기(Semantic Analyzer)</strong>: AST를 분석하여 타입 체크 등 의미적 정확성을 검증한다.</li><li><strong>중간 코드 생성기</strong>: 중간 표현을 생성한다.</li><li><strong>최적화기</strong>: 중간 코드에 다양한 최적화를 적용한다.</li><li><strong>코드 생성기</strong>: 타겟 기계어를 생성한다.</li><li><strong>어셈블러/링커</strong>: 목적 파일을 생성하고 링크한다.</li></ol><p>전통적인 컴파일러의 특징:</p><ul><li><strong>일체형 구조</strong>: 여러 단계가 밀접하게 결합되어 있어 모듈화 수준이 낮다.</li><li><strong>특정 언어/타겟 중심</strong>: 특정 언어나 타겟 아키텍처에 최적화되어 있다.</li><li><strong>커스터마이징 제한</strong>: 컴파일러의 내부 동작을 변경하거나 확장하기 어렵다.</li></ul><h4 id=gccgnu-compiler-collection>GCC(GNU Compiler Collection)<a hidden class=anchor aria-hidden=true href=#gccgnu-compiler-collection>#</a></h4><p>GCC는 가장 널리 사용되는 전통적 컴파일러 중 하나이다:</p><ul><li><strong>다양한 언어 지원</strong>: C, C++, Objective-C, Fortran, Ada 등을 지원한다.</li><li><strong>다양한 타겟 지원</strong>: 수많은 프로세서 아키텍처를 지원한다.</li><li><strong>GPL 라이센스</strong>: 오픈 소스지만 GPL 라이센스로 배포되어 일부 상업적 이용에 제약이 있다.</li><li><strong>발전 중인 구조</strong>: 최근 버전에서는 GIMPLE과 RTL이라는 중간 표현을 사용하며 모듈화가 개선되고 있다.</li></ul><h4 id=기타-전통적-컴파일러>기타 전통적 컴파일러<a hidden class=anchor aria-hidden=true href=#기타-전통적-컴파일러>#</a></h4><ul><li><strong>Microsoft Visual C++ Compiler</strong>: Windows 환경에서 널리 사용되는 C/C++ 컴파일러.</li><li><strong>Intel C++ Compiler</strong>: Intel 프로세서에 최적화된 코드를 생성하는 컴파일러.</li><li><strong>IBM XL C/C++</strong>: IBM 시스템을 위한 최적화된 컴파일러.</li></ul><h3 id=llvm과-기존-컴파일러의-주요-차이점>LLVM과 기존 컴파일러의 주요 차이점<a hidden class=anchor aria-hidden=true href=#llvm과-기존-컴파일러의-주요-차이점>#</a></h3><h4 id=아키텍처와-모듈성>아키텍처와 모듈성<a hidden class=anchor aria-hidden=true href=#아키텍처와-모듈성>#</a></h4><p><strong>LLVM</strong>:</p><ul><li>모듈화된 3단계 구조로 각 컴포넌트를 독립적으로 개발하고 사용할 수 있다.</li><li>공통 LLVM IR을 중심으로 여러 프론트엔드와 백엔드가 통합된다.</li><li>라이브러리 형태로 설계되어 다른 도구나 애플리케이션에 쉽게 통합될 수 있다.</li></ul><p><strong>전통적 컴파일러</strong>:</p><ul><li>일체형 구조로 컴포넌트 간 강한 결합을 가진다.</li><li>각 컴파일러마다 다른 중간 표현을 사용한다.</li><li>주로 독립 실행형 프로그램으로 설계되어 외부 통합이 어렵다.</li></ul><h4 id=최적화-접근-방식>최적화 접근 방식<a hidden class=anchor aria-hidden=true href=#최적화-접근-방식>#</a></h4><p><strong>LLVM</strong>:</p><ul><li>언어와 타겟에 독립적인 최적화를 IR 수준에서 적용한다.</li><li>패스 매니저를 통해 최적화 패스를 유연하게 구성할 수 있다.</li><li>링크 시간 최적화(LTO)가 설계부터 고려되었다.</li></ul><p><strong>전통적 컴파일러</strong>:</p><ul><li>최적화가 특정 언어나 타겟에 더 밀접하게 결합되어 있다.</li><li>최적화 순서가 더 고정적인 경향이 있다.</li><li>링크 시간 최적화가 후기에 추가된 경우가 많다.</li></ul><h4 id=확장성과-재사용성>확장성과 재사용성<a hidden class=anchor aria-hidden=true href=#확장성과-재사용성>#</a></h4><p><strong>LLVM</strong>:</p><ul><li>새로운 언어 지원을 위해 프론트엔드만 개발하면 기존 최적화와 코드 생성을 재사용할 수 있다.</li><li>새로운 타겟 지원을 위해 백엔드만 개발하면 모든 LLVM 기반 언어가 해당 타겟을 지원할 수 있다.</li><li>TableGen 도구를 사용하여 타겟 설명을 자동화할 수 있다.</li></ul><p><strong>전통적 컴파일러</strong>:</p><ul><li>새로운 언어나 타겟 지원을 위해 컴파일러 전체를 수정해야 하는 경우가 많다.</li><li>컴포넌트 재사용이 제한적이다.</li><li>확장 메커니즘이 덜 체계적이다.</li></ul><h4 id=jit-컴파일-지원>JIT 컴파일 지원<a hidden class=anchor aria-hidden=true href=#jit-컴파일-지원>#</a></h4><p><strong>LLVM</strong>:</p><ul><li>처음부터 JIT 컴파일을 고려하여 설계되었다.</li><li>MCJIT, ORC JIT 등 다양한 JIT 컴파일 프레임워크를 제공한다.</li><li>인터프리터, 동적 언어, REPL 환경 등을 쉽게 구현할 수 있다.</li></ul><p><strong>전통적 컴파일러</strong>:</p><ul><li>대부분 정적 컴파일에 중점을 둔다.</li><li>JIT 컴파일 지원이 제한적이거나 없는 경우가 많다.</li></ul><h4 id=라이센스와-생태계>라이센스와 생태계<a hidden class=anchor aria-hidden=true href=#라이센스와-생태계>#</a></h4><p><strong>LLVM</strong>:</p><ul><li>Apache 2.0 라이센스로 상업적 이용에 제한이 없다.</li><li>애플, 구글, 마이크로소프트 등 대기업의 지원을 받는다.</li><li>활발한 커뮤니티와 다양한 도구 생태계를 가지고 있다.</li></ul><p><strong>전통적 컴파일러(예: GCC)</strong>:</p><ul><li>GPL 라이센스로 상업적 이용에 일부 제약이 있다.</li><li>FSF(자유 소프트웨어 재단)와 커뮤니티 주도로 개발된다.</li><li>오랜 역사와 안정성을 가지고 있다.</li></ul><h3 id=llvm-기반-컴파일러와-도구>LLVM 기반 컴파일러와 도구<a hidden class=anchor aria-hidden=true href=#llvm-기반-컴파일러와-도구>#</a></h3><p>LLVM 인프라스트럭처는 다양한 언어와 도구의 기반이 되고 있다:</p><ol><li><p>프론트엔드 (언어)</p><ul><li><strong>Clang</strong>: C, C++, Objective-C를 위한 컴파일러</li><li><strong>Swift</strong>: 애플의 iOS/macOS 프로그래밍 언어</li><li><strong>Rust</strong>: 안전한 시스템 프로그래밍 언어</li><li><strong>Julia</strong>: 과학 컴퓨팅을 위한 동적 언어</li><li><strong>Kotlin Native</strong>: JVM 외부에서 실행되는 Kotlin 컴파일러</li></ul></li><li><p>도구 및 프레임워크</p><ul><li><strong>LLDB</strong>: 디버깅 도구</li><li><strong>lld</strong>: 링커</li><li><strong>Polly</strong>: 다면체 최적화 프레임워크</li><li><strong>MLIR</strong>: 머신러닝 컴파일러 인프라스트럭처</li><li><strong>Sanitizers</strong>: AddressSanitizer, ThreadSanitizer 등 다양한 검증 도구</li><li><strong>clang-tidy</strong>: 정적 분석 도구</li><li><strong>clang-format</strong>: 코드 포맷팅 도구</li></ul></li><li><p>Just-In-Time 컴파일</p><ul><li><strong>MCJIT</strong>: 기존 JIT 컴파일러</li><li><strong>ORC JIT</strong>: 최신 JIT 컴파일 프레임워크</li><li><strong>WebAssembly</strong>: 웹 브라우저에서 네이티브 코드 실행을 위한 기술의 기반</li></ul></li></ol><h3 id=실제-사용-사례와-성능-비교>실제 사용 사례와 성능 비교<a hidden class=anchor aria-hidden=true href=#실제-사용-사례와-성능-비교>#</a></h3><ol><li><p>컴파일 속도<br>LLVM(Clang)은 일반적으로 GCC보다 빠른 컴파일 속도를 보인다:</p><ul><li>증분 컴파일에서 특히 효율적</li><li>메모리 사용량도 일반적으로 더 효율적</li><li>대규모 C++ 프로젝트에서 현저한 속도 차이를 보이는 경우가 많음</li></ul></li><li><p>생성된 코드 품질<br>코드 품질 측면에서는 상황에 따라 차이가 있다:</p><ul><li>일반적인 경우 LLVM과 GCC는 비슷한 수준의 최적화를 제공</li><li>특정 벤치마크에서는 GCC가 더 나은 성능을 보이는 경우도 있음</li><li>LLVM은 Polly와 같은 고급 최적화 프레임워크를 통해 특수한 경우에 우수한 성능을 발휘</li></ul></li><li><p>에러 메시지와 진단<br>LLVM(Clang)은 개발자 경험 측면에서 큰 강점을 가진다:</p><ul><li>더 명확하고 이해하기 쉬운 에러 메시지</li><li>정확한 소스 위치 표시와 오류 수정 제안</li><li>컴파일 시간 경고와 정적 분석 도구의 강력한 통합</li></ul></li><li><p>산업 채택 사례</p><ul><li><strong>애플</strong>: macOS, iOS 개발에 LLVM/Clang을 기본 컴파일러로 사용하며, Swift 언어도 LLVM 기반</li><li><strong>구글</strong>: Android NDK에서 Clang을 기본 컴파일러로 채택, Chrome에서도 Clang 사용</li><li><strong>마이크로소프트</strong>: Visual Studio에서 Clang 지원, Windows용 LLVM 개발에 기여</li><li><strong>퀄컴, ARM, Intel</strong>: 자사 프로세서를 위한 LLVM 백엔드 개발 및 지원</li></ul></li></ol><h3 id=미래-전망>미래 전망<a hidden class=anchor aria-hidden=true href=#미래-전망>#</a></h3><h4 id=llvm의-발전-방향>LLVM의 발전 방향<a hidden class=anchor aria-hidden=true href=#llvm의-발전-방향>#</a></h4><ul><li><strong>MLIR(Multi-Level IR)</strong>: 더 높은 수준의 추상화와 도메인 특화 컴파일을 지원하는 새로운 IR 시스템</li><li><strong>병렬 컴파일</strong>: 멀티코어 활용을 더욱 개선하여 컴파일 속도 향상</li><li><strong>머신러닝 통합</strong>: 컴파일러 최적화 결정에 ML 기술 적용</li><li><strong>양자 컴퓨팅 지원</strong>: 양자 컴퓨터를 위한 컴파일러 인프라 개발</li></ul><h4 id=컴파일러-생태계의-변화>컴파일러 생태계의 변화<a hidden class=anchor aria-hidden=true href=#컴파일러-생태계의-변화>#</a></h4><ul><li>GCC와 같은 전통적 컴파일러도 모듈화와 현대적 기능 도입을 통해 발전하고 있다.</li><li>특수 목적 컴파일러와 도메인 특화 언어(DSL)의 증가로 컴파일러 다양성이 확대되고 있다.</li><li>WebAssembly와 같은 기술로 플랫폼 간 경계가 흐려지고 있다.</li></ul><h3 id=llvm과-기존-컴파일러-비교-분석>LLVM과 기존 컴파일러 비교 분석<a hidden class=anchor aria-hidden=true href=#llvm과-기존-컴파일러-비교-분석>#</a></h3><table><thead><tr><th>특성</th><th>LLVM</th><th>전통적인 컴파일러 (GCC 등)</th></tr></thead><tbody><tr><td><strong>아키텍처</strong></td><td>모듈화된 3단계 구조 (프론트엔드, 최적화기, 백엔드)</td><td>일체형 구조 또는 덜 모듈화된 구조</td></tr><tr><td><strong>중간 표현 (IR)</strong></td><td>통합된 LLVM IR 사용 (SSA 기반)</td><td>컴파일러마다 다른 중간 표현 사용</td></tr><tr><td><strong>모듈성</strong></td><td>높음 (각 컴포넌트를 독립적으로 개발/사용 가능)</td><td>낮음 (컴포넌트 간 강한 결합)</td></tr><tr><td><strong>재사용성</strong></td><td>높음 (다양한 언어와 타겟에 동일 최적화 사용)</td><td>제한적 (특정 언어나 타겟에 특화)</td></tr><tr><td><strong>확장성</strong></td><td>높음 (패스 형태로 새 최적화 추가 용이)</td><td>제한적 (기존 코드 수정 필요)</td></tr><tr><td><strong>최적화 단계</strong></td><td>소스/IR/타겟 레벨 최적화 분리</td><td>전통적으로 단일화된 최적화 과정</td></tr><tr><td><strong>지원 언어</strong></td><td>다양함 (C, C++, Swift, Rust, Julia 등)</td><td>제한적 (GCC는 주로 C, C++, Objective-C 등)</td></tr><tr><td><strong>타겟 지원</strong></td><td>광범위 (x86, ARM, MIPS, WebAssembly 등)</td><td>일반적으로 제한적 (특정 컴파일러마다 다름)</td></tr><tr><td><strong>JIT 컴파일</strong></td><td>내장 지원 (MCJIT, ORC JIT)</td><td>일반적으로 제한적이거나 없음</td></tr><tr><td><strong>툴체인 통합</strong></td><td>높음 (clang, lld, LLDB 등 일관된 도구)</td><td>제한적 (도구 간 통합 수준 낮음)</td></tr><tr><td><strong>API 접근성</strong></td><td>높음 (라이브러리로 설계됨)</td><td>낮음 (많은 경우 독립 실행형 프로그램)</td></tr><tr><td><strong>라이센스</strong></td><td>Apache 2.0 (상업적 이용 자유로움)</td><td>주로 GPL (GCC 등, 상업적 이용 제한)</td></tr><tr><td><strong>디버깅 정보</strong></td><td>표준화된 디버깅 정보 생성 (DWARF)</td><td>컴파일러마다 다양한 형식 사용</td></tr><tr><td><strong>컴파일 속도</strong></td><td>빠름 (특히 증분 컴파일)</td><td>일반적으로 느림 (개선 중)</td></tr><tr><td><strong>최적화 수준</strong></td><td>매우 높음 (광범위한 최적화 패스)</td><td>높음 (일부 경우 LLVM보다 나은 최적화)</td></tr><tr><td><strong>개발 활동</strong></td><td>활발함 (대기업들의 지원)</td><td>다양함 (GCC는 활발, 다른 것들은 덜함)</td></tr><tr><td><strong>크로스 컴파일</strong></td><td>쉬움 (설계부터 고려됨)</td><td>복잡함 (일부 컴파일러)</td></tr><tr><td><strong>링크 시간 최적화</strong></td><td>강력함 (설계부터 고려됨)</td><td>제한적 (후기에 추가된 기능)</td></tr><tr><td><strong>정적 분석 도구</strong></td><td>다양함 (clang-tidy, analyzer 등)</td><td>제한적 (컴파일러마다 다름)</td></tr><tr><td><strong>에러 메시지 품질</strong></td><td>우수함 (특히 Clang)</td><td>다양함 (개선 중)</td></tr><tr><td><strong>새로운 언어 개발용이성</strong></td><td>높음 (많은 새 언어가 LLVM 기반)</td><td>낮음 (새 언어 프론트엔드 개발 어려움)</td></tr><tr><td><strong>지속적 통합 친화성</strong></td><td>높음 (API 기반으로 도구 통합 용이)</td><td>제한적 (주로 명령줄 도구)</td></tr><tr><td><strong>플러그인 시스템</strong></td><td>강력하고 문서화 잘됨</td><td>제한적이거나 문서화 부족</td></tr><tr><td><strong>커뮤니티 생태계</strong></td><td>활발함 (다양한 언어와 프로젝트)</td><td>다양함 (컴파일러마다 다름)</td></tr></tbody></table><hr><h3 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/language-processor/>Language-Processor</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/llvm/>LLVM</a></li><li><a href=https://buenhyden.github.io/tags/low-level-virtual-machine/>Low-Level-Virtual-Machine</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/programming-languages/python-vs-javascript-vs-typescript-vs-java/><span class=title>« Prev</span><br><span>Python vs Javascript vs Typescript vs Java</span>
</a><a class=next href=https://buenhyden.github.io/posts/frontend/web-browser/service-worker/><span class=title>Next »</span><br><span>Service Worker</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>