<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>가비지 컬렉션 (Garbage Collection, GC) | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Garbage-Collection,가비지컬렉션"><meta name=description content="프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/memory-management/garbage-collection/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/memory-management/garbage-collection/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/memory-management/garbage-collection/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/memory-management/garbage-collection/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="가비지 컬렉션 (Garbage Collection, GC)"><meta property="og:description" content="프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="가비지 컬렉션 (Garbage Collection, GC)"><meta name=twitter:description content="프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"가비지 컬렉션 (Garbage Collection, GC)","item":"https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/memory-management/garbage-collection/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>가비지 컬렉션 (Garbage Collection, GC)</h1><div class=post-description>프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능</div></header><div class=post-content><h2 id=가비지-컬렉션-garbage-collection-gc>가비지 컬렉션 (Garbage Collection, GC)<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션-garbage-collection-gc>#</a></h2><p>가비지 컬렉션(Garbage Collection, GC)은 컴퓨터 프로그래밍에서 더 이상 사용되지 않는 메모리, 즉 &lsquo;가비지(garbage)&lsquo;를 자동으로 식별하고 해제하는 메모리 관리 기법이다.<br>프로그래머가 명시적으로 메모리를 할당하고 해제하는 대신, 런타임 시스템이 메모리 관리를 담당함으로써 개발 생산성을 높이고 메모리 관련 오류를 줄이는 데 기여한다.</p><p>가비지 컬렉션은 현대 프로그래밍 언어의 핵심 기능으로, 메모리 관리의 복잡성을 줄이고 개발 생산성을 높이는 데 크게 기여해왔다. 다양한 GC 알고리즘과 최적화 기법이 발전하면서, 초기의 단순한 마크-스윕 접근법에서 오늘날의 정교한 세대별, 동시, 병렬 가비지 컬렉터에 이르기까지 많은 진보가 있었다.</p><p>GC는 편의성과 성능 사이의 균형을 추구한다. 개발자는 자신의 애플리케이션 특성과 요구사항에 맞는 GC 알고리즘과 설정을 선택하고, 객체 생성 패턴과 메모리 사용을 최적화하여 GC 오버헤드를 최소화해야 한다.</p><h3 id=가비지의-정의>가비지의 정의<a hidden class=anchor aria-hidden=true href=#가비지의-정의>#</a></h3><p>가비지 컬렉션에서 &lsquo;가비지&rsquo;는 다음과 같이 정의된다:</p><ul><li><strong>더 이상 참조되지 않는 객체</strong>: 프로그램의 어떤 부분에서도 접근할 수 없는 메모리 영역</li><li><strong>접근 불가능한 메모리</strong>: 프로그램의 &ldquo;루트(roots)&ldquo;에서 시작하여 어떤 참조 경로로도 도달할 수 없는 메모리</li></ul><p>예를 들어, 다음 Java 코드를 살펴보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>createGarbage</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Object</span><span class=w> </span><span class=n>obj1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w> </span><span class=c1>// obj1 객체 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Object</span><span class=w> </span><span class=n>obj2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>();</span><span class=w> </span><span class=c1>// obj2 객체 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>obj1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>obj2</span><span class=p>;</span><span class=w> </span><span class=c1>// obj1이 이제 obj2를 가리킴</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 최초 obj1이 가리키던 객체는 이제 가비지가 됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>obj1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=c1>// obj1 참조 제거</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>obj2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=c1>// obj2 참조 제거</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 두 객체 모두 이제 가비지가 됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=가비지-컬렉션의-목적>가비지 컬렉션의 목적<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션의-목적>#</a></h3><p>가비지 컬렉션은 다음과 같은 목적을 가지고 있다:</p><ol><li><strong>메모리 누수 방지</strong>: 더 이상 사용되지 않는 메모리를 자동으로 회수하여 메모리 누수 방지</li><li><strong>댕글링 포인터(dangling pointer) 방지</strong>: 이미 해제된 메모리를 참조하는 위험한 상황 예방</li><li><strong>이중 해제(double free) 방지</strong>: 이미 해제된 메모리를 다시 해제하는 오류 예방</li><li><strong>개발자 부담 감소</strong>: 메모리 관리의 복잡성을 줄여 개발자가 핵심 로직에 집중할 수 있게 함</li></ol><h3 id=가비지-컬렉션의-역사>가비지 컬렉션의 역사<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션의-역사>#</a></h3><p>가비지 컬렉션의 개념은 1959년 John McCarthy가 Lisp 언어를 위해 처음 도입했다. 이후 다양한 프로그래밍 언어와 시스템에서 발전해왔다:</p><ul><li><strong>1960년대</strong>: Lisp의 기본 마크-스윕(Mark-Sweep) 알고리즘 개발</li><li><strong>1970-1980년대</strong>: Smalltalk, Prolog 등의 언어에서 GC 채택 및 발전</li><li><strong>1990년대</strong>: Java의 등장으로 GC가 주류 프로그래밍 환경에 도입</li><li><strong>2000년대 이후</strong>: 세대별 수집, 병렬/동시 GC 등 고급 기법 발전</li></ul><h3 id=가비지-컬렉션의-기본-원리>가비지 컬렉션의 기본 원리<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션의-기본-원리>#</a></h3><p>가비지 컬렉션의 작동 원리는 크게 두 가지 단계로 나눌 수 있다:</p><h4 id=가비지-식별garbage-detection>가비지 식별(Garbage Detection)<a hidden class=anchor aria-hidden=true href=#가비지-식별garbage-detection>#</a></h4><p>가비지를 식별하는 대표적인 두 가지 방법이 있다:</p><h5 id=참조-카운팅reference-counting>참조 카운팅(Reference Counting)<a hidden class=anchor aria-hidden=true href=#참조-카운팅reference-counting>#</a></h5><p>각 객체마다 그것을 참조하는 개수를 추적하는 방식이다.</p><p><strong>작동 방식</strong>:</p><ol><li>객체가 생성될 때 참조 카운트는 1로 시작</li><li>새로운 참조가 생성될 때마다 카운트 증가</li><li>참조가 제거될 때마다 카운트 감소</li><li>참조 카운트가 0이 되면 객체는 가비지로 간주되어 즉시 수거됨</li></ol><p><strong>예시 코드</strong> (의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>function createObject():
</span></span><span class=line><span class=cl>    object = allocate_memory()
</span></span><span class=line><span class=cl>    object.reference_count = 1
</span></span><span class=line><span class=cl>    return object
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function addReference(object):
</span></span><span class=line><span class=cl>    object.reference_count += 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>function removeReference(object):
</span></span><span class=line><span class=cl>    object.reference_count -= 1
</span></span><span class=line><span class=cl>    if object.reference_count == 0:
</span></span><span class=line><span class=cl>        collect(object)
</span></span></code></pre></td></tr></table></div></div><p><strong>장점</strong>:</p><ul><li>객체가 가비지가 되는 즉시 수거 가능</li><li>예측 가능한 성능 특성</li></ul><p><strong>단점</strong>:</p><ul><li>순환 참조 문제: 서로를 참조하는 객체들은 실제로는 접근 불가능해도 참조 카운트가 0이 아님</li><li>참조 카운트 업데이트가 자주 발생하여 오버헤드 발생</li></ul><h5 id=도달성-분석reachability-analysis>도달성 분석(Reachability Analysis)<a hidden class=anchor aria-hidden=true href=#도달성-분석reachability-analysis>#</a></h5><p>프로그램의 &ldquo;루트(roots)&ldquo;에서 시작하여 접근 가능한 모든 객체를 찾는 방식이다.<br>루트에서 접근할 수 없는 객체는 가비지로 간주된다.</p><p><strong>루트의 예</strong>:</p><ul><li>전역 변수</li><li>스택에 있는 지역 변수</li><li>활성화된 스레드</li><li>JNI 참조(Java의 경우)</li></ul><p><strong>작동 방식</strong>:</p><ol><li>루트에서 시작하여 참조를 따라 모든 도달 가능한 객체를 표시(marking)</li><li>표시되지 않은 객체는 가비지로 간주</li></ol><p><strong>장점</strong>:</p><ul><li>순환 참조 문제를 해결함</li><li>참조 갱신 오버헤드가 없음</li></ul><p><strong>단점</strong>:</p><ul><li>수집 과정 중 애플리케이션이 일시 중지될 수 있음(Stop-the-world)</li><li>메모리가 즉시 해제되지 않고 GC 사이클이 필요함</li></ul><h4 id=가비지-수집garbage-collection>가비지 수집(Garbage Collection)<a hidden class=anchor aria-hidden=true href=#가비지-수집garbage-collection>#</a></h4><p>식별된 가비지를 실제로 수집하여 메모리를 해제하는 단계이다.<br>주요 방식으로는:</p><ol><li>마크-스윕(Mark and Sweep)<ol><li><strong>마크 단계</strong>: 루트에서 도달 가능한 모든 객체에 마크를 함</li><li><strong>스윕 단계</strong>: 마크되지 않은 객체를 가비지로 간주하고 해제함</li></ol></li><li>마크-콤팩트(Mark and Compact)<ol><li><strong>마크 단계</strong>: 도달 가능한 객체에 마크</li><li><strong>콤팩트 단계</strong>: 살아있는 객체들을 메모리의 한쪽 끝으로 모아 메모리 단편화를 줄임</li></ol></li><li>복사(Copying)<ol><li>메모리를 두 영역으로 나눔</li><li>한 영역에서만 객체 할당</li><li>GC 시점에 살아있는 객체를 다른 영역으로 복사</li><li>원래 영역은 모두 지움</li></ol></li></ol><h3 id=가비지-컬렉션-알고리즘>가비지 컬렉션 알고리즘<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션-알고리즘>#</a></h3><p>다양한 가비지 컬렉션 알고리즘과 그 특성을 살펴보겠습니다.</p><h4 id=기본-알고리즘>기본 알고리즘<a hidden class=anchor aria-hidden=true href=#기본-알고리즘>#</a></h4><h5 id=마크-스윕-알고리즘>마크-스윕 알고리즘<a hidden class=anchor aria-hidden=true href=#마크-스윕-알고리즘>#</a></h5><p>앞서 설명한 대로, 도달 가능한 객체를 마크하고 나머지를 스윕(해제)하는 방식.</p><p><strong>구체적인 과정</strong>:</p><ol><li>GC 루트에서 시작하여 모든 참조를 따라가며 도달 가능한 객체에 마크 비트 설정</li><li>힙 전체를 순회하며 마크되지 않은 객체 메모리 해제</li><li>마크 비트 초기화</li></ol><p><strong>특징</strong>:</p><ul><li>단편화 문제 발생 가능</li><li>메모리 효율성 중간 수준</li><li>CPU 사용량 중간 수준</li></ul><h5 id=마크-콤팩트-알고리즘>마크-콤팩트 알고리즘<a hidden class=anchor aria-hidden=true href=#마크-콤팩트-알고리즘>#</a></h5><p>마크-스윕에 추가로 살아있는 객체들을 메모리 한쪽으로 모으는 단계가 있다.</p><p><strong>구체적인 과정</strong>:</p><ol><li>마크 단계: 도달 가능한 객체 표시</li><li>콤팩트 단계: 살아있는 객체들을 메모리 한쪽으로 이동시키고 참조 업데이트</li></ol><p><strong>특징</strong>:</p><ul><li>단편화 문제 해결</li><li>메모리 효율성 높음</li><li>CPU 사용량 높음 (객체 이동 및 참조 업데이트 필요)</li></ul><h4 id=복사-알고리즘>복사 알고리즘<a hidden class=anchor aria-hidden=true href=#복사-알고리즘>#</a></h4><p>메모리를 동일한 크기의 두 반으로 나누고(From-space와 To-space), 한 공간에서만 객체 할당이 이루어진다.</p><p><strong>구체적인 과정</strong>:</p><ol><li>From-space에서만 객체 할당</li><li>GC 시점에 살아있는 객체를 To-space로 복사</li><li>From-space와 To-space 역할 교체</li></ol><p><strong>특징</strong>:</p><ul><li>단편화 없음</li><li>메모리 효율성 낮음 (전체 메모리의 절반만 사용)</li><li>객체 할당 속도 빠름 (단순 포인터 증가)</li><li>CPU 사용량 중간 수준</li></ul><h4 id=세대별-가비지-컬렉션generational-garbage-collection>세대별 가비지 컬렉션(Generational Garbage Collection)<a hidden class=anchor aria-hidden=true href=#세대별-가비지-컬렉션generational-garbage-collection>#</a></h4><p>객체의 수명 특성을 활용한 최적화된 GC 알고리즘이다.<br>&ldquo;약한 세대 가설(Weak Generational Hypothesis)&ldquo;에 기반하는데, 이는 대부분의 객체가 짧은 생명주기를 가지며 오래 생존한 객체는 계속 생존할 가능성이 높다는 관찰에 근거한다.</p><p><strong>세대 구분</strong>:</p><ul><li><strong>Young Generation(젊은 세대)</strong>: 새로 생성된 객체들이 위치<ul><li><strong>Eden Space</strong>: 객체가 처음 생성되는 공간</li><li><strong>Survivor Spaces(S0, S1)</strong>: Minor GC를 통해 살아남은 객체가 이동하는 공간</li></ul></li><li><strong>Old Generation(오래된 세대)</strong>: 여러 GC 주기 동안 살아남은 객체들이 위치</li></ul><p><strong>작동 방식</strong>:</p><ol><li>새 객체는 Eden에 할당</li><li>Eden이 가득 차면 Minor GC 발생:<ul><li>살아있는 객체는 비어있는 Survivor 공간으로 이동</li><li>Eden은 완전히 비워짐</li></ul></li><li>다음 Minor GC 때는 Eden과 사용 중인 Survivor 공간에서 살아있는 객체가 다른 Survivor 공간으로 이동</li><li>객체가 특정 연령(age) 임계값을 넘기면 Old Generation으로 승격(promotion)</li><li>Old Generation이 가득 차면 Major GC(Full GC) 발생</li></ol><p><strong>장점</strong>:</p><ul><li>대부분의 GC는 Young Generation에서만 발생하여 효율적</li><li>전체 애플리케이션 중단 시간 감소</li><li>메모리 효율성 향상</li></ul><p><strong>단점</strong>:</p><ul><li>구현 복잡성 증가</li><li>세대 간 참조 추적을 위한 추가 오버헤드</li></ul><h4 id=병렬-동시-및-증분-가비지-컬렉션>병렬, 동시 및 증분 가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#병렬-동시-및-증분-가비지-컬렉션>#</a></h4><p>GC로 인한 애플리케이션 중단 시간을 최소화하기 위한 고급 기법.</p><h5 id=병렬-가비지-컬렉션parallel-gc>병렬 가비지 컬렉션(Parallel GC)<a hidden class=anchor aria-hidden=true href=#병렬-가비지-컬렉션parallel-gc>#</a></h5><p>여러 스레드를 사용하여 GC 작업을 병렬로 수행한다.</p><p><strong>특징</strong>:</p><ul><li>멀티코어 CPU 활용</li><li>전체 GC 소요 시간 감소</li><li>애플리케이션은 여전히 GC 동안 중단됨</li></ul><h5 id=동시-가비지-컬렉션concurrent-gc>동시 가비지 컬렉션(Concurrent GC)<a hidden class=anchor aria-hidden=true href=#동시-가비지-컬렉션concurrent-gc>#</a></h5><p>GC 작업의 일부를 애플리케이션 실행과 동시에 수행한다.</p><p><strong>특징</strong>:</p><ul><li>애플리케이션 중단 시간 최소화</li><li>CPU 리소스 경쟁으로 인한 전체 애플리케이션 처리량 감소 가능</li><li>구현 복잡성 증가</li></ul><h5 id=증분-가비지-컬렉션incremental-gc>증분 가비지 컬렉션(Incremental GC)<a hidden class=anchor aria-hidden=true href=#증분-가비지-컬렉션incremental-gc>#</a></h5><p>GC 작업을 작은 단위로 나누어 점진적으로 수행한다.</p><p><strong>특징</strong>:</p><ul><li>긴 GC 일시 중지를 여러 개의 짧은 중지로 분산</li><li>일관된 응답 시간 제공</li><li>총 GC 시간은 증가할 수 있음</li></ul><h3 id=다양한-프로그래밍-언어의-가비지-컬렉션>다양한 프로그래밍 언어의 가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#다양한-프로그래밍-언어의-가비지-컬렉션>#</a></h3><h4 id=java의-가비지-컬렉션>Java의 가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#java의-가비지-컬렉션>#</a></h4><p>Java는 가장 발전된 GC 시스템 중 하나를 가지고 있으며, JVM은 다양한 GC 알고리즘을 제공한다.</p><h5 id=hotspot-jvm의-주요-gc-알고리즘>HotSpot JVM의 주요 GC 알고리즘<a hidden class=anchor aria-hidden=true href=#hotspot-jvm의-주요-gc-알고리즘>#</a></h5><ol><li><p><strong>Serial GC</strong>: 단일 스레드 GC로 작은 애플리케이션에 적합</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 활성화 방법</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseSerialGC</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Parallel GC</strong>: 다중 스레드로 GC 수행, 처리량 중심</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 활성화 방법</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseParallelGC</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Concurrent Mark Sweep (CMS)</strong>: 애플리케이션 중단을 최소화하는 동시 수집기</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 활성화 방법</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseConcMarkSweepGC</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Garbage First (G1) GC</strong>: 큰 힙을 위한 낮은 지연 시간 수집기</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 활성화 방법</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseG1GC</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Z Garbage Collector (ZGC)</strong>: 매우 낮은 지연 시간 보장(10ms 미만)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 활성화 방법 (Java 11+)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseZGC</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h5 id=java-gc-모니터링-및-튜닝>Java GC 모니터링 및 튜닝<a hidden class=anchor aria-hidden=true href=#java-gc-모니터링-및-튜닝>#</a></h5><p>Java는 GC 활동을 모니터링하고 튜닝하기 위한 풍부한 도구를 제공한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// GC 로깅 활성화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>verbose</span><span class=p>:</span><span class=n>gc</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>PrintGCDetails</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>PrintGCTimeStamps</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 힙 크기 조정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>Xms1g</span><span class=w> </span><span class=o>-</span><span class=n>Xmx4g</span><span class=w> </span><span class=n>MyApp</span><span class=w>  </span><span class=c1>// 초기 힙 1GB, 최대 힙 4GB</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 세대 크기 조정 (G1 GC)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=n>NewRatio</span><span class=o>=</span><span class=n>2</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=n>SurvivorRatio</span><span class=o>=</span><span class=n>8</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=python의-가비지-컬렉션>Python의 가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#python의-가비지-컬렉션>#</a></h4><p>Python은 참조 카운팅을 기본 메커니즘으로 사용하며, 순환 참조 처리를 위한 추가 GC를 제공한다.</p><h5 id=참조-카운팅>참조 카운팅<a hidden class=anchor aria-hidden=true href=#참조-카운팅>#</a></h5><p>Python의 모든 객체는 참조 카운트를 유지하며, 카운트가 0이 되면 즉시 해제된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 객체의 현재 참조 카운트 확인</span>
</span></span><span class=line><span class=cl><span class=n>obj</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>getrefcount</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 1 출력 (getrefcount 호출 자체가 임시 참조 추가)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 참조 추가</span>
</span></span><span class=line><span class=cl><span class=n>ref</span> <span class=o>=</span> <span class=n>obj</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>getrefcount</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 2 출력</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 참조 제거</span>
</span></span><span class=line><span class=cl><span class=n>ref</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>getrefcount</span><span class=p>(</span><span class=n>obj</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>  <span class=c1># 1 출력</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=순환-참조-컬렉터>순환 참조 컬렉터<a hidden class=anchor aria-hidden=true href=#순환-참조-컬렉터>#</a></h5><p>순환 참조를 처리하기 위해 Python은 세대별 가비지 컬렉터를 제공한다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>gc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 현재 GC 임계값 확인 (각 세대별 임계값)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>gc</span><span class=o>.</span><span class=n>get_threshold</span><span class=p>())</span>  <span class=c1># 기본값: (700, 10, 10)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># GC 수동 실행</span>
</span></span><span class=line><span class=cl><span class=n>gc</span><span class=o>.</span><span class=n>collect</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># GC 비활성화/활성화</span>
</span></span><span class=line><span class=cl><span class=n>gc</span><span class=o>.</span><span class=n>disable</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>gc</span><span class=o>.</span><span class=n>enable</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 가비지 컬렉터 통계</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>gc</span><span class=o>.</span><span class=n>get_stats</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=javascript의-가비지-컬렉션>JavaScript의 가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#javascript의-가비지-컬렉션>#</a></h4><p>JavaScript 엔진은 대부분 도달성 분석 기반의 GC를 사용한다.<br>V8(Chrome, Node.js)을 예로 들면:</p><h5 id=v8-엔진의-gc>V8 엔진의 GC<a hidden class=anchor aria-hidden=true href=#v8-엔진의-gc>#</a></h5><ul><li><strong>Scavenge(Minor GC)</strong>: Young 객체를 위한 빠른 복사 알고리즘</li><li><strong>Mark-Sweep-Compact(Major GC)</strong>: Old 객체를 위한 전체 GC</li></ul><p>JavaScript에서는 직접적인 GC 제어가 제한적이지만, 메모리 사용 패턴을 최적화할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// 참조 제거로 객체 회수 가능하게 만들기
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span> <span class=nx>largeObject</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>data</span><span class=o>:</span> <span class=k>new</span> <span class=nb>Array</span><span class=p>(</span><span class=mi>10000000</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// 작업 완료 후
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>largeObject</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>  <span class=c1>// 참조 제거로 GC 대상이 됨
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// WeakMap/WeakSet 사용으로 약한 참조 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>weakMap</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>WeakMap</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>key</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=nx>weakMap</span><span class=p>.</span><span class=nx>set</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=s2>&#34;value&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// key에 대한 다른 참조가 없어지면 WeakMap의 항목도 GC 대상이 됨
</span></span></span></code></pre></td></tr></table></div></div><h4 id=go의-가비지-컬렉션>Go의 가비지 컬렉션<a hidden class=anchor aria-hidden=true href=#go의-가비지-컬렉션>#</a></h4><p>Go는 동시 마크-스윕 알고리즘을 사용하며 간결한 설계가 특징이다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Go에서는 GC 제어가 최소화되어 있음</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=s>&#34;runtime&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 수동 GC 실행 (테스트/디버깅 목적)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>runtime</span><span class=p>.</span><span class=nf>GC</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// GC 통계</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>var</span><span class=w> </span><span class=nx>stats</span><span class=w> </span><span class=nx>runtime</span><span class=p>.</span><span class=nx>MemStats</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nx>runtime</span><span class=p>.</span><span class=nf>ReadMemStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>stats</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>println</span><span class=p>(</span><span class=s>&#34;Next GC:&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>stats</span><span class=p>.</span><span class=nx>NextGC</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nb>println</span><span class=p>(</span><span class=s>&#34;GC Cycles:&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>stats</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Go의 GC는 짧은 중단 시간(1ms 미만)과 낮은 오버헤드를 목표로 설계되어 있다.</p><h3 id=가비지-컬렉션-최적화-전략>가비지 컬렉션 최적화 전략<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션-최적화-전략>#</a></h3><p>애플리케이션 성능을 최적화하기 위한 GC 관련 전략.</p><h4 id=객체-생명주기-관리>객체 생명주기 관리<a hidden class=anchor aria-hidden=true href=#객체-생명주기-관리>#</a></h4><ol><li><p>단기 객체 최소화<br>대부분의 GC 오버헤드는 짧은 수명의 객체에서 발생한다.<br>이를 줄이는 전략:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 최적화 전 (많은 임시 객체 생성)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>1000</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>result</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=s>&#34;Value &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>  </span><span class=c1>// 매 반복마다 새 String 객체 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 최적화 후 (한 개의 가변 객체 재사용)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>StringBuilder</span><span class=w> </span><span class=n>sb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuilder</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>1000</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sb</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=s>&#34;Value &#34;</span><span class=p>).</span><span class=na>append</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>  </span><span class=c1>// 기존 객체 재사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sb</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>  </span><span class=c1>// 최종 결과만 String으로 변환</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>객체 풀링 활용<br>자주 생성되고 해제되는 객체는 풀링을 통해 재사용할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Apache Commons Pool 라이브러리 사용 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>GenericObjectPool</span><span class=o>&lt;</span><span class=n>MyExpensiveObject</span><span class=o>&gt;</span><span class=w> </span><span class=n>pool</span><span class=w> </span><span class=o>=</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>new</span><span class=w> </span><span class=n>GenericObjectPool</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>MyObjectFactory</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>pool</span><span class=p>.</span><span class=na>setMaxIdle</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>pool</span><span class=p>.</span><span class=na>setMaxTotal</span><span class=p>(</span><span class=n>20</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>MyExpensiveObject</span><span class=w> </span><span class=n>obj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>obj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pool</span><span class=p>.</span><span class=na>borrowObject</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 객체 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>obj</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pool</span><span class=p>.</span><span class=na>returnObject</span><span class=p>(</span><span class=n>obj</span><span class=p>);</span><span class=w>  </span><span class=c1>// 풀로 반환</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=메모리-사용-패턴-최적화>메모리 사용 패턴 최적화<a hidden class=anchor aria-hidden=true href=#메모리-사용-패턴-최적화>#</a></h4><ol><li><p>불필요한 참조 제거<br>불필요한 참조를 유지하면 메모리 누수가 발생할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Cache</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>cache</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 문제: 캐시에서 항목이 제거되지 않음</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cache</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 해결: 약한 참조 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=w> </span><span class=n>WeakReference</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>betterCache</span><span class=w> </span><span class=o>=</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>WeakHashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>addBetter</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>betterCache</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>key</span><span class=p>,</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>WeakReference</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>value</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>큰 객체 관리<br>큰 객체는 특별한 관리가 필요하다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span><span class=lnt id=hl-15-19><a class=lnlinks href=#hl-15-19>19</a>
</span><span class=lnt id=hl-15-20><a class=lnlinks href=#hl-15-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 대규모 데이터 처리를 위한 청크 단위 처리</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>processLargeFile</span><span class=p>(</span><span class=n>File</span><span class=w> </span><span class=n>file</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>(</span><span class=n>BufferedReader</span><span class=w> </span><span class=n>reader</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BufferedReader</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>FileReader</span><span class=p>(</span><span class=n>file</span><span class=p>)))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>line</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>batch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>1000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>((</span><span class=n>line</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>reader</span><span class=p>.</span><span class=na>readLine</span><span class=p>())</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>batch</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>line</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>batch</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>1000</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>processBatch</span><span class=p>(</span><span class=n>batch</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>batch</span><span class=p>.</span><span class=na>clear</span><span class=p>();</span><span class=w>  </span><span class=c1>// 동일한 List 재사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>batch</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>processBatch</span><span class=p>(</span><span class=n>batch</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=언어플랫폼별-gc-튜닝>언어/플랫폼별 GC 튜닝<a hidden class=anchor aria-hidden=true href=#언어플랫폼별-gc-튜닝>#</a></h4><p>각 언어와 플랫폼은 고유한 GC 튜닝 옵션을 제공한다.</p><ul><li><p>Java GC 튜닝</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4>4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5>5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6>6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 대용량 서버 애플리케이션을 위한 G1 GC 설정 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseG1GC</span><span class=w> </span><span class=err>\</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=n>MaxGCPauseMillis</span><span class=o>=</span><span class=n>200</span><span class=w> </span><span class=err>\</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=n>InitiatingHeapOccupancyPercent</span><span class=o>=</span><span class=n>45</span><span class=w> </span><span class=err>\</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=n>G1HeapRegionSize</span><span class=o>=</span><span class=n>16m</span><span class=w> </span><span class=err>\</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=o>-</span><span class=n>Xms4g</span><span class=w> </span><span class=o>-</span><span class=n>Xmx4g</span><span class=w> </span><span class=err>\</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>MyServerApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>주요 튜닝 매개변수</strong>:</p><ul><li><code>-XX:MaxGCPauseMillis</code>: 목표 최대 GC 중단 시간(밀리초)</li><li><code>-XX:InitiatingHeapOccupancyPercent</code>: GC 시작 힙 점유율 임계값</li><li><code>-XX:G1HeapRegionSize</code>: G1 GC 힙 영역 크기</li></ul></li><li><p>Node.js GC 튜닝</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Node.js 힙 한계 설정</span>
</span></span><span class=line><span class=cl>node --max-old-space-size<span class=o>=</span><span class=m>4096</span> server.js
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># V8 GC 로깅 활성화</span>
</span></span><span class=line><span class=cl>node --trace-gc server.js
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=gc-모니터링과-분석>GC 모니터링과 분석<a hidden class=anchor aria-hidden=true href=#gc-모니터링과-분석>#</a></h4><p>효과적인 GC 튜닝을 위해서는 모니터링과 분석이 필수적이다.</p><ul><li><p>Java GC 모니터링 도구</p><ul><li><strong>JVisualVM</strong>: 시각적 GC 모니터링 도구</li><li><strong>Java Mission Control (JMC)</strong>: 상세한 JVM 분석 도구</li><li><strong>GCViewer</strong>: GC 로그 분석 도구</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># GC 로깅 활성화</span>
</span></span><span class=line><span class=cl>java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log MyApp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># GC 로그 분석</span>
</span></span><span class=line><span class=cl><span class=c1># GCViewer로 gc.log 파일 분석</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>성능 메트릭 분석<br>GC 성능을 평가하기 위한 주요 메트릭:<br>- <strong>GC 빈도</strong>: GC가 너무 자주 발생하면 문제일 수 있음<br>- <strong>GC 지속 시간</strong>: 긴 GC 중단은 응답성 문제 유발<br>- <strong>GC 효율성</strong>: 회수된 메모리 대비 GC 작업 비용<br>- <strong>메모리 사용량 패턴</strong>: 힙 사용량의 시간적 변화<br>- <strong>승격 속도</strong>: Young에서 Old 세대로의 객체 이동 속도</p></li></ul><h3 id=가비지-컬렉션의-현대적-접근법>가비지 컬렉션의 현대적 접근법<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션의-현대적-접근법>#</a></h3><p>현대적인 GC 알고리즘과 기법은 성능과 응답성을 더욱 개선하고 있습니다.</p><ul><li>로우 레이턴시 GC: 매우 짧은 중단 시간을 보장하는 GC 알고리즘.</li><li>확정적 GC (Deterministic GC): 예측 가능한 GC 동작을 제공하는 접근법.</li><li>하이브리드 메모리 관리: 자동 GC와 수동 메모리 관리를 결합한 접근법.</li><li>가비지 컬렉션 회피 기법: 특정 상황에서는 GC를 완전히 회피하는 것이 유리할 수 있다.<ul><li>오프힙 메모리 사용: 힙 외부의 메모리를 사용하여 GC 영향을 받지 않게 한다:</li><li>값 타입 활용: 객체 대신 값 타입을 사용하여 GC 부담을 줄인다.</li></ul></li></ul><h3 id=가비지-컬렉션의-문제점과-해결-방안>가비지 컬렉션의 문제점과 해결 방안<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션의-문제점과-해결-방안>#</a></h3><p>가비지 컬렉션은 많은 이점을 제공하지만, 몇 가지 도전 과제와 문제점이 있다.</p><ol><li><p>GC 일시 중지(Stop-the-World) 문제<br>대부분의 GC 알고리즘은 일시적으로 애플리케이션 실행을 중단시켜야 한다.<br><strong>문제</strong>:</p><ul><li>긴 GC 일시 중지는 응답성에 영향을 미침</li><li>실시간 애플리케이션에서 문제가 될 수 있음</li></ul><p><strong>해결 방안</strong>:</p><ol><li><strong>동시 GC 사용</strong>: CMS, G1, ZGC와 같은 동시 수집기 활용</li><li><strong>증분 GC 사용</strong>: 작은 단위로 GC 작업 분할</li><li><strong>힙 크기 최적화</strong>: 너무 크거나 작은 힙은 GC 성능에 부정적 영향</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Java에서 짧은 GC 중단을 위한 ZGC 설정 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>java</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UseZGC</span><span class=w> </span><span class=o>-</span><span class=n>Xms4G</span><span class=w> </span><span class=o>-</span><span class=n>Xmx4G</span><span class=w> </span><span class=o>-</span><span class=n>XX</span><span class=p>:</span><span class=o>+</span><span class=n>UnlockExperimentalVMOptions</span><span class=w> </span><span class=n>MyApp</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>메모리 단편화(Fragmentation)<br><strong>해결 방안</strong>:</p><ol><li><strong>압축(Compaction) 알고리즘 사용</strong>: 살아있는 객체들을 메모리의 한쪽으로 모음</li><li><strong>객체 할당 전략 최적화</strong>: 비슷한 수명을 가진 객체들을 함께 할당</li><li><strong>메모리 풀링(Memory Pooling)</strong>: 특정 크기의 객체를 위한 메모리 풀을 미리 할당</li></ol><p>압축 알고리즘의 작동 예시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[객체1][빈공간][객체2][빈공간][객체3]  // 단편화된 상태
</span></span><span class=line><span class=cl>                ↓ (압축 후)
</span></span><span class=line><span class=cl>[객체1][객체2][객체3][빈공간          ]  // 압축된 상태
</span></span></code></pre></td></tr></table></div></div></li><li><p>리소스 소비<br><strong>문제</strong>:</p><ul><li>GC는 CPU 시간을 소비함</li><li>메모리 오버헤드 발생 (GC 메타데이터, 객체 헤더 등)</li></ul><p><strong>해결 방안</strong>:</p><ol><li><strong>객체 생성 최소화</strong>: 불필요한 객체 생성 제한</li><li><strong>객체 풀링</strong>: 자주 사용되는 객체를 재사용</li><li><strong>적절한 초기 힙 크기 설정</strong>: 빈번한 힙 크기 조정 방지</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Java에서 객체 풀 사용 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>StringBuilderPool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>ThreadLocal</span><span class=o>&lt;</span><span class=n>StringBuilder</span><span class=o>&gt;</span><span class=w> </span><span class=n>pool</span><span class=w> </span><span class=o>=</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ThreadLocal</span><span class=p>.</span><span class=na>withInitial</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>StringBuilder</span><span class=p>(</span><span class=n>1024</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>StringBuilder</span><span class=w> </span><span class=nf>acquire</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>StringBuilder</span><span class=w> </span><span class=n>sb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>pool</span><span class=p>.</span><span class=na>get</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>sb</span><span class=p>.</span><span class=na>setLength</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w> </span><span class=c1>// 재사용 전 초기화</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>sb</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>buildAndRelease</span><span class=p>(</span><span class=n>StringBuilder</span><span class=w> </span><span class=n>sb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sb</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 자동으로 ThreadLocal에 유지됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>예측 불가능성<br><strong>문제</strong>:</p><ul><li>GC 타이밍과 지속 시간 예측이 어려움</li><li>일부 실시간 시스템에서는 허용할 수 없는 상황</li></ul><p><strong>해결 방안</strong>:</p><ol><li><strong>실시간 GC 알고리즘</strong>: 최대 중단 시간을 보장하는 GC 사용</li><li><strong>GC 빈도 튜닝</strong>: 적절한 힙 크기와 GC 트리거 조정</li><li><strong>수동 메모리 관리 영역 도입</strong>: 극도로 중요한 경로에서는 GC를 회피하는 설계</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3>3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4>4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5>5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6>6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7>7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8>8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Java에서 직접 메모리 사용 예시 (GC 없음)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>java.nio.ByteBuffer</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>ByteBuffer</span><span class=w> </span><span class=n>directBuffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>allocateDirect</span><span class=p>(</span><span class=n>1024</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>1024</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// DirectByteBuffer는 힙 외부에 할당되어 GC 영향을 덜 받음</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 사용 후 명시적 해제</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>directBuffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>gc</span><span class=p>();</span><span class=w> </span><span class=c1>// Native 메모리 해제 힌트</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=가비지-컬렉션의-미래-동향>가비지 컬렉션의 미래 동향<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션의-미래-동향>#</a></h3><p>GC 기술은 계속 발전하고 있으며, 몇 가지 흥미로운 미래 동향이 있다.</p><ol><li>하드웨어 지원 GC<br>하드웨어 수준에서 GC를 지원하는 접근법:<ul><li><strong>GC 가속 하드웨어</strong>: 참조 추적과 마킹을 가속화하는 특수 하드웨어</li><li><strong>메모리 태깅</strong>: 참조와 데이터를 하드웨어 수준에서 구분하는 기술</li><li><strong>병렬 마킹 유닛</strong>: 객체 그래프 탐색을 병렬화하는 특수 프로세서</li></ul></li><li>기계 학습 기반 GC<br>AI와 머신러닝을 활용하여 GC 결정을 최적화:<ul><li><strong>예측적 GC</strong>: 메모리 사용 패턴을 학습하여 선제적으로 GC 수행</li><li><strong>적응형 정책</strong>: 애플리케이션 행동에 따라 GC 정책 자동 조정</li><li><strong>GC 타이밍 최적화</strong>: 최소 영향을 주는 시점에 GC 수행</li></ul></li><li>특화된 언어 설계<br>GC 효율성을 고려한 프로그래밍 언어 설계:<ul><li><strong>영역 기반 메모리 관리</strong>: 메모리를 영역별로 관리하여 전체 GC 필요성 감소</li><li><strong>선형 타입 시스템</strong>: 컴파일 시간에 메모리 안전성을 보장하는 타입 시스템</li><li><strong>하이브리드 메모리 모델</strong>: 안전한 수동 관리와 자동 GC의 결합</li></ul></li></ol><h3 id=가비지-컬렉션과-수동-메모리-관리-비교>가비지 컬렉션과 수동 메모리 관리 비교<a hidden class=anchor aria-hidden=true href=#가비지-컬렉션과-수동-메모리-관리-비교>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>가비지 컬렉션 (GC)</strong></th><th><strong>수동 메모리 관리</strong></th></tr></thead><tbody><tr><td><strong>메모리 해제 방식</strong></td><td>자동으로, 비결정적으로 이루어짐</td><td>프로그래머가 명시적으로 free()/delete 등을 호출하여 해제</td></tr><tr><td><strong>개발 편의성</strong></td><td>메모리 관리 코드를 작성할 필요가 없으므로 코드가 간결하며 오류가 줄어듦</td><td>직접 관리해야 하므로 코드 복잡도가 증가하고, 메모리 누수 등의 위험 존재</td></tr><tr><td><strong>메모리 누수 위험</strong></td><td>자동 회수로 누수 위험이 낮으나, 잘못된 참조 유지 시 누수 가능</td><td>프로그래머의 실수로 인해 메모리 누수가 발생할 가능성이 높음</td></tr><tr><td><strong>성능 오버헤드</strong></td><td>GC 수행 시 일시적인 정지와 추가 CPU/메모리 사용 등의 오버헤드 발생</td><td>필요하지 않은 시점에 메모리 해제를 실행할 수 있어 오버헤드 제어 용이</td></tr><tr><td><strong>실시간성</strong></td><td>비결정적 해제로 인해 실시간 시스템에서는 부적합할 수 있음</td><td>해제 시점을 정확히 제어할 수 있어 실시간 요구 조건에 적합</td></tr><tr><td><strong>오류 예방</strong></td><td>중복 해제, 댕글링 포인터 등 일반적인 메모리 오류를 예방</td><td>프로그래머가 직접 관리하므로 실수 시 치명적인 오류가 발생할 수 있음</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>