<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interpreter vs Compiler vs Assembler | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Language-Processor,Assembler,Compiler,Interpreter"><meta name=description content="컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Interpreter vs Compiler vs Assembler"><meta property="og:description" content="컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Interpreter vs Compiler vs Assembler"><meta name=twitter:description content="컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Interpreter vs Compiler vs Assembler","item":"https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Interpreter vs Compiler vs Assembler</h1><div class=post-description>컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다.</div></header><div class=post-content><h2 id=compiler-vs-interpreter-vs-assembler>Compiler vs. Interpreter vs. Assembler<a hidden class=anchor aria-hidden=true href=#compiler-vs-interpreter-vs-assembler>#</a></h2><p>컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다.<br>각각의 도구는 입력 언어, 처리 방식, 실행 시간 및 사용 목적에 따라 차별화된 특징을 가지며, 개발 환경이나 애플리케이션의 요구사항에 맞춰 선택된다.</p><h3 id=컴파일러-compiler>컴파일러 (Compiler)<a hidden class=anchor aria-hidden=true href=#컴파일러-compiler>#</a></h3><p>컴파일러는 C, C++, Java와 같이 고수준 언어로 작성된 소스 코드를 한 번에 분석하고 번역하여 실행 가능한 기계어 또는 객체 코드를 생성한다.</p><p>작동 원리:</p><ol><li><strong>어휘 분석(Lexical Analysis)</strong>: 소스 코드를 토큰(token)으로 분해한다.</li><li><strong>구문 분석(Syntax Analysis)</strong>: 토큰들을 구문 규칙에 따라 분석하여 파싱 트리를 생성한다.</li><li><strong>의미 분석(Semantic Analysis)</strong>: 코드의 의미를 검사하고 타입 체킹 등을 수행한다.</li><li><strong>중간 코드 생성(Intermediate Code Generation)</strong>: 최적화를 위한 중간 표현을 생성한다.</li><li><strong>코드 최적화(Code Optimization)</strong>: 중간 코드를 최적화하여 효율성을 높인다.</li><li><strong>목적 코드 생성(Code Generation)</strong>: 최종적으로 목표 기계어 또는 바이트코드를 생성한다.</li></ol><p>특징:</p><ul><li><strong>속도</strong>: 한 번 컴파일하면 이후 실행 시 별도의 번역 과정 없이 빠르게 실행된다.</li><li><strong>메모리 효율성</strong>: 컴파일 과정에서 최적화를 통해 메모리 사용을 효율적으로 조정할 수 있다.</li><li><strong>오류 감지</strong>: 컴파일 시간에 많은 오류를 감지할 수 있어 런타임 오류를 줄일 수 있다.</li><li><strong>플랫폼 의존성</strong>: 특정 하드웨어와 운영체제를 위해 컴파일되어 이식성이 제한될 수 있다.</li></ul><h3 id=인터프리터-interpreter>인터프리터 (Interpreter)<a hidden class=anchor aria-hidden=true href=#인터프리터-interpreter>#</a></h3><p>인터프리터는 소스 코드를 한 줄씩 읽고 즉시 실행하는 방식으로 동작한다.<br>즉, 별도의 기계어 파일을 생성하지 않고, 코드 실행 시마다 해석을 수행하므로 빠른 피드백과 디버깅에 유리하지만, 전체 실행 성능은 컴파일된 코드에 비해 다소 느릴 수 있다.</p><p>작동 원리:</p><ol><li><strong>소스 코드 읽기</strong>: 프로그램 코드를 한 줄 또는 명령 단위로 읽는다.</li><li><strong>구문 분석</strong>: 해당 코드의 구문을 분석한다.</li><li><strong>실행</strong>: 분석된 코드를 즉시 실행한다.</li><li><strong>다음 명령 처리</strong>: 1~3 과정을 다음 명령에 대해 반복한다.</li></ol><p>특징:</p><ul><li><strong>유연성</strong>: 코드 수정 후 즉시 실행 가능하여 개발 및 디버깅이 용이하다.</li><li><strong>이식성</strong>: 플랫폼에 독립적으로 동작할 수 있어 이식성이 뛰어나다.</li><li><strong>실행 속도</strong>: 매번 코드를 해석해야 하므로 컴파일된 코드보다 실행 속도가 느리다.</li><li><strong>메모리 사용</strong>: 인터프리터 자체가 실행 중에 메모리에 로드되어야 하므로 추가 메모리가 필요하다.</li><li><strong>오류 감지</strong>: 런타임에 오류가 발견되므로 실행 중 예상치 못한 오류가 발생할 수 있다.</li></ul><h3 id=어셈블러-assembler>어셈블러 (Assembler)<a hidden class=anchor aria-hidden=true href=#어셈블러-assembler>#</a></h3><p>어셈블러는 어셈블리 언어라는 저수준의 기호화된 명령어를 1:1 매핑 방식으로 해당 기계어 코드로 변환한다.<br>어셈블리 언어는 각 명령어가 하드웨어의 기계어 명령어에 매우 근접하므로, 어셈블러는 하드웨어 제어나 시스템 부팅 코드 등에서 세밀한 제어가 필요한 경우에 주로 사용된다.</p><p>작동 원리:</p><ol><li><strong>심볼 테이블 생성</strong>: 라벨과 주소 간의 매핑을 생성한다.</li><li><strong>명령어 변환</strong>: 어셈블리 코드의 각 명령어를 해당하는 기계어 명령어로 변환한다.</li><li><strong>주소 계산</strong>: 상대 주소와 절대 주소를 계산한다.</li><li><strong>목적 코드 생성</strong>: 최종 기계어 코드를 생성한다.</li></ol><p>특징:</p><ul><li><strong>직접적인 하드웨어 접근</strong>: 하드웨어 수준의 명령을 직접 제어할 수 있다.</li><li><strong>효율성</strong>: 최적화된 기계어 코드 생성이 가능하다.</li><li><strong>낮은 추상화</strong>: 프로그래머가 하드웨어 수준의 지식이 필요하다.</li><li><strong>플랫폼 의존성</strong>: 특정 CPU 아키텍처에 맞게 작성되어야 한다.</li><li><strong>개발 시간</strong>: 코드 작성이 복잡하고 시간이 많이 소요된다.</li></ul><h3 id=비교-분석-표>비교 분석 표<a hidden class=anchor aria-hidden=true href=#비교-분석-표>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>컴파일러 (Compiler)</strong></th><th><strong>인터프리터 (Interpreter)</strong></th><th><strong>어셈블러 (Assembler)</strong></th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>고수준 언어를 기계어 또는 객체 코드로 변환하여 독립 실행 파일을 생성함</td><td>소스 코드를 한 줄씩 해석하며 실행하는 방식으로, 별도 기계어 파일 없이 수행됨</td><td>어셈블리 언어를 1:1 매핑을 통해 기계어 코드로 변환함</td></tr><tr><td><strong>처리 방식</strong></td><td>전체 소스 코드를 분석 및 최적화한 후 한 번에 번역함</td><td>코드 실행 시마다 실시간으로 해석하고 즉시 실행함</td><td>어셈블리 명령어를 대응되는 기계어 명령어로 직접 변환함</td></tr><tr><td><strong>시간 및 성능</strong></td><td>컴파일 시간은 소요되지만, 실행 시에는 최적화된 빠른 코드가 실행됨</td><td>실행 시마다 해석을 수행하므로, 반복 실행 시 성능은 느릴 수 있으나 디버깅에는 용이함</td><td>변환 과정이 비교적 단순하므로 빠르게 기계어를 생성하나, 최적화보다는 하드웨어 제어에 초점을 맞춤</td></tr><tr><td><strong>사용 예시</strong></td><td>C, C++, Java 등 일반 애플리케이션 및 시스템 소프트웨어 개발에 사용됨</td><td>Python, Ruby, JavaScript 등 인터랙티브 개발이나 스크립트 언어에 주로 사용됨</td><td>하드웨어 제어나 임베디드 시스템, 운영체제 부팅 코드 등 저수준 프로그래밍에 사용됨</td></tr><tr><td><strong>장단점</strong></td><td>- 높은 최적화 및 오류 검출 기능 제공- 컴파일 시간이 다소 소요됨</td><td>- 실시간 피드백과 디버깅이 용이함- 실행 시마다 해석하여 실행 속도가 느릴 수 있음</td><td>- 하드웨어와 직접 상호작용 가능하여 세밀한 제어가 가능함- 개발 난이도가 높고 이식성이 낮음</td></tr></tbody></table><p>이처럼 컴파일러는 고수준 언어의 코드를 최적화하여 빠른 실행 성능을 제공하는 반면, 인터프리터는 코드 수정 및 디버깅에 유리한 실시간 실행 환경을 제공한다.<br>어셈블러는 하드웨어 제어와 세밀한 최적화가 필요한 저수준 작업에 적합합니다. 각 도구의 특징과 사용 사례를 고려하여</p><table><thead><tr><th>특성</th><th>컴파일러</th><th>인터프리터</th><th>어셈블러</th><th>JIT 컴파일러</th></tr></thead><tbody><tr><td><strong>입력</strong></td><td>고수준 언어 코드</td><td>고수준 언어 코드</td><td>어셈블리 코드</td><td>고수준 언어 코드</td></tr><tr><td><strong>출력</strong></td><td>실행 파일/목적 파일</td><td>직접 실행 결과</td><td>기계어/목적 파일</td><td>최적화된 기계어</td></tr><tr><td><strong>처리 방식</strong></td><td>전체 코드를 한 번에 번역</td><td>한 줄씩 해석 및 실행</td><td>어셈블리 명령어를 기계어로 변환</td><td>실행 시점에 바이트코드를 기계어로 변환</td></tr><tr><td><strong>실행 속도</strong></td><td>빠름</td><td>느림</td><td>매우 빠름</td><td>보통~빠름</td></tr><tr><td><strong>메모리 효율성</strong></td><td>높음</td><td>낮음</td><td>매우 높음</td><td>중간</td></tr><tr><td><strong>개발 생산성</strong></td><td>중간</td><td>높음</td><td>낮음</td><td>높음</td></tr><tr><td><strong>오류 감지 시점</strong></td><td>컴파일 시간</td><td>런타임</td><td>어셈블 시간</td><td>컴파일 시간 + 런타임</td></tr><tr><td><strong>디버깅 용이성</strong></td><td>중간</td><td>높음</td><td>낮음</td><td>중간</td></tr><tr><td><strong>이식성</strong></td><td>낮음~중간</td><td>높음</td><td>매우 낮음</td><td>중간~높음</td></tr><tr><td><strong>반복적 실행 성능</strong></td><td>매우 높음</td><td>낮음</td><td>매우 높음</td><td>높음</td></tr><tr><td><strong>중간 표현 사용</strong></td><td>일반적으로 사용</td><td>일부 사용</td><td>사용하지 않음</td><td>항상 사용</td></tr><tr><td><strong>최적화 수준</strong></td><td>높음</td><td>낮음</td><td>프로그래머 의존적</td><td>높음(적응형)</td></tr><tr><td><strong>실행 전 준비 시간</strong></td><td>길다</td><td>매우 짧다</td><td>중간</td><td>첫 실행 시 길다</td></tr><tr><td><strong>하드웨어 제어 수준</strong></td><td>중간</td><td>낮음</td><td>매우 높음</td><td>중간</td></tr><tr><td><strong>예시 언어</strong></td><td>C, C++, Rust</td><td>Python, JavaScript, Ruby</td><td>x86 Assembly, ARM Assembly</td><td>Java, C#</td></tr><tr><td><strong>파일 확장자</strong></td><td>.c,.cpp 등</td><td>.py,.js 등</td><td>.asm,.s 등</td><td>.java,.cs 등</td></tr><tr><td><strong>개발 흐름</strong></td><td>편집 → 컴파일 → 링크 → 실행</td><td>편집 → 실행</td><td>편집 → 어셈블 → 링크 → 실행</td><td>편집 → 컴파일(바이트코드) → 실행(JIT)</td></tr><tr><td><strong>사용 사례</strong></td><td>시스템 소프트웨어, 게임, 성능 중심 애플리케이션</td><td>스크립팅, 웹 애플리케이션, 프로토타이핑</td><td>임베디드 시스템, 드라이버, 저수준 시스템 프로그래밍</td><td>크로스 플랫폼 애플리케이션, 서버 애플리케이션</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>어셈블러(Assembler)</h2></header><div class=entry-content><p>어셈블러(Assembler) Assembler는 어셈블리 언어로 작성된 소스 코드를 컴퓨터가 직접 실행할 수 있는 기계어 코드로 변환한다.
이는 저수준 프로그래밍에서 하드웨어와 직접 상호작용하거나, 부트로더, 디바이스 드라이버 등 시스템의 핵심 부분을 구현할 때 필수적인 도구로 사용된다.
어셈블러는 어셈블리 언어(Assembly Language)로 작성된 프로그램을 기계어(Machine Code)로 변환하는 프로그램이다. 어셈블리 언어는 기계어와 1:1로 대응되는 니모닉(mnemonic, 기억하기 쉬운 기호)을 사용하여 CPU의 명령어를 표현한다.
예를 들어, x86 아키텍처에서 MOV AX, 5라는 어셈블리 명령어는 AX 레지스터에 값 5를 저장하라는 의미인데, 어셈블러는 이것을 10111000 00000101과 같은 이진 기계어로 변환한다.
...</p></div><footer class=entry-footer><span title='2024-12-05 03:56:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 어셈블러(Assembler)" href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/assembler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>컴파일러(Compiler)</h2></header><div class=entry-content><p>컴파일러(Compiler) 컴파일러는 프로그래밍 언어로 작성된 소스 코드를 다른 프로그래밍 언어나 기계어로 변환하는 소프트웨어이다.
특히 고수준 프로그래밍 언어(C, Java, Python 등)를 컴퓨터가 직접 실행할 수 있는 저수준 언어(기계어, 바이트코드)로 변환하는 역할을 한다.
컴파일러는 단순 변환 이상의 기능을 수행하며, 코드의 오류 체크, 최적화, 그리고 다양한 시스템에 맞는 코드 생성 등을 담당한다.
컴파일러는 고수준 언어로 작성된 코드를 효율적인 기계어로 변환하는 복잡한 과정을 수행한다.
컴파일러의 설계와 구현은 컴퓨터 과학의 여러 분야(형식 언어 이론, 알고리즘, 최적화 기법 등)를 아우르는 종합적인 주제이다.
...</p></div><footer class=entry-footer><span title='2024-10-06 05:27:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 컴파일러(Compiler)" href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>인터프리터(Interpreter)</h2></header><div class=entry-content><p>인터프리터(Interpreter) 프로그래밍 언어의 소스 코드를 직접 실행하는 프로그램 또는 환경
기능과 역할 인터프리터의 주요 기능은 다음과 같다:
소스 코드 해석: 프로그래머가 작성한 코드를 한 줄씩 읽고 해석한다. 즉시 실행: 해석된 코드를 바로 실행한다. 대화형 환경 제공: 코드를 즉시 실행하고 결과를 확인할 수 있는 환경을 제공한다. 특징과 장점 즉시 실행: 코드 수정 후 바로 실행이 가능하다. 대화형 모드: 많은 인터프리터 언어는 대화형 모드를 제공한다. 플랫폼 독립성: 대부분 플랫폼에 독립적으로 실행 가능하다. 디버깅 용이성: 오류가 발생한 즉시 실행을 중지하여 디버깅이 쉽다. 작동 과정 이해하기 예를 들어, 다음과 같은 파이썬 코드가 있다고 생각해보자:
...</p></div><footer class=entry-footer><span title='2024-10-06 05:32:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인터프리터(Interpreter)" href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/interpreter/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>