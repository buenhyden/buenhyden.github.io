<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ahead-of-Time Compiler | hyunyoun's Blog</title><meta name=keywords content="Programming-Languages,Fundamentals,Compiler,Types,Ahead-of-Time-Compiler,AOT"><meta name=description content="**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Ahead-of-Time Compiler"><meta property="og:description" content="**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-14T18:02:00+00:00"><meta property="article:modified_time" content="2024-10-14T18:02:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="Types"><meta property="article:tag" content="Ahead-of-Time-Compiler"><meta property="article:tag" content="AOT"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Ahead-of-Time Compiler"><meta name=twitter:description content="**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":4,"name":"Programming Language Theory","item":""},{"@type":"ListItem","position":6,"name":"types of Compiler","item":"https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/"},{"@type":"ListItem","position":7,"name":"Ahead-of-Time Compiler","item":"https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ahead-of-Time Compiler","name":"Ahead-of-Time Compiler","description":"**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술","keywords":["Programming-Languages","Fundamentals","Compiler","Types","Ahead-of-Time-Compiler","AOT"],"articleBody":"Ahead-of-Time (AOT) Compiler Ahead-of-Time(AOT) 컴파일러는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 네이티브 머신 코드로 미리 변환하는 기술이다. 이는 런타임 동안의 동적 컴파일 오버헤드를 제거하여, 프로그램이 시작될 때 바로 최적화된 실행 코드를 사용할 수 있도록 함으로써 빠른 시작 시간과 예측 가능한 성능을 제공한다.\nAOT 컴파일러는 프로그램 실행 전에 소스 코드를 네이티브 코드로 변환하여 실행 성능을 최적화하는 중요한 도구이다. 특히 시작 시간, 예측 가능한 성능, 메모리 효율성이 중요한 환경에서 큰 이점을 제공한다.\n현대 소프트웨어 개발에서는 AOT 컴파일과 JIT 컴파일, 때로는 인터프리터 방식을 혼합하여 사용하는 하이브리드 접근법이 점점 더 인기를 얻고 있다. 이는 각 방식의 장점을 최대한 활용하면서 단점을 최소화하기 위한 전략이다.\n기술이 발전함에 따라 AOT 컴파일러는 더욱 정교해지고 있으며, 기계 학습, 클라우드 컴퓨팅, 양자 컴퓨팅과 같은 신기술과 결합하여 소프트웨어 개발 환경의 발전을 이끌고 있다. 개발자들은 이러한 기술을 이해하고 적절히 활용함으로써 더 효율적이고 성능이 뛰어난 애플리케이션을 구축할 수 있다.\nAOT 컴파일러의 기본 개념 AOT 컴파일은 프로그램이 실행되기 전에 소스 코드를 대상 기계의 네이티브 코드로 컴파일하는 과정이다.\n이는 프로그램이 실행될 때마다 코드를 해석하거나 JIT(Just-In-Time) 컴파일하는 대신, 한 번만 컴파일하여 실행 준비가 완료된 형태로 저장하는 방식이다.\n간단히 표현하면 다음과 같은 과정을 거칩니다:\n1 소스 코드 → [AOT 컴파일] → 네이티브 실행 파일 → 실행 이 방식은 전통적인 정적 컴파일러(C, C++ 컴파일러 등)가 사용하는 방식과 유사하지만, 현대적 AOT 컴파일러는 중간 표현(IR)이나 바이트코드를 처리하는 경우가 많다는 점에서 차이가 있다.\nAOT 컴파일의 역사적 발전 AOT 컴파일은 컴퓨터 프로그래밍의 초기부터 존재해 왔지만, ‘선행 컴파일’이라는 용어와 개념은 인터프리터와 JIT 컴파일러의 등장 이후 이들과 구별하기 위해 더 널리 사용되기 시작했다.\n초기 컴파일러 (1950년대~)\n첫 번째 고급 프로그래밍 언어인 FORTRAN의 컴파일러는 본질적으로 AOT 컴파일러였다.\n소스 코드를 한 번 컴파일하고 그 결과로 생성된 바이너리를 실행했다.\n중간 표현의 발전 (1990년대~)\nJava와.NET과 같은 플랫폼이 등장하면서, 바이트코드라는 중간 표현을 사용하는 방식이 보편화되었다.\n이러한 환경에서는 일반적으로 JIT 컴파일을 사용했지만, 성능 개선을 위해 AOT 컴파일 옵션도 점차 도입되었다.\n모바일 시대 (2010년대~)\n모바일 기기의 제한된 자원과 배터리 수명 문제로 인해 AOT 컴파일에 대한 관심이 증가했다.\nAndroid의 ART(Android Runtime)는 Dalvik VM을 대체하며 AOT 컴파일을 도입한 대표적인 사례.\n현대적 접근 (2020년대~)\n현재는 많은 환경에서 AOT와 JIT 컴파일을 혼합하여 사용하는 하이브리드 접근법이 인기를 얻고 있다.\n이는 AOT의 초기 성능 이점과 JIT의 동적 최적화 장점을 모두 활용할 수 있기 때문이다.\nhttps://www.monarch-innovation.com/aot-vs-jit-compiler-in-angular\n주요 특징 사전 컴파일: 프로그램의 소스 코드를 빌드 시점에 기계어로 변환하여 실행 파일을 생성한다. 이를 통해 실행 시점에 추가적인 컴파일 작업이 필요 없으며, 프로그램의 시작 시간을 단축시킨다. 일관된 성능: 실행 전에 모든 컴파일 작업이 완료되므로, 프로그램 실행 중에 발생할 수 있는 성능 변동이 최소화된다. 보안 강화: 소스 코드가 미리 컴파일되어 배포되므로, 코드 노출 위험이 감소하고 역공학에 대한 저항력이 높아진다. AOT 컴파일의 장단점 장점 향상된 시작 시간\n프로그램이 실행될 때 코드 해석이나 컴파일이 필요 없어 시작 시간이 단축된다.\n이는 사용자 경험에 직접적인 영향을 미친다.\n예측 가능한 성능\n실행 시 컴파일이 없으므로 성능이 안정적이고 예측 가능하다.\n특히 실시간 시스템이나 게임과 같이 일관된 성능이 중요한 애플리케이션에서 유리하다.\n낮은 메모리 사용량\nJIT 컴파일러가 필요 없어 런타임 메모리 오버헤드가 감소한다. 또한 코드 캐싱에 필요한 메모리도 절약된다.\n향상된 보안\n소스 코드나 중간 표현이 배포되지 않아 역공학이 더 어렵다. 또한 JIT 컴파일러 관련 취약점에 노출되지 않는다.\n향상된 배터리 수명 (모바일 기기)\n컴파일 작업이 없어 CPU 사용량이 감소하고 이는 배터리 수명 향상으로 이어진다.\n단점 증가된 파일 크기\n네이티브 코드는 중간 표현보다 일반적으로 크기 때문에 배포 파일 크기가 증가한다.\n플랫폼 의존성\n각 목표 플랫폼/아키텍처별로 별도 컴파일이 필요하여 “한 번 작성하고 어디서나 실행” 패러다임이 약화된다.\n동적 최적화 부재\nJIT 컴파일러와 달리 런타임 정보를 활용한 최적화가 어렵다. 특히 자주 실행되는 핫스팟 코드나 실행 패턴에 기반한 최적화에 제한이 있다.\n컴파일 시간 증가\nAOT 컴파일은 개발-빌드-테스트 주기에 시간을 추가하여 개발 속도를 늦출 수 있다.\n리플렉션 및 동적 기능 제한\n리플렉션, 동적 클래스 로딩과 같은 동적 기능이 제한되거나 특별한 처리가 필요할 수 있다.\nAOT 컴파일러의 작동 원리 AOT 컴파일러는 일반적으로 다음과 같은 단계를 거쳐 작동한다:\n소스 코드 파싱\n소스 코드를 토큰화하고 구문 분석하여 추상 구문 트리(AST)를 생성한다.\n의미 분석\nAST를 검사하여 타입 체킹, 변수 선언 확인 등 의미적 정확성을 검증한다.\n중간 표현(IR) 생성\n언어 중립적인 중간 표현으로 코드를 변환한다.\n이 단계에서 초기 최적화가 적용될 수 있다.\n최적화\n다양한 최적화 패스를 통해 코드 성능을 개선한다.\n예를 들어:\n상수 폴딩 및 전파 루프 최적화 인라인화 데드 코드 제거 레지스터 할당 코드 생성\n최적화된 IR을 특정 대상 아키텍처(x86, ARM, RISC-V 등)의 네이티브 기계어로 변환한다.\n링킹\n생성된 목적 파일을 라이브러리 및 다른 목적 파일과 링크하여 최종 실행 파일을 생성한다.\nAOT 컴파일러의 최적화 기법 정적 분석 기반 최적화 컴파일 시간에 코드 분석을 통해 다양한 최적화를 적용한다:\n인라인화 (Inlining)\n작은 함수를 호출 위치에 직접 삽입하여 함수 호출 오버헤드를 제거한다.\n1 2 3 4 5 6 // 원본 코드 int square(int x) { return x * x; } int result = square(5); // 인라인화 후 int result = 5 * 5; 상수 폴딩 및 전파 (Constant Folding \u0026 Propagation)\n컴파일 시점에 계산 가능한 표현식을 평가하고 상수 값을 전파한다.\n1 2 3 4 5 6 7 // 원본 코드 const int a = 5; const int b = 10; int result = a + b * 2; // 최적화 후 int result = 25; 데드 코드 제거 (Dead Code Elimination)\n절대 실행되지 않는 코드를 제거한다.\n1 2 3 4 5 6 7 // 원본 코드 if (false) { doSomething(); // 데드 코드 } // 최적화 후 // (해당 부분 완전히 제거됨) 루프 최적화\n루프 언롤링, 루프 불변 코드 이동, 벡터화 등 다양한 루프 최적화를 적용한다.\n1 2 3 4 5 6 7 8 9 10 // 원본 코드 for (int i = 0; i \u003c 4; i++) { array[i] = i * 2; } // 루프 언롤링 후 array[0] = 0 * 2; array[1] = 1 * 2; array[2] = 2 * 2; array[3] = 3 * 2; 아키텍처 특화 최적화\n대상 아키텍처의 특성을 활용한 최적화를 적용한다:\nSIMD 명령어 활용: Single Instruction Multiple Data 명령어를 사용하여 데이터 병렬 처리를 최적화한다. 캐시 최적화: 데이터 및 명령어 캐시 사용을 최적화하기 위한 메모리 레이아웃 조정. 분기 예측 최적화: 분기 예측 실패를 최소화하기 위한 코드 재배치 및 최적화. 전체 프로그램 최적화 (Whole Program Optimization) 다양한 모듈에 걸친 전역 최적화를 적용한다:\n링크 타임 최적화 (Link-Time Optimization, LTO)\n서로 다른 컴파일 단위에 걸친 최적화를 적용한다.\n프로필 기반 최적화 (Profile-Guided Optimization, PGO)\n테스트 실행에서 수집한 프로파일 데이터를 기반으로 컴파일 시 최적화 결정을 내린다.\nAOT 컴파일러의 구현 사례 Android Runtime (ART)\nAndroid 5.0(Lollipop)부터 도입된 ART는 이전의 Dalvik VM을 대체했다.\nART는 앱 설치 시 DEX 바이트코드를 네이티브 기계어로 컴파일하여 실행 속도를 크게 향상시켰다.\n1 2 3 4 5 6 7 8 9 10 11 // Java 소스 코드 public class Hello { public static void main(String[] args) { System.out.println(\"Hello, World!\"); } } // 컴파일 및 실행 과정 // javac Hello.java → Hello.class (바이트코드) // Android에서: dx --dex --output=Hello.dex Hello.class // ART에서 설치 시: DEX → OAT (최적화된 Android 형식, 네이티브 코드 포함) NativeAOT (.NET)\n.NET 6부터 정식 지원되는 NativeAOT(이전 명칭: CoreRT)는.NET 애플리케이션을 네이티브 코드로 컴파일하여 시작 시간과 메모리 사용량을 크게 개선한다.\n1 2 3 4 5 6 7 8 9 10 11 // C# 소스 코드 using System; class Program { static void Main() { Console.WriteLine(\"Hello, World!\"); } } // NativeAOT 컴파일 명령 // dotnet publish -r win-x64 -c Release /p:PublishAot=true Graal Native Image (Java)\nGraalVM의 Native Image는 Java 애플리케이션을 독립 실행형 네이티브 실행 파일로 컴파일한다.\n이는 Java의 시작 시간과 메모리 사용량을 크게 개선하며, 특히 마이크로서비스 및 서버리스 환경에서 유용하다.\n1 2 # 컴파일 명령 native-image -cp app.jar com.example.MyApplication Angular의 AOT 컴파일러\n웹 프레임워크인 Angular는 TypeScript 코드와 HTML 템플릿을 JavaScript로 컴파일하는 AOT 컴파일러를 제공한다. 이는 런타임에 템플릿을 컴파일하는 대신 빌드 과정에서 처리하여 웹 애플리케이션의 초기 로딩 시간을 단축한다.\n1 2 # Angular CLI를 사용한 AOT 컴파일 ng build --aot LLVM 기반 AOT 컴파일러\nLLVM은 다양한 프로그래밍 언어를 위한 모듈식 컴파일러 인프라를 제공한다.\nSwift, Rust 등 여러 언어가 LLVM을 기반으로 AOT 컴파일을 구현한다.\n1 2 3 4 5 // Swift 코드 print(\"Hello, World!\") // Swift 컴파일러는 LLVM을 사용하여 네이티브 코드 생성 // swiftc hello.swift -o hello AOT 컴파일의 실제 사용 사례 임베디드 시스템 및 IoT\n제한된 리소스를 가진 임베디드 기기에서는 AOT 컴파일이 자주 사용된다.\n메모리 사용량 감소와 예측 가능한 성능이 중요한 요소이다.\n서버리스 및 마이크로서비스\nAWS Lambda, Azure Functions 등 서버리스 환경에서는 콜드 스타트(cold start) 시간이 중요하다.\nAOT 컴파일은 시작 시간을 단축하여 사용자 경험을 개선한다.\n1 2 3 4 5 6 7 8 9 10 // Quarkus와 GraalVM을 사용한 Java 마이크로서비스 @Path(\"/hello\") public class GreetingResource { @GET @Produces(MediaType.TEXT_PLAIN) public String hello() { return \"Hello RESTEasy\"; } } // quarkus build --native로 네이티브 이미지 생성 모바일 애플리케이션\n모바일 기기의 제한된 배터리 수명과 성능을 고려하여 AOT 컴파일이 널리 사용된다.\nFlutter, React Native 등의 크로스 플랫폼 프레임워크도 부분적으로 AOT 컴파일을 활용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Flutter 앱 void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( home: Text('Hello, World!'), ); } } // flutter build apk로 AOT 컴파일된 앱 생성 게임 개발\nUnity, Unreal Engine과 같은 게임 엔진은 일관된 성능을 위해 AOT 컴파일을 활용한다.\n보안이 중요한 애플리케이션\n금융, 의료, 군사 등 보안이 중요한 분야에서는 코드 보호를 위해 AOT 컴파일을 선호한다.\n하이브리드 접근법: AOT와 JIT의 결합 최근에는 AOT와 JIT의 장점을 결합한 하이브리드 접근법이 인기를 얻고 있다:\n계층적 컴파일 (Tiered Compilation)\n자주 실행되는 코드(핫스팟)를 점진적으로 더 높은 최적화 수준으로 컴파일한다.\nAndroid의 혼합 접근법\nAndroid 7.0(Nougat)부터는 AOT, JIT, 프로필 기반 컴파일을 혼합하여 사용한다:\n앱 설치 시: 일부 AOT 컴파일 첫 실행 시: JIT 컴파일 + 사용 패턴 프로파일링 기기 유휴 상태 + 충전 중: 프로파일 기반으로 자주 사용되는 코드 AOT 컴파일 JavaScript 엔진의 발전\nV8, SpiderMonkey 등 최신 JavaScript 엔진은 인터프리터, 기본 JIT, 최적화 JIT 컴파일러를 혼합하여 사용한다.\nAOT 컴파일러의 미래 전망 WebAssembly (Wasm)\n웹 브라우저에서 네이티브에 가까운 성능으로 코드를 실행할 수 있는 WebAssembly는 AOT 컴파일의 개념을 웹으로 확장한다.\n1 2 3 4 5 6 // Rust로 작성된 WebAssembly 예제 fn main() { println!(\"Hello, WebAssembly!\"); } // wasm-pack build로 WebAssembly 컴파일 양자 컴퓨팅 언어\n양자 컴퓨팅 언어(Q#, Cirq 등)는 양자 회로 생성을 위해 AOT 컴파일 접근 방식을 사용한다.\n기계 학습 기반 최적화\n컴파일러가 기계 학습을 활용하여 더 효과적인 코드 생성 결정을 내리는 연구가 진행 중이다.\n오프로딩 컴파일 (Offloaded Compilation) 클라우드에서의 컴파일을 통해 로컬 개발 환경의 제약을 극복하는 접근법이 발전하고 있습니다.\nAOT 컴파일러 개발 및 맞춤화 LLVM 활용\nLLVM(Low Level Virtual Machine) 인프라는 AOT 컴파일러 개발을 위한 강력한 도구.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // LLVM을 사용한 간단한 컴파일러 예제 #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/IRBuilder.h\" int main() { llvm::LLVMContext context; llvm::Module *module = new llvm::Module(\"my_module\", context); llvm::IRBuilder\u003c\u003e builder(context); // IR 생성 코드… // 네이티브 코드 생성 및 최적화… return 0; } 기존 컴파일러 확장\nGCC, Clang 등 기존 컴파일러를 확장하여 특정 요구 사항에 맞게 조정할 수 있다.\n도메인 특화 언어(DSL) 컴파일러\n특정 도메인에 최적화된 컴파일러를 개발하는 접근법도 증가하고 있다.\n참고 및 출처 ","wordCount":"1733","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-14T18:02:00Z","dateModified":"2024-10-14T18:02:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href>Programming Language Theory</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/>types of Compiler</a></div><h1 class="post-title entry-hint-parent">Ahead-of-Time Compiler</h1><div class=post-description>**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술</div><div class=post-meta><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Foundations/Language%20Theory/Compilation%20and%20Interpretation/Compiler%20Types/Ahead-of-Time-Compiler.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#ahead-of-time-aot-compiler>Ahead-of-Time (AOT) Compiler</a><ul><li><a href=#aot-컴파일러의-기본-개념>AOT 컴파일러의 기본 개념</a></li><li><a href=#aot-컴파일의-역사적-발전>AOT 컴파일의 역사적 발전</a></li><li><a href=#주요-특징>주요 특징</a></li><li><a href=#aot-컴파일의-장단점>AOT 컴파일의 장단점</a></li><li><a href=#aot-컴파일러의-작동-원리>AOT 컴파일러의 작동 원리</a></li><li><a href=#aot-컴파일러의-최적화-기법>AOT 컴파일러의 최적화 기법</a></li><li><a href=#aot-컴파일러의-구현-사례>AOT 컴파일러의 구현 사례</a></li><li><a href=#aot-컴파일의-실제-사용-사례>AOT 컴파일의 실제 사용 사례</a></li><li><a href=#하이브리드-접근법-aot와-jit의-결합>하이브리드 접근법: AOT와 JIT의 결합</a></li><li><a href=#aot-컴파일러의-미래-전망>AOT 컴파일러의 미래 전망</a></li><li><a href=#aot-컴파일러-개발-및-맞춤화>AOT 컴파일러 개발 및 맞춤화</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=ahead-of-time-aot-compiler>Ahead-of-Time (AOT) Compiler<a hidden class=anchor aria-hidden=true href=#ahead-of-time-aot-compiler>#</a></h2><p><strong>Ahead-of-Time(AOT) 컴파일러</strong>는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 <strong>네이티브 머신 코드로 미리 변환</strong>하는 기술이다. 이는 런타임 동안의 동적 컴파일 오버헤드를 제거하여, 프로그램이 시작될 때 바로 최적화된 실행 코드를 사용할 수 있도록 함으로써 빠른 시작 시간과 예측 가능한 성능을 제공한다.</p><p>AOT 컴파일러는 프로그램 실행 전에 소스 코드를 네이티브 코드로 변환하여 실행 성능을 최적화하는 중요한 도구이다. 특히 시작 시간, 예측 가능한 성능, 메모리 효율성이 중요한 환경에서 큰 이점을 제공한다.</p><p>현대 소프트웨어 개발에서는 AOT 컴파일과 JIT 컴파일, 때로는 인터프리터 방식을 혼합하여 사용하는 하이브리드 접근법이 점점 더 인기를 얻고 있다. 이는 각 방식의 장점을 최대한 활용하면서 단점을 최소화하기 위한 전략이다.</p><p>기술이 발전함에 따라 AOT 컴파일러는 더욱 정교해지고 있으며, 기계 학습, 클라우드 컴퓨팅, 양자 컴퓨팅과 같은 신기술과 결합하여 소프트웨어 개발 환경의 발전을 이끌고 있다. 개발자들은 이러한 기술을 이해하고 적절히 활용함으로써 더 효율적이고 성능이 뛰어난 애플리케이션을 구축할 수 있다.</p><h3 id=aot-컴파일러의-기본-개념>AOT 컴파일러의 기본 개념<a hidden class=anchor aria-hidden=true href=#aot-컴파일러의-기본-개념>#</a></h3><p>AOT 컴파일은 프로그램이 실행되기 전에 소스 코드를 대상 기계의 네이티브 코드로 컴파일하는 과정이다.<br>이는 프로그램이 실행될 때마다 코드를 해석하거나 JIT(Just-In-Time) 컴파일하는 대신, 한 번만 컴파일하여 실행 준비가 완료된 형태로 저장하는 방식이다.</p><p>간단히 표현하면 다음과 같은 과정을 거칩니다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>소스 코드 → [AOT 컴파일] → 네이티브 실행 파일 → 실행
</span></span></code></pre></td></tr></table></div></div><p>이 방식은 전통적인 정적 컴파일러(C, C++ 컴파일러 등)가 사용하는 방식과 유사하지만, 현대적 AOT 컴파일러는 중간 표현(IR)이나 바이트코드를 처리하는 경우가 많다는 점에서 차이가 있다.</p><h3 id=aot-컴파일의-역사적-발전>AOT 컴파일의 역사적 발전<a hidden class=anchor aria-hidden=true href=#aot-컴파일의-역사적-발전>#</a></h3><p>AOT 컴파일은 컴퓨터 프로그래밍의 초기부터 존재해 왔지만, &lsquo;선행 컴파일&rsquo;이라는 용어와 개념은 인터프리터와 JIT 컴파일러의 등장 이후 이들과 구별하기 위해 더 널리 사용되기 시작했다.</p><ol><li><p>초기 컴파일러 (1950년대~)<br>첫 번째 고급 프로그래밍 언어인 FORTRAN의 컴파일러는 본질적으로 AOT 컴파일러였다.<br>소스 코드를 한 번 컴파일하고 그 결과로 생성된 바이너리를 실행했다.</p></li><li><p>중간 표현의 발전 (1990년대~)<br>Java와.NET과 같은 플랫폼이 등장하면서, 바이트코드라는 중간 표현을 사용하는 방식이 보편화되었다.<br>이러한 환경에서는 일반적으로 JIT 컴파일을 사용했지만, 성능 개선을 위해 AOT 컴파일 옵션도 점차 도입되었다.</p></li><li><p>모바일 시대 (2010년대~)<br>모바일 기기의 제한된 자원과 배터리 수명 문제로 인해 AOT 컴파일에 대한 관심이 증가했다.<br>Android의 ART(Android Runtime)는 Dalvik VM을 대체하며 AOT 컴파일을 도입한 대표적인 사례.</p></li><li><p>현대적 접근 (2020년대~)<br>현재는 많은 환경에서 AOT와 JIT 컴파일을 혼합하여 사용하는 하이브리드 접근법이 인기를 얻고 있다.<br>이는 AOT의 초기 성능 이점과 JIT의 동적 최적화 장점을 모두 활용할 수 있기 때문이다.</p></li></ol><p><figure><img alt="Ahead-of-Time (AOT) Compiler" loading=lazy src=/img/Ahead-of-Time-AOT-Compilation-1-1536x793.jpg.webp><figcaption>https://www.monarch-innovation.com/aot-vs-jit-compiler-in-angular</figcaption></figure></p><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ul><li><strong>사전 컴파일:</strong> 프로그램의 소스 코드를 빌드 시점에 기계어로 변환하여 실행 파일을 생성한다. 이를 통해 실행 시점에 추가적인 컴파일 작업이 필요 없으며, 프로그램의 시작 시간을 단축시킨다.</li><li><strong>일관된 성능:</strong> 실행 전에 모든 컴파일 작업이 완료되므로, 프로그램 실행 중에 발생할 수 있는 성능 변동이 최소화된다.</li><li><strong>보안 강화:</strong> 소스 코드가 미리 컴파일되어 배포되므로, 코드 노출 위험이 감소하고 역공학에 대한 저항력이 높아진다.</li></ul><h3 id=aot-컴파일의-장단점>AOT 컴파일의 장단점<a hidden class=anchor aria-hidden=true href=#aot-컴파일의-장단점>#</a></h3><h4 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h4><ol><li><p>향상된 시작 시간<br>프로그램이 실행될 때 코드 해석이나 컴파일이 필요 없어 시작 시간이 단축된다.<br>이는 사용자 경험에 직접적인 영향을 미친다.</p></li><li><p>예측 가능한 성능<br>실행 시 컴파일이 없으므로 성능이 안정적이고 예측 가능하다.<br>특히 실시간 시스템이나 게임과 같이 일관된 성능이 중요한 애플리케이션에서 유리하다.</p></li><li><p>낮은 메모리 사용량<br>JIT 컴파일러가 필요 없어 런타임 메모리 오버헤드가 감소한다. 또한 코드 캐싱에 필요한 메모리도 절약된다.</p></li><li><p>향상된 보안<br>소스 코드나 중간 표현이 배포되지 않아 역공학이 더 어렵다. 또한 JIT 컴파일러 관련 취약점에 노출되지 않는다.</p></li><li><p>향상된 배터리 수명 (모바일 기기)<br>컴파일 작업이 없어 CPU 사용량이 감소하고 이는 배터리 수명 향상으로 이어진다.</p></li></ol><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ol><li><p>증가된 파일 크기<br>네이티브 코드는 중간 표현보다 일반적으로 크기 때문에 배포 파일 크기가 증가한다.</p></li><li><p>플랫폼 의존성<br>각 목표 플랫폼/아키텍처별로 별도 컴파일이 필요하여 &ldquo;한 번 작성하고 어디서나 실행&rdquo; 패러다임이 약화된다.</p></li><li><p>동적 최적화 부재<br>JIT 컴파일러와 달리 런타임 정보를 활용한 최적화가 어렵다. 특히 자주 실행되는 핫스팟 코드나 실행 패턴에 기반한 최적화에 제한이 있다.</p></li><li><p>컴파일 시간 증가<br>AOT 컴파일은 개발-빌드-테스트 주기에 시간을 추가하여 개발 속도를 늦출 수 있다.</p></li><li><p>리플렉션 및 동적 기능 제한<br>리플렉션, 동적 클래스 로딩과 같은 동적 기능이 제한되거나 특별한 처리가 필요할 수 있다.</p></li></ol><h3 id=aot-컴파일러의-작동-원리>AOT 컴파일러의 작동 원리<a hidden class=anchor aria-hidden=true href=#aot-컴파일러의-작동-원리>#</a></h3><p>AOT 컴파일러는 일반적으로 다음과 같은 단계를 거쳐 작동한다:</p><ol><li><p>소스 코드 파싱<br>소스 코드를 토큰화하고 구문 분석하여 추상 구문 트리(AST)를 생성한다.</p></li><li><p>의미 분석<br>AST를 검사하여 타입 체킹, 변수 선언 확인 등 의미적 정확성을 검증한다.</p></li><li><p>중간 표현(IR) 생성<br>언어 중립적인 중간 표현으로 코드를 변환한다.<br>이 단계에서 초기 최적화가 적용될 수 있다.</p></li><li><p>최적화<br>다양한 최적화 패스를 통해 코드 성능을 개선한다.<br>예를 들어:</p><ul><li>상수 폴딩 및 전파</li><li>루프 최적화</li><li>인라인화</li><li>데드 코드 제거</li><li>레지스터 할당</li></ul></li><li><p>코드 생성<br>최적화된 IR을 특정 대상 아키텍처(x86, ARM, RISC-V 등)의 네이티브 기계어로 변환한다.</p></li><li><p>링킹<br>생성된 목적 파일을 라이브러리 및 다른 목적 파일과 링크하여 최종 실행 파일을 생성한다.</p></li></ol><h3 id=aot-컴파일러의-최적화-기법>AOT 컴파일러의 최적화 기법<a hidden class=anchor aria-hidden=true href=#aot-컴파일러의-최적화-기법>#</a></h3><h4 id=정적-분석-기반-최적화>정적 분석 기반 최적화<a hidden class=anchor aria-hidden=true href=#정적-분석-기반-최적화>#</a></h4><p>컴파일 시간에 코드 분석을 통해 다양한 최적화를 적용한다:</p><ol><li><p>인라인화 (Inlining)<br>작은 함수를 호출 위치에 직접 삽입하여 함수 호출 오버헤드를 제거한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 원본 코드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>square</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=nf>square</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 인라인화 후
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>5</span> <span class=o>*</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>상수 폴딩 및 전파 (Constant Folding & Propagation)<br>컴파일 시점에 계산 가능한 표현식을 평가하고 상수 값을 전파한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 원본 코드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 최적화 후
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>25</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>데드 코드 제거 (Dead Code Elimination)<br>절대 실행되지 않는 코드를 제거한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 원본 코드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nb>false</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>doSomething</span><span class=p>();</span> <span class=c1>// 데드 코드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 최적화 후
</span></span></span><span class=line><span class=cl><span class=c1>// (해당 부분 완전히 제거됨)
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>루프 최적화<br>루프 언롤링, 루프 불변 코드 이동, 벡터화 등 다양한 루프 최적화를 적용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 원본 코드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 루프 언롤링 후
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>array</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>아키텍처 특화 최적화<br>대상 아키텍처의 특성을 활용한 최적화를 적용한다:</p><ul><li>SIMD 명령어 활용: Single Instruction Multiple Data 명령어를 사용하여 데이터 병렬 처리를 최적화한다.</li><li>캐시 최적화: 데이터 및 명령어 캐시 사용을 최적화하기 위한 메모리 레이아웃 조정.</li><li>분기 예측 최적화: 분기 예측 실패를 최소화하기 위한 코드 재배치 및 최적화.</li></ul></li></ol><h4 id=전체-프로그램-최적화-whole-program-optimization>전체 프로그램 최적화 (Whole Program Optimization)<a hidden class=anchor aria-hidden=true href=#전체-프로그램-최적화-whole-program-optimization>#</a></h4><p>다양한 모듈에 걸친 전역 최적화를 적용한다:</p><ol><li><p>링크 타임 최적화 (Link-Time Optimization, LTO)<br>서로 다른 컴파일 단위에 걸친 최적화를 적용한다.</p></li><li><p>프로필 기반 최적화 (Profile-Guided Optimization, PGO)<br>테스트 실행에서 수집한 프로파일 데이터를 기반으로 컴파일 시 최적화 결정을 내린다.</p></li></ol><h3 id=aot-컴파일러의-구현-사례>AOT 컴파일러의 구현 사례<a hidden class=anchor aria-hidden=true href=#aot-컴파일러의-구현-사례>#</a></h3><ol><li><p>Android Runtime (ART)<br>Android 5.0(Lollipop)부터 도입된 ART는 이전의 Dalvik VM을 대체했다.<br>ART는 앱 설치 시 DEX 바이트코드를 네이티브 기계어로 컴파일하여 실행 속도를 크게 향상시켰다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Java 소스 코드</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Hello</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Hello, World!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 컴파일 및 실행 과정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// javac Hello.java → Hello.class (바이트코드)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Android에서: dx --dex --output=Hello.dex Hello.class</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// ART에서 설치 시: DEX → OAT (최적화된 Android 형식, 네이티브 코드 포함)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>NativeAOT (.NET)<br><code>.NET 6</code>부터 정식 지원되는 NativeAOT(이전 명칭: CoreRT)는.NET 애플리케이션을 네이티브 코드로 컴파일하여 시작 시간과 메모리 사용량을 크게 개선한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-csharp data-lang=csharp><span class=line><span class=cl><span class=c1>// C# 소스 코드</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Program</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>&#34;Hello, World!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NativeAOT 컴파일 명령</span>
</span></span><span class=line><span class=cl><span class=c1>// dotnet publish -r win-x64 -c Release /p:PublishAot=true</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Graal Native Image (Java)<br>GraalVM의 Native Image는 Java 애플리케이션을 독립 실행형 네이티브 실행 파일로 컴파일한다.<br>이는 Java의 시작 시간과 메모리 사용량을 크게 개선하며, 특히 마이크로서비스 및 서버리스 환경에서 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 컴파일 명령</span>
</span></span><span class=line><span class=cl>native-image -cp app.jar com.example.MyApplication
</span></span></code></pre></td></tr></table></div></div></li><li><p>Angular의 AOT 컴파일러<br>웹 프레임워크인 Angular는 TypeScript 코드와 HTML 템플릿을 JavaScript로 컴파일하는 AOT 컴파일러를 제공한다. 이는 런타임에 템플릿을 컴파일하는 대신 빌드 과정에서 처리하여 웹 애플리케이션의 초기 로딩 시간을 단축한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Angular CLI를 사용한 AOT 컴파일</span>
</span></span><span class=line><span class=cl>ng build --aot
</span></span></code></pre></td></tr></table></div></div></li><li><p>LLVM 기반 AOT 컴파일러<br>LLVM은 다양한 프로그래밍 언어를 위한 모듈식 컴파일러 인프라를 제공한다.<br>Swift, Rust 등 여러 언어가 LLVM을 기반으로 AOT 컴파일을 구현한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=c1>// Swift 코드</span>
</span></span><span class=line><span class=cl><span class=bp>print</span><span class=p>(</span><span class=s>&#34;Hello, World!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Swift 컴파일러는 LLVM을 사용하여 네이티브 코드 생성</span>
</span></span><span class=line><span class=cl><span class=c1>// swiftc hello.swift -o hello</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=aot-컴파일의-실제-사용-사례>AOT 컴파일의 실제 사용 사례<a hidden class=anchor aria-hidden=true href=#aot-컴파일의-실제-사용-사례>#</a></h3><ol><li><p>임베디드 시스템 및 IoT<br>제한된 리소스를 가진 임베디드 기기에서는 AOT 컴파일이 자주 사용된다.<br>메모리 사용량 감소와 예측 가능한 성능이 중요한 요소이다.</p></li><li><p>서버리스 및 마이크로서비스<br>AWS Lambda, Azure Functions 등 서버리스 환경에서는 콜드 스타트(cold start) 시간이 중요하다.<br>AOT 컴파일은 시작 시간을 단축하여 사용자 경험을 개선한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Quarkus와 GraalVM을 사용한 Java 마이크로서비스</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Path</span><span class=p>(</span><span class=s>&#34;/hello&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>GreetingResource</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GET</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Produces</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=na>TEXT_PLAIN</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=nf>hello</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=s>&#34;Hello RESTEasy&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// quarkus build --native로 네이티브 이미지 생성</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>모바일 애플리케이션<br>모바일 기기의 제한된 배터리 수명과 성능을 고려하여 AOT 컴파일이 널리 사용된다.<br>Flutter, React Native 등의 크로스 플랫폼 프레임워크도 부분적으로 AOT 컴파일을 활용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dart data-lang=dart><span class=line><span class=cl><span class=c1>// Flutter 앱
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>runApp</span><span class=p>(</span><span class=n>MyApp</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>MyApp</span> <span class=kd>extends</span> <span class=n>StatelessWidget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=err>@</span><span class=n>override</span>
</span></span><span class=line><span class=cl>  <span class=n>Widget</span> <span class=n>build</span><span class=p>(</span><span class=n>BuildContext</span> <span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>MaterialApp</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nl>home:</span> <span class=n>Text</span><span class=p>(</span><span class=s1>&#39;Hello, World!&#39;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// flutter build apk로 AOT 컴파일된 앱 생성
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>게임 개발<br>Unity, Unreal Engine과 같은 게임 엔진은 일관된 성능을 위해 AOT 컴파일을 활용한다.</p></li><li><p>보안이 중요한 애플리케이션<br>금융, 의료, 군사 등 보안이 중요한 분야에서는 코드 보호를 위해 AOT 컴파일을 선호한다.</p></li></ol><h3 id=하이브리드-접근법-aot와-jit의-결합>하이브리드 접근법: AOT와 JIT의 결합<a hidden class=anchor aria-hidden=true href=#하이브리드-접근법-aot와-jit의-결합>#</a></h3><p>최근에는 AOT와 JIT의 장점을 결합한 하이브리드 접근법이 인기를 얻고 있다:</p><ol><li><p>계층적 컴파일 (Tiered Compilation)<br>자주 실행되는 코드(핫스팟)를 점진적으로 더 높은 최적화 수준으로 컴파일한다.</p></li><li><p>Android의 혼합 접근법<br>Android 7.0(Nougat)부터는 AOT, JIT, 프로필 기반 컴파일을 혼합하여 사용한다:</p><ul><li>앱 설치 시: 일부 AOT 컴파일</li><li>첫 실행 시: JIT 컴파일 + 사용 패턴 프로파일링</li><li>기기 유휴 상태 + 충전 중: 프로파일 기반으로 자주 사용되는 코드 AOT 컴파일</li></ul></li><li><p>JavaScript 엔진의 발전<br>V8, SpiderMonkey 등 최신 JavaScript 엔진은 인터프리터, 기본 JIT, 최적화 JIT 컴파일러를 혼합하여 사용한다.</p></li></ol><h3 id=aot-컴파일러의-미래-전망>AOT 컴파일러의 미래 전망<a hidden class=anchor aria-hidden=true href=#aot-컴파일러의-미래-전망>#</a></h3><ol><li><p>WebAssembly (Wasm)<br>웹 브라우저에서 네이티브에 가까운 성능으로 코드를 실행할 수 있는 WebAssembly는 AOT 컴파일의 개념을 웹으로 확장한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5>5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Rust로 작성된 WebAssembly 예제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Hello, WebAssembly!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// wasm-pack build로 WebAssembly 컴파일
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>양자 컴퓨팅 언어<br>양자 컴퓨팅 언어(Q#, Cirq 등)는 양자 회로 생성을 위해 AOT 컴파일 접근 방식을 사용한다.</p></li><li><p>기계 학습 기반 최적화<br>컴파일러가 기계 학습을 활용하여 더 효과적인 코드 생성 결정을 내리는 연구가 진행 중이다.</p></li></ol><h4 id=오프로딩-컴파일-offloaded-compilation>오프로딩 컴파일 (Offloaded Compilation)<a hidden class=anchor aria-hidden=true href=#오프로딩-컴파일-offloaded-compilation>#</a></h4><p>클라우드에서의 컴파일을 통해 로컬 개발 환경의 제약을 극복하는 접근법이 발전하고 있습니다.</p><h3 id=aot-컴파일러-개발-및-맞춤화>AOT 컴파일러 개발 및 맞춤화<a hidden class=anchor aria-hidden=true href=#aot-컴파일러-개발-및-맞춤화>#</a></h3><ol><li><p>LLVM 활용<br>LLVM(Low Level Virtual Machine) 인프라는 AOT 컴파일러 개발을 위한 강력한 도구.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// LLVM을 사용한 간단한 컴파일러 예제
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;llvm/IR/LLVMContext.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;llvm/IR/Module.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;llvm/IR/IRBuilder.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>llvm</span><span class=o>::</span><span class=n>LLVMContext</span> <span class=n>context</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>llvm</span><span class=o>::</span><span class=n>Module</span> <span class=o>*</span><span class=n>module</span> <span class=o>=</span> <span class=k>new</span> <span class=n>llvm</span><span class=o>::</span><span class=n>Module</span><span class=p>(</span><span class=s>&#34;my_module&#34;</span><span class=p>,</span> <span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>llvm</span><span class=o>::</span><span class=n>IRBuilder</span><span class=o>&lt;&gt;</span> <span class=n>builder</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// IR 생성 코드…
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 네이티브 코드 생성 및 최적화…
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>기존 컴파일러 확장<br>GCC, Clang 등 기존 컴파일러를 확장하여 특정 요구 사항에 맞게 조정할 수 있다.</p></li><li><p>도메인 특화 언어(DSL) 컴파일러<br>특정 도메인에 최적화된 컴파일러를 개발하는 접근법도 증가하고 있다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/types/>Types</a></li><li><a href=https://buenhyden.github.io/tags/ahead-of-time-compiler/>Ahead-of-Time-Compiler</a></li><li><a href=https://buenhyden.github.io/tags/aot/>AOT</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/insertion-sort/><span class=title>« Prev</span><br><span>삽입 정렬 (Insertion Sort)</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/asynchronous-programming/callback/callback-hell/><span class=title>Next »</span><br><span>Callback Hell</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>