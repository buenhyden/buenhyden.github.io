<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event Loop | hyunyoun's Blog</title>
<meta name=keywords content="Programming-Languages,Javascript,Event-Loop"><meta name=description content="이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Event Loop"><meta property="og:description" content="이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-17T12:44:00+00:00"><meta property="article:modified_time" content="2024-12-17T12:44:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Javascript"><meta property="article:tag" content="Event-Loop"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Event Loop"><meta name=twitter:description content="이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Programming Languages","item":"https://buenhyden.github.io/posts/programming-languages/"},{"@type":"ListItem","position":3,"name":"Javascript","item":"https://buenhyden.github.io/posts/programming-languages/javascript/"},{"@type":"ListItem","position":4,"name":"Javascript's Concepts","item":"https://buenhyden.github.io/posts/programming-languages/javascript/concepts/"},{"@type":"ListItem","position":5,"name":"Event Loop","item":"https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event Loop","name":"Event Loop","description":"이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.","keywords":["Programming-Languages","Javascript","Event-Loop"],"articleBody":"Event Loop 이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.\n끊임없이 실행되는 프로세스로, 콜 스택이 비어있는지 확인하고 태스크 큐에서 콜백 함수를 가져와 실행하며, 자바스크립트 엔진이 아닌 호스팅 환경(브라우저 또는 Node.js)에서 제공되는 메커니즘이다. 또한, 비동기 작업의 완료 및 해당 콜백의 실행을 조정한다.\nEvent Loop의 구성 요소 콜 스택 (Call Stack): 현재 실행 중인 함수들이 쌓이는 곳. 후입선출(LIFO) 구조 웹 API (Web APIs): 브라우저에서 제공하는 비동기 작업을 처리하는 API. 콜백 큐 (Callback Queue): 비동기 작업이 완료된 후 실행될 콜백 함수들이 대기하는 곳. 선입선출(FIFO) 구조 이벤트 루프 (Event Loop): 콜 스택과 콜백 큐를 모니터링하며 작업을 조율. Event Loop의 동작 과정 JavaScript 코드가 실행되면 함수 호출은 콜 스택에 쌓인다. 비동기 함수(예: setTimeout, fetch)를 만나면 웹 API로 보내져 별도로 처리된다. 웹 API에서 작업이 완료되면 해당 콜백 함수를 콜백 큐로 보낸다. 이벤트 루프는 지속적으로 콜 스택이 비어있는지 확인한다. 콜 스택이 비어있다면, 이벤트 루프는 콜백 큐에서 가장 오래된 콜백을 콜 스택으로 이동시킨다. 이 과정을 반복한다. Event Loop의 기본 개념: 식당 시나리오 상황: 바쁜 식당에서 일하는 웨이터를 생각해보자.\n웨이터 = JavaScript의 메인 스레드 주문 접수 데스크 = 콜 스택(Call Stack) 주방 = Web APIs (비동기 작업이 실행되는 곳) 주문 대기 선반 = 콜백 큐(Callback Queue) 매니저 = Event Loop 동작 방식 웨이터(메인 스레드)는 주문 접수 데스크(콜 스택)에서 한 번에 하나의 주문만 처리할 수 있다. 주문이 들어오면 다음과 같이 처리된다. 즉시 처리 가능한 주문 → 바로 처리 (동기 작업) 조리가 필요한 주문 → 주방으로 전달 (비동기 작업) 주방(Web APIs)에서 음식이 완성되면 주문 대기 선반(콜백 큐)에 놓는다. 매니저(Event Loop)는 지속적으로: 주문 접수 데스크가 비어있는지 확인 대기 선반에 완성된 주문이 있는지 확인 있다면 웨이터에게 전달하여 손님에게 서빙하도록 함 동작 예시 1 2 3 4 5 6 7 console.log(\"손님이 입장했습니다.\"); // 1번: 즉시 실행 setTimeout(() =\u003e { console.log(\"주문하신 음식이 나왔습니다.\"); // 3번: 2초 후 실행 }, 2000); console.log(\"메뉴를 고르는 중입니다.\"); // 2번: 즉시 실행 이 코드의 실행 순서:\n“손님이 입장했습니다.” 출력 (동기 작업) setTimeout은 Web APIs로 전달 (비동기 작업) “메뉴를 고르는 중입니다.” 출력 (동기 작업) 2초 후, 콜백이 큐에 추가됨 Event Loop가 콜백을 스택으로 이동 “주문하신 음식이 나왔습니다.” 출력 마이크로태스크와 매크로태스크 :\n구분 마이크로태스크 (Microtask) 매크로태스크 (Macrotask) 우선순위 높음 (매크로태스크보다 먼저 실행) 낮음 실행 시점 현재 매크로태스크 완료 직후 다음 이벤트 루프 사이클 주요 예시 Promise.then/catch/finally\nprocess.nextTick\nqueueMicrotask\nMutationObserver setTimeout/setInterval\nsetImmediate\nrequestAnimationFrame\nI/O 작업\nUI 렌더링 실행 특성 큐의 모든 태스크가 완료될 때까지 연속 실행 한 번에 하나씩 실행 메모리 사용 일반적으로 더 적은 메모리 사용 상대적으로 더 많은 메모리 사용 사용 목적 즉각적인 상태 업데이트\n데이터 일관성 유지 무거운 계산\nI/O 작업\n타이밍 기반 작업 에러 처리 동기적으로 처리 가능 try-catch로 직접 처리 불가 실행 컨텍스트 현재 실행 컨텍스트 유지 새로운 실행 컨텍스트 생성 디버깅 상대적으로 쉬움 비동기 특성으로 인해 더 복잡 태스크 취소 일반적으로 불가능 clearTimeout 등으로 가능 이제 각각의 특징을 자세히 살펴보겠습니다:\n특성 마이크로태스크 매크로태스크 실행 시점 현재 작업 완료 직후, 렌더링 전 마이크로태스크 큐가 비어있을 때 처리 방식 큐가 비워질 때까지 연속 실행 한 번에 하나씩 실행 큐 처리 모든 마이크로태스크 처리 후 매크로태스크로 이동 각 매크로태스크 사이에 마이크로태스크 확인 마이크로태스크 (Microtasks) 마이크로태스크는 현재 실행 중인 스크립트나 태스크가 완료된 직후에 실행되는 작은 태스크.\n이들은 높은 우선순위를 가지며, 다른 매크로태스크나 렌더링 작업보다 먼저 처리된다.\n주요 특징:\n높은 우선순위 현재 작업 완료 직후 실행 모든 마이크로태스크가 처리될 때까지 계속 실행 예시:\nPromise 콜백 (.then,.catch,.finally) process.nextTick (Node.js) queueMicrotask() MutationObserver 콜백 매크로태스크 (Macrotasks) 매크로태스크는 일반적인 비동기 작업을 나타내며, 마이크로태스크보다 낮은 우선순위를 가진다.\n이들은 마이크로태스크 큐가 비어있을 때만 실행된다.\n주요 특징:\n낮은 우선순위 마이크로태스크 큐가 비어있을 때 실행 한 번에 하나씩 처리됨 예시:\nsetTimeout, setInterval I/O 작업 UI 렌더링 requestAnimationFrame Event Loop의 중요성 비차단 실행 (Non-blocking Execution)\n긴 작업이 있어도 UI가 멈추지 않음 사용자 경험 향상 효율적인 리소스 사용\n단일 스레드로도 동시성 처리 가능 메모리 사용 효율화 확장성\n많은 동시 연결 처리 가능 서버 사이드 JavaScript의 핵심 장점 주의할 점 콜 스택 블로킹 피하기\n무거운 계산은 Web Worker로 분리 긴 동기 작업 피하기 콜백 큐 관리\n너무 많은 비동기 작업 동시 실행 피하기 적절한 에러 처리 구현 실행 순서 이해\n마이크로태스크와 매크로태스크의 우선순위 파악 비동기 작업의 실행 순서 예측 참고 및 출처 ","wordCount":"662","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-17T12:44:00Z","dateModified":"2024-12-17T12:44:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/>Programming Languages</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/javascript/>Javascript</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/>Javascript's Concepts</a></div><h1 class="post-title entry-hint-parent">Event Loop</h1><div class=post-description>이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.</div><div class=post-meta><span title='2024-12-17 12:44:00 +0000 UTC'>December 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;662 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Programming%20Languages/Javascript/Concepts/Event-Loop.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#event-loop>Event Loop</a><ul><li><a href=#event-loop의-구성-요소>Event Loop의 구성 요소</a></li><li><a href=#event-loop의-동작-과정>Event Loop의 동작 과정</a></li><li><a href=#event-loop의-기본-개념-식당-시나리오>Event Loop의 기본 개념: 식당 시나리오</a></li><li><a href=#동작-예시>동작 예시</a></li><li><a href=#마이크로태스크와-매크로태스크>마이크로태스크와 매크로태스크</a></li><li><a href=#event-loop의-중요성>Event Loop의 중요성</a></li><li><a href=#주의할-점>주의할 점</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=event-loop>Event Loop<a hidden class=anchor aria-hidden=true href=#event-loop>#</a></h2><p>이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.</p><p>끊임없이 실행되는 프로세스로, 콜 스택이 비어있는지 확인하고 태스크 큐에서 콜백 함수를 가져와 실행하며, 자바스크립트 엔진이 아닌 호스팅 환경(브라우저 또는 Node.js)에서 제공되는 메커니즘이다. 또한, 비동기 작업의 완료 및 해당 콜백의 실행을 조정한다.</p><h3 id=event-loop의-구성-요소>Event Loop의 구성 요소<a hidden class=anchor aria-hidden=true href=#event-loop의-구성-요소>#</a></h3><ol><li>콜 스택 (Call Stack): 현재 실행 중인 함수들이 쌓이는 곳. 후입선출(LIFO) 구조</li><li>웹 API (Web APIs): 브라우저에서 제공하는 비동기 작업을 처리하는 API.</li><li>콜백 큐 (Callback Queue): 비동기 작업이 완료된 후 실행될 콜백 함수들이 대기하는 곳. 선입선출(FIFO) 구조</li><li>이벤트 루프 (Event Loop): 콜 스택과 콜백 큐를 모니터링하며 작업을 조율.</li></ol><h3 id=event-loop의-동작-과정>Event Loop의 동작 과정<a hidden class=anchor aria-hidden=true href=#event-loop의-동작-과정>#</a></h3><ol><li>JavaScript 코드가 실행되면 함수 호출은 콜 스택에 쌓인다.</li><li>비동기 함수(예: setTimeout, fetch)를 만나면 웹 API로 보내져 별도로 처리된다.</li><li>웹 API에서 작업이 완료되면 해당 콜백 함수를 콜백 큐로 보낸다.</li><li>이벤트 루프는 지속적으로 콜 스택이 비어있는지 확인한다.</li><li>콜 스택이 비어있다면, 이벤트 루프는 콜백 큐에서 가장 오래된 콜백을 콜 스택으로 이동시킨다.</li><li>이 과정을 반복한다.</li></ol><h3 id=event-loop의-기본-개념-식당-시나리오>Event Loop의 기본 개념: 식당 시나리오<a hidden class=anchor aria-hidden=true href=#event-loop의-기본-개념-식당-시나리오>#</a></h3><p>상황: 바쁜 식당에서 일하는 웨이터를 생각해보자.</p><ol><li>웨이터 = JavaScript의 메인 스레드</li><li>주문 접수 데스크 = 콜 스택(Call Stack)</li><li>주방 = Web APIs (비동기 작업이 실행되는 곳)</li><li>주문 대기 선반 = 콜백 큐(Callback Queue)</li><li>매니저 = Event Loop</li></ol><h4 id=동작-방식>동작 방식<a hidden class=anchor aria-hidden=true href=#동작-방식>#</a></h4><ol><li>웨이터(메인 스레드)는 주문 접수 데스크(콜 스택)에서 한 번에 하나의 주문만 처리할 수 있다.</li><li>주문이 들어오면 다음과 같이 처리된다.<ul><li>즉시 처리 가능한 주문 → 바로 처리 (동기 작업)</li><li>조리가 필요한 주문 → 주방으로 전달 (비동기 작업)</li></ul></li><li>주방(Web APIs)에서 음식이 완성되면 주문 대기 선반(콜백 큐)에 놓는다.</li><li>매니저(Event Loop)는 지속적으로:<ul><li>주문 접수 데스크가 비어있는지 확인</li><li>대기 선반에 완성된 주문이 있는지 확인</li><li>있다면 웨이터에게 전달하여 손님에게 서빙하도록 함</li></ul></li></ol><h3 id=동작-예시>동작 예시<a hidden class=anchor aria-hidden=true href=#동작-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;손님이 입장했습니다.&#34;</span><span class=p>);</span>  <span class=c1>// 1번: 즉시 실행
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;주문하신 음식이 나왔습니다.&#34;</span><span class=p>);</span>  <span class=c1>// 3번: 2초 후 실행
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>},</span> <span class=mi>2000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;메뉴를 고르는 중입니다.&#34;</span><span class=p>);</span>  <span class=c1>// 2번: 즉시 실행
</span></span></span></code></pre></td></tr></table></div></div><p>이 코드의 실행 순서:</p><ol><li>&ldquo;손님이 입장했습니다.&rdquo; 출력 (동기 작업)</li><li>setTimeout은 Web APIs로 전달 (비동기 작업)</li><li>&ldquo;메뉴를 고르는 중입니다.&rdquo; 출력 (동기 작업)</li><li>2초 후, 콜백이 큐에 추가됨</li><li>Event Loop가 콜백을 스택으로 이동</li><li>&ldquo;주문하신 음식이 나왔습니다.&rdquo; 출력</li></ol><h3 id=마이크로태스크와-매크로태스크>마이크로태스크와 매크로태스크<a hidden class=anchor aria-hidden=true href=#마이크로태스크와-매크로태스크>#</a></h3><p>:</p><table><thead><tr><th>구분</th><th>마이크로태스크 (Microtask)</th><th>매크로태스크 (Macrotask)</th></tr></thead><tbody><tr><td><strong>우선순위</strong></td><td>높음 (매크로태스크보다 먼저 실행)</td><td>낮음</td></tr><tr><td><strong>실행 시점</strong></td><td>현재 매크로태스크 완료 직후</td><td>다음 이벤트 루프 사이클</td></tr><tr><td><strong>주요 예시</strong></td><td>Promise.then/catch/finally<br>process.nextTick<br>queueMicrotask<br>MutationObserver</td><td>setTimeout/setInterval<br>setImmediate<br>requestAnimationFrame<br>I/O 작업<br>UI 렌더링</td></tr><tr><td><strong>실행 특성</strong></td><td>큐의 모든 태스크가 완료될 때까지 연속 실행</td><td>한 번에 하나씩 실행</td></tr><tr><td><strong>메모리 사용</strong></td><td>일반적으로 더 적은 메모리 사용</td><td>상대적으로 더 많은 메모리 사용</td></tr><tr><td><strong>사용 목적</strong></td><td>즉각적인 상태 업데이트<br>데이터 일관성 유지</td><td>무거운 계산<br>I/O 작업<br>타이밍 기반 작업</td></tr><tr><td><strong>에러 처리</strong></td><td>동기적으로 처리 가능</td><td>try-catch로 직접 처리 불가</td></tr><tr><td><strong>실행 컨텍스트</strong></td><td>현재 실행 컨텍스트 유지</td><td>새로운 실행 컨텍스트 생성</td></tr><tr><td><strong>디버깅</strong></td><td>상대적으로 쉬움</td><td>비동기 특성으로 인해 더 복잡</td></tr><tr><td><strong>태스크 취소</strong></td><td>일반적으로 불가능</td><td>clearTimeout 등으로 가능</td></tr></tbody></table><p>이제 각각의 특징을 자세히 살펴보겠습니다:</p><table><thead><tr><th>특성</th><th>마이크로태스크</th><th>매크로태스크</th></tr></thead><tbody><tr><td>실행 시점</td><td>현재 작업 완료 직후, 렌더링 전</td><td>마이크로태스크 큐가 비어있을 때</td></tr><tr><td>처리 방식</td><td>큐가 비워질 때까지 연속 실행</td><td>한 번에 하나씩 실행</td></tr><tr><td>큐 처리</td><td>모든 마이크로태스크 처리 후 매크로태스크로 이동</td><td>각 매크로태스크 사이에 마이크로태스크 확인</td></tr></tbody></table><h4 id=마이크로태스크-microtasks>마이크로태스크 (Microtasks)<a hidden class=anchor aria-hidden=true href=#마이크로태스크-microtasks>#</a></h4><p>마이크로태스크는 현재 실행 중인 스크립트나 태스크가 완료된 직후에 실행되는 작은 태스크.<br>이들은 높은 우선순위를 가지며, 다른 매크로태스크나 렌더링 작업보다 먼저 처리된다.</p><p>주요 특징:</p><ul><li>높은 우선순위</li><li>현재 작업 완료 직후 실행</li><li>모든 마이크로태스크가 처리될 때까지 계속 실행</li></ul><p>예시:</p><ul><li>Promise 콜백 (.then,.catch,.finally)</li><li>process.nextTick (Node.js)</li><li>queueMicrotask()</li><li>MutationObserver 콜백</li></ul><h4 id=매크로태스크-macrotasks>매크로태스크 (Macrotasks)<a hidden class=anchor aria-hidden=true href=#매크로태스크-macrotasks>#</a></h4><p>매크로태스크는 일반적인 비동기 작업을 나타내며, 마이크로태스크보다 낮은 우선순위를 가진다.<br>이들은 마이크로태스크 큐가 비어있을 때만 실행된다.</p><p>주요 특징:</p><ul><li>낮은 우선순위</li><li>마이크로태스크 큐가 비어있을 때 실행</li><li>한 번에 하나씩 처리됨</li></ul><p>예시:</p><ul><li>setTimeout, setInterval</li><li>I/O 작업</li><li>UI 렌더링</li><li>requestAnimationFrame</li></ul><h3 id=event-loop의-중요성>Event Loop의 중요성<a hidden class=anchor aria-hidden=true href=#event-loop의-중요성>#</a></h3><ol><li><p>비차단 실행 (Non-blocking Execution)</p><ul><li>긴 작업이 있어도 UI가 멈추지 않음</li><li>사용자 경험 향상</li></ul></li><li><p>효율적인 리소스 사용</p><ul><li>단일 스레드로도 동시성 처리 가능</li><li>메모리 사용 효율화</li></ul></li><li><p>확장성</p><ul><li>많은 동시 연결 처리 가능</li><li>서버 사이드 JavaScript의 핵심 장점</li></ul></li></ol><h3 id=주의할-점>주의할 점<a hidden class=anchor aria-hidden=true href=#주의할-점>#</a></h3><ol><li><p>콜 스택 블로킹 피하기</p><ul><li>무거운 계산은 Web Worker로 분리</li><li>긴 동기 작업 피하기</li></ul></li><li><p>콜백 큐 관리</p><ul><li>너무 많은 비동기 작업 동시 실행 피하기</li><li>적절한 에러 처리 구현</li></ul></li><li><p>실행 순서 이해</p><ul><li>마이크로태스크와 매크로태스크의 우선순위 파악</li><li>비동기 작업의 실행 순서 예측</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/javascript/>Javascript</a></li><li><a href=https://buenhyden.github.io/tags/event-loop/>Event-Loop</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/qa/qc/technical-verification/security-vulnerability-scanning/><span class=title>« Prev</span><br><span>Security Vulnerability Scanning</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/interpreter-pattern/><span class=title>Next »</span><br><span>Interpreter Pattern</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>