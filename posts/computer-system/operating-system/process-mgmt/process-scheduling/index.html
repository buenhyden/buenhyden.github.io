<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process Scheduling | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,Process-Mgmt,Process-Management,Process,프로세스-스케쥴링"><meta name=description content="프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Process Scheduling"><meta property="og:description" content="프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-29T06:21:00+00:00"><meta property="article:modified_time" content="2024-09-29T06:21:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Operating-System"><meta property="article:tag" content="Process-Mgmt"><meta property="article:tag" content="Process-Management"><meta property="article:tag" content="Process"><meta property="article:tag" content="프로세스-스케쥴링"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Process Scheduling"><meta name=twitter:description content="프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-system/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-system/operating-system/"},{"@type":"ListItem","position":4,"name":"Process Management","item":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/"},{"@type":"ListItem","position":5,"name":"Process Scheduling","item":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Process Scheduling","name":"Process Scheduling","description":"프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘","keywords":["Computer-System","Operating-System","Process-Mgmt","Process-Management","Process","프로세스-스케쥴링"],"articleBody":"프로세스 스케쥴링 (Process Scheduling) 프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘.\n프로세스 스케줄링도 다양한 요소를 고려하여 최적의 실행 순서를 결정한다.\n주요 특징 CPU 활용도 극대화: I/O 대기 시간 동안 다른 프로세스에 CPU를 할당하여 유휴 시간을 최소화합니다. 처리량 증가: 단위 시간당 완료되는 프로세스의 수를 늘립니다. 응답 시간 최소화: 사용자 요청에 대한 시스템의 반응 속도를 향상시킵니다. 대기 시간 감소: 프로세스가 준비 큐에서 기다리는 시간을 줄입니다. 공정성 유지: 모든 프로세스에 적절한 CPU 시간을 할당합니다. 스케줄링의 목적 CPU 활용도 최대화\nCPU가 쉬는 시간을 최소화 가능한 한 많은 작업 처리 처리량(Throughput) 향상\n단위 시간당 완료되는 프로세스 수 증가 시스템 전체의 효율성 향상 응답 시간 최소화\n사용자 요청에 대한 빠른 반응 대화형 시스템에서 특히 중요 대기 시간 최소화\n프로세스가 준비 큐에서 기다리는 시간 감소 전체적인 시스템 성능 향상 스케줄링 방식 선점형: 실행 중인 프로세스를 중단하고 다른 프로세스에 CPU를 할당할 수 있다. 비선점형: 실행 중인 프로세스가 자발적으로 CPU를 반환할 때까지 기다린다. PCB(Process Control Block) 는프로세스 스케줄링에 다음과 같은 방식으로 기여한다:\n프로세스 상태 관리: PCB는 프로세스의 현재 상태(실행 중, 준비, 대기 등)를 저장한다. 스케줄러는 이 정보를 사용하여 실행 가능한 프로세스를 식별하고 선택한다. 스케줄링 정보 제공: PCB에는 프로세스의 우선순위, CPU 사용 시간 등 스케줄링에 필요한 정보가 포함되어 있다. 스케줄러는 이 정보를 바탕으로 다음에 실행할 프로세스를 결정한다. 컨텍스트 스위칭 지원: PCB는 프로세스의 레지스터 값, 프로그램 카운터 등을 저장하여 컨텍스트 스위칭을 가능하게 한다. 이를 통해 스케줄러는 프로세스 간 전환을 효율적으로 수행할 수 있다. 리소스 할당 정보 저장: PCB는 프로세스에 할당된 메모리, 열린 파일 등의 리소스 정보를 포함한다. 스케줄러는 이 정보를 사용하여 리소스 경쟁을 관리하고 데드락을 방지한다. 성능 모니터링: PCB에 저장된 CPU 사용 시간, 대기 시간 등의 정보는 스케줄러가 시스템 성능을 모니터링하고 최적화하는 데 사용된다. 이러한 기여를 통해 PCB는 운영 체제가 효율적인 프로세스 스케줄링을 수행하고, 시스템 자원을 최적화하며, 전반적인 시스템 성능을 향상시키는 데 중요한 역할을 한다.\n주요 스케줄링 알고리즘 선입선출(FCFS, First-Come, First-Served) 이는 가장 단순한 스케줄링 방식으로, 먼저 도착한 프로세스를 먼저 처리한다.\n예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # FCFS 스케줄링 시뮬레이션 processes = [ {\"id\": 1, \"arrival_time\": 0, \"burst_time\": 6}, {\"id\": 2, \"arrival_time\": 2, \"burst_time\": 4}, {\"id\": 3, \"arrival_time\": 4, \"burst_time\": 2} ] def fcfs_scheduling(processes): current_time = 0 for process in sorted(processes, key=lambda x: x[\"arrival_time\"]): if current_time \u003c process[\"arrival_time\"]: current_time = process[\"arrival_time\"] waiting_time = current_time - process[\"arrival_time\"] print(f\"Process {process['id']}: Waiting Time = {waiting_time}\") current_time += process[\"burst_time\"] 최단 작업 우선(SJF, Shortest Job First) 실행 시간이 가장 짧은 프로세스를 우선적으로 처리하는 방식.\n특징 평균 대기 시간 최소화 실행 시간 예측 필요 기아 현상 발생 가능 라운드 로빈(Round Robin) 각 프로세스에 동일한 시간 할당량을 부여하고 순환하며 실행하는 방식.\n구현 예시 1 2 3 4 5 6 7 8 9 10 11 def round_robin_scheduling(processes, time_quantum): ready_queue = processes.copy() current_time = 0 while ready_queue: process = ready_queue.pop(0) if process[\"burst_time\"] \u003e time_quantum: process[\"burst_time\"] -= time_quantum current_time += time_quantum ready_queue.append(process) else: current_time += process[\"burst_time\"] 우선순위 스케줄링(Priority Scheduling) 각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스를 먼저 실행한다.\n고려사항 우선순위 결정 기준 우선순위 역전 현상 에이징(Aging) 기법 적용 다단계 큐(Multilevel Queue) 프로세스들을 여러 종류의 큐로 분류하여 관리하는 방식.\n구성 전위큐(Foreground Queue) 후위큐(Background Queue) 각 큐별 다른 스케줄링 알고리즘 적용 실제 운영체제의 스케줄링 Linux의 CFS(Completely Fair Scheduler)\n프로세스 간 CPU 시간을 공정하게 분배 레드-블랙 트리 사용 동적 우선순위 조정 Windows의 다단계 피드백 큐\n프로세스의 행동에 따라 우선순위 동적 조정 I/O 중심과 CPU 중심 프로세스 구분 응답성과 처리량 균형 조정 스케줄링 성능 평가 지표 CPU 활용률\nCPU가 실제 작업을 처리하는 비율 높을수록 효율적 처리량\n단위 시간당 완료되는 프로세스 수 시스템 성능 지표 턴어라운드 타임\n프로세스 시작부터 종료까지 걸리는 시간 전체적인 작업 처리 시간 대기 시간\n프로세스가 실행을 기다리는 시간 짧을수록 좋음 응답 시간\n요청부터 첫 응답까지의 시간 대화형 시스템에서 중요 스케줄링 고려사항과 최적화 시스템 특성\n배치 시스템 대화형 시스템 실시간 시스템 프로세스 특성\nCPU 중심 vs I/O 중심 메모리 사용량 우선순위 시스템 부하\n현재 실행 중인 프로세스 수 가용 자원 상태 시스템 병목 현상 새로운 트렌드와 발전 방향 멀티코어 스케줄링\n코어 간 로드 밸런싱 캐시 친화적 스케줄링 에너지 효율성 고려 가상화 환경\n가상 머신 간 자원 할당 호스트-게스트 OS 조정 실시간 마이그레이션 클라우드 환경\n탄력적 자원 할당 서비스 수준 협약(SLA) 준수 비용 최적화 참고 및 출처 ","wordCount":"669","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-29T06:21:00Z","dateModified":"2024-09-29T06:21:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process-scheduling/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/>Operating System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/>Process Management</a></div><h1 class="post-title entry-hint-parent">Process Scheduling</h1><div class=post-description>프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘</div><div class=post-meta><span title='2024-09-29 06:21:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;669 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#프로세스-스케쥴링-process-scheduling>프로세스 스케쥴링 (Process Scheduling)</a><ul><li><a href=#주요-특징>주요 특징</a></li><li><a href=#스케줄링의-목적>스케줄링의 목적</a></li><li><a href=#스케줄링-방식>스케줄링 방식</a></li><li><a href=#주요-스케줄링-알고리즘>주요 스케줄링 알고리즘</a></li><li><a href=#실제-운영체제의-스케줄링>실제 운영체제의 스케줄링</a></li><li><a href=#스케줄링-성능-평가-지표>스케줄링 성능 평가 지표</a></li><li><a href=#스케줄링-고려사항과-최적화>스케줄링 고려사항과 최적화</a></li><li><a href=#새로운-트렌드와-발전-방향>새로운 트렌드와 발전 방향</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=프로세스-스케쥴링-process-scheduling>프로세스 스케쥴링 (Process Scheduling)<a hidden class=anchor aria-hidden=true href=#프로세스-스케쥴링-process-scheduling>#</a></h2><p>프로세스 스케줄링은 컴퓨터의 CPU 자원을 여러 프로세스에 효율적으로 할당하는 방법을 결정하는 메커니즘.<br>프로세스 스케줄링도 다양한 요소를 고려하여 최적의 실행 순서를 결정한다.</p><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ol><li>CPU 활용도 극대화: I/O 대기 시간 동안 다른 프로세스에 CPU를 할당하여 유휴 시간을 최소화합니다.</li><li>처리량 증가: 단위 시간당 완료되는 프로세스의 수를 늘립니다.</li><li>응답 시간 최소화: 사용자 요청에 대한 시스템의 반응 속도를 향상시킵니다.</li><li>대기 시간 감소: 프로세스가 준비 큐에서 기다리는 시간을 줄입니다.</li><li>공정성 유지: 모든 프로세스에 적절한 CPU 시간을 할당합니다.</li></ol><h3 id=스케줄링의-목적>스케줄링의 목적<a hidden class=anchor aria-hidden=true href=#스케줄링의-목적>#</a></h3><ol><li><p>CPU 활용도 최대화</p><ul><li>CPU가 쉬는 시간을 최소화</li><li>가능한 한 많은 작업 처리</li></ul></li><li><p>처리량(Throughput) 향상</p><ul><li>단위 시간당 완료되는 프로세스 수 증가</li><li>시스템 전체의 효율성 향상</li></ul></li><li><p>응답 시간 최소화</p><ul><li>사용자 요청에 대한 빠른 반응</li><li>대화형 시스템에서 특히 중요</li></ul></li><li><p>대기 시간 최소화</p><ul><li>프로세스가 준비 큐에서 기다리는 시간 감소</li><li>전체적인 시스템 성능 향상</li></ul></li></ol><h3 id=스케줄링-방식>스케줄링 방식<a hidden class=anchor aria-hidden=true href=#스케줄링-방식>#</a></h3><ul><li>선점형: 실행 중인 프로세스를 중단하고 다른 프로세스에 CPU를 할당할 수 있다.</li><li>비선점형: 실행 중인 프로세스가 자발적으로 CPU를 반환할 때까지 기다린다.</li></ul><p>PCB(Process Control Block) 는프로세스 스케줄링에 다음과 같은 방식으로 기여한다:</p><ol><li>프로세스 상태 관리: PCB는 프로세스의 현재 상태(실행 중, 준비, 대기 등)를 저장한다. 스케줄러는 이 정보를 사용하여 실행 가능한 프로세스를 식별하고 선택한다.</li><li>스케줄링 정보 제공: PCB에는 프로세스의 우선순위, CPU 사용 시간 등 스케줄링에 필요한 정보가 포함되어 있다. 스케줄러는 이 정보를 바탕으로 다음에 실행할 프로세스를 결정한다.</li><li>컨텍스트 스위칭 지원: PCB는 프로세스의 레지스터 값, 프로그램 카운터 등을 저장하여 컨텍스트 스위칭을 가능하게 한다. 이를 통해 스케줄러는 프로세스 간 전환을 효율적으로 수행할 수 있다.</li><li>리소스 할당 정보 저장: PCB는 프로세스에 할당된 메모리, 열린 파일 등의 리소스 정보를 포함한다. 스케줄러는 이 정보를 사용하여 리소스 경쟁을 관리하고 데드락을 방지한다.</li><li>성능 모니터링: PCB에 저장된 CPU 사용 시간, 대기 시간 등의 정보는 스케줄러가 시스템 성능을 모니터링하고 최적화하는 데 사용된다.</li></ol><p>이러한 기여를 통해 PCB는 운영 체제가 효율적인 프로세스 스케줄링을 수행하고, 시스템 자원을 최적화하며, 전반적인 시스템 성능을 향상시키는 데 중요한 역할을 한다.</p><h3 id=주요-스케줄링-알고리즘>주요 스케줄링 알고리즘<a hidden class=anchor aria-hidden=true href=#주요-스케줄링-알고리즘>#</a></h3><h4 id=선입선출fcfs-first-come-first-served>선입선출(FCFS, First-Come, First-Served)<a hidden class=anchor aria-hidden=true href=#선입선출fcfs-first-come-first-served>#</a></h4><p>이는 가장 단순한 스케줄링 방식으로, 먼저 도착한 프로세스를 먼저 처리한다.</p><h5 id=예시>예시<a hidden class=anchor aria-hidden=true href=#예시>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># FCFS 스케줄링 시뮬레이션</span>
</span></span><span class=line><span class=cl><span class=n>processes</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s2>&#34;id&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;arrival_time&#34;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span> <span class=s2>&#34;burst_time&#34;</span><span class=p>:</span> <span class=mi>6</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s2>&#34;id&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&#34;arrival_time&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&#34;burst_time&#34;</span><span class=p>:</span> <span class=mi>4</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=s2>&#34;id&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s2>&#34;arrival_time&#34;</span><span class=p>:</span> <span class=mi>4</span><span class=p>,</span> <span class=s2>&#34;burst_time&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fcfs_scheduling</span><span class=p>(</span><span class=n>processes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>current_time</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>process</span> <span class=ow>in</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>processes</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=s2>&#34;arrival_time&#34;</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_time</span> <span class=o>&lt;</span> <span class=n>process</span><span class=p>[</span><span class=s2>&#34;arrival_time&#34;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>current_time</span> <span class=o>=</span> <span class=n>process</span><span class=p>[</span><span class=s2>&#34;arrival_time&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>waiting_time</span> <span class=o>=</span> <span class=n>current_time</span> <span class=o>-</span> <span class=n>process</span><span class=p>[</span><span class=s2>&#34;arrival_time&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Process </span><span class=si>{</span><span class=n>process</span><span class=p>[</span><span class=s1>&#39;id&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>: Waiting Time = </span><span class=si>{</span><span class=n>waiting_time</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>current_time</span> <span class=o>+=</span> <span class=n>process</span><span class=p>[</span><span class=s2>&#34;burst_time&#34;</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=최단-작업-우선sjf-shortest-job-first>최단 작업 우선(SJF, Shortest Job First)<a hidden class=anchor aria-hidden=true href=#최단-작업-우선sjf-shortest-job-first>#</a></h4><p>실행 시간이 가장 짧은 프로세스를 우선적으로 처리하는 방식.</p><h5 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h5><ul><li>평균 대기 시간 최소화</li><li>실행 시간 예측 필요</li><li>기아 현상 발생 가능</li></ul><h4 id=라운드-로빈round-robin>라운드 로빈(Round Robin)<a hidden class=anchor aria-hidden=true href=#라운드-로빈round-robin>#</a></h4><p>각 프로세스에 동일한 시간 할당량을 부여하고 순환하며 실행하는 방식.</p><h5 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>round_robin_scheduling</span><span class=p>(</span><span class=n>processes</span><span class=p>,</span> <span class=n>time_quantum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ready_queue</span> <span class=o>=</span> <span class=n>processes</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>current_time</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>ready_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>process</span> <span class=o>=</span> <span class=n>ready_queue</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>process</span><span class=p>[</span><span class=s2>&#34;burst_time&#34;</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>time_quantum</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>process</span><span class=p>[</span><span class=s2>&#34;burst_time&#34;</span><span class=p>]</span> <span class=o>-=</span> <span class=n>time_quantum</span>
</span></span><span class=line><span class=cl>            <span class=n>current_time</span> <span class=o>+=</span> <span class=n>time_quantum</span>
</span></span><span class=line><span class=cl>            <span class=n>ready_queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>process</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>current_time</span> <span class=o>+=</span> <span class=n>process</span><span class=p>[</span><span class=s2>&#34;burst_time&#34;</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=우선순위-스케줄링priority-scheduling>우선순위 스케줄링(Priority Scheduling)<a hidden class=anchor aria-hidden=true href=#우선순위-스케줄링priority-scheduling>#</a></h4><p>각 프로세스에 우선순위를 부여하고, 높은 우선순위의 프로세스를 먼저 실행한다.</p><h5 id=고려사항>고려사항<a hidden class=anchor aria-hidden=true href=#고려사항>#</a></h5><ul><li>우선순위 결정 기준</li><li>우선순위 역전 현상</li><li>에이징(Aging) 기법 적용</li></ul><h4 id=다단계-큐multilevel-queue>다단계 큐(Multilevel Queue)<a hidden class=anchor aria-hidden=true href=#다단계-큐multilevel-queue>#</a></h4><p>프로세스들을 여러 종류의 큐로 분류하여 관리하는 방식.</p><h5 id=구성>구성<a hidden class=anchor aria-hidden=true href=#구성>#</a></h5><ul><li>전위큐(Foreground Queue)</li><li>후위큐(Background Queue)</li><li>각 큐별 다른 스케줄링 알고리즘 적용</li></ul><h3 id=실제-운영체제의-스케줄링>실제 운영체제의 스케줄링<a hidden class=anchor aria-hidden=true href=#실제-운영체제의-스케줄링>#</a></h3><ol><li><p>Linux의 CFS(Completely Fair Scheduler)</p><ul><li>프로세스 간 CPU 시간을 공정하게 분배</li><li>레드-블랙 트리 사용</li><li>동적 우선순위 조정</li></ul></li><li><p>Windows의 다단계 피드백 큐</p><ul><li>프로세스의 행동에 따라 우선순위 동적 조정</li><li>I/O 중심과 CPU 중심 프로세스 구분</li><li>응답성과 처리량 균형 조정</li></ul></li></ol><h3 id=스케줄링-성능-평가-지표>스케줄링 성능 평가 지표<a hidden class=anchor aria-hidden=true href=#스케줄링-성능-평가-지표>#</a></h3><ol><li><p>CPU 활용률</p><ul><li>CPU가 실제 작업을 처리하는 비율</li><li>높을수록 효율적</li></ul></li><li><p>처리량</p><ul><li>단위 시간당 완료되는 프로세스 수</li><li>시스템 성능 지표</li></ul></li><li><p>턴어라운드 타임</p><ul><li>프로세스 시작부터 종료까지 걸리는 시간</li><li>전체적인 작업 처리 시간</li></ul></li><li><p>대기 시간</p><ul><li>프로세스가 실행을 기다리는 시간</li><li>짧을수록 좋음</li></ul></li><li><p>응답 시간</p><ul><li>요청부터 첫 응답까지의 시간</li><li>대화형 시스템에서 중요</li></ul></li></ol><h3 id=스케줄링-고려사항과-최적화>스케줄링 고려사항과 최적화<a hidden class=anchor aria-hidden=true href=#스케줄링-고려사항과-최적화>#</a></h3><ol><li><p>시스템 특성</p><ul><li>배치 시스템</li><li>대화형 시스템</li><li>실시간 시스템</li></ul></li><li><p>프로세스 특성</p><ul><li>CPU 중심 vs I/O 중심</li><li>메모리 사용량</li><li>우선순위</li></ul></li><li><p>시스템 부하</p><ul><li>현재 실행 중인 프로세스 수</li><li>가용 자원 상태</li><li>시스템 병목 현상</li></ul></li></ol><h3 id=새로운-트렌드와-발전-방향>새로운 트렌드와 발전 방향<a hidden class=anchor aria-hidden=true href=#새로운-트렌드와-발전-방향>#</a></h3><ol><li><p>멀티코어 스케줄링</p><ul><li>코어 간 로드 밸런싱</li><li>캐시 친화적 스케줄링</li><li>에너지 효율성 고려</li></ul></li><li><p>가상화 환경</p><ul><li>가상 머신 간 자원 할당</li><li>호스트-게스트 OS 조정</li><li>실시간 마이그레이션</li></ul></li><li><p>클라우드 환경</p><ul><li>탄력적 자원 할당</li><li>서비스 수준 협약(SLA) 준수</li><li>비용 최적화</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/operating-system/>Operating-System</a></li><li><a href=https://buenhyden.github.io/tags/process-mgmt/>Process-Mgmt</a></li><li><a href=https://buenhyden.github.io/tags/process-management/>Process-Management</a></li><li><a href=https://buenhyden.github.io/tags/process/>Process</a></li><li><a href=https://buenhyden.github.io/tags/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/>프로세스-스케쥴링</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/spiral-model/><span class=title>« Prev</span><br><span>Spiral Model</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development-and-maintenance/software-development-model/formal-methods-model/><span class=title>Next »</span><br><span>Formal Methods Model</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>