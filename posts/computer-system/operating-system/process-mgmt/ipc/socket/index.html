<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>소켓(Socket) | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,Process-Mgmt,IPC,Socket"><meta name=description content="네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="소켓(Socket)"><meta property="og:description" content="네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-02T16:30:00+00:00"><meta property="article:modified_time" content="2024-10-02T16:30:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Operating-System"><meta property="article:tag" content="Process-Mgmt"><meta property="article:tag" content="IPC"><meta property="article:tag" content="Socket"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="소켓(Socket)"><meta name=twitter:description content="네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-system/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-system/operating-system/"},{"@type":"ListItem","position":4,"name":"Process Management","item":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/"},{"@type":"ListItem","position":5,"name":"프로세스 간 통신 (Inter-Process Communication, IPC)","item":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/"},{"@type":"ListItem","position":6,"name":"소켓(Socket)","item":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"소켓(Socket)","name":"소켓(Socket)","description":"네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다.","keywords":["Computer-System","Operating-System","Process-Mgmt","IPC","Socket"],"articleBody":"소켓(Socket) 소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.\n소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.\n운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.\n소켓의 구성 요소 소켓은 다음 세 가지 요소로 구성된다:\n프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP) IP 주소: 서버 또는 클라이언트의 주소 포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호 소켓의 특징 프로토콜, IP 주소, 포트 번호로 정의된다. 서버 소켓과 클라이언트 소켓으로 구분된다. 실시간 데이터 전송에 적합하다. 소켓 통신의 장점 실시간 양방향 통신이 가능하다. 서버와 클라이언트 간 지속적인 연결을 유지할 수 있다. 소켓 통신의 단점 HTTP 통신에 비해 구현이 복잡할 수 있다. 지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다. 소켓의 종류 소켓은 크게 두 가지 유형으로 나눌 수 있다:\n스트림 소켓(SOCK_STREAM) TCP를 사용하는 연결 지향형 소켓 연결 지향적이며 양방향으로 바이트 스트림을 전송한다. 오류 수정, 전송 처리, 흐름 제어를 보장한다. 데이터의 경계가 없는 바이트 스트림 서비스를 제공한다. 웹 서버, 데이터베이스 연결 등에 사용 데이터그램 소켓(SOCK_DGRAM) UDP를 사용하는 비연결형 소켓 비연결형 소켓이다. 데이터의 크기에 제한이 있으며, 전달이 보장되지 않는다. 데이터 경계를 구분하는 데이터그램 서비스를 제공한다. 실시간 스트리밍, 게임 등에 사용 소켓 통신의 기본 흐름 서버와 클라이언트 간의 연결이 성립되면 양방향으로 데이터 통신이 가능하다. TCP 연결의 경우, 연결 요청 시 3-way handshake 과정이 진행된다. 서버는 여러 클라이언트의 연결 요청을 처리하기 위해 대기열(queue)을 만들어 관리한다. 실제 데이터 송수신은 accept() 함수로 생성된 새로운 소켓을 통해 이루어진다. 이러한 기본 흐름을 통해 소켓은 네트워크 상에서 프로세스 간 통신의 종착점 역할을 하며, 전송 계층과 응용 프로그램 사이의 인터페이스로 작동한다.\n소켓 통신의 기본 흐름은 서버와 클라이언트 간의 상호작용으로 이루어진다. :\n서버 측 흐름\n소켓 생성: socket() 함수를 사용하여 소켓을 생성한다. 바인딩: bind() 함수로 소켓에 IP 주소와 포트 번호를 할당한다. 연결 대기: listen() 함수를 호출하여 클라이언트의 연결 요청을 기다린다. 연결 수락: accept() 함수로 클라이언트의 연결 요청을 수락한다. 이 때 새로운 소켓이 생성되어 클라이언트와의 통신에 사용된다. 데이터 송수신: send()/recv() 함수를 사용하여 클라이언트와 데이터를 주고받는다. 연결 종료: close() 함수로 소켓을 닫는다. 클라이언트 측 흐름\n소켓 생성: socket() 함수를 사용하여 소켓을 생성한다. 연결 요청: connect() 함수를 호출하여 서버에 연결을 요청한다. 데이터 송수신: send()/recv() 함수를 사용하여 서버와 데이터를 주고받는다. 연결 종료: close() 함수로 소켓을 닫는다. TCP 소켓의 경우:\n서버 소켓 생성 서버 소켓 바인딩 (IP주소와 포트번호 할당) 연결 대기 (Listen) 클라이언트의 연결 요청 수락 (Accept) 데이터 송수신 연결 종료 UDP 소켓의 경우:\n소켓 생성 소켓 바인딩 데이터 송수신 소켓 종료 주요 소켓 함수 소켓의 작동 방식에서 각 함수는 다음과 같은 역할을 수행한다:\n서버 측 함수\nsocket(): 소켓을 생성한다. 통신의 첫 단계로, 네트워크 통신을 위한 엔드포인트를 만든다. bind(): 생성된 소켓에 IP 주소와 포트 번호를 할당한다. 이를 통해 특정 주소와 포트에서 들어오는 연결을 수신할 수 있게 된다. listen(): 클라이언트의 연결 요청을 대기하는 상태로 소켓을 변경한다. 연결 요청을 수신할 준비가 되었음을 나타낸다. accept(): 클라이언트의 연결 요청을 수락한다. 새로운 소켓을 생성하여 클라이언트와의 통신에 사용한다. 클라이언트 측 함수\nsocket(): 서버와 마찬가지로 소켓을 생성한다. connect(): 서버에 연결을 요청한다. 서버의 IP 주소와 포트 번호를 지정하여 연결을 시도한다. 공통 함수\nsend()/recv(): 데이터를 송수신한다. 연결된 소켓을 통해 실제 데이터 통신이 이루어진다. close(): 소켓을 닫는다. 통신이 완료되면 소켓을 종료하여 리소스를 해제한다. 이러한 함수들의 호출 순서와 역할을 통해 소켓은 네트워크 상에서 두 프로그램 간의 양방향 통신을 가능하게 한다.\n서버는 연결을 수신하고 관리하는 역할을, 클라이언트는 연결을 요청하고 데이터를 교환하는 역할을 수행한다.\n소켓의 작동 방식과 함수 호출 과정 호출 과정:\n서버는 socket() → bind() → listen() 순으로 초기화 클라이언트는 socket() → connect() 로 연결 시도 서버는 accept()로 연결 수락 send()/recv() 를 통한 양방향 통신 close()로 연결 종료 참고 및 출처 ","wordCount":"561","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-02T16:30:00Z","dateModified":"2024-10-02T16:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/>Operating System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/>Process Management</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/>프로세스 간 통신 (Inter-Process Communication, IPC)</a></div><h1 class="post-title entry-hint-parent">소켓(Socket)</h1><div class=post-description>네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다.</div><div class=post-meta><span title='2024-10-02 16:30:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;561 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20System/Operating%20System/Process%20Mgmt/IPC/Socket.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#소켓socket>소켓(Socket)</a><ul><li><a href=#소켓의-구성-요소>소켓의 구성 요소</a></li><li><a href=#소켓의-특징>소켓의 특징</a></li><li><a href=#소켓-통신의-장점>소켓 통신의 장점</a></li><li><a href=#소켓-통신의-단점>소켓 통신의 단점</a></li><li><a href=#소켓의-종류>소켓의 종류</a></li><li><a href=#소켓-통신의-기본-흐름>소켓 통신의 기본 흐름</a></li><li><a href=#주요-소켓-함수>주요 소켓 함수</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=소켓socket>소켓(Socket)<a hidden class=anchor aria-hidden=true href=#소켓socket>#</a></h2><p>소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.<br>소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.<br>운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.</p><h3 id=소켓의-구성-요소>소켓의 구성 요소<a hidden class=anchor aria-hidden=true href=#소켓의-구성-요소>#</a></h3><p>소켓은 다음 세 가지 요소로 구성된다:</p><ol><li>프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP)</li><li>IP 주소: 서버 또는 클라이언트의 주소</li><li>포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호</li></ol><h3 id=소켓의-특징>소켓의 특징<a hidden class=anchor aria-hidden=true href=#소켓의-특징>#</a></h3><ul><li>프로토콜, IP 주소, 포트 번호로 정의된다.</li><li>서버 소켓과 클라이언트 소켓으로 구분된다.</li><li>실시간 데이터 전송에 적합하다.</li></ul><h3 id=소켓-통신의-장점>소켓 통신의 장점<a hidden class=anchor aria-hidden=true href=#소켓-통신의-장점>#</a></h3><ul><li>실시간 양방향 통신이 가능하다.</li><li>서버와 클라이언트 간 지속적인 연결을 유지할 수 있다.</li></ul><h3 id=소켓-통신의-단점>소켓 통신의 단점<a hidden class=anchor aria-hidden=true href=#소켓-통신의-단점>#</a></h3><ul><li>HTTP 통신에 비해 구현이 복잡할 수 있다.</li><li>지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다.</li></ul><h3 id=소켓의-종류>소켓의 종류<a hidden class=anchor aria-hidden=true href=#소켓의-종류>#</a></h3><p>소켓은 크게 두 가지 유형으로 나눌 수 있다:</p><ol><li>스트림 소켓(SOCK_STREAM)<ul><li>TCP를 사용하는 연결 지향형 소켓</li><li>연결 지향적이며 양방향으로 바이트 스트림을 전송한다.</li><li>오류 수정, 전송 처리, 흐름 제어를 보장한다.</li><li>데이터의 경계가 없는 바이트 스트림 서비스를 제공한다.</li><li>웹 서버, 데이터베이스 연결 등에 사용</li></ul></li><li>데이터그램 소켓(SOCK_DGRAM)<ul><li>UDP를 사용하는 비연결형 소켓</li><li>비연결형 소켓이다.</li><li>데이터의 크기에 제한이 있으며, 전달이 보장되지 않는다.</li><li>데이터 경계를 구분하는 데이터그램 서비스를 제공한다.</li><li>실시간 스트리밍, 게임 등에 사용</li></ul></li></ol><h3 id=소켓-통신의-기본-흐름>소켓 통신의 기본 흐름<a hidden class=anchor aria-hidden=true href=#소켓-통신의-기본-흐름>#</a></h3><ul><li>서버와 클라이언트 간의 연결이 성립되면 양방향으로 데이터 통신이 가능하다.</li><li>TCP 연결의 경우, 연결 요청 시 3-way handshake 과정이 진행된다.</li><li>서버는 여러 클라이언트의 연결 요청을 처리하기 위해 대기열(queue)을 만들어 관리한다.</li><li>실제 데이터 송수신은 accept() 함수로 생성된 새로운 소켓을 통해 이루어진다.</li></ul><p>이러한 기본 흐름을 통해 소켓은 네트워크 상에서 프로세스 간 통신의 종착점 역할을 하며, 전송 계층과 응용 프로그램 사이의 인터페이스로 작동한다.</p><p>소켓 통신의 기본 흐름은 서버와 클라이언트 간의 상호작용으로 이루어진다. :</p><ul><li><p>서버 측 흐름</p><ol><li>소켓 생성: socket() 함수를 사용하여 소켓을 생성한다.</li><li>바인딩: bind() 함수로 소켓에 IP 주소와 포트 번호를 할당한다.</li><li>연결 대기: listen() 함수를 호출하여 클라이언트의 연결 요청을 기다린다.</li><li>연결 수락: accept() 함수로 클라이언트의 연결 요청을 수락한다. 이 때 새로운 소켓이 생성되어 클라이언트와의 통신에 사용된다.</li><li>데이터 송수신: send()/recv() 함수를 사용하여 클라이언트와 데이터를 주고받는다.</li><li>연결 종료: close() 함수로 소켓을 닫는다.</li></ol></li><li><p>클라이언트 측 흐름</p><ol><li>소켓 생성: socket() 함수를 사용하여 소켓을 생성한다.</li><li>연결 요청: connect() 함수를 호출하여 서버에 연결을 요청한다.</li><li>데이터 송수신: send()/recv() 함수를 사용하여 서버와 데이터를 주고받는다.</li><li>연결 종료: close() 함수로 소켓을 닫는다.</li></ol></li></ul><p>TCP 소켓의 경우:</p><ol><li>서버 소켓 생성</li><li>서버 소켓 바인딩 (IP주소와 포트번호 할당)</li><li>연결 대기 (Listen)</li><li>클라이언트의 연결 요청 수락 (Accept)</li><li>데이터 송수신</li><li>연결 종료</li></ol><p>UDP 소켓의 경우:</p><ol><li>소켓 생성</li><li>소켓 바인딩</li><li>데이터 송수신</li><li>소켓 종료</li></ol><h3 id=주요-소켓-함수>주요 소켓 함수<a hidden class=anchor aria-hidden=true href=#주요-소켓-함수>#</a></h3><p>소켓의 작동 방식에서 각 함수는 다음과 같은 역할을 수행한다:</p><ul><li><p>서버 측 함수</p><ol><li>socket(): 소켓을 생성한다. 통신의 첫 단계로, 네트워크 통신을 위한 엔드포인트를 만든다.</li><li>bind(): 생성된 소켓에 IP 주소와 포트 번호를 할당한다. 이를 통해 특정 주소와 포트에서 들어오는 연결을 수신할 수 있게 된다.</li><li>listen(): 클라이언트의 연결 요청을 대기하는 상태로 소켓을 변경한다. 연결 요청을 수신할 준비가 되었음을 나타낸다.</li><li>accept(): 클라이언트의 연결 요청을 수락한다. 새로운 소켓을 생성하여 클라이언트와의 통신에 사용한다.</li></ol></li><li><p>클라이언트 측 함수</p><ol><li>socket(): 서버와 마찬가지로 소켓을 생성한다.</li><li>connect(): 서버에 연결을 요청한다. 서버의 IP 주소와 포트 번호를 지정하여 연결을 시도한다.</li></ol></li><li><p>공통 함수</p><ol><li>send()/recv(): 데이터를 송수신한다. 연결된 소켓을 통해 실제 데이터 통신이 이루어진다.</li><li>close(): 소켓을 닫는다. 통신이 완료되면 소켓을 종료하여 리소스를 해제한다.</li></ol></li></ul><p>이러한 함수들의 호출 순서와 역할을 통해 소켓은 네트워크 상에서 두 프로그램 간의 양방향 통신을 가능하게 한다.<br>서버는 연결을 수신하고 관리하는 역할을, 클라이언트는 연결을 요청하고 데이터를 교환하는 역할을 수행한다.</p><h4 id=소켓의-작동-방식과-함수-호출-과정>소켓의 작동 방식과 함수 호출 과정<a hidden class=anchor aria-hidden=true href=#소켓의-작동-방식과-함수-호출-과정>#</a></h4><p>호출 과정:</p><ol><li>서버는 socket() → bind() → listen() 순으로 초기화</li><li>클라이언트는 socket() → connect() 로 연결 시도</li><li>서버는 accept()로 연결 수락</li><li>send()/recv() 를 통한 양방향 통신</li><li>close()로 연결 종료</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/operating-system/>Operating-System</a></li><li><a href=https://buenhyden.github.io/tags/process-mgmt/>Process-Mgmt</a></li><li><a href=https://buenhyden.github.io/tags/ipc/>IPC</a></li><li><a href=https://buenhyden.github.io/tags/socket/>Socket</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process/><span class=title>« Prev</span><br><span>Process</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/><span class=title>Next »</span><br><span>Message Queue</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>