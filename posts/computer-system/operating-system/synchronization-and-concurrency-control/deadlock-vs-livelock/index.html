<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Deadlock vs Livelock | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,Synchronization-and-Concurrency-Control,Critical-Section,Synchronization,Concurrency-Control,Deadlock,Livelock"><meta name=description content="데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/deadlock-vs-livelock/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/deadlock-vs-livelock/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/deadlock-vs-livelock/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Deadlock vs Livelock"><meta property="og:description" content="데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-25T07:03:00+00:00"><meta property="article:modified_time" content="2024-12-25T07:03:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Operating-System"><meta property="article:tag" content="Synchronization-and-Concurrency-Control"><meta property="article:tag" content="Critical-Section"><meta property="article:tag" content="Synchronization"><meta property="article:tag" content="Concurrency-Control"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Deadlock vs Livelock"><meta name=twitter:description content="데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Deadlock vs Livelock","item":"https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/deadlock-vs-livelock/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deadlock vs Livelock","name":"Deadlock vs Livelock","description":"데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다","keywords":["Computer-System","Operating-System","Synchronization-and-Concurrency-Control","Critical-Section","Synchronization","Concurrency-Control","Deadlock","Livelock"],"articleBody":"Deadlock Vs Livelock 데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다.\n데드락(Deadlock)은 두 개 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 무한정 대기하는 상태를 말하며, 상호 배제(Mutual Exclusion), 점유 대기(Hold and Wait), 비선점(No Preemption), 순환 대기(Circular Wait) 등의 조건이 충족되어야 한다. 예를 들어, 프로세스 A가 자원 X를 점유하고, 프로세스 B가 자원 Y를 점유한 상태에서, A는 Y를, B는 X를 요청하면 데드락이 발생한다\n라이브락(Livelock)은 프로세스들이 계속해서 상태를 변경하지만 실제로는 어떤 진전도 없는 상황을 말한다.\n지속적인 상태 변경이 일어나지만, 진전이 없다. 예를 들어, 두 사람이 좁은 복도에서 마주쳤을 때, 서로 양보하려고 같은 방향으로 계속 이동하는 상황을 생각해볼 수 있다.\n비교 분석 표 특성 데드락 (Deadlock) 라이브락 (Livelock) 정의 프로세스들이 서로의 자원을 기다리며 무한정 대기하는 상태 프로세스들이 계속 상태를 변경하지만 진전이 없는 상태 프로세스 상태 완전히 멈춰있음 계속해서 상태 변경 자원 점유 자원을 점유한 채로 다른 자원을 기다림 자원을 점유하지 않고 계속 요청하고 해제 CPU 사용 CPU 사용 없음 CPU 계속 사용 해결 가능성 외부 개입 없이 해결 불가능 시간이 지나면 자연스럽게 해결될 가능성 있음 발생 원인 자원 할당의 순환 의존성 데드락을 피하려는 과정에서 발생 가능 프로세스 진행 완전히 멈춤 진행은 하지만 실질적 진전 없음 해결 방법 예방, 회피, 탐지 및 복구 무작위성 도입, 우선순위 부여, 타임아웃 설정 실제 예시 두 프로세스가 서로의 자원을 점유하고 대기 두 사람이 복도에서 서로 양보하며 계속 이동 해결 방법 데드락 해결 방법 예방: 데드락의 네 가지 조건 중 하나를 제거한다. 회피: 자원 할당 상태를 지속적으로 검사하여 안전한 상태를 유지한다. 탐지 및 복구: 데드락을 탐지하고, 발생 시 프로세스를 강제 종료하거나 자원을 선점한다. 데드락(Deadlock)의 네 가지 조건\n상호 배제(Mutual Exclusion): 자원은 한 번에 하나의 프로세스만 사용할 수 있다. 점유 대기(Hold and Wait): 프로세스가 이미 자원을 보유한 상태에서 다른 자원을 요청한다. 비선점(No Preemption): 다른 프로세스가 사용 중인 자원을 강제로 빼앗을 수 없다. 순환 대기(Circular Wait): 프로세스들이 순환적으로 서로의 자원을 기다린다. 라이브락 해결 방법 무작위성 도입: 프로세스들이 동작을 결정할 때 약간의 무작위성을 도입한다. 우선순위 부여: 프로세스들에게 서로 다른 우선순위를 부여한다. 타임아웃 설정: 일정 시간 동안 진전이 없으면 작업을 재시도하거나 포기한다. 참고 및 출처 ","wordCount":"332","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-25T07:03:00Z","dateModified":"2024-12-25T07:03:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/deadlock-vs-livelock/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Deadlock vs Livelock</h1><div class=post-description>데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다</div><div class=post-meta><span title='2024-12-25 07:03:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;332 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20System/Operating%20System/Synchronization%20and%20Concurrency%20Control/Deadlock-vs-Livelock.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#deadlock-vs-livelock>Deadlock Vs Livelock</a></li><li><a href=#비교-분석-표>비교 분석 표</a><ul><li><a href=#해결-방법>해결 방법</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=deadlock-vs-livelock>Deadlock Vs Livelock<a hidden class=anchor aria-hidden=true href=#deadlock-vs-livelock>#</a></h2><p>데드락(Deadlock)과 라이브락(Livelock)은 둘 다 동시성 프로그래밍에서 발생할 수 있는 문제 상황으로, 데드락과 라이브락은 모두 시스템의 진행을 방해하는 심각한 문제이다.</p><p>데드락(Deadlock)은 두 개 이상의 프로세스나 스레드가 서로가 보유한 자원을 기다리며 무한정 대기하는 상태를 말하며, 상호 배제(Mutual Exclusion), 점유 대기(Hold and Wait), 비선점(No Preemption), 순환 대기(Circular Wait) 등의 조건이 충족되어야 한다. 예를 들어, 프로세스 A가 자원 X를 점유하고, 프로세스 B가 자원 Y를 점유한 상태에서, A는 Y를, B는 X를 요청하면 데드락이 발생한다</p><p>라이브락(Livelock)은 프로세스들이 계속해서 상태를 변경하지만 실제로는 어떤 진전도 없는 상황을 말한다.<br>지속적인 상태 변경이 일어나지만, 진전이 없다. 예를 들어, 두 사람이 좁은 복도에서 마주쳤을 때, 서로 양보하려고 같은 방향으로 계속 이동하는 상황을 생각해볼 수 있다.</p><h2 id=비교-분석-표>비교 분석 표<a hidden class=anchor aria-hidden=true href=#비교-분석-표>#</a></h2><table><thead><tr><th>특성</th><th>데드락 (Deadlock)</th><th>라이브락 (Livelock)</th></tr></thead><tbody><tr><td>정의</td><td>프로세스들이 서로의 자원을 기다리며 무한정 대기하는 상태</td><td>프로세스들이 계속 상태를 변경하지만 진전이 없는 상태</td></tr><tr><td>프로세스 상태</td><td>완전히 멈춰있음</td><td>계속해서 상태 변경</td></tr><tr><td>자원 점유</td><td>자원을 점유한 채로 다른 자원을 기다림</td><td>자원을 점유하지 않고 계속 요청하고 해제</td></tr><tr><td>CPU 사용</td><td>CPU 사용 없음</td><td>CPU 계속 사용</td></tr><tr><td>해결 가능성</td><td>외부 개입 없이 해결 불가능</td><td>시간이 지나면 자연스럽게 해결될 가능성 있음</td></tr><tr><td>발생 원인</td><td>자원 할당의 순환 의존성</td><td>데드락을 피하려는 과정에서 발생 가능</td></tr><tr><td>프로세스 진행</td><td>완전히 멈춤</td><td>진행은 하지만 실질적 진전 없음</td></tr><tr><td>해결 방법</td><td>예방, 회피, 탐지 및 복구</td><td>무작위성 도입, 우선순위 부여, 타임아웃 설정</td></tr><tr><td>실제 예시</td><td>두 프로세스가 서로의 자원을 점유하고 대기</td><td>두 사람이 복도에서 서로 양보하며 계속 이동</td></tr></tbody></table><h3 id=해결-방법>해결 방법<a hidden class=anchor aria-hidden=true href=#해결-방법>#</a></h3><h4 id=데드락-해결-방법>데드락 해결 방법<a hidden class=anchor aria-hidden=true href=#데드락-해결-방법>#</a></h4><ol><li><strong>예방</strong>: 데드락의 네 가지 조건 중 하나를 제거한다.</li><li><strong>회피</strong>: 자원 할당 상태를 지속적으로 검사하여 안전한 상태를 유지한다.</li><li><strong>탐지 및 복구</strong>: 데드락을 탐지하고, 발생 시 프로세스를 강제 종료하거나 자원을 선점한다.</li></ol><blockquote><p>데드락(Deadlock)의 네 가지 조건</p><ol><li><strong>상호 배제(Mutual Exclusion)</strong>: 자원은 한 번에 하나의 프로세스만 사용할 수 있다.</li><li><strong>점유 대기(Hold and Wait)</strong>: 프로세스가 이미 자원을 보유한 상태에서 다른 자원을 요청한다.</li><li><strong>비선점(No Preemption)</strong>: 다른 프로세스가 사용 중인 자원을 강제로 빼앗을 수 없다.</li><li><strong>순환 대기(Circular Wait)</strong>: 프로세스들이 순환적으로 서로의 자원을 기다린다.</li></ol></blockquote><h4 id=라이브락-해결-방법>라이브락 해결 방법<a hidden class=anchor aria-hidden=true href=#라이브락-해결-방법>#</a></h4><ol><li><strong>무작위성 도입</strong>: 프로세스들이 동작을 결정할 때 약간의 무작위성을 도입한다.</li><li><strong>우선순위 부여</strong>: 프로세스들에게 서로 다른 우선순위를 부여한다.</li><li><strong>타임아웃 설정</strong>: 일정 시간 동안 진전이 없으면 작업을 재시도하거나 포기한다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/operating-system/>Operating-System</a></li><li><a href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/>Synchronization-and-Concurrency-Control</a></li><li><a href=https://buenhyden.github.io/tags/critical-section/>Critical-Section</a></li><li><a href=https://buenhyden.github.io/tags/synchronization/>Synchronization</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-control/>Concurrency-Control</a></li><li><a href=https://buenhyden.github.io/tags/deadlock/>Deadlock</a></li><li><a href=https://buenhyden.github.io/tags/livelock/>Livelock</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/monitoring-and-observability/><span class=title>« Prev</span><br><span>Monitoring and Observability</span>
</a><a class=next href=https://buenhyden.github.io/posts/security/zero-trust/><span class=title>Next »</span><br><span>제로 트러스트 (Zero Trust)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>