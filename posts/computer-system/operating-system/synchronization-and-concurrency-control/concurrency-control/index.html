<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>동시성 제어 (Concurrency Control) | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,Synchronization-and-Concurrency-Control,Concurrency-Control"><meta name=description content="동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="동시성 제어 (Concurrency Control)"><meta property="og:description" content="동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-23T02:47:00+00:00"><meta property="article:modified_time" content="2024-11-23T02:47:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Operating-System"><meta property="article:tag" content="Synchronization-and-Concurrency-Control"><meta property="article:tag" content="Concurrency-Control"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="동시성 제어 (Concurrency Control)"><meta name=twitter:description content="동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-system/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-system/operating-system/"},{"@type":"ListItem","position":4,"name":"Synchronization and Concurrency Control","item":"https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/"},{"@type":"ListItem","position":5,"name":"동시성 제어 (Concurrency Control)","item":"https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"동시성 제어 (Concurrency Control)","name":"동시성 제어 (Concurrency Control)","description":"동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘","keywords":["Computer-System","Operating-System","Synchronization-and-Concurrency-Control","Concurrency-Control"],"articleBody":"동시성 제어 (Concurrency Control) 동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘.\n다중 사용자 환경에서 필수적으로 지원해야 하는 기능으로, 병행제어라고도 한다.\n동시성 제어의 중요성 동시성 제어는 다음과 같은 문제를 방지하여 데이터베이스의 무결성을 유지한다:\n갱신 손실: 동시에 수행된 갱신 작업으로 인한 데이터 손실 모순성: 일관성 없는 데이터 읽기 연쇄 복귀: 하나의 트랜잭션 실패로 인한 다른 트랜잭션들의 복귀 목적 트랜잭션의 직렬성 보장 데이터의 무결성 및 일관성 유지 시스템 활용도 최대화 (공유도 최대, 응답 시간 최소, 처리량 최대화) 주요 동시성 제어 기법 락킹(Locking) 기법 락킹은 가장 기본적인 동시성 제어 방법으로, 데이터에 접근할 때 잠금을 설정하여 다른 프로세스의 접근을 제한한다.\n종류 공유 락(Shared Lock):\n읽기 작업을 위한 락 여러 프로세스가 동시에 획득 가능 데이터 읽기만 허용됨 배타적 락(Exclusive Lock):\n쓰기 작업을 위한 락 한 번에 하나의 프로세스만 획득 가능 데이터 읽기와 쓰기 모두 가능 타임스탬프 기반 기법(Timestamp-based Protocol) 각 트랜잭션에 고유한 타임스탬프를 부여하여 실행 순서를 결정하는 방식.\n작동 원리 트랜잭션 시작 시 타임스탬프 부여 읽기/쓰기 타임스탬프 관리 충돌 발생 시 타임스탬프 비교하여 처리 장점 교착상태 발생하지 않음 우선순위 기반 처리 가능 낙관적 병행 제어(Optimistic Concurrency Control) 충돌이 적을 것이라 가정하고, 검증 단계에서 충돌을 확인하는 방식.\n처리 단계 읽기 단계: 데이터 읽기와 로컬 복사본 생성 수행 단계: 로컬 복사본에서 작업 수행 검증 단계: 충돌 여부 확인 쓰기 단계: 검증 성공 시 결과 반영 다중버전 병행 제어(Multiversion Concurrency Control, MVCC) 데이터의 여러 버전을 유지하여 읽기 작업의 병행성을 향상시키는 기법.\n특징 각 쓰기 작업마다 새로운 버전 생성 읽기 작업은 특정 시점의 버전을 참조 트랜잭션의 일관성 보장 실제 적용 예시 PostgreSQL이나 Oracle 같은 데이터베이스 시스템에서 MVCC를 사용하여 읽기 작업의 성능을 향상시킨다.\n동시성 제어의 구현 시 고려사항 성능과 확장성\n락의 세분성 조절 데드락 방지 메커니즘 캐시 일관성 유지 일관성 수준\n직렬성(Serializability) 스냅샷 격리(Snapshot Isolation) 읽기 일관성(Read Consistency) 장애 복구\n롤백 메커니즘 복구 로그 관리 체크포인트 설정 동시성 제어의 발전 방향 분산 시스템에서의 동시성 제어\n분산 락 관리 합의(Consensus) 알고리즘 최종 일관성(Eventual Consistency) 새로운 하드웨어 지원\n하드웨어 트랜잭션 메모리 원자적 명령어 활용 멀티코어 최적화 인메모리 데이터베이스\n락-프리 알고리즘 비동기 복제 실시간 동시성 제어 실제 구현 시 주의사항 데드락 예방\n타임아웃 설정 자원 순서화 데드락 감지 알고리즘 구현 성능 최적화\n락 경합(Lock Contention) 최소화 트랜잭션 분할 캐시 활용 모니터링과 디버깅\n락 획득/해제 로깅 성능 메트릭 수집 병목 지점 분석 참고 및 출처 ","wordCount":"370","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-23T02:47:00Z","dateModified":"2024-11-23T02:47:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/>Operating System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/synchronization-and-concurrency-control/>Synchronization and Concurrency Control</a></div><h1 class="post-title entry-hint-parent">동시성 제어 (Concurrency Control)</h1><div class=post-description>동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘</div><div class=post-meta><span title='2024-11-23 02:47:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;370 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20System/Operating%20System/Synchronization%20and%20Concurrency%20Control/Concurrency-Control.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#동시성-제어-concurrency-control>동시성 제어 (Concurrency Control)</a><ul><li><a href=#동시성-제어의-중요성>동시성 제어의 중요성</a></li><li><a href=#목적>목적</a></li><li><a href=#주요-동시성-제어-기법>주요 동시성 제어 기법</a></li><li><a href=#동시성-제어의-구현-시-고려사항>동시성 제어의 구현 시 고려사항</a></li><li><a href=#동시성-제어의-발전-방향>동시성 제어의 발전 방향</a></li><li><a href=#실제-구현-시-주의사항>실제 구현 시 주의사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=동시성-제어-concurrency-control>동시성 제어 (Concurrency Control)<a hidden class=anchor aria-hidden=true href=#동시성-제어-concurrency-control>#</a></h2><p>동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘.<br>다중 사용자 환경에서 필수적으로 지원해야 하는 기능으로, 병행제어라고도 한다.</p><h3 id=동시성-제어의-중요성>동시성 제어의 중요성<a hidden class=anchor aria-hidden=true href=#동시성-제어의-중요성>#</a></h3><p>동시성 제어는 다음과 같은 문제를 방지하여 데이터베이스의 무결성을 유지한다:</p><ul><li>갱신 손실: 동시에 수행된 갱신 작업으로 인한 데이터 손실</li><li>모순성: 일관성 없는 데이터 읽기</li><li>연쇄 복귀: 하나의 트랜잭션 실패로 인한 다른 트랜잭션들의 복귀</li></ul><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><ol><li>트랜잭션의 직렬성 보장</li><li>데이터의 무결성 및 일관성 유지</li><li>시스템 활용도 최대화 (공유도 최대, 응답 시간 최소, 처리량 최대화)</li></ol><h3 id=주요-동시성-제어-기법>주요 동시성 제어 기법<a hidden class=anchor aria-hidden=true href=#주요-동시성-제어-기법>#</a></h3><h4 id=락킹locking-기법>락킹(Locking) 기법<a hidden class=anchor aria-hidden=true href=#락킹locking-기법>#</a></h4><p>락킹은 가장 기본적인 동시성 제어 방법으로, 데이터에 접근할 때 잠금을 설정하여 다른 프로세스의 접근을 제한한다.</p><h5 id=종류>종류<a hidden class=anchor aria-hidden=true href=#종류>#</a></h5><p>공유 락(Shared Lock):</p><ul><li>읽기 작업을 위한 락</li><li>여러 프로세스가 동시에 획득 가능</li><li>데이터 읽기만 허용됨</li></ul><p>배타적 락(Exclusive Lock):</p><ul><li>쓰기 작업을 위한 락</li><li>한 번에 하나의 프로세스만 획득 가능</li><li>데이터 읽기와 쓰기 모두 가능</li></ul><h4 id=타임스탬프-기반-기법timestamp-based-protocol>타임스탬프 기반 기법(Timestamp-based Protocol)<a hidden class=anchor aria-hidden=true href=#타임스탬프-기반-기법timestamp-based-protocol>#</a></h4><p>각 트랜잭션에 고유한 타임스탬프를 부여하여 실행 순서를 결정하는 방식.</p><h5 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h5><ul><li>트랜잭션 시작 시 타임스탬프 부여</li><li>읽기/쓰기 타임스탬프 관리</li><li>충돌 발생 시 타임스탬프 비교하여 처리</li></ul><h5 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h5><ul><li>교착상태 발생하지 않음</li><li>우선순위 기반 처리 가능</li></ul><h4 id=낙관적-병행-제어optimistic-concurrency-control>낙관적 병행 제어(Optimistic Concurrency Control)<a hidden class=anchor aria-hidden=true href=#낙관적-병행-제어optimistic-concurrency-control>#</a></h4><p>충돌이 적을 것이라 가정하고, 검증 단계에서 충돌을 확인하는 방식.</p><h5 id=처리-단계>처리 단계<a hidden class=anchor aria-hidden=true href=#처리-단계>#</a></h5><ul><li>읽기 단계: 데이터 읽기와 로컬 복사본 생성</li><li>수행 단계: 로컬 복사본에서 작업 수행</li><li>검증 단계: 충돌 여부 확인</li><li>쓰기 단계: 검증 성공 시 결과 반영</li></ul><h4 id=다중버전-병행-제어multiversion-concurrency-control-mvcc>다중버전 병행 제어(Multiversion Concurrency Control, MVCC)<a hidden class=anchor aria-hidden=true href=#다중버전-병행-제어multiversion-concurrency-control-mvcc>#</a></h4><p>데이터의 여러 버전을 유지하여 읽기 작업의 병행성을 향상시키는 기법.</p><h5 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h5><ul><li>각 쓰기 작업마다 새로운 버전 생성</li><li>읽기 작업은 특정 시점의 버전을 참조</li><li>트랜잭션의 일관성 보장</li></ul><h5 id=실제-적용-예시>실제 적용 예시<a hidden class=anchor aria-hidden=true href=#실제-적용-예시>#</a></h5><p>PostgreSQL이나 Oracle 같은 데이터베이스 시스템에서 MVCC를 사용하여 읽기 작업의 성능을 향상시킨다.</p><h3 id=동시성-제어의-구현-시-고려사항>동시성 제어의 구현 시 고려사항<a hidden class=anchor aria-hidden=true href=#동시성-제어의-구현-시-고려사항>#</a></h3><ol><li><p>성능과 확장성</p><ul><li>락의 세분성 조절</li><li>데드락 방지 메커니즘</li><li>캐시 일관성 유지</li></ul></li><li><p>일관성 수준</p><ul><li>직렬성(Serializability)</li><li>스냅샷 격리(Snapshot Isolation)</li><li>읽기 일관성(Read Consistency)</li></ul></li><li><p>장애 복구</p><ul><li>롤백 메커니즘</li><li>복구 로그 관리</li><li>체크포인트 설정</li></ul></li></ol><h3 id=동시성-제어의-발전-방향>동시성 제어의 발전 방향<a hidden class=anchor aria-hidden=true href=#동시성-제어의-발전-방향>#</a></h3><ol><li><p>분산 시스템에서의 동시성 제어</p><ul><li>분산 락 관리</li><li>합의(Consensus) 알고리즘</li><li>최종 일관성(Eventual Consistency)</li></ul></li><li><p>새로운 하드웨어 지원</p><ul><li>하드웨어 트랜잭션 메모리</li><li>원자적 명령어 활용</li><li>멀티코어 최적화</li></ul></li><li><p>인메모리 데이터베이스</p><ul><li>락-프리 알고리즘</li><li>비동기 복제</li><li>실시간 동시성 제어</li></ul></li></ol><h3 id=실제-구현-시-주의사항>실제 구현 시 주의사항<a hidden class=anchor aria-hidden=true href=#실제-구현-시-주의사항>#</a></h3><ol><li><p>데드락 예방</p><ul><li>타임아웃 설정</li><li>자원 순서화</li><li>데드락 감지 알고리즘 구현</li></ul></li><li><p>성능 최적화</p><ul><li>락 경합(Lock Contention) 최소화</li><li>트랜잭션 분할</li><li>캐시 활용</li></ul></li><li><p>모니터링과 디버깅</p><ul><li>락 획득/해제 로깅</li><li>성능 메트릭 수집</li><li>병목 지점 분석</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/operating-system/>Operating-System</a></li><li><a href=https://buenhyden.github.io/tags/synchronization-and-concurrency-control/>Synchronization-and-Concurrency-Control</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-control/>Concurrency-Control</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-pattern-and-software-design-pattern/><span class=title>« Prev</span><br><span>Software Architecture pattern and Software Design Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/><span class=title>Next »</span><br><span>Domain-Driven Design</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>