<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>페이징 (Paging) | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,Memory-Mgmt,Memory-Mgmt-Techniques,Memory-Management,Memory-Management-Techniques,Paging"><meta name=description content="페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="페이징 (Paging)"><meta property="og:description" content="페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-20T13:37:00+00:00"><meta property="article:modified_time" content="2024-10-20T13:37:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Operating-System"><meta property="article:tag" content="Memory-Mgmt"><meta property="article:tag" content="Memory-Mgmt-Techniques"><meta property="article:tag" content="Memory-Management"><meta property="article:tag" content="Memory-Management-Techniques"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="페이징 (Paging)"><meta name=twitter:description content="페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-system/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-system/operating-system/"},{"@type":"ListItem","position":4,"name":"메모리 관리 (Memory Management)","item":"https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/"},{"@type":"ListItem","position":5,"name":"Memory Management Techniques","item":"https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/"},{"@type":"ListItem","position":6,"name":"페이징 (Paging)","item":"https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"페이징 (Paging)","name":"페이징 (Paging)","description":"페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다.","keywords":["Computer-System","Operating-System","Memory-Mgmt","Memory-Mgmt-Techniques","Memory-Management","Memory-Management-Techniques","Paging"],"articleBody":"페이징 (Paging) 먼저 페이징이 필요한 배경을 이해해보자.\n초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.\n이는 두 가지 큰 문제를 발생시켰다:\n큰 프로그램은 메모리에 적재하기 어려웠다. 메모리 단편화(fragmentation)가 심각했다.\n이러한 문제를 해결하기 위해 페이징이 도입되었다. 페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 ‘페이지(page)‘라 하고, 물리적 메모리의 단위를 ‘프레임(frame)‘이라고 한다.\nSource: https://www.geeksforgeeks.org/paging-in-operating-system/\n페이징 시스템의 주요 구성 요소 페이지 테이블(Page Table):\n각 프로세스마다 존재하며, 논리적 페이지 번호와 물리적 프레임 번호의 매핑 정보를 저장한다. 페이지 테이블 엔트리(PTE)에는 다음과 같은 정보가 포함된다: Valid bit: 페이지가 물리 메모리에 있는지 여부 Protection bit: 읽기/쓰기/실행 권한 Modified bit (Dirty bit): 페이지 내용이 변경되었는지 여부 Referenced bit: 최근에 접근했는지 여부 주소 변환 과정:\n1 2 논리적 주소 = 페이지 번호(p) + 오프셋(d) 물리적 주소 = 프레임 번호(f) × 페이지 크기 + 오프셋(d) 예를 들어, 페이지 크기가 4KB(2¹²)이고 32비트 주소 체계를 사용한다면:\n상위 20비트는 페이지 번호 하위 12비트는 오프셋\n이 된다. TLB(Translation Lookaside Buffer):\n페이지 테이블 접근 시간을 줄이기 위한 캐시로, 최근에 사용된 페이지 테이블 엔트리를 저장한다.\n주소 변환 과정은 다음과 같다:\n1 2 3 4 5 6 1. CPU가 논리적 주소 생성 2. TLB 검색 3. TLB Hit: 바로 물리적 주소 변환 TLB Miss: 페이지 테이블 접근 필요 4. 페이지 테이블에서 프레임 번호 확인 5. 물리적 주소로 변환하여 메모리 접근 다단계 페이지 테이블:\n큰 주소 공간을 효율적으로 관리하기 위해 페이지 테이블을 여러 단계로 구성한다.\n예를 들어 2단계 페이지 테이블의 경우:\n1 논리적 주소 = 외부 페이지 번호 + 내부 페이지 번호 + 오프셋 페이지 부재 처리(Page Fault Handling):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def handle_page_fault(logical_address): if not is_valid_address(logical_address): raise SegmentationFault page_number = get_page_number(logical_address) if not has_free_frame(): victim_page = select_victim_page() # 페이지 교체 알고리즘 사용 if is_dirty(victim_page): write_to_disk(victim_page) remove_page_table_entry(victim_page) free_frame = allocate_free_frame() load_page_from_disk(page_number, free_frame) update_page_table(page_number, free_frame) return restart_instruction() 페이징의 주요 특징 메모리 분할:\n논리적 메모리(프로세스)를 동일한 크기의 페이지로 나눈다. 물리적 메모리를 동일한 크기의 프레임으로 나눈다. 주소 변환:\n논리 주소를 물리 주소로 변환하기 위해 페이지 테이블을 사용한다. MMU(Memory Management Unit)가 주소 변환을 수행한다. 비연속적 할당:\n프로세스의 페이지들은 물리 메모리의 여러 프레임에 분산되어 저장될 수 있다. 내부 단편화:\n페이지 크기가 고정되어 있어 프로세스의 마지막 페이지에서 내부 단편화가 발생할 수 있다. 페이징의 작동 방식 프로세스가 메모리에 로드될 때, 운영체제는 프로세스를 페이지 단위로 나눈다. 각 페이지는 사용 가능한 메모리 프레임에 할당된다. 운영체제는 페이지 테이블을 생성하여 각 페이지와 해당 프레임 간의 매핑을 유지한다. CPU가 메모리에 접근할 때, 논리 주소는 페이지 번호와 오프셋으로 나뉜다. MMU는 페이지 테이블을 참조하여 페이지 번호를 프레임 번호로 변환한다. 프레임 번호와 오프셋을 조합하여 실제 물리 주소를 생성한다. 페이징의 장점 외부 단편화 제거: 메모리를 고정 크기로 관리하여 외부 단편화를 방지한다. 유연한 메모리 할당: 프로세스의 페이지들을 비연속적으로 할당할 수 있다. 메모리 보호: 페이지 단위로 접근 권한을 설정할 수 있어 보안성이 향상된다. 가상 메모리 지원: 실제 물리 메모리보다 큰 주소 공간을 제공할 수 있다. 페이징의 단점 내부 단편화: 페이지 크기가 고정되어 있어 마지막 페이지에서 낭비가 발생할 수 있다. 페이지 테이블 오버헤드: 큰 프로세스의 경우 페이지 테이블이 많은 메모리를 차지할 수 있다. 주소 변환 시간: 페이지 테이블 참조로 인한 추가적인 메모리 접근이 필요하다. 참고 및 출처 ","wordCount":"509","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-20T13:37:00Z","dateModified":"2024-10-20T13:37:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/>Operating System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/>메모리 관리 (Memory Management)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/>Memory Management Techniques</a></div><h1 class="post-title entry-hint-parent">페이징 (Paging)</h1><div class=post-description>페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다.</div><div class=post-meta><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20System/Operating%20System/Memory%20Mgmt/Memory%20Mgmt%20Techniques/Paging.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#페이징-paging>페이징 (Paging)</a><ul><li><a href=#페이징-시스템의-주요-구성-요소>페이징 시스템의 주요 구성 요소</a></li><li><a href=#페이징의-주요-특징>페이징의 주요 특징</a></li><li><a href=#페이징의-작동-방식>페이징의 작동 방식</a></li><li><a href=#페이징의-장점>페이징의 장점</a></li><li><a href=#페이징의-단점>페이징의 단점</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=페이징-paging>페이징 (Paging)<a hidden class=anchor aria-hidden=true href=#페이징-paging>#</a></h2><p>먼저 페이징이 필요한 배경을 이해해보자.<br>초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.<br>이는 두 가지 큰 문제를 발생시켰다:</p><ol><li>큰 프로그램은 메모리에 적재하기 어려웠다.</li><li>메모리 단편화(fragmentation)가 심각했다.<br>이러한 문제를 해결하기 위해 페이징이 도입되었다.</li></ol><p>페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 &lsquo;페이지(page)&lsquo;라 하고, 물리적 메모리의 단위를 &lsquo;프레임(frame)&lsquo;이라고 한다.</p><p><figure><img alt=Paging loading=lazy src=/img/paging.webp><figcaption>Source: https://www.geeksforgeeks.org/paging-in-operating-system/</figcaption></figure></p><h3 id=페이징-시스템의-주요-구성-요소>페이징 시스템의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#페이징-시스템의-주요-구성-요소>#</a></h3><ol><li><p>페이지 테이블(Page Table):</p><ul><li>각 프로세스마다 존재하며, 논리적 페이지 번호와 물리적 프레임 번호의 매핑 정보를 저장한다.</li><li>페이지 테이블 엔트리(PTE)에는 다음과 같은 정보가 포함된다:<ul><li>Valid bit: 페이지가 물리 메모리에 있는지 여부</li><li>Protection bit: 읽기/쓰기/실행 권한</li><li>Modified bit (Dirty bit): 페이지 내용이 변경되었는지 여부</li><li>Referenced bit: 최근에 접근했는지 여부</li></ul></li></ul></li><li><p>주소 변환 과정:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>논리적 주소 = 페이지 번호(p) + 오프셋(d)
</span></span><span class=line><span class=cl>물리적 주소 = 프레임 번호(f) × 페이지 크기 + 오프셋(d)
</span></span></code></pre></td></tr></table></div></div><p>예를 들어, 페이지 크기가 4KB(2¹²)이고 32비트 주소 체계를 사용한다면:</p><ul><li>상위 20비트는 페이지 번호</li><li>하위 12비트는 오프셋<br>이 된다.</li></ul></li><li><p>TLB(Translation Lookaside Buffer):<br>페이지 테이블 접근 시간을 줄이기 위한 캐시로, 최근에 사용된 페이지 테이블 엔트리를 저장한다.<br>주소 변환 과정은 다음과 같다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. CPU가 논리적 주소 생성
</span></span><span class=line><span class=cl>2. TLB 검색
</span></span><span class=line><span class=cl>3. TLB Hit: 바로 물리적 주소 변환
</span></span><span class=line><span class=cl>   TLB Miss: 페이지 테이블 접근 필요
</span></span><span class=line><span class=cl>4. 페이지 테이블에서 프레임 번호 확인
</span></span><span class=line><span class=cl>5. 물리적 주소로 변환하여 메모리 접근
</span></span></code></pre></td></tr></table></div></div></li><li><p>다단계 페이지 테이블:<br>큰 주소 공간을 효율적으로 관리하기 위해 페이지 테이블을 여러 단계로 구성한다.<br>예를 들어 2단계 페이지 테이블의 경우:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>논리적 주소 = 외부 페이지 번호 + 내부 페이지 번호 + 오프셋
</span></span></code></pre></td></tr></table></div></div></li><li><p>페이지 부재 처리(Page Fault Handling):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>handle_page_fault</span><span class=p>(</span><span class=n>logical_address</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>is_valid_address</span><span class=p>(</span><span class=n>logical_address</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=n>SegmentationFault</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>page_number</span> <span class=o>=</span> <span class=n>get_page_number</span><span class=p>(</span><span class=n>logical_address</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>has_free_frame</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>victim_page</span> <span class=o>=</span> <span class=n>select_victim_page</span><span class=p>()</span>  <span class=c1># 페이지 교체 알고리즘 사용</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_dirty</span><span class=p>(</span><span class=n>victim_page</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>write_to_disk</span><span class=p>(</span><span class=n>victim_page</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>remove_page_table_entry</span><span class=p>(</span><span class=n>victim_page</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>free_frame</span> <span class=o>=</span> <span class=n>allocate_free_frame</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>load_page_from_disk</span><span class=p>(</span><span class=n>page_number</span><span class=p>,</span> <span class=n>free_frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>update_page_table</span><span class=p>(</span><span class=n>page_number</span><span class=p>,</span> <span class=n>free_frame</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>restart_instruction</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=페이징의-주요-특징>페이징의 주요 특징<a hidden class=anchor aria-hidden=true href=#페이징의-주요-특징>#</a></h3><ol><li><p>메모리 분할:</p><ul><li>논리적 메모리(프로세스)를 동일한 크기의 페이지로 나눈다.</li><li>물리적 메모리를 동일한 크기의 프레임으로 나눈다.</li></ul></li><li><p>주소 변환:</p><ul><li>논리 주소를 물리 주소로 변환하기 위해 페이지 테이블을 사용한다.</li><li>MMU(Memory Management Unit)가 주소 변환을 수행한다.</li></ul></li><li><p>비연속적 할당:</p><ul><li>프로세스의 페이지들은 물리 메모리의 여러 프레임에 분산되어 저장될 수 있다.</li></ul></li><li><p>내부 단편화:</p><ul><li>페이지 크기가 고정되어 있어 프로세스의 마지막 페이지에서 내부 단편화가 발생할 수 있다.</li></ul></li></ol><h3 id=페이징의-작동-방식>페이징의 작동 방식<a hidden class=anchor aria-hidden=true href=#페이징의-작동-방식>#</a></h3><ol><li>프로세스가 메모리에 로드될 때, 운영체제는 프로세스를 페이지 단위로 나눈다.</li><li>각 페이지는 사용 가능한 메모리 프레임에 할당된다.</li><li>운영체제는 페이지 테이블을 생성하여 각 페이지와 해당 프레임 간의 매핑을 유지한다.</li><li>CPU가 메모리에 접근할 때, 논리 주소는 페이지 번호와 오프셋으로 나뉜다.</li><li>MMU는 페이지 테이블을 참조하여 페이지 번호를 프레임 번호로 변환한다.</li><li>프레임 번호와 오프셋을 조합하여 실제 물리 주소를 생성한다.</li></ol><h3 id=페이징의-장점>페이징의 장점<a hidden class=anchor aria-hidden=true href=#페이징의-장점>#</a></h3><ol><li>외부 단편화 제거: 메모리를 고정 크기로 관리하여 외부 단편화를 방지한다.</li><li>유연한 메모리 할당: 프로세스의 페이지들을 비연속적으로 할당할 수 있다.</li><li>메모리 보호: 페이지 단위로 접근 권한을 설정할 수 있어 보안성이 향상된다.</li><li>가상 메모리 지원: 실제 물리 메모리보다 큰 주소 공간을 제공할 수 있다.</li></ol><h3 id=페이징의-단점>페이징의 단점<a hidden class=anchor aria-hidden=true href=#페이징의-단점>#</a></h3><ol><li>내부 단편화: 페이지 크기가 고정되어 있어 마지막 페이지에서 낭비가 발생할 수 있다.</li><li>페이지 테이블 오버헤드: 큰 프로세스의 경우 페이지 테이블이 많은 메모리를 차지할 수 있다.</li><li>주소 변환 시간: 페이지 테이블 참조로 인한 추가적인 메모리 접근이 필요하다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/operating-system/>Operating-System</a></li><li><a href=https://buenhyden.github.io/tags/memory-mgmt/>Memory-Mgmt</a></li><li><a href=https://buenhyden.github.io/tags/memory-mgmt-techniques/>Memory-Mgmt-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/memory-management/>Memory-Management</a></li><li><a href=https://buenhyden.github.io/tags/memory-management-techniques/>Memory-Management-Techniques</a></li><li><a href=https://buenhyden.github.io/tags/paging/>Paging</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/><span class=title>« Prev</span><br><span>세그먼테이션 (Segmentation)</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/><span class=title>Next »</span><br><span>Message Queue</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>