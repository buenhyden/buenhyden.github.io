<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Write Policy | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Caching,Cache-Policy"><meta name=description content="Cache Policy의 Write Policy(쓰기 정책)는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Write Policy"><meta property="og:description" content="Cache Policy의 Write Policy(쓰기 정책)는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T10:53:00+00:00"><meta property="article:modified_time" content="2024-09-30T10:53:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Cache-Policy"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Write Policy"><meta name=twitter:description content="Cache Policy의 Write Policy(쓰기 정책)는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-system/"},{"@type":"ListItem","position":3,"name":"Computer Architecture","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/"},{"@type":"ListItem","position":4,"name":"Memory Architecture","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/"},{"@type":"ListItem","position":5,"name":"캐싱 (Caching)","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/"},{"@type":"ListItem","position":6,"name":"Cache Policy","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/"},{"@type":"ListItem","position":7,"name":"Write Policy","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Write Policy","name":"Write Policy","description":"Cache Policy의 Write Policy(쓰기 정책)는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다.","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Caching","Cache-Policy"],"articleBody":"Write Policy Cache Policy의 Write Policy(쓰기 정책) 는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다.\n이 정책은 데이터 일관성과 시스템 성능에 중요한 영향을 미친다.\nWrite Policy는 캐싱 시스템의 성능과 일관성에 중요한 영향을 미치는 요소이다. Write-Through와 Write-Back은 각각 장단점이 있으며, 워크로드 특성과 요구사항에 따라 적절한 정책을 선택해야 한다. 또한, Write Allocate와 No Write Allocate 같은 추가적인 처리 방식을 조합하여 최적의 결과를 얻을 수 있다. 올바른 정책 선택은 시스템의 효율성을 극대화하고 사용자 경험을 향상시키는 데 중요한 역할을 한다.\nWrite Policy란? 정의: 캐시에서 데이터가 수정되거나 추가될 때, 이를 메인 메모리에 언제, 어떻게 반영할지를 결정하는 규칙입니다. 목적: 데이터 일관성 유지: 캐시와 메인 메모리 간의 데이터 불일치를 방지. 성능 최적화: 쓰기 작업이 시스템 성능에 미치는 영향을 최소화. 주요 Write Policy 유형 Write-Through (즉시 쓰기) 작동 방식 데이터를 캐시에 쓰는 동시에 메인 메모리에도 즉시 업데이트한다. 캐시와 메인 메모리가 항상 동기화 상태를 유지한다. 장점 데이터 일관성이 보장된다. 캐시와 메인 메모리가 항상 최신 상태를 유지하므로, 다른 프로세서나 시스템이 데이터를 읽을 때 항상 최신 데이터를 가져온다. 구현이 간단하다. 단점 쓰기 작업이 많을 경우, 메인 메모리에 대한 빈번한 접근으로 인해 성능이 저하될 수 있다. 모든 쓰기 작업에서 캐시와 메인 메모리에 동시에 기록해야 하므로, 대역폭 소모가 크다. 사용 사례 데이터 일관성이 매우 중요한 시스템(예: 금융 거래 시스템). Write-Back (지연 쓰기) 작동 방식 데이터를 먼저 캐시에만 저장하고, 메인 메모리는 나중에 업데이트한다. 캐시 블록이 교체될 때(즉, 다른 데이터로 대체될 때)만 해당 블록의 데이터를 메인 메모리에 기록한다. 각 캐시 블록에는 “Dirty Bit\"라는 플래그가 있어, 해당 블록이 수정되었는지 여부를 표시한다. 장점 쓰기 작업이 캐시에만 이루어지므로, Write-Through에 비해 성능이 뛰어나다. 메인 메모리 접근 빈도가 줄어들어 대역폭 사용량이 감소한다. 단점 캐시와 메인 메모리 간 데이터 불일치 가능성이 존재한다. 따라서 추가적인 관리가 필요하다. 캐시 장애가 발생하면 수정된 데이터가 손실될 위험이 있다. 사용 사례 쓰기 작업이 빈번한 시스템(예: 게임 엔진, 실시간 애플리케이션). Write Miss 처리 방식 쓰기 작업 중 캐시에 해당 데이터가 없는 경우(Write Miss), 이를 처리하는 방식은 다음 두 가지로 나뉜다:\nWrite Allocate (Write-Miss Allocate) Write Miss가 발생하면, 해당 데이터를 먼저 캐시에 로드한 뒤, 캐시에 데이터를 기록한다. 이 방식은 지역성(Locality)을 활용하여 이후의 읽기/쓰기 작업에서 효율성을 높인다. 주로 Write-Back 정책과 함께 사용된다. **장점:\n이후의 읽기/쓰기 작업에서 성능 향상 가능. 단점:\n초기 로드 단계에서 추가적인 지연 발생. No Write Allocate (Write-No Allocate) Write Miss가 발생하면, 데이터를 캐시에 로드하지 않고 직접 메인 메모리에 기록한다. 주로 Write-Through 정책과 함께 사용된다. 장점:\n캐시 공간을 절약할 수 있다(자주 사용되지 않는 데이터는 캐시에 저장되지 않음). 단점:\n이후의 읽기/쓰기 작업에서 성능 저하 가능. Write Policy 비교 정책 유형 작동 방식 장점 단점 사용 사례 Write-Through 캐시에 쓰는 동시에 메인 메모리에도 즉시 업데이트 데이터 일관성 보장 쓰기 성능 저하 및 대역폭 소모 증가 금융 거래 시스템 등 일관성이 중요한 환경 Write-Back 캐시에만 쓰고, 교체 시에만 메인 메모리에 기록 높은 쓰기 성능과 낮은 대역폭 사용 데이터 불일치 가능성 존재 및 추가 관리 필요 실시간 애플리케이션, 게임 엔진 등 Write Allocate Write Miss 시 데이터를 캐시에 로드 후 기록 지역성을 활용하여 이후 성능 향상 초기 로드 단계에서 지연 발생 자주 접근되는 데이터가 많은 애플리케이션 No Write Allocate Write Miss 시 데이터를 직접 메인 메모리에 기록 불필요한 데이터의 캐시 공간 낭비 방지 이후 읽기/쓰기 성능 저하 가능 자주 접근되지 않는 데이터를 다루는 환경 Write Policy 선택 기준 데이터 일관성 요구사항:\n일관성이 중요한 경우 Write-Through를 선택. 성능을 더 중시한다면 Write-Back을 선택. 워크로드 특성:\n읽기가 많고 쓰기가 적다면 Write-Through 적합. 쓰기가 많다면 Write-Back 적합. 캐시 크기 및 대역폭 제한:\n대역폭이 제한적이라면 Write-Back이 유리. 데이터 지역성(Locality):\n지역성이 높다면 Write Allocate를 고려. 지역성이 낮다면 No Write Allocate를 고려. 참고 및 출처 ","wordCount":"565","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T10:53:00Z","dateModified":"2024-09-30T10:53:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/computer-architecture/>Computer Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/>Memory Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/>캐싱 (Caching)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/>Cache Policy</a></div><h1 class="post-title entry-hint-parent">Write Policy</h1><div class=post-description>Cache Policy의 Write Policy(쓰기 정책)는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다.</div><div class=post-meta><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20System/Computer%20Architecture/Memory%20Architecture/Caching/Cache%20Policy/write-policy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#write-policy>Write Policy</a><ul><li><a href=#write-policy란>Write Policy란?</a></li><li><a href=#주요-write-policy-유형>주요 Write Policy 유형</a></li><li><a href=#write-miss-처리-방식>Write Miss 처리 방식</a></li><li><a href=#write-policy-비교>Write Policy 비교</a></li><li><a href=#write-policy-선택-기준>Write Policy 선택 기준</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=write-policy>Write Policy<a hidden class=anchor aria-hidden=true href=#write-policy>#</a></h2><p><strong>Cache Policy</strong>의 <strong>Write Policy(쓰기 정책)</strong> 는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다.<br>이 정책은 데이터 일관성과 시스템 성능에 중요한 영향을 미친다.</p><p><strong>Write Policy</strong>는 캐싱 시스템의 성능과 일관성에 중요한 영향을 미치는 요소이다. <code>Write-Through</code>와 <code>Write-Back</code>은 각각 장단점이 있으며, 워크로드 특성과 요구사항에 따라 적절한 정책을 선택해야 한다. 또한, <code>Write Allocate</code>와 <code>No Write Allocate</code> 같은 추가적인 처리 방식을 조합하여 최적의 결과를 얻을 수 있다. 올바른 정책 선택은 시스템의 효율성을 극대화하고 사용자 경험을 향상시키는 데 중요한 역할을 한다.</p><h3 id=write-policy란>Write Policy란?<a hidden class=anchor aria-hidden=true href=#write-policy란>#</a></h3><ul><li><strong>정의</strong>: 캐시에서 데이터가 수정되거나 추가될 때, 이를 메인 메모리에 언제, 어떻게 반영할지를 결정하는 규칙입니다.</li><li><strong>목적</strong>:<ul><li>데이터 일관성 유지: 캐시와 메인 메모리 간의 데이터 불일치를 방지.</li><li>성능 최적화: 쓰기 작업이 시스템 성능에 미치는 영향을 최소화.</li></ul></li></ul><h3 id=주요-write-policy-유형>주요 Write Policy 유형<a hidden class=anchor aria-hidden=true href=#주요-write-policy-유형>#</a></h3><h4 id=write-through-즉시-쓰기>Write-Through (즉시 쓰기)<a hidden class=anchor aria-hidden=true href=#write-through-즉시-쓰기>#</a></h4><h5 id=작동-방식><strong>작동 방식</strong><a hidden class=anchor aria-hidden=true href=#작동-방식>#</a></h5><ul><li>데이터를 캐시에 쓰는 동시에 메인 메모리에도 즉시 업데이트한다.</li><li>캐시와 메인 메모리가 항상 동기화 상태를 유지한다.</li></ul><h5 id=장점><strong>장점</strong><a hidden class=anchor aria-hidden=true href=#장점>#</a></h5><ul><li>데이터 일관성이 보장된다. 캐시와 메인 메모리가 항상 최신 상태를 유지하므로, 다른 프로세서나 시스템이 데이터를 읽을 때 항상 최신 데이터를 가져온다.</li><li>구현이 간단하다.</li></ul><h5 id=단점><strong>단점</strong><a hidden class=anchor aria-hidden=true href=#단점>#</a></h5><ul><li>쓰기 작업이 많을 경우, 메인 메모리에 대한 빈번한 접근으로 인해 성능이 저하될 수 있다.</li><li>모든 쓰기 작업에서 캐시와 메인 메모리에 동시에 기록해야 하므로, 대역폭 소모가 크다.</li></ul><h5 id=사용-사례><strong>사용 사례</strong><a hidden class=anchor aria-hidden=true href=#사용-사례>#</a></h5><ul><li>데이터 일관성이 매우 중요한 시스템(예: 금융 거래 시스템).</li></ul><h4 id=write-back-지연-쓰기>Write-Back (지연 쓰기)<a hidden class=anchor aria-hidden=true href=#write-back-지연-쓰기>#</a></h4><h5 id=작동-방식-1><strong>작동 방식</strong><a hidden class=anchor aria-hidden=true href=#작동-방식-1>#</a></h5><ul><li>데이터를 먼저 캐시에만 저장하고, 메인 메모리는 나중에 업데이트한다.</li><li>캐시 블록이 교체될 때(즉, 다른 데이터로 대체될 때)만 해당 블록의 데이터를 메인 메모리에 기록한다.</li><li>각 캐시 블록에는 &ldquo;Dirty Bit"라는 플래그가 있어, 해당 블록이 수정되었는지 여부를 표시한다.</li></ul><h5 id=장점-1><strong>장점</strong><a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h5><ul><li>쓰기 작업이 캐시에만 이루어지므로, Write-Through에 비해 성능이 뛰어나다.</li><li>메인 메모리 접근 빈도가 줄어들어 대역폭 사용량이 감소한다.</li></ul><h5 id=단점-1><strong>단점</strong><a hidden class=anchor aria-hidden=true href=#단점-1>#</a></h5><ul><li>캐시와 메인 메모리 간 데이터 불일치 가능성이 존재한다. 따라서 추가적인 관리가 필요하다.</li><li>캐시 장애가 발생하면 수정된 데이터가 손실될 위험이 있다.</li></ul><h5 id=사용-사례-1><strong>사용 사례</strong><a hidden class=anchor aria-hidden=true href=#사용-사례-1>#</a></h5><ul><li>쓰기 작업이 빈번한 시스템(예: 게임 엔진, 실시간 애플리케이션).</li></ul><h3 id=write-miss-처리-방식>Write Miss 처리 방식<a hidden class=anchor aria-hidden=true href=#write-miss-처리-방식>#</a></h3><p>쓰기 작업 중 캐시에 해당 데이터가 없는 경우(Write Miss), 이를 처리하는 방식은 다음 두 가지로 나뉜다:</p><h4 id=write-allocate-write-miss-allocate>Write Allocate (Write-Miss Allocate)<a hidden class=anchor aria-hidden=true href=#write-allocate-write-miss-allocate>#</a></h4><ul><li>Write Miss가 발생하면, 해당 데이터를 먼저 캐시에 로드한 뒤, 캐시에 데이터를 기록한다.</li><li>이 방식은 지역성(Locality)을 활용하여 이후의 읽기/쓰기 작업에서 효율성을 높인다.</li><li>주로 <strong>Write-Back</strong> 정책과 함께 사용된다.</li></ul><p>**장점:</p><ul><li>이후의 읽기/쓰기 작업에서 성능 향상 가능.</li></ul><p><strong>단점</strong>:</p><ul><li>초기 로드 단계에서 추가적인 지연 발생.</li></ul><h4 id=no-write-allocate-write-no-allocate>No Write Allocate (Write-No Allocate)<a hidden class=anchor aria-hidden=true href=#no-write-allocate-write-no-allocate>#</a></h4><ul><li>Write Miss가 발생하면, 데이터를 캐시에 로드하지 않고 직접 메인 메모리에 기록한다.</li><li>주로 <strong>Write-Through</strong> 정책과 함께 사용된다.</li></ul><p><strong>장점</strong>:</p><ul><li>캐시 공간을 절약할 수 있다(자주 사용되지 않는 데이터는 캐시에 저장되지 않음).</li></ul><p><strong>단점</strong>:</p><ul><li>이후의 읽기/쓰기 작업에서 성능 저하 가능.</li></ul><h3 id=write-policy-비교>Write Policy 비교<a hidden class=anchor aria-hidden=true href=#write-policy-비교>#</a></h3><table><thead><tr><th>정책 유형</th><th>작동 방식</th><th>장점</th><th>단점</th><th>사용 사례</th></tr></thead><tbody><tr><td>Write-Through</td><td>캐시에 쓰는 동시에 메인 메모리에도 즉시 업데이트</td><td>데이터 일관성 보장</td><td>쓰기 성능 저하 및 대역폭 소모 증가</td><td>금융 거래 시스템 등 일관성이 중요한 환경</td></tr><tr><td>Write-Back</td><td>캐시에만 쓰고, 교체 시에만 메인 메모리에 기록</td><td>높은 쓰기 성능과 낮은 대역폭 사용</td><td>데이터 불일치 가능성 존재 및 추가 관리 필요</td><td>실시간 애플리케이션, 게임 엔진 등</td></tr><tr><td>Write Allocate</td><td>Write Miss 시 데이터를 캐시에 로드 후 기록</td><td>지역성을 활용하여 이후 성능 향상</td><td>초기 로드 단계에서 지연 발생</td><td>자주 접근되는 데이터가 많은 애플리케이션</td></tr><tr><td>No Write Allocate</td><td>Write Miss 시 데이터를 직접 메인 메모리에 기록</td><td>불필요한 데이터의 캐시 공간 낭비 방지</td><td>이후 읽기/쓰기 성능 저하 가능</td><td>자주 접근되지 않는 데이터를 다루는 환경</td></tr></tbody></table><h3 id=write-policy-선택-기준>Write Policy 선택 기준<a hidden class=anchor aria-hidden=true href=#write-policy-선택-기준>#</a></h3><ol><li><p><strong>데이터 일관성 요구사항</strong>:</p><ul><li>일관성이 중요한 경우 <code>Write-Through</code>를 선택.</li><li>성능을 더 중시한다면 <code>Write-Back</code>을 선택.</li></ul></li><li><p><strong>워크로드 특성</strong>:</p><ul><li>읽기가 많고 쓰기가 적다면 <code>Write-Through</code> 적합.</li><li>쓰기가 많다면 <code>Write-Back</code> 적합.</li></ul></li><li><p><strong>캐시 크기 및 대역폭 제한</strong>:</p><ul><li>대역폭이 제한적이라면 <code>Write-Back</code>이 유리.</li></ul></li><li><p><strong>데이터 지역성(Locality)</strong>:</p><ul><li>지역성이 높다면 <code>Write Allocate</code>를 고려.</li><li>지역성이 낮다면 <code>No Write Allocate</code>를 고려.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/cache-policy/>Cache-Policy</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/replacement-policy/><span class=title>« Prev</span><br><span>Replacement Policy</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/placement-policy/><span class=title>Next »</span><br><span>Placement Policy</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>