<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>메모리의 계층 구조 (Memory Hierarchy) | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Memory-Hierarchy"><meta name=description content="컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="메모리의 계층 구조 (Memory Hierarchy)"><meta property="og:description" content="컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-22T03:33:00+00:00"><meta property="article:modified_time" content="2024-09-22T03:33:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Memory-Hierarchy"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="메모리의 계층 구조 (Memory Hierarchy)"><meta name=twitter:description content="컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-system/"},{"@type":"ListItem","position":3,"name":"Computer Architecture","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/"},{"@type":"ListItem","position":4,"name":"Memory Architecture","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/"},{"@type":"ListItem","position":5,"name":"메모리의 계층 구조 (Memory Hierarchy)","item":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"메모리의 계층 구조 (Memory Hierarchy)","name":"메모리의 계층 구조 (Memory Hierarchy)","description":"컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Memory-Hierarchy"],"articleBody":"메모리의 계층 구조 (Memory Hierarchy) 메모리 계층 구조는 컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조.\n이 구조는 속도, 용량, 비용 간의 균형을 고려하여 여러 종류의 메모리를 계층적으로 배치한다.\n메모리 계층 구조의 각 레벨은 위로 올라갈수록 다음과 같은 특성을 가진다.\n접근 속도가 빨라짐 용량이 작아짐 비트당 가격이 높아짐 CPU에 의한 접근 빈도가 증가함 1 2 3 4 5 6 7 8 계층 구조 (위에서 아래로): 레지스터 ↓ 캐시 (L1 → L2 → L3) ↓ 메인 메모리 (RAM) ↓ 보조 기억 장치 (SSD/HDD) 이러한 계층 구조는 ‘참조 지역성(Locality of Reference)’ 원리를 활용하여 전체 시스템의 성능을 최적화한다.\n자주 사용되는 데이터를 빠른 상위 계층에 유지함으로써, 평균 데이터 접근 시간을 줄이고 전체적인 시스템 성능을 향상시킨다.\n참조 지역성(Locality of Reference)\n컴퓨터 프로그램이 메모리에 접근하는 패턴에 관한 원리로, 프로그램이 일정 기간 동안 특정한 메모리 위치 집합에 집중적으로 접근하는 경향.\n중요성 캐시 메모리 최적화: 참조 지역성 원리를 활용하여 캐시 메모리에 자주 사용되는 데이터를 저장함으로써 캐시 적중률(hit rate)을 높일 수 있다 시스템 성능 향상: 캐시 적중률이 높아지면 메모리 접근 시간이 줄어들어 전체적인 시스템 성능이 향상된다. 프로그램 최적화: 개발자가 참조 지역성을 고려하여 코드를 작성하면 프로그램의 실행 속도를 크게 개선할 수 있다. 유형 시간적 지역성 (Temporal Locality): 최근에 참조된 메모리 위치가 가까운 미래에 다시 참조될 가능성이 높다. 반복문에서 같은 변수를 여러 번 사용하는 경우 자주 호출되는 함수나 서브루틴 스택에 저장된 지역 변수에 대한 반복적인 접근 공간적 지역성 (Spatial Locality): 특정 메모리 위치가 참조되면, 그 주변의 메모리 위치들도 곧 참조될 가능성이 높다. 배열의 요소를 순차적으로 접근하는 경우 구조체의 멤버 변수들에 연속적으로 접근하는 경우 명령어들이 메모리에 연속적으로 저장되어 있는 경우 Source: https://www.scaler.com/topics/memory-hierarchy/\n레지스터 (Register) 레지스터는 메모리 계층 구조의 최상위에 위치하며, CPU 내부에 존재한다.\n특징:\n가장 빠른 접근 속도를 제공 매우 작은 용량 (일반적으로 32비트 또는 64비트) CPU가 직접 사용할 수 있는 데이터를 저장 비용이 가장 높음 캐시 메모리 (Cache Memory) 캐시 메모리는 CPU와 주 메모리 사이에 위치하며, 자주 사용되는 데이터와 명령어를 저장한다.\n종류:\nL1 캐시: CPU 코어에 가장 가까이 위치, 가장 빠르지만 용량이 작음 (보통 8~64KB) L2 캐시: L1보다 느리지만 더 큰 용량 (64KB~4MB) L3 캐시: 일부 프로세서에서 사용, L2보다 더 큰 용량 캐시 메모리는 SRAM(Static RAM)으로 구성되며, 빠른 접근 속도를 제공한다.\n주 메모리 (Main Memory) 주 메모리는 일반적으로 RAM(Random Access Memory)을 의미한다.\n특징:\nCPU가 직접 접근할 수 있는 가장 큰 메모리 주로 DRAM(Dynamic RAM)으로 구성 캐시보다 느리지만 더 큰 용량 제공 휘발성 메모리 (전원이 꺼지면 데이터 손실) 보조 기억 장치 (Secondary Storage) 보조 기억 장치는 메모리 계층 구조의 가장 하위에 위치한다.\n특징:\n하드 디스크 드라이브(HDD)나 솔리드 스테이트 드라이브(SSD) 등이 포함 가장 큰 용량을 제공 비휘발성 (전원이 꺼져도 데이터 유지) 접근 속도가 가장 느림 참고 및 출처 ","wordCount":"420","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-22T03:33:00Z","dateModified":"2024-09-22T03:33:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/computer-architecture/>Computer Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/>Memory Architecture</a></div><h1 class="post-title entry-hint-parent">메모리의 계층 구조 (Memory Hierarchy)</h1><div class=post-description>컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조</div><div class=post-meta><span title='2024-09-22 03:33:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;420 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20System/Computer%20Architecture/Memory%20Architecture/Memory-Hierarchy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#메모리의-계층-구조-memory-hierarchy>메모리의 계층 구조 (Memory Hierarchy)</a><ul><li><a href=#레지스터-register>레지스터 (Register)</a></li><li><a href=#캐시-메모리-cache-memory>캐시 메모리 (Cache Memory)</a></li><li><a href=#주-메모리-main-memory>주 메모리 (Main Memory)</a></li><li><a href=#보조-기억-장치-secondary-storage>보조 기억 장치 (Secondary Storage)</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=메모리의-계층-구조-memory-hierarchy>메모리의 계층 구조 (Memory Hierarchy)<a hidden class=anchor aria-hidden=true href=#메모리의-계층-구조-memory-hierarchy>#</a></h2><p>메모리 계층 구조는 컴퓨터 시스템에서 데이터 접근의 효율성을 극대화하고 전체 시스템 성능을 향상시키기 위해 설계된 구조.<br>이 구조는 속도, 용량, 비용 간의 균형을 고려하여 여러 종류의 메모리를 계층적으로 배치한다.</p><p>메모리 계층 구조의 각 레벨은 위로 올라갈수록 다음과 같은 특성을 가진다.</p><ul><li>접근 속도가 빨라짐</li><li>용량이 작아짐</li><li>비트당 가격이 높아짐</li><li>CPU에 의한 접근 빈도가 증가함</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>계층 구조 (위에서 아래로):
</span></span><span class=line><span class=cl>레지스터
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>캐시 (L1 → L2 → L3)
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>메인 메모리 (RAM)
</span></span><span class=line><span class=cl>    ↓
</span></span><span class=line><span class=cl>보조 기억 장치 (SSD/HDD)
</span></span></code></pre></td></tr></table></div></div><p>이러한 계층 구조는 &lsquo;참조 지역성(Locality of Reference)&rsquo; 원리를 활용하여 전체 시스템의 성능을 최적화한다.<br>자주 사용되는 데이터를 빠른 상위 계층에 유지함으로써, 평균 데이터 접근 시간을 줄이고 전체적인 시스템 성능을 향상시킨다.</p><blockquote><p>참조 지역성(Locality of Reference)<br>컴퓨터 프로그램이 메모리에 접근하는 패턴에 관한 원리로, 프로그램이 일정 기간 동안 특정한 메모리 위치 집합에 집중적으로 접근하는 경향.</p><ul><li>중요성<ul><li>캐시 메모리 최적화: 참조 지역성 원리를 활용하여 캐시 메모리에 자주 사용되는 데이터를 저장함으로써 캐시 적중률(hit rate)을 높일 수 있다</li><li>시스템 성능 향상: 캐시 적중률이 높아지면 메모리 접근 시간이 줄어들어 전체적인 시스템 성능이 향상된다.</li><li>프로그램 최적화: 개발자가 참조 지역성을 고려하여 코드를 작성하면 프로그램의 실행 속도를 크게 개선할 수 있다.</li></ul></li><li>유형<ul><li>시간적 지역성 (Temporal Locality): 최근에 참조된 메모리 위치가 가까운 미래에 다시 참조될 가능성이 높다.<ul><li>반복문에서 같은 변수를 여러 번 사용하는 경우</li><li>자주 호출되는 함수나 서브루틴</li><li>스택에 저장된 지역 변수에 대한 반복적인 접근</li></ul></li><li>공간적 지역성 (Spatial Locality): 특정 메모리 위치가 참조되면, 그 주변의 메모리 위치들도 곧 참조될 가능성이 높다.<ul><li>배열의 요소를 순차적으로 접근하는 경우</li><li>구조체의 멤버 변수들에 연속적으로 접근하는 경우</li><li>명령어들이 메모리에 연속적으로 저장되어 있는 경우</li></ul></li></ul></li></ul></blockquote><p><figure><img alt="Memory Hierarchy Design" loading=lazy src=/img/memory-hierarchy-design.webp><figcaption>Source: https://www.scaler.com/topics/memory-hierarchy/</figcaption></figure></p><h3 id=레지스터-register>레지스터 (Register)<a hidden class=anchor aria-hidden=true href=#레지스터-register>#</a></h3><p>레지스터는 메모리 계층 구조의 최상위에 위치하며, CPU 내부에 존재한다.</p><p>특징:</p><ul><li>가장 빠른 접근 속도를 제공</li><li>매우 작은 용량 (일반적으로 32비트 또는 64비트)</li><li>CPU가 직접 사용할 수 있는 데이터를 저장</li><li>비용이 가장 높음</li></ul><h3 id=캐시-메모리-cache-memory>캐시 메모리 (Cache Memory)<a hidden class=anchor aria-hidden=true href=#캐시-메모리-cache-memory>#</a></h3><p>캐시 메모리는 CPU와 주 메모리 사이에 위치하며, 자주 사용되는 데이터와 명령어를 저장한다.</p><p>종류:</p><ul><li>L1 캐시: CPU 코어에 가장 가까이 위치, 가장 빠르지만 용량이 작음 (보통 8~64KB)</li><li>L2 캐시: L1보다 느리지만 더 큰 용량 (64KB~4MB)</li><li>L3 캐시: 일부 프로세서에서 사용, L2보다 더 큰 용량</li></ul><p>캐시 메모리는 SRAM(Static RAM)으로 구성되며, 빠른 접근 속도를 제공한다.</p><h3 id=주-메모리-main-memory>주 메모리 (Main Memory)<a hidden class=anchor aria-hidden=true href=#주-메모리-main-memory>#</a></h3><p>주 메모리는 일반적으로 RAM(Random Access Memory)을 의미한다.</p><p>특징:</p><ul><li>CPU가 직접 접근할 수 있는 가장 큰 메모리</li><li>주로 DRAM(Dynamic RAM)으로 구성</li><li>캐시보다 느리지만 더 큰 용량 제공</li><li>휘발성 메모리 (전원이 꺼지면 데이터 손실)</li></ul><h3 id=보조-기억-장치-secondary-storage>보조 기억 장치 (Secondary Storage)<a hidden class=anchor aria-hidden=true href=#보조-기억-장치-secondary-storage>#</a></h3><p>보조 기억 장치는 메모리 계층 구조의 가장 하위에 위치한다.</p><p>특징:</p><ul><li>하드 디스크 드라이브(HDD)나 솔리드 스테이트 드라이브(SSD) 등이 포함</li><li>가장 큰 용량을 제공</li><li>비휘발성 (전원이 꺼져도 데이터 유지)</li><li>접근 속도가 가장 느림</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-hierarchy/>Memory-Hierarchy</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git%EC%9D%98-%EA%B3%A0%EA%B8%89-%EA%B8%B0%EB%8A%A5/><span class=title>« Prev</span><br><span>Git의 고급 기능</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-coherence/><span class=title>Next »</span><br><span>Cache Coherence</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>