<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HY's Blog | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="HY's Blog - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="HY's Blog"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="HY's Blog"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>HY's Blog</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Styles</h2></header><div class=entry-content><p>API Styles API(애플리케이션 프로그래밍 인터페이스) 스타일은 시스템 간 통신 방식을 결정하는 중요한 설계 패턴으로, 다양한 시스템과 장치가 서로 디지털적으로 통신할 수 있도록 연결해주는 역할을 한다. API 스타일은 API가 외부 세계와 상호작용하는 방식을 결정하는 중요한 요소이다.
API 스타일은 크게 다섯 가지로 분류할 수 있다:
리소스 스타일 (Resource Style) 하이퍼미디어 스타일 (Hypermedia Style) 쿼리 스타일 (Query Style) 터널 스타일 (Tunnel Style) 이벤트 기반 스타일 (Event-based Style) 각 스타일은 고유한 강점과 약점을 가지고 있으며, 적절한 API 스타일 선택은 해결하려는 문제, API 소비자, 그리고 API가 사용되는 컨텍스트에 따라 달라진다.
...</p></div><footer class=entry-footer><span title='2025-02-26 06:08:00 +0000 UTC'>February 26, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Styles" href=https://buenhyden.github.io/posts/programming-and-development/software-development/api-development-and-implementation/api-styles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backend Development</h2></header><div class=entry-content><p>Backend Development 백엔드 개발(Backend Development)은 사용자 인터페이스와 직접적으로 상호작용하지 않는 서버 측 애플리케이션 개발을 의미한다. 주로 서버 프로그래밍, 데이터베이스 관리, API 설계 및 구현, 인증/권한 부여, 비즈니스 로직 처리 등을 포함한다.
백엔드 개발자는 프론트엔드와 데이터베이스 사이의 중개자 역할을 수행하며, 시스템의 보안, 확장성, 성능을 관리한다. 다양한 프로그래밍 언어(Java, Python, Node.js 등)와 프레임워크(Spring, Django, Express 등)를 활용하여 안정적이고 효율적인 서버 애플리케이션을 구축한다.
최근에는 클라우드, 마이크로서비스, 서버리스, 인공지능(AI) 등 신기술과 결합해 더욱 복잡하고 확장성 높은 시스템을 구축하는 것이 주요 트렌드이다.
...</p></div><footer class=entry-footer><span title='2024-09-19 01:29:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backend Development" href=https://buenhyden.github.io/posts/programming-and-development/software-development/backend-development/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2025-05-27 08:37:00 +0000 UTC'>May 27, 2025</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Design" href=https://buenhyden.github.io/posts/system-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Design and Implementation</h2></header><div class=entry-content><p>API(Application Programming Interface) Design and Implementation API(응용 프로그램 프로그래밍 인터페이스, Application Programming Interface)는 소프트웨어 컴포넌트 간의 데이터 교환과 통신을 위한 표준화된 규약 및 인터페이스이다.
API는 현대 소프트웨어 개발의 핵심 요소로, 개발자가 기존 코드와 서비스를 활용하여 새로운 애플리케이션을 빠르게 구축할 수 있게 해준다. 또한, 백엔드 시스템, 서드파티 서비스, 내부 시스템 간의 연결을 가능하게 하며, 데이터와 기능을 안전하게 공유할 수 있는 표준화된 방법을 제공한다. 효과적인 API는 명확한 계약, 일관된 구조, 적절한 보안 메커니즘, 확장성 있는 설계를 갖추어야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-19 17:42:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Design and Implementation" href=https://buenhyden.github.io/posts/programming-and-development/software-development/api-development-and-implementation/api-design-and-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Programming Languages</h2></header><div class=entry-content><p></p></div><footer class=entry-footer><span title='2024-09-19 10:20:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;0 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Languages" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Engineering</h2></header><div class=entry-content><p>Data Engineering 1. 주제의 분류 적합성 데이터 엔지니어링 (Data Engineering) 은 데이터 수집, 저장, 처리, 분석을 위한 인프라 구축 및 관리에 초점을 맞춘 분야로, 컴퓨터 과학 및 공학 (Computer Science and Engineering) 의 핵심 하위 분야로 분류됩니다. 이는 소프트웨어 개발, 시스템 설계, 알고리즘 최적화 등과 밀접하게 연관되어 있습니다 [1][7].
2. 200 자 내외 요약 설명 데이터 엔지니어링은 데이터 파이프라인 설계, ETL(Extract-Transform-Load) 프로세스 구축, 데이터 저장소 관리 등을 통해 분석·AI 모델에 필요한 고품질 데이터를 제공하는 분야입니다. 데이터 엔지니어는 구조화/비구조화 데이터를 처리하며, 2025 년에는 AI 통합, 실시간 처리, LakeDB 등 기술이 주목받고 있습니다 [4][5][8].
...</p></div><footer class=entry-footer><span title='2024-09-19 01:52:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Engineering" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-engineering/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>FCM</h2></header><div class=entry-content><p>FCM FCM(Firebase Cloud Messaging)은 Google에서 제공하는 크로스 플랫폼 메시징 솔루션으로, 안정적이고 효율적으로 메시지를 전송할 수 있는 서비스이다. 모바일 앱 및 웹 애플리케이션에 **푸시 알림(push notification)**을 쉽고 안정적으로 전송할 수 있다.
FCM의 기본 개념 FCM은 Google Cloud Messaging(GCM)의 후속 서비스로, 다양한 플랫폼(Android, iOS, 웹)에서 푸시 알림을 보낼 수 있는 통합 솔루션이다.
FCM의 주요 특징은 다음과 같다:
멀티 플랫폼 지원
Android, iOS, 그리고 웹까지 지원하여 크로스플랫폼으로 동작한다. 무료 사용
별도의 비용 없이 대량의 메시지를 무제한으로 전송할 수 있다. 토픽/그룹 메시징
특정 사용자 집합(예: 관심사를 가진 그룹, 특정 주제 토픽)에 메시지 발송이 가능하다. 고급 메시지 옵션
데이터 메시지(앱이 직접 메시지 데이터를 처리)와 알림 메시지(FCM이 자동으로 기기 알림창에 표시) 타입을 구분해서 활용할 수 있다. 강력한 통계 및 관리
전송 현황 및 전송 실패, 수신 확인 등 다양한 통계와 관리 기능을 제공한다. 조건부 전송
여러 속성(국가, 디바이스 유형 등)에 따라 복잡한 조건 기반 전송이 가능하다. 독자 등 대상 지정 가능 FCM의 동작 원리 서버와 클라이언트 구조 클라이언트 앱: 사용자의 스마트폰 또는 웹 브라우저. FCM으로부터 메시지를 수신한다. FCM 백엔드: Google의 클라우드 서버에서 메시지 중계/전달. 앱 서버(옵션): 개발자가 직접 운영하는 서버로, FCM 서버에 메시지 전송을 요청. 메시지 전송 흐름 사용자의 디바이스에서 FCM SDK를 통해 FCM 서버에 **등록 토큰(Registration Token)**을 요청 및 발급. 앱 서버 또는 Firebase Console을 통해 메시지를 전송 요청. FCM 서버가 등록 토큰(또는 토픽/그룹)에 해당하는 디바이스로 메시지를 중계. 최종적으로 디바이스에 메시지가 도착, 알림이 표시되거나 앱에서 직접 데이터 처리. FCM 메시지 유형 FCM에서는 두 가지 주요 메시지 유형을 제공한다:
...</p></div><footer class=entry-footer><span title='2025-04-04 08:06:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to FCM" href=https://buenhyden.github.io/posts/programming-and-development/software-development/api-development-and-implementation/api-technologies/push-notification/fcm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mockoon</h2></header><div class=entry-content><p>Mockoon Mockoon은 개발자가 빠르고 쉽게 API를 모킹(가짜로 구현)할 수 있는 오픈 소스 데스크톱 애플리케이션이다.
이 도구는 2017년에 처음 출시되었으며, API 개발 및 테스트 과정을 간소화하기 위해 설계되었다.
Mockoon의 주요 특징:
그래픽 사용자 인터페이스(GUI)로 코드 작성 없이 API 모킹 가능 윈도우, 맥, 리눅스 지원 크로스 플랫폼 애플리케이션 무료 오픈 소스 도구 CLI(Command Line Interface) 버전 제공 Docker 이미지 지원 Mockoon이 해결하는 개발 문제 백엔드 개발자로서 다음과 같은 상황에서 Mockoon이 매우 유용하다:
...</p></div><footer class=entry-footer><span title='2025-04-01 02:17:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mockoon" href=https://buenhyden.github.io/posts/programming-and-development/software-development/api-development-and-implementation/api-technologies/api-testing-tools/mock-server-tools/mockoon/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WireMock</h2></header><div class=entry-content><p>WireMock WireMock은 HTTP 기반 API를 위한 시뮬레이션 도구로, Java 환경에서 개발되었으나 다양한 플랫폼에서 활용 가능하다. 톰 애컬턴(Tom Akehurst)이 개발한 이 오픈소스 도구는 실제 서비스와 동일하게 동작하는 모의(Mock) API를 쉽게 구축할 수 있게 해준다.
WireMock의 주요 특징 독립 실행형 서버: 자체 HTTP 서버로 실행 가능 JUnit과의 통합: Java 테스트 코드에 내장하여 사용 가능 정확한 HTTP 응답 모방: 상태 코드, 헤더, 본문 등 완벽 모방 요청 매칭: URL, 헤더, 쿼리 파라미터, 본문 등 다양한 요소 기반 매칭 응답 템플릿팅: 동적 응답 생성 가능 상태 기반 행동: 이전 요청에 따라 다른 응답 반환 가능 요청 검증: 특정 요청이 발생했는지 확인 가능 장애 시뮬레이션: 지연, 오류, 손상된 응답 등 시뮬레이션 프록시 모드: 실제 서비스와 모킹 결합 가능 레코딩 기능: 실제 서비스의 응답을 기록하여 모킹에 활용 WireMock의 작동 원리 WireMock은 실제로 두 가지 주요 모드로 작동한다:
...</p></div><footer class=entry-footer><span title='2025-04-01 02:17:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WireMock" href=https://buenhyden.github.io/posts/programming-and-development/software-development/api-development-and-implementation/api-technologies/api-testing-tools/mock-server-tools/wiremock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenAPI 사양(OpenAPI Specification, OAS)</h2></header><div class=entry-content><p>OpenAPI 사양(OpenAPI Specification, OAS) OpenAPI 사양(OpenAPI Specification, OAS)은 REST API를 설계, 문서화 및 표준화하기 위한 언어에 구애받지 않는 정의 형식이다.
Swagger와 OpenAPI의 개념과 역사 Swagger의 탄생 Swagger는 2010년 Tony Tam에 의해 시작된 프로젝트로, RESTful API를 설계, 구축, 문서화, 소비하기 위한 오픈 소스 프레임워크이다. 초기에는 Wordnik이라는 온라인 사전 API를 문서화하기 위해 개발되었으나, 빠르게 API 개발 커뮤니티 내에서 인기를 얻었다.
OpenAPI로의 전환 2015년, Swagger 사양은 Linux Foundation 산하의 OpenAPI Initiative(OAI)에 기부되었고, Swagger 사양은 “OpenAPI 사양(OpenAPI Specification, OAS)“이라는 새로운 이름을 갖게 되었다. 이러한 전환은 사양을 더 중립적이고 산업 표준으로 발전시키기 위한 움직임이었다.
...</p></div><footer class=entry-footer><span title='2025-03-14 11:21:00 +0000 UTC'>March 14, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OpenAPI 사양(OpenAPI Specification, OAS)" href=https://buenhyden.github.io/posts/programming-and-development/software-development/api-development-and-implementation/api-specification-and-documentation/openapi-specification/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>