<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Posts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Posts"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker vs. Message Broker</h2></header><div class=entry-content><p>Event Broker vs. Message Broker 이벤트 브로커와 메시지 브로커는 현대 분산 시스템에서 핵심적인 미들웨어로, 서비스 간 결합도를 낮추고 확장성, 신뢰성, 실시간성, 장애 복원력을 제공한다. 이벤트 브로커는 Pub/Sub, 이벤트 스트리밍, 실시간 데이터 분배에 최적화되어 있으며, 메시지 브로커는 큐잉, 복잡한 라우팅, 포맷 변환, 트랜잭션 등 엔터프라이즈 통합에 강점을 보인다. 두 기술은 아키텍처, 메시징 패턴, 처리 방식, 주요 기능 등에서 차이가 있으며, 실제 환경에서는 요구사항에 따라 혼합 적용되기도 한다.
핵심 개념 메시지 브로커는 작업 처리와 안정성 중심의 통신에 적합하며, 명령 (Command), 요청 - 응답, 복잡한 라우팅이 필요한 경우에 효과적이다. 이벤트 브로커는 실시간 스트리밍, 이벤트 소싱, 이벤트 기반 데이터 흐름이 중심인 아키텍처에 최적화되어 있다. 양자 모두 분산 시스템에서의 decoupling, 비동기성, 확장성 확보에 필수적인 미들웨어이며, 도메인/업무의 특성에 따라 적절히 선택하거나 병행하여 사용하는 것이 권장된다. 항목 Event Broker (이벤트 브로커) Message Broker (메시지 브로커) 기본 정의 시스템 내에서 발생한 이벤트를 토픽 기반 Pub/Sub 모델로 중계 및 브로드캐스트하는 미들웨어 송신자와 수신자 간의 메시지를 큐 기반 Point-to-Point 방식으로 중개 및 전달하는 미들웨어 기반 모델 Log 기반, Publish-Subscribe 모델 Queue 기반, Routing 기반 (Direct, Topic, Fanout, Headers) 메시지 처리 방식 여러 구독자가 동일 이벤트를 동시에 소비 가능 (1:N, N:N 확장에 유리) 메시지를 수신한 단일 소비자가 처리 (1:1 또는 Load Balancing 처리) 용도 중심성 상태 변화, 알림, 데이터 변경 전파 등 이벤트 스트리밍 중심 (Event-based) 작업 명령, 요청 처리, 커맨드 전송 중심 (Command-based) 재처리 및 리텐션 로그 기반으로 이벤트 보존 가능 (리텐션/압축 설정), 이벤트 재처리 및 타임 트래블 가능 일반적으로 메시지 소비 후 삭제, 재처리는 DLQ 기반 처리 주요 특징 실시간 이벤트 스트리밍, 대용량 데이터 브로드캐스트, 이벤트 소싱 및 추적 가능 신뢰성 높은 메시지 전달, 메시지 포맷 변환, 복잡한 라우팅 지원 대표 구현체 Apache Kafka, Apache Pulsar, Amazon EventBridge, Azure Event Grid, Solace PubSub+ RabbitMQ, Apache ActiveMQ, IBM MQ, Amazon SQS Event Broker vs. Message Broker 비교 이벤트 브로커와 메시지 브로커는 모두 메시지 기반의 비동기 통신 미들웨어이다. 하지만 이벤트 중심 (Event-Driven Architecture) 과 메시지 큐잉 및 라우팅 (Queueing & Routing) 이라는 핵심 원칙과 동작 방식의 차이가 있다.
...</p></div><footer class=entry-footer><span title='2025-07-18 05:55:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;<span>33 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Event Broker vs. Message Broker" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-brokers-vs-event-brokers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GRASP</h2></header><div class=entry-content><p>GRASP GRASP(General Responsibility Assignment Software Patterns) 는 Craig Larman 이 제안한 객체지향 설계 원칙으로, 객체와 클래스에 책임을 할당하는 9 가지 핵심 패턴을 제공한다. 이 원칙들은 객체의 역할과 협력을 명확히 하여, 시스템의 유연성, 유지보수성, 확장성을 높이는 데 중점을 둔다. GRASP 는 Information Expert, Creator, Controller, Low Coupling, High Cohesion, Polymorphism, Pure Fabrication, Indirection, Protected Variations 등으로 구성되며, 실무에서 객체지향 설계의 기초이자 실질적인 지침으로 널리 활용된다.
핵심 개념 GRASP 의 핵심 개념은 " 책임 할당 (Responsibility Assignment)" 이다. 객체지향 설계에서 가장 중요한 의사결정은 어떤 클래스나 객체가 특정 책임을 담당해야 하는지 결정하는 것이다. 실무에 바로 적용 가능한 구체적이고 명확한 설계 지침이며, SOLID 원칙과 함께 객체지향 설계의 양대 축으로 활용된다.
...</p></div><footer class=entry-footer><span title='2025-05-30 12:16:00 +0000 UTC'>May 30, 2025</span>&nbsp;·&nbsp;<span>12 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to GRASP" href=https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-principles/grasp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Failback</h2></header><div class=entry-content><p>Failback Failback 은 고가용성 아키텍처에서 장애 조치 (Failover) 후 원본 시스템 복구를 관리하는 핵심 메커니즘이다. 주로 Active-Passive 구조에서 사용되며, 데이터 일관성 유지, 서비스 중단 최소화, 자원 최적화를 목표로 한다. 페일오버와 함께 완전한 재해 복구 루프를 형성하여 비즈니스 연속성을 보장하며, 장애 상황에서 복구 시스템으로 전환된 후 원래 시스템이 복구되면 데이터 손실 없이 정상 운영으로 돌아갈 수 있게 한다.
클라우드 환경에서는 AWS EFS 복제 페일백, VMware vSphere 네트워크 페일백 등 다양한 구현 사례가 존재한다. 2025 년 현재 자동화된 페일백 솔루션과 AI 기반 예측 복구 시스템이 주목받고 있으며, 특히 금융/의료 분야에서 실시간 트랜잭션 보장을 위해 필수적으로 적용되고 있다.
...</p></div><footer class=entry-footer><span title='2025-05-18 12:45:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Failback" href=https://buenhyden.github.io/posts/software-development/distributed-systems/reliability--resilience/recovery-patterns/fallback/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load Shifting</h2></header><div class=entry-content><p>Load Shifting Load Shifting은 컴퓨팅 또는 시스템 워크로드를 효율적으로 관리하고 분배하기 위한 전략으로, 피크 시간대의 부하를 비피크 시간대로 이동시키는 것을 목표로 한다. 이를 통해 리소스 사용을 최적화하고 비용을 절감하며, 시스템의 안정성과 성능을 개선할 수 있다. 이 전략은 클라우드 컴퓨팅, 데이터 센터 운영, 그리고 대규모 분산 시스템에서 널리 사용된다.
로드 시프팅(Load Shifting)의 개념 로드 시프팅은 시스템 부하를 효율적으로 관리하는 전략으로, 피크 시간대의 작업 부하를 비피크 시간대로 이동시켜 자원 활용을 최적화하는 방법이다. 이는 마치 전기 그리드에서 전력 수요가 낮은 시간대로 소비를 옮기는 것과 유사한 개념으로, IT 인프라에 적용된다.
...</p></div><footer class=entry-footer><span title='2025-04-01 15:17:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Load Shifting" href=https://buenhyden.github.io/posts/computer-science/advanced-networking/performance-optimization/traffic-management/load-shifting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenID Connect</h2></header><div class=entry-content><p>OpenID Connect (OIDC) OpenID Connect(OIDC)는 웹 기반 애플리케이션과 서비스를 위한 현대적인 인증 프로토콜로, OAuth 2.0 프레임워크를 기반으로 구축되었다. 이 프로토콜은 사용자의 신원을 검증하고, 안전하게 정보를 교환하는 표준화된 방법을 제공한다.
OIDC의 역사와 배경 OpenID Connect는 기존 OpenID 2.0의 한계를 극복하기 위해 2014년에 공식적으로 출시되었다. OpenID Foundation이 개발한 이 프로토콜은 인증(Authentication)에 중점을 두고, OAuth 2.0의 권한 부여(Authorization) 기능을 보완한다.
초기 웹에서는 각 서비스마다 독립적인 사용자 계정과 인증 시스템이 필요했다. 이러한 분산된 접근 방식은 사용자에게 불편함을 주고, 보안 위험을 증가시켰다. OpenID Connect는 이러한 문제를 해결하기 위해 등장했으며, 현재 Google, Microsoft, Facebook 등 주요 기술 기업들이 이 표준을 채택하고 있다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:28:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to OpenID Connect" href=https://buenhyden.github.io/posts/computer-science/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SAML</h2></header><div class=entry-content><p>SAML SAML(Security Assertion Markup Language)은 기업과 조직에서 단일 로그인(SSO, Single Sign-On)과 신원 연합(Identity Federation)을 구현하기 위한 XML 기반 표준 프레임워크이다. 이 강력한 인증 기술은 현대 기업 환경에서 사용자 인증 및 권한 관리를 간소화하는 핵심 요소로 자리 잡았다.
SAML의 기본 개념 SAML은 2002년 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 처음 표준화되었으며, 현재는 SAML 2.0 버전(2005년 발표)이 가장 널리 사용되고 있다.
이 프로토콜의 주요 목적은 다음과 같다:
단일 로그인(SSO) 구현: 사용자가 한 번만 인증하여 여러 애플리케이션에 접근할 수 있도록 한다. 신원 정보 교환: 신원 공급자(IdP)와 서비스 공급자(SP) 간에 인증 정보를 안전하게 교환한다. 권한 부여 결정: 사용자의 접근 권한에 대한 정보를 전달한다. SAML의 주요 구성 요소 SAML 생태계는 다음 세 가지 주요 구성 요소로 이루어져 있다:
...</p></div><footer class=entry-footer><span title='2025-03-11 13:01:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to SAML" href=https://buenhyden.github.io/posts/computer-science/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/saml-2.0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Polling</h2></header><div class=entry-content><p>폴링 메커니즘의 비교 분석: Short Polling, Long Polling, Adaptive Polling, Smart Polling 클라이언트-서버 통신에서 폴링(Polling)은 클라이언트가 서버의 데이터 변경사항을 확인하기 위해 주기적으로 요청을 보내는 기법이다. 다양한 폴링 메커니즘이 존재하며, 각각 고유한 특성과 적합한 사용 환경이 있다.
폴링 메커니즘은 클라이언트-서버 통신에서 중요한 역할을 하며, 각 방식은 특정 상황과 요구사항에 맞게 최적화되어 있다.
Short Polling은 구현이 간단하지만 리소스 사용이 비효율적인 반면, Long Polling은 실시간성을 향상시키지만 서버 리소스 관리에 주의가 필요하다. Adaptive Polling과 Smart Polling은 더 효율적인 리소스 사용을 제공하지만 구현이 복잡하다.
...</p></div><footer class=entry-footer><span title='2025-03-09 02:30:00 +0000 UTC'>March 9, 2025</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Types of Polling" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/hybrid/polling/types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server sent Events</h2></header><div class=entry-content><p>Server Sent Events 서버 전송 이벤트(Server-Sent Events, SSE)는 웹 서버가 클라이언트 브라우저로 데이터를 자동으로 푸시할 수 있게 해주는 웹 기술이다. 전통적인 HTTP 통신에서는 클라이언트가 요청을 보내고 서버가 응답하는 방식이었지만, SSE는 서버가 필요할 때마다 자발적으로 데이터를 전송할 수 있는 단방향 통신 채널을 제공한다.
SSE는 HTML5 표준의 일부로, EventSource API를 통해 구현된다. 이 기술은 기존 HTTP 프로토콜 위에서 작동하며, 특별한 프로토콜 전환 없이 실시간 통신이 가능하다는 장점이 있다.
SSE의 핵심 특징 서버 전송 이벤트는 다음과 같은 주요 특징을 가지고 있다:
...</p></div><footer class=entry-footer><span title='2025-03-08 16:31:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Server sent Events" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/hybrid/sse/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting</h2></header><div class=entry-content><p>Rate Limiting API Rate Limiting은 시스템의 안정성과 보안을 유지하면서 공정한 리소스 분배를 보장하는 핵심 메커니즘이다.
Rate Limiting은 특정 시간 간격 동안 API에 대한 요청 수를 제한하는 기술이다. 쉽게 말해, 사용자나 클라이언트가 특정 시간 동안 보낼 수 있는 요청의 횟수에 상한선을 두는 것이다.
예를 들어, “1분당 최대 60회 요청” 또는 “1시간당 1000회 요청"과 같은 제한을 설정할 수 있다. 이러한 제한을 초과하면 API는 일반적으로 HTTP 429 상태 코드(“Too Many Requests”)를 반환하며 요청을 거부한다.
...</p></div><footer class=entry-footer><span title='2025-02-14 01:27:00 +0000 UTC'>February 14, 2025</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Rate Limiting" href=https://buenhyden.github.io/posts/software-development/performance--scalability/load-management/traffic-control/rate-limiting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Transaction Isolation Levels</h2></header><div class=entry-content><p>Transaction Isolation Levels 트랜잭션 격리 수준 (Transaction Isolation Level) 은 ACID 특성 중 Isolation 을 구현하는 핵심 메커니즘으로, 다중 트랜잭션 환경에서 발생할 수 있는 Dirty Read, Non-repeatable Read, Phantom Read 와 같은 동시성 문제를 제어한다.
ANSI SQL 표준은 Read Uncommitted, Read Committed, Repeatable Read, Serializable 네 단계를 정의하며, 각 수준은 성능과 데이터 일관성 간의 상충 관계를 고려해 선택된다.
실제 DBMS 는 Locking, MVCC, SSI 등의 방식으로 이를 구현하며, PostgreSQL·MySQL·Oracle·SQL Server 등에서 동작 방식이 상이하다.
...</p></div><footer class=entry-footer><span title='2025-02-06 04:52:00 +0000 UTC'>February 6, 2025</span>&nbsp;·&nbsp;<span>65 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Transaction Isolation Levels" href=https://buenhyden.github.io/posts/computer-science/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/page/13/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/page/15/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>