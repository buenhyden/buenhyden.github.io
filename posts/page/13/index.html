<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Posts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Posts"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral</h2></header><div class=entry-content><p>Behavioral Behavioral Design Patterns 는 객체 간 상호작용 방식과 책임 배분 전략을 설계하는 11 가지의 패턴 집합이다. 대표적으로 Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor, Interpreter가 있으며, 각 패턴은 응집도 높은 메시징, 실행 위임, 상태 기반 제어, 알고리즘 분리 등 동작 중심 설계 문제를 해결한다. 실무에서는 이벤트 처리, 명령 큐, 상태 머신, GUI 로직 등에서 널리 활용된다.
배경 GoF(“Gang of Four”) 에서 정의한 23 개 패턴 중 하나로, 객체 간의 협력과 메시지 전달을 정형화하기 위해 등장했다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;<span>23 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Behavioral" href=https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-patterns/gof/behavioral/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Programming Paradigms</h2></header><div class=entry-content><p>Programming Paradigms 아래는 “Programming Paradigms(프로그래밍 패러다임)” 에 대한 체계적이고 심층적인 조사 결과입니다. 요청하신 구조에 맞춰 네 부분으로 나누어 정리하였으며, 각 항목에 대한 상세 내용과 표, 다이어그램, 구현 예시까지 포함하였습니다.
1. 프로그래밍 패러다임 개요 및 분류 핵심 개념
프로그래밍 패러다임 (Programming Paradigm) 은 소프트웨어 개발에서 프로그램을 설계하고 구현하는 방식을 결정하는 기본적인 관점과 방법론을 의미합니다. 이는 개발자가 문제를 해결하는 데 있어 코드를 어떻게 구조화할지, 어떤 원칙을 따를지, 그리고 어떤 추상화 수준을 사용할지에 대한 틀을 제공합니다 13.
...</p></div><footer class=entry-footer><span title='2024-09-22 04:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;<span>81 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Programming Paradigms" href=https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 테이블(Hash Table)</h2></header><div class=entry-content><p>해시 테이블(Hash Table) 해시 테이블은 키(key)와 값(value) 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 키를 배열의 인덱스로 변환해 데이터를 빠르게 삽입, 검색, 삭제할 수 있도록 설계되어 있다.
이 자료구조는 데이터 접근 시간을 평균적으로 O(1)에 가깝게 만들어 효율적인 데이터 관리가 가능하도록 한다.
![Hash table](Introduction-to-Hashing.webp “https://www.geeksforgeeks.org/hashing-data-structure/?ref=outind)
해시 테이블의 기본 개념 해시 테이블은 ‘배열’과 ‘해시 함수’를 결합한 자료구조로 각 데이터 항목이 키와 값으로 구성되며, 이 키를 해시 함수에 입력하여 정수 형태의 해시 값을 산출한 후 배열 내의 특정 인덱스로 매핑하는 방식이다.
이렇게 매핑된 인덱스(버킷 또는 슬롯이라 부름)는 데이터가 저장되는 위치로 활용되며, 단순한 배열 구조를 기반으로 한다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:54:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 해시 테이블(Hash Table)" href=https://buenhyden.github.io/posts/computer-science/hash-based-structures/hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design and Architecture</h2></header><div class=entry-content><p>System Design and Architecture 시스템 디자인 (System Design) 은 복잡한 소프트웨어 시스템의 아키텍처, 구성 요소, 인터페이스, 데이터 흐름 등을 정의하여 안정적이고 확장 가능한 시스템을 구축하는 과정을 의미한다. 분산 아키텍처, 데이터 저장소, 캐싱, 로드 밸런싱, 마이크로서비스 등 다양한 기술과 패턴을 활용하여 확장 가능하고 복원력 있는 시스템을 구축한다. 요구사항 정의부터 실행 가능한 설계까지 체계적인 방법론을 제공한다.
이는 소프트웨어 공학, 컴퓨터 과학, 시스템 엔지니어링 등 다양한 분야와 밀접하게 연관되어 있으며, 대규모 분산 시스템, 클라우드 기반 서비스, IoT(사물인터넷) 등 현대 IT 인프라의 핵심 요소로 자리잡고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 21:24:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;<span>48 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to System Design and Architecture" href=https://buenhyden.github.io/posts/software-development/architecture--design/overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Repo Hosting Services</h2></header><div class=entry-content><p>Repo Hosting Services 저장소 호스팅 서비스는 개발자와 팀이 소스 코드를 저장, 관리, 공유 및 협업할 수 있는 온라인 플랫폼이다. 이 서비스들은 Git, Mercurial, SVN과 같은 버전 관리 시스템을 기반으로 하며, 코드 검토, 이슈 트래킹, CI/CD(지속적 통합/지속적 배포), 문서화 등 다양한 기능을 제공한다.
로컬 저장소와 달리, 원격 저장소를 통해 전 세계 개발자와 실시간으로 협업할 수 있고, 대규모 프로젝트 관리와 자동화된 배포 환경을 구축할 수 있다.
이러한 서비스들은 오픈 소스 프로젝트부터 엔터프라이즈급 소프트웨어 개발까지 다양한 규모의 프로젝트를 지원하며, 현대 소프트웨어 개발 방법론과 DevOps 관행을 촉진하는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-12-29 01:05:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Repo Hosting Services" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/repo-hosting-services/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server</h2></header><div class=entry-content><p>Web Application Server 웹 애플리케이션 서버(Web Application Server, WAS)는 웹 애플리케이션의 실행 환경을 제공하고, 동적인 콘텐츠를 처리하며, 데이터베이스와의 연동을 지원하는 소프트웨어 프레임워크이다.
WAS는 웹 서버와 함께 사용되며, 주로 HTTP 프로토콜을 통해 클라이언트 요청을 처리한다.
WAS는 현대적인 웹 애플리케이션 개발과 운영에서 필수적인 요소이다. 특히 데이터베이스와 연동하여 동적인 콘텐츠를 생성하고 복잡한 비즈니스 로직을 처리하는 데 강점을 가진다. 효율적인 시스템 설계를 위해 일반적으로 웹 서버와 함께 사용되며, 이를 통해 성능 최적화와 보안 강화가 가능하다.
...</p></div><footer class=entry-footer><span title='2024-10-21 15:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Web Application Server" href=https://buenhyden.github.io/posts/software-development/system-components/application--execution-core/web-application-servers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백트래킹 (Backtracking)</h2></header><div class=entry-content><p>백트래킹 (Backtracking) 백트래킹은 해결책을 찾는 과정에서 후보군을 구축하다가 해당 후보군이 해결책이 될 수 없다고 판단되면, 즉시 이전 단계로 돌아가서(백트랙) 다른 후보군을 탐색하는 문제 해결 전략이다.
알고리즘의 효율성을 높이는 중요한 기법으로, 완전 탐색보다 효율적으로 문제를 해결할 수 있게 해준다.
백트래킹은 조합 최적화 문제를 해결하는 강력한 알고리즘 패러다임이다.
모든 가능한 해결책을 체계적으로 탐색하면서도, 불가능한 경로를 조기에 차단하여 효율성을 높이는 특징이 있다.
N-Queen, 스도쿠, 미로 찾기, 조합 문제 등 다양한 영역에서 활용되며, 복잡한 문제를 해결하는 데 필수적인 도구이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 백트래킹 (Backtracking)" href=https://buenhyden.github.io/posts/computer-science/specialized-techniques/advanced-problem-solving/back-tracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분기 한정법 (Branch and Bound)</h2></header><div class=entry-content><p>분기 한정법 (Branch and Bound) 분기한정법(Branch and Bound)은 최적화 문제를 해결하기 위한 효율적인 알고리즘 설계 패러다임이다.
이 방법은 거대한, 때로는 지수적으로 큰 해공간을 체계적으로 탐색하면서 최적해를 찾아내는 강력한 기법이다.
분기한정법은 다양한 최적화 문제를 해결하기 위한 강력하고 유연한 알고리즘 패러다임이다.
이 방법의 핵심은 문제를 체계적으로 나누고, 각 하위 문제의 한계값을 계산하여 유망하지 않은 경로를 가지치기함으로써 탐색 공간을 효과적으로 줄이는 데 있다.
분기한정법은 외판원 문제, 배낭 문제, 작업 할당 문제 등 다양한 NP-hard 최적화 문제에 성공적으로 적용되어 왔다.
물론 최악의 경우에는 여전히 지수 시간이 필요하지만, 효과적인 한계 함수와 가지치기 전략을 통해 실용적인 시간 내에 최적해 또는 근사 최적해를 찾을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 분기 한정법 (Branch and Bound)" href=https://buenhyden.github.io/posts/computer-science/specialized-techniques/advanced-problem-solving/branch-and-bound/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분할 정복 (Divide and Conquer)</h2></header><div class=entry-content><p>분할 정복 (Divide and Conquer) 분할 정복은 알고리즘 설계에서 가장 강력하고 널리 사용되는 패러다임 중 하나이다.
복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 이 접근법은 효율적인 알고리즘 설계의 핵심 원리이다.
정의와 원리 분할 정복(Divide and Conquer)은 복잡한 문제를 다음과 같은 세 단계로 해결하는 알고리즘 설계 기법이다:
분할(Divide): 원래 문제를 같은 유형의 더 작은 하위 문제들로 나눈다. 정복(Conquer): 하위 문제들을 재귀적으로 해결한다. 하위 문제가 충분히 작으면 직접 해결한다. 결합(Combine): 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 만든다. 분할 정복은 재귀적 사고에 기반하며, 큰 문제를 동일한 형태의 작은 문제들로 축소하여 해결하는 방식이다.
이 과정은 문제가 충분히 작아질 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;<span>17 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 분할 정복 (Divide and Conquer)" href=https://buenhyden.github.io/posts/computer-science/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker vs. Message Broker</h2></header><div class=entry-content><p>Event Broker vs. Message Broker 이벤트 브로커와 메시지 브로커는 현대 분산 시스템에서 핵심적인 미들웨어로, 서비스 간 결합도를 낮추고 확장성, 신뢰성, 실시간성, 장애 복원력을 제공한다. 이벤트 브로커는 Pub/Sub, 이벤트 스트리밍, 실시간 데이터 분배에 최적화되어 있으며, 메시지 브로커는 큐잉, 복잡한 라우팅, 포맷 변환, 트랜잭션 등 엔터프라이즈 통합에 강점을 보인다. 두 기술은 아키텍처, 메시징 패턴, 처리 방식, 주요 기능 등에서 차이가 있으며, 실제 환경에서는 요구사항에 따라 혼합 적용되기도 한다.
핵심 개념 메시지 브로커는 작업 처리와 안정성 중심의 통신에 적합하며, 명령 (Command), 요청 - 응답, 복잡한 라우팅이 필요한 경우에 효과적이다. 이벤트 브로커는 실시간 스트리밍, 이벤트 소싱, 이벤트 기반 데이터 흐름이 중심인 아키텍처에 최적화되어 있다. 양자 모두 분산 시스템에서의 decoupling, 비동기성, 확장성 확보에 필수적인 미들웨어이며, 도메인/업무의 특성에 따라 적절히 선택하거나 병행하여 사용하는 것이 권장된다. 항목 Event Broker (이벤트 브로커) Message Broker (메시지 브로커) 기본 정의 시스템 내에서 발생한 이벤트를 토픽 기반 Pub/Sub 모델로 중계 및 브로드캐스트하는 미들웨어 송신자와 수신자 간의 메시지를 큐 기반 Point-to-Point 방식으로 중개 및 전달하는 미들웨어 기반 모델 Log 기반, Publish-Subscribe 모델 Queue 기반, Routing 기반 (Direct, Topic, Fanout, Headers) 메시지 처리 방식 여러 구독자가 동일 이벤트를 동시에 소비 가능 (1:N, N:N 확장에 유리) 메시지를 수신한 단일 소비자가 처리 (1:1 또는 Load Balancing 처리) 용도 중심성 상태 변화, 알림, 데이터 변경 전파 등 이벤트 스트리밍 중심 (Event-based) 작업 명령, 요청 처리, 커맨드 전송 중심 (Command-based) 재처리 및 리텐션 로그 기반으로 이벤트 보존 가능 (리텐션/압축 설정), 이벤트 재처리 및 타임 트래블 가능 일반적으로 메시지 소비 후 삭제, 재처리는 DLQ 기반 처리 주요 특징 실시간 이벤트 스트리밍, 대용량 데이터 브로드캐스트, 이벤트 소싱 및 추적 가능 신뢰성 높은 메시지 전달, 메시지 포맷 변환, 복잡한 라우팅 지원 대표 구현체 Apache Kafka, Apache Pulsar, Amazon EventBridge, Azure Event Grid, Solace PubSub+ RabbitMQ, Apache ActiveMQ, IBM MQ, Amazon SQS Event Broker vs. Message Broker 비교 이벤트 브로커와 메시지 브로커는 모두 메시지 기반의 비동기 통신 미들웨어이다. 하지만 이벤트 중심 (Event-Driven Architecture) 과 메시지 큐잉 및 라우팅 (Queueing & Routing) 이라는 핵심 원칙과 동작 방식의 차이가 있다.
...</p></div><footer class=entry-footer><span title='2025-07-18 05:55:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;<span>33 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Event Broker vs. Message Broker" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-brokers-vs-event-brokers/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/page/12/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/page/14/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>