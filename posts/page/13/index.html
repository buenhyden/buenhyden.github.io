<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Posts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Posts"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>연결 리스트 (Linked List)</h2></header><div class=entry-content><p>연결 리스트 (Linked List) 연결 리스트(Linked List)는 노드(Node)들의 연결을 통해 데이터를 저장하는 동적 자료구조이다.
각 노드는 데이터(Data)와 다음 노드를 가리키는 포인터(Next)로 구성되며, 필요에 따라 동적으로 크기를 조절할 수 있다.
배열과 달리 메모리의 연속적인 공간을 요구하지 않으며, 삽입/삭제 연산이 효율적이다.
연결 리스트는 유연한 메모리 관리와 효율적인 삽입/삭제 연산으로 인해 다양한 응용 분야에서 활용되는 중요한 데이터 구조이다. 배열에 비해 특정 위치 접근이 느리지만, 동적 크기 조정과 삽입/삭제 연산의 효율성은 큰 장점이다.
다양한 형태(단일, 이중, 원형)와 최적화 기법(센티넬 노드, 런너 기법 등)을 적절히, 활용하면 복잡한 문제도 효율적으로 해결할 수 있다. 특히 스택, 큐, 해시 테이블, 그래프 등 다른 자료구조의 구현에도 널리 사용되어 알고리즘과 데이터 구조를 이해하는 데 필수적인 개념이다.
...</p></div><footer class=entry-footer><span title='2024-10-07 05:53:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 연결 리스트 (Linked List)" href=https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/arrays--lists/linked-lists/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral</h2></header><div class=entry-content><p>Behavioral Behavioral Design Patterns 는 객체 간 상호작용 방식과 책임 배분 전략을 설계하는 11 가지의 패턴 집합이다. 대표적으로 Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor, Interpreter가 있으며, 각 패턴은 응집도 높은 메시징, 실행 위임, 상태 기반 제어, 알고리즘 분리 등 동작 중심 설계 문제를 해결한다. 실무에서는 이벤트 처리, 명령 큐, 상태 머신, GUI 로직 등에서 널리 활용된다.
배경 GoF(“Gang of Four”) 에서 정의한 23 개 패턴 중 하나로, 객체 간의 협력과 메시지 전달을 정형화하기 위해 등장했다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;<span>23 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Behavioral" href=https://buenhyden.github.io/posts/software-development/fundamentals/programming-principles/design-patterns/gof/behavioral/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Programming Paradigms</h2></header><div class=entry-content><p>Programming Paradigms 아래는 “Programming Paradigms(프로그래밍 패러다임)” 에 대한 체계적이고 심층적인 조사 결과입니다. 요청하신 구조에 맞춰 네 부분으로 나누어 정리하였으며, 각 항목에 대한 상세 내용과 표, 다이어그램, 구현 예시까지 포함하였습니다.
1. 프로그래밍 패러다임 개요 및 분류 핵심 개념
프로그래밍 패러다임 (Programming Paradigm) 은 소프트웨어 개발에서 프로그램을 설계하고 구현하는 방식을 결정하는 기본적인 관점과 방법론을 의미합니다. 이는 개발자가 문제를 해결하는 데 있어 코드를 어떻게 구조화할지, 어떤 원칙을 따를지, 그리고 어떤 추상화 수준을 사용할지에 대한 틀을 제공합니다 13.
...</p></div><footer class=entry-footer><span title='2024-09-22 04:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;<span>81 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Programming Paradigms" href=https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 테이블(Hash Table)</h2></header><div class=entry-content><p>해시 테이블(Hash Table) 해시 테이블은 키(key)와 값(value) 쌍을 저장하는 자료구조로, 해시 함수를 사용하여 키를 배열의 인덱스로 변환해 데이터를 빠르게 삽입, 검색, 삭제할 수 있도록 설계되어 있다.
이 자료구조는 데이터 접근 시간을 평균적으로 O(1)에 가깝게 만들어 효율적인 데이터 관리가 가능하도록 한다.
![Hash table](Introduction-to-Hashing.webp “https://www.geeksforgeeks.org/hashing-data-structure/?ref=outind)
해시 테이블의 기본 개념 해시 테이블은 ‘배열’과 ‘해시 함수’를 결합한 자료구조로 각 데이터 항목이 키와 값으로 구성되며, 이 키를 해시 함수에 입력하여 정수 형태의 해시 값을 산출한 후 배열 내의 특정 인덱스로 매핑하는 방식이다.
이렇게 매핑된 인덱스(버킷 또는 슬롯이라 부름)는 데이터가 저장되는 위치로 활용되며, 단순한 배열 구조를 기반으로 한다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:54:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 해시 테이블(Hash Table)" href=https://buenhyden.github.io/posts/computer-science/hash-based-structures/hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design and Architecture</h2></header><div class=entry-content><p>System Design and Architecture 시스템 디자인 (System Design) 은 복잡한 소프트웨어 시스템의 아키텍처, 구성 요소, 인터페이스, 데이터 흐름 등을 정의하여 안정적이고 확장 가능한 시스템을 구축하는 과정을 의미한다. 분산 아키텍처, 데이터 저장소, 캐싱, 로드 밸런싱, 마이크로서비스 등 다양한 기술과 패턴을 활용하여 확장 가능하고 복원력 있는 시스템을 구축한다. 요구사항 정의부터 실행 가능한 설계까지 체계적인 방법론을 제공한다.
이는 소프트웨어 공학, 컴퓨터 과학, 시스템 엔지니어링 등 다양한 분야와 밀접하게 연관되어 있으며, 대규모 분산 시스템, 클라우드 기반 서비스, IoT(사물인터넷) 등 현대 IT 인프라의 핵심 요소로 자리잡고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 21:24:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;<span>48 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to System Design and Architecture" href=https://buenhyden.github.io/posts/software-development/architecture--design/overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Repo Hosting Services</h2></header><div class=entry-content><p>Repo Hosting Services 저장소 호스팅 서비스는 개발자와 팀이 소스 코드를 저장, 관리, 공유 및 협업할 수 있는 온라인 플랫폼이다. 이 서비스들은 Git, Mercurial, SVN과 같은 버전 관리 시스템을 기반으로 하며, 코드 검토, 이슈 트래킹, CI/CD(지속적 통합/지속적 배포), 문서화 등 다양한 기능을 제공한다.
로컬 저장소와 달리, 원격 저장소를 통해 전 세계 개발자와 실시간으로 협업할 수 있고, 대규모 프로젝트 관리와 자동화된 배포 환경을 구축할 수 있다.
이러한 서비스들은 오픈 소스 프로젝트부터 엔터프라이즈급 소프트웨어 개발까지 다양한 규모의 프로젝트를 지원하며, 현대 소프트웨어 개발 방법론과 DevOps 관행을 촉진하는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-12-29 01:05:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Repo Hosting Services" href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/repo-hosting-services/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server</h2></header><div class=entry-content><p>Web Application Server 웹 애플리케이션 서버(Web Application Server, WAS)는 웹 애플리케이션의 실행 환경을 제공하고, 동적인 콘텐츠를 처리하며, 데이터베이스와의 연동을 지원하는 소프트웨어 프레임워크이다.
WAS는 웹 서버와 함께 사용되며, 주로 HTTP 프로토콜을 통해 클라이언트 요청을 처리한다.
WAS는 현대적인 웹 애플리케이션 개발과 운영에서 필수적인 요소이다. 특히 데이터베이스와 연동하여 동적인 콘텐츠를 생성하고 복잡한 비즈니스 로직을 처리하는 데 강점을 가진다. 효율적인 시스템 설계를 위해 일반적으로 웹 서버와 함께 사용되며, 이를 통해 성능 최적화와 보안 강화가 가능하다.
...</p></div><footer class=entry-footer><span title='2024-10-21 15:55:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Web Application Server" href=https://buenhyden.github.io/posts/software-development/system-components/application--execution-core/web-application-servers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백트래킹 (Backtracking)</h2></header><div class=entry-content><p>백트래킹 (Backtracking) 백트래킹은 해결책을 찾는 과정에서 후보군을 구축하다가 해당 후보군이 해결책이 될 수 없다고 판단되면, 즉시 이전 단계로 돌아가서(백트랙) 다른 후보군을 탐색하는 문제 해결 전략이다.
알고리즘의 효율성을 높이는 중요한 기법으로, 완전 탐색보다 효율적으로 문제를 해결할 수 있게 해준다.
백트래킹은 조합 최적화 문제를 해결하는 강력한 알고리즘 패러다임이다.
모든 가능한 해결책을 체계적으로 탐색하면서도, 불가능한 경로를 조기에 차단하여 효율성을 높이는 특징이 있다.
N-Queen, 스도쿠, 미로 찾기, 조합 문제 등 다양한 영역에서 활용되며, 복잡한 문제를 해결하는 데 필수적인 도구이다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 백트래킹 (Backtracking)" href=https://buenhyden.github.io/posts/computer-science/specialized-techniques/advanced-problem-solving/back-tracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분기 한정법 (Branch and Bound)</h2></header><div class=entry-content><p>분기 한정법 (Branch and Bound) 분기한정법(Branch and Bound)은 최적화 문제를 해결하기 위한 효율적인 알고리즘 설계 패러다임이다.
이 방법은 거대한, 때로는 지수적으로 큰 해공간을 체계적으로 탐색하면서 최적해를 찾아내는 강력한 기법이다.
분기한정법은 다양한 최적화 문제를 해결하기 위한 강력하고 유연한 알고리즘 패러다임이다.
이 방법의 핵심은 문제를 체계적으로 나누고, 각 하위 문제의 한계값을 계산하여 유망하지 않은 경로를 가지치기함으로써 탐색 공간을 효과적으로 줄이는 데 있다.
분기한정법은 외판원 문제, 배낭 문제, 작업 할당 문제 등 다양한 NP-hard 최적화 문제에 성공적으로 적용되어 왔다.
물론 최악의 경우에는 여전히 지수 시간이 필요하지만, 효과적인 한계 함수와 가지치기 전략을 통해 실용적인 시간 내에 최적해 또는 근사 최적해를 찾을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;<span>13 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 분기 한정법 (Branch and Bound)" href=https://buenhyden.github.io/posts/computer-science/specialized-techniques/advanced-problem-solving/branch-and-bound/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분할 정복 (Divide and Conquer)</h2></header><div class=entry-content><p>분할 정복 (Divide and Conquer) 분할 정복은 알고리즘 설계에서 가장 강력하고 널리 사용되는 패러다임 중 하나이다.
복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 이 접근법은 효율적인 알고리즘 설계의 핵심 원리이다.
정의와 원리 분할 정복(Divide and Conquer)은 복잡한 문제를 다음과 같은 세 단계로 해결하는 알고리즘 설계 기법이다:
분할(Divide): 원래 문제를 같은 유형의 더 작은 하위 문제들로 나눈다. 정복(Conquer): 하위 문제들을 재귀적으로 해결한다. 하위 문제가 충분히 작으면 직접 해결한다. 결합(Combine): 하위 문제들의 해결책을 결합하여 원래 문제의 해결책을 만든다. 분할 정복은 재귀적 사고에 기반하며, 큰 문제를 동일한 형태의 작은 문제들로 축소하여 해결하는 방식이다.
이 과정은 문제가 충분히 작아질 때까지 계속된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;<span>17 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 분할 정복 (Divide and Conquer)" href=https://buenhyden.github.io/posts/computer-science/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/page/12/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/page/14/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>