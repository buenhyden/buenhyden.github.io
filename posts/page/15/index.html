<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Posts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Posts"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API key authentication</h2></header><div class=entry-content><p>API key authentication API 키와 API 관리는 현대 소프트웨어 아키텍처의 핵심 요소로, 조직이 디지털 자산을 안전하게 공유하고 모니터링하는 데 필수적이다.
API 키의 이해 API 키의 정의와 목적 API 키는 API에 접근하려는 클라이언트를 식별하고 인증하는 데 사용되는 고유한 문자열이다.
주요 목적은 다음과 같다:
인증(Authentication): 요청자가 누구인지 확인 권한 부여(Authorization): 요청자가 특정 리소스에 접근할 권한이 있는지 확인 사용량 추적: 각 클라이언트의 API 사용량 모니터링 속도 제한(Rate Limiting): 단일 클라이언트의 과도한 요청 방지 오용 방지: 무단 접근 및 악의적인 사용 차단 API 키의 구조와 형식 일반적인 API 키는 다음과 같은 특성을 갖는다:
...</p></div><footer class=entry-footer><span title='2025-02-01 03:24:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;<span>57 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to API key authentication" href=https://buenhyden.github.io/posts/software-development/application-security/api-security/api-gateway-security/api-keys/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Types</h2></header><div class=entry-content><p>Data Types Python은 동적 타입 언어로, 변수를 선언할 때 명시적으로 타입을 지정할 필요가 없다.
하지만 각 데이터 타입을 이해하는 것은 효율적인 코딩과 디버깅에 필수적이다.
숫자형 (Numeric) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 정수형 (Integer): 양의 정수, 음의 정수, 0을 포함하는 숫자형 age = 25 population = 1000000000000 # Python3는 정수 크기 제한이 없습니다 print(type(age)) # &lt;class 'int'> print(type(population)) # &lt;class 'int'> # 부동소수점 (Float): 소수점을 포함하는 숫자형 height = 175.5 pi = 3.14159 print(type(height)) # &lt;class 'float'> print(type(pi)) # &lt;class 'float'> # 복소수 (Complex): 실수부와 허수부로 구성된 숫자형 complex_number = 3 + 4j print(complex_number.real) # 실수부: 3.0 print(complex_number.imag) # 허수부: 4.0 print(type(complex_number)) # &lt;class 'complex'> 문자열 (str) 문자들의 집합으로, 작은따옴표(’’)나 큰따옴표("")로 감싸서 표현한다.
...</p></div><footer class=entry-footer><span title='2024-12-24 11:05:00 +0000 UTC'>December 24, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Data Types" href=https://buenhyden.github.io/posts/software-development/python/getting-started/data-types-and-structures/data-types/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NP-난해(NP-Hard)</h2></header><div class=entry-content><p>NP-난해(NP-Hard) NP-Hard(NP-난해)는 계산 복잡도 이론에서 가장 중요한 개념 중 하나로, 문제의 난이도를 분류하는 방법을 제공한다.
이 개념은 개발자가 어떤 문제가 본질적으로 어려운지, 효율적인 해결책을 기대할 수 있는지 이해하는 데 도움이 된다.
NP-Hard 문제는 컴퓨터 과학과 실제 응용 분야에서 중요한 위치를 차지하고 있다.
비록 다항 시간 알고리즘으로 정확하게 해결하는 것은 어렵지만, 다양한 접근 방법을 통해 실용적인 해결책을 찾을 수 있다.
IT 개발자로서 NP-Hard 문제를 효과적으로 다루는 것은 중요한 기술이다. 문제의 구조를 이해하고, 적절한 알고리즘을 선택하며, 실용적인 트레이드오프를 고려하는 능력은 복잡한 시스템을 설계하고 최적화하는 데 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-12-12 14:29:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NP-난해(NP-Hard)" href=https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/completeness-theory/np-hard/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django</h2></header><div class=entry-content><p>Python Django Django는 파이썬으로 작성된 강력한 웹 프레임워크로, 빠르고 안전하며 확장 가능한 웹 애플리케이션을 개발할 수 있게 해준다. 2005년에 처음 출시된 이후 지속적으로 발전하며 오늘날 많은 대형 웹사이트의 백엔드로 사용되고 있다.
Django의 핵심 철학 Django는 “배터리 포함(Batteries Included)” 철학을 따른다. 이는 웹 개발에 필요한 대부분의 기능이 프레임워크에 이미 포함되어 있다는 의미이다. 또한 DRY(Don’t Repeat Yourself) 원칙을 중요시하며, 코드 재사용성을 높이고 반복을 줄이는 데 중점을 둔다.
장점 빠른 개발: 관리자 인터페이스와 ORM을 통해 빠른 개발이 가능하다. 보안: 다양한 보안 기능이 내장되어 있어 안전한 웹 애플리케이션 개발이 가능하다. 확장성: 다양한 서드파티 패키지를 통해 기능을 확장할 수 있다. 문서화: 풍부한 문서와 커뮤니티 지원을 받을 수 있다. 단점 모놀리식 구조: 작은 프로젝트에는 과도할 수 있다. 성능 이슈: ORM 사용 시 복잡한 쿼리에서 성능 문제가 발생할 수 있다. 학습 곡선: 초보자에게는 학습 곡선이 있을 수 있다. 실시간 처리: WebSocket 등의 실시간 기능은 추가 패키지 필요 Django의 아키텍처: MTV 패턴 Django는 MVC(Model-View-Controller) 패턴의 변형인 MTV(Model-Template-View) 패턴을 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-29 02:57:00 +0000 UTC'>November 29, 2024</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Django" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/web-frameworks/django/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>FastAPI</h2></header><div class=entry-content><p>Python FastAPI FastAPI는 2018년에 Sebastián Ramírez가 개발한 현대적인 Python 웹 프레임워크.
Python 3.6+ 의 타입 힌트를 기반으로 하며, 비동기 프로그래밍을 지원하는 고성능 웹 프레임워크.****
주요 개념 타입 힌트: FastAPI는 파이썬의 타입 힌트를 적극적으로 활용하여 코드의 안정성과 가독성을 높인다. 비동기 프로그래밍: Starlette을 기반으로 하여 비동기 프로그래밍을 지원한다. 의존성 주입: 코드의 재사용성을 높이고 결합도를 낮추는 의존성 주입 시스템을 제공한다. Pydantic: 데이터 검증과 설정 관리를 위한 Pydantic 라이브러리를 사용한다. 특징 빠른 성능: Starlette과 Pydantic을 기반으로 하여 NodeJS 및 Go와 대등한 수준의 높은 성능을 제공한다. 자동 문서화: Swagger UI와 ReDoc을 통해 API 문서를 자동으로 생성한다. 표준 기반: OpenAPI와 JSON Schema를 기반으로 한다. 쉬운 사용성: 직관적인 API로 빠른 개발이 가능하다. 장점 빠른 개발 속도: 간결한 문법과 자동 문서화 기능으로 개발 속도가 빠르다. 높은 성능: 비동기 지원과 최적화된 코드로 높은 성능을 제공한다. 타입 안정성: 파이썬의 타입 힌트를 활용하여 코드의 안정성을 높인다. 현대적인 기능: 비동기 처리, 의존성 주입, 자동 검증 등 현대적인 기능을 지원한다. 단점 상대적으로 작은 커뮤니티: 새로운 프레임워크이기 때문에 Django나 Flask에 비해 커뮤니티가 작다. 학습 곡선: 비동기 프로그래밍, 타입 힌트 등 현대적인 파이썬 개념에 익숙하지 않은 개발자에게는 학습 곡선이 있을 수 있다. 성숙도: 아직 1.0 버전이 출시되지 않아 안정성 면에서 우려가 있을 수 있다. 개발 특성 모듈화: 앱 단위로 프로젝트를 구성하여 모듈화된 개발이 가능하다. RESTful API 개발: API 서버 구축에 최적화되어 있다. 마이크로서비스: 독립적인 서비스 컴포넌트 개발에 유용하다. 성능과 기능 고성능: 비동기 처리와 최적화된 코드로 높은 성능을 제공한다. 데이터 검증: Pydantic을 통한 강력한 데이터 검증 기능을 제공한다. 보안: 내장된 보안 기능으로 SQL 인젝션, CSRF, XSS 등 다양한 보안 위협에 대응한다. 확장성: 다양한 미들웨어와 확장 기능을 지원한다. 서버 구현 예제 1 2 3 4 5 6 7 8 9 10 11 from fastapi import FastAPI app = FastAPI() @app.get("/") async def root(): return {"message": "Hello World"} @app.get("/items/{item_id}") async def read_item(item_id: int, q: str = None): return {"item_id": item_id, "q": q} 이 예제는 루트 경로와 아이템 ID를 받는 두 개의 엔드포인트를 정의한다.
...</p></div><footer class=entry-footer><span title='2024-11-29 02:56:00 +0000 UTC'>November 29, 2024</span>&nbsp;·&nbsp;<span>21 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to FastAPI" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/web-frameworks/fastapi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Linter와 Formatter</h2></header><div class=entry-content><p>Python Linter와 Formatter Linter와 Formatter는 코드의 품질과 일관성을 유지하는 데 필수적인 도구.
Linter는 코드의 잠재적인 에러, 버그, 스타일 문제, 그리고 의심스러운 구조들을 찾아내는 도구.
마치 교정 편집자가 글의 문법과 표현을 검토하는 것처럼, Linter는 코드의 품질을 검사한다.
주요 기능:
구문 오류 감지 코딩 스타일 검사 잠재적 버그 발견 코드 복잡도 분석 베스트 프랙티스 제안 보안 취약점 식별 성능 문제 파악 장점:
코드 품질 향상 일관된 코딩 스타일 유지 버그 조기 발견 단점:
...</p></div><footer class=entry-footer><span title='2024-11-28 13:46:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Python Linter와 Formatter" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/testing-and-quality/linter-and-formatter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ASGI vs CGI vs WSGI</h2></header><div class=entry-content><p>ASGI CGI WSGI 비교 분석 이 기술들은 웹 서버와 애플리케이션 간의 통신 방식을 정의하는 인터페이스 규격.
시대 순으로 발전 과정을 이해하면 좋을 것 같다.
ASGI CGI WSGI 비교 특징 CGI WSGI ASGI 등장 시기 1990년대 초반 2003년 (PEP 333) 2016년 처리 방식 프로세스 기반 동기식 비동기식 성능 매 요청마다 새 프로세스 생성 (낮음) 프로세스 재사용 (중간) 비동기 처리로 높은 성능 프로토콜 지원 HTTP/1.0 HTTP/1.1 HTTP/1.1, HTTP/2, WebSocket 구현 복잡도 단순함 중간 상대적으로 복잡함 메모리 사용 높음 (프로세스당) 중간 효율적 동시성 처리 프로세스 기반 스레드/프로세스 기반 이벤트 루프 기반 주요 사용 사례 레거시 시스템 전통적인 웹 애플리케이션 현대적 웹 애플리케이션 환경 변수 처리 시스템 환경 변수 environ 딕셔너리 scope 딕셔너리 스트리밍 지원 제한적 이터레이터 기반 네이티브 지원 프레임워크 예시 직접 구현 Django, Flask FastAPI, Starlette 서버 예시 Apache gunicorn, uWSGI uvicorn, daphne 오류 처리 제한적 표준화된 방식 포괄적 지원 설정 복잡도 간단 중간 상대적으로 복잡 확장성 제한적 중간 높음 각 기술의 기본적인 구현 예제 CGI (Common Gateway Interface):
...</p></div><footer class=entry-footer><span title='2024-11-28 03:26:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to ASGI vs CGI vs WSGI" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/gateway-interface/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Poetry</h2></header><div class=entry-content><p>Poetry Python 프로젝트의 의존성 관리와 패키징을 위한 도구. 특징 의존성 관리: pyproject.toml 파일을 사용하여 프로젝트의 의존성을 선언적으로 관리. 의존성 해결 및 버전 충돌 방지를 자동으로 처리. poetry.lock 파일을 통해 정확한 패키지 버전을 고정하여 일관된 환경을 보장. 가상 환경 관리: 프로젝트별로 독립된 가상 환경을 자동으로 생성하고 관리. 패키지 관리: 패키지 추가, 제거, 업데이트를 간단한 명령어로 수행 가능. 프로젝트 빌드 및 배포: 프로젝트 빌드와 PyPI 배포를 쉽게 할 수 있는 기능 제공. 사용 편의성: pip, virtualenv, setuptools 등 여러 도구의 통합 지원. 호환성: PEP 517 및 PEP 518 표준을 준수 PEP 517
...</p></div><footer class=entry-footer><span title='2024-11-27 13:46:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Poetry" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/package-management/poetry/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PEP</h2></header><div class=entry-content><p>PEP (Python Enhancement Proposal) 파이썬 언어의 새로운 기능, 라이브러리 개선, 스타일 가이드 등에 관한 제안을 문서화한 것.
PEP는 파이썬 커뮤니티가 파이썬 언어를 개선하기 위해 아이디어를 공유하고 논의하는 공식적인 수단으로, Python Software Foundation(PSF)에 의해 관리된다.
PEP Types 해당 PEP의 목적과 성격을 나타낸다.
약어 유형 설명 예시 PEP 번호 및 제목 I Informational 파이썬 생태계와 관련된 배경, 가이드라인 또는 기타 정보를 제공하는 비규범적(non-normative) PEP입니다. PEP 20 - The Zen of Python P Process 파이썬 커뮤니티의 프로세스, 워크플로우 또는 거버넌스에 대한 변경을 설명하거나 제안하는 규범적(normative) PEP입니다. PEP 1 - PEP Purpose and Guidelines S Standards Track 파이썬에 새로운 기능을 추가하거나, CPython의 구현 변경 또는 생태계의 상호운용 표준을 제안하는 규범적 PEP입니다. PEP 484 - Type Hints PEP Status 약어 상태 설명 A Accepted 구현을 위해 수락된 규범적 제안입니다. A Active 현재 유효한 정보 제공 지침이거나 사용 중인 프로세스입니다. D Deferred 현재는 비활성 상태이지만, 추후 다시 논의될 수 있는 초안입니다. Draft 현재 활발히 논의 및 수정 중인 제안입니다. F Final 수락되어 구현이 완료되었거나 더 이상 활성 상태가 아닌 제안입니다. P Provisional 잠정적으로 수락되었지만 추가적인 피드백이 필요한 상태입니다. R Rejected 공식적으로 거부되어 수락되지 않을 제안입니다. S Superseded 다른 후속 PEP에 의해 대체된 제안입니다. W Withdrawn 제안자나 저자에 의해 고려 대상에서 제외된 제안입니다. 주요 PEP 종류 PEP 제목 유형 상태 주요 내용 적용 버전 8 Style Guide for Python Code Style Guide Active Python 코드 스타일 가이드 모든 버전 20 The Zen of Python Informational Active Python 설계 철학 2.0+ 257 Docstring Conventions Informational Active 문서화 문자열 규칙 모든 버전 405 Python Virtual Environments Standards Track Final 가상 환경 생성 및 관리 3.3+ 443 Single-dispatch Generic Functions Standards Track Final 인자 타입별 함수 오버로딩 3.4+ 484 Type Hints Standards Track Final 타입 힌트 문법 3.5+ 3000 Python 3000 Informational Final Python 3.0 개발 가이드라인 3.0 3101 Advanced String Formatting Standards Track Final 새로운 문자열 포매팅 2.6, 3.0+ 3333 Python Web Server Gateway Interface v1.0.1 Informational Final 웹 서버와 애플리케이션 간 인터페이스 3.2+ 492 Coroutines with Async and Await Syntax Standards Track Final async/await 구문 3.5+ 498 Literal String Interpolation Standards Track Final f-문자열 3.6+ 557 Data Classes Standards Track Final @dataclass 데코레이터 3.7+ 572 Assignment Expressions Standards Track Final 할당 표현식 (:=) 3.8+ 649 Deferred Evaluation Of Annotations Using Descriptors Standards Track Accepted 주석의 지연 평가 3.10+ 695 Type Parameter Syntax Standards Track Accepted 제네릭 문법 개선 3.12 (예정) 701 Syntactic Formalization of F-strings Standards Track Accepted f-문자열 문법 개선 3.12 (예정) 702 Marking Deprecations Using the Type System Standards Track Accepted deprecation 마킹 3.13 (예정) 703 Making the Global Interpreter Lock Optional in CPython Standards Track Accepted 선택적 GIL 3.13 (예정) 749 Implementing PEP 649 Standards Track Draft PEP 649 구현 보완 3.14 (예정) 750 Tag Strings Standards Track Draft 태그 문자열 3.14 (예정) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to PEP" href=https://buenhyden.github.io/posts/software-development/python/getting-started/pep/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Classes</h2></header><div class=entry-content><p>Classes Python의 클래스(class)는 객체 지향 프로그래밍의 핵심 개념으로, 데이터와 그 데이터를 조작하는 메서드를 하나의 단위로 묶는 틀이다.
Python의 클래스는 코드의 재사용성을 높이고, 복잡한 프로그램을 구조화하는 데 도움을 준다. 객체 지향 프로그래밍의 원칙을 따르면서도 Python 특유의 간결함과 유연성을 제공한다.
클래스의 정의와 구조 클래스는 ‘class’ 키워드를 사용하여 정의한다:
일반적으로 클래스 이름은 대문자로 시작하는 카멜 케이스(CamelCase) 를 사용한다.
1 2 3 4 5 6 class ClassName: def __init__(self, parameters): self.attribute = parameters def method(self): # 메서드 내용 __init__ 메서드: 클래스의 생성자로, 객체 초기화에 사용된다. self: 클래스 자신을 가리키는 참조로, 모든 메서드의 첫 번째 매개변수로 사용된다. 객체와 인스턴스 객체(Object): 클래스로부터 생성된 실체이다. 인스턴스(Instance): 클래스의 특정 객체를 가리킨다. 1 p = Person() # Person 클래스의 인스턴스 생성 변수 인스턴스 변수: 각 객체마다 별도로 존재하는 변수로, self를 사용하여 정의한다. 클래스 변수: 클래스 자체에 속하며, 모든 객체가 공유하는 변수이다. 1 2 3 4 5 class Dog: species = "Canis familiaris" # 클래스 변수 def __init__(self, name): self.name = name # 인스턴스 변수 1 2 3 4 5 dog1 = Dog("Buddy") dog2 = Dog("Molly") print(dog1.species) # 출력: Canis familiaris print(dog2.species) # 출력: Canis familiaris 상속(Inheritance) 상속을 통해 기존 클래스의 속성과 메서드를 새로운 클래스에서 재사용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-25 12:26:00 +0000 UTC'>November 25, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Classes" href=https://buenhyden.github.io/posts/software-development/python/core-features/object-oriented-programming/classes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/page/14/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/page/16/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>