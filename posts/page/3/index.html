<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>기록하고 기억하고 활용하자. | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="기록하고 기억하고 활용하자. - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="기록하고 기억하고 활용하자."><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="기록하고 기억하고 활용하자."><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기록하고 기억하고 활용하자.","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>기록하고 기억하고 활용하자.</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kong</h2></header><div class=entry-content><p>Kong 1. 적절한 태그 (영어, 대시로 구분) API-Gateway, Cloud-Native, Microservices, Traffic-Management
2. 분류 구조 타당성 검토 및 분석 현재 구조에서 ‘Kong’ 은 “System Design > System Components > Traffic Control and Routing > API Gateway > Implementations” 로 분류됨. Kong 은 실제로 ‘API 게이트웨이 (API Gateway)’ 로 크게 분류되며, 시스템 컴포넌트 (System Components), 트래픽 제어 및 라우팅 (Traffic Control and Routing) 에 속하므로, 계층 구조가 적절함. API Gateway 구현체는 클라우드 네이티브 (Cloud Native), 마이크로서비스 (Microservices) 환경에서 필수 요소이며, 해당 분류에서 “Kong” 의 포지셔닝이 논리적으로 타당함. 3. 200 자 내외 한줄 요약 Kong 은 마이크로서비스 (Microservices) 아키텍처와 클라우드 환경에서 트래픽 관리, 인증, 로깅, 보안 기능을 제공하는 오픈 소스 API 게이트웨이 (API Gateway) 솔루션으로, 다양한 플러그인과 고가용성, 확장성을 지원하여 복잡한 시스템을 효율적으로 운영할 수 있게 한다.
...</p></div><footer class=entry-footer><span title='2025-03-23 01:52:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;43 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kong" href=https://buenhyden.github.io/posts/tools-reference/communication-technologies/api-technologies/api-gateways/kong-gateway/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Traefik</h2></header><div class=entry-content><p>Traefik 1. 적절한 태그 (영어, 대시로 구분) API-Gateway, Cloud-Native, Traffic-Management, Dynamic-Routing
2. 분류 구조 타당성 분석 Traefik(트래픽)은 트래픽 제어와 라우팅 중심의 API 게이트웨이(API Gateway) 솔루션이자, 다양한 시스템 환경(마이크로서비스, 컨테이너 기반, 클라우드 네이티브)에 활용되는 실질적인 구현체임. “System Design > System Components > Traffic Control and Routing > API Gateway > Implementations”는 트래픽의 역할 및 구현체로서의 위치를 정확히 반영하고 있음. 추가로, Traefik은 외부 및 내부 시스템을 연결하고 유연하게 라우팅 및 로드 밸런싱을 제공하므로, 해당 분류 구조의 세부 계층이 논리적이며 실무와 이론 양 측면에서 적합함. 3. 주제 요약 (200자 내외) Traefik은 마이크로서비스와 컨테이너 및 클라우드 환경에 최적화된 오픈 소스 API 게이트웨이 및 리버스 프록시 솔루션이다. 동적 서비스 탐지, 자동 SSL, 다양한 인증 및 로드밸런싱, 트래픽 관리 기능을 갖추고 있어 DevOps, 인프라 자동화에 매우 적합하다.
...</p></div><footer class=entry-footer><span title='2025-03-23 01:51:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;46 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traefik" href=https://buenhyden.github.io/posts/tools-reference/reverse-proxies-and-load-balancers/traefik/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Lucene</h2></header><div class=entry-content><p>Apache Lucene Apache Lucene은 자바로 작성된 오픈소스 검색 엔진 라이브러리로, Apache Software Foundation에서 관리하고 있다. 1999년 Doug Cutting에 의해 처음 개발되었으며, 현재는 웹 검색부터 기업용 문서 검색까지 다양한 분야에서 활용되고 있다.
Lucene은 단순한 API를 제공하면서도 복잡한 검색 기능을 지원하며, 특히 전문(full-text) 검색에 특화되어 있다. 데이터베이스 시스템에서 제공하는 일반적인 검색 기능보다 훨씬 뛰어난 성능과, 상세한 검색 옵션을 제공한다.
핵심 개념 및 구조 색인(Indexing) Lucene의 핵심은 색인 생성 기능이다. 원본 데이터를 검색 가능한 형태로 변환하는 과정으로, 다음과 같은 단계를 거친다.
...</p></div><footer class=entry-footer><span title='2025-03-03 07:07:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Lucene" href=https://buenhyden.github.io/posts/tools-reference/search-technologies/apache-lucene/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Elasticssearch</h2></header><div class=entry-content><p>Elasticssearch Elasticsearch는 분산형, RESTful 검색 및 분석 엔진으로, 대량의 데이터를 저장, 검색 및 분석하는 데 최적화된 도구이다. Apache Lucene을 기반으로 개발되었으며, 빠른 검색 응답과 실시간 데이터 처리 능력을 제공한다. 이 기술은 다양한 산업 및 애플리케이션에서 폭넓게 사용되며, 특히 대규모 데이터 처리와 복잡한 검색 작업에 강점을 가지고 있다.
Elasticsearch의 역사와 배경 Elasticsearch는 2010년 Shay Banon에 의해 처음 릴리스되었다. Banon은 원래 아내를 위한 요리 애플리케이션을 개발하면서 효율적인 검색 기능이 필요했고, 이를 위해 Lucene 검색 라이브러리를 기반으로 Elasticsearch를 만들었다. 이후 Elasticsearch는 빠르게 발전하여 현재는 Elastic NV라는 회사에서 개발과 유지보수를 담당하고 있다.
...</p></div><footer class=entry-footer><span title='2025-03-03 06:59:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Elasticssearch" href=https://buenhyden.github.io/posts/tools-reference/search-technologies/elasticssearch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Opensearch</h2></header><div class=entry-content><p>Opensearch OpenSearch는 오픈 소스 검색 및 분석 엔진으로, 대규모 데이터의 실시간 처리와 분석에 특화된 도구이다. Elasticsearch 7.10.2를 포크하여 개발되었으며, Apache 2.0 라이선스로 공개되어 자유로운 사용과 확장이 가능하다. AWS를 비롯한 다양한 기업과 커뮤니티가 협력하여 발전시켜 왔으며, 2024년 9월부터는 Linux Foundation 산하 OpenSearch Software Foundation에서 관리되고 있다.
OpenSearch의 개요와 역사 OpenSearch는 강력한 오픈 소스 검색 및 분석 제품군으로, 대규모 데이터에서 실시간 검색, 모니터링, 분석 기능을 제공한다. 텍스트, 숫자, 지리 공간 데이터 등 다양한 유형의 데이터를 처리할 수 있는 유연한 플랫폼이다.
...</p></div><footer class=entry-footer><span title='2025-03-03 06:59:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Opensearch" href=https://buenhyden.github.io/posts/tools-reference/search-technologies/opensearch/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Solr</h2></header><div class=entry-content><p>Solr Apache Solr는 고성능 오픈 소스 검색 플랫폼으로, 엔터프라이즈급 전문 검색(full-text search), 패싯 검색, 실시간 인덱싱, 동적 클러스터링, 데이터베이스 통합 및 풍부한 문서 처리 기능을 제공한다. Lucene 검색 라이브러리를 기반으로 하며, 웹 애플리케이션으로 패키징되어 쉽게 배포하고 사용할 수 있다.
역사와 발전 Solr는 2004년 CNET Networks의 Yonik Seeley에 의해 개발되었으며, 2006년 Apache Software Foundation에 기부되어 Apache 라이선스 하에 오픈 소스 프로젝트로 발전했다. 처음에는 CNET의 사이트 검색 기능을 향상시키기 위한 내부 프로젝트였으나, 현재는 전 세계적으로 수많은 대형 웹사이트와 기업에서 활용하는 주요 검색 엔진이 되었다.
...</p></div><footer class=entry-footer><span title='2025-03-03 01:58:00 +0000 UTC'>March 3, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Solr" href=https://buenhyden.github.io/posts/tools-reference/search-technologies/apache-solr/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar</h2></header><div class=entry-content><p>Apache Pulsar Apache Pulsar는 Yahoo에서 개발하고 Apache Software Foundation에서 관리하는 분산형 메시징 및 스트리밍 플랫폼이다. Pulsar는 기존의 메시지 큐와 스트리밍 시스템의 장점을 결합하여 높은 성능, 낮은 지연 시간, 그리고 강력한 내구성을 제공한다.
주요 특징 멀티 테넌시(Multi-tenancy): 다양한 팀이나 애플리케이션이 같은 클러스터를 공유할 수 있다. 스트리밍과 큐잉의 통합: 전통적인 메시징과 스트리밍 패러다임을 동시에 지원한다. 지역 간 복제(Geo-replication): 여러 데이터센터나 지역에 걸쳐 데이터를 복제할 수 있다. 계층형 스토리지: 핫 데이터는 메모리나 SSD에, 콜드 데이터는 HDD나 객체 스토리지에 저장한다. Functions와 IO 커넥터: 서버리스 컴퓨팅과 데이터 통합 기능을 제공한다. 트랜잭션 지원: 정확히 한 번(exactly-once) 메시지 처리를 보장한다. 스키마 레지스트리: 메시지의 스키마와 버전 관리를 지원한다. 아키텍처 개요 Pulsar의 아키텍처는 크게 세 가지 주요 컴포넌트로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-02-06 04:33:00 +0000 UTC'>February 6, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar" href=https://buenhyden.github.io/posts/tools-reference/communication-technologies/message-brokers/apache-pulsar/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Airflow</h2></header><div class=entry-content><p>Airflow Apache Airflow는 데이터 파이프라인을 구축, 관리, 모니터링하기 위한 오픈소스 플랫폼이다.
Airflow는 복잡한 데이터 파이프라인을 효율적으로 관리할 수 있게 해주는 강력한 도구이다.
데이터 엔지니어링 분야에서 널리 사용되며, 지속적으로 발전하고 있는 플랫폼이다.
기본적인 DAG(Directed Acyclic Graph) 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 from airflow import DAG from airflow.operators.python import PythonOperator from datetime import datetime, timedelta # DAG 기본 설정 default_args = { 'owner': 'data_engineer', 'depends_on_past': False, 'start_date': datetime(2024, 1, 1), 'email': ['alert@example.com'], 'email_on_failure': True, 'retries': 1, 'retry_delay': timedelta(minutes=5) } # DAG 정의 dag = DAG( 'data_processing_pipeline', default_args=default_args, description='데이터 처리 파이프라인', schedule_interval='0 0 * * *' # 매일 자정에 실행 ) # 태스크 함수 정의 def extract_data(**context): # 데이터 추출 로직 raw_data = {'data': 'extracted_value'} context['task_instance'].xcom_push(key='raw_data', value=raw_data) def transform_data(**context): # 데이터 변환 로직 raw_data = context['task_instance'].xcom_pull(key='raw_data') transformed_data = {'data': f"transformed_{raw_data['data']}"} context['task_instance'].xcom_push(key='transformed_data', value=transformed_data) def load_data(**context): # 데이터 적재 로직 transformed_data = context['task_instance'].xcom_pull(key='transformed_data') print(f"Loading data: {transformed_data}") # 태스크 생성 extract_task = PythonOperator( task_id='extract_data', python_callable=extract_data, provide_context=True, dag=dag ) transform_task = PythonOperator( task_id='transform_data', python_callable=transform_data, provide_context=True, dag=dag ) load_task = PythonOperator( task_id='load_data', python_callable=load_data, provide_context=True, dag=dag ) # 태스크 의존성 설정 extract_task >> transform_task >> load_task Airflow의 주요 특징 Python 기반: DAG(Directed Acyclic Graph)를 Python 코드로 정의할 수 있어 유연성과 확장성이 뛰어나다. 스케줄링: 복잡한 워크플로우를 쉽게 스케줄링할 수 있다. 모니터링: 웹 인터페이스를 통해 작업 실행 상태를 실시간으로 모니터링할 수 있다. 확장성: 다양한 외부 시스템과 쉽게 통합할 수 있다. Airflow의 주요 구성 요소 DAG (Directed Acyclic Graph):
...</p></div><footer class=entry-footer><span title='2024-10-26 05:18:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Airflow" href=https://buenhyden.github.io/posts/tools-reference/data-pipeline-tools/airflow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RabbitMQ</h2></header><div class=entry-content><p>RabbitMQ 1. 태그 Message-Broker Messaging-Queue Pub-Sub Distributed-Systems 2. 분류 구조 분석 및 평가 분석 결과 현재 “Computer Science and Engineering > Systems and Infrastructure > Infrastructure > Infrastructure Components > Messaging Systems > Implementations > Event Streaming Platforms > Messaging Queue” 구조는 RabbitMQ(래빗MQ)의 역할과 사용 환경을 잘 반영함.
RabbitMQ는 대표적인 메시지 브로커이며, 큐 기반 메시징(Messaging Queue, MQ) 솔루션이다. Event Streaming Platform(이벤트 스트리밍 플랫폼)은 Kafka(카프카) 등과 함께 RabbitMQ도 분산 메시지 처리 및 이벤트 기반 시스템 구축에서 활용되기에 넓은 범주상 일치한다.
즉, 메시징 시스템 내 구현체(Implementation) 중, 큐 기반 메시징 플랫폼(Messaging Queue)으로 RabbitMQ를 분류하는 패러다임이 현대 실무/이론 모두에 적합하다.
...</p></div><footer class=entry-footer><span title='2024-10-25 00:54:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;56 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RabbitMQ" href=https://buenhyden.github.io/posts/tools-reference/communication-technologies/message-brokers/rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RDBMS</h2></header><div class=entry-content><p>관계형 데이터베이스 관리 시스템 (Relational Database Management System, RDBMS) 관계형 데이터베이스 관리 시스템 (RDBMS) 은 구조화된 데이터를 테이블 형태로 저장하며, SQL 을 통해 데이터 관계를 관리하는 시스템입니다. 2025 년 현재 클라우드 통합과 AI 기반 최적화가 주요 트렌드로 부상했으며, 기업의 디지털 인프라 핵심으로 자리잡았습니다.
1. 주제 분류 적절성 “Computer Science and Engineering > Backend Development > 데이터베이스 “ 분류는 타당합니다. RDBMS 는 백엔드 시스템에서 데이터 저장/검색의 근간을 이루며, 85% 이상의 기업 시스템이 여전히 RDBMS 를 주력으로 활용 중입니다 [4][18].
...</p></div><footer class=entry-footer><span title='2024-10-24 01:55:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;52 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDBMS" href=https://buenhyden.github.io/posts/tools-reference/database-systems/rdbms/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/posts/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>