<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | hyunyoun's Blog</title><meta name=keywords content><meta name=description content="Posts - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/index.xml title=rss><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Posts"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://buenhyden.github.io/posts/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span class=active>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Gateway</h2></header><div class=entry-content><p>API Gateway API Gateway 는 분산 서비스 환경에서 클라이언트 요청을 받아 내부 서비스로 적절히 전달하고 응답을 반환하는 통신의 허브 역할을 한다.
인증·인가, SSL 종료, 로깅, 트래픽 제어, 응답 변환 등 핵심 기능을 수행하여 서비스 간 결합도를 낮추고 보안과 관리를 중앙 집중화한다. 경량 레이어에서 보안·성능·운영성과를 확보할 수 있어 마이크로서비스, 무상태화된 아키텍처 설계에 필수적이다.
핵심 개념으로는 프록시 방식, 페일오버, 캐싱, 트래픽 제어 등이 있으며, 실무 적용 시 인증체계 연동, 장애 대응, 확장성, 운영 모니터링 및 로깅 전략을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-20 09:40:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;<span>56 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to API Gateway" href=https://buenhyden.github.io/posts/software-development/distributed-systems/service-integration/api-gateway/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC API</h2></header><div class=entry-content><p>gRPC gRPC는 Google에서 개발한 고성능, 오픈소스 RPC(Remote Procedure Call) 프레임워크이다.
‘g’는 원래 Google을 의미했지만, 현재는 “gRPC Remote Procedure Calls"의 재귀적 약자로 사용된다. 2015년에 공개되었으며, 현재 Cloud Native Computing Foundation(CNCF)의 졸업 프로젝트이다.
gRPC는 마이크로서비스 아키텍처와 높은 성능이 필요한 시스템에 이상적인 강력한 RPC 프레임워크이다. Protocol Buffers, HTTP/2, 코드 생성 및 다양한 통신 패턴을 통해 효율적이고 확장 가능한 API를 구축할 수 있다.
시작하기 전에 Protocol Buffers 문법, HTTP/2 기본 사항, 스트리밍 패턴 및 오류 처리에 대한 확실한 이해가 필요하다. 이러한 기초를 다진 후에는 점진적으로 더 복잡한 기능을 탐색하고 실제 프로젝트에 gRPC를 통합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-19 03:22:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;<span>19 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to gRPC API" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/synchronous-communication/remote-procedure-calls/grpc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CORS</h2></header><div class=entry-content><p>CORS (Cross-Origin Resource Sharing) 다른 출처(Origin)의 리소스를 공유하기 위한 보안 메커니즘 웹 브라우저에서 실행되는 보안 정책 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 완화하는 방법 목적 동일 출처 정책(Same-Origin Policy)을 우회하면서도 안전한 교차 출처 요청을 가능하게 합니다. 웹 애플리케이션의 기능성을 확장하고 다양한 도메인 간 리소스 공유를 허용합니다. 작동 원리 브라우저는 교차 출처 요청 시 Origin 헤더를 포함시킵니다. 서버는 Access-Control-Allow-Origin 헤더로 허용된 출처를 지정합니다. 요청 유형 단순 요청 (Simple Request): GET, HEAD, POST 메서드만 사용 허용된 헤더만 사용 Content-Type이 다음으로 제한: application/x-www-form-urlencoded multipart/form-data text/plain 프리플라이트 요청(Preflight Request): OPTIONS 메서드를 사용한 사전 검사 실제 요청 전에 서버의 허가를 확인 안전하지 않은 요청에 대한 보호 CORS 시나리오 단순 요청
...</p></div><footer class=entry-footer><span title='2024-10-18 07:13:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to CORS" href=https://buenhyden.github.io/posts/software-development/application-security/web-application-security/client-side-security/cors/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IP(Internet Protocol)</h2></header><div class=entry-content><p>IP (Internet Protocol) 데이터 패킷이 네트워크를 통해 이동하고 올바른 대상에 도착할 수 있도록 데이터 패킷을 라우팅하고 주소를 지정하기 위한 프로토콜 또는 규칙의 집합이다.
OSI 7 계층에서 네트워크 계층 (3 계층) 에 위치하며, TCP/IP 4 계층에서는 인터넷 계층에 해당한다.
이 위치에서 IP 는 데이터 패킷의 주소지정과 라우팅을 담당하는 핵심적인 역할을 수행한다.
IP 정보는 각 패킷에 첨부되며, 이 정보는 라우터가 패킷을 올바른 위치로 보내는 데 도움이 된다.
인터넷에 연결하는 모든 장치나 도메인에는 IP 주소가 할당되며, 패킷이 연결된 IP 주소로 전달되면 데이터가 필요한 곳에 도착한다.
패킷이 목적지에 도착하면 IP 와 함께 어떤 전송 프로토콜이 사용되는지에 따라 다르게 처리된다.
모든 IP 데이터 패킷은 특정 정보를 특정 순서로 표시해야 하며 모든 IP 주소는 표준화된 형식을 따른다.
...</p></div><footer class=entry-footer><span title='2024-10-17 02:03:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;<span>34 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to IP(Internet Protocol)" href=https://buenhyden.github.io/posts/computer-science/core-protocols/internet-layer/internet-protocol/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Sequential Consistency</h2></header><div class=entry-content><p>순차적 일관성 (Sequential Consistency) 순차적 일관성은 분산 시스템에서 데이터 일관성 문제를 해결하기 위한 모델로, 모든 프로세스의 연산이 하나의 글로벌 순서에 따라 실행된 것처럼 보이게 하며 각 개별 프로세스의 연산은 프로그램에 명시된 순서대로 유지된다. 강력한 일관성보다는 약하지만 인과적 일관성보다는 강력한 이 모델은 공유 메모리 시스템, 분산 데이터 저장소, 협업 애플리케이션 등에서 널리 활용된다.
핵심 개념 순차적 일관성 (Sequential Consistency) 은 분산 시스템에서 알아야 하는 일관성 모델이다. 레슬리 램포트 (Leslie Lamport) 가 1979 년 “How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs” 논문에서 제안한 이 개념은 다음과 같이 정의된다:
...</p></div><footer class=entry-footer><span title='2024-10-09 08:17:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;<span>35 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Sequential Consistency" href=https://buenhyden.github.io/posts/software-development/distributed-systems/data-consistency/consistency-models/strong/sequential-consistency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linearizability</h2></header><div class=entry-content><p>선형화 가능성 (Linearizability) 선형화 가능성 (Linearizability) 은 분산 시스템에서 가장 강력한 일관성 모델로, 여러 프로세스가 공유 객체에 접근할 때 각 작업이 실제 발생 시간 사이에 원자적으로 실행된 것처럼 보이도록 한다. 이는 CAP 정리에서 말하는 일관성 (C) 에 해당하며, 모든 노드가 데이터의 동일한 상태를 볼 수 있도록 보장한다. 그러나 높은 일관성을 제공하는 대신 가용성과 파티션 내성 간의 균형을 맞추는 것이 핵심 과제이다. 데이터베이스, 분산 키 - 값 저장소, 공유 레지스터 등 다양한 시스템에서 활용된다.
...</p></div><footer class=entry-footer><span title='2024-10-09 08:06:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;<span>32 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Linearizability" href=https://buenhyden.github.io/posts/software-development/distributed-systems/data-consistency/consistency-models/strong/linearizability/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Eventual Consistency</h2></header><div class=entry-content><p>최종 일관성 (Eventual Consistency) Eventual Consistency 은 CAP 정리에 기반한 분산 시스템의 일관성 모델로, 가용성과 파티션 내성을 우선시하며 엄격한 일관성을 완화합니다. 분산 데이터베이스 및 시스템에서 데이터 복제 시 발생하는 일시적 불일치를 허용하고, 시간이 지나면 모든 복제본이 동일한 데이터 상태로 수렴하는 것을 보장하는 일관성 모델이다. 이는 CAP 정리에서 가용성과 파티션 허용성을 우선시하는 설계 선택으로, 강한 일관성 모델에 비해 낮은 지연 (latency) 과 높은 확장성을 제공한다. 그러나 데이터 충돌과 불일치 문제를 해결하기 위한 추가 메커니즘과 애플리케이션 수준의 보상이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:09:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;<span>23 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Eventual Consistency" href=https://buenhyden.github.io/posts/software-development/distributed-systems/data-consistency/consistency-models/weak/eventual-consistency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 주소 지정 방식 (Memory Address Modes)</h2></header><div class=entry-content><p>메모리 주소 지정 방식 (Memory Address Modes) 메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.
유형 즉시 주소 지정 방식 (Immediate Addressing):
데이터가 명령어 자체에 포함되어 있다. 예: “5를 더해라” 라고 직접 지시하는 것과 같다. 가장 빠르지만, 큰 데이터를 다루기 어렵다. 직접 주소 지정 방식 (Direct Addressing):
명령어에 데이터가 있는 메모리 주소를 직접 지정한다. 예: “주소 100번에 있는 값을 가져와라” 라고 지시하는 것과 같다. 간단하고 이해하기 쉽다. 간접 주소 지정 방식 (Indirect Addressing):
...</p></div><footer class=entry-footer><span title='2024-09-30 08:04:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 메모리 주소 지정 방식 (Memory Address Modes)" href=https://buenhyden.github.io/posts/computer-science/computer-systems/computer-architecture/memory-systems/memory-management/address-translation/memory-address-modes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/page/16/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>