<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Composition Over Inheritance | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles,Composition-Over-Inheritance"><meta name=description content='"Composition Over Inheritance" 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 "is-a" 관계보다 "has-a" 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/principles/design-principles/composition-over-inheritance/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/principles/design-principles/composition-over-inheritance/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/principles/design-principles/composition-over-inheritance/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/principles/design-principles/composition-over-inheritance/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Composition Over Inheritance"><meta property="og:description" content='"Composition Over Inheritance" 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 "is-a" 관계보다 "has-a" 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Composition Over Inheritance"><meta name=twitter:description content='"Composition Over Inheritance" 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 "is-a" 관계보다 "has-a" 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Principles","item":"https://buenhyden.github.io/posts/software-engineering/principles/"},{"@type":"ListItem","position":4,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/principles/design-principles/"},{"@type":"ListItem","position":5,"name":"Composition Over Inheritance","item":"https://buenhyden.github.io/posts/software-engineering/principles/design-principles/composition-over-inheritance/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/principles/>Principles</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/principles/design-principles/>Design Principles</a></div><h1>Composition Over Inheritance</h1><div class=post-description>&ldquo;Composition Over Inheritance&rdquo; 는 객체지향 설계에서 상속 (Inheritance) 보다 컴포지션 (Composition, 구성) 을 우선시하라는 원칙이다. 객체간 &ldquo;is-a&rdquo; 관계보다 &ldquo;has-a&rdquo; 관계를 통해 코드 재사용과 유연성을 달성하고자 한다. 이는 코드의 유연성과 재사용성을 높이고, 변화에 강한 구조를 만들기 위함이다. 상속의 단점을 보완하며, 다양한 기능을 조합해 객체를 설계할 수 있다.</div></header><div class=post-content><h2 id=composition-over-inheritance>Composition Over Inheritance<a hidden class=anchor aria-hidden=true href=#composition-over-inheritance>#</a></h2><p>&ldquo;Composition Over Inheritance&rdquo; 는 객체지향 프로그래밍에서 코드 재사용과 유연한 설계를 위해 상속보다 컴포지션을 우선적으로 활용하라는 설계 원칙이다. 상속의 단점인 강한 결합도와 클래스 폭발 문제를 해결하고자 한다. 인터페이스와 컴포지션을 통해 런타임 유연성을 제공하며, 인터페이스와 컴포지션을 통해 런타임 유연성을 제공하며, Bridge, Decorator, Strategy 등 다양한 디자인 패턴의 기반이 된다. 특히 다중 상속의 Diamond Problem 을 회피하고 단일 책임 원칙을 지원하여 현대적인 소프트웨어 설계에서 필수적인 원칙이다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>Composition Over Inheritance (컴포지션 우선 원칙)</strong> 은 객체지향 프로그래밍에서 클래스들이 상속을 통한 &ldquo;is-a&rdquo; 관계보다는 컴포지션을 통한 &ldquo;has-a&rdquo; 관계로 기능을 재사용하고 다형성을 구현해야 한다는 설계 원칙이다.</p><ul><li><strong>컴포지션 (Composition, 구성)</strong>: 객체가 다른 객체를 포함 (참조) 하여 기능을 조합하는 방식</li><li><strong>상속 (Inheritance, 상속)</strong>: 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 방식.</li></ul><p>전략 패턴 (Strategy Pattern), 데코레이터 패턴 (Decorator Pattern) 등 다양한 디자인 패턴에서 이 원칙이 적용된다.</p><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p><strong>역사적 배경:</strong></p><ul><li>1990 년대 초 객체지향 프로그래밍이 대중화되면서 상속 남용 문제 발생</li><li>GoF(Gang of Four) 가 1994 년 &ldquo;Design Patterns&rdquo; 책에서 공식적으로 제시</li><li>상속의 단점인 강한 결합도, 클래스 폭발, 다중 상속 문제 해결 필요성 대두</li></ul><p><strong>문제 상황:</strong></p><ul><li>상속 계층이 깊어질수록 복잡성 증가</li><li>부모 클래스 변경 시 모든 자식 클래스에 영향</li><li>다중 상속에서 Diamond Problem 발생</li><li>런타임에 행동 변경의 어려움</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><table><thead><tr><th>목적</th><th>설명</th></tr></thead><tbody><tr><td>유연성 향상</td><td>런타임에 객체의 행동을 동적으로 변경 가능</td></tr><tr><td>재사용성 증대</td><td>기존 컴포넌트를 조합하여 새로운 기능 구현</td></tr><tr><td>결합도 감소</td><td>클래스 간 의존성을 최소화하여 독립적 개발</td></tr><tr><td>테스트 용이성</td><td>Mock 객체를 이용한 단위 테스트 용이</td></tr><tr><td>유지보수성</td><td>변경 사항이 다른 클래스에 미치는 영향 최소화</td></tr></tbody></table><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><p>객체가 필요한 기능 (행동) 을 인터페이스로 정의하고, 해당 기능을 구현한 객체를 조합하여 원하는 기능을 완성한다.</p><h4 id=작동-원리-다이어그램>작동 원리 다이어그램<a hidden class=anchor aria-hidden=true href=#작동-원리-다이어그램>#</a></h4><pre class=mermaid>graph TD
    A[Client] --&gt; B[CompositeClass]
    B --&gt; C[Interface1]
    B --&gt; D[Interface2]
    C --&gt; E[Implementation1A]
    C --&gt; F[Implementation1B]
    D --&gt; G[Implementation2A]
    D --&gt; H[Implementation2B]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#e8f5e8
    style E fill:#fff3e0
    style F fill:#fff3e0
    style G fill:#fff3e0
    style H fill:#fff3e0
</pre><h3 id=상속-inheritance-vs-컴포지션-composition-비교>상속 (Inheritance) vs. 컴포지션 (Composition) 비교<a hidden class=anchor aria-hidden=true href=#상속-inheritance-vs-컴포지션-composition-비교>#</a></h3><p><strong>상속</strong>은 명확한 계층적 관계와 다형성이 필요한 경우에 적합하며, <strong>컴포지션</strong>은 유연성, 재사용성, 테스트 용이성이 중요한 현대적 소프트웨어 개발에 더 적합하다. <strong>&ldquo;Composition Over Inheritance&rdquo;</strong> 원칙에 따라 컴포지션을 기본으로 선택하고, 명확한 is-a 관계가 존재하는 경우에만 상속을 사용하는 것이 권장된다.</p><table><thead><tr><th>구분</th><th>상속 (Inheritance)</th><th>컴포지션 (Composition)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>부모 클래스로부터 속성과 메소드를 물려받는 메커니즘</td><td>다른 객체의 인스턴스를 포함하여 기능을 재사용하는 메커니즘</td></tr><tr><td><strong>관계 유형</strong></td><td>&ldquo;is-a&rdquo; 관계 (예: 자동차는 차량이다)</td><td>&ldquo;has-a&rdquo; 관계 (예: 자동차는 엔진을 가진다)</td></tr><tr><td><strong>결합도</strong></td><td>강한 결합 (Tight Coupling)</td><td>느슨한 결합 (Loose Coupling)</td></tr><tr><td><strong>가시성</strong></td><td>White-box 재사용 (내부 구조 노출)</td><td>Black-box 재사용 (내부 구조 숨김)</td></tr></tbody></table><h4 id=기술적-특성-비교>기술적 특성 비교<a hidden class=anchor aria-hidden=true href=#기술적-특성-비교>#</a></h4><table><thead><tr><th>특성</th><th>상속 (Inheritance)</th><th>컴포지션 (Composition)</th></tr></thead><tbody><tr><td><strong>런타임 유연성</strong></td><td>컴파일타임에 관계 고정</td><td>런타임에 동적 변경 가능</td></tr><tr><td><strong>다중 기능 조합</strong></td><td>다중 상속 시 Diamond Problem 발생</td><td>여러 컴포넌트 자유롭게 조합 가능</td></tr><tr><td><strong>인터페이스 노출</strong></td><td>부모의 모든 public 메소드 상속</td><td>필요한 인터페이스만 노출</td></tr><tr><td><strong>메소드 재정의</strong></td><td>오버라이딩을 통한 행동 변경</td><td>델리게이션을 통한 행동 위임</td></tr><tr><td><strong>메모리 사용</strong></td><td>단일 객체 인스턴스</td><td>여러 객체 인스턴스 (약간의 오버헤드)</td></tr><tr><td><strong>성능</strong></td><td>직접 메소드 호출</td><td>간접 메소드 호출 (미미한 성능 비용)</td></tr></tbody></table><h4 id=설계-관점-비교>설계 관점 비교<a hidden class=anchor aria-hidden=true href=#설계-관점-비교>#</a></h4><table><thead><tr><th>설계 측면</th><th>상속 (Inheritance)</th><th>컴포지션 (Composition)</th></tr></thead><tbody><tr><td><strong>SOLID 원칙 준수</strong></td><td>단일 책임 원칙 위반 가능성 높음</td><td>단일 책임 원칙 준수 용이</td></tr><tr><td><strong>개방 - 폐쇄 원칙</strong></td><td>부분적 지원 (확장은 쉬우나 수정 위험)</td><td>완전 지원 (확장 쉽고 수정 불필요)</td></tr><tr><td><strong>리스코프 치환 원칙</strong></td><td>준수 필수 (위반 시 설계 오류)</td><td>해당 없음 (인터페이스 기반)</td></tr><tr><td><strong>캡슐화</strong></td><td>부모 클래스 세부사항 노출</td><td>완전한 캡슐화 유지</td></tr><tr><td><strong>응집도</strong></td><td>부모 - 자식 간 강한 응집</td><td>각 컴포넌트의 독립적 응집</td></tr></tbody></table><h4 id=개발-및-유지보수-비교>개발 및 유지보수 비교<a hidden class=anchor aria-hidden=true href=#개발-및-유지보수-비교>#</a></h4><table><thead><tr><th>개발 측면</th><th>상속 (Inheritance)</th><th>컴포지션 (Composition)</th></tr></thead><tbody><tr><td><strong>코드 작성량</strong></td><td>적음 (자동으로 메소드 상속)</td><td>많음 (위임 메소드 작성 필요)</td></tr><tr><td><strong>초기 개발 속도</strong></td><td>빠름</td><td>느림 (인터페이스 설계 필요)</td></tr><tr><td><strong>테스트 용이성</strong></td><td>어려움 (부모 클래스 의존)</td><td>쉬움 (Mock 객체 활용 가능)</td></tr><tr><td><strong>디버깅</strong></td><td>복잡함 (상속 체인 추적)</td><td>단순함 (명확한 호출 경로)</td></tr><tr><td><strong>리팩토링</strong></td><td>어려움 (영향 범위 넓음)</td><td>쉬움 (독립적 컴포넌트)</td></tr><tr><td><strong>문서화</strong></td><td>상속 관계 이해 필요</td><td>컴포넌트별 독립적 문서화</td></tr></tbody></table><h4 id=확장성-및-재사용성-비교>확장성 및 재사용성 비교<a hidden class=anchor aria-hidden=true href=#확장성-및-재사용성-비교>#</a></h4><table><thead><tr><th>확장성 측면</th><th>상속 (Inheritance)</th><th>컴포지션 (Composition)</th></tr></thead><tbody><tr><td><strong>새 기능 추가</strong></td><td>상속 체인 수정 또는 새 클래스 생성</td><td>새 컴포넌트 추가 및 조합</td></tr><tr><td><strong>기존 기능 수정</strong></td><td>모든 하위 클래스에 영향</td><td>해당 컴포넌트만 수정</td></tr><tr><td><strong>코드 재사용</strong></td><td>수직적 재사용 (계층적)</td><td>수평적 재사용 (조합적)</td></tr><tr><td><strong>기능 조합</strong></td><td>제한적 (클래스 폭발 위험)</td><td>자유로운 조합</td></tr><tr><td><strong>버전 관리</strong></td><td>호환성 유지 어려움</td><td>컴포넌트별 독립적 버전 관리</td></tr></tbody></table><h4 id=사용-시나리오-비교>사용 시나리오 비교<a hidden class=anchor aria-hidden=true href=#사용-시나리오-비교>#</a></h4><table><thead><tr><th>시나리오</th><th>상속 권장</th><th>컴포지션 권장</th><th>이유</th></tr></thead><tbody><tr><td><strong>명확한 is-a 관계</strong></td><td>✅</td><td>❌</td><td>개념적 모델링에 적합</td></tr><tr><td><strong>코드 재사용 목적</strong></td><td>❌</td><td>✅</td><td>유연한 재사용 구조</td></tr><tr><td><strong>다형성 구현</strong></td><td>✅</td><td>✅</td><td>둘 다 가능, 컴포지션이 더 유연</td></tr><tr><td><strong>기능 확장</strong></td><td>❌</td><td>✅</td><td>런타임 확장성</td></tr><tr><td><strong>테스트 중심 개발</strong></td><td>❌</td><td>✅</td><td>Mock 객체 활용</td></tr><tr><td><strong>라이브러리 설계</strong></td><td>❌</td><td>✅</td><td>사용자 확장성</td></tr><tr><td><strong>프레임워크 설계</strong></td><td>부분적</td><td>✅</td><td>플러그인 아키텍처</td></tr><tr><td><strong>도메인 모델링</strong></td><td>✅</td><td>✅</td><td>상황에 따라 선택</td></tr></tbody></table><h4 id=성능-비교>성능 비교<a hidden class=anchor aria-hidden=true href=#성능-비교>#</a></h4><table><thead><tr><th>성능 측면</th><th>상속 (Inheritance)</th><th>컴포지션 (Composition)</th></tr></thead><tbody><tr><td><strong>메소드 호출 비용</strong></td><td>직접 호출 (빠름)</td><td>간접 호출 (약간 느림)</td></tr><tr><td><strong>메모리 사용량</strong></td><td>적음</td><td>약간 많음 (추가 객체)</td></tr><tr><td><strong>객체 생성 비용</strong></td><td>적음</td><td>많음 (여러 객체 생성)</td></tr><tr><td><strong>캐시 지역성</strong></td><td>좋음</td><td>보통</td></tr><tr><td><strong>JIT 최적화</strong></td><td>쉬움</td><td>보통</td></tr><tr><td><strong>실제 성능 영향</strong></td><td>거의 없음</td><td>거의 없음 (마이크로 벤치마크 수준)</td></tr></tbody></table><h4 id=상속-inheritance-vs-컴포지션-composition-예시>상속 (Inheritance) vs. 컴포지션 (Composition) 예시<a hidden class=anchor aria-hidden=true href=#상속-inheritance-vs-컴포지션-composition-예시>#</a></h4><h5 id=상속-inheritance>상속 (Inheritance)<a hidden class=anchor aria-hidden=true href=#상속-inheritance>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1> 1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2> 2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3> 3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4> 4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5> 5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6> 6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7> 7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8> 8</a>
</span><span class=lnt id=hl-1-9><a class=lnlinks href=#hl-1-9> 9</a>
</span><span class=lnt id=hl-1-10><a class=lnlinks href=#hl-1-10>10</a>
</span><span class=lnt id=hl-1-11><a class=lnlinks href=#hl-1-11>11</a>
</span><span class=lnt id=hl-1-12><a class=lnlinks href=#hl-1-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 부모 클래스 정의</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Animal</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>speak</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;동물이 소리를 냅니다.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 자식 클래스가 부모 클래스를 상속</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dog</span><span class=p>(</span><span class=n>Animal</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>speak</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;멍멍!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dog</span> <span class=o>=</span> <span class=n>Dog</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>dog</span><span class=o>.</span><span class=n>speak</span><span class=p>()</span>  <span class=c1># 출력: 멍멍!</span>
</span></span></code></pre></td></tr></table></div></div><pre class=mermaid>graph LR
    subgraph &#34;상속 (Inheritance)&#34;
        A1[BaseClass] --&gt; A2[DerivedClass1]
        A1 --&gt; A3[DerivedClass2]
        A2 --&gt; A4[SubDerivedClass]
    end
    
    
    style A1 fill:#ffcdd2
    style A2 fill:#ffcdd2
    style A3 fill:#ffcdd2
    style A4 fill:#ffcdd2
    
</pre><h5 id=컴포지션-composition>컴포지션 (Composition)<a hidden class=anchor aria-hidden=true href=#컴포지션-composition>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 동물의 행동을 별도의 클래스로 분리</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SpeakBehavior</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>speak</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;동물이 소리를 냅니다.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dog</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>speak_behavior</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>speak_behavior</span> <span class=o>=</span> <span class=n>speak_behavior</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>speak</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>speak_behavior</span><span class=o>.</span><span class=n>speak</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dog</span> <span class=o>=</span> <span class=n>Dog</span><span class=p>(</span><span class=n>SpeakBehavior</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>dog</span><span class=o>.</span><span class=n>speak</span><span class=p>()</span>  <span class=c1># 출력: 동물이 소리를 냅니다.</span>
</span></span></code></pre></td></tr></table></div></div><pre class=mermaid>graph LR    
    subgraph &#34;컴포지션 (Composition)&#34;
        B1[MainClass] --&gt; B2[Component1]
        B1 --&gt; B3[Component2]
        B1 --&gt; B4[Component3]
    end

    style B1 fill:#c8e6c9
    style B2 fill:#c8e6c9
    style B3 fill:#c8e6c9
    style B4 fill:#c8e6c9
</pre><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h4><table><thead><tr><th>구성 요소</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>인터페이스/추상 클래스</strong></td><td>계약 정의</td><td>구현체들의 공통 규격 제공</td></tr><tr><td><strong>구현 클래스들</strong></td><td>실제 기능 구현</td><td>특정 행동의 구체적 구현</td></tr><tr><td><strong>컴포지트 클래스</strong></td><td>객체 조합</td><td>여러 컴포넌트를 조합하여 새로운 기능 제공</td></tr><tr><td><strong>델리게이션 메커니즘</strong></td><td>작업 위임</td><td>적절한 컴포넌트에게 작업 전달</td></tr><tr><td><strong>팩토리 클래스</strong></td><td>객체 생성 관리</td><td>적절한 구현체 선택 및 생성</td></tr><tr><td><strong>설정 관리자</strong></td><td>구성 정보 관리</td><td>런타임 구성 변경 지원</td></tr></tbody></table><h4 id=아키텍처-다이어그램>아키텍처 다이어그램<a hidden class=anchor aria-hidden=true href=#아키텍처-다이어그램>#</a></h4><pre class=mermaid>graph TB
    subgraph &#34;클라이언트 계층&#34;
        Client[클라이언트 코드]
    end
    
    subgraph &#34;조합 계층&#34;
        Composite[컴포지트 클래스]
        Factory[팩토리]
    end
    
    subgraph &#34;인터페이스 계층&#34;
        IFilter[IFilter 인터페이스]
        ILogger[ILogger 인터페이스]
        IHandler[IHandler 인터페이스]
    end
    
    subgraph &#34;구현 계층&#34;
        TextFilter[텍스트 필터]
        LevelFilter[레벨 필터]
        FileLogger[파일 로거]
        ConsoleLogger[콘솔 로거]
        EmailHandler[이메일 핸들러]
        DBHandler[DB 핸들러]
    end
    
    Client --&gt; Composite
    Client --&gt; Factory
    Composite --&gt; IFilter
    Composite --&gt; ILogger
    Composite --&gt; IHandler
    IFilter --&gt; TextFilter
    IFilter --&gt; LevelFilter
    ILogger --&gt; FileLogger
    ILogger --&gt; ConsoleLogger
    IHandler --&gt; EmailHandler
    IHandler --&gt; DBHandler
    Factory --&gt; TextFilter
    Factory --&gt; FileLogger
    Factory --&gt; EmailHandler
    
    style Client fill:#e3f2fd
    style Composite fill:#f3e5f5
    style Factory fill:#f3e5f5
    style IFilter fill:#e8f5e8
    style ILogger fill:#e8f5e8
    style IHandler fill:#e8f5e8
    style TextFilter fill:#fff3e0
    style LevelFilter fill:#fff3e0
    style FileLogger fill:#fff3e0
    style ConsoleLogger fill:#fff3e0
    style EmailHandler fill:#fff3e0
    style DBHandler fill:#fff3e0
</pre><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>기법명</th><th>정의 및 구성</th><th>목적</th><th>예시/시나리오</th></tr></thead><tbody><tr><td>인터페이스 기반 컴포지션</td><td>인터페이스로 행동 정의, 구현체 주입</td><td>행동의 유연한 확장</td><td>전략 패턴 (Strategy Pattern)</td></tr><tr><td>데코레이터 패턴</td><td>객체에 기능을 동적으로 추가</td><td>런타임 기능 확장</td><td>데코레이터 패턴 (Decorator Pattern)</td></tr><tr><td>의존성 주입 (DI)</td><td>외부에서 구현 객체 주입</td><td>결합도 감소, 테스트 용이성 향상</td><td>스프링 프레임워크의 DI</td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유연성</td><td>런타임에 행동 변경 및 확장 가능, 유지보수성 우수</td></tr><tr><td></td><td>캡슐화</td><td>객체 내부 구현 숨김, 결합도 낮음</td></tr><tr><td></td><td>재사용성</td><td>기능 단위별로 객체 조합, 다양한 조합 가능</td></tr><tr><td></td><td>테스트 용이성</td><td>각 컴포넌트 단위 테스트 가능</td></tr><tr><td>⚠ 단점</td><td>구현 복잡성</td><td>설계가 복잡해질 수 있음, 객체 조합 관리 필요</td></tr><tr><td></td><td>코드 길이</td><td>단순한 경우 상속보다 코드가 길어질 수 있음</td></tr><tr><td></td><td>성능 오버헤드</td><td>객체 참조 및 위임 (Delegation) 으로 인한 오버헤드 발생 가능</td></tr></tbody></table><h3 id=상속의-문제점>상속의 문제점<a hidden class=anchor aria-hidden=true href=#상속의-문제점>#</a></h3><p>합성 우선 상속 원칙이 등장한 이유는 상속이 가진 여러 문제점 때문이다.</p><ol><li><p>강한 결합도:<br>상속은 부모 클래스와 자식 클래스 사이에 강한 결합을 만든다. 부모 클래스의 변경이 모든 자식 클래스에 영향을 미친다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Animal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>breathe</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Breathing&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>eat</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Eating normally&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Dog</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Animal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>bark</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Woof&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 나중에 Animal 클래스의 eat() 메서드가 변경됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Animal</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>breathe</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Breathing&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>eat</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>validateFood</span><span class=p>();</span><span class=w> </span><span class=c1>// 새로운 검증 메서드 추가</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Eating with validation&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>validateFood</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 검증 로직</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>이 변경은 Dog 클래스의 동작에도 영향을 미친다. Dog 클래스의 개발자는 이러한 변경을 예상하지 못했을 수 있다.</li></ul></li><li><p>취약한 베이스 클래스 문제:<br>부모 클래스의 변경이 자식 클래스를 <strong>망가뜨릴</strong> 수 있는 상황을 <strong>취약한 베이스 클래스 문제</strong> 라고 한다. 이것은 상속의 주요 문제점 중 하나이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Stack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>elements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>push</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>elements</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>item</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=nf>pop</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>elements</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>EmptyStackException</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>elements</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>elements</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>size</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>elements</span><span class=p>.</span><span class=na>size</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Stack을 확장하는 MyStack</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>MyStack</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>Stack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>pushAll</span><span class=p>(</span><span class=n>Collection</span><span class=o>&lt;?&gt;</span><span class=w> </span><span class=n>items</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>items</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>push</span><span class=p>(</span><span class=n>item</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 나중에 Stack 클래스가 변경됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Stack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 변경: elements를 private으로 변경</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>elements</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 나머지 메서드는 동일</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>이 변경으로 인해 MyStack 클래스의 pushAll 메서드는 더 이상 작동하지 않게 된다.</li></ul></li><li><p>다중 상속의 제한:<br>많은 언어 (Java, C# 등) 는 단일 상속만 지원한다. 이는 여러 소스에서 기능을 상속받아야 할 경우 심각한 제한이 된다.</p></li><li><p>계층 구조의 경직성:<br>상속은 컴파일 타임에 결정되므로, 런타임에 객체의 행동을 변경하기 어렵다. 이는 설계의 유연성을 제한한다.</p></li></ol><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><table><thead><tr><th>분류</th><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>구조적 문제</td><td>다중 상속 문제 (Diamond Problem)</td><td>여러 클래스가 같은 상위 클래스를 상속받을 때 메서드 호출이 모호해짐</td><td>인터페이스 기반 설계, 가상 상속 (Virtual Inheritance), 컴포지션 기반 설계 전환</td></tr><tr><td>설계 문제</td><td>클래스 폭발 (Class Explosion)</td><td>기능 조합이 많아질수록 클래스 수가 지수적으로 증가</td><td>런타임 컴포지션 활용, 팩토리 패턴 적용, 설정 기반 동적 구성</td></tr><tr><td>코드 품질</td><td>보일러플레이트 코드</td><td>위임 메서드, 생성자 코드 등 반복되는 코드가 많아짐</td><td>Python <code>__getattr__</code>, Kotlin 위임, 코드 생성 도구, 추상화 레벨 조정</td></tr><tr><td>설계 복잡성</td><td>객체 관계 복잡화</td><td>조합된 객체 간 관계가 많아져 설계 이해와 유지보수 어려움</td><td>명확한 인터페이스 설계, UML/문서화, 설계 패턴 활용 (예: 전략 패턴, 퍼사드 패턴 등)</td></tr><tr><td>운영 문제</td><td>객체 생성/관리 어려움</td><td>조합 객체의 수명 주기와 생성 방식 관리가 어려움</td><td>DI(Dependency Injection) 프레임워크 활용 (Spring, NestJS 등), 생명주기 관리 자동화 도구</td></tr><tr><td>성능 문제</td><td>성능 저하 가능성</td><td>조합 계층이 깊어질수록 메서드 호출 스택 증가 및 처리 지연 발생</td><td>필요한 조합만 유지, 병목 부분은 수동 최적화, 캐싱 및 Lazy Initialization 적용</td></tr><tr><td>유지보수 문제</td><td>테스트 복잡성</td><td>조합된 객체 간 단위 테스트 분리가 어려울 수 있음</td><td>의존성 분리를 통한 테스트 더블 (Mock/Stub) 활용, 단일 책임 설계</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><h4 id=컴포지션-종류>컴포지션 종류<a hidden class=anchor aria-hidden=true href=#컴포지션-종류>#</a></h4><table><thead><tr><th>종류</th><th>설명</th><th>특징</th><th>예시</th></tr></thead><tbody><tr><td><strong>집합 (Aggregation)</strong></td><td>부분이 전체와 독립적으로 존재</td><td>약한 관계, 공유 가능</td><td>대학교 - 학생</td></tr><tr><td><strong>합성 (Composition)</strong></td><td>부분이 전체에 종속적으로 존재</td><td>강한 관계, 생명주기 동일</td><td>자동차 - 엔진</td></tr><tr><td><strong>연관 (Association)</strong></td><td>객체 간 사용 관계</td><td>독립적 존재, 참조 관계</td><td>사람 - 직업</td></tr></tbody></table><h4 id=패턴-유형>패턴 유형<a hidden class=anchor aria-hidden=true href=#패턴-유형>#</a></h4><table><thead><tr><th>유형</th><th>패턴</th><th>목적</th><th>컴포지션 활용 방식</th></tr></thead><tbody><tr><td><strong>구조적 패턴</strong></td><td>Adapter, Bridge, Decorator</td><td>인터페이스 적응 및 확장</td><td>래핑과 위임</td></tr><tr><td><strong>행동 패턴</strong></td><td>Strategy, Observer, Command</td><td>알고리즘 및 행동 교체</td><td>행동 객체 조합</td></tr><tr><td><strong>생성 패턴</strong></td><td>Builder, Abstract Factory</td><td>복잡한 객체 생성</td><td>컴포넌트 조립</td></tr></tbody></table><h4 id=구현-방식>구현 방식<a hidden class=anchor aria-hidden=true href=#구현-방식>#</a></h4><table><thead><tr><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>인터페이스 기반 컴포지션</td><td>인터페이스로 행동 정의, 구현체 주입</td></tr><tr><td>객체 참조 기반 컴포지션</td><td>객체를 멤버 변수로 포함</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>분야</th><th>적용 사례</th><th>컴포지션 활용 방식</th><th>이점</th></tr></thead><tbody><tr><td><strong>웹 프레임워크</strong></td><td>Spring Framework DI, 미들웨어 구성</td><td>객체 조합, 의존성 주입 (Dependency Injection)</td><td>느슨한 결합, 테스트 용이성, 유지보수 용이</td></tr><tr><td><strong>로깅 시스템</strong></td><td>Java Logging, Python logging</td><td>Handler, Filter, Formatter 의 동적 조합</td><td>유연한 로그 처리 파이프라인 구성</td></tr><tr><td><strong>UI 프레임워크</strong></td><td>React 컴포넌트 시스템</td><td>재사용 가능한 컴포넌트의 합성 및 데코레이터 패턴</td><td>모듈화, 유지보수 용이, 확장성 높음</td></tr><tr><td><strong>게임 엔진</strong></td><td>Unity 의 GameObject-Component 구조</td><td>GameObject 에 컴포넌트 단위 기능을 조합</td><td>기능 단위 분리, 동적 조합, 재사용성</td></tr><tr><td><strong>데이터베이스 ORM</strong></td><td>Hibernate, JPA 의 연관 매핑 구조</td><td>Entity 간의 조합 및 위임</td><td>객체 - 관계 매핑 유연성</td></tr><tr><td><strong>마이크로서비스</strong></td><td>API Gateway, Service Mesh 구성</td><td>서비스 단위 조합 및 위임</td><td>확장성, 서비스 독립성, 탄력적 구조</td></tr><tr><td><strong>결제 시스템</strong></td><td>전략 패턴 기반 결제 수단 선택 시스템</td><td>PaymentStrategy 인터페이스로 동적 조합</td><td>다양한 결제 방식 유연 대응</td></tr><tr><td><strong>웹 요청 처리</strong></td><td>Express.js, Django 미들웨어 체인 구성</td><td>요청 처리 흐름을 함수형 컴포넌트로 조합</td><td>책임 분리, 확장성</td></tr><tr><td><strong>프론트엔드 UI 확장</strong></td><td>데코레이터 패턴 기반 기능 확장 (ex. Tooltip)</td><td>기본 UI 에 기능을 조합하여 동적으로 확장</td><td>코드 재사용, 유연한 UI 동작</td></tr><tr><td><strong>도메인 객체 설계</strong></td><td>사용자, 주문, 상품 등의 도메인 조합</td><td>독립 도메인 객체를 조합하여 기능을 구성</td><td>높은 응집도, 결합도 낮춤</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-온라인-쇼핑몰의-결제-시스템>사례 1: 온라인 쇼핑몰의 결제 시스템<a hidden class=anchor aria-hidden=true href=#사례-1-온라인-쇼핑몰의-결제-시스템>#</a></h4><p><strong>시나리오</strong>: 온라인 쇼핑몰의 결제 시스템에 다양한 결제 수단을 지원.<br><strong>시스템 구성</strong>:</p><ul><li><strong>PaymentStrategy 인터페이스</strong>: 결제 방식의 공통 인터페이스를 정의한다.</li><li><strong>CreditCardPayment, PayPalPayment 클래스</strong>: PaymentStrategy 인터페이스를 구현하여 각각의 결제 방식을 제공한다.</li><li><strong>ShoppingCart 클래스</strong>: PaymentStrategy 객체를 조합하여 결제 기능을 구성한다.</li></ul><p><strong>구성 다이어그램</strong>:</p><pre class=mermaid>classDiagram
    class PaymentStrategy {
        &lt;&lt;interface&gt;&gt;
        +pay(amount: float): void
    }

    class CreditCardPayment {
        +pay(amount: float): void
    }

    class PayPalPayment {
        +pay(amount: float): void
    }

    class ShoppingCart {
        -paymentStrategy: PaymentStrategy
        +setPaymentStrategy(strategy: PaymentStrategy): void
        +checkout(amount: float): void
    }

    PaymentStrategy &lt;|-- CreditCardPayment
    PaymentStrategy &lt;|-- PayPalPayment
    ShoppingCart --&gt; PaymentStrategy
</pre><p><strong>워크플로우</strong>:</p><ol><li>사용자가 결제 수단을 선택한다.</li><li>선택된 결제 수단에 해당하는 PaymentStrategy 구현체가 ShoppingCart 에 주입된다.</li><li><code>ShoppingCart</code> 는 주입된 <code>PaymentStrategy</code> 를 이용하여 <code>pay(amount)</code> 메서드를 호출하고, 해당 구현체의 로직에 따라 결제가 처리된다.</li><li>결제 결과에 따라 후속 처리 (주문 상태 변경, 알림 발송 등) 를 수행한다.</li></ol><p><strong>Workflow 다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
    participant User
    participant ShoppingCart
    participant PaymentStrategy
    participant PayPalPayment
    participant CreditCardPayment

    User-&gt;&gt;ShoppingCart: setPaymentStrategy(PayPalPayment)
    User-&gt;&gt;ShoppingCart: checkout(100.00)
    ShoppingCart-&gt;&gt;PaymentStrategy: pay(100.00)
    PaymentStrategy-&gt;&gt;PayPalPayment: pay(100.00)
    PayPalPayment--&gt;&gt;ShoppingCart: 결제 성공
    ShoppingCart--&gt;&gt;User: 주문 완료 알림
</pre><hr><p><strong>담당 역할</strong></p><table><thead><tr><th>구성 요소</th><th>역할 설명</th></tr></thead><tbody><tr><td><code>PaymentStrategy</code></td><td>다양한 결제 방식의 공통 인터페이스 제공</td></tr><tr><td><code>CreditCardPayment</code></td><td>신용카드 결제 기능 구현</td></tr><tr><td><code>PayPalPayment</code></td><td>페이팔 결제 기능 구현</td></tr><tr><td><code>ShoppingCart</code></td><td>사용자가 선택한 전략 객체를 조합하여 결제 처리 수행</td></tr></tbody></table><h4 id=사례-2-게임-캐릭터-시스템>사례 2: 게임 캐릭터 시스템<a hidden class=anchor aria-hidden=true href=#사례-2-게임-캐릭터-시스템>#</a></h4><p><strong>시나리오</strong>: 캐릭터는 점프, 공격, 방어 등 다양한 능력을 가질 수 있음. 각 능력을 컴포넌트로 구현하고, 캐릭터 객체에 필요한 능력을 조합하여 부여.</p><p><strong>시스템 구성 및 다이어그램</strong>:</p><pre class=mermaid>classDiagram
    class Character {
        +addAbility(Ability)
        +useAbility()
    }
    class Ability {
        +execute()
    }
    class JumpAbility {
        +execute()
    }
    class AttackAbility {
        +execute()
    }
    Character --&gt; Ability : has-a
    Ability &lt;|-- JumpAbility
    Ability &lt;|-- AttackAbility
</pre><p><strong>Workflow</strong>:</p><ol><li>캐릭터 객체 생성</li><li>점프, 공격 등 능력 (Ability) 컴포넌트 생성</li><li>캐릭터에 필요한 능력 추가</li><li>캐릭터가 상황에 따라 능력 사용</li></ol><p><strong>역할</strong>:</p><ul><li>Character: 능력 관리 및 실행</li><li>Ability: 행동 인터페이스</li><li>JumpAbility/AttackAbility: 구체적 행동 구현</li></ul><h4 id=사례-3-로깅-시스템-구현>사례 3: 로깅 시스템 구현<a hidden class=anchor aria-hidden=true href=#사례-3-로깅-시스템-구현>#</a></h4><p><strong>시나리오</strong>: 대규모 웹 애플리케이션에서 다양한 레벨의 로그를 여러 출력 대상 (콘솔, 파일, 데이터베이스, 이메일) 으로 전송하고, 각각에 다른 필터링 규칙을 적용해야 하는 상황</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    subgraph &#34;클라이언트 애플리케이션&#34;
        App[Web Application]
    end
    
    subgraph &#34;로깅 시스템&#34;
        Logger[Logger]
        FilterChain[Filter Chain]
        HandlerManager[Handler Manager]
    end
    
    subgraph &#34;필터 컴포넌트&#34;
        LevelFilter[Level Filter]
        TextFilter[Text Filter]
        TimeFilter[Time Filter]
    end
    
    subgraph &#34;핸들러 컴포넌트&#34;
        ConsoleHandler[Console Handler]
        FileHandler[File Handler]
        DBHandler[Database Handler]
        EmailHandler[Email Handler]
    end
    
    subgraph &#34;포맷터 컴포넌트&#34;
        SimpleFormatter[Simple Formatter]
        JSONFormatter[JSON Formatter]
        XMLFormatter[XML Formatter]
    end
    
    App --&gt; Logger
    Logger --&gt; FilterChain
    Logger --&gt; HandlerManager
    FilterChain --&gt; LevelFilter
    FilterChain --&gt; TextFilter
    FilterChain --&gt; TimeFilter
    HandlerManager --&gt; ConsoleHandler
    HandlerManager --&gt; FileHandler
    HandlerManager --&gt; DBHandler
    HandlerManager --&gt; EmailHandler
    ConsoleHandler --&gt; SimpleFormatter
    FileHandler --&gt; JSONFormatter
    DBHandler --&gt; JSONFormatter
    EmailHandler --&gt; XMLFormatter
    
    style App fill:#e3f2fd
    style Logger fill:#f3e5f5
    style FilterChain fill:#f3e5f5
    style HandlerManager fill:#f3e5f5
    style LevelFilter fill:#e8f5e8
    style TextFilter fill:#e8f5e8
    style TimeFilter fill:#e8f5e8
    style ConsoleHandler fill:#fff3e0
    style FileHandler fill:#fff3e0
    style DBHandler fill:#fff3e0
    style EmailHandler fill:#fff3e0
</pre><p><strong>활용 사례 Workflow</strong>:</p><pre class=mermaid>sequenceDiagram
    participant App as Application
    participant Logger as Logger
    participant FC as FilterChain
    participant HM as HandlerManager
    participant CH as ConsoleHandler
    participant FH as FileHandler
    participant EH as EmailHandler
    
    App-&gt;&gt;Logger: log(&#34;ERROR: Database connection failed&#34;)
    Logger-&gt;&gt;FC: filter(message)
    FC-&gt;&gt;FC: LevelFilter.filter(ERROR)
    FC-&gt;&gt;FC: TextFilter.filter(&#34;Database&#34;)
    FC-&gt;&gt;Logger: return true (passed)
    Logger-&gt;&gt;HM: handle(message)
    HM-&gt;&gt;CH: handle(message)
    CH-&gt;&gt;CH: format &amp; output to console
    HM-&gt;&gt;FH: handle(message)
    FH-&gt;&gt;FH: format &amp; write to file
    HM-&gt;&gt;EH: handle(message)
    EH-&gt;&gt;EH: format &amp; send email alert
    Logger-&gt;&gt;App: return success
</pre><p><strong>컴포지션의 역할</strong>:</p><ol><li><p>유연한 구성:</p><ul><li>런타임에 필터와 핸들러 조합 변경 가능</li><li>새로운 출력 형식 추가 시 기존 코드 수정 불필요</li></ul></li><li><p>독립적 테스트:</p><ul><li>각 컴포넌트를 Mock 객체로 대체하여 단위 테스트</li><li>통합 테스트에서 실제 구현체 조합</li></ul></li><li><p>확장성:</p><ul><li>새로운 필터 유형 추가 (예: 사용자별 필터)</li><li>새로운 출력 대상 추가 (예: Slack, Teams)</li></ul></li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계 단계</strong></td><td>인터페이스 정의</td><td>기능 단위로 인터페이스를 분리하여 각 객체의 책임을 명확히 함</td><td>SRP(단일 책임 원칙) 기반 설계, 공통 동작을 추상화하여 전략 객체 설계</td></tr><tr><td></td><td>책임 분리</td><td>조합된 객체에 과도한 책임이 몰리는 것을 방지</td><td>한 객체가 하나의 역할만 수행하도록 분리 (SoC: Separation of Concerns)</td></tr><tr><td></td><td>설계 복잡성 관리</td><td>조합 구조가 복잡해지면 이해와 유지보수가 어려워짐</td><td>설계 문서화, UML 다이어그램 활용, 리뷰 문화 도입</td></tr><tr><td><strong>구현 단계</strong></td><td>객체 수명 주기 관리</td><td>동적으로 조합되는 객체의 생성/소멸 및 공유 범위 명확히 관리 필요</td><td>DI(Dependency Injection) 프레임워크 활용, Singleton/Lifecycle 적용</td></tr><tr><td></td><td>코드 중복 방지</td><td>위임 메서드 등에서 반복 코드 발생 가능성 존재</td><td>Python: <code>__getattr__</code>, Kotlin: 위임 키워드, Java: Lombok 사용</td></tr><tr><td><strong>성능 관리</strong></td><td>메소드 호출 오버헤드</td><td>컴포지션으로 인해 호출 계층이 증가하면서 미세한 성능 저하 발생 가능</td><td>성능 민감한 로직은 직접 구현 (Flat Delegation), Hot Path 는 단순화</td></tr><tr><td></td><td>메모리 사용 최적화</td><td>불필요한 객체 다수 생성 시 메모리 과다 사용 가능</td><td>Singleton, 객체 풀링, Lazy Initialization 적용</td></tr><tr><td><strong>테스트/운영</strong></td><td>테스트 용이성 확보</td><td>각 조합 단위 객체에 대한 테스트가 어려울 수 있음</td><td>DI 기반 Mock 객체 주입, 단위 테스트 시나리오 설계</td></tr><tr><td></td><td>변경 대응력</td><td>객체 간 조합 관계가 많을수록 변경에 의한 영향도 증가</td><td>인터페이스 기반 설계, 버전 관리 전략 도입, Contract 기반 개발 도입</td></tr><tr><td></td><td>코드 가독성</td><td>조합된 객체 간의 흐름이 명확하지 않으면 유지보수가 어려움</td><td>가독성 중심의 설계, 주석 또는 문서화를 통한 의도 전달</td></tr></tbody></table><ol><li><strong>기능 단위 분리와 인터페이스화</strong>를 선행하지 않으면 컴포지션의 이점이 퇴색된다.</li><li><strong>조합 대상의 책임이 명확하지 않거나 너무 많을 경우</strong> 구조가 오히려 상속보다 더 복잡해진다.</li><li><strong>의존성 주입 없이 직접 객체 생성 시</strong>, 객체 수명 및 테스트 통제가 어려워질 수 있다.</li><li><strong>설계 문서와 코드 간 괴리</strong>가 생기지 않도록, 초기 설계와 실제 구현을 지속적으로 동기화해야 한다.</li><li><strong>성능 저하 요소</strong>(과도한 위임, 깊은 객체 참조 등) 는 반드시 사전 프로파일링과 모니터링으로 검증해야 한다.</li></ol><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>카테고리</th><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>메서드 호출</strong></td><td>호출 계층 최소화</td><td>조합이 깊어질수록 호출 체인이 길어지고 스택 오버헤드 증가 가능</td><td>핵심 기능만 조합, 불필요한 위임 제거, 인라인 최적화 또는 함수 캐싱 활용</td></tr><tr><td><strong>메서드 호출</strong></td><td>위임 오버헤드</td><td>위임 방식이 많아질 경우 메서드 호출 체인으로 인한 성능 저하 발생</td><td>위임은 핵심 로직에 최소화, 중첩 조합 대신 단일 목적 함수로 분리</td></tr><tr><td><strong>객체 생성</strong></td><td>초기화 비용</td><td>전략 객체나 조합 객체가 복잡한 초기화 과정을 가지면 성능 저하 요인</td><td>Lazy Initialization(지연 초기화), Singleton 또는 프로토타입 패턴 활용</td></tr><tr><td><strong>객체 생성</strong></td><td>객체 과다 생성</td><td>조합된 구조에서 반복적으로 객체 생성 시 GC 부담 증가</td><td>Factory 패턴 활용, 객체 풀링 적용 (특히 I/O, 네트워크 객체 등)</td></tr><tr><td><strong>메모리</strong></td><td>메모리 사용 최적화</td><td>상태를 유지하는 전략 객체나 중첩 조합은 메모리 사용량을 증가시킬 수 있음</td><td>Stateless 설계 우선, 약한 참조 (<code>weakref</code>, <code>WeakMap</code>) 활용, 불필요한 참조 제거</td></tr><tr><td><strong>런타임 동작</strong></td><td>Reflection 및 동적 바인딩</td><td>Reflection, eval, Proxy 등 런타임 해석 기반 조합은 CPU 오버헤드 유발</td><td>컴파일 타임 검증 가능한 언어 구조 활용 (Java interface, TypeScript 타입 등)</td></tr><tr><td><strong>동시성</strong></td><td>스레드 안전성 확보</td><td>조합 객체 간 상태 공유 시 동시성 이슈 발생 가능</td><td>Immutable 객체 설계, 필요한 경우 최소 범위의 동기화 적용</td></tr><tr><td><strong>관찰 및 대응</strong></td><td>성능 병목 진단 및 모니터링</td><td>조합 구조는 문제 발생 위치 추적이 어려움</td><td>APM, 프로파일러 도구 활용 (예: Py-Spy, JFR, Chrome DevTools), 병목 로그화</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>함수형 프로그래밍</strong></td><td>고차 함수 (Higher-Order Functions)</td><td>함수를 조합하여 새로운 기능 구현</td></tr><tr><td><strong>마이크로서비스</strong></td><td>서비스 컴포지션 패턴</td><td>여러 서비스를 조합하여 복잡한 비즈니스 로직 구현</td></tr><tr><td><strong>리액티브 프로그래밍</strong></td><td>스트림 컴포지션</td><td>데이터 스트림을 조합하여 복잡한 데이터 플로우 구성</td></tr><tr><td><strong>도메인 주도 설계</strong></td><td>애그리게이트 패턴</td><td>도메인 객체들을 조합하여 비즈니스 규칙 구현</td></tr><tr><td><strong>클라우드 아키텍처</strong></td><td>서버리스 컴포지션</td><td>함수들을 조합하여 애플리케이션 구성</td></tr><tr><td><strong>AI/ML</strong></td><td>파이프라인 컴포지션</td><td>데이터 전처리, 모델 훈련, 예측을 조합한 ML 파이프라인</td></tr></tbody></table><h3 id=하위-주제로-분류해서-추가적으로-학습해야-할-내용>하위 주제로 분류해서 추가적으로 학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류해서-추가적으로-학습해야-할-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>객체지향 설계 원칙</td><td>SOLID 원칙</td><td>객체 지향 프로그래밍의 5 가지 핵심 원칙</td></tr><tr><td>디자인 패턴</td><td>전략 패턴</td><td>동작을 캡슐화하여 런타임에 교체 가능하게 하는 패턴</td></tr><tr><td>디자인 패턴</td><td>데코레이터 패턴</td><td>기존 기능을 변경하지 않고 기능을 확장할 수 있는 패턴</td></tr><tr><td>테스트 전략</td><td>테스트 더블 (Mock, Stub 등)</td><td>외부 의존성을 대체하여 유닛 테스트를 용이하게 함</td></tr><tr><td>DI 프레임워크</td><td>Spring DI / NestJS DI</td><td>구성 기반 설계의 실제 구현을 돕는 프레임워크</td></tr><tr><td>리팩토링 기법</td><td>상속 → 조합 전환</td><td>기존 상속 기반 구조를 조합 기반으로 리팩토링하는 기법</td></tr><tr><td><strong>동시성 패턴</strong></td><td>Actor 모델</td><td>액터들의 조합을 통한 동시성 시스템 구축</td></tr></tbody></table><h3 id=관련-분야별-추가-학습-내용>관련 분야별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야별-추가-학습-내용>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>헥사고날 아키텍처</td><td>포트와 어댑터를 통한 비즈니스 로직과 외부 시스템 분리</td></tr><tr><td><strong>데이터베이스 설계</strong></td><td>Repository 패턴</td><td>데이터 액세스 로직의 추상화와 조합</td></tr><tr><td><strong>웹 개발</strong></td><td>미들웨어 패턴</td><td>HTTP 요청 처리 과정에서 기능들의 조합</td></tr><tr><td><strong>게임 개발</strong></td><td>Component-Entity 시스템</td><td>게임 객체를 컴포넌트들의 조합으로 구성</td></tr><tr><td><strong>DevOps</strong></td><td>Infrastructure as Code</td><td>인프라 구성요소들의 선언적 조합</td></tr><tr><td><strong>분산 시스템</strong></td><td>사가 패턴 (Saga Pattern)</td><td>분산 트랜잭션을 작은 트랜잭션들의 조합으로 구현</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=객체지향-설계-핵심-개념>객체지향 설계 핵심 개념<a hidden class=anchor aria-hidden=true href=#객체지향-설계-핵심-개념>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>컴포지션 (Composition)</strong></td><td>기능을 객체 간 조합으로 구성하는 방식</td></tr><tr><td><strong>상속 (Inheritance)</strong></td><td>부모 클래스의 속성을 자식 클래스가 물려받는 구조</td></tr><tr><td><strong>Delegation (위임)</strong></td><td>책임을 다른 객체에 위임하여 수행하는 구조</td></tr><tr><td><strong>캡슐화 (Encapsulation)</strong></td><td>객체의 내부 상태를 외부에서 숨기고 인터페이스만 노출</td></tr><tr><td><strong>인터페이스 (Interface)</strong></td><td>기능 명세를 정의하는 추상적 계약</td></tr><tr><td><strong>덕 타이핑 (Duck Typing)</strong></td><td>객체의 타입보다 &rsquo; 행동 &rsquo; 을 기준으로 간주하는 방식 (동적 언어에 많음)</td></tr><tr><td><strong>인터페이스 기반 설계</strong></td><td>구현보다 인터페이스를 중심으로 설계하여 유연성과 결합도 최소화 확보</td></tr></tbody></table><h3 id=객체지향-설계-원칙>객체지향 설계 원칙<a hidden class=anchor aria-hidden=true href=#객체지향-설계-원칙>#</a></h3><table><thead><tr><th>원칙</th><th>설명</th></tr></thead><tbody><tr><td><strong>SOLID</strong></td><td>객체지향 5 대 원칙 (SRP, OCP, LSP, ISP, DIP) 의 집합적 용어</td></tr><tr><td><strong>OCP (Open-Closed Principle)</strong></td><td>확장에는 열려 있고 변경에는 닫혀 있어야 한다</td></tr><tr><td><strong>Liskov Substitution Principle</strong></td><td>자식 클래스는 부모 클래스를 대체할 수 있어야 한다</td></tr></tbody></table><h3 id=디자인-패턴>디자인 패턴<a hidden class=anchor aria-hidden=true href=#디자인-패턴>#</a></h3><table><thead><tr><th>패턴</th><th>설명</th></tr></thead><tbody><tr><td><strong>전략 패턴 (Strategy Pattern)</strong></td><td>알고리즘을 객체화하고 런타임에 교체 가능하게 하는 패턴</td></tr><tr><td><strong>데코레이터 패턴 (Decorator Pattern)</strong></td><td>기존 객체에 기능을 동적으로 확장하는 패턴</td></tr><tr><td><strong>의존성 주입 (Dependency Injection)</strong></td><td>외부에서 의존 객체를 주입받아 결합도를 낮추는 구조</td></tr><tr><td><strong>Mixin</strong></td><td>다중 클래스에 공통 기능을 주입하기 위한 재사용 기술 (주로 다중 상속 대안)</td></tr></tbody></table><h3 id=소프트웨어-품질-속성-결합도응집도>소프트웨어 품질 속성 (결합도/응집도)<a hidden class=anchor aria-hidden=true href=#소프트웨어-품질-속성-결합도응집도>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>결합도 (Coupling)</strong></td><td>클래스/모듈 간의 의존성 정도</td></tr><tr><td><strong>응집도 (Cohesion)</strong></td><td>클래스/모듈 내부 요소의 목적 집중성</td></tr><tr><td><strong>Loose Coupling (느슨한 결합)</strong></td><td>낮은 결합도를 유지하여 유연한 변경 대응 구조</td></tr><tr><td><strong>Tight Coupling (강한 결합)</strong></td><td>높은 결합도로 인해 변경 전파가 크고 유지보수가 어려운 구조</td></tr></tbody></table><h3 id=객체지향-구조-문제-및-한계>객체지향 구조 문제 및 한계<a hidden class=anchor aria-hidden=true href=#객체지향-구조-문제-및-한계>#</a></h3><table><thead><tr><th>문제</th><th>설명</th></tr></thead><tbody><tr><td><strong>Diamond Problem</strong></td><td>다중 상속으로 인한 메서드 충돌 모호성 문제</td></tr><tr><td><strong>Fragile Base Class Problem</strong></td><td>부모 클래스 변경 시 자식 클래스가 예기치 않게 깨지는 현상</td></tr></tbody></table><h3 id=성능-및-최적화-관련-기법>성능 및 최적화 관련 기법<a hidden class=anchor aria-hidden=true href=#성능-및-최적화-관련-기법>#</a></h3><table><thead><tr><th>기법</th><th>설명</th></tr></thead><tbody><tr><td><strong>Lazy Initialization</strong></td><td>실제 사용할 때까지 객체 생성을 지연시키는 기법</td></tr><tr><td><strong>객체 풀링 (Object Pooling)</strong></td><td>반복 객체 생성을 방지하고 재사용하여 성능 향상</td></tr><tr><td><strong>프로파일링 (Profiling)</strong></td><td>실행 중인 애플리케이션의 성능 병목/자원 사용 분석 도구</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://martinfowler.com/bliki/CompositionOverInheritance.html>Composition over Inheritance by Martin Fowler</a></li><li><a href=https://en.wikipedia.org/wiki/Composition_over_inheritance>Composition over inheritance - Wikipedia</a></li><li><a href=https://www.geeksforgeeks.org/favoring-composition-over-inheritance-in-java-with-examples/>Favoring Composition Over Inheritance In Java - GeeksforGeeks</a></li><li><a href=https://javarevisited.blogspot.com/2013/06/why-favor-composition-over-inheritance-java-oops-design.html>5 Reasons to Use Composition over Inheritance - Java Revisited</a></li><li><a href=https://www.digitalocean.com/community/tutorials/composition-vs-inheritance>Composition vs Inheritance - DigitalOcean</a></li><li><a href=https://python-patterns.guide/gang-of-four/composition-over-inheritance/>Composition Over Inheritance - Python Patterns Guide</a></li><li><a href=https://realpython.com/inheritance-composition-python/>Inheritance and Composition: A Python OOP Guide - Real Python</a></li><li><a href=https://dev.to/thisismahmoud/composition-over-inheritance-4fn9>Composition over Inheritance - DEV Community</a></li><li><a href=https://www.ckhang.com/blog/2020/composition-over-inheritance/>Composition over Inheritance in Game Development - CKHang</a></li><li><a href=https://veluxer62.github.io/explanation/composition-over-inheritance/>상속보다 구성을 선호하는 것은 설계의 유연성을 높이는 설계 원칙이다 - Veluxer&rsquo;s Blog</a></li><li><a href=https://sy-develop-note.tistory.com/96>상속보다는 컴포지션을 선호해야 하는 이유 - Tistory</a></li><li><a href=https://velog.io/@sseob/inheritancevscomposition>상속과 컴포지션 비교 - Velog 블로그</a></li><li><a href=https://kim6394.tistory.com/276>상속보다 컴포지션을 사용해야하는 이유 - Gyoogle</a></li><li><a href=https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design>SOLID Principles - DigitalOcean</a></li><li><a href=https://en.wikipedia.org/wiki/Design_Patterns>Design Patterns: Elements of Reusable Object-Oriented Software - GoF</a></li><li><a href=https://refactoring.guru/design-patterns/strategy>Refactoring Guru - Strategy Pattern</a></li><li><a href=https://refactoring.guru/design-patterns/decorator>Refactoring Guru - Decorator Pattern</a></li><li><a href=https://www.oreilly.com/library/view/effective-java/9780134686097/>Effective Java - Joshua Bloch</a></li><li><a href=https://www.oreilly.com/library/view/head-first-design/0596007124/>Head First Design Patterns</a></li><li><a href=https://docs.spring.io/spring-framework/reference/core/beans/dependency-injection.html>Spring Dependency Injection Reference</a></li><li><a href=https://docs.nestjs.com/fundamentals/custom-providers>NestJS Dependency Injection</a></li><li><a href=https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance>StackOverflow - Composition vs Inheritance</a></li><li><a href=http://trccompsci.online/mediawiki/index.php/OOP_Design_Principles>OOP Design Principles - TRCCompSci</a></li><li><a href=https://www.linkedin.com/pulse/composition-over-inheritance-principle-noura-boudiaf-fj87f>Composition Over Inheritance Principle - LinkedIn Article</a></li></ul><hr></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>