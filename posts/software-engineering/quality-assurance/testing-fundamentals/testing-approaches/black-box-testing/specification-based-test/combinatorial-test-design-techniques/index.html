<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>조합 테스트 설계 기법 (Combinatorial Test Design Techniques) | hyunyoun's Blog</title><meta name=keywords content="Quality-Assurance,Quality-Control,QA,QC,Test,Test-Design,Black-box-Testing,Specification-based-Test,Combinatorial-Test-Design-Techniques"><meta name=description content="조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="조합 테스트 설계 기법 (Combinatorial Test Design Techniques)"><meta property="og:description" content="조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-02T09:42:00+00:00"><meta property="article:modified_time" content="2024-11-02T09:42:00+00:00"><meta property="article:tag" content="Quality-Assurance"><meta property="article:tag" content="Quality-Control"><meta property="article:tag" content="QA"><meta property="article:tag" content="QC"><meta property="article:tag" content="Test"><meta property="article:tag" content="Test-Design"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="조합 테스트 설계 기법 (Combinatorial Test Design Techniques)"><meta name=twitter:description content="조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"조합 테스트 설계 기법 (Combinatorial Test Design Techniques)","item":"https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"조합 테스트 설계 기법 (Combinatorial Test Design Techniques)","name":"조합 테스트 설계 기법 (Combinatorial Test Design Techniques)","description":"조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.","keywords":["Quality-Assurance","Quality-Control","QA","QC","Test","Test-Design","Black-box-Testing","Specification-based-Test","Combinatorial-Test-Design-Techniques"],"articleBody":"조합 테스트 설계 기법 (Combinatorial Test Design Techniques) 조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.\n이 기법은 모든 가능한 입력 조합을 테스트하는 대신 최적화된 조합을 선택하여 테스트 범위를 최대화하고 테스트 케이스 수를 최소화한다.\n실제 테스트 설계 시에는 다음과 같은 단계를 따르는 것이 좋다:\n테스트 대상 식별\n먼저 어떤 요소들을 테스트할 것인지 명확히 한다.\n각 요소가 가질 수 있는 값들도 정의한다. 제약조건 파악\n일부 조합은 현실적으로 불가능하거나 의미가 없을 수 있다.\n예를 들어, 특정 운영체제 버전에서는 5G를 지원하지 않을 수 있다. 테스트 방법 선택\n시스템의 중요도와 가용 자원을 고려하여 적절한 테스트 방법을 선택한다. 테스트 케이스 생성\n선택한 방법에 따라 테스트 케이스를 생성한다.\n이때 자동화 도구를 활용하면 더욱 효율적이다. 주요 특징 수학적 기반: 직교 배열(Orthogonal Arrays)과 같은 수학적 개념을 활용한다. 효율성: 적은 수의 테스트 케이스로 넓은 범위의 입력 조합을 커버한다. 리스크 감소: 특정 입력 조합에서 발생할 수 있는 결함을 효과적으로 찾아낸다. 자동화 가능: 특수한 알고리즘이나 도구를 사용하여 테스트 케이스를 자동으로 생성할 수 있다. 주요 기법 페어와이즈 테스팅(Pairwise Testing): 모든 가능한 입력 매개변수 쌍의 조합을 테스트한다. N-방향 테스팅(N-way Testing): 페어와이즈를 확장하여 3개 이상의 매개변수 조합을 고려한다. 직교 배열 테스팅(Orthogonal Array Testing): 수학적 직교 배열을 사용하여 효율적인 테스트 조합을 생성한다. 올페어 알고리즘(AllPairs Algorithm): 각 변수 쌍에 대한 모든 값 조합을 효율적으로 테스트한다. 장점 테스트 케이스 수 감소: 효율적인 조합으로 필요한 테스트 케이스 수를 줄인다. 높은 결함 검출률: 다양한 입력 조합을 테스트하여 더 많은 결함을 발견할 수 있다. 시간과 비용 절감: 적은 수의 테스트로 넓은 범위를 커버하여 테스트 시간과 비용을 줄인다. 조기 결함 발견: 개발 초기 단계에서 결함을 식별할 수 있다. 한계점 복잡한 시스템에서의 적용 어려움: 매개변수가 많은 복잡한 시스템에서는 구현이 어려울 수 있다. 모든 결함 검출 불가능: 특정 시퀀스나 의존성이 필요한 결함은 놓칠 수 있다. 정확한 입력 데이터 필요: 효과적인 테스트를 위해서는 정확하고 완전한 입력 데이터가 필요하다. 조합 테스트를 더욱 효과적으로 수행하기 위한 팁 우선순위 설정:\n모든 조합을 테스트할 수 없다면, 중요도나 위험도를 기준으로 우선순위를 정한다.\n예를 들어, 사용자가 가장 많이 사용하는 조합이나 문제가 발생했을 때 영향이 큰 조합을 먼저 테스트한다.\n테스트 자동화:\n조합 테스트는 많은 테스트 케이스를 다루기 때문에, 가능한 한 자동화하는 것이 좋다.\n이를 통해 테스트 실행 시간을 단축하고 인적 오류를 줄일 수 있다.\n결과 분석:\n테스트 결과를 체계적으로 분석하여 패턴을 찾는다.\n특정 조합에서 문제가 자주 발생한다면, 그 원인을 심층적으로 조사할 필요가 있다.\n조합 테스트 설계 기법은 효율적인 테스트 케이스 생성과 높은 결함 검출률을 제공하지만, 다른 테스트 기법들과 함께 사용하여 더 완전한 테스트 전략을 수립하는 것이 중요하다.\n참고 및 출처 ","wordCount":"393","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-02T09:42:00Z","dateModified":"2024-11-02T09:42:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</h1><div class=post-description>조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.</div><div class=post-meta><span title='2024-11-02 09:42:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Quality%20Assurance/Testing%20Fundamentals/Testing%20Approaches/Black-box%20Testing/Specification-based%20Test/Combinatorial-Test-Design-Techniques.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#조합-테스트-설계-기법-combinatorial-test-design-techniques>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</a><ul><li><a href=#주요-특징>주요 특징</a></li><li><a href=#주요-기법>주요 기법</a></li><li><a href=#장점>장점</a></li><li><a href=#한계점>한계점</a></li><li><a href=#조합-테스트를-더욱-효과적으로-수행하기-위한-팁>조합 테스트를 더욱 효과적으로 수행하기 위한 팁</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=조합-테스트-설계-기법-combinatorial-test-design-techniques>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)<a hidden class=anchor aria-hidden=true href=#조합-테스트-설계-기법-combinatorial-test-design-techniques>#</a></h2><p>조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.<br>이 기법은 모든 가능한 입력 조합을 테스트하는 대신 최적화된 조합을 선택하여 테스트 범위를 최대화하고 테스트 케이스 수를 최소화한다.</p><p>실제 테스트 설계 시에는 다음과 같은 단계를 따르는 것이 좋다:</p><ol><li>테스트 대상 식별<br>먼저 어떤 요소들을 테스트할 것인지 명확히 한다.<br>각 요소가 가질 수 있는 값들도 정의한다.</li><li>제약조건 파악<br>일부 조합은 현실적으로 불가능하거나 의미가 없을 수 있다.<br>예를 들어, 특정 운영체제 버전에서는 5G를 지원하지 않을 수 있다.</li><li>테스트 방법 선택<br>시스템의 중요도와 가용 자원을 고려하여 적절한 테스트 방법을 선택한다.</li><li>테스트 케이스 생성<br>선택한 방법에 따라 테스트 케이스를 생성한다.<br>이때 자동화 도구를 활용하면 더욱 효율적이다.</li></ol><h3 id=주요-특징>주요 특징<a hidden class=anchor aria-hidden=true href=#주요-특징>#</a></h3><ol><li>수학적 기반: 직교 배열(Orthogonal Arrays)과 같은 수학적 개념을 활용한다.</li><li>효율성: 적은 수의 테스트 케이스로 넓은 범위의 입력 조합을 커버한다.</li><li>리스크 감소: 특정 입력 조합에서 발생할 수 있는 결함을 효과적으로 찾아낸다.</li><li>자동화 가능: 특수한 알고리즘이나 도구를 사용하여 테스트 케이스를 자동으로 생성할 수 있다.</li></ol><h3 id=주요-기법>주요 기법<a hidden class=anchor aria-hidden=true href=#주요-기법>#</a></h3><ol><li>페어와이즈 테스팅(Pairwise Testing): 모든 가능한 입력 매개변수 쌍의 조합을 테스트한다.</li><li>N-방향 테스팅(N-way Testing): 페어와이즈를 확장하여 3개 이상의 매개변수 조합을 고려한다.</li><li>직교 배열 테스팅(Orthogonal Array Testing): 수학적 직교 배열을 사용하여 효율적인 테스트 조합을 생성한다.</li><li>올페어 알고리즘(AllPairs Algorithm): 각 변수 쌍에 대한 모든 값 조합을 효율적으로 테스트한다.</li></ol><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><ol><li>테스트 케이스 수 감소: 효율적인 조합으로 필요한 테스트 케이스 수를 줄인다.</li><li>높은 결함 검출률: 다양한 입력 조합을 테스트하여 더 많은 결함을 발견할 수 있다.</li><li>시간과 비용 절감: 적은 수의 테스트로 넓은 범위를 커버하여 테스트 시간과 비용을 줄인다.</li><li>조기 결함 발견: 개발 초기 단계에서 결함을 식별할 수 있다.</li></ol><h3 id=한계점>한계점<a hidden class=anchor aria-hidden=true href=#한계점>#</a></h3><ol><li>복잡한 시스템에서의 적용 어려움: 매개변수가 많은 복잡한 시스템에서는 구현이 어려울 수 있다.</li><li>모든 결함 검출 불가능: 특정 시퀀스나 의존성이 필요한 결함은 놓칠 수 있다.</li><li>정확한 입력 데이터 필요: 효과적인 테스트를 위해서는 정확하고 완전한 입력 데이터가 필요하다.</li></ol><h3 id=조합-테스트를-더욱-효과적으로-수행하기-위한-팁>조합 테스트를 더욱 효과적으로 수행하기 위한 팁<a hidden class=anchor aria-hidden=true href=#조합-테스트를-더욱-효과적으로-수행하기-위한-팁>#</a></h3><ol><li><p>우선순위 설정:<br>모든 조합을 테스트할 수 없다면, 중요도나 위험도를 기준으로 우선순위를 정한다.<br>예를 들어, 사용자가 가장 많이 사용하는 조합이나 문제가 발생했을 때 영향이 큰 조합을 먼저 테스트한다.</p></li><li><p>테스트 자동화:<br>조합 테스트는 많은 테스트 케이스를 다루기 때문에, 가능한 한 자동화하는 것이 좋다.<br>이를 통해 테스트 실행 시간을 단축하고 인적 오류를 줄일 수 있다.</p></li><li><p>결과 분석:<br>테스트 결과를 체계적으로 분석하여 패턴을 찾는다.<br>특정 조합에서 문제가 자주 발생한다면, 그 원인을 심층적으로 조사할 필요가 있다.</p></li></ol><p>조합 테스트 설계 기법은 효율적인 테스트 케이스 생성과 높은 결함 검출률을 제공하지만, 다른 테스트 기법들과 함께 사용하여 더 완전한 테스트 전략을 수립하는 것이 중요하다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/quality-assurance/>Quality-Assurance</a></li><li><a href=https://buenhyden.github.io/tags/quality-control/>Quality-Control</a></li><li><a href=https://buenhyden.github.io/tags/qa/>QA</a></li><li><a href=https://buenhyden.github.io/tags/qc/>QC</a></li><li><a href=https://buenhyden.github.io/tags/test/>Test</a></li><li><a href=https://buenhyden.github.io/tags/test-design/>Test-Design</a></li><li><a href=https://buenhyden.github.io/tags/black-box-testing/>Black-Box-Testing</a></li><li><a href=https://buenhyden.github.io/tags/specification-based-test/>Specification-Based-Test</a></li><li><a href=https://buenhyden.github.io/tags/combinatorial-test-design-techniques/>Combinatorial-Test-Design-Techniques</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/scenario-testing/><span class=title>« Prev</span><br><span>Scenario Testing</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/testing-fundamentals/testing-approaches/black-box-testing/specification-based-test/random-testing/><span class=title>Next »</span><br><span>랜덤 테스팅(Random Testing)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>