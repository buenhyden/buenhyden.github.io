<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Subtree | hyunyoun's Blog</title><meta name=keywords content="DevOps-and-Infrastructure,Version-Control-Systems,Git-Workflow"><meta name=description content="Git Subtree 는 여러 독립적인 저장소의 코드를 하나의 저장소에서 통합 관리할 수 있게 해주는 Git 의 고급 기능이다. 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹하는 방식으로 작동하며, 서브모듈과 달리 별도의 메타데이터 파일 없이 일반적인 Git 워크플로우로 관리할 수 있다. 주요 장점으로는 코드 공유 용이성, 직접 수정 가능성, 양방향 동기화 등이 있으며, 단점으로는 명령어 복잡성, 저장소 크기 증가, 접근 제어 제한 등이 있다. 2025 년 현재, Git Subtree 는 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 인기를 얻고 있으며, CI/CD 파이프라인 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/git-subtree/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/git-subtree/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/git-subtree/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Git Subtree"><meta property="og:description" content="Git Subtree 는 여러 독립적인 저장소의 코드를 하나의 저장소에서 통합 관리할 수 있게 해주는 Git 의 고급 기능이다. 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹하는 방식으로 작동하며, 서브모듈과 달리 별도의 메타데이터 파일 없이 일반적인 Git 워크플로우로 관리할 수 있다. 주요 장점으로는 코드 공유 용이성, 직접 수정 가능성, 양방향 동기화 등이 있으며, 단점으로는 명령어 복잡성, 저장소 크기 증가, 접근 제어 제한 등이 있다. 2025 년 현재, Git Subtree 는 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 인기를 얻고 있으며, CI/CD 파이프라인 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-28T10:08:00+00:00"><meta property="article:modified_time" content="2024-09-28T10:08:00+00:00"><meta property="article:tag" content="DevOps-and-Infrastructure"><meta property="article:tag" content="Version-Control-Systems"><meta property="article:tag" content="Git-Workflow"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Git Subtree"><meta name=twitter:description content="Git Subtree 는 여러 독립적인 저장소의 코드를 하나의 저장소에서 통합 관리할 수 있게 해주는 Git 의 고급 기능이다. 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹하는 방식으로 작동하며, 서브모듈과 달리 별도의 메타데이터 파일 없이 일반적인 Git 워크플로우로 관리할 수 있다. 주요 장점으로는 코드 공유 용이성, 직접 수정 가능성, 양방향 동기화 등이 있으며, 단점으로는 명령어 복잡성, 저장소 크기 증가, 접근 제어 제한 등이 있다. 2025 년 현재, Git Subtree 는 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 인기를 얻고 있으며, CI/CD 파이프라인 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Version Control Systems","item":"https://buenhyden.github.io/posts/software-engineering/version-control-systems/"},{"@type":"ListItem","position":4,"name":"Git Workflow","item":"https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/"},{"@type":"ListItem","position":5,"name":"Git Subtree","item":"https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/git-subtree/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Subtree","name":"Git Subtree","description":"Git Subtree 는 여러 독립적인 저장소의 코드를 하나의 저장소에서 통합 관리할 수 있게 해주는 Git 의 고급 기능이다. 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹하는 방식으로 작동하며, 서브모듈과 달리 별도의 메타데이터 파일 없이 일반적인 Git 워크플로우로 관리할 수 있다. 주요 장점으로는 코드 공유 용이성, 직접 수정 가능성, 양방향 동기화 등이 있으며, 단점으로는 명령어 복잡성, 저장소 크기 증가, 접근 제어 제한 등이 있다. 2025 년 현재, Git Subtree 는 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 인기를 얻고 있으며, CI/CD 파이프라인 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다.","keywords":["DevOps-and-Infrastructure","Version-Control-Systems","Git-Workflow"],"articleBody":"Git Subtree Git Subtree 는 Git 에서 제공하는 저장소 관리 도구로, 하나의 저장소 안에 다른 저장소를 포함시켜 관리할 수 있게 해주는 기능이다. 서브모듈 (Submodule) 의 대안으로 개발되었으며, 주요 저장소 (상위 저장소) 에 하위 저장소의 파일들을 직접 포함시키는 방식으로 작동한다. Git Subtree 는 복잡한 프로젝트 구조에서 코드 재사용, 공유 라이브러리 관리, 여러 저장소의 통합 관리에 유용하며, 특히 상위 저장소에서 하위 저장소의 코드를 직접 수정하고 원래 하위 저장소에 변경사항을 반영할 수 있다는 점이 큰 특징이다. 이러한 기능은 팀 협업, 라이브러리 관리, 마이크로서비스 구조의 개발 등에서 활용된다.\n핵심 개념 Git Subtree는 외부 저장소를 하나의 디렉토리처럼 포함하되, 그 내용을 상위 저장소로 직접 병합하는 방식. 하위 저장소는 더 이상 참조만 되는 것이 아니라 실제 코드와 히스토리가 포함됨. 개념 설명 서브트리 외부 저장소 코드를 메인 프로젝트에 복제·통합 단일 히스토리 모든 변경 이력을 메인 저장소에서 관리 양방향 동기화 메인 ↔ 서브트리 저장소 간 변경사항 상호 반영 목적 \u0026 필요성 목적 Git Subtree 의 주요 목적은 다음과 같다:\n여러 프로젝트에서 공통 코드 또는 라이브러리를 공유하고 재사용하기 위함 하나의 저장소에서 여러 저장소를 통합 관리가 가능하게 하기 위함 저장소가 분리된 파일들을 하나의 저장소에 포함시켜 개발을 진행하기 위함 코드 공유와 동기화를 단순화하기 위함 여러 개의 프로젝트를 하나로 합치기 위함 필요성 Git Subtree 는 다음과 같은 상황에서 필요성이 대두된다:\n여러 프로젝트에 걸쳐 공통 코드나 라이브러리를 유지보수해야 할 때 백엔드를 마이크로서비스 구조로 개발하면서 API 응답, 데이터 모델에 같은 타입을 사용해 일관성을 유지해야 할 때 여러 프로젝트를 통합 관리하고자 할 때 핵심 디자인 파일을 여러 저장소에 포함시키고 싶을 때 프로젝트 히스토리를 관리하며 통합할 필요가 있을 때 주요 기능 Git Subtree 의 주요 기능은 다음과 같다:\n하위 저장소 추가: git subtree add 명령을 통해 외부 저장소를 현재 저장소에 추가 하위 저장소 업데이트: git subtree pull 명령으로 외부 저장소의 변경사항을 가져옴 변경사항 푸시: git subtree push 명령으로 로컬에서 수정한 하위 저장소 내용을 원격 저장소에 반영 병합 전략: 서브트리 병합 (subtree merge) 기능을 통해 양쪽 저장소의 변경사항을 모두 반영 역할 Git Subtree 는 다음과 같은 역할을 수행한다:\n상위 저장소에 파일을 직접 추가하고 트래킹함 서브트리의 원격에 있는 소스와 서브트리를 추가한 저장소의 소스가 서로 달라도 subtree merge 기능을 사용해 양쪽의 변경사항을 모두 반영할 수 있도록 함 상위 저장소에서 서브트리를 직접 수정하고 원격에 푸시할 수 있게 함 여러 저장소의 히스토리를 관리하며 재사용할 수 있도록 함 특징 Git Subtree 의 주요 특징은 다음과 같다:\n상위 저장소에 파일을 직접 추가하고 트래킹하기 때문에 서브트리의 변경사항도 상위 저장소에 기록됨 서브모듈과 달리 메타데이터 파일 (예:.gitmodule) 을 생성하지 않음 하위 저장소 (Child) 의 내용을 상위 저장소 (Parent) 에서 일반적인 git 명령어로 관리할 수 있음 하위 저장소의 내용을 수정하기 위해 별도의 저장소 복사본을 유지할 필요가 없음 사용자가 새로운 것을 배울 필요 없이 저장소를 사용할 수 있게 함 핵심 원칙 Git Subtree 는 다음과 같은 핵심 원칙에 기반한다:\n통합성: 여러 저장소를 하나의 저장소로 통합하여 관리 투명성: 사용자에게 서브트리의 존재를 숨기고 일반적인 Git 워크플로우 유지 양방향 동기화: 상위 저장소와 하위 저장소 간의 변경사항을 양방향으로 전파 히스토리 보존: 하위 저장소의 커밋 히스토리를 유지하면서 통합 유연성: 다양한 상황과 워크플로우에 적응할 수 있는 유연한 구조 제공 주요 원리 \u0026 작동 원리 다이어그램 1 2 3 MainRepo/ ├── project/ │ └── external-lib/ (실제 코드 포함됨) 주요 원리 Git Subtree 의 주요 원리는 다음과 같다:\n복사 원리: Subtree 는 복사 개념으로, 하위 저장소의 코드를 상위 저장소에 복사하여 포함시킴 병합 원리: 서브트리 Merge 전략을 사용하여 Git 이 서브트리를 찾아 메인 프로젝트로 서브프로젝트의 내용을 병합함 트래킹 원리: 상위 저장소가 하위 저장소의 파일을 직접 추적하며 변경사항을 기록 분할 원리: git subtree split 명령으로 서브트리의 변경사항만 추출하여 별도의 커밋으로 분리 가능 동기화 원리: 상위 저장소와 하위 저장소 간에 push 와 pull 을 통한 양방향 동기화 가능 작동 원리 Git Subtree 는 다음과 같은 방식으로 작동한다:\n추가 (Add): 먼저 원격 저장소를 추가한 후, subtree add 명령으로 하위 저장소를 특정 폴더에 추가함 하위 저장소의 전체 커밋 히스토리가 상위 저장소로 병합됨 가져오기 (Pull): 원격의 하위 저장소에 변경사항이 있을 경우, subtree pull 명령으로 상위 저장소에 반영함 상위 저장소에 하위 저장소의 최신 변경사항을 병합함 내보내기 (Push): 상위 저장소에서 하위 저장소의 내용을 수정한 후, subtree push 명령으로 원격 하위 저장소에 반영함 원래 별개의 프로젝트였던 원격 저장소에 변경사항을 동기화할 수 있음 분할 (Split): subtree split 명령을 통해 마지막 분할 이후 변경된 내용만 찾아 별도의 커밋으로 분리함 이렇게 분리된 커밋들은 하위 저장소의 원격 저장소로 푸시할 수 있음 명령어 흐름 1 2 3 4 5 6 7 8 # 1. 서브트리 추가 git subtree add --prefix=external-lib https://github.com/example/lib.git main --squash # 2. 외부 변경 사항 병합 git subtree pull --prefix=external-lib https://github.com/example/lib.git main --squash # 3. 외부에 변경사항 push (있을 경우) git subtree push --prefix=external-lib https://github.com/example/lib.git main 구성 요소 및 아키텍처 Git Subtree 는 다음과 같은 구성 요소로 이루어져 있다:\n상위 저장소 (Parent Repository): 하위 저장소를 포함하는 주 저장소 모든 서브트리 조작의 기준점이 됨 일반적인 git add, commit, push, pull 로 관리함 하위 저장소 (Child Repository): 상위 저장소에 포함될 외부 저장소 원격에 독립적으로 존재하는 별도의 프로젝트 상위 저장소에서는 하나의 디렉토리로 취급됨 서브트리 참조 (Subtree Reference): git log 에 기록되는 서브트리 관련 정보 (git-subtree-dir, git-subtree-mainline, git-subtree-split 등) 서브트리의 위치와 마지막 동기화 상태를 추적하는 데 사용됨 원격 참조 (Remote Reference): 원격 저장소를 가리키는 참조 (remote add 로 추가됨) 서브트리 명령어에서 원격 저장소 이름으로 사용됨 서브트리 명령 (Subtree Commands): add, pull, push, split 등의 서브트리 전용 명령어 상위 저장소와 하위 저장소 간의 동기화를 관리함 Git Subtree 명령어 서브트리 추가 (add) 외부 저장소의 특정 브랜치를 현재 저장소의 하위 디렉토리로 가져온다.\n1 git subtree add --prefix= [--squash] 예시\n1 git subtree add --prefix=lib https://github.com/user/library.git main --squash lib 폴더에 library.git 의 main 브랜치 코드를 추가하고, 커밋 내역을 하나로 합친다 (--squash 옵션). 서브트리 업데이트 (pull) 외부 저장소의 변경사항을 메인 저장소의 하위 디렉토리에 병합한다.\n1 git subtree pull --prefix= [--squash] 예시\n1 git subtree pull --prefix=lib https://github.com/user/library.git main --squash lib 폴더의 서브트리를 최신 상태로 업데이트하며, 변경 내역을 하나의 커밋으로 합친다. 서브트리 변경사항 푸시 (push) 메인 저장소에서 하위 디렉토리 (서브트리) 에서 작업한 변경 사항을 외부 저장소로 푸시한다.\n1 git subtree push --prefix= 예시\n1 git subtree push --prefix=lib https://github.com/user/library.git main lib 디렉토리의 변경사항을 외부 저장소의 main 브랜치에 반영한다. 서브트리 분리 (split) 하위 디렉토리의 변경 내역만 별도의 브랜치로 분리한다.\n1 git subtree split --prefix= -b 예시\n1 git subtree split --prefix=lib -b lib-branch lib 폴더의 변경 이력만을 담은 lib-branch 브랜치를 생성한다. 원격 저장소 추가 (remote add) 외부 저장소를 원격 저장소로 등록해두면 명령어가 더 간결해진다.\n1 git remote add 예시\n1 git remote add library https://github.com/user/library.git 실무에서 자주 쓰는 옵션 --squash: 여러 커밋을 하나로 합쳐 메인 저장소의 커밋 히스토리를 깔끔하게 유지합니다. --prefix: 외부 저장소가 병합될 하위 디렉토리 경로를 지정합니다. 요약표 명령어 유형 명령어 예시 설명 추가 (add) git subtree add --prefix=lib https://github.com/user/library.git main --squash 외부 저장소를 하위 폴더로 추가 업데이트 (pull) git subtree pull --prefix=lib https://github.com/user/library.git main --squash 외부 저장소의 변경분 반영 푸시 (push) git subtree push --prefix=lib https://github.com/user/library.git main 하위 폴더 변경분 외부 저장소로 푸시 분리 (split) git subtree split --prefix=lib -b lib-branch 하위 폴더만 분리해 새 브랜치 생성 장점과 단점 구분 항목 설명 ✅ 장점 단일 저장소 관리 여러 개의 프로젝트를 하나의 저장소로 관리할 수 있음 간편한 사용성 사용자들이 서브트리로 의존성을 관리한다는 사실을 잊어도 될 정도로 투명하게 작동함 메타데이터 파일 없음 Git 서브모듈과 달리 새로운 메타데이터 파일 (예:.gitmodule) 을 생성하지 않음 직접 수정 가능 상위 저장소에서 서브트리를 직접 수정하고 원격에 푸시할 수 있음 일관된 워크플로 저장소 사용자들이 새로운 것을 배울 필요가 없음 자동 클론 상위 프로젝트 클론 시 서브트리의 코드도 자동으로 사용 가능함 병합 용이성 서브트리 merge 기능을 통해 양쪽 저장소의 변경사항을 모두 반영할 수 있음 오래된 Git 버전 지원 Git 1.5.2 보다 오래된 버전에서도 지원됨 ⚠ 단점 명령어 복잡성 새로운 병합 전략 (git subtree) 에 대해 학습해야 함 서브트리 위치 기억 어느 디렉토리를 –prefix 로 지정해야 하는지 기억해야 함 상위 저장소 크기 증가 하위 저장소를 복사하므로 상위 저장소의 크기가 커짐 제한된 접근 제어 모든 사용자가 서브트리의 내용을 자유롭게 변경해 원격에 푸시할 수 있음 업스트림 기여 복잡성 서브프로젝트에 코드를 기여하는 과정이 더 복잡함 책임의 분산 슈퍼 프로젝트와 서브 프로젝트 코드를 커밋에서 혼합하지 않을 책임이 개발자에게 있음 분류에 따른 종류 및 유형 종류 설명 사용 시나리오 기본 서브트리 –prefix 옵션으로 서브트리를 클론할 폴더 지정하고 원격 저장소와 브랜치를 지정하여 추가 간단한 외부 저장소 통합 시 원격 별칭 서브트리 서브트리를 원격으로 추가하여 더 짧은 형태로 참조하는 방식 반복적인 서브트리 작업 시 스쿼시 서브트리 –squash 옵션을 사용하여 외부 저장소의 커밋 기록을 하나의 커밋으로 압축 외부 저장소의 히스토리가 필요 없을 때 분할 서브트리 git subtree split 명령을 사용하여 서브디렉토리를 변경 이력과 함께 분리 하위 프로젝트를 독립 저장소로 분리할 때 병합 서브트리 -s recursive -Xsubtree=경로 옵션을 사용한 병합 전략 다른 브랜치의 서브디렉토리를 병합할 때 실무 적용 예시 적용 분야 예시 이점 코드 공유 백엔드 마이크로서비스 구조에서 API 응답, 데이터 모델의 타입을 일관되게 유지 여러 서비스 간 타입 일관성 보장 테마 관리 블로그 플랫폼의 테마를 별도 저장소로 관리하면서 메인 블로그 저장소에 통합 테마 수정과 업스트림 반영 용이 디자인 시스템 핵심 디자인 엘리먼트와 제품 개발 파일을 분리하여 핵심 디자인 파일을 여러 저장소에 포함 디자인 시스템의 일관성 유지 라이브러리 관리 무거운 의존성 (외부 도구나 라이브러리) 을 관리할 때 의존성의 전체 히스토리를 상위 저장소에 통합 라이브러리 사용 및 수정 용이 모노레포 여러 SPM(Swift Package Manager) 패키지를 개발 저장소에서 쉽게 작업하며 개별 저장소로 배포 단일 저장소 개발과 분리 배포 장점 결합 플러그인 관리 Vim 플러그인을 트래킹하여 통합하고 업데이트 플러그인 관리 및 업데이트 용이 오픈소스 통합 외부 저장소 코드를 한 번만 또는 가끔 가져와서 사용할 때 외부 코드 통합과 관리 단순화 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 고려사항 설명 주의할 점 저장소 구조 설계 밀접하게 연관된 프로젝트의 경우 모노레포 방식을 고려해야 함 관계가 느슨한 프로젝트에는 부적합할 수 있음 작업 디렉토리 관리 git subtree 관련 조작은 저장소 최상위 폴더에서 이루어져야 함 하위 디렉토리에서 명령 실행 시 오류 발생 변경사항 동기화 전략 원래 저장소에서 수정된 코드를 반영하려면 subtree pull 명령어 사용 fetch/merge 로는 동기화되지 않음 충돌 관리 변경 내역을 push 하기 전에 pull 해야 충돌 방지 양방향 동기화 시 충돌 발생 가능성 높음 자동화 고려 많은 서브트리를 관리할 경우 스크립트와 자동화를 통해 관리해야 함 수동 관리는 오류 가능성 증가 팀 교육 어느 디렉토리가 subtree 인지 별도로 기록하고 팀원들과 공유해야 함 문서화 없이는 팀원들이 혼란 겪을 수 있음 명령어 단순화 원격 별칭을 사용하여 명령어를 짧게 만드는 것이 좋음 긴 명령어는 기억하기 어렵고 오류 가능성 높음 스쿼시 옵션 사용 –squash 옵션으로 히스토리를 압축하여 관리 가능 모든 커밋 히스토리가 필요한 경우에는 부적합 최적화하기 위한 고려사항 및 주의할 점 고려사항 설명 주의할 점 저장소 크기 관리 서브트리는 상위 저장소에 파일을 직접 추가하므로 저장소 크기가 커짐 대형 저장소에서는 성능 저하 가능성 히스토리 압축 스쿼시 옵션을 사용하여 모든 커밋을 하나로 압축하면 저장소 크기와 성능 개선 상세 히스토리가 손실될 수 있음 분할 성능 리조인 옵션을 사용하여 전체 히스토리를 매번 검색하는 대신 체크포인트 활용 리조인 없이는 대형 저장소에서 속도 저하 저장소 규모 100 개 이상의 서브모듈/서브트리를 관리하는 경우 어떤 방식을 사용하든 관리가 어려움 과도한 서브트리 사용 지양 캐싱 최적화 모노레포 대비 서브트리는 더 작은 단위로 캐싱 최적화 가능 통합 빌드/CI 설정 필요 업데이트 빈도 자주 업데이트가 필요 없는 외부 코드에 적합 빈번한 업데이트가 필요한 경우 오버헤드 발생 병합 복잡성 외부 저장소의 변경사항을 메인 저장소에 병합하는 과정에서 복잡성 증가 가능 복잡한 병합 상황에 대비 필요 최신 동향 주제 항목 설명 모노레포 통합 Git Subtree 와 모노레포 Apollo 는 Git Subtree 를 사용하여 모노레포에서 Swift 패키지를 관리하는 방식을 도입함. 여러 개별 패키지를 하나의 개발 저장소에서 작업하고 자동화된 GitHub Actions 워크플로우를 통해 변경사항을 자동으로 분리하여 각 패키지 저장소로 푸시하는 방식이 인기를 얻고 있음 자동화 CI/CD 파이프라인 통합 2025 년에는 Git subtree 작업이 CI/CD 파이프라인에 통합되어 자동화된 워크플로우가 증가함. 코드 변경 시 자동으로 의존성을 관리하고 업데이트하는 방식이 표준화되고 있음 대안 솔루션 새로운 대안들 git-subrepo 와 같은 새로운 대안들이 등장하여 Git Subtree 와 Git Submodule 의 제한사항을 해결하려는 시도가 증가함. 이러한 도구들은 더 간단한 워크플로우와 향상된 협업 기능을 제공함 패키지 관리 통합 언어별 패키지 관리자와 통합 Rust 의 Cargo.toml 과 같은 텍스트 파일에 의존성 해시를 커밋하는 방식이 인기를 얻으면서, Git Subtree 는 패키지 관리자가 지원하지 않는 상황에서 주로 사용됨 하이브리드 접근법 모노레포와 멀티레포 혼합 액세스 권한에 따라 코드를 별도의 모노레포로 분할하고, git-subrepo 를 사용하여 모든 모노레포를 단일 모노레포에서 관리하는 하이브리드 접근법이 증가함 클라우드 개발 환경 원격 개발 환경에서의 최적화 클라우드 기반 개발 환경에서 Git Subtree 를 사용할 때 네트워크 지연과 저장소 크기 관리를 최적화하는 방법에 대한 관심이 증가함 주목해야 할 기술들 주제 항목 설명 자동화 도구 Git Subtree 자동화 GitHub Actions 와 같은 CI/CD 도구를 활용하여 Git Subtree 의 분할 및 병합 작업을 자동화하는 워크플로우. 이를 통해 개발자는 복잡한 Git Subtree 명령어를 직접 사용하지 않아도 됨 Git Subrepo Git Subtree 대안 https://github.com/ingydotnet/git-subrepo는 Git Subtree 와 Git Submodule 의 장점을 결합한 대안으로 주목받고 있음. 더 간단한 명령어와 향상된 기능을 제공함 모노레포 도구 기업용 모노레포 솔루션 nx 모노레포와 같은 도구들이 Angular 와 NestJS 를 함께 사용하는 프로젝트에서 활용되고 있음. 이러한 도구들은 캐싱 및 영향받는 패키지만 빌드하는 기능을 제공함 MDLR 선언적 Git 의존성 도구 MDLR(“Modular”) 은 Git Submodule 과 유사한 기능을 제공하면서도 복잡한 워크플로우를 개선한 선언적 버전 관리 Git 의존성 도구 하드 링크 활용 파일 시스템 최적화 “.boiler” 폴더에 서브모듈을 두고 하드 링크를 사용하여 애플리케이션의 “src” 디렉토리와 연결하는 방식. 이를 통해 링크된 파일 편집 시 원본 파일도 업데이트됨 의존성 관리 자동화 스마트 의존성 업데이트 서드파티 의존성을 자동으로 추적하고 관리하는 도구들이 Git Subtree 와 통합되고 있음. 이를 통해 보안 취약점이 있는 의존성을 자동으로 업데이트할 수 있음 앞으로의 전망 주제 항목 설명 단순화된 인터페이스 사용 편의성 향상 Git Subtree 의 복잡한 명령어를 단순화하고 직관적인 인터페이스를 제공하는 도구들이 더욱 발전할 것으로 예상됨. 이를 통해 더 많은 개발자가 Git Subtree 를 채택할 것으로 전망됨 AI 통합 지능형 병합 충돌 해결 AI 를 활용하여 Git Subtree 병합 충돌을 지능적으로 해결하는 도구들이 등장할 것으로 예상됨. 이는 복잡한 멀티레포 환경에서의 작업을 크게 단순화할 수 있음 하이브리드 접근법 모노레포와 멀티레포 결합 Apollo 의 Swift 패키지 관리 사례처럼 개발은 모노레포에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 더욱 인기를 얻을 것으로 전망됨 Git 네이티브 기능 확장 내장 기능 확대 Git 의 기본 기능으로 현재 Git Subtree 가 제공하는 기능을 더 직관적이고 사용하기 쉽게 통합하는 방향으로 발전할 것으로 예상됨 패키지 매니저 통합 의존성 관리 통합 언어별 패키지 매니저와 Git Subtree 의 기능을 통합하여 코드와 의존성을 함께 관리하는 통합 솔루션이 발전할 것으로 전망됨 분산 개발 최적화 원격 작업 환경 지원 전 세계적으로 분산된 개발 팀을 위해 네트워크 지연과 저장소 크기 문제를 해결하는 최적화된 Git Subtree 솔루션이 발전할 것으로 예상됨 추가 학습 주제 카테고리 주제 설명 Git 워크플로우 Git Subtree 명령어 심화 Git Subtree 의 고급 옵션과 명령어들 (split, merge 등) 에 대한 심층적인 이해 Git 워크플로우 Git Subtree vs Git Submodule 두 기능의 상세한 비교 분석과 각각 적합한 사용 사례 Git 워크플로우 Subtree 병합 전략 서브트리 병합 전략의 내부 작동 방식과 최적화 방법 시스템 설계 모노레포 아키텍처 대규모 프로젝트에서 모노레포와 Git Subtree 를 활용한 최적의 저장소 구조 설계 시스템 설계 마이크로서비스와 Git Subtree 마이크로서비스 아키텍처에서 공통 코드를 관리하기 위한 Git Subtree 활용법 자동화 Git Subtree CI/CD 통합 GitHub Actions 등을 활용한 Git Subtree 작업 자동화 방법 성능 최적화 대규모 저장소 최적화 100 개 이상의 하위 저장소를 관리할 때의 성능 최적화 방법 대안 기술 Git Subrepo Git Subtree 와 Submodule 의 대안으로서 Git Subrepo 의 활용법 대안 기술 MDLR 선언적 버전 관리 Git 의존성 도구인 MDLR 의 특징과 활용법 관련 분야 추가 학습 주제 카테고리 주제 설명 버전 관리 Git 내부 구조 Git 의 내부 구조와 저수준 명령어에 대한 이해 버전 관리 Git 병합 전략 다양한 Git 병합 전략의 비교와 각 상황에 적합한 전략 선택 방법 소프트웨어 아키텍처 모노레포 vs 멀티레포 프로젝트 규모와 성격에 따른 모노레포와 멀티레포 선택 기준 소프트웨어 아키텍처 마이크로서비스 설계 코드 공유가 필요한 마이크로서비스 아키텍처 설계 방법 의존성 관리 패키지 관리자 통합 언어별 패키지 관리자와 Git 워크플로우의 통합 방법 DevOps CI/CD 파이프라인 설계 Git Subtree 를 활용한 효율적인 CI/CD 파이프라인 구축 방법 CI/CD Subtree 빌드 자동화 .gitlab-ci.yml 또는 GitHub Actions 스크립트 구성 코드 품질 코드 공유 전략 여러 프로젝트 간 코드 공유를 위한 효과적인 전략 팀 협업 효율적인 개발 워크플로우 Git Subtree 를 활용한 분산 팀의 효율적인 협업 방법 보안 의존성 취약점 관리 Git Subtree 로 통합된 외부 코드의 보안 취약점 관리 방법 용어 정리 용어 설명 상위 저장소 (Parent Repository) Git Subtree 에서 하위 저장소를 포함하는 주 저장소 하위 저장소 (Child Repository) 상위 저장소에 포함되는 외부 저장소 서브트리 병합 (Subtree Merge) 한 프로젝트를 다른 프로젝트의 하위 디렉토리로 매핑하여 병합하는 전략 Squash Merge 여러 커밋을 단일 이력으로 병합 Detached HEAD 특정 커밋에 고정된 작업 상태 –prefix 옵션 서브트리를 클론할 폴더를 지정하는 Git Subtree 명령어 옵션 –squash 옵션 외부 저장소의 커밋 기록을 하나의 커밋으로 압축하는 옵션 subtree split 디렉토리만 분리해 독립 저장소처럼 추출하는 명령어 모노레포 (Monorepo) 여러 프로젝트를 하나의 저장소에서 관리하는 방식 멀티레포 (Multi-repo) 여러 프로젝트를 각각 별도의 저장소로 관리하는 방식 git-subrepo Git Subtree 와 Submodule 의 장점을 결합한 대안 도구 참고 자료 Atlassian 공식 가이드 GitHub 서브트리 병합 문서 JetBrains Space 최신 기능 Atlassian Git Subtree 튜토리얼 Git 공식 Git Subtree 문서 GitHub Discussions on subtree usage Git Subtree 사용하기 Git Subtree 개념 설명 Git Subtree 사용법 - 하나의 저장소에서 여러 저장소를 관리하기 Subtree 사용법 - ThreeSnakes의 개발 삽질 기록장 git subtree - 프로젝트 안의 또 다른 프로젝트 Git subtree를 활용한 코드 공유 Git - 서브모듈 서브트리 Merge 개념 설명 git subtree vs git submodule 차이점 Git Subtree: the alternative to Git Submodule Managing Git Projects: Git Subtree vs. Submodule Git Subtree vs. Git Submodule Git Submodule vs Subtree How Apollo Manages Swift Packages in a Monorepo with Git Subtrees ","wordCount":"2754","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-28T10:08:00Z","dateModified":"2024-09-28T10:08:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/git-subtree/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/version-control-systems/>Version Control Systems</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/version-control-systems/git-workflow/>Git Workflow</a></div><h1 class="post-title entry-hint-parent">Git Subtree</h1><div class=post-description>Git Subtree 는 여러 독립적인 저장소의 코드를 하나의 저장소에서 통합 관리할 수 있게 해주는 Git 의 고급 기능이다. 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹하는 방식으로 작동하며, 서브모듈과 달리 별도의 메타데이터 파일 없이 일반적인 Git 워크플로우로 관리할 수 있다. 주요 장점으로는 코드 공유 용이성, 직접 수정 가능성, 양방향 동기화 등이 있으며, 단점으로는 명령어 복잡성, 저장소 크기 증가, 접근 제어 제한 등이 있다. 2025 년 현재, Git Subtree 는 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 인기를 얻고 있으며, CI/CD 파이프라인 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다.</div><div class=post-meta><span title='2024-09-28 10:08:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Version%20Control%20Systems/Git%20Workflow/git-subtree.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git-subtree>Git Subtree</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#목적--필요성>목적 & 필요성</a></li><li><a href=#주요-기능>주요 기능</a></li><li><a href=#역할>역할</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#주요-원리--작동-원리>주요 원리 & 작동 원리</a></li><li><a href=#구성-요소-및-아키텍처>구성 요소 및 아키텍처</a></li><li><a href=#git-subtree-명령어>Git Subtree 명령어</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#분류에-따른-종류-및-유형>분류에 따른 종류 및 유형</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최신-동향>최신 동향</a></li><li><a href=#주목해야-할-기술들>주목해야 할 기술들</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#추가-학습-주제>추가 학습 주제</a></li><li><a href=#관련-분야-추가-학습-주제>관련 분야 추가 학습 주제</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-자료>참고 자료</a></li></ul></nav></div></details></div><div class=post-content><h2 id=git-subtree>Git Subtree<a hidden class=anchor aria-hidden=true href=#git-subtree>#</a></h2><p>Git Subtree 는 Git 에서 제공하는 저장소 관리 도구로, 하나의 저장소 안에 다른 저장소를 포함시켜 관리할 수 있게 해주는 기능이다. 서브모듈 (Submodule) 의 대안으로 개발되었으며, 주요 저장소 (상위 저장소) 에 하위 저장소의 파일들을 직접 포함시키는 방식으로 작동한다. Git Subtree 는 복잡한 프로젝트 구조에서 코드 재사용, 공유 라이브러리 관리, 여러 저장소의 통합 관리에 유용하며, 특히 상위 저장소에서 하위 저장소의 코드를 직접 수정하고 원래 하위 저장소에 변경사항을 반영할 수 있다는 점이 큰 특징이다. 이러한 기능은 팀 협업, 라이브러리 관리, 마이크로서비스 구조의 개발 등에서 활용된다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><strong>Git Subtree</strong>는 외부 저장소를 하나의 디렉토리처럼 포함하되, 그 내용을 상위 저장소로 직접 병합하는 방식.</li><li>하위 저장소는 더 이상 참조만 되는 것이 아니라 실제 코드와 히스토리가 포함됨.</li></ul><table><thead><tr><th>개념</th><th>설명</th></tr></thead><tbody><tr><td>서브트리</td><td>외부 저장소 코드를 메인 프로젝트에 복제·통합</td></tr><tr><td>단일 히스토리</td><td>모든 변경 이력을 메인 저장소에서 관리</td></tr><tr><td>양방향 동기화</td><td>메인 ↔ 서브트리 저장소 간 변경사항 상호 반영</td></tr></tbody></table><h3 id=목적--필요성>목적 & 필요성<a hidden class=anchor aria-hidden=true href=#목적--필요성>#</a></h3><h4 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h4><p>Git Subtree 의 주요 목적은 다음과 같다:</p><ul><li>여러 프로젝트에서 공통 코드 또는 라이브러리를 공유하고 재사용하기 위함</li><li>하나의 저장소에서 여러 저장소를 통합 관리가 가능하게 하기 위함</li><li>저장소가 분리된 파일들을 하나의 저장소에 포함시켜 개발을 진행하기 위함</li><li>코드 공유와 동기화를 단순화하기 위함</li><li>여러 개의 프로젝트를 하나로 합치기 위함</li></ul><h4 id=필요성>필요성<a hidden class=anchor aria-hidden=true href=#필요성>#</a></h4><p>Git Subtree 는 다음과 같은 상황에서 필요성이 대두된다:</p><ul><li>여러 프로젝트에 걸쳐 공통 코드나 라이브러리를 유지보수해야 할 때</li><li>백엔드를 마이크로서비스 구조로 개발하면서 API 응답, 데이터 모델에 같은 타입을 사용해 일관성을 유지해야 할 때</li><li>여러 프로젝트를 통합 관리하고자 할 때</li><li>핵심 디자인 파일을 여러 저장소에 포함시키고 싶을 때</li><li>프로젝트 히스토리를 관리하며 통합할 필요가 있을 때</li></ul><h3 id=주요-기능>주요 기능<a hidden class=anchor aria-hidden=true href=#주요-기능>#</a></h3><p>Git Subtree 의 주요 기능은 다음과 같다:</p><ul><li>하위 저장소 추가: <code>git subtree add</code> 명령을 통해 외부 저장소를 현재 저장소에 추가</li><li>하위 저장소 업데이트: <code>git subtree pull</code> 명령으로 외부 저장소의 변경사항을 가져옴</li><li>변경사항 푸시: <code>git subtree push</code> 명령으로 로컬에서 수정한 하위 저장소 내용을 원격 저장소에 반영</li><li>병합 전략: 서브트리 병합 (subtree merge) 기능을 통해 양쪽 저장소의 변경사항을 모두 반영</li></ul><h3 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h3><p>Git Subtree 는 다음과 같은 역할을 수행한다:</p><ul><li>상위 저장소에 파일을 직접 추가하고 트래킹함</li><li>서브트리의 원격에 있는 소스와 서브트리를 추가한 저장소의 소스가 서로 달라도 subtree merge 기능을 사용해 양쪽의 변경사항을 모두 반영할 수 있도록 함</li><li>상위 저장소에서 서브트리를 직접 수정하고 원격에 푸시할 수 있게 함</li><li>여러 저장소의 히스토리를 관리하며 재사용할 수 있도록 함</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p>Git Subtree 의 주요 특징은 다음과 같다:</p><ul><li>상위 저장소에 파일을 직접 추가하고 트래킹하기 때문에 서브트리의 변경사항도 상위 저장소에 기록됨</li><li>서브모듈과 달리 메타데이터 파일 (예:.gitmodule) 을 생성하지 않음</li><li>하위 저장소 (Child) 의 내용을 상위 저장소 (Parent) 에서 일반적인 git 명령어로 관리할 수 있음</li><li>하위 저장소의 내용을 수정하기 위해 별도의 저장소 복사본을 유지할 필요가 없음</li><li>사용자가 새로운 것을 배울 필요 없이 저장소를 사용할 수 있게 함</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>Git Subtree 는 다음과 같은 핵심 원칙에 기반한다:</p><ul><li>통합성: 여러 저장소를 하나의 저장소로 통합하여 관리</li><li>투명성: 사용자에게 서브트리의 존재를 숨기고 일반적인 Git 워크플로우 유지</li><li>양방향 동기화: 상위 저장소와 하위 저장소 간의 변경사항을 양방향으로 전파</li><li>히스토리 보존: 하위 저장소의 커밋 히스토리를 유지하면서 통합</li><li>유연성: 다양한 상황과 워크플로우에 적응할 수 있는 유연한 구조 제공</li></ul><h3 id=주요-원리--작동-원리>주요 원리 & 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리--작동-원리>#</a></h3><h4 id=다이어그램>다이어그램<a hidden class=anchor aria-hidden=true href=#다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MainRepo/
</span></span><span class=line><span class=cl>├── project/
</span></span><span class=line><span class=cl>│   └── external-lib/ (실제 코드 포함됨)
</span></span></code></pre></td></tr></table></div></div><h4 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h4><p>Git Subtree 의 주요 원리는 다음과 같다:</p><ul><li>복사 원리: Subtree 는 복사 개념으로, 하위 저장소의 코드를 상위 저장소에 복사하여 포함시킴</li><li>병합 원리: 서브트리 Merge 전략을 사용하여 Git 이 서브트리를 찾아 메인 프로젝트로 서브프로젝트의 내용을 병합함</li><li>트래킹 원리: 상위 저장소가 하위 저장소의 파일을 직접 추적하며 변경사항을 기록</li><li>분할 원리: <code>git subtree split</code> 명령으로 서브트리의 변경사항만 추출하여 별도의 커밋으로 분리 가능</li><li>동기화 원리: 상위 저장소와 하위 저장소 간에 push 와 pull 을 통한 양방향 동기화 가능</li></ul><h4 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h4><p>Git Subtree 는 다음과 같은 방식으로 작동한다:</p><ol><li><strong>추가 (Add)</strong>:<ul><li>먼저 원격 저장소를 추가한 후, subtree add 명령으로 하위 저장소를 특정 폴더에 추가함</li><li>하위 저장소의 전체 커밋 히스토리가 상위 저장소로 병합됨</li></ul></li><li><strong>가져오기 (Pull)</strong>:<ul><li>원격의 하위 저장소에 변경사항이 있을 경우, subtree pull 명령으로 상위 저장소에 반영함</li><li>상위 저장소에 하위 저장소의 최신 변경사항을 병합함</li></ul></li><li><strong>내보내기 (Push)</strong>:<ul><li>상위 저장소에서 하위 저장소의 내용을 수정한 후, subtree push 명령으로 원격 하위 저장소에 반영함</li><li>원래 별개의 프로젝트였던 원격 저장소에 변경사항을 동기화할 수 있음</li></ul></li><li><strong>분할 (Split)</strong>:<ul><li>subtree split 명령을 통해 마지막 분할 이후 변경된 내용만 찾아 별도의 커밋으로 분리함</li><li>이렇게 분리된 커밋들은 하위 저장소의 원격 저장소로 푸시할 수 있음</li></ul></li></ol><h4 id=명령어-흐름>명령어 흐름<a hidden class=anchor aria-hidden=true href=#명령어-흐름>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1. 서브트리 추가</span>
</span></span><span class=line><span class=cl>git subtree add --prefix<span class=o>=</span>external-lib https://github.com/example/lib.git main --squash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 외부 변경 사항 병합</span>
</span></span><span class=line><span class=cl>git subtree pull --prefix<span class=o>=</span>external-lib https://github.com/example/lib.git main --squash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 외부에 변경사항 push (있을 경우)</span>
</span></span><span class=line><span class=cl>git subtree push --prefix<span class=o>=</span>external-lib https://github.com/example/lib.git main
</span></span></code></pre></td></tr></table></div></div><h3 id=구성-요소-및-아키텍처>구성 요소 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구성-요소-및-아키텍처>#</a></h3><p>Git Subtree 는 다음과 같은 구성 요소로 이루어져 있다:</p><ol><li><strong>상위 저장소 (Parent Repository)</strong>:<ul><li>하위 저장소를 포함하는 주 저장소</li><li>모든 서브트리 조작의 기준점이 됨</li><li>일반적인 git add, commit, push, pull 로 관리함</li></ul></li><li><strong>하위 저장소 (Child Repository)</strong>:<ul><li>상위 저장소에 포함될 외부 저장소</li><li>원격에 독립적으로 존재하는 별도의 프로젝트</li><li>상위 저장소에서는 하나의 디렉토리로 취급됨</li></ul></li><li><strong>서브트리 참조 (Subtree Reference)</strong>:<ul><li>git log 에 기록되는 서브트리 관련 정보 (git-subtree-dir, git-subtree-mainline, git-subtree-split 등)</li><li>서브트리의 위치와 마지막 동기화 상태를 추적하는 데 사용됨</li></ul></li><li><strong>원격 참조 (Remote Reference)</strong>:<ul><li>원격 저장소를 가리키는 참조 (remote add 로 추가됨)</li><li>서브트리 명령어에서 원격 저장소 이름으로 사용됨</li></ul></li><li><strong>서브트리 명령 (Subtree Commands)</strong>:<ul><li>add, pull, push, split 등의 서브트리 전용 명령어</li><li>상위 저장소와 하위 저장소 간의 동기화를 관리함</li></ul></li></ol><h3 id=git-subtree-명령어>Git Subtree 명령어<a hidden class=anchor aria-hidden=true href=#git-subtree-명령어>#</a></h3><h4 id=서브트리-추가-add>서브트리 추가 (add)<a hidden class=anchor aria-hidden=true href=#서브트리-추가-add>#</a></h4><p>외부 저장소의 특정 브랜치를 현재 저장소의 하위 디렉토리로 가져온다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree add --prefix<span class=o>=</span>   <span class=o>[</span>--squash<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree add --prefix<span class=o>=</span>lib https://github.com/user/library.git main --squash
</span></span></code></pre></td></tr></table></div></div><ul><li><code>lib</code> 폴더에 <code>library.git</code> 의 <code>main</code> 브랜치 코드를 추가하고, 커밋 내역을 하나로 합친다 (<code>--squash</code> 옵션).</li></ul><h4 id=서브트리-업데이트-pull>서브트리 업데이트 (pull)<a hidden class=anchor aria-hidden=true href=#서브트리-업데이트-pull>#</a></h4><p>외부 저장소의 변경사항을 메인 저장소의 하위 디렉토리에 병합한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree pull --prefix<span class=o>=</span>   <span class=o>[</span>--squash<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree pull --prefix<span class=o>=</span>lib https://github.com/user/library.git main --squash
</span></span></code></pre></td></tr></table></div></div><ul><li><code>lib</code> 폴더의 서브트리를 최신 상태로 업데이트하며, 변경 내역을 하나의 커밋으로 합친다.</li></ul><h4 id=서브트리-변경사항-푸시-push>서브트리 변경사항 푸시 (push)<a hidden class=anchor aria-hidden=true href=#서브트리-변경사항-푸시-push>#</a></h4><p>메인 저장소에서 하위 디렉토리 (서브트리) 에서 작업한 변경 사항을 외부 저장소로 푸시한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree push --prefix<span class=o>=</span>  
</span></span></code></pre></td></tr></table></div></div><p><strong>예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree push --prefix<span class=o>=</span>lib https://github.com/user/library.git main
</span></span></code></pre></td></tr></table></div></div><ul><li><code>lib</code> 디렉토리의 변경사항을 외부 저장소의 <code>main</code> 브랜치에 반영한다.</li></ul><h4 id=서브트리-분리-split>서브트리 분리 (split)<a hidden class=anchor aria-hidden=true href=#서브트리-분리-split>#</a></h4><p>하위 디렉토리의 변경 내역만 별도의 브랜치로 분리한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree split --prefix<span class=o>=</span> -b 
</span></span></code></pre></td></tr></table></div></div><p><strong>예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git subtree split --prefix<span class=o>=</span>lib -b lib-branch
</span></span></code></pre></td></tr></table></div></div><ul><li><code>lib</code> 폴더의 변경 이력만을 담은 <code>lib-branch</code> 브랜치를 생성한다.</li></ul><h4 id=원격-저장소-추가-remote-add>원격 저장소 추가 (remote add)<a hidden class=anchor aria-hidden=true href=#원격-저장소-추가-remote-add>#</a></h4><p>외부 저장소를 원격 저장소로 등록해두면 명령어가 더 간결해진다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git remote add  
</span></span></code></pre></td></tr></table></div></div><p><strong>예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git remote add library https://github.com/user/library.git
</span></span></code></pre></td></tr></table></div></div><h4 id=실무에서-자주-쓰는-옵션>실무에서 자주 쓰는 옵션<a hidden class=anchor aria-hidden=true href=#실무에서-자주-쓰는-옵션>#</a></h4><ul><li><code>--squash</code>: 여러 커밋을 하나로 합쳐 메인 저장소의 커밋 히스토리를 깔끔하게 유지합니다.</li><li><code>--prefix</code>: 외부 저장소가 병합될 하위 디렉토리 경로를 지정합니다.</li></ul><h4 id=요약표>요약표<a hidden class=anchor aria-hidden=true href=#요약표>#</a></h4><table><thead><tr><th>명령어 유형</th><th>명령어 예시</th><th>설명</th></tr></thead><tbody><tr><td>추가 (add)</td><td><code>git subtree add --prefix=lib https://github.com/user/library.git main --squash</code></td><td>외부 저장소를 하위 폴더로 추가</td></tr><tr><td>업데이트 (pull)</td><td><code>git subtree pull --prefix=lib https://github.com/user/library.git main --squash</code></td><td>외부 저장소의 변경분 반영</td></tr><tr><td>푸시 (push)</td><td><code>git subtree push --prefix=lib https://github.com/user/library.git main</code></td><td>하위 폴더 변경분 외부 저장소로 푸시</td></tr><tr><td>분리 (split)</td><td><code>git subtree split --prefix=lib -b lib-branch</code></td><td>하위 폴더만 분리해 새 브랜치 생성</td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>단일 저장소 관리</td><td>여러 개의 프로젝트를 하나의 저장소로 관리할 수 있음</td></tr><tr><td></td><td>간편한 사용성</td><td>사용자들이 서브트리로 의존성을 관리한다는 사실을 잊어도 될 정도로 투명하게 작동함</td></tr><tr><td></td><td>메타데이터 파일 없음</td><td>Git 서브모듈과 달리 새로운 메타데이터 파일 (예:.gitmodule) 을 생성하지 않음</td></tr><tr><td></td><td>직접 수정 가능</td><td>상위 저장소에서 서브트리를 직접 수정하고 원격에 푸시할 수 있음</td></tr><tr><td></td><td>일관된 워크플로</td><td>저장소 사용자들이 새로운 것을 배울 필요가 없음</td></tr><tr><td></td><td>자동 클론</td><td>상위 프로젝트 클론 시 서브트리의 코드도 자동으로 사용 가능함</td></tr><tr><td></td><td>병합 용이성</td><td>서브트리 merge 기능을 통해 양쪽 저장소의 변경사항을 모두 반영할 수 있음</td></tr><tr><td></td><td>오래된 Git 버전 지원</td><td>Git 1.5.2 보다 오래된 버전에서도 지원됨</td></tr><tr><td>⚠ 단점</td><td>명령어 복잡성</td><td>새로운 병합 전략 (git subtree) 에 대해 학습해야 함</td></tr><tr><td></td><td>서브트리 위치 기억</td><td>어느 디렉토리를 &ndash;prefix 로 지정해야 하는지 기억해야 함</td></tr><tr><td></td><td>상위 저장소 크기 증가</td><td>하위 저장소를 복사하므로 상위 저장소의 크기가 커짐</td></tr><tr><td></td><td>제한된 접근 제어</td><td>모든 사용자가 서브트리의 내용을 자유롭게 변경해 원격에 푸시할 수 있음</td></tr><tr><td></td><td>업스트림 기여 복잡성</td><td>서브프로젝트에 코드를 기여하는 과정이 더 복잡함</td></tr><tr><td></td><td>책임의 분산</td><td>슈퍼 프로젝트와 서브 프로젝트 코드를 커밋에서 혼합하지 않을 책임이 개발자에게 있음</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>종류</th><th>설명</th><th>사용 시나리오</th></tr></thead><tbody><tr><td>기본 서브트리</td><td>&ndash;prefix 옵션으로 서브트리를 클론할 폴더 지정하고 원격 저장소와 브랜치를 지정하여 추가</td><td>간단한 외부 저장소 통합 시</td></tr><tr><td>원격 별칭 서브트리</td><td>서브트리를 원격으로 추가하여 더 짧은 형태로 참조하는 방식</td><td>반복적인 서브트리 작업 시</td></tr><tr><td>스쿼시 서브트리</td><td>&ndash;squash 옵션을 사용하여 외부 저장소의 커밋 기록을 하나의 커밋으로 압축</td><td>외부 저장소의 히스토리가 필요 없을 때</td></tr><tr><td>분할 서브트리</td><td>git subtree split 명령을 사용하여 서브디렉토리를 변경 이력과 함께 분리</td><td>하위 프로젝트를 독립 저장소로 분리할 때</td></tr><tr><td>병합 서브트리</td><td>-s recursive -Xsubtree=경로 옵션을 사용한 병합 전략</td><td>다른 브랜치의 서브디렉토리를 병합할 때</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>적용 분야</th><th>예시</th><th>이점</th></tr></thead><tbody><tr><td>코드 공유</td><td>백엔드 마이크로서비스 구조에서 API 응답, 데이터 모델의 타입을 일관되게 유지</td><td>여러 서비스 간 타입 일관성 보장</td></tr><tr><td>테마 관리</td><td>블로그 플랫폼의 테마를 별도 저장소로 관리하면서 메인 블로그 저장소에 통합</td><td>테마 수정과 업스트림 반영 용이</td></tr><tr><td>디자인 시스템</td><td>핵심 디자인 엘리먼트와 제품 개발 파일을 분리하여 핵심 디자인 파일을 여러 저장소에 포함</td><td>디자인 시스템의 일관성 유지</td></tr><tr><td>라이브러리 관리</td><td>무거운 의존성 (외부 도구나 라이브러리) 을 관리할 때 의존성의 전체 히스토리를 상위 저장소에 통합</td><td>라이브러리 사용 및 수정 용이</td></tr><tr><td>모노레포</td><td>여러 SPM(Swift Package Manager) 패키지를 개발 저장소에서 쉽게 작업하며 개별 저장소로 배포</td><td>단일 저장소 개발과 분리 배포 장점 결합</td></tr><tr><td>플러그인 관리</td><td>Vim 플러그인을 트래킹하여 통합하고 업데이트</td><td>플러그인 관리 및 업데이트 용이</td></tr><tr><td>오픈소스 통합</td><td>외부 저장소 코드를 한 번만 또는 가끔 가져와서 사용할 때</td><td>외부 코드 통합과 관리 단순화</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>주의할 점</th></tr></thead><tbody><tr><td>저장소 구조 설계</td><td>밀접하게 연관된 프로젝트의 경우 모노레포 방식을 고려해야 함</td><td>관계가 느슨한 프로젝트에는 부적합할 수 있음</td></tr><tr><td>작업 디렉토리 관리</td><td>git subtree 관련 조작은 저장소 최상위 폴더에서 이루어져야 함</td><td>하위 디렉토리에서 명령 실행 시 오류 발생</td></tr><tr><td>변경사항 동기화 전략</td><td>원래 저장소에서 수정된 코드를 반영하려면 subtree pull 명령어 사용</td><td>fetch/merge 로는 동기화되지 않음</td></tr><tr><td>충돌 관리</td><td>변경 내역을 push 하기 전에 pull 해야 충돌 방지</td><td>양방향 동기화 시 충돌 발생 가능성 높음</td></tr><tr><td>자동화 고려</td><td>많은 서브트리를 관리할 경우 스크립트와 자동화를 통해 관리해야 함</td><td>수동 관리는 오류 가능성 증가</td></tr><tr><td>팀 교육</td><td>어느 디렉토리가 subtree 인지 별도로 기록하고 팀원들과 공유해야 함</td><td>문서화 없이는 팀원들이 혼란 겪을 수 있음</td></tr><tr><td>명령어 단순화</td><td>원격 별칭을 사용하여 명령어를 짧게 만드는 것이 좋음</td><td>긴 명령어는 기억하기 어렵고 오류 가능성 높음</td></tr><tr><td>스쿼시 옵션 사용</td><td>&ndash;squash 옵션으로 히스토리를 압축하여 관리 가능</td><td>모든 커밋 히스토리가 필요한 경우에는 부적합</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>주의할 점</th></tr></thead><tbody><tr><td>저장소 크기 관리</td><td>서브트리는 상위 저장소에 파일을 직접 추가하므로 저장소 크기가 커짐</td><td>대형 저장소에서는 성능 저하 가능성</td></tr><tr><td>히스토리 압축</td><td>스쿼시 옵션을 사용하여 모든 커밋을 하나로 압축하면 저장소 크기와 성능 개선</td><td>상세 히스토리가 손실될 수 있음</td></tr><tr><td>분할 성능</td><td>리조인 옵션을 사용하여 전체 히스토리를 매번 검색하는 대신 체크포인트 활용</td><td>리조인 없이는 대형 저장소에서 속도 저하</td></tr><tr><td>저장소 규모</td><td>100 개 이상의 서브모듈/서브트리를 관리하는 경우 어떤 방식을 사용하든 관리가 어려움</td><td>과도한 서브트리 사용 지양</td></tr><tr><td>캐싱 최적화</td><td>모노레포 대비 서브트리는 더 작은 단위로 캐싱 최적화 가능</td><td>통합 빌드/CI 설정 필요</td></tr><tr><td>업데이트 빈도</td><td>자주 업데이트가 필요 없는 외부 코드에 적합</td><td>빈번한 업데이트가 필요한 경우 오버헤드 발생</td></tr><tr><td>병합 복잡성</td><td>외부 저장소의 변경사항을 메인 저장소에 병합하는 과정에서 복잡성 증가 가능</td><td>복잡한 병합 상황에 대비 필요</td></tr></tbody></table><h3 id=최신-동향>최신 동향<a hidden class=anchor aria-hidden=true href=#최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>모노레포 통합</td><td>Git Subtree 와 모노레포</td><td>Apollo 는 Git Subtree 를 사용하여 모노레포에서 Swift 패키지를 관리하는 방식을 도입함. 여러 개별 패키지를 하나의 개발 저장소에서 작업하고 자동화된 GitHub Actions 워크플로우를 통해 변경사항을 자동으로 분리하여 각 패키지 저장소로 푸시하는 방식이 인기를 얻고 있음</td></tr><tr><td>자동화</td><td>CI/CD 파이프라인 통합</td><td>2025 년에는 Git subtree 작업이 CI/CD 파이프라인에 통합되어 자동화된 워크플로우가 증가함. 코드 변경 시 자동으로 의존성을 관리하고 업데이트하는 방식이 표준화되고 있음</td></tr><tr><td>대안 솔루션</td><td>새로운 대안들</td><td>git-subrepo 와 같은 새로운 대안들이 등장하여 Git Subtree 와 Git Submodule 의 제한사항을 해결하려는 시도가 증가함. 이러한 도구들은 더 간단한 워크플로우와 향상된 협업 기능을 제공함</td></tr><tr><td>패키지 관리 통합</td><td>언어별 패키지 관리자와 통합</td><td>Rust 의 Cargo.toml 과 같은 텍스트 파일에 의존성 해시를 커밋하는 방식이 인기를 얻으면서, Git Subtree 는 패키지 관리자가 지원하지 않는 상황에서 주로 사용됨</td></tr><tr><td>하이브리드 접근법</td><td>모노레포와 멀티레포 혼합</td><td>액세스 권한에 따라 코드를 별도의 모노레포로 분할하고, git-subrepo 를 사용하여 모든 모노레포를 단일 모노레포에서 관리하는 하이브리드 접근법이 증가함</td></tr><tr><td>클라우드 개발 환경</td><td>원격 개발 환경에서의 최적화</td><td>클라우드 기반 개발 환경에서 Git Subtree 를 사용할 때 네트워크 지연과 저장소 크기 관리를 최적화하는 방법에 대한 관심이 증가함</td></tr></tbody></table><h3 id=주목해야-할-기술들>주목해야 할 기술들<a hidden class=anchor aria-hidden=true href=#주목해야-할-기술들>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>자동화 도구</td><td>Git Subtree 자동화</td><td>GitHub Actions 와 같은 CI/CD 도구를 활용하여 Git Subtree 의 분할 및 병합 작업을 자동화하는 워크플로우. 이를 통해 개발자는 복잡한 Git Subtree 명령어를 직접 사용하지 않아도 됨</td></tr><tr><td>Git Subrepo</td><td>Git Subtree 대안</td><td><a href=https://github.com/ingydotnet/git-subrepo>https://github.com/ingydotnet/git-subrepo</a>는 Git Subtree 와 Git Submodule 의 장점을 결합한 대안으로 주목받고 있음. 더 간단한 명령어와 향상된 기능을 제공함</td></tr><tr><td>모노레포 도구</td><td>기업용 모노레포 솔루션</td><td>nx 모노레포와 같은 도구들이 Angular 와 NestJS 를 함께 사용하는 프로젝트에서 활용되고 있음. 이러한 도구들은 캐싱 및 영향받는 패키지만 빌드하는 기능을 제공함</td></tr><tr><td>MDLR</td><td>선언적 Git 의존성 도구</td><td>MDLR(&ldquo;Modular&rdquo;) 은 Git Submodule 과 유사한 기능을 제공하면서도 복잡한 워크플로우를 개선한 선언적 버전 관리 Git 의존성 도구</td></tr><tr><td>하드 링크 활용</td><td>파일 시스템 최적화</td><td>&ldquo;.boiler&rdquo; 폴더에 서브모듈을 두고 하드 링크를 사용하여 애플리케이션의 &ldquo;src&rdquo; 디렉토리와 연결하는 방식. 이를 통해 링크된 파일 편집 시 원본 파일도 업데이트됨</td></tr><tr><td>의존성 관리 자동화</td><td>스마트 의존성 업데이트</td><td>서드파티 의존성을 자동으로 추적하고 관리하는 도구들이 Git Subtree 와 통합되고 있음. 이를 통해 보안 취약점이 있는 의존성을 자동으로 업데이트할 수 있음</td></tr></tbody></table><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>단순화된 인터페이스</td><td>사용 편의성 향상</td><td>Git Subtree 의 복잡한 명령어를 단순화하고 직관적인 인터페이스를 제공하는 도구들이 더욱 발전할 것으로 예상됨. 이를 통해 더 많은 개발자가 Git Subtree 를 채택할 것으로 전망됨</td></tr><tr><td>AI 통합</td><td>지능형 병합 충돌 해결</td><td>AI 를 활용하여 Git Subtree 병합 충돌을 지능적으로 해결하는 도구들이 등장할 것으로 예상됨. 이는 복잡한 멀티레포 환경에서의 작업을 크게 단순화할 수 있음</td></tr><tr><td>하이브리드 접근법</td><td>모노레포와 멀티레포 결합</td><td>Apollo 의 Swift 패키지 관리 사례처럼 개발은 모노레포에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 더욱 인기를 얻을 것으로 전망됨</td></tr><tr><td>Git 네이티브 기능 확장</td><td>내장 기능 확대</td><td>Git 의 기본 기능으로 현재 Git Subtree 가 제공하는 기능을 더 직관적이고 사용하기 쉽게 통합하는 방향으로 발전할 것으로 예상됨</td></tr><tr><td>패키지 매니저 통합</td><td>의존성 관리 통합</td><td>언어별 패키지 매니저와 Git Subtree 의 기능을 통합하여 코드와 의존성을 함께 관리하는 통합 솔루션이 발전할 것으로 전망됨</td></tr><tr><td>분산 개발 최적화</td><td>원격 작업 환경 지원</td><td>전 세계적으로 분산된 개발 팀을 위해 네트워크 지연과 저장소 크기 문제를 해결하는 최적화된 Git Subtree 솔루션이 발전할 것으로 예상됨</td></tr></tbody></table><h3 id=추가-학습-주제>추가 학습 주제<a hidden class=anchor aria-hidden=true href=#추가-학습-주제>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>Git 워크플로우</td><td>Git Subtree 명령어 심화</td><td>Git Subtree 의 고급 옵션과 명령어들 (split, merge 등) 에 대한 심층적인 이해</td></tr><tr><td>Git 워크플로우</td><td>Git Subtree vs Git Submodule</td><td>두 기능의 상세한 비교 분석과 각각 적합한 사용 사례</td></tr><tr><td>Git 워크플로우</td><td>Subtree 병합 전략</td><td>서브트리 병합 전략의 내부 작동 방식과 최적화 방법</td></tr><tr><td>시스템 설계</td><td>모노레포 아키텍처</td><td>대규모 프로젝트에서 모노레포와 Git Subtree 를 활용한 최적의 저장소 구조 설계</td></tr><tr><td>시스템 설계</td><td>마이크로서비스와 Git Subtree</td><td>마이크로서비스 아키텍처에서 공통 코드를 관리하기 위한 Git Subtree 활용법</td></tr><tr><td>자동화</td><td>Git Subtree CI/CD 통합</td><td>GitHub Actions 등을 활용한 Git Subtree 작업 자동화 방법</td></tr><tr><td>성능 최적화</td><td>대규모 저장소 최적화</td><td>100 개 이상의 하위 저장소를 관리할 때의 성능 최적화 방법</td></tr><tr><td>대안 기술</td><td>Git Subrepo</td><td>Git Subtree 와 Submodule 의 대안으로서 Git Subrepo 의 활용법</td></tr><tr><td>대안 기술</td><td>MDLR</td><td>선언적 버전 관리 Git 의존성 도구인 MDLR 의 특징과 활용법</td></tr></tbody></table><h3 id=관련-분야-추가-학습-주제>관련 분야 추가 학습 주제<a hidden class=anchor aria-hidden=true href=#관련-분야-추가-학습-주제>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>버전 관리</td><td>Git 내부 구조</td><td>Git 의 내부 구조와 저수준 명령어에 대한 이해</td></tr><tr><td>버전 관리</td><td>Git 병합 전략</td><td>다양한 Git 병합 전략의 비교와 각 상황에 적합한 전략 선택 방법</td></tr><tr><td>소프트웨어 아키텍처</td><td>모노레포 vs 멀티레포</td><td>프로젝트 규모와 성격에 따른 모노레포와 멀티레포 선택 기준</td></tr><tr><td>소프트웨어 아키텍처</td><td>마이크로서비스 설계</td><td>코드 공유가 필요한 마이크로서비스 아키텍처 설계 방법</td></tr><tr><td>의존성 관리</td><td>패키지 관리자 통합</td><td>언어별 패키지 관리자와 Git 워크플로우의 통합 방법</td></tr><tr><td>DevOps</td><td>CI/CD 파이프라인 설계</td><td>Git Subtree 를 활용한 효율적인 CI/CD 파이프라인 구축 방법</td></tr><tr><td>CI/CD</td><td>Subtree 빌드 자동화</td><td><code>.gitlab-ci.yml</code> 또는 GitHub Actions 스크립트 구성</td></tr><tr><td>코드 품질</td><td>코드 공유 전략</td><td>여러 프로젝트 간 코드 공유를 위한 효과적인 전략</td></tr><tr><td>팀 협업</td><td>효율적인 개발 워크플로우</td><td>Git Subtree 를 활용한 분산 팀의 효율적인 협업 방법</td></tr><tr><td>보안</td><td>의존성 취약점 관리</td><td>Git Subtree 로 통합된 외부 코드의 보안 취약점 관리 방법</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>상위 저장소 (Parent Repository)</td><td>Git Subtree 에서 하위 저장소를 포함하는 주 저장소</td></tr><tr><td>하위 저장소 (Child Repository)</td><td>상위 저장소에 포함되는 외부 저장소</td></tr><tr><td>서브트리 병합 (Subtree Merge)</td><td>한 프로젝트를 다른 프로젝트의 하위 디렉토리로 매핑하여 병합하는 전략</td></tr><tr><td>Squash Merge</td><td>여러 커밋을 단일 이력으로 병합</td></tr><tr><td>Detached HEAD</td><td>특정 커밋에 고정된 작업 상태</td></tr><tr><td>&ndash;prefix 옵션</td><td>서브트리를 클론할 폴더를 지정하는 Git Subtree 명령어 옵션</td></tr><tr><td>&ndash;squash 옵션</td><td>외부 저장소의 커밋 기록을 하나의 커밋으로 압축하는 옵션</td></tr><tr><td><code>subtree split</code></td><td>디렉토리만 분리해 독립 저장소처럼 추출하는 명령어</td></tr><tr><td>모노레포 (Monorepo)</td><td>여러 프로젝트를 하나의 저장소에서 관리하는 방식</td></tr><tr><td>멀티레포 (Multi-repo)</td><td>여러 프로젝트를 각각 별도의 저장소로 관리하는 방식</td></tr><tr><td>git-subrepo</td><td>Git Subtree 와 Submodule 의 장점을 결합한 대안 도구</td></tr></tbody></table><hr><h2 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h2><ul><li><a href=https://www.atlassian.com/git/tutorials/git-subtree>Atlassian 공식 가이드</a></li><li><a href=https://docs.github.com/ko/get-started/using-git/about-git-subtree-merges>GitHub 서브트리 병합 문서</a></li><li><a href=https://blog.jetbrains.com/space/2023/11/21/space-git-subtree/>JetBrains Space 최신 기능</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-subtree>Atlassian Git Subtree 튜토리얼</a></li><li><a href=https://git-scm.com/book/en/v2/Git-Tools-Subtree-Merge>Git 공식 Git Subtree 문서</a></li><li><a href=https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt>GitHub Discussions on subtree usage</a></li><li><a href=https://h22y25n.github.io/git/subtree/>Git Subtree 사용하기</a></li><li><a href=https://velog.io/@ohmy0418/Git-Subtree>Git Subtree 개념 설명</a></li><li><a href=https://iseongho.github.io/posts/git-subtree/>Git Subtree 사용법 - 하나의 저장소에서 여러 저장소를 관리하기</a></li><li><a href=https://www.three-snakes.com/git/git-subtree/>Subtree 사용법 - ThreeSnakes의 개발 삽질 기록장</a></li><li><a href=https://homoefficio.github.io/2015/07/18/git-subtree/>git subtree - 프로젝트 안의 또 다른 프로젝트</a></li><li><a href=https://blog.rhostem.com/posts/2020-01-03-code-sharing-with-git-subtree>Git subtree를 활용한 코드 공유</a></li><li><a href=https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-%EC%84%9C%EB%B8%8C%EB%AA%A8%EB%93%88>Git - 서브모듈</a></li><li><a href=https://github.com/progit/progit2-ko/blob/master/book/07-git-tools/sections/subtree-merges.asc>서브트리 Merge 개념 설명</a></li><li><a href=https://github.com/kaiye/git-advanced-guide/blob/master/concepts/subtree-vs-submodule.md>git subtree vs git submodule 차이점</a></li><li><a href=https://www.atlassian.com/git/tutorials/git-subtree>Git Subtree: the alternative to Git Submodule</a></li><li><a href=https://gitprotect.io/blog/managing-git-projects-git-subtree-vs-submodule/>Managing Git Projects: Git Subtree vs. Submodule</a></li><li><a href=https://www.geeksforgeeks.org/git-subtree-vs-git-submodule/>Git Subtree vs. Git Submodule</a></li><li><a href=https://adam-p.ca/blog/2022/02/git-submodule-subtree/>Git Submodule vs Subtree</a></li><li><a href=https://www.apollographql.com/blog/how-apollo-manages-swift-packages-in-a-monorepo-with-git-subtrees>How Apollo Manages Swift Packages in a Monorepo with Git Subtrees</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/devops-and-infrastructure/>DevOps-and-Infrastructure</a></li><li><a href=https://buenhyden.github.io/tags/version-control-systems/>Version-Control-Systems</a></li><li><a href=https://buenhyden.github.io/tags/git-workflow/>Git-Workflow</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-design/availability/availability-patterns/><span class=title>« Prev</span><br><span>Availability Patterns</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/version-control-systems/vcs-theory/vcs-comparison/><span class=title>Next »</span><br><span>VCS comparison</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>