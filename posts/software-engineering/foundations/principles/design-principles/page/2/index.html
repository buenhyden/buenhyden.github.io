<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Design Principles | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles"><meta name=description content="Design Principles 는 소프트웨어 시스템의 구조적 안정성, 유지보수성, 확장성을 보장하기 위한 핵심 규칙이다. 모듈화, 관심사 분리, 단일 책임 원칙 등이 대표적이며, 이는 시스템 아키텍처 설계 시 복잡성 관리와 효율적인 리소스 활용을 가능하게 한다. 실무에서는 마이크로서비스, 계층화 아키텍처, CI/CD 파이프라인 등에 적용되어 신뢰성 있는 시스템 구축을 지원한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Design Principles"><meta property="og:description" content="Design Principles 는 소프트웨어 시스템의 구조적 안정성, 유지보수성, 확장성을 보장하기 위한 핵심 규칙이다. 모듈화, 관심사 분리, 단일 책임 원칙 등이 대표적이며, 이는 시스템 아키텍처 설계 시 복잡성 관리와 효율적인 리소스 활용을 가능하게 한다. 실무에서는 마이크로서비스, 계층화 아키텍처, CI/CD 파이프라인 등에 적용되어 신뢰성 있는 시스템 구축을 지원한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Design Principles"><meta name=twitter:description content="Design Principles 는 소프트웨어 시스템의 구조적 안정성, 유지보수성, 확장성을 보장하기 위한 핵심 규칙이다. 모듈화, 관심사 분리, 단일 책임 원칙 등이 대표적이며, 이는 시스템 아키텍처 설계 시 복잡성 관리와 효율적인 리소스 활용을 가능하게 한다. 실무에서는 마이크로서비스, 계층화 아키텍처, CI/CD 파이프라인 등에 적용되어 신뢰성 있는 시스템 구축을 지원한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Software Engineering Foundations","item":""},{"@type":"ListItem","position":4,"name":"Principles","item":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/"},{"@type":"ListItem","position":5,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Software Engineering Foundations</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/>Principles</a></div><h1>Design Principles</h1><div class=post-description>Design Principles 는 소프트웨어 시스템의 구조적 안정성, 유지보수성, 확장성을 보장하기 위한 핵심 규칙이다. 모듈화, 관심사 분리, 단일 책임 원칙 등이 대표적이며, 이는 시스템 아키텍처 설계 시 복잡성 관리와 효율적인 리소스 활용을 가능하게 한다. 실무에서는 마이크로서비스, 계층화 아키텍처, CI/CD 파이프라인 등에 적용되어 신뢰성 있는 시스템 구축을 지원한다.</div></header><div class=post-content><h2 id=소프트웨어-설계-원칙-design-principles>소프트웨어 설계 원칙 (Design Principles)<a hidden class=anchor aria-hidden=true href=#소프트웨어-설계-원칙-design-principles>#</a></h2><p>소프트웨어 설계 원칙 (Design Principles) 은 소프트웨어 및 시스템 설계의 근간이 되는 원칙으로, 시스템의 구조와 품질을 결정하는 데 중요한 역할을 한다. 이러한 원칙들은 유지보수성, 확장성, 성능, 보안 등을 향상시키기 위해 설계 단계에서부터 고려되어야 하며, SOLID, DRY, KISS, YAGNI 등의 원칙들이 포함된다. 이러한 원칙들을 이해하고 적용함으로써 고품질의 소프트웨어를 개발할 수 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>소프트웨어 설계 원칙은 소프트웨어 시스템을 설계할 때 따라야 하는 지침과 규칙의 집합으로, 시스템의 품질과 유지보수성을 향상시키는 데 목적이 있다.</p><p><strong>기본 개념</strong>:</p><ul><li><strong>설계 원칙 (Design Principles)</strong>: 소프트웨어 품질 향상을 위한 검증된 가이드라인</li><li><strong>느슨한 결합 (Loose Coupling)</strong>: 모듈 간 의존성을 최소화하는 설계 방식</li><li><strong>높은 응집도 (High Cohesion)</strong>: 모듈 내부 요소들이 밀접하게 관련된 설계</li><li><strong>관심사의 분리 (Separation of Concerns)</strong>: 서로 다른 기능을 별도 모듈로 분리<br><strong>심화 개념</strong></li><li><strong>추상화 (Abstraction)</strong>: 복잡성을 숨기고 필수 요소만 노출</li><li><strong>캡슐화 (Encapsulation)</strong>: 데이터와 메서드를 하나의 단위로 묶어 정보 은닉</li><li><strong>다형성 (Polymorphism)</strong>: 같은 인터페이스로 다양한 구현체 사용</li><li><strong>의존성 주입 (Dependency Injection)</strong>: 외부에서 의존성을 주입하여 결합도 감소</li></ul><p>이러한 개념들을 바탕으로 주요 원칙들은 아래와 같다:</p><ul><li><strong>SOLID 원칙:</strong><ul><li><strong>단일 책임 원칙 (Single Responsibility Principle):</strong> 클래스는 하나의 책임만 가져야 한다.</li><li><strong>개방 - 폐쇄 원칙 (Open/Closed Principle):</strong> 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.</li><li><strong>리스코프 치환 원칙 (Liskov Substitution Principle):</strong> 하위 클래스는 상위 클래스의 기능을 대체할 수 있어야 한다.</li><li><strong>인터페이스 분리 원칙 (Interface Segregation Principle):</strong> 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다.</li><li><strong>의존 역전 원칙 (Dependency Inversion Principle):</strong> 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 추상화에 의존해야 한다.</li></ul></li><li><strong>DRY(Don&rsquo;t Repeat Yourself):</strong> 중복을 피하고, 재사용 가능한 코드를 작성해야 한다.</li><li><strong>KISS(Keep It Simple, Stupid):</strong> 설계를 단순하게 유지해야 한다.</li><li><strong>YAGNI(You Aren&rsquo;t Gonna Need It):</strong> 현재 필요하지 않은 기능은 구현하지 않아야 한다.</li></ul><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>Design Principles 는 소프트웨어 개발 과정에서 반복적으로 발생하는 문제들을 해결하기 위해 개발된 원칙들이다. 1970 년대부터 시작된 구조적 프로그래밍, 1980 년대의 객체지향 프로그래밍 등의 발전과 함께 형성되었으며, 특히 1990 년대 Robert Martin(Uncle Bob) 의 SOLID 원칙과 Gang of Four 의 디자인 패턴이 현대적 형태의 기초를 확립했다.</p><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p>소프트웨어 설계 원칙의 목적은 다음과 같다:</p><ul><li><strong>유지보수성 향상:</strong> 코드의 가독성과 이해도를 높여 유지보수를 용이하게 한다.</li><li><strong>확장성 확보:</strong> 변화하는 요구사항에 유연하게 대응할 수 있도록 한다.</li><li><strong>재사용성 증대:</strong> 모듈화된 설계를 통해 코드의 재사용성을 높인다.</li><li><strong>품질 향상:</strong> 버그를 줄이고, 안정적인 소프트웨어를 개발할 수 있다.</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><p>설계 원칙은 다음과 같은 역할을 한다:</p><ul><li><strong>구조화:</strong> 시스템을 명확한 구조로 설계하여 이해도를 높인다.</li><li><strong>표준화:</strong> 개발 팀 내에서 일관된 설계 방식을 유지한다.</li><li><strong>의사소통:</strong> 설계에 대한 명확한 기준을 제공하여 팀원 간의 의사소통을 원활하게 한다.</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>보편성</strong>: 프로그래밍 언어와 플랫폼에 독립적</li><li><strong>상호보완성</strong>: 여러 원칙들이 함께 적용될 때 시너지 효과</li><li><strong>점진적 적용</strong>: 프로젝트 규모와 복잡도에 따른 단계적 적용 가능</li><li><strong>경험 기반</strong>: 수십 년간의 개발 경험에서 도출된 실용적 지침</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><h4 id=solid-원칙>SOLID 원칙<a hidden class=anchor aria-hidden=true href=#solid-원칙>#</a></h4><table><thead><tr><th>원칙</th><th>설명</th><th>목적 및 효과</th><th>관련 개념/패턴</th></tr></thead><tbody><tr><td><strong>SRP</strong>(Single Responsibility Principle)</td><td>클래스나 모듈은 단 하나의 책임만 가져야 한다.</td><td>응집도 향상, 변경 용이성 증가</td><td>응집도, 모듈화, 리팩토링</td></tr><tr><td><strong>OCP</strong>(Open/Closed Principle)</td><td>확장에는 열려 있고, 변경에는 닫혀 있어야 한다.</td><td>기존 코드를 수정하지 않고 새로운 기능 추가 가능</td><td>상속, 전략 패턴, 템플릿 메서드</td></tr><tr><td><strong>LSP</strong>(Liskov Substitution Principle)</td><td>자식 클래스는 부모 클래스의 기능을 대체할 수 있어야 한다.</td><td>다형성 보장, 신뢰할 수 있는 상속 구조</td><td>인터페이스, 추상 클래스</td></tr><tr><td><strong>ISP</strong>(Interface Segregation Principle)</td><td>클라이언트가 사용하지 않는 인터페이스에 의존하지 않아야 한다.</td><td>불필요한 결합 방지, 인터페이스 최소화</td><td>인터페이스 설계, 분리</td></tr><tr><td><strong>DIP</strong>(Dependency Inversion Principle)</td><td>고수준 모듈은 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 한다.</td><td>결합도 감소, 유연한 아키텍처</td><td>DI (의존성 주입), 인터페이스</td></tr></tbody></table><h4 id=기타-핵심-원칙>기타 핵심 원칙<a hidden class=anchor aria-hidden=true href=#기타-핵심-원칙>#</a></h4><table><thead><tr><th>원칙</th><th>설명</th><th>목적 및 효과</th><th>관련 개념/패턴</th></tr></thead><tbody><tr><td><strong>SoC</strong>(Separation of Concerns)</td><td>관심사 (기능) 를 분리하여 각각 독립적으로 관리</td><td>코드 가독성, 유지보수성 향상</td><td>레이어드 아키텍처, 모듈화</td></tr><tr><td><strong>DRY</strong>(Don&rsquo;t Repeat Yourself)</td><td>동일한 로직은 중복하지 말고 재사용하라</td><td>유지보수 용이성, 오류 감소</td><td>함수화, 유틸리티 모듈</td></tr><tr><td><strong>KISS</strong>(Keep It Simple, Stupid)</td><td>단순하고 명확하게 설계하라</td><td>복잡도 감소, 버그 발생 확률 최소화</td><td>최소 구현, 명확한 책임</td></tr><tr><td><strong>YAGNI</strong>(You Ain&rsquo;t Gonna Need It)</td><td>당장 필요하지 않은 기능은 구현하지 마라</td><td>낭비 제거, 설계 복잡도 감소</td><td>애자일, Lean 개발</td></tr><tr><td><strong>Law of Demeter</strong>(LoD)</td><td>객체는 자신과 밀접한 객체와만 상호작용해야 한다</td><td>낮은 결합도 유지</td><td>메시지 전달, 캡슐화</td></tr><tr><td><strong>Composition over Inheritance</strong></td><td>상속보다 객체 합성을 통해 기능을 확장</td><td>유연성 확보, 상속 트리 복잡도 감소</td><td>전략 패턴, 데코레이터 패턴</td></tr><tr><td><strong>Convention over Configuration</strong></td><td>명시적 설정보다 관례 기반 기본값 사용</td><td>개발 생산성 향상, 설정 최소화</td><td>Rails, Spring Boot, NestJS</td></tr></tbody></table><pre class=mermaid>graph TB
    subgraph &#34;Design Principles&#34;
        subgraph &#34;필수 구성요소&#34;
            A1[SOLID 원칙]
            A2[DRY 원칙]
            A3[KISS 원칙]
        end
        
        subgraph &#34;선택적 구성요소&#34;
            B1[YAGNI 원칙]
            B2[Law of Demeter]
            B3[Composition over Inheritance]
            B4[Convention over Configuration]
        end
        
        subgraph &#34;적용 계층&#34;
            C1[클래스 레벨]
            C2[모듈 레벨]
            C3[시스템 레벨]
        end
        
        subgraph &#34;품질 속성&#34;
            D1[유지보수성]
            D2[확장성]
            D3[재사용성]
            D4[테스트 용이성]
        end
    end
    
    A1 --&gt; C1
    A1 --&gt; C2
    A2 --&gt; C1
    A2 --&gt; C2
    A3 --&gt; C1
    A3 --&gt; C2
    A3 --&gt; C3
    
    B1 --&gt; C2
    B1 --&gt; C3
    B2 --&gt; C1
    B3 --&gt; C1
    B3 --&gt; C2
    B4 --&gt; C3
    
    C1 --&gt; D1
    C1 --&gt; D4
    C2 --&gt; D2
    C2 --&gt; D3
    C3 --&gt; D1
    C3 --&gt; D2
</pre><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유지보수성 향상</td><td>체계적인 구조로 인한 코드 수정 용이성</td></tr><tr><td></td><td>확장성 보장</td><td>새로운 기능 추가 시 기존 코드 영향 최소화</td></tr><tr><td></td><td>재사용성 증대</td><td>모듈화된 컴포넌트의 다양한 프로젝트 활용</td></tr><tr><td></td><td>팀 협업 효율성</td><td>일관된 설계 기준으로 인한 의사소통 향상</td></tr><tr><td></td><td>테스트 용이성</td><td>분리된 관심사로 인한 단위 테스트 작성 편의</td></tr><tr><td>⚠ 단점</td><td>초기 개발 시간 증가</td><td>설계 단계에서의 추가 시간 투자 필요</td></tr><tr><td></td><td>과도한 추상화 위험</td><td>불필요한 복잡성 증가 가능성</td></tr><tr><td></td><td>성능 오버헤드</td><td>추상화 계층으로 인한 런타임 성능 저하</td></tr><tr><td></td><td>학습 곡선</td><td>개발자의 원칙 이해와 적용을 위한 학습 시간</td></tr><tr><td></td><td>원칙 간 상충</td><td>서로 다른 원칙들 간의 트레이드오프 발생</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류</th><th>원칙</th><th>주요 특징</th><th>적용 범위</th></tr></thead><tbody><tr><td>객체지향 설계</td><td>SOLID 원칙</td><td>클래스와 모듈 설계 지침</td><td>클래스/모듈 레벨</td></tr><tr><td></td><td>Law of Demeter</td><td>결합도 최소화</td><td>클래스 간 상호작용</td></tr><tr><td></td><td>Composition over Inheritance</td><td>유연한 코드 구조</td><td>클래스 설계</td></tr><tr><td>코드 품질</td><td>DRY</td><td>중복 제거</td><td>전체 코드베이스</td></tr><tr><td></td><td>KISS</td><td>단순성 유지</td><td>전체 설계</td></tr><tr><td></td><td>YAGNI</td><td>필요한 기능만 구현</td><td>기능 개발</td></tr><tr><td>아키텍처 설계</td><td>Separation of Concerns</td><td>관심사 분리</td><td>시스템 아키텍처</td></tr><tr><td></td><td>Loose Coupling</td><td>모듈 간 독립성</td><td>컴포넌트 설계</td></tr><tr><td></td><td>High Cohesion</td><td>모듈 내 응집도</td><td>모듈 설계</td></tr><tr><td>개발 프로세스</td><td>Convention over Configuration</td><td>관례 우선 설정</td><td>프레임워크 설계</td></tr><tr><td></td><td>Principle of Least Astonishment</td><td>예측 가능한 동작</td><td>인터페이스 설계</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>산업 분야</th><th>적용 사례</th><th>설명</th></tr></thead><tbody><tr><td>전자상거래</td><td>단일 책임 원칙 (SRP)</td><td>주문 처리, 결제, 배송 등을 각각의 서비스로 분리하여 유지보수성을 향상시킴</td></tr><tr><td>금융</td><td>개방 - 폐쇄 원칙 (OCP)</td><td>새로운 금융 상품 추가 시 기존 코드를 수정하지 않고 기능을 확장</td></tr><tr><td>헬스케어</td><td>인터페이스 분리 원칙 (ISP)</td><td>의료 기록 조회, 수정, 삭제 기능을 별도의 인터페이스로 분리</td></tr><tr><td>게임 개발</td><td>리스코프 치환 원칙 (LSP)</td><td>다양한 캐릭터 클래스가 동일한 방식으로 동작하도록 설계</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-쇼핑몰-백엔드-시스템-설계>사례 1: 쇼핑몰 백엔드 시스템 설계<a hidden class=anchor aria-hidden=true href=#사례-1-쇼핑몰-백엔드-시스템-설계>#</a></h4><p><strong>시나리오</strong>: 쇼핑몰 플랫폼의 주문 처리 시스템은 다양한 외부 서비스와 연동되며 빠르게 변경되는 비즈니스 요구에 따라 확장되어야 함.</p><p><strong>사용된 설계 원칙:</strong></p><ul><li>SRP: 주문 도메인을 주문 처리, 결제 처리, 배송 처리로 분리</li><li>OCP: 새로운 결제 수단 추가 시 기존 클래스 수정 없이 새로운 클래스 추가</li><li>DIP: 의존성 주입을 통해 상위 모듈과 하위 모듈 간 의존성 분리</li></ul><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>graph TD
  A[OrderController] --&gt; B[OrderService]
  B --&gt; C[&#34;PaymentProcessor (interface)&#34;]
  C --&gt; D[PayPalService]
  C --&gt; E[StripeService]
  B --&gt; F[ShippingService]
</pre><p><strong>Workflow:</strong></p><ol><li>사용자가 주문을 요청 → OrderController</li><li>OrderService 는 주문 처리 후 인터페이스에 따라 결제 요청</li><li>결제 수단에 따라 해당 구현체 호출</li><li>결제 완료 후 배송 서비스 호출</li></ol><p><strong>설계 원칙 역할:</strong></p><ul><li>SOLID 로 변경에 강하고 확장 가능한 구조 유지</li><li>DIP 로 테스트 및 유지보수 용이</li></ul><h4 id=사례-2-사용자-맞춤형-뉴스-피드-애플리케이션>사례 2: 사용자 맞춤형 뉴스 피드 애플리케이션<a hidden class=anchor aria-hidden=true href=#사례-2-사용자-맞춤형-뉴스-피드-애플리케이션>#</a></h4><p><strong>시나리오</strong>: 한 스타트업이 사용자 맞춤형 뉴스 피드 애플리케이션을 개발하고자 한다. 이 애플리케이션은 다양한 뉴스 소스를 통합하고, 사용자의 관심사에 맞는 콘텐츠를 제공해야 한다.</p><p><strong>적용된 설계 원칙</strong>:</p><ul><li><strong>단일 책임 원칙 (SRP):</strong> 뉴스 수집, 사용자 프로필 관리, 추천 알고리즘 등을 각각의 서비스로 분리</li><li><strong>개방 - 폐쇄 원칙 (OCP):</strong> 새로운 뉴스 소스 추가 시 기존 코드를 수정하지 않고 확장 가능하도록 설계</li><li><strong>의존 역전 원칙 (DIP):</strong> 뉴스 수집 서비스가 구체적인 뉴스 소스에 의존하지 않고, 추상화된 인터페이스에 의존하도록 설계</li></ul><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>graph TD
    A[사용자 인터페이스] --&gt; B[뉴스 추천 서비스]
    B --&gt; C[뉴스 수집 서비스]
    B --&gt; D[사용자 프로필 서비스]
    C --&gt; E[뉴스 소스 API]
    D --&gt; F[사용자 데이터베이스]
</pre><p><strong>워크플로우</strong>:</p><ol><li>사용자가 애플리케이션에 접속하여 뉴스 피드를 요청한다.</li><li>뉴스 추천 서비스는 사용자 프로필 서비스를 통해 관심사를 조회한다.</li><li>뉴스 수집 서비스는 다양한 뉴스 소스 API 를 통해 최신 뉴스를 수집한다.</li><li>뉴스 추천 서비스는 수집된 뉴스 중에서 사용자의 관심사에 맞는 콘텐츠를 선별하여 사용자에게 제공한다.</li></ol><h4 id=사례-3-온라인-쇼핑몰-플랫폼-구축>사례 3: 온라인 쇼핑몰 플랫폼 구축<a hidden class=anchor aria-hidden=true href=#사례-3-온라인-쇼핑몰-플랫폼-구축>#</a></h4><p><strong>시나리오</strong>: 온라인 쇼핑몰 플랫폼 구축<br><strong>시스템 구성</strong></p><pre class=mermaid>graph TB
    subgraph &#34;클라이언트 계층&#34;
        A1[웹 클라이언트]
        A2[모바일 앱]
        A3[관리자 콘솔]
    end
    
    subgraph &#34;API Gateway 계층&#34;
        B1[API Gateway]
        B2[인증 서비스]
        B3[로드 밸런서]
    end
    
    subgraph &#34;비즈니스 서비스 계층&#34;
        C1[사용자 서비스]
        C2[상품 서비스]
        C3[주문 서비스]
        C4[결제 서비스]
        C5[배송 서비스]
        C6[알림 서비스]
    end
    
    subgraph &#34;데이터 계층&#34;
        D1[사용자 DB]
        D2[상품 DB]
        D3[주문 DB]
        D4[결제 DB]
        D5[Redis Cache]
    end
    
    subgraph &#34;외부 서비스&#34;
        E1[결제 게이트웨이]
        E2[배송 업체 API]
        E3[이메일 서비스]
    end
    
    A1 --&gt; B1
    A2 --&gt; B1
    A3 --&gt; B1
    
    B1 --&gt; B2
    B1 --&gt; B3
    B3 --&gt; C1
    B3 --&gt; C2
    B3 --&gt; C3
    B3 --&gt; C4
    B3 --&gt; C5
    B3 --&gt; C6
    
    C1 --&gt; D1
    C2 --&gt; D2
    C3 --&gt; D3
    C4 --&gt; D4
    C1 --&gt; D5
    C2 --&gt; D5
    
    C4 --&gt; E1
    C5 --&gt; E2
    C6 --&gt; E3
</pre><p><strong>적용된 Design Principles 와 역할</strong>:</p><ol><li><p>Single Responsibility Principle (SRP)</p><ul><li>각 마이크로서비스가 단일 비즈니스 기능 담당</li><li>사용자 서비스: 회원 관리만</li><li>주문 서비스: 주문 처리만</li><li>결제 서비스: 결제 처리만</li></ul></li><li><p>Open/Closed Principle (OCP)</p><ul><li>API Gateway 를 통한 새로운 서비스 추가 용이</li><li>플러그인 방식의 결제 방법 확장</li></ul></li><li><p>Dependency Inversion Principle (DIP)</p><ul><li>서비스 간 직접 의존 대신 인터페이스 기반 통신</li><li>외부 서비스와의 느슨한 결합</li></ul></li><li><p>Interface Segregation Principle (ISP)</p><ul><li>클라이언트별 특화된 API 엔드포인트 제공</li><li>웹/모바일/관리자 전용 인터페이스 분리</li></ul></li></ol><p><strong>Workflow</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Client as 클라이언트
    participant Gateway as API Gateway
    participant Auth as 인증 서비스
    participant Product as 상품 서비스
    participant Order as 주문 서비스
    participant Payment as 결제 서비스
    participant Shipping as 배송 서비스
    participant Notification as 알림 서비스
    
    Client-&gt;&gt;Gateway: 주문 요청
    Gateway-&gt;&gt;Auth: 인증 확인
    Auth--&gt;&gt;Gateway: 인증 성공
    
    Gateway-&gt;&gt;Product: 상품 재고 확인
    Product--&gt;&gt;Gateway: 재고 충분
    
    Gateway-&gt;&gt;Order: 주문 생성
    Order--&gt;&gt;Gateway: 주문 ID 반환
    
    Gateway-&gt;&gt;Payment: 결제 처리
    Payment-&gt;&gt;Payment: 결제 검증 (KISS 원칙)
    Payment--&gt;&gt;Gateway: 결제 완료
    
    Gateway-&gt;&gt;Order: 주문 상태 업데이트
    Order--&gt;&gt;Gateway: 업데이트 완료
    
    Gateway-&gt;&gt;Shipping: 배송 요청
    Shipping--&gt;&gt;Gateway: 배송 등록 완료
    
    Gateway-&gt;&gt;Notification: 알림 발송
    Notification--&gt;&gt;Gateway: 알림 전송 완료
    
    Gateway--&gt;&gt;Client: 주문 완료 응답
</pre><h3 id=실무-적용-시-고려사항-및-주의할-점>실무 적용 시 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무-적용-시-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>계획 단계</strong></td><td>점진적 도입</td><td>설계 원칙을 한 번에 도입하면 혼란과 거부감 발생 가능</td><td>핵심 원칙 (SOLID, DRY) 부터 시작해 점진적으로 확장</td></tr><tr><td></td><td>팀 역량 차이</td><td>팀 구성원 간 설계 원칙에 대한 이해도와 경험 차이 발생</td><td>정기 교육, 페어 프로그래밍, 코드 리뷰를 통해 정렬</td></tr><tr><td></td><td>프로젝트 특성 고려</td><td>MVP, 초기 스타트업 vs 장기 유지보수 시스템 등 요구사항이 다름</td><td>비즈니스 요구에 따라 설계 원칙 우선순위 조절</td></tr><tr><td></td><td>설계 과잉 방지</td><td>과도한 추상화는 복잡도 증가 및 생산성 저하 초래</td><td>반복되는 패턴 발생 시에만 추상화 (3 회 법칙 적용)</td></tr><tr><td><strong>설계 단계</strong></td><td>모듈 경계 설정</td><td>명확한 책임 분할이 없으면 책임이 중첩되고 결합도가 상승함</td><td>DDD(Domain-Driven Design) 또는 SRP 적용</td></tr><tr><td></td><td>인터페이스 정의</td><td>인터페이스가 지나치게 크거나 애매하면 응집도 저하 및 ISP 위반</td><td>작고 명확한 인터페이스 정의, Swagger 문서화</td></tr><tr><td></td><td>추상화와 성능 균형</td><td>추상 계층 증가 → 성능 저하, 직관성 저하</td><td>핵심 기능은 최적화 고려, 성능 크리티컬 경로 점검</td></tr><tr><td></td><td>통신 방식 결정</td><td>서비스 간 동기/비동기, REST/gRPC 등 선택이 설계에 큰 영향을 미침</td><td>서비스 특성 기반 통신 프로토콜 선택 (지연 민감도, 안정성 등)</td></tr><tr><td><strong>구현 단계</strong></td><td>코드 일관성 유지</td><td>개발자마다 설계 원칙 적용 방식이 다르면 유지보수 어려움</td><td>Style Guide, SonarQube, Linter 도입</td></tr><tr><td></td><td>테스트 용이성</td><td>DIP 적용 시 의존성 설정/모킹이 복잡할 수 있음</td><td>IoC/DI 컨테이너, 테스트 프레임워크 적극 활용</td></tr><tr><td></td><td>자동화 도구 활용</td><td>설계 원칙 준수 여부를 수동 검토하는 것은 비효율적임</td><td>정적 분석 도구 활용 (SonarQube, ESLint, etc.)</td></tr><tr><td></td><td>문서화 및 ADR 관리</td><td>설계 의도나 결정 근거가 사라지면 팀 단위 혼선 발생</td><td>아키텍처 결정 기록 (ADR) 및 인터페이스 문서화</td></tr><tr><td><strong>유지보수 단계</strong></td><td>리팩토링 주기화</td><td>시간이 지날수록 원칙이 무너질 수 있음</td><td>리팩토링 전용 스프린트 또는 기술 부채 관리 시간 확보</td></tr><tr><td></td><td>모듈 책임 유지</td><td>유지보수 중 기능이 분산되거나 중첩되면 원칙 위반</td><td>SRP 위반 시 즉시 리팩토링 또는 책임 재분배</td></tr><tr><td></td><td>메트릭 기반 개선</td><td>설계 원칙이 실제로 효과적인지 판단 기준 필요</td><td>응집도/결합도 (CBO/LCOM), 순환 복잡도, 코드 커버리지 추적</td></tr><tr><td></td><td>API/계약 안정성 유지</td><td>인터페이스 변경 시 다른 모듈/팀에 영향이 확산됨</td><td>Contract Testing, API 버저닝 적용</td></tr></tbody></table><ul><li><strong>도입은 단계별로, 핵심 원칙부터</strong> 시작해야 실무 적용이 효율적.</li><li><strong>팀 내 일관성 유지와 자동화 도구 활용</strong>은 설계 품질을 장기적으로 유지하는 핵심 수단.</li><li><strong>설계 원칙은 성능, 가독성, 생산성과의 균형</strong> 속에서 적용되어야 하며, 지나친 이상주의는 오히려 장애가 될 수 있다.</li></ul><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><p>다음은 **설계 원칙 (Design Principles)**을 적용할 때 실무에서 <strong>성능을 최적화하기 위한 고려사항 및 주의할 점</strong>을 중복 없이 통합·정리한 표입니다. 이 표는 설계 최적화, 런타임 최적화, 운영 환경 모니터링까지 전체 개발 생애주기를 아우르는 관점에서 구성되어 있습니다.</p><hr><h2 id=-성능을-최적화하기-위한-고려사항-및-주의할-점>🚀 성능을 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#-성능을-최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>구분</th><th>고려사항</th><th>상세 설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계 최적화</strong></td><td>불필요한 추상화 제거</td><td>과도한 추상 계층은 호출 비용 증가 및 디버깅 어려움 발생</td><td>성능 중요 경로는 직접 호출, 추상화는 반복 패턴 발생 시 적용</td></tr><tr><td></td><td>계층 최소화</td><td>지나친 레이어드 아키텍처는 처리 시간 증가</td><td>계층 수 최소화 및 Hot Path 는 단순 설계</td></tr><tr><td></td><td>모듈 분리 범위 조정</td><td>과도한 모듈화는 인터페이스 호출 오버헤드 발생</td><td>응집도를 기준으로 기능 단위 분리</td></tr><tr><td></td><td>객체 생성 최적화</td><td>매번 객체 생성 시 GC(Garbage Collection) 부하 발생</td><td>객체 풀링, 싱글턴, 플라이웨이트 패턴 사용</td></tr><tr><td></td><td>의존성 주입 방식</td><td>DI 컨테이너 사용 시 런타임 의존성 해석 비용 존재</td><td>컴파일 타임 DI 또는 Lazy Injection 적용</td></tr><tr><td><strong>런타임 최적화</strong></td><td>다형성 비용 최소화</td><td>동적 디스패치로 인한 런타임 비용 증가</td><td>Hot Path 는 정적 디스패치 또는 단일 구현 선택</td></tr><tr><td></td><td>비동기 처리</td><td>대량의 요청이 직렬 처리될 경우 병목 발생 가능</td><td>Kafka, RabbitMQ 등 메시지 기반 비동기 처리 활용</td></tr><tr><td></td><td>캐싱 전략</td><td>반복 요청 시 불필요한 DB 접근 또는 계산 수행</td><td>Redis, Local Cache, TTL 정책 적용</td></tr><tr><td></td><td>데이터 접근 최적화</td><td>반복적 DB 호출 및 N+1 문제는 성능 저하의 주요 원인</td><td>배치 로딩, 쿼리 튜닝, Eager vs Lazy 로딩 전략 활용</td></tr><tr><td></td><td>재사용 vs 단순성 균형</td><td>재사용을 위한 과도한 일반화는 Hot Path 성능 저하 유발</td><td>성능 중심 기능은 중복을 감수하더라도 단순하게 설계</td></tr><tr><td><strong>모니터링 및 운영</strong></td><td>성능 프로파일링</td><td>추상적 최적화는 오히려 성능 악화 가능, 실제 병목 지점 식별 필요</td><td>APM (Application Performance Monitoring) 도구 사용</td></tr><tr><td></td><td>벤치마킹/테스트</td><td>설계 변경 전후의 성능을 정량적으로 비교해야 신뢰도 확보 가능</td><td>JMeter, Locust, k6 등으로 벤치마킹 수행</td></tr><tr><td></td><td>지속적 모니터링</td><td>운영 환경에서는 데이터 크기/트래픽 변화에 따라 성능 저하 가능성 있음</td><td>Prometheus, Grafana, CloudWatch 등 활용</td></tr><tr><td></td><td>문서화 및 기술 부채 관리</td><td>성능 이슈로 인해 원칙을 완화한 부분은 누락되면 장기적으로 유지보수 난이도 증가</td><td>성능 예외 설계는 ADR(Architectural Decision Record) 로 기록</td></tr></tbody></table><ul><li><strong>성능 중심 설계</strong>에서는 <strong>단순화, 직접 호출, 최소 추상화</strong>가 유리.</li><li>**Hot Path(성능 핵심 경로)**와 일반 경로의 설계 기준은 분리되어야 하며, 가독성과 설계 원칙보다 <strong>실제 성능 우선 전략</strong>이 필요할 수 있다.</li><li><strong>설계 원칙은 절대 법칙이 아닌 지침</strong>이며, 성능 병목이 예상되거나 확인된 부분에서는 선택적으로 <strong>설계 원칙을 완화</strong>하는 것이 실무적이다.</li></ul><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>디자인 패턴</td><td>Gang of Four 패턴</td><td>23 가지 고전 패턴의 현대적 적용</td></tr><tr><td></td><td>아키텍처 패턴</td><td>MVC, MVP, MVVM, Clean Architecture</td></tr><tr><td></td><td>엔터프라이즈 패턴</td><td>마틴 파울러의 엔터프라이즈 애플리케이션 패턴</td></tr><tr><td>개발 방법론</td><td>애자일 개발</td><td>스크럼, 칸반에서의 원칙 적용</td></tr><tr><td></td><td>TDD/BDD</td><td>테스트 주도 개발과 행위 주도 개발</td></tr><tr><td></td><td>익스트림 프로그래밍</td><td>XP 의 핵심 관행들</td></tr><tr><td>코드 품질</td><td>정적 분석</td><td>코드 복잡도, 중복도 측정</td></tr><tr><td></td><td>기술 부채 관리</td><td>원칙 위반으로 인한 부채 관리</td></tr><tr><td></td><td>리팩토링 기법</td><td>마틴 파울러의 리팩토링 카탈로그</td></tr><tr><td>아키텍처</td><td>마이크로서비스</td><td>분산 시스템에서의 원칙 적용</td></tr><tr><td></td><td>헥사고날 아키텍처</td><td>포트와 어댑터 패턴</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>느슨한 결합을 위한 이벤트 활용</td></tr><tr><td>최신 기술</td><td>클라우드 네이티브</td><td>컨테이너와 쿠버네티스 환경</td></tr><tr><td></td><td>서버리스</td><td>FaaS 에서의 설계 고려사항</td></tr><tr><td></td><td>DevOps</td><td>CI/CD 와 인프라스트럭처 as Code</td></tr></tbody></table><h3 id=추가-학습-주제-정리>추가 학습 주제 정리<a hidden class=anchor aria-hidden=true href=#추가-학습-주제-정리>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td>객체지향 설계 (OOP)</td><td><strong>SOLID 원칙</strong></td><td>객체지향 설계를 위한 다섯 가지 핵심 원칙 (SRP, OCP, LSP, ISP, DIP)</td></tr><tr><td></td><td><strong>GRASP 원칙</strong></td><td>객체 책임 할당에 대한 일반적인 설계 패턴 (Creator, Controller 등)</td></tr><tr><td></td><td><strong>디자인 스멜</strong></td><td>유지보수에 악영향을 미치는 잘못된 설계 징후 (ex. God Class, Shotgun Surgery)</td></tr><tr><td></td><td><strong>리팩토링 패턴</strong></td><td>코드 품질 향상을 위한 반복 가능한 개선 기법</td></tr><tr><td>함수형 프로그래밍</td><td><strong>순수 함수</strong></td><td>외부 상태에 영향을 주지 않고 입력만으로 결과를 반환하는 함수</td></tr><tr><td></td><td><strong>불변성 (Immutability)</strong></td><td>상태 변경을 피하는 안정적인 설계 원칙</td></tr><tr><td></td><td><strong>모나드 (Monad) 패턴</strong></td><td>함수 조합과 에러 처리 등을 위한 고급 함수형 프로그래밍 구조</td></tr><tr><td>설계 패턴</td><td><strong>GoF 디자인 패턴</strong></td><td>객체 생성, 구조, 행위 관련 23 가지 디자인 패턴 (Factory, Strategy 등)</td></tr><tr><td></td><td><strong>컴포지션 vs 상속</strong></td><td>" 상속보다는 구성 " 원칙으로 유연성과 테스트 용이성을 확보하는 방식</td></tr><tr><td>아키텍처 스타일</td><td><strong>클린 아키텍처 / 헥사고날 / Onion</strong></td><td>계층 분리, 의존성 역전, 테스트 가능성 중심의 현대 소프트웨어 설계 구조</td></tr><tr><td></td><td><strong>마이크로서비스 아키텍처</strong></td><td>독립적 배포 및 확장을 지원하는 서비스 중심 아키텍처</td></tr><tr><td>성능 최적화</td><td><strong>설계 기반 성능 튜닝</strong></td><td>설계 시점에서 추상화/계층 구조의 성능 영향을 고려</td></tr><tr><td></td><td><strong>프로파일링 및 병목 분석</strong></td><td>런타임 병목 지점을 도구 기반으로 식별하여 최적화</td></tr><tr><td>테스트 전략</td><td><strong>TDD (Test-Driven Development)</strong></td><td>테스트 주도 개발: 테스트를 먼저 작성하고 그에 맞춰 코드를 작성</td></tr><tr><td></td><td><strong>DDD (Domain-Driven Design)</strong></td><td>도메인 지식에 기반한 복잡한 비즈니스 로직 중심 설계 전략</td></tr><tr><td>동시성 설계</td><td><strong>이벤트 루프 / Non-blocking I/O</strong></td><td>비동기 프로그래밍 모델 (Node.js, asyncio 등)</td></tr><tr><td></td><td><strong>Actor 모델</strong></td><td>메시지 기반 동시성 구조 (Akka, Erlang 등)</td></tr><tr><td></td><td><strong>락 프리/무잠금 프로그래밍</strong></td><td>병목 없이 동시성 보장하는 알고리즘 (CAS, atomic operation 등)</td></tr><tr><td>분산 시스템</td><td><strong>CAP 이론</strong></td><td>Consistency, Availability, Partition Tolerance 사이의 트레이드오프 이해</td></tr><tr><td></td><td><strong>SAGA 패턴</strong></td><td>분산 환경에서의 롱런 트랜잭션 처리를 위한 보상 메커니즘</td></tr><tr><td></td><td><strong>CQRS (Command Query Responsibility Segregation)</strong></td><td>명령과 조회의 책임을 분리한 확장성 중심 설계</td></tr></tbody></table><hr><table><thead><tr><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>ACID</strong></td><td>트랜잭션의 원자성 (Atomicity), 일관성 (Consistency), 격리성 (Isolation), 지속성 (Durability) 을 보장하는 특성</td></tr><tr><td><strong>CI/CD</strong></td><td>지속적 통합 (Continuous Integration) 및 지속적 배포 (Continuous Delivery) 를 위한 자동화 파이프라인</td></tr><tr><td><strong>MVC (Model-View-Controller)</strong></td><td>사용자 인터페이스를 세 계층으로 나누어 설계하는 디자인 패턴</td></tr><tr><td><strong>리팩토링 (Refactoring)</strong></td><td>기능 변경 없이 코드의 구조를 개선하여 유지보수성을 향상시키는 작업</td></tr><tr><td><strong>모킹 (Mock)</strong></td><td>테스트를 위해 실제 객체 대신 사용하는 가짜 객체</td></tr><tr><td><strong>클린 아키텍처</strong></td><td>계층 간 의존성과 관심사를 분리하고, 내부 도메인을 중심으로 설계하는 아키텍처 스타일</td></tr><tr><td><strong>결합도 (Coupling)</strong></td><td>모듈 간 상호 의존성의 강도 (낮을수록 유지보수성 향상)</td></tr><tr><td><strong>응집도 (Cohesion)</strong></td><td>모듈 내부 구성 요소들의 관련성과 집중도 (높을수록 품질 향상)</td></tr><tr><td><strong>추상화 (Abstraction)</strong></td><td>시스템의 복잡성을 줄이기 위해 핵심 개념만을 표현하는 설계 기법</td></tr><tr><td><strong>다형성 (Polymorphism)</strong></td><td>하나의 인터페이스로 다양한 객체 타입을 처리할 수 있는 특성</td></tr><tr><td><strong>기술 부채 (Technical Debt)</strong></td><td>빠른 개발을 위해 품질을 희생한 결과로 향후 발생할 유지보수 비용</td></tr><tr><td><strong>코드 스멜 (Code Smell)</strong></td><td>유지보수가 어려운 구조적 결함의 징후 (e.g., 긴 메서드, 중복 코드 등)</td></tr><tr><td><strong>관심사의 분리 (Separation of Concerns)</strong></td><td>서로 다른 책임 또는 기능을 모듈화하여 유지보수를 쉽게 하는 설계 원칙</td></tr><tr><td><strong>인터페이스 (Interface)</strong></td><td>객체 간 상호작용을 정의하는 명세 또는 계약 (계약 기반 설계의 핵심 요소)</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=-설계-원칙-및-일반-개념>🔷 설계 원칙 및 일반 개념<a hidden class=anchor aria-hidden=true href=#-설계-원칙-및-일반-개념>#</a></h3><ul><li><a href=https://martinfowler.com/articles/principles.html>Martin Fowler - Design Principles</a></li><li><a href=https://www.geeksforgeeks.org/principles-of-software-design/>GeeksforGeeks: Principles of Software Design</a></li><li><a href=https://en.wikipedia.org/wiki/Software_design>Wikipedia: Software Design</a></li><li><a href=https://en.wikipedia.org/wiki/SOLID>Wikipedia: SOLID</a></li><li><a href=https://www.linkedin.com/pulse/software-engineering-principles-applying-solid-dry-development>LinkedIn: Software Engineering Principles</a></li><li><a href=https://swimm.io/learn/system-design/6-software-design-principles-used-by-successful-engineers>Swimm: 6 Software Design Principles Used by Successful Engineers</a></li><li><a href=https://medium.com/better-programming/risks-and-benefits-of-the-9-popular-software-design-principles-284f8d319ef1>Medium: 9 Popular Software Design Principles</a></li><li><a href=https://scalastic.io/en/solid-dry-kiss/>Scalastic: SOLID, DRY, KISS 등 설계 원칙 정리</a></li><li><a href=https://www.boldare.com/blog/kiss-yagni-dry-principles/>Boldare: DRY, KISS, YAGNI 설명</a></li><li><a href=https://www.designgurus.io/blog/essential-software-design-principles-you-should-know-before-the-interview>Essential Software Design Principles – DesignGurus</a></li></ul><h3 id=-객체지향-고급-개념>🔷 객체지향 고급 개념<a hidden class=anchor aria-hidden=true href=#-객체지향-고급-개념>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Law_of_Demeter>Law of Demeter - Wikipedia</a></li><li><a href=https://www.geeksforgeeks.org/law-of-demeter-in-java-principle-of-least-knowledge/>Law of Demeter in Java – GeeksforGeeks</a></li><li><a href=https://en.wikipedia.org/wiki/Composition_over_inheritance>Composition over Inheritance - Wikipedia</a></li><li><a href=https://arjancodes.com/blog/composition-over-inheritance-in-software-development/>Composition vs Inheritance – ArjanCodes</a></li></ul><h3 id=-클린-아키텍처-및-프레임워크>🔷 클린 아키텍처 및 프레임워크<a hidden class=anchor aria-hidden=true href=#-클린-아키텍처-및-프레임워크>#</a></h3><ul><li><a href=https://www.oreilly.com/library/view/clean-architecture-a/9780134494272/>Clean Architecture by Robert C. Martin – O&rsquo;Reilly</a></li><li><a href=https://docs.aws.amazon.com/wellarchitected/latest/framework/wellarchitected-design-principles.html>AWS Well-Architected Framework - Design Principles</a></li><li><a href=https://google.github.io/eng-practices/>Google Engineering Practices Guide</a></li><li><a href=https://learn.microsoft.com/en-us/azure/architecture/guide/design-principles/>Microsoft Azure Architecture Center</a></li><li><a href=https://www.thoughtworks.com/radar>ThoughtWorks Technology Radar</a></li></ul><h3 id=-아키텍처-및-패턴>🔷 아키텍처 및 패턴<a hidden class=anchor aria-hidden=true href=#-아키텍처-및-패턴>#</a></h3><ul><li><a href=https://www.educative.io/blog/software-architecture-diagramming-and-patterns>Educative: Software Architecture Diagramming and Patterns</a></li><li><a href=https://www.redhat.com/en/blog/14-software-architecture-patterns>Red Hat: 14 Software Architecture Design Patterns</a></li><li><a href=https://www.tutorialspoint.com/software_architecture_design/key_principles.htm>TutorialsPoint: Software Architecture Design Principles</a></li><li><a href=https://www.linkedin.com/pulse/understanding-component-design-principles-said-naeem-shah-fstvf>LinkedIn: Component Design Principles</a></li><li><a href=https://www.ictworks.org/updated-principles-for-digital-developent/>ICTWorks: Updated Principles for Digital Development</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle DRY(Don’t Repeat Yourself) 는 소프트웨어 개발에서 중복된 코드, 데이터, 문서 등을 제거하고, 각각의 지식이나 로직이 시스템 내에서 유일하게 정의되도록 하는 설계 원칙이다. 이 원칙은 코드 재사용, 유지보수성 향상, 오류 감소, 일관성 확보 등 다양한 이점을 제공하며, 함수, 모듈, 컴포넌트, 설정 파일 등 다양한 수준에서 적용된다. 하지만 과도한 추상화나 무분별한 적용은 오히려 복잡성을 초래할 수 있으므로, 상황에 맞는 균형 잡힌 적용이 필요하다.
핵심 개념 DRY 원칙은 “Every piece of knowledge must have a single, unambiguous, authoritative representation within a system” (모든 지식은 시스템 내에서 단일하고 명확하며 권위 있는 표현을 가져야 한다) 라는 철학을 기반으로 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;36 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/dry/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles SOLID 원칙은 2000 년 Robert C. Martin 에 의해 체계화된 객체 지향 설계의 5 대 핵심 원칙이다. 단일 책임 (SRP), 개방/폐쇄 (OCP), 리스코프 치환 (LSP), 인터페이스 분리 (ISP), 의존성 역전 (DIP) 원칙으로 구성되어 있다. 이 원칙들은 코드의 결합도를 낮추고, 변경에 유연하며, 테스트와 유지보수를 쉽게 만들어준다. SOLID 는 현대 소프트웨어 개발에서 품질 높은 시스템 구축의 표준이자 필수 지침으로 널리 사용된다
핵심 개념 SOLID 원칙의 정의 SRP (Single Responsibility Principle): 클래스는 하나의 책임만 가져야 하며, 변경되는 이유도 하나여야 함 OCP (Open/Closed Principle): 소프트웨어 개체는 확장에는 열려있고 수정에는 닫혀있어야 함 LSP (Liskov Substitution Principle): 하위 타입은 상위 타입으로 대체 가능해야 함 ISP (Interface Segregation Principle): 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함 DIP (Dependency Inversion Principle): 상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 함 핵심 목표 코드의 유지보수성 (Maintainability) 향상 시스템 확장성 (Extensibility) 보장 코드 재사용성 (Reusability) 증대 테스트 용이성 (Testability) 확보 결합도 (Coupling) 감소 및 응집도 (Cohesion) 증가 배경 SOLID 원칙은 2000 년 Robert C. Martin(Uncle Bob) 이 “Design Principles and Design Patterns” 논문에서 처음 제시했다. 이후 Michael Feathers 가 SOLID 라는 약어를 도입했다. 이 원칙들은 수십 년간의 객체 지향 프로그래밍 경험과 모범 사례를 바탕으로 체계화되었으며, 애자일 소프트웨어 개발과 클린 코드 철학의 기초가 되었다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/solid/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>