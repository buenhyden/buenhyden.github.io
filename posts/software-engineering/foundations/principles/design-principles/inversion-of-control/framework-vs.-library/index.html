<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Framework vs. Library | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles,Inversion-of-Control,Library,Framework"><meta name=description content="프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 ' 할리우드 원칙 '(제어의 역전) 으로 설명된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/framework-vs.-library/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/framework-vs.-library/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/framework-vs.-library/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Framework vs. Library"><meta property="og:description" content="프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 ' 할리우드 원칙 '(제어의 역전) 으로 설명된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-20T06:47:00+00:00"><meta property="article:modified_time" content="2024-11-20T06:47:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="Principles"><meta property="article:tag" content="Design-Principles"><meta property="article:tag" content="Inversion-of-Control"><meta property="article:tag" content="Library"><meta property="article:tag" content="Framework"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Framework vs. Library"><meta name=twitter:description content="프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 ' 할리우드 원칙 '(제어의 역전) 으로 설명된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Software Engineering Foundations","item":""},{"@type":"ListItem","position":4,"name":"Principles","item":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/"},{"@type":"ListItem","position":5,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/"},{"@type":"ListItem","position":6,"name":"Inversion of Control","item":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/"},{"@type":"ListItem","position":7,"name":"Framework vs. Library","item":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/framework-vs.-library/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Framework vs. Library","name":"Framework vs. Library","description":"프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 ' 할리우드 원칙 '(제어의 역전) 으로 설명된다.","keywords":["System-and-Software-Architecture","Principles","Design-Principles","Inversion-of-Control","Library","Framework"],"articleBody":"Framework vs. Library 프레임워크와 라이브러리는 소프트웨어 개발에서 필수적인 구성 요소로, 각각의 목적과 사용 방식이 다르다. 라이브러리는 특정 기능을 제공하는 코드 집합으로 개발자가 직접 호출해 사용한다. 반면, 프레임워크는 애플리케이션의 구조와 흐름을 정의하며, 개발자가 작성한 코드를 필요에 따라 호출하는 ’ 제어의 역전 ’ 원칙을 따른다. 이 차이는 시스템 설계의 핵심 원리와 실무 적용에 큰 영향을 미치며, 각 도구의 장단점, 적용 사례, 최적화 및 실무 적용 시 고려사항 등에서 뚜렷하게 드러난다.\n핵심 개념 제어의 역전 (Inversion of Control, IoC): 프로그램의 제어 흐름이 전통적인 방식과 반대로 동작하는 설계 원칙 Hollywood Principle: “Don’t call us, we’ll call you” - 프레임워크가 개발자 코드를 호출 의존성 주입 (Dependency Injection): 객체의 의존성을 외부에서 주입하는 방식 애플리케이션 프레임워크 (Application Framework): 특정 도메인의 애플리케이션 개발을 위한 포괄적인 구조 코드 라이브러리 (Code Library): 재사용 가능한 함수와 클래스의 집합 Framework vs. Library 비교 구분 프레임워크 (Framework) 라이브러리 (Library) 정의 애플리케이션 개발을 위한 구조와 제어 흐름을 제공하는 소프트웨어 플랫폼 특정 기능을 수행하는 코드 집합으로, 필요 시 개발자가 직접 호출 제어 흐름 (Control Flow) 프레임워크가 전체 흐름을 제어하며, 개발자의 코드를 호출 (제어의 역전: IoC) 개발자가 라이브러리를 직접 호출하여 제어 흐름을 관리 사용 방식 프레임워크의 구조에 맞춰 코드를 작성하고, 확장 지점을 통해 기능 구현 필요한 기능만 선택적으로 가져와 호출 구조 제공 애플리케이션의 아키텍처 및 구성 방식을 정의 구조에 영향을 주지 않음 확장성 명확한 확장 포인트 제공 (예: Hook, 인터페이스 등) 함수 단위로 조합하여 사용 가능 유연성 프레임워크의 구조를 따르므로 상대적으로 유연성은 낮음 특정 기능 단위로 자유롭게 사용 가능 재사용성 특정 프레임워크에 종속적일 수 있음 다양한 프로젝트에서 재사용 가능함 예시 Spring, Angular, Django, React (의견 분분하지만 구조 제공 시 프레임워크로 분류되기도 함) Lodash, NumPy, jQuery, Requests 사용 시나리오 비교 구분 Framework Library 적합한 프로젝트 대규모, 복잡한 애플리케이션 특정 기능이 필요한 프로젝트 팀 규모 대규모 팀 (일관성 중요) 소규모 팀 (유연성 중요) 유지보수 프레임워크 업데이트에 의존 개별적으로 관리 가능 테스트 프레임워크 테스트 환경 사용 독립적인 단위 테스트 구조 및 아키텍처 Framework 아키텍처 graph TD A[Framework Core] --\u003e B[Application Lifecycle] A --\u003e C[Dependency Injection Container] A --\u003e D[Configuration Management] A --\u003e E[Plugin System] B --\u003e F[Initialization] B --\u003e G[Execution] B --\u003e H[Cleanup] C --\u003e I[Bean Factory] C --\u003e J[Dependency Resolution] D --\u003e K[XML/Annotation Config] D --\u003e L[Environment Properties] E --\u003e M[Extension Points] E --\u003e N[Custom Components] F --\u003e O[Developer Code] G --\u003e O H --\u003e O Framework 구성요소:\n구성요소 유형 기능 역할 Core Engine 필수 애플리케이션 실행 엔진 전체 흐름 제어 Lifecycle Manager 필수 객체 생명주기 관리 초기화, 실행, 정리 Configuration System 필수 설정 관리 프레임워크 동작 제어 Dependency Injection 필수 의존성 관리 객체 간 결합도 감소 Extension Interface 선택 확장점 제공 커스터마이징 지원 Additional Libraries 선택 부가 기능 특화된 기능 제공 Library 아키텍처 graph TD A[Application Code] --\u003e B[Library API] B --\u003e C[Core Functions] B --\u003e D[Utility Functions] B --\u003e E[Helper Classes] C --\u003e F[Primary Features] D --\u003e G[Support Functions] E --\u003e H[Common Operations] A --\u003e I[Direct Function Calls] I --\u003e C I --\u003e D I --\u003e E Library 구성요소:\n구성요소 유형 기능 역할 API Interface 필수 외부 접근점 기능 노출 Core Functions 필수 주요 기능 구현 핵심 로직 처리 Documentation 필수 사용법 설명 개발자 가이드 Helper Utilities 선택 보조 기능 편의성 향상 Example Code 선택 사용 예제 학습 지원 Extension Modules 선택 확장 기능 추가 기능 제공 주요 원리 프레임워크는 제어의 역전 (Inversion of Control) 원칙에 따라 작동하며, 개발자의 코드를 호출한다. 라이브러리는 개발자가 직접 호출하여 사용하는 구조이다.\nFramework 동작 원리 (Hollywood Principle):\nsequenceDiagram participant F as Framework participant DC as Developer Code participant AC as Application Context F-\u003e\u003eAC: Initialize Application F-\u003e\u003eDC: Call setUp() method DC-\u003e\u003eF: Return configuration F-\u003e\u003eAC: Configure components F-\u003e\u003eDC: Call execute() method DC-\u003e\u003eF: Perform business logic F-\u003e\u003eDC: Call tearDown() method F-\u003e\u003eAC: Cleanup resources Library 동작 원리 (Direct Call):\nsequenceDiagram participant DC as Developer Code participant L as Library participant R as Resources DC-\u003e\u003eL: Call function A() L-\u003e\u003eR: Access resource R-\u003e\u003eL: Return data L-\u003e\u003eDC: Return result DC-\u003e\u003eL: Call function B() L-\u003e\u003eDC: Return result DC-\u003e\u003eL: Call function C() L-\u003e\u003eDC: Return result 구현 기법 구분 구현 기법 정의 구성 요소 목적 실제 예시 (시스템 구성 / 시나리오) Framework 템플릿 메서드 패턴 (Template Method Pattern) 알고리즘 골격 정의, 세부 단계는 하위 클래스에 위임 추상 클래스, 템플릿 메서드, 훅 메서드 처리 흐름의 일관성 유지, 코드 재사용 Spring Framework - JdbcTemplate\nDB 연결 → 쿼리 실행 → 결과 처리 → 연결 해제 의존성 주입 패턴 (Dependency Injection Pattern) 객체의 의존성을 외부에서 주입 IoC 컨테이너, Bean 정의, 주입 지점 결합도 감소, 테스트 용이성 향상 Spring Boot + JPA\nController → Service → Repository 간 의존성 자동 주입 Library 팩토리 패턴 (Factory Pattern) 객체 생성 로직 캡슐화 팩토리 클래스, 제품 인터페이스, 구체 클래스 생성 복잡도 은닉, 확장성 제공 Apache Commons Collections\n다양한 컬렉션을 팩토리 메서드로 생성 빌더 패턴 (Builder Pattern) 복잡한 객체를 단계적으로 생성 빌더 인터페이스, 구체 빌더, 디렉터 가독성 향상, 생성 유연성 확보 Retrofit HTTP Client\nHTTP 요청 객체를 체이닝 방식으로 구성 실무 적용 고려사항 구분 고려사항/상황 Framework 활용 시 Library 활용 시 권장사항 프로젝트 규모 소규모 프로젝트 구조적 오버헤드 발생 가능 경량화된 구성으로 적합 필요한 기능만 선택, 불필요한 프레임워크 지양 프로젝트 규모 대규모 프로젝트 아키텍처 일관성 유지 용이, 확장성 높음 라이브러리 난립 시 구조 복잡도 증가 가능 아키텍처 표준화 및 일관된 적용 방식 수립 팀 경험 수준 초급자 중심 팀 학습 곡선 큼, 사용 실수 가능성 존재 비교적 진입장벽 낮음 점진적 도입 및 내부 교육/가이드 제공 팀 경험 수준 숙련자 중심 팀 생산성 및 구조화 효과 극대화 가능 다양한 선택 가능, 자유도 활용 가능 베스트 프랙티스와 표준 개발 가이드 적용 유지보수/확장성 장기 운영 프로젝트 프레임워크 구조에 기반한 유지보수 체계 가능 각 라이브러리별 관리 및 업데이트 필요 버전 정책 및 의존성 관리 기준 수립 기술 호환성 프레임워크/라이브러리 업데이트 프레임워크 버전 간 호환성 확인 필요 의존 라이브러리 충돌 가능성 존재 공식 문서 기반 업그레이드 전략 수립 성능 요구사항 고성능 서비스 프레임워크의 내부 처리 로직에 최적화 제약 있음 세밀한 성능 조정 가능 성능 프로파일링 도구를 통한 선택 및 설정 최적화 운영 환경 구성 패키지 및 의존성 관리 통합적인 프로젝트 구조에서 패키지 충돌 적음 의존성 중복 및 충돌 가능성 존재 pip, poetry, npm 등 패키지 관리 도구 적극 활용 최적화 고려사항 구분 고려 요소 Framework 활용 시 특징 Library 활용 시 특징 권장사항 및 모범 사례 메모리 사용량 사용량 최소화 전체 프레임워크 로딩으로 메모리 부담 가능 필요한 기능만 선택적으로 로딩 가능 모듈화된 경량 라이브러리 선택, 불필요한 기능 제거 실행 속도 성능 최적화 추상화 계층 많아 오버헤드 발생 가능 직접 호출 구조로 고성능 구현 가능 크리티컬 경로는 라이브러리 사용, 병목 구간 프로파일링 적용 번들 크기 크기 최소화 프레임워크 전체 포함 시 번들 커짐 Tree Shaking 가능, 경량화 용이 Webpack, Rollup 등 번들 분석 도구 활용 초기화 시간 시작 시간 단축 부트스트랩 과정 길어질 수 있음 간단한 초기화로 즉시 사용 가능 지연 로딩 (Lazy Loading), 조건부 로딩 적용 성능 커스터마이징 필요 기능만 사용 설정 최적화 및 커스터마이징 가능 필요한 기능만 선택하여 조합 가능 설정 튜닝, 커스터마이징 및 미사용 기능 비활성화 보안 취약점 방지 프레임워크 자체 보안 패치 여부 중요 각 라이브러리별 취약점 주기적 모니터링 필요 보안 업데이트 추적, 취약점 점검 도구 (npm audit 등) 활용 확장성 구조 유연성 확보 플러그인, 확장 모듈 방식으로 구조 확장 가능 다양한 라이브러리를 조합해 유연한 확장 가능 인터페이스 기반 설계, 의존성 분리 전략 적용 중복 및 효율 경량화, 코드 중복 최소화 중복 기능 제거를 위한 구조적 설계 필요 경량화 용이하나, 중복 호출 발생 가능성 있음 최신 버전 사용, 호출 최적화, 공통 유틸 분리 강점과 약점 구분 Framework Library 강점 • 일관된 아키텍처 제공\n• 반복 작업 자동화\n• 베스트 프랙티스 내장\n• 대규모 팀 협업 용이\n• 커뮤니티 지원 풍부 • 높은 유연성\n• 낮은 학습 비용\n• 선택적 사용 가능\n• 벤더 종속성 최소화\n• 빠른 개발 시작 약점 • 높은 학습 곡선\n• 벤더 종속성\n• 제한된 유연성\n• 오버엔지니어링 위험\n• 업데이트 의존성 • 아키텍처 일관성 부족\n• 보일러플레이트 코드 증가\n• 통합 복잡성\n• 개별 라이브러리 관리 부담\n• 버전 충돌 가능성 장점과 단점 Framework 구분 내용 장점 • 표준화: 일관된 코딩 표준과 아키텍처 패턴 제공\n• 생산성: 반복적인 작업 자동화로 개발 속도 향상\n• 안정성: 검증된 코드와 패턴으로 품질 보장\n• 확장성: 플러그인과 모듈 시스템으로 기능 확장\n• 유지보수: 구조화된 코드로 유지보수 용이 단점 • 복잡성: 높은 학습 곡선과 초기 설정 복잡\n• 종속성: 특정 프레임워크에 강하게 의존\n• 제약: 프레임워크 규칙 내에서만 개발 가능\n• 성능: 추상화로 인한 오버헤드 발생\n• 비용: 라이선스 비용과 교육 비용 Framework 단점 해결 단점 해결 방법 높은 학습 곡선 • 단계적 학습 계획 수립\n• 멘토링 프로그램 운영\n• 실습 중심 교육\n• 커뮤니티 활용 벤더 종속성 • 표준 API 사용\n• 추상화 계층 도입\n• 어댑터 패턴 적용\n• 점진적 마이그레이션 계획 제한된 유연성 • 확장 포인트 활용\n• 플러그인 아키텍처 도입\n• 커스텀 컴포넌트 개발\n• 하이브리드 접근 방식 성능 오버헤드 • 프로파일링 기반 최적화\n• 네이티브 코드 활용\n• 캐싱 전략 적용\n• 지연 로딩 구현 Library 구분 내용 장점 • 유연성: 필요한 기능만 선택적으로 사용\n• 단순성: 낮은 학습 곡선과 즉시 사용 가능\n• 독립성: 다른 라이브러리와 독립적으로 동작\n• 성능: 직접적인 함수 호출로 높은 성능\n• 자유도: 개발자가 전체 흐름 제어 단점 • 일관성: 아키텍처 일관성 유지 어려움\n• 관리: 다수의 라이브러리 개별 관리 필요\n• 통합: 라이브러리 간 통합 복잡성\n• 중복: 보일러플레이트 코드 반복\n• 의존성: 버전 충돌과 의존성 관리 복잡 Library 단점 해결 단점 해결 방법 아키텍처 일관성 • 코딩 표준 수립\n• 아키텍처 가이드라인 작성\n• 코드 리뷰 프로세스\n• 정적 분석 도구 활용 의존성 관리 • 의존성 관리 도구 사용\n• 버전 정책 수립\n• 모노레포 전략\n• 자동화된 테스트 통합 복잡성 • API 표준화\n• 중간 계층 도입\n• 서비스 메시 활용\n• 마이크로서비스 패턴 활용 사례 사례 1: 전자상거래 플랫폼 개발 시나리오 프로젝트 요구사항:\n대규모 사용자 지원 실시간 주문 처리 다양한 결제 시스템 연동 재고 관리 시스템 관리자 대시보드 Framework 활용 사례 (Spring Boot 기반) 시스템 구성:\ngraph TB A[Spring Boot Application] --\u003e B[Spring Security] A --\u003e C[Spring Data JPA] A --\u003e D[Spring Web MVC] A --\u003e E[Spring Cloud Gateway] B --\u003e F[Authentication Service] C --\u003e G[Database Layer] D --\u003e H[REST API Controller] E --\u003e I[Microservices Router] G --\u003e J[(MySQL Database)] G --\u003e K[(Redis Cache)] H --\u003e L[User Service] H --\u003e M[Order Service] H --\u003e N[Payment Service] H --\u003e O[Inventory Service] Workflow (Framework 제어):\nsequenceDiagram participant C as Client participant SB as Spring Boot participant SC as Security participant Ctrl as Controller participant Svc as Service participant DB as Database C-\u003e\u003eSB: HTTP Request SB-\u003e\u003eSC: Security Filter Chain SC-\u003e\u003eCtrl: Authenticated Request Ctrl-\u003e\u003eSvc: Business Logic Call SB-\u003e\u003eSvc: Dependency Injection Svc-\u003e\u003eDB: Data Access DB-\u003e\u003eSvc: Result Svc-\u003e\u003eCtrl: Response Ctrl-\u003e\u003eSB: HTTP Response SB-\u003e\u003eC: Final Response Framework 의 역할:\n애플리케이션 부트스트랩: 자동 설정 및 빈 등록 보안 관리: JWT 토큰 검증, 권한 체크 트랜잭션 관리: 데이터베이스 트랜잭션 자동 처리 예외 처리: 글로벌 예외 핸들링 모니터링: 액추에이터를 통한 헬스 체크 Library 활용 사례 (React + 다양한 라이브러리) 시스템 구성:\ngraph TB A[React Application] --\u003e B[React Router] A --\u003e C[Redux Toolkit] A --\u003e D[Axios] A --\u003e E[Material-UI] A --\u003e F[Chart.js] B --\u003e G[Page Navigation] C --\u003e H[State Management] D --\u003e I[HTTP Client] E --\u003e J[UI Components] F --\u003e K[Data Visualization] I --\u003e L[Backend APIs] H --\u003e M[Application State] Workflow (개발자 제어):\nsequenceDiagram participant Dev as Developer Code participant R as React participant RT as React Router participant A as Axios participant Redux as Redux Dev-\u003e\u003eR: Render Component Dev-\u003e\u003eRT: Navigate to Page Dev-\u003e\u003eA: API Call A-\u003e\u003eDev: HTTP Response Dev-\u003e\u003eRedux: Dispatch Action Redux-\u003e\u003eDev: State Update Dev-\u003e\u003eR: Re-render UI Library 의 역할:\nReact: UI 컴포넌트 렌더링 React Router: 클라이언트 사이드 라우팅 Axios: HTTP 통신 Redux: 상태 관리 Material-UI: 디자인 시스템 사례 2: 웹 애플리케이션 개발 프레임워크 사용: Django 를 사용하여 웹 애플리케이션의 전체 구조를 정의하고, URL 라우팅, 데이터베이스 모델링, 템플릿 렌더링 등을 프레임워크의 구조에 맞춰 개발한다. 라이브러리 사용: Axios 를 사용하여 프론트엔드에서 비동기 HTTP 요청을 처리하며, Moment.js 를 사용하여 날짜 및 시간 관련 기능을 구현한다. 시스템 구성 다이어그램:\ngraph TD A[사용자] --\u003e B[프론트엔드] B --\u003e C[\"백엔드(Django)\"] C --\u003e D[데이터베이스] B --\u003e E[Axios] E --\u003e C 이 다이어그램은 사용자가 프론트엔드를 통해 백엔드에 요청을 보내고, 백엔드는 데이터베이스와 상호작용하며, 프론트엔드는 Axios 라이브러리를 사용하여 비동기 요청을 처리하는 구조를 나타낸다.\n사례 3: 전자상거래 웹사이트 개발 프레임워크 활용:\nSpring Boot 를 기반으로 전체 애플리케이션 구조 (REST API, 인증, 트랜잭션 등) 를 설계.\n프레임워크가 요청을 받아 컨트롤러를 호출하고, 서비스 및 DAO 계층을 순차적으로 실행.\n라이브러리 활용:\n데이터 가공이나 특정 기능 (예: PDF 생성, 암호화 등) 에 Apache Commons, iText 등 라이브러리를 직접 호출하여 사용.\n시스템 구성 다이어그램\nflowchart TD A[클라이언트] --\u003e B[Spring Boot 프레임워크] B --\u003e C[Controller] C --\u003e D[Service] D --\u003e E[Repository] D --\u003e F[\"라이브러리 호출(예: iText)\"] Workflow\n클라이언트가 주문 요청 → Spring Boot 가 컨트롤러 호출 서비스 계층에서 주문 로직 처리 PDF 영수증 생성 시 iText 라이브러리 직접 호출 역할\n프레임워크: 전체 구조 및 흐름 제어, 요청 분배 라이브러리: 특정 기능 (예: PDF 생성) 제공 차이점\n프레임워크는 전체 애플리케이션의 흐름과 구조를 제어 라이브러리는 개발자가 필요할 때 직접 호출하여 사용 앞으로의 전망 주제 항목 설명 프레임워크 자동화 및 AI 통합 AI 기반 코드 자동 생성, 테스트/빌드 자동화 도구와의 통합 가속화 마이크로서비스 아키텍처 마이크로서비스 확산으로 경량화된 프레임워크 (Spring Boot Lite 등) 수요 증가 클라우드 네이티브 Docker, Kubernetes 에 최적화된 프레임워크 발전 (예: Quarkus, Micronaut) 서버리스 최적화 AWS Lambda, Google Cloud Functions 전용 경량 프레임워크 활용 확대 개발자 경험 (DX) 강화 핫 리로드, 자동 완성, 에러 추적 등 도구가 내장된 통합형 개발환경 확대 라이브러리 경량화 및 모듈화 목적별로 분리된 모듈, 의존성 최소화 추세 강화 (예: lodash → lodash-es 등) 패키지 관리 강화 버전 충돌 방지, 중복 제거를 위한 패키지 관리자 (npm, pip, poetry 등) 의 발전 정적 타입 및 타입 안전성 강화 TypeScript, Rust 등 정적 타입 기반 라이브러리 선호 증가 공통/전체 오픈소스 생태계 확장 다양한 오픈소스 프레임워크/라이브러리 동시 활용이 일반화, 커뮤니티 주도 기술 발전 모듈 연합 (Micro Frontends) 런타임에 독립된 프론트엔드 모듈을 통합해 구성하는 아키텍처 활성화 웹어셈블리 (WASM) 브라우저에서 고성능 실행 가능 → Python, Rust 등 비 JS 언어 실행 기반 확대 AI/ML 통합 머신러닝 워크플로우를 쉽게 구성하는 전용 프레임워크 및 라이브러리 지속 확산 주목할 내용 주제 항목 설명 설계 원칙 제어의 역전 (IoC, Inversion of Control) 프레임워크가 흐름을 제어하고 개발자는 콜백만 제공하는 구조 템플릿 메서드 패턴 프레임워크의 처리 흐름을 정의하는 대표적 디자인 패턴 함수형 프로그래밍 라이브러리 설계에서 유연성과 재사용성을 높이는 패러다임 개발 트렌드 저코드/노코드 도구 비개발자도 사용할 수 있는 시각적 인터페이스 기반의 프레임워크/도구 등장 멀티플랫폼 개발 하나의 코드로 웹, 모바일, 데스크톱 등 여러 플랫폼을 동시에 지원 (예: Flutter, React Native) 실시간 처리 프레임워크 WebSocket 기반의 실시간 통신 지원 (예: Socket.io, SignalR) JAMstack 아키텍처 정적 사이트 생성 + 서버사이드 렌더링을 결합한 차세대 웹 구조 (Next.js, Nuxt.js) 풀스택 프레임워크 프론트와 백엔드를 통합한 일체형 개발 환경 제공 (T3 Stack, SvelteKit) 엣지 컴퓨팅 프레임워크 사용자와 가까운 위치에서 실행되는 경량 런타임 플랫폼 (Deno, Cloudflare Workers) GraphQL 생태계 효율적인 데이터 요청 및 응답을 위한 API 계층 기술 (Apollo, Relay 등) 마이크로서비스 도구 서비스 분산을 위한 프레임워크 및 서비스 메쉬 기술 (Spring Cloud, Istio) 보안 및 유지보수 시큐어 바이 디자인 (OWASP 기반) 보안을 아키텍처 수준에서 내장한 프레임워크 및 개발 지침 패키지 매니저 라이브러리 및 프레임워크 의존성 충돌 방지 도구 (npm, pip, pnpm 등) 추가 학습 필요 내용 주제 설명 연관 분야 제어의 역전 (IoC) 프로그램 제어 흐름을 프레임워크 등 외부로 위임하는 설계 원칙 디자인 패턴, 아키텍처 의존성 주입 (DI) 객체 간 결합도를 낮추고 유연성을 높이기 위한 객체 생성/주입 구조 소프트웨어 아키텍처 프레임워크 설계 프레임워크의 내부 구조와 확장 포인트 설계 방법론 학습 아키텍처, AOP, IoC 라이브러리 관리 패키지 관리 도구 활용, 의존성 버전 충돌 방지 기법 DevOps, 유지보수 디자인 패턴 프레임워크/라이브러리 구조 이해에 도움되는 구조/행동/생성 패턴 학습 객체 지향 설계 템플릿 메서드 패턴 알고리즘의 골격 정의 후 세부 구현은 하위 클래스에 위임하는 설계 패턴 GoF 디자인 패턴 빌더 패턴 복잡한 객체 생성을 단계별로 유연하게 처리하는 생성 패턴 객체 지향 설계 관점 지향 프로그래밍 (AOP) 로깅, 보안 등 공통 기능을 비즈니스 로직과 분리하여 모듈화하는 패러다임 프레임워크 설계, 유지보수 모듈화 코드의 재사용성과 유지보수성을 높이기 위한 논리적 분할 및 의존성 분리 전략 라이브러리 설계, 아키텍처 하위 주제별 추가 학습 내용 카테고리 주제 설명 아키텍처 패턴 MVC, MVP, MVVM 사용자 인터페이스 구조를 나누어 역할을 분리하는 대표 UI 아키텍처 패턴들 레이어드 아키텍처 표현, 도메인, 인프라 계층으로 구분된 전통적인 계층형 설계 방식 헥사고날 아키텍처 (Hexagonal) 포트와 어댑터를 이용한 내부 - 외부 분리 구조로 유연한 아키텍처 구성 가능 마이크로서비스 아키텍처 서비스 단위로 나뉜 독립 배포 가능한 아키텍처 스타일로 프레임워크/라이브러리 선택에 영향 설계 원칙 SOLID 원칙 객체지향 설계의 다섯 가지 원칙 (단일 책임, 개방 - 폐쇄 등) DRY, KISS, YAGNI 중복 제거, 단순성 유지, 과도한 기능 방지 등 실용적 설계 원칙 IoC, DI, 헐리우드 원칙 제어의 역전, 의존성 주입, 콜백 구조에 대한 설계 원리 이해 프로그래밍 패러다임 함수형 프로그래밍 순수 함수, 불변성, 고차 함수 등 라이브러리 설계 및 조합에 유용한 패러다임 성능 최적화 지연 로딩 실행 시점에 필요한 리소스를 로드하여 초기화 지연 및 자원 최적화 캐싱 전략 메모리 캐시, 분산 캐시 (Redis 등) 적용을 통한 응답속도 개선 테스트 전략 단위 테스트 Mock, Stub 기반으로 독립적 단위 기능 검증 수행 통합 테스트 여러 컴포넌트 간의 상호작용과 의존성 검증 테스트 실무 적용 프레임워크 커스터마이징 오픈소스 프레임워크 확장, 설정 변경, 훅 (Hook) 활용 방식 패키지 관리 npm, pip, Maven 등 언어별 패키지 관리 도구로 의존성 설치, 버전 관리, 빌드 자동화 수행 관련 분야별 추가 학습 카테고리 주제 설명 소프트웨어 아키텍처 마이크로서비스, 모듈화 프레임워크/라이브러리와 연계된 유연한 아키텍처 설계 소프트웨어 개발 테스트 주도 개발 (TDD) 테스트를 중심으로 개발 흐름을 구성하여 통합 안정성 확보 소프트웨어 유지보수 지속적 통합 (CI) 라이브러리/프레임워크 업데이트 및 테스트 자동화 프로세스 DevOps CI/CD 파이프라인 지속적 통합 및 지속적 배포 자동화를 위한 워크플로우 구축 컨테이너화 Docker, Kubernetes 기반의 환경 격리 및 이식성 확보 클라우드 컴퓨팅 서버리스 컴퓨팅 FaaS (Function as a Service), BaaS 등 서버 관리 최소화 아키텍처 마이크로서비스 클라우드 친화적인 분산 아키텍처 설계 및 서비스 독립 운영 데이터베이스 ORM/ODM 객체와 관계형/비관계형 DB 간의 매핑 기술 (예: SQLAlchemy, Mongoose) NoSQL 패턴 문서, 키 - 값, 컬럼 기반 DB 모델링 기법 및 설계 전략 보안 의존성 보안 프레임워크/라이브러리의 취약점 점검 및 안전한 버전 용어 정리 소프트웨어 설계 원칙 및 패턴 용어 설명 제어의 역전 (Inversion of Control, IoC) 애플리케이션의 제어 흐름을 개발자가 아닌 외부 컴포넌트 (예: 프레임워크) 가 관리하는 설계 원칙 의존성 주입 (Dependency Injection, DI) 객체가 의존하는 컴포넌트를 내부에서 생성하지 않고 외부에서 주입받는 방식으로, IoC 를 구현하는 방법 중 하나 할리우드 원칙 (Hollywood Principle) “Don’t call us, we’ll call you”–상위 컴포넌트가 하위 컴포넌트를 제어함으로써 제어의 역전을 구현 템플릿 메서드 패턴 (Template Method Pattern) 알고리즘의 구조를 상위 클래스에서 정의하고, 일부 구현을 하위 클래스에 위임하는 디자인 패턴 소프트웨어 아키텍처 및 구조 용어 설명 MVC (Model-View-Controller) 애플리케이션을 모델, 뷰, 컨트롤러로 분리하여 관심사의 분리를 달성하는 아키텍처 패턴 ORM (Object-Relational Mapping) 객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스 간 매핑을 지원하는 기술 개발 도구 및 플랫폼 용어 설명 프레임워크 (Framework) 애플리케이션 개발을 위한 구조와 제어 흐름을 제공하며, 개발자는 필요한 부분을 구현만 하면 되는 구조 라이브러리 (Library) 개발자가 호출하여 사용하는 독립적인 기능 단위의 코드 집합 패키지 매니저 (Package Manager) 외부 라이브러리 및 프레임워크의 설치, 업데이트, 의존성 관리를 자동화해주는 도구 API (Application Programming Interface) 소프트웨어 간의 상호작용을 위한 명세와 인터페이스 SDK (Software Development Kit) 특정 플랫폼용 애플리케이션을 개발하기 위해 제공되는 도구, 라이브러리, 문서 등의 모음 프로그래밍 패러다임 용어 설명 함수형 프로그래밍 (Functional Programming) 상태와 부작용을 피하고 순수 함수 기반으로 동작하는 프로그래밍 패러다임 성능 및 최적화 용어 설명 지연 로딩 (Lazy Loading) 애플리케이션에서 리소스를 실제로 필요한 시점까지 로딩하지 않고 대기시키는 기법 트리 쉐이킹 (Tree Shaking) 사용되지 않는 코드를 최종 번들에서 제거하여 최적화하는 기술 핫 리로드 (Hot Reload) 코드 변경 시 전체 애플리케이션을 재시작하지 않고 실시간으로 반영하는 기능 프로파일링 (Profiling) 애플리케이션의 성능을 측정하고 병목 지점을 분석하는 과정 참고 및 출처 Framework Vs Library 관련 Software Framework vs Library | GeeksforGeeks The Difference Between a Framework and a Library | freeCodeCamp Framework Vs. Library: Know the Main Differences in 2025 | Sencha Framework vs Library: Full Comparison | InterviewBit The Difference Between a Framework and a Library | Baeldung Framework vs. Library: Differences, Concepts, and Specific Cases | Bluebird International The Difference Between a Library and a Framework | DEV Community Framework vs. Library (Similarities and Differences) | Indeed How Libraries and Frameworks Revolutionized Software Development | LinkedIn What is the difference between Libraries vs framework? | Anar Solutions What is the difference between a framework and a library? [StackOverflow] 프레임워크와 라이브러리의 차이점 | 개발자스럽다 자바 프레임워크(Java Framework)란? | Red Hat Inversion of Control \u0026 Hollywood Principle 관련 Inversion of Control - Wikipedia bliki: Inversion Of Control | Martin Fowler Three Design Patterns That Use Inversion of Control | SitePoint Hollywood Principle | DevIQ What is the Hollywood Principle? | StackOverflow P4L5 Design Principles | Georgia Tech Course 일반 개념 정리 관련 Software framework - Wikipedia Library (computing) - Wikipedia 재정리 - Spring - 기록용 개발 블로그 - 티스토리 ","wordCount":"3326","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-20T06:47:00Z","dateModified":"2024-11-20T06:47:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/framework-vs.-library/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Software Engineering Foundations</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/>Principles</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/>Design Principles</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/foundations/principles/design-principles/inversion-of-control/>Inversion of Control</a></div><h1 class="post-title entry-hint-parent">Framework vs. Library</h1><div class=post-description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 ' 할리우드 원칙 '(제어의 역전) 으로 설명된다.</div><div class=post-meta><span title='2024-11-20 06:47:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Foundations/Principles/Design%20Principles/Inversion%20of%20Control/Framework%20vs.%20Library.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#framework-vs-library>Framework vs. Library</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#framework-vs-library-비교>Framework vs. Library 비교</a></li><li><a href=#구조-및-아키텍처>구조 및 아키텍처</a></li><li><a href=#주요-원리>주요 원리</a></li><li><a href=#구현-기법>구현 기법</a></li><li><a href=#실무-적용-고려사항>실무 적용 고려사항</a></li><li><a href=#최적화-고려사항>최적화 고려사항</a></li><li><a href=#강점과-약점>강점과 약점</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#앞으로의-전망>앞으로의 전망</a></li><li><a href=#주목할-내용>주목할 내용</a></li><li><a href=#추가-학습-필요-내용>추가 학습 필요 내용</a></li><li><a href=#하위-주제별-추가-학습-내용>하위 주제별 추가 학습 내용</a></li><li><a href=#관련-분야별-추가-학습>관련 분야별 추가 학습</a></li></ul></li><li><a href=#용어-정리>용어 정리</a><ul><li><a href=#소프트웨어-설계-원칙-및-패턴>소프트웨어 설계 원칙 및 패턴</a></li><li><a href=#소프트웨어-아키텍처-및-구조>소프트웨어 아키텍처 및 구조</a></li><li><a href=#개발-도구-및-플랫폼>개발 도구 및 플랫폼</a></li><li><a href=#프로그래밍-패러다임>프로그래밍 패러다임</a></li><li><a href=#성능-및-최적화>성능 및 최적화</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#framework-vs-library-관련>Framework Vs Library 관련</a></li><li><a href=#inversion-of-control--hollywood-principle-관련>Inversion of Control & Hollywood Principle 관련</a></li><li><a href=#일반-개념-정리-관련>일반 개념 정리 관련</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=framework-vs-library>Framework vs. Library<a hidden class=anchor aria-hidden=true href=#framework-vs-library>#</a></h2><p>프레임워크와 라이브러리는 소프트웨어 개발에서 필수적인 구성 요소로, 각각의 목적과 사용 방식이 다르다. 라이브러리는 특정 기능을 제공하는 코드 집합으로 개발자가 직접 호출해 사용한다. 반면, 프레임워크는 애플리케이션의 구조와 흐름을 정의하며, 개발자가 작성한 코드를 필요에 따라 호출하는 &rsquo; 제어의 역전 &rsquo; 원칙을 따른다. 이 차이는 시스템 설계의 핵심 원리와 실무 적용에 큰 영향을 미치며, 각 도구의 장단점, 적용 사례, 최적화 및 실무 적용 시 고려사항 등에서 뚜렷하게 드러난다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><strong>제어의 역전 (Inversion of Control, IoC)</strong>: 프로그램의 제어 흐름이 전통적인 방식과 반대로 동작하는 설계 원칙</li><li><strong>Hollywood Principle</strong>: &ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo; - 프레임워크가 개발자 코드를 호출</li><li><strong>의존성 주입 (Dependency Injection)</strong>: 객체의 의존성을 외부에서 주입하는 방식</li><li><strong>애플리케이션 프레임워크 (Application Framework)</strong>: 특정 도메인의 애플리케이션 개발을 위한 포괄적인 구조</li><li><strong>코드 라이브러리 (Code Library)</strong>: 재사용 가능한 함수와 클래스의 집합</li></ul><h3 id=framework-vs-library-비교>Framework vs. Library 비교<a hidden class=anchor aria-hidden=true href=#framework-vs-library-비교>#</a></h3><table><thead><tr><th>구분</th><th><strong>프레임워크 (Framework)</strong></th><th><strong>라이브러리 (Library)</strong></th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>애플리케이션 개발을 위한 구조와 제어 흐름을 제공하는 소프트웨어 플랫폼</td><td>특정 기능을 수행하는 코드 집합으로, 필요 시 개발자가 직접 호출</td></tr><tr><td><strong>제어 흐름 (Control Flow)</strong></td><td><strong>프레임워크가 전체 흐름을 제어</strong>하며, 개발자의 코드를 호출 (제어의 역전: IoC)</td><td><strong>개발자가 라이브러리를 직접 호출</strong>하여 제어 흐름을 관리</td></tr><tr><td><strong>사용 방식</strong></td><td>프레임워크의 구조에 맞춰 코드를 작성하고, 확장 지점을 통해 기능 구현</td><td>필요한 기능만 선택적으로 가져와 호출</td></tr><tr><td><strong>구조 제공</strong></td><td>애플리케이션의 아키텍처 및 구성 방식을 정의</td><td>구조에 영향을 주지 않음</td></tr><tr><td><strong>확장성</strong></td><td>명확한 확장 포인트 제공 (예: Hook, 인터페이스 등)</td><td>함수 단위로 조합하여 사용 가능</td></tr><tr><td><strong>유연성</strong></td><td>프레임워크의 구조를 따르므로 상대적으로 유연성은 낮음</td><td>특정 기능 단위로 자유롭게 사용 가능</td></tr><tr><td><strong>재사용성</strong></td><td>특정 프레임워크에 종속적일 수 있음</td><td>다양한 프로젝트에서 재사용 가능함</td></tr><tr><td><strong>예시</strong></td><td>Spring, Angular, Django, React (의견 분분하지만 구조 제공 시 프레임워크로 분류되기도 함)</td><td>Lodash, NumPy, jQuery, Requests</td></tr></tbody></table><h4 id=사용-시나리오-비교>사용 시나리오 비교<a hidden class=anchor aria-hidden=true href=#사용-시나리오-비교>#</a></h4><table><thead><tr><th>구분</th><th>Framework</th><th>Library</th></tr></thead><tbody><tr><td><strong>적합한 프로젝트</strong></td><td>대규모, 복잡한 애플리케이션</td><td>특정 기능이 필요한 프로젝트</td></tr><tr><td><strong>팀 규모</strong></td><td>대규모 팀 (일관성 중요)</td><td>소규모 팀 (유연성 중요)</td></tr><tr><td><strong>유지보수</strong></td><td>프레임워크 업데이트에 의존</td><td>개별적으로 관리 가능</td></tr><tr><td><strong>테스트</strong></td><td>프레임워크 테스트 환경 사용</td><td>독립적인 단위 테스트</td></tr></tbody></table><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=framework-아키텍처>Framework 아키텍처<a hidden class=anchor aria-hidden=true href=#framework-아키텍처>#</a></h4><pre class=mermaid>graph TD
    A[Framework Core] --&gt; B[Application Lifecycle]
    A --&gt; C[Dependency Injection Container]
    A --&gt; D[Configuration Management]
    A --&gt; E[Plugin System]
    
    B --&gt; F[Initialization]
    B --&gt; G[Execution]
    B --&gt; H[Cleanup]
    
    C --&gt; I[Bean Factory]
    C --&gt; J[Dependency Resolution]
    
    D --&gt; K[XML/Annotation Config]
    D --&gt; L[Environment Properties]
    
    E --&gt; M[Extension Points]
    E --&gt; N[Custom Components]
    
    F --&gt; O[Developer Code]
    G --&gt; O
    H --&gt; O
</pre><p><strong>Framework 구성요소:</strong></p><table><thead><tr><th>구성요소</th><th>유형</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>Core Engine</strong></td><td>필수</td><td>애플리케이션 실행 엔진</td><td>전체 흐름 제어</td></tr><tr><td><strong>Lifecycle Manager</strong></td><td>필수</td><td>객체 생명주기 관리</td><td>초기화, 실행, 정리</td></tr><tr><td><strong>Configuration System</strong></td><td>필수</td><td>설정 관리</td><td>프레임워크 동작 제어</td></tr><tr><td><strong>Dependency Injection</strong></td><td>필수</td><td>의존성 관리</td><td>객체 간 결합도 감소</td></tr><tr><td><strong>Extension Interface</strong></td><td>선택</td><td>확장점 제공</td><td>커스터마이징 지원</td></tr><tr><td><strong>Additional Libraries</strong></td><td>선택</td><td>부가 기능</td><td>특화된 기능 제공</td></tr></tbody></table><h4 id=library-아키텍처>Library 아키텍처<a hidden class=anchor aria-hidden=true href=#library-아키텍처>#</a></h4><pre class=mermaid>graph TD
    A[Application Code] --&gt; B[Library API]
    B --&gt; C[Core Functions]
    B --&gt; D[Utility Functions]
    B --&gt; E[Helper Classes]
    
    C --&gt; F[Primary Features]
    D --&gt; G[Support Functions]
    E --&gt; H[Common Operations]
    
    A --&gt; I[Direct Function Calls]
    I --&gt; C
    I --&gt; D
    I --&gt; E
</pre><p><strong>Library 구성요소:</strong></p><table><thead><tr><th>구성요소</th><th>유형</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>API Interface</strong></td><td>필수</td><td>외부 접근점</td><td>기능 노출</td></tr><tr><td><strong>Core Functions</strong></td><td>필수</td><td>주요 기능 구현</td><td>핵심 로직 처리</td></tr><tr><td><strong>Documentation</strong></td><td>필수</td><td>사용법 설명</td><td>개발자 가이드</td></tr><tr><td><strong>Helper Utilities</strong></td><td>선택</td><td>보조 기능</td><td>편의성 향상</td></tr><tr><td><strong>Example Code</strong></td><td>선택</td><td>사용 예제</td><td>학습 지원</td></tr><tr><td><strong>Extension Modules</strong></td><td>선택</td><td>확장 기능</td><td>추가 기능 제공</td></tr></tbody></table><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><p>프레임워크는 제어의 역전 (Inversion of Control) 원칙에 따라 작동하며, 개발자의 코드를 호출한다. 라이브러리는 개발자가 직접 호출하여 사용하는 구조이다.</p><p><strong>Framework 동작 원리 (Hollywood Principle):</strong></p><pre class=mermaid>sequenceDiagram
    participant F as Framework
    participant DC as Developer Code
    participant AC as Application Context
    
    F-&gt;&gt;AC: Initialize Application
    F-&gt;&gt;DC: Call setUp() method
    DC-&gt;&gt;F: Return configuration
    F-&gt;&gt;AC: Configure components
    F-&gt;&gt;DC: Call execute() method
    DC-&gt;&gt;F: Perform business logic
    F-&gt;&gt;DC: Call tearDown() method
    F-&gt;&gt;AC: Cleanup resources
</pre><p><strong>Library 동작 원리 (Direct Call):</strong></p><pre class=mermaid>sequenceDiagram
    participant DC as Developer Code
    participant L as Library
    participant R as Resources
    
    DC-&gt;&gt;L: Call function A()
    L-&gt;&gt;R: Access resource
    R-&gt;&gt;L: Return data
    L-&gt;&gt;DC: Return result
    
    DC-&gt;&gt;L: Call function B()
    L-&gt;&gt;DC: Return result
    
    DC-&gt;&gt;L: Call function C()
    L-&gt;&gt;DC: Return result
</pre><hr><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>구분</th><th>구현 기법</th><th>정의</th><th>구성 요소</th><th>목적</th><th>실제 예시 (시스템 구성 / 시나리오)</th></tr></thead><tbody><tr><td><strong>Framework</strong></td><td>템플릿 메서드 패턴 (Template Method Pattern)</td><td>알고리즘 골격 정의, 세부 단계는 하위 클래스에 위임</td><td>추상 클래스, 템플릿 메서드, 훅 메서드</td><td>처리 흐름의 일관성 유지, 코드 재사용</td><td><strong>Spring Framework - JdbcTemplate</strong><br>DB 연결 → 쿼리 실행 → 결과 처리 → 연결 해제</td></tr><tr><td></td><td>의존성 주입 패턴 (Dependency Injection Pattern)</td><td>객체의 의존성을 외부에서 주입</td><td>IoC 컨테이너, Bean 정의, 주입 지점</td><td>결합도 감소, 테스트 용이성 향상</td><td><strong>Spring Boot + JPA</strong><br>Controller → Service → Repository 간 의존성 자동 주입</td></tr><tr><td><strong>Library</strong></td><td>팩토리 패턴 (Factory Pattern)</td><td>객체 생성 로직 캡슐화</td><td>팩토리 클래스, 제품 인터페이스, 구체 클래스</td><td>생성 복잡도 은닉, 확장성 제공</td><td><strong>Apache Commons Collections</strong><br>다양한 컬렉션을 팩토리 메서드로 생성</td></tr><tr><td></td><td>빌더 패턴 (Builder Pattern)</td><td>복잡한 객체를 단계적으로 생성</td><td>빌더 인터페이스, 구체 빌더, 디렉터</td><td>가독성 향상, 생성 유연성 확보</td><td><strong>Retrofit HTTP Client</strong><br>HTTP 요청 객체를 체이닝 방식으로 구성</td></tr></tbody></table><h3 id=실무-적용-고려사항>실무 적용 고려사항<a hidden class=anchor aria-hidden=true href=#실무-적용-고려사항>#</a></h3><table><thead><tr><th>구분</th><th>고려사항/상황</th><th>Framework 활용 시</th><th>Library 활용 시</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>프로젝트 규모</strong></td><td>소규모 프로젝트</td><td>구조적 오버헤드 발생 가능</td><td>경량화된 구성으로 적합</td><td>필요한 기능만 선택, 불필요한 프레임워크 지양</td></tr><tr><td><strong>프로젝트 규모</strong></td><td>대규모 프로젝트</td><td>아키텍처 일관성 유지 용이, 확장성 높음</td><td>라이브러리 난립 시 구조 복잡도 증가 가능</td><td>아키텍처 표준화 및 일관된 적용 방식 수립</td></tr><tr><td><strong>팀 경험 수준</strong></td><td>초급자 중심 팀</td><td>학습 곡선 큼, 사용 실수 가능성 존재</td><td>비교적 진입장벽 낮음</td><td>점진적 도입 및 내부 교육/가이드 제공</td></tr><tr><td><strong>팀 경험 수준</strong></td><td>숙련자 중심 팀</td><td>생산성 및 구조화 효과 극대화 가능</td><td>다양한 선택 가능, 자유도 활용 가능</td><td>베스트 프랙티스와 표준 개발 가이드 적용</td></tr><tr><td><strong>유지보수/확장성</strong></td><td>장기 운영 프로젝트</td><td>프레임워크 구조에 기반한 유지보수 체계 가능</td><td>각 라이브러리별 관리 및 업데이트 필요</td><td>버전 정책 및 의존성 관리 기준 수립</td></tr><tr><td><strong>기술 호환성</strong></td><td>프레임워크/라이브러리 업데이트</td><td>프레임워크 버전 간 호환성 확인 필요</td><td>의존 라이브러리 충돌 가능성 존재</td><td>공식 문서 기반 업그레이드 전략 수립</td></tr><tr><td><strong>성능 요구사항</strong></td><td>고성능 서비스</td><td>프레임워크의 내부 처리 로직에 최적화 제약 있음</td><td>세밀한 성능 조정 가능</td><td>성능 프로파일링 도구를 통한 선택 및 설정 최적화</td></tr><tr><td><strong>운영 환경 구성</strong></td><td>패키지 및 의존성 관리</td><td>통합적인 프로젝트 구조에서 패키지 충돌 적음</td><td>의존성 중복 및 충돌 가능성 존재</td><td><code>pip</code>, <code>poetry</code>, <code>npm</code> 등 패키지 관리 도구 적극 활용</td></tr></tbody></table><h3 id=최적화-고려사항>최적화 고려사항<a hidden class=anchor aria-hidden=true href=#최적화-고려사항>#</a></h3><table><thead><tr><th>구분</th><th>고려 요소</th><th>Framework 활용 시 특징</th><th>Library 활용 시 특징</th><th>권장사항 및 모범 사례</th></tr></thead><tbody><tr><td><strong>메모리 사용량</strong></td><td>사용량 최소화</td><td>전체 프레임워크 로딩으로 메모리 부담 가능</td><td>필요한 기능만 선택적으로 로딩 가능</td><td>모듈화된 경량 라이브러리 선택, 불필요한 기능 제거</td></tr><tr><td><strong>실행 속도</strong></td><td>성능 최적화</td><td>추상화 계층 많아 오버헤드 발생 가능</td><td>직접 호출 구조로 고성능 구현 가능</td><td>크리티컬 경로는 라이브러리 사용, 병목 구간 프로파일링 적용</td></tr><tr><td><strong>번들 크기</strong></td><td>크기 최소화</td><td>프레임워크 전체 포함 시 번들 커짐</td><td>Tree Shaking 가능, 경량화 용이</td><td>Webpack, Rollup 등 번들 분석 도구 활용</td></tr><tr><td><strong>초기화 시간</strong></td><td>시작 시간 단축</td><td>부트스트랩 과정 길어질 수 있음</td><td>간단한 초기화로 즉시 사용 가능</td><td>지연 로딩 (Lazy Loading), 조건부 로딩 적용</td></tr><tr><td><strong>성능 커스터마이징</strong></td><td>필요 기능만 사용</td><td>설정 최적화 및 커스터마이징 가능</td><td>필요한 기능만 선택하여 조합 가능</td><td>설정 튜닝, 커스터마이징 및 미사용 기능 비활성화</td></tr><tr><td><strong>보안</strong></td><td>취약점 방지</td><td>프레임워크 자체 보안 패치 여부 중요</td><td>각 라이브러리별 취약점 주기적 모니터링 필요</td><td>보안 업데이트 추적, 취약점 점검 도구 (npm audit 등) 활용</td></tr><tr><td><strong>확장성</strong></td><td>구조 유연성 확보</td><td>플러그인, 확장 모듈 방식으로 구조 확장 가능</td><td>다양한 라이브러리를 조합해 유연한 확장 가능</td><td>인터페이스 기반 설계, 의존성 분리 전략 적용</td></tr><tr><td><strong>중복 및 효율</strong></td><td>경량화, 코드 중복 최소화</td><td>중복 기능 제거를 위한 구조적 설계 필요</td><td>경량화 용이하나, 중복 호출 발생 가능성 있음</td><td>최신 버전 사용, 호출 최적화, 공통 유틸 분리</td></tr></tbody></table><h3 id=강점과-약점>강점과 약점<a hidden class=anchor aria-hidden=true href=#강점과-약점>#</a></h3><table><thead><tr><th>구분</th><th>Framework</th><th>Library</th></tr></thead><tbody><tr><td><strong>강점</strong></td><td>• 일관된 아키텍처 제공<br>• 반복 작업 자동화<br>• 베스트 프랙티스 내장<br>• 대규모 팀 협업 용이<br>• 커뮤니티 지원 풍부</td><td>• 높은 유연성<br>• 낮은 학습 비용<br>• 선택적 사용 가능<br>• 벤더 종속성 최소화<br>• 빠른 개발 시작</td></tr><tr><td><strong>약점</strong></td><td>• 높은 학습 곡선<br>• 벤더 종속성<br>• 제한된 유연성<br>• 오버엔지니어링 위험<br>• 업데이트 의존성</td><td>• 아키텍처 일관성 부족<br>• 보일러플레이트 코드 증가<br>• 통합 복잡성<br>• 개별 라이브러리 관리 부담<br>• 버전 충돌 가능성</td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><h4 id=framework>Framework<a hidden class=anchor aria-hidden=true href=#framework>#</a></h4><table><thead><tr><th>구분</th><th>내용</th></tr></thead><tbody><tr><td><strong>장점</strong></td><td>• <strong>표준화</strong>: 일관된 코딩 표준과 아키텍처 패턴 제공<br>• <strong>생산성</strong>: 반복적인 작업 자동화로 개발 속도 향상<br>• <strong>안정성</strong>: 검증된 코드와 패턴으로 품질 보장<br>• <strong>확장성</strong>: 플러그인과 모듈 시스템으로 기능 확장<br>• <strong>유지보수</strong>: 구조화된 코드로 유지보수 용이</td></tr><tr><td><strong>단점</strong></td><td>• <strong>복잡성</strong>: 높은 학습 곡선과 초기 설정 복잡<br>• <strong>종속성</strong>: 특정 프레임워크에 강하게 의존<br>• <strong>제약</strong>: 프레임워크 규칙 내에서만 개발 가능<br>• <strong>성능</strong>: 추상화로 인한 오버헤드 발생<br>• <strong>비용</strong>: 라이선스 비용과 교육 비용</td></tr></tbody></table><h5 id=framework-단점-해결>Framework 단점 해결<a hidden class=anchor aria-hidden=true href=#framework-단점-해결>#</a></h5><table><thead><tr><th>단점</th><th>해결 방법</th></tr></thead><tbody><tr><td><strong>높은 학습 곡선</strong></td><td>• 단계적 학습 계획 수립<br>• 멘토링 프로그램 운영<br>• 실습 중심 교육<br>• 커뮤니티 활용</td></tr><tr><td><strong>벤더 종속성</strong></td><td>• 표준 API 사용<br>• 추상화 계층 도입<br>• 어댑터 패턴 적용<br>• 점진적 마이그레이션 계획</td></tr><tr><td><strong>제한된 유연성</strong></td><td>• 확장 포인트 활용<br>• 플러그인 아키텍처 도입<br>• 커스텀 컴포넌트 개발<br>• 하이브리드 접근 방식</td></tr><tr><td><strong>성능 오버헤드</strong></td><td>• 프로파일링 기반 최적화<br>• 네이티브 코드 활용<br>• 캐싱 전략 적용<br>• 지연 로딩 구현</td></tr></tbody></table><h4 id=library>Library<a hidden class=anchor aria-hidden=true href=#library>#</a></h4><table><thead><tr><th>구분</th><th>내용</th></tr></thead><tbody><tr><td><strong>장점</strong></td><td>• <strong>유연성</strong>: 필요한 기능만 선택적으로 사용<br>• <strong>단순성</strong>: 낮은 학습 곡선과 즉시 사용 가능<br>• <strong>독립성</strong>: 다른 라이브러리와 독립적으로 동작<br>• <strong>성능</strong>: 직접적인 함수 호출로 높은 성능<br>• <strong>자유도</strong>: 개발자가 전체 흐름 제어</td></tr><tr><td><strong>단점</strong></td><td>• <strong>일관성</strong>: 아키텍처 일관성 유지 어려움<br>• <strong>관리</strong>: 다수의 라이브러리 개별 관리 필요<br>• <strong>통합</strong>: 라이브러리 간 통합 복잡성<br>• <strong>중복</strong>: 보일러플레이트 코드 반복<br>• <strong>의존성</strong>: 버전 충돌과 의존성 관리 복잡</td></tr></tbody></table><h5 id=library-단점-해결>Library 단점 해결<a hidden class=anchor aria-hidden=true href=#library-단점-해결>#</a></h5><table><thead><tr><th>단점</th><th>해결 방법</th></tr></thead><tbody><tr><td><strong>아키텍처 일관성</strong></td><td>• 코딩 표준 수립<br>• 아키텍처 가이드라인 작성<br>• 코드 리뷰 프로세스<br>• 정적 분석 도구 활용</td></tr><tr><td><strong>의존성 관리</strong></td><td>• 의존성 관리 도구 사용<br>• 버전 정책 수립<br>• 모노레포 전략<br>• 자동화된 테스트</td></tr><tr><td><strong>통합 복잡성</strong></td><td>• API 표준화<br>• 중간 계층 도입<br>• 서비스 메시 활용<br>• 마이크로서비스 패턴</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-전자상거래-플랫폼-개발-시나리오>사례 1: 전자상거래 플랫폼 개발 시나리오<a hidden class=anchor aria-hidden=true href=#사례-1-전자상거래-플랫폼-개발-시나리오>#</a></h4><p><strong>프로젝트 요구사항:</strong></p><ul><li>대규모 사용자 지원</li><li>실시간 주문 처리</li><li>다양한 결제 시스템 연동</li><li>재고 관리 시스템</li><li>관리자 대시보드</li></ul><h5 id=framework-활용-사례-spring-boot-기반>Framework 활용 사례 (Spring Boot 기반)<a hidden class=anchor aria-hidden=true href=#framework-활용-사례-spring-boot-기반>#</a></h5><p><strong>시스템 구성:</strong></p><pre class=mermaid>graph TB
    A[Spring Boot Application] --&gt; B[Spring Security]
    A --&gt; C[Spring Data JPA]
    A --&gt; D[Spring Web MVC]
    A --&gt; E[Spring Cloud Gateway]
    
    B --&gt; F[Authentication Service]
    C --&gt; G[Database Layer]
    D --&gt; H[REST API Controller]
    E --&gt; I[Microservices Router]
    
    G --&gt; J[(MySQL Database)]
    G --&gt; K[(Redis Cache)]
    
    H --&gt; L[User Service]
    H --&gt; M[Order Service]
    H --&gt; N[Payment Service]
    H --&gt; O[Inventory Service]
</pre><p><strong>Workflow (Framework 제어):</strong></p><pre class=mermaid>sequenceDiagram
    participant C as Client
    participant SB as Spring Boot
    participant SC as Security
    participant Ctrl as Controller
    participant Svc as Service
    participant DB as Database
    
    C-&gt;&gt;SB: HTTP Request
    SB-&gt;&gt;SC: Security Filter Chain
    SC-&gt;&gt;Ctrl: Authenticated Request
    Ctrl-&gt;&gt;Svc: Business Logic Call
    SB-&gt;&gt;Svc: Dependency Injection
    Svc-&gt;&gt;DB: Data Access
    DB-&gt;&gt;Svc: Result
    Svc-&gt;&gt;Ctrl: Response
    Ctrl-&gt;&gt;SB: HTTP Response
    SB-&gt;&gt;C: Final Response
</pre><p><strong>Framework 의 역할:</strong></p><ul><li><strong>애플리케이션 부트스트랩</strong>: 자동 설정 및 빈 등록</li><li><strong>보안 관리</strong>: JWT 토큰 검증, 권한 체크</li><li><strong>트랜잭션 관리</strong>: 데이터베이스 트랜잭션 자동 처리</li><li><strong>예외 처리</strong>: 글로벌 예외 핸들링</li><li><strong>모니터링</strong>: 액추에이터를 통한 헬스 체크</li></ul><h5 id=library-활용-사례-react--다양한-라이브러리>Library 활용 사례 (React + 다양한 라이브러리)<a hidden class=anchor aria-hidden=true href=#library-활용-사례-react--다양한-라이브러리>#</a></h5><p><strong>시스템 구성:</strong></p><pre class=mermaid>graph TB
    A[React Application] --&gt; B[React Router]
    A --&gt; C[Redux Toolkit]
    A --&gt; D[Axios]
    A --&gt; E[Material-UI]
    A --&gt; F[Chart.js]
    
    B --&gt; G[Page Navigation]
    C --&gt; H[State Management]
    D --&gt; I[HTTP Client]
    E --&gt; J[UI Components]
    F --&gt; K[Data Visualization]
    
    I --&gt; L[Backend APIs]
    H --&gt; M[Application State]
</pre><p><strong>Workflow (개발자 제어):</strong></p><pre class=mermaid>sequenceDiagram
    participant Dev as Developer Code
    participant R as React
    participant RT as React Router
    participant A as Axios
    participant Redux as Redux
    
    Dev-&gt;&gt;R: Render Component
    Dev-&gt;&gt;RT: Navigate to Page
    Dev-&gt;&gt;A: API Call
    A-&gt;&gt;Dev: HTTP Response
    Dev-&gt;&gt;Redux: Dispatch Action
    Redux-&gt;&gt;Dev: State Update
    Dev-&gt;&gt;R: Re-render UI
</pre><p><strong>Library 의 역할:</strong></p><ul><li><strong>React</strong>: UI 컴포넌트 렌더링</li><li><strong>React Router</strong>: 클라이언트 사이드 라우팅</li><li><strong>Axios</strong>: HTTP 통신</li><li><strong>Redux</strong>: 상태 관리</li><li><strong>Material-UI</strong>: 디자인 시스템</li></ul><h4 id=사례-2-웹-애플리케이션-개발>사례 2: 웹 애플리케이션 개발<a hidden class=anchor aria-hidden=true href=#사례-2-웹-애플리케이션-개발>#</a></h4><ul><li><strong>프레임워크 사용</strong>: Django 를 사용하여 웹 애플리케이션의 전체 구조를 정의하고, URL 라우팅, 데이터베이스 모델링, 템플릿 렌더링 등을 프레임워크의 구조에 맞춰 개발한다.</li><li><strong>라이브러리 사용</strong>: Axios 를 사용하여 프론트엔드에서 비동기 HTTP 요청을 처리하며, Moment.js 를 사용하여 날짜 및 시간 관련 기능을 구현한다.</li></ul><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>graph TD
A[사용자] --&gt; B[프론트엔드]
B --&gt; C[&#34;백엔드(Django)&#34;]
C --&gt; D[데이터베이스]
B --&gt; E[Axios]
E --&gt; C
</pre><p>이 다이어그램은 사용자가 프론트엔드를 통해 백엔드에 요청을 보내고, 백엔드는 데이터베이스와 상호작용하며, 프론트엔드는 Axios 라이브러리를 사용하여 비동기 요청을 처리하는 구조를 나타낸다.</p><h4 id=사례-3-전자상거래-웹사이트-개발>사례 3: 전자상거래 웹사이트 개발<a hidden class=anchor aria-hidden=true href=#사례-3-전자상거래-웹사이트-개발>#</a></h4><ul><li><p><strong>프레임워크 활용:</strong><br>Spring Boot 를 기반으로 전체 애플리케이션 구조 (REST API, 인증, 트랜잭션 등) 를 설계.<br>프레임워크가 요청을 받아 컨트롤러를 호출하고, 서비스 및 DAO 계층을 순차적으로 실행.</p></li><li><p><strong>라이브러리 활용:</strong><br>데이터 가공이나 특정 기능 (예: PDF 생성, 암호화 등) 에 Apache Commons, iText 등 라이브러리를 직접 호출하여 사용.</p></li></ul><p><strong>시스템 구성 다이어그램</strong></p><pre class=mermaid>flowchart TD
    A[클라이언트] --&gt; B[Spring Boot 프레임워크]
    B --&gt; C[Controller]
    C --&gt; D[Service]
    D --&gt; E[Repository]
    D --&gt; F[&#34;라이브러리 호출(예: iText)&#34;]
</pre><p><strong>Workflow</strong></p><ol><li>클라이언트가 주문 요청 → Spring Boot 가 컨트롤러 호출</li><li>서비스 계층에서 주문 로직 처리</li><li>PDF 영수증 생성 시 iText 라이브러리 직접 호출</li></ol><p><strong>역할</strong></p><ul><li>프레임워크: 전체 구조 및 흐름 제어, 요청 분배</li><li>라이브러리: 특정 기능 (예: PDF 생성) 제공</li></ul><p><strong>차이점</strong></p><ul><li>프레임워크는 전체 애플리케이션의 흐름과 구조를 제어</li><li>라이브러리는 개발자가 필요할 때 직접 호출하여 사용</li></ul><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th><th></th></tr></thead><tbody><tr><td><strong>프레임워크</strong></td><td>자동화 및 AI 통합</td><td>AI 기반 코드 자동 생성, 테스트/빌드 자동화 도구와의 통합 가속화</td><td></td></tr><tr><td></td><td>마이크로서비스 아키텍처</td><td>마이크로서비스 확산으로 경량화된 프레임워크 (Spring Boot Lite 등) 수요 증가</td><td></td></tr><tr><td></td><td>클라우드 네이티브</td><td>Docker, Kubernetes 에 최적화된 프레임워크 발전 (예: Quarkus, Micronaut)</td><td></td></tr><tr><td></td><td>서버리스 최적화</td><td>AWS Lambda, Google Cloud Functions 전용 경량 프레임워크 활용 확대</td><td></td></tr><tr><td></td><td>개발자 경험 (DX) 강화</td><td>핫 리로드, 자동 완성, 에러 추적 등 도구가 내장된 통합형 개발환경 확대</td><td></td></tr><tr><td><strong>라이브러리</strong></td><td>경량화 및 모듈화</td><td>목적별로 분리된 모듈, 의존성 최소화 추세 강화 (예: lodash → lodash-es 등)</td><td></td></tr><tr><td></td><td>패키지 관리 강화</td><td>버전 충돌 방지, 중복 제거를 위한 패키지 관리자 (npm, pip, poetry 등) 의 발전</td><td></td></tr><tr><td></td><td>정적 타입 및 타입 안전성 강화</td><td>TypeScript, Rust 등 정적 타입 기반 라이브러리 선호 증가</td><td></td></tr><tr><td><strong>공통/전체</strong></td><td>오픈소스 생태계 확장</td><td>다양한 오픈소스 프레임워크/라이브러리 동시 활용이 일반화, 커뮤니티 주도 기술 발전</td><td></td></tr><tr><td></td><td>모듈 연합 (Micro Frontends)</td><td>런타임에 독립된 프론트엔드 모듈을 통합해 구성하는 아키텍처 활성화</td><td></td></tr><tr><td></td><td>웹어셈블리 (WASM)</td><td>브라우저에서 고성능 실행 가능 → Python, Rust 등 비 JS 언어 실행 기반 확대</td><td></td></tr><tr><td></td><td>AI/ML 통합</td><td>머신러닝 워크플로우를 쉽게 구성하는 전용 프레임워크 및 라이브러리 지속 확산</td><td></td></tr></tbody></table><h3 id=주목할-내용>주목할 내용<a hidden class=anchor aria-hidden=true href=#주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>제어의 역전 (IoC, Inversion of Control)</td><td>프레임워크가 흐름을 제어하고 개발자는 콜백만 제공하는 구조</td></tr><tr><td></td><td>템플릿 메서드 패턴</td><td>프레임워크의 처리 흐름을 정의하는 대표적 디자인 패턴</td></tr><tr><td></td><td>함수형 프로그래밍</td><td>라이브러리 설계에서 유연성과 재사용성을 높이는 패러다임</td></tr><tr><td><strong>개발 트렌드</strong></td><td>저코드/노코드 도구</td><td>비개발자도 사용할 수 있는 시각적 인터페이스 기반의 프레임워크/도구 등장</td></tr><tr><td></td><td>멀티플랫폼 개발</td><td>하나의 코드로 웹, 모바일, 데스크톱 등 여러 플랫폼을 동시에 지원 (예: Flutter, React Native)</td></tr><tr><td></td><td>실시간 처리 프레임워크</td><td>WebSocket 기반의 실시간 통신 지원 (예: Socket.io, SignalR)</td></tr><tr><td></td><td>JAMstack 아키텍처</td><td>정적 사이트 생성 + 서버사이드 렌더링을 결합한 차세대 웹 구조 (Next.js, Nuxt.js)</td></tr><tr><td></td><td>풀스택 프레임워크</td><td>프론트와 백엔드를 통합한 일체형 개발 환경 제공 (T3 Stack, SvelteKit)</td></tr><tr><td></td><td>엣지 컴퓨팅 프레임워크</td><td>사용자와 가까운 위치에서 실행되는 경량 런타임 플랫폼 (Deno, Cloudflare Workers)</td></tr><tr><td></td><td>GraphQL 생태계</td><td>효율적인 데이터 요청 및 응답을 위한 API 계층 기술 (Apollo, Relay 등)</td></tr><tr><td></td><td>마이크로서비스 도구</td><td>서비스 분산을 위한 프레임워크 및 서비스 메쉬 기술 (Spring Cloud, Istio)</td></tr><tr><td><strong>보안 및 유지보수</strong></td><td>시큐어 바이 디자인 (OWASP 기반)</td><td>보안을 아키텍처 수준에서 내장한 프레임워크 및 개발 지침</td></tr><tr><td></td><td>패키지 매니저</td><td>라이브러리 및 프레임워크 의존성 충돌 방지 도구 (npm, pip, pnpm 등)</td></tr></tbody></table><hr><h3 id=추가-학습-필요-내용>추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-필요-내용>#</a></h3><table><thead><tr><th>주제</th><th>설명</th><th>연관 분야</th></tr></thead><tbody><tr><td><strong>제어의 역전 (IoC)</strong></td><td>프로그램 제어 흐름을 프레임워크 등 외부로 위임하는 설계 원칙</td><td>디자인 패턴, 아키텍처</td></tr><tr><td><strong>의존성 주입 (DI)</strong></td><td>객체 간 결합도를 낮추고 유연성을 높이기 위한 객체 생성/주입 구조</td><td>소프트웨어 아키텍처</td></tr><tr><td><strong>프레임워크 설계</strong></td><td>프레임워크의 내부 구조와 확장 포인트 설계 방법론 학습</td><td>아키텍처, AOP, IoC</td></tr><tr><td><strong>라이브러리 관리</strong></td><td>패키지 관리 도구 활용, 의존성 버전 충돌 방지 기법</td><td>DevOps, 유지보수</td></tr><tr><td><strong>디자인 패턴</strong></td><td>프레임워크/라이브러리 구조 이해에 도움되는 구조/행동/생성 패턴 학습</td><td>객체 지향 설계</td></tr><tr><td><strong>템플릿 메서드 패턴</strong></td><td>알고리즘의 골격 정의 후 세부 구현은 하위 클래스에 위임하는 설계 패턴</td><td>GoF 디자인 패턴</td></tr><tr><td><strong>빌더 패턴</strong></td><td>복잡한 객체 생성을 단계별로 유연하게 처리하는 생성 패턴</td><td>객체 지향 설계</td></tr><tr><td><strong>관점 지향 프로그래밍 (AOP)</strong></td><td>로깅, 보안 등 공통 기능을 비즈니스 로직과 분리하여 모듈화하는 패러다임</td><td>프레임워크 설계, 유지보수</td></tr><tr><td><strong>모듈화</strong></td><td>코드의 재사용성과 유지보수성을 높이기 위한 논리적 분할 및 의존성 분리 전략</td><td>라이브러리 설계, 아키텍처</td></tr></tbody></table><h3 id=하위-주제별-추가-학습-내용>하위 주제별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제별-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>아키텍처 패턴</strong></td><td>MVC, MVP, MVVM</td><td>사용자 인터페이스 구조를 나누어 역할을 분리하는 대표 UI 아키텍처 패턴들</td></tr><tr><td></td><td>레이어드 아키텍처</td><td>표현, 도메인, 인프라 계층으로 구분된 전통적인 계층형 설계 방식</td></tr><tr><td></td><td>헥사고날 아키텍처 (Hexagonal)</td><td>포트와 어댑터를 이용한 내부 - 외부 분리 구조로 유연한 아키텍처 구성 가능</td></tr><tr><td></td><td>마이크로서비스 아키텍처</td><td>서비스 단위로 나뉜 독립 배포 가능한 아키텍처 스타일로 프레임워크/라이브러리 선택에 영향</td></tr><tr><td><strong>설계 원칙</strong></td><td>SOLID 원칙</td><td>객체지향 설계의 다섯 가지 원칙 (단일 책임, 개방 - 폐쇄 등)</td></tr><tr><td></td><td>DRY, KISS, YAGNI</td><td>중복 제거, 단순성 유지, 과도한 기능 방지 등 실용적 설계 원칙</td></tr><tr><td></td><td>IoC, DI, 헐리우드 원칙</td><td>제어의 역전, 의존성 주입, 콜백 구조에 대한 설계 원리 이해</td></tr><tr><td><strong>프로그래밍 패러다임</strong></td><td>함수형 프로그래밍</td><td>순수 함수, 불변성, 고차 함수 등 라이브러리 설계 및 조합에 유용한 패러다임</td></tr><tr><td><strong>성능 최적화</strong></td><td>지연 로딩</td><td>실행 시점에 필요한 리소스를 로드하여 초기화 지연 및 자원 최적화</td></tr><tr><td></td><td>캐싱 전략</td><td>메모리 캐시, 분산 캐시 (Redis 등) 적용을 통한 응답속도 개선</td></tr><tr><td><strong>테스트 전략</strong></td><td>단위 테스트</td><td>Mock, Stub 기반으로 독립적 단위 기능 검증 수행</td></tr><tr><td></td><td>통합 테스트</td><td>여러 컴포넌트 간의 상호작용과 의존성 검증 테스트</td></tr><tr><td><strong>실무 적용</strong></td><td>프레임워크 커스터마이징</td><td>오픈소스 프레임워크 확장, 설정 변경, 훅 (Hook) 활용 방식</td></tr><tr><td><strong>패키지 관리</strong></td><td>npm, pip, Maven 등</td><td>언어별 패키지 관리 도구로 의존성 설치, 버전 관리, 빌드 자동화 수행</td></tr></tbody></table><h3 id=관련-분야별-추가-학습>관련 분야별 추가 학습<a hidden class=anchor aria-hidden=true href=#관련-분야별-추가-학습>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>마이크로서비스, 모듈화</td><td>프레임워크/라이브러리와 연계된 유연한 아키텍처 설계</td></tr><tr><td><strong>소프트웨어 개발</strong></td><td>테스트 주도 개발 (TDD)</td><td>테스트를 중심으로 개발 흐름을 구성하여 통합 안정성 확보</td></tr><tr><td><strong>소프트웨어 유지보수</strong></td><td>지속적 통합 (CI)</td><td>라이브러리/프레임워크 업데이트 및 테스트 자동화 프로세스</td></tr><tr><td><strong>DevOps</strong></td><td>CI/CD 파이프라인</td><td>지속적 통합 및 지속적 배포 자동화를 위한 워크플로우 구축</td></tr><tr><td></td><td>컨테이너화</td><td>Docker, Kubernetes 기반의 환경 격리 및 이식성 확보</td></tr><tr><td><strong>클라우드 컴퓨팅</strong></td><td>서버리스 컴퓨팅</td><td>FaaS (Function as a Service), BaaS 등 서버 관리 최소화 아키텍처</td></tr><tr><td></td><td>마이크로서비스</td><td>클라우드 친화적인 분산 아키텍처 설계 및 서비스 독립 운영</td></tr><tr><td><strong>데이터베이스</strong></td><td>ORM/ODM</td><td>객체와 관계형/비관계형 DB 간의 매핑 기술 (예: SQLAlchemy, Mongoose)</td></tr><tr><td></td><td>NoSQL 패턴</td><td>문서, 키 - 값, 컬럼 기반 DB 모델링 기법 및 설계 전략</td></tr><tr><td><strong>보안</strong></td><td>의존성 보안</td><td>프레임워크/라이브러리의 취약점 점검 및 안전한 버전</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=소프트웨어-설계-원칙-및-패턴>소프트웨어 설계 원칙 및 패턴<a hidden class=anchor aria-hidden=true href=#소프트웨어-설계-원칙-및-패턴>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>제어의 역전 (Inversion of Control, IoC)</strong></td><td>애플리케이션의 제어 흐름을 개발자가 아닌 외부 컴포넌트 (예: 프레임워크) 가 관리하는 설계 원칙</td></tr><tr><td><strong>의존성 주입 (Dependency Injection, DI)</strong></td><td>객체가 의존하는 컴포넌트를 내부에서 생성하지 않고 외부에서 주입받는 방식으로, IoC 를 구현하는 방법 중 하나</td></tr><tr><td><strong>할리우드 원칙 (Hollywood Principle)</strong></td><td>&ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo;–상위 컴포넌트가 하위 컴포넌트를 제어함으로써 제어의 역전을 구현</td></tr><tr><td><strong>템플릿 메서드 패턴 (Template Method Pattern)</strong></td><td>알고리즘의 구조를 상위 클래스에서 정의하고, 일부 구현을 하위 클래스에 위임하는 디자인 패턴</td></tr></tbody></table><h3 id=소프트웨어-아키텍처-및-구조>소프트웨어 아키텍처 및 구조<a hidden class=anchor aria-hidden=true href=#소프트웨어-아키텍처-및-구조>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>MVC (Model-View-Controller)</strong></td><td>애플리케이션을 모델, 뷰, 컨트롤러로 분리하여 관심사의 분리를 달성하는 아키텍처 패턴</td></tr><tr><td><strong>ORM (Object-Relational Mapping)</strong></td><td>객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스 간 매핑을 지원하는 기술</td></tr></tbody></table><h3 id=개발-도구-및-플랫폼>개발 도구 및 플랫폼<a hidden class=anchor aria-hidden=true href=#개발-도구-및-플랫폼>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>프레임워크 (Framework)</strong></td><td>애플리케이션 개발을 위한 구조와 제어 흐름을 제공하며, 개발자는 필요한 부분을 구현만 하면 되는 구조</td></tr><tr><td><strong>라이브러리 (Library)</strong></td><td>개발자가 호출하여 사용하는 독립적인 기능 단위의 코드 집합</td></tr><tr><td><strong>패키지 매니저 (Package Manager)</strong></td><td>외부 라이브러리 및 프레임워크의 설치, 업데이트, 의존성 관리를 자동화해주는 도구</td></tr><tr><td><strong>API (Application Programming Interface)</strong></td><td>소프트웨어 간의 상호작용을 위한 명세와 인터페이스</td></tr><tr><td><strong>SDK (Software Development Kit)</strong></td><td>특정 플랫폼용 애플리케이션을 개발하기 위해 제공되는 도구, 라이브러리, 문서 등의 모음</td></tr></tbody></table><h3 id=프로그래밍-패러다임>프로그래밍 패러다임<a hidden class=anchor aria-hidden=true href=#프로그래밍-패러다임>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>함수형 프로그래밍 (Functional Programming)</strong></td><td>상태와 부작용을 피하고 순수 함수 기반으로 동작하는 프로그래밍 패러다임</td></tr></tbody></table><h3 id=성능-및-최적화>성능 및 최적화<a hidden class=anchor aria-hidden=true href=#성능-및-최적화>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>지연 로딩 (Lazy Loading)</strong></td><td>애플리케이션에서 리소스를 실제로 필요한 시점까지 로딩하지 않고 대기시키는 기법</td></tr><tr><td><strong>트리 쉐이킹 (Tree Shaking)</strong></td><td>사용되지 않는 코드를 최종 번들에서 제거하여 최적화하는 기술</td></tr><tr><td><strong>핫 리로드 (Hot Reload)</strong></td><td>코드 변경 시 전체 애플리케이션을 재시작하지 않고 실시간으로 반영하는 기능</td></tr><tr><td><strong>프로파일링 (Profiling)</strong></td><td>애플리케이션의 성능을 측정하고 병목 지점을 분석하는 과정</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=framework-vs-library-관련>Framework Vs Library 관련<a hidden class=anchor aria-hidden=true href=#framework-vs-library-관련>#</a></h3><ul><li><a href=https://www.geeksforgeeks.org/software-framework-vs-library/>Software Framework vs Library | GeeksforGeeks</a></li><li><a href=https://www.freecodecamp.org/news/the-difference-between-a-framework-and-a-library-bd133054023f/>The Difference Between a Framework and a Library | freeCodeCamp</a></li><li><a href=https://www.sencha.com/blog/difference-between-framework-vs-library-snc/>Framework Vs. Library: Know the Main Differences in 2025 | Sencha</a></li><li><a href=https://www.interviewbit.com/blog/framework-vs-library/>Framework vs Library: Full Comparison | InterviewBit</a></li><li><a href=https://www.baeldung.com/cs/framework-vs-library>The Difference Between a Framework and a Library | Baeldung</a></li><li><a href=https://bluebirdinternational.com/framework-vs-library/>Framework vs. Library: Differences, Concepts, and Specific Cases | Bluebird International</a></li><li><a href=https://dev.to/maggiecodes_/the-difference-between-a-library-and-a-framework-5dec>The Difference Between a Library and a Framework | DEV Community</a></li><li><a href=https://ca.indeed.com/career-advice/career-development/framework-vs-library>Framework vs. Library (Similarities and Differences) | Indeed</a></li><li><a href=https://www.linkedin.com/pulse/how-libraries-frameworks-revolutionized-software-development-chan-hgqhc>How Libraries and Frameworks Revolutionized Software Development | LinkedIn</a></li><li><a href=https://anarsolutions.com/libraries-vs-frameworks/>What is the difference between Libraries vs framework? | Anar Solutions</a></li><li><a href=https://stackoverflow.com/questions/148747/what-is-the-difference-between-a-framework-and-a-library>What is the difference between a framework and a library? [StackOverflow]</a></li><li><a href=https://blog.gaerae.com/2016/11/what-is-library-and-framework-and-architecture-and-platform.html>프레임워크와 라이브러리의 차이점 | 개발자스럽다</a></li><li><a href=https://www.redhat.com/ko/topics/application-development-and-delivery/java-peuleimwokeulan>자바 프레임워크(Java Framework)란? | Red Hat</a></li></ul><h3 id=inversion-of-control--hollywood-principle-관련>Inversion of Control & Hollywood Principle 관련<a hidden class=anchor aria-hidden=true href=#inversion-of-control--hollywood-principle-관련>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Inversion_of_control>Inversion of Control - Wikipedia</a></li><li><a href=https://martinfowler.com/bliki/InversionOfControl.html>bliki: Inversion Of Control | Martin Fowler</a></li><li><a href=https://www.sitepoint.com/three-design-patterns-that-use-inversion-of-control/>Three Design Patterns That Use Inversion of Control | SitePoint</a></li><li><a href=https://deviq.com/principles/hollywood-principle/>Hollywood Principle | DevIQ</a></li><li><a href=https://stackoverflow.com/questions/64333953/what-is-the-hollywood-principle>What is the Hollywood Principle? | StackOverflow</a></li><li><a href=https://courses.learntosolveit.com/gatech/cs6301/p4l5-design-principles>P4L5 Design Principles | Georgia Tech Course</a></li></ul><h3 id=일반-개념-정리-관련>일반 개념 정리 관련<a hidden class=anchor aria-hidden=true href=#일반-개념-정리-관련>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Software_framework>Software framework - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Library_%28computing%29>Library (computing) - Wikipedia</a></li><li><a href=https://imsfromseoul.tistory.com/269>재정리 - Spring - 기록용 개발 블로그 - 티스토리</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/principles/>Principles</a></li><li><a href=https://buenhyden.github.io/tags/design-principles/>Design-Principles</a></li><li><a href=https://buenhyden.github.io/tags/inversion-of-control/>Inversion-of-Control</a></li><li><a href=https://buenhyden.github.io/tags/library/>Library</a></li><li><a href=https://buenhyden.github.io/tags/framework/>Framework</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/frontend-development/styling-and-design-systems/stylesheet/><span class=title>« Prev</span><br><span>Stylesheet</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-science-and-engineering/data-pipeline-pattern/><span class=title>Next »</span><br><span>Data Pipeline Pattern</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>