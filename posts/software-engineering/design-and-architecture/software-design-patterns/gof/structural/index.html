<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Structural | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,Design-and-Architecture,Software-Design-Patterns,GoF,Structural,Object-Composition"><meta name=description content="GoF의 Structural Patterns 는 **객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법**으로, 유연성과 유지보수성을 강화한다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Structural"><meta property="og:description" content="GoF의 Structural Patterns 는 **객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법**으로, 유연성과 유지보수성을 강화한다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Structural"><meta name=twitter:description content="GoF의 Structural Patterns 는 **객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법**으로, 유연성과 유지보수성을 강화한다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":5,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/"},{"@type":"ListItem","position":6,"name":"Structural","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/>GoF</a></div><h1>Structural</h1><div class=post-description>GoF의 Structural Patterns 는 <strong>객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법</strong>으로, 유연성과 유지보수성을 강화한다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결한다.</div></header><div class=post-content><h2 id=structural>Structural<a hidden class=anchor aria-hidden=true href=#structural>#</a></h2><p>Structural Design Patterns 는 소프트웨어 설계에서 <strong>객체 및 클래스 구조의 조합과 관계 맺음</strong>을 중심으로, 효율적이고 유연한 구조 구축을 돕는 패턴 집합이다.<br>Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy 등 7 가지가 대표적이며, 각 패턴은 시스템의 복잡성을 줄이고, 코드의 유연성과 확장성을 높인다.<br>Adapter 는 이질적 인터페이스를 연결하고, Bridge 는 추상화와 구현을 분리하며, Composite 는 계층적 구조를 관리한다. Decorator 는 동적으로 기능을 확장하고, Facade 는 복잡한 서브시스템을 단순화하며, Flyweight 는 메모리 공유를 통한 최적화를, Proxy 는 접근 제어 및 지연 초기화를 제공한다.<br>구조 패턴을 활용하면 다양한 객체와 클래스가 상호작용하는 복잡한 시스템에서도 일관성 있고 유지보수하기 쉬운 아키텍처를 설계할 수 있다.</p><h3 id=배경--목적>배경 & 목적<a hidden class=anchor aria-hidden=true href=#배경--목적>#</a></h3><ul><li><strong>배경</strong>: 복잡한 서브시스템, 비호환 인터페이스 증가, 중복 코드 등의 구조적 복잡성 해결 필요성 대두.</li><li><strong>목적</strong>:<ul><li>클래스 간 상속보다 <strong>조합 (composition)</strong> 을 통한 느슨한 결합 실현</li><li>인터페이스 호환성 제공 (<code>Adapter</code>)</li><li>기능 확장/변경의 유연성 (<code>Decorator</code>, <code>Bridge</code>)</li><li>메모리/성능 최적화 (<code>Flyweight</code>)</li><li>시스템 복잡성 폐쇄 공간 (<code>Facade</code>), 접근 제어 (<code>Proxy</code>)</li></ul></li></ul><h3 id=필요성>필요성<a hidden class=anchor aria-hidden=true href=#필요성>#</a></h3><ul><li>복잡한 시스템에서 객체 간의 관계를 명확하게 정의하고 관리하기 위해</li><li>코드의 중복을 줄이고 재사용성을 높이기 위해</li><li>시스템의 유지보수성과 확장성을 향상시키기 위해</li></ul><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>구조 패턴은 객체와 클래스의 조합을 통해 더 큰 구조를 형성하는 방법을 제공하여, 시스템의 유연성과 효율성을 높이는 디자인 패턴이다. 이러한 패턴은 객체 간의 관계를 단순화하고, 코드의 재사용성과 유지보수성을 향상시키는 데 중점을 둔다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><ul><li><strong>객체 합성 (Object Composition)</strong>: 여러 객체를 결합하여 새로운 기능을 만드는 방식</li><li><strong>구조적 추상화 (Structural Abstraction)</strong>: 복잡한 시스템을 단순한 인터페이스로 감싸는 기법</li><li><strong>어댑터 (Adapter)</strong>: 호환되지 않는 인터페이스를 연결하는 중간 계층</li><li><strong>래퍼 (Wrapper)</strong>: 기존 객체를 감싸서 새로운 인터페이스를 제공하는 패턴</li></ul><h4 id=심화-개념>심화 개념<a hidden class=anchor aria-hidden=true href=#심화-개념>#</a></h4><ul><li><strong>브리지 패턴 (Bridge Pattern)</strong>: 추상화와 구현을 분리하여 독립적 변화 허용</li><li><strong>컴포지트 패턴 (Composite Pattern)</strong>: 부분 - 전체 계층 구조를 트리로 표현</li><li><strong>플라이웨이트 패턴 (Flyweight Pattern)</strong>: 메모리 효율성을 위한 객체 공유 메커니즘</li><li><strong>데코레이터 체이닝 (Decorator Chaining)</strong>: 여러 데코레이터를 연쇄적으로 적용하는 기법</li></ul><h4 id=패턴-적용의-결과와-트레이드오프>패턴 적용의 결과와 트레이드오프<a hidden class=anchor aria-hidden=true href=#패턴-적용의-결과와-트레이드오프>#</a></h4><p>각 구조 패턴 적용 시의 주요 트레이드오프를 분석하겠습니다:</p><table><thead><tr><th>패턴</th><th>장점</th><th>단점</th><th>트레이드오프</th></tr></thead><tbody><tr><td>Adapter</td><td>기존 코드 재사용, 호환성 확보</td><td>추가적인 인다이렉션, 복잡도 증가</td><td>재사용성 vs 성능</td></tr><tr><td>Bridge</td><td>구현과 추상화 분리, 독립적 확장</td><td>초기 설계 복잡도 높음</td><td>유연성 vs 단순성</td></tr><tr><td>Composite</td><td>일관된 트리 구조 처리</td><td>설계가 너무 일반적될 수 있음</td><td>일관성 vs 타입 안전성</td></tr><tr><td>Decorator</td><td>동적 기능 확장, 조합 가능</td><td>많은 작은 객체 생성</td><td>유연성 vs 복잡도</td></tr><tr><td>Facade</td><td>단순한 인터페이스 제공</td><td>서브시스템 기능 제한 가능</td><td>단순성 vs 제어력</td></tr><tr><td>Flyweight</td><td>메모리 사용량 최적화</td><td>공유 상태 관리 복잡</td><td>성능 vs 복잡성</td></tr><tr><td>Proxy</td><td>접근 제어, 지연 로딩</td><td>추가적인 인다이렉션</td><td>제어력 vs 성능</td></tr></tbody></table><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><table><thead><tr><th>기능</th><th>설명</th></tr></thead><tbody><tr><td>인터페이스 적응</td><td>호환되지 않는 인터페이스 간의 브리지 역할</td></tr><tr><td>구조 단순화</td><td>복잡한 서브시스템을 단순한 인터페이스로 감싸기</td></tr><tr><td>동적 기능 확장</td><td>런타임에 객체의 행동 추가/변경</td></tr><tr><td>계층 구조 관리</td><td>부분 - 전체 관계를 일관되게 처리</td></tr><tr><td>리소스 공유</td><td>유사한 객체들 간의 상태 공유로 메모리 절약</td></tr></tbody></table><p><strong>1. 구조적 조합 (Structural Composition)</strong></p><pre class=mermaid>classDiagram
    class Component {
        +operation()
    }
    class Leaf {
        +operation()
    }
    class Composite {
        -children: Component[]
        +add(Component)
        +remove(Component)
        +operation()
    }
    
    Component &lt;|-- Leaf
    Component &lt;|-- Composite
    Composite o-- Component
</pre><p><strong>2. 인터페이스 적응 (Interface Adaptation)</strong></p><pre class=mermaid>classDiagram
    class Target {
        +request()
    }
    class Adapter {
        -adaptee: Adaptee
        +request()
    }
    class Adaptee {
        +specificRequest()
    }
    
    Target &lt;|-- Adapter
    Adapter --&gt; Adaptee
</pre><p><strong>기능별 역할:</strong></p><ul><li><strong>구조 변환</strong>: 객체 구조를 클라이언트 요구에 맞게 변환</li><li><strong>인터페이스 통합</strong>: 서로 다른 인터페이스를 통합된 형태로 제공</li><li><strong>접근 제어</strong>: 객체 접근을 제어하고 추가 기능 제공</li><li><strong>성능 향상</strong>: 객체 생성과 메모리 사용을 최적화</li></ul><h4 id=패턴별-역할>패턴별 역할<a hidden class=anchor aria-hidden=true href=#패턴별-역할>#</a></h4><table><thead><tr><th>패턴</th><th>역할 요약</th></tr></thead><tbody><tr><td><strong>Adapter</strong></td><td>인터페이스를 호환시켜 기존 클래스 재사용</td></tr><tr><td><strong>Bridge</strong></td><td>추상화와 구현 독립 유지, 런타임 구현 교체</td></tr><tr><td><strong>Composite</strong></td><td>단일 객체와 그룹 객체를 동일하게 다룸</td></tr><tr><td><strong>Decorator</strong></td><td>객체에 동적 기능 추가, 서브클래스 폭발 방지</td></tr><tr><td><strong>Facade</strong></td><td>복잡한 서브시스템 기능을 단일 인터페이스로 단순화</td></tr><tr><td><strong>Flyweight</strong></td><td>공유 가능한 불변 상태 객체로 메모리 최적화</td></tr><tr><td><strong>Proxy</strong></td><td>대상 객체에 접근 제어, 지연 초기화, 로깅 기능 추가</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><p><strong>합성 중심 설계 (Composition-oriented Design)</strong></p><ul><li>상속보다 합성을 선호하는 설계 철학</li><li>런타임에 객체 관계 변경 가능</li><li>다중 상속의 복잡성 회피</li></ul></li><li><p><strong>투명성 (Transparency)</strong></p><ul><li>클라이언트가 구현 세부사항을 알 필요 없음</li><li>단일 객체와 복합 객체의 일관된 인터페이스</li><li>구조적 복잡성 은닉</li></ul></li><li><p><strong>적응성 (Adaptability)</strong></p><ul><li>기존 클래스를 수정하지 않고 새로운 기능 추가</li><li>다양한 환경과 요구사항에 유연하게 대응</li><li>점진적 시스템 발전 지원</li></ul></li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ol><li><p><strong>개방 - 폐쇄 원칙 (Open-Closed Principle)</strong></p><ul><li>확장에는 열려있고 수정에는 닫혀있는 설계</li><li>새로운 기능 추가 시 기존 코드 수정 최소화</li></ul></li><li><p><strong>인터페이스 분리 원칙 (Interface Segregation Principle)</strong></p><ul><li>클라이언트가 사용하지 않는 메서드에 의존하지 않도록 설계</li><li>작고 응집된 인터페이스 선호</li></ul></li><li><p><strong>의존성 역전 원칙 (Dependency Inversion Principle)</strong></p><ul><li>구체적인 클래스보다 추상화에 의존</li><li>고수준 모듈이 저수준 모듈에 의존하지 않도록 설계</li></ul></li></ol><h3 id=작동-원리-및-방식>작동 원리 및 방식<a hidden class=anchor aria-hidden=true href=#작동-원리-및-방식>#</a></h3><ul><li><strong>패턴별 특화된 구조 설계</strong><ul><li>Adapter: 인터페이스 호환</li><li>Bridge: 추상화와 구현 분리</li><li>Composite: 트리 구조로 객체 통합</li><li>Decorator: 동적 기능 확장</li><li>Facade: 복잡한 시스템 단순화</li><li>Flyweight: 메모리 효율성</li><li>Proxy: 객체 접근 제어</li></ul></li></ul><h4 id=작동-원리-다이어그램-text>작동 원리 다이어그램 (text)<a hidden class=anchor aria-hidden=true href=#작동-원리-다이어그램-text>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client ---&gt; [Structural Pattern] ---&gt; [Target Object]
</span></span><span class=line><span class=cl>           (Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy)
</span></span></code></pre></td></tr></table></div></div><h4 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h4><p>구조 패턴의 작동 원리를 다이어그램으로 설명하겠습니다:</p><pre class=mermaid>graph TD
    A[클라이언트 요청] --&gt; B{패턴 유형}
    B --&gt;|Adapter| C[인터페이스 변환]
    B --&gt;|Decorator| D[기능 추가]
    B --&gt;|Facade| E[복잡성 은닉]
    B --&gt;|Proxy| F[접근 제어]
    
    C --&gt; G[기존 객체]
    D --&gt; H[래핑된 객체]
    E --&gt; I[서브시스템]
    F --&gt; J[실제 객체]
    
    G --&gt; K[변환된 결과]
    H --&gt; L[확장된 기능]
    I --&gt; M[단순화된 인터페이스]
    J --&gt; N[제어된 접근]
</pre><p><strong>작동 방식:</strong></p><ol><li><strong>요청 수신</strong>: 클라이언트로부터 작업 요청 수신</li><li><strong>패턴 적용</strong>: 해당하는 구조 패턴 메커니즘 동작</li><li><strong>구조 변환</strong>: 객체 구조를 요구사항에 맞게 변환</li><li><strong>결과 반환</strong>: 변환된 결과를 클라이언트에게 반환</li></ol><h3 id=structural-vs-creationalbehavioral>Structural vs. Creational/Behavioral<a hidden class=anchor aria-hidden=true href=#structural-vs-creationalbehavioral>#</a></h3><table><thead><tr><th>분류</th><th>주요 패턴</th><th>목적 및 특징</th></tr></thead><tbody><tr><td><strong>Structural</strong></td><td>Adapter, Composite, Decorator, Facade, Bridge, Proxy, Flyweight</td><td>객체 간 관계를 조직화, 구조적 유연성 및 인터페이스 표준화</td></tr><tr><td><strong>Creational</strong></td><td>Singleton, Factory Method, Abstract Factory, Builder, Prototype</td><td>객체 생성 제어 및 추상화, 생성 코드 중앙 집중화</td></tr><tr><td><strong>Behavioral</strong></td><td>Strategy, Observer, Command, Template Method, Iterator, Mediator 등</td><td>객체 간 메시지 전달 및 알고리즘을 조정</td></tr></tbody></table><p><strong>핵심 차이점 요약</strong>:</p><ul><li>Create: <strong>어떻게 객체를 만들 것인가</strong></li><li>Structural: <strong>만들어진 객체들끼리 어떻게 구성·관계 맺을 것인가</strong></li><li>Behavioral: <strong>구성된 객체들이 어떻게 상호작용하고 행동하게 할 것인가</strong></li></ul><h3 id=구조-패턴의-종류-및-비교>구조 패턴의 종류 및 비교<a hidden class=anchor aria-hidden=true href=#구조-패턴의-종류-및-비교>#</a></h3><table><thead><tr><th>패턴명</th><th>설명</th><th>사용 시점 및 목적</th></tr></thead><tbody><tr><td>어댑터 (Adapter)</td><td>호환되지 않는 인터페이스를 가진 클래스들을 함께 작동하도록 함</td><td>기존 클래스를 재사용하고 싶지만 인터페이스가 맞지 않을 때</td></tr><tr><td>브리지 (Bridge)</td><td>추상화와 구현을 분리하여 독립적으로 확장 가능하게 함</td><td>추상화와 구현을 독립적으로 변경하고 싶을 때</td></tr><tr><td>컴포지트 (Composite)</td><td>객체들을 트리 구조로 구성하여 부분 - 전체 계층을 표현함</td><td>부분 - 전체 구조를 동일하게 다루고 싶을 때</td></tr><tr><td>데코레이터 (Decorator)</td><td>객체에 새로운 기능을 동적으로 추가함</td><td>기존 객체에 기능을 추가하고 싶을 때</td></tr><tr><td>퍼사드 (Facade)</td><td>복잡한 서브시스템에 대한 단순한 인터페이스를 제공함</td><td>복잡한 시스템을 단순화하고 싶을 때</td></tr><tr><td>플라이웨이트 (Flyweight)</td><td>많은 수의 유사한 객체들을 공유하여 메모리 사용을 최소화함</td><td>많은 수의 유사한 객체를 효율적으로 관리하고 싶을 때</td></tr><tr><td>프록시 (Proxy)</td><td>다른 객체에 대한 접근을 제어하기 위한 대리 객체를 제공함</td><td>객체에 대한 접근을 제어하고 싶을 때</td></tr></tbody></table><h3 id=각-패턴별-구현-기법>각 패턴별 구현 기법<a hidden class=anchor aria-hidden=true href=#각-패턴별-구현-기법>#</a></h3><table><thead><tr><th>패턴</th><th>기법</th><th>예시</th></tr></thead><tbody><tr><td>Adapter</td><td>클래스 어댑터 (상속), 객체 어댑터 (위임)</td><td>Java 의 <code>InputStreamReader</code> 는 <code>Reader</code> 인터페이스로 <code>InputStream</code> 래핑</td></tr><tr><td>Composite</td><td>재귀 구조, Iterator 패턴 결합</td><td>UI 위젯 계층: Panel 내에 버튼, 텍스트, 다른 패널 포함</td></tr><tr><td>Decorator</td><td>래퍼 (Wrapper)+ 위임, 동적/정적 데코레이션</td><td>Python 데코레이터 <code>@log_execution</code></td></tr><tr><td>Bridge</td><td>Abstraction/Implementor 분리, 런타임 타입 바인딩</td><td>GUIToolkit Abstraction 이 WinImpl, MacImpl 을 교체 가능</td></tr><tr><td>Facade</td><td>단일 진입점 클래스 제공, 복잡도 은닉</td><td>DB + Cache + Logger 조작을 하나의 <code>SystemManager</code> 로 제공</td></tr><tr><td>Proxy</td><td>접근 제어, 지연 초기화, 원격 프록시</td><td>LazySingleton, 이미지 미리보기 지연 로딩</td></tr><tr><td>Flyweight</td><td>공유 팩토리 + 상태 분리</td><td>Text Editor 글자 객체 공유, 글자 형태만 저장</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>패턴명</th><th>정의/구성</th><th>목적/예시</th></tr></thead><tbody><tr><td>Adapter</td><td>기존 인터페이스를 원하는 인터페이스로 변환</td><td>레거시 시스템과 신규 시스템 연동, 예: USB- 시리얼 변환기</td></tr><tr><td>Bridge</td><td>추상화와 구현 분리, 독립적 확장</td><td>UI 테마와 컴포넌트 분리, 예: 다양한 DB 드라이버와 추상화 계층</td></tr><tr><td>Composite</td><td>트리 구조로 부분 - 전체 계층 표현</td><td>파일 시스템, 메뉴 구조, 예: 디렉터리 - 파일 구조</td></tr><tr><td>Decorator</td><td>동적으로 객체에 기능 추가</td><td>스트림에 암호화/압축 추가, 예: Java IO 스트림</td></tr><tr><td>Facade</td><td>복잡한 서브시스템을 단순화</td><td>라이브러리 통합 API, 예: Spring 의 JdbcTemplate</td></tr><tr><td>Flyweight</td><td>공유 객체로 메모리 절약</td><td>대량의 텍스트 렌더링, 예: 문자 객체 풀</td></tr><tr><td>Proxy</td><td>접근 제어, 로깅, 캐싱 등 대리 기능</td><td>DB 연결 프록시, 원격 객체 대리, 예: RPC 프록시</td></tr></tbody></table><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><table><thead><tr><th>카테고리</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>유연성 & 확장성</strong></td><td>구조 유연성</td><td>객체 합성을 통해 구조를 동적으로 변경 가능. 런타임 시 변경 유연성 제공</td></tr><tr><td></td><td>기능 확장 용이성</td><td>새로운 기능이나 객체를 기존 구조에 영향 없이 쉽게 추가 가능</td></tr><tr><td></td><td>구조 변경 유연성</td><td>서브시스템 구조를 변경하더라도 외부에 영향 없이 반영 가능</td></tr><tr><td><strong>재사용성 & 호환성</strong></td><td>코드 재사용성</td><td>객체 또는 클래스 재조합을 통해 다양한 조합 가능, 중복 구현 제거</td></tr><tr><td></td><td>시스템 호환성 확보</td><td>서로 다른 인터페이스를 통합하거나 적응시켜 레거시 시스템과의 호환성 유지 가능</td></tr><tr><td><strong>복잡도 & 유지보수</strong></td><td>복잡성 감소</td><td>복잡한 객체 구성을 추상화하여 클라이언트 코드의 의존성과 복잡도 최소화</td></tr><tr><td></td><td>유지보수 용이성</td><td>내부 구현을 클라이언트로부터 은닉하여 변경 시 영향 범위를 최소화</td></tr><tr><td><strong>일관성 & 통일성</strong></td><td>인터페이스 일관성</td><td>다양한 객체 구조를 동일한 인터페이스로 다루어 클라이언트 코드의 단순화 유도</td></tr><tr><td></td><td>트리 구조 통일 처리</td><td>Leaf 와 Composite 를 동일한 Component 로 취급 가능하여 트리 구조 일관성 유지</td></tr><tr><td><strong>성능 최적화</strong></td><td>메모리/속도 최적화</td><td>Flyweight 등의 패턴을 통해 객체 공유 및 지연 로딩으로 성능과 자원 사용 효율 개선</td></tr></tbody></table><h3 id=단점과-문제점-그리고-해결방안>단점과 문제점 그리고 해결방안<a hidden class=anchor aria-hidden=true href=#단점과-문제점-그리고-해결방안>#</a></h3><table><thead><tr><th>카테고리</th><th>항목</th><th>설명</th><th>주요 원인</th><th>해결 방안 및 기법</th></tr></thead><tbody><tr><td><strong>구조 복잡성</strong></td><td>복잡성 증가</td><td>래핑 계층, 위임 구조로 인해 클래스 수 증가 및 코드 가독성 저하</td><td>Decorator, Proxy 등 패턴의 과도한 중첩</td><td>명확한 책임 분리, 문서화, 리팩토링, 구조 시각화 도구 활용</td></tr><tr><td></td><td>유지보수 어려움</td><td>계층이 많고 추상화 수준이 높아져 코드 추적이 어려움</td><td>추상화 과잉, 과도한 위임 구조</td><td>로깅/트레이싱 도구 적용, 인터페이스 문서화, 계층 최소화</td></tr><tr><td><strong>성능 저하</strong></td><td>성능 오버헤드</td><td>호출 계층 추가, 객체 생성 비용 증가로 성능 저하 가능</td><td>Proxy, Decorator, Composite 등</td><td>불필요한 레이어 제거, 객체 캐싱, 지연 로딩, Flyweight 패턴 활용</td></tr><tr><td></td><td>메모리 낭비</td><td>객체 공유 없이 다수 생성되면 메모리 사용량 증가</td><td>Flyweight 패턴 미적용</td><td>상태 분리, WeakReference 사용, 객체 풀링 적용</td></tr><tr><td><strong>타입/인터페이스 문제</strong></td><td>인터페이스 불일치</td><td>기존 인터페이스와 새로운 시스템 요구 간의 불일치 발생</td><td>레거시 시스템 호환 미흡</td><td>Adapter 패턴 활용, 인터페이스 통합 설계</td></tr><tr><td></td><td>잘못된 메서드 호출</td><td>Leaf 노드에도 <code>add()</code> 호출 가능 → 런타임 오류</td><td>공통 인터페이스 오용</td><td>타입 안전성 검증, Composite 구조 설계 시 검증 로직 적용</td></tr><tr><td></td><td>기능 중복</td><td>유사한 기능이 여러 객체에 반복 정의되며 유지보수 어려움</td><td>재사용성 고려 부족</td><td>공통 기능 분리, Decorator 패턴으로 확장 처리</td></tr><tr><td><strong>학습 및 적용 부담</strong></td><td>러닝 커브</td><td>구조 패턴은 개념적 난이도와 코드 복잡성으로 인해 이해와 적용에 시간 소요</td><td>추상 개념, 계층적 구조</td><td>학습 자료 제공, 코드 예제 기반 교육, 팀 내 설계 리뷰 문화</td></tr><tr><td><strong>디버깅/검증 난이도</strong></td><td>디버깅 어려움</td><td>호출 흐름이 다층화되어 디버깅 및 테스트 어려움</td><td>위임·합성 구조에 대한 추적 어려움</td><td>로깅 삽입, 호출 추적 툴 적용, 통합 테스트 환경 구축</td></tr><tr><td></td><td>무한 재귀</td><td>Composite 패턴 구조가 순환 구조일 경우 무한 루프 가능</td><td>구조 검증 미흡</td><td>방문자 패턴 적용, 재귀 제한 로직 도입, 순환 검증 테스트</td></tr></tbody></table><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><table><thead><tr><th>카테고리</th><th>도전 과제</th><th>주요 원인 및 영향</th><th>해결 방안 및 대응 전략</th></tr></thead><tbody><tr><td><strong>구조 관리</strong></td><td>구조 복잡성 증가</td><td>과도한 패턴 적용으로 클래스 수 증가, 계층 깊어짐</td><td>패턴 최소화 원칙, 책임 중심 분리, 시각화 도구 도입 (<code>UML</code>, <code>Graph</code>)</td></tr><tr><td></td><td>인터페이스 일관성 유지</td><td>다양한 어댑터 적용 시 인터페이스 불일치</td><td>표준 인터페이스 정의, 인터페이스 계층 설계 가이드 수립</td></tr><tr><td></td><td>순환 구조 설계 오류</td><td>Composite 구조에서 자기 참조 발생 가능</td><td>순환 탐지 로직, 방문자 패턴 (Visitor) 활용, 인터페이스 제한 적용</td></tr><tr><td><strong>성능 최적화</strong></td><td>호출 오버헤드</td><td>Decorator, Proxy 계층이 깊어져 성능 저하</td><td>지연 로딩, 캐싱 적용, 핵심 책임 중심 래핑만 유지</td></tr><tr><td></td><td>메모리 누수</td><td>Flyweight 패턴에서 extrinsic 상태 관리 부실</td><td>WeakReference 사용, 상태 외부화, immutable 구조 설계</td></tr><tr><td></td><td>실시간 처리 지연</td><td>성능 민감 애플리케이션에서 구조 패턴의 래핑이 병목</td><td>직접 접근 우선 전략, 캐시/객체 풀링 적용, 경량 구조 채택</td></tr><tr><td><strong>유지보수성과 테스트</strong></td><td>테스트 복잡도 증가</td><td>다양한 구조 조합으로 인해 테스트 커버리지 부족</td><td>조합별 테스트 시나리오 분리, Mock/Stub 활용, 컴포지션 관리 UI 도입</td></tr><tr><td></td><td>디버깅 어려움</td><td>호출 흐름이 다층 구조로 구성되어 흐름 파악이 어려움</td><td>APM, Distributed Tracing, 계층별 로깅 삽입</td></tr><tr><td></td><td>패턴 간 충돌 및 오용</td><td>패턴 목적 미숙지로 부적절한 조합 사용</td><td>패턴 적용 가이드 문서화, 리뷰 기반 적용, 교육 및 코드 예제 공유</td></tr><tr><td><strong>동시성 및 상태 관리</strong></td><td>상태 공유 문제</td><td>Flyweight 등에서 상태 공유로 인한 Race Condition</td><td>동기화 처리, immutable extrinsic 상태 관리</td></tr><tr><td></td><td>병렬 구조에서 객체 컬렉션 변경 문제</td><td>Composite children 리스트 병렬 수정 시 충돌</td><td>동기화 처리 (Lock, Concurrent Collection), 쓰기 분리 전략 적용</td></tr><tr><td><strong>환경 적응성</strong></td><td>마이크로서비스 환경에서의 적용 한계</td><td>전통 구조 패턴이 분산 시스템 환경에 그대로 적용되기 어려움</td><td>분산 Facade 패턴, 비동기 Adapter, Service Mesh 기반 구조 설계</td></tr><tr><td></td><td>클라우드/서버리스에서 상태 관리 어려움</td><td>무상태 구조, 생명주기 제어 제한</td><td>Stateless 설계, Proxy 통한 외부 자원 관리, 설정 외부화 구성 적용</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>패턴명</th><th>도메인/시스템</th><th>구체적 적용 사례</th><th>적용 목적</th><th>기대 효과</th></tr></thead><tbody><tr><td><strong>Adapter</strong></td><td>레거시 시스템 통합, API 통합</td><td>- 레거시 API ↔ 신규 시스템 인터페이스 연결 - 플랫폼별 API 래핑</td><td>인터페이스 호환성 확보</td><td>시스템 통합 용이, 재사용성 향상</td></tr><tr><td><strong>Facade</strong></td><td>웹/엔터프라이즈 시스템</td><td>API Gateway- 복잡한 라이브러리 통합 API</td><td>복잡한 서브시스템 단순화</td><td>진입점 일원화, 클라이언트 복잡도 감소</td></tr><tr><td><strong>Decorator</strong></td><td>AOP, 서비스 확장, 보안</td><td>IO 스트림 암호화/압축 - 로깅/모니터링 기능 부여</td><td>기능의 런타임 동적 확장</td><td>공통 관심사 분리, 유연한 기능 추가</td></tr><tr><td><strong>Composite</strong></td><td>UI 컴포넌트, 파일 시스템</td><td>UI 위젯 트리 (DOM)- 파일/디렉터리 구조 트리</td><td>계층적 구조 표현, 단일 인터페이스 처리</td><td>일관된 구조 관리, 복합 객체 통합 처리</td></tr><tr><td><strong>Proxy</strong></td><td>DB/네트워크 접근, 보안</td><td>DB 연결 프록시 - 인증/로깅/지연 로딩 프록시</td><td>접근 제어, 리소스 제어, 로깅</td><td>성능 최적화, 보안성 강화, 캐싱 적용</td></tr><tr><td><strong>Flyweight</strong></td><td>게임 개발, 대량 객체 관리</td><td>- 스프라이트 객체 재사용 - 문자 렌더링 공유</td><td>동일한 데이터 구조의 메모리 공유</td><td>메모리 절약, 성능 향상</td></tr><tr><td><strong>Bridge</strong></td><td>멀티플랫폼 UI, DB 추상화</td><td>OS 독립 UI 구성 - 다양한 DB 엔진 구현 분리</td><td>구현과 추상의 분리</td><td>런타임 구현 변경 용이, 확장성 향상</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-웹-애플리케이션의-로깅-및-인증-기능-확장>사례 1: 웹 애플리케이션의 로깅 및 인증 기능 확장<a hidden class=anchor aria-hidden=true href=#사례-1-웹-애플리케이션의-로깅-및-인증-기능-확장>#</a></h4><p>Decorator 패턴</p><p><strong>목적</strong>: 기존 핵심 비즈니스 로직 코드에 영향 없이 공통 관심사 모듈화</p><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>classDiagram
    class RequestHandler {
        +handle(request)
    }
    class AuthHandler {
        -handler:RequestHandler
        +handle(request)
    }
    class LoggingHandler {
        -handler:RequestHandler
        +handle(request)
    }

    RequestHandler &lt;|-- AuthHandler
    RequestHandler &lt;|-- LoggingHandler
    AuthHandler *-- RequestHandler
    LoggingHandler *-- RequestHandler
</pre><p><strong>워크플로우</strong>:</p><ol><li><code>Client</code> 의 요청이 <code>LoggingHandler</code> 로 전달됨</li><li><code>LoggingHandler</code> 가 로그를 남기고 내부 <code>AuthHandler</code> 로 위임</li><li><code>AuthHandler</code> 에서 인증 검증 후 실제 <code>RequestHandler</code> 실행</li><li>결과는 다시 <code>AuthHandler</code> → <code>LoggingHandler</code> → <code>Client</code> 로 반환</li></ol><p><strong>차이점 분석</strong>:</p><ul><li><strong>Decorator 미적용 시</strong>: 인증과 로깅 코드가 핵심 핸들러에 섞여 코드 유지보수가 어려움</li><li><strong>Decorator 적용 시</strong>: 기능 분리가 명확하며, 인증·로깅 기능을 비즈니스 로직과 독립적으로 교체·확장 가능</li></ul><h4 id=사례-2-전자상거래-플랫폼의-결제-시스템-통합>사례 2: 전자상거래 플랫폼의 결제 시스템 통합<a hidden class=anchor aria-hidden=true href=#사례-2-전자상거래-플랫폼의-결제-시스템-통합>#</a></h4><p>전자상거래 플랫폼에서 여러 결제 서비스 (신용카드, 페이팔, 암호화폐) 를 통합하는 사례.</p><p><strong>시스템 구성:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;클라이언트&#34;
        A[웹 애플리케이션]
        B[모바일 앱]
    end
    
    subgraph &#34;결제 시스템&#34;
        C[Payment Facade]
        D[Payment Adapter Factory]
        E[Credit Card Adapter]
        F[PayPal Adapter]
        G[Crypto Adapter]
    end
    
    subgraph &#34;외부 서비스&#34;
        H[Credit Card API]
        I[PayPal API]
        J[Crypto Exchange API]
    end
    
    A --&gt; C
    B --&gt; C
    C --&gt; D
    D --&gt; E
    D --&gt; F
    D --&gt; G
    E --&gt; H
    F --&gt; I
    G --&gt; J
</pre><p><strong>워크플로우:</strong></p><ol><li><strong>요청 수신</strong>: 클라이언트에서 결제 요청 전송</li><li><strong>Facade 처리</strong>: Payment Facade 가 요청을 단일 인터페이스로 처리</li><li><strong>Adapter 선택</strong>: Factory 패턴으로 적절한 Adapter 선택</li><li><strong>인터페이스 변환</strong>: 각 Adapter 가 외부 API 형식에 맞게 변환</li><li><strong>결과 통합</strong>: 응답을 통일된 형식으로 변환하여 반환</li></ol><p><strong>구조 패턴의 역할:</strong></p><ul><li><strong>Facade</strong>: 복잡한 결제 로직을 단순한 인터페이스로 제공</li><li><strong>Adapter</strong>: 각 결제 서비스의 서로 다른 API 를 통일된 인터페이스로 변환</li><li><strong>Factory</strong>: 동적으로 적절한 Adapter 인스턴스 생성</li></ul><p><strong>패턴 유무에 따른 차이점:</strong></p><ul><li><strong>패턴 적용 전</strong>: 각 결제 서비스마다 별도 구현, 클라이언트 코드 복잡성 증가</li><li><strong>패턴 적용 후</strong>: 통일된 인터페이스로 개발 효율성 향상, 새로운 결제 수단 추가 용이</li></ul><h4 id=사례-3-adapter-패턴을-활용한-레거시-시스템-통합>사례 3: Adapter 패턴을 활용한 레거시 시스템 통합<a hidden class=anchor aria-hidden=true href=#사례-3-adapter-패턴을-활용한-레거시-시스템-통합>#</a></h4><p><strong>시스템 구성</strong>: 기존 시스템 (OldSystem), 새로운 시스템 (NewSystem), Adapter 클래스</p><p><strong>Workflow</strong>: Client → Adapter → OldSystem</p><pre class=mermaid>graph LR
    Client --&gt; Adapter
    Adapter --&gt; OldSystem
</pre><p><strong>역할</strong>: Adapter 는 OldSystem 의 인터페이스를 NewSystem 이 이해할 수 있도록 변환</p><p><strong>유무 차이</strong>: Adapter 적용 시 시스템 통합이 용이하며, 미적용 시 직접 인터페이스 수정 필요</p><h4 id=사례-4-하나의-데이터-처리-파이프라인>사례 4: 하나의 데이터 처리 파이프라인<a hidden class=anchor aria-hidden=true href=#사례-4-하나의-데이터-처리-파이프라인>#</a></h4><p><strong>패턴 조합 예시</strong>: Adapter + Facade + Strategy</p><p>하나의 데이터 처리 파이프라인에서 다음과 같은 기능이 필요할 때:</p><ol><li>레거시 API(JSON 조회, XML 변환) 지원 → <strong>Adapter</strong></li><li>복잡한 데이터 파이프를 단일 진입점으로 노출 → <strong>Facade</strong></li><li>동적으로 알고리즘 선택 (예: 압축, 암호화 등) → <strong>Strategy</strong></li></ol><p><strong>구조 다이어그램</strong></p><pre class=mermaid>classDiagram
    class LegacyJSONClient {
        +get_json()
    }

    class LegacyXMLClient {
        +get_xml()
    }

    class JSONToStandardAdapter {
        +get_standard()
    }

    class XMLToStandardAdapter {
        +get_standard()
    }

    class DataFacade {
        -jsonAdapter
        -xmlAdapter
        -strategy
        +processRequest(src, type)
    }

    class Strategy {
        &lt;&lt;interface&gt;&gt;
        +execute(data)
    }

    class CompressionStrategy {
        +execute(data)
    }

    class EncryptionStrategy {
        +execute(data)
    }

    DataFacade --&gt; JSONToStandardAdapter
    DataFacade --&gt; XMLToStandardAdapter
    DataFacade --&gt; Strategy

    Strategy &lt;|-- CompressionStrategy
    Strategy &lt;|-- EncryptionStrategy
</pre><ul><li><strong>Adapter</strong>: 레거시 데이터를 표준 데이터로 변환</li><li><strong>Facade</strong>: 클라이언트는 <code>DataFacade.processRequest(…)</code> 만 호출</li><li><strong>Strategy</strong>: 런타임 시 압축 또는 암호화 알고리즘 선택 적용</li></ul><p><strong>구현 예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Adapter 패턴 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>OldSystem</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>old_method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Old System Method&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Adapter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>old_system</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>old_system</span> <span class=o>=</span> <span class=n>old_system</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>new_method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>old_system</span><span class=o>.</span><span class=n>old_method</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 클라이언트 코드</span>
</span></span><span class=line><span class=cl><span class=n>old_system</span> <span class=o>=</span> <span class=n>OldSystem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>adapter</span> <span class=o>=</span> <span class=n>Adapter</span><span class=p>(</span><span class=n>old_system</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>adapter</span><span class=o>.</span><span class=n>new_method</span><span class=p>())</span>  <span class=c1># 출력: Old System Method</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=사례-5-비동기이벤트-기반-시스템에서-structural-패턴-적용>사례 5: 비동기/이벤트 기반 시스템에서 Structural 패턴 적용<a hidden class=anchor aria-hidden=true href=#사례-5-비동기이벤트-기반-시스템에서-structural-패턴-적용>#</a></h4><p>이벤트 기반 또는 메시징 시스템에서 Structural 패턴은 다음과 같은 형태로 활용된다:</p><ul><li><strong>Proxy</strong>: 메시지 큐에 대한 접근 제어, retry logic 및 circuit breaker 포함</li><li><strong>Decorator</strong>: 메시지 수신/발행 로깅, 메시지 변환, 엔리치먼트 용으로 메시징 핸들러 래핑</li><li><strong>Facade</strong>: 메시지 브로커 (RabbitMQ, Kafka 등) API 일관된 인터페이스 제공</li></ul><pre class=mermaid>sequenceDiagram
    participant Client
    participant LogDecorator
    participant AuthDecorator
    participant MessageHandler
    participant MQProxy

    Client-&gt;&gt;LogDecorator: send(message)
    LogDecorator-&gt;&gt;AuthDecorator: send(message)
    AuthDecorator-&gt;&gt;MessageHandler: send(message)
    MessageHandler-&gt;&gt;MQProxy: publish(message)
    MQProxy-&gt;&gt;Broker: enqueue(message)
</pre><ul><li>메시지에 로깅 및 인증 장치를 붙이고, MQ 접근은 Proxy 로 통제</li></ul><h4 id=사례-6-microservice-환경에서-structural-패턴-매핑-전략>사례 6: Microservice 환경에서 Structural 패턴 매핑 전략<a hidden class=anchor aria-hidden=true href=#사례-6-microservice-환경에서-structural-패턴-매핑-전략>#</a></h4><table><thead><tr><th>계층</th><th>사용 패턴 및 목적</th></tr></thead><tbody><tr><td>Service Layer</td><td><strong>Facade</strong>: 여러 내부 서비스 호출을 감추는 진입점</td></tr><tr><td>API Gateway</td><td><strong>Adapter/Proxy</strong>: 외부 요청을 내부 API 형식에 맞춰 매핑 및 인증</td></tr><tr><td>Inter-Service</td><td><strong>Decorator/Proxy</strong>: 요청 추적, TLS 인증, circuit breaker 기능 추가</td></tr><tr><td>Common Libs</td><td><strong>Bridge/Flyweight</strong>: 공통 라이브러리 플랫폼 분리 및 메모리 공유 최적화</td></tr></tbody></table><p><strong>API Gateway 구조</strong></p><pre class=mermaid>graph LR
    ExternalClient --&gt; GatewayAdapter
    GatewayAdapter --&gt; AuthProxy
    AuthProxy --&gt; ServiceFacade
    ServiceFacade --&gt; UserService
    ServiceFacade --&gt; OrderService
</pre><ul><li><code>GatewayAdapter</code>: 외부 요청 형식을 내부 모델로 변환</li><li><code>AuthProxy</code>: 인증 및 권한 검사</li><li><code>ServiceFacade</code>: 다중 서비스 호출 흐름 정리</li></ul><h4 id=사례-7-adapter-패턴-적용-사례-기존-코드와-새-인터페이스-연결>사례 7: Adapter 패턴 적용 사례: 기존 코드와 새 인터페이스 연결<a hidden class=anchor aria-hidden=true href=#사례-7-adapter-패턴-적용-사례-기존-코드와-새-인터페이스-연결>#</a></h4><p><strong>시스템 구성:</strong></p><ul><li>Client → Target</li><li>Adapter → Adaptee</li><li>Adapter 가 기존 코드와 새 인터페이스를 연결</li></ul><p><strong>Workflow:</strong></p><ol><li>Client 가 Target 인터페이스 사용</li><li>Adapter 가 Adaptee(기존 코드) 를 호출</li><li>Adaptee 가 실제 기능 수행</li></ol><p><strong>역할:</strong></p><ul><li>기존 코드와 새 인터페이스를 연결하여 호환성 확보</li><li>기존 코드를 재사용할 수 있게 함</li></ul><p><strong>차이점:</strong></p><ul><li>패턴 미적용 시 기존 코드를 새 인터페이스에 맞게 수정해야 함</li><li>패턴 적용 시 기존 코드를 그대로 재사용 가능</li></ul><h4 id=사례-8-대규모-금융-시스템에서-레거시-계좌-시스템과-신규-api-연동-필요>사례 8: 대규모 금융 시스템에서 레거시 계좌 시스템과 신규 API 연동 필요<a hidden class=anchor aria-hidden=true href=#사례-8-대규모-금융-시스템에서-레거시-계좌-시스템과-신규-api-연동-필요>#</a></h4><p><strong>시스템 구성</strong>:</p><ul><li>Adapter 패턴 적용: <code>LegacyAccountService</code>(Adaptee) 와 <code>NewAccountAPI</code>(Target) 사이에 <code>AccountAdapter</code>(Adapter) 구현</li></ul><p><strong>시스템 구성 다이어그램</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client ---&gt; NewAccountAPI (Target)
</span></span><span class=line><span class=cl>                   ^
</span></span><span class=line><span class=cl>                   |
</span></span><span class=line><span class=cl>             AccountAdapter
</span></span><span class=line><span class=cl>                   |
</span></span><span class=line><span class=cl>         LegacyAccountService (Adaptee)
</span></span></code></pre></td></tr></table></div></div><p><strong>Workflow</strong>:</p><ol><li>클라이언트는 NewAccountAPI 인터페이스로 계좌 정보를 요청</li><li>AccountAdapter 가 LegacyAccountService 의 데이터를 변환해 반환</li><li>클라이언트는 신규 API 만 알면 됨</li></ol><p><strong>역할</strong>:</p><ul><li>Adapter 가 레거시 시스템과 신규 시스템의 호환성 보장</li><li>클라이언트는 인터페이스만 알면 되고, 내부 구현 변경에 영향 없음</li></ul><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>고려사항</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th><th><strong>주의점</strong></th></tr></thead><tbody><tr><td>설계</td><td>패턴 선택 기준</td><td>문제 유형에 맞는 패턴을 선별적으로 적용</td><td>문제 분석 → 패턴 매핑 → 설계 검토</td><td>과도한 패턴 적용은 복잡도 유발</td></tr><tr><td></td><td>책임 분리</td><td>구성요소별 역할을 명확히 분리</td><td>SRP(단일 책임 원칙) 준수</td><td>책임 분산이 불분명하면 유지보수 어려움 발생</td></tr><tr><td></td><td>인터페이스 설계</td><td>구조 확장성과 변경에 유연한 인터페이스 정의</td><td>안정적인 추상화 계층 도입</td><td>모든 객체에 추상화 적용 시 오히려 복잡도 증가</td></tr><tr><td>구현</td><td>성능 고려</td><td>레이어 추가로 인한 호출 및 메모리 오버헤드</td><td>필요한 곳에만 적용, Lazy evaluation, 객체 풀 적용</td><td>데코레이터/프록시 남용 시 성능 저하 발생</td></tr><tr><td></td><td>예외 처리 전략</td><td>계층화된 구조 내 예외 흐름 설계 필요</td><td>각 계층별 try-catch 또는 fallback 전략 구성</td><td>공통 예외 흐름 미비 시 디버깅 어려움</td></tr><tr><td></td><td>스레드 안전성</td><td>공유 자원이나 상태 변경이 있는 경우 스레드 충돌 가능성</td><td>동기화 또는 immutable 상태 설계 적용</td><td>Flyweight, Proxy 등 상태 공유 객체 주의 필요</td></tr><tr><td>운영</td><td>문서화</td><td>구조가 복잡해질수록 문서 기반 의사소통이 중요</td><td>클래스 다이어그램, 패턴 목적, 구조 흐름 문서화</td><td>문서 미흡 시 후속 개발자의 이해도 저하</td></tr><tr><td></td><td>모니터링 및 디버깅</td><td>구조가 계층화되면 디버깅과 성능 추적이 어려움</td><td>로깅, APM, 분산 추적 (Tracing) 도입</td><td>오류 전파 경로 식별이 어려워질 수 있음</td></tr><tr><td>테스트</td><td>계층 단위 테스트</td><td>복합 패턴 적용 시 단위 테스트 설계가 중요</td><td>각 구성 요소에 Mock 기반 테스트 적용</td><td>통합 테스트 설계 시 조합 증가로 인한 커버리지 누락 위험</td></tr><tr><td></td><td>통합 테스트</td><td>패턴 간 협력 작용을 검증</td><td>주요 경로 중심의 통합 테스트 설계</td><td>계층 누락 및 예외 흐름 커버리지 누락 가능성 있음</td></tr><tr><td>유지보수</td><td>변경 영향 최소화</td><td>구조 변경 시 하위 계층에 영향 최소화</td><td>인터페이스 기반 설계, OCP(개방 - 폐쇄 원칙) 적용</td><td>인터페이스가 불안정하면 전체 구조에 영향 미침</td></tr><tr><td>확장성</td><td>구조 확장 전략</td><td>새로운 기능 추가 시 기존 구조 재사용 가능하도록 설계</td><td>Composite, Decorator, Proxy 기반 확장 고려</td><td>구조 설계 초기에 확장 고려 누락 시 추후 재작성 필요</td></tr><tr><td></td><td>순환 참조 방지</td><td>Composite 등 트리 구조에서 자기 자신 포함 가능성</td><td>사이클 방지 로직 도입</td><td>스택 오버플로우 또는 무한 루프 발생 가능</td></tr></tbody></table><h4 id=테스트-전략>테스트 전략<a hidden class=anchor aria-hidden=true href=#테스트-전략>#</a></h4><p>Structural 패턴 구현 시 고려해야 할 테스트 유형:</p><ol><li><p><strong>단위 테스트 (Unit Test)</strong></p><ul><li>각 데코레이터가 기능 위임 후 후처리 로직 수행 확인</li><li><code>AuthDecorator</code> 미인증 시 <code>PermissionError</code> 발생 검증</li></ul></li><li><p><strong>통합 테스트 (Integration Test)</strong></p><ul><li>여러 데코레이터를 조합한 핸들러 흐름 검증</li><li>실행 흐름, 타이밍, 예외 전파 등 정상 처리 확인</li></ul></li><li><p><strong>성능 테스트 (Performance Test)</strong></p><ul><li>래핑 계층이 많은 경우 처리 지연 시간 측정</li><li>성능 저하 임계점 파악 및 고도화 전략 수립</li></ul></li></ol><h4 id=리팩토링-전략>리팩토링 전략<a hidden class=anchor aria-hidden=true href=#리팩토링-전략>#</a></h4><p>Structural 패턴 적용 시 소스 구조를 개선하는 방법:</p><ul><li><strong>중복 제거</strong><ul><li>데코레이터의 공통 위임 코드 추출 → <code>HandlerDecorator</code> 에 모아 재사용</li></ul></li><li><strong>레이어 최소화</strong><ul><li>래핑 계층이 너무 많은 경우 단순화 or 한 개로 통합</li></ul></li><li><strong>명확한 역할 분리</strong><ul><li>각 데코레이터 하나당 하나의 책임만 갖도록 리팩토링</li></ul></li></ul><h4 id=시스템-규모-증가-시-설계-전략>시스템 규모 증가 시 설계 전략<a hidden class=anchor aria-hidden=true href=#시스템-규모-증가-시-설계-전략>#</a></h4><ol><li><p><strong>모듈 계층화</strong></p><ul><li>유사한 책임끼리 묶어 도메인 별 모듈로 구성</li><li>각 모듈 내부는 Composite/Decorator 등으로 구조화</li></ul></li><li><p><strong>인터페이스 표준화</strong></p><ul><li>외부 통신용 API 에는 Adapter 및 Facade 중심 설계</li></ul></li><li><p><strong>기능 확장성 고려</strong></p><ul><li>새로운 로깅, 인증, 트랜잭션 처리 등은 Decorator 또는 Proxy 로 확장</li></ul></li><li><p><strong>중앙 집중 팩토리 +Bridge 적용</strong></p><ul><li>크로스 플랫폼 대응 등 플랫폼/통신 방식 변경 시 유리</li></ul></li><li><p><strong>모니터링 및 성능 계층 분리</strong></p><ul><li>Proxy 를 사용해 지연 로딩, 캐싱 계층 도입</li></ul></li><li><p><strong>문서화 + 시각화 자동화</strong></p><ul><li>UML 생성, JSON/YAML 메타데이터 기반 Echo 시스템 시각화</li></ul></li></ol><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>최적화 항목</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th><th><strong>주의점</strong></th></tr></thead><tbody><tr><td><strong>성능</strong></td><td>호출 체인 최적화</td><td>Decorator, Proxy 사용 시 호출 경로가 깊어질 수 있음</td><td>필요한 계층만 유지, 불필요한 래핑 최소화</td><td>과도한 체인 구성은 응답 지연 및 디버깅 어려움 초래</td></tr><tr><td></td><td>객체 생성 비용 최소화</td><td>반복적 객체 생성으로 인한 성능 저하 가능</td><td>객체 풀, 싱글톤, Lazy Loading 사용</td><td>객체 재사용 시 상태 공유 여부 주의</td></tr><tr><td></td><td>지연 로딩</td><td>사용 시점까지 객체 생성을 지연시켜 초기 비용 절감</td><td>Proxy 기반 Lazy Initialization 구현</td><td>초기 접근 시 지연 발생 가능성 있음</td></tr><tr><td></td><td>캐싱 적용</td><td>동일 변환 또는 결과 반복 시 캐싱을 통해 성능 향상</td><td>어댑터 결과 캐시, 변환 결과 캐싱, 캐시 만료 정책 설정</td><td>캐시 무효화 정책이 없으면 오래된 정보 사용 위험</td></tr><tr><td><strong>메모리</strong></td><td>Flyweight 활용</td><td>공유 객체를 통한 메모리 사용량 절감</td><td>공유 상태/개별 상태 분리, 불변 객체 설계</td><td>스레드 안전성 보장 필수</td></tr><tr><td></td><td>컬렉션 관리 최적화</td><td>트리 구조나 복합 객체의 자식 노드 다수일 때 메모리 부담 발생</td><td>스트리밍 처리, 자식 노드 지연 로딩</td><td>트리 깊이 증가 시 순회 비용 증가</td></tr><tr><td><strong>구조</strong></td><td>불필요한 계층 제거</td><td>단순 로직에 과도한 구조 패턴 적용은 오히려 복잡성 증가</td><td>직접 호출 가능한 경우 래퍼 생략</td><td>일관성과 재사용성을 해치지 않도록 주의</td></tr><tr><td></td><td>구조 단순화 우선</td><td>설계 시 추상화보다 단순 구조 우선 고려</td><td>YAGNI 원칙 적용, 구조적 미니멀리즘 지향</td><td>지나친 단순화는 유연성 저해 가능</td></tr><tr><td><strong>확장성</strong></td><td>플러그인 아키텍처 설계</td><td>새로운 구현체 추가 시 구조 최소 변경으로 대응</td><td>인터페이스 기반 설계, 전략/팩토리 패턴 조합</td><td>과도한 추상화는 이해도 및 유지보수성 저하</td></tr><tr><td></td><td>버전 호환성 확보</td><td>레거시와 신규 구조 공존 시 호환성 유지 필요</td><td>Adapter 패턴 활용해 구버전과 인터페이스 일치</td><td>Adapter 계층 과다 구성 시 관리 비용 증가</td></tr><tr><td><strong>유지보수</strong></td><td>명확한 역할 정의</td><td>각 구성요소의 책임이 불명확할 경우 유지보수 어려움</td><td>SRP 준수, 클래스 네이밍 명확화</td><td>역할 중첩/모호한 책임은 리팩토링 시 리스크 증가</td></tr><tr><td></td><td>구조 시각화/문서화</td><td>복잡한 패턴 구조의 이해를 돕기 위한 시각적/문서 기반 명세 필요</td><td>클래스 다이어그램, 구조도, README 문서 작성</td><td>문서화 누락 시 협업 및 후속 유지보수 어려움</td></tr><tr><td><strong>테스트</strong></td><td>계층 단위 테스트 설계</td><td>패턴 간 조합으로 인해 통합 테스트 복잡도 증가</td><td>Mock 객체 기반 계층별 단위 테스트 우선</td><td>조합 누락 시 테스트 커버리지 저하 가능성 있음</td></tr><tr><td></td><td>상태 분리와 테스트성</td><td>Flyweight, Composite 구조에서 상태 공유/분리를 명확히 해야 테스트 용이</td><td>외부 상태 분리, 순수 함수 구성</td><td>상태 공유로 인한 테스트 간 간섭 발생 가능</td></tr><tr><td><strong>분석</strong></td><td>성능 프로파일링</td><td>패턴 도입 후 성능 영향에 대한 정량적 분석 필요</td><td>APM 도구, 메모리/CPU 프로파일링 도구 활용</td><td>주관적 판단에 의존하지 않도록 수치 기반 검증 필요</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>패턴 조합 및 확장</td><td>패턴 혼용, 조합 설계</td><td>Facade+Proxy 등 여러 패턴 조합을 통해 복잡한 시스템 문제 해결 가능</td></tr><tr><td></td><td>책임 분리와 구조 명확성</td><td>유지보수성 향상</td><td>객체 간의 관계 명확화로 변경 시 영향도 최소화 및 재사용성 증가</td></tr><tr><td></td><td>문서화 및 공유</td><td>구조 설계 문서화</td><td>구조적 패턴 적용 시 아키텍처 명세화 필요, 팀 간 협업과 유지보수에 필수</td></tr><tr><td><strong>실무 적용</strong></td><td>레거시 시스템 통합</td><td>Adapter 패턴</td><td>레거시 시스템을 신규 구조와 연결하여 단계적 리팩토링 가능</td></tr><tr><td></td><td>API 게이트웨이</td><td>Facade 패턴</td><td>여러 마이크로서비스를 단일 진입점으로 통합하여 클라이언트 복잡도 감소</td></tr><tr><td></td><td>인증 시스템 통합</td><td>OAuth Adapter</td><td>다양한 OAuth 제공자와의 통합 용이화</td></tr><tr><td></td><td>데이터 캐싱 계층</td><td>Redis Proxy</td><td>캐싱 계층으로 Proxy 적용 시 성능 및 응답 속도 향상</td></tr><tr><td><strong>아키텍처</strong></td><td>마이크로서비스 구조 설계</td><td>서비스 메시, API Gateway</td><td>Proxy, Facade 를 활용한 서비스 간 통신 및 인터페이스 일원화</td></tr><tr><td></td><td>서버리스 컴포지션 구조</td><td>Composite Pattern</td><td>FaaS 간의 조합을 통해 함수 흐름 제어</td></tr><tr><td></td><td>클라우드 기반 통신 최적화</td><td>Service Mesh (Proxy)</td><td>서비스 간 통신, 로깅, 인증을 사이드카 Proxy 로 분리</td></tr><tr><td></td><td>GraphQL 연동 구조</td><td>스키마 스티칭 (Adapter)</td><td>GraphQL API 간 통합 및 호환성 확보</td></tr><tr><td><strong>성능 최적화</strong></td><td>구조적 최적화 적용</td><td>불필요한 패턴 제거</td><td>단순한 구조에는 래핑 생략으로 성능 최적화</td></tr><tr><td></td><td>객체 공유 최적화</td><td>Flyweight</td><td>대량 객체 재사용 시 메모리 사용량 감소 및 스레드 안전성 확보</td></tr><tr><td><strong>프론트엔드 기술</strong></td><td>UI 컴포넌트 구조</td><td>React HOC (Decorator)</td><td>공통 기능 (로그인 확인, 권한 부여 등) 을 고차 컴포넌트로 동적 적용 가능</td></tr><tr><td></td><td>Virtual DOM 최적화</td><td>Proxy</td><td>가상 DOM 을 통한 성능 최적화</td></tr><tr><td></td><td>컴포넌트 트리</td><td>Composite</td><td>UI 계층 구조를 객체 트리로 설계하여 일관성 있는 렌더링 구조 구현</td></tr><tr><td><strong>테스트 전략</strong></td><td>계층적 테스트 설계</td><td>Mock 객체 생성</td><td>구조적 분리가 명확하여 계층별 Mock 테스트 설계가 쉬움</td></tr><tr><td></td><td>단위 테스트 용이성</td><td>구조 기반 테스트 가능성 향상</td><td>구조적 패턴은 테스트 대상이 명확하고 독립 구성 가능</td></tr><tr><td><strong>교육 및 품질</strong></td><td>팀 협업 및 학습 곡선</td><td>패턴 교육 필요성</td><td>구조적 패턴에 대한 이해도 향상이 협업 및 유지보수 효율에 기여</td></tr><tr><td></td><td>코드 품질 향상</td><td>일관된 구조로 품질 확보</td><td>구조 패턴 적용으로 모듈화, 책임 분리가 가능하여 품질 및 확장성 확보</td></tr><tr><td><strong>미래 기술 적용</strong></td><td>엣지 컴퓨팅</td><td>분산 Flyweight</td><td>엣지 간 공유 가능한 상태 객체로 자원 최적화</td></tr><tr><td></td><td>블록체인</td><td>스마트 컨트랙트 프록시</td><td>Proxy 패턴으로 스마트 컨트랙트 업그레이드 구조 구현</td></tr><tr><td></td><td>웹어셈블리</td><td>WASM Bridge</td><td>JS ↔ WASM 간 인터페이스 연결을 위한 Bridge 패턴 적용</td></tr></tbody></table><h3 id=추가-학습-필요-내용>추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#추가-학습-필요-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>기초 개념 및 이론</strong></td><td>GoF 구조 패턴 7 종</td><td>Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy 이해</td></tr><tr><td></td><td>생성 vs 구조 패턴 비교</td><td>생성 패턴은 객체 생성에 초점, 구조 패턴은 객체 간 관계와 구성에 초점</td></tr><tr><td></td><td>OOP 설계 원칙</td><td>구조 패턴은 DIP, OCP, SRP 등의 원칙과 밀접한 연관</td></tr><tr><td><strong>구현 기술</strong></td><td>언어별 특징 및 구현 방법</td><td>Python, Java, JavaScript 등 언어별 구조 패턴 구현 방법 비교</td></tr><tr><td></td><td>인터페이스 안정성</td><td>확장성과 유지보수를 고려한 인터페이스 설계 전략</td></tr><tr><td></td><td>다형성 및 추상화</td><td>구조 패턴 구현 시 상속/인터페이스 기반 다형성 활용</td></tr><tr><td><strong>실무 적용 전략</strong></td><td>레거시 시스템 통합</td><td>Adapter 패턴을 통한 시스템 마이그레이션, 호환성 확보</td></tr><tr><td></td><td>서비스 계층 분리 (Proxy/Façade)</td><td>인증, 로깅, 캐싱 등 단일 책임 분리와 테스트 용이성 확보</td></tr><tr><td></td><td>DI/IOC 컨테이너 연계</td><td>구조 패턴을 DI 컨테이너 (Spring, NestJS 등) 와 함께 사용하는 방법</td></tr><tr><td><strong>성능 최적화</strong></td><td>Lazy Proxy</td><td>지연 로딩을 위한 프록시 최적화 전략</td></tr><tr><td></td><td>Flyweight 메모리 절감 전략</td><td>대량 객체 처리 시 공유 가능한 상태만 유지하여 메모리 사용 최소화</td></tr><tr><td></td><td>호출 최소화</td><td>불필요한 구조적 중첩 제거 및 호출 체인 최적화</td></tr><tr><td><strong>테스트 전략</strong></td><td>Mock / Stub 적용</td><td>테스트 더블을 통한 테스트 환경 분리 및 계층 테스트 구현</td></tr><tr><td></td><td>Proxy 기반 테스트 분리</td><td>외부 시스템 감싸기 통한 통합 테스트 안정성 확보</td></tr><tr><td><strong>아키텍처 연계</strong></td><td>계층형 아키텍처 (Layered)</td><td>구조 패턴을 이용한 프레젠테이션/도메인/인프라 계층 분리</td></tr><tr><td></td><td>클린 아키텍처</td><td>구조 패턴으로 계층 간 의존성 최소화, 변경에 강한 설계</td></tr><tr><td></td><td>마이크로서비스 게이트웨이</td><td>Facade 패턴을 API Gateway 로 적용하여 백엔드 서비스 추상화</td></tr><tr><td></td><td>Service Mesh (Proxy)</td><td>서비스 간 통신 책임을 Proxy 로 위임 (Observability, 보안 포함)</td></tr><tr><td><strong>현대 기술 연계</strong></td><td>서버리스 함수 컴포지션</td><td>Composite 패턴을 활용한 FaaS 함수 구성</td></tr><tr><td></td><td>블록체인 스마트 컨트랙트 Proxy</td><td>업그레이드 가능한 스마트 컨트랙트 구조 설계</td></tr><tr><td></td><td>WASM 브리지 패턴</td><td>WebAssembly ↔ JS 간 통신 추상화를 위한 Bridge 패턴 적용</td></tr><tr><td></td><td>GraphQL 스키마 스티칭</td><td>다양한 GraphQL API 를 통합하는 어댑터 패턴 응용</td></tr><tr><td><strong>프론트엔드/모바일</strong></td><td>React/Vue 데코레이터 패턴 활용</td><td>컴포넌트 기능 확장 시 Decorator 패턴 적용</td></tr><tr><td></td><td>Virtual DOM Proxy 적용</td><td>렌더링 최적화를 위한 Proxy 기반 구조</td></tr><tr><td></td><td>플랫폼 어댑터 설계</td><td>모바일 환경 (Android/iOS 등) 공통 인터페이스 추상화</td></tr><tr><td><strong>고급 패턴 확장</strong></td><td>Composite + Command 조합</td><td>복합 명령 구조로의 확장 가능성 (예: UI 이벤트 처리)</td></tr><tr><td></td><td>Functional Decorator</td><td>함수형 언어 기반 데코레이터 적용 방식</td></tr><tr><td></td><td>Thread-Safe Flyweight</td><td>멀티스레드 환경에서의 공유 객체 관리</td></tr><tr><td></td><td>Reactive Adapter</td><td>RxJS, Reactor 등과 어댑터 패턴 결합</td></tr><tr><td><strong>교육 및 문서화</strong></td><td>팀 내 공유</td><td>구조 패턴에 대한 팀 내 학습과 문서화 필요성 강조</td></tr><tr><td></td><td>도구 기반 문서화</td><td>UML, Mermaid, README 기반 구조 명세 작성</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>카테고리</strong></th><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>기본 개념</strong></td><td>구조 패턴 (Structural Pattern)</td><td>클래스나 객체를 조합해 더 큰 구조를 만드는 GoF 디자인 패턴</td></tr><tr><td></td><td>객체 조합 (Object Composition)</td><td>상속 대신 객체를 포함시켜 기능을 구성하는 방식</td></tr><tr><td></td><td>인터페이스 적응 (Interface Adaptation)</td><td>서로 다른 인터페이스를 호환되게 변환하는 과정</td></tr><tr><td></td><td>구조적 합성 (Structural Composition)</td><td>구조를 형성하기 위해 여러 객체를 결합하는 방식</td></tr><tr><td><strong>GoF 구조 패턴</strong></td><td>Adapter</td><td>호환되지 않는 인터페이스를 연결해주는 패턴</td></tr><tr><td></td><td>Bridge</td><td>추상화와 구현을 독립적으로 확장 가능하도록 분리하는 패턴</td></tr><tr><td></td><td>Composite</td><td>객체를 트리 구조로 구성하여 단일 객체와 복합 객체를 동일하게 다룰 수 있게 하는 패턴</td></tr><tr><td></td><td>Decorator</td><td>객체에 기능을 동적으로 추가할 수 있게 하는 패턴</td></tr><tr><td></td><td>Facade</td><td>복잡한 서브시스템을 단순한 인터페이스로 감싸는 패턴</td></tr><tr><td></td><td>Flyweight</td><td>유사한 객체들을 공유하여 메모리 사용을 최소화하는 패턴</td></tr><tr><td></td><td>Proxy</td><td>접근 제어, 로깅, 보안 등을 위한 대리 객체를 제공하는 패턴</td></tr><tr><td><strong>구현 기법</strong></td><td>위임 (Delegation)</td><td>작업 책임을 다른 객체에게 넘기는 메커니즘</td></tr><tr><td></td><td>래핑 (Wrapping)</td><td>기존 객체를 감싸서 새로운 기능이나 인터페이스를 제공하는 방식</td></tr><tr><td></td><td>투명성 (Transparency)</td><td>클라이언트가 개별 객체와 복합 객체를 구분하지 않고 동일하게 사용할 수 있는 특성</td></tr><tr><td></td><td>내재적 상태 (Intrinsic State)</td><td>여러 객체가 공유 가능한 불변 상태 (Flyweight 에서 활용)</td></tr><tr><td></td><td>외재적 상태 (Extrinsic State)</td><td>각 객체가 개별적으로 갖는 고유 상태 (Flyweight 에서 분리)</td></tr><tr><td><strong>설계 원칙</strong></td><td>OCP (개방 - 폐쇄 원칙)</td><td>기능 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙</td></tr><tr><td></td><td>SRP (단일 책임 원칙)</td><td>하나의 클래스는 하나의 책임만 가져야 한다는 원칙</td></tr><tr><td></td><td>Composition over Inheritance</td><td>상속보다 객체 조합을 통한 설계를 권장하는 원칙</td></tr><tr><td></td><td>YAGNI</td><td>&ldquo;You Aren&rsquo;t Gonna Need It&rdquo;—필요 없는 기능은 미리 만들지 말라는 원칙</td></tr><tr><td><strong>아키텍처 연계</strong></td><td>레이어드 아키텍처 (Layered Architecture)</td><td>각 계층이 특정 책임을 갖도록 구성된 아키텍처 (예: 프레젠테이션, 도메인, 인프라)</td></tr><tr><td></td><td>서비스 메시 (Service Mesh)</td><td>마이크로서비스 간 통신을 추상화하고 제어하는 인프라 계층</td></tr><tr><td></td><td>API 게이트웨이 (API Gateway)</td><td>클라이언트 요청을 마이크로서비스로 라우팅하는 단일 진입점 구성 요소</td></tr><tr><td><strong>테스트 및 적용</strong></td><td>Mock 객체</td><td>테스트를 위해 실제 객체 대신 사용하는 가짜 객체</td></tr><tr><td></td><td>구조적 변환 (Structural Transformation)</td><td>객체나 클래스의 구조를 재구성하거나 변경하는 작업</td></tr><tr><td><strong>표현 및 시각화</strong></td><td>Composite Graph</td><td>Composite 구조를 시각화하기 위한 그래프 형태의 표현</td></tr><tr><td></td><td>Distributed Tracing</td><td>분산 시스템에서의 호출 경로 및 관계를 추적하는 기술</td></tr><tr><td></td><td>Wrapper Object</td><td>다른 객체를 감싸고 대리하여 기능을 수행하는 객체 (Proxy, Decorator 등과 연관)</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=공식-문서-및-이론-기반>공식 문서 및 이론 기반<a hidden class=anchor aria-hidden=true href=#공식-문서-및-이론-기반>#</a></h3><ul><li><a href=https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612>Design Patterns: Elements of Reusable Object-Oriented Software (GoF 원서)</a></li><li><a href=https://refactoring.guru/design-patterns/structural-patterns>Refactoring Guru - Structural Patterns</a></li><li><a href=https://sourcemaking.com/design_patterns/structural_patterns>SourceMaking - Structural Patterns</a></li><li><a href=https://en.wikipedia.org/wiki/Structural_pattern_%28computer_science%29>Wikipedia - Structural Pattern (Computer Programming)</a></li><li><a href=https://martinfowler.com/bliki/Facade.html>Martin Fowler - Facade 패턴 활용</a></li></ul><h3 id=학습-플랫폼튜토리얼>학습 플랫폼/튜토리얼<a hidden class=anchor aria-hidden=true href=#학습-플랫폼튜토리얼>#</a></h3><ul><li><a href=https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns>DigitalOcean - Gang of Four (GoF) Design Patterns</a></li><li><a href=https://www.geeksforgeeks.org/structural-design-patterns/>GeeksforGeeks - Structural Design Patterns</a></li><li><a href=https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm>TutorialsPoint - Design Patterns Overview</a></li><li><a href=https://stackabuse.com/structural-design-patterns-in-python/>Stack Abuse - Structural Design Patterns in Python</a></li><li><a href=https://www.baeldung.com/java-structural-design-patterns>Baeldung - Proxy, Decorator, Adapter and Bridge Patterns</a></li></ul><h3 id=실무-사례-및-블로그-아티클>실무 사례 및 블로그 아티클<a hidden class=anchor aria-hidden=true href=#실무-사례-및-블로그-아티클>#</a></h3><ul><li><a href=https://blog.tuanhadev.tech/design-patterns-handbook-part-ii>TuanHaDev Blog - Structural Design Pattern Guide</a></li><li><a href=https://python.plainenglish.io/structural-design-patterns-a-comprehensive-guide-for-developers-c0cde4a86319>Python Plain English - Structural Patterns Guide</a></li><li><a href=https://bepatterns.com/what-are-structural-design-patterns/>BePatterns - What are Structural Design Patterns?</a></li><li><a href=https://dev.to/documatic/from-problems-to-solutions-understanding-design-patterns-3b7i>DEV.to - From Problems to Solutions: Design Patterns</a></li><li><a href=https://www.javacodegeeks.com/2015/09/structural-patterns-maintainability.html>Java Code Geeks - Structural Patterns and Maintainability</a></li></ul><h3 id=기업플랫폼-공식-문서-및-커뮤니티>기업/플랫폼 공식 문서 및 커뮤니티<a hidden class=anchor aria-hidden=true href=#기업플랫폼-공식-문서-및-커뮤니티>#</a></h3><ul><li><a href=https://docs.spring.io/spring-framework/reference/core/aop.html>Spring Framework Reference - Proxy Pattern in AOP</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/standard/design-patterns/decorator>Microsoft Learn - Decorator Pattern</a></li><li><a href=https://plantuml.com/>PlantUML - 구조 설계 시각화 도구</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Flyweight Pattern</h2></header><div class=entry-content><p>Flyweight Pattern Flyweight Pattern 은 메모리 상의 동일한 객체가 반복적으로 사용될 경우, 그 내부의 불변 데이터를 공유하여 메모리 낭비를 줄이는 구조적 설계 패턴이다. 객체의 상태를 고유 상태와 외부 상태로 분리하여, 공유 가능한 고유 상태만을 플라이웨이트 객체에 저장하고 팩토리를 통해 인스턴스를 관리한다.
특히 대규모 객체를 반복적으로 생성·사용하는 GUI 요소, 게임 오브젝트, 텍스트 렌더링 등의 환경에서 효과적이다. 이 패턴은 객체 간 차이를 외부화 (Extrinsic State) 하고, 공통된 내부 상태를 내부화하여 공유함으로써 객체 수를 최소화한다.
...</p></div><footer class=entry-footer><span title='2024-09-25 08:25:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flyweight Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/flyweight-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Composite Pattern</h2></header><div class=entry-content><p>Composite Pattern Composite Pattern 은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분 - 전체 계층을 표현하는 패턴이다.
Composite Pattern 은 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층 구조를 만든다. 이 패턴을 사용하면 클라이언트가 개별 객체와 복합 객체를 동일하게 다룰 수 있다.
Composite Pattern 은 복잡한 트리 구조를 간단하게 다룰 수 있게 해주는 강력한 도구이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 요구사항과 구조를 고려하여 적절히 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-25 08:24:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composite Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/composite-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decorator Pattern</h2></header><div class=entry-content><p>Decorator Pattern 객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴
" 래퍼 (wrapper)" 개념으로 각 데코레이터는 원본 객체를 감싸면서 추가 기능을 제공한다.
여러 데코레이터를 겹겹이 쌓을 수 있으며, 각 계층은 이전 계층의 기능을 확장한다.
특징 기존 객체의 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 상속 대신 구성 (composition) 을 사용하여 객체의 기능을 확장합니다. 객체를 여러 데코레이터로 감싸 기능을 조합할 수 있습니다. 사용사례 파일 입출력 시스템에서 압축, 암호화, 버퍼링 등의 기능을 조합할 때 웹 서비스에서 로깅, 캐싱, 인증 등의 기능을 동적으로 추가할 때 GUI 컴포넌트에 테두리, 스크롤바, 색상 등의 시각적 요소를 조합할 때 게임 캐릭터에 아이템, 버프, 상태 효과 등을 적용할 때 장점 객체의 기능을 동적으로 확장할 수 있어 매우 유연합니다. 단일 책임 원칙을 지키면서 기능을 조합할 수 있습니다. 상속을 통한 확장보다 더 유연한 방식을 제공합니다. 런타임에 객체의 행동을 변경할 수 있습니다. 단점 데코레이터를 너무 많이 사용하면 코드가 복잡해질 수 있습니다. 데코레이터들의 순서가 결과에 영향을 미칠 수 있어 주의가 필요합니다. 작은 객체들이 많이 생성되어 코드를 이해하기 어려울 수 있습니다. 주의사항 및 고려사항 데코레이터의 순서를 신중하게 고려해야 합니다. 예를 들어, 텍스트 처리에서 HTML 이스케이프를 마크다운 변환 전에 하면 원하는 결과를 얻을 수 없습니다. 데코레이터 체인이 너무 길어지지 않도록 주의해야 합니다. 필요한 경우 자주 사용되는 조합을 별도의 클래스로 만드는 것을 고려하세요. 데코레이터들 간의 상호작용을 고려해야 합니다. 한 데코레이터의 출력이 다른 데코레이터의 입력으로 적절한지 확인해야 합니다. 성능에 민감한 상황에서는 데코레이터 체인으로 인한 오버헤드를 고려해야 합니다. 디버깅이 어려울 수 있으므로, 로깅이나 모니터링 기능을 추가하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 from abc import ABC, abstractmethod from typing import List # Component interface class Coffee(ABC): """Base Coffee interface""" @abstractmethod def get_cost(self) -> float: pass @abstractmethod def get_ingredients(self) -> List[str]: pass @abstractmethod def get_description(self) -> str: pass # Concrete component class SimpleCoffee(Coffee): """Basic coffee implementation""" def get_cost(self) -> float: return 2.0 def get_ingredients(self) -> List[str]: return ["Coffee"] def get_description(self) -> str: return "Simple coffee" # Base decorator class CoffeeDecorator(Coffee): """Base decorator class""" def __init__(self, coffee: Coffee): self._coffee = coffee def get_cost(self) -> float: return self._coffee.get_cost() def get_ingredients(self) -> List[str]: return self._coffee.get_ingredients() def get_description(self) -> str: return self._coffee.get_description() # Concrete decorators class MilkDecorator(CoffeeDecorator): """Adds milk to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.5 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Milk"] def get_description(self) -> str: return f"{super().get_description()}, with steamed milk" class WhipDecorator(CoffeeDecorator): """Adds whipped cream to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.7 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Whipped Cream"] def get_description(self) -> str: return f"{super().get_description()}, topped with whipped cream" class CaramelDecorator(CoffeeDecorator): """Adds caramel to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.6 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Caramel"] def get_description(self) -> str: return f"{super().get_description()}, drizzled with caramel" class ExtraShotDecorator(CoffeeDecorator): """Adds an extra shot of espresso""" def get_cost(self) -> float: return super().get_cost() + 1.0 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Extra Espresso Shot"] def get_description(self) -> str: return f"{super().get_description()}, with an extra shot" # Order management class CoffeeOrder: """Manages coffee orders and provides order summary""" def __init__(self): self.coffee = None def create_order(self) -> None: """Creates a new coffee order starting with simple coffee""" self.coffee = SimpleCoffee() def add_milk(self) -> None: self.coffee = MilkDecorator(self.coffee) def add_whip(self) -> None: self.coffee = WhipDecorator(self.coffee) def add_caramel(self) -> None: self.coffee = CaramelDecorator(self.coffee) def add_extra_shot(self) -> None: self.coffee = ExtraShotDecorator(self.coffee) def get_order_summary(self) -> str: """Generates a summary of the current order""" return f""" Order Summary: Description: {self.coffee.get_description()} Ingredients: {', '.join(self.coffee.get_ingredients())} Total Cost: ${self.coffee.get_cost():f} """ # Usage example if __name__ == "__main__": # Create a new order order = CoffeeOrder() order.create_order() # Customize the coffee with various additions order.add_milk() order.add_extra_shot() order.add_whip() order.add_caramel() # Print the order summary print(order.get_order_summary()) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // Component interface class TextProcessor { constructor() { if (this.constructor === TextProcessor) { throw new Error("Abstract class cannot be instantiated"); } } process(text) { throw new Error("Method 'process' must be implemented"); } } // Concrete component class SimpleTextProcessor extends TextProcessor { process(text) { return text; } } // Base decorator class TextProcessorDecorator extends TextProcessor { constructor(processor) { super(); this._processor = processor; } process(text) { return this._processor.process(text); } } // Concrete decorators class CapitalizeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.toUpperCase(); } } class TrimDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.trim(); } } class HTMLEscapeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/&/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/>/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); } } class MarkdownToHTMLDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/\*\*(.*?)\*\*/g, '&lt;strong>$1&lt;/strong>') .replace(/\*(.*?)\*/g, '&lt;em>$1&lt;/em>') .replace(/\[(.*?)\]\((.*?)\)/g, '&lt;a href="$2">$1&lt;/a>') .replace(/^# (.*$)/gm, '&lt;h1>$1&lt;/h1>') .replace(/^## (.*$)/gm, '&lt;h2>$1&lt;/h2>'); } } class ValidationDecorator extends TextProcessorDecorator { constructor(processor, maxLength = 1000) { super(processor); this.maxLength = maxLength; } process(text) { if (!text) { throw new Error("Text cannot be empty"); } if (text.length > this.maxLength) { throw new Error(`Text length exceeds maximum limit of ${this.maxLength} characters`); } return this._processor.process(text); } } // Text processing manager class TextProcessingManager { constructor() { this.processor = new SimpleTextProcessor(); this.history = []; } addCapitalization() { this.processor = new CapitalizeDecorator(this.processor); return this; } addTrimming() { this.processor = new TrimDecorator(this.processor); return this; } addHTMLEscaping() { this.processor = new HTMLEscapeDecorator(this.processor); return this; } addMarkdownProcessing() { this.processor = new MarkdownToHTMLDecorator(this.processor); return this; } addValidation(maxLength) { this.processor = new ValidationDecorator(this.processor, maxLength); return this; } process(text) { const result = this.processor.process(text); this.history.push({ input: text, output: result, timestamp: new Date() }); return result; } getProcessingHistory() { return this.history; } } // Usage example const manager = new TextProcessingManager(); // Configure text processing chain manager .addValidation(2000) .addTrimming() .addMarkdownProcessing() .addHTMLEscaping(); // Process some text try { const input = ` # Welcome to Text Processing This is a **bold** and *italic* text example. [Click here](https://example.com) to learn more. `; const result = manager.process(input); console.log("Processed text:"); console.log(result); console.log("\nProcessing history:"); console.log(manager.getProcessingHistory()); } catch (error) { console.error("Error processing text:", error.message); } 용어 정리 용어 설명 참고 및 출처 1. 주제의 분류가 적절한지에 대해 조사 Decorator Pattern(데코레이터 패턴) 은 “Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Structural Design Patterns” 분류에 정확히 해당합니다. GoF(Gang of Four) 에서 정의한 구조 (Structural) 패턴 중 하나로, 객체의 기능 확장에 특화된 패턴입니다 [1][2][20].
...</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decorator Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/decorator-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Adapter Pattern</h2></header><div class=entry-content><p>Adapter Pattern Adapter Pattern 은 기존의 인터페이스 (Adaptee) 를 클라이언트가 기대하는 인터페이스 (Target) 로 변환하는 구조 패턴이다. 어댑터 (Adapter) 는 Target 인터페이스를 구현하고 Adaptee 객체를 감싸 (합성) 거나 상속하여, 클라이언트가 요구하는 방식으로 기능을 제공한다. 이를 통해 기존 코드 수정 없이 다양한 외부 시스템, 레거시 코드, 라이브러리와의 통합이 가능하며, 코드의 재사용성과 유지보수성을 크게 높일 수 있다.
배경 현재 사용하고 있는 라이브러리가 더 이상 요구에 부합하지 않아 재작성하거나 다른 라이브러리를 사용해야 할 때, 어댑터 패턴을 이용해 기존 코드를 가능한 적게 변경하면서 새로운 라이브러리로 교체할 수 있다.
기존에 있는 시스템에 새로운 써드파티 라이브러리가 추가되거나 레거시 인터페이스를 새로운 인터페이스로 교체하는 경우에 코드의 재사용성을 높일 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-25 06:13:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;50 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adapter Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/adapter-pattern/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>