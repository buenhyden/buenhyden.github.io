<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Structural | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,Design-and-Architecture,Software-Design-Patterns,GoF,Structural"><meta name=description content="Structural
아래는 &ldquo;Structural(구조 패턴)&rdquo; 에 대한 체계적인 조사, 분석 및 정리 결과입니다.

1. 주제에 대한 태그

Structural-Pattern
Object-Composition
Class-Relationship
GoF-Design-Patterns

1. 태그 (영문, &lsquo;-&rsquo; 사용)

Structural-Patterns
Object-Composition
Interface-Adapter
GoF-Structural


2. 카테고리 계층 구조 분석
&ldquo;Structural&rdquo; 패턴은 Software Design Patterns > GoF > Structural 하위에 적합합니다.
근거: GoF 분류 체계에서는 Structural Patterns가 객체와 클래스 간의 조합과 관계에 초점을 맞춘 별도의 범주로 정의되며, Adapter, Facade, Bridge, Composite, Decorator, Proxy, Flyweight 등이 여기에 속합니다 (geeksforgeeks.org, refactoring.guru)."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Structural"><meta property="og:description" content="Structural 아래는 “Structural(구조 패턴)” 에 대한 체계적인 조사, 분석 및 정리 결과입니다.
1. 주제에 대한 태그 Structural-Pattern Object-Composition Class-Relationship GoF-Design-Patterns 1. 태그 (영문, ‘-’ 사용) Structural-Patterns Object-Composition Interface-Adapter GoF-Structural 2. 카테고리 계층 구조 분석 “Structural” 패턴은 Software Design Patterns > GoF > Structural 하위에 적합합니다.
근거: GoF 분류 체계에서는 Structural Patterns가 객체와 클래스 간의 조합과 관계에 초점을 맞춘 별도의 범주로 정의되며, Adapter, Facade, Bridge, Composite, Decorator, Proxy, Flyweight 등이 여기에 속합니다 (geeksforgeeks.org, refactoring.guru)."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Structural"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":5,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/"},{"@type":"ListItem","position":6,"name":"Structural","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/>GoF</a></div><h1>Structural</h1></header><div class=post-content><h2 id=structural>Structural<a hidden class=anchor aria-hidden=true href=#structural>#</a></h2><p>아래는 &ldquo;Structural(구조 패턴)&rdquo; 에 대한 체계적인 조사, 분석 및 정리 결과입니다.</p><hr><h2 id=1-주제에-대한-태그>1. 주제에 대한 태그<a hidden class=anchor aria-hidden=true href=#1-주제에-대한-태그>#</a></h2><ul><li><strong>Structural-Pattern</strong></li><li><strong>Object-Composition</strong></li><li><strong>Class-Relationship</strong></li><li><strong>GoF-Design-Patterns</strong></li></ul><h2 id=1-태그-영문---사용>1. 태그 (영문, &lsquo;-&rsquo; 사용)<a hidden class=anchor aria-hidden=true href=#1-태그-영문---사용>#</a></h2><ul><li>Structural-Patterns</li><li>Object-Composition</li><li>Interface-Adapter</li><li>GoF-Structural</li></ul><hr><h2 id=2-카테고리-계층-구조-분석>2. 카테고리 계층 구조 분석<a hidden class=anchor aria-hidden=true href=#2-카테고리-계층-구조-분석>#</a></h2><p>&ldquo;Structural&rdquo; 패턴은 <code>Software Design Patterns > GoF > Structural</code> 하위에 적합합니다.<br><strong>근거</strong>: GoF 분류 체계에서는 <strong>Structural Patterns</strong>가 객체와 클래스 간의 조합과 관계에 초점을 맞춘 별도의 범주로 정의되며, Adapter, Facade, Bridge, Composite, Decorator, Proxy, Flyweight 등이 여기에 속합니다 (<a href="https://www.geeksforgeeks.org/system-design/gang-of-four-gof-design-patterns/?utm_source=chatgpt.com" title="Gang of Four (GOF) Design Patterns - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://refactoring.guru/design-patterns/go?utm_source=chatgpt.com" title="Design Patterns in Go - Refactoring.Guru">refactoring.guru</a>).</p><h2 id=2-분류-구조-검토-및-근거>2. 분류 구조 검토 및 근거<a hidden class=anchor aria-hidden=true href=#2-분류-구조-검토-및-근거>#</a></h2><ul><li><p><strong>현재 분류 구조</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Computer Science and Engineering
</span></span><span class=line><span class=cl>└─ Software Engineering &gt; [Application Development, Design and Architecture, System Design, Quality Assurance and Testing, etc]
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>분류 적합성</strong></p><ul><li><strong>제시된 분류:</strong> &ldquo;Computer Science and Engineering > Software Engineering > Design and Architecture > Software Design Patterns > GoF&rdquo;</li><li><strong>분석:</strong><br>구조 패턴 (Structural Pattern) 은 객체 또는 클래스의 관계와 구조를 통해 유연한 설계와 재사용성을 높이는 GoF(갱 오브 포, Gang of Four) 디자인 패턴의 주요 카테고리입니다.<br>이는 소프트웨어 설계와 아키텍처에서 객체 간 결합, 확장, 유지보수성, 재사용성을 실현하는 데 핵심적이며, &ldquo;Design and Architecture > Software Design Patterns > GoF&rdquo; 하위에 포함하는 것이 매우 적절합니다.</li><li><strong>근거:</strong><ul><li>GoF 디자인 패턴은 크게 생성 (Creational), 구조 (Structural), 행위 (Behavioral) 로 분류되며, 구조 패턴은 객체 또는 클래스의 구조와 관계를 다루는 패턴들로 구성됩니다.</li><li>대부분의 소프트웨어 설계 및 디자인 패턴 관련 자료에서, 구조 패턴은 GoF 디자인 패턴의 하위 카테고리로 명확히 분류됩니다.</li></ul></li></ul></li></ul><h3 id=1-주제의-분류-적합성>1. 주제의 분류 적합성<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적합성>#</a></h3><p>&ldquo;Structural Design Patterns (구조 패턴)&rdquo; 은 &ldquo;Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF (Gang of Four)&rdquo; 분류에 매우 적합하다. 구조 패턴은 GoF 디자인 패턴의 세 가지 주요 분류 (생성, 구조, 행위) 중 하나로, 클래스와 객체의 관계 및 조합 방식을 다룬다 <a href="https://refactoring.guru/design-patterns/structural-patterns?utm_source=chatgpt.com" title="Structural Design Patterns - Refactoring.Guru">1</a>[4][18].</p><h2 id=1-주제의-분류-적절성-검토>1. 주제의 분류 적절성 검토<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적절성-검토>#</a></h2><p><strong>적절함</strong>: 구조 패턴은 GoF(Gang of Four) 에서 정의한 23 개의 디자인 패턴 중 하나로, &ldquo;Software Design and Architecture&rdquo; > &ldquo;Software Design Patterns&rdquo; > &ldquo;GoF&rdquo; 분류에 속합니다. 이는 객체 지향 설계의 핵심 원칙 중 하나인 객체 간의 관계를 다루므로, 해당 분류는 매우 적절합니다.</p><h2 id=1-주제-분류-검토>1. 주제 분류 검토<a hidden class=anchor aria-hidden=true href=#1-주제-분류-검토>#</a></h2><p>주제의 분류 &ldquo;Computer Science and Engineering&rdquo; > &ldquo;Software Design and Architecture&rdquo; > &ldquo;Software Design Patterns&rdquo; > &ldquo;GoF&rdquo; 는 <strong>적절합니다</strong>. Structural Design Patterns 는 GoF(Gang of Four) 디자인 패턴의 핵심 분류 중 하나로, 클래스와 객체의 조합을 다루는 소프트웨어 설계와 아키텍처 영역의 중요한 개념입니다.</p><h2 id=2-요약-문장-200-자-내외>2. 요약 문장 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-문장-200-자-내외>#</a></h2><p>Structural Design Patterns(구조적 디자인 패턴) 는 클래스와 객체를 조합하여 더 큰 구조를 형성하는 방법을 다루는 디자인 패턴 분류입니다. GoF 에서 정의한 7 가지 패턴 (Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy) 을 포함하며, 이러한 구조를 유연하고 효율적으로 유지하면서 복잡한 관계를 단순화하고 코드의 재사용성과 유지보수성을 향상시키는 것이 목적입니다.</p><h2 id=2-요약-문장-200-자-내외-1>2. 요약 문장 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-문장-200-자-내외-1>#</a></h2><p>구조 패턴은 객체와 클래스의 조합을 통해 더 큰 구조를 형성하는 방법을 제공하여, 시스템의 유연성과 효율성을 높이는 디자인 패턴입니다. 이를 통해 코드의 재사용성과 유지보수성이 향상됩니다.</p><h2 id=3-주제-요약-200-자-내외>3. 주제 요약 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#3-주제-요약-200-자-내외>#</a></h2><p>구조 패턴은 객체 또는 클래스의 관계와 구조를 통해 유연한 설계와 재사용성을 높이는 GoF 디자인 패턴의 한 분류로, 객체 간 결합과 확장성을 구조화합니다.</p><h2 id=3-주제-요약-200-자>3. 주제 요약 (≈200 자)<a hidden class=anchor aria-hidden=true href=#3-주제-요약-200-자>#</a></h2><p>GoF Structural Patterns 는 <strong>객체와 클래스 간의 관계를 구성하고 조합하는 설계 기법</strong>으로, 유연성과 유지보수성을 강화합니다. 이 패턴들은 Adapter 를 통한 인터페이스 호환, Bridge 를 통한 추상화 구현 분리, Composite 를 통한 트리 구조 관리, Decorator 로 기능 동적 추가, Facade 를 통한 서브시스템 단순화, Flyweight 로 메모리 최적화, Proxy 로 접근 제어 등을 통해 구조적 문제를 해결합니다 (<a href="https://refactoring.guru/design-patterns/structural-patterns?utm_source=chatgpt.com" title="Structural Design Patterns - Refactoring.Guru">refactoring.guru</a>).</p><h3 id=2-200-자-요약>2. 200 자 요약<a hidden class=anchor aria-hidden=true href=#2-200-자-요약>#</a></h3><p>구조 디자인 패턴 (Structural Design Patterns) 은 클래스와 객체를 유연하고 효율적으로 조합하여 더 큰 구조를 만드는 방법을 제공한다. 이 패턴은 코드의 재사용성, 확장성, 유지보수성을 높이고, 복잡한 시스템의 결합도를 낮추는 데 핵심적인 역할을 한다 <a href="https://www.geeksforgeeks.org/structural-design-patterns/?ref=shm&amp;utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">5</a><a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">7</a>.</p><hr><h3 id=3-전체-개요-250-자-내외>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외>#</a></h3><p>구조 디자인 패턴은 객체지향 소프트웨어에서 클래스와 객체의 조합, 관계, 계층 구조를 효율적으로 설계하기 위한 패턴이다. Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy 등 7 가지가 대표적이며, 각 패턴은 시스템의 복잡성을 줄이고, 코드의 유연성과 확장성을 높인다. 구조 패턴을 활용하면 다양한 객체와 클래스가 상호작용하는 복잡한 시스템에서도 일관성 있고 유지보수하기 쉬운 아키텍처를 설계할 수 있다 <a href="https://medium.com/%40anudeepballa7/understanding-structural-design-patterns-why-how-and-when-they-are-useful-fa70a84f4ebc?utm_source=chatgpt.com" title="Understanding Structural Design Patterns: Why, How, and When …">4</a>[7][18].</p><h2 id=4-전체-개요-250-자>4. 전체 개요 (≈250 자)<a hidden class=anchor aria-hidden=true href=#4-전체-개요-250-자>#</a></h2><p>Structural Design Patterns 는 소프트웨어 설계에서 <strong>객체 및 클래스 구조의 조합과 관계 맺음</strong>을 중심으로, 효율적이고 유연한 구조 구축을 돕는 패턴 집합입니다. Adapter 는 이질적 인터페이스를 연결하고, Bridge 는 추상화와 구현을 분리하며, Composite 는 계층적 구조를 관리합니다. Decorator 는 동적으로 기능을 확장하고, Facade 는 복잡한 서브시스템을 단순화하며, Flyweight 는 메모리 공유를 통한 최적화를, Proxy 는 접근 제어 및 지연 초기화를 제공합니다. 이를 통해 코드 변경 없이 확장, 재사용, 관리가 용이한 구조를 설계할 수 있습니다 (<a href="https://refactoring.guru/design-patterns/structural-patterns?utm_source=chatgpt.com" title="Structural Design Patterns - Refactoring.Guru">refactoring.guru</a>).</p><h2 id=4-전체-개요-250-자-내외>4. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#4-전체-개요-250-자-내외>#</a></h2><p>구조 패턴 (Structural Pattern) 은 객체 또는 클래스의 관계와 구조를 통해 유연한 설계와 재사용성을 높이는 GoF 디자인 패턴의 한 분류입니다. 대표적으로 Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy 패턴이 포함됩니다.</p><h2 id=3-개요-250-자-내외>3. 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-개요-250-자-내외>#</a></h2><p>구조 패턴은 객체와 클래스의 조합을 통해 더 큰 구조를 형성하는 방법을 제공하여, 시스템의 유연성과 효율성을 높이는 디자인 패턴입니다. 이러한 패턴은 객체 간의 관계를 단순화하고, 코드의 재사용성과 유지보수성을 향상시키는 데 중점을 둡니다. 대표적인 구조 패턴으로는 어댑터 (Adapter), 브리지 (Bridge), 컴포지트 (Composite), 데코레이터 (Decorator), 퍼사드 (Facade), 플라이웨이트 (Flyweight), 프록시 (Proxy) 등이 있습니다.(<a href="https://bepatterns.com/what-are-structural-design-patterns/?utm_source=chatgpt.com" title="What are Structural Design Patterns? - BePatterns">Free Crochet patterns</a>)</p><h2 id=3-전체-개요-250-자-내외-1>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외-1>#</a></h2><p>Structural Design Patterns 는 소프트웨어 개발에서 클래스와 객체 간의 관계와 구성을 최적화하는 검증된 솔루션입니다. 1994 년 GoF 가 정의한 23 개 패턴 중 7 개를 포함하며, 서로 다른 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 도와줍니다. 이 패턴들은 상속과 객체 합성을 활용하여 추상화를 생성하고, 복잡한 시스템을 단순한 인터페이스로 감싸거나, 객체들을 트리 구조로 조합하는 등의 기능을 제공합니다. 현대 소프트웨어 아키텍처에서 모듈성과 확장성을 보장하는 핵심 개념입니다.</p><h2 id=4-핵심-개념>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념>#</a></h2><h3 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h3><ul><li><strong>객체 합성 (Object Composition)</strong>: 여러 객체를 결합하여 새로운 기능을 만드는 방식</li><li><strong>구조적 추상화 (Structural Abstraction)</strong>: 복잡한 시스템을 단순한 인터페이스로 감싸는 기법</li><li><strong>어댑터 (Adapter)</strong>: 호환되지 않는 인터페이스를 연결하는 중간 계층</li><li><strong>래퍼 (Wrapper)</strong>: 기존 객체를 감싸서 새로운 인터페이스를 제공하는 패턴</li></ul><h3 id=심화-개념>심화 개념<a hidden class=anchor aria-hidden=true href=#심화-개념>#</a></h3><ul><li><strong>브리지 패턴 (Bridge Pattern)</strong>: 추상화와 구현을 분리하여 독립적 변화 허용</li><li><strong>컴포지트 패턴 (Composite Pattern)</strong>: 부분 - 전체 계층 구조를 트리로 표현</li><li><strong>플라이웨이트 패턴 (Flyweight Pattern)</strong>: 메모리 효율성을 위한 객체 공유 메커니즘</li><li><strong>데코레이터 체이닝 (Decorator Chaining)</strong>: 여러 데코레이터를 연쇄적으로 적용하는 기법</li></ul><h2 id=4-핵심-개념-1>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념-1>#</a></h2><h3 id=정의>정의<a hidden class=anchor aria-hidden=true href=#정의>#</a></h3><p>구조 패턴은 객체와 클래스의 조합을 통해 더 큰 구조를 형성하는 방법을 제공하여, 시스템의 유연성과 효율성을 높이는 디자인 패턴입니다. 이러한 패턴은 객체 간의 관계를 단순화하고, 코드의 재사용성과 유지보수성을 향상시키는 데 중점을 둡니다.</p><h3 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h3><ul><li><p>객체 간의 관계를 단순화하여 시스템의 구조를 명확하게 함</p></li><li><p>코드의 재사용성과 유지보수성을 향상시킴</p></li><li><p>시스템의 유연성과 확장성을 높임</p></li></ul><h3 id=필요성>필요성<a hidden class=anchor aria-hidden=true href=#필요성>#</a></h3><ul><li><p>복잡한 시스템에서 객체 간의 관계를 명확하게 정의하고 관리하기 위해</p></li><li><p>코드의 중복을 줄이고 재사용성을 높이기 위해</p></li><li><p>시스템의 유지보수성과 확장성을 향상시키기 위해</p></li></ul><h2 id=5-핵심-개념>5. 핵심 개념<a hidden class=anchor aria-hidden=true href=#5-핵심-개념>#</a></h2><ul><li><strong>정의</strong><br>구조 패턴 (Structural Pattern) 은 객체 또는 클래스의 관계와 구조를 통해 유연한 설계와 재사용성을 높이는 GoF 디자인 패턴의 한 분류입니다.</li><li><strong>목적 및 필요성</strong><ul><li><strong>객체 간 결합:</strong> 객체 간 결합을 구조화하여 복잡성을 낮춥니다.</li><li><strong>확장성:</strong> 새로운 기능을 쉽게 추가할 수 있습니다.</li><li><strong>재사용성:</strong> 기존 객체 또는 클래스를 재사용할 수 있습니다.</li></ul></li><li><strong>실무 연관성</strong><ul><li><strong>실무에서는 기존 코드의 재사용, 인터페이스 호환, 기능 확장 등 다양한 시나리오에서 구조 패턴이 필수적으로 활용됩니다.</strong></li><li><strong>Adapter, Decorator, Composite 등은 실무에서 매우 빈번히 사용됩니다.</strong></li><li><strong>구조 패턴은 프론트엔드, 백엔드, 게임, 임베디드 등 다양한 도메인에서 적용됩니다.</strong></li></ul></li></ul><h2 id=-핵심-개념>🔑 핵심 개념<a hidden class=anchor aria-hidden=true href=#-핵심-개념>#</a></h2><p>Structural Patterns 는 객체와 클래스 간 <strong>관계 구성 (composition)</strong> 을 통해 복잡한 시스템을 단순화하고, <strong>인터페이스 호환성</strong>과 <strong>기능 확장성</strong>을 보장하는 설계 기법입니다 (<a href="https://www.geeksforgeeks.org/system-design/gang-of-four-gof-design-patterns/?utm_source=chatgpt.com" title="Gang of Four (GOF) Design Patterns - GeeksforGeeks">en.wikipedia.org</a>, <a href="https://refactoring.guru/design-patterns/go?utm_source=chatgpt.com" title="Design Patterns in Go - Refactoring.Guru">dev.to</a>).<br>주요 패턴으로 <strong>Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy</strong>가 포함됩니다 (<a href="https://refactoring.guru/design-patterns/structural-patterns?utm_source=chatgpt.com" title="Structural Design Patterns - Refactoring.Guru">refactoring.guru</a>).</p><h2 id=4-핵심-개념-2>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념-2>#</a></h2><ul><li><strong>정의</strong>: 구조 디자인 패턴은 객체와 클래스의 조합 방식, 즉 구조적 관계를 정의하여 시스템의 유연성과 효율성을 높이는 설계 패턴이다 <a href="https://www.geeksforgeeks.org/structural-design-patterns/?ref=shm&amp;utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">5</a><a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">7</a>.</li><li><strong>목적</strong>: 클래스와 객체를 결합하고, 복잡한 시스템을 단순화하며, 결합도를 낮추고, 코드 재사용성을 극대화한다.</li><li><strong>주요 패턴</strong>: Adapter(어댑터), Bridge(브릿지), Composite(컴포지트), Decorator(데코레이터), Facade(파사드), Flyweight(플라이웨이트), Proxy(프록시)<a href="https://medium.com/%40anudeepballa7/understanding-structural-design-patterns-why-how-and-when-they-are-useful-fa70a84f4ebc?utm_source=chatgpt.com" title="Understanding Structural Design Patterns: Why, How, and When …">4</a>[7][18].</li><li><strong>적용 시점</strong>: 여러 객체가 협력해야 하거나, 기존 코드 변경 없이 새로운 기능을 추가해야 하거나, 복잡한 인터페이스를 단순화해야 할 때 사용된다.</li><li><strong>실무적 중요성</strong>: 대규모 시스템에서 구조적 복잡성을 줄이고, 유지보수와 확장성을 보장한다.</li></ul><h3 id=배경-및-필요성>배경 및 필요성<a hidden class=anchor aria-hidden=true href=#배경-및-필요성>#</a></h3><ul><li>객체와 클래스가 복잡하게 얽혀 있을 때, 구조 패턴은 이들의 관계를 단순화하고 결합도를 낮춰 유지보수와 확장성을 높인다 <a href="https://www.geeksforgeeks.org/structural-design-patterns/?ref=shm&amp;utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">5</a><a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">7</a>.</li><li>시스템이 커질수록 구조적 복잡성이 증가하므로, 이를 체계적으로 관리하는 것이 필수적이다.</li></ul><h2 id=-배경--목적>🧬 배경 & 목적<a hidden class=anchor aria-hidden=true href=#-배경--목적>#</a></h2><ul><li><strong>배경</strong>: 복잡한 서브시스템, 비호환 인터페이스 증가, 중복 코드 등의 구조적 복잡성 해결 필요성 대두 (<a href="https://refactoring.guru/design-patterns/structural-patterns?utm_source=chatgpt.com" title="Structural Design Patterns - Refactoring.Guru">refactoring.guru</a>).</li><li><strong>목적</strong>:<ul><li>클래스 간 상속보다 <strong>조합 (composition)</strong> 을 통한 느슨한 결합 실현</li><li>인터페이스 호환성 제공 (<code>Adapter</code>)</li><li>기능 확장/변경의 유연성 (<code>Decorator</code>, <code>Bridge</code>)</li><li>메모리/성능 최적화 (<code>Flyweight</code>)</li><li>시스템 복잡성 폐쇄 공간 (<code>Facade</code>), 접근 제어 (<code>Proxy</code>)</li></ul></li></ul><h3 id=1-배경>1) 배경<a hidden class=anchor aria-hidden=true href=#1-배경>#</a></h3><ul><li><strong>문제 상황:</strong><ul><li>객체 간 결합이 복잡하거나, 기존 코드의 재사용이 어려운 경우, 유지보수와 확장성이 저하됩니다.</li></ul></li><li><strong>해결 방안:</strong><ul><li>구조 패턴을 통해 객체 간 관계와 구조를 구조화하고, 기존 코드를 재사용하거나 확장할 수 있게 합니다.</li></ul></li></ul><h3 id=목적-및-역할>목적 및 역할<a hidden class=anchor aria-hidden=true href=#목적-및-역할>#</a></h3><ul><li>코드 재사용성, 모듈화, 결합도 감소, 시스템의 일관성 유지, 복잡성 완화 <a href="https://www.geeksforgeeks.org/structural-design-patterns/?ref=shm&amp;utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">5</a>[16].</li><li>인터페이스 호환성 확보, 동적 기능 추가, 효율적 자원 관리 등 다양한 목적에 따라 사용된다.</li></ul><h3 id=2-목적-및-필요성>2) 목적 및 필요성<a hidden class=anchor aria-hidden=true href=#2-목적-및-필요성>#</a></h3><ul><li><strong>객체 간 결합 구조화:</strong><ul><li>객체 간 결합을 구조화하여 복잡성을 낮춥니다.</li></ul></li><li><strong>확장성:</strong><ul><li>새로운 기능을 쉽게 추가할 수 있습니다.</li></ul></li><li><strong>재사용성:</strong><ul><li>기존 객체 또는 클래스를 재사용할 수 있습니다.</li></ul></li></ul><h3 id=배경-및-목적>배경 및 목적<a hidden class=anchor aria-hidden=true href=#배경-및-목적>#</a></h3><p>Structural Design Patterns 는 1994 년 GoF(Gang of Four) 에 의해 체계화되었습니다. 이들은 대규모 객체지향 시스템 개발 경험을 바탕으로 클래스와 객체의 구성에서 반복적으로 나타나는 문제들을 해결하는 패턴들을 정의했습니다.</p><p><strong>주요 목적:</strong></p><ul><li>서로 다른 인터페이스를 가진 클래스들의 협업 지원</li><li>복잡한 시스템의 단순화된 인터페이스 제공</li><li>객체 구성의 유연성 향상</li><li>메모리 사용량 최적화</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><table><thead><tr><th>기능</th><th>설명</th></tr></thead><tbody><tr><td>인터페이스 적응</td><td>호환되지 않는 인터페이스 간의 브리지 역할</td></tr><tr><td>구조 단순화</td><td>복잡한 서브시스템을 단순한 인터페이스로 감싸기</td></tr><tr><td>동적 기능 확장</td><td>런타임에 객체의 행동 추가/변경</td></tr><tr><td>계층 구조 관리</td><td>부분 - 전체 관계를 일관되게 처리</td></tr><tr><td>리소스 공유</td><td>유사한 객체들 간의 상태 공유로 메모리 절약</td></tr></tbody></table><h3 id=3-주요-기능-및-역할>3) 주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#3-주요-기능-및-역할>#</a></h3><ul><li><strong>객체 간 결합 구조화:</strong><ul><li>객체 간 관계와 구조를 패턴으로 구조화합니다.</li></ul></li><li><strong>기능 확장:</strong><ul><li>새로운 기능을 쉽게 추가할 수 있습니다.</li></ul></li><li><strong>코드 재사용:</strong><ul><li>기존 코드를 재사용할 수 있습니다.</li></ul></li></ul><h2 id=-주요-기능--역할>🔧 주요 기능 & 역할<a hidden class=anchor aria-hidden=true href=#-주요-기능--역할>#</a></h2><table><thead><tr><th>패턴</th><th>역할 요약</th></tr></thead><tbody><tr><td><strong>Adapter</strong></td><td>인터페이스를 호환시켜 기존 클래스 재사용</td></tr><tr><td><strong>Bridge</strong></td><td>추상화와 구현 독립 유지, 런타임 구현 교체</td></tr><tr><td><strong>Composite</strong></td><td>단일 객체와 그룹 객체를 동일하게 다룸</td></tr><tr><td><strong>Decorator</strong></td><td>객체에 동적 기능 추가, 서브클래스 폭발 방지</td></tr><tr><td><strong>Facade</strong></td><td>복잡한 서브시스템 기능을 단일 인터페이스로 단순화</td></tr><tr><td><strong>Flyweight</strong></td><td>공유 가능한 불변 상태 객체로 메모리 최적화</td></tr><tr><td><strong>Proxy</strong></td><td>대상 객체에 접근 제어, 지연 초기화, 로깅 기능 추가</td></tr></tbody></table><hr><h2 id=-특징>⭐ 특징<a hidden class=anchor aria-hidden=true href=#-특징>#</a></h2><ul><li><strong>객체 조합 중심 구조</strong>: 상속보다 유연하고 모듈화 용이 (<a href="https://www.geeksforgeeks.org/system-design/gang-of-four-gof-design-patterns/?utm_source=chatgpt.com" title="Gang of Four (GOF) Design Patterns - GeeksforGeeks">en.wikipedia.org</a>, <a href="https://www.youtube.com/watch?v=WxGtmIBZszk&amp;utm_source=chatgpt.com" title="32. All Structural Design Patterns | Decorator, Proxy, Composite …">youtube.com</a>, <a href="https://medium.com/%40anudeepballa7/understanding-structural-design-patterns-why-how-and-when-they-are-useful-fa70a84f4ebc?utm_source=chatgpt.com" title="Understanding Structural Design Patterns: Why, How, and When …">medium.com</a>, <a href="https://www.geeksforgeeks.org/structural-design-patterns/?ref=shm&amp;utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">geeksforgeeks.org</a>)</li><li><strong>느슨한 결합 (loose coupling)</strong>: 클라이언트는 인터페이스에만 의존</li><li><strong>확장성</strong>: 기능 추가 시 기존 코드 변경 최소화</li><li><strong>메모리/성능 고려된 구조 제공</strong> (<code>Flyweight</code>, <code>Proxy</code>)</li></ul><h3 id=4-특징>4) 특징<a hidden class=anchor aria-hidden=true href=#4-특징>#</a></h3><ul><li><strong>유연성:</strong><ul><li>객체 간 결합을 구조화하여 유연성을 높입니다.</li></ul></li><li><strong>확장성:</strong><ul><li>새로운 기능을 쉽게 추가할 수 있습니다.</li></ul></li><li><strong>재사용성:</strong><ul><li>기존 코드를 재사용할 수 있습니다.</li></ul></li></ul><h3 id=특징-및-핵심-원칙>특징 및 핵심 원칙<a hidden class=anchor aria-hidden=true href=#특징-및-핵심-원칙>#</a></h3><ul><li>객체 합성 (Composition) 과 상속 (Inheritance) 의 조화</li><li>느슨한 결합 (Loose Coupling)</li><li>OCP(개방 - 폐쇄 원칙), SRP(단일 책임 원칙) 등 객체지향 원칙과 밀접한 연관</li><li>구조적 일관성, 계층화, 인터페이스 추상화</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p><strong>핵심 특징:</strong></p><ul><li>클래스와 객체 조합의 최적화</li><li>런타임 구성의 유연성</li><li>상속보다 합성 선호</li><li>인터페이스 통일성 보장</li></ul><p><strong>기술적 특징:</strong></p><ul><li>래퍼 패턴의 광범위한 활용</li><li>재귀적 구조 지원</li><li>프록시를 통한 접근 제어</li><li>메모리 사용량 최적화</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ol><li><strong>합성을 통한 구조 생성</strong></li><li><strong>인터페이스 일관성 유지</strong></li><li><strong>복잡성 캡슐화</strong></li><li><strong>런타임 유연성 확보</strong></li></ol><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><ul><li><strong>Adapter</strong>: 호환되지 않는 인터페이스를 변환하여 연결</li><li><strong>Bridge</strong>: 추상화와 구현을 분리</li><li><strong>Composite</strong>: 트리 구조로 부분 - 전체 계층 표현</li><li><strong>Decorator</strong>: 객체에 동적으로 기능 추가</li><li><strong>Facade</strong>: 복잡한 서브시스템을 단순화된 인터페이스로 제공</li><li><strong>Flyweight</strong>: 공유 객체를 사용해 메모리 절약</li><li><strong>Proxy</strong>: 객체 접근 제어 및 대리 기능 제공 <a href="https://www.youtube.com/watch?v=WxGtmIBZszk&amp;utm_source=chatgpt.com" title="32. All Structural Design Patterns | Decorator, Proxy, Composite …">2</a><a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">5</a>[18]</li></ul><h4 id=주요-원리-다이어그램-예시-composite-pattern>주요 원리 다이어그램 예시 (Composite Pattern)<a hidden class=anchor aria-hidden=true href=#주요-원리-다이어그램-예시-composite-pattern>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Component
</span></span><span class=line><span class=cl>   /      \
</span></span><span class=line><span class=cl>Leaf    Composite
</span></span><span class=line><span class=cl>             |
</span></span><span class=line><span class=cl>           Leaf
</span></span></code></pre></td></tr></table></div></div><ul><li><code>Component</code> 는 공통 인터페이스, <code>Leaf</code> 는 단일 객체, <code>Composite</code> 은 복수 객체를 트리 구조로 관리 <a href="https://en.wikipedia.org/wiki/Decorator_pattern?utm_source=chatgpt.com" title="Decorator pattern">8</a>.</li></ul><h3 id=5-핵심-원칙>5) 핵심 원칙<a hidden class=anchor aria-hidden=true href=#5-핵심-원칙>#</a></h3><ul><li><strong>캡슐화:</strong><ul><li>객체 또는 클래스의 구조와 관계를 캡슐화합니다.</li></ul></li><li><strong>분리:</strong><ul><li>객체 간 결합을 구조화하여 복잡성을 낮춥니다.</li></ul></li><li><strong>확장성:</strong><ul><li>새로운 기능을 쉽게 추가할 수 있어야 합니다.</li></ul></li></ul><h2 id=-핵심-원칙>⚖️ 핵심 원칙<a hidden class=anchor aria-hidden=true href=#-핵심-원칙>#</a></h2><ul><li><strong>Composition over Inheritance</strong>: 조합을 통한 유연하고 동적인 기능 확장</li><li><strong>Program to interface not implementation</strong>: 인터페이스 기반 설계</li><li><strong>Single Responsibility Principle</strong>: 각 클래스의 책임을 분리</li><li><strong>Open‑Closed Principle</strong>: 확장에는 열려 있지만 수정에는 닫혀 있음</li></ul><hr><h2 id=-작동-원리--시각-다이어그램>⚙️ 작동 원리 & 시각 다이어그램<a hidden class=anchor aria-hidden=true href=#-작동-원리--시각-다이어그램>#</a></h2><h3 id=1-adapter-pattern>1) Adapter Pattern<a hidden class=anchor aria-hidden=true href=#1-adapter-pattern>#</a></h3><pre class=mermaid>classDiagram
    class Target {
        +request()
    }
    class Adaptee {
        +specificRequest()
    }
    class Adapter {
        -adaptee: Adaptee
        +request()
    }
    Target &lt;|-- Adapter
    Adapter --&gt; Adaptee
</pre><ul><li><strong>Adapter</strong>는 <code>Target</code> 인터페이스를 구현하고 내부에서 <code>Adaptee</code> 의 <code>specificRequest()</code> 를 호출해 인터페이스를 맞춥니다.</li></ul><hr><h3 id=2-decorator-pattern>2) Decorator Pattern<a hidden class=anchor aria-hidden=true href=#2-decorator-pattern>#</a></h3><pre class=mermaid>sequenceDiagram
    participant Client
    participant DecoratorA
    participant DecoratorB
    participant Core
    Client-&gt;&gt;DecoratorA: operation()
    DecoratorA-&gt;&gt;DecoratorB: operation()
    DecoratorB-&gt;&gt;Core: operation()
    Core--&gt;&gt;DecoratorB: result
    DecoratorB--&gt;&gt;DecoratorA: result
    DecoratorA--&gt;&gt;Client: result
</pre><ul><li>여러 <strong>Decorator</strong>가 <strong>Core</strong> 컴포넌트를 래핑 (wrap) 하여 <strong>기능을 층층이 추가</strong>하며, 동적으로 특정 객체에 기능을 조합할 수 있습니다 (<a href="https://en.wikipedia.org/wiki/Decorator_pattern?utm_source=chatgpt.com" title="Decorator pattern">en.wikipedia.org</a>, <a href="https://en.wikipedia.org/wiki/Bridge_pattern?utm_source=chatgpt.com" title="Bridge pattern">en.wikipedia.org</a>, <a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://www.tutorialspoint.com/design_pattern/design_pattern_overview.htm?utm_source=chatgpt.com" title="Design Patterns Overview - Tutorialspoint">tutorialspoint.com</a>).</li></ul><h3 id=6-주요-원리-및-작동-원리>6) 주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#6-주요-원리-및-작동-원리>#</a></h3><ul><li><p><strong>작동 원리 다이어그램 예시 (Adapter 패턴)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Client] --&gt; [Target]
</span></span><span class=line><span class=cl>                   ^
</span></span><span class=line><span class=cl>                   |
</span></span><span class=line><span class=cl>              [Adapter] --&gt; [Adaptee]
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>Client:</strong> 기존 코드</li><li><strong>Target:</strong> 새로운 인터페이스</li><li><strong>Adapter:</strong> 기존 코드와 새로운 인터페이스를 연결</li><li><strong>Adaptee:</strong> 기존 코드</li></ul></li></ul><h3 id=주요-원리-및-작동-원리-1>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리-1>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[클라이언트] → [구조적 패턴] → [대상 객체들]
</span></span><span class=line><span class=cl>     ↓              ↓              ↓
</span></span><span class=line><span class=cl>  요청 전송      구조적 변환       실제 처리
</span></span><span class=line><span class=cl>     ↓              ↓              ↓
</span></span><span class=line><span class=cl>  단일 인터페이스   복잡성 은폐      기능 수행
</span></span></code></pre></td></tr></table></div></div><p><strong>작동 다이어그램:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>     클라이언트 코드
</span></span><span class=line><span class=cl>          ↓
</span></span><span class=line><span class=cl>    ┌─────────────┐
</span></span><span class=line><span class=cl>    │   Facade    │ ← 단순화된 인터페이스
</span></span><span class=line><span class=cl>    └─────────────┘
</span></span><span class=line><span class=cl>          ↓
</span></span><span class=line><span class=cl>    ┌─────────────┐
</span></span><span class=line><span class=cl>    │  Adapter    │ ← 인터페이스 변환
</span></span><span class=line><span class=cl>    └─────────────┘
</span></span><span class=line><span class=cl>          ↓
</span></span><span class=line><span class=cl>    ┌─────────────┐
</span></span><span class=line><span class=cl>    │ Composite   │ ← 트리 구조 관리
</span></span><span class=line><span class=cl>    └─────────────┘
</span></span><span class=line><span class=cl>          ↓
</span></span><span class=line><span class=cl>     실제 구현체들
</span></span></code></pre></td></tr></table></div></div><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=필수-구성요소>필수 구성요소<a hidden class=anchor aria-hidden=true href=#필수-구성요소>#</a></h4><table><thead><tr><th>구성요소</th><th>역할</th><th>기능</th></tr></thead><tbody><tr><td>클라이언트 (Client)</td><td>패턴 사용자</td><td>구조적 패턴을 통해 서비스 요청</td></tr><tr><td>추상화 (Abstraction)</td><td>인터페이스 정의</td><td>클라이언트가 사용할 통합 인터페이스 제공</td></tr><tr><td>어댑티 (Adaptee)</td><td>기존 구현체</td><td>기존에 존재하는 클래스나 시스템</td></tr><tr><td>래퍼 (Wrapper)</td><td>구조적 변환자</td><td>기존 객체를 감싸서 새로운 인터페이스 제공</td></tr></tbody></table><h4 id=선택-구성요소>선택 구성요소<a hidden class=anchor aria-hidden=true href=#선택-구성요소>#</a></h4><table><thead><tr><th>구성요소</th><th>역할</th><th>특징</th></tr></thead><tbody><tr><td>컨텍스트 (Context)</td><td>플라이웨이트 관리</td><td>외부 상태 관리 및 플라이웨이트 공유</td></tr><tr><td>팩토리 (Factory)</td><td>플라이웨이트 생성</td><td>플라이웨이트 인스턴스의 생성과 관리</td></tr><tr><td>리프 (Leaf)</td><td>컴포지트 말단</td><td>컴포지트 구조의 개별 요소</td></tr><tr><td>브리지 (Bridge)</td><td>추상화 - 구현 연결</td><td>추상화와 구현 간의 연결고리</td></tr></tbody></table><h3 id=7-구조-및-아키텍처>7) 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#7-구조-및-아키텍처>#</a></h3><ul><li><strong>구성 요소</strong><ul><li><strong>Client:</strong> 기존 코드 또는 새로운 코드</li><li><strong>Target:</strong> 새로운 인터페이스 또는 기능</li><li><strong>Adapter:</strong> 기존 코드와 새로운 인터페이스를 연결</li><li><strong>Adaptee:</strong> 기존 코드 또는 기능</li></ul></li><li><strong>필수 구성요소</strong><ul><li><strong>Client, Target, Adapter</strong></li></ul></li><li><strong>선택 구성요소</strong><ul><li><strong>Adaptee:</strong> 기존 코드 또는 기능</li></ul></li></ul><h2 id=7-구조-및-아키텍처--구성-요소>7. 구조 및 아키텍처 + 구성 요소<a hidden class=anchor aria-hidden=true href=#7-구조-및-아키텍처--구성-요소>#</a></h2><p>아래는 <strong>Composite</strong> 패턴의 구조 예시로, 구조 및 아키텍처와 구성 요소를 설명합니다.</p><pre class=mermaid>classDiagram
    class Component {
        +operation()
        +add(c: Component)
        +remove(c: Component)
        +getChild(i): Component
    }
    class Leaf
    class Composite

    Component &lt;|-- Leaf
    Component &lt;|-- Composite
    Composite o-- Component : children
</pre><ul><li><strong>Component</strong>: 공통 인터페이스 (<code>operation</code>, <code>add</code>, <code>remove</code>, <code>getChild</code>) 정의</li><li><strong>Leaf</strong>: 실제 작업을 수행하는 노드, <code>operation()</code> 구현</li><li><strong>Composite</strong>: 자식 (Component) 을 관리하며 <code>operation()</code> 호출 시 각 자식에게 위임</li></ul><h3 id=구조-및-아키텍처-1>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처-1>#</a></h3><h4 id=필수-구성요소-및-역할>필수 구성요소 및 역할<a hidden class=anchor aria-hidden=true href=#필수-구성요소-및-역할>#</a></h4><table><thead><tr><th>구성요소</th><th>기능/역할</th></tr></thead><tbody><tr><td>Component</td><td>공통 인터페이스 또는 추상 클래스 정의</td></tr><tr><td>ConcreteComponent</td><td>실제 기능을 구현하는 클래스</td></tr><tr><td>Decorator</td><td>기능을 동적으로 추가하는 래퍼 클래스</td></tr><tr><td>Adapter</td><td>호환되지 않는 인터페이스를 변환하는 클래스</td></tr><tr><td>Facade</td><td>복잡한 서브시스템을 단순화하는 인터페이스 제공</td></tr><tr><td>Proxy</td><td>원본 객체에 대한 접근을 제어하는 대리 객체</td></tr><tr><td>Flyweight</td><td>공유 가능한 객체의 상태를 관리</td></tr><tr><td>Composite</td><td>트리 구조에서 복수 객체를 관리하며, 클라이언트가 단일 객체처럼 다룸</td></tr><tr><td>Bridge</td><td>추상화와 구현을 분리하여 독립적으로 확장 가능</td></tr></tbody></table><h4 id=선택-구성요소-및-역할>선택 구성요소 및 역할<a hidden class=anchor aria-hidden=true href=#선택-구성요소-및-역할>#</a></h4><table><thead><tr><th>구성요소</th><th>기능/역할</th></tr></thead><tbody><tr><td>Client</td><td>구조 패턴을 사용하는 주체, 인터페이스만 알고 구현체는 모름</td></tr><tr><td>Implementor</td><td>Bridge 패턴에서 실제 구현을 담당하는 인터페이스</td></tr><tr><td>ConcreteImplementor</td><td>Bridge 패턴에서 실제 구현체</td></tr></tbody></table><h4 id=구조-다이어그램-예시-adapter-pattern>구조 다이어그램 예시 (Adapter Pattern)<a hidden class=anchor aria-hidden=true href=#구조-다이어그램-예시-adapter-pattern>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client ---&gt; Target (Interface)
</span></span><span class=line><span class=cl>                 ^
</span></span><span class=line><span class=cl>                 |
</span></span><span class=line><span class=cl>             Adapter
</span></span><span class=line><span class=cl>                 |
</span></span><span class=line><span class=cl>           Adaptee (기존 클래스)
</span></span></code></pre></td></tr></table></div></div><ul><li>Client 는 Target 인터페이스만 알고, Adapter 가 Adaptee 를 감싸서 호환성 제공 <a href="https://medium.com/%40anudeepballa7/understanding-structural-design-patterns-why-how-and-when-they-are-useful-fa70a84f4ebc?utm_source=chatgpt.com" title="Understanding Structural Design Patterns: Why, How, and When …">2</a><a href="https://www.geeksforgeeks.org/system-design/structural-design-patterns/?utm_source=chatgpt.com" title="Structural Design Patterns - GeeksforGeeks">7</a>.</li></ul><h3 id=51-구조-패턴의-종류-및-비교>5.1. 구조 패턴의 종류 및 비교<a hidden class=anchor aria-hidden=true href=#51-구조-패턴의-종류-및-비교>#</a></h3><table><thead><tr><th>패턴명</th><th>설명</th><th>사용 시점 및 목적</th></tr></thead><tbody><tr><td>어댑터 (Adapter)</td><td>호환되지 않는 인터페이스를 가진 클래스들을 함께 작동하도록 함</td><td>기존 클래스를 재사용하고 싶지만 인터페이스가 맞지 않을 때</td></tr><tr><td>브리지 (Bridge)</td><td>추상화와 구현을 분리하여 독립적으로 확장 가능하게 함</td><td>추상화와 구현을 독립적으로 변경하고 싶을 때</td></tr><tr><td>컴포지트 (Composite)</td><td>객체들을 트리 구조로 구성하여 부분 - 전체 계층을 표현함</td><td>부분 - 전체 구조를 동일하게 다루고 싶을 때</td></tr><tr><td>데코레이터 (Decorator)</td><td>객체에 새로운 기능을 동적으로 추가함</td><td>기존 객체에 기능을 추가하고 싶을 때</td></tr><tr><td>퍼사드 (Facade)</td><td>복잡한 서브시스템에 대한 단순한 인터페이스를 제공함</td><td>복잡한 시스템을 단순화하고 싶을 때</td></tr><tr><td>플라이웨이트 (Flyweight)</td><td>많은 수의 유사한 객체들을 공유하여 메모리 사용을 최소화함</td><td>많은 수의 유사한 객체를 효율적으로 관리하고 싶을 때</td></tr><tr><td>프록시 (Proxy)</td><td>다른 객체에 대한 접근을 제어하기 위한 대리 객체를 제공함</td><td>객체에 대한 접근을 제어하고 싶을 때</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>패턴명</th><th>정의/구성</th><th>목적/예시</th></tr></thead><tbody><tr><td>Adapter</td><td>기존 인터페이스를 원하는 인터페이스로 변환</td><td>레거시 시스템과 신규 시스템 연동, 예: USB- 시리얼 변환기</td></tr><tr><td>Bridge</td><td>추상화와 구현 분리, 독립적 확장</td><td>UI 테마와 컴포넌트 분리, 예: 다양한 DB 드라이버와 추상화 계층</td></tr><tr><td>Composite</td><td>트리 구조로 부분 - 전체 계층 표현</td><td>파일 시스템, 메뉴 구조, 예: 디렉터리 - 파일 구조</td></tr><tr><td>Decorator</td><td>동적으로 객체에 기능 추가</td><td>스트림에 암호화/압축 추가, 예: Java IO 스트림</td></tr><tr><td>Facade</td><td>복잡한 서브시스템을 단순화</td><td>라이브러리 통합 API, 예: Spring 의 JdbcTemplate</td></tr><tr><td>Flyweight</td><td>공유 객체로 메모리 절약</td><td>대량의 텍스트 렌더링, 예: 문자 객체 풀</td></tr><tr><td>Proxy</td><td>접근 제어, 로깅, 캐싱 등 대리 기능</td><td>DB 연결 프록시, 원격 객체 대리, 예: RPC 프록시</td></tr></tbody></table><h2 id=8-구현-기법>8. 구현 기법<a hidden class=anchor aria-hidden=true href=#8-구현-기법>#</a></h2><ul><li><strong>Interface/Abstract Class 기반 기본 인터페이스 정의</strong></li><li><strong>Recursive 구성</strong>: Composite 는 자식 요소 (Component) 를 여러 개 보유</li><li><strong>메서드 구현</strong>: Leaf 는 단일 행동, Composite 는 자식 순회하여 위임</li><li><strong>클라이언트 연산 단순화</strong>: 클라이언트는 Composite 와 Leaf 를 동일하게 다룸</li></ul><h3 id=8-구현-기법-1>8) 구현 기법<a hidden class=anchor aria-hidden=true href=#8-구현-기법-1>#</a></h3><ul><li><strong>패턴 선택:</strong><ul><li>문제 유형에 따라 Adapter, Decorator, Composite, Bridge 등 적절한 패턴 선택</li></ul></li><li><strong>객체 간 결합 구조화:</strong><ul><li>객체 간 관계와 구조를 패턴으로 구조화</li></ul></li><li><strong>기능 확장:</strong><ul><li>새로운 기능을 쉽게 추가</li></ul></li><li><strong>실제 예시</strong><ul><li><strong>Adapter:</strong> 기존 코드와 새로운 인터페이스를 연결</li><li><strong>Decorator:</strong> 기능을 동적으로 추가</li><li><strong>Composite:</strong> 객체를 트리 구조로 구성</li></ul></li></ul><h3 id=구현-기법-1>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법-1>#</a></h3><h4 id=1-adapter-패턴>1. Adapter 패턴<a hidden class=anchor aria-hidden=true href=#1-adapter-패턴>#</a></h4><p><strong>정의</strong>: 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Target: 클라이언트가 기대하는 인터페이스</li><li>Adapter: Target 인터페이스를 구현하여 Adaptee 를 감싸는 클래스</li><li>Adaptee: 기존의 호환되지 않는 인터페이스를 가진 클래스</li></ul><p><strong>목적</strong>: 기존 시스템과 새로운 시스템 간의 인터페이스 호환성 제공</p><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 시스템 구성: 레거시 결제 시스템과 새로운 결제 인터페이스</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>interface</span> <span class=nc>ModernPayment</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>processPayment</span><span class=p>(</span><span class=kt>double</span><span class=w> </span><span class=n>amount</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>LegacyPaymentSystem</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>makePayment</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>cents</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* 기존 구현 */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>PaymentAdapter</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>ModernPayment</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>LegacyPaymentSystem</span><span class=w> </span><span class=n>legacySystem</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>processPayment</span><span class=p>(</span><span class=kt>double</span><span class=w> </span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>legacySystem</span><span class=p>.</span><span class=na>makePayment</span><span class=p>((</span><span class=kt>int</span><span class=p>)(</span><span class=n>amount</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>100</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-bridge-패턴>2. Bridge 패턴<a hidden class=anchor aria-hidden=true href=#2-bridge-패턴>#</a></h4><p><strong>정의</strong>: 추상화와 구현을 분리하여 각각 독립적으로 변화할 수 있도록 하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Abstraction: 클라이언트가 사용하는 추상화 인터페이스</li><li>RefinedAbstraction: 추상화의 구체적 구현</li><li>Implementor: 구현 인터페이스</li><li>ConcreteImplementor: 구체적 구현</li></ul><p><strong>목적</strong>: 추상화와 구현의 독립적 진화 지원</p><h4 id=3-composite-패턴>3. Composite 패턴<a hidden class=anchor aria-hidden=true href=#3-composite-패턴>#</a></h4><p><strong>정의</strong>: 객체들을 트리 구조로 구성하여 부분 - 전체 계층을 표현하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Component: 공통 인터페이스</li><li>Leaf: 말단 객체</li><li>Composite: 복합 객체</li></ul><p><strong>목적</strong>: 개별 객체와 복합 객체를 동일하게 처리</p><h4 id=4-decorator-패턴>4. Decorator 패턴<a hidden class=anchor aria-hidden=true href=#4-decorator-패턴>#</a></h4><p><strong>정의</strong>: 객체의 구조를 변경하지 않고 새로운 기능을 동적으로 추가하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Component: 기본 인터페이스</li><li>ConcreteComponent: 기본 구현</li><li>Decorator: 데코레이터 기본 클래스</li><li>ConcreteDecorator: 구체적 데코레이터</li></ul><p><strong>목적</strong>: 객체의 기능을 동적으로 확장</p><h4 id=5-facade-패턴>5. Facade 패턴<a hidden class=anchor aria-hidden=true href=#5-facade-패턴>#</a></h4><p><strong>정의</strong>: 복잡한 서브시스템에 대한 단순화된 인터페이스를 제공하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Facade: 단순화된 인터페이스</li><li>Subsystem classes: 복잡한 서브시스템들</li></ul><p><strong>목적</strong>: 복잡한 시스템의 사용 편의성 향상</p><h4 id=6-flyweight-패턴>6. Flyweight 패턴<a hidden class=anchor aria-hidden=true href=#6-flyweight-패턴>#</a></h4><p><strong>정의</strong>: 많은 수의 객체를 효율적으로 지원하기 위해 공유를 사용하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Flyweight: 공유 가능한 상태를 포함하는 인터페이스</li><li>ConcreteFlyweight: 구체적 플라이웨이트</li><li>FlyweightFactory: 플라이웨이트 관리</li><li>Context: 외부 상태 보관</li></ul><p><strong>목적</strong>: 메모리 사용량 최적화</p><h4 id=7-proxy-패턴>7. Proxy 패턴<a hidden class=anchor aria-hidden=true href=#7-proxy-패턴>#</a></h4><p><strong>정의</strong>: 다른 객체에 대한 접근을 제어하기 위해 대리자를 제공하는 패턴</p><p><strong>구성</strong>:</p><ul><li>Subject: 공통 인터페이스</li><li>RealSubject: 실제 객체</li><li>Proxy: 프록시 객체</li></ul><p><strong>목적</strong>: 객체 접근 제어 및 부가 기능 제공</p><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유연한 구조</td><td>런타임에 객체 구성 변경 가능</td></tr><tr><td></td><td>코드 재사용성</td><td>기존 코드를 수정하지 않고 새로운 기능 추가</td></tr><tr><td></td><td>시스템 단순화</td><td>복잡한 서브시스템을 단순한 인터페이스로 노출</td></tr><tr><td></td><td>메모리 효율성</td><td>객체 공유를 통한 메모리 사용량 감소</td></tr><tr><td></td><td>독립적 개발</td><td>추상화와 구현의 분리로 병렬 개발 가능</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>추가적인 클래스와 인터페이스로 인한 복잡성</td></tr><tr><td></td><td>성능 오버헤드</td><td>래퍼와 프록시로 인한 성능 저하</td></tr><tr><td></td><td>디버깅 어려움</td><td>다층 구조로 인한 문제 추적의 복잡성</td></tr><tr><td></td><td>학습 곡선</td><td>패턴 이해와 적절한 적용의 어려움</td></tr><tr><td></td><td>과도한 추상화</td><td>불필요한 구조화로 인한 복잡성 증가</td></tr></tbody></table><h3 id=장점과-단점-1>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유연성</td><td>객체 구조 및 관계를 유연하게 설계 가능</td></tr><tr><td></td><td>재사용성</td><td>코드 재사용 및 확장 용이</td></tr><tr><td></td><td>유지보수성</td><td>결합도 감소로 유지보수 용이</td></tr><tr><td></td><td>복잡성 완화</td><td>복잡한 시스템을 단순화, 일관된 인터페이스 제공</td></tr><tr><td>⚠ 단점</td><td>복잡성</td><td>패턴 남용 시 구조가 오히려 복잡해질 수 있음</td></tr><tr><td></td><td>성능 저하</td><td>일부 패턴 (Decorator, Proxy 등) 은 오버헤드 발생 가능</td></tr><tr><td></td><td>학습 곡선</td><td>패턴별 의도와 구조 이해 필요, 초보자에겐 진입장벽</td></tr></tbody></table><h3 id=9-장점>9) 장점<a hidden class=anchor aria-hidden=true href=#9-장점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>원인/특성</th></tr></thead><tbody><tr><td>장점</td><td>유연성</td><td>객체 간 결합을 구조화하여 유연성을 높임</td><td>객체 간 결합 구조화</td></tr><tr><td></td><td>확장성</td><td>새로운 기능을 쉽게 추가할 수 있음</td><td>기능 확장</td></tr><tr><td></td><td>재사용성</td><td>기존 코드를 재사용할 수 있음</td><td>코드 재사용</td></tr><tr><td></td><td>복잡성 감소</td><td>객체 간 결합을 구조화하여 복잡성을 낮춤</td><td>객체 간 결합 구조화</td></tr></tbody></table><h2 id=9-장점-1>9. 장점<a hidden class=anchor aria-hidden=true href=#9-장점-1>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>장점</td><td>일관된 트리 구조 처리</td><td>Leaf, Composite 를 하나의 Component 타입으로 다룰 수 있음</td></tr><tr><td>장점</td><td>확장성</td><td>노드 추가/제거 용이, 구조 변경 유연</td></tr><tr><td>장점</td><td>코드 단순화</td><td>클라이언트 코드에서 반복적 타입 체크 제거</td></tr></tbody></table><hr><h2 id=10-단점-및-문제점--해결-방안>10. 단점 및 문제점 ↔ 해결 방안<a hidden class=anchor aria-hidden=true href=#10-단점-및-문제점--해결-방안>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>해결책</th><th></th></tr></thead><tbody><tr><td>단점</td><td>구조 복잡화</td><td>단순 구조에는 Composite 과잉일 수 있음</td><td></td></tr><tr><td>문제점 1</td><td>불필요한 메서드</td><td></td><td></td></tr><tr><td>문제점 2</td><td>잘못된 타입으로 구조 조작</td><td><code>add</code> 를 Leaf 에서도 호출 가능 -> 실행 중 예외 발생</td><td>클라이언트 Validation 도입</td></tr></tbody></table><h3 id=10-단점과-문제점-및-해결방안>10) 단점과 문제점 및 해결방안<a hidden class=anchor aria-hidden=true href=#10-단점과-문제점-및-해결방안>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>단점</td><td>복잡성</td><td>패턴 적용 시 시스템 복잡성 증가</td><td>명확한 인터페이스, 문서화</td></tr><tr><td></td><td>러닝커브</td><td>패턴 이해 및 적용에 학습 필요</td><td>교육, 예제 제공</td></tr></tbody></table><table><thead><tr><th>구분</th><th>항목</th><th>원인</th><th>영향</th><th>탐지/진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>문제점</td><td>인터페이스 불일치</td><td>기존 코드와 새 인터페이스 불일치</td><td>동작 불가</td><td>코드 리뷰</td><td>인터페이스 검증</td><td>Adapter 패턴 적용</td></tr><tr><td></td><td>기능 중복</td><td>기능 추가 시 중복</td><td>유지보수 어려움</td><td>코드 리뷰</td><td>기능 분리</td><td>Decorator 패턴 적용</td></tr></tbody></table><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><ul><li><strong>과제</strong>: 패턴 남용으로 인한 복잡성 증가<br><strong>해결책</strong>: 실제 문제 해결에 필요한 경우에만 적용, 단순함 유지</li><li><strong>과제</strong>: 성능 저하 (Decorator, Proxy 등)<br><strong>해결책</strong>: 성능 측정 및 최적화, 필요시 캐싱/풀링 적용</li><li><strong>과제</strong>: 패턴 간 충돌 및 오용<br><strong>해결책</strong>: 각 패턴의 목적과 한계를 명확히 이해하고 조합 시 주의</li></ul><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><h4 id=1-성능-최적화>1. 성능 최적화<a hidden class=anchor aria-hidden=true href=#1-성능-최적화>#</a></h4><ul><li><strong>설명</strong>: 다층 구조로 인한 성능 저하 문제</li><li><strong>해결책</strong>: 지연 로딩, 캐싱 전략, 프록시 체인 최적화</li></ul><h4 id=2-복잡성-관리>2. 복잡성 관리<a hidden class=anchor aria-hidden=true href=#2-복잡성-관리>#</a></h4><ul><li><strong>설명</strong>: 여러 패턴 조합 시 시스템 복잡도 증가</li><li><strong>해결책</strong>: 명확한 아키텍처 문서화, 패턴 적용 가이드라인 수립</li></ul><h4 id=3-메모리-누수-방지>3. 메모리 누수 방지<a hidden class=anchor aria-hidden=true href=#3-메모리-누수-방지>#</a></h4><ul><li><strong>설명</strong>: 플라이웨이트와 프록시 패턴에서의 메모리 관리</li><li><strong>해결책</strong>: 약한 참조 사용, 적절한 생명주기 관리</li></ul><h4 id=4-인터페이스-일관성>4. 인터페이스 일관성<a hidden class=anchor aria-hidden=true href=#4-인터페이스-일관성>#</a></h4><ul><li><strong>설명</strong>: 여러 어댑터 사용 시 인터페이스 불일치</li><li><strong>해결책</strong>: 표준 인터페이스 정의, 어댑터 계층 표준화</li></ul><h3 id=11-도전-과제>11) 도전 과제<a hidden class=anchor aria-hidden=true href=#11-도전-과제>#</a></h3><ul><li><strong>최신 기술 적용:</strong><ul><li>클라우드, 마이크로서비스, 서버리스 등 신기술 환경에서 구조 패턴 적용 방법 연구 필요</li></ul></li><li><strong>실무 적용 한계:</strong><ul><li>레거시 시스템, 다양한 도메인에서 패턴 적용의 어려움</li></ul></li><li><strong>성능 최적화:</strong><ul><li>객체 간 결합 관리, 메모리 사용 최적화</li></ul></li></ul><h2 id=11-도전-과제-1>11. 도전 과제<a hidden class=anchor aria-hidden=true href=#11-도전-과제-1>#</a></h2><ul><li><strong>타입 안전성 유지</strong>: <code>add()</code> 를 Leaf 에서 호출 불가능하도록 인터페이스 제한 필요</li><li><strong>순환 참조 방지</strong>: Composite 구조에서 자신을 자식으로 추가하지 않도록 설계</li><li><strong>병렬 접근 고려</strong>: 멀티스레드에서 <code>children</code> 컬렉션 동시 수정 시 동기화 필요</li></ul><hr><h3 id=12-분류-기준에-따른-종류-및-유형>12) 분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#12-분류-기준에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류</th><th>주요 패턴 예시</th><th>설명</th></tr></thead><tbody><tr><td>Adapter</td><td>Adapter</td><td>기존 코드와 새 인터페이스 연결</td></tr><tr><td>Decorator</td><td>Decorator</td><td>기능 동적 추가</td></tr><tr><td>Composite</td><td>Composite</td><td>객체를 트리 구조로 구성</td></tr><tr><td>Bridge</td><td>Bridge</td><td>추상화와 구현 분리</td></tr><tr><td>Facade</td><td>Facade</td><td>복잡한 시스템을 단순화</td></tr><tr><td>Flyweight</td><td>Flyweight</td><td>객체 공유를 통한 메모리 절약</td></tr><tr><td>Proxy</td><td>Proxy</td><td>객체 접근 제어</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>패턴명</th><th>설명</th></tr></thead><tbody><tr><td>Adapter</td><td>호환되지 않는 인터페이스 연결</td></tr><tr><td>Bridge</td><td>추상화와 구현 분리</td></tr><tr><td>Composite</td><td>트리 구조로 부분 - 전체 계층 표현</td></tr><tr><td>Decorator</td><td>동적으로 기능 추가</td></tr><tr><td>Facade</td><td>복잡한 시스템 단순화</td></tr><tr><td>Flyweight</td><td>공유 객체로 메모리 절약</td></tr><tr><td>Proxy</td><td>접근 제어, 대리 기능 제공</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형-1>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형-1>#</a></h3><table><thead><tr><th>분류 기준</th><th>패턴 이름</th><th>특징</th><th>적용 시나리오</th></tr></thead><tbody><tr><td>인터페이스 변환</td><td>Adapter</td><td>호환되지 않는 인터페이스 연결</td><td>레거시 시스템 통합</td></tr><tr><td>구조 분리</td><td>Bridge</td><td>추상화와 구현 분리</td><td>플랫폼 독립적 설계</td></tr><tr><td>계층 구조</td><td>Composite</td><td>부분 - 전체 관계 표현</td><td>파일 시스템, UI 컴포넌트</td></tr><tr><td>기능 확장</td><td>Decorator</td><td>동적 기능 추가</td><td>기능별 옵션 추가</td></tr><tr><td>인터페이스 단순화</td><td>Facade</td><td>복잡한 시스템의 단순 인터페이스</td><td>API 게이트웨이</td></tr><tr><td>메모리 최적화</td><td>Flyweight</td><td>객체 공유를 통한 메모리 절약</td><td>대량 객체 처리</td></tr><tr><td>접근 제어</td><td>Proxy</td><td>객체 접근 제어 및 부가 기능</td><td>지연 로딩, 캐싱</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>적용 분야</th><th>사용 패턴</th><th>구체적 예시</th><th>장점</th></tr></thead><tbody><tr><td>웹 개발</td><td>Facade</td><td>API Gateway</td><td>마이크로서비스 통합 관리</td></tr><tr><td>모바일 앱</td><td>Adapter</td><td>플랫폼별 API 통합</td><td>크로스 플랫폼 호환성</td></tr><tr><td>게임 개발</td><td>Flyweight</td><td>스프라이트 객체 관리</td><td>메모리 사용량 최적화</td></tr><tr><td>엔터프라이즈</td><td>Proxy</td><td>데이터베이스 연결 풀</td><td>리소스 관리 효율성</td></tr><tr><td>UI/UX</td><td>Composite</td><td>컴포넌트 계층 구조</td><td>일관된 UI 처리</td></tr><tr><td>클라우드 서비스</td><td>Decorator</td><td>서비스 기능 확장</td><td>동적 기능 추가</td></tr></tbody></table><h2 id=12-실무-사용-예시>12. 실무 사용 예시<a hidden class=anchor aria-hidden=true href=#12-실무-사용-예시>#</a></h2><table><thead><tr><th>도메인</th><th>패턴</th><th>목적</th><th>사례</th></tr></thead><tbody><tr><td>GUI 컴포넌트</td><td>Composite</td><td>컨테이너 내 위젯 일관적 처리</td><td>웹 UI 트리 구조 (DOM), Swing/JavaFX</td></tr><tr><td>파일 시스템</td><td>Composite</td><td>폴더와 파일을 동일하게 다룸</td><td>Unix 파일 트리</td></tr><tr><td>로깅 핸들러 체인</td><td>Decorator</td><td>메시지에 여러 책임을 순차 적용</td><td>SLF4J/Logback Appender</td></tr></tbody></table><h3 id=실무-적용-예시-1>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시-1>#</a></h3><table><thead><tr><th>패턴명</th><th>적용 예시</th><th>설명</th></tr></thead><tbody><tr><td>Adapter</td><td>레거시 시스템 연동</td><td>신규 API 와 레거시 시스템 연결</td></tr><tr><td>Decorator</td><td>데이터 스트림 암호화</td><td>IO 스트림에 암호화/압축 기능 동적 추가</td></tr><tr><td>Composite</td><td>파일/디렉터리 구조</td><td>파일 시스템 트리 구조 구현</td></tr><tr><td>Facade</td><td>라이브러리 통합 API</td><td>복잡한 라이브러리 기능을 단일 API 로 제공</td></tr><tr><td>Proxy</td><td>DB 연결 프록시</td><td>DB 접근 제어, 로깅, 캐싱 등 대리 기능</td></tr></tbody></table><h3 id=13-실무-사용-예시>13) 실무 사용 예시<a hidden class=anchor aria-hidden=true href=#13-실무-사용-예시>#</a></h3><table><thead><tr><th>패턴</th><th>시스템/목적</th><th>효과/결과</th></tr></thead><tbody><tr><td>Adapter</td><td>기존 코드와 새 인터페이스 연결</td><td>호환성 확보</td></tr><tr><td>Decorator</td><td>기능 동적 추가</td><td>기능 확장성 향상</td></tr><tr><td>Composite</td><td>객체 트리 구조 구성</td><td>복합 객체 관리 용이</td></tr></tbody></table><h3 id=14-활용-사례>14) 활용 사례<a hidden class=anchor aria-hidden=true href=#14-활용-사례>#</a></h3><ul><li><strong>Adapter 패턴 적용 사례: 기존 코드와 새 인터페이스 연결</strong><ul><li><strong>시스템 구성:</strong><ul><li>Client → Target</li><li>Adapter → Adaptee</li><li>Adapter 가 기존 코드와 새 인터페이스를 연결</li></ul></li><li><strong>Workflow:</strong><ol><li>Client 가 Target 인터페이스 사용</li><li>Adapter 가 Adaptee(기존 코드) 를 호출</li><li>Adaptee 가 실제 기능 수행</li></ol></li><li><strong>역할:</strong><ul><li>기존 코드와 새 인터페이스를 연결하여 호환성 확보</li><li>기존 코드를 재사용할 수 있게 함</li></ul></li><li><strong>차이점:</strong><ul><li>패턴 미적용 시 기존 코드를 새 인터페이스에 맞게 수정해야 함</li><li>패턴 적용 시 기존 코드를 그대로 재사용 가능</li></ul></li></ul></li></ul><h2 id=13-활용-사례-gui-구성>13. 활용 사례: GUI 구성<a hidden class=anchor aria-hidden=true href=#13-활용-사례-gui-구성>#</a></h2><ul><li><strong>문제</strong>: 버튼, 패널, 텍스트 필드 등 UI 컴포넌트들을 일관적으로 그리기/이벤트 처리 원하는 경우</li><li><strong>구성</strong>:<ul><li><code>Component</code> 인터페이스를 공통 정의</li><li><code>Leaf (Button, TextField)</code> 는 개별 처리</li><li><code>Composite (Panel)</code> 는 자식 <code>Component</code> 리스트 보유</li></ul></li><li><strong>클라이언트 코드</strong>: <code>panel.draw()</code> 호출 시 내부 자식을 재귀적으로 그림</li></ul><h3 id=활용-사례-시나리오-기반>활용 사례 (시나리오 기반)<a hidden class=anchor aria-hidden=true href=#활용-사례-시나리오-기반>#</a></h3><h4 id=상황-가정>상황 가정<a hidden class=anchor aria-hidden=true href=#상황-가정>#</a></h4><ul><li><strong>시스템</strong>: 대규모 금융 시스템에서 레거시 계좌 시스템과 신규 API 연동 필요</li></ul><h4 id=시스템-구성>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성>#</a></h4><ul><li>Adapter 패턴 적용: <code>LegacyAccountService</code>(Adaptee) 와 <code>NewAccountAPI</code>(Target) 사이에 <code>AccountAdapter</code>(Adapter) 구현</li></ul><h4 id=시스템-구성-다이어그램>시스템 구성 다이어그램<a hidden class=anchor aria-hidden=true href=#시스템-구성-다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client ---&gt; NewAccountAPI (Target)
</span></span><span class=line><span class=cl>                   ^
</span></span><span class=line><span class=cl>                   |
</span></span><span class=line><span class=cl>             AccountAdapter
</span></span><span class=line><span class=cl>                   |
</span></span><span class=line><span class=cl>         LegacyAccountService (Adaptee)
</span></span></code></pre></td></tr></table></div></div><h4 id=workflow>Workflow<a hidden class=anchor aria-hidden=true href=#workflow>#</a></h4><ol><li>클라이언트는 NewAccountAPI 인터페이스로 계좌 정보를 요청</li><li>AccountAdapter 가 LegacyAccountService 의 데이터를 변환해 반환</li><li>클라이언트는 신규 API 만 알면 됨</li></ol><h4 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h4><ul><li>Adapter 가 레거시 시스템과 신규 시스템의 호환성 보장</li><li>클라이언트는 인터페이스만 알면 되고, 내부 구현 변경에 영향 없음</li></ul><h3 id=활용-사례-전자상거래-플랫폼의-결제-시스템>활용 사례: 전자상거래 플랫폼의 결제 시스템<a hidden class=anchor aria-hidden=true href=#활용-사례-전자상거래-플랫폼의-결제-시스템>#</a></h3><p><strong>시나리오</strong>: 다양한 결제 수단과 배송 옵션을 지원하는 전자상거래 플랫폼에서 통합 결제 시스템 구축</p><p><strong>시스템 구성</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[웹 클라이언트] ─── [결제 파사드] ─── [어댑터 계층] ─── [외부 결제 API들]
</span></span><span class=line><span class=cl>     │                 │                 │                    │
</span></span><span class=line><span class=cl>     │                 │                 ├─ 신용카드 어댑터     │
</span></span><span class=line><span class=cl>     │                 │                 ├─ 페이팔 어댑터      │
</span></span><span class=line><span class=cl>     │                 │                 └─ 암호화폐 어댑터     │
</span></span><span class=line><span class=cl>     │                 │                                      │
</span></span><span class=line><span class=cl>     └─── [프록시] ─── [데코레이터 체인] ─── [핵심 결제 로직] ─┘
</span></span><span class=line><span class=cl>              │              │
</span></span><span class=line><span class=cl>              │              ├─ 로깅 데코레이터
</span></span><span class=line><span class=cl>              │              ├─ 보안 데코레이터
</span></span><span class=line><span class=cl>              │              └─ 캐싱 데코레이터
</span></span></code></pre></td></tr></table></div></div><p><strong>활용된 패턴들</strong>:</p><ol><li><strong>Facade</strong>: 복잡한 결제 프로세스를 단순한 인터페이스로 제공</li><li><strong>Adapter</strong>: 각기 다른 결제 업체 API 를 통일된 인터페이스로 변환</li><li><strong>Decorator</strong>: 로깅, 보안, 캐싱 등의 부가 기능을 동적으로 추가</li><li><strong>Proxy</strong>: 결제 요청의 접근 제어 및 지연 로딩</li></ol><p><strong>Workflow</strong>:</p><ol><li>클라이언트가 결제 파사드를 통해 결제 요청</li><li>파사드가 적절한 어댑터 선택</li><li>프록시를 통한 접근 권한 확인</li><li>데코레이터 체인을 통한 부가 처리</li><li>실제 결제 API 호출 및 결과 반환</li></ol><p><strong>담당 역할</strong>:</p><ul><li><strong>Facade 패턴</strong>: 복잡한 결제 시스템을 단순한 인터페이스로 노출</li><li><strong>Adapter 패턴</strong>: 다양한 결제 업체 API 의 통일된 처리</li><li><strong>Decorator 패턴</strong>: 횡단 관심사 (로깅, 보안 등) 의 모듈화</li><li><strong>Proxy 패턴</strong>: 결제 보안 및 성능 최적화</li></ul><h2 id=14-구현-예시-java>14. 구현 예시 (Java)<a hidden class=anchor aria-hidden=true href=#14-구현-예시-java>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>Component</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>render</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>LeafButton</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Component</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>render</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Button rendered&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>CompositePanel</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Component</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Component</span><span class=o>&gt;</span><span class=w> </span><span class=n>children</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=n>Component</span><span class=w> </span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>children</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>c</span><span class=p>);</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>render</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Panel start&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Component</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>children</span><span class=p>)</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=na>render</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Panel end&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=15-구현-예시-python>15) 구현 예시 (Python)<a hidden class=anchor aria-hidden=true href=#15-구현-예시-python>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Adapter 패턴 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Adaptee</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>specific_request</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Adaptee: specific request&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>request</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Adapter</span><span class=p>(</span><span class=n>Target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>adaptee</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>adaptee</span> <span class=o>=</span> <span class=n>adaptee</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>request</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Adapter: </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>adaptee</span><span class=o>.</span><span class=n>specific_request</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>adaptee</span> <span class=o>=</span> <span class=n>Adaptee</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>adapter</span> <span class=o>=</span> <span class=n>Adapter</span><span class=p>(</span><span class=n>adaptee</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>adapter</span><span class=o>.</span><span class=n>request</span><span class=p>())</span>  <span class=c1># 출력: Adapter: Adaptee: specific request</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=17-기타-사항>17. 기타 사항<a hidden class=anchor aria-hidden=true href=#17-기타-사항>#</a></h2><ul><li><strong>Decorator 예시</strong>: I/O 스트림 (<code>BufferedInputStream</code>), Java AOP <code>@Transactional</code> 등 기능 추가 활용</li><li><strong>Proxy 예시</strong>: Hibernate Lazy Loading, RPC/REST 서비스 호출 Proxy</li><li><strong>Flyweight 예시</strong>: 그래픽 문자 객체 캐싱, 텍스트 렌더링 엔진의 glyph cache</li></ul><h2 id=7-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>7. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#7-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>패턴 선택</td><td>문제 유형에 맞는 패턴 선택</td><td>문제 분석 후 패턴 선택</td></tr><tr><td>인터페이스 명확화</td><td>패턴 적용 시 인터페이스를 명확히 정의</td><td>인터페이스 분리, 문서화</td></tr><tr><td>테스트</td><td>다양한 객체 조합으로 테스트 강화</td><td>단위 테스트, 통합 테스트</td></tr><tr><td>불필요한 패턴 적용</td><td>필요 없는 패턴 적용은 피함</td><td>코드 리뷰, 최소화</td></tr></tbody></table><h2 id=15-실무-적용-고려-사항>15. 실무 적용 고려 사항<a hidden class=anchor aria-hidden=true href=#15-실무-적용-고려-사항>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장 사항</th></tr></thead><tbody><tr><td>타입 안전성</td><td><code>add()</code> 호출 오류</td><td>Composite 타입만 업데이트</td></tr><tr><td>순환 참조</td><td>구조 무한 순환 가능</td><td>사이클 방지 로직 도입</td></tr><tr><td>성능</td><td>깊은 트리 순회 overhead</td><td>재사용 가능한 노드, lazy 로딩</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>적용 필요성</td><td>불필요한 패턴 적용은 오히려 복잡성 유발</td><td>실제 문제 해결에 집중</td></tr><tr><td>성능 영향</td><td>Decorator, Proxy 등은 오버헤드 발생 가능</td><td>성능 측정 및 최적화</td></tr><tr><td>유지보수성</td><td>구조 변경 시 영향도 최소화</td><td>인터페이스 기반 설계 권장</td></tr><tr><td>확장성</td><td>새로운 구조 추가 시 구조 변화 최소화</td><td>OCP(개방 - 폐쇄 원칙) 준수</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점-1>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>권장사항</th><th>주의점</th></tr></thead><tbody><tr><td>설계</td><td>패턴 조합</td><td>단일 목적을 위한 패턴 조합 선택</td><td>과도한 패턴 중첩 방지</td></tr><tr><td>성능</td><td>호출 체이닝</td><td>불필요한 중간 계층 최소화</td><td>깊은 호출 스택으로 인한 성능 저하</td></tr><tr><td>유지보수</td><td>문서화</td><td>패턴 적용 이유와 구조 명확히 기록</td><td>복잡한 구조로 인한 이해도 저하</td></tr><tr><td>테스트</td><td>Mock 객체</td><td>각 계층별 독립적 테스트 환경 구성</td><td>통합 테스트의 복잡성 증가</td></tr><tr><td>확장성</td><td>인터페이스 설계</td><td>미래 확장을 고려한 유연한 인터페이스</td><td>불필요한 추상화로 인한 복잡성</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>최적화 방안</th><th>권장사항</th><th>주의점</th></tr></thead><tbody><tr><td>메모리</td><td>플라이웨이트 활용</td><td>공유 가능한 상태와 고유 상태 분리</td><td>스레드 안전성 확보</td></tr><tr><td>속도</td><td>지연 로딩</td><td>프록시를 통한 필요 시점 객체 생성</td><td>초기 지연 시간 고려</td></tr><tr><td>캐싱</td><td>어댑터 캐싱</td><td>변환 결과의 임시 저장</td><td>캐시 무효화 정책 수립</td></tr><tr><td>병렬 처리</td><td>컴포지트 병렬화</td><td>트리 구조의 병렬 순회</td><td>동기화 오버헤드</td></tr><tr><td>최적화</td><td>불필요한 래퍼 제거</td><td>직접 호출이 가능한 경우 패턴 생략</td><td>일관성과 성능 간의 균형</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점-1>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점-1>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>오버헤드 관리</td><td>Decorator, Proxy 등은 호출 체인이 길어질 수 있음</td><td>필요시 캐싱, 풀링 적용</td></tr><tr><td>메모리 관리</td><td>Flyweight 사용 시 공유 객체 관리 필요</td><td>객체 수명 주기 명확히 관리</td></tr><tr><td>단순화 우선</td><td>불필요한 패턴 남용은 성능 저하</td><td>단순한 구조 우선 적용</td></tr><tr><td>테스트 용이성</td><td>구조 복잡성 증가 시 테스트 어려움</td><td>테스트 자동화 및 Mock 객체 활용</td></tr></tbody></table><h2 id=16-최적화-고려-사항>16. 최적화 고려 사항<a hidden class=anchor aria-hidden=true href=#16-최적화-고려-사항>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장 사항</th></tr></thead><tbody><tr><td>트리 깊이</td><td>깊은 트리는 render 비용 증가</td><td>가상화 (Virtual List) 기법 활용</td></tr><tr><td>컬렉션 관리</td><td>자식 리스트 크기 큰 경우 메모리 부담</td><td>메모리 풀링, 스트리밍 처리 활용</td></tr></tbody></table><h2 id=8-최적화하기-위한-고려사항-및-주의할-점>8. 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#8-최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>객체 간 결합 관리</td><td>객체 간 결합을 최소화하여 성능 저하 방지</td><td>결합 최소화</td></tr><tr><td>메모리 사용</td><td>대량 객체 사용 시 메모리 최적화</td><td>메모리 프로파일링</td></tr><tr><td>기능 중복 방지</td><td>기능 추가 시 중복 방지</td><td>기능 분리, 재사용</td></tr></tbody></table><hr><h2 id=9-주제와-관련하여-주목할-내용>9. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#9-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>최신 기술</td><td>클라우드/서버리스</td><td>패턴 확장</td><td>신기술 환경에서 패턴 적용 방법 연구</td></tr><tr><td>실무 적용</td><td>기존 코드 재사용</td><td>패턴 활용</td><td>다양한 객체 결합, 확장성 향상</td></tr><tr><td>교육/훈련</td><td>팀 내 협업</td><td>패턴 이해도</td><td>교육 및 훈련 필요성</td></tr><tr><td>코드 품질</td><td>유지보수/확장성</td><td>패턴 효과</td><td>코드 품질 및 확장성 향상</td></tr></tbody></table><h2 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>패턴 조합</td><td>패턴 혼용</td><td>Facade+Proxy 등 패턴 조합 적용 사례 증가</td></tr><tr><td>테스트</td><td>Mock 객체 생성</td><td>구조 패턴으로 테스트 용이성 향상</td></tr><tr><td>클라우드</td><td>분산 시스템</td><td>구조 패턴이 마이크로서비스 아키텍처에 핵심 역할</td></tr></tbody></table><h2 id=9-주제와-관련하여-주목할-내용-1>9. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#9-주제와-관련하여-주목할-내용-1>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>구조 패턴</td><td>디자인 패턴의 결합</td><td>여러 디자인 패턴을 결합하여 복잡한 시스템 설계 가능</td></tr><tr><td>구조 패턴</td><td>테스트 용이성</td><td>객체 간의 관계를 명확하게 정의하여 단위 테스트 및 모킹이 용이함</td></tr><tr><td>구조 패턴</td><td>유지보수성 향상</td><td>객체 간의 관계를 단순화하여 코드 변경 시 영향 범위 최소화</td></tr></tbody></table><h2 id=9-주제와-관련하여-주목할-내용-2>9. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#9-주제와-관련하여-주목할-내용-2>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>서버리스 아키텍처</td><td>함수 컴포지션</td><td>FaaS 환경에서의 컴포지트 패턴 적용</td></tr><tr><td>엣지 컴퓨팅</td><td>분산 플라이웨이트</td><td>엣지 노드 간 객체 공유 최적화</td></tr><tr><td>블록체인</td><td>스마트 컨트랙트 프록시</td><td>업그레이드 가능한 스마트 컨트랙트 구조</td></tr><tr><td>GraphQL</td><td>스키마 스티칭</td><td>여러 GraphQL 스키마를 통합하는 어댑터 패턴</td></tr><tr><td>웹어셈블리</td><td>WASM 브리지</td><td>JavaScript 와 WebAssembly 간의 브리지 패턴</td></tr></tbody></table><h2 id=11-하위-주제로-추가-학습-내용>11. 하위 주제로 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#11-하위-주제로-추가-학습-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>고급 패턴</td><td>Composite Command</td><td>컴포지트와 커맨드 패턴의 결합</td></tr><tr><td>성능 최적화</td><td>Lazy Proxy</td><td>지연 로딩을 위한 고급 프록시 기법</td></tr><tr><td>동시성</td><td>Thread-Safe Flyweight</td><td>멀티스레드 환경에서의 플라이웨이트</td></tr><tr><td>함수형</td><td>Functional Decorator</td><td>함수형 프로그래밍에서의 데코레이터 패턴</td></tr><tr><td>반응형</td><td>Reactive Adapter</td><td>반응형 스트림을 위한 어댑터 패턴</td></tr></tbody></table><h2 id=12-관련-분야-추가-학습-내용>12. 관련 분야 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#12-관련-분야-추가-학습-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>소프트웨어 아키텍처</td><td>Layered Architecture</td><td>계층형 아키텍처와 구조적 패턴의 관계</td></tr><tr><td>분산 시스템</td><td>Circuit Breaker</td><td>프록시 패턴 기반의 장애 격리</td></tr><tr><td>웹 개발</td><td>MVC Pattern</td><td>구조적 패턴의 웹 아키텍처 적용</td></tr><tr><td>데이터베이스</td><td>ORM Adapter</td><td>객체 - 관계 매핑에서의 어댑터 패턴</td></tr><tr><td>보안</td><td>Security Proxy</td><td>보안 요구사항을 위한 프록시 패턴</td></tr></tbody></table><h2 id=11-하위-주제로-분류한-추가-학습-항목>11. 하위 주제로 분류한 추가 학습 항목<a hidden class=anchor aria-hidden=true href=#11-하위-주제로-분류한-추가-학습-항목>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>GoF 디자인 패턴</td><td>구조 패턴 7 종</td><td>어댑터, 브리지, 컴포지트, 데코레이터, 퍼사드, 플라이웨이트, 프록시 등</td></tr><tr><td>구조 패턴과의 비교</td><td>생성 패턴 vs. 구조 패턴</td><td>생성 패턴은 객체 생성에 중점, 구조 패턴은 객체 간의 관계에 중점</td></tr><tr><td>객체지향 설계 원칙</td><td>DIP, OCP, SRP</td><td>구조 패턴은 의존 역전 원칙 (DIP) 및 개방 폐쇄 원칙 (OCP) 과 긴밀히 연관됨</td></tr><tr><td>실전 구현 전략</td><td>DI 컨테이너와의 연계</td><td>Spring, NestJS 등 프레임워크에서 구조 패턴을 어떻게 적용하고 자동화하는지 분석</td></tr><tr><td>객체 관계 관리</td><td></td><td></td></tr></tbody></table><p>물론입니다. 아래는 **&ldquo;11. 하위 주제로 분류한 추가 학습 항목 &ldquo;**의 나머지 항목과, 이어서 <strong>12~14 번 항목</strong>까지 정리한 내용입니다.</p><hr><h2 id=11-하위-주제로-분류한-추가-학습-항목-이어서>11. 하위 주제로 분류한 추가 학습 항목 (이어서)<a hidden class=anchor aria-hidden=true href=#11-하위-주제로-분류한-추가-학습-항목-이어서>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>객체 관계 관리</td><td>Composition vs Aggregation</td><td>구조 패턴을 적용할 때 객체의 관계 설정 방식에 따라 설계 전략이 달라짐</td></tr><tr><td>성능 최적화 전략</td><td>Flyweight 적용 시 메모리 절감</td><td>많은 수의 객체가 필요한 경우 메모리 절감용 구조 패턴 적용</td></tr><tr><td>테스트 전략</td><td>Proxy / Facade 활용 테스트 분리</td><td>외부 종속성을 감싸 테스트 범위와 독립성을 높임</td></tr><tr><td>프론트엔드 개발</td><td>데코레이터 패턴 활용 컴포넌트 확장</td><td>React/Vue 같은 프레임워크에서 데코레이터 패턴 활용</td></tr><tr><td>모바일 앱 설계</td><td>어댑터 패턴으로 플랫폼 종속성 제거</td><td>플랫폼 별 구현체를 동일 인터페이스로 추상화하여 유지보수성 향상</td></tr></tbody></table><hr><h2 id=12-추가-학습-필요-항목-관련-분야-포함>12. 추가 학습 필요 항목 (관련 분야 포함)<a hidden class=anchor aria-hidden=true href=#12-추가-학습-필요-항목-관련-분야-포함>#</a></h2><table><thead><tr><th>관련 분야</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>백엔드 개발</td><td>Service Proxy 설계</td><td>서비스 계층에서 보안, 로깅 등을 프록시로 분리</td></tr><tr><td>클린 아키텍처</td><td>계층 간 의존성 최소화</td><td>구조 패턴을 통해 계층 간 결합도 최소화 및 변경 용이</td></tr><tr><td>마이크로서비스 아키텍처</td><td>API Gateway as Facade</td><td>API 게이트웨이를 퍼사드 패턴처럼 구성하여 백엔드 서비스들을 추상화</td></tr><tr><td>보안</td><td>Access Proxy 설계</td><td>민감 정보나 보안 리소스 접근을 프록시로 통제</td></tr><tr><td>게임 개발</td><td>Flyweight Pattern 으로 오브젝트 관리</td><td>수많은 오브젝트가 생성되는 게임 환경에서 메모리 최적화</td></tr><tr><td>클라우드 인프라</td><td>인프라 구성 자동화에서의 어댑터 활용</td><td>IaC 툴 (Terraform 등) 간 추상화 계층 설계</td></tr></tbody></table><h2 id=하위-주제로-추가-학습-필요-내용>하위 주제로 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-추가-학습-필요-내용>#</a></h2><table><thead><tr><th>설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>각 패턴의 심화 구현 방법</td><td>소프트웨어 아키텍처</td><td>Adapter/Decorator/Proxy 등</td></tr><tr><td>패턴 조합 및 응용</td><td>고급 설계 패턴</td><td>패턴 믹스, 패턴 간 상호작용</td></tr><tr><td>성능 최적화</td><td>시스템 설계</td><td>Flyweight, Proxy 의 캐싱/풀링</td></tr><tr><td>테스트 자동화와 구조 패턴</td><td>소프트웨어 테스트</td><td>Mock 객체, 테스트 더블</td></tr></tbody></table><hr><h2 id=추가로-알아야-할-내용-및-관련-분야>추가로 알아야 할 내용 및 관련 분야<a hidden class=anchor aria-hidden=true href=#추가로-알아야-할-내용-및-관련-분야>#</a></h2><table><thead><tr><th>설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>클라우드 네이티브 아키텍처</td><td>클라우드 아키텍처</td><td>구조 패턴과 마이크로서비스</td></tr><tr><td>코드 생성 자동화 도구</td><td>개발 생산성</td><td>코드 생성기, 템플릿 엔진</td></tr><tr><td>패턴 기반 테스트 전략</td><td>소프트웨어 테스트</td><td>구조 패턴 기반 테스트 전략</td></tr></tbody></table><h2 id=10-반드시-학습해야할-내용>10. 반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#10-반드시-학습해야할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>객체지향 설계</td><td>캡슐화/분리</td><td>객체 간 결합</td><td>객체 간 결합 구조화</td></tr><tr><td>패턴</td><td>Adapter</td><td>인터페이스 연결</td><td>기존 코드와 새 인터페이스 연결</td></tr><tr><td>패턴</td><td>Decorator</td><td>기능 동적 추가</td><td>기능을 동적으로 추가</td></tr><tr><td>실무 적용</td><td>기존 코드 재사용</td><td>실제 적용</td><td>실무 시스템에서의 패턴 적용</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>구조 패턴</td><td>Structural Pattern</td><td>객체 또는 클래스의 관계와 구조를 다루는 GoF 디자인 패턴</td></tr><tr><td>어댑터</td><td>Adapter</td><td>기존 코드와 새 인터페이스를 연결하는 패턴</td></tr><tr><td>데코레이터</td><td>Decorator</td><td>기능을 동적으로 추가하는 패턴</td></tr><tr><td>컴포지트</td><td>Composite</td><td>객체를 트리 구조로 구성하는 패턴</td></tr></tbody></table><h2 id=-용어-정리>⚠️ 용어 정리<a hidden class=anchor aria-hidden=true href=#-용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>패턴 종류</td><td>Composite</td><td>자식 요소를 포함하는 트리 구조 설계</td></tr><tr><td>패턴 종류</td><td>Decorator</td><td>객체에 기능을 동적으로 추가</td></tr><tr><td>패턴 종류</td><td>Adapter</td><td>호환되지 않는 인터페이스를 연결</td></tr><tr><td>설계 원칙</td><td>Composition over Inheritance</td><td>상속보다 조합을 통한 설계 권장</td></tr></tbody></table><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>OCP (Open-Closed Principle, 개방 - 폐쇄 원칙)</td><td>소프트웨어 구조가 확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙</td></tr><tr><td>SRP (Single Responsibility Principle, 단일 책임 원칙)</td><td>하나의 클래스는 하나의 책임만 가져야 한다는 원칙</td></tr><tr><td>Mock 객체</td><td>테스트를 위해 실제 객체를 대신하는 가짜 객체</td></tr><tr><td>Flyweight (플라이웨이트)</td><td>공유 객체를 사용해 메모리 사용을 최적화하는 패턴</td></tr></tbody></table><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Composite</td><td>트리 구조로 객체를 구성하여 클라이언트가 단일 객체와 복합 객체를 동일하게 다룰 수 있게 하는 패턴</td></tr><tr><td>Proxy</td><td>실제 객체 대신 대리 객체를 사용해 접근 제어, 로깅, 캐싱 등을 수행하는 패턴</td></tr><tr><td>Bridge</td><td>추상화와 구현을 독립적으로 확장할 수 있도록 분리하는 패턴</td></tr><tr><td>Flyweight</td><td>유사한 객체를 공유하여 메모리 사용을 최소화하는 패턴</td></tr><tr><td>Facade</td><td>복잡한 서브시스템을 단순한 인터페이스로 감싸는 패턴</td></tr><tr><td>Decorator</td><td>객체에 기능을 동적으로 추가하는 패턴</td></tr><tr><td>Adapter</td><td>인터페이스 호환이 안 되는 객체를 맞춰주는 패턴</td></tr></tbody></table><h2 id=용어-정리-3>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-3>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>구조적 합성 (Structural Composition)</td><td>여러 객체나 클래스를 조합하여 더 큰 구조를 만드는 기법</td></tr><tr><td>래퍼 객체 (Wrapper Object)</td><td>기존 객체를 감싸서 새로운 인터페이스나 기능을 제공하는 객체</td></tr><tr><td>투명성 (Transparency)</td><td>클라이언트가 개별 객체와 복합 객체를 구분하지 않고 동일하게 처리할 수 있는 특성</td></tr><tr><td>내재적 상태 (Intrinsic State)</td><td>플라이웨이트 패턴에서 여러 객체가 공유할 수 있는 불변 상태</td></tr><tr><td>외재적 상태 (Extrinsic State)</td><td>플라이웨이트 패턴에서 각 객체가 고유하게 가지는 가변 상태</td></tr><tr><td>위임 (Delegation)</td><td>한 객체가 다른 객체에게 작업을 넘기는 메커니즘</td></tr><tr><td>인터페이스 적응 (Interface Adaptation)</td><td>서로 다른 인터페이스를 호환되도록 변환하는 과정</td></tr><tr><td>구조적 변환 (Structural Transformation)</td><td>객체나 클래스의 구조를 다른 형태로 바꾸는 작업</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns>Gangs of Four (GoF) Design Patterns - DigitalOcean</a></li><li><a href=https://refactoring.guru/design-patterns/structural-patterns>Structural Design Patterns - Refactoring Guru</a></li><li><a href=https://www.geeksforgeeks.org/gang-of-four-gof-design-patterns/>Gang of Four (GOF) Design Patterns - GeeksforGeeks</a></li><li><a href=https://www.baeldung.com/java-structural-design-patterns>Proxy, Decorator, Adapter and Bridge Patterns - Baeldung</a></li><li><a href=https://blog.tuanhadev.tech/design-patterns-handbook-part-ii>Understanding Structural Design Pattern - TuanHaDev Blog</a></li><li><a href=https://javatechonline.com/structural-design-patterns-in-java/>Structural Design Patterns in Java - JavaTechOnline</a></li><li><a href=https://www.index.dev/blog/mastering-structural-design-patterns-for-developers-part-2>Mastering Structural Design Patterns for Developers - Index.dev</a></li><li><a href=https://stackabuse.com/structural-design-patterns-in-python/>Structural Design Patterns in Python - Stack Abuse</a></li><li><a href=https://sourcemaking.com/design_patterns>Design Patterns and Refactoring - SourceMaking</a></li><li><a href=https://www.infoq.com/articles/architecture-trends-2025/>InfoQ Software Architecture and Design Trends Report 2025</a></li><li><a href=https://www.clustox.com/blog/software-architecture-patterns/>Top 10 Software Architecture Patterns for 2025 - Clustox</a></li><li><a href=https://www.sayonetech.com/blog/software-architecture-patterns/>Software Architecture Patterns 2025 - SayOne</a></li></ul><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><p><a href=https://refactoring.guru/design-patterns/structural-patterns>Refactoring Guru - Structural Patterns</a></p></li><li><p><a href=https://sourcemaking.com/design_patterns/structural_patterns>SourceMaking - Structural Patterns</a></p></li><li><p><a href=https://www.geeksforgeeks.org/software-design-patterns/>GeeksforGeeks - Structural Design Patterns</a></p></li><li><p><a href=https://docs.spring.io/spring-framework/reference/core/aop.html>Spring Docs - Proxy Pattern 활용</a></p></li><li><p><a href=https://learn.microsoft.com/en-us/dotnet/standard/design-patterns/decorator>Microsoft Learn - Decorator pattern</a></p></li><li><p><a href=https://plantuml.com/>UML 구조 설계 시각화 도구 소개</a></p></li></ul><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><a href=https://refactoring.guru/design-patterns/structural-patterns>Refactoring.Guru - Structural Design Patterns</a></li><li><a href=https://www.coursera.org/articles/gang-of-four-design-patterns>Coursera - Gang of Four Design Patterns</a></li><li><a href=https://bepatterns.com/what-are-structural-design-patterns/>BePatterns - What are Structural Design Patterns?</a></li><li><a href=https://4z7l.github.io/2020/12/25/design_pattern_GoF.html>HERSTORY - GoF(Gang of Four) 디자인 패턴</a></li><li><a href=https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns>DigitalOcean - Gangs of Four (GoF) Design Patterns</a></li><li><a href=https://stackabuse.com/structural-design-patterns-in-python/>Stack Abuse - Structural Design Patterns in Python</a></li><li><a href=https://www.linkedin.com/pulse/structural-design-patterns-building-flexible-scalable-julio-c%C3%A9sar-2jswc>LinkedIn - Structural Design Patterns: Building Flexible and Scalable Code</a></li></ul><h2 id=-참고-및-출처>📚 참고 및 출처<a hidden class=anchor aria-hidden=true href=#-참고-및-출처>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Structural_pattern_%28computer_science%29>GoF “Structural Patterns” (Wikipedia)</a></li><li><a href=https://refactoring.guru/design-patterns/composite>Refactoring Guru – Composite Pattern</a></li><li><a href=https://stackoverflow.com/questions/...>StackOverflow – Decorator vs Proxy vs Adapter 구분 논의</a></li><li>[Java I/O Decorator 구조–Oracle 공식 문서]</li></ul><h2 id=참고-및-출처-3>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-3>#</a></h2><ul><li><a href=https://refactoring.guru/design-patterns/structural-patterns>GoF 구조 패턴 소개(Refactoring Guru)</a></li><li><a href=https://refactoring.guru/design-patterns/adapter>Adapter 패턴 설명(Refactoring Guru)</a></li><li><a href=https://refactoring.guru/design-patterns/decorator>Decorator 패턴 설명(Refactoring Guru)</a></li><li><a href=https://refactoring.guru/design-patterns/composite>Composite 패턴 설명(Refactoring Guru)</a></li><li><a href=https://medium.com/@kentongray/structural-patterns-and-object-oriented-design-7c6e5c8c4a9>구조 패턴과 객체지향 설계(Medium)</a></li><li><a href=https://dev.to/sachinchaurasiya/structural-patterns-in-practice-2f7c>구조 패턴 실무 적용(Dev.to)</a></li><li><a href=https://www.linkedin.com/pulse/structural-patterns-extensibility-michael-schade>구조 패턴과 확장성(LinkedIn)</a></li><li><a href=https://www.javacodegeeks.com/2015/09/structural-patterns-maintainability.html>구조 패턴과 유지보수성(Java Code Geeks)</a></li><li><a href=https://stackoverflow.com/questions/tagged/structural-patterns>구조 패턴 예시(Stack Overflow)</a></li></ul><hr><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Flyweight Pattern</h2></header><div class=entry-content><p>Flyweight Pattern Flyweight 패턴은 구조적 디자인 패턴 중 하나로, 객체를 공유하여 메모리 사용을 최소화하는 패턴이다.
플라이웨이트 패턴은 재사용 가능한 객체 인스턴스를 공유하여 메모리 사용량을 최소화하는 구조 패턴이다.
간단히 말하면 캐시 (Cache) 개념을 코드로 패턴화한 것으로, 자주 변화하는 속성 (extrinsic) 과 변하지 않는 속성 (intrinsic) 을 분리하고 변하지 않는 속성을 캐시하여 재사용함으로써 메모리 사용을 줄이는 방식이다.
Flyweight 패턴의 주요 구성 요소 Flyweight: 경량 객체를 묶는 인터페이스. ConcreteFlyweight: 공유 가능하여 재사용되는 객체로, intrinsic state 를 포함한다. UnsahredConcreteFlyweight: 공유 불가능한 객체로, extrinsic state 를 포함한다. FlyweightFactory: 경량 객체를 만드는 공장 역할과 캐시 역할을 겸비하는 Flyweight 객체 관리 클래스. Client: FlyweightFactory 를 통해 Flyweight 타입의 객체를 얻어 사용한다. Flyweight 패턴의 동작 방식 FlyweightFactory 는 Flyweight 객체들을 생성하고 관리한다. GetFlyweight() 메서드는 팩토리 메서드 역할을 한다. 객체가 메모리에 존재하면 그대로 가져와 반환하고, 없다면 새로 생성해 반환한다. Flyweight 패턴의 장점 많은 객체를 만들 때 성능을 향상시킬 수 있다. 많은 객체를 만들 때 메모리를 줄일 수 있다. 메모리 절약: 대규모 객체 시스템에서 상당한 메모리 절감 효과를 얻을 수 있다. 중복 최소화: 공유를 통해 객체의 중복 생성을 방지한다. Flyweight 패턴의 단점 특정 인스턴스를 다르게 처리하는 것이 힘들어진다. 코드 복잡성 증가: 객체를 공유하는 방식은 구현을 복잡하게 만들 수 있다. 런타임 비용: 객체 상태를 관리하는 데 런타임 비용이 발생할 수 있다. Flyweight 패턴의 사용 시기 대량의 작은 객체를 생성해야 할 때 유용하다. 객체의 상태를 자주 변하는 속성 (Extrinsic) 과 변하지 않는 속성 (Intrinsic) 으로 분리할 수 있을 때 적합하다. 공통된 내재 상태를 공유함으로써 메모리 사용을 줄일 수 있을 때 사용한다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from typing import Dict # Flyweight 클래스: 공유될 객체의 내부 상태를 정의 class CharacterStyle: def __init__(self, font_name: str, font_size: int, bold: bool): self.font_name = font_name self.font_size = font_size self.bold = bold def render(self, char: str, position: tuple) -> None: print(f"Rendering '{char}' at {position} with {self.font_name}, " f"size {self.font_size}, {'bold' if self.bold else 'normal'}") # Flyweight 팩토리: Flyweight 객체들을 관리하고 공유 class CharacterStyleFactory: def __init__(self): self._styles: Dict[str, CharacterStyle] = {} def get_style(self, font_name: str, font_size: int, bold: bool) -> CharacterStyle: # 스타일을 식별하기 위한 키 생성 key = f"{font_name}-{font_size}-{bold}" # 스타일이 존재하지 않으면 새로 생성 if key not in self._styles: self._styles[key] = CharacterStyle(font_name, font_size, bold) print(f"Creating new style: {key}") return self._styles[key] def get_style_count(self) -> int: return len(self._styles) # 문자 객체: Flyweight를 사용하는 클래스 class Character: def __init__(self, char: str, style: CharacterStyle, position: tuple): self.char = char # 외부 상태 (extrinsic state) self.style = style # 공유 상태 (intrinsic state) self.position = position # 외부 상태 def render(self) -> None: self.style.render(self.char, self.position) 실제 사용 예시
...</p></div><footer class=entry-footer><span title='2024-09-25 08:25:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flyweight Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/flyweight-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Composite Pattern</h2></header><div class=entry-content><p>Composite Pattern Composite Pattern 은 구조적 디자인 패턴 중 하나로, 객체들을 트리 구조로 구성하여 부분 - 전체 계층을 표현하는 패턴이다.
Composite Pattern 은 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층 구조를 만든다. 이 패턴을 사용하면 클라이언트가 개별 객체와 복합 객체를 동일하게 다룰 수 있다.
Composite Pattern 은 복잡한 트리 구조를 간단하게 다룰 수 있게 해주는 강력한 도구이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 요구사항과 구조를 고려하여 적절히 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-25 08:24:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composite Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/composite-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decorator Pattern</h2></header><div class=entry-content><p>Decorator Pattern 객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴
" 래퍼 (wrapper)" 개념으로 각 데코레이터는 원본 객체를 감싸면서 추가 기능을 제공한다.
여러 데코레이터를 겹겹이 쌓을 수 있으며, 각 계층은 이전 계층의 기능을 확장한다.
특징 기존 객체의 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 상속 대신 구성 (composition) 을 사용하여 객체의 기능을 확장합니다. 객체를 여러 데코레이터로 감싸 기능을 조합할 수 있습니다. 사용사례 파일 입출력 시스템에서 압축, 암호화, 버퍼링 등의 기능을 조합할 때 웹 서비스에서 로깅, 캐싱, 인증 등의 기능을 동적으로 추가할 때 GUI 컴포넌트에 테두리, 스크롤바, 색상 등의 시각적 요소를 조합할 때 게임 캐릭터에 아이템, 버프, 상태 효과 등을 적용할 때 장점 객체의 기능을 동적으로 확장할 수 있어 매우 유연합니다. 단일 책임 원칙을 지키면서 기능을 조합할 수 있습니다. 상속을 통한 확장보다 더 유연한 방식을 제공합니다. 런타임에 객체의 행동을 변경할 수 있습니다. 단점 데코레이터를 너무 많이 사용하면 코드가 복잡해질 수 있습니다. 데코레이터들의 순서가 결과에 영향을 미칠 수 있어 주의가 필요합니다. 작은 객체들이 많이 생성되어 코드를 이해하기 어려울 수 있습니다. 주의사항 및 고려사항 데코레이터의 순서를 신중하게 고려해야 합니다. 예를 들어, 텍스트 처리에서 HTML 이스케이프를 마크다운 변환 전에 하면 원하는 결과를 얻을 수 없습니다. 데코레이터 체인이 너무 길어지지 않도록 주의해야 합니다. 필요한 경우 자주 사용되는 조합을 별도의 클래스로 만드는 것을 고려하세요. 데코레이터들 간의 상호작용을 고려해야 합니다. 한 데코레이터의 출력이 다른 데코레이터의 입력으로 적절한지 확인해야 합니다. 성능에 민감한 상황에서는 데코레이터 체인으로 인한 오버헤드를 고려해야 합니다. 디버깅이 어려울 수 있으므로, 로깅이나 모니터링 기능을 추가하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 from abc import ABC, abstractmethod from typing import List # Component interface class Coffee(ABC): """Base Coffee interface""" @abstractmethod def get_cost(self) -> float: pass @abstractmethod def get_ingredients(self) -> List[str]: pass @abstractmethod def get_description(self) -> str: pass # Concrete component class SimpleCoffee(Coffee): """Basic coffee implementation""" def get_cost(self) -> float: return 2.0 def get_ingredients(self) -> List[str]: return ["Coffee"] def get_description(self) -> str: return "Simple coffee" # Base decorator class CoffeeDecorator(Coffee): """Base decorator class""" def __init__(self, coffee: Coffee): self._coffee = coffee def get_cost(self) -> float: return self._coffee.get_cost() def get_ingredients(self) -> List[str]: return self._coffee.get_ingredients() def get_description(self) -> str: return self._coffee.get_description() # Concrete decorators class MilkDecorator(CoffeeDecorator): """Adds milk to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.5 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Milk"] def get_description(self) -> str: return f"{super().get_description()}, with steamed milk" class WhipDecorator(CoffeeDecorator): """Adds whipped cream to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.7 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Whipped Cream"] def get_description(self) -> str: return f"{super().get_description()}, topped with whipped cream" class CaramelDecorator(CoffeeDecorator): """Adds caramel to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.6 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Caramel"] def get_description(self) -> str: return f"{super().get_description()}, drizzled with caramel" class ExtraShotDecorator(CoffeeDecorator): """Adds an extra shot of espresso""" def get_cost(self) -> float: return super().get_cost() + 1.0 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Extra Espresso Shot"] def get_description(self) -> str: return f"{super().get_description()}, with an extra shot" # Order management class CoffeeOrder: """Manages coffee orders and provides order summary""" def __init__(self): self.coffee = None def create_order(self) -> None: """Creates a new coffee order starting with simple coffee""" self.coffee = SimpleCoffee() def add_milk(self) -> None: self.coffee = MilkDecorator(self.coffee) def add_whip(self) -> None: self.coffee = WhipDecorator(self.coffee) def add_caramel(self) -> None: self.coffee = CaramelDecorator(self.coffee) def add_extra_shot(self) -> None: self.coffee = ExtraShotDecorator(self.coffee) def get_order_summary(self) -> str: """Generates a summary of the current order""" return f""" Order Summary: Description: {self.coffee.get_description()} Ingredients: {', '.join(self.coffee.get_ingredients())} Total Cost: ${self.coffee.get_cost():f} """ # Usage example if __name__ == "__main__": # Create a new order order = CoffeeOrder() order.create_order() # Customize the coffee with various additions order.add_milk() order.add_extra_shot() order.add_whip() order.add_caramel() # Print the order summary print(order.get_order_summary()) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // Component interface class TextProcessor { constructor() { if (this.constructor === TextProcessor) { throw new Error("Abstract class cannot be instantiated"); } } process(text) { throw new Error("Method 'process' must be implemented"); } } // Concrete component class SimpleTextProcessor extends TextProcessor { process(text) { return text; } } // Base decorator class TextProcessorDecorator extends TextProcessor { constructor(processor) { super(); this._processor = processor; } process(text) { return this._processor.process(text); } } // Concrete decorators class CapitalizeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.toUpperCase(); } } class TrimDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.trim(); } } class HTMLEscapeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/&/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/>/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); } } class MarkdownToHTMLDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/\*\*(.*?)\*\*/g, '&lt;strong>$1&lt;/strong>') .replace(/\*(.*?)\*/g, '&lt;em>$1&lt;/em>') .replace(/\[(.*?)\]\((.*?)\)/g, '&lt;a href="$2">$1&lt;/a>') .replace(/^# (.*$)/gm, '&lt;h1>$1&lt;/h1>') .replace(/^## (.*$)/gm, '&lt;h2>$1&lt;/h2>'); } } class ValidationDecorator extends TextProcessorDecorator { constructor(processor, maxLength = 1000) { super(processor); this.maxLength = maxLength; } process(text) { if (!text) { throw new Error("Text cannot be empty"); } if (text.length > this.maxLength) { throw new Error(`Text length exceeds maximum limit of ${this.maxLength} characters`); } return this._processor.process(text); } } // Text processing manager class TextProcessingManager { constructor() { this.processor = new SimpleTextProcessor(); this.history = []; } addCapitalization() { this.processor = new CapitalizeDecorator(this.processor); return this; } addTrimming() { this.processor = new TrimDecorator(this.processor); return this; } addHTMLEscaping() { this.processor = new HTMLEscapeDecorator(this.processor); return this; } addMarkdownProcessing() { this.processor = new MarkdownToHTMLDecorator(this.processor); return this; } addValidation(maxLength) { this.processor = new ValidationDecorator(this.processor, maxLength); return this; } process(text) { const result = this.processor.process(text); this.history.push({ input: text, output: result, timestamp: new Date() }); return result; } getProcessingHistory() { return this.history; } } // Usage example const manager = new TextProcessingManager(); // Configure text processing chain manager .addValidation(2000) .addTrimming() .addMarkdownProcessing() .addHTMLEscaping(); // Process some text try { const input = ` # Welcome to Text Processing This is a **bold** and *italic* text example. [Click here](https://example.com) to learn more. `; const result = manager.process(input); console.log("Processed text:"); console.log(result); console.log("\nProcessing history:"); console.log(manager.getProcessingHistory()); } catch (error) { console.error("Error processing text:", error.message); } 용어 정리 용어 설명 참고 및 출처 1. 주제의 분류가 적절한지에 대해 조사 Decorator Pattern(데코레이터 패턴) 은 “Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Structural Design Patterns” 분류에 정확히 해당합니다. GoF(Gang of Four) 에서 정의한 구조 (Structural) 패턴 중 하나로, 객체의 기능 확장에 특화된 패턴입니다 [1][2][20].
...</p></div><footer class=entry-footer><span title='2024-09-25 06:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decorator Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/decorator-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Adapter Pattern</h2></header><div class=entry-content><p>Adapter Pattern 호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있도록 하는 구조적 디자인 패턴
한국의 220V 전기 제품을 미국에서 사용하기 위해 변환 어댑터를 사용하듯이, 소프트웨어에서도 호환되지 않는 인터페이스들을 함께 작동하도록 만들어주는 것이 어댑터 패턴의 핵심
특징 기존 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환합니다. 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 협력할 수 있게 합니다. ‘Wrapper’라고도 불립니다. 사용사례 레거시 시스템과 새로운 시스템을 통합할 때 서드파티 라이브러리를 사용할 때 기존 코드의 수정을 최소화하고 싶은 경우 여러 데이터 포맷을 처리해야 하는 경우 외부 API를 내부 시스템에 통합할 때 장점 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있습니다 단일 책임 원칙을 지키면서 코드의 재사용성을 높일 수 있습니다 클래스 간의 결합도를 낮출 수 있습니다 기존 코드와 새로운 코드를 깔끔하게 분리할 수 있습니다 단점 새로운 클래스와 인터페이스가 추가되어 복잡도가 증가할 수 있습니다 때로는 많은 어댑터 클래스를 작성해야 할 수 있습니다 모든 요청이 어댑터를 통과해야 하므로 약간의 오버헤드가 발생할 수 있습니다 주의사항 및 고려사항 어댑터의 책임 범위를 명확히 해야 합니다. 어댑터는 단순히 인터페이스를 변환하는 역할만 해야 하며, 비즈니스 로직을 포함해서는 안 됩니다. 어댑터 패턴을 적용하기 전에 정말로 필요한지 검토해야 합니다. 때로는 기존 코드를 리팩터링하는 것이 더 나은 해결책일 수 있습니다. 어댑터가 처리하는 데이터 변환 과정에서 발생할 수 있는 예외 상황들을 적절히 처리해야 합니다. 양방향 어댑터를 만들 때는 순환 참조가 발생하지 않도록 주의해야 합니다. 성능에 민감한 부분에서는 어댑터로 인한 추가적인 메서드 호출이 성능에 영향을 미칠 수 있음을 고려해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod from typing import Dict # Target Interface class PaymentProcessor(ABC): @abstractmethod def process_payment(self, amount: float) -> bool: pass @abstractmethod def refund_payment(self, amount: float) -> bool: pass # Existing payment system (Adaptee) class StripePaymentSystem: def __init__(self, api_key: str): self.api_key = api_key def create_charge(self, amount: float, currency: str = "USD") -> Dict: # Simulate Stripe API call print(f"Stripe: Charging ${amount} using API key {self.api_key}") return {"success": True, "transaction_id": "str_123", "amount": amount} def create_refund(self, transaction_id: str) -> Dict: # Simulate Stripe API call print(f"Stripe: Refunding transaction {transaction_id}") return {"success": True, "refund_id": "ref_123"} # Another existing payment system (Adaptee) class PayPalAPI: def __init__(self, client_id: str): self.client_id = client_id def submit_payment(self, amount: float) -> Dict: # Simulate PayPal API call print(f"PayPal: Processing payment of ${amount} with client ID {self.client_id}") return {"status": "SUCCESS", "payment_id": "PAY123"} def reverse_payment(self, payment_id: str) -> Dict: # Simulate PayPal API call print(f"PayPal: Reversing payment {payment_id}") return {"status": "SUCCESS"} # Adapter for Stripe class StripeAdapter(PaymentProcessor): def __init__(self, stripe_processor: StripePaymentSystem): self.stripe = stripe_processor self.transaction_records = {} def process_payment(self, amount: float) -> bool: result = self.stripe.create_charge(amount) if result["success"]: self.transaction_records[amount] = result["transaction_id"] return True return False def refund_payment(self, amount: float) -> bool: transaction_id = self.transaction_records.get(amount) if not transaction_id: return False result = self.stripe.create_refund(transaction_id) return result["success"] # Adapter for PayPal class PayPalAdapter(PaymentProcessor): def __init__(self, paypal_processor: PayPalAPI): self.paypal = paypal_processor self.payment_records = {} def process_payment(self, amount: float) -> bool: result = self.paypal.submit_payment(amount) if result["status"] == "SUCCESS": self.payment_records[amount] = result["payment_id"] return True return False def refund_payment(self, amount: float) -> bool: payment_id = self.payment_records.get(amount) if not payment_id: return False result = self.paypal.reverse_payment(payment_id) return result["status"] == "SUCCESS" # Client code def process_order(processor: PaymentProcessor, amount: float): """Process an order using any payment processor""" if processor.process_payment(amount): print(f"Successfully processed payment of ${amount}") return True print(f"Failed to process payment of ${amount}") return False # Usage example if __name__ == "__main__": # Create payment processors stripe_processor = StripePaymentSystem(api_key="sk_test_123") paypal_processor = PayPalAPI(client_id="client_123") # Create adapters stripe_adapter = StripeAdapter(stripe_processor) paypal_adapter = PayPalAdapter(paypal_processor) # Process payments using different processors process_order(stripe_adapter, 100.00) process_order(paypal_adapter, 50.00) # Test refunds stripe_adapter.refund_payment(100.00) paypal_adapter.refund_payment(50.00) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 // Target interface (what the client expects) class DataAnalyzer { analyze(data) { throw new Error('analyze method must be implemented'); } getReport() { throw new Error('getReport method must be implemented'); } } // Existing CSV data processor (Adaptee) class CSVProcessor { constructor() { this.data = null; } loadCSV(csvData) { // Simulate processing CSV data console.log('Processing CSV data…'); this.data = csvData.split('\n').map(row => row.split(',')); return true; } generateStats() { if (!this.data) return null; // Simulate generating statistics return { rowCount: this.data.length, columnCount: this.data[0].length, format: 'CSV' }; } } // Existing JSON data processor (Adaptee) class JSONProcessor { constructor() { this.jsonData = null; } parseJSON(jsonString) { // Simulate parsing JSON data console.log('Parsing JSON data…'); this.jsonData = JSON.parse(jsonString); return { success: true, timestamp: new Date() }; } calculateMetrics() { if (!this.jsonData) return null; // Simulate calculating metrics return { size: JSON.stringify(this.jsonData).length, type: 'JSON', keys: Object.keys(this.jsonData) }; } } // Adapter for CSV Processor class CSVAdapter extends DataAnalyzer { constructor(csvProcessor) { super(); this.processor = csvProcessor; this.analysis = null; } analyze(data) { const success = this.processor.loadCSV(data); if (success) { this.analysis = this.processor.generateStats(); return true; } return false; } getReport() { if (!this.analysis) return null; return { type: 'CSV Analysis', entries: this.analysis.rowCount, fields: this.analysis.columnCount, format: this.analysis.format, timestamp: new Date() }; } } // Adapter for JSON Processor class JSONAdapter extends DataAnalyzer { constructor(jsonProcessor) { super(); this.processor = jsonProcessor; this.analysis = null; } analyze(data) { const result = this.processor.parseJSON(data); if (result.success) { this.analysis = this.processor.calculateMetrics(); return true; } return false; } getReport() { if (!this.analysis) return null; return { type: 'JSON Analysis', dataSize: this.analysis.size, format: this.analysis.type, availableFields: this.analysis.keys, timestamp: new Date() }; } } // Client code class DataAnalysisService { constructor(analyzer) { this.analyzer = analyzer; } processData(data) { if (this.analyzer.analyze(data)) { const report = this.analyzer.getReport(); console.log('Analysis Report:', report); return report; } console.log('Analysis failed'); return null; } } // Usage example const csvData = 'name,age,city\nJohn,New York\nJane,Boston'; const jsonData = JSON.stringify({ users: [ { name: 'John', age: 30, city: 'New York' }, { name: 'Jane', age: 25, city: 'Boston' } ] }); // Create processors and adapters const csvProcessor = new CSVProcessor(); const jsonProcessor = new JSONProcessor(); const csvAdapter = new CSVAdapter(csvProcessor); const jsonAdapter = new JSONAdapter(jsonProcessor); // Analyze both types of data using the same interface const analysisService = new DataAnalysisService(csvAdapter); analysisService.processData(csvData); const jsonAnalysisService = new DataAnalysisService(jsonAdapter); jsonAnalysisService.processData(jsonData); 용어 정리 용어 설명 참고 및 출처 1. 주제의 분류가 적절한지에 대해 조사 Adapter Pattern(어댑터 패턴)은 “Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Structural Design Patterns” 분류에 정확하게 해당합니다. GoF(Gang of Four)에서 정의한 23가지 디자인 패턴 중 구조(Structural) 패턴에 속하며, 호환되지 않는 인터페이스를 연결하는 데 중점을 둡니다[1][2][6].
...</p></div><footer class=entry-footer><span title='2024-09-25 06:13:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adapter Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/structural/adapter-pattern/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>