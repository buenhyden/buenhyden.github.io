<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creational | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,Design-and-Architecture,Software-Design-Patterns,GoF,Creational,Single-Instance-per-App-Lifecycle"><meta name=description content="Creational Design Patterns(생성 디자인 패턴) 는 객체 생성 메커니즘을 다루는 디자인 패턴 분류로, 시스템이 객체를 생성, 구성, 표현하는 방식에 독립성을 제공한다. GoF 에서 정의한 5 가지 패턴 (Singleton, Factory Method, Abstract Factory, Builder, Prototype) 을 포함하며, 객체 생성의 복잡성을 캡슐화하고 유연성을 향상시켜 재사용 가능하고 유지보수가 용이한 소프트웨어 시스템 구축을 지원한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Creational"><meta property="og:description" content="Creational Design Patterns(생성 디자인 패턴) 는 객체 생성 메커니즘을 다루는 디자인 패턴 분류로, 시스템이 객체를 생성, 구성, 표현하는 방식에 독립성을 제공한다. GoF 에서 정의한 5 가지 패턴 (Singleton, Factory Method, Abstract Factory, Builder, Prototype) 을 포함하며, 객체 생성의 복잡성을 캡슐화하고 유연성을 향상시켜 재사용 가능하고 유지보수가 용이한 소프트웨어 시스템 구축을 지원한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Creational"><meta name=twitter:description content="Creational Design Patterns(생성 디자인 패턴) 는 객체 생성 메커니즘을 다루는 디자인 패턴 분류로, 시스템이 객체를 생성, 구성, 표현하는 방식에 독립성을 제공한다. GoF 에서 정의한 5 가지 패턴 (Singleton, Factory Method, Abstract Factory, Builder, Prototype) 을 포함하며, 객체 생성의 복잡성을 캡슐화하고 유연성을 향상시켜 재사용 가능하고 유지보수가 용이한 소프트웨어 시스템 구축을 지원한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":5,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/"},{"@type":"ListItem","position":6,"name":"Creational","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/>GoF</a></div><h1>Creational</h1><div class=post-description>Creational Design Patterns(생성 디자인 패턴) 는 객체 생성 메커니즘을 다루는 디자인 패턴 분류로, 시스템이 객체를 생성, 구성, 표현하는 방식에 독립성을 제공한다. GoF 에서 정의한 5 가지 패턴 (Singleton, Factory Method, Abstract Factory, Builder, Prototype) 을 포함하며, 객체 생성의 복잡성을 캡슐화하고 유연성을 향상시켜 재사용 가능하고 유지보수가 용이한 소프트웨어 시스템 구축을 지원한다.</div></header><div class=post-content><h2 id=creational>Creational<a hidden class=anchor aria-hidden=true href=#creational>#</a></h2><p>생성 패턴은 객체 생성 방식을 다양한 방법으로 추상화하여, 시스템의 유연성과 확장성을 높이는 디자인 패턴이다.<br>이러한 패턴은 객체 생성 로직을 별도의 클래스로 분리하거나, 객체 생성을 위한 인터페이스를 제공함으로써, 코드의 결합도를 낮추고, 유지보수성과 테스트 용이성을 향상시킨다.<br>대표적인 생성 패턴으로는 싱글톤 (Singleton), 팩토리 메서드 (Factory Method), 추상 팩토리 (Abstract Factory), 빌더 (Builder), 프로토타입 (Prototype) 등이 있다. <strong>Factory Method</strong>는 서브클래스에 생성 책임을 위임하고, <strong>Abstract Factory</strong>는 관련 객체군을 생성하며, <strong>Builder</strong>는 복잡 객체를 단계적으로 구성하고, <strong>Prototype</strong>은 복제 방식을 제공하며, <strong>Singleton</strong>은 전역 인스턴스를 보장한다.</p><h3 id=배경-및-필요성>배경 및 필요성<a hidden class=anchor aria-hidden=true href=#배경-및-필요성>#</a></h3><ul><li>객체 생성이 단순하지 않고, 다양한 조건, 설정, 리소스 관리가 필요할 때 코드가 복잡해짐.</li><li>생성 패턴은 이러한 복잡성을 추상화하여, 클라이언트 코드가 객체 생성 방법을 몰라도 사용할 수 있게 한다.</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ul><li><strong>객체 생성 책임 분리:</strong> 객체 생성 로직을 캡슐화하여, 클라이언트 코드와 객체 생성 코드를 분리한다.</li><li><strong>유연성:</strong> 객체 생성 방식을 동적으로 변경할 수 있다.</li><li><strong>확장성:</strong> 새로운 객체 유형을 쉽게 추가할 수 있다.</li></ul><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>생성 디자인 패턴은 객체 생성 로직을 분리하여, 코드의 유연성, 재사용성, 유지보수성을 향상시키는 설계 패턴이다. 이를 통해 객체 생성 과정을 캡슐화하고, 복잡한 생성 로직을 감추며, 다양한 객체 생성 요구를 효율적으로 처리한다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><ul><li><strong>객체 생성 메커니즘 (Object Creation Mechanism)</strong>: 시스템에서 객체를 생성하는 방법과 절차</li><li><strong>캡슐화 (Encapsulation)</strong>: 객체 생성 로직을 숨기고 인터페이스를 통해 접근하는 방식</li><li><strong>디커플링 (Decoupling)</strong>: 클라이언트 코드와 구체적인 클래스 간의 결합도 감소</li><li><strong>추상화 (Abstraction)</strong>: 구체적인 구현 대신 인터페이스나 추상 클래스 사용</li></ul><h4 id=심화-개념>심화 개념<a hidden class=anchor aria-hidden=true href=#심화-개념>#</a></h4><ul><li><strong>객체 지향 설계 원칙 (OOP Design Principles)</strong>: SOLID 원칙과의 연관성</li><li><strong>의존성 주입 (Dependency Injection)</strong>: 현대적 대안으로서의 DI 패턴</li><li><strong>메타클래스 (Metaclass)</strong>: 클래스의 클래스 개념을 통한 동적 객체 생성</li><li><strong>리플렉션 (Reflection)</strong>: 런타임 시 동적 객체 생성 기법</li></ul><h4 id=실무-구현-연관성>실무 구현 연관성<a hidden class=anchor aria-hidden=true href=#실무-구현-연관성>#</a></h4><table><thead><tr><th>패턴</th><th>적용 상황</th><th>효과</th></tr></thead><tbody><tr><td>Factory Method</td><td>로그, 메시지 처리 등 특정 구현 객체가 런타임 결정</td><td>런타임 유연성 증가</td></tr><tr><td>Abstract Factory</td><td>UI 테마 세트, DB 드라이버 플랫폼 대응 등</td><td>제품군 일관성 유지</td></tr><tr><td>Builder</td><td>복잡 객체 생성 (예: HTTP 클라이언트, 파일 포맷)</td><td>가독성↑, 생성 옵션 구조화</td></tr><tr><td>Prototype</td><td>비용이 큰 객체 복제 시 (예: 게임 엔티티 복제)</td><td>복제 간편, 런타임 구성 가능</td></tr><tr><td>Singleton</td><td>전역 설정, 로깅, 캐시, DB 연결 등</td><td>전역 접근성, 자원 절약 효과</td></tr></tbody></table><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li><strong>객체 생성 캡슐화:</strong> 객체 생성 로직을 패턴으로 구조화한다.</li><li><strong>객체 생성 책임 분리:</strong> 클라이언트 코드와 객체 생성 코드를 분리한다.</li><li><strong>객체 생성 방식 동적 변경:</strong> 객체 생성 방식을 동적으로 변경할 수 있다.</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p><strong>핵심 특징:</strong></p><ul><li>객체 생성과 사용의 분리</li><li>구성 (Composition) 중심의 설계</li><li>인터페이스 기반 상호작용</li><li>런타임 유연성 제공</li></ul><p><strong>기술적 특징:</strong></p><ul><li>상속보다 합성 선호</li><li>개방 - 폐쇄 원칙 (Open-Closed Principle) 준수</li><li>단일 책임 원칙 (Single Responsibility Principle) 적용</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ol><li><strong>프로그래밍은 인터페이스에 대해, 구현에 대해서가 아니다</strong></li><li><strong>상속보다 객체 합성을 선호하라</strong></li><li><strong>변화하는 것을 캡슐화하라</strong></li><li><strong>느슨한 결합 (Loose Coupling) 추구</strong></li></ol><h3 id=생성-패턴의-종류-및-비교>생성 패턴의 종류 및 비교<a hidden class=anchor aria-hidden=true href=#생성-패턴의-종류-및-비교>#</a></h3><table><thead><tr><th>패턴</th><th>핵심 개념</th><th>주요 특징·장점</th><th>사용 시점 / 목적</th><th>실무 예시</th></tr></thead><tbody><tr><td><strong>Singleton</strong></td><td>애플리케이션 전체에서 오직 하나의 인스턴스만 존재하도록 보장하고, 전역 접근 지점 제공</td><td>• 전역 상태 공유<br>• Lazy Initialization 및 Thread-safe 구현 가능<br>• 인스턴스 관리 일원화</td><td>• 설정, 로그, 캐시 등 <strong>하나</strong>만 있으면 되는 자원 관리<br>• DB 연결·커넥션 풀처럼 동시에 여러 곳에서 동일 자원을 요청할 때</td><td>데이터베이스 커넥션 풀 관리 객체를 단일 인스턴스로 노출해 다중 스레드가 공유하도록 구성</td></tr><tr><td><strong>Factory Method</strong></td><td>상위 클래스에 <strong>생성 인터페이스</strong>를 정의하고, 실제 객체 생성은 하위 클래스가 결정</td><td>• 생성 로직을 서브클래스에 위임 → OCP 충실<br>• 클라이언트 - 코드와 구체 클래스 간 결합 최소화</td><td>• OS·플랫폼별로 <strong>다른 구현체</strong>가 필요한 UI 위젯, 로거 등<br>• 라이브러리에서 확장 포인트 제공하고 싶을 때</td><td>운영체제마다 서로 다른 <code>Button</code> 을 반환하도록 하는 크로스 - 플랫폼 GUI 툴킷</td></tr><tr><td><strong>Abstract Factory</strong></td><td><strong>연관된 객체군</strong>(제품 패밀리) 을 일관성 있게 생성하는 상위 인터페이스 제공</td><td>• 제품군 간 <strong>호환성·일관성</strong> 보장<br>• 클라이언트는 구체 공장·제품 클래스 알 필요 없음</td><td>• 테마·브랜드·OS 에 따라 <strong>버튼 + 체크박스 + 메뉴</strong> 등을 세트로 바꿔야 할 때<br>• 제품군 교체를 런타임 설정으로 전환하려 할 때</td><td>라이트/다크 테마 UI 컴포넌트를 한 번에 교체하는 테마 엔진</td></tr><tr><td><strong>Builder</strong></td><td><strong>복잡한 객체</strong>를 단계별로 조립하고, 동일 공정으로 서로 다른 표현을 생성</td><td>• 가독성 높은 단계별 API(플루언트 인터페이스)<br>• 파라미터 폭발·불변 객체 문제 해결<br>• Director 를 통해 생성 절차 재사용</td><td>• 필드가 많은 DTO, JSON, HTML, 그래프 등 <strong>복합 구조</strong> 생성<br>• 선택적·반복적 구성 요소가 많은 경우</td><td>메서드 체인을 이용해 SELECT·WHERE·ORDER BY 를 조립하는 SQL Query Builder</td></tr><tr><td><strong>Prototype</strong></td><td>기존 객체를 <strong>복제 (clone)</strong> 하여 새로운 객체 생성</td><td>• 객체 생성 비용·복잡도↓<br>• 런타임에 타입 몰라도 복제 가능<br>• 깊은/얕은 복제 전략 선택</td><td>• 데이터 - 집약적 초기화가 큰 비용을 차지할 때<br>• 동적 로딩 플러그인에서 새로운 인스턴스 필요할 때</td><td>게임에서 몬스터 템플릿을 미리 생성해 스폰 시마다 복제하여 성능 최적화</td></tr></tbody></table><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>원인/특성</th></tr></thead><tbody><tr><td>장점</td><td>유연성</td><td>객체 생성 방식을 동적으로 변경할 수 있음</td><td>객체 생성 캡슐화</td></tr><tr><td></td><td>확장성</td><td>새로운 객체 유형을 쉽게 추가할 수 있음</td><td>객체 생성 책임 분리</td></tr><tr><td></td><td>책임 분리</td><td>클라이언트 코드와 객체 생성 코드를 분리하여 복잡성 낮춤</td><td>객체 생성 책임 분리</td></tr><tr><td></td><td>재사용성</td><td>객체 생성 로직을 여러 곳에서 재사용 가능</td><td>객체 생성 캡슐화</td></tr></tbody></table><h3 id=단점과-문제점-및-해결방안>단점과 문제점 및 해결방안<a hidden class=anchor aria-hidden=true href=#단점과-문제점-및-해결방안>#</a></h3><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><table><thead><tr><th>항목</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>복잡성</td><td>패턴 적용 시 시스템 복잡성 증가</td><td>명확한 인터페이스, 문서화</td></tr><tr><td>러닝커브</td><td>패턴 이해 및 적용에 학습 필요</td><td>교육, 예제 제공</td></tr></tbody></table><h4 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h4><table><thead><tr><th>항목</th><th>원인</th><th>영향</th><th>탐지/진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>객체 생성 실패</td><td>팩토리 생성 실패</td><td>객체 사용 불가</td><td>코드 리뷰</td><td>팩토리 검증</td><td>팩토리 생성 검증</td></tr><tr><td>싱글톤 오용</td><td>불필요한 싱글톤 적용</td><td>확장성 저하</td><td>코드 리뷰</td><td>필요시만 적용</td><td>패턴 선택 재검토</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>카테고리</th><th>핵심 도전 과제</th><th>구체적 문제점</th><th>대표 해결 전략·모범 사례</th></tr></thead><tbody><tr><td><strong>설계 · 선택</strong></td><td>패턴 선택의 복잡성</td><td>• 상황별 적절 패턴 결정 난도<br>• 과도한 추상화로 코드 가독성 저하</td><td>• 요구사항·제약조건 매트릭스 작성 후 의사결정<br>• 프로토타입으로 타당성 검증 (PoC)<br>• " 패턴 카탈로그 " 와 체크리스트로 오남용 방지</td></tr><tr><td><strong>언어 · 플랫폼</strong></td><td>언어적 한계·Reflection 의존</td><td>• 생성자 오버로드 부족<br>• 리플렉션·프록시 남용 시 성능·보안 저하</td><td>• - 변형 Factory(등록 맵·람다 팩토리) 로 동적 타입 해결<br>• 메타프로그래밍 대신 코드 생성 (Annotation Processor, Codegen) 활용</td></tr><tr><td><strong>동시성 · 안정성</strong></td><td>싱글턴 스레드 안전</td><td>• 초기화 경합·데드락·중복 생성</td><td>• Double-Checked Locking(volatile)·정적 Holder<br>• JVM 이니셜라이저·enum 싱글턴<br>• DI 컨테이너 Scope 활용</td></tr><tr><td><strong>테스트 · 운영</strong></td><td>테스트용 교체 (스왑) 곤란</td><td>• 생산 코드와 결합 강해 Mock/Stub 주입 어려움</td><td>• 팩토리 주입 (Strategy 패턴)·Service Locator 추상화<br>• Provider 인터페이스 + DI 컨테이너로 런타임 스왑</td></tr><tr><td><strong>최신 기술 환경</strong></td><td>클라우드·서버리스·MSA 적용</td><td>• 인스턴스 생성 주기·스케일 아웃으로 싱글턴 의미 희석<br>• 무상태 함수형 플랫폼과 충돌</td><td>• 컨테이너 당 싱글턴 → Stateless Factory 로 전환<br>• 외부 스테이트 (예: Config Server, Redis) 활용</td></tr><tr><td><strong>성능 최적화</strong></td><td>생성 오버헤드·메모리</td><td>• 빈번한 객체 생성으로 GC 부하<br>• 대형 객체 초기화 비용 증가</td><td>• 객체 풀링·Flyweight<br>• Lazy Initialization·캐싱 전략<br>• Builder 단계별 스트림 처리로 중간 객체 감소</td></tr><tr><td><strong>메모리 관리</strong></td><td>객체 수명 · 누수 통제</td><td>• 길게 참조된 객체로 메모리 누수</td><td>• 약참조 (Weak/Soft Reference)·Scope 관리<br>• Prototype + Pooling 혼합으로 수명 제어</td></tr></tbody></table><h3 id=실무-사용-예시>실무 사용 예시<a hidden class=anchor aria-hidden=true href=#실무-사용-예시>#</a></h3><table><thead><tr><th>도메인/시스템</th><th>사용 패턴</th><th>적용 목적</th><th>구체적 사례 (라이브러리·기술)</th><th>주요 효과</th></tr></thead><tbody><tr><td><strong>인프라‧설정 관리</strong></td><td>Singleton</td><td>전역 상태·자원 (로그·설정 등) 단일 인스턴스 공유</td><td>Log4j <code>Logger</code>, 환경 <code>ConfigurationManager</code></td><td>인스턴스 일관성, 동시성 안전, 자원 관리 효율</td></tr><tr><td><strong>데이터베이스 접근 계층</strong></td><td>Abstract Factory</td><td>URL·드라이버 종류별 커넥션 객체군 생성</td><td>JDBC <code>DriverManager</code> → 특정 <code>Driver</code> 선택</td><td>DB 종속성 최소화, 멀티 - 벤더 확장성</td></tr><tr><td><strong>웹 프레임워크</strong></td><td>Factory Method</td><td>요청 경로·HTTP 메서드에 따른 처리기 동적 생성</td><td>Spring MVC <code>HandlerMapping</code>(factory method 로 매핑 객체 반환)</td><td>모듈화, OCP 준수, 테스트 용이성</td></tr><tr><td><strong>UI 테마 시스템</strong></td><td>Abstract Factory</td><td>버튼·체크박스 등 위젯 세트를 통일된 L&amp;F 로 생성</td><td>Swing / WPF Look-and-Feel Factory</td><td>UI 일관성, 테마 교체 유연성</td></tr><tr><td><strong>HTTP 클라이언트</strong></td><td>Builder</td><td>헤더·쿼리·타임아웃 등 옵션 체인 방식으로 요청 구성</td><td>OkHttp <code>Request.Builder</code>, Retrofit <code>Retrofit.Builder</code></td><td>가독성, 선택적 파라미터 관리, 불변 객체 유지</td></tr><tr><td><strong>게임 개발</strong></td><td>Prototype</td><td>캐릭터·아이템 템플릿을 빠르게 복제해 인스턴스화</td><td>Unity <code>ScriptableObject</code> 기반 오브젝트 복제</td><td>생성 비용 절감, 런타임 성능 향상</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-전자상거래-플랫폼>사례 1: 전자상거래 플랫폼<a hidden class=anchor aria-hidden=true href=#사례-1-전자상거래-플랫폼>#</a></h4><p><strong>시나리오</strong>: 대규모 온라인 쇼핑몰 시스템에서 다양한 결제 방식과 배송 옵션을 지원하는 주문 처리 시스템</p><p><strong>시스템 구성</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[주문 관리자] ─── [결제 처리 팩토리] ─── [신용카드 처리기]
</span></span><span class=line><span class=cl>     │                 │                    │
</span></span><span class=line><span class=cl>     │                 └─── [페이팔 처리기]   │
</span></span><span class=line><span class=cl>     │                                      │
</span></span><span class=line><span class=cl>     └─── [배송 서비스 팩토리] ─── [일반 배송]    │
</span></span><span class=line><span class=cl>                 │                         │
</span></span><span class=line><span class=cl>                 └─── [익일 배송] ──────────┘
</span></span></code></pre></td></tr></table></div></div><p><strong>활용된 패턴들</strong>:</p><ol><li><strong>Abstract Factory</strong>: 결제 처리와 배송 서비스의 패밀리 생성</li><li><strong>Builder</strong>: 복잡한 주문 정보 구성</li><li><strong>Singleton</strong>: 전역 설정 관리자</li></ol><p><strong>Workflow</strong>:</p><ol><li>고객이 주문 생성 요청</li><li>주문 빌더가 단계별로 주문 정보 구성</li><li>Abstract Factory 가 결제 방식에 따른 처리기 생성</li><li>Singleton 설정 관리자에서 배송 정책 조회</li><li>구성된 주문 객체 반환</li></ol><p><strong>담당 역할</strong>:</p><ul><li><strong>Factory 패턴</strong>: 결제 타입별 처리기 동적 생성</li><li><strong>Builder 패턴</strong>: 주문의 복잡한 설정 관리</li><li><strong>Singleton 패턴</strong>: 시스템 전반의 설정 정보 관리</li></ul><h4 id=사례-2-http-클라이언트-구성>사례 2: HTTP 클라이언트 구성<a hidden class=anchor aria-hidden=true href=#사례-2-http-클라이언트-구성>#</a></h4><p><strong>문제</strong>: GET, POST, 헤더, 쿼리 스트링 등 다양한 옵션의 조합이 필요하기 때문에 Builder 패턴을 사용</p><p><strong>적용</strong>:</p><ul><li><code>RequestBuilder</code> 가 메서드 체이닝으로 옵션 설정 제공</li><li><code>build()</code> 호출 시 <code>Request</code> 객체 완성</li></ul><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Client
    participant Builder
    participant Product

    Client-&gt;&gt;Builder: new Builder()
    Client-&gt;&gt;Builder: setUrl(), setHeader(), setBody()
    Client-&gt;&gt;Builder: build()
    Builder--&gt;&gt;Product: complete Request 객체
</pre><p><em>Builder 사용 여부 효과 비교</em>*:</p><ul><li>✅ <strong>Builder 적용</strong>: 가독성 좋고 옵션 확장에 유연</li><li>❌ <strong>직접 빌드</strong>: 파라미터 수 증가 → 코드 복잡, 유지보수 어려움</li></ul><h4 id=사례-3-객체-생성-로직-캡슐화>사례 3: 객체 생성 로직 캡슐화<a hidden class=anchor aria-hidden=true href=#사례-3-객체-생성-로직-캡슐화>#</a></h4><p>Factory 패턴 적용 사례</p><p><strong>시스템 구성:</strong></p><ul><li>Client → Factory → Product</li><li>Factory 가 Product 생성 담당</li></ul><p><strong>Workflow:</strong></p><ol><li>Client 가 Factory 에 객체 생성 요청</li><li>Factory 가 Product 생성</li><li>Client 가 Product 사용</li></ol><p><strong>역할:</strong></p><ul><li>객체 생성 로직을 캡슐화하여, 클라이언트 코드와 객체 생성 코드를 분리</li><li>유연성과 확장성 향상</li></ul><p><strong>차이점:</strong></p><ul><li>패턴 미적용 시 클라이언트 코드가 객체 생성 로직을 직접 포함</li><li>패턴 적용 시 객체 생성 로직이 캡슐화되어 유지보수 및 확장성 향상</li></ul><p><strong>구현 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Factory 패턴 예시</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Product</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>operation</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcreteProductA</span><span class=p>(</span><span class=n>Product</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>operation</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;ConcreteProductA operation&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcreteProductB</span><span class=p>(</span><span class=n>Product</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>operation</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;ConcreteProductB operation&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Factory</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>create_product</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>type_</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>type_</span> <span class=o>==</span> <span class=s2>&#34;A&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ConcreteProductA</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>type_</span> <span class=o>==</span> <span class=s2>&#34;B&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ConcreteProductB</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>ValueError</span><span class=p>(</span><span class=s2>&#34;Unknown type&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>factory</span> <span class=o>=</span> <span class=n>Factory</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>product</span> <span class=o>=</span> <span class=n>factory</span><span class=o>.</span><span class=n>create_product</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>product</span><span class=o>.</span><span class=n>operation</span><span class=p>()</span>  <span class=c1># 출력: ConcreteProductA operation</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실무-적용-고려사항>실무 적용 고려사항<a hidden class=anchor aria-hidden=true href=#실무-적용-고려사항>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>고려 항목</strong></th><th><strong>설명</strong></th><th><strong>권장 사항</strong></th><th><strong>주의할 점</strong></th></tr></thead><tbody><tr><td><strong>설계</strong></td><td>패턴 선택 기준</td><td>문제 유형과 복잡도에 맞는 패턴 선정 필요</td><td>요구사항 분석 후 적절한 패턴만 사용</td><td>단순 객체 생성에 과도한 패턴 적용 금지</td></tr><tr><td></td><td>추상화 수준 조절</td><td>고차 추상화는 유지보수와 협업 난이도 증가 가능</td><td>필요 최소한의 추상화, 구조 명확화</td><td>과도한 추상화로 인한 코드 난독화</td></tr><tr><td><strong>구현</strong></td><td>인터페이스 명확화</td><td>팩토리·빌더 등 생성자 인터페이스는 명확하고 단순해야 함</td><td>기능별 인터페이스 분리, 메서드 체이닝 및 alias 제공</td><td>의미 불분명한 메서드 및 중복 로직</td></tr><tr><td></td><td>구조적 분리</td><td>생성 관련 클래스의 위치·의존성 정리 필요</td><td>패키지/모듈 분리, 네이밍 표준화</td><td>생성자 클래스와 도메인 로직 혼합 금지</td></tr><tr><td><strong>테스트</strong></td><td>테스트 용이성 확보</td><td>전역 객체나 고정 인스턴스는 테스트를 어렵게 만듦</td><td>DI 기반 설계, 팩토리 추상화, Mock 객체 구성</td><td>Singleton 남용 시 테스트 격리 어려움</td></tr><tr><td></td><td>객체 조합 테스트</td><td>다양한 생성 경로와 조합에 대한 테스트 필요</td><td>단위/통합 테스트 강화, 테스트 케이스 자동화</td><td>테스트 커버리지 부족으로 인한 오류 누락</td></tr><tr><td><strong>성능</strong></td><td>객체 생성 비용 고려</td><td>무거운 객체는 필요 시점에 생성 또는 재사용</td><td>Lazy Initialization, 객체 풀링, 캐싱 전략 적용</td><td>불필요한 사전 초기화로 인한 메모리 낭비</td></tr><tr><td></td><td>메모리 관리</td><td>객체 생명주기 명확히 해야 누수 방지 가능</td><td>약참조 활용, 불필요 객체 해제, GC 유도 고려</td><td>참조 지속으로 인한 GC 회수 실패</td></tr><tr><td><strong>유지보수</strong></td><td>구조 변경 영향도 최소화</td><td>생성 로직 변경 시 시스템 전체에 영향 미치지 않도록 분리 구성</td><td>생성 책임 모듈화, OCP 원칙 적용</td><td>코드 변경 시 ripple effect 발생 가능</td></tr><tr><td></td><td>문서화 및 공유</td><td>패턴 사용 이유와 구조는 명확히 공유되어야 협업 가능</td><td>UML, README, 주석 등으로 생성 흐름 및 책임 명시</td><td>과도한 문서화로 실시간 유지 어려움</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th><th><strong>주의점</strong></th></tr></thead><tbody><tr><td>메모리 최적화</td><td>객체 풀링</td><td>자주 생성되는 객체를 재사용하여 메모리 할당 감소</td><td>Object Pool, Reuse 전략 적용</td><td>메모리 누수, 동기화 필요</td></tr><tr><td></td><td>객체 생성 캐싱</td><td>동일 객체 중복 생성을 방지하여 메모리 사용량 절감</td><td>객체 Cache 또는 Flyweight 패턴 적용</td><td>캐시 갱신 정책, 불일치 이슈</td></tr><tr><td></td><td>메모리 프로파일링</td><td>생성 및 유지 객체 수 모니터링을 통해 최적화 포인트 도출</td><td>실제 운영 환경에서 메모리 사용 모니터링</td><td>프로파일링 자체의 오버헤드</td></tr><tr><td>성능 최적화</td><td>지연 초기화</td><td>실제로 필요한 시점에 객체 생성하여 불필요한 리소스 낭비 방지</td><td>Lazy Initialization</td><td>첫 사용 시점 지연 발생 가능</td></tr><tr><td></td><td>팩토리 호출 오버헤드</td><td>단순 객체 생성에 복잡한 팩토리 사용은 오히려 성능 저하</td><td>직접 생성 또는 경량 팩토리 도입 고려</td><td>과도한 추상화 또는 Factory 오용</td></tr><tr><td></td><td>복제 비용 관리</td><td>프로토타입 패턴 사용 시 깊은 복제는 성능 이슈 유발 가능</td><td>얕은 복제 (Shallow Copy) 또는 복제 전략 분리</td><td>깊은 복제 시 자원 낭비 가능</td></tr><tr><td>동시성 및 안정성</td><td>스레드 안전성</td><td>멀티스레드 환경에서 객체 공유 시 적절한 동기화 필요</td><td>synchronized, volatile, Concurrent 구조 사용</td><td>과도한 동기화로 인한 병목</td></tr><tr><td></td><td>싱글턴 동기화 전략</td><td>동시 초기화 시 race condition 방지 필요</td><td><code>enum Singleton</code>, <code>static inner class</code>, DCL(Double-Checked Locking)</td><td>잘못된 동기화는 예외나 중복 인스턴스 초래</td></tr><tr><td>생성 전략 관리</td><td>생성 비용 고려</td><td>고비용 객체는 매번 새로 생성하지 않도록 주의</td><td>Pool, Prototype 전략, Factory 패턴 활용</td><td>재사용보다 단순 생성이 더 나은 경우 고려</td></tr><tr><td></td><td>불필요한 추상화 제거</td><td>단순 객체 생성에 불필요한 추상화 계층 도입 시 성능 오히려 저하</td><td>설계 간결화, 간단한 경우 직접 생성 사용</td><td>유지보수보다 성능이 중요한 경우만 적용</td></tr><tr><td>객체 생명주기 관리</td><td>빌더 객체 재사용</td><td>Builder 매번 새로 생성하면 GC 부하 증가 가능</td><td>재사용 가능한 Builder 설계</td><td>재사용 시 내부 상태 초기화 주의</td></tr><tr><td></td><td>생성/삭제 시점 최적화</td><td>객체를 언제 만들고 제거할 것인지 전략적으로 관리 필요</td><td>지연 생성, 비동기 제거, 참조 관리</td><td>객체 누수, 참조 카운팅 실패 등</td></tr></tbody></table><ul><li>생성 패턴은 다른 디자인 패턴과 결합하여 사용될 수 있다. 예를 들어, Builder 패턴은 Abstract Factory 패턴과 함께 사용되어 복잡한 객체 생성을 더욱 유연하게 할 수 있다. 또한, Prototype 패턴은 Singleton 패턴과 함께 사용되어 객체 복제를 제한할 수 있다.</li></ul><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>핵심 항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>기술 트렌드</strong></td><td>클라우드/서버리스</td><td>객체 수명 관리, Stateless 생성</td><td>클라우드 환경에서 Singleton, Pool, Lazy Init 등의 생성 전략 재정의 필요</td></tr><tr><td></td><td>웹어셈블리 (WASM)</td><td>경량 객체 팩토리</td><td>WASM 모듈 내 객체 생성 비용을 줄이기 위한 팩토리 최적화</td></tr><tr><td></td><td>GraphQL 런타임 처리</td><td>동적 스키마 생성 팩토리</td><td>GraphQL 스키마를 런타임에 조립하는 동적 팩토리 전략 활용</td></tr><tr><td></td><td>함수형 프로그래밍</td><td>불변 객체 생성</td><td>Immutable 객체 생성을 위한 Builder 변형 활용</td></tr><tr><td><strong>아키텍처 접근</strong></td><td>도메인 주도 설계 (DDD)</td><td>애그리게이트 팩토리</td><td>복잡한 도메인 객체 (애그리게이트 루트) 생성을 전담하는 팩토리 적용</td></tr><tr><td></td><td>이벤트 소싱</td><td>이벤트 기반 빌더</td><td>이벤트 로그로부터 객체 상태를 단계적으로 재구성 (Rehydration)</td></tr><tr><td></td><td>디자인 패턴 결합</td><td>복합 설계 전략</td><td>Builder + Prototype, Abstract Factory + Singleton 등 패턴 조합 사용 증가</td></tr><tr><td><strong>코드 품질 · 생산성</strong></td><td>테스트 자동화</td><td>Mock 객체 생성</td><td>생성 책임을 분리함으로써 테스트 시 의존성 주입과 Mock 구성 용이</td></tr><tr><td></td><td>유지보수성</td><td>객체 생성 책임 분리</td><td>생성 로직 모듈화를 통해 변경 시 영향도 축소 및 재사용성 증가</td></tr><tr><td><strong>조직 운영·교육</strong></td><td>팀 협업</td><td>패턴 교육·표준화 필요</td><td>생성 패턴 적용은 팀 내 공통 이해와 적용 방식 일관화가 중요</td></tr><tr><td></td><td>코드 품질 문화</td><td>생성 패턴 도입 효과</td><td>적절한 생성 패턴은 구조적 품질 향상, 확장성·유지보수성 향상 유도</td></tr></tbody></table><h2 id=11-하위-주제로-분류한-추가-학습-항목>11. 하위 주제로 분류한 추가 학습 항목<a hidden class=anchor aria-hidden=true href=#11-하위-주제로-분류한-추가-학습-항목>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>GoF 디자인 패턴</td><td>생성 패턴 5 종</td><td>Singleton, Factory Method, Abstract Factory, Builder, Prototype 등</td></tr><tr><td>생성 패턴과의 비교</td><td>구조 패턴 vs. 생성 패턴</td><td>구조 패턴은 클래스/객체의 구성, 생성 패턴은 객체 생성 책임을 다룸</td></tr><tr><td>객체지향 설계 원칙</td><td>DIP, OCP, SRP</td><td>생성 패턴은 의존 역전 원칙 (DIP) 및 개방 폐쇄 원칙 (OCP) 과 긴밀히 연관됨</td></tr><tr><td>실전 구현 전략</td><td>DI 컨테이너와의 연계</td><td>Spring, NestJS 등 프레임워크에서 생성 패턴을 어떻게 적용하고 자동화하는지 분석</td></tr><tr><td>객체 생명주기 관리</td><td>Scope, Lifecycle</td><td>Singleton, Request, Session 등 다양한 생명주기를 갖는 객체 생성 관리 전략</td></tr><tr><td>테스트 전략</td><td>객체 모킹 및 스텁</td><td>생성 패턴을 통해 테스트 대역 (Mock, Stub) 객체를 쉽게 주입 가능</td></tr></tbody></table><h3 id=관련-분야-포함-추가-학습-필요-항목>관련 분야 포함 추가 학습 필요 항목<a hidden class=anchor aria-hidden=true href=#관련-분야-포함-추가-학습-필요-항목>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td>🧩 핵심 이론</td><td>생성 패턴 5 종</td><td>Singleton, Factory Method, Abstract Factory, Builder, Prototype 등 주요 생성 패턴 학습</td></tr><tr><td></td><td>생성 패턴 vs 구조 패턴</td><td>구조 패턴은 객체 구성, 생성 패턴은 객체 생성 책임과 관련됨</td></tr><tr><td></td><td>객체 생성 로직의 캡슐화</td><td>생성 로직을 분리해 코드 유지보수성과 유연성을 향상</td></tr><tr><td></td><td>SOLID 원칙 (특히 DIP, OCP, SRP)</td><td>생성 패턴은 의존 역전, 개방 폐쇄, 단일 책임 원칙과 깊은 관련</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>카테고리</strong></th><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>1. 생성 패턴 (GoF Creational Patterns)</strong></td><td><strong>Factory Method</strong></td><td>객체 생성 로직을 서브클래스에 위임하여 캡슐화하는 패턴</td></tr><tr><td></td><td><strong>Abstract Factory</strong></td><td>관련된 객체군 (Product Family) 을 일관되게 생성하는 인터페이스 제공</td></tr><tr><td></td><td><strong>Builder Pattern</strong></td><td>복잡한 객체를 단계별로 구성하여 생성하는 패턴</td></tr><tr><td></td><td><strong>Prototype Pattern</strong></td><td>기존 객체 (Prototype) 를 복제하여 새로운 객체를 생성</td></tr><tr><td></td><td><strong>Singleton Pattern</strong></td><td>클래스 인스턴스를 단 하나로 제한하고 전역 접근을 제공</td></tr><tr><td><strong>2. 설계 원칙 및 개념</strong></td><td><strong>Encapsulate What Varies</strong></td><td>변화하는 부분을 캡슐화하여 유연하고 유지보수 가능한 구조 유도</td></tr><tr><td></td><td><strong>디커플링 (Decoupling)</strong></td><td>구성 요소 간의 결합도를 낮추어 모듈화와 확장성을 확보하는 설계 기법</td></tr><tr><td></td><td><strong>객체 생성 메커니즘 (Object Creation Mechanism)</strong></td><td>시스템 내에서 객체를 생성하고 초기화하는 다양한 기법 또는 패턴의 총칭</td></tr><tr><td><strong>3. 테스트 및 품질 관련</strong></td><td><strong>Mock / Stub 객체</strong></td><td>테스트 시 실제 객체를 대체하여 사용되는 가짜 객체 (행위 검증용)</td></tr><tr><td></td><td><strong>Object Pool (객체 풀)</strong></td><td>재사용 가능한 객체를 미리 생성하여 풀로 관리하는 메모리 최적화 패턴</td></tr><tr><td></td><td><strong>Lazy Initialization (지연 초기화)</strong></td><td>객체가 실제로 필요할 때까지 생성을 지연시키는 초기화 전략</td></tr><tr><td><strong>4. 소프트웨어 설계 접근법</strong></td><td><strong>DI (Dependency Injection)</strong></td><td>객체 간 의존성을 외부에서 주입하여 느슨한 결합과 테스트 용이성 확보</td></tr><tr><td></td><td><strong>DDD (Domain-Driven Design)</strong></td><td>도메인 모델 중심으로 복잡한 시스템을 설계하는 소프트웨어 접근 방식</td></tr><tr><td><strong>5. 배경 및 역사</strong></td><td><strong>GoF (Gang of Four)</strong></td><td>디자인 패턴을 체계화한 저자 네 명 (Gamma, Helm, Johnson, Vlissides) 을 일컫는 용어로, 디자인 패턴의 표준적 기초 제공</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=종합-가이드-및-이론-정리>종합 가이드 및 이론 정리<a hidden class=anchor aria-hidden=true href=#종합-가이드-및-이론-정리>#</a></h3><ul><li><a href=https://refactoring.guru/design-patterns/creational-patterns>Creational Design Patterns - Refactoring Guru</a></li><li><a href=https://en.wikipedia.org/wiki/Design_Patterns>Design Patterns - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Creational_pattern>Creational Pattern - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Factory_method_pattern>Factory Method Pattern - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Builder_pattern>Builder Pattern - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Prototype_pattern>Prototype Pattern - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Singleton_pattern>Singleton Pattern - Wikipedia</a></li><li><a href=https://sourcemaking.com/design_patterns/creational_patterns>Creational Patterns - SourceMaking</a></li><li><a href=https://www.geeksforgeeks.org/software-design-patterns/>Creational Design Patterns - GeeksforGeeks</a></li><li><a href=https://www.baeldung.com/creational-design-patterns>Introduction to Creational Design Patterns - Baeldung</a></li></ul><h3 id=실무-적용-및-사례-기반-자료>실무 적용 및 사례 기반 자료<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례-기반-자료>#</a></h3><ul><li><a href=https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns>Gang of Four Design Patterns - DigitalOcean</a></li><li><a href=https://dev.to/sachinchaurasiya/creational-patterns-in-practice-2f7c>Creational Patterns in Practice - Dev.to</a></li><li><a href=https://medium.com/@kentongray/creational-patterns-and-object-oriented-design-7c6e5c8c4a9>Creational Patterns and Object-Oriented Design - Medium</a></li><li><a href=https://www.linkedin.com/pulse/creational-patterns-extensibility-michael-schade>Creational Patterns and Extensibility - LinkedIn</a></li><li><a href=https://www.javacodegeeks.com/2015/09/creational-patterns-maintainability.html>Creational Patterns Maintainability - Java Code Geeks</a></li></ul><h3 id=프레임워크-및-플랫폼-관점-자료>프레임워크 및 플랫폼 관점 자료<a hidden class=anchor aria-hidden=true href=#프레임워크-및-플랫폼-관점-자료>#</a></h3><ul><li><a href=https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html>Spring Docs - Bean Scope</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures#design-patterns>Microsoft Learn - Common Web App Architectures & Design Patterns</a></li><li><a href=https://springframework.guru/gang-of-four-design-patterns/>Gang of Four Design Patterns - Spring Framework Guru</a></li></ul><h3 id=소프트웨어-아키텍처-연계>소프트웨어 아키텍처 연계<a hidden class=anchor aria-hidden=true href=#소프트웨어-아키텍처-연계>#</a></h3><ul><li><a href=https://www.clustox.com/blog/software-architecture-patterns/>Software Architecture Patterns 2025 - Clustox</a></li><li><a href=https://www.infoq.com/articles/architecture-trends-2025/>InfoQ Software Architecture and Design Trends Report 2025</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Factory Method Pattern</h2></header><div class=entry-content><p>Factory Method Pattern Factory Method 패턴은 객체 생성의 책임을 상위 클래스가 아닌 하위 클래스에 위임하여, 클라이언트가 어떤 클래스의 인스턴스를 만들 것인지 모른 채 객체를 생성할 수 있게 한다. 추상 클래스는 인터페이스만 정의하고, 실제 객체 생성을 하위 클래스에서 담당함으로써 확장성과 유연성을 확보한다. GoF 의 23 가지 디자인 패턴 중 가장 널리 사용되는 생성 패턴으로, “Virtual Constructor” 라고도 불린다.
이 패턴은 Creator 와 Product 라는 두 개의 주요 계층구조를 통해 객체 생성 로직을 캡슐화하며, Template Method 패턴과 유사한 구조를 가진다. 프레임워크 설계, UI 컴포넌트 생성, 데이터베이스 연결 관리 등 다양한 영역에서 활용되며, 2025 년 현재 마이크로서비스 아키텍처와 AI/ML 시스템에서 그 중요성이 더욱 부각되고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-25 18:21:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;38 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Factory Method Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/factory-method-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Singleton Pattern</h2></header><div class=entry-content><p>Singleton Pattern Singleton Pattern 은 클래스의 인스턴스를 하나만 만들고 전역에서 접근할 수 있도록 보장하는 디자인 패턴이다. 일반적으로 정적 메서드를 통해 인스턴스를 생성하며, 생성자 접근 제한 (private constructor), 정적 참조 (static instance), 동기화 처리가 핵심이다. 설정 객체, 로깅 시스템, 캐시, 데이터베이스 커넥션 풀 등 리소스를 공유해야 하는 경우에 자주 사용된다. 다만, 잘못된 사용은 테스트 어려움과 결합도 증가를 초래할 수 있다.
핵심 개념 싱글톤 패턴 (Singleton Pattern) 은 클래스의 인스턴스를 단 하나만 생성하고, 전역적으로 접근할 수 있도록 보장하는 생성 패턴이다.
...</p></div><footer class=entry-footer><span title='2024-09-25 18:21:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;36 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Singleton Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/singleton-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Abstract Factory Pattern</h2></header><div class=entry-content><p>Abstract Factory Pattern Abstract Factory Pattern 는 관련 객체들의 계열 (Product Family) 생성을 추상화하는 패턴으로, 클라이언트는 구체 클래스에 의존하지 않고 팩토리 인터페이스에만 의존해 객체를 생성한다. Abstract Factory 와 Concrete Factory, Abstract Product 와 Concrete Product, Client 로 구성되며, 클라이언트는 Abstract Factory 에 팩토리 구현체를 주입받아 원하는 제품 계열을 생성할 수 있다. 이는 제품 간 일관성 유지, 다양한 제품군 전환, 테스트 유연성 향상 등에 강점을 제공한다.
배경 객체 지향 시스템에서 관련 객체들의 패밀리를 생성해야 할 때, 구체적인 클래스를 명시하면 코드가 환경에 종속되고 확장성이 떨어짐. 이를 해결하기 위해 객체 생성 로직을 추상화하는 패턴이 필요해짐.
...</p></div><footer class=entry-footer><span title='2024-09-25 06:09:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;61 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Abstract Factory Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/abstract-factory-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Builder Pattern</h2></header><div class=entry-content><p>Builder Pattern Builder Pattern 은 복잡한 객체 생성 문제를 해결하는 창조적 디자인 패턴으로, Director, Builder, ConcreteBuilder, Product 의 4 가지 핵심 구성요소를 통해 단계별 객체 구성을 지원한다. 생성자 오버로딩 문제를 해결하고 불변 객체 생성을 가능하게 하며, 플루언트 인터페이스를 통한 메서드 체이닝으로 코드 가독성을 크게 향상시킨다. 현대 프레임워크와 라이브러리에서 널리 활용되고 있다.
배경 Builder Pattern 은 다음과 같은 문제를 해결하기 위해 등장했다:
점층적 생성자 패턴 (Telescoping Constructor Pattern) 의 한계 매개변수가 많아질수록 가독성 저하 매개변수 순서 기억의 어려움 코드 유지보수성 문제 자바빈 패턴 (JavaBeans Pattern) 의 문제점 객체 일관성 (Consistency) 깨짐 불변 객체 생성 불가 스레드 안전성 문제 목적 및 필요성 주요 목적:
...</p></div><footer class=entry-footer><span title='2024-09-25 06:09:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;46 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Builder Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/builder-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prototype Pattern</h2></header><div class=entry-content><p>Prototype Pattern Prototype 패턴은 복잡한 초기화 과정을 거친 객체를 새로 생성하는 대신 기존 인스턴스를 복제하는 방식으로 객체 생성을 추상화합니다. “Prototype” 인터페이스와 이를 구현한 “Concrete Prototype”, 그리고 “Client” 가 핵심 참여자이며, 클라이언트는 clone() 만 호출해 객체를 얻는다. 이로 인해 생성 방식이 은닉되고, 런타임에 동적 객체 구성, 깊은 복제 (deep clone), 프로토타입 관리 (registry) 등 고급 기능을 구현할 수 있다.
배경 프로토타입 패턴은 다음과 같은 배경에서 등장했다:
객체 생성 비용 문제
복잡한 객체 초기화 과정에서 발생하는 성능 병목 현상을 해결하기 위해 등장했다. 특히 데이터베이스 연결, 파일 로딩, 복잡한 계산 등이 포함된 객체 생성 시 유용하다.
...</p></div><footer class=entry-footer><span title='2024-09-25 06:09:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;41 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prototype Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/creational/prototype-pattern/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>