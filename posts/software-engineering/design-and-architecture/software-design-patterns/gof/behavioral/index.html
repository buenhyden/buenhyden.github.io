<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Behavioral Design Patterns | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Design-Patterns,GoF,Behavioral"><meta name=description content="Behavioral Design Patterns 는 객체 및 클래스 간의 상호작용과 책임 분산에 집중한 디자인 패턴군으로, 복잡한 시스템에서 객체들의 행위를 유연하게 조정하고 기능 확장 및 유지보수를 용이하게 만든다. 실무에서 프로그램의 확장성과 코드 품질 향상을 위해 필수적으로 활용된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Behavioral Design Patterns"><meta property="og:description" content="Behavioral Design Patterns 는 객체 및 클래스 간의 상호작용과 책임 분산에 집중한 디자인 패턴군으로, 복잡한 시스템에서 객체들의 행위를 유연하게 조정하고 기능 확장 및 유지보수를 용이하게 만든다. 실무에서 프로그램의 확장성과 코드 품질 향상을 위해 필수적으로 활용된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Behavioral Design Patterns"><meta name=twitter:description content="Behavioral Design Patterns 는 객체 및 클래스 간의 상호작용과 책임 분산에 집중한 디자인 패턴군으로, 복잡한 시스템에서 객체들의 행위를 유연하게 조정하고 기능 확장 및 유지보수를 용이하게 만든다. 실무에서 프로그램의 확장성과 코드 품질 향상을 위해 필수적으로 활용된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":5,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/"},{"@type":"ListItem","position":6,"name":"Behavioral Design Patterns","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/>GoF</a></div><h1>Behavioral Design Patterns</h1><div class=post-description>Behavioral Design Patterns 는 객체 및 클래스 간의 상호작용과 책임 분산에 집중한 디자인 패턴군으로, 복잡한 시스템에서 객체들의 행위를 유연하게 조정하고 기능 확장 및 유지보수를 용이하게 만든다. 실무에서 프로그램의 확장성과 코드 품질 향상을 위해 필수적으로 활용된다.</div></header><div class=post-content><h2 id=behavioral-design-patterns>Behavioral Design Patterns<a hidden class=anchor aria-hidden=true href=#behavioral-design-patterns>#</a></h2><p>Behavioral Design Patterns 는 객체지향 소프트웨어 설계에서 객체나 클래스 간의 커뮤니케이션과 책임 분배 방법론을 정의한 패턴군이다. GoF 가 정립한 이 패턴들은 소프트웨어의 유연성, 확장성, 재사용성을 높이기 위해 고안되었으며, 각 패턴은 알고리즘, 제어 흐름, 명령 전달, 해석, 상태 변화 등 다양한 행위를 효과적으로 설계하는 데 활용된다. 실무에서는 복잡한 로직 분리, 책임 분산, 유지보수성 향상 등에 폭넓게 적용된다.</p><h2 id=4-핵심-개념>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념>#</a></h2><ul><li><p><strong>정의</strong>: Behavioral Design Patterns 는 객체 간의 상호작용과 책임 분배를 정의하여 시스템의 유연성과 확장성을 높이는 디자인 패턴입니다.</p></li><li><p><strong>목적</strong>: 객체 간의 결합도를 낮추고, 유연한 상호작용을 통해 시스템의 유지보수성과 확장성을 향상시키는 것입니다.</p></li><li><p><strong>특징</strong>:</p><ul><li><p>객체 간의 상호작용을 중심으로 설계</p></li><li><p>책임의 명확한 분배</p></li><li><p>유연한 구조와 확장성</p></li></ul></li></ul><h3 id=a-핵심-개념-및-주요-내용>A. 핵심 개념 및 주요 내용<a hidden class=anchor aria-hidden=true href=#a-핵심-개념-및-주요-내용>#</a></h3><h4 id=1-배경-및-목적>1. 배경 및 목적<a hidden class=anchor aria-hidden=true href=#1-배경-및-목적>#</a></h4><ul><li><strong>배경:</strong> 시스템이 복잡해짐에 따라 객체 간의 책임 분산과 일관된 알고리즘 관리 필요성이 대두됨.</li><li><strong>목적:</strong> 행위 중심 설계로 객체 간 상호작용의 결합도 감소, 유연한 구조, 책임의 분리 실현</li></ul><h4 id=2-주요-기능-및-역할>2. 주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#2-주요-기능-및-역할>#</a></h4><ul><li>행위 분리, 실행 위치 위임, 알고리즘 교체, 상태 전이, 이벤트 통지 등</li></ul><h3 id=행동-디자인-패턴의-주요-특징>행동 디자인 패턴의 주요 특징<a hidden class=anchor aria-hidden=true href=#행동-디자인-패턴의-주요-특징>#</a></h3><ol><li>객체 간 통신 패턴 정의: 객체들이 서로 어떻게 상호작용하고 통신할지에 대한 패턴을 제공한다.</li><li>복잡한 제어 흐름 관리: 런타임에 따라가기 어려운 복잡한 제어 흐름을 관리한다.</li><li>알고리즘의 캡슐화: 특정 행동을 캡슐화하여 객체 간에 교환 가능하게 만든다.</li><li>객체 결합도 감소: 객체 간의 직접적인 의존성을 줄여 시스템의 유연성을 높인다.</li></ol><h4 id=3-특징>3. 특징<a hidden class=anchor aria-hidden=true href=#3-특징>#</a></h4><ul><li>객체 간 결합도 최소화</li><li>코드의 모듈화 및 재사용성 향상</li><li>새로운 행위 추가 시 구조 변경 최소화</li></ul><h4 id=4-핵심-원칙>4. 핵심 원칙<a hidden class=anchor aria-hidden=true href=#4-핵심-원칙>#</a></h4><ul><li><strong>OCP(Open-Closed Principle)</strong>: 행위 확장에 코드 변경 최소화</li><li><strong>SRP(Single Responsibility Principle)</strong>: 객체별 책임 분산</li></ul><h2 id=4-핵심-개념-1>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념-1>#</a></h2><ol><li><p><strong>정의</strong><br>Behavioral Design Patterns 는 객체나 클래스들이 어떻게 상호작용하며, 각자 어떤 책임을 가져야 하는지에 초점을 맞춥니다.</p></li><li><p><strong>주요 목적</strong></p><ul><li>객체의 행위를 조정, 위임, 캡슐화하여 결합도를 낮추고, 유연성과 변화 대응성을 높임</li><li>로직과 흐름 제어, 알고리즘 실행 방식 등 프로그램의 행위 관련 부분을 구조화</li></ul></li><li><p><strong>구성 요소</strong></p><ul><li>주체 (Invoker), 행동 (Receiver), 명령 (Command), 상태 (State), 옵저버 (Observer) 등</li><li>각 패턴마다 참여 객체와 역할이 명확히 정의됨</li></ul></li><li><p><strong>대표 패턴</strong></p><ul><li>Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor 등</li></ul></li><li><p><strong>실무 중요성</strong></p><ul><li>복잡한 비즈니스 로직의 분산과 관리, 유지보수성과 확장성 증진</li></ul></li></ol><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><p>Behavioral Design Patterns 는 객체 간의 상호작용을 정의하여 시스템의 유연성과 확장성을 높입니다. 이 패턴들은 알고리즘과 객체 간의 통신을 중심으로 하며, 시스템의 유지보수성과 확장성을 향상시키는 데 기여합니다.</p><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><p>Behavioral Design Patterns 는 객체 간의 상호작용을 정의하여 시스템의 유연성과 확장성을 높입니다. 이 패턴들은 알고리즘과 객체 간의 통신을 중심으로 하며, 시스템의 유지보수성과 확장성을 향상시키는 데 기여합니다.</p><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><p>Behavioral Design Patterns 의 구현은 객체 간의 상호작용을 정의하여 시스템의 유연성과 확장성을 높이는 데 중점을 둡니다. 예를 들어, Observer 패턴은 한 객체의 상태 변화가 관련된 다른 객체들에게 자동으로 통지되도록 구현됩니다.</p><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유연성 향상</td><td>객체 간의 결합도를 낮추어 시스템의 유연성을 높입니다.</td></tr><tr><td></td><td>재사용성 증가</td><td>공통된 상호작용을 정의하여 코드의 재사용성을 높입니다.</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>객체 간의 상호작용이 복잡해질 수 있습니다.</td></tr><tr><td></td><td>디버깅 어려움</td><td>객체 간의 상호작용이 복잡하여 디버깅이 어려울 수 있습니다.</td></tr></tbody></table><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><ul><li><p><strong>도전 과제</strong>: 객체 간의 상호작용이 복잡해질 수 있습니다.</p></li><li><p><strong>해결책</strong>: 명확한 인터페이스 정의와 문서화를 통해 복잡성을 관리할 수 있습니다.</p></li></ul><h3 id=주요-행동-디자인-패턴>주요 행동 디자인 패턴<a hidden class=anchor aria-hidden=true href=#주요-행동-디자인-패턴>#</a></h3><ol><li><p><strong>책임 연쇄 패턴 (Chain of Responsibility)</strong></p><ul><li>요청을 처리할 수 있는 객체들의 체인을 따라 요청을 전달한다.</li><li>예: 고객 지원 시스템에서 요청을 단계별로 처리하는 경우.</li></ul></li><li><p><strong>커맨드 패턴 (Command)</strong></p><ul><li>요청을 객체로 캡슐화하여 매개변수화된 클라이언트를 만들 수 있게 한다.</li></ul></li><li><p><strong>반복자 패턴 (Iterator)</strong></p><ul><li>컬렉션의 내부 구조를 노출하지 않고 요소들을 순회할 수 있게 한다.</li></ul></li><li><p><strong>중재자 패턴 (Mediator)</strong></p><ul><li>객체 간의 복잡한 의존 관계를 줄이고 중앙 집중식 통신을 구현한다.</li></ul></li><li><p><strong>옵서버 패턴 (Observer)</strong></p><ul><li>객체 간의 일대다 의존 관계를 정의하여 한 객체의 상태 변화를 다른 객체들에게 자동으로 알린다.</li></ul></li><li><p><strong>상태 패턴 (State)</strong></p><ul><li>객체의 내부 상태에 따라 행동을 변경할 수 있게 한다.</li></ul></li><li><p><strong>전략 패턴 (Strategy)</strong></p><ul><li>알고리즘군을 정의하고 각각을 캡슐화하여 교환 가능하게 만든다.</li></ul></li><li><p><strong>템플릿 메서드 패턴 (Template Method)</strong></p><ul><li>알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현할 수 있게 한다.</li></ul></li></ol><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>패턴</th><th>설명</th></tr></thead><tbody><tr><td>Observer</td><td>한 객체의 상태 변화가 관련된 다른 객체들에게 자동으로 통지되도록 하는 패턴</td></tr><tr><td>Strategy</td><td>알고리즘을 캡슐화하여 교체 가능하게 만드는 패턴</td></tr><tr><td>Command</td><td>요청을 객체로 캡슐화하여 다양한 요청을 매개변수화할 수 있는 패턴</td></tr><tr><td>State</td><td>객체의 상태에 따라 행동을 변경하는 패턴</td></tr><tr><td>Mediator</td><td>객체 간의 상호작용을 중앙 집중화하여 결합도를 낮추는 패턴</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>패턴</th><th>적용 예시</th></tr></thead><tbody><tr><td>Observer</td><td>이벤트 리스너 구현</td></tr><tr><td>Strategy</td><td>정렬 알고리즘 선택 구현</td></tr><tr><td>Command</td><td>작업 취소 기능 구현</td></tr><tr><td>State</td><td>상태에 따른 UI 변경 구현</td></tr><tr><td>Mediator</td><td>채팅 애플리케이션의 메시지 중개자 구현</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><p><strong>시나리오</strong>: 채팅 애플리케이션에서 사용자 간의 메시지 전달을 관리하는 시스템을 설계할 때, Mediator 패턴을 활용하여 사용자 객체 간의 직접적인 상호작용을 피하고 중앙 집중화된 메시지 중개자를 통해 메시지를 전달합니다.</p><p><strong>시스템 구성</strong>:</p><ul><li><p><strong>사용자 객체</strong>: 메시지를 보내고 받을 수 있는 객체</p></li><li><p><strong>메시지 중개자</strong>: 사용자 객체 간의 메시지 전달을 관리하는 중앙 객체</p></li></ul><p><strong>Workflow</strong>:</p><ol><li><p>사용자 A 가 메시지를 보냅니다.</p></li><li><p>메시지 중개자가 메시지를 받아 사용자 B 에게 전달합니다.</p></li><li><p>사용자 B 가 메시지를 수신합니다.</p></li></ol><p><strong>역할</strong>:</p><ul><li><p>사용자 객체: 메시지의 송수신을 담당합니다.</p></li><li><p>메시지 중개자: 메시지의 전달을 중앙에서 관리합니다.</p></li></ul><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>객체 간의 결합도</td><td>객체 간의 결합도를 낮추어야 합니다.</td><td>인터페이스를 활용하여 결합도를 낮추세요.</td></tr><tr><td>상호작용의 복잡성</td><td>객체 간의 상호작용이 복잡해질 수 있습니다.</td><td>명확한 문서화와 주석을 통해 관리하세요.</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>오버헤드</td><td>패턴의 사용으로 인한 오버헤드가 발생할 수 있습니다.</td><td>필요한 경우에만 패턴을 적용하세요.</td></tr><tr><td>디버깅</td><td>객체 간의 상호작용이 복잡하여 디버깅이 어려울 수 있습니다.</td><td>로깅과 디버깅 도구를 활용하여 문제를 추적하세요.</td></tr></tbody></table><h3 id=행동-디자인-패턴의-장점>행동 디자인 패턴의 장점<a hidden class=anchor aria-hidden=true href=#행동-디자인-패턴의-장점>#</a></h3><ol><li>코드 재사용성 향상: 공통된 행동을 추상화하여 여러 객체에서 재사용할 수 있다.</li><li>유지보수성 개선: 객체 간의 결합도를 낮춰 시스템 변경이 용이해진다.</li><li>확장성 증대: 새로운 행동을 기존 코드 변경 없이 추가할 수 있다.</li><li>복잡성 관리: 복잡한 객체 간 상호작용을 체계적으로 관리할 수 있다.</li></ol><h3 id=행동-디자인-패턴-사용-시-고려사항>행동 디자인 패턴 사용 시 고려사항<a hidden class=anchor aria-hidden=true href=#행동-디자인-패턴-사용-시-고려사항>#</a></h3><ol><li>패턴 선택: 문제 상황에 가장 적합한 패턴을 선택해야 한다.</li><li>오버엔지니어링 주의: 간단한 문제에 복잡한 패턴을 적용하지 않도록 주의해야 한다.</li><li>성능 고려: 일부 패턴은 추가적인 객체 생성이나 메서드 호출로 인해 성능에 영향을 줄 수 있다.</li><li>팀 이해도: 팀 구성원들이 패턴을 이해하고 올바르게 사용할 수 있어야 한다.</li></ol><p>행동 디자인 패턴을 효과적으로 사용하려면 각 패턴의 특성과 적용 상황을 잘 이해하고, 실제 문제 해결에 적절히 적용하는 연습이 필요합니다. 이를 통해 더 유연하고 확장 가능한 소프트웨어 설계를 할 수 있습니다.</p><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><hr><hr><h2 id=behavioral-design-patterns---심층-조사-및-정리>Behavioral Design Patterns - 심층 조사 및 정리<a hidden class=anchor aria-hidden=true href=#behavioral-design-patterns---심층-조사-및-정리>#</a></h2><hr><hr><h3 id=b-구조-및-아키텍처>B. 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#b-구조-및-아키텍처>#</a></h3><table><thead><tr><th>패턴명</th><th>필수 구성요소</th><th>역할/기능</th><th>선택 구성요소</th><th>역할/특징</th></tr></thead><tbody><tr><td>Chain of Responsibility</td><td>Handler, Request</td><td>요청 처리자 연결/처리 위임</td><td>ConcreteHandler</td><td>구체적 요청 처리 방식</td></tr><tr><td>Command</td><td>Command, Receiver</td><td>명령객체와 실행자 분리, Undo/Redo 등 지원</td><td>Invoker, Client</td><td>명령 실행, 명령 생성</td></tr><tr><td>Observer</td><td>Subject, Observer</td><td>상태변경 통지/구독</td><td>ConcreteObserver</td><td>실제 갱신 동작 구현</td></tr><tr><td>Strategy</td><td>Context, Strategy</td><td>알고리즘 교체를 구조화</td><td>ConcreteStrategy</td><td>구체적 알고리즘 구현</td></tr><tr><td>State</td><td>Context, State</td><td>상태 변화에 따른 행위 캡슐화</td><td>ConcreteState</td><td>각 상태별 구현</td></tr><tr><td>Mediator</td><td>Mediator, Colleague</td><td>객체 간 복잡한 통신을 중재자로 위임, 객체 직접통신 방지</td><td>ConcreteMediator</td><td>실제 중재 로직</td></tr><tr><td>Visitor</td><td>Visitor, Element</td><td>객체 구조를 변경하지 않고 새로운 연산 추가</td><td>ConcreteVisitor, …</td><td>연산구현, 요소에 방문</td></tr><tr><td>Template Method</td><td>AbstractClass</td><td>알고리즘 구조 정의, 세부 단계는 하위클래스가 오버라이드</td><td>ConcreteClass</td><td>단계별 구현</td></tr><tr><td>Iterator</td><td>Iterator, Aggregate</td><td>컬렉션 반복방법 분리/은닉화</td><td>ConcreteIterator</td><td>반복 방법 구체화</td></tr><tr><td>Memento</td><td>Originator, Memento</td><td>객체 상태 캡슐화/복원</td><td>Caretaker</td><td>상태 스냅샷 관리</td></tr><tr><td>Interpreter</td><td>AbstractExpression</td><td>언어문법 구조파악/해석</td><td>Terminal/NonTerminal</td><td>실제 해석 수행</td></tr></tbody></table><p><strong>구조 다이어그램 예시 (Strategy Pattern)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>+-------------+
</span></span><span class=line><span class=cl>|   Context   |
</span></span><span class=line><span class=cl>+-------------+
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      | uses
</span></span><span class=line><span class=cl>      v
</span></span><span class=line><span class=cl>+-------------+    +-------------+
</span></span><span class=line><span class=cl>|  Strategy   |---&gt;|ConcreteStrategyA|
</span></span><span class=line><span class=cl>+-------------+    +-------------+
</span></span><span class=line><span class=cl>                   |ConcreteStrategyB|
</span></span><span class=line><span class=cl>                   +-------------+
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=작동-원리-다이어그램>작동 원리 (다이어그램)<a hidden class=anchor aria-hidden=true href=#작동-원리-다이어그램>#</a></h3><ul><li><strong>Observer Pattern UML</strong><br>![Observer Pattern UML](<a href="https://refactoring.guru/images/patterns/diagrams/observer/structure.png?id=1f7b75563d4d3f9d15cc2beeState">https://refactoring.guru/images/patterns/diagrams/observer/structure.png?id=1f7b75563d4d3f9d15cc2beeState</a> Pattern UML**<br>![State Pattern UML](<a href="https://refactoring.guru/images/patterns/diagrams/state/structure.png?id=c027c8b5c6e8b93c9e5efd5b8cCommand">https://refactoring.guru/images/patterns/diagrams/state/structure.png?id=c027c8b5c6e8b93c9e5efd5b8cCommand</a> Pattern UML**<br>![Command Pattern UML](<a href="https://refactoring.guru/images/patterns/diagrams/command/structure.png?id=9b0efb5d8a25368f413fd90dactoring">https://refactoring.guru/images/patterns/diagrams/command/structure.png?id=9b0efb5d8a25368f413fd90dactoring</a> Guru 각 패턴 구조도</li><li><a href=https://refactoring.guru/design-patterns/observer>Observer Pattern 구조</a></li></ul><hr><h3 id=구현-기법-1>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법-1>#</a></h3><table><thead><tr><th>패턴</th><th>정의</th><th>구성</th><th>목적</th><th>실제 예시 (시스템, 시나리오)</th></tr></thead><tbody><tr><td>Command</td><td>요청을 객체로 캡슐화</td><td>Command, Receiver, Invoker</td><td>요청, 실행 분리, Undo</td><td>GUI 에서 버튼 클릭 이벤트 핸들링</td></tr><tr><td>Observer</td><td>상태 변경시 관련 객체에 통지</td><td>Subject, Observer</td><td>알림, 이벤트 구독</td><td>게시판 알림 시스템, 주식 가격 변동 알림</td></tr><tr><td>Strategy</td><td>알고리즘군을 정의하여 런타임에 교체</td><td>Context, Strategy</td><td>행위 교체</td><td>결제 수단 선택 (카드/계좌/포인트 등)</td></tr><tr><td>State</td><td>상태별 객체 생성, 행위 변경</td><td>Context, State</td><td>상태전이, 행위변경</td><td>TCP 연결 관리 (Closed, Listen, Established 등)</td></tr><tr><td>Visitor</td><td>구조 변경 없이 연산 추가</td><td>Visitor, Element</td><td>기능 확장</td><td>컴파일러에서 문법 트리 순회 및 분석</td></tr></tbody></table><hr><h3 id=e-장점과-단점>E. 장점과 단점<a hidden class=anchor aria-hidden=true href=#e-장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>코드 유지보수성</td><td>변화에 강하고 확장에 용이, 각 행위별 책임 분리 가능</td></tr><tr><td></td><td>결합도 감소</td><td>객체 간 의존성 감소로 리팩토링 및 테스트 용이</td></tr><tr><td></td><td>재사용성</td><td>공통 행위 추상화 및 캡슐화로 재사용성 향상</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>패턴 도입 시 클래스/객체 증가로 구조가 복잡해질 가능</td></tr><tr><td></td><td>과용 위험</td><td>단순 문제에 과도한 패턴 적용 시 오히려 개발/이해 저해</td></tr></tbody></table><hr><h3 id=f-도전-과제-및-해결책>F. 도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#f-도전-과제-및-해결책>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>패턴 선택의 적절성</td><td>상황에 맞지 않은 패턴 적용 시 코드 난독화</td><td>요구사항 분석, 책임과 변화 예상에 따른 선정</td></tr><tr><td>클래스/객체 수 증가</td><td>객체 수가 많아지면 관리 복잡성 증가</td><td>패턴 최소화, 코드 컨벤션 철저 적용</td></tr><tr><td>유지보수 시 패턴 구조 파악 어려움</td><td>신규 투입 개발자의 학습 곡선 존재</td><td>문서화/다이어그램 활용, 코딩 규칙 준수</td></tr></tbody></table><hr><h3 id=g-분류별-behavioral-patterns-표>G. 분류별 Behavioral Patterns 표<a hidden class=anchor aria-hidden=true href=#g-분류별-behavioral-patterns-표>#</a></h3><table><thead><tr><th>유형</th><th>설명</th><th>주요 예시</th></tr></thead><tbody><tr><td>객체 기반 (객체간 상호작용)</td><td>객체 인스턴스 관계로 행위 정의</td><td>Chain of Responsibility, Command, Iterator, Mediator, Observer, State, Strategy, Visitor</td></tr><tr><td>클래스 기반 (상속 활용)</td><td>클래스 상속 구조로 행위 정의</td><td>Interpreter, Template Method</td></tr></tbody></table><hr><h3 id=h-실무-적용-예시>H. 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#h-실무-적용-예시>#</a></h3><table><thead><tr><th>패턴</th><th>실무 예시</th><th>적용 분야</th></tr></thead><tbody><tr><td>Observer</td><td>채팅앱의 실시간 이벤트 알림</td><td>메시징, 이벤트 처리</td></tr><tr><td>Strategy</td><td>결제수단/쿠폰 적용방식 선택</td><td>전자상거래, 결제 시스템</td></tr><tr><td>Command</td><td>Undo/Redo 기능</td><td>텍스트 에디터, IDE 등</td></tr><tr><td>State</td><td>상태별 행동 분기</td><td>주문 상태, 인증 프로세스</td></tr><tr><td>Mediator</td><td>채팅방의 사용자 메시지 중재 및 전달</td><td>실시간 채팅, 게임 서버</td></tr></tbody></table><hr><h3 id=i-활용-사례-가상-시나리오>I. 활용 사례 (가상 시나리오)<a hidden class=anchor aria-hidden=true href=#i-활용-사례-가상-시나리오>#</a></h3><h4 id=사례-실시간-알림-시스템에-observer-패턴-활용>사례: 실시간 알림 시스템에 Observer 패턴 활용<a hidden class=anchor aria-hidden=true href=#사례-실시간-알림-시스템에-observer-패턴-활용>#</a></h4><ul><li><p><strong>시나리오:</strong> SNS 앱에서 새로운 댓글이 등록될 때마다 구독자들에게 실시간 알림 발송 필요</p></li><li><p><strong>시스템 구성:</strong></p><ul><li>Subject: 게시글, Observer: 사용자 알림 서비스</li><li>Subject 는 Observer 등록/제거 기능 제공, 상태 변동시 일괄 통지</li></ul></li><li><p><strong>구성 다이어그램:</strong><br>![Observer 구조 예시](<a href=https://refactoring.guru/images/patterns/diagrams>https://refactoring.guru/images/patterns/diagrams</a>워크플로우:**</p><ol><li>사용자가 게시글을 구독 (Observer 등록)</li><li>댓글 등록 시 게시글 상태 변경</li><li>게시글이 Observer(알림 서비스) 에 이벤트 통지</li><li>알림 서비스가 구독 사용자에게 실시간 알림 전송</li></ol></li><li><p><strong>역할:</strong></p><ul><li>게시글: 상태/이벤트 발생에 대한 중심 관리</li><li>알림 서비스: 사용자별 알림 분배</li></ul></li></ul><hr><h3 id=j-실무-적용-고려사항>J. 실무 적용 고려사항<a hidden class=anchor aria-hidden=true href=#j-실무-적용-고려사항>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>요구분석</td><td>패턴 적용 전 분명한 요구 파악</td><td>과한 추상화·복잡성 피하기</td></tr><tr><td>문서화</td><td>구조와 흐름의 명확한 설명</td><td>UML, 업무 플로우 등 다이어그램 병행</td></tr><tr><td>테스트</td><td>변경에 따른 영향 범위 파악</td><td>단위 테스트, 통합 테스트</td></tr><tr><td>패턴 선택</td><td>남용, 오/과용 경계</td><td>패턴 사용 목적과 장단점 명확히 인지</td></tr></tbody></table><hr><h3 id=k-성능-최적화-고려사항>K. 성능 최적화 고려사항<a hidden class=anchor aria-hidden=true href=#k-성능-최적화-고려사항>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>객체 수 관리</td><td>패턴 적용시 객체/클래스 증가 감안</td><td>객체 풀링, 불필요 객체 최소화</td></tr><tr><td>이벤트 최적화</td><td>옵저버, 이벤트 패턴의 경우</td><td>비동기/배치 처리, 큐 시스템 활용</td></tr><tr><td>상태 관리</td><td>State/Memento 등 사용시 상태메모리</td><td>불필요 상태 저장 최소화, GC 관리</td></tr><tr><td>동시 처리</td><td>다수 Observer/Handler 병렬처리</td><td>스레드풀, 이벤트 드리븐 구조 적용</td></tr></tbody></table><hr><h3 id=l-2025-년-기준-최신-동향>L. 2025 년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#l-2025-년-기준-최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Behavioral Patterns</td><td>실무적 Ubiquity</td><td>대형 SaaS, 클라우드 서비스에서 보편적 적용 증가</td></tr><tr><td>Behavioral Patterns</td><td>함수형 언어 적용</td><td>함수형 패러다임과 패턴 결합 시도 활발</td></tr><tr><td>Behavioral Patterns</td><td>자동화 프레임워크</td><td>패턴 자동 적용/생성 툴 등장</td></tr><tr><td>Behavioral Patterns</td><td>이벤트 기반 아키텍처</td><td>이벤트 소싱, CQRS 등과 결합 채택 확대</td></tr></tbody></table><hr><h3 id=m-주제와-관련한-주목할-내용>M. 주제와 관련한 주목할 내용<a hidden class=anchor aria-hidden=true href=#m-주제와-관련한-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>이벤트 중심 설계</td><td>Event-driven</td><td>Microservice 및 대규모 분산 시스템에서 필수화</td></tr><tr><td>패턴간 결합</td><td>Hybrid Pattern</td><td>복합패턴 (Composite, Observer 등) 활용 증가</td></tr><tr><td>패턴 교육/문서화</td><td>학습 및 Onboarding</td><td>신입 개발자 교육 자료로 표준화</td></tr></tbody></table><hr><h3 id=n-앞으로의-전망>N. 앞으로의 전망<a hidden class=anchor aria-hidden=true href=#n-앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Behavioral Patterns</td><td>자동화 툴 발전</td><td>패턴 자동화, 코드 생성 도구의 발전 예상</td></tr><tr><td>Behavioral Patterns</td><td>신기술과의 접목</td><td>AI, 이벤트 소싱, 비동기처리와의 융합 전망</td></tr><tr><td>Behavioral Patterns</td><td>교육/표준화</td><td>설계 교육의 핵심, 실무 표준으로 지속 자리잡음</td></tr></tbody></table><hr><h3 id=o-추가-학습-필요-하위-주제-요약표>O. 추가 학습 필요 하위 주제 (요약표)<a hidden class=anchor aria-hidden=true href=#o-추가-학습-필요-하위-주제-요약표>#</a></h3><table><thead><tr><th>설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>패턴별 코드작성/심화</td><td>Behavioral Patterns</td><td>각 Behavioral 패턴별 실제코드, 테스트</td></tr><tr><td>실제 적용 사례 분석</td><td>Pattern Application</td><td>오픈소스, 프레임워크 내 실제 사용 사례</td></tr><tr><td>패턴 조합/응용법</td><td>Hybrid Patterns</td><td>패턴 조합 및 통합 설계법</td></tr><tr><td>리팩토링 전략</td><td>Refactoring</td><td>패턴 도입 전후 리팩토링 접근법</td></tr></tbody></table><hr><h3 id=p-연관-학습-주제-및-내용>P. 연관 학습 주제 및 내용<a hidden class=anchor aria-hidden=true href=#p-연관-학습-주제-및-내용>#</a></h3><table><thead><tr><th>설명</th><th>관련 분야</th><th>주제</th></tr></thead><tbody><tr><td>GoF 패턴 전체 구조</td><td>소프트웨어 아키텍처</td><td>GoF 23 Patterns</td></tr><tr><td>이벤트 소싱, CQRS, 메시지 큐</td><td>이벤트 기반 아키텍처</td><td>Event Sourcing</td></tr><tr><td>함수형 프로그래밍과 디자인 패턴</td><td>프로그래밍 패러다임</td><td>FP & Patterns</td></tr><tr><td>복합/하이브리드 패턴</td><td>고급 소프트웨어 설계</td><td>Composite/Hybrid</td></tr></tbody></table><hr><h3 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>GoF</td><td>&lsquo;Gang of Four&rsquo;, 디자인 패턴 도서 저자 4 인을 지칭</td></tr><tr><td>OCP</td><td>Open-Closed Principle, 개방 - 폐쇄 원칙</td></tr><tr><td>SRP</td><td>Single Responsibility Principle, 단일 책임 원칙</td></tr><tr><td>Ubiquity</td><td>만연함, 어디에나 존재함 (실무적 활용의 보편성)</td></tr><tr><td>CQRS</td><td>Command Query Responsibility Segregation, 커맨드 - 쿼리 책임 분리 원칙</td></tr></tbody></table><hr><h3 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h3><ul><li><a href=https://refactoring.guru/design-patterns>Refactoring Guru - 디자인 패턴</a></li><li><a href=https://www.dofactory.com/net/design-patterns>DoFactory - Behavioral Patterns</a></li><li><a href=https://en.wikipedia.org/wiki/Behavioral_pattern>Wikipedia - Behavioral Pattern</a></li><li><a href=https://refactoring.guru/design-patterns/observer>Observer Pattern 구조, Refactoring.Guru</a></li><li><a href=https://en.wikipedia.org/wiki/Design_Patterns>Design Patterns: Elements of Reusable Object-Oriented Software (GoF Book)</a></li><li><a href=https://aws.amazon.com/ko/architecture/well-architected/>AWS Well-Architected Guide</a></li></ul><hr><h2 id=6-주제에-대한-추가-조사-내용>6. 주제에 대한 추가 조사 내용<a hidden class=anchor aria-hidden=true href=#6-주제에-대한-추가-조사-내용>#</a></h2><p>현재까지 추가 조사 내용이 없습니다.</p><hr><h2 id=7-주제에-대해-추가로-알아야-하는-내용>7. 주제에 대해 추가로 알아야 하는 내용<a hidden class=anchor aria-hidden=true href=#7-주제에-대해-추가로-알아야-하는-내용>#</a></h2><p>Behavioral Design Patterns 의 적용은 시스템의 유연성과 확장성을 높이는 데 기여하지만, 과도한 사용은 오히려 복잡성을 증가시킬 수 있습니다. 따라서 상황에 맞게 적절한 패턴을 선택하여 적용하는 것이 중요합니다.</p><hr><h2 id=8-2025-년-기준-최신-동향>8. 2025 년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#8-2025-년-기준-최신-동향>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Behavioral Design Patterns</td><td>AI 통합</td><td>AI 기술의 발전으로 Behavioral Design Patterns 의 적용이 더욱 중요해지고 있습니다.</td></tr><tr><td>Behavioral Design Patterns</td><td>마이크로서비스 아키텍처</td><td>마이크로서비스 아키텍처에서의 객체 간 상호작용을 관리하기 위해 Behavioral Design Patterns 의 활용이 증가하고 있습니다.</td></tr></tbody></table><hr><h2 id=9-주제와-관련하여-주목할-내용>9. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#9-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Behavioral Design Patterns</td><td>이벤트 기반 아키텍처</td><td>이벤트 기반 아키텍처에서의 객체 간 상호작용을 관리하기 위해 Behavioral Design Patterns 의 활용이 증가하고 있습니다.</td></tr><tr><td>Behavioral Design Patterns</td><td>리액티브 프로그래밍</td><td>리액티브 프로그래밍에서의 객체 간 상호작용을 관리하기 위해 Behavioral Design Patterns 의 활용이 증가하고 있습니다.</td></tr></tbody></table><hr><h2 id=10-앞으로의-전망>10. 앞으로의 전망<a hidden class=anchor aria-hidden=true href=#10-앞으로의-전망>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Behavioral Design Patterns</td><td>지속적인 중요성</td><td>소프트웨어 시스템의 복잡성이 증가함에 따라 Behavioral Design Patterns 의 중요성은 지속적으로 증가할 것으로 예상됩니다.</td></tr><tr><td>Behavioral Design Patterns</td><td>교육 및 학습</td><td>개발자 교육 및 학습에서 Behavioral Design Patterns 의 중요성이 강조될 것으로 예상됩니다.</td></tr></tbody></table><hr><h2 id=11-하위-주제로-분류하여-추가적으로-학습해야-할-내용>11. 하위 주제로 분류하여 추가적으로 학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#11-하위-주제로-분류하여-추가적으로-학습해야-할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>Behavioral Patterns</td><td>Chain of Responsibility</td><td>요청을 처리할 수 있는 여러 객체를 체인 형태로 연결하여, 순차적으로 처리 책임을 넘기는 구조</td></tr><tr><td>Behavioral Patterns</td><td>Interpreter</td><td>언어의 문법을 클래스로 표현하고 해석기를 통해 의미를 분석하는 구조</td></tr><tr><td>Behavioral Patterns</td><td>Iterator</td><td>컬렉션의 내부 구조를 노출하지 않고 순회할 수 있게 하는 패턴</td></tr><tr><td>Behavioral Patterns</td><td>Template Method</td><td>상위 클래스에서 알고리즘의 구조를 정의하고, 하위 클래스에서 세부 구현을 정의하는 패턴</td></tr><tr><td>Behavioral Patterns</td><td>Visitor</td><td>객체 구조를 변경하지 않고 새로운 동작을 추가할 수 있게 하는 패턴</td></tr></tbody></table><hr><h2 id=12-관련-분야와-함께-추가로-알아야-할-학습-내용>12. 관련 분야와 함께 추가로 알아야 할 학습 내용<a hidden class=anchor aria-hidden=true href=#12-관련-분야와-함께-추가로-알아야-할-학습-내용>#</a></h2><table><thead><tr><th>관련 분야</th><th>주제</th><th>간략한 설명</th></tr></thead><tbody><tr><td>소프트웨어 아키텍처</td><td>이벤트 주도 아키텍처 (EDA)</td><td>객체 간의 비동기 통신 및 decoupling 을 촉진하여 Behavioral Patterns 과 자연스럽게 통합되는 구조</td></tr><tr><td>DevOps</td><td>마이크로서비스 간의 메시지 브로커 패턴</td><td>Command, Observer 등의 Behavioral Pattern 을 메시지 전달 방식으로 구현 가능</td></tr><tr><td>소프트웨어 품질</td><td>결합도와 응집도</td><td>Behavioral 패턴이 소프트웨어 모듈 간의 결합도를 낮추고 응집도를 높이기 위한 수단이 되는 이론</td></tr><tr><td>객체지향 설계 원칙</td><td>SOLID 원칙 중 DIP, OCP</td><td>Strategy, Command 등 Behavioral Pattern 은 의존 역전 원칙 (DIP) 과 개방/폐쇄 원칙 (OCP) 을 실현하는 데 유효</td></tr><tr><td>테스트 자동화</td><td>Mocking 및 Stub 설계</td><td>Observer, Command 등 이벤트 기반 동작을 테스트할 때 mocking 전략과 연계하여 활용 가능</td></tr></tbody></table><hr><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>GoF (Gang of Four)</td><td>『Design Patterns: Elements of Reusable Object-Oriented Software』의 저자 4 인을 지칭</td></tr><tr><td>객체 간 상호작용</td><td>객체들이 메시지를 주고받으며 역할을 분담하는 구조적 관계</td></tr><tr><td>캡슐화된 요청</td><td>요청을 Command 객체로 캡슐화하여 추상화하고 다양한 처리 방식에 유연하게 대응할 수 있는 구조</td></tr><tr><td>디커플링 (Decoupling)</td><td>구성 요소 간의 결합을 줄이고 독립성을 높이는 설계 원칙</td></tr><tr><td>리스너 (Listener)</td><td>이벤트를 감지하고 처리하는 객체 또는 인터페이스</td></tr></tbody></table><hr><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><a href=https://refactoring.guru/design-patterns/behavioral-patterns>Refactoring Guru: Behavioral Patterns</a></li><li><a href=https://www.geeksforgeeks.org/behavioral-design-patterns/>GeeksForGeeks: Behavioral Design Patterns</a></li><li><a href=https://sourcemaking.com/design_patterns>SourceMaking: Design Patterns</a></li><li><a href=https://www.dofactory.com/net/design-patterns>DoFactory: Behavioral Patterns</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Interpreter Pattern</h2></header><div class=entry-content><p>Interpreter Pattern Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.
이 패턴은 주로 간단한 언어나 표현식을 해석해야 할 때 사용된다.
Interpreter 패턴은 SQL 파서, 정규 표현식 엔진, 프로그래밍 언어 인터프리터 등 다양한 분야에서 활용된다. 하지만 복잡한 문법을 다룰 때는 파서 생성기 등 다른 도구를 고려하는 것이 좋다.
Interpreter 패턴의 주요 특징 문법 표현: 언어의 문법을 클래스 구조로 표현한다. 해석 메커니즘: 각 문법 규칙에 대한 해석 방법을 제공한다. 추상 구문 트리: 표현식을 계층적 구조로 표현한다. Interpreter 패턴의 구성 요소 AbstractExpression: 모든 표현식 클래스가 구현해야 하는 인터페이스를 정의한다. TerminalExpression: 더 이상 분해할 수 없는 기본 표현식을 나타낸다. NonterminalExpression: 다른 표현식을 포함하는 복합 표현식을 나타낸다. Context: 해석기가 해석해야 할 정보를 포함한다. Client: 추상 구문 트리를 구성하고 해석을 요청한다. Interpreter 패턴의 장점 문법 확장성: 새로운 표현식을 쉽게 추가할 수 있다. 문법 구현 용이성: 각 문법 규칙을 클래스로 표현하여 구현이 간단하다. 복잡한 문제 분해: 복잡한 문제를 작은 단위로 분해하여 해결할 수 있다. Interpreter 패턴의 단점 복잡한 문법에 부적합: 문법이 복잡해질수록 클래스 계층 구조가 복잡해진다. 성능 문제: 대규모 문법 해석 시 성능이 저하될 수 있다. Interpreter 패턴 사용 예시 아래는 인터프리터 패턴을 활용하여 후위 표기법 (Postfix Notation) 을 해석하고 계산하는 예제이다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:27:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interpreter Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Visitor Pattern</h2></header><div class=entry-content><p>Visitor Pattern Visitor Pattern 은 객체 구조와 알고리즘을 분리하는 행위 디자인 패턴이다.
이 패턴의 주요 목적은 기존 객체 구조를 변경하지 않고 새로운 동작을 추가할 수 있게 하는 것이다.
Visitor Pattern 의 주요 구성 요소 Visitor (방문자) 인터페이스:
객체 구조의 각 ConcreteElement 에 대한 visit() 메서드를 선언한다. ConcreteVisitor (구체적인 방문자):
Visitor 인터페이스를 구현하여 각 ConcreteElement 에 대한 구체적인 동작을 정의한다. Element (요소) 인터페이스:
accept(Visitor) 메서드를 선언하여 Visitor 객체를 받아들인다. ConcreteElement (구체적인 요소):
...</p></div><footer class=entry-footer><span title='2024-09-24 08:27:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;36 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Visitor Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/visitor-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chain of Responsibility</h2></header><div class=entry-content><p>Chain of Responsibility Chain of Responsibility 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추기 위한 행위 디자인 패턴이다.
Chain of Responsibility 패턴은 여러 객체를 체인으로 연결하여 요청을 순차적으로 처리하는 방식이다.
각 객체는 요청을 처리할 수 있으면 처리하고, 그렇지 않으면 다음 객체로 요청을 전달한다.
주요 특징:
요청의 발신자와 수신자를 분리한다. 여러 객체가 요청을 처리할 기회를 가진다. 요청 처리 객체를 동적으로 변경할 수 있다. 구성 요소 Handler (추상 처리자): 요청을 처리하는 인터페이스를 정의한다. 다음 처리자에 대한 참조를 가진다. ConcreteHandler (구체적 처리자): Handler 를 구현하여 실제 요청 처리 로직을 구현한다. Client: 요청을 처리자 체인의 첫 번째 객체에 전달한다. 구현 방법 Handler 인터페이스 정의:
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Chain of Responsibility" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/chain-of-responsibility/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern</h2></header><div class=entry-content><p>Mediator Pattern Mediator Pattern(중재자 패턴) 은 소프트웨어 디자인 패턴 중 하나로, 객체 간의 상호작용을 캡슐화하여 서로 직접 통신하지 않고 중재자 객체를 통해서만 소통하도록 설계된 행동 패턴이다.
이 패턴은 객체 간의 복잡한 의존성을 줄이고, 시스템의 유연성과 재사용성을 향상시키는 데 도움을 준다.
주요 개념 Mediator (중재자):
객체 간의 상호작용을 조정하는 역할을 하며, 서로 다른 객체들이 직접 통신하는 대신 중재자를 통해 소통하게 한다. Mediator 는 Colleague 객체들의 통신을 관리하고 조정한다. Colleague (동료):
Mediator 와 상호작용하는 객체들로, 각 동료 객체는 Mediator 를 통해 다른 동료와 통신한다. Colleague 객체는 Mediator 에 대한 참조를 가지고 있어야 한다. ConcreteMediator (구체적인 중재자):
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/mediator-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memento Pattern</h2></header><div class=entry-content><p>Memento Pattern Memento Pattern 은 행위 디자인 패턴 중 하나로, 객체의 상태를 저장하고 이전 상태로 복원할 수 있게 해주는 패턴이다.
메멘토 패턴 (Memento Pattern) 은 소프트웨어 디자인 패턴 중 하나로, 객체의 상태를 저장하고 나중에 복원할 수 있는 메커니즘을 제공한다.
이 패턴의 주요 목적은 객체의 내부 상태를 캡슐화하면서도 외부에서 해당 상태를 저장하고 복원할 수 있게 하는 것이다.
메멘토 패턴은 객체의 상태 관리와 복원이 중요한 애플리케이션에서 매우 유용한 디자인 패턴이다.
이 패턴을 적절히 활용하면 코드의 유연성과 유지보수성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memento Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/memento-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Command Pattern</h2></header><div class=entry-content><p>Command Pattern 요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴
요청을 하는 객체와 그 요청을 수행하는 객체를 분리한다.
이를 통해 요청을 큐에 저장하거나, 로그를 남기거나, 작업을 취소하는 등의 부가적인 기능을 쉽게 추가할 수 있다.
특징 요청을 객체로 캡슐화하여 매개변수화한다. 요청 발신자와 수신자를 분리합니다. 주요 구성요소 Command: 실행될 작업을 캡슐화하는 인터페이스 ConcreteCommand: Command 인터페이스를 구현하여 특정 작업을 수행하는 클래스 Invoker: Command 객체를 실행하는 클래스 Receiver: 실제 작업을 수행하는 클래스 Client: Command 객체를 생성하고 Invoker 에게 전달하는 클래스 사용사례 GUI 버튼 및 메뉴 항목의 액션 구현 트랜잭션 시스템에서의 작업 큐 관리 매크로 기록 및 실행 기능 구현 장점 느슨한 결합: 명령을 실행하는 객체와 실제 작업을 수행하는 객체가 분리되어 있어, 시스템의 유연성이 향상된다. 확장성: 새로운 Command 클래스를 추가하는 것만으로 새로운 기능을 쉽게 추가할 수 있다. 작업 취소/재실행: Command 객체가 이전 상태를 저장할 수 있어, Undo/Redo 기능을 쉽게 구현할 수 있다. 작업 큐잉과 로깅: Command 객체를 저장하고 나중에 실행하거나, 실행 이력을 보관할 수 있다. 단점 클래스 증가: 각 명령마다 별도의 클래스가 필요하므로, 클래스의 수가 증가할 수 있다. 복잡성: 간단한 작업의 경우에도 Command 객체를 생성해야 하므로, 불필요한 복잡성이 추가될 수 있다. 메모리 사용: 작업 이력을 저장할 경우 메모리 사용량이 증가할 수 있다. 주의사항 및 고려사항 Command 인터페이스 설계: Command 인터페이스는 가능한 한 단순하게 유지하되, 필요한 모든 작업을 수행할 수 있어야 합니다. 일반적으로 execute() 와 undo() 메서드를 포함한다. 상태 관리: Undo/Redo 기능을 구현할 경우, Command 객체는 이전 상태를 적절히 저장하고 복원할 수 있어야 한다. 복합 Command: 여러 Command 를 그룹화하여 하나의 Command 처럼 실행할 수 있는 MacroCommand 를 구현할 수 있다. 예외 처리: Command 실행 중 발생할 수 있는 예외 상황을 적절히 처리해야 한다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 from abc import ABC, abstractmethod from typing import List import time # Receiver 클래스들 class Light: def __init__(self, location: str): self.location = location self.is_on = False self.brightness = 0 def turn_on(self) -> None: self.is_on = True print(f"{self.location} light is now on") def turn_off(self) -> None: self.is_on = False print(f"{self.location} light is now off") def dim(self, level: int) -> None: self.brightness = level print(f"{self.location} light dimmed to {level}%") class Thermostat: def __init__(self, location: str): self.location = location self.temperature = 20 def set_temperature(self, temperature: float) -> None: self.temperature = temperature print(f"{self.location} thermostat set to {temperature}°C") # Command 인터페이스 class Command(ABC): @abstractmethod def execute(self) -> None: pass @abstractmethod def undo(self) -> None: pass # Concrete Command 클래스들 class LightOnCommand(Command): def __init__(self, light: Light): self.light = light self._prev_state = None def execute(self) -> None: self._prev_state = self.light.is_on self.light.turn_on() def undo(self) -> None: if self._prev_state is False: self.light.turn_off() class LightDimCommand(Command): def __init__(self, light: Light, level: int): self.light = light self.level = level self._prev_level = None def execute(self) -> None: self._prev_level = self.light.brightness self.light.dim(self.level) def undo(self) -> None: if self._prev_level is not None: self.light.dim(self._prev_level) class SetThermostatCommand(Command): def __init__(self, thermostat: Thermostat, temperature: float): self.thermostat = thermostat self.temperature = temperature self._prev_temperature = None def execute(self) -> None: self._prev_temperature = self.thermostat.temperature self.thermostat.set_temperature(self.temperature) def undo(self) -> None: if self._prev_temperature is not None: self.thermostat.set_temperature(self._prev_temperature) # Invoker 클래스 class SmartHomeController: def __init__(self): self._command_history: List[Command] = [] self._current_command = None def execute_command(self, command: Command) -> None: self._current_command = command command.execute() self._command_history.append(command) def undo_last_command(self) -> None: if self._command_history: command = self._command_history.pop() command.undo() # 클라이언트 코드 def main(): # Receiver 객체들 생성 living_room_light = Light("Living Room") bedroom_light = Light("Bedroom") living_room_thermostat = Thermostat("Living Room") # Command 객체들 생성 light_on = LightOnCommand(living_room_light) bedroom_light_dim = LightDimCommand(bedroom_light, 50) set_temp = SetThermostatCommand(living_room_thermostat, 22.5) # Invoker 생성 및 커맨드 실행 controller = SmartHomeController() print("=== Executing commands ===") controller.execute_command(light_on) time.sleep(1) # 실행 간격을 위한 지연 controller.execute_command(bedroom_light_dim) time.sleep(1) controller.execute_command(set_temp) print("\n=== Undoing commands ===") time.sleep(1) controller.undo_last_command() # 온도 설정 취소 time.sleep(1) controller.undo_last_command() # 조명 밝기 조절 취소 time.sleep(1) controller.undo_last_command() # 조명 켜기 취소 if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 // Receiver 클래스들 class Light { constructor(location) { this.location = location; this.isOn = false; this.brightness = 0; } turnOn() { this.isOn = true; console.log(`${this.location} light is now on`); } turnOff() { this.isOn = false; console.log(`${this.location} light is now off`); } dim(level) { this.brightness = level; console.log(`${this.location} light dimmed to ${level}%`); } } class Thermostat { constructor(location) { this.location = location; this.temperature = 20; } setTemperature(temperature) { this.temperature = temperature; console.log(`${this.location} thermostat set to ${temperature}°C`); } } // Command 인터페이스 class Command { execute() { throw new Error('execute method must be implemented'); } undo() { throw new Error('undo method must be implemented'); } } // Concrete Command 클래스들 class LightOnCommand extends Command { constructor(light) { super(); this.light = light; this._prevState = null; } execute() { this._prevState = this.light.isOn; this.light.turnOn(); } undo() { if (this._prevState === false) { this.light.turnOff(); } } } class LightDimCommand extends Command { constructor(light, level) { super(); this.light = light; this.level = level; this._prevLevel = null; } execute() { this._prevLevel = this.light.brightness; this.light.dim(this.level); } undo() { if (this._prevLevel !== null) { this.light.dim(this._prevLevel); } } } class SetThermostatCommand extends Command { constructor(thermostat, temperature) { super(); this.thermostat = thermostat; this.temperature = temperature; this._prevTemperature = null; } execute() { this._prevTemperature = this.thermostat.temperature; this.thermostat.setTemperature(this.temperature); } undo() { if (this._prevTemperature !== null) { this.thermostat.setTemperature(this._prevTemperature); } } } // Invoker 클래스 class SmartHomeController { constructor() { this._commandHistory = []; this._currentCommand = null; } executeCommand(command) { this._currentCommand = command; command.execute(); this._commandHistory.push(command); } undoLastCommand() { if (this._commandHistory.length > 0) { const command = this._commandHistory.pop(); command.undo(); } } } // 클라이언트 코드 async function main() { // Receiver 객체들 생성 const livingRoomLight = new Light("Living Room"); const bedroomLight = new Light("Bedroom"); const livingRoomThermostat = new Thermostat("Living Room"); // Command 객체들 생성 const lightOn = new LightOnCommand(livingRoomLight); const bedroomLightDim = new LightDimCommand(bedroomLight, 50); const setTemp = new SetThermostatCommand(livingRoomThermostat, 22.5); // Invoker 생성 및 커맨드 실행 const controller = new SmartHomeController(); console.log("=== Executing commands ==="); controller.executeCommand(lightOn); await new Promise(resolve => setTimeout(resolve, 1000)); // 실행 간격을 위한 지연 controller.executeCommand(bedroomLightDim); await new Promise(resolve => setTimeout(resolve, 1000)); controller.executeCommand(setTemp); console.log("\n=== Undoing commands ==="); await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 온도 설정 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 밝기 조절 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 켜기 취소 } main(); 용어 정리 용어 설명 참고 및 출처 1. 주제의 분류 적절성 Command Pattern(커맨드 패턴) 은 “Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Behavioral Design Patterns” 분류에 정확히 부합합니다. GoF(Gang of Four) 에서 정의한 23 가지 디자인 패턴 중 하나로, 대표적인 행동 (Behavioral) 패턴입니다 [1][2][7].
...</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Command Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/command-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>State Pattern</h2></header><div class=entry-content><p>State Pattern 객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴
상태별 동작을 별도의 클래스로 분리하고, 현재 상태를 나타내는 객체에게 행동을 위임하는 것
특징 객체의 내부 상태에 따라 행동을 변경할 수 있게 합니다. 상태 전이를 명시적으로 표현합니다. 각 상태를 별도의 클래스로 캡슐화합니다. 유한 상태 기계 (Finite-State Machine) 의 개념과 유사합니다. 사용사례 문서 처리 시스템: 문서가 초안, 검토 중, 승인됨, 게시됨 등의 상태를 가지며 각 상태에서 허용되는 작업이 다릅니다. 주문 처리 시스템: 주문이 생성됨, 결제 완료, 배송 중, 배송 완료 등의 상태를 거치며, 각 상태에서 가능한 작업이 달라집니다. 게임 캐릭터: 캐릭터가 서있음, 걷기, 달리기, 점프 등 다양한 상태를 가지며, 각 상태에서의 동작이 다릅니다. 네트워크 연결: 연결 중, 연결됨, 연결 끊김 등의 상태에 따라 다른 동작을 수행합니다. 장점 상태별 동작의 명확한 분리: 각 상태의 동작이 별도의 클래스로 캡슐화되어 코드의 구조가 명확해집니다. 상태 전환 로직의 체계화: 상태 전환이 명시적으로 이루어지며, 각 상태 클래스에서 가능한 전환을 정의할 수 있습니다. 새로운 상태 추가의 용이성: 기존 코드를 수정하지 않고도 새로운 상태를 추가할 수 있어 개방 - 폐쇄 원칙을 만족합니다. 단점 클래스 수의 증가: 각 상태마다 새로운 클래스가 필요하므로 클래스 수가 많아질 수 있습니다. 상태 전환 로직의 복잡성: 상태 간의 전환이 복잡할 경우 관리가 어려워질 수 있습니다. Context 와 State 간의 결합: State 클래스들이 Context 를 참조해야 하는 경우가 있어 결합도가 높아질 수 있습니다. 주의사항 및 고려사항 상태 전환의 일관성: 상태 전환이 일관되게 이루어지도록 주의해야 하며, 잘못된 전환을 방지해야 합니다. 메모리 관리: 상태 객체들을 적절히 재사용하거나 관리하지 않으면 메모리 사용량이 증가할 수 있습니다. 순환 참조 방지: Context 와 State 간의 순환 참조가 발생하지 않도록 주의해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 from abc import ABC, abstractmethod # State 인터페이스 class MediaPlayerState(ABC): @abstractmethod def play(self, player) -> None: pass @abstractmethod def pause(self, player) -> None: pass @abstractmethod def stop(self, player) -> None: pass @abstractmethod def get_state_name(self) -> str: pass # 구체적인 State 클래스들 class PlayingState(MediaPlayerState): def play(self, player) -> None: print("이미 재생 중입니다.") def pause(self, player) -> None: print("재생을 일시정지합니다.") player.change_state(PausedState()) def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "재생 중" class PausedState(MediaPlayerState): def play(self, player) -> None: print("재생을 재개합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("이미 일시정지 상태입니다.") def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "일시정지" class StoppedState(MediaPlayerState): def play(self, player) -> None: print("재생을 시작합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("중지 상태에서는 일시정지할 수 없습니다.") def stop(self, player) -> None: print("이미 중지 상태입니다.") def get_state_name(self) -> str: return "중지됨" # Context 클래스 class MediaPlayer: def __init__(self): # 초기 상태는 중지 상태 self._state = StoppedState() print(f"미디어 플레이어가 {self._state.get_state_name()} 상태로 시작됩니다.") def change_state(self, state: MediaPlayerState) -> None: self._state = state print(f"상태가 {self._state.get_state_name()}(으)로 변경되었습니다.") def play(self) -> None: self._state.play(self) def pause(self) -> None: self._state.pause(self) def stop(self) -> None: self._state.stop(self) # 사용 예시 def main(): player = MediaPlayer() # 재생 시작 player.play() # 중지 -> 재생 # 일시정지 player.pause() # 재생 -> 일시정지 # 재생 재개 player.play() # 일시정지 -> 재생 # 중지 player.stop() # 재생 -> 중지 # 일시정지 시도 (중지 상태에서는 불가능) player.pause() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // State 인터페이스 interface OrderState { processPayment(order: Order): void; shipOrder(order: Order): void; cancelOrder(order: Order): void; getStateName(): string; } // 구체적인 State 클래스들 class PendingState implements OrderState { processPayment(order: Order): void { console.log("결제를 진행합니다."); order.changeState(new PaidState()); } shipOrder(order: Order): void { console.log("결제가 필요합니다. 배송을 시작할 수 없습니다."); } cancelOrder(order: Order): void { console.log("주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 대기"; } } class PaidState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("배송을 시작합니다."); order.changeState(new ShippedState()); } cancelOrder(order: Order): void { console.log("결제가 환불되었습니다. 주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 완료"; } } class ShippedState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("이미 배송 중입니다."); } cancelOrder(order: Order): void { console.log("배송이 시작된 주문은 취소할 수 없습니다."); } getStateName(): string { return "배송 중"; } } class CancelledState implements OrderState { processPayment(order: Order): void { console.log("취소된 주문은 결제할 수 없습니다."); } shipOrder(order: Order): void { console.log("취소된 주문은 배송할 수 없습니다."); } cancelOrder(order: Order): void { console.log("이미 취소된 주문입니다."); } getStateName(): string { return "주문 취소"; } } // Context 클래스 class Order { private state: OrderState; private readonly orderId: string; constructor(orderId: string) { this.orderId = orderId; this.state = new PendingState(); console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 생성되었습니다.`); } public changeState(state: OrderState): void { this.state = state; console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 변경되었습니다.`); } public processPayment(): void { this.state.processPayment(this); } public shipOrder(): void { this.state.shipOrder(this); } public cancelOrder(): void { this.state.cancelOrder(this); } } // 사용 예시 function main() { const order = new Order("ORD-2024-001"); // 정상적인 주문 프로세스 console.log("\n=== 정상적인 주문 프로세스 ==="); order.processPayment(); // 결제 대기 -> 결제 완료 order.shipOrder(); // 결제 완료 -> 배송 중 // 취소된 주문 시나리오 console.log("\n=== 취소된 주문 시나리오 ==="); const cancelledOrder = new Order("ORD-2024-002"); cancelledOrder.cancelOrder(); // 결제 대기 -> 취소됨 cancelledOrder.processPayment(); // 결제 시도 (실패) cancelledOrder.shipOrder(); // 배송 시도 (실패) } main(); 용어 정리 용어 설명 참고 및 출처 1. 주제의 분류가 적절한지에 대한 조사 State Pattern(상태 패턴) 은 “Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Behavioral Design Patterns” 분류에 정확히 부합합니다. GoF(Gang of Four) 에서 정의한 23 가지 디자인 패턴 중 하나로, 객체의 상태 변화에 따른 동작 변경을 다루는 대표적인 행동 (Behavioral) 패턴입니다 [1][7][14].
...</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/state-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Template Method Pattern</h2></header><div class=entry-content><p>Template Method Pattern 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴
특징 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현할 수 있게 합니다. 공통 로직은 상위 클래스에서 정의하고, 변화가 필요한 부분만 하위 클래스에서 구현합니다. 알고리즘의 구조를 변경하지 않고 특정 단계를 재정의할 수 있습니다. 두 가지 주요 부분으로 구성된다.
추상 클래스 (Abstract Class): 알고리즘의 골격을 정의하는 템플릿 메서드를 포함 서브클래스에서 구현해야 하는 추상 메서드 정의 선택적으로 오버라이드할 수 있는 훅 (hook) 메서드 제공 구체 클래스 (Concrete Class): 추상 클래스를 상속받아 추상 메서드를 실제로 구현 필요한 경우 훅 메서드를 오버라이드하여 알고리즘을 커스터마이즈 사용사례 프레임워크에서 기본 동작을 정의하고 사용자가 일부를 커스터마이즈해야 할 때 데이터 마이닝 작업에서 데이터 처리 파이프라인을 구현할 때 리포트 생성 시스템에서 다양한 형식의 리포트를 생성할 때 장점 코드 재사용성이 높아집니다 알고리즘의 공통 부분을 한 곳에서 관리할 수 있습니다 확장성이 좋아 새로운 변형을 쉽게 추가할 수 있습니다 단점 템플릿 메소드가 복잡해질수록 유지보수가 어려워질 수 있습니다 하위 클래스에서 상위 클래스의 메소드를 실수로 오버라이드할 수 있습니다 알고리즘 단계가 많아지면 클래스 계층 구조가 복잡해질 수 있습니다 주의사항 및 고려사항 템플릿 메소드는 final 로 선언하여 하위 클래스가 override 하지 못하도록 해야 합니다. Python 에서는 관례적으로 메소드 이름 앞에 언더스코어를 붙여 protected 임을 나타냅니다. 추상 메소드 (반드시 구현해야 하는 메소드) 와 훅 메소드 (선택적으로 구현할 수 있는 메소드) 를 명확히 구분해야 합니다. 상속 계층이 깊어지지 않도록 주의해야 합니다. 일반적으로 추상 클래스와 구체 클래스의 2 단계 정도가 적절합니다. 템플릿 메소드가 너무 많은 단계를 가지지 않도록 해야 합니다. 복잡한 알고리즘은 더 작은 단위로 분리하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from abc import ABC, abstractmethod class DataMiner(ABC): """데이터 마이닝을 위한 템플릿 메소드 패턴 구현""" def mine_data(self, path: str) -> None: """템플릿 메소드: 데이터 마이닝의 전체 프로세스를 정의""" raw_data = self._read_file(path) cleaned_data = self._clean_data(raw_data) analyzed_data = self._analyze_data(cleaned_data) self._send_report(analyzed_data) @abstractmethod def _read_file(self, path: str) -> list: """파일을 읽어오는 추상 메소드""" pass def _clean_data(self, data: list) -> list: """데이터 정제를 위한 훅 메소드""" return data @abstractmethod def _analyze_data(self, data: list) -> dict: """데이터 분석을 위한 추상 메소드""" pass def _send_report(self, data: dict) -> None: """분석 결과 보고를 위한 훅 메소드""" print("기본 보고서 생성:", data) class PDFDataMiner(DataMiner): """PDF 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"PDF 파일 읽기: {path}") return ["PDF 데이터 1", "PDF 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "PDF", "results": data} def _clean_data(self, data: list) -> list: # PDF 특화 데이터 정제 로직 return [item.strip() for item in data] class CSVDataMiner(DataMiner): """CSV 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"CSV 파일 읽기: {path}") return ["CSV 데이터 1", "CSV 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "CSV", "results": data} # 사용 예시 if __name__ == "__main__": pdf_miner = PDFDataMiner() csv_miner = CSVDataMiner() pdf_miner.mine_data("sample.pdf") csv_miner.mine_data("sample.csv") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BeverageMaker { /** * 음료 제조를 위한 템플릿 메소드 * @returns {void} */ prepare() { this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) { this.addCondiments(); } this.serve(); } /** * 물을 끓이는 공통 메소드 * @private */ boilWater() { console.log('물을 끓입니다'); } /** * 음료를 우리는 추상 메소드 * @abstract * @private */ brew() { throw new Error('brew 메소드를 구현해야 합니다'); } /** * 컵에 따르는 공통 메소드 * @private */ pourInCup() { console.log('컵에 따릅니다'); } /** * 고객이 첨가물을 원하는지 확인하는 훅 메소드 * @returns {boolean} */ customerWantsCondiments() { return true; } /** * 첨가물을 추가하는 추상 메소드 * @abstract * @private */ addCondiments() { throw new Error('addCondiments 메소드를 구현해야 합니다'); } /** * 음료를 서빙하는 공통 메소드 * @private */ serve() { console.log('음료가 준비되었습니다'); } } class CoffeeMaker extends BeverageMaker { brew() { console.log('커피를 우립니다'); } addCondiments() { console.log('설탕과 우유를 추가합니다'); } customerWantsCondiments() { // 고객 선호도에 따라 첨가물 추가 여부 결정 return Math.random() > 0.5; } } class TeaMaker extends BeverageMaker { brew() { console.log('차를 우립니다'); } addCondiments() { console.log('레몬을 추가합니다'); } } // 사용 예시 const coffee = new CoffeeMaker(); const tea = new TeaMaker(); console.log('=== 커피 준비 ==='); coffee.prepare(); console.log('\n=== 차 준비 ==='); tea.prepare(); 용어 정리 용어 설명 참고 및 출처 1. 주제의 분류가 적절한지에 대한 조사 Template Method Pattern(템플릿 메서드 패턴) 은 “Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Behavioral Design Patterns” 분류에 정확히 속합니다. GoF(Gang of Four) 에서 정의한 대표적인 행동 (Behavioral) 패턴 중 하나로, 알고리즘 구조의 재사용성과 확장성을 높이는 데 중점을 둡니다 [1][2][3][8].
...</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;27 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Template Method Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/template-method-pattern/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>