<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Behavioral | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,Design-and-Architecture,Software-Design-Patterns,GoF,Behavioral,Object-Communication"><meta name=description content="Behavioral Pattern 은 객체들 간 **책임 분배와 실행 흐름 협력**을 설계하여, 코드 의존성을 줄이고 유연성을 강화한다.  대표 패턴으로는 Observer, Strategy, Command 등이 있으며, 런타임 행동 변경과 확장에 효과적이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Behavioral"><meta property="og:description" content="Behavioral Pattern 은 객체들 간 **책임 분배와 실행 흐름 협력**을 설계하여, 코드 의존성을 줄이고 유연성을 강화한다.  대표 패턴으로는 Observer, Strategy, Command 등이 있으며, 런타임 행동 변경과 확장에 효과적이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Behavioral"><meta name=twitter:description content="Behavioral Pattern 은 객체들 간 **책임 분배와 실행 흐름 협력**을 설계하여, 코드 의존성을 줄이고 유연성을 강화한다.  대표 패턴으로는 Observer, Strategy, Command 등이 있으며, 런타임 행동 변경과 확장에 효과적이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기록하고 기억하고 활용하자.","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":5,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/"},{"@type":"ListItem","position":6,"name":"Behavioral","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기록하고 기억하고 활용하자.</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/>GoF</a></div><h1>Behavioral</h1><div class=post-description>Behavioral Pattern 은 객체들 간 <strong>책임 분배와 실행 흐름 협력</strong>을 설계하여, 코드 의존성을 줄이고 유연성을 강화한다. 대표 패턴으로는 Observer, Strategy, Command 등이 있으며, 런타임 행동 변경과 확장에 효과적이다.</div></header><div class=post-content><h2 id=behavioral>Behavioral<a hidden class=anchor aria-hidden=true href=#behavioral>#</a></h2><p>Behavioral Design Patterns 는 객체 간 <strong>상호작용 방식과 책임 배분 전략</strong>을 설계하는 11 가지의 패턴 집합이다. 대표적으로 <strong>Chain of Responsibility, Command, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor, Interpreter</strong>가 있으며, 각 패턴은 응집도 높은 메시징, 실행 위임, 상태 기반 제어, 알고리즘 분리 등 동작 중심 설계 문제를 해결한다. 실무에서는 이벤트 처리, 명령 큐, 상태 머신, GUI 로직 등에서 널리 활용된다.</p><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>GoF(&ldquo;Gang of Four&rdquo;) 에서 정의한 23 개 패턴 중 하나로, 객체 간의 협력과 메시지 전달을 정형화하기 위해 등장했다.</p><p><strong>문제 상황:</strong></p><ul><li>객체 간 복잡한 상호작용, 행위의 동적 변경, 알고리즘 분리 필요성 등에서 기존 구조로는 유연성과 확장성이 부족하다.</li></ul><p><strong>해결 방안:</strong></p><ul><li>행위 패턴을 통해 객체 간 상호작용을 구조화하고, 행위를 캡슐화하여 동적으로 관리할 수 있게 한다.</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><p><strong>주요 목적</strong>:</p><ol><li><strong>느슨한 결합 (Loose Coupling)</strong>: 객체 간 직접적인 의존성을 최소화</li><li><strong>책임 분산</strong>: 복잡한 작업을 여러 객체에 적절히 분배</li><li><strong>유연한 협력</strong>: 런타임에 객체 간 상호작용 방식 변경 가능</li><li><strong>코드 재사용성</strong>: 검증된 상호작용 패턴의 재활용</li></ol><p><strong>필요성</strong>:</p><ul><li>객체지향 시스템에서 객체 간 복잡한 상호작용 관리</li><li>시스템 확장성과 유지보수성 향상</li><li>비즈니스 로직의 변화에 대한 유연한 대응</li></ul><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>행위 패턴 (Behavioral Pattern) 은 객체 간 상호작용, 알고리즘 분리, 행위의 캡슐화 등을 통해 시스템의 유연성과 확장성을 높이는 GoF 디자인 패턴의 한 분류이다.</p><h4 id=기본-개념>기본 개념<a hidden class=anchor aria-hidden=true href=#기본-개념>#</a></h4><ol><li><p><strong>객체 간 커뮤니케이션 (Object Communication)</strong></p><ul><li>객체들이 어떻게 메시지를 주고받고 협력하는지를 정의</li><li>직접적인 참조를 통한 강한 결합을 피하고 느슨한 결합 구현</li></ul></li><li><p><strong>책임의 분산 (Responsibility Distribution)</strong></p><ul><li>단일 객체가 모든 작업을 처리하지 않고 여러 객체에 책임을 분산</li><li>각 객체는 자신의 전문 영역에 집중</li></ul></li><li><p><strong>알고리즘 캡슐화 (Algorithm Encapsulation)</strong></p><ul><li>알고리즘을 독립적인 객체로 캡슐화하여 런타임에 동적 선택 가능</li><li>변경과 확장에 대해 유연성 제공</li></ul></li><li><p><strong>상태 및 행위 관리 (State and Behavior Management)</strong></p><ul><li>객체의 내부 상태 변화에 따른 행위 변화를 체계적으로 관리</li><li>상태 전이와 행위 변화의 명확한 분리</li></ul></li></ol><h4 id=핵심-개념의-실무-구현-연관성>핵심 개념의 실무 구현 연관성<a hidden class=anchor aria-hidden=true href=#핵심-개념의-실무-구현-연관성>#</a></h4><ol><li><p><strong>이벤트 기반 아키텍처 (Event-Driven Architecture)</strong></p><ul><li>Observer 패턴을 통한 발행 - 구독 모델 구현</li><li>마이크로서비스 간 비동기 통신에 활용</li></ul></li><li><p><strong>상태 기계 구현 (State Machine Implementation)</strong></p><ul><li>State 패턴을 통한 복잡한 비즈니스 로직의 상태 관리</li><li>워크플로우 엔진과 결제 처리 시스템에서 핵심 역할</li></ul></li><li><p><strong>커맨드 패턴 기반 CQRS (Command Query Responsibility Segregation)</strong></p><ul><li>Command 패턴을 통한 명령과 조회의 분리</li><li>대규모 시스템의 확장성과 성능 최적화</li></ul></li></ol><h4 id=패턴이-해결하고자-하는-설계-문제>패턴이 해결하고자 하는 설계 문제<a hidden class=anchor aria-hidden=true href=#패턴이-해결하고자-하는-설계-문제>#</a></h4><table><thead><tr><th><strong>설계 문제</strong></th><th><strong>문제 설명</strong></th><th><strong>해결 방식 (패턴 적용)</strong></th></tr></thead><tbody><tr><td>객체 간 강한 결합 문제</td><td>객체들이 직접 서로를 참조함으로써 변경에 취약하고 재사용성이 떨어짐</td><td><strong>인터페이스</strong>, <strong>중재자 (Mediator)</strong>, **관찰자 (Observer)**를 통해 간접 통신 구조 설계</td></tr><tr><td>변경에 대한 시스템 취약성</td><td>한 객체 또는 모듈의 변경이 전체 시스템에 연쇄적으로 영향을 미침</td><td><strong>개방 - 폐쇄 원칙 (OCP)</strong> 기반 설계: <strong>Command</strong>, <strong>Strategy</strong>, <strong>Observer</strong> 등 적용</td></tr><tr><td>복잡한 조건부 로직</td><td>다중 <code>if-else</code> 또는 <code>switch</code> 문이 반복되어 가독성과 유지보수성 저하</td><td><strong>전략 (Strategy)</strong>, <strong>상태 (State)</strong> 패턴으로 로직을 객체로 분리하여 캡슐화</td></tr><tr><td>책임의 분산 부족</td><td>하나의 객체가 너무 많은 책임을 가짐 (단일 책임 원칙 위반)</td><td><strong>책임 연쇄 (Chain of Responsibility)</strong>, <strong>Command</strong>, <strong>Visitor</strong>로 책임 분리</td></tr><tr><td>요청 처리의 유연성 부족</td><td>요청 처리 방식이 고정되어 있고 유연하게 확장하거나 조합하기 어려움</td><td><strong>Command</strong>, <strong>Interpreter</strong>, <strong>Template Method</strong>로 요청을 캡슐화 및 구조화</td></tr><tr><td>객체 상태 관리 문제</td><td>상태에 따른 동작 변경이 조건문 기반으로 구현되어 유지보수 어려움</td><td><strong>State</strong> 패턴을 통해 객체의 상태와 동작을 분리</td></tr></tbody></table><h3 id=패턴-적용의-결과와-트레이드오프>패턴 적용의 결과와 트레이드오프<a hidden class=anchor aria-hidden=true href=#패턴-적용의-결과와-트레이드오프>#</a></h3><p><strong>긍정적 결과</strong>:</p><ul><li>시스템의 유연성과 확장성 향상</li><li>코드 재사용성과 유지보수성 개선</li><li>테스트 용이성 증대</li></ul><p><strong>트레이드오프</strong>:</p><ul><li>초기 개발 복잡도 증가 vs 장기적 유지보수 비용 절감</li><li>런타임 성능 오버헤드 vs 개발 생산성 향상</li><li>학습 곡선 존재 vs 팀 전체의 설계 품질 향상</li></ul><h3 id=기능-및-역할>기능 및 역할<a hidden class=anchor aria-hidden=true href=#기능-및-역할>#</a></h3><table><thead><tr><th>기능</th><th>역할</th></tr></thead><tbody><tr><td>메시지 전달</td><td>Chain of Responsibility, Mediator 등을 통해 요청 흐름 제어</td></tr><tr><td>행동 캡슐화</td><td>Strategy, Command 로 알고리즘/동작 구조화</td></tr><tr><td>상태 기반 행동 제어</td><td>State 패턴으로 객체 동작 상태 전환 구조화</td></tr><tr><td>순회 및 부가 기능</td><td>Iterator, Visitor 로 구조 순회 및 외부 연산 수행</td></tr><tr><td>이벤트 처리</td><td>Observer 로 상태 변화 알림 및 반응 동기화</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ol><li><p><strong>객체 컴포지션 중심</strong></p><ul><li>상속보다는 객체 컴포지션을 통한 유연성 확보</li><li>런타임에 객체 간 관계 변경 가능</li></ul></li><li><p><strong>인터페이스 기반 설계</strong></p><ul><li>구체적인 구현보다는 인터페이스에 의존</li><li>다형성을 통한 유연한 구현 교체</li></ul></li><li><p><strong>단일 책임 원칙 준수</strong></p><ul><li>각 객체는 하나의 명확한 책임만 담당</li><li>코드의 이해도와 유지보수성 향상</li></ul></li></ol><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><pre class=mermaid>graph TD
    A[Behavioral Pattern 핵심 원칙] --&gt; B[느슨한 결합&lt;br/&gt;Loose Coupling]
    A --&gt; C[책임 분산&lt;br/&gt;Responsibility Distribution]
    A --&gt; D[인터페이스 분리&lt;br/&gt;Interface Segregation]
    A --&gt; E[개방-폐쇄 원칙&lt;br/&gt;Open-Closed Principle]
    
    B --&gt; B1[객체 간 직접 참조 최소화]
    B --&gt; B2[중재자를 통한 간접 통신]
    
    C --&gt; C1[단일 책임 원칙 준수]
    C --&gt; C2[역할과 책임의 명확한 분리]
    
    D --&gt; D1[클라이언트 특화 인터페이스]
    D --&gt; D2[의존성 역전]
    
    E --&gt; E1[확장에는 열려있고]
    E --&gt; E2[수정에는 닫혀있음]
</pre><ol><li><p><strong>느슨한 결합 (Loose Coupling)</strong></p><ul><li>객체 간 직접적인 참조를 최소화하여 의존성 감소</li><li>한 객체의 변경이 다른 객체에 미치는 영향 최소화</li></ul></li><li><p><strong>책임 분산 (Responsibility Distribution)</strong></p><ul><li>복잡한 작업을 여러 객체에 적절히 분배</li><li>각 객체는 자신의 전문 영역에만 집중</li></ul></li><li><p><strong>인터페이스 분리 (Interface Segregation)</strong></p><ul><li>클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 분리</li><li>변경의 영향 범위 최소화</li></ul></li></ol><h3 id=주요-원리>주요 원리<a hidden class=anchor aria-hidden=true href=#주요-원리>#</a></h3><ol><li><p><strong>위임 원리 (Delegation Principle)</strong></p><ul><li>작업을 다른 객체에 위임하여 책임 분산</li><li>상속 대신 컴포지션을 통한 유연성 확보</li></ul></li><li><p><strong>중재 원리 (Mediation Principle)</strong></p><ul><li>객체 간 직접 통신 대신 중재자를 통한 간접 통신</li><li>시스템의 복잡성 감소</li></ul></li><li><p><strong>관찰 원리 (Observation Principle)</strong></p><ul><li>상태 변화를 관찰하고 그에 따른 적절한 반응 수행</li><li>이벤트 기반 시스템의 기초</li></ul></li></ol><h3 id=행동-패턴의-종류-및-비교>행동 패턴의 종류 및 비교<a hidden class=anchor aria-hidden=true href=#행동-패턴의-종류-및-비교>#</a></h3><pre class=mermaid>graph TB
    subgraph &#34;Behavioral Patterns Architecture&#34;
        subgraph &#34;Communication Patterns&#34;
            A1[Chain of Responsibility]
            A2[Command]
            A3[Mediator]
            A4[Observer]
        end
        
        subgraph &#34;Algorithm Patterns&#34;
            B1[Strategy]
            B2[Template Method]
            B3[Visitor]
        end
        
        subgraph &#34;State Management&#34;
            C1[State]
            C2[Memento]
        end
        
        subgraph &#34;Iteration &amp; Interpretation&#34;
            D1[Iterator]
            D2[Interpreter]
        end
        
        subgraph &#34;Utility Patterns&#34;
            E1[Null Object]
        end
    end
    
    A1 --&gt; F[Request Processing]
    A2 --&gt; F
    A3 --&gt; G[Communication Coordination]
    A4 --&gt; G
    
    B1 --&gt; H[Algorithm Selection]
    B2 --&gt; H
    B3 --&gt; H
    
    C1 --&gt; I[State Management]
    C2 --&gt; I
    
    D1 --&gt; J[Data Access]
    D2 --&gt; J
    
    E1 --&gt; K[Default Behavior]
</pre><table><thead><tr><th>패턴명</th><th>핵심 목적</th><th>사용 시점</th><th>구조적 특징</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td><strong>Chain of Responsibility</strong></td><td>요청을 처리할 수 있는 객체를 연결하여 처리 책임을 넘김</td><td>요청을 처리할 객체가 여러 개일 수 있고, 순차적으로 위임할 때</td><td>핸들러 체인 구성</td><td>결합도 감소, 처리자 유연성</td><td>디버깅 어려움, 체인 순서 의존</td></tr><tr><td><strong>Command</strong></td><td>요청을 객체로 캡슐화하여 요청자와 수행자를 분리</td><td>명령 실행을 큐잉하거나, 취소/재실행 기능이 필요할 때</td><td>명령 객체 + 리시버 구성</td><td>요청 재사용, Undo/Redo 구현 가능</td><td>클래스 수 증가, 복잡성 증가</td></tr><tr><td><strong>Interpreter</strong></td><td>문법 표현을 클래스로 정의하고 해석</td><td>도메인에 특화된 언어나 스크립트를 해석할 필요가 있을 때</td><td>추상 표현 + 구체 표현 클래스 구조</td><td>문법 유연성, DSL 구성 가능</td><td>복잡한 문법에는 부적합, 성능 저하 가능</td></tr><tr><td><strong>Iterator</strong></td><td>내부 표현을 노출하지 않고 요소에 순차 접근</td><td>컨테이너나 컬렉션의 내부 구조와 무관하게 순회가 필요할 때</td><td>반복자 객체가 컬렉션을 순회</td><td>구현 간결화, 컬렉션 타입 일관된 접근</td><td>병렬 처리 어렵고, 동시 수정 시 문제 발생</td></tr><tr><td><strong>Mediator</strong></td><td>객체 간의 상호작용을 중재자 (Mediator) 에 위임</td><td>여러 객체 간의 복잡한 상호작용이 존재할 때</td><td>중앙 중재 객체가 통신 조정</td><td>객체 간 결합도 최소화, 통제 구조 명확</td><td>Mediator 자체 복잡도 증가</td></tr><tr><td><strong>Memento</strong></td><td>객체 상태를 외부에 저장하고 복원 가능하게 함</td><td>Undo 기능 구현이나 상태 복원이 필요할 때</td><td>Memento(스냅샷) + Caretaker 구조</td><td>상태 캡슐화, 내부 정보 보호</td><td>메모리 부담, 직렬화 구현 필요</td></tr><tr><td><strong>Observer</strong></td><td>한 객체 상태 변경 시 관련 객체들에 자동 통지</td><td>상태 변화에 따라 자동으로 동기화해야 할 때 (이벤트 시스템)</td><td>Subject + Observer 구조</td><td>느슨한 결합, 이벤트 중심 설계 용이</td><td>알림 폭주 가능성, 순서 제어 어려움</td></tr><tr><td><strong>State</strong></td><td>객체 상태에 따라 행동을 동적으로 변경</td><td>상태 기반으로 분기 처리가 많고, 상태별 로직 분리 필요할 때</td><td>상태 객체들이 Context 내에서 교체됨</td><td>상태 전이 명확, SRP 준수</td><td>클래스 수 증가, 상태 전이 복잡도 증가</td></tr><tr><td><strong>Strategy</strong></td><td>알고리즘을 런타임에 교체 가능하게 캡슐화</td><td>알고리즘이 여러 개 존재하고, 런타임에 유동적으로 교체할 필요가 있을 때</td><td>전략 인터페이스 + 구현 클래스 구성</td><td>알고리즘 독립성 확보, 클라이언트 코드 단순화</td><td>객체 간 연결 필요, 전략 관리 필요</td></tr><tr><td><strong>Template Method</strong></td><td>알고리즘의 뼈대를 정의하고, 일부 단계를 서브클래스에서 구현</td><td>알고리즘은 같지만 세부 처리만 달라야 할 때</td><td>상위 클래스에서 알고리즘 흐름 고정</td><td>코드 재사용성 향상, 공통 로직 집중화</td><td>상속 기반이라 유연성 제한, 변경 어려움</td></tr><tr><td><strong>Visitor</strong></td><td>구조 변경 없이 객체에 새로운 기능을 추가</td><td>복잡한 객체 구조에 다양한 연산을 적용하고자 할 때</td><td>Visitor 인터페이스 + ConcreteVisitor</td><td>연산 분리, 새로운 기능 쉽게 추가</td><td>객체 구조가 변경되면 모든 Visitor 수정 필요, 복잡성 증가</td></tr></tbody></table><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><table><thead><tr><th><strong>구분</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td>구조적 장점</td><td>느슨한 결합 (Low Coupling)</td><td>객체 간 직접 참조 없이 인터페이스를 통해 협력 → 변경에 유연하고 테스트 용이</td></tr><tr><td>구조적 장점</td><td>책임 분리 (Responsibility Separation)</td><td>객체가 하나의 명확한 역할만 수행 → 유지보수성 및 가독성 향상</td></tr><tr><td>구조적 장점</td><td>단일 책임 원칙 (SRP 준수)</td><td>행위 캡슐화를 통해 한 객체가 하나의 책임만 가지게 됨</td></tr><tr><td>확장성</td><td>개방 - 폐쇄 원칙 (OCP 준수)</td><td>새로운 알고리즘, 상태, 동작을 기존 코드 수정 없이 확장 가능</td></tr><tr><td>확장성</td><td>전략/행위 교체 용이성</td><td>실행 시점에 객체의 행위나 전략을 교체할 수 있어 동적 로직 변경이 가능</td></tr><tr><td>재사용성</td><td>알고리즘/행위 재사용</td><td>캡슐화된 행위 객체는 다양한 컨텍스트에서 독립적으로 재사용 가능</td></tr><tr><td>테스트성</td><td>테스트 용이성</td><td>인터페이스 기반 설계 덕분에 Mocking/Stub 을 활용한 단위 테스트 작성이 쉬움</td></tr><tr><td>유연성</td><td>런타임 유연성</td><td>조건문 없이도 실행 중 전략, 상태, 행위 등을 동적으로 전환 가능</td></tr><tr><td>실무 적용성</td><td>이벤트 기반 구조 적합</td><td>Observer, Command, Chain 등의 패턴은 이벤트 중심 시스템에 적합</td></tr><tr><td>실무 적용성</td><td>핸들러 조합 및 흐름 제어 유리</td><td>Chain of Responsibility 나 Template Method 는 동작 순서나 책임을 유연하게 조절 가능</td></tr></tbody></table><h3 id=단점과-문제점-그리고-해결방안>단점과 문제점 그리고 해결방안<a hidden class=anchor aria-hidden=true href=#단점과-문제점-그리고-해결방안>#</a></h3><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><table><thead><tr><th>항목</th><th>설명</th><th>해결방안</th></tr></thead><tbody><tr><td>복잡성 증가</td><td>객체 간 협력이 많아지면서 시스템 구조가 복잡해지고 이해하기 어려움</td><td>UML 다이어그램 활용, 문서화 강화, 컴포넌트 기반 설계 적용</td></tr><tr><td>클래스 수 증가</td><td>상태, 전략, 명령 등 객체 분리로 인한 클래스 수 급증</td><td>공통 책임 통합, 유틸리티 패턴 적용, DI(의존성 주입) 로 관리</td></tr><tr><td>성능 오버헤드</td><td>중개자/위임자 호출이 늘어나면서 성능 저하 발생 가능</td><td>직접 호출 허용, Lazy Initialization, 캐싱 전략 활용</td></tr><tr><td>디버깅 어려움</td><td>호출 경로가 다양하고 간접적이라 스택 트레이스 분석이 어려움</td><td>로깅 시스템 강화, 상관 ID 사용, 트레이싱 도구 적용 (예: OpenTelemetry)</td></tr><tr><td>러닝 커브</td><td>패턴 자체의 개념과 관계 구조 학습이 필요함</td><td>팀 내 교육, 코드 리뷰 통한 공유, 패턴 캡슐화된 템플릿 제공</td></tr><tr><td>테스트 복잡성</td><td>각 객체의 독립성과 상호작용이 높아 테스트 커버리지가 어려움</td><td>Mocking 도구 활용 (예: unittest.mock, Sinon.js), 통합 테스트 우선 접근</td></tr><tr><td>구조 난해화</td><td>설계 초기에 과도한 추상화가 오히려 구조를 더 어렵게 만듦</td><td>단순성 우선 설계, 필요할 때만 패턴 도입 (YAGNI 원칙 적용)</td></tr></tbody></table><h4 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h4><table><thead><tr><th>항목</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>과도한 패턴 적용</td><td>무분별하게 모든 문제를 패턴으로 해결하려는 접근 방식</td><td>코드 복잡성 증가, 유지보수성 저하</td><td>코드 리뷰, 설계 리뷰</td><td>요구사항 기반 선별 적용, 단순한 구조 선호</td><td>리팩토링, 필요 없는 계층 제거</td></tr><tr><td>순환 참조</td><td>Observer, Mediator 간 의존성 설계 미흡</td><td>스택 오버플로우, 무한 루프 가능성</td><td>정적 분석 도구, 코드 리뷰</td><td>약한 참조 (WeakRef), 이벤트 해제 구조 명확화</td><td>참조 제거 또는 중간 매핑 객체 도입</td></tr><tr><td>메모리 누수</td><td>구독 해제 누락 (특히 Observer 패턴)</td><td>메모리 증가, 시스템 리소스 소모</td><td>메모리 프로파일링, GC 로그 분석</td><td>자동 구독 해제 구조, Context Manager, Weak Reference</td><td>스마트 포인터 활용, WeakMap/Set 구조로 관리</td></tr><tr><td>무한 재귀/호출</td><td>Self-reference 또는 재귀 흐름 차단 미비</td><td>시스템 다운, 무한 호출</td><td>스택 추적, 호출 로그 분석</td><td>호출 깊이 제한, 순환 의존성 제거</td><td>호출 트리 리팩토링 또는 이벤트 큐 도입</td></tr><tr><td>상태 불일치</td><td>State/Memento 사용 시 멀티스레드 환경에서 동기화 문제</td><td>데이터 불일치, 비정상 상태 전이</td><td>스레드 분석, 경쟁 조건 모니터링 도구 사용</td><td>불변 객체, Lock/Atomic 사용, 이벤트 기반 아</td><td></td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>도전 과제</strong></th><th><strong>원인</strong></th><th><strong>영향</strong></th><th><strong>해결 방안</strong></th></tr></thead><tbody><tr><td>패턴 선택/설계</td><td>부적절한 패턴 선택</td><td>요구사항과 무관한 패턴 적용</td><td>코드 복잡도 증가, 유지보수성 저하</td><td>패턴 선택 전 요구사항 정제 및 설계 목적 재검토</td></tr><tr><td>구조 복잡성</td><td>클래스/객체 수 증가</td><td>전략/행위 객체 분리 과도</td><td>관리 복잡성, 진입 장벽 상승</td><td>중복 전략 통합, 팩토리 패턴 도입, 문서화/시각화</td></tr><tr><td>런타임 안전성</td><td>전략/상태 불일치</td><td>Context 내부 상태와 전략 객체 간 계약 미비</td><td>예외 발생, 비정상 동작</td><td>상태 전이 제어, 전략 변경 전/후 검증, 트랜잭션 관리 강화</td></tr><tr><td>동시성 이슈</td><td>전략 객체의 공유 상태 문제</td><td>멀티스레드 환경에서 상태를 갖는 전략 객체 공유</td><td>데이터 레이스, 잘못된 동작</td><td>Stateless 객체 사용, Thread-local 전략 분리, Actor 모델 적용</td></tr><tr><td>성능 최적화</td><td>객체 호출 및 이벤트 과다</td><td>다수 객체 간 호출 및 옵저버 알림 반복</td><td>메모리/CPU 오버헤드, 응답 지연</td><td>이벤트 배치 처리, 캐싱 도입, 불필요한 참조 제거</td></tr><tr><td>타입 안정성</td><td>런타임 구성 시 오류 가능</td><td>동적 전략/핸들러 변경 → 정적 타입 체크 불가</td><td>예외 처리 누락, 런타임 실패</td><td>명확한 인터페이스 계약, 전략 매핑 유효성 검사</td></tr><tr><td>테스트/유지보수성</td><td>복잡한 흐름 및 의존성</td><td>핸들러 체인, 전략 내부 흐름이 깊고 분산됨</td><td>테스트 작성 어려움, 신규 투입 시 학습 곡선 증가</td><td>Mock 설계 강화, 행위 단위 테스트 도입, 코드 컨벤션 및 문서화 철저</td></tr><tr><td>비동기 흐름 통합</td><td>이벤트 기반 시스템에서의 제어 복잡</td><td>옵저버/커맨드/체인 등 비동기 로직의 흐름 추적 어려움</td><td>디버깅 어려움, 흐름 분기 누락</td><td>이벤트 추적 시스템 도입 (예: OpenTelemetry), 명시적 이벤트 로그 활용</td></tr><tr><td>기술 적용/환경 적응</td><td>클라우드·MSA·서버리스 환경의 특수성</td><td>동기적 객체 협력 방식이 분산/비동기 환경과 충돌</td><td>네트워크 지연, 부분 실패, 확장성 저하</td><td>이벤트 소싱, CQRS, 회로 차단기, 벌크헤드, 리액티브 패턴 조합 적용</td></tr></tbody></table><h3 id=실무-사용-예시>실무 사용 예시<a hidden class=anchor aria-hidden=true href=#실무-사용-예시>#</a></h3><table><thead><tr><th>사용 목적</th><th>함께 사용되는 기술</th><th>효과</th></tr></thead><tbody><tr><td>웹 애플리케이션 이벤트 처리</td><td>Observer + JavaScript Event System</td><td>사용자 인터랙션에 대한 실시간 반응 시스템 구현</td></tr><tr><td>마이크로서비스 간 통신</td><td>Command + Message Queue (RabbitMQ, Kafka)</td><td>서비스 간 비동기 통신 및 장애 격리</td></tr><tr><td>게임 AI 시스템</td><td>State + Finite State Machine</td><td>복잡한 NPC 행동 패턴 및 게임 상태 관리</td></tr><tr><td>API 인증/인가 시스템</td><td>Chain of Responsibility + Spring Security</td><td>다단계 보안 검증 프로세스 구현</td></tr><tr><td>데이터 처리 파이프라인</td><td>Strategy + Apache Spark</td><td>데이터 소스별 맞춤형 처리 알고리즘 적용</td></tr><tr><td>GUI 프레임워크</td><td>Observer + MVC Pattern</td><td>모델 변경에 따른 뷰 자동 업데이트</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-결제-모듈에서-strategy-패턴-적용>사례 1: 결제 모듈에서 Strategy 패턴 적용<a hidden class=anchor aria-hidden=true href=#사례-1-결제-모듈에서-strategy-패턴-적용>#</a></h4><p>전자상거래 플랫폼에서 다양한 결제 수단 (신용카드, 페이팔, 포인트 등) 을 <strong>Strategy 패턴</strong>으로 캡슐화하여 사용자가 결제 방식에 따라 적절한 <code>PaymentStrategy</code> 를 선택하도록 설계.</p><p><strong>시스템 구성 및 흐름</strong>:</p><pre class=mermaid>sequenceDiagram
    participant User
    participant Context as CheckoutService
    participant Strategy as PaymentStrategy
    participant Concrete1 as CreditCardStrategy
    participant Concrete2 as PayPalStrategy

    User-&gt;&gt;Context: selectPaymentMethod(method)
    Context-&gt;&gt;Strategy: setStrategy(concrete)
    User-&gt;&gt;Context: pay(amount)
    Context-&gt;&gt;Strategy: strategy.pay(amount)
</pre><ul><li><code>CheckoutService</code> (Context) 가 런타임에 <code>PaymentStrategy</code> 구현체 (<code>CreditCardStrategy</code>, <code>PayPalStrategy</code>) 를 주입받음.</li><li><code>pay()</code> 호출 시 선택된 알고리즘이 실행.</li></ul><p><strong>유무에 따른 차이</strong></p><table><thead><tr><th>조건</th><th>Strategy 미사용</th><th>Strategy 사용</th></tr></thead><tbody><tr><td>코드 복잡도</td><td>pay() 내부 if/else 분기 다수</td><td>결제방식별 클래스 분리로 단순화</td></tr><tr><td>확장성</td><td>새로운 결제 추가 시 pay() 수정</td><td>전략 클래스 추가 + Context 에서 등록</td></tr><tr><td>테스트</td><td>결제 방식 테스트 함께 복잡</td><td>각 전략 단위 테스트 용이</td></tr></tbody></table><h4 id=사례-2-채팅-애플리케이션>사례 2: 채팅 애플리케이션<a hidden class=anchor aria-hidden=true href=#사례-2-채팅-애플리케이션>#</a></h4><p><strong>시나리오</strong>: 채팅 애플리케이션에서 사용자 간의 메시지 전달을 관리하는 시스템을 설계할 때, Mediator 패턴을 활용하여 사용자 객체 간의 직접적인 상호작용을 피하고 중앙 집중화된 메시지 중개자를 통해 메시지를 전달한다.</p><p><strong>시스템 구성</strong>:</p><ul><li><strong>사용자 객체</strong>: 메시지를 보내고 받을 수 있는 객체</li><li><strong>메시지 중개자</strong>: 사용자 객체 간의 메시지 전달을 관리하는 중앙 객체</li></ul><p><strong>Workflow</strong>:</p><ol><li>사용자 A 가 메시지를 보낸다.</li><li>메시지 중개자가 메시지를 받아 사용자 B 에게 전달한다.</li><li>사용자 B 가 메시지를 수신한다.</li></ol><p><strong>역할</strong>:</p><ul><li>사용자 객체: 메시지의 송수신을 담당한다.</li><li>메시지 중개자: 메시지의 전달을 중앙에서 관리한다.</li></ul><h4 id=사례-3-이벤트-알림-시스템>사례 3: 이벤트 알림 시스템<a hidden class=anchor aria-hidden=true href=#사례-3-이벤트-알림-시스템>#</a></h4><p>Observer 패턴 적용 사례: 이벤트 알림 시스템</p><p><strong>시스템 구성:</strong></p><ul><li>Subject(주체) → Observer(관찰자)</li><li>Subject 는 상태 변화 시 Observer 에게 알림</li></ul><p><strong>Workflow:</strong></p><ol><li>Subject 상태 변경</li><li>Subject 가 Observer 에게 알림</li><li>Observer 가 상태 반영</li></ol><p><strong>역할:</strong></p><ul><li>상태 변화를 실시간으로 반영하여, 객체 간 결합도를 낮추고 유연성을 높입니다.</li></ul><p><strong>차이점:</strong></p><ul><li>패턴 미적용 시 직접 상태 동기화 필요</li><li>패턴 적용 시 자동 동기화 및 유연성 향상</li></ul><h4 id=사례-4-실시간-알림-시스템에-observer-패턴-활용>사례 4: 실시간 알림 시스템에 Observer 패턴 활용<a hidden class=anchor aria-hidden=true href=#사례-4-실시간-알림-시스템에-observer-패턴-활용>#</a></h4><p><strong>시나리오:</strong> SNS 앱에서 새로운 댓글이 등록될 때마다 구독자들에게 실시간 알림 발송 필요</p><p><strong>시스템 구성:</strong></p><ul><li>Subject: 게시글, Observer: 사용자 알림 서비스</li><li>Subject 는 Observer 등록/제거 기능 제공, 상태 변동시 일괄 통지</li></ul><p><strong>워크플로우:</strong></p><ol><li>사용자가 게시글을 구독 (Observer 등록)</li><li>댓글 등록 시 게시글 상태 변경</li><li>게시글이 Observer(알림 서비스) 에 이벤트 통지</li><li>알림 서비스가 구독 사용자에게 실시간 알림 전송</li></ol><p><strong>역할:</strong></p><ul><li>게시글: 상태/이벤트 발생에 대한 중심 관리</li><li>알림 서비스: 사용자별 알림 분배</li></ul><h4 id=사례-5-전자상거래-주문-처리-시스템>사례 5: 전자상거래 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#사례-5-전자상거래-주문-처리-시스템>#</a></h4><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    subgraph &#34;Order Processing System&#34;
        A[Order Controller] --&gt; B[Command Processor]
        B --&gt; C[Validation Chain]
        B --&gt; D[Payment Strategy]
        B --&gt; E[Inventory Observer]
        B --&gt; F[Notification Observer]
        
        C --&gt; C1[Stock Validator]
        C --&gt; C2[Payment Validator]
        C --&gt; C3[Address Validator]
        
        D --&gt; D1[Credit Card Strategy]
        D --&gt; D2[PayPal Strategy]
        D --&gt; D3[Bank Transfer Strategy]
        
        E --&gt; E1[Inventory Service]
        F --&gt; F1[Email Service]
        F --&gt; F2[SMS Service]
    end
</pre><p><strong>Workflow</strong>:</p><ol><li><strong>주문 접수</strong>: Command 패턴으로 주문 요청을 객체화</li><li><strong>유효성 검증</strong>: Chain of Responsibility 로 다단계 검증</li><li><strong>결제 처리</strong>: Strategy 패턴으로 결제 방식 선택</li><li><strong>재고 업데이트</strong>: Observer 패턴으로 재고 시스템에 통지</li><li><strong>알림 발송</strong>: Observer 패턴으로 고객 알림 서비스 작동</li></ol><p><strong>Behavioral Pattern 의 역할</strong>:</p><ul><li><strong>Command</strong>: 주문 요청의 캡슐화 및 실행 취소 지원</li><li><strong>Chain of Responsibility</strong>: 유연한 검증 단계 추가/제거</li><li><strong>Strategy</strong>: 다양한 결제 방식의 동적 선택</li><li><strong>Observer</strong>: 주문 상태 변화에 따른 자동 업데이트</li></ul><p><strong>패턴 유무에 따른 차이점</strong>:</p><ul><li><strong>패턴 적용 시</strong>: 각 구성요소가 독립적으로 변경 가능, 새로운 결제 방식이나 검증 단계 쉽게 추가</li><li><strong>패턴 미적용 시</strong>: 모든 로직이 하나의 클래스에 집중되어 변경 시 전체 시스템 영향, 테스트 어려움</li></ul><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th></tr></thead><tbody><tr><td><strong>패턴 선택</strong></td><td>패턴 적합성</td><td>실제 문제 유형에 적합한 패턴인지 여부 판단</td><td>문제 분석 후 적절한 패턴 선택, 오·과용 방지</td></tr><tr><td></td><td>남용/오용 경계</td><td>지나치게 많은 패턴 적용 시 복잡도 증가 가능</td><td>적용 목적과 장단점 명확히 인지 및 기록</td></tr><tr><td><strong>설계 단계</strong></td><td>요구사항 변화 대응성</td><td>요구사항 변경 가능성에 유연하게 대응할 수 있는 구조 설계</td><td>단순한 구조에서 시작해 점진적 적용, 인터페이스 기반 설계</td></tr><tr><td></td><td>인터페이스 명확성</td><td>각 역할 객체의 책임과 API 명확화</td><td>인터페이스 분리 원칙 (SRP), 설계 시점에 역할 명확히 정의</td></tr><tr><td></td><td>결합도 최소화</td><td>객체 간 의존도와 결합도는 낮출수록 유리</td><td>의존성 주입 (DI), 인터페이스 중심 설계 적용</td></tr><tr><td></td><td>순환 참조 방지</td><td>다중 객체 간 상호참조로 인한 런타임 오류 방지</td><td>설계 리뷰, 의존성 시각화 및 순환참조 검증 툴 활용</td></tr><tr><td></td><td>과도한 추상화</td><td>불필요한 추상화는 유지보수성과 성능 저하 유발</td><td>핵심 기능 위주 구성, 사용성 중심 설계</td></tr><tr><td><strong>구현 단계</strong></td><td>흐름 가시성</td><td>로직 흐름과 책임 분리가 불명확할 경우 유지보수 어려움</td><td>로깅, 시각화 도구, 메시지 흐름 주석 삽입</td></tr><tr><td></td><td>경로 제어 복잡도</td><td>복잡한 조건 분기, 예외 흐름이 많은 경우 로직 불명확</td><td>명확한 종료 조건 정의, 상태 기반 분기 도입</td></tr><tr><td></td><td>클래스 수 증가</td><td>단계마다 새로운 클래스가 필요해지며 복잡도 상승 가능</td><td>유틸리티 기반 처리 병행, 래퍼 또는 필터 방식 도입</td></tr><tr><td></td><td>직접 구현 vs 추상화</td><td>성능이 중요한 부분은 추상 계층보다 직접 구현이 유리</td><td>크리티컬 영역은 최소 간접 호출 설계, 병행 사용 고려</td></tr><tr><td><strong>테스트 단계</strong></td><td>단위 테스트 강화</td><td>객체 간 역할 분리로 단위 테스트가 가능해야 함</td><td>Mock, Stub 객체 활용, 자동화 테스트 구축</td></tr><tr><td></td><td>통합 테스트 복잡성</td><td>여러 패턴 간 협력 시 통합 테스트 난이도 증가 가능</td><td>테스트 레벨 분리, 각 패턴 조합별 시나리오 정의 및 문서화</td></tr><tr><td></td><td>변경 영향 범위 파악</td><td>구조 변경 시 영향 받는 모듈을 명확히 파악해야 함</td><td>커버리지 도구 및 통합 테스트 주기적 실행</td></tr><tr><td><strong>유지보수 단계</strong></td><td>문서화 및 가독성 유지</td><td>설계 의도와 구현 구조를 후속 개발자가 이해 가능해야 함</td><td>주석, UML, 플로우 차트 등 병행 문서화</td></tr><tr><td></td><td>인터페이스 일관성 유지</td><td>역할 또는 구성 요소가 변경되어도 외부 의존성 최소화</td><td>버전 관리, 변경 이력 관리, 하위 호환성 고려</td></tr><tr><td></td><td>클래스 의도 주석화</td><td>패턴을 적용한 목적이 코드 상에 드러나야 함</td><td>핵심 클래스에 설계 의도 주석 삽입 (<code>@Pattern</code>, <code>@Role</code> 등)</td></tr><tr><td><strong>테스트 전략</strong></td><td>테스트 가능성 확보</td><td>유닛별 테스트가 가능하도록 의존성과 흐름을 분리해야 함</td><td>전략 패턴, 의존성 주입, Facade 결합 등 테스트 중심 설계 적용</td></tr><tr><td><strong>문서화/관리</strong></td><td>설계 문서화</td><td>구조와 흐름, 의도를 명확히 기록하여 개발자 간 공유</td><td>설계 시점에 다이어그램 (UML, 시퀀스, 컴포넌트 등) 작성</td></tr><tr><td></td><td>코드 - 문서 일치</td><td>문서화 내용과 실제 구현 간 불일치 방지</td><td>정기적 리뷰 및 문서 자동 생성 도구 활용 (Swagger, TypeDoc 등)</td></tr></tbody></table><h4 id=테스트-전략>테스트 전략<a hidden class=anchor aria-hidden=true href=#테스트-전략>#</a></h4><ol><li><p><strong>단위 테스트 전략</strong></p><ul><li>각 패턴 구성요소의 독립적 테스트</li><li>Mock 객체를 활용한 의존성 격리</li><li>경계값 및 예외 상황 테스트</li></ul></li><li><p><strong>통합 테스트 전략</strong></p><ul><li>패턴 구성요소 간 상호작용 검증</li><li>엔드투엔드 시나리오 테스트</li><li>성능 및 동시성 테스트</li></ul></li></ol><h4 id=리팩토링-전략>리팩토링 전략<a hidden class=anchor aria-hidden=true href=#리팩토링-전략>#</a></h4><ol><li><p><strong>점진적 리팩토링</strong></p><ul><li>기존 코드를 단계적으로 패턴 구조로 변환</li><li>각 단계별 테스트 수행으로 안정성 확보</li></ul></li><li><p><strong>패턴 추출</strong></p><ul><li>반복되는 코드 패턴을 추상화</li><li>공통 인터페이스 도출 및 구현체 분리</li></ul></li></ol><h4 id=활용-시-흔한-실수>활용 시 흔한 실수<a hidden class=anchor aria-hidden=true href=#활용-시-흔한-실수>#</a></h4><ol><li><p><strong>불필요한 패턴 적용</strong></p><ul><li>단순한 문제에 복잡한 패턴 사용</li><li>해결책: 요구사항 복잡도에 맞는 적절한 패턴 선택</li></ul></li><li><p><strong>인터페이스 설계 오류</strong></p><ul><li>너무 크거나 작은 인터페이스 정의</li><li>해결책: 인터페이스 분리 원칙 준수</li></ul></li><li><p><strong>생명주기 관리 소홀</strong></p><ul><li>Observer 등록 해제 누락</li><li>해결책: RAII 패턴이나 자동 관리 메커니즘 활용</li></ul></li></ol><h4 id=비동기멀티스레드-환경에서의-behavioral-pattern-구현-고려사항>비동기/멀티스레드 환경에서의 Behavioral Pattern 구현 고려사항<a hidden class=anchor aria-hidden=true href=#비동기멀티스레드-환경에서의-behavioral-pattern-구현-고려사항>#</a></h4><h5 id=공통-고려사항>공통 고려사항<a hidden class=anchor aria-hidden=true href=#공통-고려사항>#</a></h5><table><thead><tr><th>항목</th><th>고려사항</th><th>설명</th><th>해결 전략</th></tr></thead><tbody><tr><td>상태 공유</td><td>공유 객체 접근 충돌</td><td>Observer 목록, 상태 객체 등</td><td>Lock, Copy-on-Write, Concurrent Queue</td></tr><tr><td>순서 보장</td><td>메시지 순서, 상태 전이 순서</td><td>notify 순서, 상태 변경 타이밍</td><td>메시지 큐 (RabbitMQ 등), Ordered Dispatcher</td></tr><tr><td>실행 컨텍스트</td><td>스레드 간 전략 객체 공유</td><td>하나의 전략이 여러 Context 에서 사용될 수 있음</td><td>Thread-Local Storage or Stateless 설계</td></tr><tr><td>중단 처리</td><td>비동기 Task 취소 및 오류</td><td>Strategy 실행 중 예외 발생</td><td>Future, Timeout 설정, 에러 전파 체계</td></tr><tr><td>동기화 비용</td><td>락 과다 사용으로 성능 저하</td><td>과도한 동기화로 성능 저하</td><td>락 최소화, CAS (Compare-and-Swap) 알고리즘 활용</td></tr></tbody></table><h3 id=성능-최적화-고려사항>성능 최적화 고려사항<a hidden class=anchor aria-hidden=true href=#성능-최적화-고려사항>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th></tr></thead><tbody><tr><td><strong>객체 관리 최적화</strong></td><td>객체 수 증가</td><td>패턴 적용으로 클래스/객체 수 증가 가능</td><td>객체 풀링, 불필요 객체 생성을 지양, Flyweight 패턴 병용</td></tr><tr><td></td><td>동일 객체 중복 생성</td><td>동일 행위/전략 객체를 매번 새로 생성하는 경우 메모리 낭비</td><td>행위 객체 캐싱, 싱글턴 또는 정적 객체 활용</td></tr><tr><td></td><td>객체 생명주기 관리</td><td>생성 - 삭제 반복으로 인한 GC 부하</td><td>지연 초기화, 참조 해제 명확히, 약한 참조 (Weak Reference) 사용</td></tr><tr><td><strong>행위 처리 최적화</strong></td><td>핸들러 실행 비용</td><td>Chain of Responsibility 등에서 체인 길이에 따라 실행 지연 가능</td><td>체인 분리, 병렬 처리 고려, 전략적 분기 설정</td></tr><tr><td></td><td>이벤트 처리 부하</td><td>Observer/Event Dispatcher 등에서 이벤트 폭주 발생 가능</td><td>큐 기반 비동기 처리, 이벤트 버퍼링 및 배치 처리</td></tr><tr><td></td><td>런타임 위임 비용</td><td>Strategy, Command 패턴에서 위임 호출에 따른 성능 저하</td><td>빈번한 호출 시 인라인 처리 또는 최적화된 인터페이스 사용</td></tr><tr><td><strong>상태 관리 최적화</strong></td><td>상태 메모리 사용량</td><td>State, Memento 등에서 불필요한 상태 저장으로 메모리 증가</td><td>최소 상태 캡처, 조건 기반 상태 저장, 상태 제거 시점 명확히 설정</td></tr><tr><td></td><td>공유 상태 동시 접근</td><td>상태 객체 공유 시 Race Condition 발생 가능</td><td>무상태 (stateless) 설계, 락 최소화, 원자성 확보</td></tr><tr><td><strong>동시성 및 병렬성</strong></td><td>다수 옵저버/핸들러 동시 실행</td><td>이벤트 리스너가 다수일 때 동시성 문제 발생 가능</td><td>스레드풀, 이벤트 루프, Actor 모델 도입</td></tr><tr><td></td><td>락 경합/데드락 위험</td><td>공유 리소스 접근 시 락 경합 및 교착 상태 발생 위험</td><td>Lock-free 자료구조 사용, 명확한 락 범위 설정, 비동기 처리</td></tr><tr><td><strong>메모리 및 네트워크</strong></td><td>메모리 누수</td><td>Observer 등에서 참조가 끊기지 않으면 GC 불가</td><td>약한 참조 (WeakMap, WeakReference), 수명 주기와 해제 타이밍 명시</td></tr><tr><td></td><td>원격 호출 비용</td><td>프록시/Facade 패턴 등에서 네트워크 요청 증가 가능</td><td>호출 최소화, 로컬 캐시 적용, 지연 로딩 도입</td></tr><tr><td><strong>디버깅/유지보수성</strong></td><td>상호작용 디버깅 어려움</td><td>패턴 간 위임 구조로 흐름 파악이 어려워 디버깅 복잡도 증가</td><td>AOP 기반 로깅, 트레이싱 도구 활용 (예: OpenTelemetry)</td></tr><tr><td></td><td>클래스 폭발/복잡성 증가</td><td>패턴 조합 시 클래스 수가 많아져 가독성과 관리가 어려워짐</td><td>패턴 최소화 원칙 적용, 공통 추상화 구조 사용, 리팩토링 주기적 수행</td></tr><tr><td><strong>패턴 적용 판단</strong></td><td>과도한 패턴 사용</td><td>실제 필요보다 많은 패턴 적용으로 오히려 복잡성 및 오버헤드 증가</td><td><strong>&ldquo;YAGNI(You Aren&rsquo;t Gonna Need It)&rdquo; 원칙 적용</strong>, 설계 시점에서 최소한의 도입 고려</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>패턴 구조 및 역할</strong></td><td>객체 협력</td><td>느슨한 결합</td><td>객체 간 직접 참조를 줄여 유연성과 재사용성을 확보함</td></tr><tr><td></td><td>책임 분리</td><td>역할 명확화</td><td>책임 단위의 분리로 유지보수성과 확장성 향상</td></tr><tr><td><strong>패턴 종류 및 특성</strong></td><td>대표 Behavioral 패턴</td><td>Observer, Strategy, Command 등</td><td>다양한 객체 간 협력 및 행위 분산을 실현하는 구조</td></tr><tr><td></td><td>이벤트 기반 패턴</td><td>Publish-Subscribe, Event Dispatcher</td><td>비동기/다대다 구조의 이벤트 흐름 구현</td></tr><tr><td><strong>실무 적용</strong></td><td>이벤트 시스템</td><td>Observer</td><td>실시간 알림, UI 반응성, 상태 변화 전파 구조 설계</td></tr><tr><td></td><td>명령/워크플로우 처리</td><td>Command, Chain of Responsibility</td><td>명령 캡슐화, 책임 체인 구조로 유연한 요청 처리</td></tr><tr><td></td><td>테스트 전략</td><td>Mockable 구조</td><td>인터페이스 분리로 테스트 시 독립적 유닛 테스트 가능</td></tr><tr><td><strong>설계 원칙 대응</strong></td><td>커플링 감소</td><td>책임 위임, 인터페이스 활용</td><td>객체 간 직접 호출 대신 메시지 기반 협력 도입</td></tr><tr><td></td><td>런타임 유연성</td><td>Strategy, Command</td><td>런타임에 행동 (알고리즘, 명령) 을 자유롭게 교체 가능</td></tr><tr><td></td><td>SOLID 원칙 적용</td><td>DIP, OCP, SRP</td><td>행동 캡슐화를 통한 의존 역전, 개방/폐쇄 원칙 구현</td></tr><tr><td><strong>현대 기술 트렌드</strong></td><td>함수형 프로그래밍</td><td>고차 함수 + Strategy</td><td>전략을 함수 객체 (First-Class Function) 로 구현 가능</td></tr><tr><td></td><td>리액티브 프로그래밍</td><td>RxJS, ReactiveX, Reactor 등</td><td>Observer 패턴 기반 비동기 데이터 흐름 모델 구현 가능</td></tr><tr><td></td><td>클라우드 네이티브 아키텍처</td><td>Event Sourcing, Saga Pattern</td><td>Command/Event 기반 구조로 마이크로서비스 간 분산 처리 구현</td></tr><tr><td></td><td>AI/ML 파이프라인</td><td>Chain of Responsibility</td><td>모델 파이프라인 각 처리 단계를 체인 구조로 구성 가능</td></tr><tr><td></td><td>AI/ML 전략</td><td>A/B 테스트 + Strategy</td><td>모델 전략 교체를 유연하게 적용 가능한 구조</td></tr><tr><td><strong>교육 및 품질 관점</strong></td><td>팀 내 패턴 교육</td><td>학습 및 온보딩</td><td>신입 개발자에게 디자인 패턴 구조 및 협력 원리 교육에 적합</td></tr><tr><td></td><td>유지보수/확장성</td><td>패턴 적용 효과</td><td>구조화된 코드 설계로 변경에 강하고 확장에 용이한 코드 구현 가능</td></tr><tr><td></td><td>코드 품질 향상</td><td>객체 간 역할 분리</td><td>단일 책임 부여 및 재사용 가능한 구조 유도</td></tr><tr><td><strong>복합 적용 전략</strong></td><td>하이브리드 패턴 구조</td><td>Composite + Observer 등</td><td>구조/행위 패턴을 조합하여 유연성과 기능성을 동시에 확보</td></tr><tr><td></td><td>Reactive + EDA</td><td>이벤트 흐름 중심 복합 아키텍처</td><td>Observer/Event Dispatcher 패턴을 활용한 모듈 간 decoupling 구성</td></tr></tbody></table><h3 id=반드시-학습해야할-내용>반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#반드시-학습해야할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>항목</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>GoF 패턴 개요</strong></td><td>Behavioral Pattern</td><td>종류 및 구조</td><td>총 11 가지 행동 패턴의 목적, 구조, 적용 방식 포함</td></tr><tr><td><strong>핵심 패턴</strong></td><td>Observer</td><td>상태 변화 알림</td><td>주체 (Subject) 의 상태 변경 시 관찰자 (Observer) 에게 자동으로 알림 전파</td></tr><tr><td></td><td>Strategy</td><td>알고리즘 교체</td><td>런타임에 알고리즘을 자유롭게 교체 가능하도록 캡슐화</td></tr><tr><td></td><td>Command</td><td>요청 캡슐화</td><td>명령을 객체로 추상화하여 요청 실행을 유연하게 제어</td></tr><tr><td></td><td>Chain of Responsibility</td><td>책임 분산 구조</td><td>요청 처리 객체를 체인으로 연결하여 처리 책임을 동적으로 전가</td></tr><tr><td></td><td>Interpreter</td><td>언어 해석</td><td>도메인 언어의 문법을 표현하고 해석기 (Context) 를 통해 의미 분석</td></tr><tr><td></td><td>Iterator</td><td>순회 구조</td><td>컬렉션의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있도록 구현</td></tr><tr><td></td><td>Template Method</td><td>알고리즘 템플릿</td><td>알고리즘의 구조는 상위 클래스가 정의하고, 세부 구현은 하위 클래스가 담당</td></tr><tr><td></td><td>Visitor</td><td>기능 확장 구조</td><td>객체 구조는 고정한 채, 새로운 연산을 추가할 수 있게 하는 구조</td></tr><tr><td><strong>객체지향 설계 원칙</strong></td><td>SOLID 원칙</td><td>OCP, SRP, DIP 등</td><td>Behavioral Pattern 은 개방/폐쇄 원칙 (OCP), 의존성 역전 원칙 (DIP) 등 설계 원칙을 구현하는 데 핵심 역할</td></tr><tr><td></td><td>Loose Coupling</td><td>결합도 최소화</td><td>패턴을 통해 객체 간 직접 의존을 줄이고 변경에 유연하게 대응</td></tr><tr><td></td><td>캡슐화/행위 위임</td><td>인터페이스 추상화</td><td>행위의 분리 및 재사용성을 높이기 위한 위임, 인터페이스 기반 설계 구현</td></tr><tr><td><strong>구현 기술</strong></td><td>델리게이션 (Delegation)</td><td>함수형 콜백, 델리게이터 구조</td><td>동적 동작 위임을 통한 유연한 런타임 행동 제어</td></tr><tr><td></td><td>Event Dispatcher</td><td>비동기 이벤트 분배 구조</td><td>이벤트 기반 시스템에서 비차단 (Non-blocking) 구조 구현</td></tr><tr><td></td><td>멀티스레딩/동시성</td><td>스레드 안전 구현</td><td>스레드 안전한 Behavioral Pattern (예: Command + Queue) 구성</td></tr><tr><td></td><td>메모리 관리</td><td>스마트 포인터/GC 대응 구조</td><td>명령 및 상태 객체의 수명 관리를 위한 메모리 최적화 전략</td></tr><tr><td><strong>실무 적용</strong></td><td>이벤트/명령 시스템</td><td>메시지 기반 워크플로우, 이벤트 버스</td><td>Command, Observer 등의 패턴을 이벤트 시스템에 적용</td></tr><tr><td></td><td>테스트 자동화</td><td>Mocking/Stub 구성</td><td>이벤트 기반 행동을 테스트하기 위한 목 객체 설계 전략</td></tr><tr><td></td><td>프레임워크 적용</td><td>Spring,.NET, Express</td><td>주요 프레임워크 내 Behavioral 패턴의 실제 구현 구조 분석</td></tr><tr><td></td><td>아키텍처 적용</td><td>MVC, MVP, MVVM</td><td>각 계층 간 책임 분리를 위한 Behavioral 패턴 적용 사례</td></tr><tr><td></td><td>마이크로서비스</td><td>메시지 브로커, API 게이트웨이</td><td>서비스 간 decoupling 을 위한 패턴 활용 (예: Command + Queue)</td></tr><tr><td><strong>심화 학습 영역</strong></td><td>패턴별 실전 코드</td><td>구현 예제 + 테스트 코드</td><td>각 행동 패턴을 독립 또는 조합하여 실전 예제와 테스트 작성</td></tr><tr><td></td><td>패턴 조합 및 응용</td><td>하이브리드 패턴</td><td>Strategy + Command, Observer + Mediator 등 복합 구조 적용 분석</td></tr><tr><td></td><td>리팩토링 전략</td><td>패턴 도입 전후 비교</td><td>코드 리팩토링을 통해 Behavioral 패턴 도입 전후의 구조 변화 분석</td></tr><tr><td><strong>연관 이론/개념</strong></td><td>이벤트 기반 아키텍처</td><td>EDA, Event Sourcing, CQRS</td><td>행동 패턴이 자연스럽게 통합되는 아키텍처 구조 학습</td></tr><tr><td></td><td>책임 분산</td><td>역할 기반 객체 협력 구조</td><td>객체 간 책임 분리를 통한 협력 구조 설계 분석</td></tr><tr><td></td><td>함수형 프로그래밍 + 패턴</td><td>FP 에서의 행동 패턴 응용</td><td>고차 함수, 콜백 기반의 Strategy, Command 구현 예</td></tr><tr><td></td><td>패턴 확장성</td><td>Composite/Hybrid Pattern</td><td>구조 + 행위 패턴 결합을 통한 설계 확장 전략</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>카테고리</strong></th><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>디자인 패턴</strong></td><td>GoF (Gang of Four)</td><td>『Design Patterns』의 저자 4 인, 디자인 패턴의 창시자들</td></tr><tr><td></td><td>Behavioral Pattern</td><td>객체 간 상호작용과 책임 분배를 다루는 패턴군</td></tr><tr><td></td><td>Strategy</td><td>알고리즘을 캡슐화하여 런타임에 교체 가능한 행동 패턴</td></tr><tr><td></td><td>Observer</td><td>상태 변화 발생 시 등록된 객체들에 알림을 전달하는 행동 패턴</td></tr><tr><td></td><td>Command</td><td>요청을 객체화하여 실행 로직을 캡슐화하는 행동 패턴</td></tr><tr><td></td><td>Chain of Responsibility</td><td>요청을 순차적으로 처리할 수 있는 핸들러 체인을 구성하는 행동 패턴</td></tr><tr><td></td><td>Mediator</td><td>객체 간 직접 통신 대신 중재자 객체를 통해 간접 통신하게 하는 행동 패턴</td></tr><tr><td><strong>설계 원칙</strong></td><td>OCP (Open-Closed Principle)</td><td>확장에는 열려 있고, 변경에는 닫혀 있어야 한다는 원칙</td></tr><tr><td></td><td>SRP (Single Responsibility Principle)</td><td>클래스는 하나의 책임만 가져야 한다는 원칙</td></tr><tr><td></td><td>Loose Coupling</td><td>객체 간 결합도를 낮추는 설계 원칙, 변경에 유연하게 대응 가능</td></tr><tr><td></td><td>Decoupling</td><td>시스템 구성 요소 간의 의존성을 낮추어 독립성 향상을 지향하는 설계 원칙</td></tr><tr><td><strong>패턴 구성 요소</strong></td><td>Context</td><td>전략 또는 상태 객체를 포함하여 실행 흐름을 제어하는 클래스</td></tr><tr><td></td><td>Strategy (전략 객체)</td><td>구체적인 알고리즘 또는 행위를 담고 있는 객체</td></tr><tr><td></td><td>Subject</td><td>상태 변화를 관리하며 Observer 들에게 알림을 전파하는 객체</td></tr><tr><td></td><td>Observer (관찰자)</td><td>Subject 의 상태 변화를 감시하고 반응하는 객체</td></tr><tr><td></td><td>Handler</td><td>Chain of Responsibility 에서 요청을 처리하거나 전달하는 객체</td></tr><tr><td><strong>구현 기법</strong></td><td>Delegation (위임)</td><td>작업을 다른 객체에 위임하여 유연성과 재사용성을 높이는 구조</td></tr><tr><td></td><td>Mediation (중재)</td><td>직접 연결된 객체들 대신 중재자를 통해 간접적으로 메시지를 주고받는 구조</td></tr><tr><td></td><td>Publish-Subscribe (발행 - 구독)</td><td>이벤트 발행자와 구독자가 느슨하게 결합되어 있는 비동기 이벤트 처리 구조</td></tr><tr><td><strong>추상 개념</strong></td><td>캡슐화 (Encapsulation)</td><td>데이터와 관련 기능을 하나의 단위로 묶고 외부로부터 은닉하는 객체지향 원칙</td></tr><tr><td></td><td>책임 분산 (Responsibility Distribution)</td><td>하나의 객체에 과도한 책임이 몰리지 않도록 여러 객체에 기능을 분산하는 방식</td></tr><tr><td><strong>기타 개념</strong></td><td>객체 간 상호작용</td><td>객체들이 메시지를 주고받으며 협력하여 기능을 수행하는 구조</td></tr><tr><td></td><td>캡슐화된 요청 (Command 객체)</td><td>요청 정보를 객체로 추상화하여 다양한 실행 전략을 유연하게 처리</td></tr><tr><td></td><td>리스너 (Listener)</td><td>이벤트를 감지하고 응답하는 구조적 역할 객체</td></tr><tr><td><strong>실무 개념</strong></td><td>CQRS (Command Query Responsibility Segregation)</td><td>커맨드와 조회 작업을 분리하여 확장성과 성능을 개선하는 설계 원칙</td></tr><tr><td></td><td>Ubiquity (만연성)</td><td>특정 개념 또는 패턴이 다양한 분야에서 널리 사용되는 상태</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://dev.to/kwnaidoo/facade-design-pattern-what-is-it-and-why-is-it-useful-32gn>Facade design pattern. What is it and why is it useful? - Dev.to</a></li><li><a href=https://en.wikipedia.org/wiki/Design_Patterns>Design Patterns - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Design_Patterns>Design Patterns: Elements of Reusable Object-Oriented Software (GoF)</a></li><li><a href=https://refactoring.guru/design-patterns/catalog>The Catalog of Design Patterns - Refactoring.Guru</a></li><li><a href=https://refactoring.guru/design-patterns/structural-patterns>Structural Design Patterns - Refactoring.Guru</a></li><li><a href=https://refactoring.guru/design-patterns/facade>Facade Pattern - Refactoring.Guru</a></li><li><a href=https://www.geeksforgeeks.org/system-design/gang-of-four-gof-design-patterns/>Gang of Four (GoF) Design Patterns - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/structural-design-patterns-in-java/>Structural Design Patterns in Java - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/facade-design-pattern-in-java/>Facade Design Pattern in Java - GeeksforGeeks</a></li><li><a href=https://medium.com/@EngineeringVision/understanding-gang-of-four-gof-design-patterns-efe4ef0bf18e>Understanding Gang of Four (GoF) Design Patterns - Medium</a></li><li><a href=https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns>GOF Design Patterns Overview - DigitalOcean</a></li><li><a href=https://www.cs.cmu.edu/~charlie/courses/15-214/2016-spring/slides/24%20-%20All%20the%20GoF%20Patterns.pdf>All the GoF Patterns - CMU School of Computer Science (PDF)</a></li><li><a href=https://sourcemaking.com/design_patterns/facade>Design Patterns and Refactoring - Sourcemaking</a></li><li><a href=https://realpython.com/facade-design-pattern-python/>How to Implement the Facade Pattern in Python - Real Python</a></li><li><a href=https://www.codecademy.com/resources/blog/software-design-patterns-explained/>Design Patterns Explained – Codecademy Blog</a></li><li><a href=https://www.baeldung.com/java-facade-pattern>Facade Pattern in Software Design - Baeldung</a></li><li><a href=https://betterprogramming.pub/typescript-design-patterns-the-facade-pattern-86f812cba5bb>The Facade Pattern in TypeScript - Medium</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern vs Observer Pattern</h2></header><div class=entry-content><p>Mediator Pattern Vs Observer Pattern Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.
Mediator 패턴:
객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴 객체 간 결합도를 낮추고 상호작용을 중앙 집중화함 복잡한 다대다 관계를 단순화하는 데 유용 Observer 패턴:
객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴 주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함 상태 변경에 대한 효율적인 알림 메커니즘을 제공 Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 객체 간의 결합도를 줄이고 상호작용 로직을 집중시키는 데 적합하다. Observer 패턴은 상태 변화에 따른 자동 알림 및 실시간 동기화를 구현할 때 적합하며, 이벤트 기반 시스템에 자주 사용된다. 두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, Mediator는 상호작용을 캡슐화하고 Observer는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-24 00:49:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern vs Observer Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/mediator-pattern-vs-observer-pattern/></a></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>