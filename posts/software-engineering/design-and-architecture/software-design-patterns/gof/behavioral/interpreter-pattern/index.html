<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Interpreter Pattern | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Design-Patterns,GoF,Behavioral,Interpreter-Pattern"><meta name=description content="Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Interpreter Pattern"><meta property="og:description" content="Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Interpreter Pattern"><meta name=twitter:description content="Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":5,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/"},{"@type":"ListItem","position":6,"name":"Behavioral Design Patterns","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/"},{"@type":"ListItem","position":7,"name":"Interpreter Pattern","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/interpreter-pattern/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/>GoF</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/gof/behavioral/>Behavioral Design Patterns</a></div><h1>Interpreter Pattern</h1><div class=post-description>Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.</div></header><div class=post-content><h2 id=interpreter-pattern>Interpreter Pattern<a hidden class=anchor aria-hidden=true href=#interpreter-pattern>#</a></h2><p>Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.<br>이 패턴은 주로 간단한 언어나 표현식을 해석해야 할 때 사용된다.</p><p>Interpreter 패턴은 SQL 파서, 정규 표현식 엔진, 프로그래밍 언어 인터프리터 등 다양한 분야에서 활용된다. 하지만 복잡한 문법을 다룰 때는 파서 생성기 등 다른 도구를 고려하는 것이 좋다.</p><h3 id=interpreter-패턴의-주요-특징>Interpreter 패턴의 주요 특징<a hidden class=anchor aria-hidden=true href=#interpreter-패턴의-주요-특징>#</a></h3><ol><li>문법 표현: 언어의 문법을 클래스 구조로 표현한다.</li><li>해석 메커니즘: 각 문법 규칙에 대한 해석 방법을 제공한다.</li><li>추상 구문 트리: 표현식을 계층적 구조로 표현한다.</li></ol><h3 id=interpreter-패턴의-구성-요소>Interpreter 패턴의 구성 요소<a hidden class=anchor aria-hidden=true href=#interpreter-패턴의-구성-요소>#</a></h3><ol><li>AbstractExpression: 모든 표현식 클래스가 구현해야 하는 인터페이스를 정의한다.</li><li>TerminalExpression: 더 이상 분해할 수 없는 기본 표현식을 나타낸다.</li><li>NonterminalExpression: 다른 표현식을 포함하는 복합 표현식을 나타낸다.</li><li>Context: 해석기가 해석해야 할 정보를 포함한다.</li><li>Client: 추상 구문 트리를 구성하고 해석을 요청한다.</li></ol><h3 id=interpreter-패턴의-장점>Interpreter 패턴의 장점<a hidden class=anchor aria-hidden=true href=#interpreter-패턴의-장점>#</a></h3><ol><li>문법 확장성: 새로운 표현식을 쉽게 추가할 수 있다.</li><li>문법 구현 용이성: 각 문법 규칙을 클래스로 표현하여 구현이 간단하다.</li><li>복잡한 문제 분해: 복잡한 문제를 작은 단위로 분해하여 해결할 수 있다.</li></ol><h3 id=interpreter-패턴의-단점>Interpreter 패턴의 단점<a hidden class=anchor aria-hidden=true href=#interpreter-패턴의-단점>#</a></h3><ol><li>복잡한 문법에 부적합: 문법이 복잡해질수록 클래스 계층 구조가 복잡해진다.</li><li>성능 문제: 대규모 문법 해석 시 성능이 저하될 수 있다.</li></ol><h3 id=interpreter-패턴-사용-예시>Interpreter 패턴 사용 예시<a hidden class=anchor aria-hidden=true href=#interpreter-패턴-사용-예시>#</a></h3><p>아래는 인터프리터 패턴을 활용하여 후위 표기법 (Postfix Notation) 을 해석하고 계산하는 예제이다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span><span class=lnt id=hl-0-35><a class=lnlinks href=#hl-0-35>35</a>
</span><span class=lnt id=hl-0-36><a class=lnlinks href=#hl-0-36>36</a>
</span><span class=lnt id=hl-0-37><a class=lnlinks href=#hl-0-37>37</a>
</span><span class=lnt id=hl-0-38><a class=lnlinks href=#hl-0-38>38</a>
</span><span class=lnt id=hl-0-39><a class=lnlinks href=#hl-0-39>39</a>
</span><span class=lnt id=hl-0-40><a class=lnlinks href=#hl-0-40>40</a>
</span><span class=lnt id=hl-0-41><a class=lnlinks href=#hl-0-41>41</a>
</span><span class=lnt id=hl-0-42><a class=lnlinks href=#hl-0-42>42</a>
</span><span class=lnt id=hl-0-43><a class=lnlinks href=#hl-0-43>43</a>
</span><span class=lnt id=hl-0-44><a class=lnlinks href=#hl-0-44>44</a>
</span><span class=lnt id=hl-0-45><a class=lnlinks href=#hl-0-45>45</a>
</span><span class=lnt id=hl-0-46><a class=lnlinks href=#hl-0-46>46</a>
</span><span class=lnt id=hl-0-47><a class=lnlinks href=#hl-0-47>47</a>
</span><span class=lnt id=hl-0-48><a class=lnlinks href=#hl-0-48>48</a>
</span><span class=lnt id=hl-0-49><a class=lnlinks href=#hl-0-49>49</a>
</span><span class=lnt id=hl-0-50><a class=lnlinks href=#hl-0-50>50</a>
</span><span class=lnt id=hl-0-51><a class=lnlinks href=#hl-0-51>51</a>
</span><span class=lnt id=hl-0-52><a class=lnlinks href=#hl-0-52>52</a>
</span><span class=lnt id=hl-0-53><a class=lnlinks href=#hl-0-53>53</a>
</span><span class=lnt id=hl-0-54><a class=lnlinks href=#hl-0-54>54</a>
</span><span class=lnt id=hl-0-55><a class=lnlinks href=#hl-0-55>55</a>
</span><span class=lnt id=hl-0-56><a class=lnlinks href=#hl-0-56>56</a>
</span><span class=lnt id=hl-0-57><a class=lnlinks href=#hl-0-57>57</a>
</span><span class=lnt id=hl-0-58><a class=lnlinks href=#hl-0-58>58</a>
</span><span class=lnt id=hl-0-59><a class=lnlinks href=#hl-0-59>59</a>
</span><span class=lnt id=hl-0-60><a class=lnlinks href=#hl-0-60>60</a>
</span><span class=lnt id=hl-0-61><a class=lnlinks href=#hl-0-61>61</a>
</span><span class=lnt id=hl-0-62><a class=lnlinks href=#hl-0-62>62</a>
</span><span class=lnt id=hl-0-63><a class=lnlinks href=#hl-0-63>63</a>
</span><span class=lnt id=hl-0-64><a class=lnlinks href=#hl-0-64>64</a>
</span><span class=lnt id=hl-0-65><a class=lnlinks href=#hl-0-65>65</a>
</span><span class=lnt id=hl-0-66><a class=lnlinks href=#hl-0-66>66</a>
</span><span class=lnt id=hl-0-67><a class=lnlinks href=#hl-0-67>67</a>
</span><span class=lnt id=hl-0-68><a class=lnlinks href=#hl-0-68>68</a>
</span><span class=lnt id=hl-0-69><a class=lnlinks href=#hl-0-69>69</a>
</span><span class=lnt id=hl-0-70><a class=lnlinks href=#hl-0-70>70</a>
</span><span class=lnt id=hl-0-71><a class=lnlinks href=#hl-0-71>71</a>
</span><span class=lnt id=hl-0-72><a class=lnlinks href=#hl-0-72>72</a>
</span><span class=lnt id=hl-0-73><a class=lnlinks href=#hl-0-73>73</a>
</span><span class=lnt id=hl-0-74><a class=lnlinks href=#hl-0-74>74</a>
</span><span class=lnt id=hl-0-75><a class=lnlinks href=#hl-0-75>75</a>
</span><span class=lnt id=hl-0-76><a class=lnlinks href=#hl-0-76>76</a>
</span><span class=lnt id=hl-0-77><a class=lnlinks href=#hl-0-77>77</a>
</span><span class=lnt id=hl-0-78><a class=lnlinks href=#hl-0-78>78</a>
</span><span class=lnt id=hl-0-79><a class=lnlinks href=#hl-0-79>79</a>
</span><span class=lnt id=hl-0-80><a class=lnlinks href=#hl-0-80>80</a>
</span><span class=lnt id=hl-0-81><a class=lnlinks href=#hl-0-81>81</a>
</span><span class=lnt id=hl-0-82><a class=lnlinks href=#hl-0-82>82</a>
</span><span class=lnt id=hl-0-83><a class=lnlinks href=#hl-0-83>83</a>
</span><span class=lnt id=hl-0-84><a class=lnlinks href=#hl-0-84>84</a>
</span><span class=lnt id=hl-0-85><a class=lnlinks href=#hl-0-85>85</a>
</span><span class=lnt id=hl-0-86><a class=lnlinks href=#hl-0-86>86</a>
</span><span class=lnt id=hl-0-87><a class=lnlinks href=#hl-0-87>87</a>
</span><span class=lnt id=hl-0-88><a class=lnlinks href=#hl-0-88>88</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.Stack</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Expression 인터페이스: 모든 표현식의 공통 인터페이스 정의 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>interface</span> <span class=nc>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Number 클래스: 숫자 표현식 (종료 표현식)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Number</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>number</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=nf>Number</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>number</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>this</span><span class=p>.</span><span class=na>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>number</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>return</span><span class=w> </span><span class=n>number</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Addition 클래스: 덧셈 표현식 (비종료 표현식) </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Addition</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>leftExpression</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>rightExpression</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=nf>Addition</span><span class=p>(</span><span class=n>Expression</span><span class=w> </span><span class=n>leftExpression</span><span class=p>,</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>rightExpression</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>this</span><span class=p>.</span><span class=na>leftExpression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>leftExpression</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>this</span><span class=p>.</span><span class=na>rightExpression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rightExpression</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>return</span><span class=w> </span><span class=n>leftExpression</span><span class=p>.</span><span class=na>interpret</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rightExpression</span><span class=p>.</span><span class=na>interpret</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Subtraction 클래스: 뺄셈 표현식 (비종료 표현식)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Subtraction</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>leftExpression</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>private</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>rightExpression</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=nf>Subtraction</span><span class=p>(</span><span class=n>Expression</span><span class=w> </span><span class=n>leftExpression</span><span class=p>,</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>rightExpression</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>this</span><span class=p>.</span><span class=na>leftExpression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>leftExpression</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>this</span><span class=p>.</span><span class=na>rightExpression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rightExpression</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>return</span><span class=w> </span><span class=n>leftExpression</span><span class=p>.</span><span class=na>interpret</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>rightExpression</span><span class=p>.</span><span class=na>interpret</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Interpreter 클래스: 후위 표기법을 해석하고 계산 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Interpreter</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>evaluate</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>expression</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>Stack</span><span class=w> </span><span class=n>stack</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>expression</span><span class=p>.</span><span class=na>split</span><span class=p>(</span><span class=s>&#34; &#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>token</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=s>&#34;+&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>subExpression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Addition</span><span class=p>(</span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>subExpression</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>token</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=s>&#34;-&#34;</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>subExpression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Subtraction</span><span class=p>(</span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>subExpression</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>Expression</span><span class=w> </span><span class=n>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Number</span><span class=p>(</span><span class=n>Integer</span><span class=p>.</span><span class=na>parseInt</span><span class=p>(</span><span class=n>token</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	            </span><span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>number</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>().</span><span class=na>interpret</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 사용 예시 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>InterpreterPatternDemo</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>String</span><span class=w> </span><span class=n>expression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;7 3 - 2 1 + +&#34;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=kt>int</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Interpreter</span><span class=p>.</span><span class=na>evaluate</span><span class=p>(</span><span class=n>expression</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;결과: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>result</span><span class=p>);</span><span class=w> </span><span class=c1>// 출력: 결과: 7 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>설명:</p><ul><li><strong>Number 클래스:</strong> 숫자 값을 나타내는 종료 표현식으로, <code>interpret</code> 메서드는 해당 숫자를 반환한다.</li><li><strong>Addition 클래스:</strong> 두 표현식의 합을 계산하는 비종료 표현식으로, <code>interpret</code> 메서드는 좌측 및 우측 표현식의 결과를 더한 값을 반환한다.</li><li><strong>Subtraction 클래스:</strong>: 두 표현식의 차를 계산하는 비종료 표현식으로, <code>interpret</code> 메서드는 좌측 표현식에서 우측 표현식의 결과를 뺀 값을 반환한다.</li><li><strong>Interpreter 클래스:</strong> 후위 표기법으로 주어진 수식을 해석하고 계산한다. 스택을 사용하여 토큰을 처리하며, 연산자가 나오면 스택에서 피연산자를 꺼내어 계산한 후 결과를 다시 스택에 넣는다.</li></ul><p>이러한 구조를 통해 인터프리터 패턴은 복잡한 문법이나 표현식을 객체지향적으로 해석하고 처리할 수 있다. 그러나 이 패턴은 문법이 복잡해질수록 클래스의 수가 증가하여 코드가 복잡해질 수 있으므로, 단순한 문법을 해석할 때 주로 사용된다.</p><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><hr><h3 id=1-주제의-분류-적절성>1. 주제의 분류 적절성<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적절성>#</a></h3><p>Interpreter Pattern(인터프리터 패턴) 은 &ldquo;Computer Science and Engineering > Software Design and Architecture > Software Design Patterns > GoF > Behavioral Design Patterns&rdquo; 분류에 정확히 해당합니다. GoF(Gang of Four) 에서 정의한 23 가지 디자인 패턴 중 하나이며, 대표적인 행동 (Behavioral) 패턴입니다 [1][2][12].</p><hr><h3 id=2-200-자-요약>2. 200 자 요약<a hidden class=anchor aria-hidden=true href=#2-200-자-요약>#</a></h3><p>인터프리터 패턴은 특정 언어나 문법을 클래스 구조로 정의하고, 해당 문법에 따라 입력된 표현식을 해석 (interpret) 하는 역할을 담당합니다. 주로 간단한 언어나 반복적으로 등장하는 규칙을 처리할 때 유용하며, 정규표현식, SQL, 계산기, DSL 등 다양한 분야에서 활용됩니다 [1][2][4][12].</p><hr><h3 id=3-250-자-개요>3. 250 자 개요<a hidden class=anchor aria-hidden=true href=#3-250-자-개요>#</a></h3><p>인터프리터 패턴은 언어나 문법의 규칙을 객체로 표현하고, 해당 규칙에 따라 입력된 문장이나 표현식을 해석하는 구조적 설계 방식입니다. 이 패턴은 문법의 각 규칙을 클래스로 매핑하고, 트리 구조 (Composite) 를 활용해 문장을 계층적으로 해석합니다. 간단한 언어나 반복되는 규칙을 처리하는 데 적합하며, 문법 확장과 유지보수가 용이한 장점이 있습니다. 컴파일러, 정규표현식, DSL, 쿼리 엔진 등에서 널리 사용됩니다 [1][2][4][12].</p><hr><h2 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h2><ul><li><strong>정의</strong>: Interpreter Pattern 은 언어나 문법의 규칙을 클래스 (객체) 로 표현하고, 해당 규칙에 따라 입력된 문장이나 표현식을 해석하는 디자인 패턴입니다 [1][2][3][12].</li><li><strong>목적</strong>: 반복적으로 등장하는 문제를 언어나 문법으로 정의하고, 이를 해석하는 엔진을 제공함으로써, 표현식 평가, 쿼리, 스크립트 해석 등 다양한 요구사항을 유연하게 처리 [1][2][12].</li><li><strong>주요 특징</strong>: 문법 규칙을 클래스로 매핑, 트리 (Composite) 구조 활용, 문법 확장 용이, 해석 로직의 재사용성 및 유연성 [1][4][12].</li><li><strong>핵심 원칙</strong>: Composite 패턴과 밀접, 각 문법 규칙을 독립적인 클래스로 분리, 해석 (interpret) 연산의 재귀적 위임 [1][12].</li><li><strong>실무 활용</strong>: 정규표현식 엔진, SQL 파서, 계산기, DSL(Domain-Specific Language) 해석, 비즈니스 룰 엔진 등 [1][10][11][12].</li></ul><hr><h2 id=주요-내용-정리>주요 내용 정리<a hidden class=anchor aria-hidden=true href=#주요-내용-정리>#</a></h2><h3 id=패턴-이름과-분류>패턴 이름과 분류<a hidden class=anchor aria-hidden=true href=#패턴-이름과-분류>#</a></h3><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td>패턴 이름</td><td>Interpreter Pattern (인터프리터 패턴)</td></tr><tr><td>분류</td><td>GoF 행동 (Behavioral) 패턴</td></tr></tbody></table><hr><h3 id=의도-intent>의도 (Intent)<a hidden class=anchor aria-hidden=true href=#의도-intent>#</a></h3><p>언어나 문법의 규칙을 객체로 정의하고, 해당 규칙에 따라 입력된 표현식이나 문장을 해석하는 엔진을 제공 [1][12].</p><hr><h3 id=다른-이름-also-known-as>다른 이름 (Also Known As)<a hidden class=anchor aria-hidden=true href=#다른-이름-also-known-as>#</a></h3><ul><li>해석자 패턴 (Interpreter Pattern)</li><li>해석 엔진 패턴</li></ul><hr><h3 id=동기-motivation--forces>동기 (Motivation / Forces)<a hidden class=anchor aria-hidden=true href=#동기-motivation--forces>#</a></h3><ul><li>반복적으로 등장하는 문제를 언어나 문법으로 정의하면, 해석 엔진을 통해 문제를 쉽게 해결할 수 있음 [1][4][12].</li><li>예: 정규표현식, 수식 계산, 쿼리 해석 등</li></ul><hr><h3 id=적용-가능성-applicability>적용 가능성 (Applicability)<a hidden class=anchor aria-hidden=true href=#적용-가능성-applicability>#</a></h3><ul><li>간단한 언어나 표현식의 문법을 해석해야 할 때</li><li>문법이 자주 변경되거나 확장될 가능성이 있을 때</li><li>반복적으로 등장하는 규칙 기반 문제를 처리할 때</li><li>복잡하지 않은 DSL, 쿼리, 수식 등 [1][2][4][10][11][12]</li></ul><hr><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=구조-다이어그램>구조 다이어그램<a hidden class=anchor aria-hidden=true href=#구조-다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+---------+         +------------------+
</span></span><span class=line><span class=cl>| Context || Expression       |
</span></span><span class=line><span class=cl>+---------+         +------------------+
</span></span><span class=line><span class=cl>                         /       \
</span></span><span class=line><span class=cl>                +-------------------+    +-------------------+
</span></span><span class=line><span class=cl>                | TerminalExpression|    |NonTerminalExpression|
</span></span><span class=line><span class=cl>                +-------------------+    +-------------------+
</span></span></code></pre></td></tr></table></div></div><h4 id=구성-요소-및-역할>구성 요소 및 역할<a hidden class=anchor aria-hidden=true href=#구성-요소-및-역할>#</a></h4><table><thead><tr><th>구성 요소</th><th>기능 및 역할</th></tr></thead><tbody><tr><td>Context</td><td>해석에 필요한 데이터, 상태, 환경 정보를 저장 및 관리 [1][2][12]</td></tr><tr><td>AbstractExpression</td><td>해석을 위한 인터페이스/추상 클래스, interpret() 메서드 정의 [1][2][12]</td></tr><tr><td>TerminalExpression</td><td>더 이상 분해되지 않는 기본 표현식 (숫자, 변수 등), interpret() 구현 [1][2][12]</td></tr><tr><td>NonTerminalExpression</td><td>다른 Expression 을 조합/재귀적으로 참조하여 복합 문법 해석 [1][2][12]</td></tr><tr><td>Client</td><td>구문 트리 (문장 구조) 생성 및 interpret() 호출 [1][2][12]</td></tr></tbody></table><h4 id=필수선택-구성요소>필수/선택 구성요소<a hidden class=anchor aria-hidden=true href=#필수선택-구성요소>#</a></h4><table><thead><tr><th>구분</th><th>구성 요소</th><th>기능 및 특징</th></tr></thead><tbody><tr><td>필수</td><td>Context</td><td>해석에 필요한 정보 저장, 상태 관리</td></tr><tr><td>필수</td><td>AbstractExpression</td><td>해석 인터페이스, interpret() 정의</td></tr><tr><td>필수</td><td>TerminalExpression</td><td>기본 표현식 해석, 트리의 리프 노드</td></tr><tr><td>필수</td><td>NonTerminalExpression</td><td>복합 표현식 해석, 트리의 내부 노드</td></tr><tr><td>선택</td><td>Parser/Builder</td><td>구문 트리 생성 자동화, 복잡한 문법 처리 시 필요</td></tr></tbody></table><hr><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><ol><li><strong>문법 규칙을 클래스 (객체) 로 정의</strong>: 각 규칙은 Expression 계층 구조로 매핑</li><li><strong>구문 트리 (Composite 구조) 생성</strong>: 문장을 Expression 객체 트리로 구성</li><li><strong>Interpret 호출</strong>: Client 가 구문 트리의 interpret() 을 호출</li><li><strong>재귀적 해석</strong>: NonTerminalExpression 이 하위 Expression 의 interpret() 을 재귀적으로 호출, TerminalExpression 이 실제 값을 반환</li></ol><h4 id=작동-원리-다이어그램>작동 원리 다이어그램<a hidden class=anchor aria-hidden=true href=#작동-원리-다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Client]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[Expression Tree] (Composite)
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   v
</span></span><span class=line><span class=cl>[interpret(Context)]
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   +--[NonTerminalExpression]--+
</span></span><span class=line><span class=cl>   |                           |
</span></span><span class=line><span class=cl>   v                           v
</span></span><span class=line><span class=cl>[TerminalExpression]   [NonTerminalExpression]
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><ul><li><strong>Composite 구조 활용</strong>: Expression 계층 구조로 트리 구성 [1][12]</li><li><strong>인터페이스/추상 클래스</strong>: interpret() 메서드 정의</li><li><strong>Terminal/NonTerminal 클래스</strong>: 각각 해석 로직 구현</li><li><strong>Context 객체</strong>: 해석에 필요한 데이터/상태 관리</li></ul><h4 id=예시-코드-java-기반>예시 코드 (Java 기반)<a hidden class=anchor aria-hidden=true href=#예시-코드-java-기반>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>interface</span> <span class=nc>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>(</span><span class=n>Map</span><span class=w> </span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>VariableExpression</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>variable</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>VariableExpression</span><span class=p>(</span><span class=kt>char</span><span class=w> </span><span class=n>variable</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>variable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>variable</span><span class=p>;</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>(</span><span class=n>Map</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>variable</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>PlusExpression</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>PlusExpression</span><span class=p>(</span><span class=n>Expression</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>right</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>right</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>(</span><span class=n>Map</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>left</span><span class=p>.</span><span class=na>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>right</span><span class=p>.</span><span class=na>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>위 구조는 후위표기법, 계산기, DSL 등에서 활용 [4][11].</li></ul><hr><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>문법 확장 용이</td><td>각 규칙을 독립 클래스로 관리, 문법 추가/수정 쉬움 [2][3][8][12]</td></tr><tr><td></td><td>재사용성/유연성</td><td>규칙별 클래스로 재사용, 다양한 해석 방식 지원 [3][12]</td></tr><tr><td></td><td>트리 구조 활용</td><td>복합 문법/표현식 처리에 적합, Composite 패턴과 결합 [1][4][12]</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>문법이 복잡해질수록 클래스 수 급증, 유지보수 어려움 [1][2][3][4][8][12]</td></tr><tr><td></td><td>성능 저하</td><td>해석 단계의 오버헤드, 대량 데이터 해석 시 비효율적 [3][8][12]</td></tr></tbody></table><hr><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><ul><li><strong>문제</strong>: 복잡한 문법에서 클래스 수 증가, 유지보수 어려움<ul><li><strong>해결책</strong>: 파서/컴파일러 생성기 도입, Visitor 패턴 등과 결합하여 관리</li></ul></li><li><strong>문제</strong>: 성능 저하<ul><li><strong>해결책</strong>: 트리 최적화, 캐싱, 복잡한 문법은 별도 파서/컴파일러 활용</li></ul></li></ul><hr><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>종류/유형</th><th>설명</th></tr></thead><tbody><tr><td>표현식 구조</td><td>Terminal</td><td>더 이상 분해 불가, 리프 노드</td></tr><tr><td></td><td>NonTerminal</td><td>복합 표현식, 내부 노드</td></tr><tr><td>문법 복잡도</td><td>단순 문법</td><td>간단한 DSL, 계산기 등</td></tr><tr><td></td><td>복합 문법</td><td>SQL, 정규표현식 등 복잡한 언어</td></tr></tbody></table><hr><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>분야</th><th>적용 예시</th><th>설명</th></tr></thead><tbody><tr><td>정규표현식</td><td>패턴 매칭 엔진</td><td>입력 문자열 패턴 해석 및 처리</td></tr><tr><td>쿼리 엔진</td><td>SQL 파서/해석기</td><td>쿼리 구문 해석 및 실행</td></tr><tr><td>계산기</td><td>수식 계산기</td><td>후위표기법, 중위표기법 해석</td></tr><tr><td>DSL</td><td>도메인 특화 언어</td><td>비즈니스 규칙, 설정 언어 해석</td></tr></tbody></table><hr><h3 id=활용-사례-시나리오-기반>활용 사례 (시나리오 기반)<a hidden class=anchor aria-hidden=true href=#활용-사례-시나리오-기반>#</a></h3><h4 id=상황-가정-간단한-수식-계산기>상황 가정: 간단한 수식 계산기<a hidden class=anchor aria-hidden=true href=#상황-가정-간단한-수식-계산기>#</a></h4><ul><li><strong>시스템 구성</strong>:<ul><li>Client → Expression Tree(Composite: Plus, Minus, Variable 등) → Context</li></ul></li><li><strong>Workflow</strong>:<ol><li>Client 가 &ldquo;xyz+-&rdquo; 와 같은 후위표기 수식 입력</li><li>Parser 가 Expression 트리 생성</li><li>interpret(context) 호출, context 에 변수 값 전달</li><li>트리 구조를 따라 재귀적으로 해석, 결과 반환</li></ol></li><li><strong>역할</strong>: Expression 트리에서 각 노드 (Plus, Minus, Variable 등) 가 자신의 interpret() 을 호출, 최종 결과 도출</li></ul><hr><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>문법 복잡도 관리</td><td>복잡한 문법은 클래스 수 급증</td><td>단순 문법/DSL 에만 적용, 복잡한 문법은 파서 활용</td></tr><tr><td>클래스 관리</td><td>규칙별 클래스 관리 필요</td><td>Visitor, 팩토리 패턴 등과 결합</td></tr><tr><td>성능 최적화</td><td>트리 해석의 오버헤드 발생</td><td>캐싱, 트리 최적화, 반복 작업 최소화</td></tr><tr><td>테스트</td><td>다양한 입력/문법 테스트 필요</td><td>단위 테스트, 통합 테스트 강화</td></tr></tbody></table><hr><h3 id=최적화하기-위한-고려사항-및-주의점>최적화하기 위한 고려사항 및 주의점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>트리 구조 최적화</td><td>불필요한 노드/계층 최소화</td><td>트리 구조 단순화, 캐싱 활용</td></tr><tr><td>반복 해석 최소화</td><td>동일 표현식 반복 해석 시 성능 저하</td><td>결과 캐싱, 메모이제이션 적용</td></tr><tr><td>복잡한 문법 분리</td><td>복잡한 문법은 별도 파서로 처리</td><td>파서/컴파일러 생성기 활용</td></tr><tr><td>리소스 관리</td><td>메모리/CPU 사용량 증가 가능</td><td>자원 사용량 모니터링, 최적화</td></tr></tbody></table><hr><h3 id=2025-년-기준-최신-동향>2025 년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#2025-년-기준-최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>DSL</td><td>도메인 특화 언어</td><td>비즈니스 룰, 설정 언어 등에서 인터프리터 패턴 활용 확대</td></tr><tr><td>쿼리/검색</td><td>Query Object</td><td>쿼리 조건식 모델링, 동적 쿼리 해석에 패턴 적용</td></tr><tr><td>AI/자동화</td><td>룰 엔진</td><td>AI, 자동화 시스템에서 규칙 해석 엔진으로 활용</td></tr><tr><td>성능</td><td>최적화 도구</td><td>복잡한 문법 해석 시 파서/컴파일러 생성기와 병행 사용</td></tr></tbody></table><hr><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>Composite 패턴</td><td>트리 구조 활용</td><td>인터프리터 패턴의 핵심 구조, 문법 계층 표현</td></tr><tr><td>Visitor 패턴</td><td>해석 로직 분리</td><td>다양한 해석 방식 지원, 유지보수성 향상</td></tr><tr><td>Query Object</td><td>쿼리 모델링</td><td>동적 쿼리 해석/실행에 효과적</td></tr><tr><td>DSL</td><td>비즈니스 규칙 해석</td><td>도메인 특화 언어 구현에 적합</td></tr></tbody></table><hr><h3 id=앞으로의-전망>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>DSL</td><td>비즈니스 자동화</td><td>다양한 산업에서 DSL 해석 엔진 수요 증가</td></tr><tr><td>AI/룰 엔진</td><td>규칙 기반 해석</td><td>AI, 자동화 시스템에서 규칙 해석에 활용 확대</td></tr><tr><td>복합 패턴</td><td>패턴 결합</td><td>Visitor, Composite 등과 결합한 고급 구현 증가</td></tr></tbody></table><hr><h3 id=하위-주제별-추가-학습-필요-내용>하위 주제별 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#하위-주제별-추가-학습-필요-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>간략 설명</th></tr></thead><tbody><tr><td>패턴 구조</td><td>Composite 패턴</td><td>트리 구조와 인터프리터 결합 방식</td></tr><tr><td>해석 로직</td><td>Visitor 패턴</td><td>다양한 해석/출력 방식 적용법</td></tr><tr><td>DSL</td><td>도메인 특화 언어</td><td>DSL 설계 및 해석 엔진 구현</td></tr><tr><td>쿼리 해석</td><td>Query Object</td><td>동적 쿼리 해석/실행 패턴</td></tr></tbody></table><hr><h3 id=추가-학습알아야-할-내용>추가 학습/알아야 할 내용<a hidden class=anchor aria-hidden=true href=#추가-학습알아야-할-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>간략 설명</th></tr></thead><tbody><tr><td>소프트웨어 아키텍처</td><td>파서/컴파일러 생성기</td><td>복잡한 문법 해석 자동화 도구</td></tr><tr><td>성능</td><td>캐싱/최적화</td><td>트리 해석 성능 개선 전략</td></tr><tr><td>테스트</td><td>단위/통합 테스트</td><td>다양한 입력/문법에 대한 테스트 전략</td></tr><tr><td>도구</td><td>DSL 프레임워크</td><td>실무 적용 가능한 DSL/쿼리 엔진 도구</td></tr></tbody></table><hr><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Composite 패턴</td><td>객체를 트리 구조로 구성해 부분 - 전체 계층 구조를 표현하는 디자인 패턴</td></tr><tr><td>TerminalExpression</td><td>더 이상 분해되지 않는 표현식 (리프 노드)</td></tr><tr><td>NonTerminalExpression</td><td>다른 Expression 을 조합하는 복합 표현식 (내부 노드)</td></tr><tr><td>DSL (Domain-Specific Language)</td><td>특정 도메인에 특화된 언어</td></tr><tr><td>Query Object</td><td>쿼리 조건식을 객체로 모델링하는 패턴</td></tr></tbody></table><hr><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><a href=https://keichee.tistory.com/189>디자인패턴 - 인터프리터 패턴 구조와 원리</a></li><li><a href=https://memodayoungee.tistory.com/72>인터프리터 패턴 - 개발 메모용 블로그</a></li><li><a href=https://seungjoonh.tistory.com/entry/dp-interpreter>Design Pattern - 성장하는 개발자</a></li><li><a href=https://louis-devlog.tistory.com/37>디자인패턴 시리즈 - 인터프리터 패턴</a></li><li><a href=https://shan0325.tistory.com/29>Interpreter 패턴이란?</a></li><li><a href=https://www.devkuma.com/docs/design-pattern/interpreter/>Design Pattern | Interpreter Pattern - devkuma</a></li><li><a href=https://velog.io/@hongchee/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80-Interpreter-Pattern-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%ED%96%89%EB%8F%99-%ED%8C%A8%ED%84%B4>인터프리터 패턴 - velog</a></li><li><a href=https://jay-cheol.tistory.com/entry/%ED%96%89%EC%9C%84-%ED%8C%A8%ED%84%B4Behavioral-Pattern-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0Interpreter-%ED%8C%A8%ED%84%B4>행위 패턴 - 인터프리터 패턴</a></li><li><a href=https://jhtop0419.tistory.com/117>Interpreter 패턴 - 평범한 개발자의 개발 여정</a></li><li><a href=https://johngrib.github.io/wiki/pattern/interpreter/>인터프리터 패턴 - 기계인간 John Grib</a></li><li><a href=https://zoosso.tistory.com/1235>디자인패턴 - 인터프리터 패턴 (까망 하르방)</a></li><li><a href=https://pandac.in/blogs/interpreter-pattern/>Understanding the Interpreter Design Pattern - PandaC</a></li><li><a href=https://gngsn.tistory.com/148>Design Pattern, Interpreter - ENFJ.dev</a></li><li><a href=https://aroma-bok.tistory.com/entry/Design-Pattern-%ED%96%89%EB%8F%99%ED%8C%A8%ED%84%B4-Interpreter>행동패턴 - Interpreter - 선 조치 후 분석</a></li></ul><p>인터프리터 패턴 (Interpreter Pattern) 은 언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 행동 (Behavioral) 디자인 패턴입니다. 주로 도메인 특화 언어 (DSL: Domain-Specific Language) 나 간단한 언어의 문법을 해석할 때 사용됩니다.(<a href="https://www.geeksforgeeks.org/interpreter-design-pattern-in-java/?utm_source=chatgpt.com" title="Interpreter Design Pattern in Java | GeeksforGeeks">GeeksforGeeks</a>)</p><hr><h2 id=1-주제의-분류-적절성-검토>1. 주제의 분류 적절성 검토<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적절성-검토>#</a></h2><ul><li><p><strong>현재 분류</strong>: &ldquo;Computer Science and Engineering&rdquo; > &ldquo;Software Design and Architecture&rdquo; > &ldquo;Software Design Patterns&rdquo; > &ldquo;GoF&rdquo; > &ldquo;Behavioral Design Patterns&rdquo;</p></li><li><p><strong>검토 결과</strong>: 적절합니다. 인터프리터 패턴은 GoF(Gang of Four) 에서 정의한 23 가지 디자인 패턴 중 하나로, 행동 패턴 (Behavioral Pattern) 에 속합니다.(<a href="https://javadesignpatterns.com/catalog/behavioral-patterns/interpreter-pattern/?utm_source=chatgpt.com" title="Interpreter Pattern - The Java Design Patterns Manual">javadesignpatterns.com</a>)</p></li></ul><hr><h2 id=2-주제-요약-200-자-내외>2. 주제 요약 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-주제-요약-200-자-내외>#</a></h2><p>인터프리터 패턴은 간단한 언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 디자인 패턴입니다. 주로 도메인 특화 언어 (DSL) 나 간단한 언어의 문법을 해석할 때 사용됩니다.(<a href="https://www.geeksforgeeks.org/interpreter-design-pattern-in-java/?utm_source=chatgpt.com" title="Interpreter Design Pattern in Java | GeeksforGeeks">GeeksforGeeks</a>)</p><hr><h2 id=3-전체-개요-250-자-내외>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외>#</a></h2><p>인터프리터 패턴은 언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 행동 디자인 패턴입니다. 각 문법 규칙을 클래스로 표현하여 추상 구문 트리 (Abstract Syntax Tree) 를 구성하고, 이를 통해 표현식을 해석합니다. 주로 도메인 특화 언어 (DSL), 수식 계산기, 간단한 프로토콜 해석 등에 활용됩니다.</p><hr><h2 id=4-핵심-개념>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념>#</a></h2><ul><li><p><strong>정의</strong>: 인터프리터 패턴은 언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 디자인 패턴입니다.</p></li><li><p><strong>주요 목적</strong>: 도메인 특화 언어 (DSL) 나 간단한 언어의 문법을 해석하여 표현식을 평가하는 기능을 제공합니다.</p></li><li><p><strong>적용 분야</strong>: 수식 계산기, SQL 파서, 간단한 스크립트 언어 해석기 등 (<a href="https://www.geeksforgeeks.org/interpreter-design-pattern/?utm_source=chatgpt.com" title="Interpreter Design Pattern | GeeksforGeeks">GeeksforGeeks</a>)</p></li></ul><hr><h2 id=5-상세-조사-내용>5. 상세 조사 내용<a hidden class=anchor aria-hidden=true href=#5-상세-조사-내용>#</a></h2><h3 id=의도-intent-1>의도 (Intent)<a hidden class=anchor aria-hidden=true href=#의도-intent-1>#</a></h3><p>언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가합니다.</p><h3 id=다른-이름-also-known-as-1>다른 이름 (Also Known As)<a hidden class=anchor aria-hidden=true href=#다른-이름-also-known-as-1>#</a></h3><ul><li>없음</li></ul><h3 id=동기-motivation--forces-1>동기 (Motivation / Forces)<a hidden class=anchor aria-hidden=true href=#동기-motivation--forces-1>#</a></h3><p>복잡한 표현식을 해석하거나 평가할 때, 이를 구성하는 문법 규칙을 클래스 구조로 정의하면 유연하게 확장하고 유지보수할 수 있습니다.</p><h3 id=적용-가능성-applicability-1>적용 가능성 (Applicability)<a hidden class=anchor aria-hidden=true href=#적용-가능성-applicability-1>#</a></h3><ul><li><p>언어의 문법을 해석하여 표현식을 평가해야 할 때</p></li><li><p>도메인 특화 언어 (DSL) 를 구현할 때</p></li><li><p>수식 계산기나 간단한 스크립트 언어 해석기를 구현할 때</p></li></ul><h3 id=구조-structure>구조 (Structure)<a hidden class=anchor aria-hidden=true href=#구조-structure>#</a></h3><p>인터프리터 패턴의 구조는 다음과 같습니다:</p><ul><li><p><strong>AbstractExpression</strong>: 모든 표현식 클래스의 공통 인터페이스를 정의합니다.</p></li><li><p><strong>TerminalExpression</strong>: 문법에서 더 이상 분해되지 않는 터미널 표현식을 구현합니다.</p></li><li><p><strong>NonTerminalExpression</strong>: 하위 표현식을 포함하는 비터미널 표현식을 구현합니다.</p></li><li><p><strong>Context</strong>: 해석에 필요한 정보를 제공합니다.</p></li><li><p><strong>Client</strong>: 표현식을 구성하고 해석을 요청합니다.(<a href="https://www.geeksforgeeks.org/interpreter-design-pattern/?utm_source=chatgpt.com" title="Interpreter Design Pattern | GeeksforGeeks">GeeksforGeeks</a>, <a href="https://medium.com/%40rajeshvelmani/understanding-language-interpretation-with-the-interpreter-design-pattern-in-java-b2a3969eaf9?utm_source=chatgpt.com" title="Understanding Language Interpretation with the Interpreter Design ...">Medium</a>)</p></li></ul><h3 id=참여자-participants>참여자 (Participants)<a hidden class=anchor aria-hidden=true href=#참여자-participants>#</a></h3><ul><li><p><strong>AbstractExpression</strong>: 모든 표현식 클래스의 공통 인터페이스를 정의합니다.</p></li><li><p><strong>TerminalExpression</strong>: 터미널 표현식을 구현합니다.</p></li><li><p><strong>NonTerminalExpression</strong>: 비터미널 표현식을 구현합니다.</p></li><li><p><strong>Context</strong>: 해석에 필요한 정보를 제공합니다.</p></li><li><p><strong>Client</strong>: 표현식을 구성하고 해석을 요청합니다.</p></li></ul><h3 id=협력-collaboration>협력 (Collaboration)<a hidden class=anchor aria-hidden=true href=#협력-collaboration>#</a></h3><p>Client 는 표현식을 구성하고, Context 와 함께 interpret 메서드를 호출하여 표현식을 해석합니다.(<a href="https://en.wikipedia.org/wiki/Interpreter_pattern?utm_source=chatgpt.com" title="Interpreter pattern">위키백과</a>)</p><h3 id=결과-consequences>결과 (Consequences)<a hidden class=anchor aria-hidden=true href=#결과-consequences>#</a></h3><ul><li><p><strong>장점</strong>:</p><ul><li><p>문법을 클래스 구조로 정의하여 유연하게 확장할 수 있습니다.</p></li><li><p>표현식을 객체로 표현하여 재사용성과 유지보수성이 향상됩니다.</p></li></ul></li><li><p><strong>단점</strong>:</p><ul><li>복잡한 문법을 표현할 경우 클래스 수가 많아져 구조가 복잡해질 수 있습니다.</li></ul></li></ul><h3 id=구현-implementation>구현 (Implementation)<a hidden class=anchor aria-hidden=true href=#구현-implementation>#</a></h3><p>다음은 간단한 수식 계산기를 구현한 예시입니다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>abc</span> <span class=kn>import</span> <span class=n>ABC</span><span class=p>,</span> <span class=n>abstractmethod</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Expression</span><span class=p>(</span><span class=n>ABC</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@abstractmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>interpret</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>context</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>pass</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Number</span><span class=p>(</span><span class=n>Expression</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>value</span> <span class=o>=</span> <span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>interpret</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>context</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Add</span><span class=p>(</span><span class=n>Expression</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>interpret</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>context</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>context</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=n>expression</span> <span class=o>=</span> <span class=n>Add</span><span class=p>(</span><span class=n>Number</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span> <span class=n>Number</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>expression</span><span class=o>.</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 출력: 15</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=알려진-사용-known-uses>알려진 사용 (Known Uses)<a hidden class=anchor aria-hidden=true href=#알려진-사용-known-uses>#</a></h3><ul><li><p>SQL 파서</p></li><li><p>수식 계산기</p></li><li><p>간단한 스크립트 언어 해석기</p></li></ul><h3 id=관련-패턴-related-patterns>관련 패턴 (Related Patterns)<a hidden class=anchor aria-hidden=true href=#관련-패턴-related-patterns>#</a></h3><ul><li><p><strong>Composite Pattern</strong>: 표현식을 트리 구조로 구성할 때 사용됩니다.</p></li><li><p><strong>Visitor Pattern</strong>: 표현식 트리를 순회하면서 다양한 연산을 수행할 때 사용됩니다.</p></li></ul><hr><h2 id=6-용어-정리>6. 용어 정리<a hidden class=anchor aria-hidden=true href=#6-용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>인터프리터 패턴 (Interpreter Pattern)</td><td>언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 디자인 패턴</td></tr><tr><td>도메인 특화 언어 (DSL)</td><td>특정 도메인에 특화된 간단한 언어</td></tr><tr><td>추상 구문 트리 (AST)</td><td>문법 구조를 트리 형태로 표현한 구조</td></tr><tr><td>터미널 표현식 (Terminal Expression)</td><td>더 이상 분해되지 않는 기본 표현식</td></tr><tr><td>비터미널 표현식 (NonTerminal Expression)</td><td>하위 표현식을 포함하는 복합 표현식</td></tr></tbody></table><hr><h2 id=7-참고-및-출처>7. 참고 및 출처<a hidden class=anchor aria-hidden=true href=#7-참고-및-출처>#</a></h2><ul><li><p><a href=https://www.geeksforgeeks.org/interpreter-design-pattern/>GeeksforGeeks - Interpreter Design Pattern</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/Interpreter_pattern>Wikipedia - Interpreter Pattern</a></p></li><li><p><a href=https://s.visual-paradigm.com/tutorials/interpreterdesignpattern.jsp>Visual Paradigm - Interpreter Pattern Tutorial</a>(<a href="https://www.geeksforgeeks.org/interpreter-design-pattern/?utm_source=chatgpt.com" title="Interpreter Design Pattern | GeeksforGeeks">GeeksforGeeks</a>, <a href="https://en.wikipedia.org/wiki/Interpreter_pattern?utm_source=chatgpt.com" title="Interpreter pattern">위키백과</a>, <a href="https://s.visual-paradigm.com/tutorials/interpreterdesignpattern.jsp?utm_source=chatgpt.com" title="Interpreter Pattern Tutorial - Visual Paradigm">s.visual-paradigm.com</a>)</p></li></ul><hr><p>계속해서 " 구현 기법 &ldquo;, " 장점과 단점 &ldquo;, " 도전 과제 " 등 다음 항목부터 자세히 정리합니다.</p><hr><h2 id=8-구현-기법>8. 구현 기법<a hidden class=anchor aria-hidden=true href=#8-구현-기법>#</a></h2><h3 id=81-정의-및-목적>8.1 정의 및 목적<a hidden class=anchor aria-hidden=true href=#81-정의-및-목적>#</a></h3><p>인터프리터 패턴의 구현 기법은 **표현식 (Expression)**을 중심으로 구성되며, 각 문법 규칙에 따라 클래스를 정의하고 이들을 재귀적으로 조합하여 **추상 구문 트리 (AST: Abstract Syntax Tree)**를 구성합니다. 그런 다음 <code>interpret()</code> 메서드를 통해 문맥 (Context) 을 기반으로 해석을 수행합니다.</p><h3 id=82-구성>8.2 구성<a hidden class=anchor aria-hidden=true href=#82-구성>#</a></h3><table><thead><tr><th>구성 요소</th><th>역할</th></tr></thead><tbody><tr><td>Context (문맥)</td><td>해석에 필요한 전역 정보 또는 상태 저장</td></tr><tr><td>AbstractExpression (추상 표현식)</td><td>모든 표현식 클래스의 공통 인터페이스를 정의</td></tr><tr><td>TerminalExpression (터미널 표현식)</td><td>더 이상 분해할 수 없는 기본 문법 요소를 표현</td></tr><tr><td>NonTerminalExpression (비터미널 표현식)</td><td>터미널 표현식을 조합해 더 복잡한 문법 구조 표현</td></tr><tr><td>Client</td><td>구문 트리를 생성하고 해석을 요청하는 주체</td></tr></tbody></table><h3 id=83-실제-예시-수식-해석기>8.3 실제 예시: 수식 해석기<a hidden class=anchor aria-hidden=true href=#83-실제-예시-수식-해석기>#</a></h3><h4 id=시스템-구성>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성>#</a></h4><ul><li><p>사용자는 문자열 수식을 입력</p></li><li><p>Lexer 가 토큰 분리</p></li><li><p>Parser 가 AST(Abstract Syntax Tree) 구성</p></li><li><p>Interpreter 가 AST 를 순회하며 값을 계산</p></li></ul><h4 id=시나리오>시나리오<a hidden class=anchor aria-hidden=true href=#시나리오>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 표현식 클래스 정의</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Subtract</span><span class=p>(</span><span class=n>Expression</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>left</span><span class=p>,</span> <span class=n>right</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>interpret</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>context</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>left</span><span class=o>.</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span> <span class=o>-</span> <span class=bp>self</span><span class=o>.</span><span class=n>right</span><span class=o>.</span><span class=n>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 표현식 해석</span>
</span></span><span class=line><span class=cl><span class=n>expr</span> <span class=o>=</span> <span class=n>Subtract</span><span class=p>(</span><span class=n>Number</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span> <span class=n>Add</span><span class=p>(</span><span class=n>Number</span><span class=p>(</span><span class=mi>5</span><span class=p>),</span> <span class=n>Number</span><span class=p>(</span><span class=mi>3</span><span class=p>)))</span>
</span></span><span class=line><span class=cl><span class=n>result</span> <span class=o>=</span> <span class=n>expr</span><span class=o>.</span><span class=n>interpret</span><span class=p>({})</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>  <span class=c1># 출력: 12</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=9-장점과-단점>9. 장점과 단점<a hidden class=anchor aria-hidden=true href=#9-장점과-단점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>구조적 해석</td><td>문법을 구조화하여 각 요소별로 해석 가능</td></tr><tr><td></td><td>확장성</td><td>새로운 문법 추가가 쉬움 (새 클래스 추가)</td></tr><tr><td></td><td>테스트 용이</td><td>각 표현식을 유닛 단위로 테스트 가능</td></tr><tr><td>⚠ 단점</td><td>클래스 남발</td><td>문법 요소가 많을 경우 클래스 수 증가</td></tr><tr><td></td><td>복잡도 증가</td><td>트리 구조가 복잡해지고 유지보수 어려움</td></tr><tr><td></td><td>성능 저하</td><td>대규모 표현식에서 인터프리팅 속도 저하</td></tr></tbody></table><hr><h2 id=10-도전-과제>10. 도전 과제<a hidden class=anchor aria-hidden=true href=#10-도전-과제>#</a></h2><table><thead><tr><th>과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>클래스 수 과다</td><td>복잡한 문법에서는 클래스를 너무 많이 생성하게 됨</td><td>간단한 DSL 적용 또는 Builder 패턴과 조합</td></tr><tr><td>성능 문제</td><td>인터프리터가 순차적으로 해석 → 느림</td><td>캐싱, 트리 최적화, JIT 컴파일러 도입</td></tr><tr><td>유지보수</td><td>새로운 문법 추가 시 트리 구조 변경 필요</td><td>인터페이스 일관성 유지 및 테스트 자동화</td></tr></tbody></table><hr><h2 id=11-분류에-따른-종류-및-유형>11. 분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#11-분류에-따른-종류-및-유형>#</a></h2><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>문법 구조</td><td>단항/이항 표현식</td><td>예: Number, Add, Subtract</td></tr><tr><td>표현 방식</td><td>트리 기반 해석</td><td>AST 기반으로 재귀적 해석 수행</td></tr><tr><td>응용 영역</td><td>DSL / 계산기 / SQL 파서</td><td>다양한 해석 환경에 적용 가능</td></tr></tbody></table><hr><h2 id=12-실무-적용-예시>12. 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#12-실무-적용-예시>#</a></h2><table><thead><tr><th>사례</th><th>설명</th><th>적용 이점</th></tr></thead><tbody><tr><td>수식 계산기</td><td>사용자가 수식을 입력하면 결과 계산</td><td>해석 로직의 유연한 확장</td></tr><tr><td>SQL 파서</td><td>SQL 문을 파싱하고 실행 계획 생성</td><td>문법별 파싱 규칙 독립화</td></tr><tr><td>DSL 엔진</td><td>설정 기반의 경량 언어 처리</td><td>설정 변경만으로 로직 재구성 가능</td></tr></tbody></table><hr><h2 id=13-활용-사례>13. 활용 사례<a hidden class=anchor aria-hidden=true href=#13-활용-사례>#</a></h2><h3 id=시나리오-iot-기기-제어를-위한-dsl-해석기>시나리오: IoT 기기 제어를 위한 DSL 해석기<a hidden class=anchor aria-hidden=true href=#시나리오-iot-기기-제어를-위한-dsl-해석기>#</a></h3><h4 id=시스템-구성-1>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성-1>#</a></h4><ul><li><p>DSL 정의: &ldquo;TURN ON LIGHT WHEN TEMP > 25&rdquo;</p></li><li><p>Parser: AST 생성</p></li><li><p>Interpreter: 센서 데이터에 따라 명령 실행</p></li></ul><h4 id=시스템-구성-다이어그램>시스템 구성 다이어그램<a hidden class=anchor aria-hidden=true href=#시스템-구성-다이어그램>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>DSL Script --&gt; Parser --&gt; AST --&gt; Interpreter --&gt; Device Controller
</span></span><span class=line><span class=cl>                                       ↑
</span></span><span class=line><span class=cl>                                   Context (Sensor Data)
</span></span></code></pre></td></tr></table></div></div><h4 id=workflow>Workflow<a hidden class=anchor aria-hidden=true href=#workflow>#</a></h4><ol><li><p>사용자 DSL 입력</p></li><li><p>구문 트리 구성</p></li><li><p>Interpreter 가 센서 Context 와 함께 해석</p></li><li><p>조건에 맞으면 장치 제어</p></li></ol><h4 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h4><ul><li><p>Interpreter: 명령을 해석하고 실행</p></li><li><p>Context: 현재 센서 데이터 제공</p></li><li><p>Client: DSL 트리 생성 및 실행 요청</p></li></ul><hr><h2 id=14-실무-적용-시-고려사항>14. 실무 적용 시 고려사항<a hidden class=anchor aria-hidden=true href=#14-실무-적용-시-고려사항>#</a></h2><table><thead><tr><th>항목</th><th>고려사항</th><th>권장사항</th></tr></thead><tbody><tr><td>문법 복잡도</td><td>너무 복잡하면 패턴 적합하지 않음</td><td>단순한 DSL 중심으로 적용</td></tr><tr><td>표현식 재사용</td><td>표현식 재사용 가능하게 구성</td><td>Composite 패턴 활용</td></tr><tr><td>성능</td><td>재귀적 해석 비용 발생</td><td>캐싱 또는 JIT 전략 고려</td></tr><tr><td>디버깅</td><td>트리 해석 과정이 직관적이지 않음</td><td>디버깅 로깅 도입 권장</td></tr></tbody></table><hr><h2 id=15-성능-최적화-고려사항>15. 성능 최적화 고려사항<a hidden class=anchor aria-hidden=true href=#15-성능-최적화-고려사항>#</a></h2><table><thead><tr><th>항목</th><th>고려사항</th><th>권장사항</th></tr></thead><tbody><tr><td>표현식 캐싱</td><td>동일 표현식 반복 계산 문제</td><td>결과 캐싱 전략 사용</td></tr><tr><td>AST 최적화</td><td>불필요한 트리 구성 요소 제거</td><td>Constant Folding 등 적용</td></tr><tr><td>해석 로직 분리</td><td>Interpreter 가 비대해짐</td><td>Interpreter 를 계층 구조로 분할</td></tr><tr><td>병렬 처리</td><td>독립 표현식 해석 병렬화</td><td>멀티스레딩/비동기 처리 도입</td></tr></tbody></table><hr><p>이어서 최신 동향, 주목할 내용, 향후 전망, 학습 주제에 대해 정리합니다.</p><p><a href=https://tommytradingchannel.gitbook.io/tommy_trading/lvp-price-action><figure><img alt="LVP 매물대 Price Action 전략 - 토미의 트레이딩 TV" loading=lazy src="https://tse2.mm.bing.net/th?id=OIP.2Gb_DEWsPl9QndLqyJ84mwHaDc&pid=Api"></figure></a></p><p>인터프리터 패턴 (Interpreter Pattern) 은 간단한 언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 행동 디자인 패턴입니다. 주로 도메인 특화 언어 (DSL: Domain-Specific Language) 나 간단한 언어의 문법을 해석할 때 사용됩니다.</p><hr><h2 id=16-2025-년-기준-최신-동향>16. 2025 년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#16-2025-년-기준-최신-동향>#</a></h2><p>2025 년 현재, 인터프리터 패턴은 다음과 같은 분야에서 주목받고 있습니다:</p><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>AI 기반 시스템</td><td>자연어 처리 인터프리터</td><td>대규모 언어 모델 (LLM) 을 활용하여 자연어 명령을 해석하고 실행하는 시스템 개발이 활발합니다.</td></tr><tr><td>도메인 특화 언어 (DSL)</td><td>비즈니스 규칙 엔진</td><td>비즈니스 로직을 DSL 로 정의하고, 인터프리터 패턴을 통해 유연하게 해석하는 시스템이 증가하고 있습니다.</td></tr><tr><td>클라우드 네이티브 아키텍처</td><td>경량 스크립트 해석기</td><td>마이크로서비스 환경에서 경량화된 스크립트 언어를 해석하는 데 인터프리터 패턴이 활용됩니다.</td></tr></tbody></table><hr><h2 id=17-주제와-관련하여-주목할-내용>17. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#17-주제와-관련하여-주목할-내용>#</a></h2><p>인터프리터 패턴과 관련하여 다음과 같은 기술 및 개념이 주목받고 있습니다:</p><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>디자인 패턴</td><td>컴포지트 패턴</td><td>인터프리터 패턴에서 표현식을 트리 구조로 구성할 때 컴포지트 패턴이 함께 사용됩니다.</td></tr><tr><td>디자인 패턴</td><td>비지터 패턴</td><td>표현식 트리를 순회하면서 다양한 연산을 수행할 때 비지터 패턴이 활용됩니다.</td></tr><tr><td>프로그래밍 언어</td><td>도메인 특화 언어 (DSL)</td><td>특정 도메인에 특화된 간단한 언어를 정의하고 해석하는 데 인터프리터 패턴이 사용됩니다.</td></tr></tbody></table><hr><h2 id=18-앞으로의-전망>18. 앞으로의 전망<a hidden class=anchor aria-hidden=true href=#18-앞으로의-전망>#</a></h2><p>인터프리터 패턴은 다음과 같은 방향으로 발전할 것으로 예상됩니다:</p><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>AI 통합</td><td>자연어 인터프리터</td><td>자연어를 해석하여 명령을 실행하는 인터프리터의 수요가 증가할 것입니다.</td></tr><tr><td>경량화</td><td>마이크로서비스용 인터프리터</td><td>마이크로서비스 아키텍처에 적합한 경량 인터프리터의 개발이 활발해질 것입니다.</td></tr><tr><td>보안 강화</td><td>안전한 스크립트 해석</td><td>스크립트 해석 시 보안을 강화하는 기술이 중요해질 것입니다.</td></tr></tbody></table><hr><h2 id=19-추가-학습-주제>19. 추가 학습 주제<a hidden class=anchor aria-hidden=true href=#19-추가-학습-주제>#</a></h2><p>인터프리터 패턴을 깊이 있게 이해하기 위해 다음과 같은 주제를 추가로 학습하는 것이 유익합니다:</p><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>디자인 패턴</td><td>컴포지트 패턴</td><td>트리 구조의 표현식을 구성하는 데 사용됩니다.</td></tr><tr><td>디자인 패턴</td><td>비지터 패턴</td><td>표현식 트리를 순회하며 연산을 수행하는 데 사용됩니다.</td></tr><tr><td>프로그래밍 언어</td><td>도메인 특화 언어 (DSL)</td><td>특정 도메인에 특화된 언어를 정의하고 해석하는 기술입니다.</td></tr><tr><td>소프트웨어 아키텍처</td><td>마이크로서비스 아키텍처</td><td>경량화된 인터프리터를 마이크로서비스 환경에 통합하는 방법입니다.</td></tr></tbody></table><hr><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>인터프리터 패턴 (Interpreter Pattern)</td><td>언어의 문법을 클래스 구조로 정의하고, 이를 해석하여 표현식을 평가하는 디자인 패턴</td></tr><tr><td>도메인 특화 언어 (DSL)</td><td>특정 도메인에 특화된 간단한 언어</td></tr><tr><td>추상 구문 트리 (AST)</td><td>문법 구조를 트리 형태로 표현한 구조</td></tr><tr><td>터미널 표현식 (Terminal Expression)</td><td>더 이상 분해되지 않는 기본 표현식</td></tr><tr><td>비터미널 표현식 (NonTerminal Expression)</td><td>하위 표현식을 포함하는 복합 표현식</td></tr></tbody></table><hr><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2><ul><li><p><a href=https://www.geeksforgeeks.org/interpreter-design-pattern/>GeeksforGeeks - Interpreter Design Pattern</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/Interpreter_pattern>Wikipedia - Interpreter Pattern</a></p></li><li><p><a href=https://tutorials.visual-paradigm.com/interpreter-pattern-tutorial/>Visual Paradigm - Interpreter Pattern Tutorial</a></p></li><li><p><a href=https://java-design-patterns.com/patterns/interpreter/>Java Design Patterns - Interpreter Pattern</a></p></li><li><p><a href=https://www.infoworld.com/article/2260834/how-to-work-with-the-interpreter-design-pattern.html>InfoWorld - How to work with the Interpreter design pattern</a></p></li><li><p><a href="https://tutorials.visual-paradigm.com/interpreter-pattern-tutorial/?utm_source=chatgpt.com" title="Interpreter Pattern Tutorial">Visual Paradigm Tutorials</a></p></li><li><p><a href="https://java-design-patterns.com/patterns/interpreter/?utm_source=chatgpt.com" title="Interpreter Pattern in Java: Building Custom Parsers for Java ...">Java Design Patterns</a></p></li><li><p><a href="https://www.infoworld.com/article/2260834/how-to-work-with-the-interpreter-design-pattern.html?utm_source=chatgpt.com" title="How to work with the Interpreter design pattern - InfoWorld">InfoWorld</a></p></li></ul><hr><p>안녕하세요! Interpreter Pattern에 대한 종합적인 조사를 시작하겠습니다. 먼저 웹 검색을 통해 최신 정보를 수집해보겠습니다.</p><p>이제 충분한 정보를 수집했습니다. 체계적으로 Interpreter Pattern에 대한 종합적인 조사 결과를 제시하겠습니다.</p><h1 id=interpreter-pattern-종합-조사-보고서>Interpreter Pattern 종합 조사 보고서<a hidden class=anchor aria-hidden=true href=#interpreter-pattern-종합-조사-보고서>#</a></h1><h2 id=1-주제-분류-검증>1. 주제 분류 검증<a hidden class=anchor aria-hidden=true href=#1-주제-분류-검증>#</a></h2><p>제시된 분류 **&ldquo;Computer Science and Engineering&rdquo; > &ldquo;Software Design and Architecture&rdquo; > &ldquo;Software Design Patterns&rdquo; > &ldquo;GoF&rdquo; > &ldquo;Behavioral Design Patterns&rdquo;**는 완전히 적절합니다. Interpreter Pattern은 GoF(Gang of Four)가 정의한 23개 디자인 패턴 중 하나이며, 행동 패턴(Behavioral Pattern) 카테고리에 속합니다.</p><h2 id=2-요약-설명-200자-내외>2. 요약 설명 (200자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-설명-200자-내외>#</a></h2><p>Interpreter Pattern은 특정 언어의 문법을 정의하고 해당 언어로 작성된 문장을 해석하기 위한 행동 패턴입니다. 문법의 각 규칙을 클래스로 표현하여 추상 구문 트리(AST)를 구성하고, 이를 재귀적으로 순회하며 해석합니다. SQL 파싱, 수식 계산, 규칙 엔진 등에서 활용됩니다.</p><h2 id=3-전체-개요-250자-내외>3. 전체 개요 (250자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250자-내외>#</a></h2><p>Interpreter Pattern은 도메인 특화 언어(DSL)나 간단한 문법을 해석하기 위한 디자인 패턴입니다. 각 문법 규칙을 별도의 클래스로 모델링하여 해석기를 구성합니다. 터미널 표현식과 비터미널 표현식으로 구분되며, Composite 패턴과 함께 사용하여 계층적 구조를 형성합니다. 유연성과 확장성이 뛰어나지만 복잡한 문법에서는 성능 이슈가 있을 수 있습니다.</p><hr><h2 id=제1부-핵심-개념-및-이론적-배경>제1부: 핵심 개념 및 이론적 배경<a hidden class=anchor aria-hidden=true href=#제1부-핵심-개념-및-이론적-배경>#</a></h2><h3 id=핵심-개념-1>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념-1>#</a></h3><p><strong>Interpreter Pattern</strong>은 특정 언어의 문법을 정의하고, 그 문법을 사용하여 작성된 문장들을 해석하는 방법을 제공하는 행동 디자인 패턴입니다. 이 패턴의 핵심 아이디어는 언어의 각 문법 규칙을 별도의 클래스로 표현하는 것입니다.</p><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>Interpreter Pattern은 다음과 같은 상황에서 등장했습니다:</p><ul><li>특정 도메인에서 반복적으로 발생하는 문제를 간단한 언어로 표현할 필요성</li><li>SQL, 정규 표현식, 수학적 표현식 등의 해석 필요</li><li>컴파일러와 인터프리터 이론의 객체지향적 구현</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ol><li><strong>언어 정의</strong>: 도메인 특화 언어(DSL)의 문법을 명확히 정의</li><li><strong>해석 메커니즘</strong>: 정의된 문법에 따라 문장을 해석하는 방법 제공</li><li><strong>확장성</strong>: 새로운 문법 규칙을 쉽게 추가할 수 있는 구조 제공</li><li><strong>재사용성</strong>: 동일한 문법을 다양한 컨텍스트에서 재사용</li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li><strong>문법 표현</strong>: 각 문법 규칙을 클래스로 모델링</li><li><strong>표현식 해석</strong>: interpret() 메서드를 통한 표현식 평가</li><li><strong>컨텍스트 관리</strong>: 해석 과정에서 필요한 상태 정보 유지</li><li><strong>계층적 구조</strong>: Composite 패턴을 활용한 트리 구조 형성</li></ul><hr><h2 id=제2부-구조-및-아키텍처>제2부: 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#제2부-구조-및-아키텍처>#</a></h2><h3 id=구조-및-아키텍처-1>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처-1>#</a></h3><p>Interpreter Pattern의 구조는 다음과 같은 핵심 구성 요소들로 이루어집니다:</p><h4 id=필수-구성요소>필수 구성요소<a hidden class=anchor aria-hidden=true href=#필수-구성요소>#</a></h4><ol><li><p><strong>AbstractExpression (추상 표현식)</strong></p><ul><li>기능: 모든 구체적 표현식이 구현해야 할 공통 인터페이스 정의</li><li>역할: interpret(Context) 메서드 선언</li><li>특징: 추상 클래스 또는 인터페이스로 구현</li></ul></li><li><p><strong>TerminalExpression (터미널 표현식)</strong></p><ul><li>기능: 문법의 터미널 심볼 표현</li><li>역할: 기본적인 해석 로직 구현</li><li>특징: 더 이상 분해되지 않는 표현식 (리프 노드)</li></ul></li><li><p><strong>NonTerminalExpression (비터미널 표현식)</strong></p><ul><li>기능: 복합 표현식 처리</li><li>역할: 하위 표현식들을 조합하여 해석</li><li>특징: 다른 표현식들을 참조하는 복합 노드</li></ul></li><li><p><strong>Context (컨텍스트)</strong></p><ul><li>기능: 해석 과정의 전역 정보 저장</li><li>역할: 해석에 필요한 상태 정보 관리</li><li>특징: 입력 스트림, 변수 값, 결과 등 포함</li></ul></li></ol><h4 id=선택-구성요소>선택 구성요소<a hidden class=anchor aria-hidden=true href=#선택-구성요소>#</a></h4><ol start=5><li><strong>Client (클라이언트)</strong><ul><li>기능: 추상 구문 트리(AST) 생성 및 해석 요청</li><li>역할: 패턴 사용을 위한 진입점 제공</li><li>특징: 파서 기능을 포함할 수 있음</li></ul></li></ol><h3 id=주요-원리-및-작동-원리-1>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리-1>#</a></h3><p>Interpreter Pattern의 작동 원리는 다음과 같습니다:</p><ol><li><strong>문법 분석</strong>: 입력 문장을 토큰으로 분해</li><li><strong>AST 구성</strong>: 토큰들을 추상 구문 트리로 조직화</li><li><strong>재귀적 해석</strong>: 트리를 순회하며 각 노드에서 interpret() 호출</li><li><strong>결과 반환</strong>: 해석된 결과를 컨텍스트를 통해 반환</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>문법: expression = term (&#39;+&#39; | &#39;-&#39;) term
</span></span><span class=line><span class=cl>      term = factor (&#39;*&#39; | &#39;/&#39;) factor  
</span></span><span class=line><span class=cl>      factor = number | &#39;(&#39; expression &#39;)&#39;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>입력: &#34;3 + 4 * 2&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>AST 구조:
</span></span><span class=line><span class=cl>    +
</span></span><span class=line><span class=cl>   / \
</span></span><span class=line><span class=cl>  3   *
</span></span><span class=line><span class=cl>     / \
</span></span><span class=line><span class=cl>    4   2
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=제3부-구현-및-활용>제3부: 구현 및 활용<a hidden class=anchor aria-hidden=true href=#제3부-구현-및-활용>#</a></h2><h3 id=구현-기법-1>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법-1>#</a></h3><h4 id=1-기본-해석-방식-basic-interpretation>1. 기본 해석 방식 (Basic Interpretation)<a hidden class=anchor aria-hidden=true href=#1-기본-해석-방식-basic-interpretation>#</a></h4><ul><li><strong>정의</strong>: 각 표현식 클래스에서 직접 해석 로직 구현</li><li><strong>구성</strong>: AbstractExpression, ConcreteExpression 클래스들</li><li><strong>목적</strong>: 단순한 문법의 직접적 해석</li><li><strong>예시</strong>: 수학 표현식 계산기</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 예시 구현</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>NumberExpression</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>number</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>number</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>AddExpression</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Expression</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>interpret</span><span class=p>(</span><span class=n>Context</span><span class=w> </span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>left</span><span class=p>.</span><span class=na>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>right</span><span class=p>.</span><span class=na>interpret</span><span class=p>(</span><span class=n>context</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=2-컨텍스트-기반-해석-context-based-interpretation>2. 컨텍스트 기반 해석 (Context-based Interpretation)<a hidden class=anchor aria-hidden=true href=#2-컨텍스트-기반-해석-context-based-interpretation>#</a></h4><ul><li><strong>정의</strong>: 컨텍스트 객체를 통한 상태 관리형 해석</li><li><strong>구성</strong>: Context 클래스와 상태 관리 로직</li><li><strong>목적</strong>: 복잡한 상태가 필요한 해석</li><li><strong>예시</strong>: 변수가 포함된 표현식 해석</li></ul><h4 id=3-방문자-패턴-결합-visitor-pattern-integration>3. 방문자 패턴 결합 (Visitor Pattern Integration)<a hidden class=anchor aria-hidden=true href=#3-방문자-패턴-결합-visitor-pattern-integration>#</a></h4><ul><li><strong>정의</strong>: Visitor 패턴과 결합하여 해석 로직 분리</li><li><strong>구성</strong>: Visitor 인터페이스와 ConcreteVisitor 클래스들</li><li><strong>목적</strong>: 해석 로직의 외부화 및 다양한 연산 지원</li><li><strong>예시</strong>: AST 순회 및 다중 연산 지원</li></ul><h3 id=분류에-따른-종류-및-유형-1>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형-1>#</a></h3><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th><th>특징</th></tr></thead><tbody><tr><td>해석 방식</td><td>직접 해석</td><td>클래스 내부에서 직접 해석</td><td>단순하고 빠름</td></tr><tr><td></td><td>간접 해석</td><td>별도 해석기를 통한 해석</td><td>유연하고 확장 가능</td></tr><tr><td>구조 복잡성</td><td>단순 해석기</td><td>터미널 표현식 중심</td><td>기본적인 문법만 지원</td></tr><tr><td></td><td>복합 해석기</td><td>비터미널 표현식 포함</td><td>복잡한 중첩 구조 지원</td></tr><tr><td>실행 방식</td><td>즉시 실행</td><td>해석과 동시에 실행</td><td>빠른 응답시간</td></tr><tr><td></td><td>지연 실행</td><td>AST 구성 후 별도 실행</td><td>최적화 가능</td></tr></tbody></table><h3 id=실무-적용-예시-1>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시-1>#</a></h3><table><thead><tr><th>분야</th><th>적용 사례</th><th>구현 내용</th><th>특징</th></tr></thead><tbody><tr><td>데이터베이스</td><td>SQL 파싱</td><td>SELECT, WHERE 절 해석</td><td>복잡한 쿼리 구조 지원</td></tr><tr><td>비즈니스 규칙</td><td>규칙 엔진</td><td>조건-행동 규칙 처리</td><td>동적 규칙 변경 가능</td></tr><tr><td>설정 관리</td><td>설정 파일 파서</td><td>XML, JSON 구조 해석</td><td>계층적 설정 구조</td></tr><tr><td>수학 계산</td><td>수식 계산기</td><td>사칙연산, 함수 처리</td><td>연산자 우선순위 지원</td></tr><tr><td>스크립팅</td><td>도메인 스크립트</td><td>게임 스크립트 해석</td><td>도메인 특화 명령어</td></tr></tbody></table><h3 id=장점과-단점-1>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>확장성</td><td>새로운 문법 규칙을 쉽게 추가 가능</td></tr><tr><td></td><td>유연성</td><td>런타임에 표현식 구조를 변경할 수 있음</td></tr><tr><td></td><td>재사용성</td><td>동일한 문법을 다양한 컨텍스트에서 활용</td></tr><tr><td></td><td>모듈성</td><td>각 문법 규칙이 독립적인 클래스로 분리</td></tr><tr><td></td><td>테스트 용이성</td><td>각 표현식을 독립적으로 테스트 가능</td></tr><tr><td>⚠ 단점</td><td>성능 오버헤드</td><td>재귀적 호출로 인한 성능 저하</td></tr><tr><td></td><td>클래스 증가</td><td>문법 규칙마다 클래스 생성 필요</td></tr><tr><td></td><td>복잡성 증가</td><td>복잡한 문법에서 관리 어려움</td></tr><tr><td></td><td>메모리 사용량</td><td>AST 구성으로 인한 메모리 오버헤드</td></tr><tr><td></td><td>디버깅 어려움</td><td>깊은 재귀 구조로 디버깅 복잡</td></tr></tbody></table><hr><h2 id=제4부-고급-주제-및-최신-동향>제4부: 고급 주제 및 최신 동향<a hidden class=anchor aria-hidden=true href=#제4부-고급-주제-및-최신-동향>#</a></h2><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><ol><li><p><strong>성능 최적화</strong></p><ul><li>문제: 복잡한 표현식에서 재귀 호출 오버헤드</li><li>해결책: AST 캐싱, 컴파일 최적화, JIT 컴파일</li></ul></li><li><p><strong>복잡한 문법 처리</strong></p><ul><li>문제: 많은 문법 규칙으로 인한 클래스 폭증</li><li>해결책: 파서 생성기 사용, 메타 프로그래밍 활용</li></ul></li><li><p><strong>메모리 관리</strong></p><ul><li>문제: 대용량 AST로 인한 메모리 부족</li><li>해결책: 스트리밍 해석, 부분 평가, 가비지 컬렉션 최적화</li></ul></li></ol><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>문법 복잡도 평가</td><td>해석할 언어의 복잡도 사전 분석</td><td>단순한 문법에만 적용, 복잡한 경우 파서 생성기 검토</td></tr><tr><td>성능 요구사항</td><td>실시간 처리 필요성 검토</td><td>성능 중요 시 컴파일 방식 고려</td></tr><tr><td>확장성 계획</td><td>향후 문법 확장 가능성 분석</td><td>확장 가능한 구조로 초기 설계</td></tr><tr><td>테스트 전략</td><td>표현식별 독립 테스트 계획</td><td>단위 테스트와 통합 테스트 병행</td></tr><tr><td>오류 처리</td><td>잘못된 문법에 대한 대응</td><td>명확한 오류 메시지와 복구 전략</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>최적화 항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>AST 캐싱</td><td>동일한 표현식 재사용</td><td>LRU 캐시나 WeakReference 활용</td></tr><tr><td>조기 평가</td><td>상수 표현식 사전 계산</td><td>컴파일 타임 최적화 적용</td></tr><tr><td>메모리 풀링</td><td>객체 재사용을 통한 GC 압박 감소</td><td>Object Pool 패턴 적용</td></tr><tr><td>스트리밍 처리</td><td>대용량 입력의 부분 처리</td><td>Iterator 패턴과 결합</td></tr><tr><td>병렬 처리</td><td>독립적 표현식의 병렬 평가</td><td>Fork-Join 프레임워크 활용</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><p><strong>시나리오: E-commerce 할인 규칙 엔진</strong></p><p>한 온라인 쇼핑몰에서 복잡한 할인 규칙을 동적으로 적용해야 하는 상황을 가정합니다.</p><p><strong>시스템 구성:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8>8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트 애플리케이션
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>   규칙 파서 (Parser)
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>   할인 규칙 AST
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>   할인 계산 엔진 (Interpreter)
</span></span><span class=line><span class=cl>        ↓
</span></span><span class=line><span class=cl>   할인 결과 반환
</span></span></code></pre></td></tr></table></div></div><p><strong>활용 사례 Workflow:</strong></p><ol><li><strong>규칙 정의</strong>: &ldquo;IF (고객등급 = &lsquo;VIP&rsquo; AND 구매금액 > 100000) THEN 할인율 = 15%&rdquo;</li><li><strong>파싱</strong>: 규칙을 토큰으로 분해하고 AST 구성</li><li><strong>해석</strong>: 고객 정보를 컨텍스트로 하여 규칙 평가</li><li><strong>적용</strong>: 계산된 할인율을 주문에 적용</li></ol><p><strong>시스템 구성 다이어그램:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[클라이언트] -&gt; [규칙파서] -&gt; [AST빌더] -&gt; [인터프리터] -&gt; [할인엔진]
</span></span><span class=line><span class=cl>     ↑                                              ↓
</span></span><span class=line><span class=cl>[비즈니스규칙] &lt;------ [컨텍스트] &lt;------ [고객정보]
</span></span></code></pre></td></tr></table></div></div><p><strong>역할:</strong></p><ul><li><strong>유연성</strong>: 마케팅팀이 코드 수정 없이 규칙 변경 가능</li><li><strong>확장성</strong>: 새로운 할인 조건을 쉽게 추가</li><li><strong>유지보수성</strong>: 각 규칙이 독립적으로 관리됨</li></ul><h3 id=2025년-기준-최신-동향>2025년 기준 최신 동향<a hidden class=anchor aria-hidden=true href=#2025년-기준-최신-동향>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>AI 통합</td><td>자연어 처리 기반 규칙 생성</td><td>LLM을 활용한 자연어 → DSL 변환</td></tr><tr><td>클라우드 네이티브</td><td>서버리스 규칙 엔진</td><td>AWS Lambda, Azure Functions 기반 해석기</td></tr><tr><td>실시간 처리</td><td>스트리밍 인터프리터</td><td>Apache Kafka, Apache Flink와 통합</td></tr><tr><td>보안 강화</td><td>샌드박스 실행 환경</td><td>안전한 DSL 실행을 위한 격리 환경</td></tr><tr><td>성능 최적화</td><td>JIT 컴파일레이션</td><td>GraalVM, 동적 최적화 기술 적용</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용-1>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용-1>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>언어 설계</td><td>Domain-Specific Language</td><td>특정 도메인에 최적화된 언어 설계</td></tr><tr><td>컴파일러 기술</td><td>ANTLR, Yacc/Bison</td><td>파서 생성기와의 통합 활용</td></tr><tr><td>함수형 프로그래밍</td><td>불변성 기반 해석</td><td>함수형 언어의 패턴 매칭 활용</td></tr><tr><td>메타프로그래밍</td><td>코드 생성 기술</td><td>런타임 코드 생성과 최적화</td></tr><tr><td>마이크로서비스</td><td>분산 규칙 처리</td><td>규칙별 마이크로서비스 분리</td></tr></tbody></table><h3 id=앞으로의-전망-1>앞으로의 전망<a hidden class=anchor aria-hidden=true href=#앞으로의-전망-1>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>자동화</td><td>규칙 자동 생성</td><td>머신러닝 기반 규칙 자동 추출</td></tr><tr><td>통합</td><td>로우코드/노코드 플랫폼</td><td>비개발자도 사용 가능한 시각적 규칙 편집기</td></tr><tr><td>성능</td><td>하드웨어 가속</td><td>GPU, FPGA를 활용한 병렬 해석</td></tr><tr><td>표준화</td><td>산업 표준 DSL</td><td>도메인별 표준 DSL 언어 정립</td></tr><tr><td>보안</td><td>제로 트러스트 실행</td><td>보안이 강화된 샌드박스 실행 환경</td></tr></tbody></table><h3 id=하위-주제로-추가-학습할-내용>하위 주제로 추가 학습할 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-추가-학습할-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>컴파일러 이론</td><td>파싱 알고리즘</td><td>LL, LR, LALR 파서 구현</td></tr><tr><td></td><td>어휘 분석</td><td>토크나이저, 렉서 구현 기법</td></tr><tr><td>언어 설계</td><td>DSL 설계 원칙</td><td>도메인 특화 언어 설계 방법론</td></tr><tr><td></td><td>문법 정의</td><td>BNF, EBNF 문법 표기법</td></tr><tr><td>성능 최적화</td><td>AST 최적화</td><td>트리 변환 및 최적화 기법</td></tr><tr><td></td><td>메모리 관리</td><td>가비지 컬렉션, 메모리 풀링</td></tr></tbody></table><h3 id=관련-분야-추가-학습-내용>관련 분야 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야-추가-학습-내용>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>소프트웨어 아키텍처</td><td>마이크로서비스 패턴</td><td>분산 시스템에서의 규칙 처리</td></tr><tr><td>데이터베이스</td><td>쿼리 최적화</td><td>SQL 실행 계획 최적화 기법</td></tr><tr><td>머신러닝</td><td>자연어 처리</td><td>텍스트 파싱 및 의미 분석</td></tr><tr><td>보안</td><td>코드 분석</td><td>정적/동적 코드 분석 도구</td></tr><tr><td>DevOps</td><td>지속적 통합</td><td>규칙 변경의 자동 배포</td></tr></tbody></table><hr><h2 id=용어-정리-3>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-3>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Abstract Syntax Tree (AST)</td><td>프로그램의 구문 구조를 나타내는 트리 자료구조로, 소스 코드의 추상적 구문 표현</td></tr><tr><td>Domain-Specific Language (DSL)</td><td>특정 도메인이나 문제 영역에 특화된 컴퓨터 언어</td></tr><tr><td>Terminal Expression</td><td>더 이상 분해되지 않는 기본 표현식으로, AST의 리프 노드에 해당</td></tr><tr><td>Non-Terminal Expression</td><td>다른 표현식들을 조합하여 구성되는 복합 표현식</td></tr><tr><td>Grammar</td><td>언어의 구문 규칙을 정의하는 형식적 규칙 집합</td></tr><tr><td>Lexical Analysis</td><td>소스 코드를 토큰으로 분해하는 컴파일러의 첫 번째 단계</td></tr><tr><td>Parser Generator</td><td>문법 정의로부터 파서를 자동 생성하는 도구 (예: ANTLR, Yacc)</td></tr><tr><td>Context</td><td>해석 과정에서 필요한 전역 상태나 변수를 저장하는 객체</td></tr><tr><td>Double Dispatch</td><td>두 개의 다형성 디스패치를 통해 메서드 호출을 결정하는 기법</td></tr><tr><td>Tree Walking</td><td>AST를 순회하면서 각 노드를 방문하는 알고리즘</td></tr></tbody></table><hr><h2 id=참고-및-출처-3>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-3>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Interpreter_pattern>Wikipedia - Interpreter Pattern</a></li><li><a href=https://www.geeksforgeeks.org/interpreter-design-pattern/>GeeksforGeeks - Interpreter Design Pattern</a></li><li><a href=https://sourcemaking.com/design_patterns/interpreter>Source Making - Interpreter Pattern</a></li><li><a href=https://www.tutorialspoint.com/design_pattern/interpreter_pattern.htm>TutorialsPoint - Interpreter Pattern</a></li><li><a href=https://springframework.guru/gang-of-four-design-patterns/interpreter-pattern/>Spring Framework Guru - Interpreter Pattern</a></li><li><a href=https://www.baeldung.com/java-interpreter-pattern>Baeldung - Interpreter Design Pattern in Java</a></li><li><a href=https://craftinginterpreters.com/a-tree-walk-interpreter.html>Crafting Interpreters - Tree-Walk Interpreter</a></li><li><a href=https://www.momentslog.com/development/design-pattern/interpreter-pattern-in-query-languages-sql-parsing>Moments Log - Interpreter Pattern in SQL Parsing</a></li><li><a href=https://curatepartners.com/blogs/skills-tools-platforms/mastering-the-interpreter-pattern-enhancing-flexibility-in-domain-specific-language-processing/>Curate Partners - Mastering the Interpreter Pattern</a></li><li><a href=https://incusdata.com/blog/design-patterns-interpreter-pattern-part1>Incus Data - Interpreter Pattern Guide</a></li></ul></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>