<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hollywood Principle | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles,Inversion-of-Control,Hollywood-Principle"><meta name=description content="Hollywood Principle 은 &#34;Don't call us, we'll call you&#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/hollywood-principle/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/hollywood-principle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/hollywood-principle/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hollywood Principle"><meta property="og:description" content="Hollywood Principle 은 &#34;Don't call us, we'll call you&#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-04T14:27:00+00:00"><meta property="article:modified_time" content="2025-02-04T14:27:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="Principles"><meta property="article:tag" content="Design-Principles"><meta property="article:tag" content="Inversion-of-Control"><meta property="article:tag" content="Hollywood-Principle"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hollywood Principle"><meta name=twitter:description content="Hollywood Principle 은 &#34;Don't call us, we'll call you&#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/"},{"@type":"ListItem","position":5,"name":"Inversion of Control","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/"},{"@type":"ListItem","position":6,"name":"Hollywood Principle","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/hollywood-principle/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hollywood Principle","name":"Hollywood Principle","description":"Hollywood Principle 은 \"Don't call us, we'll call you\" 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.","keywords":["System-and-Software-Architecture","Principles","Design-Principles","Inversion-of-Control","Hollywood-Principle"],"articleBody":"Hollywood Principle Hollywood Principle 은 객체지향 설계 및 프레임워크 설계에서 널리 쓰이는 원칙으로, “Don’t call us, we’ll call you” 라는 문구로 대표된다. 이 원칙은 저수준 (구현) 모듈이 고수준 (프레임워크, 추상화) 모듈을 직접 호출하는 것이 아니라, 고수준 모듈이 저수준 모듈을 필요할 때 호출하도록 구조를 설계한다. 이를 통해 의존성 부패 (Dependency Rot) 를 방지하고, 시스템의 유연성, 확장성, 테스트 용이성을 높인다. 대표적으로 Inversion of Control, Dependency Injection, Observer, Template Method, Strategy 패턴 등에서 적용된다.\n핵심 개념 Hollywood Principle 은 **“Don’t call us, we’ll call you”**라는 문구로 요약되며, 저수준 컴포넌트는 고수준 컴포넌트의 호출을 기다리는 방식으로 제어 흐름을 관리한다. 느슨한 결합, 의존성 부패 방지, 확장성 및 테스트 용이성 확보를 목적으로 하며 프레임워크 설계, 이벤트 기반 시스템, 디자인 패턴 (Observer, Template Method, Strategy 등) 에 적용된다.\n제어의 역전 (Inversion of Control, IoC) 프로그램의 제어 흐름이 애플리케이션 코드가 아닌 외부 프레임워크에서 결정되는 원칙 전통적인 “call” 방식에서 “callback” 방식으로의 패러다임 전환 콜백 메커니즘 (Callback Mechanism) 특정 이벤트나 조건 발생 시 자동으로 호출되는 함수나 메서드 비동기 프로그래밍과 이벤트 처리의 핵심 메커니즘 의존성 주입 (Dependency Injection, DI) 객체가 필요한 의존성을 생성하지 않고 외부에서 제공받는 방식 객체 생성과 사용의 책임을 분리하여 결합도를 낮춤 이벤트 기반 아키텍처 (Event-driven Architecture) 이벤트의 발생과 처리를 중심으로 시스템을 설계하는 방식 Publisher-Subscriber 패턴의 기반이 되는 아키텍처 스타일 느슨한 결합 (Loose Coupling) 컴포넌트 간 의존성을 최소화하여 변경에 대한 영향을 줄이는 설계 방식 높은 응집도 (High Cohesion) 와 함께 소프트웨어 품질의 핵심 지표 프레임워크 vs 라이브러리 구분 프레임워크: 애플리케이션 코드를 호출하는 주체 라이브러리: 애플리케이션 코드에 의해 호출되는 대상 Publisher-Subscriber 패턴 이벤트 발행자와 구독자 간의 비동기 통신을 지원하는 패턴 일대다 통신과 느슨한 결합을 동시에 실현 배경 및 필요성 Hollywood Principle 은 1980 년대 후반 객체지향 프로그래밍의 발전과 함께 등장했다. Martin Fowler 가 1988 년으로 그 기원을 추적하였으며, 할리우드 오디션에서 흔히 듣는 “Don’t call us, we’ll call you” 문구에서 이름이 유래되었다.\n필요성:\n코드의 재사용성 향상 컴포넌트 간 결합도 감소 테스트 가능성 증대 확장성과 유지보수성 개선 관심사의 분리 실현 주요 기능 및 역할 제어 흐름 관리: 프레임워크가 애플리케이션의 실행 흐름을 제어 의존성 관리: 객체 간 의존성을 외부에서 주입하여 관리 이벤트 처리: 비동기적 이벤트 발생과 처리를 조율 생명주기 관리: 객체의 생성, 초기화, 소멸을 프레임워크가 관리 확장점 제공: 플러그인이나 확장 모듈을 위한 훅 (Hook) 제공 특징 비침입적 (Non-intrusive): 비즈니스 로직에 프레임워크 코드가 침투하지 않음 선언적 (Declarative): 설정이나 어노테이션을 통한 선언적 프로그래밍 확장가능 (Extensible): 새로운 구현체를 쉽게 추가할 수 있는 구조 테스트 친화적: Mock 객체를 쉽게 주입하여 단위 테스트 용이 핵심 원칙 “Don’t call us, we’ll call you”: 능동적 호출에서 수동적 대기로의 전환 제어권 위임: 애플리케이션 코드가 제어권을 프레임워크에 위임 인터페이스 기반 설계: 구체 클래스 대신 인터페이스에 의존 관심사 분리: 비즈니스 로직과 인프라스트럭처 코드의 분리 작동 원리 저수준 컴포넌트 (플러그인, 리스너 등) 는 고수준 컴포넌트에 등록만 한다. 고수준 컴포넌트 (프레임워크, 이벤트 디스패처 등) 가 필요할 때 저수준 컴포넌트를 호출한다. sequenceDiagram participant Client as Client Code participant Framework as Framework participant Callback as Callback Handler Note over Client,Callback: 1. 등록 단계 (Registration Phase) Client-\u003e\u003eFramework: register(callback) Framework-\u003e\u003eFramework: store callback in registry Note over Framework: 2. 대기 단계 (Waiting Phase) Note over Framework: Framework waits for events/conditions Note over Framework: 3. 트리거 단계 (Triggering Phase) Framework-\u003e\u003eFramework: Internal event occurs Note over Framework,Callback: 4. 호출 단계 (Invocation Phase) Framework-\u003e\u003eCallback: \"Don't call us, we'll call you\" Note over Callback: 5. 실행 단계 (Execution Phase) Callback-\u003e\u003eCallback: Execute business logic Note over Framework: 6. 반환 단계 (Return Phase) Callback-\u003e\u003eFramework: Return control/result Framework-\u003e\u003eClient: Optional: notify completion Hollywood Principle 의 작동 원리는 다음과 같은 단계로 구성된다:\n등록 단계 (Registration): 클라이언트 코드가 프레임워크에 콜백이나 핸들러를 등록 대기 단계 (Waiting): 클라이언트는 능동적으로 호출하지 않고 대기 트리거 단계 (Triggering): 프레임워크 내부에서 특정 이벤트나 조건 발생 호출 단계 (Invocation): 프레임워크가 등록된 콜백을 호출 실행 단계 (Execution): 클라이언트의 비즈니스 로직 실행 반환 단계 (Return): 제어권이 프레임워크로 돌아감 구조 및 아키텍처 Hollywood Principle 은 고수준 모듈이 제어 흐름을 담당하고 저수준 모듈은 콜백, 이벤트 등록, 추상 클래스 상속 등을 통해 호출될 수 있는 상태를 유지하는 구조이다.\ngraph TB subgraph \"Hollywood Principle 전체 아키텍처\" Framework[Framework/Container] subgraph \"필수 구성요소 (Essential Components)\" Registry[Callback Registry] EventManager[Event Manager] LifecycleManager[Lifecycle Manager] end subgraph \"선택 구성요소 (Optional Components)\" ConfigManager[Configuration Manager] SecurityManager[Security Manager] MonitoringManager[Monitoring Manager] end subgraph \"클라이언트 구성요소 (Client Components)\" ClientCode[Client Code] CallbackHandlers[Callback Handlers] EventListeners[Event Listeners] end Framework --\u003e Registry Framework --\u003e EventManager Framework --\u003e LifecycleManager Framework -.-\u003e ConfigManager Framework -.-\u003e SecurityManager Framework -.-\u003e MonitoringManager ClientCode --\u003e CallbackHandlers ClientCode --\u003e EventListeners Registry --\u003e CallbackHandlers EventManager --\u003e EventListeners LifecycleManager --\u003e ClientCode style Framework fill:#e8f5e8 style Registry fill:#e3f2fd style EventManager fill:#e3f2fd style LifecycleManager fill:#e3f2fd style ConfigManager fill:#fff3e0 style SecurityManager fill:#fff3e0 style MonitoringManager fill:#fff3e0 style ClientCode fill:#fce4ec style CallbackHandlers fill:#f3e5f5 style EventListeners fill:#f3e5f5 end 구성요소 구분 구성요소 기능 설명 역할 및 특징 필수 Framework / Container(프레임워크 / 컨테이너) 시스템 전체 제어 흐름 담당콜백 실행, 생명주기 전반 제어 중앙 제어권 보유, 실행 흐름 결정 Callback Registry(콜백 레지스트리) 콜백 함수 등록/해제/관리 동적 콜백 관리로 유연성 제공 Event Manager(이벤트 매니저) 이벤트 발생/전파/처리이벤트 큐 및 리스너 관리 비동기 이벤트 처리 지원 Lifecycle Manager(생명주기 매니저) 객체 생성~소멸까지 관리의존성 주입 시점 통제 리소스/의존성 관리, 전체 생명주기 제어 선택 Configuration Manager(설정 매니저) 설정 파일 로딩 및 설정 값 관리 런타임 설정 변경 지원 Security Manager(보안 매니저) 인증/인가, 접근 제어 수행 **AOP(관심사 분리)**에 적합 Monitoring Manager(모니터링 매니저) 성능 지표 수집, 로깅, 시스템 상태 추적 실시간 모니터링 및 경보 시스템 연동 구현 기법 구분 패턴 / 기법 개념 요약 제어 흐름 목적 대표 기술 / 예시 의존성 주입 Dependency Injection (DI) 의존 객체 생성을 외부에서 주입 객체 생성 제어권 → 컨테이너 결합도 감소, 테스트 용이성 향상 Spring, NestJS, Angular, Guice 관찰자 패턴 Observer Pattern 상태 변화 발생 시 등록된 리스너에 자동 통보 알림 제어권 → Subject 상태 변화 감지, 다대일 연동 EventEmitter, addEventListener 템플릿 메서드 Template Method Pattern 알고리즘의 뼈대를 상위 클래스가 정의하고, 하위 클래스가 구현 알고리즘 순서 제어권 → 추상 클래스 알고리즘 재사용성, 확장성 Spring JdbcTemplate, React Lifecycle 이벤트 기반 Event-driven Programming 이벤트가 발생하면 리스너 또는 핸들러가 비동기적으로 반응 흐름 제어권 → 이벤트 루프/큐 느슨한 결합, 비동기 흐름 처리 Node.js, Kafka, AWS EventBridge 전략 패턴 Strategy Pattern 실행 알고리즘을 객체로 분리하고 유연하게 교체 실행 제어권 → 외부 전략 객체 런타임 유연성, 조건별 실행 방식 분리 Array.prototype.sort(callback) 서비스 등록소 Service Locator Pattern 객체를 전역 등록소에서 가져다 씀 (DI 의 대안적 방식) 의존성 해결 제어권 → Locator 의존성 중앙 관리 Unity Container, InversifyJS 이벤트 버스 Event Bus / Message Bus 메시지 중심으로 컴포넌트 간 통신 메시지 흐름 제어권 → 중앙 버스 컴포넌트 간 결합도 제거 Vue EventBus, RabbitMQ, EventBridge 콜백 등록 Callback Registry 콜백 함수를 동적으로 등록 및 해제 가능 호출 시점 제어권 → 외부 등록자 유연한 이벤트 대응 구조 jQuery .on(), Node.js callbacks 생명주기 관리 Lifecycle Management 객체 생성~소멸 주기를 일관되게 관리 자원 생명 제어권 → 컨테이너 자원 누수 방지, 예측 가능한 상태 전환 React, Angular, Spring Context Dependency Injection (의존성 주입) 제어 역전: 객체 생성과 의존성 주입을 컨테이너가 담당 핵심: \" 객체를 직접 생성하지 말고, 주입받아 사용하세요 \" graph TD subgraph \"Dependency Injection Pattern\" DI_Container[DI Container] DI_Service[Service Interface] DI_ServiceImpl[Service Implementation] DI_Client[Client Class] DI_Container --\u003e|creates \u0026 injects| DI_ServiceImpl DI_Container --\u003e|creates \u0026 injects| DI_Client DI_Client -.-\u003e|depends on| DI_Service DI_ServiceImpl -.-\u003e|implements| DI_Service style DI_Container fill:#e8f5e8 style DI_Service fill:#e3f2fd style DI_ServiceImpl fill:#fff3e0 style DI_Client fill:#fce4ec end 정의: 객체가 필요한 의존성을 생성하지 않고 외부에서 주입받는 기법\n구성:\nInjector (주입자): 의존성을 제공하는 주체 Service (서비스): 주입될 의존성 객체 Client (클라이언트): 의존성을 필요로 하는 객체 목적: 객체 생성과 사용의 책임 분리, 결합도 감소\n실제 예시:\n1 2 3 4 5 6 7 8 9 10 // Spring Framework 예시 @Service public class OrderService { private final PaymentService paymentService; // 생성자 주입 public OrderService(PaymentService paymentService) { this.paymentService = paymentService; } } Observer Pattern (관찰자 패턴) 제어 역전: 상태 변화 알림을 Subject 가 주도 핵심: \" 변화를 감지하면 우리가 알려드리겠습니다 \" graph TD subgraph \"Observer Pattern\" Subject[Subject] Observer1[Observer 1] Observer2[Observer 2] ObserverN[Observer N] Subject --\u003e|\"notifyObservers()\"| Observer1 Subject --\u003e|\"notifyObservers()\"| Observer2 Subject --\u003e|\"notifyObservers()\"| ObserverN Observer1 -.-\u003e|subscribe| Subject Observer2 -.-\u003e|subscribe| Subject ObserverN -.-\u003e|subscribe| Subject style Subject fill:#e8f5e8 style Observer1 fill:#e3f2fd style Observer2 fill:#e3f2fd style ObserverN fill:#e3f2fd end 정의: 객체의 상태 변화를 여러 관찰자에게 자동으로 알리는 패턴\n구성:\nSubject (주제): 상태 변화의 주체 Observer (관찰자): 변화를 감지하고 처리하는 객체 목적: 일대다 의존성 정의, 느슨한 결합 실현\n실제 예시:\n1 2 3 4 5 6 7 8 9 // JavaScript EventEmitter 예시 const EventEmitter = require('events'); const emitter = new EventEmitter(); emitter.on('dataChanged', (data) =\u003e { console.log('Data updated:', data); }); emitter.emit('dataChanged', { id: 1, value: 'new data' }); Template Method Pattern (템플릿 메서드 패턴) 제어 역전: 알고리즘 실행 순서를 상위 클래스가 제어 핵심: \" 전체 흐름은 우리가 관리하고, 세부사항만 구현하세요 \" graph TD subgraph \"Template Method Pattern\" AbstractClass[Abstract Template Class] ConcreteClass1[Concrete Class 1] ConcreteClass2[Concrete Class 2] AbstractClass --\u003e|calls| Hook1[\"primitiveOperation1()\"] AbstractClass --\u003e|calls| Hook2[\"primitiveOperation2()\"] ConcreteClass1 -.-\u003e|implements| Hook1 ConcreteClass2 -.-\u003e|implements| Hook2 ConcreteClass1 --\u003e|extends| AbstractClass ConcreteClass2 --\u003e|extends| AbstractClass style AbstractClass fill:#e8f5e8 style ConcreteClass1 fill:#e3f2fd style ConcreteClass2 fill:#e3f2fd style Hook1 fill:#fff3e0 style Hook2 fill:#fff3e0 end 정의: 알고리즘의 골격을 정의하고 하위 클래스에서 세부 단계를 구현하는 패턴\n구성:\nAbstract Class (추상 클래스): 템플릿 메서드 정의 Concrete Class (구체 클래스): 세부 단계 구현 목적: 알고리즘 구조 고정, 세부 구현의 변경 허용\n실제 예시:\n1 2 3 4 5 6 7 8 9 // Spring JdbcTemplate 예시 public abstract class JdbcTemplate { public final List\u003cT\u003e query(String sql, RowMapper\u003cT\u003e mapper) { // 1. 연결 획득 // 2. SQL 실행 // 3. 결과 처리 (mapper 콜백 호출) // 4. 연결 해제 } } Event-driven Programming (이벤트 기반 프로그래밍) 제어 역전: 이벤트 발생과 처리를 이벤트 버스가 조율 핵심: \" 이벤트가 발생하면 우리가 처리하겠습니다 \" graph TD subgraph \"Event-Driven Pattern\" EventProducer[Event Producer] EventBus[Event Bus] EventConsumer1[Event Consumer 1] EventConsumer2[Event Consumer 2] EventQueue[Event Queue] EventProducer --\u003e|publish| EventBus EventBus --\u003e|enqueue| EventQueue EventQueue --\u003e|dispatch| EventConsumer1 EventQueue --\u003e|dispatch| EventConsumer2 EventConsumer1 -.-\u003e|subscribe| EventBus EventConsumer2 -.-\u003e|subscribe| EventBus style EventProducer fill:#e8f5e8 style EventBus fill:#e3f2fd style EventQueue fill:#fff3e0 style EventConsumer1 fill:#fce4ec style EventConsumer2 fill:#fce4ec end 정의: 이벤트 발생에 따라 프로그램 흐름이 결정되는 프로그래밍 방식\n구성:\nEvent Producer (이벤트 생산자): 이벤트를 발생시키는 주체 Event Bus (이벤트 버스): 이벤트 전달 매개체 Event Consumer (이벤트 소비자): 이벤트를 처리하는 주체 목적: 비동기적 상호작용 처리, 시스템 간 결합도 감소\n실제 예시:\n1 2 3 4 5 6 7 // Node.js 이벤트 루프 예시 const fs = require('fs'); fs.readFile('data.txt', (err, data) =\u003e { if (err) throw err; console.log(data); // 콜백이 호출됨 }); 장점과 단점 구분 항목 설명 ✅ 장점 느슨한 결합 (Low Coupling) 컴포넌트 간 직접적인 의존성이 줄어들어 변경에 유연하게 대응 가능 높은 응집도 (High Cohesion) 각 모듈이 자신이 맡은 역할에 집중할 수 있도록 구조화됨 확장성 (Extensibility) 새로운 구현체 또는 기능 추가 시 기존 코드 변경 없이 가능 재사용성 (Reusability) 공통 인터페이스 및 컴포넌트 재사용률 증가 관심사의 분리 (Separation of Concerns) 도메인 로직, 인프라 로직, UI 등 계층별 책임 분리가 용이 테스트 용이성 (Testability) 의존 객체를 Mock 등으로 주입하여 단위 테스트가 쉬워짐 유지보수성 향상 (Maintainability) 변경이 국소화되어 코드 이해 및 수정이 용이 설계 유연성 확보 전략 패턴, DI, 이벤트 기반 처리 등 다양한 설계 방식과 연계 가능 ⚠ 단점 구조적 복잡성 증가 객체 간 연결 관계가 분산되어 코드 구조를 직관적으로 파악하기 어려움 디버깅의 어려움 런타임에 의존성 주입, 이벤트 전파 등으로 인해 호출 추적이 복잡 성능 오버헤드 DI 컨테이너, 리플렉션, 프록시 객체 사용 등으로 인한 실행 비용 증가 가능 프레임워크 종속성 증가 특정 IoC/DI 프레임워크 (Spring, Angular 등) 에 대한 강한 의존 위험 학습 곡선 (Learning Curve) 초보 개발자에게는 DI, 이벤트 전파, 추상화 개념이 어려울 수 있음 오용 시 설계 취약점 노출 과도한 추상화 또는 불필요한 인터페이스 설계는 오히려 복잡도 유발 초기 설정 부담 의존성 매핑, 설정파일 구성 등 초기 진입 비용 존재 동적 흐름으로 인한 예측 어려움 실행 흐름이 런타임에 결정되므로 정적 분석이 어렵고 예외 발생 위치 추적이 어려움 장점은 시스템의 유연성, 테스트성, 재사용성, 구조적 품질을 대폭 향상시킴 단점은 시스템의 추상화 수준 증가, 학습 난이도, 디버깅/성능 관리 부담 **현대 프레임워크 (Spring, NestJS, Angular 등)**는 이러한 장단점을 구조적으로 흡수할 수 있도록 다양한 도구 (DevTools, AOP, 트레이싱 등) 를 함께 제공 도전 과제 도전 과제 설명 해결책 1. 코드 복잡도 증가 간접 호출과 추상화가 많아지며, 전반적인 코드 흐름이 복잡해짐 명확한 인터페이스 설계, 계층적 책임 분리, 포괄적 문서화 및 코드 리뷰 강화 2. 성능 저하 가능성 리플렉션, 프록시, 동적 주입 등의 사용으로 런타임 오버헤드 발생 캐싱 전략, 컴파일 타임 주입 (Dagger, NestJS), 지연 로딩 (Lazy Loading) 적용 3. 디버깅 난이도 실행 흐름이 이벤트나 DI 컨테이너에 의해 결정되어 추적이 어려움 구조화된 로깅 (SLF4J, Winston), APM (New Relic, Datadog), 단위별 테스트 도입 4. 호출 흐름 가시성 부족 이벤트 기반 설계나 메시지 버스 사용 시 흐름이 암시적으로 전개되어 가독성이 저하됨 AOP 기반 트레이싱, 이벤트 로그 시각화 도구 활용 (OpenTelemetry, Zipkin 등) 5. 학습 곡선 DI, IoC, 이벤트 기반 패턴에 익숙하지 않은 개발자에게 진입장벽이 존재 페어프로그래밍, 주석 중심 설계 문서 제공, 온보딩용 샘플 프로젝트 제공 6. 의존성 과잉 분리 문제 작은 단위로 지나치게 나눈 컴포넌트는 오히려 관리 포인트를 증가시키고 오버엔지니어링 유발 의미 단위의 기능 그룹화, 모듈 간 책임 최소화, 필요 시 단순화 전략 적용 7. 프레임워크 의존성 증가 DI/IoC 가 프레임워크에 묶여 구현될 경우 전환 비용이 커질 수 있음 도메인 로직을 프레임워크와 분리하고, 어댑터 패턴 등으로 종속성 차단 8. 테스트 복잡성 증가 DI 및 콜백 기반 설계로 인해 테스트 환경 구성 시 모킹과 설정이 복잡해질 수 있음 테스트 컨테이너 활용 (Spring TestContext, Jest Mocks), 의존성 명시적 구성 IoC 기반 설계는 유연성과 확장성의 장점이 크지만, 동시에 복잡성과 학습 비용, 디버깅 어려움이라는 단점이 동반된다. 이러한 도전 과제를 해결하기 위해선 설계 명확화, 도구 활용, 문서화, 교육 체계화가 필수이다. 특히 로깅/모니터링/트레이싱 도구는 실무에서 IoC 설계의 가시성과 유지보수성을 확보하는 핵심 도구이다. 분류에 따른 종류 및 유형 분류 기준 유형 설명 적용 사례 설계 패턴 기반 Observer 이벤트 기반 구조에서 상태 변화 시 알림을 구독자에게 전달하는 패턴 EventEmitter, RxJS, DOM Events Template Method 알고리즘의 구조는 상위 클래스가 정의하고, 구체 구현은 하위 클래스에 위임 Spring JdbcTemplate, React render() 제어 구조 방식 Callback-based IoC 프레임워크가 콜백 함수를 등록하고 필요 시 실행 Express middleware, setTimeout Event-driven IoC 이벤트 발생 → 핸들러 등록 기반 흐름 제어 Node.js 이벤트 루프, NestJS Injection-based IoC 외부에서 의존성을 생성하고 객체에 주입 Spring DI, NestJS Provider Template-based IoC 일정한 실행 순서를 정한 후 사용자 구현을 삽입하는 방식 Java Template 패턴 제어 주체 유형 Flow Inversion 실행 흐름 제어가 프레임워크에 의해 전환됨 React 렌더링, Spring DispatcherServlet Interface Inversion 객체가 인터페이스에 의존하고 구현체는 나중에 주입 DIP (Dependency Inversion Principle) 의존성 주입 방법 Constructor-based IoC 생성자를 통한 의존성 주입 @Autowired 생성자 주입 Setter-based IoC 설정자 (setter) 를 통해 의존성 주입 Spring XML DI Interface-based IoC 명시적인 인터페이스 구현을 통한 주입 Guice, Spring Annotation-driven IoC 어노테이션으로 의존성 및 실행 흐름 제어 Spring Boot, Jakarta CDI 적용 범위 기준 Component-level IoC 단일 컴포넌트 혹은 클래스 단위에서의 제어 역전 React 컴포넌트, DI 단위 서비스 Framework-level IoC 프레임워크가 전체 실행 제어권을 가짐 Spring, Angular, NestJS System-level IoC 아키텍처 전반에서 이벤트와 제어 흐름을 위임 EDA(Event-Driven Architecture), Kubernetes Operator 실무 적용 예시 분야/기술 적용 방식 구체적 예시 프론트엔드 컴포넌트 간 메시지 전달, 라이프사이클 자동 제어 Vue 의 이벤트 버스, React useEffect, Angular ngOnInit() 등 웹 개발 (JS) 이벤트 핸들러 등록에 의한 흐름 위임 addEventListener, EventEmitter, async/await 모바일 개발 시스템 호출 기반 생명주기 관리 Android onCreate, onPause, iOS AppDelegate 메서드 게임 개발 엔진이 호출하는 구조 기반 흐름 제어 Unity Start(), Update() 등 MonoBehaviour 메서드 백엔드 (Java) 의존성 주입 (DI), 이벤트 리스닝 Spring @Autowired, @Component, @EventListener, @Async Node.js 이벤트 루프 기반 비동기 처리 EventEmitter, 비동기 콜백, Promise, async/await 마이크로서비스 이벤트 기반 아키텍처로 서비스 간 제어 분리 Kafka, RabbitMQ 등 메시지 브로커를 통한 서비스 간 간접 통신 ASP.NET 페이지/컨트롤러 생명주기 자동 호출 Page_Load, Page_Init, MVC 컨트롤러의 OnActionExecuting 등 Angular 의존성 주입 및 모듈 자동 등록 @Injectable(), 의존성 프로바이더 설정, 컴포넌트 주입 Express.js 미들웨어 체인 구조에 따른 흐름 위임 app.use(), next() 를 활용한 요청 처리 흐름 제어 활용 사례 사례 1: 주문 처리 시스템에서 이메일 알림 처리 시나리오: 주문 처리 시스템에서 이메일 알림 처리\n시스템 구성:\nOrderService: 주문 처리 및 이벤트 발행 EmailNotificationService: 이벤트 리스너로 동작하여 메일 발송 EventDispatcher: 이벤트 관리 및 분배 Workflow 다이어그램:\nsequenceDiagram participant OrderService participant EventDispatcher participant EmailService OrderService-\u003e\u003eEventDispatcher: emit(OrderCreated) EventDispatcher-\u003e\u003eEmailService: on(OrderCreated) EmailService-\u003e\u003eEmailService: sendEmail() Workflow:\n주문 생성 요청 → OrderService 이벤트 발행: OrderCreated EmailService 가 해당 이벤트 수신 후 이메일 발송 역할 요약:\n컴포넌트 역할 OrderService 주문 처리 및 이벤트 발행 EventDispatcher 이벤트 라우팅 및 디스패치 EmailNotificationService 후속 처리 (이메일 발송) 사례 2: 온라인 쇼핑몰 주문 처리 시스템 시나리오: 대규모 온라인 쇼핑몰에서 주문 처리 시 여러 서비스가 협력하여 작업을 수행하는 시스템\n시스템 구성 요소:\nOrderService (주문 서비스): 주문 생성 및 관리 EventPublisher (이벤트 발행자): 시스템 이벤트 발행 PaymentService (결제 서비스): 결제 처리 InventoryService (재고 서비스): 재고 관리 EmailService (이메일 서비스): 알림 이메일 발송 EventBus (이벤트 버스): 이벤트 중개 및 라우팅\n시스템 구성: graph TB %% Frontend Layer subgraph \"👤 Frontend Layer\" User[사용자] end %% Service Layer subgraph \"⚙️ Service Layer\" OrderController[주문 컨트롤러] OrderService[주문 서비스] EventPublisher[이벤트 발행자] EventBus[이벤트 버스] PaymentService[결제 서비스] InventoryService[재고 서비스] EmailService[이메일 서비스] LoggingService[로깅 서비스] ShippingService[배송 서비스] NotificationService[알림 서비스] end %% Infra Layer (간접적 표현) subgraph \"💾 Infra Layer\" Database[(DB 또는 큐 시스템)] end %% 흐름 정의 User --\u003e|\"1.주문 요청\"| OrderController OrderController --\u003e|\"2.주문 처리\"| OrderService OrderService --\u003e|\"3.이벤트 발행\"| EventPublisher EventPublisher --\u003e|\"4.주문 생성 이벤트\"| EventBus EventBus --\u003e|\"5.결제 처리\"| PaymentService EventBus --\u003e|\"6.재고 차감\"| InventoryService EventBus --\u003e|\"7.이메일 발송\"| EmailService EventBus --\u003e|\"8.로깅\"| LoggingService PaymentService --\u003e|결제 완료 이벤트| EventBus InventoryService --\u003e|재고 차감 이벤트| EventBus EventBus --\u003e|배송 준비 이벤트| ShippingService ShippingService --\u003e|배송 시작 이벤트| EventBus EventBus --\u003e|알림 발송| NotificationService %% Infra 연계 표현 PaymentService --\u003e Database InventoryService --\u003e Database LoggingService --\u003e Database Hollywood Principle 의 역할:\n이벤트 기반 아키텍처: 각 서비스는 직접 호출하지 않고 이벤트를 통해 통신 느슨한 결합: 서비스 간 직접적인 의존성 없이 독립적 운영 확장성: 새로운 서비스 추가 시 기존 코드 변경 없이 이벤트 구독만 추가 비동기 처리: 블로킹 없이 여러 작업을 동시에 처리 Workflow:\n사용자가 주문 요청을 보냄 주문 컨트롤러가 요청을 받아 주문 서비스에 전달 주문 서비스가 \" 주문 생성 \" 이벤트를 이벤트 버스에 발행 Hollywood Principle 적용: 이벤트 버스가 등록된 서비스들을 호출 각 서비스가 독립적으로 작업 수행 (결제, 재고 차감, 이메일 발송) 작업 완료 후 결과를 다시 이벤트로 알림 최종적으로 사용자에게 주문 완료 응답 전송 sequenceDiagram participant User as 사용자 participant Controller as 주문 컨트롤러 participant OrderSvc as 주문 서비스 participant EventBus as 이벤트 버스 participant PaymentSvc as 결제 서비스 participant InventorySvc as 재고 서비스 participant EmailSvc as 이메일 서비스 participant ShippingSvc as 배송 서비스 Note over User,ShippingSvc: 주문 처리 워크플로우 User-\u003e\u003eController: 1. 주문 요청 (POST /orders) Controller-\u003e\u003eOrderSvc: 2. 주문 생성 요청 OrderSvc-\u003e\u003eOrderSvc: 3. 주문 데이터 검증 및 저장 OrderSvc-\u003e\u003eEventBus: 4. \"OrderCreated\" 이벤트 발행 Note over EventBus: Hollywood Principle 적용점:\"우리가 필요한 서비스들을 호출할게요!\" par 병렬 처리 (Parallel Processing) EventBus-\u003e\u003ePaymentSvc: 5a. 결제 처리 콜백 호출 PaymentSvc-\u003e\u003ePaymentSvc: 결제 API 호출 PaymentSvc-\u003e\u003eEventBus: \"PaymentCompleted\" 이벤트 and EventBus-\u003e\u003eInventorySvc: 5b. 재고 차감 콜백 호출 InventorySvc-\u003e\u003eInventorySvc: 재고 확인 및 차감 InventorySvc-\u003e\u003eEventBus: \"InventoryUpdated\" 이벤트 and EventBus-\u003e\u003eEmailSvc: 5c. 주문 확인 이메일 콜백 호출 EmailSvc-\u003e\u003eEmailSvc: 이메일 템플릿 생성 및 발송 EmailSvc-\u003e\u003eEventBus: \"EmailSent\" 이벤트 end Note over EventBus: 모든 이벤트 완료 확인 EventBus-\u003e\u003eShippingSvc: 6. 배송 준비 콜백 호출 ShippingSvc-\u003e\u003eShippingSvc: 배송 라벨 생성 ShippingSvc-\u003e\u003eEventBus: \"ShippingPrepared\" 이벤트 EventBus-\u003e\u003eController: 7. 주문 처리 완료 알림 Controller-\u003e\u003eUser: 8. 주문 완료 응답 (200 OK) Note over User,ShippingSvc: 전체 프로세스에서 Hollywood Principle:각 서비스는 직접 호출하지 않고이벤트 버스가 필요할 때 호출 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 구분 고려사항 설명 권장사항 설계 원칙 적절한 추상화 수준 유지 과도한 추상화는 복잡도만 높이고, 추상화 부족은 재사용성을 낮춤 핵심 도메인만 추상화, 구체 구현은 필요시 계층화 적용 인터페이스 명확한 계약 정의 소비자와 제공자 간의 인터페이스는 역할에 맞게 분리되어야 함 단일 책임 원칙 (SRP), 인터페이스 분리 원칙 (ISP) 적용 구현 구조 IoC/DI 구조의 일관성 프레임워크/컨테이너에 따라 설계 표준과 구현 패턴이 달라질 수 있음 코드 스타일 가이드 문서화, 코드 리뷰 프로세스 강화 컴포넌트 책임 모듈 간 책임 명확화 이벤트/콜백/의존성 흐름이 명확하지 않으면 추적과 유지보수가 어려움 이벤트 네이밍 컨벤션 정립, 도메인 중심 핸들러 설계 테스트 전략 테스트 용이성 확보 DI 를 적용해도 테스트 전략이 미흡하면 결합도를 낮추는 이점이 사라짐 Mock/Stub/Fake 등 Test Double 전략 활용 에러 처리 장애 전파 방지 느슨한 결합 구조에서는 한 컴포넌트 실패가 전체 장애로 이어질 수 있음 Circuit Breaker, Retry, Timeout 설정 적용 흐름 추적 이벤트 및 제어 흐름 가시성 확보 비동기 구조에서는 흐름 파악이 어려워 디버깅, 운영에 어려움 발생 APM, 구조화 로깅, 시퀀스 다이어그램 기반 문서화 문서화 호출 구조 및 의사결정 기록 DI 구조에서는 흐름이 코드로 드러나지 않으므로 시각적 문서화 필요 아키텍처 다이어그램, 이벤트 카탈로그, 기술 의사결정 기록 (ADR) 관리 모니터링 시스템 관측 가능성 (Observability) 문제 발생 원인을 빠르게 식별할 수 있는 설계 필요 로그 집계 (ELK), 분산 추적 (Jaeger, OpenTelemetry), 메트릭 수집 (Prometheus) 최적화하기 위한 고려사항 카테고리 고려사항 설명 권장사항 이벤트 처리 이벤트 병목 방지 하나의 이벤트에 과도한 리스너가 연결될 경우 처리 지연 발생 가능 이벤트 큐, 메시지 브로커, 비동기 배치 처리 도입 이벤트 순서 보장 이벤트 핸들러가 비동기일 경우 순서가 꼬이는 문제 발생 Kafka Partition Key, Event Sourcing 시간 정렬 사용 불필요한 이벤트 제한 남용 시 코드 복잡도 및 자원 낭비 유발 필요 이벤트만 정의, Consumer 수 제한, 이벤트 카탈로그 관리 콜백/비동기 콜백 체인 최적화 깊은 콜백 체인은 디버깅/유지보수 어려움 Promise/async-await, 콜백 분리, 체인 길이 제한 비동기 처리 최적화 비동기 병렬 처리가 오히려 성능 저하로 이어질 수 있음 스레드 풀 크기 조정, 논블로킹 I/O (예: Netty, Reactor) DI 구성 요소 DI 오버헤드 관리 DI 컨테이너 자체의 초기화 비용, 리플렉션 성능 이슈 존재 JIT 대신 AOT 컴파일 사용 (Spring Native 등), 런타임 캐싱 불필요한 추상화 제거 과도한 추상화는 불필요한 계층 및 호출 비용 유발 실제 변경 가능성이 있는 부분만 추상화 의존성 범위 최소화 DI 범위가 넓을수록 초기화 시간과 메모리 사용 증가 DI 타겟을 단일 책임 단위로 분리, 프로토타입보다 싱글톤 활용 메모리 관리 GC 친화적 구조 설계 이벤트 리스너 및 DI 객체의 참조 누락 시 GC 대상 제외 WeakReference 사용, 리스너 해제 필수, @PreDestroy 등으로 정리 수행 리플렉션 리플렉션 최소화 DI 프레임워크의 리플렉션 사용은 런타임 성능 저하 원인 메타프로그래밍 최소화, 런타임 코드 생성 회피, final 타입 활용 직렬화/캐싱 효율적인 데이터 직렬화 느린 JSON 직렬화는 응답 지연 유발 Protobuf, Avro 등 이진 직렬화 적용, GZIP 압축 런타임/컴파일 캐싱 동일 의존성/이벤트 반복 생성 시 오버헤드 발생 CDI 캐시, Context 객체 재사용, 인스턴스 풀링 적용 모니터링/분석 성능 병목 지점 파악 병목 발생 시 위치 추적이 어려운 구조 APM (New Relic, Datadog), 분산 추적 (OpenTelemetry, Jaeger) 도입 주제와 관련하여 주목할 내용 분류 항목 설명 핵심 원칙 Hollywood Principle “Don’t call us, we’ll call you”—프레임워크가 제어 흐름을 관리 의존성 역전 원칙 (DIP) 고수준 모듈이 저수준 모듈에 의존하지 않고 추상화에 의존하도록 설계 단일 책임 원칙 (SRP) 컴포넌트가 하나의 책임만 가지도록 하여 유지보수성과 확장성 확보 디자인 패턴 Strategy Pattern 실행 알고리즘을 동적으로 변경 가능하게 하여 유연한 구조 제공 Command Pattern 요청을 객체로 캡슐화해 실행을 지연하거나 큐잉/로깅 등 가능 Observer Pattern 이벤트 발생 시 리스너에게 자동 알림, 느슨한 결합 구현 Template Method Pattern 알고리즘의 틀은 상위 클래스에서, 세부 로직은 하위 클래스에 위임 아키텍처 마이크로서비스 아키텍처 서비스 간 통신을 이벤트 기반 메시징으로 처리하여 IoC 구현 육각형 아키텍처 (Hexagonal) 포트 - 어댑터 구조로 외부와의 의존성 방향을 명확히 분리 프레임워크 Spring IoC Container 의존성 주입 및 생명주기 제어를 지원하는 Java 기반 IoC 프레임워크 Angular DI 계층적 주입 트리 기반의 DI 시스템을 제공하는 프론트엔드 프레임워크 기술/언어 AOP (Aspect-Oriented Programming) 횡단 관심사 분리로 로깅/보안/트랜잭션 등의 IoC 기반 처리 가능 Reactive Programming 비동기 스트림 기반으로 이벤트/데이터 흐름을 조율하는 패러다임 JavaScript Event Loop 비동기 콜백 기반 IoC 처리 메커니즘 (단일 스레드 환경에서의 제어 역전 예시) C# Delegates / Events 형식 안전한 콜백 구조로 이벤트 기반 프로그래밍 가능 설계 목적 느슨한 결합 객체 간 독립성 강화로 유지보수성/확장성 확보 의존성 부패 방지 (Dependency Rot) 과도하게 얽힌 의존성 구조를 추상화와 제어 분리로 해소 하위 주제별 추가 학습 필요 내용 카테고리 주제 간략 설명 디자인 패턴 Observer Pattern 이벤트 알림 구조로 느슨한 결합 구현 Template Method Pattern 알고리즘 골격은 상위에서, 세부는 하위 클래스에 위임 Strategy Pattern 런타임 알고리즘 교체 가능, 유연한 설계 구조 IoC / DI IoC (Inversion of Control) 제어 흐름을 프레임워크가 담당, Hollywood Principle 의 핵심 DI (Dependency Injection) 외부에서 의존 객체를 주입, 테스트/유지보수 용이 설계 원칙 SOLID 원칙 (특히 DIP, SRP) 의존성 역전 원칙, 단일 책임 원칙 등 IoC 와 밀접한 설계 원칙 Law of Demeter (최소 지식 원칙) 컴포넌트 간 결합도 최소화, 간접 호출 지양 아키텍처 패턴 이벤트 소싱 (Event Sourcing) 모든 상태 변경을 이벤트로 저장, 감사/복원 가능 CQRS (Command Query Responsibility Segregation) 읽기/쓰기 분리로 시스템 확장성과 최적화 구현 플러그인/확장성 설계 플러그인 아키텍처 동적으로 기능 추가 가능한 구조, 인터페이스 기반 확장 이벤트 시스템 도메인 이벤트를 중심으로 비동기/확장 가능한 시스템 구축 테스트 전략 Mock / Stub / Spy IoC 환경에서의 의존성 대체 및 단위 테스트 구현 기법 동시성 모델 Actor Model 메시지를 주고받는 방식으로 동시성 제어, 고립성 유지 CSP (Communicating Sequential Processes) 채널 기반 통신 (Go, Kotlin Coroutine 등에서 활용) 함수형 프로그래밍 고차 함수 (Higher-Order Functions) 함수를 매개변수/리턴값으로 사용하는 추상화 기법 Reactive Extensions (Rx, Reactor 등) 비동기 데이터 스트림과 옵저버블 기반 이벤트 처리 모델 관련 분야별 추가 학습 내용 카테고리 주제 설명 웹 개발 Webhook 아키텍처 외부 시스템과의 통합 시 HTTP 기반 이벤트 푸시 방식 Server-Sent Events (SSE) 서버에서 클라이언트로 단방향 실시간 데이터 전송 방식 클라우드 Serverless 아키텍처 이벤트 기반 함수 실행 (ex. AWS Lambda), 자동 확장 및 비용 최적화에 효과적 AWS 기반 이벤트 아키텍처 EventBridge, Lambda, SQS 조합으로 서버리스 이벤트 처리 구현 데이터베이스 Database Triggers INSERT/UPDATE/DELETE 시 자동 실행되는 DB 수준의 콜백 기능 Change Data Capture (CDC) 데이터 변경을 추적하여 외부 시스템으로 이벤트 발행 (ex. Debezium, Kafka Connect) 모바일 개발 iOS Delegation Pattern 델리게이트를 활용한 ViewController 간의 통신 구조 (Swift/Objective-C) Android Lifecycle Callbacks 생명주기 이벤트에 따른 콜백 메서드 활용 (onCreate, onResume 등) 게임 개발 Entity-Component-System (ECS) 데이터 중심, 컴포넌트 기반 아키텍처로 유연하고 확장성 높은 게임 로직 구성 Event Bus Pattern 객체 간 메시지를 느슨하게 전달하는 게임 이벤트 처리 방식 DevOps GitOps Workflow Git 저장소의 이벤트 기반으로 자동화된 CI/CD 파이프라인 실행 Infrastructure as Code (IaC) Terraform, Pulumi 등으로 선언적으로 인프라를 관리하고 자동화 소프트웨어 설계 레이어드 아키텍처 표현, 애플리케이션, 도메인, 인프라 계층으로 구성된 구조에서 IoC 적용 지점 분석 결합도와 응집도 컴포넌트 간 의존성 최소화 (Loose Coupling) 와 책임 집중 (High Cohesion) 설계 원칙 코드 품질 의존성 분석 의존성 그래프 시각화 및 모듈간 결합도 분석 (ex. SonarQube, CodeScene) 성능 최적화 DI 컨테이너 성능 최적화 DI 사용에 따른 메모리/속도 이슈 관리 (AOT 컴파일, Lazy Loading 등) 용어 정리 핵심 원칙 및 설계 철학 용어 설명 Hollywood Principle (헐리우드 원칙) “Don’t call us, we’ll call you”—제어 흐름을 프레임워크가 담당. Inversion of Control (IoC, 제어의 역전) 실행 흐름 제어권을 프레임워크 등 상위 컴포넌트로 전환하는 설계 원칙 Dependency Injection (DI, 의존성 주입) 의존성을 외부에서 주입하여 결합도를 낮추는 IoC 구현 방식 느슨한 결합 (Loose Coupling) 컴포넌트 간 의존성이 낮아 변경에 강한 구조 높은 응집도 (High Cohesion) 한 모듈이 명확하고 관련된 책임만 갖도록 하는 설계 Law of Demeter (최소 지식 원칙) 다른 객체 내부 구조를 몰라도 작동하는 설계 디자인 패턴 및 구조 전략 용어 설명 Observer / Template / Strategy 패턴 제어 흐름 역전이 적용되는 대표적인 디자인 패턴 CQRS Command 와 Query 를 분리해 읽기/쓰기 책임을 분리하는 아키텍처 패턴 Event Sourcing 상태 저장 대신 이벤트 시퀀스로 시스템 상태를 재구성하는 방식 Choreography 서비스 간 이벤트 기반 비중앙 통합 방식 Orchestration 중앙 조정자가 서비스 호출을 순서대로 관리하는 통합 방식 Service Locator 의존 객체를 찾기 위한 전역 접근점 제공 패턴 (IoC 대안이나 결합도 높음) 비동기/이벤트 기반 프로그래밍 용어 설명 Callback Hell 중첩된 콜백 구조로 인해 가독성 및 유지보수성이 낮아지는 문제 Event Loop JavaScript 등 단일 스레드 환경에서 비동기 작업을 처리하는 메커니즘 Reactive Streams 비동기 데이터 흐름을 처리하기 위한 스트림 표준 Backpressure 생산자와 소비자 간 속도 불균형을 조절하는 흐름 제어 메커니즘 Fluent Interface 메서드 체이닝 기반의 유창한 API 설계 방식 실패 내성 및 안정성 설계 용어 설명 Circuit Breaker 연속 실패 시 호출 차단으로 시스템을 보호하는 패턴 Retry 실패한 작업을 일정 횟수 재시도하는 실패 복구 전략 보상 트랜잭션 (Compensating Transaction) 실패한 작업의 반대 작업을 통해 데이터 일관성을 복구하는 전략 Idempotency 동일 작업을 여러 번 실행해도 결과가 동일한 특성 (중복 처리 방지) DLQ (Dead Letter Queue) 실패 메시지를 별도로 격리하여 후속 처리용으로 보관하는 큐 IoC 인프라 및 실무 관련 개념 용어 설명 IoC Container 객체 생성, 의존성 주입, 생명주기 관리 등을 담당하는 컨테이너 컴포넌트 Aspect Weaving AOP(관점 지향 프로그래밍) 에서 관심사를 핵심 로직에 삽입하는 처리 과정 의존성 부패 (Dependency Rot) 과도한 의존성 확장 및 모듈 간 결합 증가로 구조가 무너지는 현상 참고 및 출처 핵심 개념 (Hollywood Principle / IoC / DI) Inversion of Control – Wikipedia Martin Fowler’s Bliki: Inversion Of Control Hollywood Principle – DevIQ The Hollywood Principle – DZone Hollywood Principle in Software Design – Medium What is the Hollywood Principle? – Stack Overflow The Hollywood Principle – Matthew Mead Blog Design Patterns Explained – Dependency Injection – Stackify Three Design Patterns That Use Inversion of Control – SitePoint Inversion of Control (IoC) Design Principle – LinkedIn 프레임워크 / 이벤트 시스템 실무 예시 Spring Events – Baeldung Spring – Event Handling – GeeksforGeeks Spring Cloud Stream Error Handling Guide 클라우드 / 메시징 / 아키텍처 Event-Driven Architecture Best Practices – AWS Docs Handling Errors in Kafka Consumers – Confluent Dead Letter Queues – RabbitMQ Martin Fowler – Event-Driven Architecture 기타 참고 아티클 및 커뮤니티 자료 DEV Community: Code Smell 271 – The Hollywood Principle Peter Miľovčík – Hollywood Principle and Patterns HackerNoon – The Hollywood Principle의 설계적 의미 기계인간 John Grib: 헐리우드 원칙과 의존성 부패 Doublem.org – 헐리우드 원칙의 실무적 의미 ","wordCount":"4661","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-02-04T14:27:00Z","dateModified":"2025-02-04T14:27:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/hollywood-principle/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/>Design Principles</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/>Inversion of Control</a></div><h1 class="post-title entry-hint-parent">Hollywood Principle</h1><div class=post-description>Hollywood Principle 은 "Don't call us, we'll call you" 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</div><div class=post-meta><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Design%20and%20Architecture/Design%20Principles/Inversion%20of%20Control/Hollywood-Principle.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#hollywood-principle>Hollywood Principle</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#배경-및-필요성>배경 및 필요성</a></li><li><a href=#주요-기능-및-역할>주요 기능 및 역할</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#작동-원리>작동 원리</a></li><li><a href=#구조-및-아키텍처>구조 및 아키텍처</a></li><li><a href=#구현-기법>구현 기법</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#도전-과제>도전 과제</a></li><li><a href=#분류에-따른-종류-및-유형>분류에 따른 종류 및 유형</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#활용-사례>활용 사례</a></li><li><a href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#최적화하기-위한-고려사항>최적화하기 위한 고려사항</a></li><li><a href=#주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용</a></li><li><a href=#하위-주제별-추가-학습-필요-내용>하위 주제별 추가 학습 필요 내용</a></li><li><a href=#관련-분야별-추가-학습-내용>관련 분야별 추가 학습 내용</a></li></ul></li><li><a href=#용어-정리>용어 정리</a><ul><li><a href=#핵심-원칙-및-설계-철학>핵심 원칙 및 설계 철학</a></li><li><a href=#디자인-패턴-및-구조-전략>디자인 패턴 및 구조 전략</a></li><li><a href=#비동기이벤트-기반-프로그래밍>비동기/이벤트 기반 프로그래밍</a></li><li><a href=#실패-내성-및-안정성-설계>실패 내성 및 안정성 설계</a></li><li><a href=#ioc-인프라-및-실무-관련-개념>IoC 인프라 및 실무 관련 개념</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#핵심-개념-hollywood-principle--ioc--di>핵심 개념 (Hollywood Principle / IoC / DI)</a></li><li><a href=#프레임워크--이벤트-시스템-실무-예시>프레임워크 / 이벤트 시스템 실무 예시</a></li><li><a href=#클라우드--메시징--아키텍처>클라우드 / 메시징 / 아키텍처</a></li><li><a href=#기타-참고-아티클-및-커뮤니티-자료>기타 참고 아티클 및 커뮤니티 자료</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=hollywood-principle>Hollywood Principle<a hidden class=anchor aria-hidden=true href=#hollywood-principle>#</a></h2><p>Hollywood Principle 은 객체지향 설계 및 프레임워크 설계에서 널리 쓰이는 원칙으로, &ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo; 라는 문구로 대표된다. 이 원칙은 저수준 (구현) 모듈이 고수준 (프레임워크, 추상화) 모듈을 직접 호출하는 것이 아니라, 고수준 모듈이 저수준 모듈을 필요할 때 호출하도록 구조를 설계한다. 이를 통해 의존성 부패 (Dependency Rot) 를 방지하고, 시스템의 유연성, 확장성, 테스트 용이성을 높인다. 대표적으로 Inversion of Control, Dependency Injection, Observer, Template Method, Strategy 패턴 등에서 적용된다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>Hollywood Principle 은 **&ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo;**라는 문구로 요약되며, <strong>저수준 컴포넌트는 고수준 컴포넌트의 호출을 기다리는 방식</strong>으로 제어 흐름을 관리한다. 느슨한 결합, 의존성 부패 방지, 확장성 및 테스트 용이성 확보를 목적으로 하며 프레임워크 설계, 이벤트 기반 시스템, 디자인 패턴 (Observer, Template Method, Strategy 등) 에 적용된다.</p><ol><li><strong>제어의 역전 (Inversion of Control, IoC)</strong><ul><li>프로그램의 제어 흐름이 애플리케이션 코드가 아닌 외부 프레임워크에서 결정되는 원칙</li><li>전통적인 &ldquo;call&rdquo; 방식에서 &ldquo;callback&rdquo; 방식으로의 패러다임 전환</li></ul></li><li><strong>콜백 메커니즘 (Callback Mechanism)</strong><ul><li>특정 이벤트나 조건 발생 시 자동으로 호출되는 함수나 메서드</li><li>비동기 프로그래밍과 이벤트 처리의 핵심 메커니즘</li></ul></li><li><strong>의존성 주입 (Dependency Injection, DI)</strong><ul><li>객체가 필요한 의존성을 생성하지 않고 외부에서 제공받는 방식</li><li>객체 생성과 사용의 책임을 분리하여 결합도를 낮춤</li></ul></li><li><strong>이벤트 기반 아키텍처 (Event-driven Architecture)</strong><ul><li>이벤트의 발생과 처리를 중심으로 시스템을 설계하는 방식</li><li>Publisher-Subscriber 패턴의 기반이 되는 아키텍처 스타일</li></ul></li><li><strong>느슨한 결합 (Loose Coupling)</strong><ul><li>컴포넌트 간 의존성을 최소화하여 변경에 대한 영향을 줄이는 설계 방식</li><li>높은 응집도 (High Cohesion) 와 함께 소프트웨어 품질의 핵심 지표</li></ul></li><li><strong>프레임워크 vs 라이브러리 구분</strong><ul><li>프레임워크: 애플리케이션 코드를 호출하는 주체</li><li>라이브러리: 애플리케이션 코드에 의해 호출되는 대상</li></ul></li><li><strong>Publisher-Subscriber 패턴</strong><ul><li>이벤트 발행자와 구독자 간의 비동기 통신을 지원하는 패턴</li><li>일대다 통신과 느슨한 결합을 동시에 실현</li></ul></li></ol><h3 id=배경-및-필요성>배경 및 필요성<a hidden class=anchor aria-hidden=true href=#배경-및-필요성>#</a></h3><p>Hollywood Principle 은 1980 년대 후반 객체지향 프로그래밍의 발전과 함께 등장했다. Martin Fowler 가 1988 년으로 그 기원을 추적하였으며, 할리우드 오디션에서 흔히 듣는 &ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo; 문구에서 이름이 유래되었다.</p><p><strong>필요성:</strong></p><ul><li>코드의 재사용성 향상</li><li>컴포넌트 간 결합도 감소</li><li>테스트 가능성 증대</li><li>확장성과 유지보수성 개선</li><li>관심사의 분리 실현</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ol><li><strong>제어 흐름 관리</strong>: 프레임워크가 애플리케이션의 실행 흐름을 제어</li><li><strong>의존성 관리</strong>: 객체 간 의존성을 외부에서 주입하여 관리</li><li><strong>이벤트 처리</strong>: 비동기적 이벤트 발생과 처리를 조율</li><li><strong>생명주기 관리</strong>: 객체의 생성, 초기화, 소멸을 프레임워크가 관리</li><li><strong>확장점 제공</strong>: 플러그인이나 확장 모듈을 위한 훅 (Hook) 제공</li></ol><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>비침입적 (Non-intrusive)</strong>: 비즈니스 로직에 프레임워크 코드가 침투하지 않음</li><li><strong>선언적 (Declarative)</strong>: 설정이나 어노테이션을 통한 선언적 프로그래밍</li><li><strong>확장가능 (Extensible)</strong>: 새로운 구현체를 쉽게 추가할 수 있는 구조</li><li><strong>테스트 친화적</strong>: Mock 객체를 쉽게 주입하여 단위 테스트 용이</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ol><li><strong>&ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo;</strong>: 능동적 호출에서 수동적 대기로의 전환</li><li><strong>제어권 위임</strong>: 애플리케이션 코드가 제어권을 프레임워크에 위임</li><li><strong>인터페이스 기반 설계</strong>: 구체 클래스 대신 인터페이스에 의존</li><li><strong>관심사 분리</strong>: 비즈니스 로직과 인프라스트럭처 코드의 분리</li></ol><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><ul><li>저수준 컴포넌트 (플러그인, 리스너 등) 는 고수준 컴포넌트에 등록만 한다.</li><li>고수준 컴포넌트 (프레임워크, 이벤트 디스패처 등) 가 필요할 때 저수준 컴포넌트를 호출한다.</li></ul><pre class=mermaid>sequenceDiagram
    participant Client as Client Code
    participant Framework as Framework
    participant Callback as Callback Handler
    
    Note over Client,Callback: 1. 등록 단계 (Registration Phase)
    Client-&gt;&gt;Framework: register(callback)
    Framework-&gt;&gt;Framework: store callback in registry
    
    Note over Framework: 2. 대기 단계 (Waiting Phase)
    Note over Framework: Framework waits for events/conditions
    
    Note over Framework: 3. 트리거 단계 (Triggering Phase)
    Framework-&gt;&gt;Framework: Internal event occurs
    
    Note over Framework,Callback: 4. 호출 단계 (Invocation Phase)
    Framework-&gt;&gt;Callback: &#34;Don&#39;t call us, we&#39;ll call you&#34;
    
    Note over Callback: 5. 실행 단계 (Execution Phase)
    Callback-&gt;&gt;Callback: Execute business logic
    
    Note over Framework: 6. 반환 단계 (Return Phase)
    Callback-&gt;&gt;Framework: Return control/result
    Framework-&gt;&gt;Client: Optional: notify completion
</pre><p>Hollywood Principle 의 작동 원리는 다음과 같은 단계로 구성된다:</p><ol><li><strong>등록 단계 (Registration)</strong>: 클라이언트 코드가 프레임워크에 콜백이나 핸들러를 등록</li><li><strong>대기 단계 (Waiting)</strong>: 클라이언트는 능동적으로 호출하지 않고 대기</li><li><strong>트리거 단계 (Triggering)</strong>: 프레임워크 내부에서 특정 이벤트나 조건 발생</li><li><strong>호출 단계 (Invocation)</strong>: 프레임워크가 등록된 콜백을 호출</li><li><strong>실행 단계 (Execution)</strong>: 클라이언트의 비즈니스 로직 실행</li><li><strong>반환 단계 (Return)</strong>: 제어권이 프레임워크로 돌아감</li></ol><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><p>Hollywood Principle 은 고수준 모듈이 제어 흐름을 담당하고 저수준 모듈은 <strong>콜백, 이벤트 등록, 추상 클래스 상속 등</strong>을 통해 호출될 수 있는 상태를 유지하는 구조이다.</p><pre class=mermaid>graph TB
    subgraph &#34;Hollywood Principle 전체 아키텍처&#34;
        Framework[Framework/Container]
        
        subgraph &#34;필수 구성요소 (Essential Components)&#34;
            Registry[Callback Registry]
            EventManager[Event Manager]
            LifecycleManager[Lifecycle Manager]
        end
        
        subgraph &#34;선택 구성요소 (Optional Components)&#34;
            ConfigManager[Configuration Manager]
            SecurityManager[Security Manager]
            MonitoringManager[Monitoring Manager]
        end
        
        subgraph &#34;클라이언트 구성요소 (Client Components)&#34;
            ClientCode[Client Code]
            CallbackHandlers[Callback Handlers]
            EventListeners[Event Listeners]
        end
        
        Framework --&gt; Registry
        Framework --&gt; EventManager
        Framework --&gt; LifecycleManager
        Framework -.-&gt; ConfigManager
        Framework -.-&gt; SecurityManager
        Framework -.-&gt; MonitoringManager
        
        ClientCode --&gt; CallbackHandlers
        ClientCode --&gt; EventListeners
        
        Registry --&gt; CallbackHandlers
        EventManager --&gt; EventListeners
        LifecycleManager --&gt; ClientCode
        
        style Framework fill:#e8f5e8
        style Registry fill:#e3f2fd
        style EventManager fill:#e3f2fd
        style LifecycleManager fill:#e3f2fd
        style ConfigManager fill:#fff3e0
        style SecurityManager fill:#fff3e0
        style MonitoringManager fill:#fff3e0
        style ClientCode fill:#fce4ec
        style CallbackHandlers fill:#f3e5f5
        style EventListeners fill:#f3e5f5
    end
</pre><h4 id=구성요소>구성요소<a hidden class=anchor aria-hidden=true href=#구성요소>#</a></h4><table><thead><tr><th>구분</th><th>구성요소</th><th>기능 설명</th><th>역할 및 특징</th></tr></thead><tbody><tr><td>필수</td><td><strong>Framework / Container</strong>(프레임워크 / 컨테이너)</td><td>시스템 전체 제어 흐름 담당콜백 실행, 생명주기 전반 제어</td><td><strong>중앙 제어권 보유</strong>, 실행 흐름 결정</td></tr><tr><td></td><td><strong>Callback Registry</strong>(콜백 레지스트리)</td><td>콜백 함수 등록/해제/관리</td><td>동적 콜백 관리로 유연성 제공</td></tr><tr><td></td><td><strong>Event Manager</strong>(이벤트 매니저)</td><td>이벤트 발생/전파/처리이벤트 큐 및 리스너 관리</td><td><strong>비동기 이벤트 처리</strong> 지원</td></tr><tr><td></td><td><strong>Lifecycle Manager</strong>(생명주기 매니저)</td><td>객체 생성~소멸까지 관리의존성 주입 시점 통제</td><td>리소스/의존성 관리, <strong>전체 생명주기 제어</strong></td></tr><tr><td>선택</td><td><strong>Configuration Manager</strong>(설정 매니저)</td><td>설정 파일 로딩 및 설정 값 관리</td><td>런타임 설정 변경 지원</td></tr><tr><td></td><td><strong>Security Manager</strong>(보안 매니저)</td><td>인증/인가, 접근 제어 수행</td><td>**AOP(관심사 분리)**에 적합</td></tr><tr><td></td><td><strong>Monitoring Manager</strong>(모니터링 매니저)</td><td>성능 지표 수집, 로깅, 시스템 상태 추적</td><td>실시간 모니터링 및 경보 시스템 연동</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>구분</th><th>패턴 / 기법</th><th>개념 요약</th><th>제어 흐름</th><th>목적</th><th>대표 기술 / 예시</th></tr></thead><tbody><tr><td><strong>의존성 주입</strong></td><td>Dependency Injection (DI)</td><td>의존 객체 생성을 외부에서 주입</td><td>객체 생성 제어권 → 컨테이너</td><td>결합도 감소, 테스트 용이성 향상</td><td>Spring, NestJS, Angular, Guice</td></tr><tr><td><strong>관찰자 패턴</strong></td><td>Observer Pattern</td><td>상태 변화 발생 시 등록된 리스너에 자동 통보</td><td>알림 제어권 → Subject</td><td>상태 변화 감지, 다대일 연동</td><td>EventEmitter, addEventListener</td></tr><tr><td><strong>템플릿 메서드</strong></td><td>Template Method Pattern</td><td>알고리즘의 뼈대를 상위 클래스가 정의하고, 하위 클래스가 구현</td><td>알고리즘 순서 제어권 → 추상 클래스</td><td>알고리즘 재사용성, 확장성</td><td>Spring JdbcTemplate, React Lifecycle</td></tr><tr><td><strong>이벤트 기반</strong></td><td>Event-driven Programming</td><td>이벤트가 발생하면 리스너 또는 핸들러가 비동기적으로 반응</td><td>흐름 제어권 → 이벤트 루프/큐</td><td>느슨한 결합, 비동기 흐름 처리</td><td>Node.js, Kafka, AWS EventBridge</td></tr><tr><td><strong>전략 패턴</strong></td><td>Strategy Pattern</td><td>실행 알고리즘을 객체로 분리하고 유연하게 교체</td><td>실행 제어권 → 외부 전략 객체</td><td>런타임 유연성, 조건별 실행 방식 분리</td><td><code>Array.prototype.sort(callback)</code></td></tr><tr><td><strong>서비스 등록소</strong></td><td>Service Locator Pattern</td><td>객체를 전역 등록소에서 가져다 씀 (DI 의 대안적 방식)</td><td>의존성 해결 제어권 → Locator</td><td>의존성 중앙 관리</td><td>Unity Container, InversifyJS</td></tr><tr><td><strong>이벤트 버스</strong></td><td>Event Bus / Message Bus</td><td>메시지 중심으로 컴포넌트 간 통신</td><td>메시지 흐름 제어권 → 중앙 버스</td><td>컴포넌트 간 결합도 제거</td><td>Vue EventBus, RabbitMQ, EventBridge</td></tr><tr><td><strong>콜백 등록</strong></td><td>Callback Registry</td><td>콜백 함수를 동적으로 등록 및 해제 가능</td><td>호출 시점 제어권 → 외부 등록자</td><td>유연한 이벤트 대응 구조</td><td>jQuery <code>.on()</code>, Node.js callbacks</td></tr><tr><td><strong>생명주기 관리</strong></td><td>Lifecycle Management</td><td>객체 생성~소멸 주기를 일관되게 관리</td><td>자원 생명 제어권 → 컨테이너</td><td>자원 누수 방지, 예측 가능한 상태 전환</td><td>React, Angular, Spring Context</td></tr></tbody></table><h4 id=dependency-injection-의존성-주입>Dependency Injection (의존성 주입)<a hidden class=anchor aria-hidden=true href=#dependency-injection-의존성-주입>#</a></h4><ul><li><strong>제어 역전</strong>: 객체 생성과 의존성 주입을 컨테이너가 담당</li><li><strong>핵심</strong>: " 객체를 직접 생성하지 말고, 주입받아 사용하세요 "</li></ul><pre class=mermaid>graph TD
    subgraph &#34;Dependency Injection Pattern&#34;
        DI_Container[DI Container]
        DI_Service[Service Interface]
        DI_ServiceImpl[Service Implementation]
        DI_Client[Client Class]
        
        DI_Container --&gt;|creates &amp; injects| DI_ServiceImpl
        DI_Container --&gt;|creates &amp; injects| DI_Client
        DI_Client -.-&gt;|depends on| DI_Service
        DI_ServiceImpl -.-&gt;|implements| DI_Service
        
        style DI_Container fill:#e8f5e8
        style DI_Service fill:#e3f2fd
        style DI_ServiceImpl fill:#fff3e0
        style DI_Client fill:#fce4ec
    end
</pre><p><strong>정의</strong>: 객체가 필요한 의존성을 생성하지 않고 외부에서 주입받는 기법<br><strong>구성</strong>:</p><ul><li>Injector (주입자): 의존성을 제공하는 주체</li><li>Service (서비스): 주입될 의존성 객체</li><li>Client (클라이언트): 의존성을 필요로 하는 객체</li></ul><p><strong>목적</strong>: 객체 생성과 사용의 책임 분리, 결합도 감소<br><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Spring Framework 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>OrderService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>PaymentService</span><span class=w> </span><span class=n>paymentService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 생성자 주입</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>OrderService</span><span class=p>(</span><span class=n>PaymentService</span><span class=w> </span><span class=n>paymentService</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>paymentService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>paymentService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=observer-pattern-관찰자-패턴>Observer Pattern (관찰자 패턴)<a hidden class=anchor aria-hidden=true href=#observer-pattern-관찰자-패턴>#</a></h4><ul><li><strong>제어 역전</strong>: 상태 변화 알림을 Subject 가 주도</li><li><strong>핵심</strong>: " 변화를 감지하면 우리가 알려드리겠습니다 "</li></ul><pre class=mermaid>graph TD
    subgraph &#34;Observer Pattern&#34;
        Subject[Subject]
        Observer1[Observer 1]
        Observer2[Observer 2]
        ObserverN[Observer N]
        
        Subject --&gt;|&#34;notifyObservers()&#34;| Observer1
        Subject --&gt;|&#34;notifyObservers()&#34;| Observer2
        Subject --&gt;|&#34;notifyObservers()&#34;| ObserverN
        
        Observer1 -.-&gt;|subscribe| Subject
        Observer2 -.-&gt;|subscribe| Subject
        ObserverN -.-&gt;|subscribe| Subject
        
        style Subject fill:#e8f5e8
        style Observer1 fill:#e3f2fd
        style Observer2 fill:#e3f2fd
        style ObserverN fill:#e3f2fd
    end
</pre><p><strong>정의</strong>: 객체의 상태 변화를 여러 관찰자에게 자동으로 알리는 패턴<br><strong>구성</strong>:</p><ul><li>Subject (주제): 상태 변화의 주체</li><li>Observer (관찰자): 변화를 감지하고 처리하는 객체</li></ul><p><strong>목적</strong>: 일대다 의존성 정의, 느슨한 결합 실현<br><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7>7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8>8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// JavaScript EventEmitter 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>EventEmitter</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;events&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>emitter</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>EventEmitter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>emitter</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;dataChanged&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Data updated:&#39;</span><span class=p>,</span> <span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>emitter</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;dataChanged&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=nx>id</span><span class=o>:</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>value</span><span class=o>:</span> <span class=s1>&#39;new data&#39;</span> <span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=template-method-pattern-템플릿-메서드-패턴>Template Method Pattern (템플릿 메서드 패턴)<a hidden class=anchor aria-hidden=true href=#template-method-pattern-템플릿-메서드-패턴>#</a></h4><ul><li><strong>제어 역전</strong>: 알고리즘 실행 순서를 상위 클래스가 제어</li><li><strong>핵심</strong>: " 전체 흐름은 우리가 관리하고, 세부사항만 구현하세요 "</li></ul><pre class=mermaid>graph TD
    subgraph &#34;Template Method Pattern&#34;
        AbstractClass[Abstract Template Class]
        ConcreteClass1[Concrete Class 1]
        ConcreteClass2[Concrete Class 2]
        
        AbstractClass --&gt;|calls| Hook1[&#34;primitiveOperation1()&#34;]
        AbstractClass --&gt;|calls| Hook2[&#34;primitiveOperation2()&#34;]
        
        ConcreteClass1 -.-&gt;|implements| Hook1
        ConcreteClass2 -.-&gt;|implements| Hook2
        
        ConcreteClass1 --&gt;|extends| AbstractClass
        ConcreteClass2 --&gt;|extends| AbstractClass
        
        style AbstractClass fill:#e8f5e8
        style ConcreteClass1 fill:#e3f2fd
        style ConcreteClass2 fill:#e3f2fd
        style Hook1 fill:#fff3e0
        style Hook2 fill:#fff3e0
    end
</pre><p><strong>정의</strong>: 알고리즘의 골격을 정의하고 하위 클래스에서 세부 단계를 구현하는 패턴<br><strong>구성</strong>:</p><ul><li>Abstract Class (추상 클래스): 템플릿 메서드 정의</li><li>Concrete Class (구체 클래스): 세부 단계 구현</li></ul><p><strong>목적</strong>: 알고리즘 구조 고정, 세부 구현의 변경 허용<br><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8>8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Spring JdbcTemplate 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>abstract</span><span class=w> </span><span class=kd>class</span> <span class=nc>JdbcTemplate</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nf>query</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>sql</span><span class=p>,</span><span class=w> </span><span class=n>RowMapper</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>mapper</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 1. 연결 획득</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 2. SQL 실행</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 3. 결과 처리 (mapper 콜백 호출)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 4. 연결 해제</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=event-driven-programming-이벤트-기반-프로그래밍>Event-driven Programming (이벤트 기반 프로그래밍)<a hidden class=anchor aria-hidden=true href=#event-driven-programming-이벤트-기반-프로그래밍>#</a></h4><ul><li><strong>제어 역전</strong>: 이벤트 발생과 처리를 이벤트 버스가 조율</li><li><strong>핵심</strong>: " 이벤트가 발생하면 우리가 처리하겠습니다 "</li></ul><pre class=mermaid>graph TD
    subgraph &#34;Event-Driven Pattern&#34;
        EventProducer[Event Producer]
        EventBus[Event Bus]
        EventConsumer1[Event Consumer 1]
        EventConsumer2[Event Consumer 2]
        EventQueue[Event Queue]
        
        EventProducer --&gt;|publish| EventBus
        EventBus --&gt;|enqueue| EventQueue
        EventQueue --&gt;|dispatch| EventConsumer1
        EventQueue --&gt;|dispatch| EventConsumer2
        
        EventConsumer1 -.-&gt;|subscribe| EventBus
        EventConsumer2 -.-&gt;|subscribe| EventBus
        
        style EventProducer fill:#e8f5e8
        style EventBus fill:#e3f2fd
        style EventQueue fill:#fff3e0
        style EventConsumer1 fill:#fce4ec
        style EventConsumer2 fill:#fce4ec
    end
</pre><p><strong>정의</strong>: 이벤트 발생에 따라 프로그램 흐름이 결정되는 프로그래밍 방식<br><strong>구성</strong>:</p><ul><li>Event Producer (이벤트 생산자): 이벤트를 발생시키는 주체</li><li>Event Bus (이벤트 버스): 이벤트 전달 매개체</li><li>Event Consumer (이벤트 소비자): 이벤트를 처리하는 주체</li></ul><p><strong>목적</strong>: 비동기적 상호작용 처리, 시스템 간 결합도 감소<br><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Node.js 이벤트 루프 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>fs</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;fs&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fs</span><span class=p>.</span><span class=nx>readFile</span><span class=p>(</span><span class=s1>&#39;data.txt&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>err</span><span class=p>,</span> <span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=k>throw</span> <span class=nx>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span> <span class=c1>// 콜백이 호출됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td><strong>느슨한 결합 (Low Coupling)</strong></td><td>컴포넌트 간 직접적인 의존성이 줄어들어 변경에 유연하게 대응 가능</td></tr><tr><td></td><td><strong>높은 응집도 (High Cohesion)</strong></td><td>각 모듈이 자신이 맡은 역할에 집중할 수 있도록 구조화됨</td></tr><tr><td></td><td><strong>확장성 (Extensibility)</strong></td><td>새로운 구현체 또는 기능 추가 시 기존 코드 변경 없이 가능</td></tr><tr><td></td><td><strong>재사용성 (Reusability)</strong></td><td>공통 인터페이스 및 컴포넌트 재사용률 증가</td></tr><tr><td></td><td><strong>관심사의 분리 (Separation of Concerns)</strong></td><td>도메인 로직, 인프라 로직, UI 등 계층별 책임 분리가 용이</td></tr><tr><td></td><td><strong>테스트 용이성 (Testability)</strong></td><td>의존 객체를 Mock 등으로 주입하여 단위 테스트가 쉬워짐</td></tr><tr><td></td><td><strong>유지보수성 향상 (Maintainability)</strong></td><td>변경이 국소화되어 코드 이해 및 수정이 용이</td></tr><tr><td></td><td><strong>설계 유연성 확보</strong></td><td>전략 패턴, DI, 이벤트 기반 처리 등 다양한 설계 방식과 연계 가능</td></tr><tr><td>⚠ 단점</td><td><strong>구조적 복잡성 증가</strong></td><td>객체 간 연결 관계가 분산되어 코드 구조를 직관적으로 파악하기 어려움</td></tr><tr><td></td><td><strong>디버깅의 어려움</strong></td><td>런타임에 의존성 주입, 이벤트 전파 등으로 인해 호출 추적이 복잡</td></tr><tr><td></td><td><strong>성능 오버헤드</strong></td><td>DI 컨테이너, 리플렉션, 프록시 객체 사용 등으로 인한 실행 비용 증가 가능</td></tr><tr><td></td><td><strong>프레임워크 종속성 증가</strong></td><td>특정 IoC/DI 프레임워크 (Spring, Angular 등) 에 대한 강한 의존 위험</td></tr><tr><td></td><td><strong>학습 곡선 (Learning Curve)</strong></td><td>초보 개발자에게는 DI, 이벤트 전파, 추상화 개념이 어려울 수 있음</td></tr><tr><td></td><td><strong>오용 시 설계 취약점 노출</strong></td><td>과도한 추상화 또는 불필요한 인터페이스 설계는 오히려 복잡도 유발</td></tr><tr><td></td><td><strong>초기 설정 부담</strong></td><td>의존성 매핑, 설정파일 구성 등 초기 진입 비용 존재</td></tr><tr><td></td><td><strong>동적 흐름으로 인한 예측 어려움</strong></td><td>실행 흐름이 런타임에 결정되므로 정적 분석이 어렵고 예외 발생 위치 추적이 어려움</td></tr></tbody></table><ul><li><strong>장점</strong>은 시스템의 <strong>유연성, 테스트성, 재사용성, 구조적 품질</strong>을 대폭 향상시킴</li><li><strong>단점</strong>은 시스템의 <strong>추상화 수준 증가, 학습 난이도, 디버깅/성능 관리 부담</strong></li><li>**현대 프레임워크 (Spring, NestJS, Angular 등)**는 이러한 장단점을 구조적으로 흡수할 수 있도록 다양한 도구 (DevTools, AOP, 트레이싱 등) 를 함께 제공</li></ul><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td><strong>1. 코드 복잡도 증가</strong></td><td>간접 호출과 추상화가 많아지며, 전반적인 코드 흐름이 복잡해짐</td><td>명확한 인터페이스 설계, 계층적 책임 분리, 포괄적 문서화 및 코드 리뷰 강화</td></tr><tr><td><strong>2. 성능 저하 가능성</strong></td><td>리플렉션, 프록시, 동적 주입 등의 사용으로 런타임 오버헤드 발생</td><td>캐싱 전략, 컴파일 타임 주입 (Dagger, NestJS), 지연 로딩 (Lazy Loading) 적용</td></tr><tr><td><strong>3. 디버깅 난이도</strong></td><td>실행 흐름이 이벤트나 DI 컨테이너에 의해 결정되어 추적이 어려움</td><td>구조화된 로깅 (SLF4J, Winston), APM (New Relic, Datadog), 단위별 테스트 도입</td></tr><tr><td><strong>4. 호출 흐름 가시성 부족</strong></td><td>이벤트 기반 설계나 메시지 버스 사용 시 흐름이 암시적으로 전개되어 가독성이 저하됨</td><td>AOP 기반 트레이싱, 이벤트 로그 시각화 도구 활용 (OpenTelemetry, Zipkin 등)</td></tr><tr><td><strong>5. 학습 곡선</strong></td><td>DI, IoC, 이벤트 기반 패턴에 익숙하지 않은 개발자에게 진입장벽이 존재</td><td>페어프로그래밍, 주석 중심 설계 문서 제공, 온보딩용 샘플 프로젝트 제공</td></tr><tr><td><strong>6. 의존성 과잉 분리 문제</strong></td><td>작은 단위로 지나치게 나눈 컴포넌트는 오히려 관리 포인트를 증가시키고 오버엔지니어링 유발</td><td>의미 단위의 기능 그룹화, 모듈 간 책임 최소화, 필요 시 단순화 전략 적용</td></tr><tr><td><strong>7. 프레임워크 의존성 증가</strong></td><td>DI/IoC 가 프레임워크에 묶여 구현될 경우 전환 비용이 커질 수 있음</td><td>도메인 로직을 프레임워크와 분리하고, 어댑터 패턴 등으로 종속성 차단</td></tr><tr><td><strong>8. 테스트 복잡성 증가</strong></td><td>DI 및 콜백 기반 설계로 인해 테스트 환경 구성 시 모킹과 설정이 복잡해질 수 있음</td><td>테스트 컨테이너 활용 (Spring TestContext, Jest Mocks), 의존성 명시적 구성</td></tr></tbody></table><ul><li>IoC 기반 설계는 <strong>유연성과 확장성의 장점</strong>이 크지만, 동시에 <strong>복잡성과 학습 비용, 디버깅 어려움</strong>이라는 단점이 동반된다.</li><li>이러한 도전 과제를 해결하기 위해선 <strong>설계 명확화, 도구 활용, 문서화, 교육 체계화</strong>가 필수이다.</li><li>특히 <strong>로깅/모니터링/트레이싱 도구</strong>는 실무에서 IoC 설계의 가시성과 유지보수성을 확보하는 핵심 도구이다.</li></ul><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th><strong>분류 기준</strong></th><th><strong>유형</strong></th><th><strong>설명</strong></th><th><strong>적용 사례</strong></th></tr></thead><tbody><tr><td><strong>설계 패턴 기반</strong></td><td>Observer</td><td>이벤트 기반 구조에서 상태 변화 시 알림을 구독자에게 전달하는 패턴</td><td><code>EventEmitter</code>, RxJS, DOM Events</td></tr><tr><td></td><td>Template Method</td><td>알고리즘의 구조는 상위 클래스가 정의하고, 구체 구현은 하위 클래스에 위임</td><td>Spring <code>JdbcTemplate</code>, React <code>render()</code></td></tr><tr><td><strong>제어 구조 방식</strong></td><td>Callback-based IoC</td><td>프레임워크가 콜백 함수를 등록하고 필요 시 실행</td><td>Express middleware, setTimeout</td></tr><tr><td></td><td>Event-driven IoC</td><td>이벤트 발생 → 핸들러 등록 기반 흐름 제어</td><td>Node.js 이벤트 루프, NestJS</td></tr><tr><td></td><td>Injection-based IoC</td><td>외부에서 의존성을 생성하고 객체에 주입</td><td>Spring DI, NestJS Provider</td></tr><tr><td></td><td>Template-based IoC</td><td>일정한 실행 순서를 정한 후 사용자 구현을 삽입하는 방식</td><td>Java Template 패턴</td></tr><tr><td><strong>제어 주체 유형</strong></td><td>Flow Inversion</td><td>실행 흐름 제어가 프레임워크에 의해 전환됨</td><td>React 렌더링, Spring DispatcherServlet</td></tr><tr><td></td><td>Interface Inversion</td><td>객체가 인터페이스에 의존하고 구현체는 나중에 주입</td><td>DIP (Dependency Inversion Principle)</td></tr><tr><td><strong>의존성 주입 방법</strong></td><td>Constructor-based IoC</td><td>생성자를 통한 의존성 주입</td><td><code>@Autowired</code> 생성자 주입</td></tr><tr><td></td><td>Setter-based IoC</td><td>설정자 (setter) 를 통해 의존성 주입</td><td>Spring XML DI</td></tr><tr><td></td><td>Interface-based IoC</td><td>명시적인 인터페이스 구현을 통한 주입</td><td>Guice, Spring</td></tr><tr><td></td><td>Annotation-driven IoC</td><td>어노테이션으로 의존성 및 실행 흐름 제어</td><td>Spring Boot, Jakarta CDI</td></tr><tr><td><strong>적용 범위 기준</strong></td><td>Component-level IoC</td><td>단일 컴포넌트 혹은 클래스 단위에서의 제어 역전</td><td>React 컴포넌트, DI 단위 서비스</td></tr><tr><td></td><td>Framework-level IoC</td><td>프레임워크가 전체 실행 제어권을 가짐</td><td>Spring, Angular, NestJS</td></tr><tr><td></td><td>System-level IoC</td><td>아키텍처 전반에서 이벤트와 제어 흐름을 위임</td><td>EDA(Event-Driven Architecture), Kubernetes Operator</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th><strong>분야/기술</strong></th><th><strong>적용 방식</strong></th><th><strong>구체적 예시</strong></th></tr></thead><tbody><tr><td><strong>프론트엔드</strong></td><td>컴포넌트 간 메시지 전달, 라이프사이클 자동 제어</td><td>Vue 의 이벤트 버스, React <code>useEffect</code>, Angular <code>ngOnInit()</code> 등</td></tr><tr><td><strong>웹 개발 (JS)</strong></td><td>이벤트 핸들러 등록에 의한 흐름 위임</td><td><code>addEventListener</code>, <code>EventEmitter</code>, <code>async/await</code></td></tr><tr><td><strong>모바일 개발</strong></td><td>시스템 호출 기반 생명주기 관리</td><td>Android <code>onCreate</code>, <code>onPause</code>, iOS <code>AppDelegate</code> 메서드</td></tr><tr><td><strong>게임 개발</strong></td><td>엔진이 호출하는 구조 기반 흐름 제어</td><td>Unity <code>Start()</code>, <code>Update()</code> 등 MonoBehaviour 메서드</td></tr><tr><td><strong>백엔드 (Java)</strong></td><td>의존성 주입 (DI), 이벤트 리스닝</td><td>Spring <code>@Autowired</code>, <code>@Component</code>, <code>@EventListener</code>, <code>@Async</code></td></tr><tr><td><strong>Node.js</strong></td><td>이벤트 루프 기반 비동기 처리</td><td><code>EventEmitter</code>, 비동기 콜백, <code>Promise</code>, <code>async/await</code></td></tr><tr><td><strong>마이크로서비스</strong></td><td>이벤트 기반 아키텍처로 서비스 간 제어 분리</td><td>Kafka, RabbitMQ 등 메시지 브로커를 통한 서비스 간 간접 통신</td></tr><tr><td><strong>ASP.NET</strong></td><td>페이지/컨트롤러 생명주기 자동 호출</td><td><code>Page_Load</code>, <code>Page_Init</code>, MVC 컨트롤러의 <code>OnActionExecuting</code> 등</td></tr><tr><td><strong>Angular</strong></td><td>의존성 주입 및 모듈 자동 등록</td><td><code>@Injectable()</code>, 의존성 프로바이더 설정, 컴포넌트 주입</td></tr><tr><td><strong>Express.js</strong></td><td>미들웨어 체인 구조에 따른 흐름 위임</td><td><code>app.use()</code>, <code>next()</code> 를 활용한 요청 처리 흐름 제어</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-주문-처리-시스템에서-이메일-알림-처리>사례 1: 주문 처리 시스템에서 이메일 알림 처리<a hidden class=anchor aria-hidden=true href=#사례-1-주문-처리-시스템에서-이메일-알림-처리>#</a></h4><p><strong>시나리오</strong>: 주문 처리 시스템에서 이메일 알림 처리</p><p><strong>시스템 구성</strong>:</p><ul><li><code>OrderService</code>: 주문 처리 및 이벤트 발행</li><li><code>EmailNotificationService</code>: 이벤트 리스너로 동작하여 메일 발송</li><li><code>EventDispatcher</code>: 이벤트 관리 및 분배</li></ul><p><strong>Workflow 다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
  participant OrderService
  participant EventDispatcher
  participant EmailService

  OrderService-&gt;&gt;EventDispatcher: emit(OrderCreated)
  EventDispatcher-&gt;&gt;EmailService: on(OrderCreated)
  EmailService-&gt;&gt;EmailService: sendEmail()
</pre><p><strong>Workflow</strong>:</p><ol><li>주문 생성 요청 → <code>OrderService</code></li><li>이벤트 발행: <code>OrderCreated</code></li><li><code>EmailService</code> 가 해당 이벤트 수신 후 이메일 발송</li></ol><p><strong>역할 요약</strong>:</p><table><thead><tr><th>컴포넌트</th><th>역할</th></tr></thead><tbody><tr><td>OrderService</td><td>주문 처리 및 이벤트 발행</td></tr><tr><td>EventDispatcher</td><td>이벤트 라우팅 및 디스패치</td></tr><tr><td>EmailNotificationService</td><td>후속 처리 (이메일 발송)</td></tr></tbody></table><h4 id=사례-2-온라인-쇼핑몰-주문-처리-시스템>사례 2: 온라인 쇼핑몰 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#사례-2-온라인-쇼핑몰-주문-처리-시스템>#</a></h4><p><strong>시나리오</strong>: 대규모 온라인 쇼핑몰에서 주문 처리 시 여러 서비스가 협력하여 작업을 수행하는 시스템<br><strong>시스템 구성 요소</strong>:</p><ol><li><strong>OrderService (주문 서비스)</strong>: 주문 생성 및 관리</li><li><strong>EventPublisher (이벤트 발행자)</strong>: 시스템 이벤트 발행</li><li><strong>PaymentService (결제 서비스)</strong>: 결제 처리</li><li><strong>InventoryService (재고 서비스)</strong>: 재고 관리</li><li><strong>EmailService (이메일 서비스)</strong>: 알림 이메일 발송</li><li><strong>EventBus (이벤트 버스)</strong>: 이벤트 중개 및 라우팅<br><strong>시스템 구성</strong>:</li></ol><pre class=mermaid>graph TB

    %% Frontend Layer
    subgraph &#34;👤 Frontend Layer&#34;
        User[사용자]
    end

    %% Service Layer
    subgraph &#34;⚙️ Service Layer&#34;
        OrderController[주문 컨트롤러]
        OrderService[주문 서비스]
        EventPublisher[이벤트 발행자]
        EventBus[이벤트 버스]
        PaymentService[결제 서비스]
        InventoryService[재고 서비스]
        EmailService[이메일 서비스]
        LoggingService[로깅 서비스]
        ShippingService[배송 서비스]
        NotificationService[알림 서비스]
    end

    %% Infra Layer (간접적 표현)
    subgraph &#34;💾 Infra Layer&#34;
        Database[(DB 또는 큐 시스템)]
    end

    %% 흐름 정의
    User --&gt;|&#34;1.주문 요청&#34;| OrderController
    OrderController --&gt;|&#34;2.주문 처리&#34;| OrderService
    OrderService --&gt;|&#34;3.이벤트 발행&#34;| EventPublisher
    EventPublisher --&gt;|&#34;4.주문 생성 이벤트&#34;| EventBus

    EventBus --&gt;|&#34;5.결제 처리&#34;| PaymentService
    EventBus --&gt;|&#34;6.재고 차감&#34;| InventoryService
    EventBus --&gt;|&#34;7.이메일 발송&#34;| EmailService
    EventBus --&gt;|&#34;8.로깅&#34;| LoggingService

    PaymentService --&gt;|결제 완료 이벤트| EventBus
    InventoryService --&gt;|재고 차감 이벤트| EventBus
    EventBus --&gt;|배송 준비 이벤트| ShippingService
    ShippingService --&gt;|배송 시작 이벤트| EventBus
    EventBus --&gt;|알림 발송| NotificationService

    %% Infra 연계 표현
    PaymentService --&gt; Database
    InventoryService --&gt; Database
    LoggingService --&gt; Database
</pre><p><strong>Hollywood Principle 의 역할</strong>:</p><ol><li><strong>이벤트 기반 아키텍처</strong>: 각 서비스는 직접 호출하지 않고 이벤트를 통해 통신</li><li><strong>느슨한 결합</strong>: 서비스 간 직접적인 의존성 없이 독립적 운영</li><li><strong>확장성</strong>: 새로운 서비스 추가 시 기존 코드 변경 없이 이벤트 구독만 추가</li><li><strong>비동기 처리</strong>: 블로킹 없이 여러 작업을 동시에 처리</li></ol><p><strong>Workflow</strong>:</p><ol><li>사용자가 주문 요청을 보냄</li><li>주문 컨트롤러가 요청을 받아 주문 서비스에 전달</li><li>주문 서비스가 " 주문 생성 " 이벤트를 이벤트 버스에 발행</li><li><strong>Hollywood Principle 적용</strong>: 이벤트 버스가 등록된 서비스들을 호출</li><li>각 서비스가 독립적으로 작업 수행 (결제, 재고 차감, 이메일 발송)</li><li>작업 완료 후 결과를 다시 이벤트로 알림</li><li>최종적으로 사용자에게 주문 완료 응답 전송</li></ol><pre class=mermaid>sequenceDiagram
    participant User as 사용자
    participant Controller as 주문 컨트롤러
    participant OrderSvc as 주문 서비스
    participant EventBus as 이벤트 버스
    participant PaymentSvc as 결제 서비스
    participant InventorySvc as 재고 서비스
    participant EmailSvc as 이메일 서비스
    participant ShippingSvc as 배송 서비스
    
    Note over User,ShippingSvc: 주문 처리 워크플로우
    
    User-&gt;&gt;Controller: 1. 주문 요청 (POST /orders)
    Controller-&gt;&gt;OrderSvc: 2. 주문 생성 요청
    OrderSvc-&gt;&gt;OrderSvc: 3. 주문 데이터 검증 및 저장
    OrderSvc-&gt;&gt;EventBus: 4. &#34;OrderCreated&#34; 이벤트 발행
    
    Note over EventBus: Hollywood Principle 적용점:&lt;br/&gt;&#34;우리가 필요한 서비스들을 호출할게요!&#34;
    
    par 병렬 처리 (Parallel Processing)
        EventBus-&gt;&gt;PaymentSvc: 5a. 결제 처리 콜백 호출
        PaymentSvc-&gt;&gt;PaymentSvc: 결제 API 호출
        PaymentSvc-&gt;&gt;EventBus: &#34;PaymentCompleted&#34; 이벤트
    and
        EventBus-&gt;&gt;InventorySvc: 5b. 재고 차감 콜백 호출
        InventorySvc-&gt;&gt;InventorySvc: 재고 확인 및 차감
        InventorySvc-&gt;&gt;EventBus: &#34;InventoryUpdated&#34; 이벤트
    and
        EventBus-&gt;&gt;EmailSvc: 5c. 주문 확인 이메일 콜백 호출
        EmailSvc-&gt;&gt;EmailSvc: 이메일 템플릿 생성 및 발송
        EmailSvc-&gt;&gt;EventBus: &#34;EmailSent&#34; 이벤트
    end
    
    Note over EventBus: 모든 이벤트 완료 확인
    EventBus-&gt;&gt;ShippingSvc: 6. 배송 준비 콜백 호출
    ShippingSvc-&gt;&gt;ShippingSvc: 배송 라벨 생성
    ShippingSvc-&gt;&gt;EventBus: &#34;ShippingPrepared&#34; 이벤트
    
    EventBus-&gt;&gt;Controller: 7. 주문 처리 완료 알림
    Controller-&gt;&gt;User: 8. 주문 완료 응답 (200 OK)
    
    Note over User,ShippingSvc: 전체 프로세스에서 Hollywood Principle:&lt;br/&gt;각 서비스는 직접 호출하지 않고&lt;br/&gt;이벤트 버스가 필요할 때 호출
</pre><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>적절한 추상화 수준 유지</td><td>과도한 추상화는 복잡도만 높이고, 추상화 부족은 재사용성을 낮춤</td><td>핵심 도메인만 추상화, 구체 구현은 필요시 계층화 적용</td></tr><tr><td><strong>인터페이스</strong></td><td>명확한 계약 정의</td><td>소비자와 제공자 간의 인터페이스는 역할에 맞게 분리되어야 함</td><td>단일 책임 원칙 (SRP), 인터페이스 분리 원칙 (ISP) 적용</td></tr><tr><td><strong>구현 구조</strong></td><td>IoC/DI 구조의 일관성</td><td>프레임워크/컨테이너에 따라 설계 표준과 구현 패턴이 달라질 수 있음</td><td>코드 스타일 가이드 문서화, 코드 리뷰 프로세스 강화</td></tr><tr><td><strong>컴포넌트 책임</strong></td><td>모듈 간 책임 명확화</td><td>이벤트/콜백/의존성 흐름이 명확하지 않으면 추적과 유지보수가 어려움</td><td>이벤트 네이밍 컨벤션 정립, 도메인 중심 핸들러 설계</td></tr><tr><td><strong>테스트 전략</strong></td><td>테스트 용이성 확보</td><td>DI 를 적용해도 테스트 전략이 미흡하면 결합도를 낮추는 이점이 사라짐</td><td>Mock/Stub/Fake 등 Test Double 전략 활용</td></tr><tr><td><strong>에러 처리</strong></td><td>장애 전파 방지</td><td>느슨한 결합 구조에서는 한 컴포넌트 실패가 전체 장애로 이어질 수 있음</td><td>Circuit Breaker, Retry, Timeout 설정 적용</td></tr><tr><td><strong>흐름 추적</strong></td><td>이벤트 및 제어 흐름 가시성 확보</td><td>비동기 구조에서는 흐름 파악이 어려워 디버깅, 운영에 어려움 발생</td><td>APM, 구조화 로깅, 시퀀스 다이어그램 기반 문서화</td></tr><tr><td><strong>문서화</strong></td><td>호출 구조 및 의사결정 기록</td><td>DI 구조에서는 흐름이 코드로 드러나지 않으므로 시각적 문서화 필요</td><td>아키텍처 다이어그램, 이벤트 카탈로그, 기술 의사결정 기록 (ADR) 관리</td></tr><tr><td><strong>모니터링</strong></td><td>시스템 관측 가능성 (Observability)</td><td>문제 발생 원인을 빠르게 식별할 수 있는 설계 필요</td><td>로그 집계 (ELK), 분산 추적 (Jaeger, OpenTelemetry), 메트릭 수집 (Prometheus)</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항>최적화하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항>#</a></h3><table><thead><tr><th>카테고리</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>이벤트 처리</strong></td><td>이벤트 병목 방지</td><td>하나의 이벤트에 과도한 리스너가 연결될 경우 처리 지연 발생 가능</td><td>이벤트 큐, 메시지 브로커, 비동기 배치 처리 도입</td></tr><tr><td></td><td>이벤트 순서 보장</td><td>이벤트 핸들러가 비동기일 경우 순서가 꼬이는 문제 발생</td><td>Kafka Partition Key, Event Sourcing 시간 정렬 사용</td></tr><tr><td></td><td>불필요한 이벤트 제한</td><td>남용 시 코드 복잡도 및 자원 낭비 유발</td><td>필요 이벤트만 정의, Consumer 수 제한, 이벤트 카탈로그 관리</td></tr><tr><td><strong>콜백/비동기</strong></td><td>콜백 체인 최적화</td><td>깊은 콜백 체인은 디버깅/유지보수 어려움</td><td>Promise/async-await, 콜백 분리, 체인 길이 제한</td></tr><tr><td></td><td>비동기 처리 최적화</td><td>비동기 병렬 처리가 오히려 성능 저하로 이어질 수 있음</td><td>스레드 풀 크기 조정, 논블로킹 I/O (예: Netty, Reactor)</td></tr><tr><td><strong>DI 구성 요소</strong></td><td>DI 오버헤드 관리</td><td>DI 컨테이너 자체의 초기화 비용, 리플렉션 성능 이슈 존재</td><td>JIT 대신 AOT 컴파일 사용 (Spring Native 등), 런타임 캐싱</td></tr><tr><td></td><td>불필요한 추상화 제거</td><td>과도한 추상화는 불필요한 계층 및 호출 비용 유발</td><td>실제 변경 가능성이 있는 부분만 추상화</td></tr><tr><td></td><td>의존성 범위 최소화</td><td>DI 범위가 넓을수록 초기화 시간과 메모리 사용 증가</td><td>DI 타겟을 단일 책임 단위로 분리, 프로토타입보다 싱글톤 활용</td></tr><tr><td><strong>메모리 관리</strong></td><td>GC 친화적 구조 설계</td><td>이벤트 리스너 및 DI 객체의 참조 누락 시 GC 대상 제외</td><td>WeakReference 사용, 리스너 해제 필수, <code>@PreDestroy</code> 등으로 정리 수행</td></tr><tr><td><strong>리플렉션</strong></td><td>리플렉션 최소화</td><td>DI 프레임워크의 리플렉션 사용은 런타임 성능 저하 원인</td><td>메타프로그래밍 최소화, 런타임 코드 생성 회피, <code>final</code> 타입 활용</td></tr><tr><td><strong>직렬화/캐싱</strong></td><td>효율적인 데이터 직렬화</td><td>느린 JSON 직렬화는 응답 지연 유발</td><td>Protobuf, Avro 등 이진 직렬화 적용, GZIP 압축</td></tr><tr><td></td><td>런타임/컴파일 캐싱</td><td>동일 의존성/이벤트 반복 생성 시 오버헤드 발생</td><td>CDI 캐시, Context 객체 재사용, 인스턴스 풀링 적용</td></tr><tr><td><strong>모니터링/분석</strong></td><td>성능 병목 지점 파악</td><td>병목 발생 시 위치 추적이 어려운 구조</td><td>APM (New Relic, Datadog), 분산 추적 (OpenTelemetry, Jaeger) 도입</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>분류</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>핵심 원칙</strong></td><td>Hollywood Principle</td><td>&ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo;—프레임워크가 제어 흐름을 관리</td></tr><tr><td></td><td>의존성 역전 원칙 (DIP)</td><td>고수준 모듈이 저수준 모듈에 의존하지 않고 추상화에 의존하도록 설계</td></tr><tr><td></td><td>단일 책임 원칙 (SRP)</td><td>컴포넌트가 하나의 책임만 가지도록 하여 유지보수성과 확장성 확보</td></tr><tr><td><strong>디자인 패턴</strong></td><td>Strategy Pattern</td><td>실행 알고리즘을 동적으로 변경 가능하게 하여 유연한 구조 제공</td></tr><tr><td></td><td>Command Pattern</td><td>요청을 객체로 캡슐화해 실행을 지연하거나 큐잉/로깅 등 가능</td></tr><tr><td></td><td>Observer Pattern</td><td>이벤트 발생 시 리스너에게 자동 알림, 느슨한 결합 구현</td></tr><tr><td></td><td>Template Method Pattern</td><td>알고리즘의 틀은 상위 클래스에서, 세부 로직은 하위 클래스에 위임</td></tr><tr><td><strong>아키텍처</strong></td><td>마이크로서비스 아키텍처</td><td>서비스 간 통신을 이벤트 기반 메시징으로 처리하여 IoC 구현</td></tr><tr><td></td><td>육각형 아키텍처 (Hexagonal)</td><td>포트 - 어댑터 구조로 외부와의 의존성 방향을 명확히 분리</td></tr><tr><td><strong>프레임워크</strong></td><td>Spring IoC Container</td><td>의존성 주입 및 생명주기 제어를 지원하는 Java 기반 IoC 프레임워크</td></tr><tr><td></td><td>Angular DI</td><td>계층적 주입 트리 기반의 DI 시스템을 제공하는 프론트엔드 프레임워크</td></tr><tr><td><strong>기술/언어</strong></td><td>AOP (Aspect-Oriented Programming)</td><td>횡단 관심사 분리로 로깅/보안/트랜잭션 등의 IoC 기반 처리 가능</td></tr><tr><td></td><td>Reactive Programming</td><td>비동기 스트림 기반으로 이벤트/데이터 흐름을 조율하는 패러다임</td></tr><tr><td></td><td>JavaScript Event Loop</td><td>비동기 콜백 기반 IoC 처리 메커니즘 (단일 스레드 환경에서의 제어 역전 예시)</td></tr><tr><td></td><td>C# Delegates / Events</td><td>형식 안전한 콜백 구조로 이벤트 기반 프로그래밍 가능</td></tr><tr><td><strong>설계 목적</strong></td><td>느슨한 결합</td><td>객체 간 독립성 강화로 유지보수성/확장성 확보</td></tr><tr><td></td><td>의존성 부패 방지 (Dependency Rot)</td><td>과도하게 얽힌 의존성 구조를 추상화와 제어 분리로 해소</td></tr></tbody></table><h3 id=하위-주제별-추가-학습-필요-내용>하위 주제별 추가 학습 필요 내용<a hidden class=anchor aria-hidden=true href=#하위-주제별-추가-학습-필요-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>간략 설명</th></tr></thead><tbody><tr><td><strong>디자인 패턴</strong></td><td>Observer Pattern</td><td>이벤트 알림 구조로 느슨한 결합 구현</td></tr><tr><td></td><td>Template Method Pattern</td><td>알고리즘 골격은 상위에서, 세부는 하위 클래스에 위임</td></tr><tr><td></td><td>Strategy Pattern</td><td>런타임 알고리즘 교체 가능, 유연한 설계 구조</td></tr><tr><td><strong>IoC / DI</strong></td><td>IoC (Inversion of Control)</td><td>제어 흐름을 프레임워크가 담당, Hollywood Principle 의 핵심</td></tr><tr><td></td><td>DI (Dependency Injection)</td><td>외부에서 의존 객체를 주입, 테스트/유지보수 용이</td></tr><tr><td><strong>설계 원칙</strong></td><td>SOLID 원칙 (특히 DIP, SRP)</td><td>의존성 역전 원칙, 단일 책임 원칙 등 IoC 와 밀접한 설계 원칙</td></tr><tr><td></td><td>Law of Demeter (최소 지식 원칙)</td><td>컴포넌트 간 결합도 최소화, 간접 호출 지양</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>이벤트 소싱 (Event Sourcing)</td><td>모든 상태 변경을 이벤트로 저장, 감사/복원 가능</td></tr><tr><td></td><td>CQRS (Command Query Responsibility Segregation)</td><td>읽기/쓰기 분리로 시스템 확장성과 최적화 구현</td></tr><tr><td><strong>플러그인/확장성 설계</strong></td><td>플러그인 아키텍처</td><td>동적으로 기능 추가 가능한 구조, 인터페이스 기반 확장</td></tr><tr><td></td><td>이벤트 시스템</td><td>도메인 이벤트를 중심으로 비동기/확장 가능한 시스템 구축</td></tr><tr><td><strong>테스트 전략</strong></td><td>Mock / Stub / Spy</td><td>IoC 환경에서의 의존성 대체 및 단위 테스트 구현 기법</td></tr><tr><td><strong>동시성 모델</strong></td><td>Actor Model</td><td>메시지를 주고받는 방식으로 동시성 제어, 고립성 유지</td></tr><tr><td></td><td>CSP (Communicating Sequential Processes)</td><td>채널 기반 통신 (Go, Kotlin Coroutine 등에서 활용)</td></tr><tr><td><strong>함수형 프로그래밍</strong></td><td>고차 함수 (Higher-Order Functions)</td><td>함수를 매개변수/리턴값으로 사용하는 추상화 기법</td></tr><tr><td></td><td>Reactive Extensions (Rx, Reactor 등)</td><td>비동기 데이터 스트림과 옵저버블 기반 이벤트 처리 모델</td></tr></tbody></table><h3 id=관련-분야별-추가-학습-내용>관련 분야별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야별-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>웹 개발</strong></td><td>Webhook 아키텍처</td><td>외부 시스템과의 통합 시 HTTP 기반 이벤트 푸시 방식</td></tr><tr><td></td><td>Server-Sent Events (SSE)</td><td>서버에서 클라이언트로 단방향 실시간 데이터 전송 방식</td></tr><tr><td><strong>클라우드</strong></td><td>Serverless 아키텍처</td><td>이벤트 기반 함수 실행 (ex. AWS Lambda), 자동 확장 및 비용 최적화에 효과적</td></tr><tr><td></td><td>AWS 기반 이벤트 아키텍처</td><td>EventBridge, Lambda, SQS 조합으로 서버리스 이벤트 처리 구현</td></tr><tr><td><strong>데이터베이스</strong></td><td>Database Triggers</td><td>INSERT/UPDATE/DELETE 시 자동 실행되는 DB 수준의 콜백 기능</td></tr><tr><td></td><td>Change Data Capture (CDC)</td><td>데이터 변경을 추적하여 외부 시스템으로 이벤트 발행 (ex. Debezium, Kafka Connect)</td></tr><tr><td><strong>모바일 개발</strong></td><td>iOS Delegation Pattern</td><td>델리게이트를 활용한 ViewController 간의 통신 구조 (Swift/Objective-C)</td></tr><tr><td></td><td>Android Lifecycle Callbacks</td><td>생명주기 이벤트에 따른 콜백 메서드 활용 (<code>onCreate</code>, <code>onResume</code> 등)</td></tr><tr><td><strong>게임 개발</strong></td><td>Entity-Component-System (ECS)</td><td>데이터 중심, 컴포넌트 기반 아키텍처로 유연하고 확장성 높은 게임 로직 구성</td></tr><tr><td></td><td>Event Bus Pattern</td><td>객체 간 메시지를 느슨하게 전달하는 게임 이벤트 처리 방식</td></tr><tr><td><strong>DevOps</strong></td><td>GitOps Workflow</td><td>Git 저장소의 이벤트 기반으로 자동화된 CI/CD 파이프라인 실행</td></tr><tr><td></td><td>Infrastructure as Code (IaC)</td><td>Terraform, Pulumi 등으로 선언적으로 인프라를 관리하고 자동화</td></tr><tr><td><strong>소프트웨어 설계</strong></td><td>레이어드 아키텍처</td><td>표현, 애플리케이션, 도메인, 인프라 계층으로 구성된 구조에서 IoC 적용 지점 분석</td></tr><tr><td></td><td>결합도와 응집도</td><td>컴포넌트 간 의존성 최소화 (Loose Coupling) 와 책임 집중 (High Cohesion) 설계 원칙</td></tr><tr><td><strong>코드 품질</strong></td><td>의존성 분석</td><td>의존성 그래프 시각화 및 모듈간 결합도 분석 (ex. SonarQube, CodeScene)</td></tr><tr><td><strong>성능 최적화</strong></td><td>DI 컨테이너 성능 최적화</td><td>DI 사용에 따른 메모리/속도 이슈 관리 (AOT 컴파일, Lazy Loading 등)</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=핵심-원칙-및-설계-철학>핵심 원칙 및 설계 철학<a hidden class=anchor aria-hidden=true href=#핵심-원칙-및-설계-철학>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Hollywood Principle (헐리우드 원칙)</td><td>&ldquo;Don&rsquo;t call us, we&rsquo;ll call you&rdquo;—제어 흐름을 프레임워크가 담당.</td></tr><tr><td>Inversion of Control (IoC, 제어의 역전)</td><td>실행 흐름 제어권을 프레임워크 등 상위 컴포넌트로 전환하는 설계 원칙</td></tr><tr><td>Dependency Injection (DI, 의존성 주입)</td><td>의존성을 외부에서 주입하여 결합도를 낮추는 IoC 구현 방식</td></tr><tr><td>느슨한 결합 (Loose Coupling)</td><td>컴포넌트 간 의존성이 낮아 변경에 강한 구조</td></tr><tr><td>높은 응집도 (High Cohesion)</td><td>한 모듈이 명확하고 관련된 책임만 갖도록 하는 설계</td></tr><tr><td>Law of Demeter (최소 지식 원칙)</td><td>다른 객체 내부 구조를 몰라도 작동하는 설계</td></tr></tbody></table><h3 id=디자인-패턴-및-구조-전략>디자인 패턴 및 구조 전략<a hidden class=anchor aria-hidden=true href=#디자인-패턴-및-구조-전략>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Observer / Template / Strategy 패턴</td><td>제어 흐름 역전이 적용되는 대표적인 디자인 패턴</td></tr><tr><td>CQRS</td><td>Command 와 Query 를 분리해 읽기/쓰기 책임을 분리하는 아키텍처 패턴</td></tr><tr><td>Event Sourcing</td><td>상태 저장 대신 이벤트 시퀀스로 시스템 상태를 재구성하는 방식</td></tr><tr><td>Choreography</td><td>서비스 간 이벤트 기반 비중앙 통합 방식</td></tr><tr><td>Orchestration</td><td>중앙 조정자가 서비스 호출을 순서대로 관리하는 통합 방식</td></tr><tr><td>Service Locator</td><td>의존 객체를 찾기 위한 전역 접근점 제공 패턴 (IoC 대안이나 결합도 높음)</td></tr></tbody></table><h3 id=비동기이벤트-기반-프로그래밍>비동기/이벤트 기반 프로그래밍<a hidden class=anchor aria-hidden=true href=#비동기이벤트-기반-프로그래밍>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Callback Hell</td><td>중첩된 콜백 구조로 인해 가독성 및 유지보수성이 낮아지는 문제</td></tr><tr><td>Event Loop</td><td>JavaScript 등 단일 스레드 환경에서 비동기 작업을 처리하는 메커니즘</td></tr><tr><td>Reactive Streams</td><td>비동기 데이터 흐름을 처리하기 위한 스트림 표준</td></tr><tr><td>Backpressure</td><td>생산자와 소비자 간 속도 불균형을 조절하는 흐름 제어 메커니즘</td></tr><tr><td>Fluent Interface</td><td>메서드 체이닝 기반의 유창한 API 설계 방식</td></tr></tbody></table><h3 id=실패-내성-및-안정성-설계>실패 내성 및 안정성 설계<a hidden class=anchor aria-hidden=true href=#실패-내성-및-안정성-설계>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Circuit Breaker</td><td>연속 실패 시 호출 차단으로 시스템을 보호하는 패턴</td></tr><tr><td>Retry</td><td>실패한 작업을 일정 횟수 재시도하는 실패 복구 전략</td></tr><tr><td>보상 트랜잭션 (Compensating Transaction)</td><td>실패한 작업의 반대 작업을 통해 데이터 일관성을 복구하는 전략</td></tr><tr><td>Idempotency</td><td>동일 작업을 여러 번 실행해도 결과가 동일한 특성 (중복 처리 방지)</td></tr><tr><td>DLQ (Dead Letter Queue)</td><td>실패 메시지를 별도로 격리하여 후속 처리용으로 보관하는 큐</td></tr></tbody></table><h3 id=ioc-인프라-및-실무-관련-개념>IoC 인프라 및 실무 관련 개념<a hidden class=anchor aria-hidden=true href=#ioc-인프라-및-실무-관련-개념>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>IoC Container</td><td>객체 생성, 의존성 주입, 생명주기 관리 등을 담당하는 컨테이너 컴포넌트</td></tr><tr><td>Aspect Weaving</td><td>AOP(관점 지향 프로그래밍) 에서 관심사를 핵심 로직에 삽입하는 처리 과정</td></tr><tr><td>의존성 부패 (Dependency Rot)</td><td>과도한 의존성 확장 및 모듈 간 결합 증가로 구조가 무너지는 현상</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=핵심-개념-hollywood-principle--ioc--di>핵심 개념 (Hollywood Principle / IoC / DI)<a hidden class=anchor aria-hidden=true href=#핵심-개념-hollywood-principle--ioc--di>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Inversion_of_control>Inversion of Control – Wikipedia</a></li><li><a href=https://martinfowler.com/bliki/InversionOfControl.html>Martin Fowler&rsquo;s Bliki: Inversion Of Control</a></li><li><a href=https://deviq.com/principles/hollywood-principle/>Hollywood Principle – DevIQ</a></li><li><a href=https://dzone.com/articles/the-hollywood-principle>The Hollywood Principle – DZone</a></li><li><a href=https://medium.com/@sandy619g/hollywood-principle-in-software-engineering-5d68f679b524>Hollywood Principle in Software Design – Medium</a></li><li><a href=https://stackoverflow.com/questions/64333953/what-is-the-hollywood-principle>What is the Hollywood Principle? – Stack Overflow</a></li><li><a href=http://matthewtmead.com/blog/hollywood-principle-dont-call-us-well-call-you-4/>The Hollywood Principle – Matthew Mead Blog</a></li><li><a href=https://stackify.com/dependency-injection/>Design Patterns Explained – Dependency Injection – Stackify</a></li><li><a href=https://www.sitepoint.com/three-design-patterns-that-use-inversion-of-control/>Three Design Patterns That Use Inversion of Control – SitePoint</a></li><li><a href=https://www.linkedin.com/pulse/inversion-control-ioc-design-principle-jahid-momin>Inversion of Control (IoC) Design Principle – LinkedIn</a></li></ul><h3 id=프레임워크--이벤트-시스템-실무-예시>프레임워크 / 이벤트 시스템 실무 예시<a hidden class=anchor aria-hidden=true href=#프레임워크--이벤트-시스템-실무-예시>#</a></h3><ul><li><a href=https://www.baeldung.com/spring-events>Spring Events – Baeldung</a></li><li><a href=https://www.geeksforgeeks.org/spring-event-handling/>Spring – Event Handling – GeeksforGeeks</a></li><li><a href=https://docs.spring.io/spring-cloud-stream/docs/current/reference/html/spring-cloud-stream.html#_error_handling>Spring Cloud Stream Error Handling Guide</a></li></ul><h3 id=클라우드--메시징--아키텍처>클라우드 / 메시징 / 아키텍처<a hidden class=anchor aria-hidden=true href=#클라우드--메시징--아키텍처>#</a></h3><ul><li><a href=https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-driven-architecture.html>Event-Driven Architecture Best Practices – AWS Docs</a></li><li><a href=https://docs.confluent.io/platform/current/kafka/error-handling.html>Handling Errors in Kafka Consumers – Confluent</a></li><li><a href=https://www.rabbitmq.com/dlx.html>Dead Letter Queues – RabbitMQ</a></li><li><a href=https://martinfowler.com/articles/201701-event-driven.html>Martin Fowler – Event-Driven Architecture</a></li></ul><h3 id=기타-참고-아티클-및-커뮤니티-자료>기타 참고 아티클 및 커뮤니티 자료<a hidden class=anchor aria-hidden=true href=#기타-참고-아티클-및-커뮤니티-자료>#</a></h3><ul><li><a href=https://dev.to/mcsee/code-smell-271-the-hollywood-principle-3hh7>DEV Community: Code Smell 271 – The Hollywood Principle</a></li><li><a href=https://publish.obsidian.md/petermilovcik/Knowledge/Hollywood+Principle>Peter Miľovčík – Hollywood Principle and Patterns</a></li><li><a href=https://hackernoon.com/code-smell-271-the-hollywood-principle>HackerNoon – The Hollywood Principle의 설계적 의미</a></li><li><a href=https://johngrib.github.io/wiki/jargon/hollywood-principle/>기계인간 John Grib: 헐리우드 원칙과 의존성 부패</a></li><li><a href=https://doublem.org/Hollywood-Principle/>Doublem.org – 헐리우드 원칙의 실무적 의미</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/principles/>Principles</a></li><li><a href=https://buenhyden.github.io/tags/design-principles/>Design-Principles</a></li><li><a href=https://buenhyden.github.io/tags/inversion-of-control/>Inversion-of-Control</a></li><li><a href=https://buenhyden.github.io/tags/hollywood-principle/>Hollywood-Principle</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/jwt/rfc-7519/><span class=title>« Prev</span><br><span>RFC 7519</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-fundamentals/api-lifecycle-management/><span class=title>Next »</span><br><span>API Lifecycle Management</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>