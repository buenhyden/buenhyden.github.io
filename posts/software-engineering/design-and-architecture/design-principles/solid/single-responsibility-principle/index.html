<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Single Responsibility Principle | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles,Solid,Single-Responsibility-Principle"><meta name=description content="Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/single-responsibility-principle/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/single-responsibility-principle/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/single-responsibility-principle/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/single-responsibility-principle/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Single Responsibility Principle"><meta property="og:description" content="Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Single Responsibility Principle"><meta name=twitter:description content="Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/"},{"@type":"ListItem","position":5,"name":"SOLID Principles","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/"},{"@type":"ListItem","position":6,"name":"Single Responsibility Principle","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/single-responsibility-principle/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/>Design Principles</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/solid/>SOLID Principles</a></div><h1>Single Responsibility Principle</h1><div class=post-description>Single Responsibility Principle(SRP) 는 클래스나 모듈이 하나의 책임만을 가져야 한다는 객체 지향 설계 원칙이다. 이는 변경 이유를 하나로 제한하여 코드의 응집도를 높이고 유지보수를 용이하게 한다.</div></header><div class=post-content><h2 id=single-responsibility-principle>Single Responsibility Principle<a hidden class=anchor aria-hidden=true href=#single-responsibility-principle>#</a></h2><p>Single Responsibility Principle(단일 책임 원칙, SRP) 은 SOLID 설계 원칙 중 하나로, " 클래스, 모듈, 함수 등은 오직 하나의 책임만을 가져야 하며, 단 하나의 변경 이유만을 가져야 한다 " 는 원칙이다. SRP 를 적용하면 각 클래스가 명확한 역할을 갖고, 코드의 응집도가 높아지며, 유지보수성과 테스트 용이성이 크게 향상된다. SRP 는 대규모 시스템, 마이크로서비스, 도메인 주도 설계 등 다양한 환경에서 핵심적으로 적용된다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><h4 id=정의-및-기본-개념>정의 및 기본 개념<a hidden class=anchor aria-hidden=true href=#정의-및-기본-개념>#</a></h4><ul><li><strong>책임 (Responsibility):</strong> 모듈이 수행해야 하는 기능이나 역할을 의미한다.</li><li><strong>단일 책임</strong>: 클래스나 모듈이 오직 하나의 기능이나 역할만을 담당해야 함</li><li><strong>변경의 이유</strong>: 클래스가 변경되어야 하는 이유가 단 하나여야 함</li><li><strong>Actor</strong>: 변경을 요구하는 이해관계자 그룹</li><li><strong>응집성 (Cohesion)</strong>: 관련된 기능들이 하나의 모듈에 집중되는 정도</li><li><strong>결합도 (Coupling)</strong>: 모듈 간의 의존성 정도</li></ul><h4 id=핵심-원리>핵심 원리<a hidden class=anchor aria-hidden=true href=#핵심-원리>#</a></h4><ol><li><strong>분리의 원칙</strong>: 서로 다른 이유로 변경되는 기능들을 분리</li><li><strong>단일 목적</strong>: 각 구성요소는 명확하고 단일한 목적을 가져야 함</li><li><strong>변경 격리</strong>: 한 기능의 변경이 다른 기능에 영향을 주지 않아야 함</li></ol><pre class=mermaid>graph TD
    A[단일 책임 원칙] --&gt; B[하나의 책임]
    A --&gt; C[하나의 변경 이유]
    A --&gt; D[하나의 Actor]
    
    B --&gt; E[명확한 목적]
    B --&gt; F[기능적 응집성]
    
    C --&gt; G[변경 격리]
    C --&gt; H[영향 범위 최소화]
    
    D --&gt; I[이해관계자 분리]
    D --&gt; J[요구사항 분할]
</pre><h3 id=배경-및-필요성>배경 및 필요성<a hidden class=anchor aria-hidden=true href=#배경-및-필요성>#</a></h3><h4 id=발전-배경>발전 배경<a hidden class=anchor aria-hidden=true href=#발전-배경>#</a></h4><ul><li><strong>1970 년대</strong>: Tom DeMarco 의 응집성 개념에서 시작</li><li><strong>1979 년</strong>: Structured Analysis and System Specification 에서 응집도 원리 제시</li><li><strong>2002 년</strong>: Robert C. Martin 이 SOLID 원칙의 일부로 공식화</li><li><strong>2003 년</strong>: &ldquo;Agile Software Development, Principles, Patterns, and Practices&rdquo; 저서에서 구체화</li><li><strong>2014 년</strong>: Martin 이 " 변경의 이유 " 개념을 명확히 정의</li></ul><h4 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h4><ol><li><strong>코드 복잡성 감소</strong>: 각 구성요소의 역할을 명확히 하여 이해하기 쉬운 코드 작성</li><li><strong>유지보수성 향상</strong>: 변경 사항의 영향 범위를 제한하여 안전한 수정 가능</li><li><strong>재사용성 증대</strong>: 단일 목적의 구성요소는 다른 컨텍스트에서 재사용 용이</li><li><strong>테스트 용이성</strong>: 각 구성요소를 독립적으로 테스트 가능</li><li><strong>병렬 개발</strong>: 서로 다른 팀이 독립적으로 개발 가능</li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li><strong>역할 분리</strong>: 각 클래스/모듈이 한 가지 책임만 담당.</li><li><strong>변경 영향 최소화</strong>: 한 책임의 변경이 다른 책임에 영향을 주지 않음.</li><li><strong>응집도 향상</strong>: 관련 기능이 한 곳에 모여 있어 코드 관리가 쉬움.</li></ul><h4 id=설계-차원의-역할>설계 차원의 역할<a hidden class=anchor aria-hidden=true href=#설계-차원의-역할>#</a></h4><ul><li><strong>아키텍처 정리</strong>: 시스템을 논리적이고 일관성 있는 구조로 조직화</li><li><strong>의존성 관리</strong>: 모듈 간 불필요한 의존성 제거</li><li><strong>인터페이스 정의</strong>: 명확한 책임 경계를 통한 인터페이스 설계</li></ul><h4 id=개발-차원의-역할>개발 차원의 역할<a hidden class=anchor aria-hidden=true href=#개발-차원의-역할>#</a></h4><ul><li><strong>코드 품질 향상</strong>: 가독성, 유지보수성, 확장성 개선</li><li><strong>버그 감소</strong>: 변경 사항의 부작용 최소화</li><li><strong>개발 효율성</strong>: 명확한 책임 분할로 개발자 간 협업 개선</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><h4 id=설계적-특징>설계적 특징<a hidden class=anchor aria-hidden=true href=#설계적-특징>#</a></h4><ul><li><strong>단순성</strong>: 각 구성요소가 하나의 명확한 목적을 가짐</li><li><strong>예측가능성</strong>: 변경의 영향 범위를 예측하기 쉬움</li><li><strong>모듈성</strong>: 독립적으로 동작하는 구성요소들의 조합</li></ul><h4 id=구현적-특징>구현적 특징<a hidden class=anchor aria-hidden=true href=#구현적-특징>#</a></h4><ul><li><strong>높은 응집성</strong>: 관련 기능들이 하나의 모듈에 집중</li><li><strong>낮은 결합도</strong>: 모듈 간 의존성 최소화</li><li><strong>명확한 인터페이스</strong>: 각 모듈의 역할이 인터페이스를 통해 명확히 드러남</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><p>SRP 는 모듈이 하나의 책임만을 가지도록 설계하여, 변경의 이유를 하나로 제한한다. 이를 통해 코드의 응집도를 높이고, 변경에 따른 영향을 최소화한다.</p><h4 id=기본-원칙>기본 원칙<a hidden class=anchor aria-hidden=true href=#기본-원칙>#</a></h4><ol><li><strong>단일 책임</strong>: 클래스는 오직 하나의 책임만을 가져야 함</li><li><strong>단일 변경 이유</strong>: 클래스가 변경되는 이유는 오직 하나여야 함</li><li><strong>단일 Actor</strong>: 클래스는 하나의 이해관계자 그룹에만 책임을 져야 함</li></ol><h4 id=적용-원칙>적용 원칙<a hidden class=anchor aria-hidden=true href=#적용-원칙>#</a></h4><pre class=mermaid>flowchart TD
    A[요구사항 분석] --&gt; B{여러 책임 존재?}
    B --&gt;|Yes| C[책임 분리]
    B --&gt;|No| D[단일 책임 유지]
    
    C --&gt; E[별도 클래스 생성]
    E --&gt; F[인터페이스 정의]
    F --&gt; G[의존성 주입]
    
    D --&gt; H[구현 완료]
    G --&gt; H
</pre><h3 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h3><h4 id=식별-과정>식별 과정<a hidden class=anchor aria-hidden=true href=#식별-과정>#</a></h4><ol><li><strong>책임 식별</strong>: 클래스나 모듈이 수행하는 모든 기능 나열</li><li><strong>변경 이유 분석</strong>: 각 기능이 변경될 수 있는 이유 파악</li><li><strong>Actor 구분</strong>: 변경을 요구하는 이해관계자 그룹 식별</li><li><strong>분리 결정</strong>: 서로 다른 이유로 변경되는 기능들을 별도 모듈로 분리</li></ol><h4 id=리팩토링-과정>리팩토링 과정<a hidden class=anchor aria-hidden=true href=#리팩토링-과정>#</a></h4><pre class=mermaid>sequenceDiagram
    participant Dev as 개발자
    participant Code as 기존 코드
    participant Analysis as 분석
    participant Refactor as 리팩토링

    Dev-&gt;&gt;Code: 다중 책임 클래스 식별
    Code-&gt;&gt;Analysis: 책임 분석
    Analysis-&gt;&gt;Analysis: 변경 이유 파악
    Analysis-&gt;&gt;Refactor: Extract Class 적용
    Refactor-&gt;&gt;Refactor: 인터페이스 정의
    Refactor-&gt;&gt;Dev: 단일 책임 클래스들
</pre><h4 id=아키텍처-다이어그램>아키텍처 다이어그램<a hidden class=anchor aria-hidden=true href=#아키텍처-다이어그램>#</a></h4><pre class=mermaid>classDiagram
    class UserController {
        +createUser(request)
        +updateUser(id, request)
        +deleteUser(id)
    }
    
    class UserService {
        +createUser(userData)
        +updateUser(id, userData)
        +deleteUser(id)
    }
    
    class UserRepository {
        +save(user)
        +findById(id)
        +delete(id)
    }
    
    class UserValidator {
        +validateUserData(userData)
        +validateEmail(email)
    }
    
    class EmailService {
        +sendWelcomeEmail(user)
        +sendNotification(user, message)
    }
    
    UserController --&gt; UserService : uses
    UserService --&gt; UserRepository : uses
    UserService --&gt; UserValidator : uses
    UserService --&gt; EmailService : uses
</pre><table><thead><tr><th>구분</th><th>항목</th><th>기능</th><th>역할</th><th>특징</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>책임 경계 (Responsibility Boundary)</td><td>클래스나 모듈의 책임 범위 정의</td><td>책임 있는 부분과 없는 부분을 명확히 구분</td><td>이해하기 쉬운 경계 설정</td></tr><tr><td><strong>구성 요소</strong></td><td>인터페이스 (Interface)</td><td>구성요소 간 상호작용 방식 정의</td><td>구현 세부사항은 숨기고 계약만 제공</td><td>변경에 강하고 안정적인 설계</td></tr><tr><td><strong>구현 요소</strong></td><td>구현체 (Implementation)</td><td>실제 비즈니스 로직 수행</td><td>구체 기능 제공 및 단일 책임 집중</td><td>테스트 가능하고 유연한 변경 구조</td></tr><tr><td><strong>설계 기법</strong></td><td>의존성 주입 컨테이너 (DI Container)</td><td>의존성 관리 자동화</td><td>런타임에 적절한 구현체 주입</td><td>느슨한 결합 및 구성 유연성 확보</td></tr><tr><td><strong>디자인 패턴</strong></td><td>팩토리 패턴 (Factory Pattern)</td><td>객체 생성 로직 캡슐화</td><td>생성 책임을 클라이언트로부터 분리</td><td>생성과 사용의 명확한 분리</td></tr></tbody></table><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>구현 기법</th><th>정의/구성</th><th>목적/예시</th></tr></thead><tbody><tr><td>역할별 클래스 분리</td><td>각 책임별로 클래스를 분리</td><td>서비스/저장소 분리, 컨트롤러/비즈니스 로직 분리 등</td></tr><tr><td>인터페이스/추상 클래스 활용</td><td>공통 기능 추상화, 구현체 분리</td><td>저장소 인터페이스, 출력 인터페이스 등</td></tr><tr><td>유틸리티 클래스 분리</td><td>공통 기능을 별도 유틸리티 클래스로 분리</td><td>날짜 처리, 포맷 변환 등</td></tr></tbody></table><h4 id=extract-class-기법>Extract Class 기법<a hidden class=anchor aria-hidden=true href=#extract-class-기법>#</a></h4><ul><li><strong>정의</strong>: 하나의 클래스에서 여러 책임을 별도 클래스로 분리</li><li><strong>구성</strong>: 원본 클래스, 추출될 클래스, 인터페이스</li><li><strong>목적</strong>: 과도한 책임을 가진 클래스를 단일 책임으로 분리</li><li><strong>예시</strong>: 사용자 관리 클래스에서 이메일 발송 기능을 별도 클래스로 분리</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 기존 - SRP 위반</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>UserManager</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>createUser</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>email</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 사용자 생성 로직</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>User</span><span class=w> </span><span class=n>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>User</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>email</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>database</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>user</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 이메일 발송 로직 (다른 책임)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Email</span><span class=w> </span><span class=n>email</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Email</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>email</span><span class=p>.</span><span class=na>setTo</span><span class=p>(</span><span class=n>user</span><span class=p>.</span><span class=na>getEmail</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>email</span><span class=p>.</span><span class=na>setSubject</span><span class=p>(</span><span class=s>&#34;환영합니다!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>emailSender</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>email</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 개선 - SRP 적용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>UserService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>EmailService</span><span class=w> </span><span class=n>emailService</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>createUser</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>email</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>User</span><span class=w> </span><span class=n>user</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>User</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>email</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>database</span><span class=p>.</span><span class=na>save</span><span class=p>(</span><span class=n>user</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>emailService</span><span class=p>.</span><span class=na>sendWelcomeEmail</span><span class=p>(</span><span class=n>user</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>EmailService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>sendWelcomeEmail</span><span class=p>(</span><span class=n>User</span><span class=w> </span><span class=n>user</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Email</span><span class=w> </span><span class=n>email</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Email</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>email</span><span class=p>.</span><span class=na>setTo</span><span class=p>(</span><span class=n>user</span><span class=p>.</span><span class=na>getEmail</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>email</span><span class=p>.</span><span class=na>setSubject</span><span class=p>(</span><span class=s>&#34;환영합니다!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>emailSender</span><span class=p>.</span><span class=na>send</span><span class=p>(</span><span class=n>email</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=extract-method-기법>Extract Method 기법<a hidden class=anchor aria-hidden=true href=#extract-method-기법>#</a></h4><ul><li><strong>정의</strong>: 큰 메소드에서 특정 기능을 별도 메소드로 분리</li><li><strong>구성</strong>: 원본 메소드, 추출된 메소드들, 주 로직</li><li><strong>목적</strong>: 메소드 레벨에서 단일 책임 원칙 적용</li><li><strong>예시</strong>: 복잡한 계산 로직을 여러 단계로 분리</li></ul><h4 id=interface-segregation-기법>Interface Segregation 기법<a hidden class=anchor aria-hidden=true href=#interface-segregation-기법>#</a></h4><ul><li><strong>정의</strong>: 큰 인터페이스를 작은 단위로 분리</li><li><strong>구성</strong>: 원본 인터페이스, 분리된 인터페이스들, 구현체</li><li><strong>목적</strong>: 클라이언트가 필요하지 않은 기능에 의존하지 않도록 함</li><li><strong>예시</strong>: 다기능 프린터 인터페이스를 출력, 스캔, 팩스 인터페이스로 분리</li></ul><h4 id=dependency-injection-기법>Dependency Injection 기법<a hidden class=anchor aria-hidden=true href=#dependency-injection-기법>#</a></h4><ul><li><strong>정의</strong>: 의존성을 외부에서 주입받아 결합도 감소</li><li><strong>구성</strong>: 의존성 인터페이스, 구현체, 주입 메커니즘</li><li><strong>목적</strong>: 구성요소 간 느슨한 결합으로 단일 책임 유지</li><li><strong>예시</strong>: 서비스 클래스에 리포지토리 인터페이스를 주입</li></ul><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>코드 가독성 향상</td><td>각 클래스의 목적이 명확하여 이해하기 쉬움</td></tr><tr><td></td><td>유지보수성 개선</td><td>변경 사항의 영향 범위가 제한되어 안전한 수정 가능</td></tr><tr><td></td><td>테스트 용이성</td><td>단일 책임으로 인해 독립적인 테스트 작성 가능</td></tr><tr><td></td><td>재사용성 증대</td><td>명확한 목적의 구성요소는 다른 컨텍스트에서 재사용 용이</td></tr><tr><td></td><td>병렬 개발 지원</td><td>서로 다른 팀이 독립적으로 개발 가능</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>동일한 기능을 위해 더 많은 클래스 필요</td></tr><tr><td></td><td>과도한 추상화</td><td>불필요한 추상화로 인한 코드 복잡성 증가</td></tr><tr><td></td><td>책임 정의의 어려움</td><td>적절한 책임 범위 결정의 주관성</td></tr><tr><td></td><td>성능 오버헤드</td><td>구성요소 간 통신으로 인한 성능 저하 가능성</td></tr><tr><td></td><td>초기 개발 비용</td><td>설계 단계에서 더 많은 시간과 노력 필요</td></tr></tbody></table><h4 id=단점-해결-방법>단점 해결 방법<a hidden class=anchor aria-hidden=true href=#단점-해결-방법>#</a></h4><p><strong>과도한 분할 방지</strong></p><ul><li>비즈니스 도메인 기준으로 적절한 추상화 수준 유지</li><li>KISS(Keep It Simple, Stupid) 원칙과의 균형 고려</li></ul><p><strong>성능 최적화</strong></p><ul><li>필요시 구성요소 간 통신 최소화</li><li>캐싱, 배치 처리 등 성능 개선 기법 적용</li></ul><p><strong>명확한 가이드라인 수립</strong></p><ul><li>팀 내 일관된 책임 정의 기준 마련</li><li>코드 리뷰를 통한 지속적인 개선</li></ul><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td><strong>책임 정의의 모호성</strong></td><td>무엇이 단일 책임인지 정의하기 어려움</td><td>도메인 전문가와 협업, 변경 빈도 기준으로 책임 범위 정의</td></tr><tr><td><strong>역할 분리 기준의 불명확성</strong></td><td>역할의 경계가 불분명하면 설계가 복잡해짐</td><td>도메인 분석 기반 역할 정의, 코드 리뷰 강화</td></tr><tr><td><strong>과도한 역할 분할</strong></td><td>분할이 지나치면 관리할 클래스와 모듈이 지나치게 많아짐</td><td>실용적 관점에서 점진적 리팩토링 적용</td></tr><tr><td><strong>클래스/파일 수 증가</strong></td><td>분리로 인해 클래스 및 파일 수가 급증</td><td>패키지 구조 체계화, 네이밍 규칙 준수</td></tr><tr><td><strong>중복 코드 발생 위험</strong></td><td>동일한 기능을 여러 구현체에서 반복할 가능성</td><td>공통 기능을 유틸리티 클래스로 추출 및 재사용</td></tr><tr><td><strong>레거시 시스템 적용의 어려움</strong></td><td>기존 시스템에 원칙 적용 시 리팩토링 비용과 리스크가 큼</td><td>Strangler Fig 패턴을 활용한 점진적 전환</td></tr><tr><td><strong>팀 간 커뮤니케이션 오버헤드</strong></td><td>모듈 분리로 인한 팀 간 협업 복잡성</td><td>명확한 인터페이스 정의, 설계 문서화 및 아키텍처 가이드 공유</td></tr></tbody></table><h3 id=분류-기준에-따른-종류-및-유형>분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류-기준에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th><th>예시</th></tr></thead><tbody><tr><td>적용 레벨</td><td>클래스 레벨</td><td>개별 클래스의 단일 책임</td><td>UserService, EmailService</td></tr><tr><td></td><td>모듈 레벨</td><td>패키지/모듈의 단일 책임</td><td>인증 모듈, 결제 모듈</td></tr><tr><td></td><td>서비스 레벨</td><td>마이크로서비스의 단일 책임</td><td>사용자 서비스, 주문 서비스</td></tr><tr><td>책임 유형</td><td>데이터 처리</td><td>데이터 변환, 검증, 포맷팅</td><td>DataValidator, DataFormatter</td></tr><tr><td></td><td>비즈니스 로직</td><td>핵심 업무 규칙 처리</td><td>OrderCalculator, InventoryManager</td></tr><tr><td></td><td>외부 연동</td><td>외부 시스템과의 통신</td><td>PaymentGateway, EmailSender</td></tr><tr><td></td><td>인프라 관리</td><td>기술적 관심사 처리</td><td>DatabaseConnection, Logger</td></tr><tr><td>분리 전략</td><td>수직 분리</td><td>계층별 책임 분리</td><td>Controller, Service, Repository</td></tr><tr><td></td><td>수평 분리</td><td>기능별 책임 분리</td><td>UserManager, ProductManager</td></tr><tr><td></td><td>시간적 분리</td><td>생명주기별 책임 분리</td><td>Factory, Destroyer</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>영역</th><th>적용 사례</th><th>분리 전 구조</th><th>분리 후 구조</th><th>기대 효과</th></tr></thead><tbody><tr><td>웹 개발</td><td>MVC 패턴</td><td>모든 로직이 하나의 클래스</td><td>Controller, Service, Repository 계층 분리</td><td>계층별 책임 명확화, 유지보수 용이</td></tr><tr><td>데이터 처리</td><td>ETL 파이프라인 분리</td><td>추출·변환·적재 통합 처리</td><td>Extractor, Transformer, Loader 모듈 분리</td><td>각 단계별 독립적 개발 및 테스트 가능</td></tr><tr><td>인증 시스템</td><td>인증/인가/세션 분리</td><td>인증 기능 통합</td><td>AuthService, AuthorizationService, SessionService</td><td>보안 책임 분리, 기능별 테스트 용이</td></tr><tr><td>결제 시스템</td><td>결제 프로세스 분리</td><td>검증·처리·알림 통합</td><td>PaymentValidator, PaymentProcessor, NotificationService</td><td>단계별 안정성 확보 및 기능 확장 용이</td></tr><tr><td>로깅 시스템</td><td>로그 수집/처리/저장 책임 분리</td><td>로그 기능이 하나의 클래스에 집중</td><td>LogCollector, LogFormatter, LogStorage</td><td>성능 최적화 및 포맷 다양성 대응 가능</td></tr><tr><td>사용자 관리 시스템</td><td>사용자 정보 관리 vs 인증 분리</td><td>단일 모듈에 모든 사용자 기능 포함</td><td>UserProfileService, AuthenticationService</td><td>책임 명확화, 보안 기능 독립화</td></tr><tr><td>백엔드 서비스</td><td>비즈니스 로직과 저장소 책임 분리</td><td>단일 서비스 클래스</td><td>Service, Repository 인터페이스 및 구현 분리</td><td>DIP 적용으로 테스트 용이성 증가</td></tr><tr><td>프론트엔드 컴포넌트</td><td>역할별 UI 분리</td><td>UI 처리 통합</td><td>ViewComponent, EventHandlerComponent 등 역할 기반 분리</td><td>재사용성 향상, 유지보수 용이</td></tr><tr><td>유틸리티 관리</td><td>공통 기능 유틸 클래스 분리</td><td>기능 중복 존재</td><td>DateUtil, FormatUtil 등 독립 클래스 구성</td><td>중복 제거, 코드 일관성 확보</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-전자상거래-주문-시스템>사례 1: 전자상거래 주문 시스템<a hidden class=anchor aria-hidden=true href=#사례-1-전자상거래-주문-시스템>#</a></h4><p><strong>시나리오</strong>: 온라인 쇼핑몰의 주문 처리 시스템을 SRP 를 적용하여 설계하는 사례</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    A[OrderController] --&gt; B[OrderService]
    B --&gt; C[PaymentService]
    B --&gt; D[InventoryService]
    B --&gt; E[ShippingService]
    B --&gt; F[NotificationService]
    
    C --&gt; G[PaymentGateway]
    D --&gt; H[InventoryRepository]
    E --&gt; I[ShippingProvider]
    F --&gt; J[EmailService]
    F --&gt; K[SMSService]
    
    H --&gt; L[(Database)]
    G --&gt; M[외부 결제 API]
    I --&gt; N[배송업체 API]
</pre><p><strong>각 구성요소의 단일 책임</strong>:</p><ul><li><strong>OrderController</strong>: HTTP 요청/응답 처리만 담당</li><li><strong>OrderService</strong>: 주문 비즈니스 로직 조율</li><li><strong>PaymentService</strong>: 결제 처리 로직</li><li><strong>InventoryService</strong>: 재고 관리</li><li><strong>ShippingService</strong>: 배송 처리</li><li><strong>NotificationService</strong>: 알림 발송</li></ul><p><strong>Workflow</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Client
    participant OrderController
    participant OrderService
    participant PaymentService
    participant InventoryService
    participant ShippingService
    participant NotificationService

    Client-&gt;&gt;OrderController: 주문 요청
    OrderController-&gt;&gt;OrderService: 주문 처리 요청
    OrderService-&gt;&gt;InventoryService: 재고 확인
    InventoryService--&gt;&gt;OrderService: 재고 상태
    OrderService-&gt;&gt;PaymentService: 결제 처리
    PaymentService--&gt;&gt;OrderService: 결제 결과
    OrderService-&gt;&gt;ShippingService: 배송 요청
    ShippingService--&gt;&gt;OrderService: 배송 정보
    OrderService-&gt;&gt;NotificationService: 알림 발송
    NotificationService--&gt;&gt;OrderService: 발송 완료
    OrderService--&gt;&gt;OrderController: 처리 결과
    OrderController--&gt;&gt;Client: 응답
</pre><p><strong>SRP 적용 효과</strong>:</p><ul><li><strong>유지보수성</strong>: 결제 로직 변경 시 PaymentService 만 수정</li><li><strong>확장성</strong>: 새로운 결제 수단 추가 시 기존 코드 영향 없음</li><li><strong>테스트 용이성</strong>: 각 서비스를 독립적으로 테스트 가능</li><li><strong>재사용성</strong>: NotificationService 를 다른 기능에서도 활용 가능</li></ul><h4 id=사례-2-온라인-학습-플랫폼>사례 2: 온라인 학습 플랫폼<a hidden class=anchor aria-hidden=true href=#사례-2-온라인-학습-플랫폼>#</a></h4><p><strong>시나리오</strong>: 온라인 학습 플랫폼</p><p><strong>시스템 구성</strong>:</p><ul><li><code>CourseManager</code>: 강좌 생성, 수정, 삭제 (→ SRP 위반)</li><li>SRP 준수 시 다음과 같이 분리:<ul><li><code>CourseCreator</code></li><li><code>CourseEditor</code></li><li><code>CourseDeleter</code></li></ul></li></ul><p><strong>시스템 아키텍처 다이어그램</strong></p><pre class=mermaid>classDiagram
  class CourseCreator {
    +createCourse()
  }

  class CourseEditor {
    +editCourse()
  }

  class CourseDeleter {
    +deleteCourse()
  }

  class Frontend {
    +handleUserInput()
  }

  Frontend --&gt; CourseCreator
  Frontend --&gt; CourseEditor
  Frontend --&gt; CourseDeleter
</pre><p><strong>Workflow</strong>:</p><ol><li>사용자가 강좌 생성 요청</li><li><code>CourseCreator</code> 가 요청 처리</li><li>강좌 편집 요청 시 <code>CourseEditor</code> 가 처리</li><li>삭제 요청은 <code>CourseDeleter</code> 가 처리</li></ol><p><strong>역할 분리 효과</strong>:</p><ul><li>코드 테스트가 용이해짐</li><li>요구사항 변경에 유연하게 대응</li><li>DevOps 관점에서 기능별 CI/CD 적용 가능</li></ul><h3 id=실무-적용-고려사항-및-권장사항>실무 적용 고려사항 및 권장사항<a hidden class=anchor aria-hidden=true href=#실무-적용-고려사항-및-권장사항>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설계 단계</strong></td><td>책임 정의 명확화</td><td>모듈 또는 클래스의 역할을 혼동하지 않도록 함</td><td>도메인 전문가와 협업하여 명확한 책임 경계 설정</td></tr><tr><td></td><td>변경 빈도 분석</td><td>자주 바뀌는 기능을 기준으로 책임을 분리</td><td>과거 변경 이력 분석, 요구사항 중심 설계</td></tr><tr><td></td><td>적절한 추상화 수준</td><td>과도한 추상화는 유지보수를 어렵게 할 수 있음</td><td>기능 중심의 실용적 추상화 적용</td></tr><tr><td><strong>구현 단계</strong></td><td>인터페이스 우선 설계</td><td>구현체보다 추상화 중심의 구조를 먼저 정의함</td><td>인터페이스 기반 의존성 설계로 DIP 준수</td></tr><tr><td></td><td>점진적 리팩토링</td><td>초기 도입 시 전체 재설계보다 점진적 적용이 효과적</td><td>기능 단위로 단계적 구조 개선</td></tr><tr><td></td><td>테스트 주도 개발 (TDD)</td><td>구조적 책임 분리를 테스트와 병행할 수 있음</td><td>단위 테스트 기반 개발로 자연스럽게 SRP 유도</td></tr><tr><td><strong>운영 단계</strong></td><td>코드/파일 증가</td><td>역할 분리로 인해 클래스 및 파일 수 증가 가능성</td><td>패키지 구조 체계화, 네이밍 표준화, 문서화</td></tr><tr><td></td><td>코드 중복</td><td>공통 로직이 여러 모듈에 반복될 가능성</td><td>유틸리티 클래스 또는 공통 인터페이스 추출</td></tr><tr><td></td><td>모듈 간 결합도</td><td>모듈 간 강한 의존은 유지보수 비용을 높임</td><td>인터페이스/DI 활용하여 결합도 최소화</td></tr><tr><td></td><td>지속적 모니터링</td><td>리팩토링 시점이나 책임 범위 재조정 타이밍 판단 필요</td><td>변경 빈도, 코드 복잡도 등의 지표 기반으로 개선 계획 수립</td></tr><tr><td><strong>팀 협업</strong></td><td>팀 내 일관성 확보</td><td>SRP/DIP 등 원칙 적용에 대한 이해도 차이 발생 가능성</td><td>정기적 교육, 코드 리뷰 기준 설정, 아키텍처 가이드 공유</td></tr></tbody></table><h3 id=최적화-고려사항-및-주의할-점>최적화 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>성능 최적화</strong></td><td>구성요소 간 통신 비용</td><td>모듈 간 과도한 호출로 인한 오버헤드 발생 가능</td><td>인터페이스 통한 일괄 처리, 캐싱 전략 적용</td></tr><tr><td></td><td>메모리 사용량</td><td>객체 과다 생성 시 GC(Garbage Collection) 부담 증가</td><td>객체 풀링 (Pooling), 싱글톤 (Singleton) 등으로 관리</td></tr><tr><td></td><td>네트워크 호출 최적화</td><td>마이크로서비스, 분산 환경에서 네트워크 비용 발생</td><td>배치 호출, GraphQL, API Gateway 활용 등으로 호출 최소화</td></tr><tr><td><strong>구조 최적화</strong></td><td>의존성 그래프 관리</td><td>순환 의존 발생 시 구조 불안정</td><td>의존성 방향 명확화, 계층 아키텍처 또는 헥사고날 아키텍처 적용</td></tr><tr><td></td><td>인터페이스 안정성</td><td>자주 바뀌는 인터페이스는 의존 모듈에 영향을 줌</td><td>도메인 안정성 기준으로 인터페이스 설계, 의사결정 기록 (ADR) 문서화</td></tr><tr><td></td><td>모듈 경계 최적화</td><td>과도한 모듈화 시 복잡도 증가</td><td>도메인/기능 기준으로 합리적 분할, 역할/경계 명확화</td></tr><tr><td><strong>개발 최적화</strong></td><td>코드 중복</td><td>책임 분리 중 반복 로직 발생 가능</td><td>공통 기능을 유틸리티 또는 공유 서비스로 모듈화</td></tr><tr><td></td><td>개발 생산성</td><td>과도한 보일러플레이트 (boilerplate) 로 개발 속도 저하</td><td>DI 프레임워크 (Spring, NestJS 등) 적극 활용, 코드 생성 도구 사용</td></tr><tr><td></td><td>문서화 자동화</td><td>구조가 복잡해질수록 문서 미비로 협업 어려움</td><td>README, ADR 문서, Swagger, Typedoc 등 자동 문서화 도구 활용</td></tr><tr><td><strong>설계 최적화</strong></td><td>역할 정의/경계 불분명</td><td>SRP(단일 책임 원칙) 적용 시 경계 설정이 모호할 수 있음</td><td>도메인 분석 기반 역할 정의, 표준화 및 코드 리뷰 강화</td></tr><tr><td></td><td>변경 용이성</td><td>요구사항 변화 시 유연하게 대처 가능한 구조 필요</td><td>OCP(개방 - 폐쇄 원칙), SRP 원칙 기반 설계 적용</td></tr><tr><td></td><td>테스트 용이성</td><td>모듈 간 결합도가 높으면 테스트 어려움</td><td>의존성 주입 (DI) 기반 테스트 구조 구성, 단위 테스트 우선 설계</td></tr><tr><td><strong>운영/협업 최적화</strong></td><td>모듈 경량화</td><td>지나친 분할로 인한 유지보수 및 배포 복잡성 증가</td><td>기능 단위로 경량화, 디렉토리 구조 명확화</td></tr><tr><td></td><td>모듈 재사용성</td><td>비슷한 책임의 모듈을 반복 개발하게 될 수 있음</td><td>일반화된 인터페이스 설계 및 공유 모듈화</td></tr><tr><td></td><td>의사소통 명확성</td><td>구조가 복잡할수록 팀원 간 책임/경계 혼란 발생 가능</td><td>책임 및 경계 문서화, 정기적인 아키텍처 공유 및 리뷰</td></tr></tbody></table><h3 id=srp-관련-주요-문제와-해결-방안>SRP 관련 주요 문제와 해결 방안<a hidden class=anchor aria-hidden=true href=#srp-관련-주요-문제와-해결-방안>#</a></h3><table><thead><tr><th>문제 유형</th><th>원인</th><th>영향</th><th>탐지/진단 방법</th><th>예방 방안</th><th>해결 전략</th></tr></thead><tbody><tr><td><strong>책임 모호화</strong></td><td>책임 정의가 불분명하거나 도메인 분석 부족</td><td>변경 충돌, 설계 오해, 테스트 난이도 상승</td><td>설계 리뷰, 변경 이력 분석, 코드 리뷰</td><td>도메인 전문가 협업, 명세 기반 책임 문서화</td><td>책임 재정의, 역할 분할, 클래스 분리</td></tr><tr><td><strong>과도한 역할 분리</strong></td><td>모든 기능을 억지로 분리하려는 잘못된 SRP 해석</td><td>클래스/파일 수 증가, 보일러플레이트 증가, 설계 복잡도 증가</td><td>클래스 수 증가 모니터링, 정적 분석 툴 (Coupling/Complexity)</td><td>실용적 SRP 해석 적용 (비즈니스/변경 단위 기준)</td><td>일부 모듈 통합, 리팩토링</td></tr><tr><td><strong>God Class</strong></td><td>여러 책임이 한 클래스에 집중되어 있음</td><td>높은 결합도, 낮은 응집도, 테스트/유지보수 복잡성</td><td>클래스 크기 (라인/메서드 수), 의존성 수, 복잡도 메트릭 (Cyclomatic)</td><td>정기적 코드 리뷰, 모듈 응집도 평가</td><td><code>Extract Class</code>, <code>Extract Method</code> 리팩토링</td></tr><tr><td><strong>Shotgun Surgery</strong></td><td>단일 책임이 제대로 분리되지 않아 다양한 곳에서 동시에 변경 발생</td><td>유지보수 리스크 증가, 생산성 저하</td><td>변경 이력 분석 (버전 관리 시스템), 변경 빈도 추적</td><td>연관 기능은 하나의 클래스/모듈로 집중</td><td><code>Move Method</code>, <code>Move Field</code> 리팩토링</td></tr><tr><td><strong>Feature Envy</strong></td><td>기능이 다른 클래스의 데이터에 과도하게 의존</td><td>캡슐화 위반, 불필요한 결합도 증가</td><td>메소드 호출 패턴 분석, 정적 분석 도구 사용</td><td>데이터와 책임의 일치 유지, 정보 은닉 원칙 준수</td><td><code>Move Method</code> 를 통해 기능 이동</td></tr><tr><td><strong>Large Class</strong></td><td>장기간 책임이 누적되어 클래스가 비대화됨</td><td>테스트 어려움, 변경 충돌 위험 증가</td><td>클래스 라인/필드/메소드 수 분석, 응집도 (Cohesion) 분석</td><td>관심사 분리 기반 설계, 기능별 구조 정의</td><td><code>Extract Class</code>, <code>Extract Subclass</code> 패턴</td></tr><tr><td><strong>Divergent Change</strong></td><td>클래스가 다양한 이유로 자주 변경됨</td><td>예측 불가한 변경 전파, 유지보수 난이도 증가</td><td>변경 이력 분석, 이유별 변경 빈도 분류</td><td>변경 이유 기준 책임 분리 (기능/도메인 중심)</td><td><code>Extract Class</code> 로 변경 이유별 클래스 분리</td></tr><tr><td><strong>Middle Man</strong></td><td>지나치게 위임만 하는 클래스가 생김 (SRP 적용의 부작용)</td><td>성능 오버헤드, 코드 복잡성, 설계 이해도 저하</td><td>위임만 하는 클래스 탐지, 로직 비율 분석</td><td>위임 필요성 명확히 판단 후 설계 결정</td><td><code>Remove Middle Man</code> 리팩토링</td></tr><tr><td><strong>모듈 간 의존성 증가</strong></td><td>책임 분리 이후 모듈 간 공유 데이터/행동 증가</td><td>결합도 증가, 변화 전파 위험성</td><td>DI 사용 로그, 영향도 분석 도구</td><td>이벤트 기반 아키텍처, 안정적 인터페이스 정의</td><td>Pub/Sub, 메시지 큐, 인터페이스 개선 등으로 통신 구조 재설계</td></tr><tr><td><strong>코드 중복 발생</strong></td><td>유사한 책임을 분산하면서 공통 기능이 중복됨</td><td>중복 로직, 유지보수 비용 증가, 버그 유발 가능성</td><td>중복 탐지 도구 (e.g., SonarQube), 코드 리뷰</td><td>공통 로직 유틸리티화, 인터페이스 기반 공통 책임 관리</td><td><code>Extract Utility Class</code>, Template 패턴 등 재사용 구조 설계</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>SRP (단일 책임 원칙)</td><td>클래스/모듈은 하나의 책임만 가져야 하며, 변경 이유도 하나여야 함</td></tr><tr><td></td><td>OCP (개방/폐쇄 원칙)</td><td>확장에는 열려 있고, 기존 코드는 수정하지 않아야 함</td></tr><tr><td></td><td>LSP (리스코프 치환 원칙)</td><td>하위 타입은 상위 타입을 완전히 대체할 수 있어야 함</td></tr><tr><td></td><td>ISP (인터페이스 분리 원칙)</td><td>클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 함</td></tr><tr><td></td><td>DIP (의존성 역전 원칙)</td><td>고수준, 저수준 모듈 모두 추상화에 의존해야 하며 구체 구현에 의존하면 안 됨</td></tr><tr><td><strong>설계 패턴</strong></td><td>Strategy Pattern</td><td>알고리즘을 캡슐화하여 런타임에 동적으로 교체 가능</td></tr><tr><td></td><td>Command Pattern</td><td>요청을 객체로 캡슐화하여 요청 매개변수화 및 실행 큐 지원</td></tr><tr><td></td><td>Observer Pattern</td><td>상태 변화가 발생하면 관련 객체 (구독자) 에게 자동 통보</td></tr><tr><td></td><td>Factory Pattern</td><td>객체 생성을 전담하는 클래스를 통해 생성 책임과 사용 책임을 분리</td></tr><tr><td><strong>코드 품질</strong></td><td>Code Smell</td><td>유지보수에 불리한 구조나 설계상의 문제점을 암시하는 코드 패턴</td></tr><tr><td></td><td>Refactoring</td><td>기능은 동일하게 유지하면서 코드 구조를 개선하는 작업</td></tr><tr><td></td><td>Clean Code</td><td>읽기 쉽고, 예측 가능하며, 변경에 강한 고품질 코드 작성 원칙</td></tr><tr><td></td><td>Technical Debt</td><td>빠른 개발을 위해 축적된 구조적 부채, 장기적으로 유지보수 비용 증가 원인</td></tr><tr><td><strong>아키텍처</strong></td><td>Microservices</td><td>단일 책임 원칙에 기반한 작고 독립적인 서비스 간 통신 구조</td></tr><tr><td></td><td>Domain-Driven Design (DDD)</td><td>도메인 모델을 기반으로 책임과 경계를 명확히 나누는 설계 전략</td></tr><tr><td></td><td>Hexagonal Architecture</td><td>내부 비즈니스 로직과 외부 시스템 (데이터베이스, UI 등) 의 의존성을 명확히 분리</td></tr><tr><td></td><td>Clean Architecture</td><td>의존성 규칙을 적용하여 계층별로 책임과 변경 가능성을 통제</td></tr><tr><td><strong>실무 적용</strong></td><td>책임 분리 기반 계층 구조</td><td>예: Controller / Service / Repository 로 계층 분리</td></tr><tr><td></td><td>유틸리티 및 공통 모듈 분리</td><td>공통 기능을 분리해 재사용성 증대 및 코드 중복 최소화</td></tr><tr><td></td><td>테스트 가능 구조</td><td>SRP + DIP 기반으로 Mocking 이 쉬운 구조 설계로 테스트 용이성 확보</td></tr></tbody></table><hr><h3 id=심화학습-및-연계-주제>심화학습 및 연계 주제<a hidden class=anchor aria-hidden=true href=#심화학습-및-연계-주제>#</a></h3><table><thead><tr><th>카테고리</th><th>주제/패턴 또는 기법</th><th>설명</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>OCP (개방/폐쇄 원칙)</td><td>SRP 기반 구조는 OCP 적용의 기초가 되며, 변경 없이 기능 확장 가능</td></tr><tr><td></td><td>ISP (인터페이스 분리 원칙)</td><td>책임 단위에 맞춘 인터페이스 설계를 통해 SRP 와 시너지 생성</td></tr><tr><td></td><td>Law of Demeter (데메테르 법칙)</td><td>낮은 결합도 유지를 위한 최소 지식 원칙, SRP 기반 설계에 부합</td></tr><tr><td></td><td>DRY / YAGNI</td><td>중복 제거와 불필요한 책임 방지를 통해 SRP 보조</td></tr><tr><td><strong>리팩토링 기법</strong></td><td>Extract Class / Method</td><td>책임 분리를 위한 대표적 기법, 하나의 클래스가 두 개 이상의 책임을 질 경우 유용</td></tr><tr><td></td><td>Move Method / Move Field</td><td>책임에 따라 메소드나 필드를 적절한 클래스로 이동하여 응집도 개선</td></tr><tr><td></td><td>Replace Conditional with Polymorphism</td><td>역할에 따라 조건문을 다형성으로 대체하여 단일 책임 구현</td></tr><tr><td></td><td>Introduce Parameter Object</td><td>연관된 매개변수들을 묶어 책임 단위 객체로 추출</td></tr><tr><td><strong>테스트 전략</strong></td><td>Unit Testing / Mock Objects</td><td>SRP 구조에서는 단위 테스트가 단순하며 모의 객체 사용 용이</td></tr><tr><td></td><td>Test-Driven Development (TDD)</td><td>SRP 에 적합한 설계를 자연스럽게 유도</td></tr><tr><td></td><td>Behavior-Driven Development (BDD)</td><td>행위 중심 테스트를 통해 책임 명확화</td></tr><tr><td><strong>아키텍처 및 시스템</strong></td><td>Microservices Architecture</td><td>서비스 단위로 SRP 적용, 각 서비스는 독립된 단일 책임 수행</td></tr><tr><td></td><td>Layered Architecture</td><td>Controller, Service, Repository 계층 간 책임 분리 적용</td></tr><tr><td></td><td>Hexagonal Architecture / Clean Architecture</td><td>내부 도메인 로직과 외부 의존성 분리를 통해 SRP 구조화</td></tr><tr><td></td><td>Event-Driven Architecture</td><td>모듈 간 강한 결합을 제거하고 이벤트 단위로 책임 분리</td></tr><tr><td></td><td>CQRS / Event Sourcing</td><td>읽기/쓰기 또는 상태 변경을 별도 책임으로 분리</td></tr><tr><td><strong>도메인 설계</strong></td><td>DDD (Domain-Driven Design)</td><td>Bounded Context 기반으로 책임 단위 도출</td></tr><tr><td></td><td>Repository Pattern / Unit of Work</td><td>데이터 액세스 책임을 별도 계층으로 분리하여 SRP 적용</td></tr><tr><td><strong>함수형 프로그래밍</strong></td><td>Pure Function / Immutability</td><td>부작용 없는 함수와 불변성을 활용해 단일 책임 함수 설계</td></tr><tr><td></td><td>Function Composition</td><td>작은 책임 함수 조합으로 복잡한 로직 구성</td></tr><tr><td><strong>문서화 및 관리</strong></td><td>ADR (Architecture Decision Record)</td><td>책임 분리 기준과 설계 이유를 기록</td></tr><tr><td></td><td>README / UML / 설계 리뷰</td><td>SRP 적용 결과 및 책임 단위 명세 공유</td></tr><tr><td><strong>DevOps/자동화</strong></td><td>Infrastructure as Code / CI-CD Pipeline</td><td>빌드, 테스트, 배포 단계를 모듈별로 책임 분리</td></tr><tr><td></td><td>Container Orchestration (K8s 등)</td><td>컨테이너 단위로 책임 단일화, 독립 배포 가능 구조 설계</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=핵심-개념-1>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념-1>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Cohesion (응집도)</strong></td><td>클래스나 모듈이 하나의 목적을 위해 얼마나 밀접하게 관련되어 있는지를 나타내는 정도</td></tr><tr><td><strong>Coupling (결합도)</strong></td><td>모듈 간 상호 의존성의 정도. 낮을수록 변경에 강하고 유지보수가 쉬움</td></tr><tr><td><strong>Actor (액터)</strong></td><td>변경을 요구하는 이해관계자나 시스템 외부 주체</td></tr><tr><td><strong>Code Smell</strong></td><td>코드에서 더 깊은 문제를 암시하는 구조적 결함의 징후</td></tr><tr><td><strong>Utility Class</strong></td><td>공통 기능 (날짜 처리, 문자열 포맷 등) 을 제공하는 재사용 가능한 클래스</td></tr><tr><td><strong>Domain Analysis</strong></td><td>시스템의 요구사항을 분석하고 역할 및 책임을 식별하는 과정</td></tr></tbody></table><h3 id=객체지향-설계-원칙>객체지향 설계 원칙<a hidden class=anchor aria-hidden=true href=#객체지향-설계-원칙>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>SRP (Single Responsibility Principle)</strong></td><td>클래스나 모듈은 하나의 책임만을 가져야 한다는 설계 원칙</td></tr><tr><td><strong>SOLID</strong></td><td>객체지향 설계 5 대 원칙의 집합: SRP, OCP, LSP, ISP, DIP</td></tr><tr><td><strong>OCP (Open-Closed Principle)</strong></td><td>확장에는 열려 있고, 수정에는 닫혀 있어야 한다는 원칙</td></tr><tr><td><strong>LSP (Liskov Substitution Principle)</strong></td><td>하위 타입은 상위 타입을 대체할 수 있어야 한다는 원칙</td></tr><tr><td><strong>ISP (Interface Segregation Principle)</strong></td><td>클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙</td></tr><tr><td><strong>DIP (Dependency Inversion Principle)</strong></td><td>상위 모듈과 하위 모듈은 구체화가 아닌 추상화에 의존해야 한다는 원칙</td></tr></tbody></table><h3 id=설계-및-구현-기법>설계 및 구현 기법<a hidden class=anchor aria-hidden=true href=#설계-및-구현-기법>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Interface (인터페이스)</strong></td><td>객체 간 상호작용의 계약을 정의하는 추상화 계층</td></tr><tr><td><strong>Dependency Injection (DI)</strong></td><td>객체의 의존성을 외부에서 주입받아 결합도를 낮추는 기법</td></tr><tr><td><strong>Modularization (모듈화)</strong></td><td>책임 단위별로 코드를 분리해 독립성과 재사용성을 높이는 구조화 전략</td></tr><tr><td><strong>Refactoring (리팩토링)</strong></td><td>코드의 외부 동작을 유지하면서 내부 구조를 개선하는 과정</td></tr><tr><td><strong>UML (Unified Modeling Language)</strong></td><td>시스템 설계를 시각화하기 위한 표준화된 다이어그램 언어</td></tr><tr><td><strong>ADR (Architecture Decision Record)</strong></td><td>아키텍처 및 설계 결정 사항을 문서화해 추적 가능하게 하는 형식화된 기록</td></tr></tbody></table><h3 id=디자인-패턴>디자인 패턴<a hidden class=anchor aria-hidden=true href=#디자인-패턴>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Strategy Pattern</strong></td><td>알고리즘을 캡슐화하여 동적으로 교체할 수 있도록 설계하는 패턴</td></tr><tr><td><strong>Command Pattern</strong></td><td>요청을 객체로 캡슐화하여 실행, 큐잉, 로그 등의 기능을 유연하게 처리하도록 하는 패턴</td></tr><tr><td><strong>Observer Pattern</strong></td><td>객체의 상태 변화가 있을 때 등록된 관찰자에게 자동으로 통지하는 패턴</td></tr><tr><td><strong>Factory Pattern</strong></td><td>객체 생성 로직을 분리하여 객체 생성을 캡슐화하고 확장에 유리하게 만드는 패턴</td></tr><tr><td><strong>Chain of Responsibility</strong></td><td>요청을 여러 처리 객체 중 하나가 처리할 수 있도록 연결한 패턴</td></tr></tbody></table><h3 id=아키텍처-및-구조>아키텍처 및 구조<a hidden class=anchor aria-hidden=true href=#아키텍처-및-구조>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Microservices</strong></td><td>애플리케이션을 독립적으로 배포 가능한 작은 서비스 단위로 분리한 아키텍처</td></tr><tr><td><strong>Hexagonal Architecture</strong></td><td>애플리케이션 핵심 도메인을 외부 의존성과 분리하고, 포트/어댑터 구조를 따르는 아키텍처 패턴</td></tr><tr><td><strong>Clean Architecture</strong></td><td>의존성 규칙을 기반으로 계층 간 분리를 엄격히 지켜 유연성과 테스트 용이성을 확보하는 아키텍처</td></tr><tr><td><strong>Domain Driven Design (DDD)</strong></td><td>도메인 모델을 중심으로 문제를 설계하고 구현하는 방법론</td></tr></tbody></table><h3 id=테스트-및-개발-방법론>테스트 및 개발 방법론<a hidden class=anchor aria-hidden=true href=#테스트-및-개발-방법론>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Unit Test (단위 테스트)</strong></td><td>클래스 또는 함수 같은 작은 단위의 로직을 독립적으로 검증하는 테스트 방식</td></tr><tr><td><strong>Test-Driven Development (TDD)</strong></td><td>테스트를 먼저 작성하고 구현하는 테스트 주도 개발 방법론</td></tr><tr><td><strong>Behavior-Driven Development (BDD)</strong></td><td>사용자 행위 중심으로 테스트 케이스를 작성하고 검증하는 개발 방식</td></tr><tr><td><strong>Mock Object (모의 객체)</strong></td><td>테스트에서 실제 객체를 대체하기 위해 사용하는 테스트 더블 객체</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Single-responsibility_principle>단일 책임 원칙 위키피디아</a></li><li><a href=https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design>SOLID 원칙 설명 - DigitalOcean</a></li><li><a href=https://www.geeksforgeeks.org/single-responsibility-in-solid-design-principle/>단일 책임 원칙 예제 - GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/solid-principle-in-programming-understand-with-real-life-examples/>SOLID 원칙 실생활 예제 - GeeksforGeeks</a></li><li><a href=https://www.baeldung.com/java-single-responsibility-principle>Java에서의 단일 책임 원칙 - Baeldung</a></li><li><a href=https://www.baeldung.com/solid-principles>SOLID Principles Explained with Examples - Baeldung</a></li><li><a href=https://hackernoon.com/solid-learn-about-the-single-responsibility-principle-with-examples>SRP 상세 설명 - HackerNoon</a></li><li><a href=https://www.techtarget.com/whatis/definition/Single-Responsibility-Principle-SRP>단일 책임 원칙 정의 - TechTarget</a></li><li><a href=https://www.alpharithms.com/solid-single-responsibility-principle-srp-284015/>SRP 클린 코드 패턴 - αlphαrithms</a></li><li><a href=https://www.lambdatest.com/blog/single-responsibility-principle/>SRP 실무 적용 - LambdaTest</a></li><li><a href=https://www.theserverside.com/tip/How-to-apply-the-single-responsibility-principle-in-Java>Java 적용 방법 - TheServerSide</a></li><li><a href=https://refactoring.guru/design-patterns/single-responsibility-principle>Refactoring Guru: SRP</a></li><li><a href=https://www.oreilly.com/library/view/clean-architecture/9780134494272/>Clean Architecture by Robert C. Martin - O’Reilly</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures>Microsoft Learn - Clean Architecture</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles>Microsoft: SRP 적용 가이드</a></li><li><a href=https://devsm.tistory.com/55>SOLID 원칙 - SRP(단일 책임 원칙) - 티스토리</a></li><li><a href=https://steady-coding.tistory.com/377>SOLID 원칙 1 - 단일 책임 원칙(SRP) - Steady Coding</a></li><li><a href=https://velog.io/@clydehan/SOLID-%EC%9B%90%EC%B9%99-1-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99SRP>SOLID 원칙 - 단일 책임 원칙(SRP) - Velog</a></li><li><a href=https://dreamcoding.tistory.com/65>SOLID SRP: 단일 책임 원칙 - Dream Coding</a></li></ul><hr></div></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>