<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mediator Pattern vs Observer Pattern | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Software-Design-Patterns,Behavioral-Design-Patterns,Mediator-Pattern,Observer-Pattern"><meta name=description content="Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Mediator Pattern vs Observer Pattern"><meta property="og:description" content="Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-24T00:49:00+00:00"><meta property="article:modified_time" content="2024-09-24T00:49:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="Software-Design-Patterns"><meta property="article:tag" content="Behavioral-Design-Patterns"><meta property="article:tag" content="Mediator-Pattern"><meta property="article:tag" content="Observer-Pattern"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Mediator Pattern vs Observer Pattern"><meta name=twitter:description content="Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":5,"name":"Software Design Patterns","item":""},{"@type":"ListItem","position":6,"name":"GoF","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/"},{"@type":"ListItem","position":7,"name":"Behavioral Design Patterns","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/"},{"@type":"ListItem","position":8,"name":"Mediator Pattern","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/"},{"@type":"ListItem","position":9,"name":"Mediator Pattern vs Observer Pattern","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Mediator Pattern vs Observer Pattern","name":"Mediator Pattern vs Observer Pattern","description":"Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.","keywords":["System-and-Software-Architecture","Software-Design-Patterns","Behavioral-Design-Patterns","Mediator-Pattern","Observer-Pattern"],"articleBody":"Mediator Pattern Vs Observer Pattern Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.\nMediator 패턴:\n객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴 객체 간 결합도를 낮추고 상호작용을 중앙 집중화함 복잡한 다대다 관계를 단순화하는 데 유용 Observer 패턴:\n객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴 주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함 상태 변경에 대한 효율적인 알림 메커니즘을 제공 Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 객체 간의 결합도를 줄이고 상호작용 로직을 집중시키는 데 적합하다. Observer 패턴은 상태 변화에 따른 자동 알림 및 실시간 동기화를 구현할 때 적합하며, 이벤트 기반 시스템에 자주 사용된다. 두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, Mediator는 상호작용을 캡슐화하고 Observer는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.\n특성 Mediator 패턴 Observer 패턴 목적 객체 간의 상호작용을 Mediator를 통해 캡슐화하여, 객체들이 서로 직접 통신하지 않고 중재자를 통해 간접적으로 통신하도록 함. 한 객체의 상태 변화가 발생했을 때, 이를 의존 객체들에게 자동으로 알림을 전달하여 상태를 동기화함. 구성요소 Mediator, ConcreteMediator, Colleague Subject, Observer 통신 구조 중앙 집중식 분산형 일대다 상호작용 방식 중재자가 객체 간의 통신을 조정하며, 모든 상호작용은 중재자를 통해 이루어짐. Subject가 상태 변화 시 Observer들에게 알림을 보내는 1:N 관계로 통신. 객체 간 관계 객체들이 중재자에 의존 주체와 관찰자 간 직접 관계 제어 흐름 중재자가 모든 상호작용 제어 주체가 상태 변경 감지 및 알림 확장성 중재자 복잡성으로 제한될 수 있음 동적으로 관찰자 추가/제거 가능 주요 사용 사례 복잡한 GUI, 항공 관제 시스템 이벤트 처리, 상태 모니터링 결합도 객체 간 결합도 낮음, 중재자에 의존 주체와 관찰자 간 느슨한 결합 유연성 객체 간 상호작용 변경 용이 새로운 구독자 추가 용이 책임 분배 Mediator에 상호작용 로직이 집중되어 있어 유지보수가 용이하지만, 복잡성이 증가할 수 있음. Observer들이 Subject의 상태 변화를 구독하므로, Observer가 많아지면 관리가 어려워질 수 있음. 복잡성 관리 복잡한 상호작용을 단순화 상태 변경 알림을 단순화 성능 중앙 집중식으로 병목 가능성 다수의 관찰자로 인한 성능 저하 가능 구현 난이도 중재자 설계가 복잡할 수 있음 비교적 간단한 구현 장점 - 객체 간 의존성이 줄어듦\n- 상호작용 로직을 Mediator에 집중하여 관리 용이 - Subject와 Observer 간의 느슨한 결합\n- 실시간 상태 동기화 가능 단점 - Mediator가 지나치게 많은 책임을 맡아 복잡해질 수 있음\n- 추가적인 계층으로 인해 오버헤드 발생 가능 - Observer가 많아질 경우 성능 저하 가능\n- 순환 참조 문제 발생 가능성 활용 사례 - 채팅 서버와 클라이언트 간의 통신GUI 컴포넌트 간의 상호작용 조정 - 이벤트 기반 아키텍처GUI의 이벤트 처리\n- 데이터 모델과 UI의 동기화 두 패턴의 선택 기준:\nMediator 패턴 선택 시기:\n객체 간 상호작용이 복잡하고 다대다(M:N) 관계일 때 중앙 집중적인 제어가 필요할 때 객체 간 결합도를 최소화하고 싶을 때 Observer 패턴 선택 시기:\n일대다(1:N) 관계의 상태 변화 전파가 필요할 때 느슨한 결합이 필요하고 각 객체가 독립적으로 동작해야 할 때 이벤트 기반 시스템을 구현할 때 용어 정리 용어 설명 참고 및 출처 ","wordCount":"457","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-24T00:49:00Z","dateModified":"2024-09-24T00:49:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href>Software Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/>GoF</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/>Behavioral Design Patterns</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/detailed-design/software-design-patterns/gof/behavioral/mediator-pattern/>Mediator Pattern</a></div><h1 class="post-title entry-hint-parent">Mediator Pattern vs Observer Pattern</h1><div class=post-description>Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.</div><div class=post-meta><span title='2024-09-24 00:49:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Design%20and%20Architecture/Detailed%20Design/Software%20Design%20Patterns/GoF/Behavioral/Mediator%20Pattern/Mediator-Pattern-vs-Observer-Pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#mediator-pattern-vs-observer-pattern>Mediator Pattern Vs Observer Pattern</a></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=mediator-pattern-vs-observer-pattern>Mediator Pattern Vs Observer Pattern<a hidden class=anchor aria-hidden=true href=#mediator-pattern-vs-observer-pattern>#</a></h2><p>Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.</p><p>Mediator 패턴:</p><ul><li>객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴</li><li>객체 간 결합도를 낮추고 상호작용을 중앙 집중화함</li><li>복잡한 다대다 관계를 단순화하는 데 유용</li></ul><p>Observer 패턴:</p><ul><li>객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴</li><li>주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함</li><li>상태 변경에 대한 효율적인 알림 메커니즘을 제공</li></ul><p>Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 <strong>객체 간의 결합도를 줄이고 상호작용 로직을 집중</strong>시키는 데 적합하다.
Observer 패턴은 상태 변화에 따른 <strong>자동 알림 및 실시간 동기화</strong>를 구현할 때 적합하며, <strong>이벤트 기반 시스템</strong>에 자주 사용된다.
두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, <strong>Mediator</strong>는 상호작용을 캡슐화하고 <strong>Observer</strong>는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.</p><table><thead><tr><th>특성</th><th>Mediator 패턴</th><th>Observer 패턴</th></tr></thead><tbody><tr><td><strong>목적</strong></td><td>객체 간의 상호작용을 Mediator를 통해 캡슐화하여, 객체들이 서로 직접 통신하지 않고 중재자를 통해 간접적으로 통신하도록 함.</td><td>한 객체의 상태 변화가 발생했을 때, 이를 의존 객체들에게 자동으로 알림을 전달하여 상태를 동기화함.</td></tr><tr><td><strong>구성요소</strong></td><td>Mediator, ConcreteMediator, Colleague</td><td>Subject, Observer</td></tr><tr><td>통신 구조</td><td>중앙 집중식</td><td>분산형 일대다</td></tr><tr><td><strong>상호작용 방식</strong></td><td>중재자가 객체 간의 통신을 조정하며, 모든 상호작용은 중재자를 통해 이루어짐.</td><td>Subject가 상태 변화 시 Observer들에게 알림을 보내는 1:N 관계로 통신.</td></tr><tr><td>객체 간 관계</td><td>객체들이 중재자에 의존</td><td>주체와 관찰자 간 직접 관계</td></tr><tr><td>제어 흐름</td><td>중재자가 모든 상호작용 제어</td><td>주체가 상태 변경 감지 및 알림</td></tr><tr><td>확장성</td><td>중재자 복잡성으로 제한될 수 있음</td><td>동적으로 관찰자 추가/제거 가능</td></tr><tr><td>주요 사용 사례</td><td>복잡한 GUI, 항공 관제 시스템</td><td>이벤트 처리, 상태 모니터링</td></tr><tr><td>결합도</td><td>객체 간 결합도 낮음, 중재자에 의존</td><td>주체와 관찰자 간 느슨한 결합</td></tr><tr><td>유연성</td><td>객체 간 상호작용 변경 용이</td><td>새로운 구독자 추가 용이</td></tr><tr><td><strong>책임 분배</strong></td><td>Mediator에 상호작용 로직이 집중되어 있어 유지보수가 용이하지만, 복잡성이 증가할 수 있음.</td><td>Observer들이 Subject의 상태 변화를 구독하므로, Observer가 많아지면 관리가 어려워질 수 있음.</td></tr><tr><td>복잡성 관리</td><td>복잡한 상호작용을 단순화</td><td>상태 변경 알림을 단순화</td></tr><tr><td>성능</td><td>중앙 집중식으로 병목 가능성</td><td>다수의 관찰자로 인한 성능 저하 가능</td></tr><tr><td>구현 난이도</td><td>중재자 설계가 복잡할 수 있음</td><td>비교적 간단한 구현</td></tr><tr><td><strong>장점</strong></td><td>- 객체 간 의존성이 줄어듦<br>- 상호작용 로직을 Mediator에 집중하여 관리 용이</td><td>- Subject와 Observer 간의 느슨한 결합<br>- 실시간 상태 동기화 가능</td></tr><tr><td><strong>단점</strong></td><td>- Mediator가 지나치게 많은 책임을 맡아 복잡해질 수 있음<br>- 추가적인 계층으로 인해 오버헤드 발생 가능</td><td>- Observer가 많아질 경우 성능 저하 가능<br>- 순환 참조 문제 발생 가능성</td></tr><tr><td><strong>활용 사례</strong></td><td>- 채팅 서버와 클라이언트 간의 통신GUI 컴포넌트 간의 상호작용 조정</td><td>- 이벤트 기반 아키텍처GUI의 이벤트 처리<br>- 데이터 모델과 UI의 동기화</td></tr></tbody></table><p>두 패턴의 선택 기준:</p><ol><li><p>Mediator 패턴 선택 시기:</p><ul><li>객체 간 상호작용이 복잡하고 다대다(M:N) 관계일 때</li><li>중앙 집중적인 제어가 필요할 때</li><li>객체 간 결합도를 최소화하고 싶을 때</li></ul></li><li><p>Observer 패턴 선택 시기:</p><ul><li>일대다(1:N) 관계의 상태 변화 전파가 필요할 때</li><li>느슨한 결합이 필요하고 각 객체가 독립적으로 동작해야 할 때</li><li>이벤트 기반 시스템을 구현할 때</li></ul></li></ol><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/software-design-patterns/>Software-Design-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/behavioral-design-patterns/>Behavioral-Design-Patterns</a></li><li><a href=https://buenhyden.github.io/tags/mediator-pattern/>Mediator-Pattern</a></li><li><a href=https://buenhyden.github.io/tags/observer-pattern/>Observer-Pattern</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/database-systems/database-fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/><span class=title>« Prev</span><br><span>ER(Entity-Relationship) 모델링</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/system-test-vs-end-to-end-test/><span class=title>Next »</span><br><span>System Test vs End-to-End Test</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>