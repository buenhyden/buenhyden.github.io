<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Convention over Configuration | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles,Convention-over-Configuration"><meta name=description content="Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/convention-over-configuration/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/convention-over-configuration/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/convention-over-configuration/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/convention-over-configuration/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Convention over Configuration"><meta property="og:description" content="Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Convention over Configuration"><meta name=twitter:description content="Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기록하고 기억하고 활용하자.","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":6,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/"},{"@type":"ListItem","position":7,"name":"Convention over Configuration","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/convention-over-configuration/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기록하고 기억하고 활용하자.</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-fundamentals/core-principles/design-principles/>Design Principles</a></div><h1>Convention over Configuration</h1><div class=post-description>Convention over Configuration(설정보다 관례) 은 개발자가 반복적으로 해야 하는 설정을 최소화하고, 합리적인 기본값과 규칙을 제공해 개발 효율성과 표준화를 높이는 소프트웨어 설계 원칙이다. 관례를 따르면 별도 설정 없이 빠르게 개발이 가능하며, 필요 시에만 설정을 추가하면 된다.</div></header><div class=post-content><h2 id=convention-over-configuration>Convention over Configuration<a hidden class=anchor aria-hidden=true href=#convention-over-configuration>#</a></h2><p>&ldquo;Convention over Configuration&rdquo;(CoC) 은 소프트웨어 개발에서 명시적인 설정을 최소화하고, 합리적인 기본 규칙을 통해 개발자의 작업 부담을 줄이는 설계 원칙이다. 소프트웨어 프레임워크가 합리적인 기본값과 표준 규칙을 제공함으로써 개발자가 명시적으로 설정해야 할 부분을 최소화한다. 관례를 따르는 한 추가 설정이 필요 없으며, 관례를 벗어나는 경우에만 명시적 구성이 요구된다. Ruby on Rails 에서 처음 도입되어 다양한 프레임워크에 확산되었으며, 개발 생산성 향상, 오류 감소, 유지보수 용이성 등의 장점을 제공한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>Convention over Configuration (CoC, 설정보다 관례)</strong> 는 소프트웨어 프레임워크가 개발자가 내려야 하는 결정의 수를 줄이면서도 유연성을 잃지 않도록 하는 소프트웨어 설계 패러다임이다. 프레임워크나 시스템이 합리적이고 널리 통용되는 기본 규칙 (관례) 을 제공하여, 개발자가 반드시 필요한 경우에만 설정을 하도록 하는 소프트웨어 설계 패러다임이다.</p><p><strong>핵심 개념들:</strong></p><ol><li><strong>합리적 기본값 (Sensible Defaults)</strong>: 가장 일반적인 사용 사례에 맞는 기본 설정 제공</li><li><strong>명명 규칙 (Naming Conventions)</strong>: 클래스명, 메서드명, 파일명 등의 표준화된 규칙</li><li><strong>자동 발견 (Auto-discovery)</strong>: 프레임워크가 코드 구조를 자동으로 인식하고 연결</li><li><strong>오버라이드 가능성 (Override Capability)</strong>: 기본 관례에서 벗어날 필요가 있을 때 명시적 설정 허용</li><li><strong>DRY 원칙 (Don&rsquo;t Repeat Yourself)</strong>: 중복된 설정과 코드 제거<br><strong>적용 방식</strong>: 파일/폴더 구조, 네이밍 규칙, 기본 동작 등에서 관례를 제공하고, 관례를 따를 경우 별도 설정이 필요 없음. 관례를 벗어날 때만 설정을 추가한다.</li></ol><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>2000 년대 초반 Java 기반 프레임워크들은 복잡한 XML 설정 파일을 요구했다. 예를 들어, 초기 Hibernate 는 엔티티와 데이터베이스 테이블 간의 관계를 모두 XML 로 명시해야 했다.</p><p><strong>2004 년 Ruby on Rails 등장:</strong> David Heinemeier Hansson 이 Ruby on Rails 에서 이 개념을 도입하고 명명했다. Rails 는 " 만약 Sales 클래스가 있다면, 데이터베이스 테이블은 &lsquo;sales&rsquo; 라고 가정한다 " 는 식의 관례를 도입했다.</p><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ol><li><strong>개발 생산성 향상</strong>: 반복적인 설정 작업 제거</li><li><strong>인지 부하 감소</strong>: 개발자가 고민해야 할 결정사항 최소화</li><li><strong>코드 일관성</strong>: 표준화된 구조와 명명 규칙으로 팀 내 일관성 확보</li><li><strong>진입 장벽 완화</strong>: 새로운 개발자가 프로젝트를 이해하기 쉽게 만듦</li><li><strong>유지보수성 개선</strong>: 예측 가능한 구조로 코드 변경과 확장 용이</li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li>합리적인 기본값 제공</li><li>반복적/불필요한 설정 생략</li><li>명확한 프로젝트 구조와 네이밍 규칙 제공</li><li>필요시 설정 오버라이드 (Override) 가능</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>설정 파일 최소화</li><li>표준화된 규칙 (관례) 기반</li><li>빠른 프로젝트 셋업 및 실행</li><li>협업 및 유지보수 용이</li><li>관례를 벗어날 때만 설정 필요</li><li>일부 유연성 제한 가능성</li></ul><h3 id=구조-및-작동-원리>구조 및 작동 원리<a hidden class=anchor aria-hidden=true href=#구조-및-작동-원리>#</a></h3><p><strong>합리적인 기본값 제공</strong>과 <strong>명시적 설정 최소화</strong>를 통해 개발 효율성을 높인다. 프레임워크는 표준 규칙을 기반으로 동작하며, 개발자가 표준을 따를 경우 별도의 설정 없이도 원하는 결과를 얻을 수 있다.</p><h4 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h4><ol><li><strong>최소 놀람 원칙 (Principle of Least Astonishment)</strong>: 개발자가 예상하는 대로 동작</li><li><strong>관례의 일관성</strong>: 프레임워크 전반에 걸친 일관된 규칙 적용</li><li><strong>점진적 복잡성</strong>: 단순한 경우는 단순하게, 복잡한 경우에만 복잡하게</li><li><strong>의견이 있는 소프트웨어 (Opinionated Software)</strong>: 최선의 방법에 대한 명확한 의견 제시</li></ol><h4 id=작동-원리>작동 원리<a hidden class=anchor aria-hidden=true href=#작동-원리>#</a></h4><pre class=mermaid>graph TD
    A[개발자 코드 작성] --&gt; B{관례 준수 여부}
    B --&gt;|YES| C[자동 설정 적용]
    B --&gt;|NO| D[명시적 설정 검색]
    C --&gt; E[리플렉션/스캐닝]
    D --&gt; F[설정 오버라이드]
    E --&gt; G[자동 매핑 수행]
    F --&gt; G
    G --&gt; H[애플리케이션 실행]
</pre><p><strong>작동 단계:</strong></p><ol><li><strong>코드 스캐닝</strong>: 프레임워크가 클래스패스를 스캔하여 관련 클래스 발견</li><li><strong>관례 적용</strong>: 명명 규칙과 구조 패턴을 기반으로 자동 매핑</li><li><strong>기본값 설정</strong>: 미리 정의된 합리적 기본값 적용</li><li><strong>오버라이드 처리</strong>: 명시적 설정이 있는 경우 기본값 대신 적용</li><li><strong>의존성 주입</strong>: 발견된 컴포넌트들을 자동으로 연결</li></ol><h4 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h4><pre class=mermaid>graph LR
    A[Convention Engine] --&gt; B[Scanner]
    A --&gt; C[Mapper]
    A --&gt; D[Resolver]
    A --&gt; E[Injector]
    
    B --&gt; F[Class Scanner]
    B --&gt; G[Resource Scanner]
    
    C --&gt; H[Name Mapper]
    C --&gt; I[Type Mapper]
    
    D --&gt; J[Configuration Resolver]
    D --&gt; K[Dependency Resolver]
    
    E --&gt; L[Bean Injector]
    E --&gt; M[Property Injector]
</pre><h4 id=구성요소>구성요소<a hidden class=anchor aria-hidden=true href=#구성요소>#</a></h4><table><thead><tr><th>구분</th><th>구성 요소</th><th>기능</th><th>역할/설명</th></tr></thead><tbody><tr><td>필수</td><td>관례 엔진 (Convention Engine)</td><td>CoC 전반 조율</td><td>스캐닝, 매핑, 해석, 주입 등 전체 프로세스를 통합 관리</td></tr><tr><td></td><td>스캐너 (Scanner)</td><td>클래스패스 및 리소스 검색</td><td>관례에 따른 자동 컴포넌트 탐지 및 등록</td></tr><tr><td></td><td>매퍼 (Mapper)</td><td>명명 규칙 기반 자동 매핑</td><td>클래스 → 테이블, URL → 컨트롤러 등의 규칙 기반 자동 연결</td></tr><tr><td></td><td>해석기 (Resolver)</td><td>설정 충돌 처리 및 의존성 분석</td><td>기본값과 명시적 설정 간 우선순위 판단 및 충돌 조율</td></tr><tr><td>선택</td><td>어노테이션 처리기 (Annotation Processor)</td><td>어노테이션 기반 설정 처리</td><td>관례와 명시적 설정의 중간 지점, 세밀한 제어 가능</td></tr><tr><td></td><td>외부 설정 관리자 (External Configuration Manager)</td><td>외부 설정 파일 (.yml,.properties 등) 처리</td><td>환경별 설정 분리, 커맨드라인/CI/CD 대응 유연</td></tr><tr><td></td><td>프로파일 관리자 (Profile Manager)</td><td>환경별 관례 세트 제공</td><td>dev/test/prod 등 환경별로 서로 다른 관례 세트 자동 적용</td></tr></tbody></table><h4 id=주요-원리-다이어그램>주요 원리 다이어그램<a hidden class=anchor aria-hidden=true href=#주요-원리-다이어그램>#</a></h4><pre class=mermaid>sequenceDiagram
    participant Dev as 개발자
    participant FW as 프레임워크
    participant Scanner as 스캐너
    participant Engine as 관례엔진
    participant App as 애플리케이션

    Dev-&gt;&gt;FW: 코드 작성 (관례 준수)
    FW-&gt;&gt;Scanner: 클래스패스 스캔 시작
    Scanner-&gt;&gt;Engine: 발견된 컴포넌트 전달
    Engine-&gt;&gt;Engine: 명명 규칙 적용
    Engine-&gt;&gt;Engine: 기본값 설정
    Engine-&gt;&gt;App: 설정된 컴포넌트 등록
    App-&gt;&gt;Dev: 애플리케이션 실행
</pre><hr><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>구현 기법</th><th>정의</th><th>구성 요소</th><th>목적</th><th>실제 사례 (프레임워크 기반)</th></tr></thead><tbody><tr><td><strong>리플렉션 기반 스캐닝</strong></td><td>런타임 메타데이터 분석을 통해 컴포넌트를 자동으로 탐지하는 기법</td><td>클래스패스 탐색, 어노테이션 필터링, 메타데이터 추출 등</td><td>명시적 등록 없이 컴포넌트 자동 탐색</td><td>Spring Boot <code>@ComponentScan</code>, NestJS provider 자동 등록</td></tr><tr><td><strong>명명 규칙 매핑</strong></td><td>명명 규칙 기반으로 코드 요소들 간 관계를 자동 매핑하는 기법</td><td>단수/복수 변환, 접두/접미사, 케이스 컨벤션 등</td><td>명시적 매핑 없이 관계 자동 연결</td><td>Rails 모델명 → 테이블명, Django URL → View</td></tr><tr><td><strong>자동 설정 (Auto-configuration)</strong></td><td>클래스패스 조건과 의존성을 기반으로 설정을 자동 구성하는 기법</td><td>조건부 구성, 자동 활성화, 기본값 제공 메커니즘</td><td>명시적 설정 없이도 애플리케이션 자동 구동</td><td>Spring Boot <code>@EnableAutoConfiguration</code>, Micronaut DI</td></tr><tr><td><strong>템플릿 기반 생성</strong></td><td>템플릿 기반 코드 생성을 통해 반복작업을 자동화하는 기법 (제한된 CoC 적용)</td><td>템플릿 정의, 메타데이터 바인딩, 조건 기반 생성</td><td>보일러플레이트 코드 자동 생성 및 초기 개발 속도 향상</td><td>Rails <code>generate scaffold</code>, Angular CLI <code>ng generate</code></td></tr><tr><td><strong>기본 디렉터리 구조 인식</strong></td><td>디렉터리 구조만으로 역할을 추론하여 자동 등록하는 기법</td><td>표준 폴더 탐색, 경로 기반 자동 등록 로직 등</td><td>파일 구조만으로 컴포넌트 자동 연결</td><td>Next.js <code>pages/</code>, Nuxt.js <code>pages/</code>, Rails <code>controllers/</code></td></tr><tr><td><strong>구성 어노테이션 (Annotation Config)</strong></td><td>선언적 어노테이션을 통해 설정을 간소화하고 자동으로 해석하는 기법</td><td>어노테이션 스캐너, 메타정보 해석기, 매핑 처리 로직</td><td>선언적 구성으로 설정을 간결하게 표현</td><td>Spring <code>@Service</code>, NestJS <code>@Injectable</code>, Jakarta <code>@Inject</code></td></tr></tbody></table><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>개발 생산성 향상</td><td>반복적인 설정 작업 없이 빠르게 개발 가능, 초기 구동 시간 단축</td></tr><tr><td></td><td>코드 일관성 유지</td><td>표준화된 구조와 명명 규칙으로 팀원 간 코드 품질 및 가독성 향상</td></tr><tr><td></td><td>보일러플레이트 최소화</td><td>반복적인 설정 및 등록 코드 제거로 코드량 감소</td></tr><tr><td></td><td>유지보수성 향상</td><td>예측 가능한 구조와 위치로 변경 사항 관리가 용이, 오류 발생 지점 추적이 쉬움</td></tr><tr><td></td><td>협업 효율성 증대</td><td>팀 내 공통 규칙을 기반으로 역할 분담 및 코드 리뷰 효율 향상</td></tr><tr><td></td><td>오류 감소</td><td>자동 설정 및 명명 규칙으로 인한 설정 누락/오류 가능성 감소</td></tr><tr><td>⚠ 단점</td><td>암묵적 동작으로 인한 디버깅 어려움</td><td>명시적 설정 없이 동작하는 로직은 디버깅 시 진입 경로 추적이 어려움</td></tr><tr><td></td><td>유연성 한계</td><td>프레임워크가 정의한 관례를 벗어나기 어려워, 고도화된 요구사항에 대응 시 불편할 수 있음</td></tr><tr><td></td><td>초기 학습 곡선 존재</td><td>관례와 규칙을 명확히 이해하지 못하면 진입 장벽이 발생함</td></tr><tr><td></td><td>커스터마이징 복잡성</td><td>기본 규칙을 오버라이드할 때 설정 경로와 우선순위가 복잡해질 수 있음</td></tr><tr><td></td><td>성능 오버헤드</td><td>리플렉션, 클래스패스 스캐닝 등으로 인한 런타임 성능 저하 가능성 존재</td></tr><tr><td></td><td>프레임워크 종속성 증가</td><td>특정 프레임워크의 관례와 철학에 강하게 의존하게 되어 이식성 (Portability) 이 낮아질 수 있음</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>분류</th><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td><strong>요구사항 복잡성</strong></td><td>비표준 비즈니스 로직 대응 한계</td><td>복잡한 요구사항은 기본 관례만으로 표현이 불가능</td><td>오버라이드 기능 활용, 명시적 설정 병행, 설정 확장 인터페이스 제공</td></tr><tr><td><strong>관례 이해도</strong></td><td>관례 미숙지로 인한 진입 장벽</td><td>초심자나 비숙련자는 자동 동작의 원리를 이해하지 못해 혼란 유발</td><td>공식 문서화, 교육 자료 제공, 개발자 온보딩 가이드 구축</td></tr><tr><td><strong>관례 충돌</strong></td><td>라이브러리 간 규칙 충돌</td><td>서로 다른 프레임워크의 관례가 충돌하거나 중복될 경우 혼동 발생</td><td>명시적 우선순위 지정, 네임스페이스 분리, 설정 병합 전략 적용</td></tr><tr><td><strong>디버깅 어려움</strong></td><td>암묵적 동작으로 인한 원인 분석 어려움</td><td>자동화된 동작은 호출 흐름을 추적하기 어려워 디버깅에 시간 소요</td><td>상세 로깅, 호출 추적 로그, 관례 추적 도구 제공</td></tr><tr><td><strong>IDE 지원 부족</strong></td><td>동적 매핑이 많아 코드 추론이 어려움</td><td>리플렉션 및 런타임 구성은 IDE 의 자동 완성/정적 분석에서 인식 어려움</td><td>IDE 플러그인 제공, 메타정보 힌트 파일 생성 (예: tsconfig paths, Spring metadata)</td></tr><tr><td><strong>성능 이슈</strong></td><td>런타임 스캐닝 및 리플렉션으로 인한 오버헤드</td><td>클래스패스 스캐닝 및 구성 요소 자동 연결에 따른 초기 지연</td><td>캐싱, 빌드 타임 코드 생성 (AOT), Lazy Loading 적용</td></tr><tr><td><strong>커스터마이징 복잡성</strong></td><td>관례를 벗어난 설정 시 구조 복잡화</td><td>기본 설정을 우회하거나 오버라이드할 경우 설정 경로와 우선순위 복잡해짐</td><td>유연한 설정 확장 방식 제공, 명확한 설정 계층 구조 정의</td></tr></tbody></table><h3 id=분류에-따른-종류>분류에 따른 종류<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류>#</a></h3><table><thead><tr><th>분류 기준</th><th>종류</th><th>설명</th></tr></thead><tbody><tr><td><strong>적용 범위</strong></td><td>프레임워크 레벨</td><td>전체 애플리케이션의 구조와 작동 방식에 관례를 적용하는 방식 (예: Spring Boot, Rails)</td></tr><tr><td></td><td>라이브러리/도구 레벨</td><td>특정 기능 영역 (ORM, 빌드, 테스트 등) 에 국한된 관례 적용 (예: Hibernate, Maven)</td></tr><tr><td></td><td>애플리케이션 레벨</td><td>개발팀 또는 조직 차원에서의 코드 구조, 네이밍, 설정 관례 (예: 내부 코딩 컨벤션, 모듈 패턴)</td></tr><tr><td><strong>구현 방식</strong></td><td>어노테이션 기반</td><td>클래스, 메서드 등에 메타데이터를 추가하여 동작을 유도하는 방식 (<code>@Component</code>, <code>@Entity</code>)</td></tr><tr><td></td><td>명명 규칙 기반</td><td>클래스명, 메서드명 등 이름 패턴을 기준으로 자동 매핑 및 동작 연결 (예: 컨트롤러명으로 URL 추론)</td></tr><tr><td></td><td>디렉터리 구조 기반</td><td>특정 폴더 구조에 따라 역할을 자동 인식하고 구성하는 방식 (<code>pages/</code>, <code>controllers/</code> 등)</td></tr><tr><td><strong>유연성 정도</strong></td><td>강제적 관례</td><td>사용자가 설정을 바꿀 수 없는 고정된 규칙 (예: Rails 기본 디렉터리 구조)</td></tr><tr><td></td><td>유연한 관례</td><td>기본 관례를 제공하지만 명시적 설정으로 덮어쓸 수 있는 구조 (예: Spring Boot 의 <code>@Configuration</code>)</td></tr><tr><td></td><td>선택적 관례</td><td>사용자가 원할 때만 관례 기반 설정을 활성화하는 구조 (예: 옵트인 플러그인 설정)</td></tr></tbody></table><h3 id=분류에-따른-유형>분류에 따른 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-유형>#</a></h3><table><thead><tr><th>도메인</th><th>유형</th><th>설명</th><th>예시</th></tr></thead><tbody><tr><td><strong>웹 프레임워크</strong></td><td>MVC 매핑 관례</td><td>URL 경로와 컨트롤러, 액션 메서드를 자동 연결</td><td>Spring MVC, Rails</td></tr><tr><td></td><td>RESTful 자동 매핑</td><td>HTTP 메서드 → 액션 매핑, URL → 자원 식별 자동화</td><td>Django REST Framework, Laravel API Routes</td></tr><tr><td><strong>ORM</strong></td><td>클래스 - 테이블 매핑</td><td>클래스명과 테이블명을 명명 규칙에 따라 자동 연결</td><td>Hibernate, ActiveRecord</td></tr><tr><td></td><td>연관관계 추론</td><td>외래키 명명 패턴을 기반으로 관계 자동 생성</td><td>JPA, Sequelize</td></tr><tr><td><strong>빌드/배포 도구</strong></td><td>표준 디렉터리 구조</td><td>소스/리소스/테스트/타깃 디렉토리 등 미리 정해진 구조에 따라 자동 인식</td><td>Maven, Gradle</td></tr><tr><td></td><td>의존성 관리</td><td>설정 파일의 좌표로 자동 다운로드 및 버전 추론</td><td>npm, pip</td></tr><tr><td><strong>테스트 도구</strong></td><td>테스트 자동 인식</td><td>파일명/메서드명 패턴을 통해 테스트 자동 탐색 및 실행</td><td>JUnit, pytest</td></tr><tr><td></td><td>픽스처 자동 구성</td><td>테스트 실행 시 자동으로 데이터 또는 환경을 세팅</td><td>RSpec, TestNG</td></tr><tr><td><strong>프레임워크 구현체</strong></td><td>CoC 중심 설계</td><td>프레임워크의 핵심 철학으로 CoC 적용되어 최소 설정만으로 작동</td><td>Ruby on Rails, Spring Boot, Django</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>프레임워크</th><th>적용 영역</th><th>관례 내용</th><th>효과</th></tr></thead><tbody><tr><td>Ruby on Rails</td><td>모델 - 테이블 매핑</td><td>User 클래스 → users 테이블</td><td>XML 설정 파일 불필요</td></tr><tr><td></td><td>URL 라우팅</td><td>/users/1 → UsersController#show</td><td>라우팅 설정 최소화</td></tr><tr><td></td><td>뷰 템플릿</td><td>show 액션 → show.html.erb</td><td>뷰 파일 자동 연결</td></tr><tr><td>Spring Boot</td><td>자동 설정</td><td>H2 의존성 → 인메모리 DB 설정</td><td>데이터베이스 설정 자동화</td></tr><tr><td></td><td>컴포넌트 스캔</td><td>@Service → 빈 자동 등록</td><td>XML/Java Config 간소화</td></tr><tr><td></td><td>프로퍼티 바인딩</td><td>application.yml → @ConfigurationProperties</td><td>설정 자동 주입</td></tr><tr><td>Django</td><td>앱 구조</td><td>앱별 models.py, views.py</td><td>표준화된 프로젝트 구조</td></tr><tr><td></td><td>URL 패턴</td><td>urls.py → 뷰 함수 매핑</td><td>중앙화된 URL 관리</td></tr><tr><td></td><td>템플릿</td><td>뷰명 → 템플릿 파일 자동 검색</td><td>템플릿 경로 설정 간소화</td></tr><tr><td>Maven</td><td>디렉토리 레이아웃</td><td>src/main/java → 소스 디렉토리</td><td>프로젝트 구조 표준화</td></tr><tr><td></td><td>라이프사이클</td><td>compile → test → package</td><td>빌드 프로세스 자동화</td></tr><tr><td></td><td>의존성 관리</td><td>groupId:artifactId:version</td><td>라이브러리 관리 간소화</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-전자상거래-플랫폼-restful-api-개발>사례 1: 전자상거래 플랫폼 RESTful API 개발<a hidden class=anchor aria-hidden=true href=#사례-1-전자상거래-플랫폼-restful-api-개발>#</a></h4><p><strong>시나리오</strong>: 전자상거래 플랫폼 RESTful API 개발</p><p><strong>프로젝트 배경</strong>:</p><ul><li>중소 규모 온라인 쇼핑몰의 백엔드 API 개발</li><li>빠른 프로토타입 개발과 유지보수성 중시</li><li>소규모 팀 (3-4 명) 으로 신속한 개발 필요</li></ul><p><strong>시스템 구성</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>E-commerce API Platform
</span></span><span class=line><span class=cl>├── Spring Boot 3.x (메인 프레임워크)
</span></span><span class=line><span class=cl>├── Spring Data JPA (데이터 접근)
</span></span><span class=line><span class=cl>├── H2/PostgreSQL (데이터베이스)
</span></span><span class=line><span class=cl>├── Spring Security (보안)
</span></span><span class=line><span class=cl>└── Gradle (빌드 도구)
</span></span></code></pre></td></tr></table></div></div><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>graph TB
    Client[클라이언트 앱] --&gt; Gateway[API Gateway]
    Gateway --&gt; Auth[인증 서비스]
    Gateway --&gt; Product[상품 서비스]
    Gateway --&gt; Order[주문 서비스]
    Gateway --&gt; User[사용자 서비스]
    
    Product --&gt; ProductDB[(상품 DB)]
    Order --&gt; OrderDB[(주문 DB)]
    User --&gt; UserDB[(사용자 DB)]
    
    subgraph &#34;Convention over Configuration 적용 영역&#34;
        Product
        Order
        User
    end
</pre><p><strong>활용 사례 Workflow</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Dev as 개발자
    participant SB as Spring Boot
    participant JPA as Spring Data JPA
    participant DB as 데이터베이스

    Note over Dev: 1. 엔티티 클래스 생성
    Dev-&gt;&gt;SB: @Entity Product 클래스 작성
    
    Note over SB: 2. 자동 설정 적용
    SB-&gt;&gt;JPA: 엔티티 스캔 및 Repository 생성
    SB-&gt;&gt;DB: 테이블 자동 생성 (products)
    
    Note over Dev: 3. REST API 개발
    Dev-&gt;&gt;SB: @RestController ProductController 작성
    SB-&gt;&gt;SB: /products 엔드포인트 자동 매핑
    
    Note over Dev: 4. 비즈니스 로직 구현
    Dev-&gt;&gt;Dev: Service 레이어 구현에 집중
</pre><p><strong>Convention over Configuration 의 역할</strong>:</p><ol><li><p><strong>엔티티 - 테이블 자동 매핑</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8>8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Product</span><span class=w> </span><span class=p>{</span><span class=w>  </span><span class=c1>// &#39;products&#39; 테이블 자동 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GeneratedValue</span><span class=p>(</span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GenerationType</span><span class=p>.</span><span class=na>IDENTITY</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>  </span><span class=c1>// &#39;id&#39; 컬럼 자동 매핑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w>  </span><span class=c1>// &#39;name&#39; 컬럼 자동 매핑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>BigDecimal</span><span class=w> </span><span class=n>price</span><span class=p>;</span><span class=w>  </span><span class=c1>// &#39;price&#39; 컬럼 자동 매핑</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Repository 자동 생성</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>interface</span> <span class=nc>ProductRepository</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>JpaRepository</span><span class=o>&lt;</span><span class=n>Product</span><span class=p>,</span><span class=w> </span><span class=n>Long</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// CRUD 메서드 자동 구현</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// findByName, findByPriceGreaterThan 등 메서드명 기반 쿼리 자동 생성</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>REST 엔드포인트 자동 매핑</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@RestController</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@RequestMapping</span><span class=p>(</span><span class=s>&#34;/api/products&#34;</span><span class=p>)</span><span class=w>  </span><span class=c1>// /api/products 기본 경로</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ProductController</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GetMapping</span><span class=w>  </span><span class=c1>// GET /api/products</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Product</span><span class=o>&gt;</span><span class=w> </span><span class=nf>getAllProducts</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GetMapping</span><span class=p>(</span><span class=s>&#34;/{id}&#34;</span><span class=p>)</span><span class=w>  </span><span class=c1>// GET /api/products/{id}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Product</span><span class=w> </span><span class=nf>getProduct</span><span class=p>(</span><span class=nd>@PathVariable</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h4 id=사례-2-spring-boot-기반-웹-서비스-개발>사례 2: Spring Boot 기반 웹 서비스 개발<a hidden class=anchor aria-hidden=true href=#사례-2-spring-boot-기반-웹-서비스-개발>#</a></h4><p><strong>시나리오</strong>: 신규 개발자가 팀에 합류하여 Spring Boot 로 웹 애플리케이션을 개발해야 하는 상황.</p><p><strong>시스템 구성 및 다이어그램</strong></p><pre class=mermaid>classDiagram
    class Application
    class Controller
    class Service
    class Repository
    Application --&gt; Controller
    Controller --&gt; Service
    Service --&gt; Repository
</pre><ul><li>Application: Spring Boot 프로젝트의 진입점, 관례적 구조와 설정 적용</li><li>Controller/Service/Repository: 관례적 네이밍 및 위치에 따라 자동 인식 및 연결</li></ul><p><strong>Workflow</strong>:</p><ol><li>개발자는 관례에 따라 Controller, Service, Repository 를 생성</li><li>별도 설정 없이 Spring Boot 가 자동으로 컴포넌트 스캔 및 DI(의존성 주입) 적용</li><li>필요시 application.properties 에서 설정 오버라이드</li></ol><p><strong>역할</strong>:</p><ul><li>Spring Boot: 관례적 구조/설정 자동 적용, 필요시 오버라이드 지원</li><li>개발자: 핵심 로직 개발에 집중, 관례만 숙지하면 빠른 개발 가능</li></ul><h4 id=사례-3-mvpminimum-viable-product-개발>사례 3: MVP(Minimum Viable Product) 개발<a hidden class=anchor aria-hidden=true href=#사례-3-mvpminimum-viable-product-개발>#</a></h4><p><strong>시나리오</strong>: Ruby on Rails 를 사용하여 기본 규칙에 따라 모델, 컨트롤러, 뷰를 생성하고, 최소한의 설정으로 애플리케이션을 구현한다.</p><p><strong>결과</strong>: 스타트업은 Ruby on Rails 의 Convention over Configuration 원칙을 적극 활용함으로써, 최소한의 설정으로 사용자 인증, 데이터베이스 모델링, RESTful API 를 빠르게 구축했다. 프로젝트 초기 설정 비용을 줄이고, 개발 속도를 2 배 이상 단축했으며, 코드 일관성과 테스트 유지보수성도 확보할 수 있었다.</p><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>graph TD
    A[Developer] --&gt;|rails generate model User| B[Model Layer]
    A --&gt;|rails generate controller Users| C[Controller Layer]
    B --&gt; D[ORM - ActiveRecord]
    C --&gt; E[Routing]
    C --&gt; F[View Rendering Engine]
    D --&gt; G[Database]
</pre><p><strong>Workflow</strong></p><pre class=mermaid>sequenceDiagram
    participant Dev as Developer
    participant Rails as Rails Framework
    participant DB as Database

    Dev-&gt;&gt;Rails: generate model User
    Rails--&gt;&gt;Dev: creates user.rb, migration, schema mapping
    Dev-&gt;&gt;Rails: generate controller Users
    Rails--&gt;&gt;Dev: creates users_controller.rb, routes
    Dev-&gt;&gt;Rails: start server
    Dev-&gt;&gt;Rails: access /users
    Rails-&gt;&gt;DB: query users table
    DB--&gt;&gt;Rails: returns user data
    Rails--&gt;&gt;Dev: renders user view
</pre><hr><p><strong>역할별 구성 요소 설명</strong>:</p><table><thead><tr><th>구성 요소</th><th>역할</th></tr></thead><tbody><tr><td>Developer</td><td>Rails CLI 를 사용하여 모델, 컨트롤러, 마이그레이션을 자동 생성</td></tr><tr><td>Rails Framework</td><td>Convention 에 따라 디렉터리 구조와 파일, 기본 동작 생성</td></tr><tr><td>ActiveRecord (ORM)</td><td>모델과 테이블 간 매핑 및 쿼리 처리</td></tr><tr><td>Routing</td><td>URL 경로를 컨트롤러 액션에 자동 연결</td></tr><tr><td>View Engine (ERB 등)</td><td>컨트롤러에서 받은 데이터를 HTML 뷰로 렌더링</td></tr><tr><td>Database</td><td>ORM 을 통해 조작되는 실제 데이터 저장소</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>관례 학습 및 교육</td><td>프레임워크나 도구의 내재된 규칙과 관례를 이해하지 못하면 개발 효율 저하</td><td>공식 문서 기반 가이드라인 작성, 온보딩 시 체크리스트 및 실습 환경 제공</td></tr><tr><td>프로젝트 초기 설계</td><td>디렉터리 구조, 명명 규칙, 자동 매핑 기준 등 초기부터 설계 방향성 확립 필요</td><td>프레임워크 권장 구조 기반 설계 + 예외 시 커스터마이징 방안 문서화</td></tr><tr><td>문서화</td><td>암묵적으로 동작하는 로직은 팀원 간 이해 차이 발생 가능</td><td>위키, 아키텍처 문서에 자동 매핑 구조, 오버라이드 방법, 예외 패턴 등 명시</td></tr><tr><td>코드 리뷰</td><td>관례 준수 여부와 설정 변경 영향 등을 코드 리뷰 과정에서 점검 필요</td><td>코드 리뷰 체크리스트에 관례 위반 항목 포함, 정적 분석 도구와 연동</td></tr><tr><td>오버라이드 관리</td><td>자동 설정을 무시하거나 수정할 경우 전체 시스템 동작에 영향</td><td>변경 이력 추적, 영향 분석 문서화, 오버라이드 허용 기준 수립</td></tr><tr><td>팀 내 협업 기준</td><td>규칙 기반 개발은 일관된 협업 구조가 전제됨</td><td>명명 규칙, 폴더 구조, 예외 처리 등을 표준 문서로 공유 및 팀 워크샵 진행</td></tr><tr><td>테스트 전략</td><td>암묵적 자동 설정은 유닛 테스트만으로 검증 어려움</td><td>통합 테스트 우선 전략 수립, 모킹 객체 활용, 자동 구성 영역에 대한 테스트 케이스 확보</td></tr><tr><td>프레임워크 버전 관리</td><td>CoC 동작은 프레임워크 버전에 종속되므로 마이너 변경에도 동작 변화 가능성 있음</td><td>LTS (Long Term Support) 버전 사용, 변경 로그 주기적 확인 및 호환성 테스트</td></tr><tr><td>성능 최적화</td><td>리플렉션 기반 자동 스캔, 클래스패스 분석은 런타임 성능에 영향을 줄 수 있음</td><td>APM (Application Performance Monitoring) 도구 도입, 필요한 경우 명시적 설정으로 전환</td></tr><tr><td>예외 상황 처리</td><td>관례로 처리되지 않는 비즈니스 로직이나 구성에 대한 예외 처리가 필요</td><td>예외 조건 명시, 로그 레벨 조정, 폴백 (fallback) 전략 마련</td></tr><tr><td>보안 고려</td><td>자동 스캐닝은 민감한 경로 또는 클래스를 포함할 수 있어 보안 이슈 가능성</td><td>스캔 범위 제한, 특정 패키지 제외 설정, 중요 설정은 명시적 선언 유지</td></tr><tr><td>커스터마이징 기준</td><td>관례를 무시하고 설정을 직접 구성해야 하는 경우 기준과 책임 명확화 필요</td><td>확장 지점 명확히 정의, 커스터마이징 가능한 위치와 방식 가이드 제공</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>스캐닝 최적화</strong></td><td>클래스패스 전체를 스캔하면 불필요한 리소스까지 포함되어 성능 저하</td><td><code>basePackages</code> 명시, <code>excludeFilters</code> 사용으로 범위 제한</td></tr><tr><td><strong>지연 로딩 활용</strong></td><td>필요하지 않은 컴포넌트까지 초기화되면 메모리와 부팅 시간 낭비</td><td><code>@Lazy</code>, 조건부 빈 등록 (<code>@ConditionalOnMissingBean</code>) 으로 불필요 초기화 방지</td></tr><tr><td><strong>리플렉션 최소화</strong></td><td>리플렉션은 런타임 오버헤드를 유발함</td><td><code>MethodHandle</code>, 바이트코드 생성 (예: ASM) 등 정적 바인딩 방식 고려</td></tr><tr><td><strong>메타데이터 캐싱</strong></td><td>반복적인 리플렉션 결과는 캐시를 통해 성능 개선 가능</td><td>메타데이터 캐시 전략 설계 (Spring 의 <code>StandardAnnotationMetadata</code> 등 활용)</td></tr><tr><td><strong>빌드 타임 분석 적용</strong></td><td>런타임이 아닌 컴파일 타임에 구성 분석을 수행하여 부팅 속도 및 실행 성능 향상</td><td><code>Annotation Processor</code>, <code>AOT (Ahead-Of-Time) 컴파일</code>, GraalVM 네이티브 이미지 등 활용</td></tr><tr><td><strong>시작 시간 최적화</strong></td><td>자동 설정 수가 많을수록 애플리케이션 부팅 속도 저하</td><td>조건부 자동 구성, 불필요 모듈 제거, 프로파일 기반 설정 분리 (<code>application-dev.yml</code> 등)</td></tr><tr><td><strong>모듈 경량화</strong></td><td>자동 설정 로직이 많은 라이브러리는 메모리 사용량 증가로 이어질 수 있음</td><td>실제 사용하는 기능 위주로 의존성 구성, 모놀리식 구조의 모듈 분리</td></tr><tr><td><strong>자동 설정 전략 관리</strong></td><td>과도한 오버라이드는 자동 설정 효율성을 해침</td><td>가능한 관례 유지, 필요 시 부분적 명시 설정만 적용</td></tr><tr><td><strong>라우팅 최적화</strong></td><td>자동 라우팅 수가 많아지면 매 요청마다 라우팅 테이블 탐색 비용 증가</td><td>불필요 라우팅 리소스 제외, URL 명시 구성 (<code>@RequestMapping</code>, <code>excludeRoutes</code>)</td></tr><tr><td><strong>ORM 성능 관리</strong></td><td>ORM 의 자동 쿼리/조인 기능은 편리하지만 성능 병목 가능성 존재</td><td>Lazy/Eager 로딩 전략 명확화, N+1 문제 방지 (<code>fetch join</code>, <code>includes</code>)</td></tr><tr><td><strong>의존성 관리</strong></td><td>자동 의존성 구성은 편리하지만 불필요 의존성 포함 시 성능 및 보안 이슈 발생</td><td>필요 최소화, BOM 및 보안 감사 툴 활용 (예: <code>npm audit</code>, <code>OWASP Dependency Check</code>)</td></tr><tr><td><strong>캐시 전략 적용</strong></td><td>자동 구성된 컴포넌트 또는 쿼리는 재사용할 수 있도록 캐싱 적용 필요</td><td>HTTP 캐시, 메모리 캐시 (Redis 등), ORM 쿼리 결과 캐시 병행 적용</td></tr><tr><td><strong>모니터링 및 튜닝</strong></td><td>암묵적 동작은 성능 병목의 원인 파악이 어려움</td><td>APM 도구 (New Relic, Prometheus 등) 도입으로 성능 지표 추적 및 병목 구간 가시화</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>언어 설계</td><td>DSL (Domain-Specific Language)</td><td>특정 도메인에 특화된 언어로 관례 표현</td></tr><tr><td>아키텍처 패턴</td><td>IoC (Inversion of Control)</td><td>제어 역전을 통한 프레임워크 주도 설정</td></tr><tr><td>설계 원칙</td><td>DI (Dependency Injection)</td><td>의존성 주입을 통한 자동 연결</td></tr><tr><td>프로그래밍 기법</td><td>리플렉션 (Reflection)</td><td>런타임 메타데이터 분석을 통한 동적 설정</td></tr><tr><td>메타프로그래밍</td><td>어노테이션 처리 (Annotation Processing)</td><td>컴파일 타임 코드 생성 및 분석</td></tr><tr><td>빌드 도구</td><td>자동 설정 (Auto-configuration)</td><td>의존성 기반 자동 환경 구성</td></tr><tr><td>테스트 전략</td><td>통합 테스트</td><td>관례 기반 동작의 전체적 검증</td></tr><tr><td>성능 최적화</td><td>지연 로딩 (Lazy Loading)</td><td>필요시점까지 초기화 지연</td></tr></tbody></table><h3 id=하위-주제로-분류한-추가-학습-내용>하위 주제로 분류한 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류한-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>설계 패턴</td><td>Factory Pattern</td><td>관례 기반 객체 생성</td></tr><tr><td></td><td>Builder Pattern</td><td>설정 객체의 단계별 구성</td></tr><tr><td></td><td>Strategy Pattern</td><td>관례별 다른 전략 적용</td></tr><tr><td>프레임워크 설계</td><td>Plugin Architecture</td><td>확장 가능한 관례 시스템</td></tr><tr><td></td><td>Service Provider Interface</td><td>표준 인터페이스 기반 자동 발견</td></tr><tr><td>빌드 시스템</td><td>Gradle Convention Plugin</td><td>빌드 스크립트의 관례화</td></tr><tr><td></td><td>Maven Archetype</td><td>프로젝트 템플릿 기반 생성</td></tr><tr><td>테스트 자동화</td><td>Test Fixture</td><td>테스트 데이터 자동 설정</td></tr><tr><td>성능 튜닝</td><td>Native Image</td><td>컴파일 타임 최적화</td></tr><tr><td>문서화</td><td>OpenAPI Generator</td><td>관례 기반 API 문서 자동 생성</td></tr></tbody></table><h3 id=관련-분야의-추가-학습-내용>관련 분야의 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야의-추가-학습-내용>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>Software Architecture</td><td>Microservices Patterns</td><td>서비스 간 관례 기반 통신</td></tr><tr><td></td><td>Event-Driven Architecture</td><td>이벤트 명명 및 라우팅 관례</td></tr><tr><td>DevOps</td><td>Infrastructure as Code</td><td>인프라 설정의 관례화</td></tr><tr><td></td><td>GitOps</td><td>Git 기반 배포 관례</td></tr><tr><td>API Design</td><td>RESTful API Design</td><td>HTTP 메서드와 URL 관례</td></tr><tr><td></td><td>GraphQL Schema</td><td>스키마 명명 및 구조 관례</td></tr><tr><td>Database Design</td><td>Schema Migration</td><td>데이터베이스 변경 관례</td></tr><tr><td></td><td>ORM Mapping</td><td>객체 - 관계 매핑 관례</td></tr><tr><td>Security</td><td>Authentication Patterns</td><td>인증/인가 설정 관례</td></tr><tr><td></td><td>HTTPS/TLS Configuration</td><td>보안 설정의 자동화</td></tr><tr><td>Monitoring</td><td>Observability</td><td>로깅, 메트릭, 트레이싱 관례</td></tr><tr><td></td><td>Health Check Patterns</td><td>서비스 상태 확인 관례</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><h3 id=아키텍처-및-설계-패턴>아키텍처 및 설계 패턴<a hidden class=anchor aria-hidden=true href=#아키텍처-및-설계-패턴>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>DI (Dependency Injection)</strong></td><td>객체 간 결합도를 낮추고 테스트 용이성을 확보하기 위한 설계 패턴</td></tr><tr><td><strong>ActiveRecord</strong></td><td>ORM의 한 방식으로, 모델이 자체적으로 DB 접근 로직을 포함하는 구조</td></tr><tr><td><strong>Metaprogramming (메타프로그래밍)</strong></td><td>프로그램이 코드 자체를 분석하거나 생성·수정하는 고급 설계 기술</td></tr><tr><td><strong>Annotation Processing</strong></td><td>어노테이션 정보를 기반으로 컴파일 타임에 코드나 설정을 자동 생성하는 기법</td></tr></tbody></table><hr><h3 id=프레임워크라이브러리-기반-기능-및-코드-구조화>프레임워크/라이브러리 기반 기능 및 코드 구조화<a hidden class=anchor aria-hidden=true href=#프레임워크라이브러리-기반-기능-및-코드-구조화>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Routing (라우팅)</strong></td><td>요청 URL을 컨트롤러/핸들러와 연결하는 역할</td></tr><tr><td><strong>View Engine</strong></td><td>템플릿과 데이터를 조합해 최종 사용자에게 보여질 UI를 렌더링</td></tr><tr><td><strong>Scaffolding (스캐폴딩)</strong></td><td>프로젝트 초기 구조 및 반복적인 CRUD 코드를 자동 생성</td></tr><tr><td><strong>Boilerplate Code</strong></td><td>필수적이지만 반복적으로 작성되는 전형적 코드 구조</td></tr><tr><td><strong>ORM (Object-Relational Mapping)</strong></td><td>객체와 관계형 DB 간의 자동화된 매핑 시스템</td></tr><tr><td><strong>Classpath Scanning</strong></td><td>런타임 시 클래스패스 내 특정 클래스나 어노테이션 자동 검색</td></tr><tr><td><strong>Reflection (리플렉션)</strong></td><td>클래스나 메서드 등의 정보를 런타임에 탐색하거나 조작하는 기능</td></tr></tbody></table><h3 id=빌드-및-실행-시점-동작>빌드 및 실행 시점 동작<a hidden class=anchor aria-hidden=true href=#빌드-및-실행-시점-동작>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Reflection (리플렉션)</strong></td><td>런타임 중 동적 탐색 및 실행을 가능케 하는 기능</td></tr><tr><td><strong>Classpath Scanning</strong></td><td>런타임 또는 빌드타임 클래스 탐색</td></tr><tr><td><strong>Annotation Processing</strong></td><td>컴파일 타임에 어노테이션 기반 코드 생성</td></tr><tr><td><strong>Metaprogramming</strong></td><td>런타임/컴파일타임 시점에 코드의 생성, 변경, 실행을 수행하는 프로그래밍 기법</td></tr></tbody></table><h3 id=devops-및-배포-자동화>DevOps 및 배포 자동화<a hidden class=anchor aria-hidden=true href=#devops-및-배포-자동화>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>CI/CD</strong></td><td>지속적 통합/배포를 통해 개발 효율성과 안정성을 높이는 자동화 방식</td></tr></tbody></table><h3 id=기능-활성화-및-설정-방식>기능 활성화 및 설정 방식<a hidden class=anchor aria-hidden=true href=#기능-활성화-및-설정-방식>#</a></h3><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>Override (오버라이드)</strong></td><td>기본 설정 또는 동작을 명시적으로 덮어쓰는 행위</td></tr><tr><td><strong>Opt-in (옵트인)</strong></td><td>사용자가 명시적으로 요청해야 기능이 활성화되는 방식</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=-공식-문서-및-기술-블로그>📘 공식 문서 및 기술 블로그<a hidden class=anchor aria-hidden=true href=#-공식-문서-및-기술-블로그>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Convention_over_configuration>Convention over configuration - Wikipedia</a></li><li><a href=https://martinfowler.com/bliki/ConventionOverConfiguration.html>Martin Fowler - Convention Over Configuration</a></li><li><a href=https://learn.microsoft.com/en-us/archive/msdn-magazine/2009/february/patterns-in-practice-convention-over-configuration>Patterns in Practice - Convention Over Configuration | Microsoft Learn</a></li><li><a href=https://www.devx.com/terms/convention-over-configuration/>Convention Over Configuration - Glossary - DevX</a></li><li><a href=https://markheath.net/post/convention-over-configuration>Convention Over Configuration</a></li><li><a href=https://devopedia.org/convention-over-configuration>Convention over Configuration - Devopedia</a></li><li><a href=https://medium.com/@hermanjunge/convention-over-configuration-why-it-matters-40a21f6f5d7e>How Convention Over Configuration simplifies code - Medium</a></li><li><a href=https://startup-house.com/glossary/convention-over-configuration>Convention Over Configuration: Streamlining Software Development | Startup House</a></li><li><a href=https://build5nines.com/benefits-of-convention-over-configuration-for-iac-deployment-projects/>Benefits Of Convention Over Configuration For IaC Deployment Projects - Build5Nines</a></li></ul><h3 id=-프레임워크-문서-및-레퍼런스>🧱 프레임워크 문서 및 레퍼런스<a hidden class=anchor aria-hidden=true href=#-프레임워크-문서-및-레퍼런스>#</a></h3><ul><li><a href=https://rubyonrails.org/doctrine>The Rails Doctrine</a></li><li><a href=https://guides.rubyonrails.org/>Ruby on Rails Guides</a></li><li><a href=https://docs.spring.io/spring-boot/index.html>Spring Boot :: Spring Boot 공식 문서</a></li><li><a href=https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/>Spring Boot Reference Guide</a></li><li><a href=https://docs.djangoproject.com/en/stable/>Django Documentation</a></li><li><a href=https://www.geeksforgeeks.org/springboot-configuration/>SpringBoot Configuration | GeeksforGeeks</a></li><li><a href=https://www.geeksforgeeks.org/django-vs-spring-boot/>Django vs Spring Boot: Which is Better For Your Website | GeeksforGeeks</a></li></ul><h3 id=-개인-및-커뮤니티-블로그>🧑‍💻 개인 및 커뮤니티 블로그<a hidden class=anchor aria-hidden=true href=#-개인-및-커뮤니티-블로그>#</a></h3><ul><li><a href=https://erinyees.tistory.com/1>CoC(Convention over Configuration) - Erinyees의 블로그</a></li><li><a href=https://ko.wikipedia.org/wiki/%EC%84%A4%EC%A0%95%EB%B3%B4%EB%8B%A4_%EA%B4%80%EC%8A%B5>설정보다 관습 - 위키백과 (한국어)</a></li><li><a href=https://bigdown.tistory.com/entry/Spring-Boot-%EC%B2%AB-%EB%B2%88%EC%A7%B8-%EC%98%88%EC%A0%9C>Spring Boot 첫 번째 예제 - 기억을 지배하는 기록</a></li><li><a href=https://codelila.com/convention-over-configuration-rails-design-philosophy/>Accelerate Development with Rails Convention Over Configuration - Codelila</a></li><li><a href=https://jdm.kr/blog/101>Convention over configuration(CoC)의 이해 :: JDM&rsquo;s Blog</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>