<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Modeling | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Modeling"><meta name=description content='"Principles and Modeling" 은 소프트웨어 시스템의 설계와 구축을 위한 근본적인 원칙들과 이를 시각적으로 표현하고 분석하는 모델링 기법들을 통합한 분야이다. 원칙은 설계와 구현의 방향성을 제시하며, 모델링은 복잡한 시스템을 시각적으로 구조화해 이해와 의사소통, 검증, 최적화를 가능하게 한다. SOLID 원칙과 같은 설계 원칙을 통해 시스템의 품질과 유지보수성을 확보하고, UML 과 같은 모델링 언어로 시스템의 구조와 동작을 명확하게 표현하여 개발팀 간의 소통과 시스템 이해를 촉진하는 것이 핵심이다.'><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/modeling-and-documentation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/modeling-and-documentation/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/modeling-and-documentation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/modeling-and-documentation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Modeling"><meta property="og:description" content='"Principles and Modeling" 은 소프트웨어 시스템의 설계와 구축을 위한 근본적인 원칙들과 이를 시각적으로 표현하고 분석하는 모델링 기법들을 통합한 분야이다. 원칙은 설계와 구현의 방향성을 제시하며, 모델링은 복잡한 시스템을 시각적으로 구조화해 이해와 의사소통, 검증, 최적화를 가능하게 한다. SOLID 원칙과 같은 설계 원칙을 통해 시스템의 품질과 유지보수성을 확보하고, UML 과 같은 모델링 언어로 시스템의 구조와 동작을 명확하게 표현하여 개발팀 간의 소통과 시스템 이해를 촉진하는 것이 핵심이다.'><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Modeling"><meta name=twitter:description content='"Principles and Modeling" 은 소프트웨어 시스템의 설계와 구축을 위한 근본적인 원칙들과 이를 시각적으로 표현하고 분석하는 모델링 기법들을 통합한 분야이다. 원칙은 설계와 구현의 방향성을 제시하며, 모델링은 복잡한 시스템을 시각적으로 구조화해 이해와 의사소통, 검증, 최적화를 가능하게 한다. SOLID 원칙과 같은 설계 원칙을 통해 시스템의 품질과 유지보수성을 확보하고, UML 과 같은 모델링 언어로 시스템의 구조와 동작을 명확하게 표현하여 개발팀 간의 소통과 시스템 이해를 촉진하는 것이 핵심이다.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Modeling","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/modeling-and-documentation/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Modeling</h1><div class=post-description>&ldquo;Principles and Modeling&rdquo; 은 소프트웨어 시스템의 설계와 구축을 위한 근본적인 원칙들과 이를 시각적으로 표현하고 분석하는 모델링 기법들을 통합한 분야이다. 원칙은 설계와 구현의 방향성을 제시하며, 모델링은 복잡한 시스템을 시각적으로 구조화해 이해와 의사소통, 검증, 최적화를 가능하게 한다. SOLID 원칙과 같은 설계 원칙을 통해 시스템의 품질과 유지보수성을 확보하고, UML 과 같은 모델링 언어로 시스템의 구조와 동작을 명확하게 표현하여 개발팀 간의 소통과 시스템 이해를 촉진하는 것이 핵심이다.</div></header><div class=post-content><h2 id=modeling>Modeling<a hidden class=anchor aria-hidden=true href=#modeling>#</a></h2><p>소프트웨어 개발에서 Principles and Modeling 은 복잡한 시스템을 체계적으로 설계하고 관리하기 위한 필수적인 접근법이다. 설계 원칙은 비즈니스 목표와 전략을 기술적 설계에 연결하는 역할을 하고 코드의 품질, 유지보수성, 확장성을 보장하는 가이드라인을 제공하며, 모델링은 시스템의 구조와 동작을 추상화하여 구조, 행위, 데이터 흐름 등을 시각적으로 표현해 다양한 이해관계자들이 쉽게 이해하고 소통할 수 있도록 돕는다. 이 두 영역의 결합을 통해 고품질의 소프트웨어 시스템을 효율적으로 개발하고 관리할 수 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><strong>아키텍처 원칙 (Architecture Principles)</strong>: 시스템 또는 엔터프라이즈 아키텍처의 설계와 변화에 대한 방향성과 제약을 제공하는 기본적 지침. 전략과 설계 사이의 다리 역할을 하며, 일관성·미래지향성·지속가능성을 보장한다.</li><li><strong>모델링 (Modeling)</strong>: 시스템의 구조, 행위, 데이터 흐름 등을 추상화하여 시각적으로 표현하는 과정. 복잡성 관리, 의사소통, 검증, 설계 품질 향상에 필수적이다.</li><li><strong>개념 모델 (Conceptual Model)</strong>: 시스템의 주요 개념과 이들 간의 관계를 정의하는 모델. 요구사항, 구조, 행위, 속성 등을 포함한다.</li><li><strong>다중 관점 (Multi-view Modeling)</strong>: 시스템을 다양한 관점 (Use Case, Design, Process, Implementation, Deployment) 에서 모델링하여 전체 구조와 세부 동작을 모두 이해한다.</li><li><strong>추상화 (Abstraction)</strong>: 불필요한 세부사항을 숨기고 본질적인 특성에 집중하는 모델링의 핵심 원리.</li><li><strong>정확성·일관성·연결성 (Precision, Consistency, Connectedness)</strong>: 모델은 현실과 연결되어야 하며, 명확하고 일관성 있게 표현되어야 한다.</li></ul><h4 id=설계-원칙-design-principles>설계 원칙 (Design Principles)<a hidden class=anchor aria-hidden=true href=#설계-원칙-design-principles>#</a></h4><ul><li><strong>SOLID 원칙</strong>: 객체지향 설계의 5 가지 핵심 원칙</li><li><strong>관심사의 분리 (Separation of Concerns)</strong>: 시스템을 독립적인 부분으로 분해</li><li><strong>추상화 (Abstraction)</strong>: 복잡성을 숨기고 본질만 드러내는 기법</li><li><strong>캡슐화 (Encapsulation)</strong>: 데이터와 메서드를 하나의 단위로 묶는 원칙</li></ul><h4 id=모델링-기법-modeling-techniques>모델링 기법 (Modeling Techniques)<a hidden class=anchor aria-hidden=true href=#모델링-기법-modeling-techniques>#</a></h4><ul><li><strong>UML (Unified Modeling Language)</strong>: 시스템 설계를 위한 표준 모델링 언어</li><li><strong>C4 모델</strong>: 시스템을 계층적으로 표현하여 다양한 수준의 아키텍처 뷰를 제공한다.<ul><li><strong>Context Diagram</strong>: 시스템과 외부 요소 간의 관계를 나타낸다.</li><li><strong>Container Diagram</strong>: 시스템을 구성하는 주요 컨테이너 (애플리케이션, 데이터베이스 등) 를 표현한다.</li><li><strong>Component Diagram</strong>: 각 컨테이너 내의 구성 요소와 그들 간의 관계를 상세히 나타낸다.</li><li><strong>Code Diagram</strong>: 구현 수준의 세부 사항을 보여준다.</li></ul></li><li><strong>ADL (Architecture Description Language)</strong>: 아키텍처를 명확하게 기술하고 분석할 수 있는 언어.</li><li><strong>도메인 모델링 (Domain Modeling)</strong>: 비즈니스 도메인의 개념적 표현</li><li><strong>아키텍처 모델링</strong>: 시스템의 고수준 구조 표현</li><li><strong>행위 모델링 (Behavioral Modeling)</strong>: 시스템의 동적 동작 표현</li></ul><h3 id=배경-및-목적>배경 및 목적<a hidden class=anchor aria-hidden=true href=#배경-및-목적>#</a></h3><p>소프트웨어 시스템의 복잡성이 증가하면서 체계적인 설계 방법론의 필요성이 대두되었다. Robert C. Martin 이 2000 년에 제시한 SOLID 원칙과 1990 년대에 표준화된 UML 은 이러한 요구에 대한 응답으로 등장했다.</p><p>이들의 목적은 다음과 같다:</p><ul><li><strong>품질 향상</strong>: 유지보수 가능하고 확장 가능한 소프트웨어 개발</li><li><strong>의사소통 개선</strong>: 개발팀과 이해관계자 간의 명확한 소통</li><li><strong>위험 관리</strong>: 설계 단계에서의 문제 조기 발견 및 해결</li><li><strong>표준화</strong>: 일관된 개발 방법론 제공</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><h4 id=설계-원칙의-기능>설계 원칙의 기능<a hidden class=anchor aria-hidden=true href=#설계-원칙의-기능>#</a></h4><ul><li><strong>코드 구조화</strong>: 체계적이고 논리적인 코드 구성</li><li><strong>결합도 감소</strong>: 모듈 간 의존성 최소화</li><li><strong>응집도 증가</strong>: 관련 기능의 밀접한 결합</li><li><strong>재사용성 향상</strong>: 컴포넌트의 재활용 가능성 증대</li></ul><h4 id=모델링의-역할>모델링의 역할<a hidden class=anchor aria-hidden=true href=#모델링의-역할>#</a></h4><ul><li><strong>시각화</strong>: 복잡한 시스템의 직관적 표현</li><li><strong>문서화</strong>: 설계 결정사항과 시스템 구조 기록</li><li><strong>검증</strong>: 요구사항과 설계의 일치성 확인</li><li><strong>소통</strong>: 다양한 이해관계자 간의 공통 언어 제공</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>원칙은 변하지 않는 핵심 (핵심 메커니즘/패턴), 모델은 상황에 따라 다양한 형태로 구현.</li><li>모델은 다양한 정밀도와 관점에서 표현 가능하며, 현실과의 연결성이 중요.</li><li>모델링은 반복적·점진적으로 발전하며, 실험과 검증을 통해 완성도 향상.</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ul><li><strong>분리 (Separation)</strong>: 사용자 개념과 기술 개념 분리, 관심사의 분리.</li><li><strong>연결성 (Connectedness)</strong>: 모델과 현실의 연결, 다양한 관점의 통합.</li><li><strong>정확성 (Precision)</strong>: 명확한 정의와 일관성 있는 표현.</li><li><strong>단순화 (Simplification)</strong>: 복잡성 감소, 본질에 집중.</li><li><strong>모듈화 (Modularity)</strong>: 각 구성요소의 독립성 보장.</li></ul><h4 id=설계-원칙-design-principles-1>설계 원칙 (Design Principles)<a hidden class=anchor aria-hidden=true href=#설계-원칙-design-principles-1>#</a></h4><p><strong>SOLID 원칙</strong>: 소프트웨어 설계에서 코드의 유지보수성, 확장성, 재사용성을 높이기 위해 제안된 5 가지 핵심 설계 원칙을 의미한다. 객체지향 설계에서 주로 언급되지만, 절차적 프로그래밍 등 다양한 패러다임에도 적용할 수 있다.</p><table><thead><tr><th>원칙명</th><th>설명</th><th>핵심 개념</th><th>설계 목적</th></tr></thead><tbody><tr><td><strong>단일 책임 원칙 (SRP)</strong></td><td>클래스는 하나의 책임만 가져야 하며, 변경 이유도 하나여야 함</td><td>기능별 책임 분리</td><td>유지보수성과 변경 용이성 확보</td></tr><tr><td><strong>개방 - 폐쇄 원칙 (OCP)</strong></td><td>확장에는 열려 있고, 기존 코드는 수정 없이 재사용 가능해야 함</td><td>추상화와 다형성 활용</td><td>기능 확장 시 기존 코드 안정성 유지</td></tr><tr><td><strong>리스코프 치환 원칙 (LSP)</strong></td><td>하위 타입은 상위 타입으로 대체 가능해야 함</td><td>다형성의 일관성</td><td>코드 재사용성과 예측 가능성 확보</td></tr><tr><td><strong>인터페이스 분리 원칙 (ISP)</strong></td><td>클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 됨</td><td>작고 명확한 인터페이스</td><td>유연하고 응집력 높은 API 설계</td></tr><tr><td><strong>의존성 역전 원칙 (DIP)</strong></td><td>고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 추상화에 의존해야 함</td><td>추상 계층 도입</td><td>유연하고 테스트 가능한 아키텍처 구성</td></tr></tbody></table><h4 id=모델링-원칙>모델링 원칙<a hidden class=anchor aria-hidden=true href=#모델링-원칙>#</a></h4><ul><li><strong>추상화</strong>: 불필요한 세부사항 제거</li><li><strong>단순성</strong>: 이해하기 쉬운 모델 작성</li><li><strong>일관성</strong>: 표기법과 용어의 통일</li><li><strong>완전성</strong>: 필요한 모든 측면의 포함</li></ul><h3 id=원칙과-모델링의-통합-효과>원칙과 모델링의 통합 효과<a hidden class=anchor aria-hidden=true href=#원칙과-모델링의-통합-효과>#</a></h3><ul><li><strong>품질 보장</strong>: SOLID 원칙 준수로 유지보수성과 확장성 확보</li><li><strong>명확한 소통</strong>: UML 모델링으로 이해관계자 간 효과적 의사소통</li><li><strong>위험 완화</strong>: 설계 단계에서 문제점 조기 발견 및 대응</li><li><strong>지속적 개선</strong>: 모델 기반 리팩토링과 시스템 진화</li></ul><h3 id=아키텍처-설계-프로세스>아키텍처 설계 프로세스<a hidden class=anchor aria-hidden=true href=#아키텍처-설계-프로세스>#</a></h3><table><thead><tr><th>단계</th><th>명칭</th><th>주요 활동 내용</th><th>목적 및 산출물</th></tr></thead><tbody><tr><td>1 단계</td><td><strong>요구사항 분석</strong></td><td>- 비즈니스 목표 및 시스템 목적 정의<br>- 이해관계자의 요구사항 수집 및 정리<br>- 시스템 범위 및 제약사항 도출</td><td>요구사항 명세서, 유즈케이스, 요구사항 목록</td></tr><tr><td>2 단계</td><td><strong>원칙 적용</strong></td><td>- SOLID 등 설계 원칙 적용<br>- 적절한 아키텍처 패턴 선택<br>- 설계 가이드라인 수립</td><td>아키텍처 결정 문서, 설계 가이드</td></tr><tr><td>3 단계</td><td><strong>모델링</strong></td><td>- UML 다이어그램 작성 (클래스, 시퀀스, 컴포넌트 등)<br>- 도메인 모델 및 아키텍처 뷰 구성</td><td>모델 문서, 시각화된 시스템 설계</td></tr><tr><td>4 단계</td><td><strong>검증 및 개선</strong></td><td>- 설계 원칙 및 패턴의 적용 여부 검토<br>- 리뷰 및 피드백 반영<br>- 지속적 리팩토링 및 품질 개선</td><td>설계 리뷰 리포트, 개선된 설계안</td></tr></tbody></table><h4 id=모델링-워크플로우>모델링 워크플로우<a hidden class=anchor aria-hidden=true href=#모델링-워크플로우>#</a></h4><table><thead><tr><th>단계</th><th>명칭</th><th>주요 활동 내용</th><th>산출물 및 목적</th></tr></thead><tbody><tr><td>1 단계</td><td><strong>도메인 분석</strong></td><td>- 비즈니스 도메인의 핵심 개념 및 관계 도출<br>- 유비쿼터스 언어 정의<br>- 도메인 전문가와 협업</td><td>도메인 모델, 개념 클래스 다이어그램</td></tr><tr><td>2 단계</td><td><strong>요구사항 모델링</strong></td><td>- 유스케이스 다이어그램으로 액터와 시스템 기능 정의<br>- 기능적/비기능적 요구사항 문서화</td><td>유스케이스 모델, 요구사항 명세서</td></tr><tr><td>3 단계</td><td><strong>구조 설계</strong></td><td>- 클래스/컴포넌트 다이어그램 작성<br>- 패키지/모듈 간 의존성 정의</td><td>시스템 구조 설계서, 클래스 및 컴포넌트 뷰</td></tr><tr><td>4 단계</td><td><strong>동작 모델링</strong></td><td>- 시퀀스/액티비티 다이어그램으로 흐름 정의<br>- 상태 다이어그램으로 객체 생명주기 표현</td><td>행위 모델, 시스템 흐름 문서</td></tr></tbody></table><p><strong>모델링 기법 (Modeling Techniques)</strong>:</p><ul><li>구조 다이어그램 (Structure): 시스템의 정적 구조 표현</li><li>행위 다이어그램 (Behavior): 시스템의 동적 동작 표현</li><li>상호작용 다이어그램 (Interaction): 객체 간 상호작용 표현</li><li>도메인 모델링: 비즈니스 도메인의 개념적 표현</li><li>아키텍처 모델링: 시스템의 고수준 구조 표현</li></ul><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1>사례 1<a hidden class=anchor aria-hidden=true href=#사례-1>#</a></h4><p><strong>시나리오</strong>: 대형 병원 정보 시스템 구축</p><p><strong>시스템 구성</strong>: 환자 관리, 진료, 예약, 결제, 데이터 분석 등 모듈. 각 모듈은 개념 계층 (환자, 진료, 예약 등), 뷰 계층 (의사/간호사/행정별 맞춤 뷰), 사용자 계층 (역할별 접근 제어) 로 설계.</p><p><strong>다이어그램</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[환자관리 개념] → [의사 뷰] → [의사 사용자]
</span></span><span class=line><span class=cl>            → [간호사 뷰] → [간호사 사용자]
</span></span><span class=line><span class=cl>            → [행정 뷰]   → [행정 사용자]
</span></span></code></pre></td></tr></table></div></div><p><strong>Workflow</strong>:</p><ul><li>환자 등록 → 진료 예약 → 진료 기록 → 결제 및 데이터 분석. 각 단계별로 역할별 뷰 제공 및 데이터 흐름 명확화.</li></ul><p><strong>역할</strong>:</p><ul><li>복잡성 감소, 사용자 맞춤화, 데이터 일관성, 변화 대응력 강화.</li></ul><h4 id=사례-2>사례 2<a hidden class=anchor aria-hidden=true href=#사례-2>#</a></h4><p><strong>시나리오</strong>: 국제 전자상거래 플랫폼의 아키텍처 설계</p><p><strong>배경</strong>:</p><ul><li>다양한 국가의 사용자와 결제 시스템을 지원하는 플랫폼 구축</li></ul><p><strong>적용 원칙 및 기법</strong>:</p><ul><li><strong>SOLID 원칙</strong><ul><li>각 도메인 서비스 (예: 상품, 결제, 배송) 는 단일 책임을 가지도록 설계.</li><li>의존 역전 원칙을 적용해 각 서비스는 인터페이스 기반으로 외부와 통신.</li></ul></li><li><strong>DRY 원칙</strong><ul><li>결제 인증 로직, 주소 정규화 로직 등은 공통 유틸 모듈로 추출하여 재사용.</li></ul></li><li><strong>KISS 원칙</strong><ul><li>복잡한 결제 플로우는 상태 패턴 (State Pattern) 을 통해 단순화.</li></ul></li><li><strong>C4 모델</strong><ul><li><strong>Context Diagram</strong>: 외부 결제 API, 고객, 관리자, 재고 시스템과의 관계 정의.</li><li><strong>Container Diagram</strong>: Web App, Backend API, Payment Processor, DB 등 구성.</li><li><strong>Component Diagram</strong>: Backend API 내부를 주문, 장바구니, 할인 컴포넌트로 구분.</li><li><strong>Code Diagram</strong>: 각 컴포넌트의 클래스 구조 및 인터페이스 명세 설계.</li></ul></li></ul><p><strong>시스템 구성도</strong>:</p><pre class=mermaid>graph TD
  User[고객] --&gt; WebApp[Web Application]
  WebApp --&gt; APIGW[API Gateway]
  APIGW --&gt; AuthService[인증 서비스]
  APIGW --&gt; OrderService[주문 서비스]
  APIGW --&gt; PaymentService[결제 서비스]
  PaymentService --&gt; ExternalAPI[해외 PG사 API]
  OrderService --&gt; InventoryService[재고 서비스]
  OrderService --&gt; ShippingService[배송 서비스]
  OrderService --&gt; DB[(PostgreSQL)]
  PaymentService --&gt; Redis[Redis Cache]
  ShippingService --&gt; NotificationService[알림 서비스]
</pre><p><strong>워크플로우</strong>:<br>예시) 국제 결제 흐름 중심</p><ol><li>고객이 장바구니에 상품을 담고 결제 요청.</li><li><strong>API Gateway</strong>가 요청을 라우팅 → <strong>Authentication Service</strong>에서 사용자 인증.</li><li><strong>Order Service</strong>가 주문 생성 → <strong>Inventory Service</strong>로 재고 차감 요청.</li><li><strong>Payment Service</strong>는 외부 PG 사 API 에 결제 요청 → 실패 시 Circuit Breaker 로 격리.</li><li>성공 시 주문 상태를 업데이트 → <strong>Shipping Service</strong>에 배송 요청.</li><li>배송 시작 이벤트가 발생하면 → <strong>Notification Service</strong>가 이메일/SMS 발송.</li></ol><h4 id=사례-3>사례 3<a hidden class=anchor aria-hidden=true href=#사례-3>#</a></h4><p><strong>시나리오</strong>: 대규모 전자상거래 플랫폼을 새로 구축하는 프로젝트에서 Principles and Modeling 을 활용한 시스템 설계를 수행했다. 이 프로젝트는 확장 가능하고 유지보수가 용이한 마이크로서비스 아키텍처 기반 플랫폼 구축을 목표로 했다.</p><p><strong>시스템 구성</strong>: 마이크로서비스 구조</p><table><thead><tr><th>서비스명</th><th>기술 스택</th><th>주요 역할</th></tr></thead><tbody><tr><td><strong>사용자 서비스</strong></td><td>Spring Boot + JWT</td><td>회원가입, 로그인, 프로필 관리</td></tr><tr><td><strong>상품 서비스</strong></td><td>Spring Boot + MySQL</td><td>상품 정보 관리, 카테고리 분류, 검색 기능 제공</td></tr><tr><td><strong>주문 서비스</strong></td><td>Spring Boot + Kafka</td><td>주문 처리, 결제 연동, 주문 상태 관리</td></tr><tr><td><strong>결제 서비스</strong></td><td>Spring Boot + PG 연동</td><td>다양한 결제 수단 지원, 결제 검증 및 환불 처리</td></tr><tr><td><strong>재고 서비스</strong></td><td>Spring Boot + Redis</td><td>실시간 재고 관리, 재고 부족 알림, 입출고 이력 관리</td></tr><tr><td><strong>알림 서비스</strong></td><td>Spring Boot + WebSocket</td><td>실시간 알림, 이메일/SMS 발송, 푸시 알림</td></tr></tbody></table><p><strong>개발 워크플로우</strong>:</p><table><thead><tr><th>단계</th><th>명칭</th><th>주요 내용</th><th>산출물 및 목표</th></tr></thead><tbody><tr><td>1 단계</td><td><strong>도메인 분석</strong></td><td>- 전자상거래 핵심 개념, 비즈니스 규칙 파악<br>- 엔티티: User, Product, Order 등<br>- 주문 - 결제 - 배송 규칙 정리</td><td>도메인 모델, 유비쿼터스 언어 정의</td></tr><tr><td>2 단계</td><td><strong>유스케이스 모델링</strong></td><td>- 고객, 관리자, 배송업체 중심 유스케이스 도출<br>- 상품 검색, 주문, 결제 등 기능 정의</td><td>유스케이스 다이어그램, 요구사항 목록</td></tr><tr><td>3 단계</td><td><strong>아키텍처 설계</strong></td><td>- 마이크로서비스 아키텍처 기반 설계<br>- 서비스 경계 및 통신 방식 정의<br>- 데이터 일관성 전략 수립</td><td>아키텍처 뷰, 서비스 분해 전략 문서</td></tr><tr><td>4 단계</td><td><strong>상세 설계</strong></td><td>- 클래스/시퀀스 다이어그램 작성<br>- API 인터페이스 정의<br>- DB 스키마 모델링</td><td>설계 문서, API 명세, ERD</td></tr><tr><td>5 단계</td><td><strong>구현 및 테스트</strong></td><td>- 모델 기반 코드 구현<br>- 단위/통합/성능 테스트 수행<br>- 부하 처리 시나리오 기반 검증</td><td>기능 구현된 서비스, 테스트 결과 리포트</td></tr></tbody></table><p><strong>적용된 설계 원칙</strong></p><ul><li>SOLID 원칙 적용 사례</li></ul><table><thead><tr><th>원칙명</th><th>적용 방식</th><th>예시</th></tr></thead><tbody><tr><td><strong>SRP</strong>(단일 책임 원칙)</td><td>각 서비스가 하나의 책임만 가지도록 분리</td><td>사용자 서비스는 사용자 관리만 담당</td></tr><tr><td><strong>OCP</strong>(개방 - 폐쇄 원칙)</td><td>인터페이스 기반 확장 설계</td><td>새로운 결제 방식 추가 시 기존 코드 수정 없이 구현 가능</td></tr><tr><td><strong>LSP</strong>(리스코프 치환 원칙)</td><td>상위 타입으로 대체 가능한 설계</td><td>알림 인터페이스를 구현한 Email, SMS, Push 클래스 사용</td></tr><tr><td><strong>ISP</strong>(인터페이스 분리 원칙)</td><td>역할별로 인터페이스를 세분화</td><td>결제 인터페이스를 결제, 환불, 검증 등으로 나누어 설계</td></tr><tr><td><strong>DIP</strong>(의존성 역전 원칙)</td><td>추상화 계층에 의존하도록 설계</td><td>Repository 인터페이스를 통해 DB 접근 방식 추상화</td></tr></tbody></table><ul><li>설계 패턴 활용<ol><li><strong>Repository 패턴</strong>: 데이터 접근 로직의 추상화</li><li><strong>Factory 패턴</strong>: 결제 방식별 객체 생성 관리</li><li><strong>Observer 패턴</strong>: 주문 상태 변경 시 관련 서비스 알림</li><li><strong>Strategy 패턴</strong>: 다양한 할인 정책 적용</li><li><strong>Command 패턴</strong>: 주문 처리 과정의 단계별 실행</li></ol></li></ul><p><strong>활용된 모델링 기법</strong>:</p><table><thead><tr><th>모델링 요소</th><th>목적</th><th>결과</th></tr></thead><tbody><tr><td><strong>도메인 모델링</strong></td><td>핵심 도메인 엔티티 (User, Product 등) 와 그 관계를 정의하여 비즈니스 개념을 모델링</td><td>비즈니스 로직 기반 구성, 유비쿼터스 언어 확립</td></tr><tr><td><strong>유스케이스 다이어그램</strong></td><td>고객, 관리자 등의 액터를 중심으로 시스템의 기능 요구사항을 시각화</td><td>시스템 요구사항 도출, 기능 우선순위 설정</td></tr><tr><td><strong>클래스 다이어그램</strong></td><td>각 마이크로서비스 내 클래스 구조 및 관계를 정의</td><td>코드 구현의 청사진 제공, 객체지향 설계 가이드 수립</td></tr><tr><td><strong>시퀀스 다이어그램</strong></td><td>시간 흐름에 따른 객체 및 서비스 간 상호작용을 표현하여 동적 프로세스를 모델링</td><td>서비스 간 통신 흐름 명세, 예외 및 오류 처리 전략 도출</td></tr><tr><td><strong>컴포넌트 다이어그램</strong></td><td>마이크로서비스 구성 요소 간의 의존성과 인터페이스 관계를 시각화</td><td>전체 시스템 구조 파악, 인터페이스 명세 및 배포 전략 수립</td></tr><tr><td><strong>배포 다이어그램</strong></td><td>Docker, Kubernetes 기반의 물리적/논리적 배포 구조를 시각화</td><td>인프라 설계 기준 수립, 운영 및 확장 전략 계획 수립</td></tr></tbody></table><p><strong>시스템 아키텍처 다이어그램</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span><span class=lnt id=hl-2-24><a class=lnlinks href=#hl-2-24>24</a>
</span><span class=lnt id=hl-2-25><a class=lnlinks href=#hl-2-25>25</a>
</span><span class=lnt id=hl-2-26><a class=lnlinks href=#hl-2-26>26</a>
</span><span class=lnt id=hl-2-27><a class=lnlinks href=#hl-2-27>27</a>
</span><span class=lnt id=hl-2-28><a class=lnlinks href=#hl-2-28>28</a>
</span><span class=lnt id=hl-2-29><a class=lnlinks href=#hl-2-29>29</a>
</span><span class=lnt id=hl-2-30><a class=lnlinks href=#hl-2-30>30</a>
</span><span class=lnt id=hl-2-31><a class=lnlinks href=#hl-2-31>31</a>
</span><span class=lnt id=hl-2-32><a class=lnlinks href=#hl-2-32>32</a>
</span><span class=lnt id=hl-2-33><a class=lnlinks href=#hl-2-33>33</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Frontend (React)]
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      | HTTP/HTTPS
</span></span><span class=line><span class=cl>      ↓
</span></span><span class=line><span class=cl>[API Gateway (Spring Cloud Gateway)]
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      |-- User Service (Spring Boot + JWT)
</span></span><span class=line><span class=cl>      |     └── UserDB (MySQL)
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      |-- Product Service (Spring Boot)
</span></span><span class=line><span class=cl>      |     └── ProductDB (MySQL)
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      |-- Order Service (Spring Boot)
</span></span><span class=line><span class=cl>      |     ├── OrderDB (MySQL)
</span></span><span class=line><span class=cl>      |     └── Message Queue (Kafka)
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      |-- Payment Service (Spring Boot)
</span></span><span class=line><span class=cl>      |     ├── PaymentDB (MySQL)
</span></span><span class=line><span class=cl>      |     └── External PG APIs
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      |-- Inventory Service (Spring Boot)
</span></span><span class=line><span class=cl>      |     ├── InventoryDB (MySQL)
</span></span><span class=line><span class=cl>      |     └── Cache (Redis)
</span></span><span class=line><span class=cl>      |
</span></span><span class=line><span class=cl>      └── Notification Service (Spring Boot)
</span></span><span class=line><span class=cl>            ├── NotificationDB (MySQL)
</span></span><span class=line><span class=cl>            └── External APIs (Email, SMS)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[Infrastructure Layer]
</span></span><span class=line><span class=cl>├── Docker Containers
</span></span><span class=line><span class=cl>├── Kubernetes Cluster
</span></span><span class=line><span class=cl>├── Load Balancer
</span></span><span class=line><span class=cl>└── Monitoring (Prometheus + Grafana)
</span></span></code></pre></td></tr></table></div></div><p><strong>주문 처리 플로우</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Customer -&gt; Frontend: 주문 요청
</span></span><span class=line><span class=cl>Frontend -&gt; API Gateway: POST /orders
</span></span><span class=line><span class=cl>API Gateway -&gt; Order Service: 주문 생성 요청
</span></span><span class=line><span class=cl>Order Service -&gt; Product Service: 상품 정보 조회
</span></span><span class=line><span class=cl>Product Service -&gt; Order Service: 상품 정보 응답
</span></span><span class=line><span class=cl>Order Service -&gt; Inventory Service: 재고 확인 요청
</span></span><span class=line><span class=cl>Inventory Service -&gt; Order Service: 재고 확인 응답
</span></span><span class=line><span class=cl>Order Service -&gt; Payment Service: 결제 처리 요청
</span></span><span class=line><span class=cl>Payment Service -&gt; External PG: 결제 승인 요청
</span></span><span class=line><span class=cl>External PG -&gt; Payment Service: 결제 승인 응답
</span></span><span class=line><span class=cl>Payment Service -&gt; Order Service: 결제 완료 알림
</span></span><span class=line><span class=cl>Order Service -&gt; Kafka: 주문 완료 이벤트 발행
</span></span><span class=line><span class=cl>Kafka -&gt; Inventory Service: 재고 차감 이벤트
</span></span><span class=line><span class=cl>Kafka -&gt; Notification Service: 알림 발송 이벤트
</span></span><span class=line><span class=cl>Order Service -&gt; API Gateway: 주문 완료 응답
</span></span><span class=line><span class=cl>API Gateway -&gt; Frontend: 주문 완료 응답
</span></span><span class=line><span class=cl>Frontend -&gt; Customer: 주문 완료 화면
</span></span></code></pre></td></tr></table></div></div><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>계획 단계</td><td>프로젝트 규모 평가</td><td>소규모 프로젝트에서는 과도한 모델링 지양</td><td>프로젝트 크기에 맞는 적절한 수준 적용</td></tr><tr><td></td><td>팀 역량 고려</td><td>팀원들의 SOLID 원칙과 UML 이해도 파악</td><td>사전 교육과 점진적 도입 계획 수립</td></tr><tr><td>설계 단계</td><td>원칙의 균형적 적용</td><td>모든 원칙을 무조건 적용하려 하지 말고 선택적</td><td>상황에 맞는 원칙 우선순위 설정</td></tr><tr><td></td><td>모델의 적절한 상세도</td><td>너무 상세하거나 너무 추상적인 모델 지양</td><td>목적에 맞는 적절한 추상화 수준 유지</td></tr><tr><td>구현 단계</td><td>모델과 코드의 일관성</td><td>구현 과정에서 모델과 코드 간 괴리 발생 주의</td><td>정기적인 모델 업데이트와 검토 프로세스</td></tr><tr><td></td><td>점진적 리팩토링</td><td>한번에 모든 원칙을 적용하려 하지 말고 단계적</td><td>작은 단위로 지속적인 개선 수행</td></tr><tr><td>유지보수</td><td>문서화 관리</td><td>모델과 설계 문서의 지속적 관리</td><td>자동화 도구 활용한 문서 동기화</td></tr><tr><td></td><td>팀 지식 공유</td><td>설계 결정사항과 원칙 적용 근거 공유</td><td>정기적인 아키텍처 리뷰 미팅 개최</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>설계 최적화</td><td>적절한 추상화 레벨</td><td>과도한 추상화로 인한 성능 오버헤드 방지</td><td>성능 크리티컬 부분은 직접 구현 고려</td></tr><tr><td></td><td>인터페이스 설계</td><td>너무 세분화된 인터페이스로 인한 호출 비용</td><td>응집도 높은 인터페이스 그룹핑</td></tr><tr><td>구현 최적화</td><td>객체 생성 비용</td><td>불필요한 객체 생성과 의존성 주입 최소화</td><td>싱글톤 패턴과 팩토리 패턴 적절히 활용</td></tr><tr><td></td><td>메모리 사용량 관리</td><td>복잡한 객체 구조로 인한 메모리 사용량 증가</td><td>경량 객체 설계와 리소스 풀링 활용</td></tr><tr><td>런타임 최적화</td><td>동적 바인딩 비용</td><td>다형성 사용으로 인한 런타임 오버헤드</td><td>성능 중요 부분은 정적 바인딩 고려</td></tr><tr><td></td><td>캐싱 전략</td><td>자주 사용되는 객체와 연산 결과 캐싱</td><td>적절한 캐시 레벨과 무효화 전략 수립</td></tr><tr><td>모니터링</td><td>성능 메트릭 수집</td><td>설계 원칙 적용 전후 성능 비교 측정</td><td>APM 도구 활용한 지속적 성능 모니터링</td></tr><tr><td></td><td>병목 지점 식별</td><td>추상화 계층에서 발생하는 성능 병목 파악</td><td>프로파일링 도구를 통한 정기적 분석</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>새로운 모델링 기법</td><td>Event Storming</td><td>도메인 이벤트 중심의 협업적 모델링 기법</td></tr><tr><td></td><td>C4 Model</td><td>소프트웨어 아키텍처 시각화를 위한 계층적 다이어그램</td></tr><tr><td>현대적 설계 원칙</td><td>Hexagonal Architecture</td><td>포트와 어댑터 패턴 기반 의존성 역전 아키텍처</td></tr><tr><td></td><td>Clean Architecture</td><td>의존성 규칙 기반 계층형 아키텍처 설계</td></tr><tr><td>자동화 도구</td><td>Model-to-Code Generation</td><td>UML 모델에서 자동 코드 생성 도구의 발전</td></tr><tr><td></td><td>Architecture Decision Records</td><td>아키텍처 결정사항의 체계적 문서화</td></tr><tr><td>클라우드 네이티브</td><td>Microservices Patterns</td><td>마이크로서비스 아키텍처의 설계 패턴과 원칙</td></tr><tr><td></td><td>Event-Driven Architecture</td><td>이벤트 기반 느슨한 결합 시스템 설계</td></tr><tr><td>품질 관리</td><td>Architecture Testing</td><td>아키텍처 준수 여부를 자동으로 검증하는 테스팅 기법</td></tr><tr><td></td><td>Technical Debt Management</td><td>설계 부채의 측정과 관리 방법론</td></tr></tbody></table><h3 id=하위-주제별-추가-학습-내용>하위 주제별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제별-추가-학습-내용>#</a></h3><table><thead><tr><th>설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>아키텍처 원칙의 유형/정의/적용</td><td>원칙</td><td>과학적, 설계, 비즈니스, IT 원칙</td></tr><tr><td>UML/ERD 등 모델링 언어</td><td>모델링 언어</td><td>클래스, 시퀀스, 상태, 배포 등 다이어그램</td></tr><tr><td>계층적/모듈화 모델링</td><td>모델링 기법</td><td>3 계층, 도메인 모델, 뷰 모델 등</td></tr><tr><td>시뮬레이션/분석 모델</td><td>분석/검증</td><td>성능 시뮬레이션, &lsquo;what-if&rsquo; 분석</td></tr></tbody></table><h3 id=관련-분야별-확장-학습>관련 분야별 확장 학습<a hidden class=anchor aria-hidden=true href=#관련-분야별-확장-학습>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td>소프트웨어 공학</td><td>Software Craftsmanship</td><td>소프트웨어 장인정신과 지속적 학습 문화</td></tr><tr><td></td><td>Technical Leadership</td><td>기술 리더십과 아키텍처 의사결정</td></tr><tr><td>DevOps</td><td>Infrastructure as Code</td><td>인프라 설계 원칙과 모델링</td></tr><tr><td></td><td>Observability</td><td>시스템 관찰 가능성과 모니터링 설계</td></tr><tr><td>데이터 엔지니어링</td><td>Data Modeling</td><td>데이터 아키텍처와 모델링 기법</td></tr><tr><td></td><td>Data Mesh</td><td>분산 데이터 아키텍처 설계 원칙</td></tr><tr><td>보안</td><td>Security by Design</td><td>보안 중심 설계 원칙과 모델링</td></tr><tr><td></td><td>Zero Trust Architecture</td><td>제로 트러스트 보안 아키텍처 모델</td></tr><tr><td>성능 엔지니어링</td><td>Performance Modeling</td><td>성능 모델링과 용량 계획</td></tr><tr><td></td><td>Scalability Patterns</td><td>확장성 설계 패턴과 원칙</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>아키텍처 원칙 (Architecture Principle)</td><td>시스템 설계·변화의 방향성과 제약을 제공하는 기본 지침</td></tr><tr><td>모델링 (Modeling)</td><td>복잡한 시스템을 시각적으로 구조화·표현하는 과정</td></tr><tr><td>개념 모델 (Conceptual Model)</td><td>시스템의 주요 개념과 관계를 정의한 모델</td></tr><tr><td>추상화 (Abstraction)</td><td>불필요한 세부를 숨기고 본질에 집중하는 모델링 원리</td></tr><tr><td>다중 관점 (Multi-view Modeling)</td><td>다양한 관점에서 시스템을 모델링하는 방법</td></tr><tr><td>시뮬레이션 (Simulation)</td><td>시스템 동작을 예측·검증·분석하는 모델 기반 기법</td></tr><tr><td>보니니의 역설 (Bonini&rsquo;s Paradox)</td><td>모델이 지나치게 복잡해져 현실만큼 이해하기 어려워지는 현상</td></tr><tr><td>결합도 (Coupling)</td><td>모듈 간의 상호 의존성 정도로, 낮은 결합도가 바람직함</td></tr><tr><td>응집도 (Cohesion)</td><td>모듈 내부 요소들의 관련성 정도로, 높은 응집도가 바람직함</td></tr><tr><td>추상화 (Abstraction)</td><td>복잡한 시스템에서 핵심적인 개념이나 기능을 간단히 표현하는 기법</td></tr><tr><td>다형성 (Polymorphism)</td><td>동일한 인터페이스를 통해 서로 다른 구현체를 사용할 수 있는 특성</td></tr><tr><td>캡슐화 (Encapsulation)</td><td>데이터와 메서드를 하나의 단위로 묶고 외부에서의 직접 접근을 제한하는 기법</td></tr><tr><td>상속 (Inheritance)</td><td>기존 클래스의 특성을 새로운 클래스가 물려받아 재사용하는 기법</td></tr><tr><td>인터페이스 (Interface)</td><td>클래스가 구현해야 하는 메서드들의 명세를 정의한 추상적 계약</td></tr><tr><td>의존성 주입 (Dependency Injection)</td><td>객체의 의존성을 외부에서 주입하여 결합도를 낮추는 기법</td></tr><tr><td>리팩토링 (Refactoring)</td><td>기능을 변경하지 않으면서 코드 구조와 품질을 개선하는 과정</td></tr><tr><td>스테레오타입 (Stereotype)</td><td>UML 에서 모델 요소의 특별한 의미나 용도를 나타내는 분류 방법</td></tr><tr><td>C4 모델</td><td>Context, Container, Component, Code 의 네 단계로 아키텍처를 시각화하는 모델</td></tr><tr><td>MDD</td><td>Model-Driven Development, 모델을 기반으로 코드를 자동 생성하거나 동기화하는 개발 방식</td></tr><tr><td>SRP</td><td>Single Responsibility Principle, 클래스는 단 하나의 책임만 가져야 한다는 원칙</td></tr><tr><td>ADL</td><td>Architecture Description Language, 시스템 구조를 공식적으로 서술하는 언어</td></tr><tr><td>SOMA/SOMF</td><td>서비스 지향 모델링을 위한 프레임워크, SOA 기반 시스템에 사용됨</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://learn.microsoft.com/en-us/azure/architecture/framework/>Microsoft Architecture Center - Architecture Principles</a></li><li><a href=https://c4model.com/>Simon Brown - C4 Model 공식 사이트</a></li><li><a href=https://www.thoughtworks.com/radar>ThoughtWorks Technology Radar</a></li><li><a href=https://martinfowler.com/books/uml.html>Martin Fowler - UML Distilled</a></li><li><a href=https://www.uml-diagrams.org/>UML 공식 문서</a></li><li><a href=https://www.geeksforgeeks.org/software-engineering-architectural-design/>GeeksforGeeks - Software Architecture Design</a></li><li><a href=https://www.geeksforgeeks.org/analysis-modelling-in-software-engineering/>GeeksforGeeks - Analysis Modeling in Software Engineering</a></li><li><a href=https://www.geeksforgeeks.org/solid-principle-in-programming-understand-with-real-life-examples/>GeeksforGeeks - SOLID Principles</a></li><li><a href=https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design>DigitalOcean - SOLID Design Principles</a></li><li><a href=https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-uml/>Visual Paradigm - What is UML</a></li><li><a href=https://www.tutorialspoint.com/software_architecture_design/architecture_models.htm>Tutorials Point - Architecture Models in Software Design</a></li><li><a href=https://www.baeldung.com/solid-principles>Baeldung - SOLID Principles Guide</a></li><li><a href=https://www.freecodecamp.org/news/solid-design-principles-in-software-development/>FreeCodeCamp - SOLID Design Principles</a></li><li><a href=https://en.wikipedia.org/wiki/Software_architecture>Wikipedia - Software Architecture</a></li><li><a href=https://en.wikipedia.org/wiki/Unified_Modeling_Language>Wikipedia - Unified Modeling Language</a></li><li><a href=https://www.frontiersin.org/journals/computer-science/articles/10.3389/fcomp.2022.1008296/full>CDSA의 3계층 모델링 원칙 및 사례</a></li><li><a href=https://sebokwiki.org/wiki/System_Modeling_Concepts>시스템 모델링 개념 및 추상화 원리</a></li><li><a href=https://sar.ac.id/stmik_ebook/prog_file_file/QSxDUeH6lq.pdf>아키텍처 원칙의 개념과 역할</a></li><li><a href=https://nriit.edu.in/files/IT-Notes/UMLDP/UML-UNIT-1.pdf>UML 및 모델링의 원리와 실무 적용</a></li><li><a href=https://www.bbc.co.uk/bitesize/guides/zyqfr82/revision/3>모델링과 시뮬레이션의 장단점</a></li><li><a href=http://bcp.psych.ualberta.ca/~mike/Pearl_Street/PSYCO452/pdfstuff/Chapter2.pdf>모델링의 과학적 장단점 및 보니니의 역설</a></li><li><a href=https://www.justinmind.com/blog/use-case-diagramming-examples/>유스케이스/시나리오 모델링 사례</a></li><li><a href=https://atlan.com/what-is-data-architecture/>데이터 아키텍처 구성 요소 및 원칙</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UML</h2></header><div class=entry-content><p>UML(Unified Modeling Language) UML(Unified Modeling Language)은 시스템, 소프트웨어, 비즈니스 프로세스를 시각적으로 모델링하기 위한 표준화된 범용 모델링 언어이다. 1990년대 중반에 Grady Booch, James Rumbaugh, Ivar Jacobson(종종 “삼총사"라고 불림)에 의해 개발되었으며, 현재는 OMG(Object Management Group)에서 관리하고 있다.
UML은 객체지향 프로그래밍의 개념이 확산되면서 소프트웨어 설계와 구조를 표현하는 공통 언어의 필요성에 의해 탄생했다. 프로그래밍 언어나 개발 방법론과 무관하게 사용할 수 있으며, 시스템의 다양한 측면을 표현할 수 있는 여러 다이어그램 유형을 제공한다.
UML은 현재 버전 2.5.1(2017년 12월 발표)까지 발전해왔으며, 소프트웨어 개발 과정에서 다음과 같은 역할을 한다:
...</p></div><footer class=entry-footer><span title='2024-12-16 12:56:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UML" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/modeling-and-documentation/diagram-standards/uml/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>