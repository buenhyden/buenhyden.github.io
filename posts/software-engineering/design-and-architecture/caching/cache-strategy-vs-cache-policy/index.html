<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Cache Strategy vs Cache Policy | hyunyoun's Blog</title><meta name=keywords content="System-Design,Caching,Cache-Strategy,Cache-Policy"><meta name=description content="캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/cache-strategy-vs-cache-policy/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/cache-strategy-vs-cache-policy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/cache-strategy-vs-cache-policy/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Cache Strategy vs Cache Policy"><meta property="og:description" content="캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T15:24:00+00:00"><meta property="article:modified_time" content="2024-09-30T15:24:00+00:00"><meta property="article:tag" content="System-Design"><meta property="article:tag" content="Caching"><meta property="article:tag" content="Cache-Strategy"><meta property="article:tag" content="Cache-Policy"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Cache Strategy vs Cache Policy"><meta name=twitter:description content="캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":"https://buenhyden.github.io/posts/software-engineering/"},{"@type":"ListItem","position":3,"name":"Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"캐싱 (Caching)","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/"},{"@type":"ListItem","position":5,"name":"Cache Strategy vs Cache Policy","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/cache-strategy-vs-cache-policy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Cache Strategy vs Cache Policy","name":"Cache Strategy vs Cache Policy","description":"캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.","keywords":["System-Design","Caching","Cache-Strategy","Cache-Policy"],"articleBody":"Cache Strategy vs. Cache Policy 캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.\n이 둘은 상호보완적이지만 명확한 차이가 있다.\n캐시 전략(Cache Strategy) 캐시 전략은 시스템 전체의 캐시 사용 방식을 결정하는 상위 레벨의 설계 접근법을 의미한다.\n주로 다음과 같은 요소를 포함한다:\n계층적 구조: L1, L2, L3 캐시로 이어지는 메모리 계층 구조 설계 분산 캐시: 여러 서버에 캐시를 분산하여 처리 능력 확장 데이터 프리페칭: 프로세서가 필요로 할 데이터를 미리 예측하여 캐시에 로드 클라이언트 측 캐싱: 사용자 브라우저에 데이터 저장으로 서버 부하 감소 예시: 멀티코어 프로세서에서 L3 캐시를 공유하여 코어 간 데이터 일관성 유지\n캐시 정책(Cache Policy) 캐시 정책은 캐시의 구체적 운영 규칙을 정의하는 세부 실행 방침이다.\n주요 유형:\n교체 정책(Replacement Policy)\nLRU(Least Recently Used): 가장 오래전에 사용된 데이터 제거 FIFO(First-In First-Out): 먼저 들어온 데이터부터 제거 LFU(Least Frequently Used): 사용 빈도가 가장 낮은 데이터 제거 쓰기 정책(Write Policy)\nWrite-through: 캐시와 주기억장치에 동시 기록(데이터 무손실 보장) Write-back: 캐시에만 먼저 기록, 이후 주기억장치에 배치 방식 배치 정책(Placement Policy)\n직접 매핑(Direct-mapped): 메모리 블록이 특정 캐시 라인에만 배치 완전 연관(Fully associative): 어떤 캐시 라인이든 자유 배치 세트 연관(Set-associative): 특정 세트 내에서 자유 배치 비교 분석표 구분 캐시 전략 (Cache Strategy) 캐시 정책 (Cache Policy) 목적 시스템 전체의 캐시 활용 최적화 캐시 운영의 구체적 규칙 정의 적용 수준 아키텍처 설계 차원 캐시 메모리 운영 차원 주요 기법 계층화, 분산 캐시, 프리페칭 LRU, Write-through, 직접 매핑 변경 주기 장기적/구조적 변경 필요 소프트웨어 설정으로 비교적 신속 변경 가능 성능 영향 요소 캐시 용량, 물리적 배치, 네트워크 토폴로지 히트율, 지연 시간, 데이터 일관성 예시 L3 공유 캐시 사용, 분산 캐시 클러스터 LRU 교체, Write-back 쓰기 상호작용 관계 캐시 전략은 정책의 실행 환경을 결정한다.\n예를 들어 분산 캐시 전략을 채택하면, 각 노드에서 LRU 정책과 Write-back 정책을 조합해 사용할 수 있다.\n반면 직접 매핑 배치 정책을 사용하는 시스템에서는 단순한 FIFO 교체 정책이 더 효율적일 수 있다.\n참고 및 출처 ","wordCount":"303","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T15:24:00Z","dateModified":"2024-09-30T15:24:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/cache-strategy-vs-cache-policy/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/>Software Engineering</a>&nbsp;»&nbsp;<a href>Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/>캐싱 (Caching)</a></div><h1 class="post-title entry-hint-parent">Cache Strategy vs Cache Policy</h1><div class=post-description>캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.</div><div class=post-meta><span title='2024-09-30 15:24:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Design%20and%20Architecture/Caching/Cache-Strategy-vs-Cache-Policy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#cache-strategy-vs-cache-policy>Cache Strategy vs. Cache Policy</a><ul><li><a href=#캐시-전략cache-strategy>캐시 전략(Cache Strategy)</a></li><li><a href=#캐시-정책cache-policy>캐시 정책(Cache Policy)</a></li><li><a href=#비교-분석표>비교 분석표</a></li><li><a href=#상호작용-관계>상호작용 관계</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=cache-strategy-vs-cache-policy>Cache Strategy vs. Cache Policy<a hidden class=anchor aria-hidden=true href=#cache-strategy-vs-cache-policy>#</a></h2><p>캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.<br>이 둘은 상호보완적이지만 명확한 차이가 있다.</p><h3 id=캐시-전략cache-strategy>캐시 전략(Cache Strategy)<a hidden class=anchor aria-hidden=true href=#캐시-전략cache-strategy>#</a></h3><p><strong>캐시 전략</strong>은 시스템 전체의 캐시 사용 방식을 결정하는 상위 레벨의 설계 접근법을 의미한다.</p><p>주로 다음과 같은 요소를 포함한다:</p><ul><li><strong>계층적 구조</strong>: L1, L2, L3 캐시로 이어지는 메모리 계층 구조 설계</li><li><strong>분산 캐시</strong>: 여러 서버에 캐시를 분산하여 처리 능력 확장</li><li><strong>데이터 프리페칭</strong>: 프로세서가 필요로 할 데이터를 미리 예측하여 캐시에 로드</li><li><strong>클라이언트 측 캐싱</strong>: 사용자 브라우저에 데이터 저장으로 서버 부하 감소</li></ul><p>예시: 멀티코어 프로세서에서 L3 캐시를 공유하여 코어 간 데이터 일관성 유지</p><h3 id=캐시-정책cache-policy>캐시 정책(Cache Policy)<a hidden class=anchor aria-hidden=true href=#캐시-정책cache-policy>#</a></h3><p><strong>캐시 정책</strong>은 캐시의 구체적 운영 규칙을 정의하는 세부 실행 방침이다.</p><p>주요 유형:</p><ol><li><p>교체 정책(Replacement Policy)</p><ul><li><strong>LRU(Least Recently Used)</strong>: 가장 오래전에 사용된 데이터 제거</li><li><strong>FIFO(First-In First-Out)</strong>: 먼저 들어온 데이터부터 제거</li><li><strong>LFU(Least Frequently Used)</strong>: 사용 빈도가 가장 낮은 데이터 제거</li></ul></li><li><p>쓰기 정책(Write Policy)</p><ul><li><strong>Write-through</strong>: 캐시와 주기억장치에 동시 기록(데이터 무손실 보장)</li><li><strong>Write-back</strong>: 캐시에만 먼저 기록, 이후 주기억장치에 배치 방식</li></ul></li><li><p>배치 정책(Placement Policy)</p><ul><li>직접 매핑(Direct-mapped): 메모리 블록이 특정 캐시 라인에만 배치</li><li>완전 연관(Fully associative): 어떤 캐시 라인이든 자유 배치</li><li>세트 연관(Set-associative): 특정 세트 내에서 자유 배치</li></ul></li></ol><h3 id=비교-분석표>비교 분석표<a hidden class=anchor aria-hidden=true href=#비교-분석표>#</a></h3><table><thead><tr><th>구분</th><th>캐시 전략 (Cache Strategy)</th><th>캐시 정책 (Cache Policy)</th></tr></thead><tbody><tr><td><strong>목적</strong></td><td>시스템 전체의 캐시 활용 최적화</td><td>캐시 운영의 구체적 규칙 정의</td></tr><tr><td><strong>적용 수준</strong></td><td>아키텍처 설계 차원</td><td>캐시 메모리 운영 차원</td></tr><tr><td><strong>주요 기법</strong></td><td>계층화, 분산 캐시, 프리페칭</td><td>LRU, Write-through, 직접 매핑</td></tr><tr><td><strong>변경 주기</strong></td><td>장기적/구조적 변경 필요</td><td>소프트웨어 설정으로 비교적 신속 변경 가능</td></tr><tr><td><strong>성능 영향 요소</strong></td><td>캐시 용량, 물리적 배치, 네트워크 토폴로지</td><td>히트율, 지연 시간, 데이터 일관성</td></tr><tr><td><strong>예시</strong></td><td>L3 공유 캐시 사용, 분산 캐시 클러스터</td><td>LRU 교체, Write-back 쓰기</td></tr></tbody></table><h3 id=상호작용-관계>상호작용 관계<a hidden class=anchor aria-hidden=true href=#상호작용-관계>#</a></h3><p>캐시 전략은 정책의 실행 환경을 결정한다.<br>예를 들어 <strong>분산 캐시 전략</strong>을 채택하면, 각 노드에서 <strong>LRU 정책</strong>과 <strong>Write-back 정책</strong>을 조합해 사용할 수 있다.<br>반면 직접 매핑 배치 정책을 사용하는 시스템에서는 단순한 FIFO 교체 정책이 더 효율적일 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-design/>System-Design</a></li><li><a href=https://buenhyden.github.io/tags/caching/>Caching</a></li><li><a href=https://buenhyden.github.io/tags/cache-strategy/>Cache-Strategy</a></li><li><a href=https://buenhyden.github.io/tags/cache-policy/>Cache-Policy</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/web-infrastructure/web-application-servers/web-application-server-vs-web-server/><span class=title>« Prev</span><br><span>Web Application Server (WAS) vs. Web Server</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/quality-assurance-vs-quality-control-vs-testing/><span class=title>Next »</span><br><span>QA vs QC vs Testing</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>