<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Model–view–presenter Pattern | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Architecture,Architectue-Styles,Structural,Layered,MVP"><meta name=description content="Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/structural/layered/mvc/model-view-presenter-pattern/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/structural/layered/mvc/model-view-presenter-pattern/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js integrity="sha256-pDvBr9RG+cTMZqxd1F0C6NZeJvxTROwO94f4jW3bb54=" crossorigin=anonymous></script><script>mermaid.initialize({startOnLoad:!0})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/structural/layered/mvc/model-view-presenter-pattern/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Model–view–presenter Pattern"><meta property="og:description" content="Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-27T09:10:00+00:00"><meta property="article:modified_time" content="2024-09-27T09:10:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Architectue-Styles"><meta property="article:tag" content="Structural"><meta property="article:tag" content="Layered"><meta property="article:tag" content="MVP"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Model–view–presenter Pattern"><meta name=twitter:description content="Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Model–view–presenter Pattern","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/structural/layered/mvc/model-view-presenter-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Model–view–presenter Pattern","name":"Model–view–presenter Pattern","description":"Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.","keywords":["System-and-Software-Architecture","Architecture","Architectue-Styles","Structural","Layered","MVP"],"articleBody":"Model–view–presenter Pattern 1. 주제의 분류 적절성 분석 Model–View–Presenter(MVP) 패턴은 “Computer Science and Engineering \u003e System and Software Architecture \u003e Architecture \u003e Architecture Styles \u003e Structural \u003e Layered \u003e MVC (Model-View-Controller)” 분류에 매우 적합합니다.\nMVP 는 MVC(Model-View-Controller) 아키텍처 패턴에서 파생된 구조적 (Structural) 계층형 (Layered) UI 아키텍처 패턴으로, 사용자 인터페이스 개발에서 관심사의 분리와 테스트 용이성을 극대화하기 위해 고안되었습니다 [1][3][4][14].\nMVC 와 마찬가지로 View, Model, 그리고 중재자 역할의 Presenter 로 계층을 명확히 분리하므로, Layered 및 MVC 하위 분류에 위치하는 것이 타당합니다.\n2. 200 자 요약 Model–View–Presenter(MVP) 패턴은 사용자 인터페이스를 Model(데이터/비즈니스), View(UI), Presenter(중재자) 로 분리하는 구조적 계층형 아키텍처 패턴입니다.\nPresenter 가 View 와 Model 사이의 모든 상호작용을 중재하여, 코드의 테스트 용이성과 유지보수성을 극대화합니다 [1][4][6][9][14].\n3. 250 자 개요 Model–View–Presenter(MVP) 패턴은 MVC 에서 파생된 UI 아키텍처 패턴으로, 애플리케이션을 Model(비즈니스/데이터), View(사용자 인터페이스), Presenter(중재자) 세 계층으로 분리합니다.\nPresenter 는 View 와 Model 간의 모든 상호작용을 담당하며, View 는 최대한 수동적으로 동작합니다.\n이 구조는 관심사의 분리, 테스트 용이성, 유지보수성, 코드 재사용성을 높이며, 특히 웹·모바일·데스크톱 등 다양한 UI 환경에서 널리 사용됩니다 [1][4][6][9][14][15].\n4. 핵심 개념 MVP 란?\nModel–View–Presenter(MVP) 는 MVC 에서 파생된 아키텍처 패턴으로, UI 를 Model, View, Presenter 세 계층으로 분리하여 각 계층의 책임을 명확히 합니다 [1][4][9][14]. Model(모델): 데이터와 비즈니스 로직을 담당, View 와 직접 연결되지 않음 [4][9][11][15]. View(뷰): 사용자에게 데이터 표시 및 입력 수집, Presenter 와만 통신하며 최대한 수동적으로 동작 [1][4][6][9][14]. Presenter(프리젠터): View 와 Model 사이의 중재자 역할, 모든 프레젠테이션 로직을 담당하며 View 와 1:1 관계를 맺는 것이 일반적 [1][4][9][11][14]. 관심사의 분리: 각 계층이 자신의 역할에만 집중하여 코드의 유지보수성과 테스트 용이성을 극대화 [3][6][7][14]. 5. 상세 조사 내용 배경 및 목적 1990 년대 Taligent 에서 MVC 의 한계를 극복하고 UI 테스트 용이성, 관심사 분리, 유지보수성 향상을 위해 고안됨 [1]. View 와 Model 의 직접 의존성을 제거하여, 프레젠테이션 로직을 Presenter 에 집중시킴 [4][14]. 주요 기능 및 역할 계층 역할/기능 Model 데이터 관리, 비즈니스 로직, 외부 데이터 소스 연동 View UI 표시, 사용자 입력 수집, Presenter 에 이벤트 전달 Presenter View 와 Model 중재, 프레젠테이션 로직, 상태 관리 특징 View 와 Model 의 직접 의존성 없음, Presenter 가 중재자 역할 [1][4][11][14]. View 는 최대한 수동적 (Passive View) 으로 동작 [1][4][14]. Presenter 와 View 는 1:1 매핑이 일반적, 복잡한 경우 다수 Presenter 사용 가능 [1][11][14]. 테스트 용이성, 유지보수성, 코드 재사용성, 확장성 우수 [3][6][7][14]. 핵심 원칙 관심사 분리 (Separation of Concerns) 느슨한 결합 (Loose Coupling) 인터페이스 기반 통신 (Interface-Driven Communication) 테스트 용이성 (Testability) 주요 원리 및 작동 원리 사용자의 입력은 View 에서 Presenter 로 전달됨 [1][4][14]. Presenter 는 Model 에서 데이터를 받아 비즈니스 로직을 처리하고, 결과를 View 에 전달해 UI 를 갱신함 [1][4][14]. View 는 Presenter 를 통해서만 Model 과 간접적으로 상호작용함 [1][4][14]. 다이어그램 (Mermaid) sequenceDiagram participant User participant View participant Presenter participant Model User-\u003e\u003eView: 입력(클릭, 입력 등) View-\u003e\u003ePresenter: 이벤트 전달 Presenter-\u003e\u003eModel: 데이터 요청/수정 Model--\u003e\u003ePresenter: 데이터 반환 Presenter-\u003e\u003eView: UI 갱신 View--\u003e\u003eUser: 결과 표시 구조 및 아키텍처 필수 구성요소 및 역할 구성요소 기능/역할 특징 Model 데이터, 비즈니스 로직, 외부 연동 View 와 직접 연결 없음 View UI 표시, 입력 수집, Presenter 호출 최대한 수동적 Presenter View-Model 중재, 프레젠테이션 로직 View 와 1:1 매핑 일반 선택 구성요소 구성요소 기능/역할 특징 ViewModel View 와 Presenter 사이 데이터 변환 MVVM 등 확장 패턴에서 사용 Router 화면 전환, 라우팅 관리 웹/모바일에서 활용 구조 다이어그램 (Mermaid) graph TD User[사용자] --\u003e View[View] View --\u003e Presenter[Presenter] Presenter --\u003e Model[Model] Model --\u003e Presenter Presenter --\u003e View 구현 기법 Model 구현: 데이터베이스, API, 비즈니스 로직 클래스 등 View 구현: UI 프레임워크, 화면 컴포넌트, 입력 이벤트 처리 Presenter 구현: View/Model 인터페이스 구현, 프레젠테이션 로직, 상태 관리 통신: 인터페이스 (Contract) 기반으로 View-Presenter, Presenter-Model 연결 [4][14][15]. 실제 예시: Android, WinForms, WPF 등에서 널리 활용 [15]. Java, C#, Kotlin 등 다양한 언어에서 구현 가능 [9][15]. 장점과 단점 구분 항목 설명 ✅ 장점 관심사 분리 각 계층의 책임 명확, 유지보수성 우수 테스트 용이성 Presenter 단위 테스트 용이 확장성 UI/로직/데이터 독립적 변경 가능 코드 재사용성 Presenter/Model 재사용 가능 유연성 다양한 UI/플랫폼 적용 가능 ⚠ 단점 복잡성 증가 단순 UI 에선 구조가 불필요하게 복잡 코드량 증가 인터페이스, 클래스 수 증가 View-Presenter 의존성 1:1 매핑 시 결합도 높아질 수 있음 학습 곡선 구조 이해에 시간 소요 단점 해결 방법 소규모 프로젝트엔 단순화 적용 코드/인터페이스 재사용, 공통 Presenter 모듈화 문서화 및 코드 리뷰 강화 도전 과제 및 해결책 Presenter-View 결합도: 인터페이스 기반 설계, DI(Dependency Injection) 활용 테스트 복잡성: Mock, Stub, 자동화 테스트 도구 활용 구조 복잡성: 공통 Presenter/Model 모듈화, 코드/설계 문서화 분류 기준에 따른 종류 및 유형 분류 기준 유형 설명 View 역할 Passive View View 가 최대한 수동적으로 동작 Supervising Presenter View 가 일부 UI 로직 담당, Presenter 가 핵심 로직 담당 확장 패턴 MVVM ViewModel 추가, 데이터 바인딩 강화 MVPVM Presenter 와 ViewModel 결합 패턴 실무 적용 예시 분야 적용 사례 설명 모바일 Android MVP 액티비티 - 프래그먼트 - 프리젠터 구조 데스크톱 WinForms MVP UI- 프리젠터 - 모델 분리 웹 GWT MVP Google Web Toolkit 에서 활용 임베디드 TouchGFX MVP 임베디드 UI 프레임워크 적용 활용 사례 (시나리오 기반) 상황: 모바일 쇼핑앱 상품 상세 화면 시스템 구성: Model: 상품 데이터, 네트워크 API View: 상품 상세 UI(Activity/Fragment) Presenter: 상품 데이터 요청, UI 상태 관리 구조 다이어그램 (Mermaid) graph TD User[사용자] --\u003e View[상품 상세 화면] View --\u003e Presenter[상품 Presenter] Presenter --\u003e Model[상품 데이터/네트워크] Model --\u003e Presenter Presenter --\u003e View Workflow: 사용자가 상품 상세 진입 View 가 Presenter 에 데이터 요청 Presenter 가 Model 에서 데이터 조회 Presenter 가 View 에 결과 전달 View 가 UI 갱신 역할: Android 개발자: View/Presenter 구현 백엔드 개발자: Model(API, DB) 구현 QA: 테스트 자동화 실무 적용 고려사항 및 권장사항 항목 설명 권장사항 계층 분리 각 계층 책임 명확화 설계 문서화, 코드 리뷰 인터페이스 View-Presenter, Presenter-Model 계약 Contract, DI 적용 테스트 Presenter 단위 테스트 Mock, Stub 활용 코드 재사용 공통 Presenter/Model 모듈화 코드 중복 최소화 확장성 UI/로직/데이터 독립적 확장 모듈화 설계 최적화 고려사항 및 권장사항 항목 설명 권장사항 성능 불필요한 View-Presenter 통신 최소화 이벤트 버스, 캐싱 활용 유지보수성 코드 구조화, 문서화 설계/코드 문서 자동화 테스트 자동화 테스트 적용 CI/CD 파이프라인 구축 확장성 계층별 독립적 확장 공통 모듈화, DI 활용 보안 입력 검증, 데이터 보호 보안 프레임워크 도입 기타 사항 (문제, 원인, 영향, 진단, 예방, 해결) 문제: Presenter-View 결합도, 코드량 증가, 구조 복잡성 원인: 1:1 매핑, 불필요한 계층화, 설계 미흡 영향: 유지보수 비용 증가, 버그 발생 진단: 코드 리뷰, 정적 분석, 테스트 자동화 예방: 설계 표준화, 공통 모듈화, 코드 리뷰 강화 해결: Presenter/Model 모듈화, DI 적용, 리팩토링 8. 주제와 관련한 주목할 내용 주제 항목 설명 계층 구조 관심사 분리 각 계층의 책임 명확화 테스트 Presenter 단위 테스트 Mock, Stub 활용 확장성 UI/로직/데이터 독립적 확장 모듈화 설계 코드 재사용 공통 Presenter/Model 코드 중복 최소화 결합도 인터페이스 기반 통신 DI, Contract 활용 9. 하위 학습 주제 간략 설명 카테고리 주제 View-Presenter 계약 설계 인터페이스, Contract DI 적용 구현 Dependency Injection 테스트 자동화 품질 Mock, Stub, CI/CD 확장 패턴 설계 MVVM, MVPVM 등 코드 모듈화 구현 공통 Presenter/Model 10. 추가 학습/알아야 할 내용 간략 설명 관련 분야 주제 MVP vs MVC 아키텍처 구조/역할 차이 분석 MVP vs MVVM 아키텍처 데이터 바인딩, ViewModel RxMVP 구현 Reactive MVP, RxJava 모바일 MVP 모바일 Android, iOS 적용 클린 아키텍처와의 비교 설계 계층 구조 차이 분석 용어 정리 카테고리 용어 설명 아키텍처 MVP Model-View-Presenter, 3 계층 구조 아키텍처 패턴 아키텍처 Passive View View 가 최대한 수동적으로 동작하는 방식 아키텍처 Supervising Presenter View 가 일부 UI 로직 담당, Presenter 가 핵심 로직 담당 구현 Contract View-Presenter, Presenter-Model 간 인터페이스 계약 구현 DI Dependency Injection, 의존성 주입 품질 단위 테스트 Presenter 단위의 기능 검증 테스트 품질 통합 테스트 계층 간 상호작용 검증 테스트 참고 및 출처 Model–view–presenter - Wikipedia Difference Between MVC and MVP Patterns | Baeldung MVP 패턴에 대해 자세히 알아보십시오. - EchoTech What is Model-View-Presenter (MVP) - Startup House Model-View-Presenter Pattern in Java: Enhancing UI Logic Separation for Cleaner Code MVP (Model View Presenter) Architecture Pattern in Android with Example | GeeksforGeeks Architectural Pattern - Model–view–presenter (MVP) - DEV Community Model–View–Presenter (MVP) 패턴은 사용자 인터페이스 (UI) 설계에서 핵심적인 아키텍처 스타일 중 하나로, 특히 복잡한 UI 로직을 분리하고 테스트 가능성을 높이는 데 효과적입니다. 이 패턴은 MVC(Model–View–Controller) 에서 발전된 형태로, 프레젠터 (Presenter) 가 중심 역할을 하여 모델 (Model) 과 뷰 (View) 를 연결합니다.\n1. 주제 분류의 적절성 분석 MVP 패턴은 “Computer Science and Engineering \u003e System and Software Architecture \u003e Architecture \u003e Architecture Styles \u003e Structural \u003e Layered \u003e MVC (Model-View-Controller)” 분류에 적합합니다. 이는 MVP 가 MVC 에서 파생된 구조적 아키텍처 스타일로, 계층화된 구조를 통해 UI, 비즈니스 로직, 데이터 관리를 명확히 분리하기 때문입니다.\n2. 요약 설명 (200 자 내외) Model–View–Presenter(MVP) 패턴은 UI, 비즈니스 로직, 데이터 관리를 명확히 분리하여 테스트 용이성과 유지보수성을 향상시키는 아키텍처 스타일입니다. 프레젠터는 뷰와 모델 간의 중재자로서 사용자 입력을 처리하고, 모델의 데이터를 뷰에 전달합니다.\n3. 전체 개요 (250 자 내외) MVP 패턴은 UI 설계에서 핵심적인 아키텍처 스타일로, 프레젠터가 중심이 되어 모델과 뷰를 연결합니다. 이러한 구조는 각 구성 요소의 책임을 명확히 하여 코드의 재사용성과 테스트 용이성을 높이며, 특히 복잡한 UI 로직을 효과적으로 관리할 수 있도록 지원합니다.\n4. 핵심 개념 Model: 애플리케이션의 데이터와 비즈니스 로직을 관리합니다.\nView: 사용자에게 정보를 표시하고, 사용자 입력을 프레젠터에게 전달합니다.\nPresenter: 사용자 입력을 처리하고, 모델과 상호작용하여 데이터를 가져와 뷰를 업데이트합니다.\n5. 주요 원리 및 작동 원리 MVP 패턴에서의 상호작용은 다음과 같습니다:\nsequenceDiagram participant User participant View participant Presenter participant Model User-\u003e\u003eView: 사용자 입력 View-\u003e\u003ePresenter: 입력 전달 Presenter-\u003e\u003eModel: 데이터 요청 Model--\u003e\u003ePresenter: 데이터 반환 Presenter-\u003e\u003eView: 뷰 업데이트 6. 구조 및 아키텍처 MVP 패턴의 구조는 다음과 같습니다:\nclassDiagram class View { +displayData(data) +getUserInput() } class Presenter { +onUserAction() +updateView() } class Model { +fetchData() +processData() } View --\u003e Presenter Presenter --\u003e Model Model --\u003e Presenter Presenter --\u003e View 7. 구현 기법 Python 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # model.py class Model: def get_data(self): return \"Hello from Model\" # view.py class View: def display(self, data): print(f\"View: {data}\") # presenter.py class Presenter: def __init__(self, view, model): self.view = view self.model = model def run(self): data = self.model.get_data() self.view.display(data) # main.py if __name__ == \"__main__\": model = Model() view = View() presenter = Presenter(view, model) presenter.run() JavaScript 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // model.js class Model { getData() { return \"Hello from Model\"; } } // view.js class View { display(data) { console.log(`View: ${data}`); } } // presenter.js class Presenter { constructor(view, model) { this.view = view; this.model = model; } run() { const data = this.model.getData(); this.view.display(data); } } // main.js const model = new Model(); const view = new View(); const presenter = new Presenter(view, model); presenter.run(); 8. 장점과 단점 구분 항목 설명 ✅ 장점 테스트 용이성 프레젠터와 모델을 분리하여 단위 테스트가 용이합니다. 유지보수성 각 구성 요소의 책임이 명확하여 코드 유지보수가 쉽습니다. ⚠ 단점 복잡성 증가 구성 요소 분리로 인해 초기 설계가 복잡할 수 있습니다. 코드량 증가 각 구성 요소의 인터페이스 정의로 인해 코드량이 증가할 수 있습니다. 9. 도전 과제 및 해결책 도전 과제: 프레젠터의 역할이 과도하게 증가하여 복잡성이 높아질 수 있습니다.\n해결책: 프레젠터를 기능별로 분리하거나, 헬퍼 클래스를 도입하여 책임을 분산시킵니다.\n10. 분류 기준에 따른 종류 및 유형 분류 기준 유형 설명 프레젠터와 뷰의 관계 Passive View 뷰는 단순히 프레젠터의 지시에 따라 동작합니다. Supervising Controller 뷰가 일부 프레젠터의 역할을 수행합니다. 11. 실무 적용 예시 분야 적용 사례 설명 데스크톱 애플리케이션 PyQt 기반 GUI MVP 패턴을 적용하여 UI 와 로직을 분리합니다. 웹 애플리케이션 JavaScript SPA 프레젠터를 통해 모델과 뷰를 연결하여 유지보수성을 높입니다. 12. 활용 사례 상황: 사용자가 데이터를 입력하고 결과를 확인하는 간단한 애플리케이션.\n시스템 구성:\ngraph LR View --\u003e Presenter Presenter --\u003e Model Model --\u003e Presenter Presenter --\u003e View Workflow:(stackoverflow.com)\n사용자가 뷰에 데이터를 입력합니다.\n뷰는 입력을 프레젠터에 전달합니다.\n프레젠터는 모델에 데이터를 전달하여 처리합니다.\n모델은 처리 결과를 프레젠터에 반환합니다.\n프레젠터는 결과를 뷰에 전달하여 표시합니다.(java-design-patterns.com)\n역할:\nView: 사용자 입력 수집 및 결과 표시.\nPresenter: 입력 처리 및 모델과의 중재.\nModel: 데이터 처리 및 비즈니스 로직 수행.\n13. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점 고려사항 설명 권장사항 구성 요소 분리 각 구성 요소의 책임을 명확히 분리합니다. 인터페이스를 통해 의존성을 최소화합니다. 테스트 전략 프레젠터와 모델에 대한 단위 테스트를 설계합니다. 모킹 (Mock) 을 활용하여 테스트를 수행합니다. 14. 최적화하기 위한 고려사항 및 주의할 점 고려사항 설명 권장사항 프레젠터의 복잡성 관리 프레젠터의 책임이 과도하게 증가하지 않도록 관리합니다. 기능별로 프레젠터를 분리하거나 헬퍼 클래스를 도입합니다. 코드 중복 최소화 유사한 기능을 모듈화하여 재사용성을 높입니다. 공통 로직을 별도의 유틸리티 클래스로 분리합니다. 15. 기타 사항 문제: 프레젠터와 뷰 간의 순환 참조로 인해 메모리 누수가 발생할 수 있습니다.\n원인: 프레젠터와 뷰가 서로를 강하게 참조할 경우, 가비지 컬렉션이 제대로 이루어지지 않을 수 있습니다.\n해결 방법: 약한 참조 (Weak Reference) 를 사용하거나, 뷰가 프레젠터를 명시적으로 해제하도록 설계합니다.\n용어 정리 카테고리 용어 설명 아키텍처 패턴 MVP Model–View–Presenter 패턴으로, UI, 비즈니스 로직, 데이터를 분리하여 설계하는 아키텍처 스타일입니다. 물론입니다. 아래는 “Model–View–Presenter Pattern” 과 관련된 용어 정리를 이어서 작성한 내용입니다.\n용어 정리 카테고리 용어 설명 아키텍처 구성 Model 애플리케이션의 상태와 비즈니스 로직을 포함하며, 데이터를 저장하고 처리하는 계층입니다. 아키텍처 구성 View 사용자에게 UI 를 제공하고, 사용자 입력을 Presenter 에게 전달하는 구성요소입니다. 아키텍처 구성 Presenter 사용자 입력을 처리하고 Model 을 제어하며, 결과를 View 에 전달하는 중개자 역할을 합니다. 아키텍처 유형 Passive View View 가 전적으로 Presenter 에 의해 제어되는 MVP 패턴의 한 방식입니다. 아키텍처 유형 Supervising Controller View 가 간단한 모델 바인딩을 처리하며, 나머지는 Presenter 가 제어하는 구조입니다. 설계 원칙 Separation of Concerns 각 구성요소의 역할과 책임을 명확히 분리하여 코드 유지보수성과 확장성을 높이는 원칙입니다. 테스트 전략 Mocking 테스트 대상 외의 객체를 흉내내어 단위 테스트를 용이하게 하는 기법입니다. 프로그래밍 개념 Dependency Injection 외부 객체를 주입받아 내부 의존성을 줄이고 테스트 용이성을 높이는 설계 기법입니다. 참고 및 출처 Martin Fowler의 GUI Architectures\nMicrosoft Docs: MVP Design Pattern\nAndroid Developer Guide - MVP Pattern\nRefactoring.Guru - MVP Pattern 설명\n좋습니다. 이어서 MVC vs MVP vs MVVM 비교 정리와 함께 MVP 의 전반적인 분석 내용을 마저 정리합니다.\n✅ MVC Vs MVP Vs MVVM 비교 구분 MVC (Model-View-Controller) MVP (Model-View-Presenter) MVVM (Model-View-ViewModel) 구성요소 Model, View, Controller Model, View, Presenter Model, View, ViewModel 흐름 제어 Controller 가 흐름 제어 Presenter 가 모든 흐름 제어 ViewModel 이 데이터 바인딩 중심 View 역할 Controller 에 사용자 입력 전달 Presenter 에 전달만 수행 ViewModel 과 양방향 바인딩 테스트 용이성 중간 정도 가장 용이함 바인딩 구현에 따라 다름 플랫폼 활용 웹, 서버 앱 웹, WinForms, Android 등 WPF, Angular, React 등 데이터 바인딩 없음 없음 있음 (양방향 또는 단방향) 의존성 방향 View → Controller ← Model View ←→ Presenter ←→ Model View ←→ ViewModel ←→ Model ✅ 구조 및 아키텍처 (다이어그램) flowchart LR View --\u003e Presenter Presenter --\u003e Model Model --\u003e Presenter Presenter --\u003e View View: 사용자 인터페이스 요소\nPresenter: 사용자 입력을 받아 처리하고 Model 을 조작하며 View 를 업데이트\nModel: 비즈니스 로직과 데이터 보유\n✅ 주요 원리와 작동 원리 단방향 흐름: View 는 Presenter 에만 의존하며 Model 은 Presenter 에만 노출됨\n의존성 역전: Presenter 는 인터페이스를 통해 View 및 Model 에 의존 (테스트 및 확장성 강화)\n✅ MVP 의 구성 요소별 기능 구성 요소 기능 책임 Model 비즈니스 로직, 데이터 처리 DB 접근, 상태 유지 View UI 표현, 사용자 입력 전달 인터페이스 표시 Presenter 이벤트 처리, 로직 실행 모델 제어 및 뷰 갱신 ✅ 구현 기법 JavaScript MVP 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // View class LoginView { constructor(presenter) { this.presenter = presenter; document.getElementById('loginBtn').addEventListener('click', () =\u003e { const user = document.getElementById('user').value; this.presenter.handleLogin(user); }); } showSuccess() { alert('Login success!'); } } // Presenter class LoginPresenter { constructor(view, model) { this.view = view; this.model = model; } handleLogin(user) { if (this.model.validateUser(user)) { this.view.showSuccess(); } } } // Model class LoginModel { validateUser(user) { return user === 'admin'; } } const model = new LoginModel(); const presenter = new LoginPresenter(null, model); const view = new LoginView(presenter); presenter.view = view; ✅ 장점과 단점 구분 항목 설명 ✅ 장점 테스트 용이성 Presenter 는 독립 테스트 가능 유지보수성 View 와 로직 분리로 코드 가독성 높음 명확한 책임 분리 각 계층이 독립적으로 작동 가능 ⚠ 단점 Boilerplate 코드 View 와 Presenter 사이 반복 코드 발생 복잡도 증가 작은 앱에도 오버엔지니어링 우려 있음 👉 해결 방안:\nView 와 Presenter 간 자동 연결 코드 생성\n코드 제너레이터나 프레임워크 (예: Android MVP 템플릿) 활용\n✅ 실무 적용 예시 분야 기술 스택 적용 예 Android App Java + Android SDK Activity 는 View, Presenter 는 로직 담당 Web App JavaScript + jQuery View 는 DOM 조작, Presenter 는 이벤트 핸들 Desktop App C# + WinForms View 는 UI 제어, Presenter 는 비즈니스 흐름 담당 ✅ 실무 적용 고려사항 및 최적화 방안 실무 적용 고려사항 항목 설명 권장사항 Presenter 설계 뷰에 의존하지 않도록 인터페이스 사용 Interface 로 추상화 View 단순화 UI 는 View 에서만 다룸 복잡한 상태 처리 Presenter 로 위임 테스트 가능성 Presenter 는 독립 테스트 가능하도록 구성 Mock 기반 테스트 도입 최적화 방안 항목 설명 권장사항 DI 적용 Presenter 의존성 주입으로 유연성 강화 DI 프레임워크 사용 State 관리 ViewModel 수준 상태 관리 구현 단순 데이터 클래스로 상태 전달 재사용성 확보 공통 Presenter 유틸 구성 기능 단위 분리 및 모듈화 적용 ✅ 활용 사례 상황: Android 기반 금융 앱의 로그인 기능\n시스템 구성 View: LoginActivity (Android Activity)\nPresenter: LoginPresenter\nModel: UserRepository\n다이어그램 flowchart LR LoginActivity -- onClick --\u003e LoginPresenter LoginPresenter -- validate --\u003e UserRepository UserRepository --\u003e LoginPresenter --\u003e LoginActivity Workflow 사용자가 로그인 버튼 클릭\nPresenter 가 사용자 입력을 검증\nModel 에서 사용자 인증 처리\n결과를 Presenter 가 받아 View 에 전달\n역할 View: UI 입력 수집, 결과 표시\nPresenter: 로직 흐름 제어, 상태 처리\nModel: 인증 처리, 외부 API 연동\n이후 단계로는 다음 내용도 제안드립니다:\nMVVM 과의 심화 비교\nMVP 와 클린 아키텍처의 통합 전략\n테스트 코드 예제 포함 MVP 프로젝트 구성\n필요하시면 바로 이어서 정리해드리겠습니다.\nModel-View-Presenter Pattern (MVP) 패턴 종합 분석 1. 주제 분류 분석 제시된 분류를 검토한 결과, 마지막 단계의 분류가 부적절합니다.\n현재 분류: \"Computer Science and Engineering\" \u003e \"System and Software Architecture\" \u003e \"Architecture\" \u003e \"Architecture Styles\" \u003e \"Structural\" \u003e \"Layered\" \u003e \"MVC (Model-View-Controller)\"\n적절한 분류: \"Computer Science and Engineering\" \u003e \"System and Software Architecture\" \u003e \"Architecture\" \u003e \"Architecture Styles\" \u003e \"Structural\" \u003e \"Layered\" \u003e \"MVP (Model-View-Presenter)\"\n또는 \"Computer Science and Engineering\" \u003e \"System and Software Architecture\" \u003e \"Architecture\" \u003e \"Architecture Styles\" \u003e \"Structural\" \u003e \"Presentation Layer Patterns\" \u003e \"MVP (Model-View-Presenter)\"\n근거: MVP 는 MVC 에서 파생되었지만 별개의 독립적인 아키텍처 패턴이며, 프레젠테이션 로직에서 관심사 분리를 위해 특별히 설계된 패턴입니다.\n2. 요약 및 개요 200 자 요약: Model-View-Presenter (MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, Presenter 가 ‘middle-man’ 역할을 담당하여 모든 프레젠테이션 로직을 처리합니다. View 와 Model 간 직접 통신을 차단하고 인터페이스 기반 통신을 통해 관심사 분리와 테스트 용이성을 극대화합니다.\n250 자 개요: MVP 패턴은 1990 년대 Taligent 에서 시작되어 현재까지 널리 사용되는 UI 아키텍처 패턴입니다. 자동화된 단위 테스트 촉진과 프레젠테이션 로직의 관심사 분리 개선을 목적으로 합니다. Model(데이터), View(UI), Presenter(중재자) 로 구성되며, Passive View 와 Supervising Controller 두 가지 주요 변형이 있습니다. Android, 웹 애플리케이션, 데스크탑 애플리케이션 개발에서 특히 유용합니다.\n3. 핵심 개념 MVP 패턴을 이해하기 위해 반드시 알아야 하는 핵심 개념들:\n관심사 분리 (Separation of Concerns): 사용자 인터페이스 (View) 를 애플리케이션 로직 (Presenter) 과 데이터/모델 계층에서 명확히 분리 Presenter 의 중재자 역할: Presenter 가 Model 과 View 사이의 “middle-man” 기능을 수행 인터페이스 기반 통신: View-Presenter 와 Presenter-Model 간 모든 통신이 인터페이스를 통해 이루어짐 단방향 의존성: View 와 Model 이 서로의 존재를 알지 못하고 직접 통신하지 않음 테스트 용이성: Presenter 를 View 와 독립적으로 테스트 가능 일대일 관계: 일반적으로 하나의 Presenter 가 하나의 View 를 관리 4. 배경 및 목적 배경 MVP 패턴은 1990 년대 초 Apple, IBM, Hewlett-Packard 의 합작 회사인 Taligent 에서 시작되었습니다. Taligent 의 C++ 기반 CommonPoint 환경에서 애플리케이션 개발을 위한 기본 프로그래밍 모델로 사용되었고, 이후 Java 로 이식되어 Mike Potel 의 논문을 통해 대중화되었습니다.\n목적 및 필요성 자동화된 단위 테스트 촉진: UI 로직을 비즈니스 로직에서 분리하여 독립적인 테스트 가능 프레젠테이션 로직의 관심사 분리 개선: UI 계층이 해야 할 것보다 더 많은 일을 하는 문제 해결 MVC 의 한계 극복: MVC 에서 Controller 에 집중되는 비즈니스 로직 분산과 View-Model 간 결합도 감소 5. 주요 원리 및 작동 원리 핵심 원칙 완전한 View-Model 분리: View 는 Model 에 대한 직접적인 지식이 없음 Presenter 중심의 로직 처리: 모든 프레젠테이션 로직이 Presenter 에 집중 인터페이스 기반 설계: 구성 요소 간 느슨한 결합 유지 단일 책임 원칙: 각 구성 요소가 명확한 역할 분담 작동 원리 다이어그램 sequenceDiagram participant User participant View participant Presenter participant Model User-\u003e\u003eView: 사용자 입력 View-\u003e\u003ePresenter: 이벤트 전달 Presenter-\u003e\u003eModel: 데이터 요청/업데이트 Model--\u003e\u003ePresenter: 데이터 반환 Presenter-\u003e\u003eView: View 업데이트 View--\u003e\u003eUser: 결과 표시 6. 구조 및 아키텍처 MVP 아키텍처 다이어그램 graph TB User[User] View[View- UI 렌더링- 사용자 입력 처리- 이벤트 전달] Presenter[Presenter- 비즈니스 로직- View 상태 관리- Model 조작] Model[Model- 데이터 관리- 비즈니스 규칙- 외부 서비스 통신] User -.-\u003e View View --\u003e Presenter Presenter --\u003e View Presenter --\u003e Model Model --\u003e Presenter style View fill:#e1f5fe style Presenter fill:#f3e5f5 style Model fill:#e8f5e8 필수 구성요소 Model 기능: 데이터 저장 계층으로 도메인 로직과 데이터베이스 및 네트워크 계층과의 통신 담당 역할: API 를 통한 데이터 가져오기 및 저장, 데이터베이스 운영, 네트워크 통신, 기타 비즈니스 관련 로직 캡슐화 특징: View 에 대한 지식이 전혀 없으며 독립적으로 테스트 가능 View 기능: UI 계층으로 데이터 시각화 제공 및 Presenter 에 알리기 위한 사용자 행동 추적 역할: 데이터를 표시하고 사용자 명령 (이벤트) 을 Presenter 에 라우팅하는 수동적 인터페이스 특징: 비즈니스 로직 없이 순수한 UI 로직만 포함 Presenter 기능: Model 에서 데이터를 가져와 표시할 내용을 결정하는 UI 로직 적용 역할: Model 과 View 에 작용하여 저장소에서 데이터를 가져와 View 에 표시하기 위해 포맷 특징: Model 과 View 간의 유일한 통신 경로 선택적 구성요소 Contract Interface: View 와 Presenter 간 통신 인터페이스 정의 Repository Pattern: 데이터 접근 추상화 Service Layer: 복잡한 비즈니스 로직 처리 Dependency Injection: 의존성 관리 및 테스트 용이성 7. 구현 기법 Passive View 패턴 정의: Presenter 가 Model 의 변화를 반영하여 View 를 업데이트하며, View 는 Model 의 변화를 인식하지 못함\n구성: View 가 완전히 수동적이며 모든 UI 업데이트를 Presenter 가 담당\n목적: 최대한의 테스트 가능성 확보\n실제 예시:\n1 2 3 4 5 6 // Presenter가 모든 View 업데이트 제어 presenter.onDataLoaded = (data) =\u003e { view.showUserName(data.name); view.showUserEmail(data.email); view.hideLoadingIndicator(); }; Supervising Controller 패턴 정의: View 가 간단한 데이터 바인딩을 직접 수행할 수 있으며 선언적으로 정의 가능\n구성: Presenter 는 Model 을 업데이트하고 선언적으로 지정할 수 없는 복잡한 UI 로직이 필요한 경우에만 View 상태를 조작\n목적: 코드 단순화와 데이터 바인딩 활용\n실제 예시:\n1 2 3 4 // View가 직접 데이터 바인딩 처리 view.bindUserData(model.userData); // Presenter는 복잡한 로직만 처리 presenter.handleComplexValidation(); 인터페이스 기반 구현 정의: Contract 패턴을 통한 View-Presenter 간 통신\n구성:\n1 2 3 4 5 6 7 8 9 10 11 // Contract 인터페이스 정의 interface LoginContract { interface View { showProgress(); hideProgress(); showError(message); } interface Presenter { login(username, password); } } 목적: 느슨한 결합과 테스트 용이성\n실제 예시: Android MVP 에서 Contract 패턴 활용\n8. 장점과 단점 구분 항목 설명 ✅ 장점 관심사 분리 사용자 인터페이스 (View) 를 애플리케이션 로직 (Presenter) 과 데이터/모델 계층에서 명확히 분리하여 유지보수성과 테스트 가능성 향상 테스트 용이성 Presenter 가 대부분의 애플리케이션 로직을 포함하므로 View 와 독립적으로 테스트 가능 유연성과 확장성 View, Presenter, Model 간 잘 정의된 인터페이스로 한 구성 요소의 변경이 다른 구성 요소에 영향을 주지 않음 코드 재사용성 Presenter 의 비즈니스 로직과 Model 의 데이터 조작 작업을 다양한 View 에서 재사용 가능 병렬 개발 관심사 분리로 UI 디자이너와 개발자가 병렬로 작업 가능 ⚠ 단점 복잡성 증가 MVC 와 같은 단순한 아키텍처보다 더 많은 보일러플레이트 코드와 개발 시간 필요 학습 곡선 패턴에 익숙하지 않은 개발자에게는 각 구성 요소의 책임과 상호작용 이해에 어려움 잠재적 오버헤드 작은 프로젝트나 단순한 UI 에서는 패턴의 이점보다 추가된 복잡성이 더 클 수 있음 Presenter 비대화 단일 책임 원칙을 따르지 않으면 모든 상호작용 인터페이스를 가진 단일 클래스 관리가 어려움 단점 해결 방법 MVP 프레임워크 활용: 보일러플레이트 코드 자동 생성 단일 책임 원칙 준수: Presenter 를 기능별로 분할 의존성 주입 활용: 객체 간 결합도 감소 프로젝트 규모 고려: 적절한 복잡성 수준 유지 9. 도전 과제 도전 과제 설명 해결책 Presenter 크기 관리 신중하지 않으면 Presenter 가 모든 것을 아는 거대한 클래스로 확장되는 경향 단일 책임 원칙에 따른 Presenter 분할, 컴포지션 패턴 활용 메모리 누수 View 에 대한 강한 참조로 인한 메모리 누수 WeakReference 사용, Lifecycle 인식 컴포넌트 활용 복잡한 UI 로직 복잡한 UI 상호작용 처리의 어려움 상태 머신 패턴, Command 패턴 조합 사용 데이터 바인딩 제한 UI 프레임워크의 바인딩 기능을 활용할 수 없음 Supervising Controller 패턴 적용 또는 MVVM 고려 10. 분류 기준에 따른 종류 및 유형 분류 기준 유형 특징 적용 사례 View 수동성 Passive View View 가 완전히 수동적이며 Controller 가 모든 View 업데이트 처리 최대 테스트 가능성이 필요한 엔터프라이즈 애플리케이션 Supervising Controller View 가 간단한 데이터 바인딩을 직접 수행하고 Presenter 는 복잡한 상호작용 로직만 처리 데이터 바인딩을 지원하는 플랫폼 플랫폼 웹 MVP ASP.NET WebForms 기반 구현 웹 애플리케이션 개발 데스크탑 MVP Windows Forms, WPF 기반 구현 데스크탑 애플리케이션 모바일 MVP Android, iOS 기반 구현 모바일 애플리케이션 개발 구현 방식 인터페이스 기반 Contract 패턴 활용 테스트 중심 개발 상속 기반 베이스 클래스 활용 빠른 프로토타이핑 11. 실무 적용 예시 분야 애플리케이션 유형 MVP 적용 방식 주요 이점 모바일 개발 Android 앱 Activity/Fragment 를 View 로, 비즈니스 로직을 Presenter 로 분리 UI 와 로직 분리로 테스트 용이성 확보 웹 개발 ASP.NET 애플리케이션 동일한 Model 과 Presenter 를 ASP.NET 웹과 Windows Forms 에서 사용 다중 플랫폼 지원 데스크탑 개발 Java Swing/JavaFX 복잡한 UI 와 비즈니스 로직이 있는 클라이언트 - 서버 애플리케이션 명확한 관심사 분리 엔터프라이즈 대규모 시스템 Application Controller 패턴과 결합하여 네비게이션 플로우 제어 복잡한 워크플로우 관리 12. 활용 사례: Android 로그인 애플리케이션 시나리오 사용자가 ID/Password 를 입력하여 로그인하고, 성공 시 홈 화면으로 이동하는 Android 애플리케이션\n시스템 구성 classDiagram class LoginContract { \u003c\u003e +interface View +interface Presenter } class LoginActivity { +showProgress() +hideProgress() +showError(message) +navigateToHome() } class LoginPresenter { +login(username, password) +onDestroy() } class UserModel { +validateCredentials(username, password) +getUserData() } class UserRepository { +authenticate(username, password) +fetchUserProfile() } LoginActivity ..|\u003e LoginContract LoginPresenter ..|\u003e LoginContract LoginPresenter --\u003e UserModel UserModel --\u003e UserRepository 워크플로우 사용자 입력: 사용자가 LoginActivity 에서 ID/PW 입력 후 로그인 버튼 클릭 이벤트 전달: LoginActivity 가 LoginPresenter 의 login(username, password) 메소드 호출 인증 처리: LoginPresenter 가 UserModel 을 통해 인증 로직 실행 데이터 접근: UserModel 이 UserRepository 에서 사용자 정보 확인 결과 처리: 인증 결과에 따라 LoginPresenter 가 LoginActivity 에 결과 전달 UI 업데이트: 성공 시 홈 화면 이동, 실패 시 에러 메시지 표시 MVP 역할 분담 View (LoginActivity): UI 이벤트 처리, 진행 상태 표시, 결과 화면 전환 Presenter (LoginPresenter): 인증 로직 조정, View 상태 관리, 에러 처리 Model (UserModel): 실제 인증 처리, 데이터 검증, 비즈니스 규칙 적용 13. 실무에서 효과적으로 적용하기 위한 고려사항 고려사항 설명 권장사항 프로젝트 규모 평가 작은 프로젝트에서는 MVP 가 과도한 복잡성을 야기할 수 있음 프로젝트 복잡도와 팀 규모를 고려한 적절한 아키텍처 선택 팀 역량 고려 MVP 패턴에 대한 팀원들의 이해도 평가 충분한 교육과 가이드라인 제공, 코드 리뷰 강화 인터페이스 설계 View 와 Presenter 간 상호작용의 세분화 수준 결정 높은 수준의 인터페이스 유지, 과도한 세분화 지양 테스트 전략 단위 테스트와 통합 테스트 전략 수립 Presenter 중심의 테스트, Mock 객체 활용 의존성 관리 구성 요소 간 의존성 주입 방식 결정 DI 프레임워크 활용, 인터페이스 기반 설계 14. 최적화하기 위한 고려사항 최적화 영역 고려사항 권장사항 Presenter 크기 관리 단일 책임 원칙 위반 시 거대한 클래스가 될 위험 기능별 Presenter 분할, 컴포지션 패턴 활용 메모리 관리 View 참조로 인한 메모리 누수 방지 WeakReference 사용, Lifecycle 관리 성능 최적화 불필요한 View 업데이트 방지 상태 변화 감지, 배치 업데이트 코드 재사용성 공통 로직의 재사용성 극대화 베이스 클래스, 유틸리티 클래스 활용 프레임워크 활용 보일러플레이트 코드 감소 MVP 지원 프레임워크나 라이브러리 사용 15. 기타 사항 주요 문제점과 해결방법 문제 원인 영향 탐지 및 진단 예방 방법 해결 방법 메모리 누수 View 에 대한 강한 참조 유지 앱 크래시, 성능 저하 Memory Profiler 사용 WeakReference 사용, Lifecycle 인식 onDestroy 에서 참조 해제 Presenter 비대화 단일 책임 원칙 위반 유지보수 어려움, 테스트 복잡성 클래스 크기 모니터링 기능별 분할 설계 책임에 따른 Presenter 분리 과도한 인터페이스 불필요한 추상화 코드 복잡성 증가 코드 리뷰 실용적 설계 접근 필수 인터페이스만 유지 테스트 복잡성 의존성 관리 어려움 테스트 작성 어려움 테스트 커버리지 확인 DI 패턴 적용 Mock 프레임워크 활용 16. 주제와 관련하여 주목할 내용 주제 항목 설명 비교 패턴 MVC vs MVP vs MVVM MVP 는 MVC 의 View-Model 결합 문제를 해결하고 MVVM 은 데이터 바인딩에 특화 현대 프레임워크 Android Architecture Components MVVM 으로의 패러다임 전환과 LiveData, ViewModel 활용 테스트 패턴 Test Double Pattern Mock, Stub, Fake 객체를 활용한 효과적인 MVP 테스트 의존성 주입 DI Container Dagger, Hilt 를 활용한 MVP 구현 최적화 함수형 프로그래밍 Reactive MVP RxJava, Coroutines 를 활용한 반응형 MVP 구현 17. 하위 주제로 추가 학습 내용 카테고리 주제 설명 아키텍처 패턴 Clean Architecture with MVP MVP 를 Clean Architecture 에 통합하는 방법 테스팅 MVP Unit Testing Strategies Presenter 중심의 효과적인 테스트 전략 모바일 개발 MVP in React Native 크로스 플랫폼에서의 MVP 적용 방법 웹 개발 MVP in Modern Web Frameworks Angular, React 에서의 MVP 패턴 활용 성능 최적화 MVP Performance Patterns 대규모 애플리케이션에서의 MVP 성능 최적화 18. 관련 분야별 추가 학습 내용 관련 분야 주제 설명 소프트웨어 설계 SOLID Principles in MVP MVP 구현에서 SOLID 원칙 적용 방법 디자인 패턴 Observer Pattern Integration MVP 와 Observer 패턴의 효과적인 결합 모바일 아키텍처 Android Jetpack with MVP 현대적 Android 개발에서의 MVP 활용 웹 아키텍처 Progressive Web Apps MVP PWA 개발에서의 MVP 패턴 적용 마이크로서비스 Frontend Microservices MVP 마이크로 프론트엔드에서의 MVP 활용 용어 정리 카테고리 용어 설명 아키텍처 패턴 Passive View View 가 완전히 수동적이며 Presenter 가 모든 UI 업데이트를 담당하는 MVP 변형 아키텍처 패턴 Supervising Controller View 가 간단한 데이터 바인딩을 직접 수행할 수 있는 MVP 변형 아키텍처 패턴 Presentation Model View Model 이라고도 하며, View 의 상태를 캡처하는 모델을 중심으로 하는 패턴 설계 패턴 Contract Pattern View 와 Presenter 간 인터페이스를 정의하여 결합도를 낮추는 패턴 설계 패턴 Repository Pattern 데이터 접근 로직을 캡슐화하여 비즈니스 로직에서 분리하는 패턴 설계 패턴 Dependency Injection 객체 간 의존성을 외부에서 주입하여 결합도를 낮추는 기법 테스팅 Test Double 테스트에서 실제 객체를 대체하는 Mock, Stub, Fake 객체의 총칭 테스팅 Unit Testing 개별 구성 요소를 독립적으로 테스트하는 방법 프로그래밍 원칙 Separation of Concerns 프로그램을 구별되는 기능을 가진 섹션으로 분리하는 설계 원칙 프로그래밍 원칙 Single Responsibility Principle 하나의 클래스는 하나의 책임만 가져야 한다는 SOLID 원칙 참고 및 출처 Model–view–presenter - Wikipedia MVP (Model View Presenter) Architecture Pattern in Android with Example - GeeksforGeeks Design Patterns: Model View Presenter - Microsoft Learn Model-View-Presenter Pattern in Java - Java Design Patterns Difference Between MVC and MVP Patterns - Baeldung MVP (Model View Presenter) Architecture Pattern in Android - Scaler Topics Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, 관심사 분리 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.\nMVC 패턴에서 파생되었으며, 주로 Windows Forms, ASP.NET, Java Swing 애플리케이션에서 활용된다.\n이 패턴은 1990 년대 Taligent 사에서 처음 도입되었으며, 현재까지 엔터프라이즈급 애플리케이션에서 구조적 안정성을 제공하는 핵심 아키텍처로 자리잡았다. UI 복잡도가 높은 프로젝트에서 체계적인 관리를 원한다면 MVP 구현을 적극 고려해볼 만하다.\nhttps://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/\n핵심 구성 요소 Model: 데이터 저장/관리 및 비즈니스 로직 처리 담당. 데이터베이스 연동, API 통신, 캐싱 기능 수행. UI 와 독립적으로 동작하여 재사용성 향상. View: 사용자 인터페이스 표시 및 입력 이벤트 전달. 수동적 (passive) 으로 Presenter 에 이벤트 전송. 데이터 표시 형식만 관리 (예: 텍스트 박스 값 표시). Presenter: Model 과 View 의 중재자 역할. 사용자 입력 처리 → Model 업데이트 → 변경 사항 View 반영. 복잡한 UI 로직 캡슐화로 테스트 용이성 증대. 작동 메커니즘 사용자가 View 와 상호작용하여 이벤트를 발생시킨다 (예: 로그인). View → Presenter 에 이벤트 전달 Presenter 가 Model 에서 데이터 검증/처리 처리 결과를 View 에 반영 (예: \" 로그인 성공 \" 메시지 표시) 주요 장점 유지보수성 향상:\nUI 변경 시 비즈니스 로직 영향 최소화. 예: 웹 → 모바일 전환 시 Presenter 재사용 가능 테스트 효율성:\nPresenter 단위 테스트로 70% 이상 버그 감소 가능.\n1 2 3 4 5 6 7 8 // Java 테스트 예시 @Test public void testFileLoading() { MockView view = new MockView(); Presenter presenter = new Presenter(view); presenter.loadFile(\"test.txt\"); assertTrue(view.getDisplayedText().contains(\"Loaded\")); } 협업 강화:\n디자이너 (UI)/개발자 (로직) 병렬 작업 가능.\n코드 재사용:\n동일 Presenter 로 다양한 플랫폼 UI 구현 가능.\n단점 복잡성 증가: 단순한 애플리케이션에서는 MVP 패턴의 도입으로 오히려 구조가 복잡해질 수 있다. 코드량 증가: 각 구성 요소의 분리로 인해 코드의 양이 늘어날 수 있다. MVP 패턴의 변형 패시브 뷰 (Passive View): 뷰는 사용자 입력을 프레젠터에게 전달하고, 프레젠터는 모든 로직을 처리한 후 뷰를 업데이트한다. 슈퍼바이저 뷰 (Supervising View): 뷰가 일부 프레젠테이션 로직을 처리하며, 프레젠터는 복잡한 로직에 집중한다. 적용 시 고려사항 소규모 프로젝트: 과도한 추상화로 인한 복잡성 증가 가능 실시간 업데이트: Model 변경 시 View 자동 갱신 메커니즘 필요 (Observer 패턴 활용) 프레임워크 선택: Android 의 경우 MVP 보다 MVVM 이 더 널리 사용되는 추세 구현 예시 Python 코드 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 # Model class UserModel: def __init__(self): self.database = Database() # 데이터베이스 연결 def get_user_data(self, user_id): # 데이터베이스에서 사용자 정보 조회 return self.database.query(f\"SELECT * FROM users WHERE id = {user_id}\") def update_user(self, user_data): # 사용자 정보 업데이트 return self.database.update(\"users\", user_data) # View class UserView: def __init__(self, presenter): self.presenter = presenter def display_user_info(self, user_data): # 사용자 정보를 화면에 표시 print(f\"이름: {user_data['name']}\") print(f\"이메일: {user_data['email']}\") def get_user_input(self): # 사용자 입력 받기 name = input(\"이름을 입력하세요: \") email = input(\"이메일을 입력하세요: \") return {\"name\": name, \"email\": email} # Presenter class UserPresenter: def __init__(self, model, view): self.model = model self.view = view def load_user(self, user_id): # 모델에서 데이터를 가져와서 뷰에 전달 user_data = self.model.get_user_data(user_id) self.view.display_user_info(user_data) def update_user_info(self): # 뷰에서 입력받은 데이터를 모델에 전달 user_data = self.view.get_user_input() self.model.update_user(user_data) # 전체 애플리케이션 구성 def main(): # 각 구성 요소 초기화 model = UserModel() view = UserView(None) # presenter는 나중에 설정 presenter = UserPresenter(model, view) view.presenter = presenter # view에 presenter 연결 # 애플리케이션 실행 presenter.load_user(1) # 사용자 ID 1의 정보 로드 presenter.update_user_info() # 사용자 정보 업데이트 if __name__ == \"__main__\": main() 참고 및 출처 ","wordCount":"5528","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-27T09:10:00Z","dateModified":"2024-09-27T09:10:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/structural/layered/mvc/model-view-presenter-pattern/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Model–view–presenter Pattern</h1><div class=post-description>Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.</div><div class=post-meta><span title='2024-09-27 09:10:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;26 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Design%20and%20Architecture/Architecture%20Styles%20and%20Patterns/Architecture%20Styles/Structural/Layered/MVC/model-view-presenter-pattern.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#modelviewpresenter-pattern>Model–view–presenter Pattern</a><ul><li><a href=#1-주제의-분류-적절성-분석>1. 주제의 분류 적절성 분석</a></li><li><a href=#2-200-자-요약>2. 200 자 요약</a></li><li><a href=#3-250-자-개요>3. 250 자 개요</a></li></ul></li><li><a href=#4-핵심-개념>4. 핵심 개념</a></li><li><a href=#5-상세-조사-내용>5. 상세 조사 내용</a><ul><li><a href=#배경-및-목적>배경 및 목적</a></li><li><a href=#주요-기능-및-역할>주요 기능 및 역할</a></li><li><a href=#특징>특징</a></li><li><a href=#핵심-원칙>핵심 원칙</a></li><li><a href=#주요-원리-및-작동-원리>주요 원리 및 작동 원리</a></li><li><a href=#구조-및-아키텍처>구조 및 아키텍처</a></li><li><a href=#구현-기법>구현 기법</a></li><li><a href=#장점과-단점>장점과 단점</a></li><li><a href=#도전-과제-및-해결책>도전 과제 및 해결책</a></li><li><a href=#분류-기준에-따른-종류-및-유형>분류 기준에 따른 종류 및 유형</a></li><li><a href=#실무-적용-예시>실무 적용 예시</a></li><li><a href=#활용-사례-시나리오-기반>활용 사례 (시나리오 기반)</a></li><li><a href=#실무-적용-고려사항-및-권장사항>실무 적용 고려사항 및 권장사항</a></li><li><a href=#최적화-고려사항-및-권장사항>최적화 고려사항 및 권장사항</a></li><li><a href=#기타-사항-문제-원인-영향-진단-예방-해결>기타 사항 (문제, 원인, 영향, 진단, 예방, 해결)</a></li></ul></li><li><a href=#8-주제와-관련한-주목할-내용>8. 주제와 관련한 주목할 내용</a></li><li><a href=#9-하위-학습-주제>9. 하위 학습 주제</a></li><li><a href=#10-추가-학습알아야-할-내용>10. 추가 학습/알아야 할 내용</a></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li><li><a href=#1-주제-분류의-적절성-분석>1. 주제 분류의 적절성 분석</a></li><li><a href=#2-요약-설명-200-자-내외>2. 요약 설명 (200 자 내외)</a></li><li><a href=#3-전체-개요-250-자-내외>3. 전체 개요 (250 자 내외)</a></li><li><a href=#4-핵심-개념-1>4. 핵심 개념</a></li><li><a href=#5-주요-원리-및-작동-원리>5. 주요 원리 및 작동 원리</a></li><li><a href=#6-구조-및-아키텍처>6. 구조 및 아키텍처</a></li><li><a href=#7-구현-기법>7. 구현 기법</a><ul><li><a href=#python-예시>Python 예시</a></li><li><a href=#javascript-예시>JavaScript 예시</a></li></ul></li><li><a href=#8-장점과-단점>8. 장점과 단점</a></li><li><a href=#9-도전-과제-및-해결책>9. 도전 과제 및 해결책</a></li><li><a href=#10-분류-기준에-따른-종류-및-유형>10. 분류 기준에 따른 종류 및 유형</a></li><li><a href=#11-실무-적용-예시>11. 실무 적용 예시</a></li><li><a href=#12-활용-사례>12. 활용 사례</a></li><li><a href=#13-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>13. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</a></li><li><a href=#14-최적화하기-위한-고려사항-및-주의할-점>14. 최적화하기 위한 고려사항 및 주의할 점</a></li><li><a href=#15-기타-사항>15. 기타 사항</a></li><li><a href=#용어-정리-1>용어 정리</a></li><li><a href=#용어-정리-2>용어 정리</a></li><li><a href=#참고-및-출처-1>참고 및 출처</a></li><li><a href=#-mvc-vs-mvp-vs-mvvm-비교>✅ MVC Vs MVP Vs MVVM 비교</a></li><li><a href=#-구조-및-아키텍처-다이어그램>✅ 구조 및 아키텍처 (다이어그램)</a></li><li><a href=#-주요-원리와-작동-원리>✅ 주요 원리와 작동 원리</a></li><li><a href=#-mvp-의-구성-요소별-기능>✅ MVP 의 구성 요소별 기능</a></li><li><a href=#-구현-기법>✅ 구현 기법</a><ul><li><a href=#javascript-mvp-예제>JavaScript MVP 예제</a></li></ul></li><li><a href=#-장점과-단점>✅ 장점과 단점</a></li><li><a href=#-실무-적용-예시>✅ 실무 적용 예시</a></li><li><a href=#-실무-적용-고려사항-및-최적화-방안>✅ 실무 적용 고려사항 및 최적화 방안</a><ul><li><a href=#실무-적용-고려사항>실무 적용 고려사항</a></li><li><a href=#최적화-방안>최적화 방안</a></li></ul></li><li><a href=#-활용-사례>✅ 활용 사례</a><ul><li><a href=#시스템-구성>시스템 구성</a></li><li><a href=#다이어그램>다이어그램</a></li><li><a href=#workflow>Workflow</a></li><li><a href=#역할>역할</a></li></ul></li><li><a href=#model-view-presenter-pattern-mvp-패턴-종합-분석>Model-View-Presenter Pattern (MVP) 패턴 종합 분석</a><ul><li><a href=#1-주제-분류-분석>1. 주제 분류 분석</a></li><li><a href=#2-요약-및-개요>2. 요약 및 개요</a></li><li><a href=#3-핵심-개념>3. 핵심 개념</a></li><li><a href=#4-배경-및-목적>4. 배경 및 목적</a></li><li><a href=#5-주요-원리-및-작동-원리-1>5. 주요 원리 및 작동 원리</a></li><li><a href=#6-구조-및-아키텍처-1>6. 구조 및 아키텍처</a></li><li><a href=#7-구현-기법-1>7. 구현 기법</a></li><li><a href=#8-장점과-단점-1>8. 장점과 단점</a></li><li><a href=#9-도전-과제>9. 도전 과제</a></li><li><a href=#10-분류-기준에-따른-종류-및-유형-1>10. 분류 기준에 따른 종류 및 유형</a></li><li><a href=#11-실무-적용-예시-1>11. 실무 적용 예시</a></li><li><a href=#12-활용-사례-android-로그인-애플리케이션>12. 활용 사례: Android 로그인 애플리케이션</a></li><li><a href=#13-실무에서-효과적으로-적용하기-위한-고려사항>13. 실무에서 효과적으로 적용하기 위한 고려사항</a></li><li><a href=#14-최적화하기-위한-고려사항>14. 최적화하기 위한 고려사항</a></li><li><a href=#15-기타-사항-1>15. 기타 사항</a></li><li><a href=#16-주제와-관련하여-주목할-내용>16. 주제와 관련하여 주목할 내용</a></li><li><a href=#17-하위-주제로-추가-학습-내용>17. 하위 주제로 추가 학습 내용</a></li><li><a href=#18-관련-분야별-추가-학습-내용>18. 관련 분야별 추가 학습 내용</a></li><li><a href=#용어-정리-3>용어 정리</a></li><li><a href=#참고-및-출처-2>참고 및 출처</a></li><li><a href=#참고-및-출처-3>참고 및 출처</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=modelviewpresenter-pattern>Model–view–presenter Pattern<a hidden class=anchor aria-hidden=true href=#modelviewpresenter-pattern>#</a></h2><h3 id=1-주제의-분류-적절성-분석>1. 주제의 분류 적절성 분석<a hidden class=anchor aria-hidden=true href=#1-주제의-분류-적절성-분석>#</a></h3><p>Model–View–Presenter(MVP) 패턴은 &ldquo;Computer Science and Engineering > System and Software Architecture > Architecture > Architecture Styles > Structural > Layered > MVC (Model-View-Controller)&rdquo; 분류에 매우 적합합니다.<br>MVP 는 MVC(Model-View-Controller) 아키텍처 패턴에서 파생된 구조적 (Structural) 계층형 (Layered) UI 아키텍처 패턴으로, 사용자 인터페이스 개발에서 관심사의 분리와 테스트 용이성을 극대화하기 위해 고안되었습니다 [1][3][4][14].<br>MVC 와 마찬가지로 View, Model, 그리고 중재자 역할의 Presenter 로 계층을 명확히 분리하므로, Layered 및 MVC 하위 분류에 위치하는 것이 타당합니다.</p><hr><h3 id=2-200-자-요약>2. 200 자 요약<a hidden class=anchor aria-hidden=true href=#2-200-자-요약>#</a></h3><p>Model–View–Presenter(MVP) 패턴은 사용자 인터페이스를 Model(데이터/비즈니스), View(UI), Presenter(중재자) 로 분리하는 구조적 계층형 아키텍처 패턴입니다.<br>Presenter 가 View 와 Model 사이의 모든 상호작용을 중재하여, 코드의 테스트 용이성과 유지보수성을 극대화합니다 [1][4][6][9][14].</p><hr><h3 id=3-250-자-개요>3. 250 자 개요<a hidden class=anchor aria-hidden=true href=#3-250-자-개요>#</a></h3><p>Model–View–Presenter(MVP) 패턴은 MVC 에서 파생된 UI 아키텍처 패턴으로, 애플리케이션을 Model(비즈니스/데이터), View(사용자 인터페이스), Presenter(중재자) 세 계층으로 분리합니다.<br>Presenter 는 View 와 Model 간의 모든 상호작용을 담당하며, View 는 최대한 수동적으로 동작합니다.<br>이 구조는 관심사의 분리, 테스트 용이성, 유지보수성, 코드 재사용성을 높이며, 특히 웹·모바일·데스크톱 등 다양한 UI 환경에서 널리 사용됩니다 [1][4][6][9][14][15].</p><hr><h2 id=4-핵심-개념>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념>#</a></h2><ul><li><strong>MVP 란?</strong><br>Model–View–Presenter(MVP) 는 MVC 에서 파생된 아키텍처 패턴으로, UI 를 Model, View, Presenter 세 계층으로 분리하여 각 계층의 책임을 명확히 합니다 [1][4][9][14].</li><li><strong>Model(모델)</strong>: 데이터와 비즈니스 로직을 담당, View 와 직접 연결되지 않음 [4][9][11][15].</li><li><strong>View(뷰)</strong>: 사용자에게 데이터 표시 및 입력 수집, Presenter 와만 통신하며 최대한 수동적으로 동작 [1][4][6][9][14].</li><li><strong>Presenter(프리젠터)</strong>: View 와 Model 사이의 중재자 역할, 모든 프레젠테이션 로직을 담당하며 View 와 1:1 관계를 맺는 것이 일반적 [1][4][9][11][14].</li><li><strong>관심사의 분리</strong>: 각 계층이 자신의 역할에만 집중하여 코드의 유지보수성과 테스트 용이성을 극대화 [3][6][7][14].</li></ul><hr><h2 id=5-상세-조사-내용>5. 상세 조사 내용<a hidden class=anchor aria-hidden=true href=#5-상세-조사-내용>#</a></h2><h3 id=배경-및-목적>배경 및 목적<a hidden class=anchor aria-hidden=true href=#배경-및-목적>#</a></h3><ul><li>1990 년대 Taligent 에서 MVC 의 한계를 극복하고 UI 테스트 용이성, 관심사 분리, 유지보수성 향상을 위해 고안됨 [1].</li><li>View 와 Model 의 직접 의존성을 제거하여, 프레젠테이션 로직을 Presenter 에 집중시킴 [4][14].</li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><table><thead><tr><th>계층</th><th>역할/기능</th></tr></thead><tbody><tr><td>Model</td><td>데이터 관리, 비즈니스 로직, 외부 데이터 소스 연동</td></tr><tr><td>View</td><td>UI 표시, 사용자 입력 수집, Presenter 에 이벤트 전달</td></tr><tr><td>Presenter</td><td>View 와 Model 중재, 프레젠테이션 로직, 상태 관리</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>View 와 Model 의 직접 의존성 없음, Presenter 가 중재자 역할 [1][4][11][14].</li><li>View 는 최대한 수동적 (Passive View) 으로 동작 [1][4][14].</li><li>Presenter 와 View 는 1:1 매핑이 일반적, 복잡한 경우 다수 Presenter 사용 가능 [1][11][14].</li><li>테스트 용이성, 유지보수성, 코드 재사용성, 확장성 우수 [3][6][7][14].</li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ul><li>관심사 분리 (Separation of Concerns)</li><li>느슨한 결합 (Loose Coupling)</li><li>인터페이스 기반 통신 (Interface-Driven Communication)</li><li>테스트 용이성 (Testability)</li></ul><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><ul><li>사용자의 입력은 View 에서 Presenter 로 전달됨 [1][4][14].</li><li>Presenter 는 Model 에서 데이터를 받아 비즈니스 로직을 처리하고, 결과를 View 에 전달해 UI 를 갱신함 [1][4][14].</li><li>View 는 Presenter 를 통해서만 Model 과 간접적으로 상호작용함 [1][4][14].</li></ul><h4 id=다이어그램-mermaid>다이어그램 (Mermaid)<a hidden class=anchor aria-hidden=true href=#다이어그램-mermaid>#</a></h4><pre class=mermaid>sequenceDiagram
    participant User
    participant View
    participant Presenter
    participant Model

    User-&gt;&gt;View: 입력(클릭, 입력 등)
    View-&gt;&gt;Presenter: 이벤트 전달
    Presenter-&gt;&gt;Model: 데이터 요청/수정
    Model--&gt;&gt;Presenter: 데이터 반환
    Presenter-&gt;&gt;View: UI 갱신
    View--&gt;&gt;User: 결과 표시
</pre><hr><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><h4 id=필수-구성요소-및-역할>필수 구성요소 및 역할<a hidden class=anchor aria-hidden=true href=#필수-구성요소-및-역할>#</a></h4><table><thead><tr><th>구성요소</th><th>기능/역할</th><th>특징</th></tr></thead><tbody><tr><td>Model</td><td>데이터, 비즈니스 로직, 외부 연동</td><td>View 와 직접 연결 없음</td></tr><tr><td>View</td><td>UI 표시, 입력 수집, Presenter 호출</td><td>최대한 수동적</td></tr><tr><td>Presenter</td><td>View-Model 중재, 프레젠테이션 로직</td><td>View 와 1:1 매핑 일반</td></tr></tbody></table><h4 id=선택-구성요소>선택 구성요소<a hidden class=anchor aria-hidden=true href=#선택-구성요소>#</a></h4><table><thead><tr><th>구성요소</th><th>기능/역할</th><th>특징</th></tr></thead><tbody><tr><td>ViewModel</td><td>View 와 Presenter 사이 데이터 변환</td><td>MVVM 등 확장 패턴에서 사용</td></tr><tr><td>Router</td><td>화면 전환, 라우팅 관리</td><td>웹/모바일에서 활용</td></tr></tbody></table><h4 id=구조-다이어그램-mermaid>구조 다이어그램 (Mermaid)<a hidden class=anchor aria-hidden=true href=#구조-다이어그램-mermaid>#</a></h4><pre class=mermaid>graph TD
    User[사용자] --&gt; View[View]
    View --&gt; Presenter[Presenter]
    Presenter --&gt; Model[Model]
    Model --&gt; Presenter
    Presenter --&gt; View
</pre><hr><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><ul><li><strong>Model 구현</strong>: 데이터베이스, API, 비즈니스 로직 클래스 등</li><li><strong>View 구현</strong>: UI 프레임워크, 화면 컴포넌트, 입력 이벤트 처리</li><li><strong>Presenter 구현</strong>: View/Model 인터페이스 구현, 프레젠테이션 로직, 상태 관리</li><li><strong>통신</strong>: 인터페이스 (Contract) 기반으로 View-Presenter, Presenter-Model 연결 [4][14][15].</li><li><strong>실제 예시</strong>:<ul><li>Android, WinForms, WPF 등에서 널리 활용 [15].</li><li>Java, C#, Kotlin 등 다양한 언어에서 구현 가능 [9][15].</li></ul></li></ul><hr><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>관심사 분리</td><td>각 계층의 책임 명확, 유지보수성 우수</td></tr><tr><td></td><td>테스트 용이성</td><td>Presenter 단위 테스트 용이</td></tr><tr><td></td><td>확장성</td><td>UI/로직/데이터 독립적 변경 가능</td></tr><tr><td></td><td>코드 재사용성</td><td>Presenter/Model 재사용 가능</td></tr><tr><td></td><td>유연성</td><td>다양한 UI/플랫폼 적용 가능</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>단순 UI 에선 구조가 불필요하게 복잡</td></tr><tr><td></td><td>코드량 증가</td><td>인터페이스, 클래스 수 증가</td></tr><tr><td></td><td>View-Presenter 의존성</td><td>1:1 매핑 시 결합도 높아질 수 있음</td></tr><tr><td></td><td>학습 곡선</td><td>구조 이해에 시간 소요</td></tr></tbody></table><ul><li><strong>단점 해결 방법</strong><ul><li>소규모 프로젝트엔 단순화 적용</li><li>코드/인터페이스 재사용, 공통 Presenter 모듈화</li><li>문서화 및 코드 리뷰 강화</li></ul></li></ul><hr><h3 id=도전-과제-및-해결책>도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#도전-과제-및-해결책>#</a></h3><ul><li><strong>Presenter-View 결합도</strong>: 인터페이스 기반 설계, DI(Dependency Injection) 활용</li><li><strong>테스트 복잡성</strong>: Mock, Stub, 자동화 테스트 도구 활용</li><li><strong>구조 복잡성</strong>: 공통 Presenter/Model 모듈화, 코드/설계 문서화</li></ul><hr><h3 id=분류-기준에-따른-종류-및-유형>분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류-기준에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>View 역할</td><td>Passive View</td><td>View 가 최대한 수동적으로 동작</td></tr><tr><td></td><td>Supervising Presenter</td><td>View 가 일부 UI 로직 담당, Presenter 가 핵심 로직 담당</td></tr><tr><td>확장 패턴</td><td>MVVM</td><td>ViewModel 추가, 데이터 바인딩 강화</td></tr><tr><td></td><td>MVPVM</td><td>Presenter 와 ViewModel 결합 패턴</td></tr></tbody></table><hr><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>분야</th><th>적용 사례</th><th>설명</th></tr></thead><tbody><tr><td>모바일</td><td>Android MVP</td><td>액티비티 - 프래그먼트 - 프리젠터 구조</td></tr><tr><td>데스크톱</td><td>WinForms MVP</td><td>UI- 프리젠터 - 모델 분리</td></tr><tr><td>웹</td><td>GWT MVP</td><td>Google Web Toolkit 에서 활용</td></tr><tr><td>임베디드</td><td>TouchGFX MVP</td><td>임베디드 UI 프레임워크 적용</td></tr></tbody></table><hr><h3 id=활용-사례-시나리오-기반>활용 사례 (시나리오 기반)<a hidden class=anchor aria-hidden=true href=#활용-사례-시나리오-기반>#</a></h3><ul><li><strong>상황</strong>: 모바일 쇼핑앱 상품 상세 화면</li><li><strong>시스템 구성</strong>:<ul><li>Model: 상품 데이터, 네트워크 API</li><li>View: 상품 상세 UI(Activity/Fragment)</li><li>Presenter: 상품 데이터 요청, UI 상태 관리</li></ul></li><li><strong>구조 다이어그램 (Mermaid)</strong></li></ul><pre class=mermaid>graph TD
    User[사용자] --&gt; View[상품 상세 화면]
    View --&gt; Presenter[상품 Presenter]
    Presenter --&gt; Model[상품 데이터/네트워크]
    Model --&gt; Presenter
    Presenter --&gt; View
</pre><ul><li><strong>Workflow</strong>:<ol><li>사용자가 상품 상세 진입</li><li>View 가 Presenter 에 데이터 요청</li><li>Presenter 가 Model 에서 데이터 조회</li><li>Presenter 가 View 에 결과 전달</li><li>View 가 UI 갱신</li></ol></li><li><strong>역할</strong>:<ul><li>Android 개발자: View/Presenter 구현</li><li>백엔드 개발자: Model(API, DB) 구현</li><li>QA: 테스트 자동화</li></ul></li></ul><hr><h3 id=실무-적용-고려사항-및-권장사항>실무 적용 고려사항 및 권장사항<a hidden class=anchor aria-hidden=true href=#실무-적용-고려사항-및-권장사항>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>계층 분리</td><td>각 계층 책임 명확화</td><td>설계 문서화, 코드 리뷰</td></tr><tr><td>인터페이스</td><td>View-Presenter, Presenter-Model 계약</td><td>Contract, DI 적용</td></tr><tr><td>테스트</td><td>Presenter 단위 테스트</td><td>Mock, Stub 활용</td></tr><tr><td>코드 재사용</td><td>공통 Presenter/Model 모듈화</td><td>코드 중복 최소화</td></tr><tr><td>확장성</td><td>UI/로직/데이터 독립적 확장</td><td>모듈화 설계</td></tr></tbody></table><hr><h3 id=최적화-고려사항-및-권장사항>최적화 고려사항 및 권장사항<a hidden class=anchor aria-hidden=true href=#최적화-고려사항-및-권장사항>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>성능</td><td>불필요한 View-Presenter 통신 최소화</td><td>이벤트 버스, 캐싱 활용</td></tr><tr><td>유지보수성</td><td>코드 구조화, 문서화</td><td>설계/코드 문서 자동화</td></tr><tr><td>테스트</td><td>자동화 테스트 적용</td><td>CI/CD 파이프라인 구축</td></tr><tr><td>확장성</td><td>계층별 독립적 확장</td><td>공통 모듈화, DI 활용</td></tr><tr><td>보안</td><td>입력 검증, 데이터 보호</td><td>보안 프레임워크 도입</td></tr></tbody></table><hr><h3 id=기타-사항-문제-원인-영향-진단-예방-해결>기타 사항 (문제, 원인, 영향, 진단, 예방, 해결)<a hidden class=anchor aria-hidden=true href=#기타-사항-문제-원인-영향-진단-예방-해결>#</a></h3><ul><li><strong>문제</strong>: Presenter-View 결합도, 코드량 증가, 구조 복잡성</li><li><strong>원인</strong>: 1:1 매핑, 불필요한 계층화, 설계 미흡</li><li><strong>영향</strong>: 유지보수 비용 증가, 버그 발생</li><li><strong>진단</strong>: 코드 리뷰, 정적 분석, 테스트 자동화</li><li><strong>예방</strong>: 설계 표준화, 공통 모듈화, 코드 리뷰 강화</li><li><strong>해결</strong>: Presenter/Model 모듈화, DI 적용, 리팩토링</li></ul><hr><h2 id=8-주제와-관련한-주목할-내용>8. 주제와 관련한 주목할 내용<a hidden class=anchor aria-hidden=true href=#8-주제와-관련한-주목할-내용>#</a></h2><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>계층 구조</td><td>관심사 분리</td><td>각 계층의 책임 명확화</td></tr><tr><td>테스트</td><td>Presenter 단위 테스트</td><td>Mock, Stub 활용</td></tr><tr><td>확장성</td><td>UI/로직/데이터 독립적 확장</td><td>모듈화 설계</td></tr><tr><td>코드 재사용</td><td>공통 Presenter/Model</td><td>코드 중복 최소화</td></tr><tr><td>결합도</td><td>인터페이스 기반 통신</td><td>DI, Contract 활용</td></tr></tbody></table><hr><h2 id=9-하위-학습-주제>9. 하위 학습 주제<a hidden class=anchor aria-hidden=true href=#9-하위-학습-주제>#</a></h2><table><thead><tr><th>간략 설명</th><th>카테고리</th><th>주제</th></tr></thead><tbody><tr><td>View-Presenter 계약</td><td>설계</td><td>인터페이스, Contract</td></tr><tr><td>DI 적용</td><td>구현</td><td>Dependency Injection</td></tr><tr><td>테스트 자동화</td><td>품질</td><td>Mock, Stub, CI/CD</td></tr><tr><td>확장 패턴</td><td>설계</td><td>MVVM, MVPVM 등</td></tr><tr><td>코드 모듈화</td><td>구현</td><td>공통 Presenter/Model</td></tr></tbody></table><hr><h2 id=10-추가-학습알아야-할-내용>10. 추가 학습/알아야 할 내용<a hidden class=anchor aria-hidden=true href=#10-추가-학습알아야-할-내용>#</a></h2><table><thead><tr><th>간략 설명</th><th>관련 분야</th><th>주제</th></tr></thead><tbody><tr><td>MVP vs MVC</td><td>아키텍처</td><td>구조/역할 차이 분석</td></tr><tr><td>MVP vs MVVM</td><td>아키텍처</td><td>데이터 바인딩, ViewModel</td></tr><tr><td>RxMVP</td><td>구현</td><td>Reactive MVP, RxJava</td></tr><tr><td>모바일 MVP</td><td>모바일</td><td>Android, iOS 적용</td></tr><tr><td>클린 아키텍처와의 비교</td><td>설계</td><td>계층 구조 차이 분석</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>아키텍처</td><td>MVP</td><td>Model-View-Presenter, 3 계층 구조 아키텍처 패턴</td></tr><tr><td>아키텍처</td><td>Passive View</td><td>View 가 최대한 수동적으로 동작하는 방식</td></tr><tr><td>아키텍처</td><td>Supervising Presenter</td><td>View 가 일부 UI 로직 담당, Presenter 가 핵심 로직 담당</td></tr><tr><td>구현</td><td>Contract</td><td>View-Presenter, Presenter-Model 간 인터페이스 계약</td></tr><tr><td>구현</td><td>DI</td><td>Dependency Injection, 의존성 주입</td></tr><tr><td>품질</td><td>단위 테스트</td><td>Presenter 단위의 기능 검증 테스트</td></tr><tr><td>품질</td><td>통합 테스트</td><td>계층 간 상호작용 검증 테스트</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter>Model–view–presenter - Wikipedia</a></li><li><a href=https://www.baeldung.com/mvc-vs-mvp-pattern>Difference Between MVC and MVP Patterns | Baeldung</a></li><li><a href=https://isonpro.tistory.com/301>MVP 패턴에 대해 자세히 알아보십시오. - EchoTech</a></li><li><a href=https://startup-house.com/glossary/model-view-presenter>What is Model-View-Presenter (MVP) - Startup House</a></li><li><a href=https://java-design-patterns.com/patterns/model-view-presenter/>Model-View-Presenter Pattern in Java: Enhancing UI Logic Separation for Cleaner Code</a></li><li><a href=https://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/>MVP (Model View Presenter) Architecture Pattern in Android with Example | GeeksforGeeks</a></li><li><a href=https://dev.to/binoy123/architectural-pattern-model-view-presenter-mvp-28hl>Architectural Pattern - Model–view–presenter (MVP) - DEV Community</a></li></ul><p>Model–View–Presenter (MVP) 패턴은 사용자 인터페이스 (UI) 설계에서 핵심적인 아키텍처 스타일 중 하나로, 특히 복잡한 UI 로직을 분리하고 테스트 가능성을 높이는 데 효과적입니다. 이 패턴은 MVC(Model–View–Controller) 에서 발전된 형태로, 프레젠터 (Presenter) 가 중심 역할을 하여 모델 (Model) 과 뷰 (View) 를 연결합니다.</p><hr><h2 id=1-주제-분류의-적절성-분석>1. 주제 분류의 적절성 분석<a hidden class=anchor aria-hidden=true href=#1-주제-분류의-적절성-분석>#</a></h2><p>MVP 패턴은 &ldquo;Computer Science and Engineering > System and Software Architecture > Architecture > Architecture Styles > Structural > Layered > MVC (Model-View-Controller)&rdquo; 분류에 적합합니다. 이는 MVP 가 MVC 에서 파생된 구조적 아키텍처 스타일로, 계층화된 구조를 통해 UI, 비즈니스 로직, 데이터 관리를 명확히 분리하기 때문입니다.</p><hr><h2 id=2-요약-설명-200-자-내외>2. 요약 설명 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#2-요약-설명-200-자-내외>#</a></h2><p>Model–View–Presenter(MVP) 패턴은 UI, 비즈니스 로직, 데이터 관리를 명확히 분리하여 테스트 용이성과 유지보수성을 향상시키는 아키텍처 스타일입니다. 프레젠터는 뷰와 모델 간의 중재자로서 사용자 입력을 처리하고, 모델의 데이터를 뷰에 전달합니다.</p><hr><h2 id=3-전체-개요-250-자-내외>3. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#3-전체-개요-250-자-내외>#</a></h2><p>MVP 패턴은 UI 설계에서 핵심적인 아키텍처 스타일로, 프레젠터가 중심이 되어 모델과 뷰를 연결합니다. 이러한 구조는 각 구성 요소의 책임을 명확히 하여 코드의 재사용성과 테스트 용이성을 높이며, 특히 복잡한 UI 로직을 효과적으로 관리할 수 있도록 지원합니다.</p><hr><h2 id=4-핵심-개념-1>4. 핵심 개념<a hidden class=anchor aria-hidden=true href=#4-핵심-개념-1>#</a></h2><ul><li><p><strong>Model</strong>: 애플리케이션의 데이터와 비즈니스 로직을 관리합니다.</p></li><li><p><strong>View</strong>: 사용자에게 정보를 표시하고, 사용자 입력을 프레젠터에게 전달합니다.</p></li><li><p><strong>Presenter</strong>: 사용자 입력을 처리하고, 모델과 상호작용하여 데이터를 가져와 뷰를 업데이트합니다.</p></li></ul><hr><h2 id=5-주요-원리-및-작동-원리>5. 주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#5-주요-원리-및-작동-원리>#</a></h2><p>MVP 패턴에서의 상호작용은 다음과 같습니다:</p><pre class=mermaid>sequenceDiagram
    participant User
    participant View
    participant Presenter
    participant Model

    User-&gt;&gt;View: 사용자 입력
    View-&gt;&gt;Presenter: 입력 전달
    Presenter-&gt;&gt;Model: 데이터 요청
    Model--&gt;&gt;Presenter: 데이터 반환
    Presenter-&gt;&gt;View: 뷰 업데이트
</pre><hr><h2 id=6-구조-및-아키텍처>6. 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#6-구조-및-아키텍처>#</a></h2><p>MVP 패턴의 구조는 다음과 같습니다:</p><pre class=mermaid>classDiagram
    class View {
        +displayData(data)
        +getUserInput()
    }
    class Presenter {
        +onUserAction()
        +updateView()
    }
    class Model {
        +fetchData()
        +processData()
    }

    View --&gt; Presenter
    Presenter --&gt; Model
    Model --&gt; Presenter
    Presenter --&gt; View
</pre><hr><h2 id=7-구현-기법>7. 구현 기법<a hidden class=anchor aria-hidden=true href=#7-구현-기법>#</a></h2><h3 id=python-예시>Python 예시<a hidden class=anchor aria-hidden=true href=#python-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span><span class=lnt id=hl-5-26><a class=lnlinks href=#hl-5-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># model.py</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Model</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_data</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Hello from Model&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># view.py</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>View</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>display</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;View: </span><span class=si>{</span><span class=n>data</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># presenter.py</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Presenter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>view</span><span class=p>,</span> <span class=n>model</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>view</span> <span class=o>=</span> <span class=n>view</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>model</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>run</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>get_data</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>view</span><span class=o>.</span><span class=n>display</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># main.py</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span> <span class=o>=</span> <span class=n>Model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>view</span> <span class=o>=</span> <span class=n>View</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>presenter</span> <span class=o>=</span> <span class=n>Presenter</span><span class=p>(</span><span class=n>view</span><span class=p>,</span> <span class=n>model</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>presenter</span><span class=o>.</span><span class=n>run</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=javascript-예시>JavaScript 예시<a hidden class=anchor aria-hidden=true href=#javascript-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span><span class=lnt id=hl-6-30><a class=lnlinks href=#hl-6-30>30</a>
</span><span class=lnt id=hl-6-31><a class=lnlinks href=#hl-6-31>31</a>
</span><span class=lnt id=hl-6-32><a class=lnlinks href=#hl-6-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// model.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>Model</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>getData</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s2>&#34;Hello from Model&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// view.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>display</span><span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`View: </span><span class=si>${</span><span class=nx>data</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// presenter.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>Presenter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>constructor</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=nx>model</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>view</span> <span class=o>=</span> <span class=nx>view</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>model</span> <span class=o>=</span> <span class=nx>model</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>run</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>data</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>model</span><span class=p>.</span><span class=nx>getData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>view</span><span class=p>.</span><span class=nx>display</span><span class=p>(</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>model</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Model</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>view</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>View</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>presenter</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Presenter</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=nx>model</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>presenter</span><span class=p>.</span><span class=nx>run</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=8-장점과-단점>8. 장점과 단점<a hidden class=anchor aria-hidden=true href=#8-장점과-단점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>테스트 용이성</td><td>프레젠터와 모델을 분리하여 단위 테스트가 용이합니다.</td></tr><tr><td></td><td>유지보수성</td><td>각 구성 요소의 책임이 명확하여 코드 유지보수가 쉽습니다.</td></tr><tr><td>⚠ 단점</td><td>복잡성 증가</td><td>구성 요소 분리로 인해 초기 설계가 복잡할 수 있습니다.</td></tr><tr><td></td><td>코드량 증가</td><td>각 구성 요소의 인터페이스 정의로 인해 코드량이 증가할 수 있습니다.</td></tr></tbody></table><hr><h2 id=9-도전-과제-및-해결책>9. 도전 과제 및 해결책<a hidden class=anchor aria-hidden=true href=#9-도전-과제-및-해결책>#</a></h2><ul><li><p><strong>도전 과제</strong>: 프레젠터의 역할이 과도하게 증가하여 복잡성이 높아질 수 있습니다.</p></li><li><p><strong>해결책</strong>: 프레젠터를 기능별로 분리하거나, 헬퍼 클래스를 도입하여 책임을 분산시킵니다.</p></li></ul><hr><h2 id=10-분류-기준에-따른-종류-및-유형>10. 분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#10-분류-기준에-따른-종류-및-유형>#</a></h2><table><thead><tr><th>분류 기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>프레젠터와 뷰의 관계</td><td>Passive View</td><td>뷰는 단순히 프레젠터의 지시에 따라 동작합니다.</td></tr><tr><td></td><td>Supervising Controller</td><td>뷰가 일부 프레젠터의 역할을 수행합니다.</td></tr></tbody></table><hr><h2 id=11-실무-적용-예시>11. 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#11-실무-적용-예시>#</a></h2><table><thead><tr><th>분야</th><th>적용 사례</th><th>설명</th></tr></thead><tbody><tr><td>데스크톱 애플리케이션</td><td>PyQt 기반 GUI</td><td>MVP 패턴을 적용하여 UI 와 로직을 분리합니다.</td></tr><tr><td>웹 애플리케이션</td><td>JavaScript SPA</td><td>프레젠터를 통해 모델과 뷰를 연결하여 유지보수성을 높입니다.</td></tr></tbody></table><hr><h2 id=12-활용-사례>12. 활용 사례<a hidden class=anchor aria-hidden=true href=#12-활용-사례>#</a></h2><p><strong>상황</strong>: 사용자가 데이터를 입력하고 결과를 확인하는 간단한 애플리케이션.</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph LR
    View --&gt; Presenter
    Presenter --&gt; Model
    Model --&gt; Presenter
    Presenter --&gt; View
</pre><p><strong>Workflow</strong>:(<a href="https://stackoverflow.com/questions/3541625/mvp-presenter-model-communication?utm_source=chatgpt.com" title="MVP: Presenter-Model communication - python - Stack Overflow">stackoverflow.com</a>)</p><ol><li><p>사용자가 뷰에 데이터를 입력합니다.</p></li><li><p>뷰는 입력을 프레젠터에 전달합니다.</p></li><li><p>프레젠터는 모델에 데이터를 전달하여 처리합니다.</p></li><li><p>모델은 처리 결과를 프레젠터에 반환합니다.</p></li><li><p>프레젠터는 결과를 뷰에 전달하여 표시합니다.(<a href="https://java-design-patterns.com/patterns/model-view-presenter/?utm_source=chatgpt.com" title="Model-View-Presenter Pattern in Java: Enhancing UI Logic ...">java-design-patterns.com</a>)</p></li></ol><p><strong>역할</strong>:</p><ul><li><p><strong>View</strong>: 사용자 입력 수집 및 결과 표시.</p></li><li><p><strong>Presenter</strong>: 입력 처리 및 모델과의 중재.</p></li><li><p><strong>Model</strong>: 데이터 처리 및 비즈니스 로직 수행.</p></li></ul><hr><h2 id=13-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>13. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#13-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>구성 요소 분리</td><td>각 구성 요소의 책임을 명확히 분리합니다.</td><td>인터페이스를 통해 의존성을 최소화합니다.</td></tr><tr><td>테스트 전략</td><td>프레젠터와 모델에 대한 단위 테스트를 설계합니다.</td><td>모킹 (Mock) 을 활용하여 테스트를 수행합니다.</td></tr></tbody></table><hr><h2 id=14-최적화하기-위한-고려사항-및-주의할-점>14. 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#14-최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>프레젠터의 복잡성 관리</td><td>프레젠터의 책임이 과도하게 증가하지 않도록 관리합니다.</td><td>기능별로 프레젠터를 분리하거나 헬퍼 클래스를 도입합니다.</td></tr><tr><td>코드 중복 최소화</td><td>유사한 기능을 모듈화하여 재사용성을 높입니다.</td><td>공통 로직을 별도의 유틸리티 클래스로 분리합니다.</td></tr></tbody></table><hr><h2 id=15-기타-사항>15. 기타 사항<a hidden class=anchor aria-hidden=true href=#15-기타-사항>#</a></h2><ul><li><p><strong>문제</strong>: 프레젠터와 뷰 간의 순환 참조로 인해 메모리 누수가 발생할 수 있습니다.</p></li><li><p><strong>원인</strong>: 프레젠터와 뷰가 서로를 강하게 참조할 경우, 가비지 컬렉션이 제대로 이루어지지 않을 수 있습니다.</p></li><li><p><strong>해결 방법</strong>: 약한 참조 (Weak Reference) 를 사용하거나, 뷰가 프레젠터를 명시적으로 해제하도록 설계합니다.</p></li></ul><hr><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>아키텍처 패턴</td><td>MVP</td><td>Model–View–Presenter 패턴으로, UI, 비즈니스 로직, 데이터를 분리하여 설계하는 아키텍처 스타일입니다.</td></tr></tbody></table><p>물론입니다. 아래는 &ldquo;Model–View–Presenter Pattern&rdquo; 과 관련된 용어 정리를 이어서 작성한 내용입니다.</p><hr><h2 id=용어-정리-2>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-2>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>아키텍처 구성</td><td>Model</td><td>애플리케이션의 상태와 비즈니스 로직을 포함하며, 데이터를 저장하고 처리하는 계층입니다.</td></tr><tr><td>아키텍처 구성</td><td>View</td><td>사용자에게 UI 를 제공하고, 사용자 입력을 Presenter 에게 전달하는 구성요소입니다.</td></tr><tr><td>아키텍처 구성</td><td>Presenter</td><td>사용자 입력을 처리하고 Model 을 제어하며, 결과를 View 에 전달하는 중개자 역할을 합니다.</td></tr><tr><td>아키텍처 유형</td><td>Passive View</td><td>View 가 전적으로 Presenter 에 의해 제어되는 MVP 패턴의 한 방식입니다.</td></tr><tr><td>아키텍처 유형</td><td>Supervising Controller</td><td>View 가 간단한 모델 바인딩을 처리하며, 나머지는 Presenter 가 제어하는 구조입니다.</td></tr><tr><td>설계 원칙</td><td>Separation of Concerns</td><td>각 구성요소의 역할과 책임을 명확히 분리하여 코드 유지보수성과 확장성을 높이는 원칙입니다.</td></tr><tr><td>테스트 전략</td><td>Mocking</td><td>테스트 대상 외의 객체를 흉내내어 단위 테스트를 용이하게 하는 기법입니다.</td></tr><tr><td>프로그래밍 개념</td><td>Dependency Injection</td><td>외부 객체를 주입받아 내부 의존성을 줄이고 테스트 용이성을 높이는 설계 기법입니다.</td></tr></tbody></table><hr><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><p><a href=https://martinfowler.com/eaaDev/uiArchs.html>Martin Fowler의 GUI Architectures</a></p></li><li><p><a href=https://learn.microsoft.com/en-us/aspnet/web-forms/overview/presenting-and-managing-data/model-view-presenter/model-view-presenter>Microsoft Docs: MVP Design Pattern</a></p></li><li><p><a href=https://developer.android.com/>Android Developer Guide - MVP Pattern</a></p></li><li><p><a href=https://refactoring.guru/design-patterns/mvp>Refactoring.Guru - MVP Pattern 설명</a></p></li></ul><hr><p>좋습니다. 이어서 <strong>MVC vs MVP vs MVVM 비교 정리</strong>와 함께 MVP 의 전반적인 분석 내용을 마저 정리합니다.</p><hr><h2 id=-mvc-vs-mvp-vs-mvvm-비교>✅ MVC Vs MVP Vs MVVM 비교<a hidden class=anchor aria-hidden=true href=#-mvc-vs-mvp-vs-mvvm-비교>#</a></h2><table><thead><tr><th>구분</th><th>MVC (Model-View-Controller)</th><th>MVP (Model-View-Presenter)</th><th>MVVM (Model-View-ViewModel)</th></tr></thead><tbody><tr><td>구성요소</td><td>Model, View, Controller</td><td>Model, View, Presenter</td><td>Model, View, ViewModel</td></tr><tr><td>흐름 제어</td><td>Controller 가 흐름 제어</td><td>Presenter 가 모든 흐름 제어</td><td>ViewModel 이 데이터 바인딩 중심</td></tr><tr><td>View 역할</td><td>Controller 에 사용자 입력 전달</td><td>Presenter 에 전달만 수행</td><td>ViewModel 과 양방향 바인딩</td></tr><tr><td>테스트 용이성</td><td>중간 정도</td><td>가장 용이함</td><td>바인딩 구현에 따라 다름</td></tr><tr><td>플랫폼 활용</td><td>웹, 서버 앱</td><td>웹, WinForms, Android 등</td><td>WPF, Angular, React 등</td></tr><tr><td>데이터 바인딩</td><td>없음</td><td>없음</td><td>있음 (양방향 또는 단방향)</td></tr><tr><td>의존성 방향</td><td>View → Controller ← Model</td><td>View ←→ Presenter ←→ Model</td><td>View ←→ ViewModel ←→ Model</td></tr></tbody></table><hr><h2 id=-구조-및-아키텍처-다이어그램>✅ 구조 및 아키텍처 (다이어그램)<a hidden class=anchor aria-hidden=true href=#-구조-및-아키텍처-다이어그램>#</a></h2><pre class=mermaid>flowchart LR
  View --&gt; Presenter
  Presenter --&gt; Model
  Model --&gt; Presenter
  Presenter --&gt; View
</pre><ul><li><p><strong>View</strong>: 사용자 인터페이스 요소</p></li><li><p><strong>Presenter</strong>: 사용자 입력을 받아 처리하고 Model 을 조작하며 View 를 업데이트</p></li><li><p><strong>Model</strong>: 비즈니스 로직과 데이터 보유</p></li></ul><hr><h2 id=-주요-원리와-작동-원리>✅ 주요 원리와 작동 원리<a hidden class=anchor aria-hidden=true href=#-주요-원리와-작동-원리>#</a></h2><ul><li><p><strong>단방향 흐름</strong>: View 는 Presenter 에만 의존하며 Model 은 Presenter 에만 노출됨</p></li><li><p><strong>의존성 역전</strong>: Presenter 는 인터페이스를 통해 View 및 Model 에 의존 (테스트 및 확장성 강화)</p></li></ul><hr><h2 id=-mvp-의-구성-요소별-기능>✅ MVP 의 구성 요소별 기능<a hidden class=anchor aria-hidden=true href=#-mvp-의-구성-요소별-기능>#</a></h2><table><thead><tr><th>구성 요소</th><th>기능</th><th>책임</th></tr></thead><tbody><tr><td>Model</td><td>비즈니스 로직, 데이터 처리</td><td>DB 접근, 상태 유지</td></tr><tr><td>View</td><td>UI 표현, 사용자 입력 전달</td><td>인터페이스 표시</td></tr><tr><td>Presenter</td><td>이벤트 처리, 로직 실행</td><td>모델 제어 및 뷰 갱신</td></tr></tbody></table><hr><h2 id=-구현-기법>✅ 구현 기법<a hidden class=anchor aria-hidden=true href=#-구현-기법>#</a></h2><h3 id=javascript-mvp-예제>JavaScript MVP 예제<a hidden class=anchor aria-hidden=true href=#javascript-mvp-예제>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23>23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24>24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25>25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26>26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27>27</a>
</span><span class=lnt id=hl-9-28><a class=lnlinks href=#hl-9-28>28</a>
</span><span class=lnt id=hl-9-29><a class=lnlinks href=#hl-9-29>29</a>
</span><span class=lnt id=hl-9-30><a class=lnlinks href=#hl-9-30>30</a>
</span><span class=lnt id=hl-9-31><a class=lnlinks href=#hl-9-31>31</a>
</span><span class=lnt id=hl-9-32><a class=lnlinks href=#hl-9-32>32</a>
</span><span class=lnt id=hl-9-33><a class=lnlinks href=#hl-9-33>33</a>
</span><span class=lnt id=hl-9-34><a class=lnlinks href=#hl-9-34>34</a>
</span><span class=lnt id=hl-9-35><a class=lnlinks href=#hl-9-35>35</a>
</span><span class=lnt id=hl-9-36><a class=lnlinks href=#hl-9-36>36</a>
</span><span class=lnt id=hl-9-37><a class=lnlinks href=#hl-9-37>37</a>
</span><span class=lnt id=hl-9-38><a class=lnlinks href=#hl-9-38>38</a>
</span><span class=lnt id=hl-9-39><a class=lnlinks href=#hl-9-39>39</a>
</span><span class=lnt id=hl-9-40><a class=lnlinks href=#hl-9-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// View
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>LoginView</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>presenter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>presenter</span> <span class=o>=</span> <span class=nx>presenter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;loginBtn&#39;</span><span class=p>).</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s1>&#39;click&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s1>&#39;user&#39;</span><span class=p>).</span><span class=nx>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>.</span><span class=nx>presenter</span><span class=p>.</span><span class=nx>handleLogin</span><span class=p>(</span><span class=nx>user</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>showSuccess</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>alert</span><span class=p>(</span><span class=s1>&#39;Login success!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Presenter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>LoginPresenter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=nx>model</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>view</span> <span class=o>=</span> <span class=nx>view</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>model</span> <span class=o>=</span> <span class=nx>model</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nx>handleLogin</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>model</span><span class=p>.</span><span class=nx>validateUser</span><span class=p>(</span><span class=nx>user</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>.</span><span class=nx>view</span><span class=p>.</span><span class=nx>showSuccess</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Model
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>LoginModel</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>validateUser</span><span class=p>(</span><span class=nx>user</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>user</span> <span class=o>===</span> <span class=s1>&#39;admin&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>model</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>LoginModel</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>presenter</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>LoginPresenter</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=nx>model</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>view</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>LoginView</span><span class=p>(</span><span class=nx>presenter</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>presenter</span><span class=p>.</span><span class=nx>view</span> <span class=o>=</span> <span class=nx>view</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-장점과-단점>✅ 장점과 단점<a hidden class=anchor aria-hidden=true href=#-장점과-단점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>테스트 용이성</td><td>Presenter 는 독립 테스트 가능</td></tr><tr><td></td><td>유지보수성</td><td>View 와 로직 분리로 코드 가독성 높음</td></tr><tr><td></td><td>명확한 책임 분리</td><td>각 계층이 독립적으로 작동 가능</td></tr><tr><td>⚠ 단점</td><td>Boilerplate 코드</td><td>View 와 Presenter 사이 반복 코드 발생</td></tr><tr><td></td><td>복잡도 증가</td><td>작은 앱에도 오버엔지니어링 우려 있음</td></tr></tbody></table><p>👉 <strong>해결 방안</strong>:</p><ul><li><p>View 와 Presenter 간 자동 연결 코드 생성</p></li><li><p>코드 제너레이터나 프레임워크 (예: Android MVP 템플릿) 활용</p></li></ul><hr><h2 id=-실무-적용-예시>✅ 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#-실무-적용-예시>#</a></h2><table><thead><tr><th>분야</th><th>기술 스택</th><th>적용 예</th></tr></thead><tbody><tr><td>Android App</td><td>Java + Android SDK</td><td>Activity 는 View, Presenter 는 로직 담당</td></tr><tr><td>Web App</td><td>JavaScript + jQuery</td><td>View 는 DOM 조작, Presenter 는 이벤트 핸들</td></tr><tr><td>Desktop App</td><td>C# + WinForms</td><td>View 는 UI 제어, Presenter 는 비즈니스 흐름 담당</td></tr></tbody></table><hr><h2 id=-실무-적용-고려사항-및-최적화-방안>✅ 실무 적용 고려사항 및 최적화 방안<a hidden class=anchor aria-hidden=true href=#-실무-적용-고려사항-및-최적화-방안>#</a></h2><h3 id=실무-적용-고려사항>실무 적용 고려사항<a hidden class=anchor aria-hidden=true href=#실무-적용-고려사항>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>Presenter 설계</td><td>뷰에 의존하지 않도록 인터페이스 사용</td><td>Interface 로 추상화</td></tr><tr><td>View 단순화</td><td>UI 는 View 에서만 다룸</td><td>복잡한 상태 처리 Presenter 로 위임</td></tr><tr><td>테스트 가능성</td><td>Presenter 는 독립 테스트 가능하도록 구성</td><td>Mock 기반 테스트 도입</td></tr></tbody></table><h3 id=최적화-방안>최적화 방안<a hidden class=anchor aria-hidden=true href=#최적화-방안>#</a></h3><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>DI 적용</td><td>Presenter 의존성 주입으로 유연성 강화</td><td>DI 프레임워크 사용</td></tr><tr><td>State 관리</td><td>ViewModel 수준 상태 관리 구현</td><td>단순 데이터 클래스로 상태 전달</td></tr><tr><td>재사용성 확보</td><td>공통 Presenter 유틸 구성</td><td>기능 단위 분리 및 모듈화 적용</td></tr></tbody></table><hr><h2 id=-활용-사례>✅ 활용 사례<a hidden class=anchor aria-hidden=true href=#-활용-사례>#</a></h2><p><strong>상황</strong>: Android 기반 금융 앱의 로그인 기능</p><h3 id=시스템-구성>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성>#</a></h3><ul><li><p>View: <code>LoginActivity</code> (Android Activity)</p></li><li><p>Presenter: <code>LoginPresenter</code></p></li><li><p>Model: <code>UserRepository</code></p></li></ul><h3 id=다이어그램>다이어그램<a hidden class=anchor aria-hidden=true href=#다이어그램>#</a></h3><pre class=mermaid>flowchart LR
  LoginActivity -- onClick --&gt; LoginPresenter
  LoginPresenter -- validate --&gt; UserRepository
  UserRepository --&gt; LoginPresenter --&gt; LoginActivity
</pre><h3 id=workflow>Workflow<a hidden class=anchor aria-hidden=true href=#workflow>#</a></h3><ol><li><p>사용자가 로그인 버튼 클릭</p></li><li><p>Presenter 가 사용자 입력을 검증</p></li><li><p>Model 에서 사용자 인증 처리</p></li><li><p>결과를 Presenter 가 받아 View 에 전달</p></li></ol><h3 id=역할>역할<a hidden class=anchor aria-hidden=true href=#역할>#</a></h3><ul><li><p><strong>View</strong>: UI 입력 수집, 결과 표시</p></li><li><p><strong>Presenter</strong>: 로직 흐름 제어, 상태 처리</p></li><li><p><strong>Model</strong>: 인증 처리, 외부 API 연동</p></li></ul><hr><p>이후 단계로는 다음 내용도 제안드립니다:</p><ul><li><p>MVVM 과의 심화 비교</p></li><li><p>MVP 와 클린 아키텍처의 통합 전략</p></li><li><p>테스트 코드 예제 포함 MVP 프로젝트 구성</p></li></ul><p>필요하시면 바로 이어서 정리해드리겠습니다.</p><h2 id=model-view-presenter-pattern-mvp-패턴-종합-분석>Model-View-Presenter Pattern (MVP) 패턴 종합 분석<a hidden class=anchor aria-hidden=true href=#model-view-presenter-pattern-mvp-패턴-종합-분석>#</a></h2><h3 id=1-주제-분류-분석>1. 주제 분류 분석<a hidden class=anchor aria-hidden=true href=#1-주제-분류-분석>#</a></h3><p>제시된 분류를 검토한 결과, <strong>마지막 단계의 분류가 부적절</strong>합니다.</p><p><strong>현재 분류</strong>: <code>"Computer Science and Engineering" > "System and Software Architecture" > "Architecture" > "Architecture Styles" > "Structural" > "Layered" > "MVC (Model-View-Controller)"</code></p><p><strong>적절한 분류</strong>: <code>"Computer Science and Engineering" > "System and Software Architecture" > "Architecture" > "Architecture Styles" > "Structural" > "Layered" > "MVP (Model-View-Presenter)"</code></p><p>또는 <code>"Computer Science and Engineering" > "System and Software Architecture" > "Architecture" > "Architecture Styles" > "Structural" > "Presentation Layer Patterns" > "MVP (Model-View-Presenter)"</code></p><p><strong>근거</strong>: MVP 는 MVC 에서 파생되었지만 별개의 독립적인 아키텍처 패턴이며, 프레젠테이션 로직에서 관심사 분리를 위해 특별히 설계된 패턴입니다.</p><h3 id=2-요약-및-개요>2. 요약 및 개요<a hidden class=anchor aria-hidden=true href=#2-요약-및-개요>#</a></h3><p><strong>200 자 요약</strong>: Model-View-Presenter (MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, Presenter 가 &lsquo;middle-man&rsquo; 역할을 담당하여 모든 프레젠테이션 로직을 처리합니다. View 와 Model 간 직접 통신을 차단하고 인터페이스 기반 통신을 통해 관심사 분리와 테스트 용이성을 극대화합니다.</p><p><strong>250 자 개요</strong>: MVP 패턴은 1990 년대 Taligent 에서 시작되어 현재까지 널리 사용되는 UI 아키텍처 패턴입니다. 자동화된 단위 테스트 촉진과 프레젠테이션 로직의 관심사 분리 개선을 목적으로 합니다. Model(데이터), View(UI), Presenter(중재자) 로 구성되며, Passive View 와 Supervising Controller 두 가지 주요 변형이 있습니다. Android, 웹 애플리케이션, 데스크탑 애플리케이션 개발에서 특히 유용합니다.</p><h3 id=3-핵심-개념>3. 핵심 개념<a hidden class=anchor aria-hidden=true href=#3-핵심-개념>#</a></h3><p>MVP 패턴을 이해하기 위해 반드시 알아야 하는 핵심 개념들:</p><ul><li><strong>관심사 분리 (Separation of Concerns)</strong>: 사용자 인터페이스 (View) 를 애플리케이션 로직 (Presenter) 과 데이터/모델 계층에서 명확히 분리</li><li><strong>Presenter 의 중재자 역할</strong>: Presenter 가 Model 과 View 사이의 &ldquo;middle-man&rdquo; 기능을 수행</li><li><strong>인터페이스 기반 통신</strong>: View-Presenter 와 Presenter-Model 간 모든 통신이 인터페이스를 통해 이루어짐</li><li><strong>단방향 의존성</strong>: View 와 Model 이 서로의 존재를 알지 못하고 직접 통신하지 않음</li><li><strong>테스트 용이성</strong>: Presenter 를 View 와 독립적으로 테스트 가능</li><li><strong>일대일 관계</strong>: 일반적으로 하나의 Presenter 가 하나의 View 를 관리</li></ul><h3 id=4-배경-및-목적>4. 배경 및 목적<a hidden class=anchor aria-hidden=true href=#4-배경-및-목적>#</a></h3><h4 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h4><p>MVP 패턴은 1990 년대 초 Apple, IBM, Hewlett-Packard 의 합작 회사인 Taligent 에서 시작되었습니다. Taligent 의 C++ 기반 CommonPoint 환경에서 애플리케이션 개발을 위한 기본 프로그래밍 모델로 사용되었고, 이후 Java 로 이식되어 Mike Potel 의 논문을 통해 대중화되었습니다.</p><h4 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h4><ul><li><strong>자동화된 단위 테스트 촉진</strong>: UI 로직을 비즈니스 로직에서 분리하여 독립적인 테스트 가능</li><li><strong>프레젠테이션 로직의 관심사 분리 개선</strong>: UI 계층이 해야 할 것보다 더 많은 일을 하는 문제 해결</li><li><strong>MVC 의 한계 극복</strong>: MVC 에서 Controller 에 집중되는 비즈니스 로직 분산과 View-Model 간 결합도 감소</li></ul><h3 id=5-주요-원리-및-작동-원리-1>5. 주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#5-주요-원리-및-작동-원리-1>#</a></h3><h4 id=핵심-원칙-1>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙-1>#</a></h4><ol><li><strong>완전한 View-Model 분리</strong>: View 는 Model 에 대한 직접적인 지식이 없음</li><li><strong>Presenter 중심의 로직 처리</strong>: 모든 프레젠테이션 로직이 Presenter 에 집중</li><li><strong>인터페이스 기반 설계</strong>: 구성 요소 간 느슨한 결합 유지</li><li><strong>단일 책임 원칙</strong>: 각 구성 요소가 명확한 역할 분담</li></ol><h4 id=작동-원리-다이어그램>작동 원리 다이어그램<a hidden class=anchor aria-hidden=true href=#작동-원리-다이어그램>#</a></h4><pre class=mermaid>sequenceDiagram
    participant User
    participant View
    participant Presenter
    participant Model
    
    User-&gt;&gt;View: 사용자 입력
    View-&gt;&gt;Presenter: 이벤트 전달
    Presenter-&gt;&gt;Model: 데이터 요청/업데이트
    Model--&gt;&gt;Presenter: 데이터 반환
    Presenter-&gt;&gt;View: View 업데이트
    View--&gt;&gt;User: 결과 표시
</pre><h3 id=6-구조-및-아키텍처-1>6. 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#6-구조-및-아키텍처-1>#</a></h3><h4 id=mvp-아키텍처-다이어그램>MVP 아키텍처 다이어그램<a hidden class=anchor aria-hidden=true href=#mvp-아키텍처-다이어그램>#</a></h4><pre class=mermaid>graph TB
    User[User]
    View[View&lt;br/&gt;- UI 렌더링&lt;br/&gt;- 사용자 입력 처리&lt;br/&gt;- 이벤트 전달]
    Presenter[Presenter&lt;br/&gt;- 비즈니스 로직&lt;br/&gt;- View 상태 관리&lt;br/&gt;- Model 조작]
    Model[Model&lt;br/&gt;- 데이터 관리&lt;br/&gt;- 비즈니스 규칙&lt;br/&gt;- 외부 서비스 통신]
    
    User -.-&gt; View
    View --&gt; Presenter
    Presenter --&gt; View
    Presenter --&gt; Model
    Model --&gt; Presenter
    
    style View fill:#e1f5fe
    style Presenter fill:#f3e5f5
    style Model fill:#e8f5e8
</pre><h4 id=필수-구성요소>필수 구성요소<a hidden class=anchor aria-hidden=true href=#필수-구성요소>#</a></h4><h5 id=model>Model<a hidden class=anchor aria-hidden=true href=#model>#</a></h5><ul><li><strong>기능</strong>: 데이터 저장 계층으로 도메인 로직과 데이터베이스 및 네트워크 계층과의 통신 담당</li><li><strong>역할</strong>: API 를 통한 데이터 가져오기 및 저장, 데이터베이스 운영, 네트워크 통신, 기타 비즈니스 관련 로직 캡슐화</li><li><strong>특징</strong>: View 에 대한 지식이 전혀 없으며 독립적으로 테스트 가능</li></ul><h5 id=view>View<a hidden class=anchor aria-hidden=true href=#view>#</a></h5><ul><li><strong>기능</strong>: UI 계층으로 데이터 시각화 제공 및 Presenter 에 알리기 위한 사용자 행동 추적</li><li><strong>역할</strong>: 데이터를 표시하고 사용자 명령 (이벤트) 을 Presenter 에 라우팅하는 수동적 인터페이스</li><li><strong>특징</strong>: 비즈니스 로직 없이 순수한 UI 로직만 포함</li></ul><h5 id=presenter>Presenter<a hidden class=anchor aria-hidden=true href=#presenter>#</a></h5><ul><li><strong>기능</strong>: Model 에서 데이터를 가져와 표시할 내용을 결정하는 UI 로직 적용</li><li><strong>역할</strong>: Model 과 View 에 작용하여 저장소에서 데이터를 가져와 View 에 표시하기 위해 포맷</li><li><strong>특징</strong>: Model 과 View 간의 유일한 통신 경로</li></ul><h4 id=선택적-구성요소>선택적 구성요소<a hidden class=anchor aria-hidden=true href=#선택적-구성요소>#</a></h4><ul><li><strong>Contract Interface</strong>: View 와 Presenter 간 통신 인터페이스 정의</li><li><strong>Repository Pattern</strong>: 데이터 접근 추상화</li><li><strong>Service Layer</strong>: 복잡한 비즈니스 로직 처리</li><li><strong>Dependency Injection</strong>: 의존성 관리 및 테스트 용이성</li></ul><h3 id=7-구현-기법-1>7. 구현 기법<a hidden class=anchor aria-hidden=true href=#7-구현-기법-1>#</a></h3><h4 id=passive-view-패턴>Passive View 패턴<a hidden class=anchor aria-hidden=true href=#passive-view-패턴>#</a></h4><ul><li><p><strong>정의</strong>: Presenter 가 Model 의 변화를 반영하여 View 를 업데이트하며, View 는 Model 의 변화를 인식하지 못함</p></li><li><p><strong>구성</strong>: View 가 완전히 수동적이며 모든 UI 업데이트를 Presenter 가 담당</p></li><li><p><strong>목적</strong>: 최대한의 테스트 가능성 확보</p></li><li><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5>5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Presenter가 모든 View 업데이트 제어
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>presenter</span><span class=p>.</span><span class=nx>onDataLoaded</span> <span class=o>=</span> <span class=p>(</span><span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>view</span><span class=p>.</span><span class=nx>showUserName</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>view</span><span class=p>.</span><span class=nx>showUserEmail</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>email</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>view</span><span class=p>.</span><span class=nx>hideLoadingIndicator</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=supervising-controller-패턴>Supervising Controller 패턴<a hidden class=anchor aria-hidden=true href=#supervising-controller-패턴>#</a></h4><ul><li><p><strong>정의</strong>: View 가 간단한 데이터 바인딩을 직접 수행할 수 있으며 선언적으로 정의 가능</p></li><li><p><strong>구성</strong>: Presenter 는 Model 을 업데이트하고 선언적으로 지정할 수 없는 복잡한 UI 로직이 필요한 경우에만 View 상태를 조작</p></li><li><p><strong>목적</strong>: 코드 단순화와 데이터 바인딩 활용</p></li><li><p><strong>실제 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// View가 직접 데이터 바인딩 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>view</span><span class=p>.</span><span class=nx>bindUserData</span><span class=p>(</span><span class=nx>model</span><span class=p>.</span><span class=nx>userData</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Presenter는 복잡한 로직만 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>presenter</span><span class=p>.</span><span class=nx>handleComplexValidation</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=인터페이스-기반-구현>인터페이스 기반 구현<a hidden class=anchor aria-hidden=true href=#인터페이스-기반-구현>#</a></h4><ul><li><p><strong>정의</strong>: Contract 패턴을 통한 View-Presenter 간 통신</p></li><li><p><strong>구성</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Contract 인터페이스 정의
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>interface</span> <span class=nx>LoginContract</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>interface</span> <span class=nx>View</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>showProgress</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>hideProgress</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nx>showError</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>interface</span> <span class=nx>Presenter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>login</span><span class=p>(</span><span class=nx>username</span><span class=p>,</span> <span class=nx>password</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>목적</strong>: 느슨한 결합과 테스트 용이성</p></li><li><p><strong>실제 예시</strong>: Android MVP 에서 Contract 패턴 활용</p></li></ul><h3 id=8-장점과-단점-1>8. 장점과 단점<a hidden class=anchor aria-hidden=true href=#8-장점과-단점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td><strong>관심사 분리</strong></td><td>사용자 인터페이스 (View) 를 애플리케이션 로직 (Presenter) 과 데이터/모델 계층에서 명확히 분리하여 유지보수성과 테스트 가능성 향상</td></tr><tr><td></td><td><strong>테스트 용이성</strong></td><td>Presenter 가 대부분의 애플리케이션 로직을 포함하므로 View 와 독립적으로 테스트 가능</td></tr><tr><td></td><td><strong>유연성과 확장성</strong></td><td>View, Presenter, Model 간 잘 정의된 인터페이스로 한 구성 요소의 변경이 다른 구성 요소에 영향을 주지 않음</td></tr><tr><td></td><td><strong>코드 재사용성</strong></td><td>Presenter 의 비즈니스 로직과 Model 의 데이터 조작 작업을 다양한 View 에서 재사용 가능</td></tr><tr><td></td><td><strong>병렬 개발</strong></td><td>관심사 분리로 UI 디자이너와 개발자가 병렬로 작업 가능</td></tr><tr><td>⚠ 단점</td><td><strong>복잡성 증가</strong></td><td>MVC 와 같은 단순한 아키텍처보다 더 많은 보일러플레이트 코드와 개발 시간 필요</td></tr><tr><td></td><td><strong>학습 곡선</strong></td><td>패턴에 익숙하지 않은 개발자에게는 각 구성 요소의 책임과 상호작용 이해에 어려움</td></tr><tr><td></td><td><strong>잠재적 오버헤드</strong></td><td>작은 프로젝트나 단순한 UI 에서는 패턴의 이점보다 추가된 복잡성이 더 클 수 있음</td></tr><tr><td></td><td><strong>Presenter 비대화</strong></td><td>단일 책임 원칙을 따르지 않으면 모든 상호작용 인터페이스를 가진 단일 클래스 관리가 어려움</td></tr></tbody></table><h4 id=단점-해결-방법>단점 해결 방법<a hidden class=anchor aria-hidden=true href=#단점-해결-방법>#</a></h4><ul><li><strong>MVP 프레임워크 활용</strong>: 보일러플레이트 코드 자동 생성</li><li><strong>단일 책임 원칙 준수</strong>: Presenter 를 기능별로 분할</li><li><strong>의존성 주입 활용</strong>: 객체 간 결합도 감소</li><li><strong>프로젝트 규모 고려</strong>: 적절한 복잡성 수준 유지</li></ul><h3 id=9-도전-과제>9. 도전 과제<a hidden class=anchor aria-hidden=true href=#9-도전-과제>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td><strong>Presenter 크기 관리</strong></td><td>신중하지 않으면 Presenter 가 모든 것을 아는 거대한 클래스로 확장되는 경향</td><td>단일 책임 원칙에 따른 Presenter 분할, 컴포지션 패턴 활용</td></tr><tr><td><strong>메모리 누수</strong></td><td>View 에 대한 강한 참조로 인한 메모리 누수</td><td>WeakReference 사용, Lifecycle 인식 컴포넌트 활용</td></tr><tr><td><strong>복잡한 UI 로직</strong></td><td>복잡한 UI 상호작용 처리의 어려움</td><td>상태 머신 패턴, Command 패턴 조합 사용</td></tr><tr><td><strong>데이터 바인딩 제한</strong></td><td>UI 프레임워크의 바인딩 기능을 활용할 수 없음</td><td>Supervising Controller 패턴 적용 또는 MVVM 고려</td></tr></tbody></table><h3 id=10-분류-기준에-따른-종류-및-유형-1>10. 분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#10-분류-기준에-따른-종류-및-유형-1>#</a></h3><table><thead><tr><th>분류 기준</th><th>유형</th><th>특징</th><th>적용 사례</th></tr></thead><tbody><tr><td><strong>View 수동성</strong></td><td>Passive View</td><td>View 가 완전히 수동적이며 Controller 가 모든 View 업데이트 처리</td><td>최대 테스트 가능성이 필요한 엔터프라이즈 애플리케이션</td></tr><tr><td></td><td>Supervising Controller</td><td>View 가 간단한 데이터 바인딩을 직접 수행하고 Presenter 는 복잡한 상호작용 로직만 처리</td><td>데이터 바인딩을 지원하는 플랫폼</td></tr><tr><td><strong>플랫폼</strong></td><td>웹 MVP</td><td>ASP.NET WebForms 기반 구현</td><td>웹 애플리케이션 개발</td></tr><tr><td></td><td>데스크탑 MVP</td><td>Windows Forms, WPF 기반 구현</td><td>데스크탑 애플리케이션</td></tr><tr><td></td><td>모바일 MVP</td><td>Android, iOS 기반 구현</td><td>모바일 애플리케이션 개발</td></tr><tr><td><strong>구현 방식</strong></td><td>인터페이스 기반</td><td>Contract 패턴 활용</td><td>테스트 중심 개발</td></tr><tr><td></td><td>상속 기반</td><td>베이스 클래스 활용</td><td>빠른 프로토타이핑</td></tr></tbody></table><h3 id=11-실무-적용-예시-1>11. 실무 적용 예시<a hidden class=anchor aria-hidden=true href=#11-실무-적용-예시-1>#</a></h3><table><thead><tr><th>분야</th><th>애플리케이션 유형</th><th>MVP 적용 방식</th><th>주요 이점</th></tr></thead><tbody><tr><td><strong>모바일 개발</strong></td><td>Android 앱</td><td>Activity/Fragment 를 View 로, 비즈니스 로직을 Presenter 로 분리</td><td>UI 와 로직 분리로 테스트 용이성 확보</td></tr><tr><td><strong>웹 개발</strong></td><td>ASP.NET 애플리케이션</td><td>동일한 Model 과 Presenter 를 ASP.NET 웹과 Windows Forms 에서 사용</td><td>다중 플랫폼 지원</td></tr><tr><td><strong>데스크탑 개발</strong></td><td>Java Swing/JavaFX</td><td>복잡한 UI 와 비즈니스 로직이 있는 클라이언트 - 서버 애플리케이션</td><td>명확한 관심사 분리</td></tr><tr><td><strong>엔터프라이즈</strong></td><td>대규모 시스템</td><td>Application Controller 패턴과 결합하여 네비게이션 플로우 제어</td><td>복잡한 워크플로우 관리</td></tr></tbody></table><h3 id=12-활용-사례-android-로그인-애플리케이션>12. 활용 사례: Android 로그인 애플리케이션<a hidden class=anchor aria-hidden=true href=#12-활용-사례-android-로그인-애플리케이션>#</a></h3><h4 id=시나리오>시나리오<a hidden class=anchor aria-hidden=true href=#시나리오>#</a></h4><p>사용자가 ID/Password 를 입력하여 로그인하고, 성공 시 홈 화면으로 이동하는 Android 애플리케이션</p><h4 id=시스템-구성-1>시스템 구성<a hidden class=anchor aria-hidden=true href=#시스템-구성-1>#</a></h4><pre class=mermaid>classDiagram
    class LoginContract {
        &lt;&lt;interface&gt;&gt;
        +interface View
        +interface Presenter
    }
    
    class LoginActivity {
        +showProgress()
        +hideProgress()
        +showError(message)
        +navigateToHome()
    }
    
    class LoginPresenter {
        +login(username, password)
        +onDestroy()
    }
    
    class UserModel {
        +validateCredentials(username, password)
        +getUserData()
    }
    
    class UserRepository {
        +authenticate(username, password)
        +fetchUserProfile()
    }
    
    LoginActivity ..|&gt; LoginContract
    LoginPresenter ..|&gt; LoginContract
    LoginPresenter --&gt; UserModel
    UserModel --&gt; UserRepository
</pre><h4 id=워크플로우>워크플로우<a hidden class=anchor aria-hidden=true href=#워크플로우>#</a></h4><ol><li><strong>사용자 입력</strong>: 사용자가 LoginActivity 에서 ID/PW 입력 후 로그인 버튼 클릭</li><li><strong>이벤트 전달</strong>: LoginActivity 가 LoginPresenter 의 <code>login(username, password)</code> 메소드 호출</li><li><strong>인증 처리</strong>: LoginPresenter 가 UserModel 을 통해 인증 로직 실행</li><li><strong>데이터 접근</strong>: UserModel 이 UserRepository 에서 사용자 정보 확인</li><li><strong>결과 처리</strong>: 인증 결과에 따라 LoginPresenter 가 LoginActivity 에 결과 전달</li><li><strong>UI 업데이트</strong>: 성공 시 홈 화면 이동, 실패 시 에러 메시지 표시</li></ol><h4 id=mvp-역할-분담>MVP 역할 분담<a hidden class=anchor aria-hidden=true href=#mvp-역할-분담>#</a></h4><ul><li><strong>View (LoginActivity)</strong>: UI 이벤트 처리, 진행 상태 표시, 결과 화면 전환</li><li><strong>Presenter (LoginPresenter)</strong>: 인증 로직 조정, View 상태 관리, 에러 처리</li><li><strong>Model (UserModel)</strong>: 실제 인증 처리, 데이터 검증, 비즈니스 규칙 적용</li></ul><h3 id=13-실무에서-효과적으로-적용하기-위한-고려사항>13. 실무에서 효과적으로 적용하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#13-실무에서-효과적으로-적용하기-위한-고려사항>#</a></h3><table><thead><tr><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>프로젝트 규모 평가</strong></td><td>작은 프로젝트에서는 MVP 가 과도한 복잡성을 야기할 수 있음</td><td>프로젝트 복잡도와 팀 규모를 고려한 적절한 아키텍처 선택</td></tr><tr><td><strong>팀 역량 고려</strong></td><td>MVP 패턴에 대한 팀원들의 이해도 평가</td><td>충분한 교육과 가이드라인 제공, 코드 리뷰 강화</td></tr><tr><td><strong>인터페이스 설계</strong></td><td>View 와 Presenter 간 상호작용의 세분화 수준 결정</td><td>높은 수준의 인터페이스 유지, 과도한 세분화 지양</td></tr><tr><td><strong>테스트 전략</strong></td><td>단위 테스트와 통합 테스트 전략 수립</td><td>Presenter 중심의 테스트, Mock 객체 활용</td></tr><tr><td><strong>의존성 관리</strong></td><td>구성 요소 간 의존성 주입 방식 결정</td><td>DI 프레임워크 활용, 인터페이스 기반 설계</td></tr></tbody></table><h3 id=14-최적화하기-위한-고려사항>14. 최적화하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#14-최적화하기-위한-고려사항>#</a></h3><table><thead><tr><th>최적화 영역</th><th>고려사항</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>Presenter 크기 관리</strong></td><td>단일 책임 원칙 위반 시 거대한 클래스가 될 위험</td><td>기능별 Presenter 분할, 컴포지션 패턴 활용</td></tr><tr><td><strong>메모리 관리</strong></td><td>View 참조로 인한 메모리 누수 방지</td><td>WeakReference 사용, Lifecycle 관리</td></tr><tr><td><strong>성능 최적화</strong></td><td>불필요한 View 업데이트 방지</td><td>상태 변화 감지, 배치 업데이트</td></tr><tr><td><strong>코드 재사용성</strong></td><td>공통 로직의 재사용성 극대화</td><td>베이스 클래스, 유틸리티 클래스 활용</td></tr><tr><td><strong>프레임워크 활용</strong></td><td>보일러플레이트 코드 감소</td><td>MVP 지원 프레임워크나 라이브러리 사용</td></tr></tbody></table><h3 id=15-기타-사항-1>15. 기타 사항<a hidden class=anchor aria-hidden=true href=#15-기타-사항-1>#</a></h3><h4 id=주요-문제점과-해결방법>주요 문제점과 해결방법<a hidden class=anchor aria-hidden=true href=#주요-문제점과-해결방법>#</a></h4><table><thead><tr><th>문제</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방 방법</th><th>해결 방법</th></tr></thead><tbody><tr><td><strong>메모리 누수</strong></td><td>View 에 대한 강한 참조 유지</td><td>앱 크래시, 성능 저하</td><td>Memory Profiler 사용</td><td>WeakReference 사용, Lifecycle 인식</td><td>onDestroy 에서 참조 해제</td></tr><tr><td><strong>Presenter 비대화</strong></td><td>단일 책임 원칙 위반</td><td>유지보수 어려움, 테스트 복잡성</td><td>클래스 크기 모니터링</td><td>기능별 분할 설계</td><td>책임에 따른 Presenter 분리</td></tr><tr><td><strong>과도한 인터페이스</strong></td><td>불필요한 추상화</td><td>코드 복잡성 증가</td><td>코드 리뷰</td><td>실용적 설계 접근</td><td>필수 인터페이스만 유지</td></tr><tr><td><strong>테스트 복잡성</strong></td><td>의존성 관리 어려움</td><td>테스트 작성 어려움</td><td>테스트 커버리지 확인</td><td>DI 패턴 적용</td><td>Mock 프레임워크 활용</td></tr></tbody></table><h3 id=16-주제와-관련하여-주목할-내용>16. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#16-주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>비교 패턴</strong></td><td>MVC vs MVP vs MVVM</td><td>MVP 는 MVC 의 View-Model 결합 문제를 해결하고 MVVM 은 데이터 바인딩에 특화</td></tr><tr><td><strong>현대 프레임워크</strong></td><td>Android Architecture Components</td><td>MVVM 으로의 패러다임 전환과 LiveData, ViewModel 활용</td></tr><tr><td><strong>테스트 패턴</strong></td><td>Test Double Pattern</td><td>Mock, Stub, Fake 객체를 활용한 효과적인 MVP 테스트</td></tr><tr><td><strong>의존성 주입</strong></td><td>DI Container</td><td>Dagger, Hilt 를 활용한 MVP 구현 최적화</td></tr><tr><td><strong>함수형 프로그래밍</strong></td><td>Reactive MVP</td><td>RxJava, Coroutines 를 활용한 반응형 MVP 구현</td></tr></tbody></table><h3 id=17-하위-주제로-추가-학습-내용>17. 하위 주제로 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#17-하위-주제로-추가-학습-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>아키텍처 패턴</strong></td><td>Clean Architecture with MVP</td><td>MVP 를 Clean Architecture 에 통합하는 방법</td></tr><tr><td><strong>테스팅</strong></td><td>MVP Unit Testing Strategies</td><td>Presenter 중심의 효과적인 테스트 전략</td></tr><tr><td><strong>모바일 개발</strong></td><td>MVP in React Native</td><td>크로스 플랫폼에서의 MVP 적용 방법</td></tr><tr><td><strong>웹 개발</strong></td><td>MVP in Modern Web Frameworks</td><td>Angular, React 에서의 MVP 패턴 활용</td></tr><tr><td><strong>성능 최적화</strong></td><td>MVP Performance Patterns</td><td>대규모 애플리케이션에서의 MVP 성능 최적화</td></tr></tbody></table><h3 id=18-관련-분야별-추가-학습-내용>18. 관련 분야별 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#18-관련-분야별-추가-학습-내용>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 설계</strong></td><td>SOLID Principles in MVP</td><td>MVP 구현에서 SOLID 원칙 적용 방법</td></tr><tr><td><strong>디자인 패턴</strong></td><td>Observer Pattern Integration</td><td>MVP 와 Observer 패턴의 효과적인 결합</td></tr><tr><td><strong>모바일 아키텍처</strong></td><td>Android Jetpack with MVP</td><td>현대적 Android 개발에서의 MVP 활용</td></tr><tr><td><strong>웹 아키텍처</strong></td><td>Progressive Web Apps MVP</td><td>PWA 개발에서의 MVP 패턴 적용</td></tr><tr><td><strong>마이크로서비스</strong></td><td>Frontend Microservices MVP</td><td>마이크로 프론트엔드에서의 MVP 활용</td></tr></tbody></table><hr><h3 id=용어-정리-3>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-3>#</a></h3><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>아키텍처 패턴</strong></td><td>Passive View</td><td>View 가 완전히 수동적이며 Presenter 가 모든 UI 업데이트를 담당하는 MVP 변형</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>Supervising Controller</td><td>View 가 간단한 데이터 바인딩을 직접 수행할 수 있는 MVP 변형</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>Presentation Model</td><td>View Model 이라고도 하며, View 의 상태를 캡처하는 모델을 중심으로 하는 패턴</td></tr><tr><td><strong>설계 패턴</strong></td><td>Contract Pattern</td><td>View 와 Presenter 간 인터페이스를 정의하여 결합도를 낮추는 패턴</td></tr><tr><td><strong>설계 패턴</strong></td><td>Repository Pattern</td><td>데이터 접근 로직을 캡슐화하여 비즈니스 로직에서 분리하는 패턴</td></tr><tr><td><strong>설계 패턴</strong></td><td>Dependency Injection</td><td>객체 간 의존성을 외부에서 주입하여 결합도를 낮추는 기법</td></tr><tr><td><strong>테스팅</strong></td><td>Test Double</td><td>테스트에서 실제 객체를 대체하는 Mock, Stub, Fake 객체의 총칭</td></tr><tr><td><strong>테스팅</strong></td><td>Unit Testing</td><td>개별 구성 요소를 독립적으로 테스트하는 방법</td></tr><tr><td><strong>프로그래밍 원칙</strong></td><td>Separation of Concerns</td><td>프로그램을 구별되는 기능을 가진 섹션으로 분리하는 설계 원칙</td></tr><tr><td><strong>프로그래밍 원칙</strong></td><td>Single Responsibility Principle</td><td>하나의 클래스는 하나의 책임만 가져야 한다는 SOLID 원칙</td></tr></tbody></table><hr><h3 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter>Model–view–presenter - Wikipedia</a></li><li><a href=https://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/>MVP (Model View Presenter) Architecture Pattern in Android with Example - GeeksforGeeks</a></li><li><a href=https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/august/design-patterns-model-view-presenter>Design Patterns: Model View Presenter - Microsoft Learn</a></li><li><a href=https://java-design-patterns.com/patterns/model-view-presenter/>Model-View-Presenter Pattern in Java - Java Design Patterns</a></li><li><a href=https://www.baeldung.com/mvc-vs-mvp-pattern>Difference Between MVC and MVP Patterns - Baeldung</a></li><li><a href=https://www.scaler.com/topics/android/mvp-architecture-android/>MVP (Model View Presenter) Architecture Pattern in Android - Scaler Topics</a></li></ul><hr><p>Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, <strong>관심사 분리</strong> 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.<br>MVC 패턴에서 파생되었으며, 주로 Windows Forms, ASP.NET, Java Swing 애플리케이션에서 활용된다.</p><p>이 패턴은 1990 년대 Taligent 사에서 처음 도입되었으며, 현재까지 엔터프라이즈급 애플리케이션에서 구조적 안정성을 제공하는 핵심 아키텍처로 자리잡았다. UI 복잡도가 높은 프로젝트에서 체계적인 관리를 원한다면 MVP 구현을 적극 고려해볼 만하다.</p><p><figure><img alt="MVP pattern" loading=lazy src=/img/MVPSchema.png><figcaption>https://www.geeksforgeeks.org/mvp-model-view-presenter-architecture-pattern-in-android-with-example/</figcaption></figure></p><h4 id=핵심-구성-요소>핵심 구성 요소<a hidden class=anchor aria-hidden=true href=#핵심-구성-요소>#</a></h4><ul><li><strong>Model</strong>:<ul><li>데이터 저장/관리 및 비즈니스 로직 처리 담당.</li><li>데이터베이스 연동, API 통신, 캐싱 기능 수행.</li><li>UI 와 독립적으로 동작하여 재사용성 향상.</li></ul></li><li><strong>View</strong>:<ul><li>사용자 인터페이스 표시 및 입력 이벤트 전달.</li><li>수동적 (passive) 으로 Presenter 에 이벤트 전송.</li><li>데이터 표시 형식만 관리 (예: 텍스트 박스 값 표시).</li></ul></li><li><strong>Presenter</strong>:<ul><li>Model 과 View 의 중재자 역할.</li><li>사용자 입력 처리 → Model 업데이트 → 변경 사항 View 반영.</li><li>복잡한 UI 로직 캡슐화로 테스트 용이성 증대.</li></ul></li></ul><h4 id=작동-메커니즘>작동 메커니즘<a hidden class=anchor aria-hidden=true href=#작동-메커니즘>#</a></h4><ol><li>사용자가 View 와 상호작용하여 이벤트를 발생시킨다 (예: 로그인).</li><li>View → Presenter 에 이벤트 전달</li><li>Presenter 가 Model 에서 데이터 검증/처리</li><li>처리 결과를 View 에 반영 (예: " 로그인 성공 " 메시지 표시)</li></ol><h4 id=주요-장점>주요 장점<a hidden class=anchor aria-hidden=true href=#주요-장점>#</a></h4><ol><li><p><strong>유지보수성 향상</strong>:</p><ol><li>UI 변경 시 비즈니스 로직 영향 최소화.</li><li><em>예: 웹 → 모바일 전환 시 Presenter 재사용 가능</em></li></ol></li><li><p><strong>테스트 효율성</strong>:<br>Presenter 단위 테스트로 70% 이상 버그 감소 가능.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4>4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5>5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6>6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7>7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Java 테스트 예시</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>testFileLoading</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>MockView</span><span class=w> </span><span class=n>view</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MockView</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Presenter</span><span class=w> </span><span class=n>presenter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Presenter</span><span class=p>(</span><span class=n>view</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>presenter</span><span class=p>.</span><span class=na>loadFile</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>assertTrue</span><span class=p>(</span><span class=n>view</span><span class=p>.</span><span class=na>getDisplayedText</span><span class=p>().</span><span class=na>contains</span><span class=p>(</span><span class=s>&#34;Loaded&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>협업 강화</strong>:<br>디자이너 (UI)/개발자 (로직) 병렬 작업 가능.</p></li><li><p><strong>코드 재사용</strong>:<br>동일 Presenter 로 다양한 플랫폼 UI 구현 가능.</p></li></ol><h4 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h4><ul><li><strong>복잡성 증가:</strong> 단순한 애플리케이션에서는 MVP 패턴의 도입으로 오히려 구조가 복잡해질 수 있다.</li><li><strong>코드량 증가:</strong> 각 구성 요소의 분리로 인해 코드의 양이 늘어날 수 있다.</li></ul><h4 id=mvp-패턴의-변형>MVP 패턴의 변형<a hidden class=anchor aria-hidden=true href=#mvp-패턴의-변형>#</a></h4><ul><li><strong>패시브 뷰 (Passive View):</strong> 뷰는 사용자 입력을 프레젠터에게 전달하고, 프레젠터는 모든 로직을 처리한 후 뷰를 업데이트한다.</li><li><strong>슈퍼바이저 뷰 (Supervising View):</strong> 뷰가 일부 프레젠테이션 로직을 처리하며, 프레젠터는 복잡한 로직에 집중한다.</li></ul><h4 id=적용-시-고려사항>적용 시 고려사항<a hidden class=anchor aria-hidden=true href=#적용-시-고려사항>#</a></h4><ul><li><strong>소규모 프로젝트</strong>: 과도한 추상화로 인한 복잡성 증가 가능</li><li><strong>실시간 업데이트</strong>: Model 변경 시 View 자동 갱신 메커니즘 필요 (Observer 패턴 활용)</li><li><strong>프레임워크 선택</strong>: Android 의 경우 MVP 보다 MVVM 이 더 널리 사용되는 추세</li></ul><h4 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h4><p>Python 코드 예시</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34>34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35>35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36>36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37>37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38>38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39>39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40>40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41>41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42>42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43>43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44>44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45>45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46>46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47>47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48>48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49>49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50>50</a>
</span><span class=lnt id=hl-18-51><a class=lnlinks href=#hl-18-51>51</a>
</span><span class=lnt id=hl-18-52><a class=lnlinks href=#hl-18-52>52</a>
</span><span class=lnt id=hl-18-53><a class=lnlinks href=#hl-18-53>53</a>
</span><span class=lnt id=hl-18-54><a class=lnlinks href=#hl-18-54>54</a>
</span><span class=lnt id=hl-18-55><a class=lnlinks href=#hl-18-55>55</a>
</span><span class=lnt id=hl-18-56><a class=lnlinks href=#hl-18-56>56</a>
</span><span class=lnt id=hl-18-57><a class=lnlinks href=#hl-18-57>57</a>
</span><span class=lnt id=hl-18-58><a class=lnlinks href=#hl-18-58>58</a>
</span><span class=lnt id=hl-18-59><a class=lnlinks href=#hl-18-59>59</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Model</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UserModel</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>database</span> <span class=o>=</span> <span class=n>Database</span><span class=p>()</span>  <span class=c1># 데이터베이스 연결</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_user_data</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 데이터베이스에서 사용자 정보 조회</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>database</span><span class=o>.</span><span class=n>query</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;SELECT * FROM users WHERE id = </span><span class=si>{</span><span class=n>user_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>update_user</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 사용자 정보 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>database</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=s2>&#34;users&#34;</span><span class=p>,</span> <span class=n>user_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># View</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UserView</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>presenter</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>presenter</span> <span class=o>=</span> <span class=n>presenter</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>display_user_info</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user_data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 사용자 정보를 화면에 표시</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;이름: </span><span class=si>{</span><span class=n>user_data</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;이메일: </span><span class=si>{</span><span class=n>user_data</span><span class=p>[</span><span class=s1>&#39;email&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_user_input</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 사용자 입력 받기</span>
</span></span><span class=line><span class=cl>        <span class=n>name</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s2>&#34;이름을 입력하세요: &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>email</span> <span class=o>=</span> <span class=nb>input</span><span class=p>(</span><span class=s2>&#34;이메일을 입력하세요: &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;name&#34;</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=s2>&#34;email&#34;</span><span class=p>:</span> <span class=n>email</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Presenter</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UserPresenter</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>model</span><span class=p>,</span> <span class=n>view</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span> <span class=o>=</span> <span class=n>model</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>view</span> <span class=o>=</span> <span class=n>view</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>load_user</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>user_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 모델에서 데이터를 가져와서 뷰에 전달</span>
</span></span><span class=line><span class=cl>        <span class=n>user_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>get_user_data</span><span class=p>(</span><span class=n>user_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>view</span><span class=o>.</span><span class=n>display_user_info</span><span class=p>(</span><span class=n>user_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>update_user_info</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 뷰에서 입력받은 데이터를 모델에 전달</span>
</span></span><span class=line><span class=cl>        <span class=n>user_data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>view</span><span class=o>.</span><span class=n>get_user_input</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>model</span><span class=o>.</span><span class=n>update_user</span><span class=p>(</span><span class=n>user_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 전체 애플리케이션 구성</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 각 구성 요소 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span> <span class=o>=</span> <span class=n>UserModel</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>view</span> <span class=o>=</span> <span class=n>UserView</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>  <span class=c1># presenter는 나중에 설정</span>
</span></span><span class=line><span class=cl>    <span class=n>presenter</span> <span class=o>=</span> <span class=n>UserPresenter</span><span class=p>(</span><span class=n>model</span><span class=p>,</span> <span class=n>view</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>view</span><span class=o>.</span><span class=n>presenter</span> <span class=o>=</span> <span class=n>presenter</span>  <span class=c1># view에 presenter 연결</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 애플리케이션 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>presenter</span><span class=o>.</span><span class=n>load_user</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 사용자 ID 1의 정보 로드</span>
</span></span><span class=line><span class=cl>    <span class=n>presenter</span><span class=o>.</span><span class=n>update_user_info</span><span class=p>()</span>  <span class=c1># 사용자 정보 업데이트</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>main</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><hr><h3 id=참고-및-출처-3>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-3>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/architecture/>Architecture</a></li><li><a href=https://buenhyden.github.io/tags/architectue-styles/>Architectue-Styles</a></li><li><a href=https://buenhyden.github.io/tags/structural/>Structural</a></li><li><a href=https://buenhyden.github.io/tags/layered/>Layered</a></li><li><a href=https://buenhyden.github.io/tags/mvp/>MVP</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/structural/layered/mvc/model-view-viewmodel-pattern/><span class=title>« Prev</span><br><span>Model-View-ViewModel Pattern</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-design/reliability/master-slave-pattern/><span class=title>Next »</span><br><span>Master-Slave Pattern</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>