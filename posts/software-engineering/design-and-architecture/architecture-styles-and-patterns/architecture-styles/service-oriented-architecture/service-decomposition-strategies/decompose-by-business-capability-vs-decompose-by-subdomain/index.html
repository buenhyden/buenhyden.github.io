<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Decompose by Business Capability vs Decompose by Subdomain | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Architecture,Architectue-Styles,Service-Oriented,Microservices-Architecture,Decomposition"><meta name=description content="Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented-architecture/service-decomposition-strategies/decompose-by-business-capability-vs-decompose-by-subdomain/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented-architecture/service-decomposition-strategies/decompose-by-business-capability-vs-decompose-by-subdomain/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented-architecture/service-decomposition-strategies/decompose-by-business-capability-vs-decompose-by-subdomain/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Decompose by Business Capability vs Decompose by Subdomain"><meta property="og:description" content="Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-13T01:13:00+00:00"><meta property="article:modified_time" content="2024-11-13T01:13:00+00:00"><meta property="article:tag" content="System-and-Software-Architecture"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Architectue-Styles"><meta property="article:tag" content="Service-Oriented"><meta property="article:tag" content="Microservices-Architecture"><meta property="article:tag" content="Decomposition"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Decompose by Business Capability vs Decompose by Subdomain"><meta name=twitter:description content="Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Decompose by Business Capability vs Decompose by Subdomain","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented-architecture/service-decomposition-strategies/decompose-by-business-capability-vs-decompose-by-subdomain/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Decompose by Business Capability vs Decompose by Subdomain","name":"Decompose by Business Capability vs Decompose by Subdomain","description":"Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.","keywords":["System-and-Software-Architecture","Architecture","Architectue-Styles","Service-Oriented","Microservices-Architecture","Decomposition"],"articleBody":"Decompose by Business Capability vs. Decompose by Subdomain Decompose by Business Capability\n정의: 비즈니스의 기능적 역량을 중심으로 시스템을 분해하는 방식으로, 조직의 주요 기능(예: 판매, 마케팅, 고객 서비스 등)에 따라 모듈을 나누는 방법. 특징: 비즈니스의 주요 역량을 중심으로 서비스나 모듈을 설계. 시스템의 경계가 기능적인 책임(Functional Responsibility)에 맞춰 설정됨. 기술적으로 독립적이고 명확한 책임 분리가 가능. 조직 구조와 자연스럽게 연계되므로 비즈니스와 IT의 연계성이 높아짐. 비즈니스의 장기적 확장성과 변화를 쉽게 수용할 수 있음. 예시: 주문 관리 시스템(Order Management System), 재고 관리 시스템(Inventory Management System) 등으로 분할. Decompose by Subdomain\n정의: 도메인 주도 설계(DDD, Domain-Driven Design)에서 제안된 방식으로, 도메인을 여러 하위 도메인으로 나누고 이를 기반으로 시스템을 분해하는 방법. 특징: 도메인의 문제 공간을 세분화하여 각 하위 도메인을 중심으로 설계. 하위 도메인은 주 도메인(Core Domain), 지원 도메인(Supporting Domain), 일반 도메인(Generic Domain)으로 나뉘며 각각의 도메인에 맞는 설계를 적용. 기술적으로는 비즈니스 로직과 관련된 문제를 해결하는 데 최적화됨. 하위 도메인 간의 독립성이 강조되며, 상호작용을 최소화하도록 설계. 예시: 전자상거래 도메인에서 카탈로그 관리(Catalog Management), 결제 처리(Payment Processing), 배송 관리(Shipping Management) 등으로 분할. Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.\nDecompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.\n두 접근 방식은 상호 배타적이지 않으며, 프로젝트의 요구사항과 목표에 따라 혼합하여 사용할 수도 있다.\nDecompose By Business Capability vs. Decompose by Subdomain 비교 분석 비교 항목 Decompose by Business Capability Decompose by Subdomain 초점 비즈니스의 주요 기능적 역량 도메인의 문제 공간과 하위 도메인 설계 기준 조직의 기능적 책임과 역량 도메인 주도 설계 원칙과 하위 도메인 분리 적용 시점 비즈니스와 IT 간의 명확한 연계를 원할 때 도메인의 복잡성을 해결하고 문제를 구체화해야 할 때 구성 요소 간 경계 기능적 책임에 따라 경계 설정 도메인 경계(Context Boundary) 설정 조직 연계성 조직 구조와 자연스럽게 연결됨 조직 구조와는 독립적, 도메인 모델링 중심 확장성 비즈니스 기능 확장에 유리 도메인 요구사항 변화에 유리 복잡도 관리 조직적인 복잡도 관리에 유리 도메인의 세부적인 복잡도 관리에 유리 대표 사례 CRM 시스템, ERP 모듈 전자상거래의 하위 도메인(결제, 배송, 재고 관리 등) 도구 및 방법론 비즈니스 프로세스 분석, BPMN 도메인 주도 설계(DDD), Event Storming 강점 비즈니스와 기술의 연계성이 뛰어나며, 이해하기 쉽고 관리 용이 도메인의 복잡한 문제 해결에 최적화, 기술적 독립성이 뛰어남 단점 세부적인 도메인 문제 해결에는 한계 비즈니스 프로세스와 완전히 일치하지 않을 수 있음 참고 및 출처 ","wordCount":"372","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-11-13T01:13:00Z","dateModified":"2024-11-13T01:13:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented-architecture/service-decomposition-strategies/decompose-by-business-capability-vs-decompose-by-subdomain/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1 class="post-title entry-hint-parent">Decompose by Business Capability vs Decompose by Subdomain</h1><div class=post-description>Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다. Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.</div><div class=post-meta><span title='2024-11-13 01:13:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Engineering/Design%20and%20Architecture/Architecture%20Styles%20and%20Patterns/Architecture%20Styles/Service-oriented%20architecture/Service%20Decomposition%20Strategies/Decompose-by-Business-Capability-vs-Decompose-by-Subdomain.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#decompose-by-business-capability-vs-decompose-by-subdomain>Decompose by Business Capability vs. Decompose by Subdomain</a><ul><li><a href=#decompose-by-business-capability-vs-decompose-by-subdomain-비교-분석>Decompose By Business Capability vs. Decompose by Subdomain 비교 분석</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=decompose-by-business-capability-vs-decompose-by-subdomain>Decompose by Business Capability vs. Decompose by Subdomain<a hidden class=anchor aria-hidden=true href=#decompose-by-business-capability-vs-decompose-by-subdomain>#</a></h2><ol><li><p>Decompose by Business Capability</p><ul><li><strong>정의</strong>: 비즈니스의 기능적 역량을 중심으로 시스템을 분해하는 방식으로, 조직의 주요 기능(예: 판매, 마케팅, 고객 서비스 등)에 따라 모듈을 나누는 방법.</li><li><strong>특징</strong>:<ul><li>비즈니스의 주요 역량을 중심으로 서비스나 모듈을 설계.</li><li>시스템의 경계가 기능적인 책임(Functional Responsibility)에 맞춰 설정됨.</li><li>기술적으로 독립적이고 명확한 책임 분리가 가능.</li><li>조직 구조와 자연스럽게 연계되므로 비즈니스와 IT의 연계성이 높아짐.</li><li>비즈니스의 장기적 확장성과 변화를 쉽게 수용할 수 있음.</li></ul></li><li><strong>예시</strong>:<ul><li><strong>주문 관리 시스템(Order Management System)</strong>, <strong>재고 관리 시스템(Inventory Management System)</strong> 등으로 분할.</li></ul></li></ul></li><li><p>Decompose by Subdomain</p><ul><li><strong>정의</strong>: 도메인 주도 설계(DDD, Domain-Driven Design)에서 제안된 방식으로, 도메인을 여러 하위 도메인으로 나누고 이를 기반으로 시스템을 분해하는 방법.</li><li><strong>특징</strong>:<ul><li>도메인의 문제 공간을 세분화하여 각 하위 도메인을 중심으로 설계.</li><li>하위 도메인은 주 도메인(Core Domain), 지원 도메인(Supporting Domain), 일반 도메인(Generic Domain)으로 나뉘며 각각의 도메인에 맞는 설계를 적용.</li><li>기술적으로는 비즈니스 로직과 관련된 문제를 해결하는 데 최적화됨.</li><li>하위 도메인 간의 독립성이 강조되며, 상호작용을 최소화하도록 설계.</li></ul></li><li><strong>예시</strong>:<ul><li>전자상거래 도메인에서 <strong>카탈로그 관리(Catalog Management)</strong>, <strong>결제 처리(Payment Processing)</strong>, <strong>배송 관리(Shipping Management)</strong> 등으로 분할.</li></ul></li></ul></li></ol><p>Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.<br>Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.<br>두 접근 방식은 상호 배타적이지 않으며, 프로젝트의 요구사항과 목표에 따라 혼합하여 사용할 수도 있다.</p><h3 id=decompose-by-business-capability-vs-decompose-by-subdomain-비교-분석>Decompose By Business Capability vs. Decompose by Subdomain 비교 분석<a hidden class=anchor aria-hidden=true href=#decompose-by-business-capability-vs-decompose-by-subdomain-비교-분석>#</a></h3><table><thead><tr><th><strong>비교 항목</strong></th><th><strong>Decompose by Business Capability</strong></th><th><strong>Decompose by Subdomain</strong></th></tr></thead><tbody><tr><td><strong>초점</strong></td><td>비즈니스의 주요 기능적 역량</td><td>도메인의 문제 공간과 하위 도메인</td></tr><tr><td><strong>설계 기준</strong></td><td>조직의 기능적 책임과 역량</td><td>도메인 주도 설계 원칙과 하위 도메인 분리</td></tr><tr><td><strong>적용 시점</strong></td><td>비즈니스와 IT 간의 명확한 연계를 원할 때</td><td>도메인의 복잡성을 해결하고 문제를 구체화해야 할 때</td></tr><tr><td><strong>구성 요소 간 경계</strong></td><td>기능적 책임에 따라 경계 설정</td><td>도메인 경계(Context Boundary) 설정</td></tr><tr><td><strong>조직 연계성</strong></td><td>조직 구조와 자연스럽게 연결됨</td><td>조직 구조와는 독립적, 도메인 모델링 중심</td></tr><tr><td><strong>확장성</strong></td><td>비즈니스 기능 확장에 유리</td><td>도메인 요구사항 변화에 유리</td></tr><tr><td><strong>복잡도 관리</strong></td><td>조직적인 복잡도 관리에 유리</td><td>도메인의 세부적인 복잡도 관리에 유리</td></tr><tr><td><strong>대표 사례</strong></td><td>CRM 시스템, ERP 모듈</td><td>전자상거래의 하위 도메인(결제, 배송, 재고 관리 등)</td></tr><tr><td><strong>도구 및 방법론</strong></td><td>비즈니스 프로세스 분석, BPMN</td><td>도메인 주도 설계(DDD), Event Storming</td></tr><tr><td><strong>강점</strong></td><td>비즈니스와 기술의 연계성이 뛰어나며, 이해하기 쉽고 관리 용이</td><td>도메인의 복잡한 문제 해결에 최적화, 기술적 독립성이 뛰어남</td></tr><tr><td><strong>단점</strong></td><td>세부적인 도메인 문제 해결에는 한계</td><td>비즈니스 프로세스와 완전히 일치하지 않을 수 있음</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/system-and-software-architecture/>System-and-Software-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/architecture/>Architecture</a></li><li><a href=https://buenhyden.github.io/tags/architectue-styles/>Architectue-Styles</a></li><li><a href=https://buenhyden.github.io/tags/service-oriented/>Service-Oriented</a></li><li><a href=https://buenhyden.github.io/tags/microservices-architecture/>Microservices-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/decomposition/>Decomposition</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/use-cases/industry-patterns/warehouse-control-system/><span class=title>« Prev</span><br><span>WCS(Warehouse Control System)</span>
</a><a class=next href=https://buenhyden.github.io/posts/systems-and-infrastructure/database-systems/database-fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/><span class=title>Next »</span><br><span>ER(Entity-Relationship) 모델링</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>