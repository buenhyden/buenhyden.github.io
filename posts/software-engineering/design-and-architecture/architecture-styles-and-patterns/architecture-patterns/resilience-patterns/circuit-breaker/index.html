<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Circuit Breaker | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,MSA-Patterns,Reliability,Circuit-Breaker-Pattern"><meta name=description content="서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/circuit-breaker/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/circuit-breaker/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/circuit-breaker/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/circuit-breaker/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Circuit Breaker"><meta property="og:description" content="서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Circuit Breaker"><meta name=twitter:description content="서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Circuit Breaker","item":"https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/circuit-breaker/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Circuit Breaker</h1><div class=post-description>서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.</div></header><div class=post-content><h2 id=circuit-breaker>Circuit Breaker<a hidden class=anchor aria-hidden=true href=#circuit-breaker>#</a></h2><p>아래는 &ldquo;Circuit Breaker Pattern(서킷 브레이커 패턴)&rdquo; 에 대한 체계적이고 심층적인 조사, 분석, 정리입니다.</p><hr><h2 id=1-태그-tag>1. 태그 (Tag)<a hidden class=anchor aria-hidden=true href=#1-태그-tag>#</a></h2><ul><li><strong>Resilience-Pattern</strong></li><li><strong>Fault-Tolerance</strong></li><li><strong>Distributed-Systems</strong></li><li><strong>Error-Handling</strong></li></ul><hr><h2 id=2-분류-구조-적합성-분석>2. 분류 구조 적합성 분석<a hidden class=anchor aria-hidden=true href=#2-분류-구조-적합성-분석>#</a></h2><p><strong>현재 분류 구조</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Computer Science and Engineering
</span></span><span class=line><span class=cl>└─ Software Engineering
</span></span><span class=line><span class=cl>   └─ Design and Architecture
</span></span><span class=line><span class=cl>      └─ Architecture Patterns
</span></span><span class=line><span class=cl>         └─ Resilience Patterns
</span></span></code></pre></td></tr></table></div></div><p><strong>분석 및 근거</strong><br>Circuit Breaker Pattern 은 시스템의 내결함성 (Resilience) 과 신뢰성을 높이기 위해, 장애 발생 시 일정 시간 동안 요청을 차단하여 시스템의 자원 고갈과 장애 전파를 방지하는 설계 패턴입니다.<br>이 패턴은 &ldquo;Architecture Patterns > Resilience Patterns&rdquo; 에 포함되어야 하며, &ldquo;Software Engineering > Design and Architecture&rdquo; 계층 아래에 위치하는 것이 적절합니다.<br>따라서, 현재 분류 구조는 주제의 특성과 실무적 중요성 모두를 반영하고 있습니다.</p><hr><h2 id=3-요약-200-자-내외>3. 요약 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#3-요약-200-자-내외>#</a></h2><p>Circuit Breaker Pattern 은 장애 발생 시 일정 시간 동안 요청을 차단하여, 불필요한 자원 낭비와 장애 전파를 방지하는 내결함성 설계 패턴입니다.</p><hr><h2 id=4-개요-250-자-내외>4. 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#4-개요-250-자-내외>#</a></h2><p>Circuit Breaker Pattern 은 외부 시스템 호출, 데이터베이스 쿼리 등에서 장애가 반복적으로 발생할 때, 일정 시간 동안 요청을 차단하여 시스템의 자원 고갈과 장애 전파를 방지하는 내결함성 및 신뢰성 향상 패턴입니다.<br>주로 분산 시스템, 마이크로서비스 환경에서 사용됩니다.</p><hr><h2 id=5-핵심-개념>5. 핵심 개념<a hidden class=anchor aria-hidden=true href=#5-핵심-개념>#</a></h2><ul><li><strong>정의 및 목적</strong><ul><li>Circuit Breaker Pattern 은 장애가 반복적으로 발생할 때, 일정 시간 동안 요청을 차단하여 불필요한 자원 낭비와 장애 전파를 방지하는 패턴입니다.</li><li>목적은 시스템의 신뢰성, 내결함성, 자원 효율성, 그리고 장애 전파 방지입니다.</li></ul></li><li><strong>실무 연관성</strong><ul><li>실무에서는 외부 API 호출, 데이터베이스 쿼리, 분산 시스템 간 통신 등 다양한 작업에 적용됩니다.</li><li>내결함성, 신뢰성, 서비스 품질 향상에 필수적인 요소로 작용합니다.</li></ul></li></ul><hr><h2 id=6-세부-조사-내용>6. 세부 조사 내용<a hidden class=anchor aria-hidden=true href=#6-세부-조사-내용>#</a></h2><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><ul><li><strong>분산 시스템의 복잡성 증가</strong><ul><li>여러 서비스가 상호작용하는 환경에서 장애가 연쇄적으로 전파될 위험이 높아졌습니다.</li></ul></li><li><strong>불필요한 자원 낭비</strong><ul><li>장애 상황에서도 계속 요청을 시도하면 자원 (스레드, 메모리 등) 이 불필요하게 소모됩니다.</li></ul></li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ul><li><strong>장애 전파 방지</strong><ul><li>장애가 연쇄적으로 전파되는 것을 방지하여 시스템 전체의 안정성을 높입니다.</li></ul></li><li><strong>자원 효율성</strong><ul><li>불필요한 자원 소모를 줄여 시스템의 효율성을 높입니다.</li></ul></li><li><strong>신뢰성 및 내결함성</strong><ul><li>시스템의 신뢰성과 내결함성을 높여 사용자 경험을 개선합니다.</li></ul></li></ul><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li><strong>요청 차단</strong><ul><li>장애가 반복적으로 발생하면 일정 시간 동안 요청을 차단합니다.</li></ul></li><li><strong>자동 복구</strong><ul><li>일정 시간이 지나면 요청을 다시 허용하여 시스템이 복구되었는지 확인합니다.</li></ul></li><li><strong>장애 전파 방지</strong><ul><li>장애가 다른 서비스나 시스템에 전파되는 것을 방지합니다.</li></ul></li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li><strong>상태 기반</strong><ul><li>CLOSED(정상), OPEN(차단), HALF-OPEN(부분 복구) 상태로 동작합니다.</li></ul></li><li><strong>자동화</strong><ul><li>장애 감지, 요청 차단, 복구 시도 등이 자동으로 이루어집니다.</li></ul></li><li><strong>Low-risk(저위험)</strong><ul><li>불필요한 자원 낭비와 장애 전파를 방지하여 시스템 전체의 위험을 줄입니다.</li></ul></li></ul><h3 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h3><ul><li><strong>Fail Fast(빠른 실패)</strong><ul><li>장애 발생 시 즉시 실패 처리를 하여 시스템의 복잡성과 장애 전파를 방지합니다.</li></ul></li><li><strong>Graceful Degradation(우아한 성능 저하)</strong><ul><li>장애 발생 시 핵심 기능은 유지하면서 일부 기능만 저하시키는 방식으로 동작합니다.</li></ul></li><li><strong>Resource Management(자원 관리)</strong><ul><li>자원을 효율적으로 관리하여 시스템의 확장성과 안정성을 높입니다.</li></ul></li></ul><h3 id=주요-원리-및-작동-원리>주요 원리 및 작동 원리<a hidden class=anchor aria-hidden=true href=#주요-원리-및-작동-원리>#</a></h3><p><strong>다이어그램 (Text)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span><span class=lnt id=hl-1-8><a class=lnlinks href=#hl-1-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stateDiagram-v2
</span></span><span class=line><span class=cl>    [*] --&gt; CLOSED
</span></span><span class=line><span class=cl>    CLOSED --&gt; OPEN: 장애 발생(임계치 초과)
</span></span><span class=line><span class=cl>    OPEN --&gt; HALF_OPEN: 일정 시간 후
</span></span><span class=line><span class=cl>    HALF_OPEN --&gt; CLOSED: 요청 성공
</span></span><span class=line><span class=cl>    HALF_OPEN --&gt; OPEN: 요청 실패
</span></span><span class=line><span class=cl>    HALF_OPEN --&gt; [*]: 장애 지속
</span></span><span class=line><span class=cl>    CLOSED --&gt; [*]: 정상 종료
</span></span></code></pre></td></tr></table></div></div><p><strong>설명</strong></p><ul><li><strong>CLOSED</strong>: 정상 상태, 요청 허용</li><li><strong>OPEN</strong>: 장애 발생, 요청 차단</li><li><strong>HALF-OPEN</strong>: 일정 시간 후 요청을 다시 허용하여 시스템이 복구되었는지 확인</li><li><strong>CLOSED</strong>: 요청이 성공하면 다시 정상 상태로 전환</li><li><strong>OPEN</strong>: 요청이 실패하면 다시 차단 상태로 전환</li></ul><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><p><strong>구성 요소</strong></p><table><thead><tr><th>항목</th><th>기능 및 역할</th></tr></thead><tbody><tr><td>Client</td><td>요청을 시작하고, 결과 또는 실패를 처리하는 주체</td></tr><tr><td>Operation</td><td>실제로 실행되는 작업 (예: 외부 API 호출, 데이터베이스 쿼리 등)</td></tr><tr><td>CircuitBreaker</td><td>장애 감지, 요청 차단, 복구 시도 등 Circuit Breaker 상태 관리</td></tr></tbody></table><p><strong>필수 구성요소</strong></p><ul><li><strong>Client</strong>: 요청을 시작하고 결과를 처리</li><li><strong>Operation</strong>: 실제 작업 수행</li><li><strong>CircuitBreaker</strong>: 장애 감지 및 요청 차단, 복구 시도</li></ul><p><strong>선택 구성요소</strong></p><ul><li><strong>Fallback Handler</strong>: 요청 차단 시 대체 동작을 수행하는 핸들러</li><li><strong>Logging Module</strong>: 장애, 요청 차단, 복구 등 이벤트 로그 기록</li></ul><p><strong>구조 다이어그램 (Text)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+---------------------+
</span></span><span class=line><span class=cl>|      Client         |
</span></span><span class=line><span class=cl>+----------+----------+
</span></span><span class=line><span class=cl>           |
</span></span><span class=line><span class=cl>           v
</span></span><span class=line><span class=cl>+---------------------+
</span></span><span class=line><span class=cl>|   CircuitBreaker    |
</span></span><span class=line><span class=cl>+----------+----------+
</span></span><span class=line><span class=cl>           |
</span></span><span class=line><span class=cl>           v
</span></span><span class=line><span class=cl>+---------------------+
</span></span><span class=line><span class=cl>|     Operation       |
</span></span><span class=line><span class=cl>+---------------------+
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=7-구현-기법>7. 구현 기법<a hidden class=anchor aria-hidden=true href=#7-구현-기법>#</a></h2><table><thead><tr><th>기법</th><th>정의 및 목적</th><th>예시 (시스템 구성, 시나리오)</th></tr></thead><tbody><tr><td>상태 기반</td><td>CLOSED, OPEN, HALF-OPEN 상태로 동작</td><td>외부 API 호출 시 장애 발생 시 요청 차단</td></tr><tr><td>임계치 설정</td><td>장애 발생 임계치 (예: 실패 횟수, 실패율) 설정</td><td>5 회 연속 실패 시 OPEN 상태로 전환</td></tr><tr><td>복구 시도</td><td>일정 시간 후 HALF-OPEN 상태로 전환하여 복구 시도</td><td>30 초 후 HALF-OPEN 상태로 전환, 요청 재시도</td></tr><tr><td>Polly 라이브러리</td><td>.NET 환경에서 Circuit Breaker 를 쉽게 구현할 수 있는 라이브러리</td><td>Polly 의 AddCircuitBreaker 사용</td></tr></tbody></table><hr><h2 id=8-장점>8. 장점<a hidden class=anchor aria-hidden=true href=#8-장점>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>장점</td><td>장애 전파 방지</td><td>장애가 연쇄적으로 전파되는 것을 방지하여 시스템 전체의 안정성 향상</td></tr><tr><td></td><td>자원 효율성</td><td>불필요한 자원 소모를 줄여 시스템의 효율성 향상</td></tr><tr><td></td><td>신뢰성 및 내결함성</td><td>시스템의 신뢰성과 내결함성을 높여 사용자 경험 개선</td></tr><tr><td></td><td>빠른 복구</td><td>장애 발생 시 빠르게 요청을 차단하여 시스템이 빠르게 복구할 수 있음</td></tr></tbody></table><hr><h2 id=9-단점과-문제점-그리고-해결방안>9. 단점과 문제점 그리고 해결방안<a hidden class=anchor aria-hidden=true href=#9-단점과-문제점-그리고-해결방안>#</a></h2><h3 id=단점>단점<a hidden class=anchor aria-hidden=true href=#단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>단점</td><td>과도한 차단</td><td>장애 감지가 민감할 경우 불필요한 요청 차단이 발생할 수 있음</td><td>장애 감지 기준 조정</td></tr><tr><td></td><td>대체 동작 필요</td><td>요청 차단 시 대체 동작이 없으면 서비스 품질 저하 가능</td><td>Fallback Pattern 적용</td></tr></tbody></table><h3 id=문제점>문제점<a hidden class=anchor aria-hidden=true href=#문제점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>문제점</td><td>장애 감지 오류</td><td>장애 감지 기준이 부적절</td><td>불필요한 요청 차단</td><td>로그, 모니터링</td><td>장애 감지 기준 튜닝</td><td>동적 장애 감지 기준 적용</td></tr><tr><td></td><td>대체 동작 미구현</td><td>대체 동작 미구현</td><td>서비스 품질 저하</td><td>테스트, 모니터링</td><td>대체 동작 구현</td><td>Fallback Pattern 적용</td></tr></tbody></table><hr><h2 id=10-도전-과제>10. 도전 과제<a hidden class=anchor aria-hidden=true href=#10-도전-과제>#</a></h2><table><thead><tr><th>과제</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>동적 장애 감지 기준</td><td>시스템 환경 변화</td><td>불필요한 요청 차단</td><td>모니터링, 로그</td><td>동적 장애 감지 기준 적용</td><td>머신러닝, 통계 기반 적용</td></tr><tr><td>대체 동작 표준화</td><td>비즈니스 요구 다양</td><td>서비스 품질 저하</td><td>테스트, 모니터링</td><td>표준화된 대체 동작 정의</td><td>프레임워크, 라이브러리화</td></tr></tbody></table><hr><h2 id=11-분류-기준에-따른-종류-및-유형>11. 분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#11-분류-기준에-따른-종류-및-유형>#</a></h2><table><thead><tr><th>기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>적용 대상</td><td>네트워크 호출</td><td>외부 API, 서비스 호출 시 적용</td></tr><tr><td></td><td>데이터베이스 쿼리</td><td>데이터베이스 쿼리 시 적용</td></tr><tr><td></td><td>파일 I/O</td><td>파일 읽기/쓰기 시 적용</td></tr><tr><td>구현 방식</td><td>상태 기반</td><td>CLOSED, OPEN, HALF-OPEN 상태로 동작</td></tr><tr><td></td><td>임계치 기반</td><td>실패 횟수, 실패율 등 임계치 설정</td></tr></tbody></table><hr><h2 id=12-실무-사용-예시>12. 실무 사용 예시<a hidden class=anchor aria-hidden=true href=#12-실무-사용-예시>#</a></h2><table><thead><tr><th>사용 예시</th><th>목적</th><th>효과</th></tr></thead><tbody><tr><td>외부 API 호출</td><td>장애 전파 방지</td><td>서비스 신뢰성 향상</td></tr><tr><td>데이터베이스 쿼리</td><td>자원 효율성</td><td>데이터 가용성 향상</td></tr><tr><td>파일 I/O</td><td>장애 전파 방지</td><td>파일 접근성 향상</td></tr></tbody></table><hr><h2 id=13-활용-사례>13. 활용 사례<a hidden class=anchor aria-hidden=true href=#13-활용-사례>#</a></h2><p><strong>사례: 온라인 결제 서비스</strong></p><ul><li><strong>시스템 구성</strong><ul><li>결제 서비스 → 외부 결제 게이트웨이 호출</li></ul></li><li><strong>Workflow</strong><ol><li>결제 요청 발생</li><li>결제 서비스가 결제 게이트웨이 호출</li><li>연속 실패 시 Circuit Breaker 가 OPEN 상태로 전환, 요청 차단</li><li>일정 시간 후 HALF-OPEN 상태로 전환, 요청 재시도</li><li>요청 성공 시 CLOSED 상태로 복구, 실패 시 다시 OPEN 상태로 전환</li></ol></li><li><strong>Circuit Breaker Pattern 의 역할</strong><ul><li>결제 게이트웨이 장애 시 요청 차단 및 장애 전파 방지</li><li>결제 서비스의 신뢰성 및 사용자 경험 향상</li></ul></li><li><strong>유무에 따른 차이</strong><ul><li>Circuit Breaker Pattern 미적용 시: 장애가 연쇄적으로 전파되어 전체 시스템 장애 가능</li><li>Circuit Breaker Pattern 적용 시: 장애 전파 방지 및 시스템 신뢰성 향상</li></ul></li></ul><hr><h2 id=14-구현-예시>14. 구현 예시<a hidden class=anchor aria-hidden=true href=#14-구현-예시>#</a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span><span class=lnt id=hl-3-16><a class=lnlinks href=#hl-3-16>16</a>
</span><span class=lnt id=hl-3-17><a class=lnlinks href=#hl-3-17>17</a>
</span><span class=lnt id=hl-3-18><a class=lnlinks href=#hl-3-18>18</a>
</span><span class=lnt id=hl-3-19><a class=lnlinks href=#hl-3-19>19</a>
</span><span class=lnt id=hl-3-20><a class=lnlinks href=#hl-3-20>20</a>
</span><span class=lnt id=hl-3-21><a class=lnlinks href=#hl-3-21>21</a>
</span><span class=lnt id=hl-3-22><a class=lnlinks href=#hl-3-22>22</a>
</span><span class=lnt id=hl-3-23><a class=lnlinks href=#hl-3-23>23</a>
</span><span class=lnt id=hl-3-24><a class=lnlinks href=#hl-3-24>24</a>
</span><span class=lnt id=hl-3-25><a class=lnlinks href=#hl-3-25>25</a>
</span><span class=lnt id=hl-3-26><a class=lnlinks href=#hl-3-26>26</a>
</span><span class=lnt id=hl-3-27><a class=lnlinks href=#hl-3-27>27</a>
</span><span class=lnt id=hl-3-28><a class=lnlinks href=#hl-3-28>28</a>
</span><span class=lnt id=hl-3-29><a class=lnlinks href=#hl-3-29>29</a>
</span><span class=lnt id=hl-3-30><a class=lnlinks href=#hl-3-30>30</a>
</span><span class=lnt id=hl-3-31><a class=lnlinks href=#hl-3-31>31</a>
</span><span class=lnt id=hl-3-32><a class=lnlinks href=#hl-3-32>32</a>
</span><span class=lnt id=hl-3-33><a class=lnlinks href=#hl-3-33>33</a>
</span><span class=lnt id=hl-3-34><a class=lnlinks href=#hl-3-34>34</a>
</span><span class=lnt id=hl-3-35><a class=lnlinks href=#hl-3-35>35</a>
</span><span class=lnt id=hl-3-36><a class=lnlinks href=#hl-3-36>36</a>
</span><span class=lnt id=hl-3-37><a class=lnlinks href=#hl-3-37>37</a>
</span><span class=lnt id=hl-3-38><a class=lnlinks href=#hl-3-38>38</a>
</span><span class=lnt id=hl-3-39><a class=lnlinks href=#hl-3-39>39</a>
</span><span class=lnt id=hl-3-40><a class=lnlinks href=#hl-3-40>40</a>
</span><span class=lnt id=hl-3-41><a class=lnlinks href=#hl-3-41>41</a>
</span><span class=lnt id=hl-3-42><a class=lnlinks href=#hl-3-42>42</a>
</span><span class=lnt id=hl-3-43><a class=lnlinks href=#hl-3-43>43</a>
</span><span class=lnt id=hl-3-44><a class=lnlinks href=#hl-3-44>44</a>
</span><span class=lnt id=hl-3-45><a class=lnlinks href=#hl-3-45>45</a>
</span><span class=lnt id=hl-3-46><a class=lnlinks href=#hl-3-46>46</a>
</span><span class=lnt id=hl-3-47><a class=lnlinks href=#hl-3-47>47</a>
</span><span class=lnt id=hl-3-48><a class=lnlinks href=#hl-3-48>48</a>
</span><span class=lnt id=hl-3-49><a class=lnlinks href=#hl-3-49>49</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// Circuit Breaker Pattern 구현 예시 (JavaScript)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>CircuitBreaker</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>constructor</span><span class=p>(</span><span class=nx>failureThreshold</span><span class=p>,</span> <span class=nx>recoveryTimeout</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>failureThreshold</span> <span class=o>=</span> <span class=nx>failureThreshold</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>recoveryTimeout</span> <span class=o>=</span> <span class=nx>recoveryTimeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>failures</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>state</span> <span class=o>=</span> <span class=s1>&#39;CLOSED&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=p>.</span><span class=nx>nextAttempt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kr>async</span> <span class=nx>execute</span><span class=p>(</span><span class=nx>request</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span> <span class=o>===</span> <span class=s1>&#39;OPEN&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span> <span class=o>&gt;</span> <span class=k>this</span><span class=p>.</span><span class=nx>nextAttempt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>state</span> <span class=o>=</span> <span class=s1>&#39;HALF_OPEN&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Circuit breaker is OPEN&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>request</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>.</span><span class=nx>failures</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>.</span><span class=nx>state</span> <span class=o>=</span> <span class=s1>&#39;CLOSED&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>this</span><span class=p>.</span><span class=nx>failures</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>failures</span> <span class=o>&gt;=</span> <span class=k>this</span><span class=p>.</span><span class=nx>failureThreshold</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>state</span> <span class=o>=</span> <span class=s1>&#39;OPEN&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>nextAttempt</span> <span class=o>=</span> <span class=nb>Date</span><span class=p>.</span><span class=nx>now</span><span class=p>()</span> <span class=o>+</span> <span class=k>this</span><span class=p>.</span><span class=nx>recoveryTimeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>throw</span> <span class=nx>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 사용 예시
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>breaker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>CircuitBreaker</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>10000</span><span class=p>);</span> <span class=c1>// 3회 실패 시 10초 차단
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kr>async</span> <span class=kd>function</span> <span class=nx>fetchUserData</span><span class=p>(</span><span class=nx>userId</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>response</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>breaker</span><span class=p>.</span><span class=nx>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>fetch</span><span class=p>(</span><span class=sb>`/api/users/</span><span class=si>${</span><span class=nx>userId</span><span class=si>}</span><span class=sb>`</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kr>await</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 실패 시 대체 동작
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>{</span> <span class=nx>id</span><span class=o>:</span> <span class=nx>userId</span><span class=p>,</span> <span class=nx>name</span><span class=o>:</span> <span class=s1>&#39;Default User&#39;</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=15-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>15. 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#15-실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>장애 감지 기준</td><td>환경, 네트워크 상황에 맞는 장애 감지 기준 설정</td><td>모니터링, 튜닝</td></tr><tr><td>대체 동작 구현</td><td>요청 차단 시 대체 동작 (예: 기본값 반환, 로그 기록) 구현</td><td>표준화된 대체 동작 정의</td></tr><tr><td>로깅 및 모니터링</td><td>장애, 요청 차단, 복구 등 이벤트 로그, 메트릭 수집</td><td>로그, 메트릭 수집</td></tr></tbody></table><hr><h2 id=16-최적화하기-위한-고려사항-및-주의할-점>16. 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#16-최적화하기-위한-고려사항-및-주의할-점>#</a></h2><table><thead><tr><th>항목</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>동적 장애 감지 기준</td><td>시스템 상태, 네트워크 상황에 따라 장애 감지 기준 자동 조정</td><td>동적 장애 감지 기준 적용</td></tr><tr><td>자원 낭비 최소화</td><td>불필요한 요청은 최대한 빨리 차단하여 자원 낭비 최소화</td><td>요청 차단 로직 강화</td></tr><tr><td>대체 동작 최적화</td><td>요청 차단 시 대체 동작이 서비스 품질에 미치는 영향 최소화</td><td>대체 동작 품질 관리</td></tr></tbody></table><hr><h2 id=17-주제와-관련하여-주목할-내용>17. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#17-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>내결함성</td><td>Resilience</td><td>Circuit Breaker</td><td>장애 전파 방지 및 신뢰성 향상</td></tr><tr><td>분산 시스템</td><td>Microservices</td><td>Fault Tolerance</td><td>서비스 간 통신 시 장애 대응 및 회복력 강화</td></tr><tr><td>비동기 처리</td><td>Async/Await</td><td>상태 관리</td><td>비동기 작업에 Circuit Breaker 적용 예시</td></tr><tr><td>실무 적용</td><td>실무 예시</td><td>결제 서비스</td><td>외부 API 호출 시 Circuit Breaker 적용으로 장애 전파 방지</td></tr></tbody></table><hr><h2 id=18-반드시-학습해야할-내용>18. 반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#18-반드시-학습해야할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>내결함성</td><td>Resilience Pattern</td><td>Retry Pattern</td><td>Circuit Breaker 와 함께 사용되는 내결함성 패턴</td></tr><tr><td>분산 시스템</td><td>Microservices</td><td>Timeout Pattern</td><td>Circuit Breaker 와 함께 사용되는 타임아웃 패턴</td></tr><tr><td>비동기 처리</td><td>Async Programming</td><td>Promise, Async/Await</td><td>비동기 작업에 Circuit Breaker 적용 방법</td></tr><tr><td>실무 적용</td><td>실무 예시</td><td>Fallback Pattern</td><td>Circuit Breaker 후에도 실패 시 대체 동작 구현 방법</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>내결함성</td><td>Resilience</td><td>시스템이 장애 상황에서도 정상적으로 동작하는 능력</td></tr><tr><td>분산 시스템</td><td>Microservices</td><td>여러 서비스가 네트워크를 통해 상호작용하는 시스템 구조</td></tr><tr><td>실패 전파</td><td>Failure Propagation</td><td>장애가 한 시스템에서 다른 시스템으로 전파되는 현상</td></tr><tr><td>실무 적용</td><td>Circuit Breaker</td><td>장애 발생 시 요청을 차단하여 장애 전파와 자원 낭비를 방지</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker>Circuit Breaker Pattern (Microsoft Docs)</a></li><li><a href=https://martinfowler.com/bliki/CircuitBreaker.html>Circuit Breaker Pattern (Martin Fowler)</a></li><li><a href=https://patterns.arc42.org/patterns/circuit-breaker/>Circuit Breaker Pattern (Patterns for Resilient Architecture)</a></li><li><a href=https://dev.to/vipulkumarsviit/circuit-breaker-pattern-in-microservices-2m5c>Circuit Breaker Pattern in Microservices (dev.to)</a></li><li><a href=https://www.pollydocs.org/strategies/circuit-breaker>Polly Circuit Breaker Documentation</a></li></ul><p>아래는 <strong>Circuit Breaker Pattern</strong>에 대한 1~5 단계 정리입니다. 이후 단계도 준비 완료되어 있습니다!</p><hr><h2 id=1-태그-tags>1. 태그 (Tags)<a hidden class=anchor aria-hidden=true href=#1-태그-tags>#</a></h2><p>Circuit-Breaker-Pattern<br>Resilience-Patterns<br>Fault-Tolerance<br>Distributed-Systems</p><hr><h2 id=2-분류-구조-적절성-검토>2. 분류 구조 적절성 검토<a hidden class=anchor aria-hidden=true href=#2-분류-구조-적절성-검토>#</a></h2><p>&ldquo;Circuit Breaker Pattern&rdquo; 은 <strong>Software Engineering > Design and Architecture > Architecture Patterns > Resilience Patterns</strong> 안에 정확히 자리 잡는 패턴입니다.</p><ul><li><strong>근거</strong>: 마이크로서비스나 분산 시스템에서 외부 호출 장애가 전체 시스템에 확산되는 것을 방지하며, 오류 상태에 따라 호출을 차단하거나 회복 테스트를 진행하는 탄력성 원칙의 핵심 구성 요소입니다 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://arxiv.org/abs/1708.07422?utm_source=chatgpt.com" title="Resilience Design Patterns: A Structured Approach to Resilience at Extreme Scale">arxiv.org</a>).</li></ul><hr><h2 id=3-요약-200-자>3. 요약 (200 자)<a hidden class=anchor aria-hidden=true href=#3-요약-200-자>#</a></h2><p>Circuit Breaker Pattern 은 외부 서비스 호출 실패가 발생하면 설정된 임계치까지 실패를 감지한 후 차단 (Open) 상태로 전환하여 추가 호출을 막습니다. 이후 일정 시간 (Wait duration) 후 Half‑Open 상태에서 일부 호출을 재시도하며, 성공 시 Closed 상태로 복귀하고, 실패 시 다시 Open 상태로 되돌아갑니다. 이를 통해 장애 확산을 방지하고 시스템 회복을 유도할 수 있습니다 (<a href="https://mobisoftinfotech.com/resources/blog/microservices/resilience4j-circuit-breaker-retry-bulkhead-spring-boot?utm_source=chatgpt.com" title="Resilience4j Circuit Breaker, Retry & Bulkhead Tutorial">mobisoftinfotech.com</a>).</p><hr><h2 id=4-개요-250-자>4. 개요 (250 자)<a hidden class=anchor aria-hidden=true href=#4-개요-250-자>#</a></h2><p>Circuit Breaker Pattern 은 고장난 외부 서비스 호출을 보호하고 장애 확산 (cascading failure) 을 방지하기 위해 설계된 탄력성 구조입니다. Closed, Open, Half‑Open 의 세 상태를 통해 호출 흐름을 제어하며, 실패율 기반 트리거, 재시도 확인, 폴백 (fallback) 연계 기능을 제공합니다. Resilience4j, Hystrix, Istio, Polly 등 다양한 프레임워크와 통합되어 마이크로서비스, 분산 시스템, API 게이트웨이 환경에서 성능과 안정성을 강화합니다 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>).</p><hr><h2 id=5-핵심-개념-core-concepts>5. 핵심 개념 (Core Concepts)<a hidden class=anchor aria-hidden=true href=#5-핵심-개념-core-concepts>#</a></h2><ul><li><strong>Closed 상태</strong>: 호출 허용, failure count 모니터링 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>)</li><li><strong>Open 상태</strong>: failure threshold 이상 시 즉시 실패 대응, 호출 차단 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>)</li><li><strong>Half‑Open 상태</strong>: Open 이후 일정 시간 경과 후 일부 호출을 테스트한 뒤 상태 복귀 결정 (<a href="https://www.graphapp.ai/blog/understanding-the-circuit-breaker-pattern-a-comprehensive-guide?utm_source=chatgpt.com" title="Understanding the Circuit Breaker Pattern: A Comprehensive Guide">graphapp.ai</a>)</li><li><strong>Failure Threshold</strong>: 실패율 (logic-errors/timeouts) 초과 기준</li><li><strong>Wait Duration</strong>: Open 유지 시간 (<a href="https://mobisoftinfotech.com/resources/blog/microservices/resilience4j-circuit-breaker-retry-bulkhead-spring-boot?utm_source=chatgpt.com" title="Resilience4j Circuit Breaker, Retry & Bulkhead Tutorial">mobisoftinfotech.com</a>)</li><li><strong>Permitted Calls in Half‑Open</strong>: 복귀 시도 제한 횟수 (<a href="https://mobisoftinfotech.com/resources/blog/microservices/resilience4j-circuit-breaker-retry-bulkhead-spring-boot?utm_source=chatgpt.com" title="Resilience4j Circuit Breaker, Retry & Bulkhead Tutorial">mobisoftinfotech.com</a>)</li><li><strong>Fallback</strong>: Circuit Open 또는 호출 실패 시 대체 로직 제공</li><li><strong>Metrics & Monitoring</strong>: 상태, 실패율, 호출 상태 등 실시간 수집 필수 (<a href="https://www.graphapp.ai/blog/understanding-the-circuit-breaker-pattern-a-comprehensive-guide?utm_source=chatgpt.com" title="Understanding the Circuit Breaker Pattern: A Comprehensive Guide">graphapp.ai</a>)</li></ul><h3 id=실무-연관성>실무 연관성<a hidden class=anchor aria-hidden=true href=#실무-연관성>#</a></h3><ul><li><strong>Resilience4j / Spring Boot</strong>: 세밀한 설정 및 actuator 통합 지원 (<a href="https://www.javacodegeeks.com/2024/11/improving-application-resilience-with-circuit-breaker-patterns-in-spring-boot.html?utm_source=chatgpt.com" title="Improving Application Resilience with Circuit Breaker Patterns in …">javacodegeeks.com</a>)</li><li><strong>Istio 등 서비스 메시</strong>: 인프라 레벨에서 호출 차단/복귀 제어</li><li><strong>Polly (.NET)</strong>: Circuit Breaker 전략 + Retry/Fallback 쉽게 구성 가능 (<a href="https://www.graphapp.ai/blog/understanding-the-circuit-breaker-pattern-a-comprehensive-guide?utm_source=chatgpt.com" title="Understanding the Circuit Breaker Pattern: A Comprehensive Guide">graphapp.ai</a>)</li></ul><hr><p>이제 다음 단계—<strong>배경 · 목적 · 특징</strong>, <strong>작동 원리 (다이어그램 포함)</strong>, <strong>구조 및 구성 요소</strong>, <strong>구현 기법</strong>, <strong>장단점 및 해결방안</strong>, <strong>도전 과제</strong>, <strong>분류 기준</strong>, <strong>실무 예시</strong>, <strong>활용 사례</strong>, <strong>코드 구현</strong>, <strong>최적화 · 주의사항</strong>, <strong>용어정리 · 참고/출처</strong>—로 바로 이어가겠습니다. 어떤 항목부터 시작하면 좋을까요?</p><p>이어서 <strong>Circuit Breaker Pattern</strong>의 다음 단계를 정리합니다: <strong>배경·목적·특징</strong>, <strong>작동 원리 다이어그램</strong>, <strong>구조 및 구성요소</strong>, <strong>구현 기법</strong>, <strong>장단점 및 해결방안</strong>, <strong>도전 과제</strong>.</p><hr><h2 id=6-배경-background>6. 배경 (Background)<a hidden class=anchor aria-hidden=true href=#6-배경-background>#</a></h2><ul><li>분산 시스템에서는 장애가 전파되어 전체 서비스에 악영향을 주는 **cascading failure(연쇄 장애)** 가 빈발합니다 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">harsh05.medium.com</a>, <a href="https://arxiv.org/abs/1708.07422?utm_source=chatgpt.com" title="Resilience Design Patterns: A Structured Approach to Resilience at Extreme Scale">en.wikipedia.org</a>).</li><li>Circuit Breaker 는 이런 장애 확산을 방지하고 호출 대상이 회복할 시간을 제공하기 위해 고안된 패턴입니다.</li></ul><hr><h2 id=7-목적-및-필요성-purpose--need>7. 목적 및 필요성 (Purpose & Need)<a hidden class=anchor aria-hidden=true href=#7-목적-및-필요성-purpose--need>#</a></h2><ul><li><strong>장애 확산 방지</strong>: 실패하는 종속 서비스가 전체 시스템에 영향을 주는 것을 막습니다.</li><li><strong>리소스 보호</strong>: 비정상적 호출을 차단해 스레드풀이나 DB 연결 고갈 방지 (<a href="https://mobisoftinfotech.com/resources/blog/microservices/resilience4j-circuit-breaker-retry-bulkhead-spring-boot?utm_source=chatgpt.com" title="Resilience4j Circuit Breaker, Retry & Bulkhead Tutorial">dzone.com</a>)</li><li><strong>성능 안정성 확보</strong>: 장애 발생 시 응답 지연 없이 즉시 실패 처리로 UX 영향 최소화 (<a href="https://www.graphapp.ai/blog/understanding-the-circuit-breaker-pattern-a-comprehensive-guide?utm_source=chatgpt.com" title="Understanding the Circuit Breaker Pattern: A Comprehensive Guide">graphapp.ai</a>).</li><li><strong>복구 지원</strong>: Half‑Open 상태를 통해 일정 요청만 허용해 복구 판단 (<a href="https://www.javacodegeeks.com/2024/11/improving-application-resilience-with-circuit-breaker-patterns-in-spring-boot.html?utm_source=chatgpt.com" title="Improving Application Resilience with Circuit Breaker Patterns in …">resilience4j.readme.io</a>).</li></ul><hr><h2 id=8-특징-characteristics>8. 특징 (Characteristics)<a hidden class=anchor aria-hidden=true href=#8-특징-characteristics>#</a></h2><ul><li><strong>3 단계 상태 머신</strong>: Closed → Open → Half‑Open 전이 기반 호출 제어 (<a href="https://www.javacodegeeks.com/2024/11/improving-application-resilience-with-circuit-breaker-patterns-in-spring-boot.html?utm_source=chatgpt.com" title="Improving Application Resilience with Circuit Breaker Patterns in …">resilience4j.readme.io</a>).</li><li><strong>Sliding Window 기반 실패율 판단</strong>: 최근 호출 결과 집계로 threshold 초과 시 Open State 전환 (<a href="https://www.javacodegeeks.com/2024/11/improving-application-resilience-with-circuit-breaker-patterns-in-spring-boot.html?utm_source=chatgpt.com" title="Improving Application Resilience with Circuit Breaker Patterns in …">resilience4j.readme.io</a>).</li><li><strong>Fallback 지원</strong>: Open 또는 실패 시 백업 로직 수행 가능.</li><li><strong>프레임워크 및 서비스 메시 지원</strong>: Resilience4j, Hystrix, Polly, Istio 등 광범위하게 사용 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>).</li></ul><hr><h2 id=9-핵심-원리-및-작동-원리-operation--diagram>9. 핵심 원리 및 작동 원리 (Operation & Diagram)<a hidden class=anchor aria-hidden=true href=#9-핵심-원리-및-작동-원리-operation--diagram>#</a></h2><pre class=mermaid>stateDiagram-v2
    [*] --&gt; Closed
    Closed --&gt; Open : failureRate &gt; threshold
    Open --&gt; HalfOpen : waitDuration elapsed
    HalfOpen --&gt; Closed : testCalls succeed
    HalfOpen --&gt; Open : testCalls fail
</pre><ul><li><strong>Closed</strong>: 정상 호출, 실패 모니터링</li><li><strong>Open</strong>: 즉시 실패, 호출 차단</li><li><strong>Half‑Open</strong>: 제한된 테스트 호출 허용 후 상태 전환</li></ul><hr><h2 id=10-구조-및-구성요소-structure--components>10. 구조 및 구성요소 (Structure & Components)<a hidden class=anchor aria-hidden=true href=#10-구조-및-구성요소-structure--components>#</a></h2><table><thead><tr><th>유형</th><th>구성 요소</th><th>역할</th></tr></thead><tbody><tr><td>필수</td><td>CircuitBreaker</td><td>상태 머신 + threshold, window 설정</td></tr><tr><td></td><td>SlidingWindow</td><td>호출 결과 집계 및 통계 계산</td></tr><tr><td></td><td>CallInterceptor</td><td>호출 가로채고 상태에 따라 차단 또는 실행</td></tr><tr><td></td><td>StateTransitionManager</td><td>상태 전이 및 reset 예약 타이머</td></tr><tr><td>선택</td><td>FallbackHandler</td><td>실패 시 대체 동작 제공</td></tr><tr><td></td><td>MetricsCollector</td><td>state 변경, 실패율, 성공/실패 카운트 등 수집</td></tr><tr><td></td><td>AdminControl</td><td>강제 Open/Close 조작 가능</td></tr></tbody></table><p><strong>아키텍처 다이어그램:</strong></p><pre class=mermaid>classDiagram
class CircuitBreaker {
  +state
  +isCallPermitted()
  +onSuccess()
  +onFailure()
}
class SlidingWindow {
  +record(success)
  +failureRate()
}
class CallInterceptor {
  +invoke(callable)
}
class StateTransitionManager {
  +scheduleHalfOpen()
}
class FallbackHandler
class MetricsCollector
class AdminControl

CircuitBreaker --&gt; SlidingWindow
CircuitBreaker --&gt; StateTransitionManager
CallInterceptor --&gt; CircuitBreaker
CircuitBreaker --&gt; FallbackHandler
CircuitBreaker --&gt; MetricsCollector
AdminControl ..|&gt; CircuitBreaker
</pre><hr><h2 id=11-구현-기법-implementation-techniques>11. 구현 기법 (Implementation Techniques)<a hidden class=anchor aria-hidden=true href=#11-구현-기법-implementation-techniques>#</a></h2><ul><li><strong>Resilience4j + Spring Boot</strong><ul><li><code>CircuitBreakerConfig.custom()…build()</code> 방식 설정 후 <code>CircuitBreakerRegistry</code> 에 등록 (<a href="https://anshulgautam.in/blog/circuit-breaker-pattern-annotations/?utm_source=chatgpt.com" title="Circuit Breaker Pattern using Resilience4j Annotations">anshulgautam.in</a>, <a href="https://mobisoftinfotech.com/resources/blog/microservices/resilience4j-circuit-breaker-retry-bulkhead-spring-boot?utm_source=chatgpt.com" title="Resilience4j Circuit Breaker, Retry & Bulkhead Tutorial">dzone.com</a>)</li><li><code>@CircuitBreaker(name="…", fallbackMethod="…")</code> 어노테이션 사용</li></ul></li><li><strong>Polly (.NET)</strong><ul><li><code>Policy.Handle&lt;Exception>().CircuitBreakerAsync(…)</code> 형태 구성, <code>onBreak</code>, <code>onReset</code> 이벤트 핸들링</li></ul></li><li><strong>Istio Service Mesh</strong><ul><li>VirtualService 설정에 <code>circuitBreaker</code> 구성으로 트래픽 관리 가능 (<a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker?utm_source=chatgpt.com" title="Circuit Breaker Pattern - Azure Architecture Center | Microsoft Learn">learn.microsoft.com</a>)</li></ul></li><li><strong>AWS Step Functions + DynamoDB</strong><ul><li>상태며 <code>CircuitStatus</code> 관리 후 Open 시 호출 중단 및 fallback 흐름 실행 (<a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/circuit-breaker.html?utm_source=chatgpt.com" title="Circuit breaker pattern - AWS Prescriptive Guidance">docs.aws.amazon.com</a>)</li></ul></li></ul><hr><h2 id=12-장점-benefits>12. 장점 (Benefits)<a hidden class=anchor aria-hidden=true href=#12-장점-benefits>#</a></h2><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>장점</td><td>장애 확산 방지</td><td>cascading failure 예방 (<a href="https://arxiv.org/abs/1708.07422?utm_source=chatgpt.com" title="Resilience Design Patterns: A Structured Approach to Resilience at Extreme Scale">en.wikipedia.org</a>)</td></tr><tr><td></td><td>리소스 절약</td><td>비정상 호출로부터 스레드/커넥션 보호</td></tr><tr><td></td><td>빠른 피드백</td><td>즉시 실패 처리로 응답 시간 지연 방지</td></tr><tr><td></td><td>graceful recovery</td><td>Half‑Open 상태 통해 서비스 회복 감지 및 복귀</td></tr></tbody></table><hr><h2 id=13-단점--문제점-및-해결방안>13. 단점 & 문제점 및 해결방안<a hidden class=anchor aria-hidden=true href=#13-단점--문제점-및-해결방안>#</a></h2><h3 id=단점-1>단점<a hidden class=anchor aria-hidden=true href=#단점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>단점</td><td>민감도 설정 어려움</td><td>threshold 또는 window size 부적절 시 과잉 차단 또는 감지 실패</td><td>모니터링 기반 정책 조정</td></tr><tr><td></td><td>지연 문제 발생</td><td>Half‑Open 대기 중 잠정 실패 발생</td><td>test call 수 제한, fallback 로직</td></tr><tr><td></td><td>복잡성 증가</td><td>상태 추적 및 fallback 로직 구현 부담</td><td>프레임워크 사용, 구성 자동화</td></tr></tbody></table><h3 id=문제점-1>문제점<a hidden class=anchor aria-hidden=true href=#문제점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방</th><th>해결 기법</th></tr></thead><tbody><tr><td>문제점</td><td>오인 차단</td><td>burst 오류 또는 env glitch</td><td>정상 요청 차단</td><td>호출 실패율 분석</td><td>fallback, rate limiter 조합</td><td>circuit breaker 및 fallback 분리</td></tr><tr><td></td><td>상태 불일관성</td><td>다중 인스턴스에서 상태 sync 안됨</td><td>일부만 차단, others 호출 허용</td><td>분산 tracing</td><td>shared registry / config sync</td><td>중앙 상태 저장</td></tr></tbody></table><hr><h2 id=14-도전-과제-challenges>14. 도전 과제 (Challenges)<a hidden class=anchor aria-hidden=true href=#14-도전-과제-challenges>#</a></h2><ul><li><strong>Threshold 자동 조정</strong>: 환경 변화에 따라 실시간 정책 수정 필요</li><li><strong>분산 상태 공유</strong>: 여러 인스턴스간 CB 상태 동기화</li><li><strong>Fallback 복잡성</strong>: 복합 서비스 호출 시 대체 처리 설계</li><li><strong>관측성 확보</strong>: state 전이, 호출 실패율 등 관찰 위한 모니터링 필요</li></ul><hr><p>다음 단계로 <strong>분류 기준에 따른 유형</strong>, <strong>실무 사용 예시</strong>, <strong>활용 사례 다이어그램</strong>, <strong>코드 구현 (Python/JS)</strong>, <strong>최적화 고려사항</strong>, <strong>용어정리 + 참고 및 출처</strong>까지 바로 이어서 작성하겠습니다! 어떤 항목을 먼저 시작할까요?</p><p>이어서 <strong>Circuit Breaker Pattern</strong>의 나머지 항목들—분류 유형, 실무 예시, 활용 사례, 코드 구현, 최적화 고려사항, 용어 및 참고—를 정리합니다.</p><hr><h2 id=16-분류-기준에-따른-유형-classification-types>16. 분류 기준에 따른 유형 (Classification Types)<a hidden class=anchor aria-hidden=true href=#16-분류-기준에-따른-유형-classification-types>#</a></h2><table><thead><tr><th>기준</th><th>유형</th><th>설명</th></tr></thead><tbody><tr><td>구현 위치</td><td>Application-level</td><td>Resilience4j·Hystrix 등 라이브러리 사용</td></tr><tr><td></td><td>Infrastructure-level</td><td>Istio, Envoy 등 서비스 메쉬 단</td></tr><tr><td>동작 방식</td><td>Time-based</td><td>고정 또는 점증 오픈 유지 시간</td></tr><tr><td></td><td>Count-based</td><td>실패 횟수 기준 트리거</td></tr><tr><td>조합 전략</td><td>단독 사용</td><td>Fallback 없이 차단만 수행</td></tr><tr><td></td><td>복합 전략</td><td>Retry, Fallback 등과 함께 사용</td></tr></tbody></table><p><strong>설명</strong></p><ul><li><em>Application-level</em>은 코드에서 직접 구성, <em>Infrastructure-level</em>은 네트워크 레이어에서 자동 제어</li><li><em>Time-based</em>는 시간 기반 상태 전이, <em>Count-based</em>는 실패 카운팅 기반</li><li><em>Combining</em>은 시스템 회복력 강화를 위한 패턴 통합 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://arxiv.org/abs/1708.07422?utm_source=chatgpt.com" title="Resilience Design Patterns: A Structured Approach to Resilience at Extreme Scale">numberanalytics.com</a>, <a href="https://mobisoftinfotech.com/resources/blog/microservices/resilience4j-circuit-breaker-retry-bulkhead-spring-boot?utm_source=chatgpt.com" title="Resilience4j Circuit Breaker, Retry & Bulkhead Tutorial">squash.io</a>)</li></ul><hr><h2 id=17-실무-사용-예시>17. 실무 사용 예시<a hidden class=anchor aria-hidden=true href=#17-실무-사용-예시>#</a></h2><table><thead><tr><th>주체</th><th>목적</th><th>구현 방식</th><th>효과</th></tr></thead><tbody><tr><td>Spring Boot + Resilience4j</td><td>외부 결제 API 장애 방지</td><td><code>@CircuitBreaker</code>, Fallback</td><td>호출 실패 즉시 대체 응답 제공</td></tr><tr><td>.NET Polly</td><td>외부 HTTP 호출 보호</td><td><code>Policy.Handle&lt;Exception>().CircuitBreakerAsync(…)</code></td><td>재시도 반복 유도 방지 (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://www.graphapp.ai/blog/understanding-the-circuit-breaker-pattern-a-comprehensive-guide?utm_source=chatgpt.com" title="Understanding the Circuit Breaker Pattern: A Comprehensive Guide">graphapp.ai</a>, <a href="https://www.javacodegeeks.com/2024/11/improving-application-resilience-with-circuit-breaker-patterns-in-spring-boot.html?utm_source=chatgpt.com" title="Improving Application Resilience with Circuit Breaker Patterns in …">docs.aws.amazon.com</a>)</td></tr><tr><td>Istio Service Mesh</td><td>네트워크 호출 보호</td><td>VirtualService 내 <code>circuitBreaker</code> 설정</td><td>메시 전체에 장애 전파 방지</td></tr><tr><td>Python Flask + pybreaker</td><td>외부 API 장애 관리</td><td><code>CircuitBreaker</code> 클래스 사용</td><td>오류 시 기본 응답으로 우아한 종료</td></tr></tbody></table><hr><h2 id=18-활용-사례>18. 활용 사례<a hidden class=anchor aria-hidden=true href=#18-활용-사례>#</a></h2><h3 id=a-결제-서비스-장애-대응>A. 결제 서비스 장애 대응<a hidden class=anchor aria-hidden=true href=#a-결제-서비스-장애-대응>#</a></h3><ul><li><strong>시나리오</strong>: 결제 API 지연 또는 오류가 발생할 때, 주문 시스템 전체가 지연되는 문제</li><li><strong>구성 요소</strong>:<ul><li>Circuit Breaker 설정:<ul><li>실패 임계치 5 회</li><li>Open 상태 유지 60 초</li><li>Half‑Open 시도 3 회</li></ul></li><li>Fallback 로직: " 결제 지연 중입니다 " 메시지 반환</li></ul></li><li><strong>Workflow</strong>:</li></ul><pre class=mermaid>sequenceDiagram
  participant OrderService
  participant CB as CircuitBreaker
  participant PaymentAPI
  participant Fallback
  OrderService-&gt;&gt;CB: processPayment()
  CB-&gt;&gt;PaymentAPI: 호출
  alt 성공
    PaymentAPI--&gt;&gt;CB: OK
    CB--&gt;&gt;OrderService: 성공
  else 실패 반복
    CB 켜짐(Open)
    CB--&gt;&gt;Fallback: fallback()
    Fallback--&gt;&gt;OrderService: 지연 응답
  end
</pre><ul><li><strong>비교</strong>:<ul><li><strong>미도입</strong>: 무한 재시도로 API 병목 및 주문 지연 발생</li><li><strong>도입</strong>: Open 상태에서 즉시 대체 응답으로 UX 유지</li></ul></li></ul><hr><h2 id=19-구현-예시-python--javascript>19. 구현 예시 (Python & JavaScript)<a hidden class=anchor aria-hidden=true href=#19-구현-예시-python--javascript>#</a></h2><h3 id=python-pybreaker-활용>Python (pybreaker 활용)<a hidden class=anchor aria-hidden=true href=#python-pybreaker-활용>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pybreaker</span> <span class=kn>import</span> <span class=n>CircuitBreaker</span><span class=p>,</span> <span class=n>CircuitBreakerError</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>requests</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>cb</span> <span class=o>=</span> <span class=n>CircuitBreaker</span><span class=p>(</span><span class=n>fail_max</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span> <span class=n>reset_timeout</span><span class=o>=</span><span class=mi>60</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>call_payment</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cb</span><span class=o>.</span><span class=n>call</span><span class=p>(</span><span class=k>lambda</span><span class=p>:</span> <span class=n>requests</span><span class=o>.</span><span class=n>post</span><span class=p>(</span><span class=s2>&#34;https://pay/api&#34;</span><span class=p>,</span> <span class=n>json</span><span class=o>=...</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=n>CircuitBreakerError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;status&#34;</span><span class=p>:</span><span class=s2>&#34;pending&#34;</span><span class=p>,</span> <span class=s2>&#34;message&#34;</span><span class=p>:</span><span class=s2>&#34;지연 중입니다.&#34;</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=javascript-opossum>JavaScript (Opossum)<a hidden class=anchor aria-hidden=true href=#javascript-opossum>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>CircuitBreaker</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s1>&#39;@redhat/opossum&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>options</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>timeout</span><span class=o>:</span><span class=mi>2000</span><span class=p>,</span> <span class=nx>errorThresholdPercentage</span><span class=o>:</span><span class=mi>50</span><span class=p>,</span> <span class=nx>resetTimeout</span><span class=o>:</span><span class=mi>60000</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>breaker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>CircuitBreaker</span><span class=p>(</span><span class=nx>paymentCall</span><span class=p>,</span> <span class=nx>options</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>breaker</span><span class=p>.</span><span class=nx>fallback</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>({</span> <span class=nx>status</span><span class=o>:</span><span class=s1>&#39;pending&#39;</span><span class=p>,</span> <span class=nx>message</span><span class=o>:</span><span class=s1>&#39;지연 중입니다.&#39;</span> <span class=p>}));</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=20-실무에서-효과적인-적용-고려사항-및-주의점>20. 실무에서 효과적인 적용 고려사항 및 주의점<a hidden class=anchor aria-hidden=true href=#20-실무에서-효과적인-적용-고려사항-및-주의점>#</a></h2><table><thead><tr><th>항목</th><th>고려 사항</th><th>권장사항</th></tr></thead><tbody><tr><td>Threshold 설정</td><td>임계치가 너무 낮거나 높으면 의미 상실</td><td>실제 실패율 기준 튜닝</td></tr><tr><td>Fallback 구현</td><td>단순 오류 숨기기만 하면 분석 어려움</td><td>사용자 경험 및 로깅 포함</td></tr><tr><td>Half‑Open 전략</td><td>테스트 호출 과할 경우 연쇄 실패 가능</td><td>소수 요청만 허용</td></tr><tr><td>모니터링</td><td>상태 전이/호출 수 기록이 없으면 운영 어려움</td><td>상태 이벤트 및 메트릭 수집</td></tr><tr><td>분산 환경</td><td>다수 인스턴스 CB 상태 동기화 필요</td><td>공유 저장소 또는 메시 동기화</td></tr></tbody></table><hr><h2 id=21-최적화-고려사항-및-주의점>21. 최적화 고려사항 및 주의점<a hidden class=anchor aria-hidden=true href=#21-최적화-고려사항-및-주의점>#</a></h2><table><thead><tr><th>항목</th><th>고려 사항</th><th>권장사항</th></tr></thead><tbody><tr><td>자동 튜닝</td><td>고정 설정은 장기 운영에서 비효율</td><td>메트릭 기반 threshold 자동 조정</td></tr><tr><td>상태 동기화</td><td>스레드/프로세스 별 CB 상태 차이로 오작동 가능</td><td>중앙 저장소 또는 시그널 서비스 활용</td></tr><tr><td>이벤트 폭주</td><td>상태 전이 이벤트가 많으면 모니터링 시스템 부담</td><td>이벤트 sampling 적용</td></tr><tr><td>정책 조합</td><td>Retry/Fallback 연계 시 영향 주의</td><td>흐름 순서 명확히 구성</td></tr></tbody></table><hr><h2 id=22-용어-정리>22. 용어 정리<a hidden class=anchor aria-hidden=true href=#22-용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Resilience</td><td>Closed</td><td>정상 호출 상태</td></tr><tr><td>Resilience</td><td>Open</td><td>장애 차단 상태</td></tr><tr><td>Resilience</td><td>Half‑Open</td><td>복귀 시도 상태</td></tr><tr><td>Resilience</td><td>Failure Threshold</td><td>실패율 임계치</td></tr><tr><td>Resilience</td><td>Reset Timeout (Wait Duration)</td><td>Open 유지 시간</td></tr><tr><td>Resilience</td><td>Permitted Calls</td><td>Half‑Open 상태에서 허용 요청 수</td></tr><tr><td>Resilience</td><td>Fallback</td><td>실패 시 대체 응답</td></tr></tbody></table><hr><h2 id=23-참고-및-출처>23. 참고 및 출처<a hidden class=anchor aria-hidden=true href=#23-참고-및-출처>#</a></h2><ul><li>[Azure Architecture Center: Circuit Breaker] (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">en.wikipedia.org</a>, <a href="https://anshulgautam.in/blog/circuit-breaker-pattern-annotations/?utm_source=chatgpt.com" title="Circuit Breaker Pattern using Resilience4j Annotations">learn.microsoft.com</a>, <a href="https://arxiv.org/abs/1708.07422?utm_source=chatgpt.com" title="Resilience Design Patterns: A Structured Approach to Resilience at Extreme Scale">numberanalytics.com</a>, <a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>, <a href="https://www.graphapp.ai/blog/understanding-the-circuit-breaker-pattern-a-comprehensive-guide?utm_source=chatgpt.com" title="Understanding the Circuit Breaker Pattern: A Comprehensive Guide">graphapp.ai</a>)</li><li>[GeeksforGeeks: Circuit Breaker in Microservices] (<a href="https://www.geeksforgeeks.org/what-is-circuit-breaker-pattern-in-microservices/?utm_source=chatgpt.com" title="What is Circuit Breaker Pattern in Microservices? - GeeksforGeeks">geeksforgeeks.org</a>)</li><li>[Wikipedia: Circuit breaker design pattern] (<a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker?utm_source=chatgpt.com" title="Circuit Breaker Pattern - Azure Architecture Center | Microsoft Learn">en.wikipedia.org</a>)</li><li>[Polly Documentation: Circuit Breaker Strategy] (<a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/circuit-breaker.html?utm_source=chatgpt.com" title="Circuit breaker pattern - AWS Prescriptive Guidance">pollydocs.org</a>)</li><li>[Medium: Enhancing Microservice Resilience with Circuit Breaker] (<a href="https://medium.com/%40sarkarpabitra1999/enhancing-microservice-resilience-with-the-circuit-breaker-pattern-in-python-and-java-f04395e07b99?utm_source=chatgpt.com" title="Enhancing Microservice Resilience with the Circuit Breaker Pattern …">medium.com</a>)</li><li>[Microsoft Learn: Implementing Circuit Breaker in.NET] (<a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/implement-circuit-breaker-pattern?utm_source=chatgpt.com" title="Implementing the Circuit Breaker pattern -.NET | Microsoft Learn">learn.microsoft.com</a>)</li><li>[Number Analytics: Mastering Circuit Breaker Pattern] (<a href="https://arxiv.org/abs/1708.07422?utm_source=chatgpt.com" title="Resilience Design Patterns: A Structured Approach to Resilience at Extreme Scale">numberanalytics.com</a>)</li></ul><hr><p>원하시는 <strong>추가 심화 예시</strong>나 <strong>도구/언어 커스텀 코드</strong>, <strong>정책 자동화 방법</strong> 관련 요청 있으시면 알려주세요!</p><p>이어서 <strong>Circuit Breaker Pattern</strong>의 마지막 주요 항목들을 정리했습니다:</p><hr><h2 id=-24-통합-패턴-비교-및-조합-전략>🚀 24. 통합 패턴 비교 및 조합 전략<a hidden class=anchor aria-hidden=true href=#-24-통합-패턴-비교-및-조합-전략>#</a></h2><p>다른 회복성 패턴과 <strong>Circuit Breaker</strong>를 비교하고, 효율적으로 조합하는 전략을 정리했습니다.</p><table><thead><tr><th>패턴</th><th>역할</th><th>조합 전략 예시</th></tr></thead><tbody><tr><td><strong>Retry</strong></td><td>일시적 오류에 반복 시도 시도</td><td>Circuit Breaker → Retry → Fallback 순으로 구성 (<code>CB</code> 가 닫혀 있을 때만 재시도)</td></tr><tr><td><strong>Hedging</strong></td><td>지연 및 불확실성에서 빠른 응답 확보</td><td>Circuit Breaker 내부/외부에서 핸들 가능, <code>Open</code> 상태에서는 헤징 호출 차단</td></tr><tr><td><strong>Fallback</strong></td><td>오류 시 대체 로직 제공</td><td>Circuit Open 또는 호출 실패 시 로직 실행, <code>Retry/Hedging</code> 보다 선행 적용</td></tr><tr><td><strong>Timeout</strong></td><td>응답 지연에 대해 빠른 종료 처리</td><td>Circuit Breaker 와 함께 동작 → Timeout 실패 시 CB 에 기록</td></tr></tbody></table><p><strong>설명</strong></p><ul><li>개별 패턴만 사용할 때보다 조합 시 시스템 안정성과 사용자 경험을 균형 있게 확보할 수 있습니다.</li><li><strong>예시 워크플로우</strong>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[Request] → [Circuit Breaker] → [Timeout] → [Retry] → [Fallback]
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=-25-정책-자동화--튜닝-가이드>🎯 25. 정책 자동화 & 튜닝 가이드<a hidden class=anchor aria-hidden=true href=#-25-정책-자동화--튜닝-가이드>#</a></h2><ul><li><strong>Adaptive Thresholding</strong>: 실패율 증가 시 threshold 자동 확대, 감소 시 축소하는 로직 적용</li><li><strong>Auto-scaling & CB</strong>: 트래픽 증가 시 CB threshold 를 동적으로 조정하여 과도 차단 방지</li><li><strong>ML 기반 anomaly detection</strong>: 통계 기반 CB 설정 시 비정상 패턴 탐지에 적용</li></ul><hr><h2 id=-최종-요약--추천>📌 최종 요약 & 추천<a hidden class=anchor aria-hidden=true href=#-최종-요약--추천>#</a></h2><ul><li><strong>Circuit Breaker</strong>는 분산 시스템에서 장애 확산을 방지하고 서비스 안정성과 신뢰성을 확보하는 핵심 패턴입니다.</li><li>적절한 <strong>threshold</strong> 및 <strong>재복귀 전략 (Half‑Open)</strong> 설정이 관건이며, <strong>Retry/Hedging/Fallback/Timeout</strong> 등 다른 패턴과 조합하면 회복성과 사용자 경험을 극대화할 수 있습니다.</li><li>실시간 <strong>모니터링</strong>, <strong>정책 자동 조정</strong>, <strong>분산 상태 동기화</strong>는 운영 환경에서 안정화의 핵심 요소입니다.</li></ul><hr><p>원하시는 추가 항목 (예: <strong>ML 기반 정책 조정 예시</strong>, <strong>Go 언어 기반 구현 예시</strong>, <strong>Policy 중심 대시보드 설계</strong>) 있으시면 언제든 요청해 주세요!</p><p>네, Circuit Breaker Pattern 에 대해 체계적으로 조사하고 분석해보겠습니다. 먼저 최신 정보를 수집하기 위해 웹 검색을 진행하겠습니다.</p><h2 id=circuit-breaker-pattern-종합-분석>Circuit Breaker Pattern 종합 분석<a hidden class=anchor aria-hidden=true href=#circuit-breaker-pattern-종합-분석>#</a></h2><h3 id=1-태그-tags-1>1. 태그 (Tags)<a hidden class=anchor aria-hidden=true href=#1-태그-tags-1>#</a></h3><ul><li><strong>Circuit-Breaker-Pattern</strong></li><li><strong>Microservices-Resilience</strong></li><li><strong>Fault-Tolerance</strong></li><li><strong>Distributed-Systems</strong></li></ul><h3 id=2-분류-구조-검증>2. 분류 구조 검증<a hidden class=anchor aria-hidden=true href=#2-분류-구조-검증>#</a></h3><p>제시된 분류 &ldquo;Computer Science and Engineering > Software Engineering > Design and Architecture > Architecture Patterns > Resilience Patterns&rdquo; 는 <strong>매우 적절</strong>합니다.</p><p><strong>근거:</strong></p><ul><li>Circuit Breaker Pattern 은 소프트웨어 아키텍처 설계 패턴의 한 종류</li><li>특히 분산 시스템의 복원력 (Resilience) 을 강화하는 패턴</li><li>마이크로서비스 아키텍처에서 장애 전파 방지를 위한 핵심 패턴</li><li>시스템의 안정성과 내결함성을 향상시키는 아키텍처 패턴</li></ul><h3 id=3-요약-설명-200-자-내외>3. 요약 설명 (200 자 내외)<a hidden class=anchor aria-hidden=true href=#3-요약-설명-200-자-내외>#</a></h3><p>Circuit Breaker Pattern 은 분산 시스템에서 서비스 간 통신 실패를 감지하고 관리하는 디자인 패턴입니다. 전기 회로 차단기처럼 작동하여 장애가 발생한 서비스에 대한 요청을 일시적으로 차단함으로써 연쇄 장애를 방지하고 시스템의 전체적인 안정성과 복원력을 향상시킵니다.</p><h3 id=4-전체-개요-250-자-내외>4. 전체 개요 (250 자 내외)<a hidden class=anchor aria-hidden=true href=#4-전체-개요-250-자-내외>#</a></h3><p>Circuit Breaker Pattern 은 마이크로서비스 아키텍처에서 필수적인 복원력 패턴으로, Closed, Open, Half-Open 의 세 가지 상태를 통해 장애 상황을 관리합니다. 장애가 발생한 서비스로의 반복적인 요청을 차단하여 리소스 낭비를 방지하고, Fallback 메커니즘을 통해 우아한 성능 저하 (Graceful Degradation) 를 제공합니다. Netflix Hystrix, Resilience4j 등의 라이브러리로 구현 가능하며, 현대 클라우드 네이티브 애플리케이션의 핵심 구성 요소입니다.</p><hr><h2 id=5-핵심-개념-1>5. 핵심 개념<a hidden class=anchor aria-hidden=true href=#5-핵심-개념-1>#</a></h2><h3 id=51-기본-개념>5.1 기본 개념<a hidden class=anchor aria-hidden=true href=#51-기본-개념>#</a></h3><ul><li><strong>Circuit Breaker (회로 차단기)</strong>: 전기 회로 차단기에서 영감을 받은 소프트웨어 디자인 패턴</li><li><strong>Fault Tolerance (내결함성)</strong>: 시스템이 장애에도 불구하고 계속 작동할 수 있는 능력</li><li><strong>Cascading Failure (연쇄 장애)</strong>: 하나의 장애가 다른 시스템으로 전파되어 전체 시스템 장애를 일으키는 현상</li><li><strong>Resilience (복원력)</strong>: 시스템이 장애로부터 빠르게 회복할 수 있는 능력</li><li><strong>Graceful Degradation (우아한 성능 저하)</strong>: 일부 기능이 실패해도 핵심 기능은 유지하는 설계 원칙</li></ul><h3 id=52-실무-구현을-위한-연관-개념>5.2 실무 구현을 위한 연관 개념<a hidden class=anchor aria-hidden=true href=#52-실무-구현을-위한-연관-개념>#</a></h3><ul><li><strong>State Machine (상태 머신)</strong>: Closed, Open, Half-Open 상태 관리</li><li><strong>Threshold Configuration (임계값 설정)</strong>: 장애 감지를 위한 기준값 설정</li><li><strong>Timeout Management (타임아웃 관리)</strong>: 응답 시간 기반 장애 판단</li><li><strong>Fallback Mechanism (대체 메커니즘)</strong>: 장애 시 대안 동작 정의</li><li><strong>Monitoring and Metrics (모니터링 및 메트릭)</strong>: 시스템 상태 추적 및 분석</li></ul><hr><h2 id=6-주제와-관련하여-조사할-내용>6. 주제와 관련하여 조사할 내용<a hidden class=anchor aria-hidden=true href=#6-주제와-관련하여-조사할-내용>#</a></h2><h3 id=61-배경>6.1 배경<a hidden class=anchor aria-hidden=true href=#61-배경>#</a></h3><p>Circuit Breaker Pattern 은 <strong>Michael Nygard</strong>가 저서 &ldquo;Release It!&rdquo; 에서 처음 체계화한 패턴으로, 분산 시스템의 복잡성이 증가하면서 필수적인 패턴이 되었습니다. 마이크로서비스 아키텍처의 확산과 함께 <strong>Netflix</strong>에서 Hystrix 라이브러리를 통해 실용화되었으며, 현재는 클라우드 네이티브 애플리케이션의 표준 패턴으로 자리잡았습니다.</p><h3 id=62-목적-및-필요성>6.2 목적 및 필요성<a hidden class=anchor aria-hidden=true href=#62-목적-및-필요성>#</a></h3><p><strong>주요 목적:</strong></p><ul><li>연쇄 장애 (Cascading Failure) 방지</li><li>시스템 자원 보호 및 효율적 활용</li><li>빠른 실패 (Fail-Fast) 구현을 통한 응답성 향상</li><li>장애 서비스의 복구 시간 확보</li></ul><p><strong>필요성:</strong></p><ul><li>분산 시스템에서 서비스 간 의존성으로 인한 장애 전파 위험</li><li>네트워크 지연, 타임아웃으로 인한 리소스 고갈 방지</li><li>사용자 경험 개선을 위한 안정적인 서비스 제공</li><li>마이크로서비스 환경에서의 복원력 강화</li></ul><h3 id=63-주요-기능-및-역할>6.3 주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#63-주요-기능-및-역할>#</a></h3><p><strong>핵심 기능:</strong></p><ul><li><strong>장애 감지</strong>: 연속적인 실패 모니터링</li><li><strong>요청 차단</strong>: 장애 서비스로의 요청 임시 중단</li><li><strong>상태 관리</strong>: 세 가지 상태 (Closed, Open, Half-Open) 전환</li><li><strong>자동 복구</strong>: 서비스 상태 확인 후 정상 운영 재개</li><li><strong>Fallback 실행</strong>: 대체 동작 수행</li></ul><p><strong>시스템에서의 역할:</strong></p><ul><li><strong>Proxy 역할</strong>: 서비스 호출을 감싸는 래퍼 기능</li><li><strong>Guard 역할</strong>: 시스템 보호를 위한 방어막</li><li><strong>Monitor 역할</strong>: 서비스 상태 지속적 감시</li><li><strong>Decision Maker 역할</strong>: 요청 허용/차단 결정</li></ul><h3 id=64-특징>6.4 특징<a hidden class=anchor aria-hidden=true href=#64-특징>#</a></h3><ul><li><strong>상태 기반 동작</strong>: 명확한 상태 전환 로직</li><li><strong>설정 가능한 임계값</strong>: 비즈니스 요구사항에 맞는 조정 가능</li><li><strong>실시간 모니터링</strong>: 지속적인 서비스 상태 추적</li><li><strong>자동화된 복구</strong>: 수동 개입 없는 자동 상태 전환</li><li><strong>경량화</strong>: 최소한의 오버헤드로 구현 가능</li></ul><h3 id=65-핵심-원칙>6.5 핵심 원칙<a hidden class=anchor aria-hidden=true href=#65-핵심-원칙>#</a></h3><ol><li><strong>Fail Fast</strong>: 장애 상황에서 빠른 실패 제공</li><li><strong>Isolation</strong>: 장애 격리를 통한 전파 방지</li><li><strong>Monitoring</strong>: 지속적인 상태 감시</li><li><strong>Recovery</strong>: 자동 복구 메커니즘</li><li><strong>Fallback</strong>: 대체 동작 제공</li></ol><h3 id=66-주요-원리>6.6 주요 원리<a hidden class=anchor aria-hidden=true href=#66-주요-원리>#</a></h3><p><strong>상태 전환 원리:</strong></p><pre class=mermaid>stateDiagram-v2
    [*] --&gt; Closed
    Closed --&gt; Open : 임계값 초과 실패
    Open --&gt; HalfOpen : 타임아웃 후
    HalfOpen --&gt; Closed : 성공
    HalfOpen --&gt; Open : 실패
    Open --&gt; [*]
    Closed --&gt; [*]
    HalfOpen --&gt; [*]
</pre><p><strong>동작 원리:</strong></p><ol><li><strong>정상 상태 (Closed)</strong>: 모든 요청 통과, 실패율 모니터링</li><li><strong>실패 감지</strong>: 설정된 임계값 초과 시 상태 전환</li><li><strong>차단 상태 (Open)</strong>: 모든 요청 즉시 실패 반환</li><li><strong>복구 확인 (Half-Open)</strong>: 제한된 테스트 요청 허용</li><li><strong>상태 결정</strong>: 테스트 결과에 따른 최종 상태 전환</li></ol><h3 id=67-작동-원리>6.7 작동 원리<a hidden class=anchor aria-hidden=true href=#67-작동-원리>#</a></h3><p><strong>Circuit Breaker 작동 플로우:</strong></p><pre class=mermaid>flowchart TD
    A[서비스 호출 요청] --&gt; B{Circuit Breaker 상태 확인}
    B --&gt;|Closed| C[실제 서비스 호출]
    B --&gt;|Open| D[즉시 Fallback 실행]
    B --&gt;|Half-Open| E[제한된 테스트 호출]
    
    C --&gt; F{호출 성공?}
    F --&gt;|성공| G[응답 반환]
    F --&gt;|실패| H[실패 카운트 증가]
    
    H --&gt; I{임계값 초과?}
    I --&gt;|예| J[Open 상태로 전환]
    I --&gt;|아니오| G
    
    E --&gt; K{테스트 호출 성공?}
    K --&gt;|성공| L[Closed 상태로 전환]
    K --&gt;|실패| M[Open 상태로 전환]
    
    D --&gt; N[Fallback 응답 반환]
    J --&gt; O[타임아웃 타이머 시작]
    O --&gt; P[Half-Open으로 전환]
</pre><h3 id=68-구조-및-아키텍처>6.8 구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#68-구조-및-아키텍처>#</a></h3><p><strong>필수 구성요소:</strong></p><table><thead><tr><th>구성요소</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>State Manager</strong></td><td>상태 관리</td><td>Closed/Open/Half-Open 상태 전환 및 유지</td></tr><tr><td><strong>Failure Counter</strong></td><td>실패 추적</td><td>연속 실패 횟수 및 실패율 계산</td></tr><tr><td><strong>Timer</strong></td><td>시간 관리</td><td>타임아웃 및 대기 시간 관리</td></tr><tr><td><strong>Configuration</strong></td><td>설정 관리</td><td>임계값, 타임아웃 등 파라미터 설정</td></tr></tbody></table><p><strong>선택 구성요소:</strong></p><table><thead><tr><th>구성요소</th><th>기능</th><th>역할</th></tr></thead><tbody><tr><td><strong>Metrics Collector</strong></td><td>메트릭 수집</td><td>성능 지표 및 통계 데이터 수집</td></tr><tr><td><strong>Fallback Handler</strong></td><td>대체 처리</td><td>장애 시 대안 동작 수행</td></tr><tr><td><strong>Event Listener</strong></td><td>이벤트 처리</td><td>상태 변경 시 알림 및 로깅</td></tr><tr><td><strong>Health Check</strong></td><td>상태 확인</td><td>서비스 건강 상태 주기적 점검</td></tr></tbody></table><p><strong>시스템 아키텍처:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;Client Application&#34;
        A[Service Call]
    end
    
    subgraph &#34;Circuit Breaker&#34;
        B[Request Interceptor]
        C[State Manager]
        D[Failure Counter]
        E[Timer]
        F[Configuration]
        G[Fallback Handler]
    end
    
    subgraph &#34;Target Service&#34;
        H[External Service]
    end
    
    A --&gt; B
    B --&gt; C
    C --&gt; D
    C --&gt; E
    C --&gt; F
    C --&gt; G
    B --&gt; H
    B --&gt; G
</pre><h3 id=69-구현-기법>6.9 구현 기법<a hidden class=anchor aria-hidden=true href=#69-구현-기법>#</a></h3><p><strong>1. Library-based 구현</strong></p><ul><li><strong>정의</strong>: 기존 라이브러리를 활용한 구현 방식</li><li><strong>구성</strong>: Hystrix, Resilience4j, Polly 등 활용</li><li><strong>목적</strong>: 빠른 구현과 검증된 기능 활용</li><li><strong>실제 예시</strong>: Spring Boot + Resilience4j 조합</li></ul><p><strong>2. Custom 구현</strong></p><ul><li><strong>정의</strong>: 직접 구현하는 방식</li><li><strong>구성</strong>: 상태 머신, 카운터, 타이머 직접 구현</li><li><strong>목적</strong>: 특수한 요구사항 충족</li><li><strong>실제 예시</strong>: 특정 프로토콜이나 프레임워크에 최적화된 구현</li></ul><p><strong>3. Infrastructure 기반 구현</strong></p><ul><li><strong>정의</strong>: 인프라스트럭처 레벨에서 구현</li><li><strong>구성</strong>: Service Mesh(Istio), API Gateway 활용</li><li><strong>목적</strong>: 애플리케이션 코드 변경 없이 적용</li><li><strong>실제 예시</strong>: Istio Envoy Proxy 의 Circuit Breaker 기능</li></ul><p><strong>4. Annotation 기반 구현</strong></p><ul><li><strong>정의</strong>: 어노테이션을 통한 선언적 구현</li><li><strong>구성</strong>: Spring AOP, AspectJ 활용</li><li><strong>목적</strong>: 코드 침투성 최소화</li><li><strong>실제 예시</strong>: @CircuitBreaker 어노테이션 사용</li></ul><h3 id=610-장점>6.10 장점<a hidden class=anchor aria-hidden=true href=#610-장점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>장점</td><td><strong>연쇄 장애 방지</strong></td><td>하나의 서비스 장애가 전체 시스템으로 전파되는 것을 차단하여 시스템 안정성 확보</td></tr><tr><td></td><td><strong>빠른 실패 제공</strong></td><td>장애 상황에서 즉시 실패를 반환하여 응답 시간 단축 및 사용자 경험 개선</td></tr><tr><td></td><td><strong>리소스 보호</strong></td><td>장애 서비스로의 불필요한 요청을 차단하여 CPU, 메모리, 네트워크 리소스 절약</td></tr><tr><td></td><td><strong>자동 복구</strong></td><td>서비스 복구 시 자동으로 정상 상태로 전환하여 수동 개입 없이 서비스 재개</td></tr><tr><td></td><td><strong>우아한 성능 저하</strong></td><td>Fallback 메커니즘을 통해 핵심 기능은 유지하면서 부가 기능만 제한적으로 제공</td></tr><tr><td></td><td><strong>모니터링 강화</strong></td><td>실시간 상태 추적을 통해 시스템 건강 상태 파악 및 예방적 조치 가능</td></tr></tbody></table><h3 id=611-단점과-문제점-그리고-해결방안>6.11 단점과 문제점 그리고 해결방안<a hidden class=anchor aria-hidden=true href=#611-단점과-문제점-그리고-해결방안>#</a></h3><p><strong>단점:</strong></p><table><thead><tr><th>구분</th><th>항목</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>단점</td><td><strong>복잡성 증가</strong></td><td>시스템에 추가적인 로직과 상태 관리가 필요하여 복잡도 상승</td><td>검증된 라이브러리 사용, 명확한 설계 문서화</td></tr><tr><td></td><td><strong>잘못된 트리핑</strong></td><td>임시적 장애를 영구적 장애로 오판하여 불필요한 서비스 차단</td><td>적절한 임계값 설정, 동적 임계값 조정</td></tr><tr><td></td><td><strong>설정 어려움</strong></td><td>임계값, 타임아웃 등 파라미터 최적화의 복잡성</td><td>모니터링 데이터 기반 조정, A/B 테스트</td></tr><tr><td></td><td><strong>Fallback 한계</strong></td><td>모든 상황에 대한 적절한 대체 동작 정의의 어려움</td><td>비즈니스 우선순위 기반 Fallback 전략 수립</td></tr></tbody></table><p><strong>문제점:</strong></p><table><thead><tr><th>구분</th><th>항목</th><th>원인</th><th>영향</th><th>탐지 및 진단</th><th>예방 방법</th><th>해결 방법 및 기법</th></tr></thead><tbody><tr><td>문제점</td><td><strong>False Positive</strong></td><td>부적절한 임계값 설정</td><td>정상 서비스 차단</td><td>메트릭 분석, 알람 설정</td><td>적응형 임계값 사용</td><td>동적 조정 알고리즘 적용</td></tr><tr><td></td><td><strong>State Synchronization</strong></td><td>다중 인스턴스 환경에서 상태 불일치</td><td>일관성 없는 동작</td><td>분산 모니터링</td><td>중앙화된 상태 관리</td><td>Redis, Hazelcast 등 활용</td></tr><tr><td></td><td><strong>Performance Overhead</strong></td><td>추가적인 처리 로직</td><td>응답 시간 증가</td><td>성능 테스트</td><td>효율적인 알고리즘 사용</td><td>비동기 처리, 캐싱</td></tr><tr><td></td><td><strong>Configuration Drift</strong></td><td>환경별 설정 차이</td><td>예상과 다른 동작</td><td>설정 검증</td><td>환경별 설정 표준화</td><td>Infrastructure as Code</td></tr></tbody></table><h3 id=612-도전-과제>6.12 도전 과제<a hidden class=anchor aria-hidden=true href=#612-도전-과제>#</a></h3><p><strong>1. 마이크로서비스 환경에서의 복잡성</strong></p><ul><li><strong>원인</strong>: 서비스 간 복잡한 의존 관계</li><li><strong>영향</strong>: 최적 설정 어려움, 디버깅 복잡성</li><li><strong>해결방안</strong>: Service Mesh 활용, 의존성 맵핑</li></ul><p><strong>2. 클라우드 네이티브 환경 적응</strong></p><ul><li><strong>원인</strong>: 동적 스케일링, 컨테이너 환경</li><li><strong>영향</strong>: 상태 관리 어려움, 설정 복잡성</li><li><strong>해결방안</strong>: 클라우드 네이티브 라이브러리 사용</li></ul><p><strong>3. AI/ML 기반 적응형 Circuit Breaker</strong></p><ul><li><strong>원인</strong>: 정적 임계값의 한계</li><li><strong>영향</strong>: 최적화되지 않은 성능</li><li><strong>해결방안</strong>: 머신러닝 기반 동적 조정</li></ul><h3 id=613-분류-기준에-따른-종류-및-유형>6.13 분류 기준에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#613-분류-기준에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>유형</th><th>특징</th><th>적용 사례</th></tr></thead><tbody><tr><td><strong>구현 방식</strong></td><td>Library-based</td><td>기존 라이브러리 활용</td><td>Hystrix, Resilience4j</td></tr><tr><td></td><td>Custom</td><td>직접 구현</td><td>특수 요구사항 대응</td></tr><tr><td></td><td>Infrastructure</td><td>인프라 레벨 구현</td><td>Istio, API Gateway</td></tr><tr><td><strong>상태 관리</strong></td><td>Simple</td><td>기본 3-state</td><td>대부분의 구현</td></tr><tr><td></td><td>Extended</td><td>추가 상태 포함</td><td>METRICS_ONLY, DISABLED</td></tr><tr><td><strong>트리거 방식</strong></td><td>Count-based</td><td>실패 횟수 기반</td><td>간단한 환경</td></tr><tr><td></td><td>Rate-based</td><td>실패율 기반</td><td>복잡한 환경</td></tr><tr><td></td><td>Time-based</td><td>시간 창 기반</td><td>실시간 요구사항</td></tr><tr><td><strong>스코프</strong></td><td>Service-level</td><td>서비스 단위</td><td>마이크로서비스</td></tr><tr><td></td><td>Method-level</td><td>메서드 단위</td><td>세밀한 제어</td></tr><tr><td></td><td>Global</td><td>전역 적용</td><td>시스템 전체 보호</td></tr></tbody></table><h3 id=614-실무-사용-예시>6.14 실무 사용 예시<a hidden class=anchor aria-hidden=true href=#614-실무-사용-예시>#</a></h3><table><thead><tr><th>사용 목적</th><th>함께 사용하는 기술</th><th>효과</th></tr></thead><tbody><tr><td><strong>API Gateway 보호</strong></td><td>Kong, Zuul, Spring Cloud Gateway</td><td>백엔드 서비스 장애 시 게이트웨이 안정성 확보</td></tr><tr><td><strong>데이터베이스 연결 보호</strong></td><td>Connection Pool, JPA, MyBatis</td><td>DB 장애 시 애플리케이션 리소스 보호</td></tr><tr><td><strong>외부 서비스 호출</strong></td><td>HTTP Client, gRPC, Message Queue</td><td>외부 의존성 장애로부터 격리</td></tr><tr><td><strong>마이크로서비스 통신</strong></td><td>Spring Boot, Docker, Kubernetes</td><td>서비스 간 장애 전파 방지</td></tr><tr><td><strong>클라우드 서비스 연동</strong></td><td>AWS SDK, Azure SDK, GCP Client</td><td>클라우드 서비스 장애 대응</td></tr></tbody></table><h3 id=615-활용-사례>6.15 활용 사례<a hidden class=anchor aria-hidden=true href=#615-활용-사례>#</a></h3><p><strong>Netflix 스트리밍 서비스 사례</strong></p><p><strong>시스템 구성:</strong></p><ul><li>추천 서비스, 사용자 서비스, 콘텐츠 서비스, 결제 서비스</li><li>API Gateway 를 통한 마이크로서비스 통신</li><li>Hystrix Circuit Breaker 적용</li></ul><p><strong>시스템 구성 다이어그램:</strong></p><pre class=mermaid>graph TB
    subgraph &#34;Netflix Platform&#34;
        A[API Gateway]
        B[추천 서비스]
        C[사용자 서비스]
        D[콘텐츠 서비스]
        E[결제 서비스]
        F[Circuit Breaker Dashboard]
    end
    
    subgraph &#34;External Services&#34;
        G[추천 알고리즘 서비스]
        H[결제 처리 서비스]
    end
    
    A --&gt; B
    A --&gt; C
    A --&gt; D
    A --&gt; E
    B --&gt; G
    E --&gt; H
    F --&gt; A
</pre><p><strong>Workflow:</strong></p><ol><li>사용자가 Netflix 앱에서 영화 추천 요청</li><li>API Gateway 가 추천 서비스로 요청 전달</li><li>추천 서비스가 외부 알고리즘 서비스 호출</li><li>외부 서비스 장애 시 Circuit Breaker 활성화</li><li>Fallback 으로 캐시된 추천 목록 반환</li><li>사용자는 지연 없이 추천 콘텐츠 확인</li></ol><p><strong>Circuit Breaker 역할:</strong></p><ul><li>외부 추천 알고리즘 서비스 장애 감지</li><li>장애 시 캐시된 추천 목록으로 Fallback</li><li>서비스 복구 시 자동으로 정상 모드 전환</li></ul><p><strong>유무에 따른 차이점:</strong></p><ul><li><strong>Circuit Breaker 적용 시</strong>: 외부 서비스 장애에도 기본 추천 제공</li><li><strong>미적용 시</strong>: 외부 서비스 장애로 전체 추천 기능 중단</li></ul><h3 id=616-구현-예시>6.16 구현 예시<a hidden class=anchor aria-hidden=true href=#616-구현-예시>#</a></h3><p><strong>Python 을 이용한 Circuit Breaker 구현:</strong>### 6.17 실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점</p><table><thead><tr><th>구분</th><th>고려사항</th><th>주의할 점</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>설정 관리</strong></td><td>적절한 임계값 설정</td><td>너무 민감하거나 둔감한 설정</td><td>모니터링 데이터 기반 점진적 조정</td></tr><tr><td><strong>모니터링</strong></td><td>실시간 상태 추적</td><td>알람 피로도</td><td>중요도별 알람 분류, 대시보드 구성</td></tr><tr><td><strong>테스트</strong></td><td>장애 상황 시뮬레이션</td><td>프로덕션 환경 영향</td><td>Chaos Engineering, Canary 배포</td></tr><tr><td><strong>문서화</strong></td><td>설정 근거 기록</td><td>설정 변경 이력 누락</td><td>설정 변경 시 반드시 문서 업데이트</td></tr><tr><td><strong>팀 교육</strong></td><td>운영진 이해도 향상</td><td>잘못된 수동 개입</td><td>정기적인 교육, 플레이북 작성</td></tr><tr><td><strong>의존성 관리</strong></td><td>서비스 간 의존성 파악</td><td>순환 의존성</td><td>의존성 맵 작성, 정기적 검토</td></tr><tr><td><strong>Fallback 전략</strong></td><td>비즈니스 로직 반영</td><td>일관성 없는 대체 로직</td><td>비즈니스 팀과 협의한 우선순위</td></tr><tr><td><strong>성능 영향</strong></td><td>오버헤드 최소화</td><td>과도한 모니터링 로직</td><td>비동기 처리, 샘플링 활용</td></tr></tbody></table><h3 id=618-최적화하기-위한-고려사항-및-주의할-점>6.18 최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#618-최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>최적화 방안</th><th>주의할 점</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>알고리즘</strong></td><td>적응형 임계값</td><td>과도한 복잡성</td><td>점진적 도입, A/B 테스트</td></tr><tr><td><strong>상태 동기화</strong></td><td>분산 상태 관리</td><td>네트워크 지연</td><td>Redis Cluster, 일관성 수준 조정</td></tr><tr><td><strong>메모리 사용</strong></td><td>통계 데이터 최적화</td><td>메모리 누수</td><td>순환 버퍼, 정기적 가비지 컬렉션</td></tr><tr><td><strong>네트워크</strong></td><td>배치 처리</td><td>지연 시간 증가</td><td>적절한 배치 크기, 비동기 전송</td></tr><tr><td><strong>캐싱</strong></td><td>Fallback 데이터 캐싱</td><td>데이터 일관성</td><td>TTL 설정, 캐시 무효화 전략</td></tr><tr><td><strong>스케일링</strong></td><td>수평 확장 대응</td><td>상태 불일치</td><td>Stateless 설계, 외부 상태 저장소</td></tr><tr><td><strong>설정 동적 변경</strong></td><td>런타임 설정 변경</td><td>설정 충돌</td><td>중앙화된 설정 관리, 검증 로직</td></tr><tr><td><strong>로그 최적화</strong></td><td>구조화된 로그</td><td>로그 오버플로우</td><td>로그 레벨 조정, 로그 로테이션</td></tr></tbody></table><hr><h2 id=7-주제와-관련하여-주목할-내용>7. 주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#7-주제와-관련하여-주목할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>라이브러리</strong></td><td>Resilience4j</td><td>차세대 Circuit Breaker</td><td>Hystrix 대체제, 함수형 프로그래밍 지원</td></tr><tr><td></td><td>Netflix Hystrix</td><td>레거시 라이브러리</td><td>현재 유지보수 모드, 안정적이지만 새 프로젝트 비권장</td></tr><tr><td></td><td>Polly (.NET)</td><td>.NET 생태계</td><td>C# 환경에서 가장 인기 있는 복원력 라이브러리</td></tr><tr><td><strong>클라우드</strong></td><td>Service Mesh</td><td>인프라 수준 구현</td><td>Istio, Linkerd 를 통한 코드 변경 없는 적용</td></tr><tr><td></td><td>API Gateway</td><td>진입점 보호</td><td>Kong, Zuul 에서 제공하는 Circuit Breaker 기능</td></tr><tr><td></td><td>Serverless</td><td>FaaS 환경 적용</td><td>AWS Lambda, Azure Functions 에서의 구현 고려사항</td></tr><tr><td><strong>모니터링</strong></td><td>Metrics</td><td>성능 지표 수집</td><td>Prometheus, Grafana 를 통한 시각화</td></tr><tr><td></td><td>Alerting</td><td>실시간 알림</td><td>PagerDuty, Slack 연동을 통한 즉시 대응</td></tr><tr><td></td><td>Tracing</td><td>분산 추적</td><td>Jaeger, Zipkin 을 통한 요청 흐름 추적</td></tr><tr><td><strong>패턴</strong></td><td>Bulkhead</td><td>격리 패턴</td><td>리소스 풀 분리를 통한 장애 격리</td></tr><tr><td></td><td>Retry</td><td>재시도 패턴</td><td>Circuit Breaker 와 조합하여 효과적인 복원력 구현</td></tr><tr><td></td><td>Timeout</td><td>시간 제한</td><td>무한 대기 방지, Circuit Breaker 와 상호 보완</td></tr></tbody></table><hr><h2 id=8-반드시-학습해야-할-내용>8. 반드시 학습해야 할 내용<a hidden class=anchor aria-hidden=true href=#8-반드시-학습해야-할-내용>#</a></h2><table><thead><tr><th>카테고리</th><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>기초 이론</strong></td><td>분산 시스템</td><td>CAP 정리</td><td>일관성, 가용성, 분할 내성의 트레이드오프 이해</td></tr><tr><td></td><td>장애 유형</td><td>Byzantine Failure</td><td>분산 시스템에서 발생하는 다양한 장애 패턴</td></tr><tr><td></td><td>복원력 공학</td><td>Resilience Engineering</td><td>시스템의 적응력과 복구력에 대한 체계적 접근</td></tr><tr><td><strong>설계 패턴</strong></td><td>Microservices</td><td>Service Design</td><td>서비스 경계 설정, 데이터 일관성 관리</td></tr><tr><td></td><td>Event-Driven</td><td>Asynchronous Messaging</td><td>이벤트 기반 아키텍처에서의 Circuit Breaker 적용</td></tr><tr><td></td><td>CQRS</td><td>Command Query Separation</td><td>읽기/쓰기 분리 시 Circuit Breaker 적용 방안</td></tr><tr><td><strong>운영 기술</strong></td><td>Observability</td><td>관찰 가능성</td><td>로그, 메트릭, 트레이스를 통한 시스템 상태 파악</td></tr><tr><td></td><td>Chaos Engineering</td><td>장애 주입</td><td>의도적 장애를 통한 시스템 복원력 검증</td></tr><tr><td></td><td>SRE</td><td>Site Reliability Engineering</td><td>신뢰성 중심의 운영 방법론과 Circuit Breaker 통합</td></tr></tbody></table><hr><h2 id=용어-정리-1>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리-1>#</a></h2><table><thead><tr><th>카테고리</th><th>용어</th><th>설명</th></tr></thead><tbody><tr><td><strong>아키텍처</strong></td><td>Microservices Architecture</td><td>대규모 애플리케이션을 독립적으로 배포 가능한 작은 서비스들로 분해하는 아키텍처 패턴</td></tr><tr><td></td><td>Service Mesh</td><td>마이크로서비스 간 통신을 관리하는 인프라스트럭처 계층</td></tr><tr><td></td><td>API Gateway</td><td>클라이언트와 백엔드 서비스 사이의 진입점 역할을 하는 서버</td></tr><tr><td><strong>복원력</strong></td><td>Fault Tolerance</td><td>시스템이 일부 구성 요소의 장애에도 불구하고 정상적으로 작동할 수 있는 능력</td></tr><tr><td></td><td>Graceful Degradation</td><td>시스템의 일부가 실패할 때 핵심 기능을 유지하면서 부가 기능을 점진적으로 제한하는 설계 원칙</td></tr><tr><td></td><td>Fail-Fast</td><td>오류 상황에서 빠르게 실패를 보고하여 전체 시스템의 안정성을 보장하는 설계 원칙</td></tr><tr><td><strong>상태 관리</strong></td><td>State Machine</td><td>유한한 수의 상태와 상태 간 전환 규칙을 정의한 계산 모델</td></tr><tr><td></td><td>Circuit Breaker State</td><td>Closed(정상), Open(차단), Half-Open(반개방) 세 가지 주요 상태</td></tr><tr><td><strong>모니터링</strong></td><td>Metrics</td><td>시스템의 성능과 동작을 측정하는 수치 데이터</td></tr><tr><td></td><td>SLA (Service Level Agreement)</td><td>서비스 제공자와 고객 간의 서비스 수준 합의</td></tr><tr><td></td><td>SLO (Service Level Objective)</td><td>SLA 달성을 위한 구체적이고 측정 가능한 목표</td></tr><tr><td><strong>구현 기술</strong></td><td>Hystrix</td><td>Netflix 에서 개발한 Circuit Breaker 라이브러리 (현재 유지보수 모드)</td></tr><tr><td></td><td>Resilience4j</td><td>현대적인 Java 기반 복원력 라이브러리, Hystrix 의 후속작</td></tr><tr><td></td><td>Polly</td><td>.NET 환경을 위한 복원력 라이브러리</td></tr></tbody></table><hr><h2 id=참고-및-출처-1>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-1>#</a></h2><ul><li><a href=https://learn.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker>Circuit Breaker Pattern - Azure Architecture Center</a></li><li><a href=https://www.baeldung.com/cs/microservices-circuit-breaker-pattern>Circuit Breaker Pattern in Microservices - Baeldung</a></li><li><a href=https://resilience4j.readme.io/docs/circuitbreaker>Resilience4j Official Documentation</a></li><li><a href=https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/circuit-breaker.html>AWS Circuit Breaker Pattern Guide</a></li><li><a href=https://microservices.io/patterns/reliability/circuit-breaker.html>Microservices Pattern: Circuit Breaker</a></li><li><a href=https://netflixtechblog.com/>Netflix Technology Blog</a></li><li><a href=https://www.geeksforgeeks.org/spring-boot-circuit-breaker-pattern-with-resilience4j/>Spring Boot Circuit Breaker with Resilience4J - GeeksforGeeks</a></li></ul><hr><p>서킷 브레이커 패턴 (Circuit Breaker Pattern) 은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.<br>이 패턴의 주요 목적은 서비스 간 장애 전파를 방지하고, 시스템의 전반적인 안정성을 유지하는 것이다.</p><p>서킷 브레이커 패턴은 전기 회로의 차단기에서 착안한 개념이다.<br>전기 회로에서 과부하가 발생하면 차단기가 작동하여 전류를 차단하듯이, 소프트웨어 시스템에서도 특정 서비스에 문제가 발생했을 때 해당 서비스로의 호출을 차단한다.</p><p>서킷 브레이커 패턴을 효과적으로 사용하면 마이크로서비스 아키텍처에서 장애의 전파를 방지하고, 시스템의 전반적인 안정성과 복원력을 크게 향상시킬 수 있다. 이 패턴은 특히 외부 서비스에 의존성이 높은 시스템에서 매우 유용하며, 적절히 구현하면 사용자 경험을 크게 개선할 수 있다.</p><p><figure><img alt="Circuit Breaker Pattern" loading=lazy src=/img/1_yZHLhbM0q1bjfLbuaKU2TA.webp><figcaption>https://blog.bitsrc.io/circuit-breaker-pattern-3389a7b259f1</figcaption></figure></p><h3 id=서킷-브레이커의-상태>서킷 브레이커의 상태<a hidden class=anchor aria-hidden=true href=#서킷-브레이커의-상태>#</a></h3><p>서킷 브레이커는 일반적으로 다음 세 가지 상태를 가진다:</p><ol><li><strong>Closed (닫힘)</strong>: 정상 상태로, 모든 요청이 외부 서비스로 전달된다.</li><li><strong>Open (열림)</strong>: 요청 실패 횟수가 임계치를 초과한 상태로, 외부 서비스로의 요청을 차단한다.</li><li><strong>Half-Open (반열림)</strong>: 일정 시간이 지난 후, 일부 요청을 보내어 외부 서비스가 회복되었는지 확인한다.</li></ol><h3 id=동작-원리>동작 원리<a hidden class=anchor aria-hidden=true href=#동작-원리>#</a></h3><ol><li><p><strong>정상 상태 (Closed)</strong>: 서비스가 정상적으로 동작하는 상태이다.</p></li><li><p><strong>장애 감지 (Open 으로 전환)</strong>:</p><ul><li>서비스 호출 실패율이 설정된 임계치를 초과하면 서킷 브레이커가 Open 상태로 전환된다.</li><li>이 상태에서는 외부 서비스로의 호출을 즉시 차단하고, 빠른 실패 (Fail Fast) 응답을 반환한다.</li></ul></li><li><p><strong>복구 시도 (Half-Open)</strong>:</p><ul><li>Open 상태가 일정 시간 지속된 후, Half-Open 상태로 전환된다.</li><li>이 상태에서는 제한된 수의 요청만 외부 서비스로 전달하여 서비스의 회복 여부를 확인한다.</li></ul></li><li><p><strong>상태 전이</strong>:</p><ul><li>Half-Open 상태에서 요청이 성공하면 Closed 상태로 돌아간다.</li><li>실패하면 다시 Open 상태로 전환된다.</li></ul></li></ol><h3 id=구현-방법>구현 방법<a hidden class=anchor aria-hidden=true href=#구현-방법>#</a></h3><p>서킷 브레이커 패턴을 구현하는 방법은 여러 가지가 있다.<br>대표적인 방법으로는 다음과 같은 것들이 있다:</p><ol><li><p><strong>Resilience4j 사용</strong>: Java 에서 널리 사용되는 라이브러리로, 스프링 부트와 통합이 쉽다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5>5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6>6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>CircuitBreakerConfig</span><span class=w> </span><span class=n>config</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CircuitBreakerConfig</span><span class=p>.</span><span class=na>custom</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>failureRateThreshold</span><span class=p>(</span><span class=n>50</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>waitDurationInOpenState</span><span class=p>(</span><span class=n>Duration</span><span class=p>.</span><span class=na>ofMillis</span><span class=p>(</span><span class=n>1000</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>slidingWindowSize</span><span class=p>(</span><span class=n>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=na>build</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>CircuitBreakerRegistry</span><span class=w> </span><span class=n>registry</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CircuitBreakerRegistry</span><span class=p>.</span><span class=na>of</span><span class=p>(</span><span class=n>config</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>CircuitBreaker</span><span class=w> </span><span class=n>circuitBreaker</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>registry</span><span class=p>.</span><span class=na>circuitBreaker</span><span class=p>(</span><span class=s>&#34;myCircuitBreaker&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Spring Cloud Circuit Breaker</strong>: 스프링 클라우드에서 제공하는 추상화 계층을 사용할 수 있다.</p></li><li><p><strong>Istio 와 같은 서비스 메시 사용</strong>: 쿠버네티스 환경에서는 Istio 를 통해 서킷 브레이커를 구현할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span><span class=lnt id=hl-15-17><a class=lnlinks href=#hl-15-17>17</a>
</span><span class=lnt id=hl-15-18><a class=lnlinks href=#hl-15-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>networking.istio.io/v1alpha3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>DestinationRule</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>circuit-breaker-for-httpbin</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>host</span><span class=p>:</span><span class=w> </span><span class=l>httpbin</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>trafficPolicy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>connectionPool</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>tcp</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>maxConnections</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>http</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>http1MaxPendingRequests</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>maxRequestsPerConnection</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>outlierDetection</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>consecutiveErrors</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>interval</span><span class=p>:</span><span class=w> </span><span class=l>1s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>baseEjectionTime</span><span class=p>:</span><span class=w> </span><span class=l>3m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>maxEjectionPercent</span><span class=p>:</span><span class=w> </span><span class=m>100</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=주의사항-및-고려사항>주의사항 및 고려사항<a hidden class=anchor aria-hidden=true href=#주의사항-및-고려사항>#</a></h3><ol><li><strong>임계값 설정</strong>: 실패 임계값과 시간 간격을 적절히 설정해야 합니다. 너무 낮으면 불필요한 차단이, 너무 높으면 장애 전파를 막지 못할 수 있다.</li><li><strong>폴백 메커니즘</strong>: 서킷이 열렸을 때 대체 응답을 제공하는 폴백 로직을 구현해야 한다.</li><li><strong>모니터링</strong>: 서킷 브레이커의 상태와 성능을 지속적으로 모니터링해야 한다.</li><li><strong>테스트</strong>: 다양한 장애 시나리오에 대한 테스트를 수행하여 서킷 브레이커가 예상대로 동작하는지 확인해야 한다.</li></ol><h3 id=구현-예시>구현 예시<a hidden class=anchor aria-hidden=true href=#구현-예시>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span><span class=lnt id=hl-16-22><a class=lnlinks href=#hl-16-22>22</a>
</span><span class=lnt id=hl-16-23><a class=lnlinks href=#hl-16-23>23</a>
</span><span class=lnt id=hl-16-24><a class=lnlinks href=#hl-16-24>24</a>
</span><span class=lnt id=hl-16-25><a class=lnlinks href=#hl-16-25>25</a>
</span><span class=lnt id=hl-16-26><a class=lnlinks href=#hl-16-26>26</a>
</span><span class=lnt id=hl-16-27><a class=lnlinks href=#hl-16-27>27</a>
</span><span class=lnt id=hl-16-28><a class=lnlinks href=#hl-16-28>28</a>
</span><span class=lnt id=hl-16-29><a class=lnlinks href=#hl-16-29>29</a>
</span><span class=lnt id=hl-16-30><a class=lnlinks href=#hl-16-30>30</a>
</span><span class=lnt id=hl-16-31><a class=lnlinks href=#hl-16-31>31</a>
</span><span class=lnt id=hl-16-32><a class=lnlinks href=#hl-16-32>32</a>
</span><span class=lnt id=hl-16-33><a class=lnlinks href=#hl-16-33>33</a>
</span><span class=lnt id=hl-16-34><a class=lnlinks href=#hl-16-34>34</a>
</span><span class=lnt id=hl-16-35><a class=lnlinks href=#hl-16-35>35</a>
</span><span class=lnt id=hl-16-36><a class=lnlinks href=#hl-16-36>36</a>
</span><span class=lnt id=hl-16-37><a class=lnlinks href=#hl-16-37>37</a>
</span><span class=lnt id=hl-16-38><a class=lnlinks href=#hl-16-38>38</a>
</span><span class=lnt id=hl-16-39><a class=lnlinks href=#hl-16-39>39</a>
</span><span class=lnt id=hl-16-40><a class=lnlinks href=#hl-16-40>40</a>
</span><span class=lnt id=hl-16-41><a class=lnlinks href=#hl-16-41>41</a>
</span><span class=lnt id=hl-16-42><a class=lnlinks href=#hl-16-42>42</a>
</span><span class=lnt id=hl-16-43><a class=lnlinks href=#hl-16-43>43</a>
</span><span class=lnt id=hl-16-44><a class=lnlinks href=#hl-16-44>44</a>
</span><span class=lnt id=hl-16-45><a class=lnlinks href=#hl-16-45>45</a>
</span><span class=lnt id=hl-16-46><a class=lnlinks href=#hl-16-46>46</a>
</span><span class=lnt id=hl-16-47><a class=lnlinks href=#hl-16-47>47</a>
</span><span class=lnt id=hl-16-48><a class=lnlinks href=#hl-16-48>48</a>
</span><span class=lnt id=hl-16-49><a class=lnlinks href=#hl-16-49>49</a>
</span><span class=lnt id=hl-16-50><a class=lnlinks href=#hl-16-50>50</a>
</span><span class=lnt id=hl-16-51><a class=lnlinks href=#hl-16-51>51</a>
</span><span class=lnt id=hl-16-52><a class=lnlinks href=#hl-16-52>52</a>
</span><span class=lnt id=hl-16-53><a class=lnlinks href=#hl-16-53>53</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>enum</span> <span class=kn>import</span> <span class=n>Enum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>State</span><span class=p>(</span><span class=n>Enum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>CLOSED</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=n>OPEN</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=n>HALF_OPEN</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CircuitBreaker</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>failure_threshold</span><span class=p>,</span> <span class=n>recovery_time</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>failure_threshold</span> <span class=o>=</span> <span class=n>failure_threshold</span>  <span class=c1># 허용되는 최대 실패 횟수</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>recovery_time</span> <span class=o>=</span> <span class=n>recovery_time</span>  <span class=c1># Open 상태에서 Half-Open 상태로 전환되기까지의 시간</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=n>State</span><span class=o>.</span><span class=n>CLOSED</span>  <span class=c1># 초기 상태는 Closed</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>failure_count</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 실패 횟수 초기화</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>last_failure_time</span> <span class=o>=</span> <span class=kc>None</span>  <span class=c1># 마지막 실패 시간 초기화</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>call</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>func</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>==</span> <span class=n>State</span><span class=o>.</span><span class=n>OPEN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=bp>self</span><span class=o>.</span><span class=n>last_failure_time</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>recovery_time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=n>State</span><span class=o>.</span><span class=n>HALF_OPEN</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Circuit is open. Request blocked.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>failure_count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>last_failure_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>failure_count</span> <span class=o>&gt;=</span> <span class=bp>self</span><span class=o>.</span><span class=n>failure_threshold</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=n>State</span><span class=o>.</span><span class=n>OPEN</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=n>e</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>==</span> <span class=n>State</span><span class=o>.</span><span class=n>HALF_OPEN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=n>State</span><span class=o>.</span><span class=n>CLOSED</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>failure_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>unstable_service</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 이 함수는 불안정한 서비스를 시뮬레이션합니다.</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Service failure&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;Service success&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>circuit_breaker</span> <span class=o>=</span> <span class=n>CircuitBreaker</span><span class=p>(</span><span class=n>failure_threshold</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=n>recovery_time</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>response</span> <span class=o>=</span> <span class=n>circuit_breaker</span><span class=o>.</span><span class=n>call</span><span class=p>(</span><span class=n>unstable_service</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>response</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><hr><h2 id=참고-및-출처-2>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처-2>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circuit Breaker</h2></header><div class=entry-content><p>Circuit Breaker Circuit Breaker는 분산 시스템에서 장애가 발생하거나 과부하 상태일 때 서비스의 안정성을 유지하기 위한 디자인 패턴이다. 이는 전기 회로의 차단기에서 영감을 받아, 연속적인 실패 시 추가적인 장애 전파를 방지하고 시스템을 보호한다. 특히 마이그레이션 과정에서 서비스 간 의존성이 높은 환경에서 필수적으로 적용된다.
서킷 브레이커 패턴의 기본 개념 서킷 브레이커 패턴은 전기 회로의 차단기에서 영감을 받은 소프트웨어 디자인 패턴으로, 가정용 전기 차단기가 과부하 시 전기를 차단하여 화재를 방지하는 것처럼, 소프트웨어 서킷 브레이커는 장애가 발생한 서비스에 대한 호출을 일시적으로 중단하여 시스템 전체의 안정성을 보호한다.
...</p></div><footer class=entry-footer><span title='2025-04-01 15:17:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circuit Breaker" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/circuit-breaker/circuit-breaker/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>