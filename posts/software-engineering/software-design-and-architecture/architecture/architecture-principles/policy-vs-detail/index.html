<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Policy vs. Detail | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Architecture-Principles,Policy-vs-Detail"><meta name=description content="Policy vs. Detail 은 소프트웨어 시스템을 고수준 정책 (비즈니스 규칙, 핵심 로직) 과 저수준 세부사항 (프레임워크, 데이터베이스, UI) 으로 분리하는 아키텍처 원칙이다. 의존성 규칙을 통해 세부사항이 정책에 의존하도록 하여 변경에 유연하고 테스트 가능한 시스템을 만들 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/policy-vs-detail/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/policy-vs-detail/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/policy-vs-detail/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/policy-vs-detail/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Policy vs. Detail"><meta property="og:description" content="Policy vs. Detail 은 소프트웨어 시스템을 고수준 정책 (비즈니스 규칙, 핵심 로직) 과 저수준 세부사항 (프레임워크, 데이터베이스, UI) 으로 분리하는 아키텍처 원칙이다. 의존성 규칙을 통해 세부사항이 정책에 의존하도록 하여 변경에 유연하고 테스트 가능한 시스템을 만들 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Policy vs. Detail"><meta name=twitter:description content="Policy vs. Detail 은 소프트웨어 시스템을 고수준 정책 (비즈니스 규칙, 핵심 로직) 과 저수준 세부사항 (프레임워크, 데이터베이스, UI) 으로 분리하는 아키텍처 원칙이다. 의존성 규칙을 통해 세부사항이 정책에 의존하도록 하여 변경에 유연하고 테스트 가능한 시스템을 만들 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":""},{"@type":"ListItem","position":3,"name":"Software Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Architecture","item":"https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/"},{"@type":"ListItem","position":5,"name":"Architecture Principles","item":"https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/"},{"@type":"ListItem","position":6,"name":"Policy vs. Detail","item":"https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/policy-vs-detail/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href>Software Engineering</a>&nbsp;»&nbsp;<a href>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/>Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/architecture-principles/>Architecture Principles</a></div><h1>Policy vs. Detail</h1><div class=post-description>Policy vs. Detail 은 소프트웨어 시스템을 고수준 정책 (비즈니스 규칙, 핵심 로직) 과 저수준 세부사항 (프레임워크, 데이터베이스, UI) 으로 분리하는 아키텍처 원칙이다. 의존성 규칙을 통해 세부사항이 정책에 의존하도록 하여 변경에 유연하고 테스트 가능한 시스템을 만들 수 있다.</div></header><div class=post-content><h2 id=policy-vs-detail>Policy vs. Detail<a hidden class=anchor aria-hidden=true href=#policy-vs-detail>#</a></h2><p>소프트웨어 아키텍처에서 Policy 와 Detail 의 분리는 시스템의 핵심 비즈니스 규칙과 외부 인터페이스, 기술적 구현을 명확히 구분하는 원칙이다. 정책은 시스템의 전체적인 동작과 구조를 정의하는 중요한 비즈니스 규칙과 관련된 결정으로, 변경될 가능성이 적고 안정적이다. 반면 상세 구현은 정책을 실행하기 위한 특정 기술, 프레임워크, 데이터베이스 등과 같은 구체적인 실행 방법에 관한 것으로, 상대적으로 자주 변경된다. 이러한 분리는 의존성을 올바른 방향으로 관리하여 시스템의 유연성, 확장성, 유지보수성을 크게 향상시키는 데 핵심적인 역할을 한다. 의존성 규칙을 통해 세부사항이 정책에 의존하도 함으로써 비즈니스 로직의 안정성을 보장하고, 기술적 변경으로부터 핵심 로직을 보호할 수 있다.</p><h3 id=배경>배경<a hidden class=anchor aria-hidden=true href=#배경>#</a></h3><p>Policy vs. Detail 개념은 Robert C. Martin 의 Clean Architecture 에서 체계화되었으며, 다음과 같은 문제점들을 해결하기 위해 등장했다:</p><ul><li><strong>기술 중심 설계의 문제</strong>: 비즈니스 로직이 기술적 세부사항에 강하게 결합</li><li><strong>변경의 파급효과</strong>: 데이터베이스나 프레임워크 변경이 비즈니스 로직에 영향</li><li><strong>테스트의 어려움</strong>: 외부 의존성으로 인한 단위 테스트 복잡성</li><li><strong>재사용성 부족</strong>: 특정 기술에 종속된 비즈니스 로직</li></ul><h3 id=policy-vs-detail-비교>Policy vs. Detail 비교<a hidden class=anchor aria-hidden=true href=#policy-vs-detail-비교>#</a></h3><p>Policy 와 Detail 의 구분은 소프트웨어 시스템에서 변경의 이유와 빈도, 중요도에 따라 결정된다. 이 분리를 통해 시스템의 핵심 가치를 보호하고 기술적 변경에 대한 유연성을 확보할 수 있다.</p><table><thead><tr><th>구분</th><th>정책 (Policy)</th><th>상세 구현 (Detail)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>시스템의 고수준 비즈니스 규칙과 핵심 도메인 로직</td><td>정책을 실현하는 저수준 기술과 구체적 구현 메커니즘</td></tr><tr><td><strong>역할</strong></td><td>" 무엇 " 과 " 왜 " 를 결정</td><td>" 어떻게 " 를 구현</td></tr><tr><td><strong>포함 내용</strong></td><td>비즈니스 로직, 도메인 규칙, 엔티티, 유스케이스, 도메인 서비스</td><td>데이터베이스, UI, 웹 프레임워크, 외부 API, 통신 프로토콜 등</td></tr><tr><td><strong>특징</strong></td><td>안정적이며 변경 빈도가 낮음기술적 세부사항에 독립적시스템의 핵심 가치를 반영</td><td>변동성이 크고 교체 가능함구체적 기술과 환경에 의존정책을 지원하는 수단</td></tr><tr><td><strong>결정 주체</strong></td><td>아키텍트, 설계자</td><td>개발자, 인프라 담당자</td></tr><tr><td><strong>의존 방향</strong></td><td>외부 (상세 구현) 을 알지 않음</td><td>내부 (정책) 에 정의된 추상화에 의존함</td></tr><tr><td>추상성</td><td>높음</td><td>낮음</td></tr><tr><td>안정성 요구</td><td>높음</td><td>상대적으로 낮음</td></tr><tr><td>변경 빈도</td><td>낮음</td><td>높음</td></tr><tr><td>변경 이유</td><td>비즈니스 요구사항 변경</td><td>기술적 요구사항 변경</td></tr><tr><td>유연성</td><td>높음 (변화에 강함)</td><td>낮음 (기술 변화에 민감)</td></tr><tr><td>문서화</td><td>선언적, 개념적</td><td>절차적, 구체적</td></tr><tr><td>영향</td><td>시스템 전체에 영향</td><td>특정 모듈/컴포넌트에 국한</td></tr><tr><td>재사용성</td><td>높음</td><td>낮음</td></tr><tr><td><strong>예시</strong></td><td>주문 생성 시 재고 검증, 가격 계산 규칙, 포인트 적립 정책 등</td><td>PostgreSQL, React, REST API, Kafka, gRPC 등</td></tr></tbody></table><ul><li>정책과 상세 구현을 분리함으로써 변경에 대한 영향을 최소화하고, 시스템의 유연성과 유지보수성을 향상시킬 수 있다.</li><li>정책과 상세 구현을 분리하기 위해서는 명확한 경계 (Boundary) 설정이 필요하다:<ul><li>아키텍처 경계는 시스템의 다양한 영역 간의 명확한 구분선</li><li>각 경계는 인터페이스와 어댑터를 통해 소통</li><li>경계를 넘어서는 데이터는 단순하고 독립적인 구조여야 함</li><li>경계 인터페이스는 내부 원 (정책) 이 소유해야 함</li><li>각 영역에서 사용하는 데이터 형식은 해당 영역의 필요에 최적화되어야 함</li></ul></li><li>로버트 C. 마틴 (Uncle Bob) 의 클린 아키텍처 (Clean Architecture) 는 정책 vs 상세 구현 원칙을 잘 구현한 아키텍처 패턴이다:<ul><li>동심원 형태의 계층 구조로 표현됨</li><li>내부로 갈수록 더 높은 수준의 추상화 (정책) 를 포함</li><li>외부 원은 메커니즘 (상세 구현) 을, 내부 원은 정책을 담당</li><li>의존성 규칙을 철저히 준수하여 내부로만 향하도록 설계</li><li>정책은 구체적인 기술 선택에 영향을 받지 않음</li></ul></li></ul><p><strong>Policy 중심 설계 vs. Detail 중심 설계 강점과 약점</strong>:</p><table><thead><tr><th>접근 방식</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td><strong>Policy 중심 설계</strong></td><td>• 비즈니스 로직 안정성<br>• 높은 재사용성<br>• 독립적 테스트 가능<br>• 기술 변경에 유연함</td><td>• 초기 설계 복잡도<br>• 추상화 오버헤드<br>• 학습 곡선 존재</td></tr><tr><td><strong>Detail 중심 설계</strong></td><td>• 빠른 프로토타이핑<br>• 단순한 구조<br>• 프레임워크 활용 용이</td><td>• 기술 종속성<br>• 변경 시 파급효과<br>• 테스트 어려움<br>• 재사용성 부족</td></tr></tbody></table><p><strong>의존성 규칙 (Dependency Rule)</strong>:</p><table><thead><tr><th>항목</th><th>내용</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>소스 코드 의존성이 항상 내부 (정책) 를 향해야 한다는 원칙</td></tr><tr><td><strong>주요 원칙</strong></td><td>- 고수준 모듈은 저수준 모듈에 의존하지 않음<br>- 저수준 모듈은 고수준 모듈이 정의한 인터페이스에 의존</td></tr><tr><td><strong>기반 원칙</strong></td><td>의존성 역전 원칙 (Dependency Inversion Principle)</td></tr><tr><td><strong>목적</strong></td><td>시스템의 핵심 비즈니스 로직을 기술 변화로부터 보호하고, 아키텍처의 유연성과 유지보수성 향상</td></tr></tbody></table><h3 id=목적-및-효과>목적 및 효과<a hidden class=anchor aria-hidden=true href=#목적-및-효과>#</a></h3><h4 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h4><table><thead><tr><th><strong>목적</strong></th><th><strong>Policy (정책)</strong></th><th><strong>Detail (상세 구현)</strong></th></tr></thead><tbody><tr><td><strong>핵심 가치 보호</strong></td><td>핵심 비즈니스 로직의 안정성과 지속성 보장</td><td>기술적 세부사항 변화로부터 정책 보호</td></tr><tr><td><strong>유연성 확보</strong></td><td>다양한 구현 환경에 적응 가능정책 재사용 용이</td><td>기술 스택 또는 외부 시스템의 자유로운 교체 가능</td></tr><tr><td><strong>테스트 용이성</strong></td><td>외부 의존성 없이 순수한 로직 테스트 가능</td><td>Mock/Stub 등을 통한 외부 시스템 테스트 가능</td></tr><tr><td><strong>유지보수성 향상</strong></td><td>정책 변경이 시스템 전체에 영향을 주지 않도록 국소화</td><td>기술 업그레이드가 비즈니스 로직에 영향 없음</td></tr></tbody></table><h4 id=효과>효과<a hidden class=anchor aria-hidden=true href=#효과>#</a></h4><table><thead><tr><th><strong>핵심 효과</strong></th><th><strong>Policy (정책)</strong></th><th><strong>Detail (상세 구현)</strong></th></tr></thead><tbody><tr><td><strong>시스템 복잡성 관리</strong></td><td>- 비즈니스 로직을 명확히 분리해 상위 개념 중심으로 시스템 구조화<br>- 도메인 중심 설계로 이해도 향상</td><td>- 구현 계층을 모듈화하여 기술적 복잡성 캡슐화<br>- 프레임워크, 라이브러리 의존 분리로 유지 쉬움</td></tr><tr><td><strong>변경 영향 범위 최소화</strong></td><td>- 정책 변경 시 UI, DB 등 외부 요소에 영향 없음<br>- 규칙 변경의 국소화 가능</td><td>- 기술 변경 시 정책에 영향 없음<br>- 구현 교체 (예: DB, API) 시 다른 계층에 영향 제한</td></tr><tr><td><strong>시스템 유지보수성 향상</strong></td><td>- 규칙 중심으로 기능을 명확히 분리<br>- 확장성과 구조 변경이 쉬움</td><td>- 기술 진화에 따른 모듈 교체 용이<br>- 환경별 구성 차이에 대응 쉬움</td></tr><tr><td><strong>기술적 결정 유연성 확보</strong></td><td>- 초기 설계 시 기술에 의존하지 않고 정책 중심으로 설계 가능<br>- 기술 결정 지연 가능</td><td>- 최신 기술 도입 시 정책과 무관하게 모듈 교체<br>- 선택 자유도 및 확장성 확보</td></tr><tr><td><strong>테스트 용이성 증가</strong></td><td>- 순수 로직 테스트가 가능하므로 빠르고 안정적인 단위 테스트 가능</td><td>- 의존성 격리를 통한 Mock 테스트 가능<br>- 통합 테스트 구성 용이</td></tr></tbody></table><p>개발자의 관점에서 <strong>정책 (Policy)</strong> 과 <strong>상세 구현 (Detail)</strong> 의 분리는 <strong>관심사의 분리 (Separation of Concerns, SoC)</strong> 원칙을 매우 효과적으로 실현한다.</p><table><thead><tr><th>SoC 관점 요소</th><th>정책과 상세 구현 분리가 기여하는 방식</th></tr></thead><tbody><tr><td><strong>기능별 책임 분리</strong></td><td>비즈니스 규칙 (정책) 은 <strong>&rsquo; 무엇을 할 것인가 &lsquo;</strong> 에만 집중하고, 기술 세부사항 (상세 구현) 은 <strong>&rsquo; 어떻게 할 것인가 &lsquo;</strong> 에 집중함</td></tr><tr><td><strong>모듈 간 결합도 감소</strong></td><td>정책과 구현 간의 <strong>결합도를 낮추고</strong>, 구현은 정책의 추상화 (인터페이스) 에만 의존함으로써, 구현체 변경이 정책에 영향 없음</td></tr><tr><td><strong>변경에 대한 영향 최소화</strong></td><td>프레임워크, DB 등 저수준 세부사항 변경 시에도 정책 (핵심 로직) 은 영향받지 않음 → <strong>하나의 concern 이 다른 concern 에 영향을 주지 않음</strong></td></tr><tr><td><strong>독립적 개발 및 테스트 가능</strong></td><td>정책을 외부 시스템과 분리해 개발할 수 있으며, 테스트 시에도 구현 (예: DB, API) 없이 <strong>mock/stub 으로 검증 가능</strong></td></tr><tr><td><strong>코드 가독성과 유지보수성 향상</strong></td><td>각 레이어가 명확한 책임을 갖기 때문에 <strong>의도 파악과 코드 구조 이해가 쉬워지고, 유지보수 비용이 낮아짐</strong></td></tr></tbody></table><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><p>정책 vs 상세 구현 원칙은 소프트웨어 아키텍처에서 다음과 같은 주요 기능과 역할을 수행한다:</p><table><thead><tr><th>핵심 항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>관심사 분리 (Separation of Concerns)</strong></td><td>- 각 계층이 <strong>단일 책임 원칙 (SRP)</strong> 을 가짐<br>- 비즈니스 로직이 기술 구현으로부터 격리됨<br>- 개발자는 한 가지 관심사에 집중 가능</td></tr><tr><td><strong>의존성 관리 (Dependency Management)</strong></td><td>- 의존성은 항상 <strong>상세 구현 → 정책</strong> 방향으로 흐름<br>- 안정적인 정책 계층이 변동성 높은 구현 계층에 영향받지 않음<br>- <strong>의존성 역전 원칙 (DIP)</strong> 적용</td></tr><tr><td><strong>아키텍처 경계 정의 (Architectural Boundaries)</strong></td><td>- 관심사 간 <strong>명확한 인터페이스</strong> 정의<br>- <strong>데이터 변환 및 통신 규약</strong> 명세<br>- 계층 간 데이터 포맷 및 메시지 구조 표준화</td></tr><tr><td><strong>플러그인 아키텍처 지원 (Plug-in Architecture)</strong></td><td>- 상세 구현을 독립적이고 교체 가능한 <strong>플러그인</strong>으로 취급<br>- UI, DB, 프레임워크 등을 유연하게 교체 가능<br>- 핵심 정책 로직과 구현 간 결합도 최소화</td></tr></tbody></table><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><p>정책 vs 상세 구현 원칙의 주요 특징은 다음과 같다:</p><table><thead><tr><th>핵심 원칙</th><th>설명</th></tr></thead><tbody><tr><td><strong>계층화된 아키텍처</strong></td><td>- 정책은 내부, 구현은 외부에 위치한 동심원 구조<br>- 각 레이어는 추상화 수준에 따라 분리됨<br>- 레이어 간 통신은 명확한 인터페이스 기반</td></tr><tr><td><strong>소스 코드 의존성 방향 제어</strong></td><td>- <strong>저수준 모듈 → 고수준 모듈</strong> 방향으로만 의존성 흐름<br>- 고수준 모듈은 저수준 모듈의 존재를 모름<br>- 런타임 의존성과 컴파일 의존성 분리 가능</td></tr><tr><td><strong>프레임워크 독립성</strong></td><td>- 정책 계층은 프레임워크에 전혀 의존하지 않음<br>- 프레임워크는 " 플러그인 " 처럼 사용<br>- 교체 및 업그레이드가 용이한 구조 확보</td></tr><tr><td><strong>테스트 용이성</strong></td><td>- 비즈니스 로직은 외부 요소 없이 단독 테스트 가능<br>- 각 계층은 독립적으로 테스트 가능<br>- 테스트 자동화 및 커버리지 향상에 기여</td></tr></tbody></table><h3 id=정책과-구현-분리를-위한-핵심-아키텍처-설계-원칙>정책과 구현 분리를 위한 핵심 아키텍처 설계 원칙<a hidden class=anchor aria-hidden=true href=#정책과-구현-분리를-위한-핵심-아키텍처-설계-원칙>#</a></h3><p>정책 vs 상세 구현 원칙을 구현하기 위한 핵심 원칙들은 다음과 같다:</p><table><thead><tr><th><strong>원칙명</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>의존성 규칙 (Dependency Rule)</strong></td><td>- 소스 코드 의존성은 항상 <strong>외부 → 내부 (저수준 → 고수준)</strong> 으로 향함<br>- 정책 계층은 구현 계층의 존재를 알지 않아야 함<br>- 안정적인 요소에만 의존하도록 설계</td></tr><tr><td><strong>의존성 역전 원칙 (DIP)</strong></td><td>- 고수준 모듈과 저수준 모듈 모두 <strong>추상화 (인터페이스)</strong> 에 의존<br>- 세부 구현은 추상화에 따라야 하며, 추상화는 구현에 의존하지 않음<br>SOLID 원칙 중 하나</td></tr><tr><td><strong>플러그인 아키텍처 원칙</strong></td><td>- DB, UI, 프레임워크 등을 <strong>교체 가능한 플러그인</strong> 으로 간주<br>- 핵심 로직이 중심에 위치하고, 플러그인이 이를 참조함<br>- 플러그인은 핵심 로직이 정의한 인터페이스를 구현</td></tr><tr><td><strong>경계 컨텍스트 원칙 (Boundary Context)</strong></td><td>- 시스템을 도메인 또는 기능 단위로 <strong>명확한 경계</strong> 로 구분<br>- 인터페이스 및 데이터 포맷은 단순하고 중립적<br>- 한 영역의 변경이 다른 영역에 영향을 주지 않도록 설계</td></tr></tbody></table><h3 id=정책-policy-vs-상세-구현-detail-의-아키텍처-설계-원칙-정리>정책 (Policy) vs. 상세 구현 (Detail) 의 아키텍처 설계 원칙 정리<a hidden class=anchor aria-hidden=true href=#정책-policy-vs-상세-구현-detail-의-아키텍처-설계-원칙-정리>#</a></h3><table><thead><tr><th><strong>구분</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>의존성 방향 제어</strong></td><td>- 정책 (고수준) 은 구현 (저수준) 에 의존하지 않음<br>- 구현이 정책의 <strong>인터페이스</strong>에 의존함<br>- DIP (의존성 역전 원칙) 적용</td></tr><tr><td><strong>계층화된 구조</strong></td><td>- 동심원 계층 구조<br>- 내부에서 외부 방향: <code>Entities → Use Cases → Interface Adapters → Frameworks</code></td></tr><tr><td><strong>경계 및 인터페이스 설계</strong></td><td>- 각 계층 간 <strong>명확한 경계</strong> 정의<br>- <strong>인터페이스는 정책 계층에서 소유</strong><br>- 경계를 넘는 데이터는 중립적, 단순한 구조 사용</td></tr><tr><td><strong>데이터 흐름 제어</strong></td><td>- 외부 → 내부: 사용자 입력, 외부 이벤트 등<br>- 내부 → 외부: 비즈니스 처리 결과를 외부에 전달 (예: UI, DB 저장 등)</td></tr><tr><td><strong>의존성 규칙</strong></td><td>- 소스코드 의존성은 항상 <strong>바깥에서 안쪽으로</strong> 향함<br>- 외부 계층 변경이 내부 계층에 영향을 주지 않음</td></tr></tbody></table><pre class=mermaid>flowchart TD
    %% Clean Architecture Layers
    subgraph &#34;Clean Architecture Layers&#34;
        D[Frameworks &amp; Drivers&lt;br/&gt;프레임워크 &amp; 드라이버]
        C[Interface Adapters&lt;br/&gt;인터페이스 어댑터]
        U[Use Cases&lt;br/&gt;유스케이스]
        E[Entities&lt;br/&gt;엔티티]
    end

    %% 의존성 흐름
    D --&gt; C
    C --&gt; U
    U --&gt; E

    %% 시맨틱 분류: Policy vs Detail
    classDef policy fill:#4caf50,color:#fff,stroke:#2e7d32,stroke-width:2px
    classDef adapter fill:#ff9800,color:#fff,stroke:#ef6c00,stroke-width:2px
    classDef detail fill:#f44336,color:#fff,stroke:#b71c1c,stroke-width:2px

    class E,U policy
    class C adapter
    class D detail
</pre><p><strong>의존성 규칙 (Dependency Rule):</strong></p><ol><li>소스 코드 의존성은 항상 안쪽 (고수준) 을 향해야 함</li><li>내부 계층은 외부 계층에 대해 아무것도 알지 말아야 함</li><li>외부 계층의 변경이 내부 계층에 영향을 주지 않아야 함</li></ol><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><p>정책 vs 상세 구현 원칙은 다양한 아키텍처 패턴을 통해 구현될 수 있다:</p><table><thead><tr><th>유형</th><th>설명</th><th>특징</th></tr></thead><tbody><tr><td>클린 아키텍처<br>(Clean Architecture)</td><td>로버트 C. 마틴 (Uncle Bob) 이 제안한 아키텍처</td><td>- 동심원 형태의 레이어<br>- 의존성이 항상 내부로 향함<br>- 엔티티, 유스케이스, 인터페이스 어댑터, 프레임워크의 4 계층 구조</td></tr><tr><td>헥사고날 아키텍처<br>(Hexagonal Architecture)</td><td>알리스테어 콕번 (Alistair Cockburn) 이 제안한 포트와 어댑터 아키텍처</td><td>- 내부 (비즈니스 로직) 와 외부 (인프라) 구분<br>- 포트 (인터페이스) 와 어댑터 (구현) 로 연결<br>- 육각형 형태로 모든 방향의 외부 연결 표현</td></tr><tr><td>양파 아키텍처<br>(Onion Architecture)</td><td>제프리 팔레모 (Jeffrey Palermo) 가 제안한 계층형 아키텍처</td><td>- 동심원 형태의 구조<br>- 중심에 도메인 모델 위치<br>- 도메인 서비스, 애플리케이션 서비스, 외부 계층으로 구성</td></tr><tr><td>DCI 아키텍처<br>(Data, Context, Interaction)</td><td>트라이그브 렌스켜그 (Trygve Reenskaug) 와 제임스 코플리엔 (James Coplien) 이 제안</td><td>- 데이터 (객체 상태), 컨텍스트 (환경), 상호작용 (행위) 분리<br>- 역할 기반 모델링<br>- 사용자 멘탈 모델과 코드 일치 강조</td></tr><tr><td>BCE 아키텍처<br>(Boundary-Control-Entity)</td><td>아이바 제이콥슨 (Ivar Jacobson) 이 제안한 객체지향 아키텍처</td><td>- 경계 (UI), 제어 (비즈니스 로직), 엔티티 (데이터) 로 구분<br>- 유스케이스 중심 설계<br>- 자코비안 객체 지향 소프트웨어 공학 (OOSE) 의 일부</td></tr><tr><td>계층형 아키텍처<br>(Layered Architecture)</td><td>가장 일반적인 다층 아키텍처 패턴</td><td>- 수평적 계층으로 구성<br>- 각 계층은 특정 책임 담당<br>- 일반적으로 표현, 비즈니스, 영속성 계층으로 구분</td></tr><tr><td>CQRS<br>(Command Query Responsibility Segregation)</td><td>명령과 조회 책임 분리</td><td>- 명령 (데이터 변경) 과 조회 (데이터 읽기) 모델 분리<br>- 각 모델에 최적화된 구현 가능<br>- 이벤트 소싱과 자주 결합</td></tr></tbody></table><h4 id=동심원-계층-구조-concentric-layer-structure>동심원 계층 구조 (Concentric Layer Structure)<a hidden class=anchor aria-hidden=true href=#동심원-계층-구조-concentric-layer-structure>#</a></h4><p>클린 아키텍처에서는 동심원 형태의 계층 구조로 표현된다:</p><table><thead><tr><th><strong>계층명</strong></th><th><strong>주요 역할 및 내용</strong></th><th><strong>의존성</strong></th><th><strong>특징</strong></th></tr></thead><tbody><tr><td><strong>엔티티 계층 (Entities Layer)</strong></td><td>- 핵심 비즈니스 규칙과 데이터 구조 포함<br>- 기업 전반에 적용되는 도메인 모델<br>- 가장 안정적인 로직 포함</td><td>없음 (독립적)</td><td>- 변경 가능성 가장 낮음<br>- 재사용성 높음</td></tr><tr><td><strong>유스케이스 계층 (Use Cases Layer)</strong></td><td>- 애플리케이션의 특정 비즈니스 로직<br>- 유스케이스 단위의 도메인 로직 실행<br>- 엔티티와 상호작용</td><td>엔티티 계층만 의존</td><td>- UI/DB 독립<br>- 비즈니스 절차 흐름 제어</td></tr><tr><td><strong>인터페이스 어댑터 계층 (Interface Adapters Layer)</strong></td><td>- 외부 ↔ 내부 데이터 변환<br>- 컨트롤러, 프레젠터, 게이트웨이 포함<br>- MVC 구성요소 위치</td><td>유스케이스, 엔티티 계층에 의존</td><td>- 입출력 포맷 처리<br>- 외부 세계와 내부 도메인 연결 역할</td></tr><tr><td><strong>프레임워크 및 드라이버 계층 (Frameworks & Drivers Layer)</strong></td><td>- DB, UI, 웹 서버, 외부 API 등<br>- 기술적 구현 및 외부 도구 위치<br>- 상세 구현 담당</td><td>인터페이스 계층에서 정의한 추상화에 의존 (역방향)</td><td>- 변경 가능성 높음<br>- 내부 정책에 영향 주지 않아야 함</td></tr></tbody></table><ul><li><strong>의존성 방향</strong>은 항상 <strong>바깥 → 안쪽 (Detail → Policy)</strong> 으로 향함</li><li><strong>안쪽 계층 (Entities, Use Cases)</strong> 은 외부 기술에 대해 전혀 알지 않아야 함</li><li><strong>가장 바깥 계층 (Frameworks & Drivers)</strong> 은 교체 가능한 플러그인처럼 동작해야 함</li><li><strong>각 계층은 자신보다 더 안쪽 계층만 참조 가능</strong></li></ul><h4 id=헥사고날-아키텍처-hexagonal-architecture-구조>헥사고날 아키텍처 (Hexagonal Architecture) 구조<a hidden class=anchor aria-hidden=true href=#헥사고날-아키텍처-hexagonal-architecture-구조>#</a></h4><p>또 다른 구현 방식인 헥사고날 아키텍처는 다음과 같은 구조를 가진다:</p><table><thead><tr><th><strong>구성 요소</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>내부 영역 (Inside)</strong></td><td>- 핵심 비즈니스 로직 및 도메인 모델<br>- 외부 기술에 대한 의존 없음<br>- 포트를 통해 외부와 통신</td></tr><tr><td><strong>외부 영역 (Outside)</strong></td><td>- 데이터베이스, 사용자 인터페이스, 외부 API 등<br>- 내부 로직과 직접 연결되지 않음<br>- 어댑터를 통해 통신</td></tr><tr><td><strong>포트 (Ports)</strong></td><td>- 내부 영역에서 정의한 <strong>인터페이스</strong><br>- 내부가 외부에 필요로 하는 동작의 명세<br>- 예: <code>OrderRepository</code>, <code>PaymentGatewayPort</code></td></tr><tr><td><strong>어댑터 (Adapters)</strong></td><td>- 포트를 구현한 실제 클래스 또는 모듈<br>- 외부 시스템과 포트 간 데이터 변환 수행<br>- 예: <code>OrderRepositoryImpl</code>, <code>HttpPaymentGatewayAdapter</code></td></tr></tbody></table><ul><li>내부는 <strong>순수한 비즈니스 로직</strong>만 포함하며, 외부와의 연결은 모두 추상화된 포트를 통해 이루어짐</li><li>외부 시스템 (예: DB, API) 은 내부의 포트를 구현하는 어댑터를 통해 연결됨</li><li>포트와 어댑터는 <strong>경계 (Interface) 와 구현체 (Implementation)</strong> 관계로 분리됨</li><li>이 구조는 <strong>테스트 용이성</strong>, <strong>프레임워크 독립성</strong>, <strong>유연한 기술 교체</strong>에 유리함</li></ul><h4 id=클린-아키텍처-계층-구조-및-의존성-흐름>클린 아키텍처 계층 구조 및 의존성 흐름<a hidden class=anchor aria-hidden=true href=#클린-아키텍처-계층-구조-및-의존성-흐름>#</a></h4><pre class=mermaid>graph TB
    subgraph &#34;Policy Layer (정책 계층)&#34;
        E[Entities&lt;br/&gt;엔티티]
        UC[Use Cases&lt;br/&gt;유스케이스]
        DS[Domain Services&lt;br/&gt;도메인 서비스]
    end
    
    subgraph &#34;Detail Layer (세부사항 계층)&#34;
        DB[(Database&lt;br/&gt;데이터베이스)]
        WEB[Web Framework&lt;br/&gt;웹 프레임워크]
        UI[User Interface&lt;br/&gt;사용자 인터페이스]
        API[External API&lt;br/&gt;외부 API]
    end
    
    subgraph &#34;Interface Adapters (인터페이스 어댑터)&#34;
        REPO[Repository&lt;br/&gt;저장소]
        CTRL[Controller&lt;br/&gt;컨트롤러]
        PRES[Presenter&lt;br/&gt;프레젠터]
    end
    
    E --&gt; UC
    UC --&gt; DS
    
    UC -.-&gt; REPO
    UC -.-&gt; CTRL
    UC -.-&gt; PRES
    
    REPO --&gt; DB
    CTRL --&gt; WEB
    PRES --&gt; UI
    API --&gt; CTRL
    
    classDef policy fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef detail fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef adapter fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    
    class E,UC,DS policy
    class DB,WEB,UI,API detail
    class REPO,CTRL,PRES adapter
</pre><table><thead><tr><th>계층</th><th>구성 요소</th><th>역할 및 설명</th></tr></thead><tbody><tr><td><strong>Policy Layer (정책 계층)</strong></td><td><code>Entities</code>, <code>Use Cases</code>, <code>Domain Services</code></td><td>시스템의 핵심 비즈니스 로직과 도메인 규칙을 정의하는 가장 내부 계층</td></tr><tr><td><strong>Interface Adapters (인터페이스 어댑터)</strong></td><td><code>Repository</code>, <code>Controller</code>, <code>Presenter</code></td><td>정책 계층과 세부 구현 계층을 연결하는 어댑터 계층. 추상화된 인터페이스와 구현체를 연결</td></tr><tr><td><strong>Detail Layer (세부사항 계층)</strong></td><td><code>Database</code>, <code>Web Framework</code>, <code>UI</code>, <code>External API</code></td><td>기술적으로 구체적인 구현 세부사항을 포함하며, 변경 가능성이 높은 외부 요소들</td></tr></tbody></table><p><strong>범주별 구성 요소</strong></p><table><thead><tr><th><strong>구성 범주</strong></th><th><strong>구성요소</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>Policy Components<br>(정책 구성요소)</strong></td><td><code>Entities</code></td><td>도메인의 핵심 비즈니스 규칙을 캡슐화한 객체</td></tr><tr><td></td><td><code>Use Cases</code></td><td>사용자 요구사항을 처리하는 애플리케이션 비즈니스 로직</td></tr><tr><td></td><td><code>Domain Services</code></td><td>복수 엔티티 간의 도메인 규칙을 처리하는 도메인 계층의 서비스</td></tr><tr><td><strong>Detail Components<br>(세부사항 구성요소)</strong></td><td><code>Frameworks</code></td><td>Express, NestJS, Spring 등 웹 프레임워크 및 기술적 도구</td></tr><tr><td></td><td><code>Databases</code></td><td>PostgreSQL, MongoDB 등 데이터 저장소</td></tr><tr><td></td><td><code>External Interfaces</code></td><td>외부 API, 파일 시스템, 클라우드 서비스 등 시스템 외부와 통신하는 인터페이스</td></tr><tr><td><strong>Boundary Components<br>(경계 구성요소)</strong></td><td><code>Interface Adapters</code></td><td>도메인 모델 ↔ 외부 세계 간 데이터 포맷 변환 역할</td></tr><tr><td></td><td><code>Controllers</code></td><td>사용자 요청을 수신하여 유스케이스를 호출하는 입구 역할</td></tr><tr><td></td><td><code>Presenters</code></td><td>응답 데이터를 ViewModel 또는 DTO 로 변환하는 역할</td></tr><tr><td><strong>Optional Components<br>(선택 구성요소)</strong></td><td><code>Gateways</code></td><td>외부 API 또는 시스템과의 연결을 위한 어댑터 역할</td></tr><tr><td></td><td><code>Event Buses</code></td><td>도메인 이벤트 기반의 비동기 메시지 전달 메커니즘</td></tr><tr><td></td><td><code>Caching Layer</code></td><td>Redis 등 캐시를 이용한 성능 최적화 계층</td></tr></tbody></table><p><strong>의존성 방향</strong>:</p><ul><li><strong>항상 바깥에서 안쪽 (Detail → Adapter → Policy)</strong> 으로 향함</li><li><strong>Use Case</strong>는 <strong>Repository</strong>, <strong>Controller</strong>, <strong>Presenter</strong>에 대해 추상화만 알고 있으며, 실제 구현은 어댑터 계층에서 담당</li><li>이는 <strong>정책은 구현을 몰라도 되며</strong>, <strong>구현은 정책의 인터페이스를 따르도록 강제</strong>하는 구조</li></ul><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th><strong>항목</strong></th><th><strong>장점</strong></th><th><strong>단점</strong></th></tr></thead><tbody><tr><td><strong>유지보수성</strong></td><td>- 코드 구조가 명확하여 수정이 쉬움<br>- 변경 범위가 국한되어 안정성 향상</td><td>- 인터페이스와 경계 설계에 초기 복잡성 존재</td></tr><tr><td><strong>테스트 용이성</strong></td><td>- 비즈니스 로직을 외부 의존성 없이 테스트 가능<br>- mock/stub 기반 테스트 용이</td><td>- 계층 구조로 인한 테스트 구성 비용 증가 가능</td></tr><tr><td><strong>기술 독립성</strong></td><td>- 프레임워크나 DB 교체가 자유로움<br>- 핵심 로직은 기술 변화에 영향 없음</td><td>- 모든 기술에 대한 추상화 구현 필요<br>- 과한 일반화는 오버엔지니어링 초래 가능</td></tr><tr><td><strong>개발 생산성</strong></td><td>- 병렬 개발 가능<br>- 명확한 계약 (인터페이스) 기반 협업 용이</td><td>- 초기 개발 속도 저하<br>- 설계 및 추상화 설계에 많은 노력 필요</td></tr><tr><td><strong>시스템 수명/확장성</strong></td><td>- 오래된 구성 요소의 현대화 가능<br>- 새로운 기능 추가가 기존 코드 영향 없이 가능</td><td>- 과도한 추상화는 복잡성 증가 및 성능 저하 유발 가능</td></tr><tr><td><strong>관심사 분리</strong></td><td>- 각 계층이 명확한 책임을 가짐<br>- 복잡성 분산으로 이해 용이</td><td>- 전 팀원의 설계 이해도 필요<br>- 원칙 미숙지 시 잘못된 분리 구조 발생 위험</td></tr><tr><td><strong>문서 및 구조 명확성</strong></td><td>- 시스템의 구조와 흐름이 분명해짐<br>- 모듈 간 역할 구분이 명확</td><td>- 인터페이스, 포트, 어댑터에 대한 문서화/관리 부담 증가</td></tr><tr><td><strong>성능 및 효율성</strong></td><td>(간접 이점) → 변경 격리로 인해 운영 안정성 확보 가능</td><td>- 계층 간 데이터 변환 및 호출로 인한 런타임 오버헤드 발생 가능</td></tr><tr><td><strong>적용 범위</strong></td><td>- 대규모, 장기 시스템에 매우 적합</td><td>- 소규모 프로젝트에서는 과도한 설계일 수 있음 (YAGNI 위반 가능성)</td></tr></tbody></table><ul><li><strong>장점</strong>: 유지보수성, 테스트성, 유연성, 확장성, 협업 구조에 탁월함</li><li><strong>단점</strong>: 초기 설계 비용, 팀 역량, 성능 이슈, 과도한 추상화의 위험</li></ul><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><p>다양한 환경과 상황에서 정책 vs 상세 구현 원칙을 적용하는 방법에 대한 실무 예시는 다음과 같다:</p><h4 id=시스템-유형별-계층화-아키텍처-구현>시스템 유형별 계층화 아키텍처 구현<a hidden class=anchor aria-hidden=true href=#시스템-유형별-계층화-아키텍처-구현>#</a></h4><table><thead><tr><th>적용 분야</th><th>구현 방법</th><th>이점</th><th>주요 고려사항</th></tr></thead><tbody><tr><td><strong>웹 애플리케이션</strong></td><td>- 컨트롤러: 요청 처리 및 라우팅<br>- 서비스 계층: 비즈니스 로직<br>- 리포지토리: 데이터 액세스 추상화<br>ORM: 데이터베이스 액세스 구현</td><td>- UI 변경에 영향 받지 않는 비즈니스 로직<br>- 데이터베이스 교체 용이성<br>- 테스트 용이성 증가</td><td>- 계층 간 데이터 변환 오버헤드<br>- 적절한 경계 설정<br>DTO 설계</td></tr><tr><td><strong>마이크로서비스</strong></td><td>- API 게이트웨이: 외부 인터페이스<br>- 서비스 코어: 비즈니스 로직<br>- 인프라 어댑터: 외부 시스템 연동<br>- 메시지 브로커: 서비스 간 통신</td><td>- 서비스 독립성 보장<br>- 기술 다양성 지원<br>- 독립적 배포 및 확장</td><td>- 서비스 경계 설정<br>- 분산 시스템 복잡성<br>- 일관성 유지</td></tr><tr><td><strong>모바일 앱</strong></td><td>- UI 계층: 화면 및 사용자 상호작용<br>- 프레젠터: 화면 로직<br>- 도메인 계층: 비즈니스 로직<br>- 데이터 계층: 로컬/원격 데이터 액세스</td><td>- 다양한 플랫폼 지원 용이성<br>UI 변경 독립성<br>- 오프라인 동작 지원</td><td>- 모바일 환경 제약<br>- 성능 최적화<br>- 디바이스 특화 기능 처리</td></tr><tr><td><strong>임베디드 시스템</strong></td><td>- 하드웨어 추상화 계층 (HAL)<br>- 드라이버 계층<br>- 미들웨어<br>- 애플리케이션 계층</td><td>- 하드웨어 독립성<br>- 코드 재사용성<br>- 테스트 용이성</td><td>- 자원 제약 환경<br>- 실시간 요구사항<br>- 최적화 필요성</td></tr><tr><td><strong>기업 애플리케이션</strong></td><td>- 프레젠테이션 계층<br>- 애플리케이션 서비스<br>- 도메인 모델<br>- 인프라스트럭처 계층</td><td>- 복잡한 비즈니스 규칙 관리<br>- 장기적 유지보수성<br>- 팀 간 병렬 개발</td><td>- 복잡한 레거시 시스템 통합<br>- 대규모 팀 조정<br>- 성능 요구사항</td></tr><tr><td><strong>클라우드 네이티브</strong></td><td>- API 게이트웨이<br>- 서버리스 함수<br>- 이벤트 기반 통합<br>- 관리형 서비스 어댑터</td><td>- 클라우드 서비스 교체 용이성<br>- 서버리스 아키텍처 지원<br>- 멀티 클라우드 전략</td><td>- 클라우드 의존성 관리<br>- 분산 시스템 복잡성<br>- 비용 최적화</td></tr><tr><td><strong>게임 개발</strong></td><td>- 렌더링 엔진<br>- 게임 로직<br>- 물리 엔진<br>- 입력 처리 시스템</td><td>- 엔진 교체 용이성<br>- 플랫폼 독립성<br>- 재사용 가능한 게임 로직</td><td>- 성능 중심 설계<br>- 실시간 처리 요구사항<br>- 리소스 제약</td></tr></tbody></table><h4 id=업무-영역에-따른-policy-vs-detail-구조-적용-사례>업무 영역에 따른 Policy Vs Detail 구조 적용 사례<a hidden class=anchor aria-hidden=true href=#업무-영역에-따른-policy-vs-detail-구조-적용-사례>#</a></h4><table><thead><tr><th>분야</th><th>Policy 예시</th><th>Detail 예시</th><th>분리 방법</th></tr></thead><tbody><tr><td><strong>전자상거래</strong></td><td>주문 처리 규칙, 할인 정책</td><td>결제 게이트웨이, 쇼핑몰 UI</td><td>Repository 패턴, Service 인터페이스</td></tr><tr><td><strong>금융 시스템</strong></td><td>대출 심사 규칙, 이자 계산</td><td>외부 신용평가 API, 웹 인터페이스</td><td>Gateway 패턴, Adapter 패턴</td></tr><tr><td><strong>콘텐츠 관리</strong></td><td>콘텐츠 검열 규칙, 분류 로직</td><td>파일 저장소, CMS UI</td><td>Strategy 패턴, Factory 패턴</td></tr><tr><td><strong>헬스케어</strong></td><td>진단 알고리즘, 처방 규칙</td><td>의료기기 연동, EMR 시스템</td><td>Observer 패턴, Command 패턴</td></tr><tr><td><strong>교육 플랫폼</strong></td><td>학습 진도 관리, 평가 기준</td><td>LMS UI, 동영상 스트리밍</td><td>Template Method, State 패턴</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-결제-시스템의-정책세부사항-분리>사례 1: 결제 시스템의 정책/세부사항 분리<a hidden class=anchor aria-hidden=true href=#사례-1-결제-시스템의-정책세부사항-분리>#</a></h4><p><strong>시나리오</strong>: 결제 정책 (할인 규칙, 승인 조건 등) 이 자주 변경됨. 외부 결제 게이트웨이, DB, UI 등은 빈번히 교체/변경됨.<br><strong>시스템 구성</strong>: 정책 (비즈니스 규칙) 은 도메인 계층에 집중, 외부 연동 및 데이터 저장은 인프라 계층에서 처리.<br><strong>워크플로우</strong>:</p><ol><li>사용자가 결제 요청 → 결제 정책 (Policy) 검증</li><li>정책 통과 시 외부 결제 게이트웨이 (Detail) 호출</li><li>결제 결과 저장 및 알림 처리 (Detail)<br><strong>다이어그램</strong></li></ol><pre class=mermaid>flowchart TD
    User[사용자]
    Policy[&#34;결제 정책(Policy)&#34;]
    Gateway[&#34;결제 게이트웨이(Detail)&#34;]
    DB[&#34;DB(Detail)&#34;]
    User --&gt; Policy
    Policy --&gt; Gateway
    Gateway --&gt; DB
</pre><h4 id=사례-2-온라인-뱅킹-시스템>사례 2: 온라인 뱅킹 시스템<a hidden class=anchor aria-hidden=true href=#사례-2-온라인-뱅킹-시스템>#</a></h4><p><strong>시나리오</strong>: 대형 은행의 온라인 뱅킹 시스템 구축</p><p><strong>시스템 구성</strong></p><pre class=mermaid>graph TB
    subgraph &#34;Policy Layer - 은행 핵심 업무&#34;
        AC[Account Entity&lt;br/&gt;계좌 엔티티]
        TR[Transfer Use Case&lt;br/&gt;이체 유스케이스]
        LN[Loan Service&lt;br/&gt;대출 서비스]
        FR[Fraud Detection&lt;br/&gt;부정거래 탐지]
    end
    
    subgraph &#34;Interface Adapters - 어댑터&#34;
        WC[Web Controller&lt;br/&gt;웹 컨트롤러]
        MF[Mobile Facade&lt;br/&gt;모바일 파사드]
        AR[Account Repository&lt;br/&gt;계좌 저장소]
        EG[External Gateway&lt;br/&gt;외부 게이트웨이]
    end
    
    subgraph &#34;Details - 기술적 세부사항&#34;
        WEB[Web UI&lt;br/&gt;웹 인터페이스]
        MOB[Mobile App&lt;br/&gt;모바일 앱]
        DB[(Core Banking DB&lt;br/&gt;핵심 은행 DB)]
        PAY[Payment Gateway&lt;br/&gt;결제 게이트웨이]
        KYC[KYC Service&lt;br/&gt;본인확인 서비스]
    end
    
    AC --&gt; TR
    TR --&gt; LN
    TR --&gt; FR
    
    TR -.-&gt; AR
    TR -.-&gt; EG
    WC --&gt; TR
    MF --&gt; TR
    
    WEB --&gt; WC
    MOB --&gt; MF
    AR --&gt; DB
    EG --&gt; PAY
    EG --&gt; KYC
    
    classDef policy fill:#e8f5e8,stroke:#2e7d32,stroke-width:3px
    classDef adapter fill:#fff3e0,stroke:#f57722,stroke-width:2px
    classDef detail fill:#ffebee,stroke:#c62828,stroke-width:2px
    
    class AC,TR,LN,FR policy
    class WC,MF,AR,EG adapter
    class WEB,MOB,DB,PAY,KYC detail
</pre><p><strong>워크플로우</strong>:</p><ol><li><strong>이체 요청 처리</strong>:<ul><li>사용자가 모바일 앱에서 이체 요청</li><li>Mobile Facade 가 요청을 받아 Transfer Use Case 로 전달</li><li>Transfer Use Case 가 비즈니스 규칙 검증 (잔액, 한도, 부정거래)</li><li>Account Repository 를 통해 계좌 정보 조회/업데이트</li><li>External Gateway 를 통해 타행 이체 처리</li></ul></li><li><strong>부정거래 탐지</strong>:<ul><li>Fraud Detection 서비스가 이체 패턴 분석</li><li>의심 거래 발견 시 이체 중단 및 알림</li></ul></li></ol><p><strong>각 계층의 역할</strong>:</p><ul><li><strong>Policy Layer (은행 핵심 업무)</strong>:<ul><li>계좌 관리 규칙: 최소 잔액, 이체 한도</li><li>이체 업무 규칙: 본인 확인, 수수료 계산</li><li>대출 심사 규칙: 신용 평가, 담보 평가</li><li>부정거래 탐지: 패턴 분석, 위험도 계산</li></ul></li><li><strong>Detail Layer (기술적 세부사항)</strong>:<ul><li>웹/모바일 UI: 사용자 인터페이스</li><li>데이터베이스: Oracle, PostgreSQL 등</li><li>외부 연동: SWIFT, 카드사 API</li><li>인증 시스템: ActiveDirectory, LDAP</li></ul></li></ul><h4 id=사례-3-전자상거래-플랫폼의-할인-정책-적용>사례 3: 전자상거래 플랫폼의 할인 정책 적용<a hidden class=anchor aria-hidden=true href=#사례-3-전자상거래-플랫폼의-할인-정책-적용>#</a></h4><p><strong>시나리오</strong>: 전자상거래 플랫폼의 할인 정책 적용<br><strong>정책 (Policy)</strong>: 특정 기간 동안 특정 상품에 대해 10% 할인 적용<br><strong>세부사항 (Detail)</strong>: 할인 계산 로직, UI 표시, 데이터베이스 저장 방식 등<br><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>graph TD
  A[Discount Policy Module] --&gt; B[Discount Calculation Service]
  B --&gt; C[UI Component]
  B --&gt; D[Database]
</pre><p><strong>Workflow</strong>:</p><ol><li>사용자가 상품을 조회하면, 할인 정책 모듈에서 해당 상품에 대한 할인 여부를 확인</li><li>할인 계산 서비스에서 할인 금액을 계산</li><li>UI 컴포넌트에서 할인 금액을 표시</li><li>주문 시 데이터베이스에 할인 금액 저장</li></ol><p><strong>차이점</strong>: 할인 정책 변경 시 정책 모듈만 수정하면 되며, 계산 로직이나 UI, 데이터베이스는 변경하지 않아도 되어 유지보수가 용이</p><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th><strong>분류</strong></th><th><strong>고려사항</strong></th><th><strong>설명</strong></th><th><strong>권장사항</strong></th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>계층 분리</td><td>정책 (비즈니스 로직) 과 상세 구현 (기술) 을 명확히 구분</td><td>Clean Architecture, DDD 적용단일 책임 원칙 (SRP) 준수</td></tr><tr><td></td><td>인터페이스 정의</td><td>계층 간 통신은 추상화된 계약을 통해 이루어져야 함</td><td>인터페이스 기반 설계, 인터페이스 분리 원칙 (ISP) 적용</td></tr><tr><td></td><td>의존성 관리</td><td>의존성은 고수준에서 정의하고, 저수준에서 구현</td><td>의존성 주입 (DI) 사용의존성 방향: 외부 → 내부</td></tr><tr><td><strong>테스트 전략</strong></td><td>테스트 용이성</td><td>정책과 세부사항이 분리되어야 독립적 테스트 가능</td><td>단위 테스트 (UseCase, Entity), 통합 테스트 (Adapter, Infrastructure) 병행</td></tr><tr><td><strong>데이터 전략</strong></td><td>데이터 형식과 전달 구조</td><td>계층 간 데이터 형식이 복잡성 및 결합도에 영향</td><td>불변 DTO 사용, 중립적인 데이터 포맷, 양방향 매퍼 활용</td></tr><tr><td></td><td>데이터 변환 위치</td><td>데이터 변환 책임 위치가 명확하지 않으면 책임이 불분명해짐</td><td>각 계층의 진입점에서 변환 수행, 책임 명확히 구분</td></tr><tr><td><strong>경계 관리</strong></td><td>경계 위치 결정</td><td>경계 설정이 과하거나 부족하면 시스템 유연성 저하</td><td>변경 가능성과 중요도 기준으로 경계 설정적절한 수의 경계 유지</td></tr><tr><td></td><td>경계 내부 구조</td><td>경계 내부도 잘 구조화되어야 유지보수성 확보 가능</td><td>내부 구조 계층화, 책임 분리, 세부 구현 은닉</td></tr><tr><td><strong>조직 운영</strong></td><td>팀 구조와 역량</td><td>팀이 아키텍처를 이해하지 못하면 원칙이 무너지기 쉬움</td><td>아키텍처 교육 및 리뷰 문화 조성팀 구조를 아키텍처와 정렬</td></tr><tr><td></td><td>문서화</td><td>추상화 및 인터페이스 설계 시 명확한 설명 필요</td><td>정책은 선언적으로, 구현은 절차적으로 문서화아키텍처 결정 문서 (ADR) 유지</td></tr><tr><td><strong>도입 전략</strong></td><td>점진적 도입</td><td>기존 시스템에 전면 적용 시 위험</td><td>새 기능부터 적용, 점진적 리팩토링</td></tr><tr><td></td><td>적절한 추상화 수준</td><td>불필요한 추상화는 복잡성만 증가</td><td>YAGNI 원칙 적용실제 변경 가능성을 기반으로 추상화</td></tr><tr><td><strong>성능 최적화</strong></td><td>계층 통신 및 응답 시간</td><td>계층 간 과도한 변환 및 호출은 성능 오버헤드 유발</td><td>성능 중요 경로 식별 및 최적화필요 시 계층 우회 허용적절한 캐싱 적용</td></tr><tr><td></td><td>메모리 사용량</td><td>중간 객체 과도 생성으로 인한 메모리 낭비 가능</td><td>객체 재사용, 객체 풀링 고려메모리 프로파일링</td></tr><tr><td><strong>도구/기술</strong></td><td>프레임워크 및 도구 선택</td><td>기존 기술과의 호환성 또는 지원 부족</td><td>DI 컨테이너 등 아키텍처 구현 지원 도구 활용기술 선택 시 아키텍처 적합성 고려</td></tr><tr><td><strong>복잡성 제어</strong></td><td>오버엔지니어링 방지</td><td>작은 프로젝트에서 불필요한 계층 도입은 역효과</td><td>프로젝트 규모/복잡도에 따라 추상화 적용최소한의 아키텍처로 시작, 필요 시 확장</td></tr></tbody></table><ul><li><strong>설계</strong>, <strong>데이터 처리</strong>, <strong>경계 구조</strong>, <strong>조직 운영</strong>, <strong>도입 방식</strong>, <strong>성능 고려</strong> 등 다면적 요소 필요</li><li>기술적 아키텍처뿐 아니라 <strong>조직적/문화적 기반</strong>도 함께 설계해야 성공적으로 적용 가능</li><li>실무에서는 <strong>과하지 않게</strong>, <strong>점진적으로</strong>, <strong>현실적인 변경 가능성 기반으로 설계</strong>하는 것이 핵심</li></ul><h3 id=최적화하기-위한-고려사항>최적화하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항>#</a></h3><table><thead><tr><th><strong>최적화 대상</strong></th><th><strong>문제점 / 고려사항</strong></th><th><strong>권장 최적화 방법</strong></th></tr></thead><tbody><tr><td><strong>데이터 변환</strong></td><td>- 계층 간 DTO 변환 오버헤드<br>- 직렬화/역직렬화 비용</td><td>- DTO 구조 최적화<br>- 필요한 필드만 선택<br>- 직렬화 포맷 개선 (e.g. MessagePack, Protobuf)</td></tr><tr><td><strong>메모리 사용</strong></td><td>- 중간 객체 과다 생성<br>- GC 부담<br>- 메모리 누수 가능성</td><td>- 객체 풀링 / 재사용<br>- 불변 객체 사용<br>- 순환 참조 방지, 약참조 활용</td></tr><tr><td><strong>계층 통신 구조</strong></td><td>- 과도한 계층 분리로 인한 호출 비용<br>- 중복된 호출 패턴</td><td>- 불필요한 계층 제거<br>- 배치 처리, 일괄 요청<br>- 계층 우회 API 설계</td></tr><tr><td><strong>데이터베이스 접근</strong></td><td>- N+1 쿼리 문제<br>- 느린 조인 / 하위 쿼리<br>- 불필요한 트랜잭션</td><td>- JPQL 최적화, 쿼리 튜닝<br>- Lazy Loading + Fetch Join<br>- 커넥션 풀 튜닝</td></tr><tr><td><strong>네트워크 호출</strong></td><td>- 외부 API 또는 서비스 간 호출 지연<br>- 요청 수 증가에 따른 병목</td><td>- 캐싱 적용<br>- 데이터 압축<br>- 지연 처리 (lazy/eager batching)</td></tr><tr><td><strong>CPU 사용률</strong></td><td>- 인터페이스 호출 오버헤드<br>- 비효율적인 알고리즘</td><td>- 연산 병목 지점 식별 (HotSpot 분석)<br>- 연산 최적화 (예: 정렬, 탐색)<br>- 멀티 스레딩, JIT 활용</td></tr><tr><td><strong>비동기 처리</strong></td><td>- 모든 요청을 동기적으로 처리할 경우 응답 지연</td><td>- 메시지 큐 기반 이벤트 처리<br>- 비동기 I/O<br>- Coroutine / Thread 기반 처리</td></tr><tr><td><strong>캐싱 전략</strong></td><td>- 반복된 연산 / 외부 호출에 대해 캐시 미적용<br>- 캐시 일관성 유지 어려움</td><td>- 다층 캐싱 구조 (메모리 + 디스크)<br>- TTL/ETag 기반 만료 정책<br>- 읽기 중심 로직에 계산 캐시 적용</td></tr><tr><td><strong>병렬 처리 / 동시성</strong></td><td>- 공유 자원 경합, 락 경쟁<br>- 단일 스레드 병목</td><td>- 불변 객체 사용<br>- 병렬 분산 처리<br>- 메시지 패싱 방식 구조 적용</td></tr><tr><td><strong>지연 로딩</strong></td><td>- 모든 데이터 즉시 로딩 시 오버헤드 발생</td><td>- 실제 접근 시점에 로딩 (Lazy)<br>- Fetch 전략 조절 (select only needed)<br>- 필요한 필드만 쿼리</td></tr><tr><td><strong>배치 처리</strong></td><td>- 동일 작업 반복 수행으로 인한 왕복 횟수 증가</td><td>- 일괄 처리 API 도입<br>- 컬렉션 기반 처리<br>- 데이터 집계 및 정렬 사전 수행</td></tr><tr><td><strong>로드 밸런싱</strong></td><td>- 트래픽 집중 시 특정 노드 과부하</td><td>- 로드 밸런서 적용 (L7/L4)<br>- 세션 스티키 전략 사용<br>- 클러스터링</td></tr><tr><td><strong>모니터링 및 진단</strong></td><td>- 병목 위치 파악 어려움<br>- 성능 문제 사전 인지 불가</td><td>- APM 도구 사용 (예: Prometheus, Grafana, Datadog)<br>- 리소스/쿼리 프로파일링<br>- 지표 기반 최적화</td></tr><tr><td><strong>조기 최적화 방지</strong></td><td>- 사용되지 않을 최적화 작업으로 복잡성 증가</td><td>- 실측 기반의 최적화<br>- 우선순위 기반 병목 개선<br>- 가독성/유지보수성과의 균형 고려</td></tr></tbody></table><ul><li><strong>핵심 최적화 방향</strong>: " 계층 경계 최소화 &ldquo;, " 불필요한 데이터/자원 최소화 &ldquo;, " 병목 지점 식별 후 집중 "</li><li><strong>성능보다 먼저 고려할 것</strong>: <strong>측정 기반 최적화</strong>, <strong>유지보수성 유지</strong>, <strong>실제 사용 패턴 반영</strong></li><li>실무에서는 <strong>캐싱 + 비동기 + 병렬 처리</strong>의 적절한 조합이 가장 실용적인 성능 향상 수단</li></ul><h3 id=장점과-단점-1>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점-1>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>비즈니스 로직 보호</td><td>기술적 변경으로부터 핵심 로직 격리</td></tr><tr><td></td><td>높은 테스트 용이성</td><td>Policy 계층의 독립적 단위 테스트 가능</td></tr><tr><td></td><td>기술 독립성</td><td>프레임워크나 데이터베이스 교체 용이</td></tr><tr><td></td><td>재사용성 향상</td><td>다양한 환경에서 Policy 재사용 가능</td></tr><tr><td></td><td>유지보수성</td><td>변경 영향 범위 제한으로 안전한 수정</td></tr><tr><td></td><td>확장성</td><td>새로운 Detail 추가 시 Policy 영향 없음</td></tr><tr><td>⚠️ 단점</td><td>초기 복잡도 증가</td><td>설계 단계에서 더 많은 고민과 시간 필요</td></tr><tr><td></td><td>추상화 오버헤드</td><td>인터페이스와 어댑터로 인한 코드 증가</td></tr><tr><td></td><td>성능 오버헤드</td><td>계층 간 데이터 변환으로 인한 처리 지연</td></tr><tr><td></td><td>과도한 설계 위험</td><td>불필요한 추상화로 인한 복잡성 증가</td></tr><tr><td></td><td>팀 학습 비용</td><td>새로운 개발 패러다임 습득 필요</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>주제</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>설계 원칙</td><td>단일 책임 원칙 (Single Responsibility Principle)</td><td>모듈이 하나의 책임만을 가지도록 설계하여 응집도를 높이는 원칙</td></tr><tr><td></td><td>인터페이스 분리 원칙 (Interface Segregation Principle)</td><td>클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 분리하는 원칙</td></tr><tr><td></td><td>의존성 역전 원칙 (Dependency Inversion Principle)</td><td>고수준 모듈이 저수준 모듈에 의존하지 않고, 추상화에 의존하도록 설계하여 결합도를 낮추는 원칙</td></tr><tr><td></td><td>관심사의 분리 (Separation of Concerns)</td><td>시스템을 정책과 구현 세부사항 등 다양한 관심사로 분리하여 유지보수를 용이하게 함</td></tr><tr><td>아키텍처</td><td>헥사고날 아키텍처 (Hexagonal Architecture)</td><td>내부의 정책과 외부의 입출력 세부사항을 포트와 어댑터로 명확히 구분하는 아키텍처</td></tr><tr><td></td><td>클린 아키텍처 (Clean Architecture)</td><td>핵심 비즈니스 로직 (Policy) 을 중심에 두고, 외부 세부사항은 바깥 계층으로 배치</td></tr><tr><td></td><td>온리워드 (Onlyward) 종속성 원칙</td><td>내부 (core) 계층에서 외부 (detail) 계층으로만 의존이 향하도록 설계하는 원칙</td></tr><tr><td>언어/도구</td><td>인터페이스 중심 설계 (Interface-driven Design)</td><td>세부 구현보다 인터페이스 정의에 집중하여 유연한 구조를 구성할 수 있도록 함</td></tr><tr><td>테스트</td><td>모킹 (Mock) 기반 테스트</td><td>정책 계층은 테스트 대상이 되고, 세부사항은 Mock 처리하여 단위 테스트를 용이하게 함</td></tr></tbody></table><h3 id=하위-주제로-분류해서-추가적으로-학습해야할-내용들>하위 주제로 분류해서 추가적으로 학습해야할 내용들<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류해서-추가적으로-학습해야할-내용들>#</a></h3><table><thead><tr><th>카테고리</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>SOLID 원칙 심화</td><td>Policy-Detail 분리의 이론적 기반</td></tr><tr><td></td><td>관심사 분리 (SoC)</td><td>시스템 구성 요소의 역할과 책임 분리</td></tr><tr><td></td><td>최소 지식 원칙 (LoD)</td><td>객체 간 결합도 최소화 방법</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>계층형 아키텍처</td><td>전통적인 N-tier 아키텍처와의 비교</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>비동기 통신을 통한 결합도 감소</td></tr><tr><td></td><td>서비스 지향 아키텍처</td><td>서비스 단위의 Policy-Detail 분리</td></tr><tr><td><strong>구현 기법</strong></td><td>의존성 주입 프레임워크</td><td>Spring, Guice, Dagger 등 활용법</td></tr><tr><td></td><td>모킹과 테스트 더블</td><td>Policy 테스트를 위한 Detail 대체 기법</td></tr><tr><td></td><td>설정 관리</td><td>환경별 Detail 설정 외부화</td></tr><tr><td><strong>도메인 설계</strong></td><td>도메인 주도 설계 (DDD)</td><td>비즈니스 도메인 중심의 Policy 설계</td></tr><tr><td></td><td>바운디드 컨텍스트</td><td>도메인 경계에 따른 Policy 분리</td></tr><tr><td></td><td>애그리게이트 패턴</td><td>도메인 객체의 일관성 보장</td></tr></tbody></table><h3 id=관련-분야와-함께-추가로-학습해야할-내용들>관련 분야와 함께 추가로 학습해야할 내용들<a hidden class=anchor aria-hidden=true href=#관련-분야와-함께-추가로-학습해야할-내용들>#</a></h3><table><thead><tr><th>관련 분야</th><th>주제</th><th>설명</th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>마이크로서비스 아키텍처</td><td>서비스 간 Policy-Detail 분리 적용</td></tr><tr><td></td><td>서버리스 아키텍처</td><td>함수 단위의 Policy 구현</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>비동기 이벤트를 통한 결합도 해제</td></tr><tr><td><strong>클라우드 컴퓨팅</strong></td><td>컨테이너 기술 (Docker/K8s)</td><td>Policy 와 Detail 의 독립적 배포</td></tr><tr><td></td><td>서비스 메시 (Service Mesh)</td><td>마이크로서비스 간 통신 추상화</td></tr><tr><td></td><td>API 게이트웨이</td><td>외부 접근의 단일 진입점</td></tr><tr><td><strong>데이터베이스</strong></td><td>CQRS (Command Query Responsibility Segregation)</td><td>읽기/쓰기 모델 분리</td></tr><tr><td></td><td>이벤트 소싱</td><td>상태 변화의 이벤트 기반 관리</td></tr><tr><td></td><td>폴리글랏 영속성</td><td>용도별 최적화된 저장소 선택</td></tr><tr><td><strong>테스팅</strong></td><td>테스트 주도 개발 (TDD)</td><td>Policy 우선 설계를 위한 개발 방법론</td></tr><tr><td></td><td>행위 주도 개발 (BDD)</td><td>비즈니스 요구사항 중심의 Policy 검증</td></tr><tr><td></td><td>계약 테스트</td><td>서비스 간 인터페이스 호환성 검증</td></tr><tr><td><strong>DevOps</strong></td><td>CI/CD 파이프라인</td><td>Policy 와 Detail 의 독립적 배포 전략</td></tr><tr><td></td><td>인프라스트럭처 as Code</td><td>환경 설정의 코드화</td></tr><tr><td></td><td>모니터링과 옵저버빌리티</td><td>분산 시스템의 상태 추적</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>용어</th><th>설명</th></tr></thead><tbody><tr><td>Interface(인터페이스)</td><td>정책과 세부사항을 연결하는 추상적 경계</td></tr><tr><td>DDD</td><td>도메인 주도 설계, 정책/세부사항 분리 강조 설계 방법론</td></tr><tr><td>정책 (Policy)</td><td>시스템의 전체적인 동작과 구조를 정의하는 고수준 결정으로, 핵심 비즈니스 규칙과 관련됨</td></tr><tr><td>상세 구현 (Detail)</td><td>정책을 실현하기 위한 구체적인 메커니즘과 저수준 구현 방법 (데이터베이스, UI, 외부 시스템 등)</td></tr><tr><td>의존성 규칙 (Dependency Rule)</td><td>소스 코드 의존성은 항상 저수준 (상세 구현) 에서 고수준 (정책) 으로 향해야 한다는 원칙</td></tr><tr><td>의존성 역전 원칙 (DIP)</td><td>고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다는 SOLID 원칙</td></tr><tr><td>경계 (Boundary)</td><td>시스템의 다양한 영역 간의 명확한 구분선으로, 인터페이스와 어댑터를 통해 소통</td></tr><tr><td>엔티티 (Entity)</td><td>핵심 비즈니스 규칙과 데이터 구조를 캡슐화하는 객체</td></tr><tr><td>유스케이스 (Use Case)</td><td>애플리케이션 특정 비즈니스 규칙을 구현하는 객체</td></tr><tr><td>어댑터 (Adapter)</td><td>외부 시스템과 내부 시스템 간의 인터페이스 변환을 담당하는 구성 요소</td></tr><tr><td>포트 (Port)</td><td>내부 시스템이 외부와 통신하기 위한 인터페이스</td></tr><tr><td>DTO(Data Transfer Object)</td><td>계층 간 데이터 전달을 위한 단순한 구조로, 행위가 없는 순수한 데이터 객체</td></tr><tr><td>CQRS(Command Query Responsibility Segregation)</td><td>명령 (데이터 변경) 과 조회 (데이터 읽기) 모델을 분리하는 아키텍처 패턴</td></tr><tr><td>이벤트 소싱 (Event Sourcing)</td><td>상태 변경을 이벤트로 저장하고, 이벤트를 재생하여 상태를 재구성하는 패턴</td></tr><tr><td>마이크로서비스 (Microservices)</td><td>작고 독립적인 서비스로 구성된 아키텍처 스타일</td></tr><tr><td>플러그인 아키텍처 (Plug-in Architecture)</td><td>핵심 시스템에 플러그인 형태로 기능을 추가할 수 있는 아키텍처</td></tr><tr><td><strong>바운더리 (Boundary)</strong></td><td>시스템의 서로 다른 관심사를 분리하는 아키텍처적 경계선</td></tr><tr><td><strong>인터페이스 어댑터 (Interface Adapter)</strong></td><td>서로 다른 계층 간 데이터 형식을 변환하는 계층</td></tr><tr><td><strong>플러그인 아키텍처 (Plugin Architecture)</strong></td><td>핵심 로직에 기능을 플러그인 형태로 추가할 수 있는 구조</td></tr><tr><td><strong>포트와 어댑터 (Ports and Adapters)</strong></td><td>헥사고날 아키텍처에서 외부 세계와의 연결점을 나타내는 개념</td></tr><tr><td><strong>애그리게이트 (Aggregate)</strong></td><td>DDD 에서 일관성 경계를 가지는 도메인 객체들의 집합</td></tr><tr><td><strong>바운디드 컨텍스트 (Bounded Context)</strong></td><td>DDD 에서 특정 도메인 모델이 적용되는 명시적 경계</td></tr><tr><td><strong>이벤트 스토밍 (Event Storming)</strong></td><td>도메인 이벤트를 중심으로 비즈니스 프로세스를 모델링하는 기법</td></tr><tr><td>클린 아키텍처 (Clean Architecture)</td><td>고수준 정책을 중심에 두고 저수준 세부사항은 바깥 계층으로 배치하는 구조적 아키텍처</td></tr><tr><td>헥사고날 아키텍처 (Hexagonal Architecture)</td><td>내부 비즈니스 로직과 외부 어댑터를 포트로 연결하여 분리하는 설계 방식</td></tr><tr><td>관심사의 분리 (Separation of Concerns)</td><td>시스템의 각 부분이 명확히 독립된 관심사를 다루도록 분리하는 원칙</td></tr><tr><td>온리워드 종속성 원칙 (Onlyward Dependency Principle)</td><td>의존성이 항상 안쪽 (정책) 에서 바깥쪽 (세부사항) 으로만 향하도록 구성</td></tr><tr><td>인터페이스 중심 설계 (Interface-driven Design)</td><td>구현보다 인터페이스 중심으로 시스템을 설계하여 교체 가능성과 유연성 확보</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://blog.cleancoder.com/>Uncle Bob - Clean Architecture 설명</a></li><li><a href=https://alistair.cockburn.us/hexagonal-architecture/>Hexagonal Architecture (Alistair Cockburn)</a></li><li><a href=https://martinfowler.com/bliki/InversionOfControl.html>Martin Fowler - Inversion of Control</a></li><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans>Spring - Dependency Injection 가이드</a></li><li><a href=https://www.domainlanguage.com/ddd/reference/>Domain-Driven Design Reference</a></li><li><a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Clean Architecture - The Clean Code Blog - Uncle Bob</a></li><li><a href=https://roadmap.sh/software-design-architecture/architectural-principles/policy-vs-detail>Policy vs Detail - Roadmap.sh</a></li><li><a href="https://www.informit.com/articles/article.aspx?p=2832399">The Clean Architecture Dependency Rule | InformIT</a></li><li><a href=https://en.wikipedia.org/wiki/Dependency_inversion_principle>Dependency inversion principle - Wikipedia</a></li><li><a href=https://clevercoder.net/2018/09/08/clean-architecture-summary-review/>Clean Architecture by Uncle Bob: Summary and review - CleverCoder.net</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles>Architectural principles - .NET | Microsoft Learn</a></li><li><a href=https://www.geeksforgeeks.org/complete-guide-to-clean-architecture/>Complete Guide to Clean Architecture | GeeksforGeeks</a></li><li><a href=https://bitloops.com/docs/bitloops-language/learning/software-architecture/clean-architecture>Clean Architecture Reference Guide | Bitloops Docs</a></li><li><a href=https://khalilstemmler.com/articles/software-design-architecture/organizing-app-logic/>Organizing App Logic with the Clean Architecture | Khalil Stemmler</a></li><li><a href=https://convincedcoder.com/2019/04/27/Software-architecture-boundaries/>Software architecture and boundaries | Convinced Coder</a></li><li><a href=https://roadmap.sh/software-design-architecture/architectural-principles/policy-vs-detail>Policy vs Detail - roadmap.sh</a></li><li><a href=https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles>Architectural principles - Microsoft Learn</a></li><li><a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>The Clean Architecture - Uncle Bob&rsquo;s Blog</a></li><li><a href=https://clevercoder.net/2018/09/08/clean-architecture-summary-review/>Clean Architecture Summary and Review</a></li><li><a href=https://pubs.opengroup.org/architecture/togaf8-doc/arch/chap29.html>TOGAF Architecture Principles</a></li><li><a href=https://www.workingsoftware.dev/architecture-principles/>Architecture Principles: An approach to effective decision making</a></li><li><a href=https://www.infoq.com/articles/architecture-trends-2025/>InfoQ Software Architecture and Design Trends Report - 2025</a></li><li><a href=https://insights.daffodilsw.com/blog/top-software-architecture-patterns>Top Software Architecture Patterns for 2025</a></li><li><a href=https://bitloops.com/docs/bitloops-language/learning/software-architecture/clean-architecture>Bitloops: Clean Architecture - The Fundamentals</a></li><li><a href=https://www.sweetprocess.com/what-are-the-differences-between-a-policy-a-process-and-a-procedure-why-knowing-this-is-the-key-to-scaling-and-automating-your-business/>SweetProcess: Policy vs. Procedure vs. Process</a></li><li><a href=https://hidayatrizvi.com/policy-vs-procedure-vs-standard/>Hidayat Rizvi: Policy vs Procedure vs Standard</a></li><li><a href=https://www.comprose.com/blog/policy-process-procedure-or-work-instruction>Comprose: Policy, Procedure, Work Instructions, Process</a></li><li><a href=https://www.standardfusion.com/blog/policy-management-best-practices>StandardFusion: Policy Management Best Practices</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>