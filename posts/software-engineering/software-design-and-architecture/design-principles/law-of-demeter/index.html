<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Law of Demeter | hyunyoun's Blog</title><meta name=keywords content="System-and-Software-Architecture,Principles,Design-Principles"><meta name=description content="Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 ' 최소 지식의 원칙 ' 이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/law-of-demeter/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/law-of-demeter/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/law-of-demeter/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/law-of-demeter/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Law of Demeter"><meta property="og:description" content="Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 ' 최소 지식의 원칙 ' 이다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Law of Demeter"><meta name=twitter:description content="Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 ' 최소 지식의 원칙 ' 이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Engineering","item":""},{"@type":"ListItem","position":3,"name":"Software Design and Architecture","item":""},{"@type":"ListItem","position":4,"name":"Design Principles","item":"https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/"},{"@type":"ListItem","position":5,"name":"Law of Demeter","item":"https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/law-of-demeter/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a>&nbsp;»&nbsp;<a href>Software Engineering</a>&nbsp;»&nbsp;<a href>Software Design and Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/>Design Principles</a></div><h1>Law of Demeter</h1><div class=post-description>Law of Demeter 는 객체지향 설계에서 객체 간의 결합도를 줄이기 위한 설계 원칙으로, 객체는 직접적인 친구들과만 상호작용해야 하며 메서드 체이닝을 피해야 한다는 &rsquo; 최소 지식의 원칙 &rsquo; 이다.</div></header><div class=post-content><h2 id=law-of-demeter>Law of Demeter<a hidden class=anchor aria-hidden=true href=#law-of-demeter>#</a></h2><p>Law of Demeter(데메테르의 법칙) 는 " 최소 지식 원칙 (Principle of Least Knowledge)" 이라고도 불리며, 소프트웨어의 각 모듈이나 객체가 자신과 밀접하게 연관된 객체와만 상호작용해야 한다는 설계 지침이다. 이 원칙은 객체 간 불필요한 의존성과 결합도를 줄여 시스템의 유연성, 유지보수성, 테스트 용이성을 높인다. 대표적으로 &ldquo;A.getB().getC().doSomething()&rdquo; 과 같은 체이닝 호출을 지양하고, 중간 객체의 책임을 명확히 분리하는 방식으로 적용된다. 실무에서는 Facade, Service Layer, DTO, 의존성 주입 등 다양한 패턴과 기법으로 활용된다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p><strong>Law of Demeter (디미터 법칙)</strong> 또는 <strong>Principle of Least Knowledge (최소 지식의 원칙)</strong> 는 객체지향 프로그래밍에서 객체 간의 상호작용을 제한하여 느슨한 결합 (Loose Coupling) 을 달성하는 설계 원칙이다.</p><p><strong>핵심 철학:</strong></p><ul><li>객체는 자신의 직접적인 " 친구 " 들과만 대화해야 함</li><li>" 낯선 사람 " 과는 대화하지 말아야 함</li><li>다른 객체의 내부 구조나 속성에 대해 최소한만 가정해야 함</li></ul><p><strong>핵심 규칙</strong>: 한 메서드는 다음 객체에만 메시지를 보낼 수 있다:</p><ul><li>자기 자신 (this)</li><li>메서드 인자 (argument)</li><li>자신이 생성한 객체</li><li>자신의 인스턴스 변수</li></ul><h3 id=목적-및-필요성>목적 및 필요성<a hidden class=anchor aria-hidden=true href=#목적-및-필요성>#</a></h3><ol><li><strong>결합도 감소</strong>: 컴포넌트 간 상호의존성 최소화</li><li><strong>유지보수성 향상</strong>: 변경 시 영향 범위 제한</li><li><strong>캡슐화 강화</strong>: 객체의 내부 구현 은닉</li><li><strong>적응성 증대</strong>: 요구사항 변경에 대한 유연한 대응</li><li><strong>정보 숨김</strong>: 불필요한 세부사항 노출 방지</li></ol><h3 id=주요-기능-및-역할>주요 기능 및 역할<a hidden class=anchor aria-hidden=true href=#주요-기능-및-역할>#</a></h3><ul><li>객체 간 직접적인 상호작용만 허용해 의존성 최소화</li><li>정보 은닉 (캡슐화) 강화</li><li>시스템의 안정성 및 유연성 향상</li></ul><h3 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h3><ul><li>느슨한 결합 (Loose Coupling) 지향</li><li>정보 은닉 (Information Hiding) 강조</li><li>유지보수성, 확장성, 테스트 용이성 향상</li></ul><h3 id=핵심-원칙-및-주요-원리>핵심 원칙 및 주요 원리<a hidden class=anchor aria-hidden=true href=#핵심-원칙-및-주요-원리>#</a></h3><ul><li>" 친구의 친구와는 대화하지 않는다 (Only talk to your immediate friends)".</li><li>객체의 메서드는 다음과 같은 객체의 메서드만 호출해야 한다:<ul><li>자기 자신의 메서드</li><li>메서드의 매개변수로 전달된 객체의 메서드</li><li>자기 자신의 필드로 선언된 객체의 메서드</li><li>메서드 내에서 생성된 객체의 메서드</li></ul></li><li>객체 체이닝 (Chained Calls) 지양</li></ul><pre class=mermaid>flowchart TD
    A[Object A] --&gt;|has| B[Object B]
    B --&gt;|has| C[Object C]
    A -.-&gt;|&#34;X (위반)&#34;| C
    A --&gt;|&#34;O (준수)&#34;| B
</pre><p><strong>세 가지 핵심 권고사항:</strong></p><ol><li>각 단위는 다른 단위에 대해 제한된 지식만 가져야 함</li><li>각 단위는 친구들과만 대화해야 함</li><li>직접적인 친구들과만 대화해야 함</li></ol><p><strong>형식적 정의:</strong> 클래스 C 의 메서드 M 은 다음 유형의 객체 메서드만 호출할 수 있다:</p><ul><li>M 의 인수 객체들 (C 자신 포함)</li><li>C 의 인스턴스 변수 클래스들</li><li>M 에 의해 생성된 객체들</li><li>전역 변수 및 C 의 직접적인 구성 요소 객체들</li></ul><p><strong>캡슐화 메커니즘:</strong></p><pre class=mermaid>flowchart LR
    subgraph &#34;Law of Demeter 준수&#34;
        A1[Object A] --&gt;|&#34;명령/위임&#34;| B1[Object B]
        B1 --&gt;|&#34;내부 처리&#34;| C1[Object C]
    end
    
    subgraph &#34;Law of Demeter 위반&#34;
        A2[Object A] --&gt;|&#34;직접 접근&#34;| B2[Object B]
        A2 -.-&gt;|&#34;체이닝 접근&#34;| C2[Object C]
        B2 --&gt; C2
    end
</pre><h3 id=구현-기법>구현 기법<a hidden class=anchor aria-hidden=true href=#구현-기법>#</a></h3><table><thead><tr><th>기법</th><th>정의/구성</th><th>목적</th><th>실제 예시 (시스템/시나리오)</th></tr></thead><tbody><tr><td>위임 (Delegation)</td><td>중간 객체에 기능 위임</td><td>결합도 감소</td><td>Car 가 Engine 에 start() 위임</td></tr><tr><td>Facade 패턴</td><td>복잡한 내부 구조 감춤</td><td>단순화, 은닉</td><td>Service Layer, API Facade</td></tr><tr><td>DTO(Data Transfer Object)</td><td>데이터 전달만 담당</td><td>정보 은닉, 결합도 감소</td><td>API 응답 객체, DB 전송 객체</td></tr><tr><td>의존성 주입 (DI)</td><td>외부에서 객체 주입</td><td>결합도 최소화</td><td>Spring DI, 생성자 주입 등</td></tr></tbody></table><h4 id=위임자-메서드-delegate-methods>위임자 메서드 (Delegate Methods)<a hidden class=anchor aria-hidden=true href=#위임자-메서드-delegate-methods>#</a></h4><p><strong>정의</strong>: 내부 객체의 기능을 직접 노출하지 않고 래퍼 메서드를 통해 접근<br><strong>구성</strong>: 공개 메서드 → 내부 객체의 비공개 메서드 호출<br><strong>목적</strong>: 내부 구조 은닉과 인터페이스 안정성 확보</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ❌ Law of Demeter 위반
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>order</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>street</span> <span class=o>=</span> <span class=nx>order</span><span class=p>.</span><span class=nx>getCustomer</span><span class=p>().</span><span class=nx>getAddress</span><span class=p>().</span><span class=nx>getStreet</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 깊은 탐색으로 인한 강한 결합
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✅ Law of Demeter 준수 - 위임 메서드 사용
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>Order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>getCustomerStreet</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>customer</span><span class=p>.</span><span class=nx>getAddressStreet</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>OrderProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>order</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>street</span> <span class=o>=</span> <span class=nx>order</span><span class=p>.</span><span class=nx>getCustomerStreet</span><span class=p>();</span> <span class=c1>// 직접 요청
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=명령-패턴-command-pattern>명령 패턴 (Command Pattern)<a hidden class=anchor aria-hidden=true href=#명령-패턴-command-pattern>#</a></h4><p><strong>정의</strong>: 데이터를 요청하는 대신 수행할 행동을 명령<br><strong>구성</strong>: 명령 객체 → 수신자 객체의 메서드 실행<br><strong>목적</strong>: Tell Don&rsquo;t Ask 원칙 구현</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span><span class=lnt id=hl-3-14><a class=lnlinks href=#hl-3-14>14</a>
</span><span class=lnt id=hl-3-15><a class=lnlinks href=#hl-3-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ❌ 데이터 요청 후 처리
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>PayrollProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>calculatePay</span><span class=p>(</span><span class=nx>employee</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>hours</span> <span class=o>=</span> <span class=nx>employee</span><span class=p>.</span><span class=nx>getTimesheet</span><span class=p>().</span><span class=nx>getHours</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>rate</span> <span class=o>=</span> <span class=nx>employee</span><span class=p>.</span><span class=nx>getDepartment</span><span class=p>().</span><span class=nx>getPayRate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>hours</span> <span class=o>*</span> <span class=nx>rate</span><span class=p>;</span> <span class=c1>// 외부에서 계산
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ✅ 행동 명령
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>PayrollProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>calculatePay</span><span class=p>(</span><span class=nx>employee</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>employee</span><span class=p>.</span><span class=nx>calculatePay</span><span class=p>();</span> <span class=c1>// 행동 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=인터페이스-분리-interface-segregation>인터페이스 분리 (Interface Segregation)<a hidden class=anchor aria-hidden=true href=#인터페이스-분리-interface-segregation>#</a></h4><p><strong>정의</strong>: 넓은 인터페이스를 좁고 집중된 인터페이스로 분리<br><strong>구성</strong>: 다중 특화 인터페이스 → 단일 책임 구현<br><strong>목적</strong>: 불필요한 의존성 제거</p><h4 id=의존성-주입-dependency-injection>의존성 주입 (Dependency Injection)<a hidden class=anchor aria-hidden=true href=#의존성-주입-dependency-injection>#</a></h4><p><strong>정의</strong>: 필요한 객체를 외부에서 주입받아 직접 참조<br><strong>구성</strong>: 생성자/세터 주입 → 직접 의존성 확보<br><strong>목적</strong>: 간접적 의존성 제거</p><h3 id=장점과-단점>장점과 단점<a hidden class=anchor aria-hidden=true href=#장점과-단점>#</a></h3><table><thead><tr><th>구분</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td>✅ 장점</td><td>유지보수성 향상</td><td>객체 간 느슨한 결합으로 변경 시 영향 범위 최소화</td></tr><tr><td></td><td>캡슐화 강화</td><td>내부 구현 세부사항 은닉으로 안정적인 인터페이스 제공</td></tr><tr><td></td><td>테스트 용이성</td><td>모킹과 스텁 생성이 쉬워져 단위 테스트 작성 용이</td></tr><tr><td></td><td>재사용성 증대</td><td>독립적인 컴포넌트로 다른 컨텍스트에서 재사용 가능</td></tr><tr><td></td><td>병렬 개발 가능</td><td>인터페이스만 정의되면 독립적으로 개발 진행 가능</td></tr><tr><td>⚠ 단점</td><td>래퍼 메서드 증가</td><td>위임을 위한 추가 메서드들로 인한 코드량 증가</td></tr><tr><td></td><td>성능 오버헤드</td><td>추가적인 메서드 호출로 인한 시간/공간 비용 발생</td></tr><tr><td></td><td>과도한 추상화 위험</td><td>지나친 래퍼로 인해 실제 로직 파악이 어려워질 수 있음</td></tr><tr><td></td><td>넓은 인터페이스 위험</td><td>잘못 적용 시 클래스가 과도하게 많은 메서드를 노출할 수 있음</td></tr></tbody></table><h3 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h3><table><thead><tr><th>도전 과제</th><th>설명</th><th>해결책</th></tr></thead><tbody><tr><td>성능 vs 설계 품질의 균형</td><td>래퍼 메서드나 위임 객체가 많아질수록 호출 비용 증가 가능성 있음</td><td>핫스팟 분석 후 선택적 적용, JIT/컴파일러 최적화 활용</td></tr><tr><td>과도한 래퍼 메서드</td><td>모든 접근을 위임할 경우 코드 양 증가 및 유지보수 복잡성 초래</td><td>핵심 도메인 로직 중심으로 적용, 실용적 접근 지향</td></tr><tr><td>기존 코드베이스 적용</td><td>레거시 시스템에 일괄 적용 어려움, 영향 범위 넓음</td><td>단계적 리팩토링, Bounded Context 단위로 분리 적용</td></tr><tr><td>일관되지 않은 팀 해석과 구현</td><td>개발자마다 LoD 해석 및 구현 방식 상이</td><td>코딩 가이드라인 정립, 코드 리뷰 문화 정착</td></tr><tr><td>과도한 캡슐화와 설계 복잡도 증가</td><td>지나친 위임으로 설계가 오히려 난해해지는 경우</td><td>위임 수준 조절, 퍼사드 (Facade) 패턴이나 도메인 전용 메서드 사용</td></tr><tr><td>자동화 한계</td><td>위임 메서드 수동 작성 시 생산성 저하</td><td>IDE 템플릿/생성 도구, Lombok, CodeGen 등 자동화 도구 활용</td></tr></tbody></table><h3 id=분류에-따른-종류-및-유형>분류에 따른 종류 및 유형<a hidden class=anchor aria-hidden=true href=#분류에-따른-종류-및-유형>#</a></h3><table><thead><tr><th>분류 기준</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>적용 범위</strong></td><td>메서드 레벨</td><td>한 메서드 내에서의 객체 접근을 최소화 (직접 소유 객체만 접근)</td></tr><tr><td></td><td>클래스 레벨</td><td>클래스 간 상호작용에서 중간 객체 체인을 제한하는 설계</td></tr><tr><td></td><td>패키지/모듈 레벨</td><td>패키지/모듈 간 의존성을 최소화하고 중재 계층을 둔 구조</td></tr><tr><td><strong>엄격성 수준</strong></td><td>Classic LoD</td><td>모든 객체 접근을 일점 (one-dot) 규칙에 따라 제한하는 전통적인 접근 방식</td></tr><tr><td></td><td>Pragmatic LoD</td><td>실용성을 고려해 일부 예외를 허용하며 핵심 도메인에 집중하는 접근 방식</td></tr><tr><td></td><td>Contextual LoD</td><td>레거시 시스템, 서드파티 API 등 컨텍스트에 따라 제한적으로 적용하는 방식</td></tr><tr><td><strong>구현 방식</strong></td><td>위임 기반</td><td>객체 접근을 직접 하지 않고 위임 메서드 (Facade/Service 등) 를 통해 우회 접근</td></tr><tr><td></td><td>인터페이스 기반</td><td>구체 구현이 아닌 추상화 계층 (인터페이스, 추상 클래스) 을 통한 결합도 완화</td></tr><tr><td></td><td>의존성 주입 (DI) 기반</td><td>DI 컨테이너를 활용해 간접적으로 의존성 주입, 테스트 용이성과 결합도 개선</td></tr><tr><td><strong>사용 사례 유형</strong></td><td>Fluent LoD</td><td>빌더 패턴, DSL 등 메서드 체이닝 구조에서 LoD 원칙을 흐름 유지와 조화롭게 적용</td></tr></tbody></table><h3 id=실무-적용-예시>실무 적용 예시<a hidden class=anchor aria-hidden=true href=#실무-적용-예시>#</a></h3><table><thead><tr><th>적용 영역</th><th>적용 방법/예시</th><th>효과</th></tr></thead><tbody><tr><td>도메인 모델</td><td>중첩 객체 직접 접근 금지, 위임 활용</td><td>결합도 감소, 유지보수성 향상</td></tr><tr><td>서비스 레이어</td><td>Facade 패턴 적용</td><td>내부 구조 은닉, 단순화</td></tr><tr><td>API 설계</td><td>DTO 활용, 체이닝 호출 금지</td><td>정보 은닉, 확장성 강화</td></tr><tr><td>의존성 관리</td><td>DI 로 객체 주입</td><td>결합도 최소화, 테스트 용이</td></tr></tbody></table><h3 id=활용-사례>활용 사례<a hidden class=anchor aria-hidden=true href=#활용-사례>#</a></h3><h4 id=사례-1-전자상거래-주문-처리-시스템>사례 1: 전자상거래 주문 처리 시스템<a hidden class=anchor aria-hidden=true href=#사례-1-전자상거래-주문-처리-시스템>#</a></h4><p><strong>시나리오</strong>: 온라인 쇼핑몰에서 주문 처리 과정에 Law of Demeter 적용</p><p><strong>시스템 구성</strong>:</p><pre class=mermaid>graph TB
    subgraph &#34;Order Processing System&#34;
        OC[Order Controller]
        OS[Order Service]
        O[Order]
        C[Customer]
        P[Payment]
        I[Inventory]
        S[Shipping]
    end
    
    OC --&gt;|&#34;processOrder(orderData)&#34;| OS
    OS --&gt;|&#34;createOrder()&#34;| O
    OS --&gt;|&#34;validatePayment()&#34;| P
    OS --&gt;|&#34;checkInventory()&#34;| I
    OS --&gt;|&#34;arrangeShipping()&#34;| S
    
    O --&gt;|&#34;calculateTotal()&#34;| O
    O --&gt;|&#34;validateCustomer()&#34;| C
</pre><p><strong>Law of Demeter 위반 사례</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ❌ 위반: 깊은 객체 탐색
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>orderData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>customer</span> <span class=o>=</span> <span class=nx>orderData</span><span class=p>.</span><span class=nx>getCustomer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>address</span> <span class=o>=</span> <span class=nx>customer</span><span class=p>.</span><span class=nx>getAddress</span><span class=p>().</span><span class=nx>getStreet</span><span class=p>();</span> <span class=c1>// 위반
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>const</span> <span class=nx>paymentMethod</span> <span class=o>=</span> <span class=nx>customer</span><span class=p>.</span><span class=nx>getPayment</span><span class=p>().</span><span class=nx>getMethod</span><span class=p>().</span><span class=nx>getType</span><span class=p>();</span> <span class=c1>// 위반
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kr>const</span> <span class=nx>discount</span> <span class=o>=</span> <span class=nx>customer</span><span class=p>.</span><span class=nx>getMembership</span><span class=p>().</span><span class=nx>getLevel</span><span class=p>().</span><span class=nx>getDiscount</span><span class=p>();</span> <span class=c1>// 위반
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=c1>// 복잡한 결합 관계로 인한 취약한 코드
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Law of Demeter 준수 개선안</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span><span class=lnt id=hl-6-17><a class=lnlinks href=#hl-6-17>17</a>
</span><span class=lnt id=hl-6-18><a class=lnlinks href=#hl-6-18>18</a>
</span><span class=lnt id=hl-6-19><a class=lnlinks href=#hl-6-19>19</a>
</span><span class=lnt id=hl-6-20><a class=lnlinks href=#hl-6-20>20</a>
</span><span class=lnt id=hl-6-21><a class=lnlinks href=#hl-6-21>21</a>
</span><span class=lnt id=hl-6-22><a class=lnlinks href=#hl-6-22>22</a>
</span><span class=lnt id=hl-6-23><a class=lnlinks href=#hl-6-23>23</a>
</span><span class=lnt id=hl-6-24><a class=lnlinks href=#hl-6-24>24</a>
</span><span class=lnt id=hl-6-25><a class=lnlinks href=#hl-6-25>25</a>
</span><span class=lnt id=hl-6-26><a class=lnlinks href=#hl-6-26>26</a>
</span><span class=lnt id=hl-6-27><a class=lnlinks href=#hl-6-27>27</a>
</span><span class=lnt id=hl-6-28><a class=lnlinks href=#hl-6-28>28</a>
</span><span class=lnt id=hl-6-29><a class=lnlinks href=#hl-6-29>29</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// ✅ 개선: 책임 위임과 캡슐화
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>OrderController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>processOrder</span><span class=p>(</span><span class=nx>orderData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>order</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>orderService</span><span class=p>.</span><span class=nx>createOrder</span><span class=p>(</span><span class=nx>orderData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>order</span><span class=p>.</span><span class=nx>process</span><span class=p>();</span> <span class=c1>// 단일 진입점
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>class</span> <span class=nx>Order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>process</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=nx>validateCustomerEligibility</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>calculateTotalWithDiscounts</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>processPayment</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>reserveInventory</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>this</span><span class=p>.</span><span class=nx>arrangeShipping</span><span class=p>();</span> <span class=c1>// 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>getOrderSummary</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 각 메서드는 해당 도메인 객체에 위임
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>validateCustomerEligibility</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>customer</span><span class=p>.</span><span class=nx>validateForOrder</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=nx>calculateTotalWithDiscounts</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>discount</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>customer</span><span class=p>.</span><span class=nx>getApplicableDiscount</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>this</span><span class=p>.</span><span class=nx>items</span><span class=p>.</span><span class=nx>calculateTotal</span><span class=p>(</span><span class=nx>discount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>시스템 구성 다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
    participant Controller
    participant OrderService
    participant Order
    participant Customer
    participant Payment
    participant Inventory
    
    Controller-&gt;&gt;OrderService: processOrder(data)
    OrderService-&gt;&gt;Order: createOrder()
    Order-&gt;&gt;Customer: validateForOrder()
    Customer--&gt;&gt;Order: validation result
    Order-&gt;&gt;Payment: processPayment()
    Payment--&gt;&gt;Order: payment result
    Order-&gt;&gt;Inventory: reserveItems()
    Inventory--&gt;&gt;Order: reservation result
    Order--&gt;&gt;OrderService: order summary
    OrderService--&gt;&gt;Controller: process result
</pre><p><strong>Workflow</strong>:</p><ol><li><strong>주문 접수</strong>: Controller 가 OrderService 에 주문 처리 요청</li><li><strong>주문 생성</strong>: OrderService 가 Order 객체 생성 및 초기화</li><li><strong>고객 검증</strong>: Order 가 Customer 에게 주문 자격 검증 위임</li><li><strong>결제 처리</strong>: Order 가 Payment 에게 결제 처리 위임</li><li><strong>재고 확인</strong>: Order 가 Inventory 에게 재고 확보 위임</li><li><strong>배송 준비</strong>: Order 가 Shipping 에게 배송 준비 위임</li><li><strong>결과 반환</strong>: 각 단계의 결과를 Controller 에 전달</li></ol><p><strong>각 컴포넌트의 역할</strong>:</p><ul><li><strong>Order</strong>: 주문 프로세스 전체 조율 및 상태 관리</li><li><strong>Customer</strong>: 고객 정보 관리 및 자격 검증</li><li><strong>Payment</strong>: 결제 수단 관리 및 결제 처리</li><li><strong>Inventory</strong>: 재고 관리 및 예약 처리</li><li><strong>Shipping</strong>: 배송지 관리 및 배송 일정 수립</li></ul><h4 id=사례-2-전자상거래-시스템에서의-law-of-demeter-적용>사례 2: 전자상거래 시스템에서의 Law of Demeter 적용<a hidden class=anchor aria-hidden=true href=#사례-2-전자상거래-시스템에서의-law-of-demeter-적용>#</a></h4><p><strong>시나리오</strong>: 전자상거래 플랫폼에서 주문 처리 (Checkout) 를 담당하는 <code>OrderService</code> 클래스가 <code>Customer</code>, <code>Cart</code>, <code>Payment</code>, <code>Shipping</code> 등의 도메인 객체와 상호작용함.</p><p><strong>문제 발생 전</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>customer</span><span class=p>.</span><span class=na>getCart</span><span class=p>().</span><span class=na>getItems</span><span class=p>().</span><span class=na>forEach</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>i</span><span class=p>.</span><span class=na>getProduct</span><span class=p>().</span><span class=na>getName</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>➡ Law of Demeter 위반 (너무 많은 체이닝)</p><p><strong>리팩토링 후</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>customer</span><span class=p>.</span><span class=na>describeCartItems</span><span class=p>();</span><span class=w>  </span><span class=c1>// 위임 메서드 도입</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>시스템 구성</strong>:</p><pre class=mermaid>classDiagram
    class OrderService {
        +checkout()
    }
    class Customer {
        +describeCartItems()
    }
    class Cart {
        +getItems()
    }
    class Item {
        +getProduct()
    }
    class Product {
        +getName()
    }
    OrderService --&gt; Customer : uses
    Customer --&gt; Cart : owns
    Cart --&gt; Item : contains
    Item --&gt; Product : references
</pre><p><strong>Workflow 다이어그램</strong>:</p><pre class=mermaid>sequenceDiagram
    participant OrderService
    participant Customer
    participant Cart
    participant Item
    participant Product

    OrderService-&gt;&gt;Customer: describeCartItems()
    Customer-&gt;&gt;Cart: getItems()
    Cart-&gt;&gt;Item: 각 아이템 반환
    Item-&gt;&gt;Product: getProduct()
    Product--&gt;&gt;Item: 이름 반환
</pre><p><strong>담당 역할</strong>:</p><table><thead><tr><th>클래스</th><th>역할 설명</th></tr></thead><tbody><tr><td>OrderService</td><td>주문 처리 및 흐름 제어</td></tr><tr><td>Customer</td><td>고객 정보 및 행위 책임 주체</td></tr><tr><td>Cart</td><td>장바구니 항목 관리</td></tr><tr><td>Item</td><td>개별 상품 항목</td></tr><tr><td>Product</td><td>상품 정보 보유 객체</td></tr></tbody></table><h3 id=실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>실무에서 효과적으로 적용하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td>설계 원칙</td><td>객체 간 책임 분리</td><td>각 객체는 자신의 책임만 수행</td><td>단일 책임 원칙 (SRP) 및 명확한 도메인 경계 설정</td></tr><tr><td>위임 구조</td><td>위임 메서드의 적절한 사용</td><td>불필요한 래퍼 메서드로 인한 복잡도 증가 방지</td><td>핵심 로직 위주로 적용, 자동화 도구 활용</td></tr><tr><td>패턴 활용</td><td>설계 단순화 패턴 적용</td><td>구조를 단순화하기 위한 패턴의 활용</td><td>Facade, Service Layer, Adapter 패턴 적절히 활용</td></tr><tr><td>테스트 전략</td><td>Mock/Stub 구조의 유지 관리</td><td>위임 구조가 복잡해질 경우 테스트 설계가 어려워짐</td><td>인터페이스 기반 설계 및 테스트용 추상화 적용</td></tr><tr><td>구현 실용성</td><td>과도한 캡슐화 및 분리의 부작용 방지</td><td>지나치게 분리하면 가독성/유지보수성 저하</td><td>실용적 캡슐화와 책임 위임의 균형 유지</td></tr><tr><td>성능 측면</td><td>메서드 호출 오버헤드</td><td>위임 호출이 누적되면 성능 저하 요인</td><td>프로파일링 및 핫스팟 분석을 통한 선별적 최적화</td></tr><tr><td>유지보수</td><td>변경에 대한 영향도 고려</td><td>위임 구조는 구조 변경 시 영향도가 넓어질 수 있음</td><td>인터페이스 변경 시 버전 관리, 점진적 리팩토링 적용</td></tr><tr><td>팀 협업/문화</td><td>일관된 LoD 적용 기준</td><td>개발자마다 LoD 해석이 달라질 수 있음</td><td>코딩 컨벤션, 코드 리뷰 기준에 LoD 포함</td></tr></tbody></table><h3 id=최적화하기-위한-고려사항-및-주의할-점>최적화하기 위한 고려사항 및 주의할 점<a hidden class=anchor aria-hidden=true href=#최적화하기-위한-고려사항-및-주의할-점>#</a></h3><table><thead><tr><th>구분</th><th>고려사항</th><th>설명</th><th>권장사항</th></tr></thead><tbody><tr><td><strong>메모리 사용량</strong></td><td>객체 수 증가</td><td>위임 및 계층 분리로 인해 객체가 많이 생성될 수 있음</td><td>객체 풀링 (Object Pooling), 경량 객체 패턴 적용</td></tr><tr><td><strong>메서드 호출 수</strong></td><td>호출 체인 과다</td><td>메서드 체인이 깊어질수록 성능 저하 우려</td><td>필요 시 직접 접근 허용, 호출 최소화</td></tr><tr><td><strong>위임 오버헤드</strong></td><td>과도한 위임 구조</td><td>불필요한 래퍼 메서드 증가 → CPU 자원 낭비</td><td>정적 분석 도구 활용, 위임 최소화</td></tr><tr><td><strong>실행 시간 최적화</strong></td><td>핫패스 성능 저하 우려</td><td>위임 로직이 자주 실행되는 경로에 존재할 경우 성능 저하 가능</td><td>프로파일링으로 핫패스 식별, 선택적 최적화</td></tr><tr><td><strong>캐싱 전략</strong></td><td>반복 연산 결과 재사용 필요성</td><td>위임 호출 결과가 동일할 경우 불필요한 재계산</td><td>메모이제이션 (Memoization) 적용</td></tr><tr><td><strong>컴파일러 최적화</strong></td><td>JIT 인라이닝 최적화 유도 가능성</td><td>메서드 분리가 적절하면 컴파일러 인라이닝 가능</td><td>프로파일 기반 최적화 (PGO: Profile-Guided Optimization) 적용</td></tr><tr><td><strong>네트워크 통신</strong></td><td>원격 객체 접근에 따른 비용 증가</td><td>마이크로서비스 또는 원격 객체 간 호출 시 오버헤드 발생</td><td>비동기 호출, 배치 처리 적용</td></tr><tr><td><strong>데이터베이스 접근</strong></td><td>위임 구조로 인해 N+1 문제 발생 가능</td><td>객체 그래프 탐색 시 반복 쿼리 발생</td><td>지연 로딩 (Lazy Loading), 배치 로딩 (Batch Fetching) 전략</td></tr><tr><td><strong>자동화 도구 활용</strong></td><td>생산성 및 일관성 향상</td><td>위임 메서드 반복 작성의 생산성 저하</td><td>IDE 플러그인, 코드 생성기 도입</td></tr><tr><td><strong>리팩토링 전략</strong></td><td>복잡도 감소와 성능 균형 필요</td><td>위임으로 인한 계층 구조가 오히려 복잡성을 증가시킬 수 있음</td><td>주기적 리팩토링 및 계층 간소화</td></tr></tbody></table><h3 id=주제와-관련하여-주목할-내용>주제와 관련하여 주목할 내용<a hidden class=anchor aria-hidden=true href=#주제와-관련하여-주목할-내용>#</a></h3><table><thead><tr><th>분류</th><th>항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>최소 지식 원칙 (Least Knowledge)</td><td>객체는 자신과 직접 관련된 객체와만 상호작용해야 한다는 원칙</td></tr><tr><td></td><td>느슨한 결합 (Loose Coupling)</td><td>결합도를 낮추고 모듈 간 독립성 향상을 통해 유지보수성 확보</td></tr><tr><td></td><td>정보 은닉 (Encapsulation)</td><td>객체 내부 상태나 구현을 외부에 노출하지 않도록 보호</td></tr><tr><td></td><td>Tell, Don&rsquo;t Ask</td><td>데이터를 요청하지 말고 필요한 작업을 요청하라는 메시지 중심 접근법</td></tr><tr><td></td><td>단일 책임 원칙 (SRP)</td><td>객체가 하나의 책임만 가지도록 하여 자연스럽게 LoD 준수</td></tr><tr><td></td><td>의존성 역전 원칙 (DIP)</td><td>고수준 모듈이 저수준 구현이 아닌 추상에 의존하도록 설계</td></tr><tr><td><strong>디자인 패턴</strong></td><td>Delegation Pattern</td><td>책임을 다른 객체에 위임하는 방식</td></tr><tr><td></td><td>Facade Pattern</td><td>복잡한 내부 구조를 단순화하여 외부에 단일 인터페이스 제공</td></tr><tr><td></td><td>Mediator Pattern</td><td>객체 간 상호작용을 중앙 집중화하여 직접 결합 제거</td></tr><tr><td></td><td>Command Pattern</td><td>요청을 객체로 캡슐화하고 위임을 통해 실행</td></tr><tr><td><strong>아키텍처 패턴</strong></td><td>Layered Architecture</td><td>각 계층이 하위 계층에만 의존하는 구조</td></tr><tr><td></td><td>Hexagonal Architecture</td><td>포트/어댑터 구조로 외부 의존성 분리</td></tr><tr><td></td><td>Clean Architecture</td><td>핵심 도메인을 외부 요소로부터 격리하여 LoD 원칙을 체계적으로 구현</td></tr><tr><td><strong>프로그래밍 기법</strong></td><td>위임 메서드</td><td>중간 객체로의 책임 전가를 통해 직접 접근 방지</td></tr><tr><td></td><td>인터페이스 분리 (ISP)</td><td>필요한 기능만 제공하여 불필요한 의존성 제거</td></tr><tr><td></td><td>의존성 주입 (DI)</td><td>직접 생성 대신 외부에서 주입하여 결합도 낮춤</td></tr><tr><td><strong>리팩토링 전략</strong></td><td>중간자 제거 (Remove Middleman)</td><td>불필요한 중간 객체를 제거하여 과도한 위임 방지</td></tr><tr><td><strong>품질 메트릭스</strong></td><td>RFC (Response For Class)</td><td>클래스가 노출하는 응답 수 측정으로 LoD 위반 여부 간접 판단</td></tr><tr><td></td><td>WMC (Weighted Methods per Class)</td><td>클래스의 복잡도와 결합 정도를 측정</td></tr><tr><td></td><td>Coupling Metrics</td><td>모듈 간 결합도 수치화</td></tr><tr><td><strong>유틸리티/도구</strong></td><td>리팩토링 도구</td><td>IntelliJ, SonarQube 등에서 LoD 위반 코드 자동 분석 가능</td></tr><tr><td><strong>보조 패러다임</strong></td><td>AOP (Aspect-Oriented Programming)</td><td>횡단 관심사를 분리하여 직접 호출 없이도 기능 주입 가능</td></tr></tbody></table><h3 id=하위-주제로-분류한-추가-학습-내용>하위 주제로 분류한 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#하위-주제로-분류한-추가-학습-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>설계 원칙</strong></td><td>Principle of Least Knowledge</td><td>객체는 필요한 최소한의 객체와만 상호작용해야 한다는 LoD 의 핵심 개념</td></tr><tr><td></td><td>캡슐화 (Encapsulation)</td><td>내부 구현을 숨기고 명확한 인터페이스만 제공</td></tr><tr><td></td><td>정보 은닉 (Information Hiding)</td><td>불필요한 정보 노출을 제한함으로써 변경에 유연한 구조 유지</td></tr><tr><td></td><td>결합도와 응집도 (Coupling & Cohesion)</td><td>모듈 간 관계 최적화를 위한 이론적 기반</td></tr><tr><td></td><td>Single Responsibility Principle</td><td>객체가 한 가지 책임만 갖도록 하여 자연스럽게 LoD 준수</td></tr><tr><td><strong>디자인 패턴</strong></td><td>Delegation Pattern</td><td>책임을 다른 객체에 위임함으로써 직접 접근 제거</td></tr><tr><td></td><td>Facade Pattern</td><td>복잡한 내부 구현을 감추는 단순한 외부 인터페이스 제공</td></tr><tr><td></td><td>Service Layer</td><td>도메인 로직과 애플리케이션 로직 분리</td></tr><tr><td></td><td>DTO (Data Transfer Object)</td><td>데이터 전송용 단순 객체로, 의존성 명확화</td></tr><tr><td><strong>소프트웨어 아키텍처</strong></td><td>마이크로서비스와 LoD</td><td>독립적 서비스 간 통신 시 LoD 적용 고려사항</td></tr><tr><td></td><td>이벤트 기반 아키텍처</td><td>비동기 메시징을 활용한 느슨한 결합 구현</td></tr><tr><td></td><td>DDD 와 경계 컨텍스트</td><td>객체 간 경계 명확화를 통해 LoD 실현</td></tr><tr><td><strong>리팩토링</strong></td><td>체이닝 호출 제거</td><td>메서드 체이닝 등 직접 참조 패턴을 위임 방식으로 개선</td></tr><tr><td></td><td>레거시 코드 리팩토링</td><td>기존 시스템에 LoD 원칙을 점진적으로 적용하는 방법</td></tr><tr><td><strong>테스트 전략</strong></td><td>Mocking / Stubbing</td><td>LoD 구조에서의 단위 테스트 구성법</td></tr><tr><td></td><td>테스트 최적화</td><td>위임 구조에 적합한 테스트 케이스 분리</td></tr><tr><td><strong>성능 최적화</strong></td><td>위임에 따른 오버헤드 최소화</td><td>LoD 적용이 성능에 미치는 영향 고려 및 최적화 전략</td></tr><tr><td><strong>도구 및 프레임워크</strong></td><td>Spring Framework 와 DI</td><td>의존성 주입 기반으로 LoD 적용</td></tr><tr><td></td><td>.NET Core DI</td><td>.NET 환경에서의 DI 컨테이너 활용</td></tr><tr><td></td><td>정적 분석 도구 (Static Analysis Tools)</td><td>IntelliJ, SonarQube 등을 통한 LoD 위반 코드 탐지 및 개선 지원</td></tr></tbody></table><h3 id=관련-분야와-추가-학습-내용>관련 분야와 추가 학습 내용<a hidden class=anchor aria-hidden=true href=#관련-분야와-추가-학습-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>주제</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>소프트웨어 아키텍처</strong></td><td>Clean Architecture</td><td>핵심 도메인 보호를 위한 계층화된 설계 구조</td></tr><tr><td></td><td>Hexagonal Architecture</td><td>포트와 어댑터로 외부 의존성을 격리하여 느슨한 결합 실현</td></tr><tr><td></td><td>Architecture Decision Records</td><td>아키텍처 설계 시 LoD 관련 고려사항을 기록하고 공유</td></tr><tr><td></td><td>계층화 설계</td><td>LoD 원칙을 각 계층 간 명확한 책임 분리로 구현</td></tr><tr><td><strong>객체지향 설계 원칙</strong></td><td>SOLID Principles</td><td>LoD 와 상호 보완적인 SRP, DIP 등의 설계 원칙</td></tr><tr><td></td><td>결합도/응집도 (Coupling/Cohesion)</td><td>LoD 가 결합도 감소, 응집도 증가에 기여</td></tr><tr><td><strong>함수형 프로그래밍</strong></td><td>함수 합성 (Functional Composition)</td><td>메서드 체이닝 없이도 복잡한 처리를 구성하는 안전한 방식</td></tr><tr><td></td><td>불변 객체 (Immutable Objects)</td><td>상태 공유 없이 안전하게 객체 전달 가능</td></tr><tr><td></td><td>모나드 패턴 (Monadic Design)</td><td>부작용 없는 체이닝 구조로 LoD 보완</td></tr><tr><td><strong>디자인 패턴</strong></td><td>Mediator Pattern</td><td>객체 간 직접 의존을 중재하여 결합도 감소</td></tr><tr><td></td><td>Delegation Pattern</td><td>책임을 외부 객체에 위임하여 직접 접근 제한</td></tr><tr><td></td><td>Facade Pattern</td><td>복잡한 내부 구현을 감춘 단순한 인터페이스 제공</td></tr><tr><td><strong>분산 시스템</strong></td><td>Service Mesh Architecture</td><td>마이크로서비스 간 통신을 인프라 수준에서 제어</td></tr><tr><td></td><td>API Gateway Pattern</td><td>클라이언트와 마이크로서비스 사이 추상화 계층 구성</td></tr><tr><td></td><td>Event Sourcing</td><td>도메인 이벤트 기반으로 시스템 상태 추적</td></tr><tr><td><strong>성능 엔지니어링</strong></td><td>메모리 관리 (Memory Management)</td><td>위임 구조에서 불필요한 객체 생성을 방지</td></tr><tr><td></td><td>컴파일러 최적화</td><td>위임 메서드 호출이 성능에 미치는 영향과 인라이닝 최적화 활용</td></tr><tr><td></td><td>프로파일링 & 모니터링</td><td>런타임 성능을 정량적으로 측정하고 병목을 분석</td></tr><tr><td><strong>코드 품질 관리</strong></td><td>정적 분석 도구</td><td>LoD 위반 여부를 자동 분석 (SonarQube, IntelliJ 등)</td></tr><tr><td><strong>프로그램 기법</strong></td><td>Law of Demeter for Functions</td><td>LoD 개념을 메서드/함수 레벨에서도 확장 적용</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>Law of Demeter (데메테르의 법칙)</strong></td><td>객체는 직접적으로 연관된 객체와만 상호작용해야 한다는 객체지향 설계 원칙</td></tr><tr><td><strong>Principle of Least Knowledge</strong></td><td>Law of Demeter 의 다른 명칭으로, 객체 간 상호작용을 최소화해야 한다는 설계 원칙</td></tr><tr><td><strong>Delegation (위임)</strong></td><td>특정 작업의 책임을 다른 객체에게 넘기는 설계 기법</td></tr><tr><td><strong>Delegation Method (위임 메서드)</strong></td><td>다른 객체의 기능을 호출하는 중간 메서드로, 결합도를 낮추는 수단</td></tr><tr><td><strong>Facade Pattern (퍼사드 패턴)</strong></td><td>복잡한 내부 시스템을 단순한 인터페이스로 감추는 디자인 패턴</td></tr><tr><td><strong>DTO (Data Transfer Object)</strong></td><td>계층 간 데이터 전달만을 담당하는 객체로, 부작용 없이 구조화된 데이터 교환 가능</td></tr><tr><td><strong>Service Layer (서비스 레이어)</strong></td><td>비즈니스 로직을 캡슐화하여 프레젠테이션과 도메인 계층 간의 결합도를 낮추는 구조적 계층</td></tr><tr><td><strong>Dependency Injection (의존성 주입)</strong></td><td>객체 생성 책임을 외부로 분리하여 결합도를 줄이는 구성 방식</td></tr><tr><td><strong>Encapsulation (캡슐화)</strong></td><td>객체 내부 구현을 숨기고, 공개된 메서드를 통해서만 상태에 접근하도록 제한하는 원칙</td></tr><tr><td><strong>Information Hiding (정보 은닉)</strong></td><td>모듈 또는 객체의 내부 세부사항을 외부에서 감추는 설계 원칙</td></tr><tr><td><strong>Loose Coupling (느슨한 결합)</strong></td><td>컴포넌트 간 의존도를 낮춤으로써 변경 시 영향 범위를 최소화하는 구조</td></tr><tr><td><strong>Coupling (결합도)</strong></td><td>모듈 간의 의존성 강도를 나타내는 소프트웨어 설계 메트릭</td></tr><tr><td><strong>Cohesion (응집도)</strong></td><td>모듈 내부 구성 요소들이 얼마나 관련 있는 기능을 수행하는지를 나타내는 메트릭</td></tr><tr><td><strong>Method Chaining (메서드 체이닝)</strong></td><td>연속적인 메서드 호출로 로직을 구성하는 방식으로, LoD 위반 가능성이 높은 패턴</td></tr><tr><td><strong>Tell Don&rsquo;t Ask</strong></td><td>객체에게 필요한 데이터를 꺼내 처리하기보다, 작업을 직접 요청하여 캡슐화를 강화하는 설계 원칙</td></tr><tr><td><strong>Refactoring (리팩토링)</strong></td><td>외부 동작은 그대로 두고, 코드 구조를 더 나은 형태로 재정비하는 기법</td></tr><tr><td><strong>RFC (Response For Class)</strong></td><td>클래스가 응답할 수 있는 메서드 수를 나타내는 클래스 복잡도 메트릭</td></tr><tr><td><strong>WMC (Weighted Methods per Class)</strong></td><td>클래스에 정의된 메서드들의 가중 합을 계산하여 복잡도를 나타내는 메트릭</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=공식-문서-및-백그라운드>공식 문서 및 백그라운드<a hidden class=anchor aria-hidden=true href=#공식-문서-및-백그라운드>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Law_of_Demeter>Law of Demeter - Wikipedia</a></li><li><a href=https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/general-formulation.html>Law of Demeter (General Formulation) - Northeastern University</a></li></ul><h3 id=실무-적용-및-자바-기반-예제>실무 적용 및 자바 기반 예제<a hidden class=anchor aria-hidden=true href=#실무-적용-및-자바-기반-예제>#</a></h3><ul><li><a href=https://www.baeldung.com/java-demeter-law>Law of Demeter in Java - Baeldung</a></li><li><a href=https://www.geeksforgeeks.org/law-of-demeter-in-java-principle-of-least-knowledge/>Law of Demeter in Java – GeeksforGeeks</a></li><li><a href=https://pawelpluta.com/the-law-of-demeter-by-example/>The Law of Demeter by Example - Paweł Pluta</a></li><li><a href=https://medium.com/vattenfall-tech/the-law-of-demeter-by-example-fd7adbf0c324>The Law of Demeter by Example - Medium</a></li></ul><h3 id=설계-원칙-설명-및-해설>설계 원칙 설명 및 해설<a hidden class=anchor aria-hidden=true href=#설계-원칙-설명-및-해설>#</a></h3><ul><li><a href=https://www.infoworld.com/article/2251481/demystifying-the-law-of-demeter-principle.html>Demystifying the Law of Demeter - InfoWorld</a></li><li><a href=https://dzone.com/articles/the-genius-of-the-law-of-demeter>The Genius of the Law of Demeter - DZone</a></li><li><a href=https://testdouble.com/insights/law-of-demeter-explained>Understanding the Law of Demeter - Test Double</a></li><li><a href=https://deviq.com/laws/law-of-demeter/>Law of Demeter - DevIQ</a></li><li><a href=https://dev.to/dazevedo/law-of-demeter-principle-of-least-knowledge-35l2>Law of Demeter (Principle of Least Knowledge) - DEV Community</a></li><li><a href=https://www.linkedin.com/pulse/understanding-law-demeter-design-approaches-venkataramanan-krishnan-mpyyc>Understanding the Law of Demeter and Design Approaches - LinkedIn</a></li><li><a href=http://www.pinte.ro/Blog/IT/The-Law-of-Demeter-software-design-principle/62>The Law of Demeter Software Design Principle - Pinte.ro</a></li></ul><h3 id=기타-관련-설계-원칙도구-참고>기타 관련 설계 원칙/도구 참고<a hidden class=anchor aria-hidden=true href=#기타-관련-설계-원칙도구-참고>#</a></h3><ul><li><a href=https://www.designgurus.io/blog/essential-software-design-principles-you-should-know-before-the-interview>Essential Software Design Principles - Design Gurus</a></li><li><a href=https://www.jetbrains.com/help/idea/structural-search-and-replace.html>JetBrains - IntelliJ Structural Search</a></li><li><a href=https://docs.sonarsource.com/>SonarQube 공식 문서</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>