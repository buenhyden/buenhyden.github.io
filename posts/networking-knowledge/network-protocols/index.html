<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Network Protocol | hyunyoun's Blog</title>
<meta name=keywords content="Networking-Knowledge,Protocol,Network-Protocol,Ethernet,Frame-Relay,ATM,SONET,SDH,PDH,CDMA,GSM"><meta name=description content="컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계로 신호 체계, 인증, 그리고 오류 감지 및 수정 기능을 포함한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking-knowledge/network-protocols/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Network Protocol"><meta property="og:description" content="컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계로 신호 체계, 인증, 그리고 오류 감지 및 수정 기능을 포함한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Network Protocol"><meta name=twitter:description content="컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계로 신호 체계, 인증, 그리고 오류 감지 및 수정 기능을 포함한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Network","item":"https://buenhyden.github.io/posts/networking-knowledge/"},{"@type":"ListItem","position":3,"name":"Network Protocol","item":"https://buenhyden.github.io/posts/networking-knowledge/network-protocols/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-knowledge/>Network</a></div><h1>Network Protocol</h1><div class=post-description>컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계로 신호 체계, 인증, 그리고 오류 감지 및 수정 기능을 포함한다.</div></header><div class=post-content><h2 id=network-protocol>Network Protocol<a hidden class=anchor aria-hidden=true href=#network-protocol>#</a></h2><p>네트워크 프로토콜은 디지털 통신의 기초를 이루는 규칙과 규약의 집합이다.<br>이 프로토콜들은 데이터가 네트워크 상에서 어떻게 전송되고, 수신되며, 해석되는지를 정의한다.<br>마치 서로 다른 언어를 사용하는 사람들이 소통하기 위한 공통 언어와 같이, 프로토콜은 다양한 장치들이 서로 효과적으로 통신할 수 있도록 해준다.</p><p>네트워크 프로토콜은 디지털 통신의 근간을 이루는 규칙과 규약이다.<br>물리적 연결부터 응용 프로그램까지 다양한 계층에서 작동하며, 각각 고유한 역할을 수행한다. 인터넷의 급속한 발전과 새로운 기술의 등장에 따라 프로토콜도 계속 진화하고 있으며, 이러한 진화는 더 빠르고, 안전하며, 효율적인 네트워크 통신을 가능하게 한다.</p><p>네트워크 프로토콜에 대한 이해는 IT 분야의 전문가뿐만 아니라, 점점 더 디지털화되는 세상에서 모든 사람에게 중요한 지식이 되고 있다. 프로토콜의 작동 원리를 이해함으로써 네트워크 문제 해결, 보안 강화, 효율적인 시스템 설계가 가능해진다.</p><h3 id=네트워크-프로토콜의-기본-개념>네트워크 프로토콜의 기본 개념<a hidden class=anchor aria-hidden=true href=#네트워크-프로토콜의-기본-개념>#</a></h3><p>네트워크 프로토콜은 다음과 같은 핵심 요소를 정의한다:</p><ol><li><strong>메시지 형식</strong>: 데이터가 어떤 구조로 구성되는지 정의한다.</li><li><strong>메시지 순서</strong>: 통신 과정에서 메시지가 전송되는 순서를 정의한다.</li><li><strong>메시지 처리</strong>: 특정 이벤트(메시지 수신, 오류 발생 등)에 대한 대응 방법을 정의한다.</li><li><strong>타이밍</strong>: 데이터 전송의 속도와 동기화 방법을 정의한다.</li><li><strong>오류 처리</strong>: 통신 중 발생하는 오류를 감지하고 복구하는 방법을 정의한다.</li></ol><h3 id=osi-7계층-모델과-네트워크-프로토콜>OSI 7계층 모델과 네트워크 프로토콜<a hidden class=anchor aria-hidden=true href=#osi-7계층-모델과-네트워크-프로토콜>#</a></h3><p>OSI(Open Systems Interconnection) 모델은 네트워크 통신을 7개의 논리적 계층으로 분류한 개념적 프레임워크이다.</p><p>각 계층은 특정 기능을 담당하며, 해당 계층에서 작동하는 프로토콜들이 존재한다.</p><ol><li><strong>물리 계층(Physical Layer)</strong>: 물리적 미디어를 통한 비트 전송</li><li><strong>데이터 링크 계층(Data Link Layer)</strong>: 직접 연결된 두 노드 간의 안정적인 데이터 전송</li><li><strong>네트워크 계층(Network Layer)</strong>: 서로 다른 네트워크 간의 패킷 라우팅</li><li><strong>전송 계층(Transport Layer)</strong>: 종단 간(end-to-end) 연결 및 신뢰성 있는 데이터 전송</li><li><strong>세션 계층(Session Layer)</strong>: 통신 세션 관리</li><li><strong>표현 계층(Presentation Layer)</strong>: 데이터 변환, 암호화, 압축</li><li><strong>응용 계층(Application Layer)</strong>: 사용자와 네트워크 간의 인터페이스 제공</li></ol><p><figure><img alt="seven layers of the OSI model." loading=lazy src=/img/TCP-IP-protocol-suit.png><figcaption>https://techwavehub.net/protocol/</figcaption></figure></p><h3 id=네트워크-프로토콜의-표준화-기관>네트워크 프로토콜의 표준화 기관<a hidden class=anchor aria-hidden=true href=#네트워크-프로토콜의-표준화-기관>#</a></h3><p>네트워크 프로토콜은 다양한 기관에 의해 표준화된다:</p><ul><li><strong>IETF(Internet Engineering Task Force)</strong>: 인터넷 프로토콜 표준화</li><li><strong>IEEE(Institute of Electrical and Electronics Engineers)</strong>: 이더넷 등의 표준화</li><li><strong>W3C(World Wide Web Consortium)</strong>: 웹 관련 표준화</li><li><strong>ISO(International Organization for Standardization)</strong>: OSI 모델 등의 표준화</li><li><strong>ITU(International Telecommunication Union)</strong>: 통신 표준화</li></ul><h3 id=프로토콜의-종류-간략-요약>프로토콜의 종류 간략 요약<a hidden class=anchor aria-hidden=true href=#프로토콜의-종류-간략-요약>#</a></h3><p>네트워크 프로토콜은 목적과 기능에 따라 다양한 종류로 분류된다:</p><ol><li><strong>인터넷 프로토콜</strong>: IP, TCP, UDP, ICMP 등</li><li><strong>라우팅 프로토콜</strong>: RIP, OSPF, BGP 등</li><li><strong>응용 프로토콜</strong>: HTTP, FTP, SMTP, DNS 등</li><li><strong>보안 프로토콜</strong>: SSL/TLS, IPSec, SSH 등</li><li><strong>링크 계층 프로토콜</strong>: 이더넷, PPP, HDLC 등</li><li><strong>네트워크 관리 프로토콜</strong>: SNMP, RMON 등</li><li><strong>VoIP 프로토콜</strong>: SIP, H, RTP 등</li></ol><h3 id=네트워크-프로토콜-상세-분석>네트워크 프로토콜 상세 분석<a hidden class=anchor aria-hidden=true href=#네트워크-프로토콜-상세-분석>#</a></h3><h4 id=인터넷-프로토콜-스위트tcpip>인터넷 프로토콜 스위트(TCP/IP)<a hidden class=anchor aria-hidden=true href=#인터넷-프로토콜-스위트tcpip>#</a></h4><p>TCP/IP는 현대 인터넷의 기반이 되는 프로토콜 집합으로, OSI 모델보다 단순화된 4계층 모델을 사용한다.</p><h5 id=ipinternet-protocol>IP(Internet Protocol)<a hidden class=anchor aria-hidden=true href=#ipinternet-protocol>#</a></h5><p>IP는 네트워크 계층에서 작동하며, 데이터 패킷의 주소 지정과 라우팅을 담당한다.</p><p><strong>특징:</strong></p><ul><li><strong>패킷 전달</strong>: 데이터를 작은 패킷으로 분할하여 전송</li><li><strong>비연결성(Connectionless)</strong>: 각 패킷은 독립적으로 처리</li><li><strong>베스트 에포트(Best Effort)</strong>: 신뢰성 보장 없이 최선의 전달 시도</li><li><strong>주소 지정</strong>: IPv4(32비트)와 IPv6(128비트) 주소 체계</li></ul><p><strong>IPv4와 IPv6의 차이점:</strong></p><ul><li><strong>주소 공간</strong>: IPv4는 약 43억 개, IPv6는 2^128개의 주소 제공</li><li><strong>헤더 구조</strong>: IPv6는 단순화된 헤더로 처리 효율성 증가</li><li><strong>보안</strong>: IPv6는 IPSec을 기본 내장</li><li><strong>자동 구성</strong>: IPv6는 향상된 자동 구성 기능 제공</li></ul><h5 id=tcptransmission-control-protocol>TCP(Transmission Control Protocol)<a hidden class=anchor aria-hidden=true href=#tcptransmission-control-protocol>#</a></h5><p>TCP는 전송 계층에서 작동하며, 신뢰성 있는 데이터 전송을 보장한다.</p><p><strong>특징:</strong></p><ul><li><strong>연결 지향적(Connection-oriented)</strong>: 통신 전 연결 설정 필요</li><li><strong>신뢰성 있는 전송</strong>: 데이터 손실 시 재전송</li><li><strong>흐름 제어</strong>: 수신자의 처리 능력에 맞춰 전송 속도 조절</li><li><strong>혼잡 제어</strong>: 네트워크 혼잡 상황 감지 및 대응</li><li><strong>순서 보장</strong>: 데이터 패킷의 순서 유지</li></ul><p><strong>3-way 핸드셰이크:</strong></p><ol><li><strong>SYN</strong>: 클라이언트가 서버에 연결 요청(시퀀스 번호 포함)</li><li><strong>SYN-ACK</strong>: 서버가 요청 수락 및 응답(서버의 시퀀스 번호 포함)</li><li><strong>ACK</strong>: 클라이언트가 서버의 응답 확인</li></ol><h5 id=udpuser-datagram-protocol>UDP(User Datagram Protocol)<a hidden class=anchor aria-hidden=true href=#udpuser-datagram-protocol>#</a></h5><p>UDP는 TCP의 대안으로, 신뢰성보다 속도를 우선시하는 프로토콜이다.</p><p><strong>특징:</strong></p><ul><li><strong>비연결성</strong>: 사전 연결 설정 불필요</li><li><strong>신뢰성 없음</strong>: 패킷 손실 복구 메커니즘 없음</li><li><strong>순서 보장 없음</strong>: 패킷이 다른 순서로 도착할 수 있음</li><li><strong>낮은 오버헤드</strong>: 단순한 헤더 구조로 처리 속도 빠름</li><li><strong>브로드캐스트/멀티캐스트 지원</strong>: 여러 수신자에게 동시 전송 가능</li></ul><h5 id=tcp와-udp의-비교>TCP와 UDP의 비교<a hidden class=anchor aria-hidden=true href=#tcp와-udp의-비교>#</a></h5><table><thead><tr><th>특성</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>연결 방식</td><td>연결 지향적</td><td>비연결성</td></tr><tr><td>신뢰성</td><td>높음 (재전송)</td><td>낮음 (재전송 없음)</td></tr><tr><td>속도</td><td>상대적으로 느림</td><td>빠름</td></tr><tr><td>순서 보장</td><td>있음</td><td>없음</td></tr><tr><td>오버헤드</td><td>높음</td><td>낮음</td></tr><tr><td>사용 사례</td><td>웹 브라우징, 이메일, 파일 전송</td><td>영상 스트리밍, 온라인 게임, DNS</td></tr></tbody></table><h4 id=라우팅-프로토콜>라우팅 프로토콜<a hidden class=anchor aria-hidden=true href=#라우팅-프로토콜>#</a></h4><p>라우팅 프로토콜은 네트워크 간 최적의 경로를 결정하는 규칙을 정의한다.</p><h5 id=내부-게이트웨이-프로토콜igp>내부 게이트웨이 프로토콜(IGP)<a hidden class=anchor aria-hidden=true href=#내부-게이트웨이-프로토콜igp>#</a></h5><p>동일한 자율 시스템(AS) 내에서 사용되는 프로토콜이다.</p><p><strong>주요 IGP 종류:</strong></p><ul><li><strong>RIP(Routing Information Protocol)</strong>: 홉 카운트 기반의 간단한 프로토콜</li><li><strong>OSPF(Open Shortest Path First)</strong>: 링크 상태 알고리즘 사용, 대규모 네트워크에 적합</li><li><strong>EIGRP(Enhanced Interior Gateway Routing Protocol)</strong>: 시스코 독점 프로토콜, 하이브리드 방식</li></ul><h5 id=외부-게이트웨이-프로토콜egp>외부 게이트웨이 프로토콜(EGP)<a hidden class=anchor aria-hidden=true href=#외부-게이트웨이-프로토콜egp>#</a></h5><p>서로 다른 자율 시스템 간의 라우팅을 위한 프로토콜이다.</p><p><strong>주요 EGP 종류:</strong></p><ul><li><strong>BGP(Border Gateway Protocol)</strong>: 인터넷의 주요 라우팅 프로토콜, 정책 기반 라우팅 지원</li></ul><h4 id=응용-계층-프로토콜>응용 계층 프로토콜<a hidden class=anchor aria-hidden=true href=#응용-계층-프로토콜>#</a></h4><p>응용 계층 프로토콜은 사용자 애플리케이션과 네트워크 간의 인터페이스를 제공한다.</p><h5 id=httphttpshypertext-transfer-protocolsecure>HTTP/HTTPS(HyperText Transfer Protocol/Secure)<a hidden class=anchor aria-hidden=true href=#httphttpshypertext-transfer-protocolsecure>#</a></h5><p>웹 브라우저와 웹 서버 간의 통신을 위한 프로토콜이다.</p><p><strong>특징:</strong></p><ul><li><strong>요청-응답 모델</strong>: 클라이언트가 요청, 서버가 응답</li><li><strong>상태 비저장(Stateless)</strong>: 각 요청은 독립적으로 처리</li><li><strong>메소드</strong>: GET, POST, PUT, DELETE 등 다양한 작업 정의</li><li><strong>HTTPS</strong>: SSL/TLS를 통한 암호화 통신</li></ul><p><strong>HTTP 버전 변화:</strong></p><ul><li><strong>HTTP/1.0</strong>: 기본적인 요청-응답 모델</li><li><strong>HTTP/1.1</strong>: 지속적 연결, 파이프라이닝 도입</li><li><strong>HTTP/2</strong>: 멀티플렉싱, 헤더 압축, 서버 푸시 기능 추가</li><li><strong>HTTP/3</strong>: UDP 기반(QUIC 프로토콜), 지연 시간 감소</li></ul><h5 id=smtpsimple-mail-transfer-protocol>SMTP(Simple Mail Transfer Protocol)<a hidden class=anchor aria-hidden=true href=#smtpsimple-mail-transfer-protocol>#</a></h5><p>이메일 전송을 위한 프로토콜이다.</p><p><strong>특징:</strong></p><ul><li><strong>푸시 방식</strong>: 발신자가 수신자에게 직접 메일 전송</li><li><strong>텍스트 기반</strong>: 명령과 응답이 텍스트 형식</li><li><strong>지속적 연결</strong>: 여러 이메일을 하나의 연결로 전송 가능</li></ul><h5 id=pop3imappost-office-protocolinternet-message-access-protocol>POP3/IMAP(Post Office Protocol/Internet Message Access Protocol)<a hidden class=anchor aria-hidden=true href=#pop3imappost-office-protocolinternet-message-access-protocol>#</a></h5><p>이메일 검색을 위한 프로토콜입니다.</p><p><strong>POP3 특징:</strong></p><ul><li><strong>다운로드 후 삭제</strong>: 기본적으로 서버에서 메일 삭제</li><li><strong>단순한 구조</strong>: 제한된 서버 측 기능</li></ul><p><strong>IMAP 특징:</strong></p><ul><li><strong>서버 저장</strong>: 이메일이 서버에 유지됨</li><li><strong>다중 폴더</strong>: 서버에서 메일 구성 가능</li><li><strong>부분 다운로드</strong>: 헤더만 먼저 다운로드 가능</li></ul><h5 id=ftpfile-transfer-protocol>FTP(File Transfer Protocol)<a hidden class=anchor aria-hidden=true href=#ftpfile-transfer-protocol>#</a></h5><p>파일 전송을 위한 프로토콜입니다.</p><p><strong>특징:</strong></p><ul><li><strong>이중 연결</strong>: 제어 연결과 데이터 연결 분리</li><li><strong>인증 요구</strong>: 사용자 이름과 비밀번호 필요</li><li><strong>두 가지 모드</strong>: 액티브 모드와 패시브 모드</li></ul><h5 id=dnsdomain-name-system>DNS(Domain Name System)<a hidden class=anchor aria-hidden=true href=#dnsdomain-name-system>#</a></h5><p>도메인 이름을 IP 주소로 변환하는 프로토콜입니다.</p><p><strong>특징:</strong></p><ul><li><strong>계층적 구조</strong>: 루트, 최상위 도메인(TLD), 서브도메인 등</li><li><strong>분산 데이터베이스</strong>: 전 세계에 분산된 서버 구조</li><li><strong>캐싱</strong>: 빠른 응답을 위한 임시 저장</li></ul><p><strong>DNS 작동 과정:</strong></p><ol><li>클라이언트가 DNS 리졸버에 쿼리 전송</li><li>리졸버가 루트 DNS 서버에 문의</li><li>루트 서버가 TLD 서버 정보 제공</li><li>TLD 서버가 권한 있는 네임 서버 정보 제공</li><li>권한 있는 네임 서버가 IP 주소 제공</li><li>리졸버가 클라이언트에 IP 주소 반환</li></ol><h4 id=4-보안-프로토콜>4. 보안 프로토콜<a hidden class=anchor aria-hidden=true href=#4-보안-프로토콜>#</a></h4><p>네트워크 통신의 보안을 강화하기 위한 프로토콜입니다.</p><h5 id=ssltlssecure-sockets-layertransport-layer-security>SSL/TLS(Secure Sockets Layer/Transport Layer Security)<a hidden class=anchor aria-hidden=true href=#ssltlssecure-sockets-layertransport-layer-security>#</a></h5><p>데이터 암호화와 인증을 위한 프로토콜입니다.</p><p><strong>특징:</strong></p><ul><li><strong>암호화</strong>: 데이터의 기밀성 보장</li><li><strong>인증</strong>: 서버와 클라이언트의 신원 확인</li><li><strong>무결성</strong>: 데이터 변조 감지</li></ul><p><strong>TLS 핸드셰이크 과정:</strong></p><ol><li><strong>클라이언트 헬로</strong>: 지원하는 암호화 방식 전송</li><li><strong>서버 헬로</strong>: 사용할 암호화 방식 선택 및 인증서 전송</li><li><strong>인증서 검증</strong>: 클라이언트가 서버 인증서 확인</li><li><strong>키 교환</strong>: 세션 키 생성을 위한 정보 교환</li><li><strong>세션 키 생성</strong>: 양측이 동일한 세션 키 생성</li><li><strong>암호화 통신 시작</strong>: 생성된 키로 암호화 통신</li></ol><h5 id=ipsecinternet-protocol-security>IPSec(Internet Protocol Security)<a hidden class=anchor aria-hidden=true href=#ipsecinternet-protocol-security>#</a></h5><p>IP 계층에서의 보안을 위한 프로토콜 집합입니다.</p><p><strong>특징:</strong></p><ul><li><strong>인증 헤더(AH)</strong>: 데이터 무결성과 인증 제공</li><li><strong>보안 페이로드 캡슐화(ESP)</strong>: 암호화와 제한된 인증 제공</li><li><strong>두 가지 모드</strong>: 전송 모드와 터널 모드</li></ul><h4 id=5-링크-계층-프로토콜>5. 링크 계층 프로토콜<a hidden class=anchor aria-hidden=true href=#5-링크-계층-프로토콜>#</a></h4><p>인접한 네트워크 노드 간의 통신을 담당하는 프로토콜입니다.</p><h5 id=이더넷ethernet>이더넷(Ethernet)<a hidden class=anchor aria-hidden=true href=#이더넷ethernet>#</a></h5><p>가장 널리 사용되는 LAN 기술입니다.</p><p><strong>특징:</strong></p><ul><li><strong>CSMA/CD</strong>: 충돌 감지 및 해결 메커니즘</li><li><strong>MAC 주소</strong>: 물리적 주소를 사용한 장치 식별</li><li><strong>프레임 구조</strong>: 특정 형식의 데이터 패킷</li></ul><h5 id=ppppoint-to-point-protocol>PPP(Point-to-Point Protocol)<a hidden class=anchor aria-hidden=true href=#ppppoint-to-point-protocol>#</a></h5><p>두 네트워크 노드 간의 직접 연결을 위한 프로토콜입니다.</p><p><strong>특징:</strong></p><ul><li><strong>인증</strong>: PAP, CHAP 등의 인증 방식 지원</li><li><strong>다중 프로토콜</strong>: 여러 네트워크 프로토콜 지원</li><li><strong>링크 설정</strong>: 연결 설정, 유지, 종료 기능</li></ul><h3 id=네트워크-프로토콜의-실제-작동-예시>네트워크 프로토콜의 실제 작동 예시<a hidden class=anchor aria-hidden=true href=#네트워크-프로토콜의-실제-작동-예시>#</a></h3><p>실제 웹 페이지 접속 과정을 통해 여러 프로토콜의 상호작용을 살펴보겠습니다:</p><ol><li><p><strong>DNS 조회</strong>: 브라우저가 <code>www.example.com</code>의 IP 주소를 알기 위해 DNS 프로토콜 사용</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트 -&gt; DNS 서버: &#34;www.example.com의 IP 주소는?&#34;
</span></span><span class=line><span class=cl>DNS 서버 -&gt; 클라이언트: &#34;93.184.216.34입니다.&#34;
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>TCP 연결 설정</strong>: 브라우저가 웹 서버와 TCP 연결 설정(3-way 핸드셰이크)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트 -&gt; 서버: SYN(시퀀스 번호: 1000)
</span></span><span class=line><span class=cl>서버 -&gt; 클라이언트: SYN-ACK(시퀀스 번호: 2000, ACK: 1001)
</span></span><span class=line><span class=cl>클라이언트 -&gt; 서버: ACK(ACK: 2001)
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>TLS 핸드셰이크</strong>(HTTPS의 경우): 암호화 통신을 위한 키 교환</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트 -&gt; 서버: &#34;안녕하세요, TLS 1.3을 지원합니다.&#34;
</span></span><span class=line><span class=cl>서버 -&gt; 클라이언트: &#34;안녕하세요, 여기 제 인증서가 있습니다.&#34;
</span></span><span class=line><span class=cl>클라이언트: [인증서 확인]
</span></span><span class=line><span class=cl>클라이언트 -&gt; 서버: &#34;이 키를 사용해 암호화합시다.&#34;
</span></span><span class=line><span class=cl>서버: [키 확인 및 수락]
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>HTTP 요청</strong>: 브라우저가 웹 페이지 요청</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GET / HTTP/1.1
</span></span><span class=line><span class=cl>Host: www.example.com
</span></span><span class=line><span class=cl>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
</span></span><span class=line><span class=cl>Accept: text/html,application/xhtml+xml
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>HTTP 응답</strong>: 서버가 요청한 웹 페이지 제공</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HTTP/1.1 200 OK
</span></span><span class=line><span class=cl>Date: Thu, 13 Mar 2025 12:00:00 GMT
</span></span><span class=line><span class=cl>Content-Type: text/html
</span></span><span class=line><span class=cl>Content-Length: 1234
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;!DOCTYPE html&gt;
</span></span><span class=line><span class=cl>&lt;html&gt;
</span></span><span class=line><span class=cl>&lt;head&gt;
</span></span><span class=line><span class=cl>    &lt;title&gt;Example Domain&lt;/title&gt;
</span></span><span class=line><span class=cl>&lt;/head&gt;
</span></span><span class=line><span class=cl>&lt;body&gt;
</span></span><span class=line><span class=cl>    &lt;h1&gt;Example Domain&lt;/h1&gt;
</span></span><span class=line><span class=cl>    &lt;p&gt;This domain is for use in illustrative examples...&lt;/p&gt;
</span></span><span class=line><span class=cl>&lt;/body&gt;
</span></span><span class=line><span class=cl>&lt;/html&gt;
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>TCP 연결 종료</strong>: 통신 완료 후 연결 종료(4-way 핸드셰이크)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>클라이언트 -&gt; 서버: FIN
</span></span><span class=line><span class=cl>서버 -&gt; 클라이언트: ACK
</span></span><span class=line><span class=cl>서버 -&gt; 클라이언트: FIN
</span></span><span class=line><span class=cl>클라이언트 -&gt; 서버: ACK
</span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=프로토콜-캡슐화와-디캡슐화>프로토콜 캡슐화와 디캡슐화<a hidden class=anchor aria-hidden=true href=#프로토콜-캡슐화와-디캡슐화>#</a></h3><p>네트워크 통신에서 데이터는 계층을 통과하며 각 계층의 헤더가 추가(캡슐화)되거나 제거(디캡슐화)됩니다.</p><p><strong>캡슐화 과정(송신 측):</strong></p><ol><li>응용 계층: 데이터 생성</li><li>전송 계층: TCP/UDP 헤더 추가</li><li>네트워크 계층: IP 헤더 추가</li><li>데이터 링크 계층: MAC 헤더와 트레일러 추가</li><li>물리 계층: 비트로 변환하여 전송</li></ol><p><strong>디캡슐화 과정(수신 측):</strong></p><ol><li>물리 계층: 비트를 프레임으로 변환</li><li>데이터 링크 계층: MAC 헤더와 트레일러 제거</li><li>네트워크 계층: IP 헤더 제거</li><li>전송 계층: TCP/UDP 헤더 제거</li><li>응용 계층: 데이터 처리</li></ol><h3 id=프로토콜-분석-도구>프로토콜 분석 도구<a hidden class=anchor aria-hidden=true href=#프로토콜-분석-도구>#</a></h3><p>네트워크 프로토콜을 분석하기 위한 다양한 도구가 있습니다:</p><h4 id=wireshark>Wireshark<a hidden class=anchor aria-hidden=true href=#wireshark>#</a></h4><p>가장 널리 사용되는 패킷 분석 도구로, 다양한 프로토콜의 패킷을 캡처하고 분석할 수 있습니다.</p><p><strong>주요 기능:</strong></p><ul><li>실시간 패킷 캡처</li><li>프로토콜 디코딩</li><li>필터링 기능</li><li>통계 분석</li><li>시각화 도구</li></ul><h4 id=tcpdump>Tcpdump<a hidden class=anchor aria-hidden=true href=#tcpdump>#</a></h4><p>명령줄 기반의 패킷 분석 도구로, 유닉스 계열 시스템에서 주로 사용됩니다.</p><p><strong>사용 예시:</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># HTTP 트래픽 캡처</span>
</span></span><span class=line><span class=cl>tcpdump -i eth0 port <span class=m>80</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 특정 호스트와의 통신 캡처</span>
</span></span><span class=line><span class=cl>tcpdump host 192.168.1.1
</span></span></code></pre></td></tr></table></div></div><h3 id=미래의-네트워크-프로토콜-동향>미래의 네트워크 프로토콜 동향<a hidden class=anchor aria-hidden=true href=#미래의-네트워크-프로토콜-동향>#</a></h3><p>네트워크 기술의 발전에 따라 프로토콜도 계속 진화하고 있습니다:</p><ol><li><strong>HTTP/3</strong>: QUIC 프로토콜 기반, 지연 시간 감소</li><li><strong>5G 프로토콜</strong>: 고속, 저지연, 대용량 통신 지원</li><li><strong>IoT 프로토콜</strong>: MQTT, CoAP 등 경량화된 프로토콜 발전</li><li><strong>SDN(Software-Defined Networking)</strong>: OpenFlow 등의 프로토콜 발전</li><li><strong>블록체인 네트워크 프로토콜</strong>: 분산 네트워크를 위한 새로운 프로토콜</li></ol><h3 id=physical-protocol>Physical Protocol<a hidden class=anchor aria-hidden=true href=#physical-protocol>#</a></h3><p>물리 프로토콜은 실제 데이터가 물리적 매체를 통해 전송되는 방식을 정의한다.<br>이는 전기 신호, 광신호, 전파 등의 형태로 데이터를 전송하는 방법을 다룬다.</p><table><thead><tr><th>프로토콜</th><th>OSI 계층</th><th>TCP/IP 계층</th><th>역할 및 기능</th><th>주요 특징</th><th>장점</th><th>동작 방식</th></tr></thead><tbody><tr><td>Ethernet</td><td>물리 계층, 데이터 링크 계층</td><td>네트워크 액세스 계층</td><td>LAN에서 데이터 전송</td><td>MAC 주소 사용, CSMA/CD 방식</td><td>빠르고 안정적, 비용 효율적</td><td>패킷 교환 방식, 스위치 기반 데이터 전송</td></tr><tr><td>Frame Relay</td><td>데이터 링크 계층</td><td>네트워크 액세스 계층</td><td>가상 회로를 통한 데이터 전송</td><td>DLCI 사용, 간소화된 프로토콜</td><td>X.25보다 효율적, 고속 데이터 전송</td><td>가상 회로 기반, LMI 신호로 상태 확인</td></tr><tr><td>ATM</td><td>데이터 링크 계층, 네트워크 계층</td><td>네트워크 액세스 계층</td><td>음성, 비디오, 데이터 통합 전송</td><td>53바이트 셀 단위 전송, QoS 보장</td><td>멀티미디어 데이터 전송에 적합, 하드웨어 기반 스위칭</td><td>셀 기반 스위칭, 가상 회로 사용</td></tr><tr><td>SONET</td><td>물리 계층</td><td>네트워크 액세스 계층</td><td>광섬유 기반 고속 데이터 전송</td><td>동기식 전송, STS 프레임 사용</td><td>고속 전송, 표준화된 인터페이스</td><td>프레임 기반 동기 전송, 다중화 기술 사용</td></tr><tr><td>SDH</td><td>물리 계층</td><td>네트워크 액세스 계층</td><td>SONET의 국제 표준 버전</td><td>STM 프레임 사용</td><td>글로벌 호환성, 유연한 대역폭 할당</td><td>SONET와 유사한 동기 전송 방식</td></tr><tr><td>PDH</td><td>물리 계층</td><td>네트워크 액세스 계층</td><td>디지털 계위 신호 전송</td><td>비동기식 다중화</td><td>기존 네트워크와의 호환성</td><td>준동기식 전송, 비트 스터핑 사용</td></tr><tr><td>CDMA</td><td>물리 계층</td><td>네트워크 액세스 계층</td><td>무선 통신에서 다중 접속</td><td>코드 분할 다중 접속</td><td>높은 용량, 간섭 저항성</td><td>확산 스펙트럼 기술 사용</td></tr><tr><td>GSM</td><td>물리 계층, 데이터 링크 계층</td><td>네트워크 액세스 계층</td><td>디지털 셀룰러 이동통신</td><td>TDMA 기반, SIM 카드 사용</td><td>글로벌 로밍, 음성 및 데이터 서비스</td><td>시분할 다중 접속, 주파수 호핑</td></tr></tbody></table><p>추가 설명:</p><ol><li>Ethernet은 현재 가장 널리 사용되는 LAN 프로토콜로, CSMA/CD 방식을 통해 데이터 충돌을 관리하며, 비교적 단순한 구조로 높은 효율성을 제공한다.</li><li>Token Ring은 IBM이 개발한 프로토콜로, 토큰을 사용하여 충돌 없는 데이터 전송을 보장하지만, 현재는 Ethernet에 비해 사용빈도가 낮다.</li><li>Frame Relay는 패킷 스위칭 기술을 사용하는 WAN 프로토콜로, 가상 회선을 통해 효율적인 데이터 전송을 제공한다.</li><li>ATM은 고정 크기의 셀을 사용하여 다양한 형태의 트래픽을 통합 전송할 수 있으며, QoS를 보장하는 특징이 있다.</li><li>SONET/SDH는 광통신 네트워크의 표준 프로토콜로, 높은 신뢰성과 관리 용이성을 제공한다.</li><li>PDH는 SONET/SDH 이전에 사용된 디지털 전송 방식으로, 비동기식 특성으로 인해 관리가 다소 복잡할 수 있다.</li><li>CDMA는 코드분할 방식을 사용하는 무선통신 프로토콜로, 높은 보안성과 간섭 저항성이 특징이다.</li><li>GSM은 글로벌 이동통신 표준으로, SIM 카드를 통한 사용자 인증과 글로벌 로밍 서비스를 제공한다.</li></ol><h3 id=logical-protocol>Logical Protocol<a hidden class=anchor aria-hidden=true href=#logical-protocol>#</a></h3><p>논리 프로토콜은 데이터의 논리적인 주소 지정, 라우팅, 흐름 제어 등을 담당한다.<br>이는 실제 물리적 연결과는 독립적으로 동작한다.</p><h4 id=ip--ipsec>IP / IPSec<a hidden class=anchor aria-hidden=true href=#ip--ipsec>#</a></h4><p>IP는 인터넷 통신의 기본이 되는 프로토콜로, 데이터 패킷의 주소 지정과 라우팅을 담당한다.<br>반면 IPsec은 IP 통신에 보안 기능을 추가하여 데이터의 기밀성, 무결성, 인증을 제공한다.<br>IPsec은 VPN 구현에 널리 사용되며, 네트워크 계층에서 작동하여 전체 네트워크 트래픽을 보호할 수 있다.</p><table><thead><tr><th>구분</th><th>IP (Internet Protocol)</th><th>IPsec (Internet Protocol Security)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>네트워크 계층 (3계층)</td><td>네트워크 계층 (3계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>인터넷 계층</td><td>인터넷 계층</td></tr><tr><td>주요 역할</td><td>데이터그램 기반의 패킷 전달 및 라우팅</td><td>IP 통신의 보안성 제공 (인증, 암호화, 무결성)</td></tr><tr><td>프로토콜 특성</td><td>- 비연결형 서비스<br>- 최선형 전달<br>- 독립적 패킷 라우팅<br>- 단편화/재조립 지원</td><td>- 종단간 보안<br>- 투명한 보안 서비스<br>- 유연한 구성<br>- 호환성 유지</td></tr><tr><td>주요 기능</td><td>- 패킷 라우팅<br>- 주소 지정<br>- 단편화/재조립<br>- 헤더 처리</td><td>- 데이터 암호화<br>- 패킷 인증<br>- 무결성 보장<br>- 키 관리</td></tr><tr><td>동작 모드</td><td>- 데이터그램 방식<br>- 패킷 독립 처리<br>- 헤더 기반 라우팅<br>TTL 기반 제어</td><td>- 전송 모드<br>- 터널 모드<br>ESP/AH 프로토콜<br>IKE 키 교환</td></tr><tr><td>보안 특성</td><td>- 기본 보안 없음<br>- 평문 전송<br>- 위조/변조 가능<br>- 도청 가능</td><td>- 강력한 암호화<br>- 패킷 인증<br>- 재전송 방지<br>- 키 관리 자동화</td></tr><tr><td>헤더 구조</td><td>- 버전<br>- 헤더 길이<br>- 서비스 유형<br>- 전체 길이<br>- 식별자<br>- 플래그<br>- 단편화 오프셋<br>TTL<br>- 프로토콜<br>- 체크섬<br>- 출발지/목적지 주소</td><td>- AH 헤더 (인증)<br>ESP 헤더 (암호화)<br>- 보안 연관(SA) 정보<br>- 시퀀스 번호<br>- 무결성 체크값</td></tr><tr><td>장점</td><td>- 단순한 구조<br>- 효율적인 라우팅<br>- 높은 확장성<br>- 상호운용성</td><td>- 강력한 보안<br>- 투명한 적용<br>- 유연한 구성<br>- 표준화된 보안</td></tr><tr><td>단점</td><td>- 신뢰성 없음<br>- 보안성 없음<br>QoS 보장 없음<br>- 혼잡 제어 없음</td><td>- 구현 복잡성<br>- 성능 오버헤드<br>- 키 관리 부담<br>NAT 통과 문제</td></tr><tr><td>활용 분야</td><td>- 인터넷 통신<br>- 기본 네트워킹<br>- 패킷 전달<br>- 라우팅</td><td>- VPN 구축<br>- 기업 네트워크<br>- 원격 접속<br>- 보안 통신</td></tr><tr><td>표준화 기구</td><td>IETF</td><td>IETF</td></tr><tr><td>관련 프로토콜</td><td>IPv4, IPv6</td><td>ESP, AH, IKE</td></tr></tbody></table><p>이 두 프로토콜의 주요 차이점과 상호 관계는 다음과 같다:</p><ol><li><p>기본 동작과 보안:</p><ul><li>IP: 기본적인 패킷 전달에 중점</li><li>IPsec: IP 통신에 보안 기능을 추가</li></ul></li><li><p>구현 복잡성:</p><ul><li>IP: 단순하고 기본적인 구현</li><li>IPsec: 복잡한 보안 메커니즘 구현</li></ul></li><li><p>성능과 오버헤드:</p><ul><li>IP: 최소한의 오버헤드</li><li>IPsec: 보안 처리로 인한 추가 오버헤드</li></ul></li><li><p>응용 환경:</p><ul><li>IP: 모든 인터넷 통신의 기본</li><li>IPsec: 보안이 중요한 특수한 환경</li></ul></li></ol><p>IP와 IPsec은 서로 보완적인 관계에 있으며, 현대 네트워크에서는 요구사항에 따라 적절히 선택하여 사용된다.</p><h4 id=tcp--udp>TCP / UDP<a hidden class=anchor aria-hidden=true href=#tcp--udp>#</a></h4><p>TCP는 신뢰성 있는 데이터 전송을 보장하며, 연결 지향적인 프로토콜이다.<br>3-way handshake를 통해 연결을 설정하고, 데이터의 순서를 보장하며, 오류 발생 시 재전송을 수행한다.<br>흐름 제어와 혼잡 제어 기능을 통해 네트워크의 안정성을 유지한다.</p><p>UDP는 비연결 지향적이며 단순한 데이터 전송에 중점을 둔다.<br>연결 설정 과정이 없어 빠른 전송이 가능하지만, 데이터의 신뢰성과 순서를 보장하지 않는다.<br>실시간 스트리밍이나 게임 등 속도가 중요한 애플리케이션에서 주로 사용된다.</p><table><thead><tr><th>구분</th><th>TCP (Transmission Control Protocol)</th><th>UDP (User Datagram Protocol)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>전송 계층 (4계층)</td><td>전송 계층 (4계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>전송 계층</td><td>전송 계층</td></tr><tr><td>프로토콜 특성</td><td>연결형 프로토콜 (Connection-oriented)<br>- 데이터 전송 전 연결 설정<br>- 순차적 데이터 전송<br>- 신뢰성 보장</td><td>비연결형 프로토콜 (Connectionless)<br>- 연결 설정 없음<br>- 독립적 데이터 전송<br>- 신뢰성 미보장</td></tr><tr><td>주요 기능</td><td>- 흐름 제어<br>- 혼잡 제어<br>- 오류 검출 및 복구<br>- 데이터 순서 보장<br>- 데이터 분할 및 재조립</td><td>- 단순한 데이터 전송<br>- 최소한의 오류 검출<br>- 빠른 전송 속도<br>- 실시간 데이터 처리</td></tr><tr><td>데이터 전송 방식</td><td>세그먼트(Segment) 단위로 분할 전송<br>3-way 핸드셰이킹<br>- 순차번호 부여<br>- 확인응답 사용</td><td>데이터그램(Datagram) 단위로 독립 전송<br>- 연결 설정 없음<br>- 순차번호 없음<br>- 확인응답 없음</td></tr><tr><td>신뢰성 보장</td><td>- 데이터 손실 시 재전송<br>- 중복 데이터 제거<br>- 순서 보장<br>- 데이터 완전성 검증</td><td>- 데이터 손실 가능<br>- 중복 데이터 가능<br>- 순서 보장 없음<br>- 최소한의 오류 검출</td></tr><tr><td>속도 특성</td><td>- 상대적으로 느림<br>- 오버헤드 큼<br>- 처리 시간 많이 소요</td><td>- 상대적으로 빠름<br>- 오버헤드 작음<br>- 처리 시간 적게 소요</td></tr><tr><td>주요 사용 분야</td><td>- 파일 전송<br>- 이메일<br>- 웹 브라우징<br>- 원격 접속</td><td>- 실시간 스트리밍<br>- 온라인 게임<br>VoIP<br>DNS 쿼리</td></tr><tr><td>장점</td><td>- 높은 신뢰성<br>- 데이터 순서 보장<br>- 혼잡 제어 기능<br>- 완전성 보장</td><td>- 빠른 전송 속도<br>- 적은 지연 시간<br>- 단순한 구조<br>- 적은 시스템 부하</td></tr><tr><td>단점</td><td>- 느린 전송 속도<br>- 많은 시스템 자원 사용<br>- 큰 프로토콜 오버헤드<br>- 지연 시간 발생</td><td>- 데이터 손실 가능<br>- 신뢰성 부족<br>- 순서 보장 없음<br>- 혼잡 제어 없음</td></tr><tr><td>헤더 크기</td><td>20-60 바이트</td><td>8 바이트</td></tr><tr><td>연결 설정</td><td>필요 (3-way handshaking)</td><td>불필요</td></tr><tr><td>순서 제어</td><td>있음 (순차번호 사용)</td><td>없음</td></tr><tr><td>흐름 제어</td><td>있음 (윈도우 크기 조절)</td><td>없음</td></tr><tr><td>혼잡 제어</td><td>있음 (혼잡 윈도우 사용)</td><td>없음</td></tr></tbody></table><h4 id=http--https>HTTP / HTTPS<a hidden class=anchor aria-hidden=true href=#http--https>#</a></h4><p>HTTP와 HTTPS는 모두 웹 통신에 사용되는 프로토콜이지만, HTTPS는 보안 기능이 추가되어 더 안전한 통신을 제공한다.<br>두 프로토콜 모두 OSI 모델과 TCP/IP 모델의 최상위 계층에서 동작하며, 웹 브라우저와 서버 간의 데이터 교환을 담당한다.</p><table><thead><tr><th>구분</th><th>HTTP (Hypertext Transfer Protocol)</th><th>HTTPS (Hypertext Transfer Protocol Secure)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>기본 포트</td><td>80</td><td>443</td></tr><tr><td>보안 계층</td><td>없음</td><td>SSL/TLS</td></tr><tr><td>주요 역할</td><td>웹 브라우저와 웹 서버 간의 통신</td><td>보안이 강화된 웹 브라우저와 웹 서버 간의 통신</td></tr><tr><td>데이터 전송 방식</td><td>평문 전송</td><td>암호화된 전송</td></tr><tr><td>통신 과정</td><td>1. TCP 연결 수립<br>2. HTTP 요청 전송<br>3. HTTP 응답 수신<br>4. 연결 종료</td><td>1. TCP 연결 수립<br>2. SSL/TLS 핸드셰이크<br>3. 암호화된 HTTP 요청 전송<br>4. 암호화된 HTTP 응답 수신<br>5. 연결 종료</td></tr><tr><td>주요 특징</td><td>- Stateless 프로토콜<br>- 확장 가능한 구조<br>- 단순한 요청-응답 모델<br>- 텍스트 기반 통신</td><td>- HTTP에 보안 계층 추가<br>- 데이터 암호화<br>- 서버 인증<br>- 데이터 무결성 보장</td></tr><tr><td>주요 기능</td><td>- 웹 페이지 전송<br>- 파일 전송<br>- 폼 데이터 전송<br>API 통신</td><td>- 보안 웹 페이지 전송<br>- 암호화된 파일 전송<br>- 보안 API 통신<br>- 전자 상거래</td></tr><tr><td>HTTP 메소드 지원</td><td>GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH</td><td>동일한 HTTP 메소드 지원</td></tr><tr><td>보안 특성</td><td>- 데이터 노출 위험<br>- 중간자 공격 취약<br>- 데이터 변조 가능<br>- 서버 인증 없음</td><td>- 데이터 암호화<br>- 중간자 공격 방지<br>- 데이터 무결성 보장<br>- 서버 인증 제공</td></tr><tr><td>성능 특성</td><td>- 빠른 통신 속도<br>- 적은 리소스 사용<br>- 낮은 서버 부하<br>- 단순한 구현</td><td>- 상대적으로 느린 속도<br>- 더 많은 리소스 사용<br>- 높은 서버 부하<br>- 복잡한 구현</td></tr><tr><td>장점</td><td>- 단순한 구조<br>- 빠른 속도<br>- 적은 오버헤드<br>- 쉬운 디버깅</td><td>- 강력한 보안<br>- 데이터 보호<br>- 신뢰성 있는 통신<br>SEO 이점</td></tr><tr><td>단점</td><td>- 보안성 부족<br>- 데이터 노출<br>- 신뢰성 부족<br>- 무결성 보장 없음</td><td>- 추가 처리 시간<br>- 높은 리소스 사용<br>- 인증서 비용<br>- 복잡한 설정</td></tr><tr><td>주요 사용 사례</td><td>- 일반 웹사이트<br>- 비중요 정보 전송<br>- 내부 네트워크 통신<br>- 테스트 환경</td><td>- 전자상거래<br>- 온라인 뱅킹<br>- 민감한 정보 전송<br>- 기업 웹사이트</td></tr><tr><td>헤더 특성</td><td>일반 텍스트 헤더</td><td>암호화된 헤더</td></tr><tr><td>캐싱 가능 여부</td><td>가능</td><td>가능 (보안 고려 필요)</td></tr></tbody></table><p>HTTP/HTTPS의 발전 과정을 보면 다음과 같은 주요 버전들이 있다:</p><ol><li><p>HTTP/1.0</p><ul><li>기본적인 요청-응답 모델</li><li>연결당 하나의 요청만 처리</li><li>단순한 헤더 구조</li></ul></li><li><p>HTTP/1.1</p><ul><li>지속적 연결 지원</li><li>파이프라이닝 도입</li><li>호스트 헤더 필수화</li></ul></li><li><p>HTTP/2</p><ul><li>멀티플렉싱 지원</li><li>헤더 압축</li><li>서버 푸시</li><li>스트림 우선순위</li></ul></li><li><p>HTTP/3 (최신)</p><ul><li>QUIC 프로토콜 기반</li><li>향상된 성능</li><li>개선된 보안</li><li>더 나은 모바일 지원</li></ul></li></ol><p>이러한 웹 프로토콜들은 현대 인터넷의 근간을 이루며, 특히 HTTPS는 보안이 중요시되는 현대 웹 환경에서 필수적인 프로토콜로 자리잡았다.</p><h4 id=ssl--tls>SSL / TLS<a hidden class=anchor aria-hidden=true href=#ssl--tls>#</a></h4><p>SSL과 TLS는 모두 웹 통신의 보안을 위해 설계된 프로토콜로, 데이터의 암호화, 인증, 무결성을 보장한다.<br>TLS는 SSL의 후속 버전으로, 더 강력한 보안 기능과 성능 개선을 제공한다.<br>현재는 SSL이 더 이상 사용되지 않고 TLS가 널리 사용되고 있다.</p><table><thead><tr><th>구분</th><th>SSL (Secure Sockets Layer)</th><th>TLS (Transport Layer Security)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>표현 계층(6계층) / 세션 계층(5계층)</td><td>표현 계층(6계층) / 세션 계층(5계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>주요 역할</td><td>네트워크 통신의 종단간 보안 제공</td><td>네트워크 통신의 종단간 보안 제공</td></tr><tr><td>현재 상태</td><td>더 이상 사용되지 않음 (Deprecated)</td><td>현재 표준으로 사용 중</td></tr><tr><td>최신 버전</td><td>SSL 3.0 (사용 중단)</td><td>TLS 1.3</td></tr><tr><td>주요 기능</td><td>- 데이터 암호화<br>- 인증<br>- 무결성 검증<br>- 키 교환</td><td>- 향상된 데이터 암호화<br>- 강화된 인증<br>- 개선된 무결성 검증<br>- 최적화된 키 교환</td></tr><tr><td>핸드셰이크 과정</td><td>1. Client Hello<br>2. Server Hello<br>3. 인증서 교환<br>4. 키 교환<br>5. 암호화 통신 시작</td><td>1. Client Hello<br>2. Server Hello + 인증서 + 키 교환<br>3. 클라이언트 완료<br>4. 암호화 통신 시작</td></tr><tr><td>지원 암호화 알고리즘</td><td>- RC4<br>DES<br>3DES<br>AES</td><td>- AES<br>ChaCha20<br>Poly1305<br>- 최신 암호화 알고리즘</td></tr><tr><td>보안 특징</td><td>- 기본적인 암호화 제공<br>- 취약한 암호화 알고리즘 포함<br>- 알려진 보안 취약점 존재</td><td>- 강력한 암호화<br>- 취약한 알고리즘 제거<br>- 최신 보안 기능 추가</td></tr><tr><td>성능 특성</td><td>- 상대적으로 느린 핸드셰이크<br>- 더 많은 라운드 트립 필요<br>- 높은 지연 시간</td><td>- 최적화된 핸드셰이크<br>0-RTT 재개 지원<br>- 낮은 지연 시간</td></tr><tr><td>장점</td><td>- 구현 단순<br>- 광범위한 호환성<br>- 기본적인 보안 제공</td><td>- 향상된 보안<br>- 더 나은 성능<br>- 현대적 암호화<br>- 지속적인 개선</td></tr><tr><td>단점</td><td>- 알려진 취약점<br>- 낮은 성능<br>- 사용 중단됨<br>- 더 이상의 개선 없음</td><td>- 이전 버전과의 호환성 문제<br>- 구현 복잡성<br>- 더 많은 리소스 필요</td></tr><tr><td>주요 사용 사례</td><td>(현재는 사용하지 않음)</td><td>- HTTPS 웹 통신<br>- 이메일 보안<br>VPN<br>- 금융 거래</td></tr><tr><td>보안 강도</td><td>취약 (더 이상 안전하지 않음)</td><td>매우 강력 (현재 표준)</td></tr><tr><td>인증서 지원</td><td>X 인증서</td><td>X 인증서 (향상된 검증)</td></tr><tr><td>키 교환 방식</td><td>- RSA<br>Diffie-Hellman</td><td>- ECDHE<br>DHE<br>- 향상된 키 교환 방식</td></tr></tbody></table><p>TLS의 발전 과정을 보면 다음과 같은 주요 개선사항들이 있었다:</p><ol><li><p>TLS 1.0</p><ul><li>SSL 3.0을 기반으로 개발</li><li>기본적인 보안 개선</li><li>HMAC 도입</li></ul></li><li><p>TLS 1.1</p><ul><li>CBC 공격 방어</li><li>명시적 IV 사용</li><li>에러 처리 개선</li></ul></li><li><p>TLS 1.2</p><ul><li>SHA-256 지원</li><li>암호화 스위트 개선</li><li>의사난수 함수 개선</li></ul></li><li><p>TLS 1.3 (최신)</p><ul><li>핸드셰이크 최적화</li><li>0-RTT 재개</li><li>취약한 알고리즘 제거</li><li>향상된 개인정보 보호</li></ul></li></ol><p>이러한 보안 프로토콜들은 현대 인터넷 보안의 근간을 이루며, 특히 TLS는 지속적인 개선을 통해 더욱 안전하고 효율적인 보안 통신을 가능하게 하고 있다.</p><h4 id=snmp--icmp--ntp--rmon>SNMP / ICMP / NTP / RMON<a hidden class=anchor aria-hidden=true href=#snmp--icmp--ntp--rmon>#</a></h4><p>SNMP는 네트워크 장치의 상태를 모니터링하고 관리하는 데 사용되며, MIB를 통해 정보를 구조화한다.<br>Manager와 Agent 간의 통신으로 동작한다.</p><p>ICMP는 네트워크 문제를 진단하고 오류를 보고하는 데 사용된다.<br>Ping과 Traceroute 같은 도구에서 활용되며, 연결 없이 메시지를 전송한다.</p><p>NTP는 네트워크 상의 장치들 간에 시간을 동기화하는 데 사용된다.<br>계층적 구조를 통해 정확한 시간 정보를 전파하며, 네트워크 지연을 고려하여 시간을 조정한다.</p><p>RMON은 SNMP의 확장된 형태로, 더 상세한 네트워크 모니터링 기능을 제공한다.</p><p>모두 네트워크 관리와 운영에 중요한 역할을 하며, 각각의 특성에 따라 다양한 네트워크 기능을 지원한다.</p><table><thead><tr><th>구분</th><th>SNMP (Simple Network Management Protocol)</th><th>ICMP (Internet Control Message Protocol)</th><th>NTP (Network Time Protocol)</th><th>RMON (Remote Network Monitoring)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>응용 계층 (7계층)</td><td>네트워크 계층 (3계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>응용 계층</td><td>인터넷 계층</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>프로토콜 역할</td><td>네트워크 장비 및 시스템 관리 및 모니터링</td><td>네트워크 오류 보고 및 진단</td><td>컴퓨터 시스템 간 시간 동기화</td><td>원격 네트워크 모니터링 및 분석</td></tr><tr><td>주요 기능</td><td>- 네트워크 모니터링<br>- 성능 관리<br>- 장비 구성 관리<br>- 문제 감지 및 보고</td><td>- 오류 메시지 전송<br>- 네트워크 연결성 테스트<br>- 경로 진단<br>- 라우터 광고/요청</td><td>- 시간 정보 동기화<br>- 지연시간 측정<br>- 시간 서버 계층 구조 관리<br>- 정밀한 시간 조정</td><td>- 트래픽 모니터링<br>- 통계 수집<br>- 이력 데이터 관리<br>- 알람 설정</td></tr><tr><td>동작 방식</td><td>- 관리자/에이전트 구조<br>GET/SET 명령 사용<br>MIB 기반 정보 관리<br>- 트랩 메시지 사용</td><td>- IP 프로토콜 기반<br>- 요청/응답 메시지<br>- 타입과 코드로 메시지 구분<br>TTL 기반 작동</td><td>- 계층적 서버 구조<br>UDP 포트 123 사용<br>- 폴링 방식<br>- 지터 버퍼 사용</td><td>- SNMP 기반 동작<br>- 프로브/콘솔 구조<br>- 지속적 데이터 수집<br>- 이벤트 기반 알림</td></tr><tr><td>특성</td><td>- UDP 기반 통신<br>- 비연결형 서비스<br>- 간단한 구조<br>- 확장 가능한 구조</td><td>- IP의 필수 구성요소<br>- 신뢰성 없는 전송<br>- 제어 메시지 전용<br>- 낮은 우선순위</td><td>- 정밀한 시간 동기화<br>- 계층적 구조<br>- 지연 보상<br>- 신뢰성 있는 동기화</td><td>- 분산 모니터링<br>- 상세한 통계<br>- 이력 데이터 저장<br>- 유연한 분석</td></tr><tr><td>주요 특징</td><td>- 버전 1, 2c, 3 존재<br>- 보안 기능 강화(v3)<br>- 표준화된 관리 체계<br>- 다양한 플랫폼 지원</td><td>- Echo 요청/응답<br>- 도달 불가 메시지<br>- 리다이렉션 메시지<br>- 시간 초과 메시지</td><td>- 스트라텀 레벨 구조<br>- 밀리초 단위 정확도<br>- 서머타임 자동 조정<br>- 루트 지연 계산</td><td>- 상세한 모니터링<br>- 이력 데이터 관리<br>- 유연한 분석<br>- 선제적 대응 가능</td></tr><tr><td>장점</td><td>- 쉬운 구현<br>- 낮은 네트워크 부하<br>- 통합 관리 가능<br>- 자동화된 모니터링</td><td>- 간단한 구조<br>- 필수적인 오류 보고<br>- 네트워크 진단 용이<br>- 빠른 응답</td><td>- 높은 정확도<br>- 안정적인 동기화<br>- 확장성<br>- 자동 조정</td><td>- 높은 리소스 사용<br>- 구현 복잡성<br>- 높은 저장공간 요구<br>- 관리 부담</td></tr><tr><td>단점</td><td>- 제한된 보안(v1,v2c)<br>- 복잡한 설정(v3)<br>- 대역폭 제한<br>- 확장성 제한</td><td>- 보안 취약성<br>- 신뢰성 부족<br>- 제한된 기능<br>- 차단 가능성</td><td>- 복잡한 구현<br>- 네트워크 지연 영향<br>- 보안 취약성<br>- 높은 자원 사용</td><td>- 네트워크 성능 분석<br>- 트래픽 모니터링<br>- 장애 예방<br>- 용량 계획</td></tr><tr><td>사용 포트</td><td>UDP 161(요청), 162(트랩)</td><td>IP 프로토콜 타입 1</td><td>UDP 123</td><td></td></tr><tr><td>보안 기능</td><td>- 커뮤니티 문자열(v1,v2c)<br>- 인증/암호화(v3)<br>- 접근 제어<br>- 보안 모델</td><td>- 기본 보안 기능 없음<br>- 필터링 필요<br>- 제한된 보안</td><td>- 인증 지원<br>- 대칭키 암호화<br>- 접근 제어<br>NTPv4 보안 강화</td><td></td></tr><tr><td>일반적 용도</td><td>- 네트워크 모니터링<br>- 성능 관리<br>- 장애 관리<br>- 구성 관리</td><td>- Ping 테스트<br>- 경로 추적<br>- 오류 보고<br>- 네트워크 진단</td><td>- 서버 시간 동기화<br>- 로그 시간 동기화<br>- 금융 거래 시간 동기화<br>- 네트워크 시간 관리</td><td></td></tr></tbody></table><h4 id=arp--rarp--dhcp--dns>ARP / RARP / DHCP / DNS<a hidden class=anchor aria-hidden=true href=#arp--rarp--dhcp--dns>#</a></h4><p>이러한 프로토콜들은 각각의 고유한 역할을 통해 현대 네트워크의 기반을 형성한다.<br>특히:</p><ul><li>ARP는 로컬 네트워크에서의 주소 해석을 담당</li><li>RARP는 역방향 주소 해석을 제공했으나 현재는 거의 사용되지 않음</li><li>DHCP는 네트워크 구성의 자동화를 담당</li><li>DNS는 도메인 이름 시스템의 근간을 형성<br>이들은 서로 보완적인 관계를 가지며, 현대 네트워크에서 필수적인 역할을 수행한다.</li></ul><table><thead><tr><th>구분</th><th>ARP (Address Resolution Protocol)</th><th>RARP (Reverse ARP)</th><th>DHCP (Dynamic Host Configuration Protocol)</th><th>DNS (Domain Name System)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>네트워크 계층 (3계층)</td><td>네트워크 계층 (3계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>인터넷 계층</td><td>인터넷 계층</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>기본 포트</td><td>해당 없음</td><td>해당 없음</td><td>UDP 67(서버), 68(클라이언트)</td><td>UDP/TCP 53</td></tr><tr><td>주요 역할</td><td>IP 주소를 MAC 주소로 변환</td><td>MAC 주소를 IP 주소로 변환</td><td>자동 네트워크 구성</td><td>도메인 이름을 IP 주소로 변환</td></tr><tr><td>핵심 기능</td><td>- MAC 주소 검색<br>ARP 캐시 관리<br>- 브로드캐스트 요청<br>- 유니캐스트 응답</td><td>- IP 주소 요청<br>- 부팅 시 IP 할당<br>- 서버 기반 주소 관리<br>- 하드웨어 주소 매핑</td><td>- IP 주소 자동 할당<br>- 네트워크 설정 제공<br>- 임대 시간 관리<br>- 주소 풀 관리</td><td>- 이름 해석<br>- 계층적 네임스페이스<br>- 분산 데이터베이스<br>- 캐싱</td></tr><tr><td>동작 방식</td><td>1. ARP 요청 브로드캐스트<br>2. 대상 호스트 응답<br>3. ARP 캐시 업데이트<br>4. 통신 시작</td><td>1. RARP 요청 브로드캐스트<br>2. RARP 서버 응답<br>3. IP 주소 할당<br>4. 부팅 계속</td><td>1. DHCP 발견<br>2. DHCP 제안<br>3. DHCP 요청<br>4. DHCP 승인</td><td>1. DNS 쿼리 전송<br>2. 재귀적/반복적 검색<br>3. 응답 수신<br>4. 캐시 저장</td></tr><tr><td>특성</td><td>- 브로드캐스트 기반<br>- 로컬 네트워크 한정<br>- 캐시 사용<br>- 자동 갱신</td><td>- 서버 필요<br>- 제한된 사용<br>- 단순한 구조<br>- 레거시 프로토콜</td><td>- 클라이언트-서버 모델<br>- 자동화된 설정<br>- 중앙 관리<br>- 동적 할당</td><td>- 계층적 구조<br>- 분산 시스템<br>- 캐시 메커니즘<br>- 이중화 지원</td></tr><tr><td>장점</td><td>- 자동 주소 매핑<br>- 간단한 구현<br>- 효율적 동작<br>- 자가 갱신</td><td>- 단순한 구조<br>- 쉬운 구현<br>- 중앙 관리<br>- 일관성 보장</td><td>- 자동화된 관리<br>- 효율적인 주소 사용<br>- 유연한 설정<br>- 중앙 관리 용이</td><td>- 사용자 친화적<br>- 확장성<br>- 유연성<br>- 신뢰성</td></tr><tr><td>단점</td><td>- 보안 취약성<br>- 브로드캐스트 부하<br>- 로컬 네트워크 제한<br>ARP 스푸핑 위험</td><td>- 서버 의존성<br>- 제한된 기능<br>- 확장성 부족<br>- 현대 환경 부적합</td><td>- 단일 장애점<br>- 설정 복잡성<br>- 보안 이슈<br>- 서버 부하</td><td>- 캐시 포이즈닝<br>DNS 증폭 공격<br>- 지연 가능성<br>- 복잡한 관리</td></tr><tr><td>일반적 용도</td><td>- LAN 통신<br>IP 네트워킹<br>- 게이트웨이 통신<br>- 네트워크 연결</td><td>- 디스크리스 워크스테이션<br>- 단순 네트워크 구성<br>- 레거시 시스템<br>- 제한된 환경</td><td>- 네트워크 자동 구성<br>IP 주소 관리<br>- 네트워크 설정 배포<br>- 대규모 네트워크 관리</td><td>- 웹 브라우징<br>- 이메일 시스템<br>- 네트워크 서비스<br>- 도메인 관리</td></tr></tbody></table><h4 id=igmp--pim>IGMP / PIM<a hidden class=anchor aria-hidden=true href=#igmp--pim>#</a></h4><p>두 프로토콜은 멀티캐스트 통신에서 서로 다른 역할을 수행하며 상호 보완적으로 동작한다:</p><ol><li><p>IGMP는 로컬 네트워크에서 멀티캐스트 그룹 관리를 담당하며:</p><ul><li>호스트의 그룹 가입/탈퇴 처리</li><li>라우터의 그룹 멤버십 추적</li><li>효율적인 멀티캐스트 전달 지원</li></ul></li><li><p>PIM은 네트워크 전반에서 멀티캐스트 라우팅을 담당하며:</p><ul><li>효율적인 멀티캐스트 트리 구성</li><li>최적의 멀티캐스트 경로 계산</li><li>다양한 네트워크 환경 지원</li></ul></li></ol><p>이 두 프로토콜의 조합으로 효율적인 멀티캐스트 통신이 가능해진다.</p><table><thead><tr><th>구분</th><th>IGMP (Internet Group Management Protocol)</th><th>PIM (Protocol Independent Multicast)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>네트워크 계층 (3계층)</td><td>네트워크 계층 (3계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>인터넷 계층</td><td>인터넷 계층</td></tr><tr><td>프로토콜 유형</td><td>멀티캐스트 관리 프로토콜</td><td>멀티캐스트 라우팅 프로토콜</td></tr><tr><td>주요 역할</td><td>호스트와 라우터 간의 멀티캐스트 그룹 관리</td><td>멀티캐스트 트래픽의 효율적인 라우팅</td></tr><tr><td>동작 모드</td><td>- IGMPv1: 기본 질의/응답<br>IGMPv2: 빠른 탈퇴 추가<br>IGMPv3: 소스 필터링 지원</td><td>- Dense Mode (DM)<br>Sparse Mode (SM)<br>Sparse-Dense Mode<br>Bidirectional Mode</td></tr><tr><td>주요 기능</td><td>- 그룹 가입/탈퇴 관리<br>- 멤버십 보고<br>- 주기적인 질의<br>- 그룹 상태 추적</td><td>- 멀티캐스트 트리 구성<br>- 최적 경로 계산<br>RPF 확인<br>RP 관리</td></tr><tr><td>특성</td><td>- 로컬 서브넷 범위<br>IPv4/IPv6 지원<br>- 질의/응답 기반<br>- 상태 기반 프로토콜</td><td>- 프로토콜 독립적<br>- 유니캐스트 라우팅 활용<br>- 확장성<br>- 유연한 구성</td></tr><tr><td>주요 메시지 유형</td><td>- Membership Query<br>Membership Report<br>Leave Group<br>Group-Specific Query</td><td>- Hello<br>Join/Prune<br>Assert<br>Bootstrap</td></tr><tr><td>동작 방식</td><td>1. 라우터의 주기적 질의<br>2. 호스트의 멤버십 보고<br>3. 그룹 상태 유지<br>4. 필요시 빠른 탈퇴</td><td>1. 이웃 탐색<br>2. 트리 구성<br>3. 경로 최적화<br>4. 주기적 갱신</td></tr><tr><td>장점</td><td>- 단순한 구현<br>- 효율적인 그룹 관리<br>- 빠른 응답성<br>- 낮은 오버헤드</td><td>- 높은 확장성<br>- 효율적인 트래픽 전달<br>- 유연한 토폴로지<br>- 다양한 모드 지원</td></tr><tr><td>단점</td><td>- 제한된 범위<br>- 보안 취약성<br>- 버전 호환성 문제<br>- 대역폭 제한</td><td>- 복잡한 구성<br>- 높은 리소스 사용<br>- 관리 부담<br>- 초기 설정 복잡</td></tr><tr><td>적용 환경</td><td>- 로컬 네트워크<br>- 엔드 시스템<br>- 액세스 네트워크<br>- 마지막 홉 라우터</td><td>- 기업 네트워크<br>- 서비스 제공자<br>- 백본 네트워크<br>- 대규모 네트워크</td></tr><tr><td>주요 특징</td><td>- 버전별 기능 향상<br>MLD와의 통합<br>- 빠른 응답 메커니즘<br>- 그룹별 관리</td><td>- 다양한 동작 모드<br>RP 기반 동작<br>- 자동 RP 탐색<br>- 경로 최적화</td></tr><tr><td>보안 고려사항</td><td>- 무단 가입 위험<br>- 스누핑 취약성<br>DoS 공격 가능성<br>- 인증 메커니즘 부재</td><td>- 인증 필요<br>RP 보안<br>- 경로 검증<br>- 액세스 제어</td></tr></tbody></table><h4 id=rtp--rtcp--rtsp--sip--h323--webrtc--websocket>RTP / RTCP / RTSP / SIP / H.323 / WebRTC / WebSocket<a hidden class=anchor aria-hidden=true href=#rtp--rtcp--rtsp--sip--h323--webrtc--websocket>#</a></h4><p>RTP와 RTCP는 실시간 미디어 전송에 중점을 두고 있으며, RTSP는 스트리밍 미디어의 원격 제어에 사용된다.<br>SIP와 H.323은 VoIP와 화상 회의 등의 멀티미디어 통신 세션 설정에 사용되며, WebRTC는 웹 브라우저 기반의 실시간 통신을 WebSocket은 웹에서의 실시간 양방향 통신을 가능하게 한다.<br>각 프로토콜은 OSI 모델과 TCP/IP 모델에서 주로 응용 계층에 위치하지만, 실제 구현에서는 하위 계층의 프로토콜들과 함께 사용된다.<br>예를 들어, RTP는 주로 UDP를 기반으로 사용되며, SIP는 TCP나 UDP를 사용할 수 있다.<br>이러한 프로토콜들은 실시간 통신, 스트리밍 미디어, 인터넷 전화, 화상 회의 등 다양한 멀티미디어 애플리케이션에서 중요한 역할을 한다.<br>각 프로토콜의 특성과 장단점을 이해하면 적절한 상황에 맞는 프로토콜을 선택하여 효율적인 네트워크 통신을 구현할 수 있다.</p><table><thead><tr><th>구분</th><th>RTP (Real-time Transport Protocol)</th><th>RTCP (RTP Control Protocol)</th><th>RTSP (Real Time Streaming Protocol)</th><th>SIP (Session Initiation Protocol)</th><th>H.323 (ITU-T H)</th><th>WebRTC (Web Real-Time Communication)</th><th>WebSocket</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>세션 계층 (5계층) / 표현 계층 (6계층)</td><td>세션 계층 (5계층) / 표현 계층 (6계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>주요 역할</td><td>실시간 오디오/비디오 데이터 전송</td><td>RTP 세션 모니터링 및 제어</td><td>스트리밍 미디어 제어</td><td>멀티미디어 세션 관리</td><td>종합적인 멀티미디어 통신 제어</td><td>브라우저 기반 실시간 통신</td><td>웹 브라우저와 서버 간의 양방향 실시간 통신 지원</td></tr><tr><td>핵심 기능</td><td>- 순차 번호 부여<br>- 타임스탬프 관리<br>- 페이로드 타입 식별<br>- 미디어 동기화</td><td>- QoS 모니터링<br>- 세션 통계 수집<br>- 참가자 식별<br>- 세션 제어</td><td>- 미디어 전송 제어<br>- 재생/일시정지/정지<br>- 세션 설정/해제<br>- 미디어 속성 협상</td><td>- 세션 설정/수정/종료<br>- 사용자 위치 관리<br>- 미디어 협상<br>- 참가자 관리</td><td>- 호 설정/해제<br>- 대역폭 관리<br>- 멀티포인트 제어<br>- 보안 관리</td><td>- P2P 연결<br>- 미디어 스트리밍<br>- 데이터 채널<br>NAT 통과</td><td>- 전이중 통신 지원<br>- 실시간 양방향 데이터 교환<br>- 단일 TCP 연결 유지<br>- 연결 상태 관리</td></tr><tr><td>특성</td><td>- UDP 기반 전송<br>- 실시간 전송 최적화<br>- 낮은 지연<br>- 손실 허용</td><td>- 주기적 보고<br>- 제어 정보 전송<br>- 대역폭 제한<br>RTP 보완</td><td>- TCP 기반<br>- 상태 기반 프로토콜<br>- 클라이언트-서버 모델<br>HTTP 유사 구문</td><td>- 텍스트 기반<br>- 확장 가능<br>- 독립적 동작<br>- 모듈화 설계</td><td>- 이진 프로토콜<br>- 복잡한 구조<br>- 종합적 기능<br>- 엄격한 표준</td><td>- 브라우저 내장<br>- 표준 기반<br>- 플러그인 불필요<br>- 보안 중심</td><td>- HTTP 기반 호환성<br>- 지속적 연결 유지<br>- 낮은 지연시간<br>- 헤더 오버헤드 최소화</td></tr><tr><td>동작 방식</td><td>- 패킷 단위 전송<br>- 헤더 정보 처리<br>- 스트리밍 최적화<br>- 버퍼 관리</td><td>- 주기적 리포트 전송<br>- 피드백 제공<br>- 통계 수집<br>- 성능 모니터링</td><td>- 요청/응답 방식<br>- 세션 추적<br>- 상태 관리<br>- 명령어 처리</td><td>- 요청/응답 방식<br>- 프록시 서버 활용<br>- 등록 관리<br>- 다이얼로그 관리</td><td>- 게이트키퍼 중심<br>- 엔드포인트 등록<br>- 대역폭 제어<br>- 서비스 품질 관리</td><td>- ICE/STUN/TURN 활용<br>- 미디어 협상<br>- 시그널링 서버 활용<br>- 보안 연결 수립</td><td>- HTTP 핸드셰이크로 시작<br>- 웹소켓 프로토콜로 업그레이드<br>- 양방향 채널 수립<br>- 프레임 기반 메시지 교환</td></tr><tr><td>장점</td><td>- 실시간 전송 최적화<br>- 유연한 구조<br>- 다양한 코덱 지원<br>- 효율적 전송</td><td>- 세션 품질 관리<br>- 문제 진단 용이<br>- 확장 가능<br>- 효과적 모니터링</td><td>- 간단한 구현<br>- 방화벽 통과 용이<br>- 표준화된 제어<br>- 확장성</td><td>- 단순한 구조<br>- 높은 확장성<br>- 쉬운 구현<br>- 유연성</td><td>- 완벽한 기능 세트<br>- 높은 안정성<br>QoS 보장<br>- 표준화</td><td>- 쉬운 통합<br>- 강력한 보안<br>- 개방형 표준<br>- 크로스 플랫폼</td><td>- 실시간성 보장<br>- 서버 푸시 가능<br>- 효율적인 리소스 사용<br>HTTP 호환성</td></tr><tr><td>단점</td><td>- QoS 보장 없음<br>- 보안 기능 부족<br>- 대역폭 오버헤드<br>- 복잡한 구현</td><td>- 추가 대역폭 필요<br>- 제한된 제어<br>- 지연 발생<br>- 구현 복잡성</td><td>- 상태 관리 부담<br>TCP 지연<br>- 제한된 기능<br>- 보안 취약성</td><td>- 초기 지연<br>NAT 문제<br>- 복잡한 보안<br>- 오버헤드</td><td>- 높은 복잡도<br>- 무거운 구현<br>- 높은 비용<br>- 유연성 부족</td><td>- 브라우저 제한<br>- 리소스 소모<br>- 구형 브라우저 미지원<br>- 복잡한 디버깅</td><td>- 이전 브라우저 지원 제한<br>- 연결 유지 부담<br>- 프록시/방화벽 제한<br>- 재연결 처리 필요</td></tr><tr><td>일반적 용도</td><td>- 스트리밍 서비스<br>VoIP<br>- 화상 회의<br>- 실시간 방송</td><td>- 스트리밍 품질 관리<br>- 네트워크 모니터링<br>- 성능 최적화<br>- 문제 해결</td><td>- 동영상 스트리밍<br>- 미디어 서버 제어<br>- 온디맨드 서비스<br>- 라이브 방송</td><td>- VoIP 서비스<br>- 화상 통화<br>- 인스턴트 메시징<br>- 화상 회의</td><td>- 기업용 화상 회의<br>- 텔레프레즌스<br>- 통합 커뮤니케이션<br>- 원격 교육</td><td>- 웹 기반 화상 채팅<br>- 파일 공유<br>- 실시간 게임<br>- 원격 지원</td><td>- 실시간 채팅<br>- 실시간 데이터 피드<br>- 온라인 게임<br>- 실시간 모니터링</td></tr></tbody></table><h4 id=radius--tacacs>RADIUS / TACACS+<a hidden class=anchor aria-hidden=true href=#radius--tacacs>#</a></h4><p>두 프로토콜 모두 네트워크 접근 제어와 보안 강화에 중요한 역할을 한다.</p><table><thead><tr><th>구분</th><th>RADIUS (Remote Authentication Dial-In User Service)</th><th>TACACS+ (Terminal Access Controller Access Control System Plus)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>기본 포트</td><td>UDP 1812(인증), 1813(과금)</td><td>TCP 49</td></tr><tr><td>전송 프로토콜</td><td>UDP</td><td>TCP</td></tr><tr><td>프로토콜 역할</td><td>네트워크 접근 인증, 권한 부여, 과금 관리</td><td>네트워크 장비 접근 제어, 인증, 권한 부여, 감사</td></tr><tr><td>주요 기능</td><td>- 사용자 인증<br>- 접근 권한 부여<br>- 서비스 과금<br>- 네트워크 정책 적용</td><td>- 상세한 명령어 제어<br>- 세분화된 권한 관리<br>- 감사 로깅<br>- 중앙집중식 관리</td></tr><tr><td>동작 방식</td><td>1. 클라이언트 접근 요청<br>2. RADIUS 서버 인증<br>3. 권한 부여<br>4. 과금 정보 수집</td><td>1. 사용자 로그인<br>2. 명령어 권한 검증<br>3. 상세 로깅<br>4. 세션 관리</td></tr><tr><td>특성</td><td>- 패킷 헤더만 암호화<br>- 통합된 인증/권한부여<br>- 확장 가능한 속성<br>- 간단한 구현</td><td>- 전체 패킷 암호화<br>- 분리된 AAA 기능<br>- 상세한 명령어 제어<br>- 강력한 보안</td></tr><tr><td>보안 특성</td><td>- 패스워드만 암호화<br>- 기본적인 보안<br>- 제한된 암호화<br>UDP 기반 취약성</td><td>- 전체 세션 암호화<br>- 강력한 보안<br>TCP 기반 신뢰성<br>- 상세한 감사</td></tr><tr><td>장점</td><td>- 널리 사용됨<br>- 구현 용이<br>- 다양한 벤더 지원<br>- 과금 기능 제공</td><td>- 강력한 보안<br>- 상세한 제어<br>- 명확한 감사<br>- 확장성</td></tr><tr><td>단점</td><td>- 제한된 보안<br>UDP 신뢰성 문제<br>- 기본적 명령어 제어<br>- 제한된 감사</td><td>- 높은 리소스 사용<br>- 복잡한 구성<br>- 단일 벤더 의존<br>- 높은 비용</td></tr><tr><td>AAA 기능 구현</td><td>- 통합된 인증/권한부여<br>- 단순한 과금<br>- 기본적인 감사<br>- 제한된 로깅</td><td>- 분리된 AAA 처리<br>- 상세한 권한 제어<br>comprehensive 감사<br>- 풍부한 로깅</td></tr><tr><td>확장성</td><td>- 속성-값 쌍 확장<br>- 벤더 특화 속성<br>- 유연한 정책 설정<br>- 다중 서버 지원</td><td>- 상세한 명령어 제어<br>- 계층적 권한 관리<br>- 다양한 인증 방식<br>- 그룹 기반 정책</td></tr><tr><td>일반적 용도</td><td>- ISP 서비스<br>- 무선 네트워크<br>VPN 접근<br>- 원격 접속</td><td>- 네트워크 장비 관리<br>- 기업 인프라<br>- 보안 중요 환경<br>- 상세 접근 제어</td></tr></tbody></table><p>이 두 프로토콜의 주요 차이점과 용도는 다음과 같다:</p><ol><li><p>RADIUS는:</p><ul><li>대중적이고 광범위한 사용</li><li>ISP 환경에 적합</li><li>과금 기능 중심</li><li>다양한 벤더 지원</li></ul></li><li><p>TACACS+는:</p><ul><li>상세한 명령어 제어</li><li>기업 네트워크 관리에 적합</li><li>강력한 보안 기능</li><li>Cisco 환경에 최적화</li></ul></li></ol><p>선택 시 고려사항:</p><ul><li>보안 요구사항</li><li>네트워크 규모</li><li>관리 복잡도</li><li>비용 효율성</li></ul><p>이러한 특성을 고려하여 환경에 맞는 프로토콜을 선택하는 것이 중요하다.</p><h4 id=pppoe--l2tp>PPPoE / L2TP<a hidden class=anchor aria-hidden=true href=#pppoe--l2tp>#</a></h4><p>PPPoE는 이더넷 상에서 PPP 연결을 제공하여 효율적인 사용자 접근 제어와 과금을 가능하게 한다.<br>L2TP는 VPN 구현에 사용되며, 다양한 L2 데이터 유형을 IP 네트워크를 통해 전송할 수 있게 해준다.<br>두 프로토콜 모두 네트워크 액세스에 중요한 역할을 하며, 각각의 특성에 따라 다양한 네트워크 환경에서 사용된다.</p><table><thead><tr><th>구분</th><th>PPPoE (Point-to-Point Protocol over Ethernet)</th><th>L2TP (Layer 2 Tunneling Protocol)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>데이터링크 계층 (2계층)</td><td>데이터링크 계층 (2계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>네트워크 접근 계층</td><td>네트워크 접근 계층</td></tr><tr><td>프로토콜 역할</td><td>이더넷 상에서 PPP 프레임 전송 및 세션 관리</td><td>가상 사설망(VPN) 구현을 위한 터널링 제공</td></tr><tr><td>주요 기능</td><td>- PPP 세션 설정/해제<br>- 인증 및 암호화<br>- 대역폭 관리<br>- 서비스 과금 지원</td><td>- 터널 생성/관리<br>- 데이터 캡슐화<br>- 세션 관리<br>- 멀티프로토콜 지원</td></tr><tr><td>동작 단계</td><td>1. 발견 단계<br>2. 세션 설정<br>3. PPP 세션 시작<br>4. 데이터 전송<br>5. 세션 종료</td><td>1. 터널 설정<br>2. 세션 설정<br>3. 데이터 전송<br>4. 터널 유지관리<br>5. 세션 종료</td></tr><tr><td>특성</td><td>- 연결 지향적<br>- 세션 기반<br>- 이더넷 프레임 사용<br>- 점대점 연결</td><td>- 터널링 프로토콜<br>- 제어/데이터 분리<br>UDP 기반<br>- 다중 세션 지원</td></tr><tr><td>보안 특성</td><td>- PAP/CHAP 인증<br>- 기본적인 암호화<br>- 세션 격리<br>- 접근 제어</td><td>- 자체 보안 없음<br>IPSec 결합 필요<br>- 터널 인증<br>- 데이터 무결성</td></tr><tr><td>헤더 구조</td><td>- PPPoE 헤더<br>PPP 헤더<br>- 이더넷 프레임<br>- 페이로드</td><td>- L2TP 헤더<br>UDP 헤더<br>IP 헤더<br>- 페이로드</td></tr><tr><td>장점</td><td>- 간단한 구현<br>- 널리 사용됨<br>- 안정적인 연결<br>- 과금 용이</td><td>- 유연한 터널링<br>- 프로토콜 독립적<br>- 확장성<br>NAT 통과 가능</td></tr><tr><td>단점</td><td>- 추가 오버헤드<br>MTU 크기 제한<br>- 성능 저하<br>- 확장성 제한</td><td>- 복잡한 설정<br>- 보안 부족<br>- 오버헤드<br>- 추가 보안 필요</td></tr><tr><td>일반적 용도</td><td>- 광대역 인터넷 접속<br>ADSL 서비스<br>- 가정용 인터넷<br>- 소규모 사무실</td><td>- 기업 VPN<br>- 원격 접속<br>ISP 서비스<br>- 사이트 간 연결</td></tr><tr><td>QoS 지원</td><td>- 기본적인 QoS<br>- 대역폭 제어<br>- 우선순위 지원<br>- 세션별 제어</td><td>- QoS 태그 전달<br>- 터널 수준 QoS<br>- 세션별 QoS<br>DSCP 지원</td></tr><tr><td>구현 복잡도</td><td>- 비교적 단순<br>- 표준화된 구현<br>- 쉬운 트러블슈팅<br>- 적은 설정 필요</td><td>- 상대적으로 복잡<br>- 다양한 설정 필요<br>- 전문성 요구<br>- 세밀한 설정 가능</td></tr></tbody></table><p>이 두 프로토콜의 주요 활용 시나리오는 다음과 같다:</p><p>PPPoE는:</p><ul><li>가정용 광대역 인터넷 연결</li><li>ADSL/VDSL 서비스</li><li>소규모 사무실 네트워크</li><li>ISP 가입자 관리</li></ul><p>L2TP는:</p><ul><li>기업용 VPN 구축</li><li>원격 사무실 연결</li><li>보안 터널링 요구 환경</li><li>복잡한 네트워크 구성</li></ul><p>이러한 특성을 고려하여 네트워크 환경과 요구사항에 맞는 프로토콜을 선택하는 것이 중요하다.<br>PPPoE는 단순하고 안정적인 연결이 필요한 경우에, L2TP는 더 복잡하고 유연한 터널링이 필요한 경우에 적합하다.</p><h4 id=ldap--saml--kerberos--openid-connect--scim>LDAP / SAML / Kerberos / OpenID Connect / SCIM<a hidden class=anchor aria-hidden=true href=#ldap--saml--kerberos--openid-connect--scim>#</a></h4><p>이 프로토콜들은 모두 사용자 인증, 권한 부여, 또는 ID 관리와 관련된 기능을 제공하며, 주로 응용 계층에서 동작한다.<br>각 프로토콜은 특정 사용 사례와 환경에 맞게 설계되어 있어, 조직의 요구사항에 따라 적절한 프로토콜을 선택하여 사용할 수 있다.</p><table><thead><tr><th>구분</th><th>LDAP (Lightweight Directory Access Protocol)</th><th>SAML (Security Assertion Markup Language)</th><th>Kerberos</th><th>OpenID Connect</th><th>SCIM (System for Cross-domain Identity Management)</th></tr></thead><tbody><tr><td>OSI 7계층 위치</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td><td>응용 계층 (7계층)</td></tr><tr><td>TCP/IP 4계층 위치</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td><td>응용 계층</td></tr><tr><td>기본 포트</td><td>TCP 389 (LDAPS: 636)</td><td>HTTP 기반</td><td>TCP 88</td><td>HTTPS 기반</td><td>HTTPS 기반</td></tr><tr><td>주요 역할</td><td>디렉터리 서비스 접근 및 관리</td><td>기업 간 SSO 인증</td><td>네트워크 인증</td><td>OAuth 2.0 기반 인증 및 인가</td><td>사용자 신원 정보 관리</td></tr><tr><td>핵심 기능</td><td>- 디렉터리 검색<br>- 사용자/그룹 관리<br>- 속성 조회/수정<br>- 조직 구조 관리</td><td>- SSO 제공<br>- 인증 정보 교환<br>- 권한 위임<br>- 페더레이션</td><td>- 티켓 기반 인증<br>- 상호 인증<br>- 세션 관리<br>- 키 분배</td><td>- 인증<br>- 사용자 정보 제공<br>- 토큰 관리<br>OAuth 2.0 확장</td><td>- 신원 정보 동기화<br>- 프로비저닝<br>- 사용자 관리<br>API 표준화</td></tr><tr><td>동작 방식</td><td>- 클라이언트-서버 모델<br>- 바인딩 및 검색<br>- 트리 구조 탐색<br>- 필터링</td><td>- XML 기반 통신<br>IdP-SP 모델<br>- 어설션 교환<br>- 메타데이터 공유</td><td>- 티켓 발급/검증<br>TGT/ST 사용<br>- 대칭키 암호화<br>- 시간 동기화</td><td>- REST/JSON 기반<br>OAuth 2.0 흐름<br>JWT 사용<br>- 스코프 기반</td><td>- REST API 기반<br>JSON 스키마<br>CRUD 작업<br>- 벌크 작업</td></tr><tr><td>특성</td><td>- 계층적 구조<br>- 확장 가능한 스키마<br>- 읽기 최적화<br>- 표준화된 인터페이스</td><td>- 플랫폼 독립적<br>XML 기반<br>- 높은 보안성<br>- 기업용 표준</td><td>- 강력한 보안<br>- 단일 로그인<br>- 시간 기반<br>- 상호 인증</td><td>- 경량화<br>- 모바일 친화적<br>OAuth 호환<br>- 사용 편의성</td><td>- 표준화된 API<br>- 확장 가능<br>- 플랫폼 독립적<br>RESTful</td></tr><tr><td>장점</td><td>- 널리 사용됨<br>- 효율적인 검색<br>- 표준화<br>- 확장성</td><td>- 강력한 보안<br>- 기업 환경 적합<br>- 풍부한 생태계<br>- 상호운용성</td><td>- 강력한 보안<br>- 중앙화된 인증<br>- 검증된 방식<br>- 효율적 관리</td><td>- 구현 용이<br>- 모던 웹 적합<br>- 유연성<br>JSON 기반</td><td>- 표준화된 관리<br>- 자동화 용이<br>- 확장성<br>- 통합 용이</td></tr><tr><td>단점</td><td>- 복잡한 설정<br>- 보안 취약성<br>- 쓰기 성능<br>- 변경 관리 어려움</td><td>- 구현 복잡성<br>- 높은 오버헤드<br>XML 복잡성<br>- 설정 어려움</td><td>- 복잡한 구현<br>- 시간 동기화 필요<br>- 확장 어려움<br>- 초기 설정 복잡</td><td>- 보안 고려 필요<br>- 표준 준수 중요<br>- 토큰 관리<br>- 범위 제한</td><td>- 구현 복잡성<br>- 표준 해석 차이<br>- 보안 고려 필요<br>- 초기 도입 어려움</td></tr><tr><td>일반적 용도</td><td>- 기업 디렉터리<br>- 사용자 관리<br>- 인증/인가<br>- 조직 정보 관리</td><td>- 기업 SSO<br>- 클라우드 서비스<br>B2B 통합<br>- 페더레이션</td><td>- 윈도우 도메인<br>- 기업 네트워크<br>- 내부 시스템<br>- 보안 환경</td><td>- 소비자 서비스<br>- 모바일 앱<br>- 웹 서비스<br>API 보안</td><td>- ID 관리 자동화<br>- 클라우드 통합<br>- 사용자 동기화<br>HR 시스템</td></tr></tbody></table><p>이러한 프로토콜들은 각각의 용도에 따라 다음과 같이 활용된다:</p><ol><li>LDAP: 기업 내부의 디렉터리 서비스와 사용자 관리에 주로 사용된다.</li><li>SAML: 기업 환경에서의 SSO와 페더레이션에 적합하다.</li><li>Kerberos: 네트워크 수준의 강력한 인증이 필요한 환경에서 사용된다.</li><li>OpenID Connect: 현대적인 웹/모바일 서비스의 인증에 적합하다.</li><li>SCIM: 여러 시스템 간의 신원 정보 동기화에 사용된다.</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SMB</h2></header><div class=entry-content><p>SMB 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-30 02:10:00 +0000 UTC'>December 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SMB" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/application-layer-protocols/file-sharing/smb/smb/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CoAP</h2></header><div class=entry-content><p>CoAP 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-15 03:26:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CoAP" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/specialized-protocols/internet-of-things/coap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DCCP</h2></header><div class=entry-content><p>DCCP 참고 및 출처</p></div><footer class=entry-footer><span title='2025-03-13 13:59:00 +0000 UTC'>March 13, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DCCP" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/data-transport-protocols/connectionless/dccp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Service</h2></header><div class=entry-content><p>Web Service 참고 및 출처</p></div><footer class=entry-footer><span title='2025-03-13 13:55:00 +0000 UTC'>March 13, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Service" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/application-layer-protocols/web-service/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>QUIC</h2></header><div class=entry-content><p>QUIC 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-30 02:16:00 +0000 UTC'>December 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to QUIC" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/data-transport-protocols/connection-oriented/quic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>File Transfer Protocols</h2></header><div class=entry-content><p>File Transfer Protocols FTP / SFTP / SCP / TFTP 이 프로토콜들은 모두 파일 전송을 위한 것이지만, 각각의 특성과 보안 수준, 기능의 복잡성에서 차이가 있다.
FTP는 가장 오래되고 널리 사용되는 프로토콜이지만 보안에 취약하다.
SFTP와 SCP는 SSH를 기반으로 하여 보안성이 높다.
TFTP는 가장 단순한 구조로, 제한된 환경에서 사용된다.
구분 FTP (File Transfer Protocol) SFTP (SSH File Transfer Protocol) SCP (Secure Copy Protocol) TFTP (Trivial File Transfer Protocol) OSI 7계층 위치 응용 계층 (7계층) 응용 계층 (7계층) 응용 계층 (7계층) 응용 계층 (7계층) TCP/IP 4계층 위치 응용 계층 응용 계층 응용 계층 응용 계층 기본 포트 20(데이터), 21(제어) 22 22 69 전송 프로토콜 TCP TCP TCP UDP 보안 특성 암호화 없음 (기본) SSH 기반 암호화 SSH 기반 암호화 암호화 없음 주요 역할 일반 파일 전송 및 관리 보안 파일 전송 및 관리 보안 파일 복사 단순 파일 전송 연결 특성 - 제어 연결과 데이터 연결 분리
- 능동/수동 모드 지원
- 지속적 연결 - 단일 암호화 연결
SSH 터널링 사용
- 지속적 연결 - 단일 암호화 연결
- 일회성 연결
- 비대화형 - 단순 연결
- 비연결형
- 최소한의 기능 주요 기능 - 파일 업로드/다운로드
- 디렉토리 탐색
- 파일 관리
- 권한 관리 - 파일 업로드/다운로드
- 디렉토리 관리
- 파일 권한 제어
- 원격 파일 조작 - 파일 복사
- 디렉토리 복사
- 재귀적 복사
- 보존 모드 지원 - 파일 읽기/쓰기
- 단순 전송
- 최소 메모리 사용
- 간단한 구현 인증 방식 사용자명/비밀번호 - SSH 키 기반
- 비밀번호
- 인증서 - SSH 키 기반
- 비밀번호 인증 없음 (기본) 특징 - 다양한 명령어 지원
- 세션 유지
ASCII/이진 모드
- 재시작 기능 - 풍부한 파일 작업
- 플랫폼 독립적
- 강력한 보안
- 세션 관리 - 간단한 사용법
- 빠른 전송
- 명령행 기반
- 최소한의 기능 - 단순한 구조
- 최소한의 메모리
- 쉬운 구현
- 빠른 시작 장점 - 널리 지원됨
- 다양한 기능
- 유연한 사용
- 재시작 가능 - 강력한 보안
- 다양한 기능
- 호환성
- 신뢰성 - 간단한 사용
- 높은 보안
- 빠른 속도
- 적은 오버헤드 - 단순한 구현
- 적은 메모리
- 빠른 전송
ROM 부팅 가능 단점 - 보안 취약
- 복잡한 설정
- 방화벽 문제
- 오버헤드 큼 - 구현 복잡
- 높은 오버헤드
- 느린 속도
- 리소스 많이 사용 - 제한된 기능
- 진행률 표시 없음
- 세션 관리 없음
- 유연성 부족 - 보안 없음
- 큰 파일 부적합
- 신뢰성 낮음
- 기능 제한적 일반적 사용 사례 - 웹 호스팅
- 파일 공유
- 백업
- 일반 파일 전송 - 보안 파일 전송
- 원격 파일 관리
- 자동화된 전송
- 기업 환경 - 서버 간 파일 복사
- 백업
- 스크립트 자동화
- 단순 전송 - 네트워크 부팅
- 펌웨어 업데이트
- 설정 파일 전송
- 임베디드 시스템 이들 프로토콜은 다음과 같은 상황에서 선택적으로 사용된다:
...</p></div><footer class=entry-footer><span title='2024-12-30 02:09:00 +0000 UTC'>December 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to File Transfer Protocols" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/application-layer-protocols/file-transfer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Remote Access Protocols</h2></header><div class=entry-content><p>Remote Access Protocols Telnet / SSH 네트워크를 통해 원격 시스템에 접속하여 명령어를 실행할 수 있게 해주는 프로토콜.
구분 TELNET (TELecommunication NETwork) SSH (Secure Shell) OSI 7계층 위치 응용 계층 (7계층) 응용 계층 (7계층) TCP/IP 4계층 위치 응용 계층 응용 계층 기본 포트 23 22 전송 프로토콜 TCP TCP 보안 특성 - 암호화 없음
- 평문 전송
- 기본적인 인증만 제공
- 보안 취약 - 강력한 암호화
- 다중 인증 방식
- 데이터 무결성 검증
- 키 기반 인증 주요 기능 - 원격 터미널 접속
- 텍스트 기반 통신
- 간단한 명령어 실행
- 기본적인 세션 관리 - 보안 원격 접속
- 파일 전송(SFTP/SCP)
- 포트 포워딩
X11 포워딩 인증 방식 - 사용자명/비밀번호
- 평문 전송
- 단순 인증 - 공개키/개인키
- 비밀번호
- 다중 인증
- 인증서 기반 데이터 전송 특성 - 평문 전송
- 압축 없음
- 무결성 검사 없음
- 중간자 공격 취약 - 암호화 전송
- 압축 지원
- 무결성 검사
- 중간자 공격 방지 세션 관리 - 단순한 세션 관리
- 연결 유지 기능 제한
- 재접속 시 새로운 세션 - 고급 세션 관리
- 연결 유지 기능
- 세션 재사용 가능
- 다중 채널 지원 주요 특징 - 단순한 구조
- 적은 리소스 사용
- 빠른 연결
- 호환성 높음 - 강력한 보안
- 다양한 기능
- 확장성
- 현대적 설계 장점 - 간단한 구현
- 낮은 리소스 요구
- 빠른 응답 속도
- 널리 지원됨 - 높은 보안성
- 다양한 기능
- 신뢰성
- 표준화된 프로토콜 단점 - 보안 취약
- 기능 제한
- 현대 환경 부적합
- 데이터 노출 위험 - 높은 리소스 사용
- 구현 복잡성
- 초기 설정 필요
- 상대적으로 느림 동작 방식 1. TCP 연결 수립
2. 사용자 인증
3. 터미널 에뮬레이션
4. 명령어 전송/수신 1. TCP 연결 수립
2. 버전 협상
3. 키 교환
4. 인증
5. 채널 설정
6. 암호화된 통신 일반적 사용 사례 - 레거시 시스템 관리
- 간단한 원격 접속
- 제한된 환경
- 테스트 목적 - 서버 관리
- 보안 파일 전송
- 원격 명령 실행
- 터널링 현재 상태 사용 권장되지 않음 현재 표준으로 사용 중 SSH의 주요 보안 기능:
...</p></div><footer class=entry-footer><span title='2024-12-30 02:09:00 +0000 UTC'>December 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Remote Access Protocols" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/remote-access-protocols/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Routing Protocols</h2></header><div class=entry-content><p>Routing Protocols RIP / RIPv2 / RIPng / OSPF / EIGRP / IS-IS / BGP 각 라우팅 프로토콜의 주요 특성을 요약한 것이다.
각 프로토콜은 네트워크의 규모와 요구사항에 따라 선택되어 사용된다.
예를 들어, RIP는 소규모 네트워크에 적합하고, OSPF와 IS-IS는 대규모 네트워크에 적합하며, BGP는 인터넷 백본과 같은 초대규모 네트워크에 사용된다.
라우팅 프로토콜들의 특징을 체계적으로 비교 분석하여 표로 정리해드리겠습니다. 각 프로토콜의 특성과 동작 방식을 상세하게 설명하여 이해를 돕도록 하겠습니다.
구분 RIP (Routing Information Protocol) / RIPv2 (Routing Information Protocol version 2) RIPng (Routing Information Protocol next generation) OSPF (Open Shortest Path First) EIGRP (Enhanced Interior Gateway Routing Protocol) IS-IS (Intermediate System to Intermediate System) BGP (Border Gateway Protocol) OSI 7계층 위치 네트워크 계층 (3계층) 네트워크 계층 (3계층) 네트워크 계층 (3계층) 네트워크 계층 (3계층) 네트워크 계층 (3계층) 네트워크 계층 (3계층) TCP/IP 4계층 위치 인터넷 계층 인터넷 계층 인터넷 계층 인터넷 계층 인터넷 계층 인터넷 계층 프로토콜 유형 내부 게이트웨이 프로토콜(IGP) 내부 게이트웨이 프로토콜(IGP) 내부 게이트웨이 프로토콜(IGP) 내부 게이트웨이 프로토콜(IGP) 내부 게이트웨이 프로토콜(IGP) 외부 게이트웨이 프로토콜(EGP) 라우팅 알고리즘 거리 벡터 거리 벡터 링크 스테이트 하이브리드(DUAL) 링크 스테이트 경로 벡터 메트릭 계산 방식 홉 카운트 홉 카운트 비용(대역폭) 복합 메트릭(대역폭, 지연, 부하, 신뢰성) 비용 다양한 속성(AS 경로, 로컬 선호도 등) 최대 홉 카운트 15 15 제한 없음 제한 없음 제한 없음 제한 없음 수렴 속도 느림 느림 빠름 매우 빠름 빠름 느림 업데이트 방식 주기적(30초) 주기적(30초) 변경 시 변경 시 변경 시 변경 시 네트워크 규모 소규모 소규모 대규모 중대규모 대규모 초대규모(인터넷) 특징 - 구현 간단
- 설정 쉬움
- 제한된 확장성
- 카운팅 투 인피니티 문제 - IPv6 지원
RIPv2 기반
- 향상된 보안
- 동일한 제한사항 - 영역 기반 계층구조
- 빠른 수렴
- 대규모 확장성
- 정확한 토폴로지 정보 - Cisco 전용
- 빠른 수렴
- 효율적인 대역폭 사용
- 유연한 경로 선택 - 계층적 구조
- 벤더 중립적
- 대규모 확장성
- 빠른 수렴 - 정책 기반 라우팅
- 대규모 확장성
- 풍부한 경로 속성
AS 간 라우팅 장점 - 이해하기 쉬움
- 적은 리소스 사용
- 간단한 구현
- 모든 벤더 지원 - IPv6 네이티브 지원
- 보안 강화
- 간단한 구현
- 기존 RIP 호환 - 효율적인 대역폭 사용
- 빠른 수렴
- 계층적 설계
- 뛰어난 확장성 - 빠른 수렴
- 효율적인 리소스 사용
- 유연한 토폴로지
- 부분 업데이트 - 높은 확장성
- 벤더 중립성
- 효율적인 라우팅
IPv4/IPv6 통합 지원 - 강력한 정책 제어
- 뛰어난 확장성
- 풍부한 경로 정보
- 정교한 경로 선택 단점 - 느린 수렴
- 제한된 확장성
- 비효율적 라우팅
- 대역폭 낭비 - 느린 수렴
- 제한된 확장성
IPv4 미지원
- 홉 제한 - 복잡한 설정
- 높은 리소스 요구
- 복잡한 트러블슈팅
- 많은 CPU/메모리 사용 - Cisco 전용
- 복잡한 메트릭
- 라이센스 비용
- 트러블슈팅 어려움 - 복잡한 설정
- 높은 학습 곡선
- 복잡한 트러블슈팅
- 전문성 요구 - 복잡한 설정
- 느린 수렴
- 높은 리소스 요구
- 전문성 요구 적용 환경 소규모 네트워크 IPv6 소규모 네트워크 중대형 엔터프라이즈 네트워크 Cisco 기반 네트워크 대형 서비스 제공자 네트워크 인터넷 서비스 제공자 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-30 02:09:00 +0000 UTC'>December 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;497 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing Protocols" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/network-control-and-routing-protocols/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Messaging Protocols</h2></header><div class=entry-content><p>Messaging Protocol 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-15 03:28:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Messaging Protocols" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/application-layer-protocols/messaging-protocols/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Email Protocols</h2></header><div class=entry-content><p>Email Protocols SMTP / POP3 / IMAP 이 세 프로토콜은 모두 이메일 통신에 중요한 역할을 하며, 각각의 특성에 따라 이메일 전송, 수신, 관리 기능을 제공한다.
SMTP는 이메일 전송을, POP3와 IMAP은 이메일 수신을 담당하지만, IMAP이 더 현대적이고 유연한 기능을 제공한다.
구분 SMTP (Simple Mail Transfer Protocol) POP3 (Post Office Protocol 3) IMAP (Internet Message Access Protocol) OSI 7계층 위치 응용 계층 (7계층) 응용 계층 (7계층) 응용 계층 (7계층) TCP/IP 4계층 위치 응용 계층 응용 계층 응용 계층 기본 포트 25 (일반), 587 (TLS/SSL) 110 (일반), 995 (TLS/SSL) 143 (일반), 993 (TLS/SSL) 주요 역할 이메일 발송 및 전달 이메일 다운로드 및 삭제 서버상의 이메일 관리 및 접근 통신 방향 클라이언트 → 서버
서버 → 서버 클라이언트 ← 서버 양방향 (클라이언트 ↔ 서버) 기본 동작 방식 1. 연결 수립
2. 송신자 확인
3. 수신자 확인
4. 메시지 전송
5. 연결 종료 1. 서버 접속
2. 인증
3. 메일 다운로드
4. 서버에서 메일 삭제(옵션)
5. 연결 종료 1. 서버 접속
2. 인증
3. 메일함 선택
4. 메일 조작(읽기/이동/삭제 등)
5. 상태 동기화 주요 특징 - 텍스트 기반 프로토콜
- 메일 릴레이 가능
- 단순한 명령어 체계
- 확장 가능한 구조 - 단순한 구조
- 오프라인 접근 가능
- 서버 저장공간 최소화
- 한 기기에서만 접근 - 서버 중심 관리
- 다중 기기 접근
- 폴더 구조 지원
- 실시간 동기화 메일 저장 위치 전달 중계 역할만 수행 로컬 장치 메일 서버 다중 기기 지원 해당 없음 제한적 (한 기기에서만 관리) 완벽 지원 (모든 기기 동기화) 서버 자원 사용 낮음 낮음 높음 대역폭 사용 메일 전송 시에만 사용 전체 메일 다운로드로 많이 사용 필요한 부분만 동기화하여 효율적 장점 - 단순한 구현
- 안정적인 전달
- 낮은 리소스 사용
- 높은 호환성 - 단순한 구조
- 오프라인 사용 가능
- 서버 부하 낮음
- 구현 용이 - 유연한 메일 관리
- 다중 기기 지원
- 서버 백업 용이
- 부분 동기화 가능 단점 - 기본 보안 기능 없음
- 인증 제한적
- 스팸 메일 취약
- 첨부파일 크기 제한 - 한 기기에서만 관리
- 메일 동기화 어려움
- 폴더 구조 제한
- 유연성 부족 - 복잡한 구현
- 높은 서버 부하
- 느린 초기 접속
- 많은 서버 자원 필요 보안 기능 기본적으로 없음 (SMTPS로 보안 추가 가능) 기본적으로 없음 (POP3S로 보안 추가 가능) 기본적으로 없음 (IMAPS로 보안 추가 가능) 주요 명령어 - HELO/EHLO
MAIL FROM
RCPT TO
DATA
QUIT - USER
PASS
LIST
RETR
DELE - SELECT
FETCH
STORE
SEARCH
EXPUNGE 이러한 이메일 프로토콜들은 다음과 같이 함께 동작한다:
...</p></div><footer class=entry-footer><span title='2024-12-14 12:55:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;466 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Email Protocols" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/application-layer-protocols/email/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>