<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>프래그먼테이션 (Fragmentation) | hyunyoun's Blog</title>
<meta name=keywords content="Networking-Knowledge,Fundamentals,OSI-7Layers,Network-Layer,Fragmentation"><meta name=description content="Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/fragmentation/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/fragmentation/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/fragmentation/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="프래그먼테이션 (Fragmentation)"><meta property="og:description" content="Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-16T02:40:00+00:00"><meta property="article:modified_time" content="2024-10-16T02:40:00+00:00"><meta property="article:tag" content="Networking-Knowledge"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="OSI-7Layers"><meta property="article:tag" content="Network-Layer"><meta property="article:tag" content="Fragmentation"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="프래그먼테이션 (Fragmentation)"><meta name=twitter:description content="Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Network","item":"https://buenhyden.github.io/posts/networking-knowledge/"},{"@type":"ListItem","position":3,"name":"Fundamentals of Network","item":"https://buenhyden.github.io/posts/networking-knowledge/fundamentals/"},{"@type":"ListItem","position":4,"name":"OSI 7Layers","item":"https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/"},{"@type":"ListItem","position":5,"name":"OSI 7 Layers - 3. Network Layer","item":"https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/"},{"@type":"ListItem","position":6,"name":"프래그먼테이션 (Fragmentation)","item":"https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/fragmentation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"프래그먼테이션 (Fragmentation)","name":"프래그먼테이션 (Fragmentation)","description":"Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.","keywords":["Networking-Knowledge","Fundamentals","OSI-7Layers","Network-Layer","Fragmentation"],"articleBody":"프래그먼테이션 (Fragmentation) Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.\n이는 다음과 같은 목적을 가진다:\n다양한 MTU를 가진 네트워크 간의 통신 가능 네트워크 성능 향상 대역폭 활용도 개선 프래그먼테이션이 필요한 이유 네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.\n이를 MTU(Maximum Transmission Unit)라고 한다.\n예를 들어:\n이더넷의 MTU: 1500 바이트 PPP의 MTU: 576 바이트 Wi-Fi의 MTU: 2304 바이트\n만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다. Fragmentation의 작동 방식 프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.\n각 프래그먼트는:\n원본 패킷의 헤더 정보를 포함 고유한 프래그먼트 오프셋 값을 가짐 More Fragments(MF) 플래그로 추가 프래그먼트 여부를 표시 프래그먼트 전송 각 프래그먼트는 독립적으로 목적지로 전송된다.\n이때:\n각각 다른 경로로 전송될 수 있음 순서가 뒤바뀔 수 있음 일부가 손실될 수 있음 재조립 과정 목적지에서는 다음과 같은 방식으로 프래그먼트들을 재조립한다:\n프래그먼트 오프셋을 이용해 올바른 순서 확인 MF 플래그로 모든 프래그먼트 수신 여부 확인 타임아웃을 통해 손실된 프래그먼트 처리 구체적인 예시를 통한 이해 4000 바이트 크기의 데이터 패킷이 1500 바이트 MTU 네트워크를 통과해야 하는 경우:\n1번 프래그먼트: 크기: 1500 바이트 오프셋: 0 MF 플래그: 1 (더 있음) 2번 프래그먼트: 크기: 1500 바이트 오프셋: 1480 MF 플래그: 1 (더 있음) 3번 프래그먼트: 크기: 1000 바이트 오프셋: 2960 MF 플래그: 0 (마지막) Fragmentation의 주요 구성 요소 Identification Field (16 비트): 같은 원본 패킷의 조각들을 식별한다. Fragment Offset Field (13 비트): 조각의 순서를 나타낸다. More Fragments Field (MF): 더 많은 조각이 있는지 표시한다. Don’t Fragment Field (DF): 패킷의 분할을 금지할 수 있다. Fragmentation의 장단점 장점:\n다양한 네트워크 환경에서의 통신 가능 네트워크 리소스의 효율적 사용 단점:\n재조립 과정에서의 복잡성 증가 패킷 손실 시 전체 데이터의 재전송 필요 보안 문제 발생 가능성 (일부 방화벽에서 문제 발생) IPv6에서의 프래그먼테이션 IPv6에서는 중간 라우터에서의 프래그먼테이션을 금지하고, 대신:\nPath MTU Discovery를 통해 적절한 패킷 크기 결정 출발지에서만 프래그먼테이션 수행 더 효율적인 전송 보장 Fragmentation 회피 기술 Path MTU Discovery: 경로상의 최소 MTU를 찾아 패킷 크기를 조절한다. TCP MSS (Maximum Segment Size) 조정: TCP 세그먼트 크기를 MTU에 맞게 조절한다. 실제 응용 사례 파일 전송을 예로 들어보면:\n10MB 크기의 파일을 전송할 경우:\n응용 프로그램 계층: 파일을 세그먼트로 분할 IP 계층: 필요한 경우 추가 프래그먼테이션 수행 네트워크: MTU에 맞는 크기로 전송 수신측: 순차적 재조립 후 파일 복원 참고 및 출처 ","wordCount":"372","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-16T02:40:00Z","dateModified":"2024-10-16T02:40:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/fragmentation/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-knowledge/>Network</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/>Fundamentals of Network</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/>OSI 7Layers</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/>OSI 7 Layers - 3. Network Layer</a></div><h1 class="post-title entry-hint-parent">프래그먼테이션 (Fragmentation)</h1><div class=post-description>Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.</div><div class=post-meta><span title='2024-10-16 02:40:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Networking%20Knowledge/Fundamentals/OSI%207Layers/Network%20Layer/Fragmentation.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#프래그먼테이션-fragmentation>프래그먼테이션 (Fragmentation)</a><ul><li><a href=#프래그먼테이션이-필요한-이유>프래그먼테이션이 필요한 이유</a></li><li><a href=#fragmentation의-작동-방식>Fragmentation의 작동 방식</a></li><li><a href=#fragmentation의-주요-구성-요소>Fragmentation의 주요 구성 요소</a></li><li><a href=#fragmentation의-장단점>Fragmentation의 장단점</a></li><li><a href=#ipv6에서의-프래그먼테이션>IPv6에서의 프래그먼테이션</a></li><li><a href=#fragmentation-회피-기술>Fragmentation 회피 기술</a></li><li><a href=#실제-응용-사례>실제 응용 사례</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=프래그먼테이션-fragmentation>프래그먼테이션 (Fragmentation)<a hidden class=anchor aria-hidden=true href=#프래그먼테이션-fragmentation>#</a></h2><p>Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.</p><p>이는 다음과 같은 목적을 가진다:</p><ol><li>다양한 MTU를 가진 네트워크 간의 통신 가능</li><li>네트워크 성능 향상</li><li>대역폭 활용도 개선</li></ol><h3 id=프래그먼테이션이-필요한-이유>프래그먼테이션이 필요한 이유<a hidden class=anchor aria-hidden=true href=#프래그먼테이션이-필요한-이유>#</a></h3><p>네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.<br>이를 MTU(Maximum Transmission Unit)라고 한다.<br>예를 들어:</p><ul><li>이더넷의 MTU: 1500 바이트</li><li>PPP의 MTU: 576 바이트</li><li>Wi-Fi의 MTU: 2304 바이트<br>만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다.</li></ul><h3 id=fragmentation의-작동-방식>Fragmentation의 작동 방식<a hidden class=anchor aria-hidden=true href=#fragmentation의-작동-방식>#</a></h3><ol><li><p>프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.<br>각 프래그먼트는:</p><ul><li>원본 패킷의 헤더 정보를 포함</li><li>고유한 프래그먼트 오프셋 값을 가짐</li><li>More Fragments(MF) 플래그로 추가 프래그먼트 여부를 표시</li></ul></li><li><p>프래그먼트 전송 각 프래그먼트는 독립적으로 목적지로 전송된다.<br>이때:</p><ul><li>각각 다른 경로로 전송될 수 있음</li><li>순서가 뒤바뀔 수 있음</li><li>일부가 손실될 수 있음</li></ul></li><li><p>재조립 과정 목적지에서는 다음과 같은 방식으로 프래그먼트들을 재조립한다:</p><ul><li>프래그먼트 오프셋을 이용해 올바른 순서 확인</li><li>MF 플래그로 모든 프래그먼트 수신 여부 확인</li><li>타임아웃을 통해 손실된 프래그먼트 처리</li></ul></li></ol><h4 id=구체적인-예시를-통한-이해>구체적인 예시를 통한 이해<a hidden class=anchor aria-hidden=true href=#구체적인-예시를-통한-이해>#</a></h4><p>4000 바이트 크기의 데이터 패킷이 1500 바이트 MTU 네트워크를 통과해야 하는 경우:</p><ul><li>1번 프래그먼트:<ul><li>크기: 1500 바이트</li><li>오프셋: 0</li><li>MF 플래그: 1 (더 있음)</li></ul></li><li>2번 프래그먼트:<ul><li>크기: 1500 바이트</li><li>오프셋: 1480</li><li>MF 플래그: 1 (더 있음)</li></ul></li><li>3번 프래그먼트:<ul><li>크기: 1000 바이트</li><li>오프셋: 2960</li><li>MF 플래그: 0 (마지막)</li></ul></li></ul><h3 id=fragmentation의-주요-구성-요소>Fragmentation의 주요 구성 요소<a hidden class=anchor aria-hidden=true href=#fragmentation의-주요-구성-요소>#</a></h3><ol><li>Identification Field (16 비트): 같은 원본 패킷의 조각들을 식별한다.</li><li>Fragment Offset Field (13 비트): 조각의 순서를 나타낸다.</li><li>More Fragments Field (MF): 더 많은 조각이 있는지 표시한다.</li><li>Don&rsquo;t Fragment Field (DF): 패킷의 분할을 금지할 수 있다.</li></ol><h3 id=fragmentation의-장단점>Fragmentation의 장단점<a hidden class=anchor aria-hidden=true href=#fragmentation의-장단점>#</a></h3><p>장점:</p><ul><li>다양한 네트워크 환경에서의 통신 가능</li><li>네트워크 리소스의 효율적 사용</li></ul><p>단점:</p><ul><li>재조립 과정에서의 복잡성 증가</li><li>패킷 손실 시 전체 데이터의 재전송 필요</li><li>보안 문제 발생 가능성 (일부 방화벽에서 문제 발생)</li></ul><h3 id=ipv6에서의-프래그먼테이션>IPv6에서의 프래그먼테이션<a hidden class=anchor aria-hidden=true href=#ipv6에서의-프래그먼테이션>#</a></h3><p>IPv6에서는 중간 라우터에서의 프래그먼테이션을 금지하고, 대신:</p><ul><li>Path MTU Discovery를 통해 적절한 패킷 크기 결정</li><li>출발지에서만 프래그먼테이션 수행</li><li>더 효율적인 전송 보장</li></ul><h3 id=fragmentation-회피-기술>Fragmentation 회피 기술<a hidden class=anchor aria-hidden=true href=#fragmentation-회피-기술>#</a></h3><ol><li>Path MTU Discovery: 경로상의 최소 MTU를 찾아 패킷 크기를 조절한다.</li><li>TCP MSS (Maximum Segment Size) 조정: TCP 세그먼트 크기를 MTU에 맞게 조절한다.</li></ol><h3 id=실제-응용-사례>실제 응용 사례<a hidden class=anchor aria-hidden=true href=#실제-응용-사례>#</a></h3><p>파일 전송을 예로 들어보면:<br>10MB 크기의 파일을 전송할 경우:</p><ol><li>응용 프로그램 계층: 파일을 세그먼트로 분할</li><li>IP 계층: 필요한 경우 추가 프래그먼테이션 수행</li><li>네트워크: MTU에 맞는 크기로 전송</li><li>수신측: 순차적 재조립 후 파일 복원</li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/networking-knowledge/>Networking-Knowledge</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/osi-7layers/>OSI-7Layers</a></li><li><a href=https://buenhyden.github.io/tags/network-layer/>Network-Layer</a></li><li><a href=https://buenhyden.github.io/tags/fragmentation/>Fragmentation</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/osi-7layers/network-layer/network-hop/><span class=title>« Prev</span><br><span>Network Hop</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/complexity-classes/reducibility/><span class=title>Next »</span><br><span>환원 가능성 (Reducibility)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>