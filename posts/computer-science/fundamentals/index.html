<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Computer Science's Fundamentals | hyunyoun's Blog</title>
<meta name=keywords content><meta name=description content="Computer Science's Fundamentals - hyunyoun's Blog"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/fundamentals/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/fundamentals/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/fundamentals/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/fundamentals/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Computer Science's Fundamentals"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Computer Science's Fundamentals"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Computer Science's Fundamentals","item":"https://buenhyden.github.io/posts/computer-science/fundamentals/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>Computer Science and Engineering</a></div><h1>Computer Science's Fundamentals</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Runtime</h2></header><div class=entry-content><p>Runtime 컴퓨터 과학에서 런타임(runtime) 은 프로그램이 실제로 실행되는 기간과 그 실행 환경 전체를 의미한다.
프로그램이 컴파일되어 기계어 코드로 번역된 후, 운영체제에 의해 메모리에 로드되고 CPU가 해당 코드를 실행하는 순간부터 프로그램 실행이 종료될 때까지의 모든 활동을 포괄하는 개념이다.
컴퓨터 과학에서 런타임은 단순히 프로그램이 실행되는 시간만을 의미하지 않는다. 이는 코드 실행을 지원하는 복잡한 환경, 시스템, 메커니즘의 총체를 의미한다. 현대 소프트웨어 개발에서 런타임의 이해는 효율적이고 안정적인 애플리케이션을 구축하는 데 필수적이다.
런타임 환경의 선택과 최적화는 애플리케이션의 성능, 보안, 확장성, 유지보수성에 직접적인 영향을 미친다. 각 런타임은 고유한 장단점과 특성을 가지고 있으며, 특정 사용 사례에 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-05 04:12:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2878 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Runtime" href=https://buenhyden.github.io/posts/computer-science/fundamentals/runtime/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화(Lazy Initialization) 지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법이다.
지연 초기화는 리소스 사용을 최적화하고 애플리케이션의 시작 시간을 개선하는 강력한 도구이지만 무분별한 적용은 오히려 코드를 복잡하게 만들고 성능 문제를 야기할 수 있다.
지연 초기화의 기본 개념 지연 초기화는 객체나 리소스의 초기화를 그것이 실제로 필요할 때까지 미루는 설계 패턴이다.
이는 “필요할 때까지 만들지 말라"는 원칙에 기반한다.
기본 원리 즉시 초기화(Eager Initialization): 객체가 생성될 때 모든 의존성과 리소스를 즉시 초기화 지연 초기화(Lazy Initialization): 객체의 특정 부분이 실제로 사용될 때 해당 부분만 초기화 지연 초기화가 유용한 상황 비용이 많이 드는 연산: 메모리 사용량이 큰 객체, 계산 비용이 높은 값, 데이터베이스 연결 등 사용되지 않을 수 있는 컴포넌트: 애플리케이션의 모든 실행 경로에서 필요하지 않은 리소스 초기화 의존성 문제 해결: 순환 참조 같은 의존성 문제를 해결하기 위한 방법 지연 초기화의 구현 패턴 기본 지연 초기화 패턴 가장 단순한 형태의 지연 초기화 구현.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3465 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/lazy-initialization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비결정성 (Non-determinism)</h2></header><div class=entry-content><p>비결정성 (Non-determinism) 알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성
특징 다중 선택: 각 단계에서 여러 가능한 다음 단계 중 하나를 임의로 선택할 수 있다. 병렬 처리: 여러 가능한 경로를 동시에 탐색할 수 있는 개념적 모델을 제공한다. 결정성과의 차이: 결정성 알고리즘은 각 단계에서 다음 단계가 유일하게 결정되는 반면, 비결정성 알고리즘은 그렇지 않다. 비결정성 알고리즘 비결정성 알고리즘은 다음과 같은 특징을 가진다.
실행 경로의 다양성: 동일한 입력에 대해 여러 가능한 실행 경로가 존재한다. 비결정도: 각 단계에서 선택 가능한 다음 단계의 최대 개수를 비결정도라고 한다. 계산 능력: 비결정성 알고리즘과 결정성 알고리즘의 계산 능력은 동일하다. 응용 NP 문제: 비결정성 알고리즘으로 다항식 시간 내에 해결 가능한 결정형 문제를 NP 문제라고 한다. 유한 오토마타: 비결정적 유한 오토마타(NFA)는 탐색과 백트래킹 기법을 통해 모든 가능한 선택을 시도한다. 탐색 및 백트래킹 알고리즘: 비결정성은 여러 가지 경우를 순차적으로 계산하며 최적값을 갱신하는 백트래킹 기법의 모델로 사용된다. 장점 간결한 표현: 복잡한 언어나 시스템을 비결정성을 통해 더 간결하게 정의할 수 있다. 논증 간소화: 비결정성을 통해 공식적인 논증을 간단히 할 수 있다. 모델링 유연성: 실제 세계의 불확실성이나 복잡성을 모델링하는 데 유용하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import random import threading # 결정적인 함수의 예 def deterministic_sum(a, b): return a + b # 항상 같은 입력에 대해 같은 결과 # 비결정적인 함수의 예 def non_deterministic_choice(options): return random.choice(options) # 매번 다른 결과가 나올 수 있음 # 비결정적인 멀티스레딩 예제 shared_counter = 0 lock = threading.Lock() def increment_counter(): global shared_counter current = shared_counter # 의도적으로 경쟁 조건을 만듦 threading.Thread(target=lambda: None).start() shared_counter = current + 1 def run_concurrent_increments(n): threads = [] for _ in range(n): t = threading.Thread(target=increment_counter) threads.append(t) t.start() for t in threads: t.join() return shared_counter 다양한 상황에서 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-13 09:18:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;701 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비결정성 (Non-determinism)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/non-determinism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bitwise Operators</h2></header><div class=entry-content><p>Bitwise Operators 비트와이즈 연산자는 저수준 최적화, 데이터 압축, 하드웨어 제어 등 다양한 영역에서 강력한 도구이다.
모든 비트를 직접 다루기 때문에 신중하게 사용해야 하지만, 잘 활용하면 성능과 메모리 효율성에서 큰 이점을 얻을 수 있다.
현대 프로그래밍에서는 추상화 수준이 높아졌지만, 시스템 프로그래밍, 임베디드 시스템, 게임 개발, 데이터베이스 엔진 등에서 비트와이즈 연산은 여전히 핵심적인 역할을 수행한다. 효율적인 프로그래밍을 위해 비트와이즈 연산자의 활용법을 숙지하는 것이 좋다.
비트와이즈 연산자의 기본 개념 비트와이즈 연산자는 정수 값을 이진수(비트)로 표현하여 비트 단위로 연산을 수행한다.
컴퓨터의 모든 데이터는 결국 이진수로 저장되기 때문에, 비트 단위 조작은 저수준(low-level) 프로그래밍에서 특히 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-14 12:56:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2120 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bitwise Operators" href=https://buenhyden.github.io/posts/computer-science/fundamentals/bitwise-operators/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Endianness</h2></header><div class=entry-content><p>Endianness Endianness의 기본 개념 Endianness(엔디안)는 컴퓨터 메모리에서 데이터를 저장하는 바이트 순서를 의미한다.
이 개념은 다중 바이트 값(2바이트 이상)을 다룰 때 중요하게 작용한다. 근본적으로 엔디안은 “바이트들을 어떤 순서로 배열할 것인가"라는 질문에 대한 답이다.
Big Endian Vs Little Endian 엔디안에는 주로 두 가지 방식이 있다:
Big Endian (빅 엔디안): 가장 중요한(Most Significant Byte, MSB) 바이트가 가장 낮은 메모리 주소에 저장된다. 즉, 메모리 주소가 왼쪽에서 오른쪽으로 증가할 때, 데이터의 가장 중요한 부분이 먼저 나온다. Little Endian (리틀 엔디안): 가장 덜 중요한(Least Significant Byte, LSB) 바이트가 가장 낮은 메모리 주소에 저장된다. 즉, 메모리 주소가 왼쪽에서 오른쪽으로 증가할 때, 데이터의 가장 덜 중요한 부분이 먼저 나옵니다. 예를 들어, 16진수 값 0x12345678을 메모리에 저장한다고 가정해 보면:
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;688 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Endianness" href=https://buenhyden.github.io/posts/computer-science/fundamentals/endianness/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Floating Point Numbers</h2></header><div class=entry-content><p>부동소수점 수(Floating Point Numbers) 부동소수점 수는 컴퓨터에서 실수를 표현하는 핵심적인 방식으로, 프로그래밍에서 매우 중요한 개념이다.
부동소수점은 컴퓨터에서 실수를 표현하는 효율적인 방법이지만, 그 특성과 한계를 이해하는 것이 중요하다.
정밀도 문제, 반올림 오차, 비교 문제 등을 인식하고 적절히 대응하는 것이 안정적인 소프트웨어 개발의 핵심이다.
실용적인 측면에서는:
정확한 산술이 필요한 영역에서는 Decimal 같은 정밀 타입 사용 부동소수점 비교 시 epsilon 값을 활용한 근사 비교 적용 부동소수점의 특수한 값들(NaN, Infinity 등)을 적절히 처리 필요에 따라 반올림 정책을 명확히 설정하고 일관되게 적용 이러한 원칙을 따르면 부동소수점 관련 문제를 최소화하고 안정적인 시스템을 구축할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-13 16:19:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1708 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Floating Point Numbers" href=https://buenhyden.github.io/posts/computer-science/fundamentals/floating-point-numbers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 인코딩(Character Encodings)</h2></header><div class=entry-content><p>문자 인코딩(Character Encodings) 문자 인코딩은 인간이 읽을 수 있는 텍스트를 컴퓨터가 이해할 수 있는 이진 형식으로 변환하는 방법을 정의한다.
니다. 컴퓨터는 오직 0과 1만 이해하지만, 우리 인간은 다양한 언어와 기호로 의사소통한다. 문자 인코딩은 이 간극을 메우는 중요한 다리 역할을 한다.
문자 인코딩은 현대 소프트웨어 개발의 기초가 되는 개념입니다. UTF-8은 현재 가장 보편적인 인코딩 방식이지만, 레거시 시스템과의 호환성, 효율성, 특정 언어 요구사항 등 다양한 고려사항에 따라 다른 인코딩도 여전히 사용된다.
개발자는 다양한 인코딩 방식을 이해하고, 적절히 처리할 수 있어야 하며, 특히 국제화(i18n)와 지역화(l10n)가 중요한 글로벌 애플리케이션 개발에서는 문자 인코딩에 대한 깊은 이해가 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-12-13 12:56:00 +0000 UTC'>December 13, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1186 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 인코딩(Character Encodings)" href=https://buenhyden.github.io/posts/computer-science/fundamentals/character-encodings/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>