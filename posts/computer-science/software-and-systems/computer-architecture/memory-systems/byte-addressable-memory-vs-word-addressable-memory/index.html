<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Byte Addressable Memory vs Word Addressable Memory | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Computer-Architecture,Memory-Architecture,Byte-Addressable-Memory,Word-Addressable-Memory"><meta name=description content="컴퓨터 메모리의 주소 지정 방식을 설명하는 개념"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Byte Addressable Memory vs Word Addressable Memory"><meta property="og:description" content="컴퓨터 메모리의 주소 지정 방식을 설명하는 개념"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-30T11:38:00+00:00"><meta property="article:modified_time" content="2024-09-30T11:38:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="Computer-Architecture"><meta property="article:tag" content="Memory-Architecture"><meta property="article:tag" content="Byte-Addressable-Memory"><meta property="article:tag" content="Word-Addressable-Memory"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Byte Addressable Memory vs Word Addressable Memory"><meta name=twitter:description content="컴퓨터 메모리의 주소 지정 방식을 설명하는 개념"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":4,"name":"Computer Architecture","item":"https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/"},{"@type":"ListItem","position":5,"name":"Memory Architecture","item":"https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/"},{"@type":"ListItem","position":6,"name":"Byte Addressable Memory vs Word Addressable Memory","item":"https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Byte Addressable Memory vs Word Addressable Memory","name":"Byte Addressable Memory vs Word Addressable Memory","description":"컴퓨터 메모리의 주소 지정 방식을 설명하는 개념","keywords":["Computer-System","Computer-Architecture","Memory-Architecture","Byte-Addressable-Memory","Word-Addressable-Memory"],"articleBody":"Byte Addressable Memory vs. Word Addressable Memory Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.\n이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.\nSourece: https://examradar.com/memory-organisation/\nByte Addressable Memory Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.\n가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.\nCPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.\n32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.\n세밀한 메모리 조작이 가능하며 다양한 데이터 타입을 효율적으로 저장할 수 있으며, 문자열 처리 등 바이트 단위 연산에 유리하다.\n엔디안(Endianness)\n메모리에 다중 바이트 데이터를 저장하는 순서를 나타낸다. 주요 엔디안(Endianness)는 다음과 같다. 빅 엔디안(Big Endian): 가장 중요한 바이트(Most Significant Byte, MSB)가 가장 낮은 메모리 주소에 저장된다. 사람이 숫자를 읽는 방식과 유사하여 직관적이다. 주로 네트워크 프로토콜에서 사용되며, “네트워크 바이트 순서\"라고도 한다. 리틀 엔디안(Little Endian): 가장 덜 중요한 바이트(Least Significant Byte, LSB)가 가장 낮은 메모리 주소에 저장된다. Intel x86, x64 프로세서 등 많은 현대 컴퓨터 시스템에서 사용된다. 일부 수학적 연산에서 효율적일 수 있다. 예를 들어, 32비트 정수 0x11223344를 메모리에 저장할 때: 빅 엔디안: 11 22 33 44 리틀 엔디안: 44 33 22 11 엔디안은 다중 바이트 데이터 처리에만 영향을 미치며, 단일 바이트 데이터(예: ASCII 문자)는 영향을 받지 않는다. Word Addressable Memory Word Addressable Memory는 메모리의 각 워드(word)마다 고유한 주소가 할당되는 메모리 구조로, 여기서 워드는 프로세서가 한 번에 처리할 수 있는 데이터의 기본 단위를 의미한다. 일반적으로 워드 크기는 32비트(4바이트) 또는 64비트(8바이트)이다.\n워드 단위로만 메모리에 접근할 수 있으며, 개별 바이트에 직접 접근할 수 없다.\n바이트 주소 지정 방식에 비해 더 적은 주소로 더 큰 메모리 공간을 관리할 수 있으며, 워드 크기의 데이터 처리에 효율적이다. 또한, 작은 크기의 데이터 처리에는 비효율적일 수 있다.\n워드 크기에 따라 주소 지정 가능한 메모리 용량이 달라진다.\n예를 들어:\n16비트 주소와 32비트 워드 시스템: 2^16 * 4바이트 = 256KB 32비트 주소와 64비트 워드 시스템: 2^32 * 8바이트 = 32GB 큰 데이터 처리에 효율적이며, 주소 공간을 효율적으로 사용할 수 있다.\n하지만, 작은 데이터 처리에 비효율적이며, 바이트 단위 조작이 어렵다.\n비교 분석 표 특성 Byte Addressable Memory Word Addressable Memory 주소 단위 1 바이트 1 워드 (보통 4바이트 또는 8바이트) 메모리 접근 바이트 단위로 가능 워드 단위로만 가능 주소 공간 더 많은 주소 필요 더 적은 주소 필요 유연성 높음 (바이트 단위 조작 가능) 제한적 (워드 단위로만 조작) 메모리 효율 세밀한 메모리 관리 가능 워드 크기 미만의 데이터도 워드 전체 사용 구현 복잡도 상대적으로 복잡 상대적으로 단순 주요 용도 범용 컴퓨팅 시스템 특수 목적 프로세서, 일부 임베디드 시스템 데이터 정렬 바이트 단위 정렬 가능 워드 경계에 정렬 필요 세부 특성 비교 메모리 접근 패턴 1 2 3 4 5 6 7 8 # Byte Addressable def access_byte(address): return memory[address] # 직접 바이트 접근 # Word Addressable def access_word(address): word_address = address // WORD_SIZE return memory[word_address] # 워드 단위 접근 메모리 사용 효율 1 2 3 4 5 # Byte Addressable char small_data = 'A'; # 1바이트만 사용 # Word Addressable word small_data = 'A'; # 전체 워드(4바이트) 사용 주소 계산 1 2 3 4 5 # Byte Addressable byte_address = base_address + offset # Word Addressable word_address = (base_address + offset) // WORD_SIZE 시스템 수준 영향 영향 분야 Byte Addressable Word Addressable 메모리 관리 더 복잡하지만 유연함 단순하지만 제한적 캐시 구성 바이트 단위 접근 지원 필요 워드 단위로 단순화 버스 대역폭 바이트 단위 전송 지원 워드 단위 전송에 최적화 명령어 세트 바이트 조작 명령어 포함 워드 단위 명령어 중심 성능 특성 세밀한 조작 가능하나 오버헤드 있음 단순하고 효율적이나 제한적 이러한 차이점들을 이해하는 것은 시스템 설계와 최적화에 중요하다. 특히 저수준 프로그래밍이나 시스템 프로그래밍을 할 때 이러한 특성들을 고려해야 한다.\n참고 및 출처 ","wordCount":"609","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-30T11:38:00Z","dateModified":"2024-09-30T11:38:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>컴퓨터 과학</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/>Computer Architecture</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/software-and-systems/computer-architecture/memory-systems/>Memory Architecture</a></div><h1 class="post-title entry-hint-parent">Byte Addressable Memory vs Word Addressable Memory</h1><div class=post-description>컴퓨터 메모리의 주소 지정 방식을 설명하는 개념</div><div class=post-meta><span title='2024-09-30 11:38:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science/Software%20and%20Systems/Computer%20Architecture/Memory%20Systems/Byte-Addressable-Memory-vs-Word-Addressable-Memory.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#byte-addressable-memory-vs-word-addressable-memory>Byte Addressable Memory vs. Word Addressable Memory</a><ul><li><a href=#byte-addressable-memory>Byte Addressable Memory</a></li><li><a href=#word-addressable-memory>Word Addressable Memory</a></li><li><a href=#비교-분석-표>비교 분석 표</a></li><li><a href=#세부-특성-비교>세부 특성 비교</a></li><li><a href=#시스템-수준-영향>시스템 수준 영향</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=byte-addressable-memory-vs-word-addressable-memory>Byte Addressable Memory vs. Word Addressable Memory<a hidden class=anchor aria-hidden=true href=#byte-addressable-memory-vs-word-addressable-memory>#</a></h2><p>Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.<br>이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.</p><p><figure><img alt="Byte Addressable Memory vs. Word Addressable Memory" loading=lazy src=/img/fig_a.jpg.webp><figcaption>Sourece: https://examradar.com/memory-organisation/</figcaption></figure></p><h3 id=byte-addressable-memory>Byte Addressable Memory<a hidden class=anchor aria-hidden=true href=#byte-addressable-memory>#</a></h3><p>Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.</p><p>가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.<br>CPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.<br>32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.</p><p>세밀한 메모리 조작이 가능하며 다양한 데이터 타입을 효율적으로 저장할 수 있으며, 문자열 처리 등 바이트 단위 연산에 유리하다.</p><blockquote><p>엔디안(Endianness)</p><ul><li>메모리에 다중 바이트 데이터를 저장하는 순서를 나타낸다.</li><li>주요 엔디안(Endianness)는 다음과 같다.<ul><li>빅 엔디안(Big Endian):<ul><li>가장 중요한 바이트(Most Significant Byte, MSB)가 가장 낮은 메모리 주소에 저장된다.</li><li>사람이 숫자를 읽는 방식과 유사하여 직관적이다.</li><li>주로 네트워크 프로토콜에서 사용되며, &ldquo;네트워크 바이트 순서"라고도 한다.</li></ul></li><li>리틀 엔디안(Little Endian):<ul><li>가장 덜 중요한 바이트(Least Significant Byte, LSB)가 가장 낮은 메모리 주소에 저장된다.</li><li>Intel x86, x64 프로세서 등 많은 현대 컴퓨터 시스템에서 사용된다.</li><li>일부 수학적 연산에서 효율적일 수 있다.</li></ul></li></ul></li><li>예를 들어, 32비트 정수 0x11223344를 메모리에 저장할 때:<ul><li>빅 엔디안: 11 22 33 44</li><li>리틀 엔디안: 44 33 22 11</li></ul></li><li>엔디안은 다중 바이트 데이터 처리에만 영향을 미치며, 단일 바이트 데이터(예: ASCII 문자)는 영향을 받지 않는다.</li></ul></blockquote><h3 id=word-addressable-memory>Word Addressable Memory<a hidden class=anchor aria-hidden=true href=#word-addressable-memory>#</a></h3><p>Word Addressable Memory는 메모리의 각 워드(word)마다 고유한 주소가 할당되는 메모리 구조로, 여기서 워드는 프로세서가 한 번에 처리할 수 있는 데이터의 기본 단위를 의미한다. 일반적으로 워드 크기는 32비트(4바이트) 또는 64비트(8바이트)이다.<br>워드 단위로만 메모리에 접근할 수 있으며, 개별 바이트에 직접 접근할 수 없다.<br>바이트 주소 지정 방식에 비해 더 적은 주소로 더 큰 메모리 공간을 관리할 수 있으며, 워드 크기의 데이터 처리에 효율적이다. 또한, 작은 크기의 데이터 처리에는 비효율적일 수 있다.</p><p>워드 크기에 따라 주소 지정 가능한 메모리 용량이 달라진다.<br>예를 들어:</p><ul><li>16비트 주소와 32비트 워드 시스템: 2^16 * 4바이트 = 256KB</li><li>32비트 주소와 64비트 워드 시스템: 2^32 * 8바이트 = 32GB</li></ul><p>큰 데이터 처리에 효율적이며, 주소 공간을 효율적으로 사용할 수 있다.<br>하지만, 작은 데이터 처리에 비효율적이며, 바이트 단위 조작이 어렵다.</p><h3 id=비교-분석-표>비교 분석 표<a hidden class=anchor aria-hidden=true href=#비교-분석-표>#</a></h3><table><thead><tr><th>특성</th><th>Byte Addressable Memory</th><th>Word Addressable Memory</th></tr></thead><tbody><tr><td><strong>주소 단위</strong></td><td>1 바이트</td><td>1 워드 (보통 4바이트 또는 8바이트)</td></tr><tr><td><strong>메모리 접근</strong></td><td>바이트 단위로 가능</td><td>워드 단위로만 가능</td></tr><tr><td><strong>주소 공간</strong></td><td>더 많은 주소 필요</td><td>더 적은 주소 필요</td></tr><tr><td><strong>유연성</strong></td><td>높음 (바이트 단위 조작 가능)</td><td>제한적 (워드 단위로만 조작)</td></tr><tr><td><strong>메모리 효율</strong></td><td>세밀한 메모리 관리 가능</td><td>워드 크기 미만의 데이터도 워드 전체 사용</td></tr><tr><td><strong>구현 복잡도</strong></td><td>상대적으로 복잡</td><td>상대적으로 단순</td></tr><tr><td><strong>주요 용도</strong></td><td>범용 컴퓨팅 시스템</td><td>특수 목적 프로세서, 일부 임베디드 시스템</td></tr><tr><td><strong>데이터 정렬</strong></td><td>바이트 단위 정렬 가능</td><td>워드 경계에 정렬 필요</td></tr></tbody></table><h3 id=세부-특성-비교>세부 특성 비교<a hidden class=anchor aria-hidden=true href=#세부-특성-비교>#</a></h3><h4 id=메모리-접근-패턴>메모리 접근 패턴<a hidden class=anchor aria-hidden=true href=#메모리-접근-패턴>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7>7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Byte Addressable</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>access_byte</span><span class=p>(</span><span class=n>address</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memory</span><span class=p>[</span><span class=n>address</span><span class=p>]</span>  <span class=c1># 직접 바이트 접근</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Word Addressable</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>access_word</span><span class=p>(</span><span class=n>address</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>word_address</span> <span class=o>=</span> <span class=n>address</span> <span class=o>//</span> <span class=n>WORD_SIZE</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memory</span><span class=p>[</span><span class=n>word_address</span><span class=p>]</span>  <span class=c1># 워드 단위 접근</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=메모리-사용-효율>메모리 사용 효율<a hidden class=anchor aria-hidden=true href=#메모리-사용-효율>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Byte Addressable</span>
</span></span><span class=line><span class=cl><span class=n>char</span> <span class=n>small_data</span> <span class=o>=</span> <span class=s1>&#39;A&#39;</span><span class=p>;</span>    <span class=c1># 1바이트만 사용</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Word Addressable</span>
</span></span><span class=line><span class=cl><span class=n>word</span> <span class=n>small_data</span> <span class=o>=</span> <span class=s1>&#39;A&#39;</span><span class=p>;</span>    <span class=c1># 전체 워드(4바이트) 사용</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=주소-계산>주소 계산<a hidden class=anchor aria-hidden=true href=#주소-계산>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Byte Addressable</span>
</span></span><span class=line><span class=cl><span class=n>byte_address</span> <span class=o>=</span> <span class=n>base_address</span> <span class=o>+</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Word Addressable</span>
</span></span><span class=line><span class=cl><span class=n>word_address</span> <span class=o>=</span> <span class=p>(</span><span class=n>base_address</span> <span class=o>+</span> <span class=n>offset</span><span class=p>)</span> <span class=o>//</span> <span class=n>WORD_SIZE</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=시스템-수준-영향>시스템 수준 영향<a hidden class=anchor aria-hidden=true href=#시스템-수준-영향>#</a></h3><table><thead><tr><th>영향 분야</th><th>Byte Addressable</th><th>Word Addressable</th></tr></thead><tbody><tr><td><strong>메모리 관리</strong></td><td>더 복잡하지만 유연함</td><td>단순하지만 제한적</td></tr><tr><td><strong>캐시 구성</strong></td><td>바이트 단위 접근 지원 필요</td><td>워드 단위로 단순화</td></tr><tr><td><strong>버스 대역폭</strong></td><td>바이트 단위 전송 지원</td><td>워드 단위 전송에 최적화</td></tr><tr><td><strong>명령어 세트</strong></td><td>바이트 조작 명령어 포함</td><td>워드 단위 명령어 중심</td></tr><tr><td><strong>성능 특성</strong></td><td>세밀한 조작 가능하나 오버헤드 있음</td><td>단순하고 효율적이나 제한적</td></tr></tbody></table><p>이러한 차이점들을 이해하는 것은 시스템 설계와 최적화에 중요하다. 특히 저수준 프로그래밍이나 시스템 프로그래밍을 할 때 이러한 특성들을 고려해야 한다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/computer-architecture/>Computer-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/memory-architecture/>Memory-Architecture</a></li><li><a href=https://buenhyden.github.io/tags/byte-addressable-memory/>Byte-Addressable-Memory</a></li><li><a href=https://buenhyden.github.io/tags/word-addressable-memory/>Word-Addressable-Memory</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/system-design/caching/cache/cache/><span class=title>« Prev</span><br><span>캐시 (Cache)</span>
</a><a class=next href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/allocation-policy/><span class=title>Next »</span><br><span>Allocation Policy</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>