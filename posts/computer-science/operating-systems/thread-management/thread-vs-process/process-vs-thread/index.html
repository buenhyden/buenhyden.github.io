<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process vs Thread | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,System-Execution-Models,Process,Thread"><meta name=description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/operating-systems/thread-management/thread-vs-process/process-vs-thread/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/operating-systems/thread-management/thread-vs-process/process-vs-thread/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/operating-systems/thread-management/thread-vs-process/process-vs-thread/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Process vs Thread"><meta property="og:description" content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-05T08:30:00+00:00"><meta property="article:modified_time" content="2024-10-05T08:30:00+00:00"><meta property="article:tag" content="Computer-System"><meta property="article:tag" content="System-Execution-Models"><meta property="article:tag" content="Process"><meta property="article:tag" content="Thread"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Process vs Thread"><meta name=twitter:description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-science/operating-systems/"},{"@type":"ListItem","position":4,"name":"Process vs Thread","item":"https://buenhyden.github.io/posts/computer-science/operating-systems/thread-management/thread-vs-process/process-vs-thread/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Process vs Thread","name":"Process vs Thread","description":"Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.","keywords":["Computer-System","System-Execution-Models","Process","Thread"],"articleBody":"Process vs. Thread 프로세스:\n독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. 스레드:\n프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. https://www.geeksforgeeks.org/thread-in-operating-system/\nProcess vs. Thread 특성 Process Thread 정의 실행 중인 프로그램의 인스턴스 프로세스 내에서 실행되는 더 작은 실행 단위 메모리 공간 독립적인 메모리 공간 (코드, 데이터, 스택, 힙) 프로세스의 메모리 공간 공유 (코드, 데이터, 힙), 독립적인 스택 구성 요소 - 코드 영역\n- 데이터 영역\n- 스택 영역\n- 힙 영역 - 스레드 ID\n- 프로그램 카운터\n- 레지스터 집합\n- 스택 자원 공유 다른 프로세스와 자원 공유 안 함 같은 프로세스 내 스레드 간 자원 공유 생성 비용 높음 낮음 컨텍스트 스위칭 비용이 큼 비용이 적음 (같은 프로세스 내에서) 안정성 높음 (한 프로세스의 오류가 다른 프로세스에 영향 없음) 상대적으로 낮음 (한 스레드의 오류가 전체 프로세스에 영향) 통신 프로세스 간 통신(IPC) 필요 (복잡하고 오버헤드 큼) 쉽고 빠른 통신 (공유 메모리 사용) 병렬 처리 가능하지만 오버헤드 큼 효율적인 병렬 처리 가능 메모리 구조 비교 메모리 영역 Process Thread 코드 영역 독립적 공유 데이터 영역 독립적 공유 힙 영역 독립적 공유 스택 영역 독립적 각 스레드마다 독립적 특성 상세 비교 특성 Process Thread 독립성 완전히 독립적 부분적으로 독립적 자원 공유 제한적 (IPC 필요) 쉽게 공유 가능 오류 영향 다른 프로세스에 영향 없음 같은 프로세스의 모든 스레드에 영향 동기화 필요성 낮음\n- IPC 메커니즘 필요 공유 자원에 대한 동기화 필요\n- 뮤텍스, 세마포어 등 사용 생성 시간 더 오래 걸림 더 빠름 종료 시간 더 오래 걸림 더 빠름 장단점 비교 구분 Process Thread 장점 - 높은 안정성\n- 다른 프로세스의 영향 받지 않음\n- 보안성이 높음 - 생성/종료가 빠름\n- 자원 공유가 쉬움\n- 통신 비용이 적음 단점 - 많은 시스템 자원 필요\n- 프로세스 간 통신이 복잡\n- 컨텍스트 스위칭 비용이 큼 - 동기화 문제 발생 가능\n- 디버깅이 어려움\n- 하나의 스레드 문제가 전체에 영향 사용 사례 비교 용도 Process 선호 Thread 선호 웹 서버 안정성이 중요한 경우 높은 동시성이 필요한 경우 GUI 앱 독립적인 작업이 많은 경우 반응성이 중요한 경우 데이터 처리 대용량 병렬 처리 데이터 공유가 많은 경우 시스템 서비스 격리가 필요한 경우 빈번한 통신이 필요한 경우 활용 예 - 독립적인 애플리케이션 - 웹 브라우저의 각 탭 - 다중 사용자 서버 - 웹 서버 요청 처리 - 게임 엔진 (렌더링, 물리 연산) - 멀티미디어 애플리케이션 동기화 메커니즘 비교 메커니즘 Process Thread 공유 메모리 명시적으로 설정 필요 기본적으로 공유 뮤텍스 프로세스 간 뮤텍스 필요 프로세스 내 뮤텍스 사용 세마포어 시스템 세마포어 필요 프로세스 내 세마포어 사용 메시지 전달 IPC 메커니즘 사용 직접 메모리 접근 이러한 차이점들을 이해하고 적절히 활용하면, 상황에 맞는 최적의 실행 단위를 선택할 수 있다.\n참고 및 출처 ","wordCount":"449","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-05T08:30:00Z","dateModified":"2024-10-05T08:30:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science/operating-systems/thread-management/thread-vs-process/process-vs-thread/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>컴퓨터 과학</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/operating-systems/>Operating System</a></div><h1 class="post-title entry-hint-parent">Process vs Thread</h1><div class=post-description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</div><div class=post-meta><span title='2024-10-05 08:30:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science/Operating%20systems/Thread%20Management/Thread%20vs%20Process/Process-vs-Thread.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#process-vs-thread>Process vs. Thread</a><ul><li><a href=#process-vs-thread-1>Process vs. Thread</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=process-vs-thread>Process vs. Thread<a hidden class=anchor aria-hidden=true href=#process-vs-thread>#</a></h2><ol><li><p>프로세스:</p><ul><li>독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다.</li><li>다른 프로세스와 완전히 격리되어 있어 안정성이 높다.</li><li>생성과 전환에 많은 비용이 든다.</li></ul></li><li><p>스레드:</p><ul><li>프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다.</li><li>프로세스보다 가볍고, 생성과 전환 비용이 적다.</li><li>동시성을 제공하지만, 동기화 문제에 주의해야 한다.</li></ul></li></ol><p><figure><img alt="Single Threaded vs Multi-threaded Process" loading=lazy src=/img/Screenshot-from-2024-02-26-11-48-56-768.png><figcaption>https://www.geeksforgeeks.org/thread-in-operating-system/</figcaption></figure></p><h3 id=process-vs-thread-1>Process vs. Thread<a hidden class=anchor aria-hidden=true href=#process-vs-thread-1>#</a></h3><table><thead><tr><th>특성</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td>정의</td><td>실행 중인 프로그램의 인스턴스</td><td>프로세스 내에서 실행되는 더 작은 실행 단위</td></tr><tr><td>메모리 공간</td><td>독립적인 메모리 공간 (코드, 데이터, 스택, 힙)</td><td>프로세스의 메모리 공간 공유 (코드, 데이터, 힙), 독립적인 스택</td></tr><tr><td>구성 요소</td><td>- 코드 영역<br>- 데이터 영역<br>- 스택 영역<br>- 힙 영역</td><td>- 스레드 ID<br>- 프로그램 카운터<br>- 레지스터 집합<br>- 스택</td></tr><tr><td>자원 공유</td><td>다른 프로세스와 자원 공유 안 함</td><td>같은 프로세스 내 스레드 간 자원 공유</td></tr><tr><td>생성 비용</td><td>높음</td><td>낮음</td></tr><tr><td>컨텍스트 스위칭</td><td>비용이 큼</td><td>비용이 적음 (같은 프로세스 내에서)</td></tr><tr><td>안정성</td><td>높음 (한 프로세스의 오류가 다른 프로세스에 영향 없음)</td><td>상대적으로 낮음 (한 스레드의 오류가 전체 프로세스에 영향)</td></tr><tr><td>통신</td><td>프로세스 간 통신(IPC) 필요 (복잡하고 오버헤드 큼)</td><td>쉽고 빠른 통신 (공유 메모리 사용)</td></tr><tr><td>병렬 처리</td><td>가능하지만 오버헤드 큼</td><td>효율적인 병렬 처리 가능</td></tr></tbody></table><h4 id=메모리-구조-비교>메모리 구조 비교<a hidden class=anchor aria-hidden=true href=#메모리-구조-비교>#</a></h4><table><thead><tr><th>메모리 영역</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>코드 영역</strong></td><td>독립적</td><td>공유</td></tr><tr><td><strong>데이터 영역</strong></td><td>독립적</td><td>공유</td></tr><tr><td><strong>힙 영역</strong></td><td>독립적</td><td>공유</td></tr><tr><td><strong>스택 영역</strong></td><td>독립적</td><td>각 스레드마다 독립적</td></tr></tbody></table><h4 id=특성-상세-비교>특성 상세 비교<a hidden class=anchor aria-hidden=true href=#특성-상세-비교>#</a></h4><table><thead><tr><th>특성</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>독립성</strong></td><td>완전히 독립적</td><td>부분적으로 독립적</td></tr><tr><td><strong>자원 공유</strong></td><td>제한적 (IPC 필요)</td><td>쉽게 공유 가능</td></tr><tr><td><strong>오류 영향</strong></td><td>다른 프로세스에 영향 없음</td><td>같은 프로세스의 모든 스레드에 영향</td></tr><tr><td><strong>동기화</strong></td><td>필요성 낮음<br>- IPC 메커니즘 필요</td><td>공유 자원에 대한 동기화 필요<br>- 뮤텍스, 세마포어 등 사용</td></tr><tr><td><strong>생성 시간</strong></td><td>더 오래 걸림</td><td>더 빠름</td></tr><tr><td><strong>종료 시간</strong></td><td>더 오래 걸림</td><td>더 빠름</td></tr></tbody></table><h4 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h4><table><thead><tr><th>구분</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>장점</strong></td><td>- 높은 안정성<br>- 다른 프로세스의 영향 받지 않음<br>- 보안성이 높음</td><td>- 생성/종료가 빠름<br>- 자원 공유가 쉬움<br>- 통신 비용이 적음</td></tr><tr><td><strong>단점</strong></td><td>- 많은 시스템 자원 필요<br>- 프로세스 간 통신이 복잡<br>- 컨텍스트 스위칭 비용이 큼</td><td>- 동기화 문제 발생 가능<br>- 디버깅이 어려움<br>- 하나의 스레드 문제가 전체에 영향</td></tr></tbody></table><h4 id=사용-사례-비교>사용 사례 비교<a hidden class=anchor aria-hidden=true href=#사용-사례-비교>#</a></h4><table><thead><tr><th>용도</th><th>Process 선호</th><th>Thread 선호</th></tr></thead><tbody><tr><td><strong>웹 서버</strong></td><td>안정성이 중요한 경우</td><td>높은 동시성이 필요한 경우</td></tr><tr><td><strong>GUI 앱</strong></td><td>독립적인 작업이 많은 경우</td><td>반응성이 중요한 경우</td></tr><tr><td><strong>데이터 처리</strong></td><td>대용량 병렬 처리</td><td>데이터 공유가 많은 경우</td></tr><tr><td><strong>시스템 서비스</strong></td><td>격리가 필요한 경우</td><td>빈번한 통신이 필요한 경우</td></tr><tr><td>활용 예</td><td>- 독립적인 애플리케이션<br>- 웹 브라우저의 각 탭<br>- 다중 사용자 서버</td><td>- 웹 서버 요청 처리<br>- 게임 엔진 (렌더링, 물리 연산)<br>- 멀티미디어 애플리케이션</td></tr></tbody></table><h4 id=동기화-메커니즘-비교>동기화 메커니즘 비교<a hidden class=anchor aria-hidden=true href=#동기화-메커니즘-비교>#</a></h4><table><thead><tr><th>메커니즘</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>공유 메모리</strong></td><td>명시적으로 설정 필요</td><td>기본적으로 공유</td></tr><tr><td><strong>뮤텍스</strong></td><td>프로세스 간 뮤텍스 필요</td><td>프로세스 내 뮤텍스 사용</td></tr><tr><td><strong>세마포어</strong></td><td>시스템 세마포어 필요</td><td>프로세스 내 세마포어 사용</td></tr><tr><td><strong>메시지 전달</strong></td><td>IPC 메커니즘 사용</td><td>직접 메모리 접근</td></tr></tbody></table><p>이러한 차이점들을 이해하고 적절히 활용하면, 상황에 맞는 최적의 실행 단위를 선택할 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/computer-system/>Computer-System</a></li><li><a href=https://buenhyden.github.io/tags/system-execution-models/>System-Execution-Models</a></li><li><a href=https://buenhyden.github.io/tags/process/>Process</a></li><li><a href=https://buenhyden.github.io/tags/thread/>Thread</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/operating-systems/multithreading/multithreading-vs-multiprocessing-vs-multitasking/><span class=title>« Prev</span><br><span>Multithreading vs. Multiprocessing vs Multitasking</span>
</a><a class=next href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/><span class=title>Next »</span><br><span>Poetry vs uv vs Rye</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>