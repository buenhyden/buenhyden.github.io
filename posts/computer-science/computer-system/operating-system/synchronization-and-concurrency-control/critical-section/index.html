<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>임계 영역 (Critical Section) | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,Synchronization-and-Concurrency-Control,Critical-Section"><meta name=description content="여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="임계 영역 (Critical Section)"><meta property="og:description" content="여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="임계 영역 (Critical Section)"><meta name=twitter:description content="여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-science/computer-system/"},{"@type":"ListItem","position":4,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/"},{"@type":"ListItem","position":5,"name":"임계 영역 (Critical Section)","item":"https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/computer-system/>Computer System</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/>Operating System</a></div><h1>임계 영역 (Critical Section)</h1><div class=post-description>여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역</div></header><div class=post-content><h2 id=임계-영역-critical-section>임계 영역 (Critical Section)<a hidden class=anchor aria-hidden=true href=#임계-영역-critical-section>#</a></h2><p>운영체제에서 임계 영역(Critical Section)은 여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역을 말한다.<br>이는 병렬 컴퓨팅 환경에서 중요한 개념으로, 데이터의 일관성과 무결성을 보장하기 위해 사용된다.</p><p>여러 프로세스가 동시에 임계 영역에 진입하면 데이터의 일관성이 깨질 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 임계 영역 예시</span>
</span></span><span class=line><span class=cl><span class=n>balance</span> <span class=o>=</span> <span class=mi>1000</span>  <span class=c1># 공유 자원</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>withdraw</span><span class=p>(</span><span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>global</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>    <span class=c1># 임계 영역 시작</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>balance</span>
</span></span><span class=line><span class=cl>    <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span> <span class=o>-</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>    <span class=n>balance</span> <span class=o>=</span> <span class=n>temp</span>
</span></span><span class=line><span class=cl>    <span class=c1># 임계 영역 종료</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=임계-영역-문제의-해결-조건>임계 영역 문제의 해결 조건<a hidden class=anchor aria-hidden=true href=#임계-영역-문제의-해결-조건>#</a></h3><ol><li>상호 배제(Mutual Exclusion): 한 프로세스가 임계 영역에 있을 때 다른 프로세스는 진입할 수 없다.</li><li>진행(Progress): 임계 영역에 있는 프로세스가 없다면, 진입하려는 프로세스가 들어갈 수 있어야 한다.</li><li>한정된 대기(Bounded Waiting): 프로세스의 임계 영역 진입은 무한정 연기되어서는 안 된다.</li></ol><h3 id=임계-영역-관련-문제와-해결-방법>임계 영역 관련 문제와 해결 방법<a hidden class=anchor aria-hidden=true href=#임계-영역-관련-문제와-해결-방법>#</a></h3><table><thead><tr><th>구분</th><th>데드락(Deadlock)</th><th>경쟁 상태(Race Condition)</th><th>기아 상태(Starvation)</th><th>라이브락(Livelock)</th></tr></thead><tbody><tr><td>정의</td><td>두 개 이상의 프로세스가 서로의 자원을 기다리며 영구적으로 블록된 상태</td><td>여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상태</td><td>특정 프로세스가 필요한 자원을 계속 할당받지 못하는 상태</td><td>프로세스들이 서로에게 응답하며 상태는 변하지만 실제 진행은 없는 상태</td></tr><tr><td>발생 원인</td><td>상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시 충족</td><td>공유 자원에 대한 동시 접근, 원자성 결여</td><td>부적절한 자원 할당 정책, 우선순위 역전 현상</td><td>프로세스들의 과도한 양보, 재귀적 회피 동작</td></tr><tr><td>결과</td><td>시스템 전체 또는 일부 프로세스의 완전한 정지</td><td>데이터 불일치, 예측 불가능한 결과</td><td>특정 프로세스의 실행 지연 또는 무한 대기</td><td>CPU 자원 소비, 실제 작업 진행 없음</td></tr><tr><td>특징</td><td>프로세스들이 움직이지 않고 완전히 멈춤</td><td>타이밍에 따라 결과가 비결정적</td><td>자원 할당의 불공정성</td><td>프로세스들이 활발히 상태 변경</td></tr><tr><td>해결 방법</td><td>프로세스 강제 종료, 자원 선점, 데드락 발생 조건 제거</td><td>동기화 메커니즘 사용(뮤텍스, 세마포어 등)</td><td>에이징(Aging) 기법 도입, 공정한 스케줄링</td><td>무작위 대기 시간 도입, 우선순위 조정</td></tr><tr><td>예방 기법</td><td>자원 할당 그래프 사용, 자원 순서화, 타임아웃 설정</td><td>임계 영역 설정, 원자적 연산 사용</td><td>자원 예약 시스템, 우선순위 조정 메커니즘</td><td>타임아웃 설정, 재시도 횟수 제한</td></tr><tr><td>탐지 방법</td><td>자원 할당 그래프 분석, 대기 사이클 검출</td><td>데이터 일관성 검사, 로그 분석</td><td>자원 할당 통계 모니터링</td><td>CPU 사용률 분석, 진행률 모니터링</td></tr><tr><td>영향 범위</td><td>전체 시스템 또는 관련 프로세스 그룹</td><td>공유 자원을 사용하는 프로세스들</td><td>특정 프로세스 또는 프로세스 그룹</td><td>상호 작용하는 프로세스 그룹</td></tr><tr><td>복구 방법</td><td>프로세스 재시작, 시스템 재부팅</td><td>트랜잭션 롤백, 상태 복원</td><td>우선순위 재조정, 자원 재할당</td><td>프로세스 재시작 또는 동작 패턴 변경</td></tr><tr><td>모니터링 방법</td><td>시스템 자원 모니터링, 프로세스 상태 감시</td><td>로그 분석, 데이터 정합성 검사</td><td>자원 할당 히스토리 분석</td><td>CPU 사용률 추적, 진행 상태 모니터링</td></tr></tbody></table><h4 id=해결-방법>해결 방법<a hidden class=anchor aria-hidden=true href=#해결-방법>#</a></h4><ol><li><p>상호 배제(Mutual Exclusion) 구현:</p><ul><li>뮤텍스(Mutex): 하나의 공유 자원에 대한 접근을 제어한다.</li><li>세마포어(Semaphore): 여러 개의 공유 자원에 대한 접근을 제어한다.</li></ul></li><li><p>동기화 기법:</p><ul><li>피터슨 알고리즘(Peterson&rsquo;s Algorithm): 두 프로세스 간의 상호 배제를 소프트웨어적으로 구현한다.</li><li>베이커리 알고리즘(Bakery Algorithm): 여러 프로세스 간의 상호 배제를 구현한다.</li></ul></li><li><p>하드웨어 지원:</p><ul><li>테스트와 설정(Test-and-Set) 명령어: 원자적 연산을 통해 상호 배제를 구현한다.</li><li>비교와 교환(Compare-and-Swap) 명령어: 더 정교한 동기화 제어를 가능하게 한다.</li></ul></li><li><p>운영체제 수준의 지원:</p><ul><li>모니터(Monitor): 고수준의 동기화 메커니즘으로, 상호 배제를 자동으로 보장한다.</li><li>조건 변수(Condition Variables): 프로세스 간 통신과 동기화를 위해 사용된다.</li></ul></li><li><p>프로그래밍 언어 수준의 지원:</p><ul><li>동기화 키워드(예: Java의 synchronized): 임계 영역에 대한 접근을 언어 차원에서 제어한다.</li></ul></li><li><p>락-프리(Lock-Free) 및 대기-프리(Wait-Free) 알고리즘:</p><ul><li>락을 사용하지 않고도 동시성을 관리하는 고급 기법.</li></ul></li></ol><h5 id=해결-방법들을-적용할-때-고려해야-할-중요한-원칙>해결 방법들을 적용할 때 고려해야 할 중요한 원칙<a hidden class=anchor aria-hidden=true href=#해결-방법들을-적용할-때-고려해야-할-중요한-원칙>#</a></h5><ul><li>상호 배제(Mutual Exclusion)<ul><li>한 번에 하나의 프로세스만 임계 영역에 진입할 수 있도록 보장</li><li>적절한 동기화 메커니즘 사용</li></ul></li><li>진행(Progress)<ul><li>임계 영역에 있는 프로세스가 없다면 진입을 원하는 프로세스가 진입할 수 있어야 함</li><li>기아 상태 방지</li></ul></li><li>한정 대기(Bounded Waiting)<ul><li>프로세스의 임계 영역 진입 요청 후 무한정 대기하지 않도록 보장</li><li>공정성 확보</li></ul></li><li>원자성(Atomicity)<ul><li>임계 영역의 연산은 중단되지 않고 완전히 수행되어야 함</li><li>트랜잭션 관리</li></ul></li></ul><h3 id=임계-영역-최적화-기법>임계 영역 최적화 기법<a hidden class=anchor aria-hidden=true href=#임계-영역-최적화-기법>#</a></h3><h4 id=임계-영역-최소화>임계 영역 최소화<a hidden class=anchor aria-hidden=true href=#임계-영역-최소화>#</a></h4><p>임계 영역을 가능한 한 작게 유지하는 것이 중요하다.<br>이를 통해 동기화로 인한 오버헤드를 줄이고 병렬 처리 효율을 높일 수 있다.</p><ul><li>공유 데이터 접근 코드만 임계 영역으로 설정</li><li>계산 로직은 임계 영역 밖으로 이동</li></ul><h4 id=세밀한-잠금-fine-grained-locking>세밀한 잠금 (Fine-grained Locking)<a hidden class=anchor aria-hidden=true href=#세밀한-잠금-fine-grained-locking>#</a></h4><p>큰 임계 영역을 여러 개의 작은 임계 영역으로 나누는 기법.</p><ul><li>데이터 구조의 일부분만 잠그도록 설계</li><li>동시성을 높이고 대기 시간을 줄임</li></ul><h4 id=락-프리-알고리즘-lock-free-algorithms>락-프리 알고리즘 (Lock-free Algorithms)<a hidden class=anchor aria-hidden=true href=#락-프리-알고리즘-lock-free-algorithms>#</a></h4><p>락을 사용하지 않고 원자적 연산을 활용하여 동기화를 구현한다.</p><ul><li>Compare-and-Swap (CAS) 등의 원자적 연산 사용</li><li>데드락 위험 제거 및 성능 향상</li></ul><h4 id=읽기-쓰기-락-read-write-locks>읽기-쓰기 락 (Read-Write Locks)<a hidden class=anchor aria-hidden=true href=#읽기-쓰기-락-read-write-locks>#</a></h4><p>읽기 작업과 쓰기 작업에 대해 서로 다른 락을 사용한다.</p><ul><li>다수의 읽기 작업 동시 허용</li><li>쓰기 작업 시에만 배타적 접근</li></ul><h4 id=비동기-프로그래밍-asynchronous-programming>비동기 프로그래밍 (Asynchronous Programming)<a hidden class=anchor aria-hidden=true href=#비동기-프로그래밍-asynchronous-programming>#</a></h4><p>비동기 프로그래밍 모델을 사용하여 임계 영역 접근을 최소화한다.</p><ul><li>이벤트 기반 프로그래밍</li><li>콜백 또는 Promise 패턴 활용</li></ul><h4 id=락-결합-lock-coalescing>락 결합 (Lock Coalescing)<a hidden class=anchor aria-hidden=true href=#락-결합-lock-coalescing>#</a></h4><p>여러 개의 연속된 락 획득과 해제를 하나로 합치는 기법.</p><ul><li>락 획득/해제 횟수 감소</li><li>오버헤드 감소 및 성능 향상</li></ul><h4 id=락-계층화-lock-hierarchies>락 계층화 (Lock Hierarchies)<a hidden class=anchor aria-hidden=true href=#락-계층화-lock-hierarchies>#</a></h4><p>락을 계층적으로 구성하여 데드락을 방지하고 성능을 개선한다.</p><ul><li>락 획득 순서 강제</li><li>복잡한 동기화 시나리오에서 유용</li></ul><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>교착상태 (Deadlock)</h2></header><div class=entry-content><p>교착상태 (Deadlock) 둘 이상의 프로세스가 서로가 가진 자원을 기다리며 무한정 대기하는 상황
Source: https://www.geeksforgeeks.org/deadlock-system-model/
교착상태를 시뮬레이션하는 예제:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 import threading import time class Resource: def __init__(self, name): self.name = name self.lock = threading.Lock() def acquire(self, process_name): print(f"{process_name}가 {self.name} 획득 시도") self.lock.acquire() print(f"{process_name}가 {self.name} 획득 성공") def release(self, process_name): print(f"{process_name}가 {self.name} 반환") self.lock.release() def process_task(process_name, first_resource, second_resource): """ 교착상태를 발생시키는 프로세스 작업을 시뮬레이션합니다. 각 프로세스는 두 개의 자원을 순차적으로 획득하려 시도합니다. """ try: # 첫 번째 자원 획득 first_resource.acquire(process_name) print(f"{process_name}가 작업 중…") time.sleep(1) # 다른 프로세스가 두 번째 자원을 획득할 시간을 줌 # 두 번째 자원 획득 시도 second_resource.acquire(process_name) print(f"{process_name}가 모든 자원 획득 성공") # 작업 수행 time.sleep(1) # 자원 반환 second_resource.release(process_name) first_resource.release(process_name) except Exception as e: print(f"{process_name} 오류 발생: {e}") def main(): # 두 개의 자원 생성 resource_A = Resource("Resource A") resource_B = Resource("Resource B") # 두 개의 프로세스 생성 # Process 1은 A -> B 순서로 자원 획득 시도 # Process 2는 B -> A 순서로 자원 획득 시도 process1 = threading.Thread( target=process_task, args=("Process 1", resource_A, resource_B) ) process2 = threading.Thread( target=process_task, args=("Process 2", resource_B, resource_A) ) # 프로세스 시작 process1.start() process2.start() # 프로세스 종료 대기 process1.join() process2.join() if __name__ == "__main__": print("교착상태 시뮬레이션 시작") main() print("시뮬레이션 종료") Deadlock이 발생하기 위한 필요 조건 Deadlock이 발생하기 위해서는 다음 네 가지 조건이 모두 충족되어야 한다:
...</p></div><footer class=entry-footer><span title='2024-10-03 23:24:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;632 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 교착상태 (Deadlock)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/deadlock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Race Condition</h2></header><div class=entry-content><p>경쟁 상태 (Race Condition) 여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 접근의 타이밍이나 순서에 따라 결과가 달라질 수 있는 상황.
이는 프로그램의 실행 결과가 프로세스/스레드의 실행 순서에 따라 예측할 수 없게 달라지는 현상을 초래한다.
Source: https://www.rapitasystems.com/blog/race-condition-testing
발생 조건 경쟁 상태가 발생하기 위한 조건은 다음과 같다:
두 개 이상의 포인터가 동시에 같은 데이터에 접근. 최소한 하나의 포인터가 데이터를 쓰기 위해 사용됨. 데이터 접근을 동기화하는 메커니즘이 없음. 해결책 및 방지책 동기화 메커니즘 사용: 뮤텍스(mutex), 세마포어, 락(lock) 등을 사용하여 공유 자원에 대한 접근을 제어한다. 원자적 연산 사용: 분할할 수 없는 단일 연산으로 처리하여 중간 상태를 방지한다. 스레드 안전 프로그래밍: 모든 함수를 스레드 안전하게 설계한다. 락프리 알고리즘: 고급 기법으로, 특정 동시성 작업을 최적화하는 데 사용된다. 트랜잭션 격리 수준 조정: 데이터베이스에서는 직렬화 가능한 트랜잭션 격리 수준을 사용하여 경쟁 상태를 방지할 수 있다. 실제 시스템에서의 예방책 정적 분석 도구 사용: 소스 코드나 컴파일된 바이너리를 분석하여 잠재적인 경쟁 상태를 탐지한다. 로그 분석 및 모니터링: 시스템 로그를 분석하여 경쟁 상태의 징후를 감지한다. 분산 추적 시스템: 분산 시스템에서 요청과 메시지의 흐름을 추적하여 타이밍 의존성을 식별한다. 일관성 검사 도구: 분산 노드 간의 데이터 일관성을 확인하여 경쟁 상태로 인한 이상을 탐지한다. 고려사항 및 주의사항 비결정적 특성: 경쟁 상태로 인한 버그는 재현하기 어려우므로 철저한 테스트가 필요하다. 성능 영향: 동기화 메커니즘의 과도한 사용은 성능 저하를 초래할 수 있으므로 균형이 필요하다. 데드락 주의: 락을 사용할 때는 데드락 발생 가능성에 주의해야 한다. 확장성 고려: 분산 시스템에서는 경쟁 상태 관리가 시스템의 확장성에 영향을 미칠 수 있다. 모범 사례 최소한의 임계 영역: 락으로 보호되는 코드 영역을 최소화하여 성능 저하를 방지한다. 세분화된 락: 전역 락 대신 세분화된 락을 사용하여 병렬성을 높인다. 불변성 활용: 가능한 경우 불변 객체를 사용하여 동시성 문제를 원천적으로 방지한다. 스레드 안전한 라이브러리 사용: 검증된 스레드 안전 라이브러리를 활용한다. 실제 시스템에서의 해결 전략 데이터베이스 트랜잭션: 데이터베이스 시스템에서는 ACID 속성을 갖는 트랜잭션을 사용하여 경쟁 상태를 관리한다. 분산 락: 분산 시스템에서는 Zookeeper나 etcd와 같은 도구를 사용하여 분산 락을 구현한다. 버전 관리: 낙관적 동시성 제어를 위해 데이터 버전을 관리하여 충돌을 감지하고 해결한다. 이벤트 소싱: 상태 변경을 이벤트로 기록하여 일관성을 유지하고 경쟁 상태를 해결한다. 경쟁 상태를 시연하고 해결하는 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import threading import time # 경쟁 상태가 발생하는 예제 class BankAccount: def __init__(self): self.balance = 0 # 공유 자원 def deposit(self, amount): # 현재 잔액 읽기 current = self.balance # 시간 지연을 통한 경쟁 상태 시뮬레이션 time.sleep(0.1) # 잔액 업데이트 self.balance = current + amount def get_balance(self): return self.balance # 경쟁 상태가 해결된 버전 class SafeBankAccount: def __init__(self): self.balance = 0 self.lock = threading.Lock() # 상호 배제를 위한 락 def deposit(self, amount): with self.lock: # 임계 영역 보호 current = self.balance time.sleep(0.1) self.balance = current + amount def get_balance(self): with self.lock: return self.balance # 테스트 함수 def test_race_condition(): # 경쟁 상태가 있는 계좌 account = BankAccount() # 여러 스레드가 동시에 입금 threads = [] for _ in range(10): t = threading.Thread(target=account.deposit, args=(100,)) threads.append(t) t.start() # 모든 스레드 완료 대기 for t in threads: t.join() print(f"예상 잔액: 1000, 실제 잔액: {account.get_balance()}") # 안전한 계좌로 테스트 safe_account = SafeBankAccount() # 동일한 테스트 수행 threads = [] for _ in range(10): t = threading.Thread(target=safe_account.deposit, args=(100,)) threads.append(t) t.start() for t in threads: t.join() print(f"안전한 계좌 잔액: {safe_account.get_balance()}") if __name__ == "__main__": test_race_condition() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-03 23:11:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;581 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Race Condition" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/race-condition/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>라이브락 (Livelock)</h2></header><div class=entry-content><p>라이브락 (Livelock) 멀티스레딩 환경에서 발생할 수 있는 문제 상황으로, 프로세스나 스레드가 계속 실행 중이지만 실제로는 유용한 작업을 수행하지 못하는 상태
라이브락의 특징: 진행 중 상태: 프로세스나 스레드가 ‘실행 중’ 상태를 유지한다. 무의미한 작업: 실제로는 어떠한 유용한 작업도 수행하지 못한다. 반복적 상태 변경: 특정 조건을 만족시키기 위해 상태를 계속 변경하지만 원하는 결과를 달성하지 못한다. 라이브락과 데드락의 차이: 데드락: 프로세스들이 서로의 자원을 기다리며 완전히 멈춘 상태 라이브락: 프로세스들이 계속 실행되지만 실제로는 진전이 없는 상태 라이브락의 예시: 복도에서 마주친 두 사람: 서로 지나가려고 같은 방향으로 계속 이동하지만 결국 지나가지 못하는 상황 프로세스 간 자원 경쟁: 프로세스 A가 자원 Y를 보유하고 X를 필요로 함 프로세스 B가 자원 X를 보유하고 Y를 필요로 함 두 프로세스가 서로의 자원을 기다리며 계속 상태를 변경하지만 진전이 없음 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import threading import time class Philosopher: def __init__(self, name, left_fork, right_fork): self.name = name self.left_fork = left_fork self.right_fork = right_fork def try_eat(self): while True: # 계속해서 시도 if self.left_fork.acquire(timeout=1): # 왼쪽 포크 잡기 시도 print(f"{self.name}이(가) 왼쪽 포크를 집었습니다") if self.right_fork.acquire(timeout=1): # 오른쪽 포크 잡기 시도 print(f"{self.name}이(가) 식사를 시작합니다") time.sleep(1) # 식사하는 시간 self.right_fork.release() self.left_fork.release() print(f"{self.name}이(가) 포크를 내려놓고 다시 시도합니다") time.sleep(0.1) # 다른 철학자에게 기회를 주기 위한 대기 else: print(f"{self.name}이(가) 포크를 얻지 못해 다시 시도합니다") time.sleep(0.1) # 재시도 전 대기 # 테스트 코드 fork1 = threading.Lock() fork2 = threading.Lock() philosopher1 = Philosopher("철학자1", fork1, fork2) philosopher2 = Philosopher("철학자2", fork2, fork1) # 두 철학자가 동시에 식사하려 시도 t1 = threading.Thread(target=philosopher1.try_eat) t2 = threading.Thread(target=philosopher2.try_eat) t1.start() t2.start() 이 코드에서 두 철학자는 모두 활발히 행동하고 있지만(포크를 집었다 놨다 하면서), 실제로 식사는 하지 못하는 라이브락 상황이 발생할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 09:17:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;550 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 라이브락 (Livelock)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/livelock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Starvation</h2></header><div class=entry-content><p>기아 상태 (Starvation) 운영 체제 및 동시성 프로그래밍에서 중요한 문제로, 특정 프로세스가 필요한 자원을 지속적으로 얻지 못해 실행되지 못하는 상황.
자원 관리 문제로, 낮은 우선순위 프로세스가 높은 우선순위 프로세스에 의해 자원이 계속 점유되어 무기한 대기하는 상황으로 주로 우선순위 기반 스케줄링에서 발생하며, 시스템 성능과 공정성에 부정적인 영향을 미친다.
Source: https://www.javatpoint.com/what-is-starvation-in-operating-system
발생 조건 기아 상태가 발생하기 위한 주요 조건은 다음과 같다:
우선순위 기반 스케줄링: 높은 우선순위 프로세스가 계속 실행되면서 낮은 우선순위 프로세스가 실행되지 못함. 자원 부족: 시스템 자원이 제한적일 때 특정 프로세스가 지속적으로 자원을 얻지 못함. 비공정한 스케줄링 알고리즘: 공정성을 고려하지 않는 알고리즘이 낮은 우선순위 프로세스를 무시함. 임계 구역 점유: 특정 프로세스가 임계 구역을 오래 점유하여 다른 프로세스의 접근을 차단. 해결책 및 방지책 기아 상태를 해결하거나 방지하기 위한 방법은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-03 07:52:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Starvation" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/starvation/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>