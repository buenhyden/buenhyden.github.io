<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Operating System | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,Operating-System,OS"><meta name=description content="운영체제는 컴퓨터 하드웨어 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 시스템 소프트웨어"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Operating System"><meta property="og:description" content="운영체제는 컴퓨터 하드웨어 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 시스템 소프트웨어"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Operating System"><meta name=twitter:description content="운영체제는 컴퓨터 하드웨어 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 시스템 소프트웨어"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Computer System","item":"https://buenhyden.github.io/posts/computer-science/computer-system/"},{"@type":"ListItem","position":4,"name":"Operating System","item":"https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/computer-system/>Computer System</a></div><h1>Operating System</h1><div class=post-description>운영체제는 컴퓨터 하드웨어 자원을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 시스템 소프트웨어</div></header><div class=post-content><h2 id=operating-system>Operating System<a hidden class=anchor aria-hidden=true href=#operating-system>#</a></h2><p>컴퓨터 하드웨어와 소프트웨어 자원을 관리하고 다양한 서비스를 제공하는 소프트웨어.</p><p><figure><img alt="Operating System" loading=lazy src=/img/conceptual_view.jpg><figcaption>Source: https://www.tutorialspoint.com/operating_system/os_overview.htm</figcaption></figure></p><h3 id=특성>특성<a hidden class=anchor aria-hidden=true href=#특성>#</a></h3><ul><li>동시성: 여러 작업을 동시에 처리할 수 있음</li><li>하드웨어 추상화: 하드웨어 세부사항을 숨기고 일관된 인터페이스 제공</li><li>자원 할당: 시스템 자원을 효율적으로 관리하고 할당</li><li>가상화: 가상 메모리와 가상 CPU 생성</li><li>보안: 무단 접근 방지 및 데이터 보호</li><li>결함 허용: 하드웨어 및 소프트웨어 오류 처리</li></ul><h3 id=주요-기능>주요 기능<a hidden class=anchor aria-hidden=true href=#주요-기능>#</a></h3><ul><li>프로세스 관리: 프로세스 생성, 실행, 종료 관리하며 프로세스 간 통신을 지원</li><li>메모리 관리: 메모리 할당 및 해제를 관리하고 가상 메모리를 구현</li><li>파일 시스템 관리: 파일 저장, 검색, 조직화</li><li>장치 관리: 입출력 장치 제어 및 드라이버 관리</li><li>사용자 인터페이스 제공: GUI 또는 CLI 제공</li><li>보안 및 보호: 데이터 및 시스템 보호</li><li>네트워킹: 네트워크 통신 지원</li></ul><h3 id=운영체제의-목적>운영체제의 목적<a hidden class=anchor aria-hidden=true href=#운영체제의-목적>#</a></h3><p>운영체제는 다음과 같은 주요 목적을 가지고 있다:</p><ol><li><strong>사용자 편의성 제공</strong>: 복잡한 하드웨어를 추상화하여 사용하기 쉽게 만든다.</li><li><strong>자원 효율성 최대화</strong>: 시스템 자원을 효율적으로 관리하고 할당한다.</li><li><strong>시스템 신뢰성 보장</strong>: 안정적인 시스템 운영을 보장한다.</li></ol><h3 id=계층적-디자인>계층적 디자인<a hidden class=anchor aria-hidden=true href=#계층적-디자인>#</a></h3><p>운영체제는 다음과 같은 계층 구조로 설계되어 있다:</p><ol><li><strong>하드웨어 계층</strong>: CPU, 메모리, 디스크 등 물리적 자원</li><li><strong>커널 계층</strong>: 운영체제의 핵심 기능을 수행</li><li><strong>시스템 콜 계층</strong>: 사용자 프로그램과 커널 간의 인터페이스</li><li><strong>사용자 계층</strong>: 응용 프로그램과 사용자 인터페이스</li></ol><h3 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h3><p>운영체제의 주요 구성 요소는 다음과 같다:</p><ol><li><strong>커널(Kernel)</strong>: 운영체제의 핵심 부분으로, 자원 관리와 하드웨어 제어를 담당.</li><li><strong>쉘(Shell)</strong>: 사용자와 커널 사이의 인터페이스를 제공.</li><li><strong>파일 시스템</strong>: 데이터의 저장과 관리를 담당.</li><li><strong>장치 드라이버</strong>: 하드웨어 장치와의 통신을 담당.</li></ol><h3 id=운영체제의-유형>운영체제의 유형<a hidden class=anchor aria-hidden=true href=#운영체제의-유형>#</a></h3><ol><li><p>배치 처리 시스템 (Batch Operating System)<br>초기 컴퓨터 시스템에서 사용된 이 방식은 유사한 작업들을 그룹으로 모아서 연속적으로 처리한다.<br>예를 들어, 급여 계산이나 재고 관리와 같은 대량의 반복적인 작업을 처리할 때 효율적이다.<br>사용자와의 상호작용은 최소화되어 있으며, 작업이 시작되면 중간에 개입할 수 없다.</p></li><li><p>멀티프로그래밍 시스템 (Multiprogramming Operating System)<br>CPU 사용률을 최대화하기 위해 여러 프로그램을 메모리에 동시에 유지하면서 실행하는 시스템.<br>한 프로그램이 I/O 작업을 수행할 때 다른 프로그램이 CPU를 사용할 수 있게 하여 자원 활용도를 높인다.</p></li><li><p>멀티프로세싱 시스템 (Multiprocessing Operating System)<br>두 개 이상의 프로세서를 사용하여 병렬 처리를 수행하는 시스템.<br>현대의 대부분의 컴퓨터가 이 방식을 사용하며, 하나의 프로세서가 실패하더라도 시스템이 계속 동작할 수 있는 장점이 있다.</p></li><li><p>멀티태스킹 시스템 (Multitasking Operating System)<br>여러 작업을 동시에 수행하는 것처럼 보이게 하는 시스템.<br>실제로는 CPU가 매우 빠른 속도로 작업들을 번갈아가며 실행한다.<br>현대의 Windows, macOS, Linux가 이에 해당한다.</p></li><li><p>시분할 시스템 (Time-Sharing Operating System)<br>여러 사용자가 동시에 컴퓨터를 사용할 수 있게 하는 시스템.<br>CPU 시간을 작은 단위로 나누어 각 사용자에게 할당한다.<br>초기 메인프레임 컴퓨터에서 많이 사용되었다.</p></li><li><p>분산 운영체제 (Distributed Operating System)<br>여러 컴퓨터의 자원을 네트워크로 연결하여 하나의 시스템처럼 사용할 수 있게 하는 시스템.<br>클라우드 컴퓨팅 환경에서 많이 사용된다.</p></li><li><p>네트워크 운영체제 (Network Operating System)<br>네트워크로 연결된 다른 컴퓨터의 자원을 사용할 수 있게 해주는 시스템.<br>서버-클라이언트 모델을 기반으로 동작한다.</p></li><li><p>실시간 운영체제 (Real-Time Operating System)<br>정해진 시간 내에 작업 완료를 보장하는 시스템.</p></li></ol><h4 id=운영체제-유형-비교>운영체제 유형 비교<a hidden class=anchor aria-hidden=true href=#운영체제-유형-비교>#</a></h4><table><thead><tr><th>운영 체제 유형</th><th>설명</th><th>주요 특징</th><th>장점</th><th>단점</th><th>사용 예시</th></tr></thead><tbody><tr><td>배치 운영 체제</td><td>유사한 작업을 그룹화하여 일괄 처리하는 시스템</td><td>• 작업 그룹화<br>• 순차적 실행<br>• 운영자 개입 최소화</td><td>• 자원 효율성 높음<br>• 대량 작업 처리에 적합</td><td>• 상호작용 부족<br>• 긴 대기 시간</td><td>• 급여 시스템<br>• 은행 거래 명세서 처리</td></tr><tr><td>다중 프로그래밍 운영 체제</td><td>여러 프로그램을 메모리에 동시에 로드하여 실행하는 시스템</td><td>• 동시 프로그램 실행<br>• CPU 활용도 최적화</td><td>• 처리량 증가<br>• 자원 활용도 향상</td><td>• 복잡한 메모리 관리<br>• 프로세스 간 간섭 가능성</td><td>• 서버 환경<br>• 대형 컴퓨터 시스템</td></tr><tr><td>다중 처리 운영 체제</td><td>여러 프로세서를 사용하여 작업을 병렬 처리하는 시스템</td><td>• 병렬 처리<br>• 부하 분산</td><td>• 성능 향상<br>• 신뢰성 증가</td><td>• 복잡한 설계<br>• 높은 구현 비용</td><td>• 슈퍼컴퓨터<br>• 고성능 서버</td></tr><tr><td>다중 작업 운영 체제</td><td>여러 작업을 동시에 실행하는 시스템</td><td>• 작업 전환<br>• 시분할</td><td>• 사용자 반응성 향상<br>• 자원 공유 효율화</td><td>• 컨텍스트 전환 오버헤드<br>• 복잡한 스케줄링</td><td>• 데스크톱 컴퓨터<br>• 워크스테이션</td></tr><tr><td>시분할 운영 체제</td><td>CPU 시간을 여러 사용자나 작업에 분할하여 할당하는 시스템</td><td>• 빠른 응답 시간<br>• 대화형 컴퓨팅</td><td>• 다중 사용자 지원<br>• 자원 공유 효율성</td><td>• 보안 위험<br>• 성능 저하 가능성</td><td>• 클라우드 컴퓨팅 환경<br>• 대학 컴퓨터 실습실</td></tr><tr><td>분산 운영 체제</td><td>네트워크로 연결된 여러 컴퓨터에서 작동하는 시스템</td><td>• 자원 공유<br>• 확장성</td><td>• 높은 신뢰성<br>• 성능 향상</td><td>• 복잡한 구현<br>• 네트워크 의존성</td><td>• 클러스터 컴퓨팅<br>• 그리드 컴퓨팅</td></tr><tr><td>네트워크 운영 체제</td><td>네트워크 자원 관리에 특화된 시스템</td><td>• 네트워크 프로토콜 지원<br>• 원격 접속 기능</td><td>• 자원 공유 용이<br>• 중앙 관리 효율성</td><td>• 네트워크 의존성<br>• 보안 취약점</td><td>• 기업 네트워크<br>• 파일 서버</td></tr><tr><td>실시간 운영 체제</td><td>시간 제약이 엄격한 작업을 처리하는 시스템</td><td>• 빠른 응답 시간<br>• 예측 가능한 동작</td><td>• 높은 신뢰성<br>• 정확한 타이밍</td><td>• 제한된 기능<br>• 복잡한 설계</td><td>• 로봇 제어 시스템<br>• 의료 기기</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상호 배제 (Mutual Exclusion)</h2></header><div class=entry-content><p>상호 배제 (Mutual Exclusion) 여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 메커니즘.
한 번에 하나의 프로세스나 스레드만 임계 영역(critical section)에 진입할 수 있도록 보장하는 기법이다.
필요한 이유:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 상호 배제가 없는 경우의 문제점 class BankAccount: def __init__(self): self.balance = 1000 def withdraw(self, amount): # 다음 세 줄의 작업이 원자적이지 않음 current_balance = self.balance # 잔액 읽기 current_balance = current_balance - amount # 계산 self.balance = current_balance # 결과 저장 # 두 스레드가 동시에 실행되면 문제가 발생할 수 있음 account = BankAccount() # 스레드 1: withdraw(500) # 스레드 2: withdraw(500) # 예상 잔액: 0, 실제 잔액: 500 (잘못된 결과) 목적 데이터 무결성 유지: 여러 프로세스가 동시에 공유 데이터를 수정하는 것을 방지한다. 경쟁 조건(Race Condition) 예방: 프로세스 실행 순서에 따른 결과 불일치를 막는다. 교착 상태(Deadlock)와 기아 상태(Starvation) 방지: 자원 할당의 효율성을 높인다. 구현 방법 잠금(Lock)
가장 기본적인 동기화 메커니즘으로, 한 번에 하나의 스레드만 임계 영역에 접근할 수 있게 한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 07:50:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상호 배제 (Mutual Exclusion)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/mutual-exclusion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기화 (Synchronization)</h2></header><div class=entry-content><p>동기화 (Synchronization) 여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 메커니즘.
동기화란 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하도록 하는 것을 의미한다. 이는 여러 작업 간의 실행 순서와 타이밍을 제어하여 데이터의 일관성을 유지하고 경쟁 상태(Race Condition)를 방지하는 것을 목표로 한다.
동기화의 필요성 동기화가 필요한 주요 이유는 다음과 같다:
데이터 일관성 유지: 여러 프로세스나 스레드가 동시에 같은 데이터에 접근할 때 발생할 수 있는 불일치를 방지한다. 경쟁 상태 방지: 둘 이상의 프로세스가 공유 자원에 동시에 접근하려 할 때 발생할 수 있는 예측 불가능한 결과를 방지한다. 순서 보장: 특정 작업이 다른 작업보다 먼저 실행되어야 하는 경우, 동기화를 통해 실행 순서를 제어할 수 있다. 동기화 메커니즘 동기화를 구현하기 위한 주요 메커니즘은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-02 07:48:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;304 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기화 (Synchronization)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/synchronization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>잠금 (Lock)</h2></header><div class=entry-content><p>잠금 (Lock) 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 기본 요소이다.
임계 영역을 보호하고 한 번에 하나의 스레드만 접근할 수 있도록 한다.
스레드가 임계 영역에 진입하기 전에 lock을 획득(acquire)하고, 임계 영역을 빠져나올 때 lock을 해제(release)한다. 다른 스레드가 이미 lock을 보유하고 있다면, lock을 획득하려는 스레드는 lock이 해제될 때까지 대기한다.
Lock은 두 가지 상태를 가진다:
잠금 해제 상태 (Unlocked): 다른 프로세스나 스레드가 Lock을 획득할 수 있는 상태 잠금 상태 (Locked): 이미 한 프로세스나 스레드가 Lock을 보유하고 있는 상태 작동 방식 Lock 획득 (acquire): 스레드가 임계 영역에 진입하기 전에 lock을 획득합니다. 임계 영역 실행: lock을 획득한 스레드만 임계 영역의 코드를 실행할 수 있습니다. Lock 해제 (release): 임계 영역을 빠져나올 때 lock을 해제합니다. Lock을 사용할 때 고려해야할 사항 Lock의 범위는 가능한 한 작게 유지하여 성능 저하를 최소화한다. Lock을 획득하는 시간을 최소화하여 다른 스레드의 대기 시간을 줄인다. 데드락을 방지하기 위해 Lock 획득 순서를 일관되게 유지한다. 예외 상황에서도 Lock이 올바르게 해제되도록 보장한다. 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import threading class BankAccount: def __init__(self): self.balance = 1000 self.lock = threading.Lock() # Lock 객체 생성 def withdraw(self, amount): # Lock을 획득 시도. 이미 잠겨있다면 획득할 때까지 대기 self.lock.acquire() try: if self.balance >= amount: # 잔액 확인과 차감이 하나의 원자적 작업으로 수행됨 current_balance = self.balance current_balance -= amount self.balance = current_balance print(f"출금 성공: {amount}, 잔액: {self.balance}") else: print("잔액 부족") finally: # 예외가 발생하더라도 반드시 Lock을 해제 self.lock.release() Lock의 유형 공유 락(Shared Lock)과 배타 락(Exclusive Lock) 공유 락(Shared Lock):
여러 스레드가 동시에 리소스를 읽을 수 있지만, 쓰기는 불가능한 락. 읽기 작업에 사용되는 락(Lock) 여러 스레드가 동시에 획득 가능 쓰기 작업을 차단함 배타 락(Exclusive Lock):
한 번에 하나의 스레드만 리소스에 접근할 수 있는 락. 쓰기 작업에 사용되는 락(Lock). 다른 세션의 읽기와 쓰기를 모두 막는다. 데이터 일관성 보장에 유용. 동시성이 낮음. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 import threading from typing import Set, Optional class SharedExclusiveLock: def __init__(self): self._lock = threading.Lock() self._shared_holders: Set[int] = set() # 공유 락을 보유한 스레드들 self._exclusive_holder: Optional[int] = None # 배타 락을 보유한 스레드 self._shared_count = 0 self._condition = threading.Condition(self._lock) def acquire_shared(self) -> bool: """공유 락 획득""" with self._lock: while self._exclusive_holder is not None: self._condition.wait() thread_id = threading.get_ident() self._shared_holders.add(thread_id) self._shared_count += 1 return True def release_shared(self): """공유 락 해제""" with self._lock: thread_id = threading.get_ident() if thread_id not in self._shared_holders: raise RuntimeError("공유 락을 보유하고 있지 않습니다") self._shared_holders.remove(thread_id) self._shared_count -= 1 if self._shared_count == 0: self._condition.notify_all() def acquire_exclusive(self) -> bool: """배타 락 획득""" with self._lock: while self._exclusive_holder is not None or self._shared_count > 0: self._condition.wait() self._exclusive_holder = threading.get_ident() return True def release_exclusive(self): """배타 락 해제""" with self._lock: if self._exclusive_holder != threading.get_ident(): raise RuntimeError("배타 락을 보유하고 있지 않습니다") self._exclusive_holder = None self._condition.notify_all() # 사용 예시 def reader(lock: SharedExclusiveLock, reader_id: int): """읽기 작업을 수행하는 스레드""" print(f"Reader {reader_id} 시작") lock.acquire_shared() try: print(f"Reader {reader_id} 읽기 작업 수행 중…") time.sleep(1) finally: lock.release_shared() print(f"Reader {reader_id} 종료") def writer(lock: SharedExclusiveLock, writer_id: int): """쓰기 작업을 수행하는 스레드""" print(f"Writer {writer_id} 시작") lock.acquire_exclusive() try: print(f"Writer {writer_id} 쓰기 작업 수행 중…") time.sleep(2) finally: lock.release_exclusive() print(f"Writer {writer_id} 종료") 업데이트 락(Update Lock)과 의도 락(Intent Lock) 업데이트 락(Update Lock):
읽기는 허용하지만, 다른 업데이트 락이나 배타 락의 획득을 방지하는 락(Lock). 읽기 작업은 허용하지만 다른 업데이트나 쓰기 작업은 차단. 읽기-쓰기 전환 시 데드락 방지에 유용하다. Conversion Deadlock을 방지하기 위해 사용된다. 수정을 위해 베타 락(Exclusive Lock)을 걸기 전에 사용하는 락(Lock). 의도 락(Intent Lock):
상위 레벨 리소스에 대한 락을 설정하기 전에 사용되는 락. 계층적 락킹 구조에서 사용. 다른 트랜잭션에게 락 의도를 알림. 데이터베이스 시스템에서 주로 사용됨. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import threading from enum import Enum, auto from typing import Dict, Set class LockType(Enum): INTENT_SHARED = auto() INTENT_EXCLUSIVE = auto() UPDATE = auto() SHARED = auto() EXCLUSIVE = auto() class HierarchicalLock: def __init__(self): self._lock = threading.Lock() self._holders: Dict[LockType, Set[int]] = { lock_type: set() for lock_type in LockType } self._condition = threading.Condition(self._lock) def _can_acquire(self, lock_type: LockType, thread_id: int) -> bool: """주어진 락 타입을 획득할 수 있는지 확인""" if lock_type == LockType.UPDATE: # 업데이트 락은 공유 락과 호환되지만 다른 업데이트 락과는 호환되지 않음 return not (self._holders[LockType.EXCLUSIVE] or self._holders[LockType.UPDATE]) elif lock_type == LockType.INTENT_SHARED: # 의도 공유 락은 배타 락과만 충돌 return not self._holders[LockType.EXCLUSIVE] # … 다른 락 타입에 대한 호환성 검사 로직 추가 def acquire(self, lock_type: LockType) -> bool: """락 획득""" with self._lock: thread_id = threading.get_ident() while not self._can_acquire(lock_type, thread_id): self._condition.wait() self._holders[lock_type].add(thread_id) return True def release(self, lock_type: LockType): """락 해제""" with self._lock: thread_id = threading.get_ident() if thread_id not in self._holders[lock_type]: raise RuntimeError(f"{lock_type} 락을 보유하고 있지 않습니다") self._holders[lock_type].remove(thread_id) self._condition.notify_all() 스핀 락 (Spin Lock) 락을 획득할 때까지 계속해서 확인하는 바쁜 대기(busy-waiting) 방식의 락.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:54:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1400 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 잠금 (Lock)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/lock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>임계 영역 (Critical Section)</h2></header><div class=entry-content><p>임계 영역 (Critical Section) 운영체제에서 임계 영역(Critical Section)은 여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역을 말한다.
이는 병렬 컴퓨팅 환경에서 중요한 개념으로, 데이터의 일관성과 무결성을 보장하기 위해 사용된다.
여러 프로세스가 동시에 임계 영역에 진입하면 데이터의 일관성이 깨질 수 있다.
1 2 3 4 5 6 7 8 9 10 # 임계 영역 예시 balance = 1000 # 공유 자원 def withdraw(amount): global balance # 임계 영역 시작 temp = balance temp = temp - amount balance = temp # 임계 영역 종료 임계 영역 문제의 해결 조건 상호 배제(Mutual Exclusion): 한 프로세스가 임계 영역에 있을 때 다른 프로세스는 진입할 수 없다. 진행(Progress): 임계 영역에 있는 프로세스가 없다면, 진입하려는 프로세스가 들어갈 수 있어야 한다. 한정된 대기(Bounded Waiting): 프로세스의 임계 영역 진입은 무한정 연기되어서는 안 된다. 임계 영역 관련 문제와 해결 방법 구분 데드락(Deadlock) 경쟁 상태(Race Condition) 기아 상태(Starvation) 라이브락(Livelock) 정의 두 개 이상의 프로세스가 서로의 자원을 기다리며 영구적으로 블록된 상태 여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상태 특정 프로세스가 필요한 자원을 계속 할당받지 못하는 상태 프로세스들이 서로에게 응답하며 상태는 변하지만 실제 진행은 없는 상태 발생 원인 상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시 충족 공유 자원에 대한 동시 접근, 원자성 결여 부적절한 자원 할당 정책, 우선순위 역전 현상 프로세스들의 과도한 양보, 재귀적 회피 동작 결과 시스템 전체 또는 일부 프로세스의 완전한 정지 데이터 불일치, 예측 불가능한 결과 특정 프로세스의 실행 지연 또는 무한 대기 CPU 자원 소비, 실제 작업 진행 없음 특징 프로세스들이 움직이지 않고 완전히 멈춤 타이밍에 따라 결과가 비결정적 자원 할당의 불공정성 프로세스들이 활발히 상태 변경 해결 방법 프로세스 강제 종료, 자원 선점, 데드락 발생 조건 제거 동기화 메커니즘 사용(뮤텍스, 세마포어 등) 에이징(Aging) 기법 도입, 공정한 스케줄링 무작위 대기 시간 도입, 우선순위 조정 예방 기법 자원 할당 그래프 사용, 자원 순서화, 타임아웃 설정 임계 영역 설정, 원자적 연산 사용 자원 예약 시스템, 우선순위 조정 메커니즘 타임아웃 설정, 재시도 횟수 제한 탐지 방법 자원 할당 그래프 분석, 대기 사이클 검출 데이터 일관성 검사, 로그 분석 자원 할당 통계 모니터링 CPU 사용률 분석, 진행률 모니터링 영향 범위 전체 시스템 또는 관련 프로세스 그룹 공유 자원을 사용하는 프로세스들 특정 프로세스 또는 프로세스 그룹 상호 작용하는 프로세스 그룹 복구 방법 프로세스 재시작, 시스템 재부팅 트랜잭션 롤백, 상태 복원 우선순위 재조정, 자원 재할당 프로세스 재시작 또는 동작 패턴 변경 모니터링 방법 시스템 자원 모니터링, 프로세스 상태 감시 로그 분석, 데이터 정합성 검사 자원 할당 히스토리 분석 CPU 사용률 추적, 진행 상태 모니터링 해결 방법 상호 배제(Mutual Exclusion) 구현:
...</p></div><footer class=entry-footer><span title='2024-10-03 07:49:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;748 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 임계 영역 (Critical Section)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process Synchronization</h2></header><div class=entry-content><p>프로세스 동기화 (Process Synchronization) 여러 프로세스가 공유하는 자원의 일관성을 유지하기 위한 메커니즘.
컴퓨터 시스템에서 여러 프로세스가 공유 자원에 접근할 때 충돌을 방지하고 데이터의 일관성을 유지하기 위해 동기화가 필요하다.
다음 두 가지 목적을 가진다:
실행 순서 제어: 프로세스를 올바른 순서대로 실행하기 상호 배제: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기 필요성 데이터 일관성 유지: 여러 프로세스가 공유 데이터에 동시 접근할 때 발생할 수 있는 예상치 못한 결과를 방지한다. 실행 순서 보장: 특정 프로세스의 실행이 다른 프로세스의 결과에 의존하는 경우, 올바른 순서로 실행되도록 한다. 임계 영역 문제 임계 영역(Critical Section)은 여러 프로세스가 공유하는 데이터를 접근하는 코드 영역을 말한다.
예를 들어, 은행 계좌의 잔액을 수정하는 코드가 임계 영역이 될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 06:22:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;601 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process Synchronization" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동시성 제어 (Concurrency Control)</h2></header><div class=entry-content><p>동시성 제어 (Concurrency Control) 동시성 제어는 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 데이터의 일관성과 무결성을 보장하기 위한 제어 메커니즘.
다중 사용자 환경에서 필수적으로 지원해야 하는 기능으로, 병행제어라고도 한다.
동시성 제어의 중요성 동시성 제어는 다음과 같은 문제를 방지하여 데이터베이스의 무결성을 유지한다:
갱신 손실: 동시에 수행된 갱신 작업으로 인한 데이터 손실 모순성: 일관성 없는 데이터 읽기 연쇄 복귀: 하나의 트랜잭션 실패로 인한 다른 트랜잭션들의 복귀 목적 트랜잭션의 직렬성 보장 데이터의 무결성 및 일관성 유지 시스템 활용도 최대화 (공유도 최대, 응답 시간 최소, 처리량 최대화) 주요 동시성 제어 기법 락킹(Locking) 기법 락킹은 가장 기본적인 동시성 제어 방법으로, 데이터에 접근할 때 잠금을 설정하여 다른 프로세스의 접근을 제한한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 02:47:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;370 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 제어 (Concurrency Control)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/concurrency-control/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 관리 (Memory Management)</h2></header><div class=entry-content><p>메모리 관리 (Memory Management) 운영체제의 핵심 기능 중 하나로, 컴퓨터의 주 메모리를 효율적으로 관리하는 역할을 한다.
목적:
프로세스 간 메모리 할당 및 해제 사용 중인 메모리 공간 추적 메모리 단편화 최소화 주 메모리의 효율적 활용 주요 메모리 관리 기법 페이징 (Paging) 물리 메모리를 고정 크기의 블록(페이지)으로 나눔 프로세스의 가상 주소 공간도 같은 크기의 페이지로 나눔 장점:
외부 단편화 문제 해결, 가상 메모리 구현 용이 단점:
내부 단편화 발생 가능 세그멘테이션 (Segmentation) 프로세스를 논리적 단위(세그먼트)로 나눔 각 세그먼트는 서로 다른 크기를 가질 수 있음 장점:
논리적 분할로 보안성 향상, 공유와 보호 용이 단점:
외부 단편화 발생 가능 가상 메모리 (Virtual Memory) 물리적 메모리보다 큰 주소 공간 제공 하드 디스크를 RAM의 확장으로 사용 장점:
더 큰 프로그램 실행 가능, 멀티태스킹 효율 향상 단점:
물리적 메모리보다 접근 속도 느림 메모리 할당 방식 연속 할당: 프로세스에 연속된 메모리 공간 할당 비연속 할당: 프로세스를 여러 조각으로 나누어 할당 (페이징, 세그멘테이션) 메모리 관리의 주요 문제와 해결 방안 메모리 단편화:
...</p></div><footer class=entry-footer><span title='2024-10-01 17:18:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;259 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 관리 (Memory Management)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/components/memory-mgmt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kernel</h2></header><div class=entry-content><p>커널 (Kernel) 운영 체제의 커널은 컴퓨터 시스템의 핵심 구성 요소로, 하드웨어와 소프트웨어 간의 중개자 역할을 수행하며, 시스템의 가장 핵심적인 기능들을 담당한다.
일반 사용자가 직접 접근할 수 없는 커널은 운영체제의 가장 하위 계층에 위치하여 시스템의 안정성과 보안을 보장한다.
Source: https://linux-kernel-labs.github.io/refs/pull/183/merge/lectures/intro.html
커널은 운영 체제의 핵심으로, 컴퓨터 시스템의 효율적인 운영과 관리를 담당하는 중요한 구성 요소이다.
현대의 복잡한 컴퓨팅 환경에서 커널의 역할은 더욱 중요해지고 있으며, 지속적인 발전과 최적화가 이루어지고 있다.
장점:
하드웨어 자원의 효율적 관리 시스템의 안정성과 보안성 향상 응용 프로그램 개발의 용이성 제공 단점:
...</p></div><footer class=entry-footer><span title='2024-10-01 16:06:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;786 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kernel" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/components/kernel/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux</h2></header><div class=entry-content><p>Linux Roadmap Roadmap - Linux 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-01 15:55:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linux" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/types/linux/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>File System</h2></header><div class=entry-content><p>File System 컴퓨터 운영 체제에서 파일과 데이터를 저장, 관리, 검색하는 데 사용되는 구조
파일 시스템은 물리적 저장 장치에서 파일의 물리적 위치를 관리하고, 파일의 이름, 크기, 속성 등을 포함한 메타데이터를 유지한다.
역할과 필요성:
파일 시스템은 컴퓨터에서 데이터를 체계적으로 저장하고 관리하기 위해 필수적.
초기 컴퓨터에서는 데이터의 양이 적어 파일 시스템이 필요하지 않았지만, 데이터가 증가하면서 효율적인 관리가 필요하게 되었다.
기능 데이터 조직: 파일을 디렉터리 구조로 구성하여 쉽게 탐색할 수 있도록 합니다. 데이터 접근: 특정 파일에 대한 빠르고 효율적인 접근을 지원합니다. 저장 공간 관리: 디스크 공간을 효율적으로 사용하여 중복을 최소화하고 성능을 최적화합니다. 주요 파일 시스템 종류 FAT (File Allocation Table) 특징: 오래된 파일 시스템으로 간단한 구조를 가지고 있으며, 호환성이 높아 다양한 운영 체제에서 사용됩니다. 제한: 단일 파일 크기 제한(4GB) 및 볼륨 크기 제한(2TB)이 있어 대용량 데이터를 처리하는 데는 부적합합니다. NTFS (New Technology File System) 특징: Windows 운영 체제에서 주로 사용되며, 보안, 파일 압축, 대용량 파일 지원 등 고급 기능을 제공합니다. 장점: 데이터 무결성을 위한 저널링 기능과 향상된 보안 기능을 갖추고 있습니다. ext3/ext4 (Extended Filesystem) 특징: 리눅스에서 주로 사용되며, ext3는 저널링을 도입하여 데이터 무결성을 강화했습니다. ext4는 대용량 스토리지 지원과 성능 향상을 제공합니다. 장점: 대용량 데이터 처리에 적합하며, 온라인 상태에서 파일 시스템 확장이 가능합니다. HFS+ 및 APFS (Apple File System) HFS+: macOS에서 사용되며 유니코드 파일명 지원과 대용량 파일 처리를 제공합니다. APFS: 최신 macOS 및 iOS 기기에서 사용되며, 저장 공간 관리와 데이터 무결성을 강화한 최신 파일 시스템입니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-01 08:30:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;223 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to File System" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/components/file-system/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>