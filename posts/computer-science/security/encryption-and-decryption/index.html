<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Encryption and Decryption | hyunyoun's Blog</title>
<meta name=keywords content="Computer-Science,Security,Encryption-and-Decryption,Encryption,Decryption"><meta name=description content="데이터를 보호하기 위한 핵심적인 기술로, 원본 데이터를 알고리즘을 통해 암호문으로 변환하는 과정"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Encryption and Decryption"><meta property="og:description" content="데이터를 보호하기 위한 핵심적인 기술로, 원본 데이터를 알고리즘을 통해 암호문으로 변환하는 과정"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Encryption and Decryption"><meta name=twitter:description content="데이터를 보호하기 위한 핵심적인 기술로, 원본 데이터를 알고리즘을 통해 암호문으로 변환하는 과정"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Security","item":"https://buenhyden.github.io/posts/computer-science/security/"},{"@type":"ListItem","position":4,"name":"Encryption and Decryption","item":"https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/security/>Security</a></div><h1>Encryption and Decryption</h1><div class=post-description>데이터를 보호하기 위한 핵심적인 기술로, 원본 데이터를 알고리즘을 통해 암호문으로 변환하는 과정</div></header><div class=post-content><h2 id=암호화encryption-and-복호화decryption>암호화(Encryption) And 복호화(Decryption)<a hidden class=anchor aria-hidden=true href=#암호화encryption-and-복호화decryption>#</a></h2><p>데이터 보안을 위한 암호화는 중요한 정보를 보호하기 위한 핵심적인 기술<br>정보를 보호하기 위해 평문(일반 텍스트)을 암호문(해독하기 어려운 형태)으로 변환하는 과정.<br>현대 디지털 시대에서 암호화는 개인정보 보호, 데이터 기밀성 유지, 안전한 통신 등을 위한 필수적인 기술.<br>특히 온라인 뱅킹, 전자상거래, 메시징 등에서 중요한 역할을 한다.</p><p>기본 원리:</p><ol><li>암호화(Encryption): 평문을 특정 알고리즘과 키를 사용하여 암호문으로 변환</li><li>복호화(Decryption): 암호문을 올바른 키를 사용하여 다시 평문으로 변환</li></ol><h3 id=암호화의-중요성>암호화의 중요성<a hidden class=anchor aria-hidden=true href=#암호화의-중요성>#</a></h3><ol><li>데이터 보안: 민감한 정보를 무단 접근으로부터 보호합니다.</li><li>프라이버시 보호: 개인정보를 안전하게 유지합니다.</li><li>데이터 무결성: 전송 중 데이터 변조를 방지합니다.</li><li>인증: 통신 당사자의 신원을 확인합니다.</li><li>법규 준수: 많은 산업 분야에서 데이터 암호화가 법적 요구사항입니다.</li></ol><h3 id=암호화-유형>암호화 유형<a hidden class=anchor aria-hidden=true href=#암호화-유형>#</a></h3><ol><li><p>저장 데이터 암호화:</p><ul><li>디스크나 데이터베이스에 저장된 정보를 암호화합니다.</li><li>AES-256과 같은 강력한 알고리즘을 사용합니다.</li></ul></li><li><p>전송 중 데이터 암호화:</p><ul><li>네트워크를 통해 이동하는 데이터를 보호합니다.</li><li>SSL/TLS 프로토콜을 사용합니다.</li></ul></li></ol><h3 id=구현-방법>구현 방법<a hidden class=anchor aria-hidden=true href=#구현-방법>#</a></h3><ol><li><p>클라이언트 측 암호화:</p><ul><li>데이터가 서버에 도달하기 전에 암호화됩니다.</li><li>엔드-투-엔드 보안을 제공합니다.</li></ul></li><li><p>서버 측 암호화:</p><ul><li>서버에서 데이터를 수신한 후 암호화합니다.</li><li>관리가 더 용이할 수 있습니다.</li></ul></li></ol><h3 id=주요-방식>주요 방식<a hidden class=anchor aria-hidden=true href=#주요-방식>#</a></h3><h4 id=대칭키-암호화-symmetric-encryption>대칭키 암호화 (Symmetric Encryption)<a hidden class=anchor aria-hidden=true href=#대칭키-암호화-symmetric-encryption>#</a></h4><p>암호화와 복호화에 동일한 키를 사용하는 암호화 방식.<br>이 방식은 데이터의 기밀성을 보장하기 위해 널리 사용되고 있다.</p><p>특징:</p><ul><li>암호화와 복호화에 같은 키를 사용합니다.</li><li>암호화하는 단위에 따라 스트림 암호와 블록 암호로 나눌 수 있습니다.</li><li>대표적인 알고리즘으로는 AES, DES, SEED 등이 있습니다.</li></ul><p>장점:</p><ol><li>속도: 공개키 암호화 방식에 비해 암호화와 복호화 속도가 매우 빠릅니다.</li><li>효율성: CPU와 메모리 사용량이 적어 대용량 데이터 처리에 적합합니다.</li><li>보안성: 적절히 구현될 경우 매우 안전합니다. 예를 들어, AES-256은 현재 기술로 해독이 거의 불가능합니다.</li></ol><p>단점:</p><ol><li>키 관리의 어려움: 안전한 통신을 위해서는 송신자와 수신자가 동일한 키를 공유해야 합니다.</li><li>키 배포 문제: 키를 안전하게 교환하는 것이 어려울 수 있습니다.</li><li>확장성 제한: 다수의 사용자와 통신할 경우 키 관리가 복잡해집니다.</li></ol><p>사용 사례:</p><ol><li><p>금융 서비스:</p><ul><li>결제 애플리케이션에서 개인식별정보(PII) 보호</li><li>메시지 발신자 인증</li></ul></li><li><p>데이터 저장:</p><ul><li>디스크 전체 암호화 (예: Windows의 BitLocker, OS X의 FileVault)</li></ul></li><li><p>통신 보안:</p><ul><li>SSL/TLS 프로토콜에서 세션 키로 사용</li></ul></li><li><p>클라우드 스토리지:</p><ul><li>저장된 데이터의 암호화</li></ul></li><li><p>메시징 애플리케이션:</p><ul><li>WhatsApp, Signal 등의 엔드-투-엔드 암호화에서 일부 사용</li></ul></li><li><p>정부 기관:</p><ul><li>미국 정부는 기밀 정보 암호화에 AES를 사용</li></ul></li></ol><h4 id=비대칭키-암호화-asymmetric-encryption>비대칭키 암호화 (Asymmetric Encryption)<a hidden class=anchor aria-hidden=true href=#비대칭키-암호화-asymmetric-encryption>#</a></h4><p>공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 키를 사용하는 암호화 방식.</p><p>특징:</p><ol><li>두 개의 키 사용: 공개키와 개인키(비밀키)를 사용합니다.</li><li>키 관계: 공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있습니다.</li><li>키 분배: 공개키는 누구나 접근 가능하지만, 개인키는 소유자만 알고 있어야 합니다.</li><li>수학적 기반: 대부분의 비대칭키 알고리즘은 복잡한 수학적 문제(예: 소인수 분해)에 기반합니다.</li></ol><p>장점:</p><ol><li>보안성 향상: 개인키가 노출되지 않아 대칭키 방식보다 안전합니다.</li><li>키 관리 용이성: 다수의 사용자와 통신할 때 키 관리가 더 쉽습니다.</li><li>인증 및 무결성: 디지털 서명을 통해 송신자 인증과 데이터 무결성 검증이 가능합니다.</li><li>부인 방지: 송신자가 메시지 전송을 부인할 수 없습니다.</li></ol><p>단점:</p><ol><li>처리 속도: 대칭키 암호화에 비해 암호화/복호화 속도가 느립니다.</li><li>리소스 소모: 복잡한 수학적 연산으로 인해 더 많은 컴퓨팅 리소스를 필요로 합니다.</li><li>키 크기: 동일한 보안 수준을 위해 대칭키보다 더 큰 키 크기가 필요합니다.</li></ol><p>사용 사례:</p><ol><li>디지털 서명: 문서의 인증 및 무결성 검증에 사용됩니다.</li><li>이메일 암호화: 안전한 이메일 통신을 위해 사용됩니다.</li><li>SSL/TLS: 웹 통신의 보안을 위해 사용됩니다.</li><li>암호화폐: 비트코인 등의 거래 인증에 사용됩니다.</li><li>키 교환: Diffie-Hellman 알고리즘을 통한 안전한 키 교환에 사용됩니다.</li><li>공개키 기반구조(PKI): 디지털 인증서의 발급 및 관리에 사용됩니다.</li><li>봉투 암호화: 대칭키를 안전하게 전송하기 위해 사용됩니다.</li></ol><h4 id=해시-함수>해시 함수<a hidden class=anchor aria-hidden=true href=#해시-함수>#</a></h4><p>임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수<br>이 함수에 의해 얻어지는 값을 해시 값, 해시 코드, 또는 간단히 해시라고 한다.</p><p>특징:</p><ol><li>결정론적: 같은 입력에 대해 항상 같은 출력을 생성합니다.</li><li>단방향성: 해시 값으로부터 원본 데이터를 복구하는 것이 계산상 불가능합니다.</li><li>고정 길이 출력: 입력 데이터의 길이와 관계없이 항상 고정된 길이의 출력을 생성합니다.</li><li>눈사태 효과: 입력값이 조금만 달라져도 완전히 다른 해시 값을 생성합니다.</li></ol><p>장점:</p><ol><li>빠른 데이터 검색: 해시 테이블을 사용하여 상수 시간에 데이터를 검색할 수 있습니다.</li><li>데이터 무결성 검증: 해시 값을 통해 데이터의 변경 여부를 쉽게 확인할 수 있습니다.</li><li>보안성: 단방향성으로 인해 비밀번호 저장 등 보안 관련 용도로 적합합니다.</li><li>효율적인 데이터 구조: 해시 테이블, 블룸 필터 등 효율적인 데이터 구조를 구현할 수 있습니다.</li></ol><p>단점:</p><ol><li>해시 충돌: 서로 다른 입력이 같은 해시 값을 가질 수 있습니다.</li><li>비가역성: 해시 값으로부터 원본 데이터를 복구할 수 없어, 역방향 검색이 필요한 경우에는 적합하지 않습니다.</li><li>성능 영향: 복잡한 데이터 구조나 대용량 데이터셋의 경우 해시 값 계산이 성능에 영향을 줄 수 있습니다.</li></ol><p>사용 사례:</p><ol><li>비밀번호 저장: 데이터베이스에 비밀번호를 안전하게 저장할 때 사용합니다.</li><li>데이터베이스 인덱싱: 효율적인 데이터 검색을 위해 사용됩니다.</li><li>파일 무결성 검증: 다운로드한 파일이 원본과 동일한지 확인할 때 사용됩니다.</li><li>암호화: 디지털 서명, 메시지 인증 코드(MAC), 키 유도 함수 등에 사용됩니다.</li><li>블록체인: 작업 증명(Proof of Work) 알고리즘 등에 사용됩니다.</li><li>로드 밸런싱: 일관된 해싱 등의 알고리즘에 사용되어 네트워크 요청을 서버에 분산합니다.</li><li>캐싱: 브라우저 캐시 등에서 URL을 키로 사용하여 로컬 저장소를 빠르게 검색합니다.</li><li>컴파일러 작업: 심볼 테이블 구현 등에 사용됩니다.</li></ol><h3 id=모범-사례>모범 사례<a hidden class=anchor aria-hidden=true href=#모범-사례>#</a></h3><ol><li>강력한 암호화 알고리즘 사용</li><li>적절한 키 관리: 암호화 키를 안전하게 저장하고 관리합니다.</li><li>정기적인 암호화 정책 검토 및 업데이트</li><li>최소 권한 원칙 적용: 암호화 키에 대한 접근을 제한합니다.</li><li>데이터 분류: 중요도에 따라 데이터를 분류하고 적절한 수준의 암호화 적용</li></ol><h3 id=클라우드-환경에서의-암호화>클라우드 환경에서의 암호화<a hidden class=anchor aria-hidden=true href=#클라우드-환경에서의-암호화>#</a></h3><ol><li>클라우드 서비스 제공업체의 암호화 기능 활용</li><li>고객 관리 키(CMK) 사용: 자체 암호화 키를 관리하여 보안 강화</li></ol><h3 id=암호화-강도를-높이기-위한-주요-요소>암호화 강도를 높이기 위한 주요 요소<a hidden class=anchor aria-hidden=true href=#암호화-강도를-높이기-위한-주요-요소>#</a></h3><ol><li><p>키 길이 증가:</p><ul><li>대칭키의 경우, 키 길이가 1비트 증가할 때마다 암호화 강도가 2배 증가합니다.</li><li>비대칭키의 경우, 키 길이가 1비트 증가할 때마다 암호화 강도가 약 1.02~1.05배 증가합니다.</li></ul></li><li><p>강력한 암호화 알고리즘 선택:</p><ul><li>AES, RSA, ECC 등 현대적이고 안전한 알고리즘을 사용합니다.</li><li>알고리즘의 보안 강도에 따라 적절한 키 길이를 선택합니다.</li></ul></li><li><p>암호화 모드 최적화:</p><ul><li>CBC, CTR, GCM 등 안전한 블록 암호 운영 모드를 사용합니다.</li><li>특히 GCM은 기밀성과 무결성을 동시에 제공합니다.</li></ul></li><li><p>Nonce 사용:</p><ul><li>각 암호화 프로세스마다 고유하고 예측 불가능한 Nonce를 사용합니다.</li><li>이는 암호화 과정에 무작위성을 추가하여 보안을 강화합니다.</li></ul></li><li><p>라운드 수 증가:</p><ul><li>AES와 같은 알고리즘에서 라운드 수를 늘리면 보안 강도가 향상됩니다.</li></ul></li><li><p>해시 함수 강화:</p><ul><li>암호화된 패스워드 저장 시 안전한 해시 함수를 사용합니다.</li><li>Salting과 key stretching 기법을 적용하여 해시의 보안성을 높입니다.</li></ul></li><li><p>정기적인 키 갱신:</p><ul><li>암호화 키를 주기적으로 변경하여 장기간 사용으로 인한 취약점을 방지합니다.</li></ul></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비대칭키 암호화 (Asymmetric Encryption)</h2></header><div class=entry-content><p>비대칭키 암호화 (Asymmetric Encryption) 비대칭키 암호화는 공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식.
장점:
키 분배가 용이하다 (공개키는 공개적으로 공유 가능) 높은 보안성을 제공한다. 디지털 서명 등 다양한 보안 기능 구현이 가능하다. 단점:
대칭키 암호화에 비해 처리 속도가 느리다. 더 많은 컴퓨팅 자원이 필요하다. 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes class AsymmetricEncryption: def __init__(self): # 키 쌍 생성 self.private_key = rsa.generate_private_key( public_exponent=65537, # 일반적으로 사용되는 공개 지수 key_size=2048 # 보안을 위한 충분한 키 크기 ) # 개인키로부터 공개키 추출 self.public_key = self.private_key.public_key() def encrypt_message(self, message): """공개키로 메시지 암호화""" encrypted = self.public_key.encrypt( message.encode(), padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return encrypted def decrypt_message(self, encrypted_message): """개인키로 메시지 복호화""" decrypted = self.private_key.decrypt( encrypted_message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return decrypted.decode() 주요 특징 키 분배 문제 해결: 안전하지 않은 채널에서도 키를 교환할 수 있다. 높은 보안성: 공개키가 노출되어도 개인키가 안전하면 전체 시스템이 안전하다. 디지털 서명 가능: 메시지의 무결성과 발신자 인증에 사용된다. 느린 처리 속도: 대칭키 암호화에 비해 연산 속도가 느리다. 작동 원리 공개키와 개인키라는 두 개의 키를 사용한다.
공개키로 암호화한 데이터는 개인키로만 복호화할 수 있다.
개인키로 암호화한 데이터는 공개키로만 복호화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:22:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비대칭키 암호화 (Asymmetric Encryption)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/asymmetric-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 함수 (Hash Functions)</h2></header><div class=entry-content><p>해시 함수 (Hash Functions) 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
특징:
일방향성: 해시 값으로부터 원본 데이터를 복구하는 것이 계산상 불가능하다.
1 2 3 4 5 6 7 8 9 10 11 12 13 def demonstrate_one_way(): """해시 함수의 일방향성을 보여주는 함수""" class PasswordManager: def __init__(self): self.password_hash = None def set_password(self, password): # 비밀번호는 해시값으로만 저장 self.password_hash = create_hash(password) def verify_password(self, password): # 입력된 비밀번호의 해시값과 저장된 해시값 비교 return create_hash(password) == self.password_hash 결정성: 같은 입력에 대해 항상 같은 해시 값을 생성한다.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:22:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1804 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 함수 (Hash Functions)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/hash-functions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>대칭키 암호화 (Symmetric Encryption)</h2></header><div class=entry-content><p>대칭키 암호화 (Symmetric Encryption) 대칭키 암호화는 동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식.
구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from cryptography.fernet import Fernet class SymmetricEncryption: def __init__(self): # 대칭키 생성 self.key = Fernet.generate_key() self.cipher_suite = Fernet(self.key) def encrypt(self, data): """데이터 암호화""" if isinstance(data, str): data = data.encode() return self.cipher_suite.encrypt(data) def decrypt(self, encrypted_data): """데이터 복호화""" decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode() # 사용 예시 encryptor = SymmetricEncryption() message = "Hello, World!" encrypted = encryptor.encrypt(message) decrypted = encryptor.decrypt(encrypted) 주요 특징 암호화와 복호화에 같은 키를 사용한다. 혼돈(confusion)과 확산(diffusion)의 원리를 이용하여 평문을 암호화한다. 주로 치환(substitution)과 순열(permutation) 연산을 포함한 라운드를 반복하는 구조로 설계된다. 데이터 변환 방식에 따라 블록 암호와 스트림 암호로 구분된다. 혼돈(confusion)과 확산(diffusion)의 원리 혼돈(confusion)
암호문과 키 사이의 관계를 숨기는 것.
키의 단일 비트 변화가 암호문의 많은 비트를 변화시킴.
주로 치환(substitution) 연산을 통해 달성. 확산(diffusion)
암호문과 평문 사이의 관계를 숨기는 것.
평문의 통계적 특성을 암호문 전체에 분산시킴.
주로 순열(permutation) 연산을 통해 달성. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def confusion_example(input_data, key): # 혼돈(Confusion) 예시: XOR 연산을 사용하여 입력 데이터와 키를 결합 # 각 문자를 키와 XOR 연산하여 암호화 return [chr(ord(char) ^ key) for char in input_data] def diffusion_example(input_data): # 확산(Diffusion) 예시: 간단한 순열 연산을 사용 # 입력 데이터를 뒤집어 확산 효과를 시뮬레이션 return input_data[::-1] # 예시 데이터와 키 input_data = "HELLO" key = 3 # 혼돈 적용 confused_data = confusion_example(input_data, key) # 확산 적용 diffused_data = diffusion_example(confused_data) # 결과 출력 print("원본 데이터:", input_data) print("혼돈 적용 후:", ''.join(confused_data)) print("확산 적용 후:", ''.join(diffused_data)) 라운드 반복 구조 치환과 순열 연산을 포함한 기본 구조(라운드)를 여러 번 반복하는 방식.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:21:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;806 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 대칭키 암호화 (Symmetric Encryption)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/symmetric-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동형 암호화(Homomorphic Encryption)</h2></header><div class=entry-content><p>동형 암호화(Homomorphic Encryption) 동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술.
일반적인 암호화 방식에서는 데이터를 처리하기 위해서는 먼저 복호화를 해야 하지만, 동형 암호화에서는 암호화된 상태 그대로 데이터를 처리할 수 있다.
예를 들어, 두 개의 숫자 3과 4를 동형 암호화했다고 가정해보자.
이 암호화된 값들을 더하면, 그 결과를 복호화했을 때 7(즉, 3+4)이 나오게 된다.
동형 암호화의 종류 부분 동형 암호화(Partial Homomorphic Encryption, PHE):
하나의 연산만 지원(덧셈 또는 곱셈).
- 대표적인 예로 Paillier 암호화(덧셈 지원)와 RSA(곱셈 지원)가 있다.
- 구현이 비교적 간단하고 성능이 우수합니다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:11:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;340 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동형 암호화(Homomorphic Encryption)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/homomorphic-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>양자 암호화(quantum cryptography)</h2></header><div class=entry-content><p>양자 암호화(quantum cryptography) 양자 암호화는 양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술.
전통적인 암호화가 수학적 복잡성에 기반한다면, 양자 암호화는 양자역학의 기본 법칙을 활용하여 이론적으로 해독이 불가능한 보안을 제공한다.
양자 암호화의 핵심 원리 양자 암호화의 가장 중요한 원리는 양자역학의 기본 특성들을 활용한다:
관측 효과: 양자 상태를 측정하면 그 상태가 변화한다. 이는 도청자가 통신을 엿들으려 할 때 필연적으로 흔적을 남기게 됨을 의미한다. 복제 불가능성: 양자 상태는 완벽하게 복제할 수 없다는 ‘양자 복제 불가 정리’를 기반으로 한다. 이는 도청자가 양자 정보를 완벽하게 복사할 수 없음을 보장한다. 중첩 상태: 양자는 동시에 여러 상태를 가질 수 있으며, 측정 전까지는 확률적인 상태로 존재한다. 이러한 특성은 암호키 생성에 활용된다. 양자 암호화의 구현 방식 양자키분배(Quantum Key Distribution, QKD)는 가장 대표적인 양자 암호화 구현 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:11:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 양자 암호화(quantum cryptography)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/quantum-cryptography/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>영지식 증명(Zero-Knowledge Proof, ZKP)</h2></header><div class=entry-content><p>영지식 증명(Zero-Knowledge Proof, ZKP) 영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.
즉, 증명자(Prover)는 검증자(Verifier)에게 자신이 특정 정보를 알고 있다는 것을 증명하되, 그 정보의 내용은 전혀 노출하지 않는다.
쉬운 예시를 들어보자.
색맹이 아닌 사람(증명자)이 색맹인 사람(검증자)에게 두 개의 공이 서로 다른 색이라는 것을 증명하고 싶다고 가정해보자. 검증자는 두 공의 위치를 무작위로 바꾸고, 증명자는 어떤 공이 바뀌었는지 맞춘다.
이 과정을 여러 번 반복하면, 증명자가 실제로 색의 차이를 볼 수 있다는 것이 증명되지만, 각 공이 어떤 색인지는 검증자에게 전혀 알려지지 않는다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:10:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 영지식 증명(Zero-Knowledge Proof, ZKP)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/zero-knowledge-proof/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>디지털 서명 (digital signature)</h2></header><div class=entry-content><p>디지털 서명 (digital signature) 디지털 서명은 전자 문서나 메시지의 진위성, 무결성, 그리고 부인 방지를 보장하기 위해 사용되는 암호화 기술
이는 실제 서명의 디지털 버전으로 볼 수 있다.
장점:
높은 보안성: 암호화 기술을 사용하여 위조가 매우 어렵다. 효율성: 종이 기반 서명에 비해 빠르고 비용 효율적이다. 글로벌 접근성: 지리적 제약 없이 사용 가능하다. 기본 원리 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding, rsa class DigitalSignature: def __init__(self): # 키 쌍 생성 (실제 사용시에는 더 큰 키 크기 사용) self.private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048 ) self.public_key = self.private_key.public_key() def sign_document(self, document): """문서에 대한 디지털 서명 생성""" # 문서의 해시값 계산 후 서명 signature = self.private_key.sign( document.encode(), padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) return signature def verify_signature(self, document, signature): """서명 검증""" try: self.public_key.verify( signature, document.encode(), padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) return True except: return False 주요 특징 인증: 문서나 메시지가 실제로 서명자에 의해 생성되었음을 확인한다. 무결성: 전송 과정에서 데이터가 변경되지 않았음을 보장한다. 부인 방지: 서명자가 나중에 서명 사실을 부인할 수 없게 한다. 작동 과정 해시 생성 단계: 해시 함수를 사용하여 문서의 고유한 해시값을 생성한다.
...</p></div><footer class=entry-footer><span title='2024-11-09 06:16:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;643 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 디지털 서명 (digital signature)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/digital-signature/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>암호화 모드 (Modes of Operation)</h2></header><div class=entry-content><p>암호화 모드 (Modes of Operation) 암호화 모드는 블록 암호를 사용하여 한 블록보다 긴 평문을 안전하게 암호화하는 방법을 정의한다.
블록 암호는 기본적으로 고정된 크기(예: AES의 경우 128비트)의 데이터만 처리할 수 있기 때문에, 더 큰 데이터를 처리하기 위해서는 특별한 운영 모드가 필요하다.
암호화 모드의 중요성 암호화 모드는 블록 암호의 보안성과 효율성을 크게 향상시킨다.
적절한 모드를 선택함으로써 다음과 같은 이점을 얻을 수 있다:
패턴 은닉: CBC, CFB 등의 모드는 평문의 패턴을 숨겨 암호 분석을 어렵게 한다. 오류 전파 제어: OFB, CTR 모드는 오류 전파를 제한하여 데이터 손상을 최소화한다. 병렬 처리: ECB, CTR 모드는 병렬 처리를 통해 암호화 속도를 향상시킨다. 스트리밍 지원: CFB, OFB, CTR 모드는 스트림 암호처럼 사용할 수 있어 실시간 데이터 처리에 적합하다. 주요 암호화 모드와 특징 ECB (Electronic Codebook) 모드 작동 방식:
...</p></div><footer class=entry-footer><span title='2024-11-08 13:53:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;469 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 암호화 모드 (Modes of Operation)" href=https://buenhyden.github.io/posts/computer-science/security/encryption-and-decryption/modes-of-operation/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>