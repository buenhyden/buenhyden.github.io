<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Native Compiler vs Cross Compiler | hyunyoun's Blog</title>
<meta name=keywords content="Programming-Languages,Fundamentals,Compiler,Native-Compiler,Cross-Compiler"><meta name=description content="Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/native-compiler-vs-cross-compiler/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/native-compiler-vs-cross-compiler/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/native-compiler-vs-cross-compiler/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Native Compiler vs Cross Compiler"><meta property="og:description" content="Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-14T03:33:00+00:00"><meta property="article:modified_time" content="2024-10-14T03:33:00+00:00"><meta property="article:tag" content="Programming-Languages"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Compiler"><meta property="article:tag" content="Native-Compiler"><meta property="article:tag" content="Cross-Compiler"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Native Compiler vs Cross Compiler"><meta name=twitter:description content="Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":4,"name":"언어 프로세서(Language Processor)","item":"https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/"},{"@type":"ListItem","position":5,"name":"컴파일러(Compiler)","item":"https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/"},{"@type":"ListItem","position":6,"name":"Native Compiler vs Cross Compiler","item":"https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/native-compiler-vs-cross-compiler/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Native Compiler vs Cross Compiler","name":"Native Compiler vs Cross Compiler","description":"Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.","keywords":["Programming-Languages","Fundamentals","Compiler","Native-Compiler","Cross-Compiler"],"articleBody":"Native Compiler vs. Cross Compiler Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.\nNative Compiler는 컴파일러가 실행되는 동일한 시스템의 하드웨어와 운영체제에 최적화된 코드를 생성한다. Cross Compiler는 호스트 시스템에서 실행되지만 다른 플랫폼(즉, 대상 시스템)에서 실행될 코드를 생성한다. 네이티브 컴파일러(Native Compiler)의 이해 네이티브 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 동일한 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자가 사용하는 컴퓨터와 동일한 운영체제 및 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.\n네이티브 컴파일러의 작동 방식 네이티브 컴파일러의 기본적인 작동 과정은 다음과 같다:\n소스 코드 분석: 프로그래밍 언어로 작성된 소스 코드를 파싱하여 구문 분석한다. 중간 표현 생성: 소스 코드를 컴파일러 내부에서 다루기 쉬운 중간 표현(IR)으로 변환한다. 최적화: 다양한 최적화 기법을 적용하여 코드 효율성을 향상시킨다. 코드 생성: 최적화된 중간 표현을 호스트 시스템(개발자의 컴퓨터)과 동일한 아키텍처를 위한 기계어로 변환한다. 링킹: 생성된 목적 파일을 필요한 라이브러리와 링크하여 최종 실행 파일을 생성한다. 네이티브 컴파일러의 장단점 장점 간편한 설정과 사용: 일반적으로 설치가 쉽고, 추가적인 복잡한 설정이 필요 없다. 즉각적인 테스트 가능: 컴파일된 프로그램을 바로 실행하고 테스트할 수 있다. 효율적인 디버깅: 실시간으로 프로그램을 디버깅할 수 있어 문제 해결이 용이하다. 시스템 리소스 직접 접근: 호스트 시스템의 리소스와 기능을 직접적으로 활용할 수 있다. 개발 생산성: 빠른 컴파일-실행-디버그 사이클로 개발 생산성이 향상된다. 한계 제한된 타겟 범위: 개발 시스템과 다른 환경을 위한 코드를 생성할 수 없다. 이식성 문제: 다른 아키텍처나 운영체제용 소프트웨어 개발이 어렵다. 특수 하드웨어 활용 제한: 개발 시스템에 없는 특수 하드웨어 기능을 활용하기 어렵다. 대표적인 네이티브 컴파일러 GCC(GNU Compiler Collection): Linux 및 Unix 환경에서 널리 사용되는 오픈 소스 컴파일러 모음. Clang/LLVM: 모듈식 아키텍처를 갖춘 현대적인 컴파일러 인프라스트럭처. Microsoft Visual C++ Compiler(MSVC): Windows 환경에서 주로 사용되는 C/C++ 컴파일러. Intel C++ Compiler: Intel 프로세서에서 최적의 성능을 발휘하도록 최적화된 컴파일러. 네이티브 컴파일러의 응용 분야 데스크톱 애플리케이션 개발: Windows, macOS, Linux용 애플리케이션 개발에 널리 사용된다. 서버 소프트웨어 개발: 서버에서 실행될 고성능 소프트웨어 개발에 사용된다. 개발 도구 및 유틸리티: 개발 환경에서 사용되는 도구와 유틸리티 개발에 적합하다. 성능 중심 애플리케이션: 게임 엔진, 과학 계산, 데이터베이스 등 성능이 중요한 응용 프로그램 개발에 사용된다. 교육 및 학습: 프로그래밍 교육과 학습에 적합한 환경을 제공한다. 네이티브 컴파일러 사용 시나리오 웹 브라우저 개발: Firefox, Chrome 등의 웹 브라우저는 각 플랫폼에 맞는 네이티브 컴파일러로 빌드된다. 데이터베이스 시스템: MySQL, PostgreSQL 등은 실행 환경에 맞는 네이티브 컴파일러로 빌드된다. 개발 IDE: Visual Studio, Eclipse 등 개발 도구 자체도 네이티브 컴파일러로 빌드된다. 크로스 컴파일러(Cross Compiler) 크로스 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 다른 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자의 컴퓨터와 다른 운영체제나 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.\n크로스 컴파일러의 작동 방식 크로스 컴파일러의 기본적인 작동 과정은 다음과 같다:\n소스 코드 분석: 네이티브 컴파일러와 동일하게 소스 코드를 파싱한다. 중간 표현 생성: 소스 코드를 중간 표현으로 변환한다. 최적화: 타겟 시스템을 고려한 최적화를 적용한다. 타겟 코드 생성: 최적화된 중간 표현을 타겟 시스템(호스트와 다른 시스템)의 아키텍처에 맞는 기계어로 변환한다. 타겟 링킹: 타겟 시스템에 맞는 라이브러리와 링크하여 타겟 환경에서 실행 가능한 파일을 생성한다. 크로스 컴파일러의 구성 요소 크로스 컴파일러는 일반적으로 다음과 같은 구성 요소를 포함하는 도구체인(toolchain)의 형태로 제공된다:\n바이너리 유틸리티(Binutils): 어셈블러, 링커, 기타 바이너리 파일 조작 도구를 포함한다. 컴파일러 프론트엔드: 소스 코드를 파싱하고 중간 표현을 생성하는 부분. 타겟 코드 생성기: 타겟 아키텍처에 맞는 코드를 생성한다. 타겟 표준 라이브러리: 타겟 시스템에서 필요한 표준 라이브러리. 타겟 시스템 헤더 파일: 타겟 시스템의 API와 시스템 콜을 정의하는 헤더 파일. 크로스 컴파일러의 장단점 장점 플랫폼 이식성: 다양한 타겟 플랫폼을 위한 소프트웨어 개발이 가능하다. 리소스 제한 극복: 타겟 시스템의 제한된 리소스에서 직접 컴파일하기 어려운 경우에 유용하다. 개발 환경 통합: 강력한 개발 환경에서 제한된 타겟 시스템을 위한 코드를 개발할 수 있다. 배치 빌드 및 자동화: CI/CD 파이프라인에서 다양한 타겟 플랫폼을 위한 빌드를 자동화할 수 있다. 최적화 가능성: 타겟 플랫폼에 맞춘 세밀한 최적화가 가능하다. 도전 과제 복잡한 설정: 타겟 시스템에 맞는 도구체인 설정이 복잡할 수 있다. 디버깅 어려움: 타겟 시스템에서의 디버깅이 직접적으로 어렵다. 라이브러리 의존성 관리: 타겟 시스템에 맞는 라이브러리 찾기와 관리가 어려울 수 있다. 플랫폼 특화 문제: 엔디안, 메모리 정렬, 데이터 타입 크기 등 플랫폼 간 차이를 고려해야 한다. 테스트 제한: 실제 타겟 하드웨어나 에뮬레이터 없이는 완전한 테스트가 어렵다. 대표적인 크로스 컴파일러 Arm GNU Toolchain: ARM 프로세서를 위한 GCC 기반 크로스 컴파일러. Android NDK(Native Development Kit): Android 기기를 위한 네이티브 코드 개발 도구. MinGW(Minimalist GNU for Windows): Linux에서 Windows 실행 파일을 생성할 수 있는 도구. Xcode Cross Compilers: macOS에서 iOS, watchOS 등을 위한 코드를 개발할 수 있는 도구. RISC-V GNU Toolchain: RISC-V 아키텍처를 위한 크로스 컴파일러. 크로스 컴파일러의 응용 분야 임베디드 시스템 개발: 리소스가 제한된 임베디드 기기를 위한 펌웨어와 소프트웨어 개발에 필수적이다. 모바일 애플리케이션 개발: Android, iOS 등 모바일 플랫폼의 네이티브 애플리케이션 개발에 사용된다. IoT(Internet of Things) 개발: 다양한 IoT 기기를 위한 소프트웨어 개발에 활용된다. 게임 콘솔 소프트웨어: PlayStation, Xbox, Nintendo Switch 등 게임 콘솔용 소프트웨어 개발에 사용된다. 이기종 컴퓨팅 환경: GPU, FPGA 등 특수 하드웨어를 위한 코드 개발에 활용된다. 레거시 시스템 지원: 오래된 또는 특수 목적 하드웨어를 위한 소프트웨어 유지보수에 사용된다. 크로스 컴파일러 사용 시나리오 라즈베리 파이 애플리케이션: x86 PC에서 ARM 기반 라즈베리 파이를 위한 코드를 개발한다. 스마트워치 소프트웨어: 데스크톱 환경에서 저전력 임베디드 프로세서용 코드를 개발한다. 산업용 제어 시스템: 강력한 개발 환경에서 특수 목적 제어 시스템용 소프트웨어를 개발한다. 자율주행차 소프트웨어: 다양한 임베디드 컨트롤러와 센서 시스템을 위한 코드를 통합 개발한다. 네이티브 컴파일러와 크로스 컴파일러 비교 분석 특성 네이티브 컴파일러 (Native Compiler) 크로스 컴파일러 (Cross Compiler) 정의 실행 환경과 동일한 환경에서 실행되는 컴파일러 실행 환경과 다른 환경을 위한 코드를 생성하는 컴파일러 실행 환경 호스트 시스템 = 타겟 시스템 호스트 시스템 ≠ 타겟 시스템 주요 용도 일반적인 애플리케이션 개발, 데스크톱 소프트웨어 임베디드 시스템, 모바일 기기, IoT 기기, 게임 콘솔 개발 개발 편의성 높음 (즉시 컴파일 및 실행 가능) 중간~낮음 (타겟 환경에서 테스트 어려움) 디버깅 용이성 높음 (실시간 디버깅 용이) 낮음 (원격 디버깅 또는 에뮬레이터 필요) 설정 복잡성 낮음 (기본 설치로 충분한 경우 많음) 높음 (도구체인, 라이브러리, 헤더 파일 설정 필요) 빌드 속도 일반적으로 빠름 환경 설정에 따라 다양함 (때로는 더 느림) 시스템 자원 접근 직접 접근 가능 제한적 (타겟 시스템 특성 고려 필요) 라이브러리 의존성 호스트 시스템 라이브러리 사용 타겟 시스템용 라이브러리 필요 (크로스 컴파일된) 바이너리 크기 최적화 제한적 (호스트 시스템 최적화 중심) 우수함 (타겟 시스템에 맞춤 최적화 가능) 컴파일러 구성 단일 아키텍처 지원 다중 아키텍처 지원 (설정에 따라) 헤더/라이브러리 경로 표준 경로 사용 타겟 시스템용 별도 경로 지정 필요 도구체인 구성 단순함 복잡함 (타겟 아키텍처별 도구체인 필요) 메모리 모델 처리 호스트와 동일 (고려 불필요) 타겟 시스템 메모리 모델 고려 필요 (엔디안, 정렬 등) 인라인 어셈블리 호스트 아키텍처 명령어 사용 타겟 아키텍처 명령어 사용 시스템 콜 인터페이스 호스트 OS와 동일 타겟 OS에 맞게 조정 필요 부동소수점 처리 호스트 하드웨어 사용 타겟 하드웨어 특성 고려 필요 설치 난이도 낮음 높음 (여러 도구와 의존성 설정 필요) CI/CD 통합 쉬움 복잡함 (특수 설정 필요) 대표적 사용 사례 데스크톱 애플리케이션, 서버 소프트웨어 임베디드 펌웨어, 모바일 앱, 콘솔 게임, IoT 기기 예시 도구 GCC, Clang, MSVC (동일 플랫폼용) Arm GNU 툴체인, MinGW, Android NDK 참고 및 출처 ","wordCount":"1097","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-14T03:33:00Z","dateModified":"2024-10-14T03:33:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/native-compiler-vs-cross-compiler/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>컴퓨터 과학</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/>언어 프로세서(Language Processor)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/>컴파일러(Compiler)</a></div><h1 class="post-title entry-hint-parent">Native Compiler vs Cross Compiler</h1><div class=post-description>Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.</div><div class=post-meta><span title='2024-10-14 03:33:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science/Compilers%20and%20Programming%20Language%20Theory/Language%20Processor/Compiler/native-compiler-vs-cross-compiler.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#native-compiler-vs-cross-compiler>Native Compiler vs. Cross Compiler</a><ul><li><a href=#네이티브-컴파일러native-compiler의-이해>네이티브 컴파일러(Native Compiler)의 이해</a></li><li><a href=#크로스-컴파일러cross-compiler>크로스 컴파일러(Cross Compiler)</a></li><li><a href=#네이티브-컴파일러와-크로스-컴파일러-비교-분석>네이티브 컴파일러와 크로스 컴파일러 비교 분석</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=native-compiler-vs-cross-compiler>Native Compiler vs. Cross Compiler<a hidden class=anchor aria-hidden=true href=#native-compiler-vs-cross-compiler>#</a></h2><p>Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.</p><ul><li>Native Compiler는 컴파일러가 실행되는 동일한 시스템의 하드웨어와 운영체제에 최적화된 코드를 생성한다.</li><li>Cross Compiler는 호스트 시스템에서 실행되지만 다른 플랫폼(즉, 대상 시스템)에서 실행될 코드를 생성한다.</li></ul><h3 id=네이티브-컴파일러native-compiler의-이해>네이티브 컴파일러(Native Compiler)의 이해<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러native-compiler의-이해>#</a></h3><p>네이티브 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 동일한 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자가 사용하는 컴퓨터와 동일한 운영체제 및 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.</p><h4 id=네이티브-컴파일러의-작동-방식>네이티브 컴파일러의 작동 방식<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-작동-방식>#</a></h4><p>네이티브 컴파일러의 기본적인 작동 과정은 다음과 같다:</p><ol><li><strong>소스 코드 분석</strong>: 프로그래밍 언어로 작성된 소스 코드를 파싱하여 구문 분석한다.</li><li><strong>중간 표현 생성</strong>: 소스 코드를 컴파일러 내부에서 다루기 쉬운 중간 표현(IR)으로 변환한다.</li><li><strong>최적화</strong>: 다양한 최적화 기법을 적용하여 코드 효율성을 향상시킨다.</li><li><strong>코드 생성</strong>: 최적화된 중간 표현을 호스트 시스템(개발자의 컴퓨터)과 동일한 아키텍처를 위한 기계어로 변환한다.</li><li><strong>링킹</strong>: 생성된 목적 파일을 필요한 라이브러리와 링크하여 최종 실행 파일을 생성한다.</li></ol><h4 id=네이티브-컴파일러의-장단점>네이티브 컴파일러의 장단점<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-장단점>#</a></h4><h5 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h5><ol><li><strong>간편한 설정과 사용</strong>: 일반적으로 설치가 쉽고, 추가적인 복잡한 설정이 필요 없다.</li><li><strong>즉각적인 테스트 가능</strong>: 컴파일된 프로그램을 바로 실행하고 테스트할 수 있다.</li><li><strong>효율적인 디버깅</strong>: 실시간으로 프로그램을 디버깅할 수 있어 문제 해결이 용이하다.</li><li><strong>시스템 리소스 직접 접근</strong>: 호스트 시스템의 리소스와 기능을 직접적으로 활용할 수 있다.</li><li><strong>개발 생산성</strong>: 빠른 컴파일-실행-디버그 사이클로 개발 생산성이 향상된다.</li></ol><h5 id=한계>한계<a hidden class=anchor aria-hidden=true href=#한계>#</a></h5><ol><li><strong>제한된 타겟 범위</strong>: 개발 시스템과 다른 환경을 위한 코드를 생성할 수 없다.</li><li><strong>이식성 문제</strong>: 다른 아키텍처나 운영체제용 소프트웨어 개발이 어렵다.</li><li><strong>특수 하드웨어 활용 제한</strong>: 개발 시스템에 없는 특수 하드웨어 기능을 활용하기 어렵다.</li></ol><h4 id=대표적인-네이티브-컴파일러>대표적인 네이티브 컴파일러<a hidden class=anchor aria-hidden=true href=#대표적인-네이티브-컴파일러>#</a></h4><ol><li><strong>GCC(GNU Compiler Collection)</strong>: Linux 및 Unix 환경에서 널리 사용되는 오픈 소스 컴파일러 모음.</li><li><strong>Clang/LLVM</strong>: 모듈식 아키텍처를 갖춘 현대적인 컴파일러 인프라스트럭처.</li><li><strong>Microsoft Visual C++ Compiler(MSVC)</strong>: Windows 환경에서 주로 사용되는 C/C++ 컴파일러.</li><li><strong>Intel C++ Compiler</strong>: Intel 프로세서에서 최적의 성능을 발휘하도록 최적화된 컴파일러.</li></ol><h4 id=네이티브-컴파일러의-응용-분야>네이티브 컴파일러의 응용 분야<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러의-응용-분야>#</a></h4><ol><li><strong>데스크톱 애플리케이션 개발</strong>: Windows, macOS, Linux용 애플리케이션 개발에 널리 사용된다.</li><li><strong>서버 소프트웨어 개발</strong>: 서버에서 실행될 고성능 소프트웨어 개발에 사용된다.</li><li><strong>개발 도구 및 유틸리티</strong>: 개발 환경에서 사용되는 도구와 유틸리티 개발에 적합하다.</li><li><strong>성능 중심 애플리케이션</strong>: 게임 엔진, 과학 계산, 데이터베이스 등 성능이 중요한 응용 프로그램 개발에 사용된다.</li><li><strong>교육 및 학습</strong>: 프로그래밍 교육과 학습에 적합한 환경을 제공한다.</li></ol><h4 id=네이티브-컴파일러-사용-시나리오>네이티브 컴파일러 사용 시나리오<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러-사용-시나리오>#</a></h4><ol><li><strong>웹 브라우저 개발</strong>: Firefox, Chrome 등의 웹 브라우저는 각 플랫폼에 맞는 네이티브 컴파일러로 빌드된다.</li><li><strong>데이터베이스 시스템</strong>: MySQL, PostgreSQL 등은 실행 환경에 맞는 네이티브 컴파일러로 빌드된다.</li><li><strong>개발 IDE</strong>: Visual Studio, Eclipse 등 개발 도구 자체도 네이티브 컴파일러로 빌드된다.</li></ol><h3 id=크로스-컴파일러cross-compiler>크로스 컴파일러(Cross Compiler)<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러cross-compiler>#</a></h3><p>크로스 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 다른 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자의 컴퓨터와 다른 운영체제나 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.</p><h4 id=크로스-컴파일러의-작동-방식>크로스 컴파일러의 작동 방식<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-작동-방식>#</a></h4><p>크로스 컴파일러의 기본적인 작동 과정은 다음과 같다:</p><ol><li><strong>소스 코드 분석</strong>: 네이티브 컴파일러와 동일하게 소스 코드를 파싱한다.</li><li><strong>중간 표현 생성</strong>: 소스 코드를 중간 표현으로 변환한다.</li><li><strong>최적화</strong>: 타겟 시스템을 고려한 최적화를 적용한다.</li><li><strong>타겟 코드 생성</strong>: 최적화된 중간 표현을 타겟 시스템(호스트와 다른 시스템)의 아키텍처에 맞는 기계어로 변환한다.</li><li><strong>타겟 링킹</strong>: 타겟 시스템에 맞는 라이브러리와 링크하여 타겟 환경에서 실행 가능한 파일을 생성한다.</li></ol><h4 id=크로스-컴파일러의-구성-요소>크로스 컴파일러의 구성 요소<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-구성-요소>#</a></h4><p>크로스 컴파일러는 일반적으로 다음과 같은 구성 요소를 포함하는 도구체인(toolchain)의 형태로 제공된다:</p><ol><li><strong>바이너리 유틸리티(Binutils)</strong>: 어셈블러, 링커, 기타 바이너리 파일 조작 도구를 포함한다.</li><li><strong>컴파일러 프론트엔드</strong>: 소스 코드를 파싱하고 중간 표현을 생성하는 부분.</li><li><strong>타겟 코드 생성기</strong>: 타겟 아키텍처에 맞는 코드를 생성한다.</li><li><strong>타겟 표준 라이브러리</strong>: 타겟 시스템에서 필요한 표준 라이브러리.</li><li><strong>타겟 시스템 헤더 파일</strong>: 타겟 시스템의 API와 시스템 콜을 정의하는 헤더 파일.</li></ol><h4 id=크로스-컴파일러의-장단점>크로스 컴파일러의 장단점<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-장단점>#</a></h4><h5 id=장점-1>장점<a hidden class=anchor aria-hidden=true href=#장점-1>#</a></h5><ol><li><strong>플랫폼 이식성</strong>: 다양한 타겟 플랫폼을 위한 소프트웨어 개발이 가능하다.</li><li><strong>리소스 제한 극복</strong>: 타겟 시스템의 제한된 리소스에서 직접 컴파일하기 어려운 경우에 유용하다.</li><li><strong>개발 환경 통합</strong>: 강력한 개발 환경에서 제한된 타겟 시스템을 위한 코드를 개발할 수 있다.</li><li><strong>배치 빌드 및 자동화</strong>: CI/CD 파이프라인에서 다양한 타겟 플랫폼을 위한 빌드를 자동화할 수 있다.</li><li><strong>최적화 가능성</strong>: 타겟 플랫폼에 맞춘 세밀한 최적화가 가능하다.</li></ol><h5 id=도전-과제>도전 과제<a hidden class=anchor aria-hidden=true href=#도전-과제>#</a></h5><ol><li><strong>복잡한 설정</strong>: 타겟 시스템에 맞는 도구체인 설정이 복잡할 수 있다.</li><li><strong>디버깅 어려움</strong>: 타겟 시스템에서의 디버깅이 직접적으로 어렵다.</li><li><strong>라이브러리 의존성 관리</strong>: 타겟 시스템에 맞는 라이브러리 찾기와 관리가 어려울 수 있다.</li><li><strong>플랫폼 특화 문제</strong>: 엔디안, 메모리 정렬, 데이터 타입 크기 등 플랫폼 간 차이를 고려해야 한다.</li><li><strong>테스트 제한</strong>: 실제 타겟 하드웨어나 에뮬레이터 없이는 완전한 테스트가 어렵다.</li></ol><h4 id=대표적인-크로스-컴파일러>대표적인 크로스 컴파일러<a hidden class=anchor aria-hidden=true href=#대표적인-크로스-컴파일러>#</a></h4><ol><li><strong>Arm GNU Toolchain</strong>: ARM 프로세서를 위한 GCC 기반 크로스 컴파일러.</li><li><strong>Android NDK(Native Development Kit)</strong>: Android 기기를 위한 네이티브 코드 개발 도구.</li><li><strong>MinGW(Minimalist GNU for Windows)</strong>: Linux에서 Windows 실행 파일을 생성할 수 있는 도구.</li><li><strong>Xcode Cross Compilers</strong>: macOS에서 iOS, watchOS 등을 위한 코드를 개발할 수 있는 도구.</li><li><strong>RISC-V GNU Toolchain</strong>: RISC-V 아키텍처를 위한 크로스 컴파일러.</li></ol><h4 id=크로스-컴파일러의-응용-분야>크로스 컴파일러의 응용 분야<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러의-응용-분야>#</a></h4><ol><li><strong>임베디드 시스템 개발</strong>: 리소스가 제한된 임베디드 기기를 위한 펌웨어와 소프트웨어 개발에 필수적이다.</li><li><strong>모바일 애플리케이션 개발</strong>: Android, iOS 등 모바일 플랫폼의 네이티브 애플리케이션 개발에 사용된다.</li><li><strong>IoT(Internet of Things) 개발</strong>: 다양한 IoT 기기를 위한 소프트웨어 개발에 활용된다.</li><li><strong>게임 콘솔 소프트웨어</strong>: PlayStation, Xbox, Nintendo Switch 등 게임 콘솔용 소프트웨어 개발에 사용된다.</li><li><strong>이기종 컴퓨팅 환경</strong>: GPU, FPGA 등 특수 하드웨어를 위한 코드 개발에 활용된다.</li><li><strong>레거시 시스템 지원</strong>: 오래된 또는 특수 목적 하드웨어를 위한 소프트웨어 유지보수에 사용된다.</li></ol><h4 id=크로스-컴파일러-사용-시나리오>크로스 컴파일러 사용 시나리오<a hidden class=anchor aria-hidden=true href=#크로스-컴파일러-사용-시나리오>#</a></h4><ol><li><strong>라즈베리 파이 애플리케이션</strong>: x86 PC에서 ARM 기반 라즈베리 파이를 위한 코드를 개발한다.</li><li><strong>스마트워치 소프트웨어</strong>: 데스크톱 환경에서 저전력 임베디드 프로세서용 코드를 개발한다.</li><li><strong>산업용 제어 시스템</strong>: 강력한 개발 환경에서 특수 목적 제어 시스템용 소프트웨어를 개발한다.</li><li><strong>자율주행차 소프트웨어</strong>: 다양한 임베디드 컨트롤러와 센서 시스템을 위한 코드를 통합 개발한다.</li></ol><h3 id=네이티브-컴파일러와-크로스-컴파일러-비교-분석>네이티브 컴파일러와 크로스 컴파일러 비교 분석<a hidden class=anchor aria-hidden=true href=#네이티브-컴파일러와-크로스-컴파일러-비교-분석>#</a></h3><table><thead><tr><th>특성</th><th>네이티브 컴파일러 (Native Compiler)</th><th>크로스 컴파일러 (Cross Compiler)</th></tr></thead><tbody><tr><td><strong>정의</strong></td><td>실행 환경과 동일한 환경에서 실행되는 컴파일러</td><td>실행 환경과 다른 환경을 위한 코드를 생성하는 컴파일러</td></tr><tr><td><strong>실행 환경</strong></td><td>호스트 시스템 = 타겟 시스템</td><td>호스트 시스템 ≠ 타겟 시스템</td></tr><tr><td><strong>주요 용도</strong></td><td>일반적인 애플리케이션 개발, 데스크톱 소프트웨어</td><td>임베디드 시스템, 모바일 기기, IoT 기기, 게임 콘솔 개발</td></tr><tr><td><strong>개발 편의성</strong></td><td>높음 (즉시 컴파일 및 실행 가능)</td><td>중간~낮음 (타겟 환경에서 테스트 어려움)</td></tr><tr><td><strong>디버깅 용이성</strong></td><td>높음 (실시간 디버깅 용이)</td><td>낮음 (원격 디버깅 또는 에뮬레이터 필요)</td></tr><tr><td><strong>설정 복잡성</strong></td><td>낮음 (기본 설치로 충분한 경우 많음)</td><td>높음 (도구체인, 라이브러리, 헤더 파일 설정 필요)</td></tr><tr><td><strong>빌드 속도</strong></td><td>일반적으로 빠름</td><td>환경 설정에 따라 다양함 (때로는 더 느림)</td></tr><tr><td><strong>시스템 자원 접근</strong></td><td>직접 접근 가능</td><td>제한적 (타겟 시스템 특성 고려 필요)</td></tr><tr><td><strong>라이브러리 의존성</strong></td><td>호스트 시스템 라이브러리 사용</td><td>타겟 시스템용 라이브러리 필요 (크로스 컴파일된)</td></tr><tr><td><strong>바이너리 크기 최적화</strong></td><td>제한적 (호스트 시스템 최적화 중심)</td><td>우수함 (타겟 시스템에 맞춤 최적화 가능)</td></tr><tr><td><strong>컴파일러 구성</strong></td><td>단일 아키텍처 지원</td><td>다중 아키텍처 지원 (설정에 따라)</td></tr><tr><td><strong>헤더/라이브러리 경로</strong></td><td>표준 경로 사용</td><td>타겟 시스템용 별도 경로 지정 필요</td></tr><tr><td><strong>도구체인 구성</strong></td><td>단순함</td><td>복잡함 (타겟 아키텍처별 도구체인 필요)</td></tr><tr><td><strong>메모리 모델 처리</strong></td><td>호스트와 동일 (고려 불필요)</td><td>타겟 시스템 메모리 모델 고려 필요 (엔디안, 정렬 등)</td></tr><tr><td><strong>인라인 어셈블리</strong></td><td>호스트 아키텍처 명령어 사용</td><td>타겟 아키텍처 명령어 사용</td></tr><tr><td><strong>시스템 콜 인터페이스</strong></td><td>호스트 OS와 동일</td><td>타겟 OS에 맞게 조정 필요</td></tr><tr><td><strong>부동소수점 처리</strong></td><td>호스트 하드웨어 사용</td><td>타겟 하드웨어 특성 고려 필요</td></tr><tr><td><strong>설치 난이도</strong></td><td>낮음</td><td>높음 (여러 도구와 의존성 설정 필요)</td></tr><tr><td><strong>CI/CD 통합</strong></td><td>쉬움</td><td>복잡함 (특수 설정 필요)</td></tr><tr><td><strong>대표적 사용 사례</strong></td><td>데스크톱 애플리케이션, 서버 소프트웨어</td><td>임베디드 펌웨어, 모바일 앱, 콘솔 게임, IoT 기기</td></tr><tr><td><strong>예시 도구</strong></td><td>GCC, Clang, MSVC (동일 플랫폼용)</td><td>Arm GNU 툴체인, MinGW, Android NDK</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/programming-languages/>Programming-Languages</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/compiler/>Compiler</a></li><li><a href=https://buenhyden.github.io/tags/native-compiler/>Native-Compiler</a></li><li><a href=https://buenhyden.github.io/tags/cross-compiler/>Cross-Compiler</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/compilers-and-programming-language-theory/language-processor/compiler/types/just-in-time-compiler/><span class=title>« Prev</span><br><span>Just-In-Time (JIT) Compiler</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/brute-force/><span class=title>Next »</span><br><span>브루트 포스 (Brute Force)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>