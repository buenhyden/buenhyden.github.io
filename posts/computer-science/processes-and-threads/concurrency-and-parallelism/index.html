<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency and Parallelism | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,System-Execution-Models,Concurrency,Parallelism"><meta name=description content="동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Concurrency and Parallelism"><meta property="og:description" content="동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Concurrency and Parallelism"><meta name=twitter:description content="동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Computer Science and Engineering","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Process vs Thread","item":"https://buenhyden.github.io/posts/computer-science/processes-and-threads/"},{"@type":"ListItem","position":4,"name":"Concurrency and Parallelism","item":"https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>Computer Science and Engineering</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/>Process vs Thread</a></div><h1>Concurrency and Parallelism</h1><div class=post-description>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다. 동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.</div></header><div class=post-content><h2 id=동시성-concurrency-vs-병렬성-parallelism>동시성 (Concurrency) vs. 병렬성 (Parallelism)<a hidden class=anchor aria-hidden=true href=#동시성-concurrency-vs-병렬성-parallelism>#</a></h2><p>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.<br>동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.<br>실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.</p><p><figure><img alt="Concurrent vs Parallel" loading=lazy src=/img/8e925d68-4f47-4ef9-8d51-6a39f19c75d2.jpg><figcaption>Source: &lt;https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism</figcaption></figure></p><p>동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.<br>이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 &ldquo;컨텍스트 스위칭(Context Switching)&ldquo;이라고 한다.</p><p>병렬성(Parallelism)은 여러 작업을 실제로 동시에 처리하는 개념으로, 여러 코어나 프로세서가 필요하며, 실제로 동시에 실행된다. 이로 인해 전체적인 처리 속도를 향상시킬 수 있다.<br>이러한 작업들은 여러 코어나 프로세서가 각각 독립적인 작업을 동시에 처리하며 각 작업은 서로 다른 하드웨어 자원을 사용한다.</p><h3 id=동시성concurrency과-병렬성parallelism-비교>동시성(Concurrency)과 병렬성(Parallelism) 비교<a hidden class=anchor aria-hidden=true href=#동시성concurrency과-병렬성parallelism-비교>#</a></h3><table><thead><tr><th>특성</th><th>동시성 (Concurrency)</th><th>병렬성 (Parallelism)</th></tr></thead><tbody><tr><td>정의</td><td>여러 작업을 번갈아가며 실행하여 동시에 처리되는 것처럼 보이게 함</td><td>여러 작업을 실제로 동시에 처리함</td></tr><tr><td>실행 방식</td><td>작업 간 빠른 전환 (Context Switching)</td><td>실제 동시 실행</td></tr><tr><td>하드웨어 요구사항</td><td>단일 코어로도 가능</td><td>다중 코어 또는 프로세서 필요</td></tr><tr><td>목적</td><td>응답성 향상, 자원 효율성 증대</td><td>전체 처리 속도 향상</td></tr><tr><td>성능 특성</td><td>I/O 대기 시간 최소화</td><td>CPU 처리량 최대화</td></tr><tr><td>복잡성</td><td>작업 간 전환과 자원 공유로 인해 복잡할 수 있음</td><td>작업 분할과 결과 통합 과정이 필요</td></tr><tr><td>적용 사례</td><td>웹 서버, 사용자 인터페이스, 멀티태스킹 OS</td><td>대규모 데이터 처리, 과학 계산, 그래픽 렌더링</td></tr><tr><td>구현 방법</td><td>멀티스레딩, 비동기 프로그래밍</td><td>멀티프로세싱, GPU 병렬 처리</td></tr><tr><td>자원 관리</td><td>자원 공유와 동기화 필요</td><td>각 작업이 독립적인 자원 사용</td></tr><tr><td>자원 공유</td><td>쉬움 (공유 메모리)</td><td>어려움 (프로세스 간 통신 필요)</td></tr><tr><td>리소스 효율성</td><td>대기 시간 활용으로 효율적</td><td>CPU 자원 최대 활용</td></tr><tr><td>메모리 사용</td><td>공유 메모리 사용</td><td>독립적인 메모리 공간</td></tr><tr><td>적합한 작업</td><td>I/O 바운드 작업<br>(파일, 네트워크, DB 작업)</td><td>CPU 바운드 작업<br>(복잡한 계산, 데이터 처리)</td></tr><tr><td>확장성</td><td>단일 시스템 내에서 제한적<br>I/O 작업에 대해 좋은 확장성</td><td>여러 시스템으로 확장 가능<br>CPU 코어 수에 비례하여 확장</td></tr><tr><td>성능 향상</td><td>응답 시간 개선에 중점</td><td>처리량 증가에 중점</td></tr><tr><td>에러 처리</td><td>상대적으로 단순</td><td>복잡한 동기화 필요</td></tr><tr><td>디버깅 난이도</td><td>상대적으로 어려움 (타이밍 이슈)</td><td>매우 어려움 (동시성 문제 + 분산 시스템 이슈)</td></tr><tr><td>프로그래밍 모델</td><td>이벤트 기반, 콜백, Promises 등</td><td>MapReduce, 데이터 병렬화 등</td></tr></tbody></table><h4 id=선택-기준표>선택 기준표<a hidden class=anchor aria-hidden=true href=#선택-기준표>#</a></h4><table><thead><tr><th>상황</th><th>권장 방식</th><th>이유</th></tr></thead><tbody><tr><td>웹 서버 개발</td><td>동시성</td><td>대부분 I/O 작업 위주</td></tr><tr><td>이미지 처리</td><td>병렬성</td><td>CPU 집약적 작업</td></tr><tr><td>사용자 인터페이스</td><td>동시성</td><td>반응성 향상 필요</td></tr><tr><td>대규모 데이터 분석</td><td>병렬성</td><td>독립적인 데이터 처리 가능</td></tr><tr><td>실시간 스트리밍</td><td>동시성</td><td>지속적인 I/O 처리 필요</td></tr><tr><td>과학적 계산</td><td>병렬성</td><td>복잡한 계산 작업 분할 가능</td></tr></tbody></table><h4 id=성능-비교표>성능 비교표<a hidden class=anchor aria-hidden=true href=#성능-비교표>#</a></h4><table><thead><tr><th>작업 유형</th><th>동시성 성능</th><th>병렬성 성능</th></tr></thead><tbody><tr><td>I/O 작업</td><td>매우 좋음</td><td>보통</td></tr><tr><td>CPU 작업</td><td>보통</td><td>매우 좋음</td></tr><tr><td>메모리 사용</td><td>효율적</td><td>많은 사용</td></tr><tr><td>응답 시간</td><td>일관적</td><td>변동 가능</td></tr><tr><td>처리량</td><td>중간</td><td>높음</td></tr><tr><td>자원 활용</td><td>효율적</td><td>최대화</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동시성 (Concurrency)</h2></header><div class=entry-content><p>동시성 (Concurrency) 동시성 (Concurrency)은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 매우 빠르게 작업 간 전환을 하면서 처리하는 방식이다. 예를 들어, 하나의 CPU 코어에서 여러 작업을 빠르게 번갈아가며 실행하여 마치 동시에 여러 작업이 처리되는 것처럼 보이게 만든다.
Source: https://dynamogeeks.com/blog/concurrency-vs-parallelism-a-simplified-explanation
동시성의 특징 논리적 개념: 동시성은 물리적으로 동시에 실행되는 것이 아닌, 논리적으로 동시에 실행되는 것처럼 보이게 하는 개념이다. 자원 효율성: CPU가 유휴 상태로 있지 않고 계속해서 작업을 처리하므로 시스템 자원을 효율적으로 사용할 수 있다. 응답성 향상: 여러 작업을 번갈아가며 처리하므로 전체적인 시스템의 응답성이 향상된다. 동시성의 구현 방법 멀티스레딩: 하나의 프로세스 내에서 여러 스레드를 사용하여 작업을 동시에 처리한다. 비동기 프로그래밍: 작업을 비동기적으로 처리하여 한 작업이 완료되기를 기다리지 않고 다른 작업을 수행할 수 있게 한다. 동시성의 장점 성능 향상: 여러 작업을 동시에 처리함으로써 전체적인 처리 속도를 높일 수 있다. 자원 활용 최적화: CPU와 같은 시스템 자원을 최대한 활용할 수 있다. 사용자 경험 개선: 특히 UI 애플리케이션에서 동시성을 활용하면 사용자 반응성을 크게 향상시킬 수 있다. 동시성의 주의점 복잡성 증가: 동시성 프로그래밍은 일반적인 순차적 프로그래밍보다 복잡할 수 있다. 동기화 문제: 여러 작업이 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 주의해야 한다. 디버깅의 어려움: 동시에 실행되는 작업들 간의 상호작용으로 인해 버그를 찾고 수정하기가 어려울 수 있다. 동시성의 실제 예시 웹 브라우저: 여러 탭을 동시에 열어 각각 다른 웹페이지를 로드하면서 사용자 입력을 받는 것은 동시성의 좋은 예이다. 데이터베이스 시스템: 여러 사용자의 쿼리를 동시에 처리하는 데이터베이스 시스템도 동시성을 활용한다. 동시성은 현대 프로그래밍에서 매우 중요한 개념으로, 시스템의 성능을 향상시키고 사용자 경험을 개선하는 데 크게 기여한다.
...</p></div><footer class=entry-footer><span title='2024-10-04 06:51:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 (Concurrency)" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/concurrency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>병렬성 (Parallelism)</h2></header><div class=entry-content><p>병렬성 (Parallelism) 병렬성(Parallelism)은 컴퓨터 프로그래밍에서 여러 작업을 동시에 실행하여 전체적인 처리 속도를 향상시키는 기술을 말한다.
이는 여러 CPU 코어나 프로세서를 활용하여 다양한 작업을 동시에 처리하는 방식이다.
예를 들어, 대규모 데이터베이스의 쿼리 처리나 대용량 파일의 압축 해제 등은 병렬 처리를 통해 성능을 크게 향상시킬 수 있다.
Source: https://dynamogeeks.com/blog/concurrency-vs-parallelism-a-simplified-explanation
병렬성의 종류 병렬성은 크게 두 가지 방식으로 구현될 수 있다:
데이터 병렬화 (Data parallelism):
동일한 작업을 여러 데이터 조각에 대해 동시에 수행한다.
예를 들어, 대규모 행렬 연산에서 행렬을 여러 부분으로 나누고, 각 부분을 동시에 처리하여 계산을 가속화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-04 02:35:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병렬성 (Parallelism)" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/parallelism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기화 (Synchronization)</h2></header><div class=entry-content><p>동기화 (Synchronization) 여러 프로세스나 스레드가 공유 자원에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 메커니즘.
동기화란 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하도록 하는 것을 의미한다. 이는 여러 작업 간의 실행 순서와 타이밍을 제어하여 데이터의 일관성을 유지하고 경쟁 상태(Race Condition)를 방지하는 것을 목표로 한다.
동기화의 필요성 동기화가 필요한 주요 이유는 다음과 같다:
데이터 일관성 유지: 여러 프로세스나 스레드가 동시에 같은 데이터에 접근할 때 발생할 수 있는 불일치를 방지한다. 경쟁 상태 방지: 둘 이상의 프로세스가 공유 자원에 동시에 접근하려 할 때 발생할 수 있는 예측 불가능한 결과를 방지한다. 순서 보장: 특정 작업이 다른 작업보다 먼저 실행되어야 하는 경우, 동기화를 통해 실행 순서를 제어할 수 있다. 동기화 메커니즘 동기화를 구현하기 위한 주요 메커니즘은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-02 07:48:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기화 (Synchronization)" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/synchronization/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>