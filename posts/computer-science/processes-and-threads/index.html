<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Process vs Thread | hyunyoun's Blog</title>
<meta name=keywords content="Computer-System,System-Execution-Models,Process,Thread"><meta name=description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/processes-and-threads/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Process vs Thread"><meta property="og:description" content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Process vs Thread"><meta name=twitter:description content="Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Process vs Thread","item":"https://buenhyden.github.io/posts/computer-science/processes-and-threads/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a></div><h1>Process vs Thread</h1><div class=post-description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</div></header><div class=post-content><h2 id=process-vs-thread>Process vs. Thread<a hidden class=anchor aria-hidden=true href=#process-vs-thread>#</a></h2><ol><li><p>프로세스:</p><ul><li>독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다.</li><li>다른 프로세스와 완전히 격리되어 있어 안정성이 높다.</li><li>생성과 전환에 많은 비용이 든다.</li></ul></li><li><p>스레드:</p><ul><li>프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다.</li><li>프로세스보다 가볍고, 생성과 전환 비용이 적다.</li><li>동시성을 제공하지만, 동기화 문제에 주의해야 한다.</li></ul></li></ol><p><figure><img alt="Single Threaded vs Multi-threaded Process" loading=lazy src=/img/Screenshot-from-2024-02-26-11-48-56-768.png><figcaption>https://www.geeksforgeeks.org/thread-in-operating-system/</figcaption></figure></p><h3 id=process-vs-thread-1>Process vs. Thread<a hidden class=anchor aria-hidden=true href=#process-vs-thread-1>#</a></h3><table><thead><tr><th>특성</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td>정의</td><td>실행 중인 프로그램의 인스턴스</td><td>프로세스 내에서 실행되는 더 작은 실행 단위</td></tr><tr><td>메모리 공간</td><td>독립적인 메모리 공간 (코드, 데이터, 스택, 힙)</td><td>프로세스의 메모리 공간 공유 (코드, 데이터, 힙), 독립적인 스택</td></tr><tr><td>구성 요소</td><td>- 코드 영역<br>- 데이터 영역<br>- 스택 영역<br>- 힙 영역</td><td>- 스레드 ID<br>- 프로그램 카운터<br>- 레지스터 집합<br>- 스택</td></tr><tr><td>자원 공유</td><td>다른 프로세스와 자원 공유 안 함</td><td>같은 프로세스 내 스레드 간 자원 공유</td></tr><tr><td>생성 비용</td><td>높음</td><td>낮음</td></tr><tr><td>컨텍스트 스위칭</td><td>비용이 큼</td><td>비용이 적음 (같은 프로세스 내에서)</td></tr><tr><td>안정성</td><td>높음 (한 프로세스의 오류가 다른 프로세스에 영향 없음)</td><td>상대적으로 낮음 (한 스레드의 오류가 전체 프로세스에 영향)</td></tr><tr><td>통신</td><td>프로세스 간 통신(IPC) 필요 (복잡하고 오버헤드 큼)</td><td>쉽고 빠른 통신 (공유 메모리 사용)</td></tr><tr><td>병렬 처리</td><td>가능하지만 오버헤드 큼</td><td>효율적인 병렬 처리 가능</td></tr></tbody></table><h4 id=메모리-구조-비교>메모리 구조 비교<a hidden class=anchor aria-hidden=true href=#메모리-구조-비교>#</a></h4><table><thead><tr><th>메모리 영역</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>코드 영역</strong></td><td>독립적</td><td>공유</td></tr><tr><td><strong>데이터 영역</strong></td><td>독립적</td><td>공유</td></tr><tr><td><strong>힙 영역</strong></td><td>독립적</td><td>공유</td></tr><tr><td><strong>스택 영역</strong></td><td>독립적</td><td>각 스레드마다 독립적</td></tr></tbody></table><h4 id=특성-상세-비교>특성 상세 비교<a hidden class=anchor aria-hidden=true href=#특성-상세-비교>#</a></h4><table><thead><tr><th>특성</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>독립성</strong></td><td>완전히 독립적</td><td>부분적으로 독립적</td></tr><tr><td><strong>자원 공유</strong></td><td>제한적 (IPC 필요)</td><td>쉽게 공유 가능</td></tr><tr><td><strong>오류 영향</strong></td><td>다른 프로세스에 영향 없음</td><td>같은 프로세스의 모든 스레드에 영향</td></tr><tr><td><strong>동기화</strong></td><td>필요성 낮음<br>- IPC 메커니즘 필요</td><td>공유 자원에 대한 동기화 필요<br>- 뮤텍스, 세마포어 등 사용</td></tr><tr><td><strong>생성 시간</strong></td><td>더 오래 걸림</td><td>더 빠름</td></tr><tr><td><strong>종료 시간</strong></td><td>더 오래 걸림</td><td>더 빠름</td></tr></tbody></table><h4 id=장단점-비교>장단점 비교<a hidden class=anchor aria-hidden=true href=#장단점-비교>#</a></h4><table><thead><tr><th>구분</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>장점</strong></td><td>- 높은 안정성<br>- 다른 프로세스의 영향 받지 않음<br>- 보안성이 높음</td><td>- 생성/종료가 빠름<br>- 자원 공유가 쉬움<br>- 통신 비용이 적음</td></tr><tr><td><strong>단점</strong></td><td>- 많은 시스템 자원 필요<br>- 프로세스 간 통신이 복잡<br>- 컨텍스트 스위칭 비용이 큼</td><td>- 동기화 문제 발생 가능<br>- 디버깅이 어려움<br>- 하나의 스레드 문제가 전체에 영향</td></tr></tbody></table><h4 id=사용-사례-비교>사용 사례 비교<a hidden class=anchor aria-hidden=true href=#사용-사례-비교>#</a></h4><table><thead><tr><th>용도</th><th>Process 선호</th><th>Thread 선호</th></tr></thead><tbody><tr><td><strong>웹 서버</strong></td><td>안정성이 중요한 경우</td><td>높은 동시성이 필요한 경우</td></tr><tr><td><strong>GUI 앱</strong></td><td>독립적인 작업이 많은 경우</td><td>반응성이 중요한 경우</td></tr><tr><td><strong>데이터 처리</strong></td><td>대용량 병렬 처리</td><td>데이터 공유가 많은 경우</td></tr><tr><td><strong>시스템 서비스</strong></td><td>격리가 필요한 경우</td><td>빈번한 통신이 필요한 경우</td></tr><tr><td>활용 예</td><td>- 독립적인 애플리케이션<br>- 웹 브라우저의 각 탭<br>- 다중 사용자 서버</td><td>- 웹 서버 요청 처리<br>- 게임 엔진 (렌더링, 물리 연산)<br>- 멀티미디어 애플리케이션</td></tr></tbody></table><h4 id=동기화-메커니즘-비교>동기화 메커니즘 비교<a hidden class=anchor aria-hidden=true href=#동기화-메커니즘-비교>#</a></h4><table><thead><tr><th>메커니즘</th><th>Process</th><th>Thread</th></tr></thead><tbody><tr><td><strong>공유 메모리</strong></td><td>명시적으로 설정 필요</td><td>기본적으로 공유</td></tr><tr><td><strong>뮤텍스</strong></td><td>프로세스 간 뮤텍스 필요</td><td>프로세스 내 뮤텍스 사용</td></tr><tr><td><strong>세마포어</strong></td><td>시스템 세마포어 필요</td><td>프로세스 내 세마포어 사용</td></tr><tr><td><strong>메시지 전달</strong></td><td>IPC 메커니즘 사용</td><td>직접 메모리 접근</td></tr></tbody></table><p>이러한 차이점들을 이해하고 적절히 활용하면, 상황에 맞는 최적의 실행 단위를 선택할 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency and Parallelism</h2></header><div class=entry-content><p>동시성 (Concurrency) vs. 병렬성 (Parallelism) 동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.
동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.
실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.
Source: &lt;https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism
동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.
이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 “컨텍스트 스위칭(Context Switching)“이라고 한다.
...</p></div><footer class=entry-footer><span title='2024-10-05 02:38:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrency and Parallelism" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-and-parallelism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Thread</h2></header><div class=entry-content><p>스레드의 기본 개념과 프로세스와의 차이점 설명. 멀티스레딩의 장점과 주요 구현 방식(POSIX Threads, Windows Threads). 유사 기술: 멀티프로세싱, 비동기 처리. Thread Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.
하나의 프로세스는 여러 개의 Thread를 가질 수 있으며, 이들은 프로세스의 자원을 공유한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
Thread의 구성 요소 Thread는 다음과 같은 구성 요소를 가진다:
프로그램 카운터 레지스터 집합 스택 공간 Thread ID
이러한 요소들은 각 Thread의 독립적인 실행을 가능하게 한다. Thread의 특징 경량성: Thread는 프로세스에 비해 생성과 관리가 더 빠르고 효율적이다. 자원 공유: 같은 프로세스 내의 Thread들은 코드, 데이터, 파일 등의 자원을 공유한다. 병렬 실행: 멀티코어 시스템에서는 여러 Thread가 실제로 동시에 실행될 수 있다. 기능과 역할 기능 역할 장점 병렬 처리 - 동시에 여러 작업 수행
CPU 활용도 증가 - 성능 향상
- 응답성 개선 자원 공유 - 프로세스 자원 공유
- 효율적인 메모리 사용 - 메모리 절약
- 통신 비용 감소 비동기 처리 - 독립적인 작업 수행
- 이벤트 처리 - 응답성 향상
UI 처리 효율화 Thread의 종류 Thread는 크게 두 가지로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-04 23:32:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/threads/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>임계 영역 (Critical Section)</h2></header><div class=entry-content><p>임계 영역 (Critical Section) 운영체제에서 임계 영역(Critical Section)은 여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역을 말한다.
이는 병렬 컴퓨팅 환경에서 중요한 개념으로, 데이터의 일관성과 무결성을 보장하기 위해 사용된다.
여러 프로세스가 동시에 임계 영역에 진입하면 데이터의 일관성이 깨질 수 있다.
1 2 3 4 5 6 7 8 9 10 # 임계 영역 예시 balance = 1000 # 공유 자원 def withdraw(amount): global balance # 임계 영역 시작 temp = balance temp = temp - amount balance = temp # 임계 영역 종료 임계 영역 문제의 해결 조건 상호 배제(Mutual Exclusion): 한 프로세스가 임계 영역에 있을 때 다른 프로세스는 진입할 수 없다. 진행(Progress): 임계 영역에 있는 프로세스가 없다면, 진입하려는 프로세스가 들어갈 수 있어야 한다. 한정된 대기(Bounded Waiting): 프로세스의 임계 영역 진입은 무한정 연기되어서는 안 된다. 임계 영역 관련 문제와 해결 방법 구분 데드락(Deadlock) 경쟁 상태(Race Condition) 기아 상태(Starvation) 라이브락(Livelock) 정의 두 개 이상의 프로세스가 서로의 자원을 기다리며 영구적으로 블록된 상태 여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과가 달라지는 상태 특정 프로세스가 필요한 자원을 계속 할당받지 못하는 상태 프로세스들이 서로에게 응답하며 상태는 변하지만 실제 진행은 없는 상태 발생 원인 상호 배제, 점유와 대기, 비선점, 순환 대기 조건이 동시 충족 공유 자원에 대한 동시 접근, 원자성 결여 부적절한 자원 할당 정책, 우선순위 역전 현상 프로세스들의 과도한 양보, 재귀적 회피 동작 결과 시스템 전체 또는 일부 프로세스의 완전한 정지 데이터 불일치, 예측 불가능한 결과 특정 프로세스의 실행 지연 또는 무한 대기 CPU 자원 소비, 실제 작업 진행 없음 특징 프로세스들이 움직이지 않고 완전히 멈춤 타이밍에 따라 결과가 비결정적 자원 할당의 불공정성 프로세스들이 활발히 상태 변경 해결 방법 프로세스 강제 종료, 자원 선점, 데드락 발생 조건 제거 동기화 메커니즘 사용(뮤텍스, 세마포어 등) 에이징(Aging) 기법 도입, 공정한 스케줄링 무작위 대기 시간 도입, 우선순위 조정 예방 기법 자원 할당 그래프 사용, 자원 순서화, 타임아웃 설정 임계 영역 설정, 원자적 연산 사용 자원 예약 시스템, 우선순위 조정 메커니즘 타임아웃 설정, 재시도 횟수 제한 탐지 방법 자원 할당 그래프 분석, 대기 사이클 검출 데이터 일관성 검사, 로그 분석 자원 할당 통계 모니터링 CPU 사용률 분석, 진행률 모니터링 영향 범위 전체 시스템 또는 관련 프로세스 그룹 공유 자원을 사용하는 프로세스들 특정 프로세스 또는 프로세스 그룹 상호 작용하는 프로세스 그룹 복구 방법 프로세스 재시작, 시스템 재부팅 트랜잭션 롤백, 상태 복원 우선순위 재조정, 자원 재할당 프로세스 재시작 또는 동작 패턴 변경 모니터링 방법 시스템 자원 모니터링, 프로세스 상태 감시 로그 분석, 데이터 정합성 검사 자원 할당 히스토리 분석 CPU 사용률 추적, 진행 상태 모니터링 해결 방법 상호 배제(Mutual Exclusion) 구현:
...</p></div><footer class=entry-footer><span title='2024-10-03 07:49:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 임계 영역 (Critical Section)" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/critical-section/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>