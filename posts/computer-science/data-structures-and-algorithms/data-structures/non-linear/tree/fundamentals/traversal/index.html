<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Traversal | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Tree,Fundamentals,Traversal"><meta name=description content="트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Traversal"><meta property="og:description" content="트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Traversal"><meta name=twitter:description content="트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/"},{"@type":"ListItem","position":4,"name":"Data Structures","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":6,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/"},{"@type":"ListItem","position":7,"name":"Fundamentals of Tree","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/"},{"@type":"ListItem","position":8,"name":"Traversal","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>컴퓨터 과학</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/>Fundamentals of Tree</a></div><h1>Traversal</h1><div class=post-description>트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다.</div></header><div class=post-content><h2 id=traversal>Traversal<a hidden class=anchor aria-hidden=true href=#traversal>#</a></h2><h2 id=트리-순회tree-traversal에-대한-깊이-있는-이해>트리 순회(Tree Traversal)에 대한 깊이 있는 이해<a hidden class=anchor aria-hidden=true href=#트리-순회tree-traversal에-대한-깊이-있는-이해>#</a></h2><p>트리 순회(Tree Traversal)는 트리 자료구조에서 각 노드를 체계적으로 방문하는 과정을 의미한다.<br>트리의 모든 노드를 빠짐없이 정해진 순서에 따라 방문하는 것이 핵심이다.<br>이러한 순회 방법은 트리 내의 데이터를 처리하고, 검색하며, 조작하는 기본적인 방법으로, 컴퓨터 과학에서 매우 중요한 알고리즘이다.</p><p>트리 순회는 트리 자료구조를 다루는 핵심 연산으로, 다양한 알고리즘과 응용 프로그램에서 필수적이다.<br>각 순회 방법은 고유한 특성과 장단점을 가지고 있으며, 해결하려는 문제의 성격에 따라 적절한 방법을 선택하는 것이 중요하다.<br>재귀적 방법은 간결하고 이해하기 쉽지만, 대규모 트리에서는 반복적 방법이나 최적화된 알고리즘을 고려해야 할 수 있다. 트리 순회에 대한 깊은 이해는 효율적인 알고리즘 설계와 문제 해결 능력 향상에 큰 도움이 된다.</p><h3 id=트리-순회의-기본-개념>트리 순회의 기본 개념<a hidden class=anchor aria-hidden=true href=#트리-순회의-기본-개념>#</a></h3><p>트리 순회는 기본적으로 트리의 모든 노드를 한 번씩 방문하는 과정이다.<br>트리는 계층적 구조를 가지고 있어 배열이나 연결 리스트와 같은 선형 자료구조와 달리 여러 가지 다른 방법으로 순회할 수 있다.<br>트리 순회 알고리즘은 일반적으로 재귀적으로 구현되며, 그 과정에서 노드의 데이터를 처리하거나 출력한다.</p><h3 id=이진-트리-순회-방법>이진 트리 순회 방법<a hidden class=anchor aria-hidden=true href=#이진-트리-순회-방법>#</a></h3><p>이진 트리는 가장 일반적인 트리 유형으로, 각 노드가 최대 두 개의 자식을 가진다.<br>이진 트리의 기본적인 순회 방법은 다음과 같이 네 가지가 있다.</p><h4 id=전위-순회preorder-traversal>전위 순회(Preorder Traversal)<a hidden class=anchor aria-hidden=true href=#전위-순회preorder-traversal>#</a></h4><p>전위 순회는 루트 노드를 먼저 방문한 다음, 왼쪽 서브트리를 전위 순회하고, 마지막으로 오른쪽 서브트리를 전위 순회한다.</p><p>순서: <strong>루트 → 왼쪽 서브트리 → 오른쪽 서브트리</strong></p><p>알고리즘(의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>preorder(node):
</span></span><span class=line><span class=cl>    if node is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    방문(node)
</span></span><span class=line><span class=cl>    preorder(node.left)
</span></span><span class=line><span class=cl>    preorder(node.right)
</span></span></code></pre></td></tr></table></div></div><p>특징:</p><ul><li>깊이 우선 탐색(DFS) 방식</li><li>트리 구조의 복사본을 만들 때 유용</li><li>디렉토리 구조를 표시할 때 사용 (루트 디렉토리부터 시작)</li><li>표현식 트리에서 전위 표기법(prefix notation)을 생성할 때 사용</li></ul><p>예시 활용:</p><ul><li>트리 복제</li><li>XML/HTML 파싱 (루트 태그부터 처리)</li><li>트리 직렬화</li></ul><h4 id=중위-순회inorder-traversal>중위 순회(Inorder Traversal)<a hidden class=anchor aria-hidden=true href=#중위-순회inorder-traversal>#</a></h4><p>중위 순회는 왼쪽 서브트리를 중위 순회한 다음, 루트 노드를 방문하고, 마지막으로 오른쪽 서브트리를 중위 순회한다. 다.</p><p>순서: <strong>왼쪽 서브트리 → 루트 → 오른쪽 서브트리</strong></p><p>알고리즘(의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>inorder(node):
</span></span><span class=line><span class=cl>    if node is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    inorder(node.left)
</span></span><span class=line><span class=cl>    방문(node)
</span></span><span class=line><span class=cl>    inorder(node.right)
</span></span></code></pre></td></tr></table></div></div><p>특징:</p><ul><li>이진 검색 트리(BST)에서 중위 순회를 하면 노드를 오름차순으로 방문</li><li>중위 표기법의 수식을 생성할 때 사용</li><li>대칭적인 순회 방식</li></ul><p>예시 활용:</p><ul><li>BST에서 정렬된 데이터 검색</li><li>표현식 트리에서 중위 표기식 생성</li><li>트리의 균형 검사</li></ul><h4 id=후위-순회postorder-traversal>후위 순회(Postorder Traversal)<a hidden class=anchor aria-hidden=true href=#후위-순회postorder-traversal>#</a></h4><p>후위 순회는 왼쪽 서브트리를 후위 순회한 다음, 오른쪽 서브트리를 후위 순회하고, 마지막으로 루트 노드를 방문한다.</p><p>순서: <strong>왼쪽 서브트리 → 오른쪽 서브트리 → 루트</strong></p><p>알고리즘(의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postorder(node):
</span></span><span class=line><span class=cl>    if node is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    postorder(node.left)
</span></span><span class=line><span class=cl>    postorder(node.right)
</span></span><span class=line><span class=cl>    방문(node)
</span></span></code></pre></td></tr></table></div></div><p>특징:</p><ul><li>자식 노드를 먼저 처리한 후 부모 노드를 처리</li><li>트리를 삭제할 때 유용 (리프 노드부터 삭제하므로 메모리 관리에 효율적)</li><li>후위 표기법(postfix notation)을 생성할 때 사용</li><li>디렉토리 크기 계산과 같은 상향식 계산에 적합</li></ul><p>예시 활용:</p><ul><li>파일 시스템에서 디렉토리 크기 계산</li><li>표현식 트리 평가 (후위 표기법)</li><li>트리 삭제 연산</li></ul><h4 id=레벨-순회level-order-traversal-또는-너비-우선-순회breadth-first-traversal>레벨 순회(Level Order Traversal) 또는 너비 우선 순회(Breadth-First Traversal)<a hidden class=anchor aria-hidden=true href=#레벨-순회level-order-traversal-또는-너비-우선-순회breadth-first-traversal>#</a></h4><p>레벨 순회는 루트 노드부터 시작하여 레벨별로 각 노드를 왼쪽에서 오른쪽으로 방문한다.</p><p>순서: <strong>레벨 1 → 레벨 2 → 레벨 3 → … → 레벨 n</strong></p><p>알고리즘(의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1> 1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2> 2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3> 3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4> 4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5> 5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6> 6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7> 7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8> 8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9> 9</a>
</span><span class=lnt id=hl-3-10><a class=lnlinks href=#hl-3-10>10</a>
</span><span class=lnt id=hl-3-11><a class=lnlinks href=#hl-3-11>11</a>
</span><span class=lnt id=hl-3-12><a class=lnlinks href=#hl-3-12>12</a>
</span><span class=lnt id=hl-3-13><a class=lnlinks href=#hl-3-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>levelOrder(root):
</span></span><span class=line><span class=cl>    if root is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    queue Q 초기화
</span></span><span class=line><span class=cl>    Q에 root 삽입
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    while Q is not empty:
</span></span><span class=line><span class=cl>        node = Q에서 제거
</span></span><span class=line><span class=cl>        방문(node)
</span></span><span class=line><span class=cl>        if node.left is not null:
</span></span><span class=line><span class=cl>            Q에 node.left 삽입
</span></span><span class=line><span class=cl>        if node.right is not null:
</span></span><span class=line><span class=cl>            Q에 node.right 삽입
</span></span></code></pre></td></tr></table></div></div><p>특징:</p><ul><li>너비 우선 탐색(BFS) 방식</li><li>큐(Queue) 자료구조를 사용하여 구현</li><li>최단 경로 문제 및 가장 가까운 노드 찾기에 유용</li><li>트리의 레벨별 특성을 분석할 때 적합</li></ul><p>예시 활용:</p><ul><li>최단 경로 알고리즘</li><li>레벨별 트리 시각화</li><li>트리의 너비 계산</li><li>가장 가까운 공통 조상 찾기</li></ul><h3 id=일반-트리-순회-방법>일반 트리 순회 방법<a hidden class=anchor aria-hidden=true href=#일반-트리-순회-방법>#</a></h3><p>일반 트리는 각 노드가 임의의 수의 자식을 가질 수 있는 트리이다.<br>일반 트리의 순회 방법은 이진 트리의 순회 방법을 확장한 형태이다.</p><h4 id=전위-순회preorder-traversal-1>전위 순회(Preorder Traversal)<a hidden class=anchor aria-hidden=true href=#전위-순회preorder-traversal-1>#</a></h4><p>일반 트리에서 전위 순회는 루트를 먼저 방문한 다음, 각 자식 서브트리를 왼쪽에서 오른쪽으로 전위 순회한다.</p><p>알고리즘(의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>preorder(node):
</span></span><span class=line><span class=cl>    if node is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    방문(node)
</span></span><span class=line><span class=cl>    for each child of node:
</span></span><span class=line><span class=cl>        preorder(child)
</span></span></code></pre></td></tr></table></div></div><h4 id=후위-순회postorder-traversal-1>후위 순회(Postorder Traversal)<a hidden class=anchor aria-hidden=true href=#후위-순회postorder-traversal-1>#</a></h4><p>일반 트리에서 후위 순회는 각 자식 서브트리를 왼쪽에서 오른쪽으로 후위 순회한 다음, 루트를 방문한다.</p><p>알고리즘(의사 코드):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postorder(node):
</span></span><span class=line><span class=cl>    if node is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    for each child of node:
</span></span><span class=line><span class=cl>        postorder(child)
</span></span><span class=line><span class=cl>    방문(node)
</span></span></code></pre></td></tr></table></div></div><h4 id=레벨-순회level-order-traversal>레벨 순회(Level Order Traversal)<a hidden class=anchor aria-hidden=true href=#레벨-순회level-order-traversal>#</a></h4><p>일반 트리에서 레벨 순회는 이진 트리와 동일하게 레벨별로 노드를 방문한다.</p><h3 id=특수한-트리-순회-방법>특수한 트리 순회 방법<a hidden class=anchor aria-hidden=true href=#특수한-트리-순회-방법>#</a></h3><p>기본적인 순회 방법 외에도 특수한 목적을 위한 다양한 트리 순회 방법이 있다.</p><ol><li>지그재그 순회(Zigzag Traversal)<br>지그재그 순회는 레벨 순회의 변형으로, 홀수 레벨에서는 왼쪽에서 오른쪽으로, 짝수 레벨에서는 오른쪽에서 왼쪽으로 노드를 방문한다.</li><li>모리스 순회(Morris Traversal)<br>모리스 순회는 추가 공간을 사용하지 않고 트리를 순회하는 방법으로, 특히 중위 순회에 많이 사용된다. 이 방법은 스택이나 재귀를 사용하지 않고 O(1)의 추가 공간만을 사용한다.</li><li>경계 순회(Boundary Traversal)<br>경계 순회는 트리의 경계(왼쪽 경계, 리프 노드, 오른쪽 경계)를 따라 노드를 방문하는 방법이다.</li><li>대각선 순회(Diagonal Traversal)<br>대각선 순회는 트리의 대각선 방향으로 노드를 그룹화하여 방문하는 방법이다.</li></ol><h3 id=트리-순회의-구현-방식>트리 순회의 구현 방식<a hidden class=anchor aria-hidden=true href=#트리-순회의-구현-방식>#</a></h3><p>트리 순회는 주로 두 가지 방식으로 구현된다.</p><h4 id=재귀적-방법recursive-approach>재귀적 방법(Recursive Approach)<a hidden class=anchor aria-hidden=true href=#재귀적-방법recursive-approach>#</a></h4><p>재귀적 방법은 가장 간단하고 직관적인 구현 방식이다.<br>각 노드에 대해 재귀 함수를 호출하여 서브트리를 순회한다.</p><p>장점:</p><ul><li>코드가 간결하고 이해하기 쉬움</li><li>트리의 구조를 자연스럽게 반영</li></ul><p>단점:</p><ul><li>깊은 트리에서는 스택 오버플로우 발생 가능</li><li>함수 호출 오버헤드로 인한 성능 저하 가능</li></ul><h4 id=반복적-방법iterative-approach>반복적 방법(Iterative Approach)<a hidden class=anchor aria-hidden=true href=#반복적-방법iterative-approach>#</a></h4><p>반복적 방법은 스택 또는 큐와 같은 보조 자료구조를 사용하여 순회를 구현한다.</p><p>장점:</p><ul><li>스택 오버플로우 위험 없음</li><li>대규모 트리에 더 효율적일 수 있음</li></ul><p>단점:</p><ul><li>코드가 복잡해질 수 있음</li><li>로직을 이해하기 어려울 수 있음</li></ul><h5 id=전위-순회의-반복적-구현>전위 순회의 반복적 구현<a hidden class=anchor aria-hidden=true href=#전위-순회의-반복적-구현>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>iterativePreorder(root):
</span></span><span class=line><span class=cl>    if root is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    stack S 초기화
</span></span><span class=line><span class=cl>    S에 root 삽입
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    while S is not empty:
</span></span><span class=line><span class=cl>        node = S에서 pop
</span></span><span class=line><span class=cl>        방문(node)
</span></span><span class=line><span class=cl>        if node.right is not null:
</span></span><span class=line><span class=cl>            S에 node.right 삽입
</span></span><span class=line><span class=cl>        if node.left is not null:
</span></span><span class=line><span class=cl>            S에 node.left 삽입
</span></span></code></pre></td></tr></table></div></div><h5 id=중위-순회의-반복적-구현>중위 순회의 반복적 구현<a hidden class=anchor aria-hidden=true href=#중위-순회의-반복적-구현>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>iterativeInorder(root):
</span></span><span class=line><span class=cl>    if root is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    stack S 초기화
</span></span><span class=line><span class=cl>    current = root
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    while current is not null or S is not empty:
</span></span><span class=line><span class=cl>        while current is not null:
</span></span><span class=line><span class=cl>            S에 current 삽입
</span></span><span class=line><span class=cl>            current = current.left
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        current = S에서 pop
</span></span><span class=line><span class=cl>        방문(current)
</span></span><span class=line><span class=cl>        current = current.right
</span></span></code></pre></td></tr></table></div></div><h5 id=후위-순회의-반복적-구현>후위 순회의 반복적 구현<a hidden class=anchor aria-hidden=true href=#후위-순회의-반복적-구현>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>iterativePostorder(root):
</span></span><span class=line><span class=cl>    if root is null:
</span></span><span class=line><span class=cl>        return
</span></span><span class=line><span class=cl>    stack S1, S2 초기화
</span></span><span class=line><span class=cl>    S1에 root 삽입
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    while S1 is not empty:
</span></span><span class=line><span class=cl>        node = S1에서 pop
</span></span><span class=line><span class=cl>        S2에 node 삽입
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        if node.left is not null:
</span></span><span class=line><span class=cl>            S1에 node.left 삽입
</span></span><span class=line><span class=cl>        if node.right is not null:
</span></span><span class=line><span class=cl>            S1에 node.right 삽입
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    while S2 is not empty:
</span></span><span class=line><span class=cl>        node = S2에서 pop
</span></span><span class=line><span class=cl>        방문(node)
</span></span></code></pre></td></tr></table></div></div><h3 id=트리-순회의-시간-및-공간-복잡도>트리 순회의 시간 및 공간 복잡도<a hidden class=anchor aria-hidden=true href=#트리-순회의-시간-및-공간-복잡도>#</a></h3><h4 id=시간-복잡도>시간 복잡도<a hidden class=anchor aria-hidden=true href=#시간-복잡도>#</a></h4><p>모든 기본 트리 순회 알고리즘(전위, 중위, 후위, 레벨 순회)은 트리의 모든 노드를 한 번씩 방문하므로 시간 복잡도는 O(n)이다. 여기서 n은 트리의 노드 수이다.</p><h4 id=공간-복잡도>공간 복잡도<a hidden class=anchor aria-hidden=true href=#공간-복잡도>#</a></h4><ul><li>재귀적 방법: O(h), 여기서 h는 트리의 높이이다. 최악의 경우(편향 트리) O(n)이 될 수 있다.</li><li>반복적 방법(스택 사용): 전위, 중위, 후위 순회에서 O(h)이다.</li><li>반복적 방법(큐 사용): 레벨 순회에서 O(w), 여기서 w는 트리의 최대 너비이다. 최악의 경우 O(n/2) ≈ O(n)이 될 수 있습니다.</li></ul><h3 id=트리-순회의-응용>트리 순회의 응용<a hidden class=anchor aria-hidden=true href=#트리-순회의-응용>#</a></h3><ol><li><p>표현식 트리 평가<br>표현식 트리는 수학 표현식을 나타내는 이진 트리이다.<br>내부 노드는 연산자를, 리프 노드는 피연산자를 나타낸다.</p><ul><li>전위 순회 → 전위 표기법(prefix notation) 또는 폴란드 표기법</li><li>중위 순회 → 중위 표기법(infix notation) 또는 일반적인 수학 표기법</li><li>후위 순회 → 후위 표기법(postfix notation) 또는 역폴란드 표기법</li></ul></li><li><p>트리 직렬화 및 역직렬화<br>트리를 문자열이나 배열과 같은 선형 자료구조로 변환하는 과정을 직렬화라고 하며, 그 반대 과정을 역직렬화라고 한다. 트리 순회는 이러한 과정에 필수적이다.</p></li><li><p>이진 검색 트리(BST) 연산<br>이진 검색 트리에서 중위 순회를 수행하면 정렬된 순서로 노드를 방문할 수 있다.<br>이는 BST의 유효성 검사와 같은 작업에 유용하다.</p></li><li><p>파일 시스템 탐색<br>디렉토리 구조는 트리로 모델링할 수 있으며, 파일 시스템 탐색은 트리 순회로 구현할 수 있다.</p></li><li><p>구문 분석 트리(Parse Tree) 처리<br>프로그래밍 언어의 구문 분석 과정에서 생성되는 구문 분석 트리는 다양한 트리 순회 방법을 사용하여 처리된다.</p></li></ol><h3 id=n-항-트리-순회>N-항 트리 순회<a hidden class=anchor aria-hidden=true href=#n-항-트리-순회>#</a></h3><p>N-항 트리(각 노드가 임의의 수의 자식을 가질 수 있는 트리)의 순회는 이진 트리 순회의 확장이다.</p><ol><li><p>깊이 우선 순회(Depth-First Traversal)<br>N-항 트리에서 깊이 우선 순회는 루트를 방문한 후, 각 자식 서브트리를 깊이 우선으로 순회한다.</p></li><li><p>너비 우선 순회(Breadth-First Traversal)<br>N-항 트리에서 너비 우선 순회는 레벨별로 노드를 방문한다.</p></li></ol><h3 id=특정-문제에-맞는-순회-방법-선택>특정 문제에 맞는 순회 방법 선택<a hidden class=anchor aria-hidden=true href=#특정-문제에-맞는-순회-방법-선택>#</a></h3><p>적절한 트리 순회 방법을 선택하는 것은 해결하려는 문제의 성격에 따라 달라진다.</p><ul><li><strong>데이터 정렬이 필요한 경우</strong>: 이진 검색 트리에서 중위 순회 사용</li><li><strong>트리 복제가 필요한 경우</strong>: 전위 순회 사용</li><li><strong>상향식 계산이 필요한 경우</strong>: 후위 순회 사용</li><li><strong>최단 경로 찾기가 필요한 경우</strong>: 레벨 순회(BFS) 사용</li><li><strong>가장 깊은 노드 찾기가 필요한 경우</strong>: 깊이 우선 순회(DFS) 사용</li></ul><h3 id=효율적인-트리-순회-구현을-위한-최적화-기법>효율적인 트리 순회 구현을 위한 최적화 기법<a hidden class=anchor aria-hidden=true href=#효율적인-트리-순회-구현을-위한-최적화-기법>#</a></h3><ol><li><p>꼬리 재귀 최적화(Tail Recursion Optimization)<br>꼬리 재귀는 재귀 호출이 함수의 마지막 작업일 때 발생한다.<br>이러한 경우 컴파일러는 재귀 호출을 반복문으로 최적화할 수 있다.</p></li><li><p>반복자(Iterator) 패턴 사용<br>반복자 패턴을 사용하면 트리 순회 로직을 캡슐화하고 순회 과정을 제어할 수 있다.</p></li><li><p>모리스 순회 알고리즘 사용<br>모리스 순회 알고리즘은 추가 공간을 사용하지 않고 트리를 순회할 수 있어, 메모리 제약이 있는 환경에서 유용하다.</p></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Preorder Traversal</h2></header><div class=entry-content><p>전위 순회(Preorder Traversal) 전위 순회(Preorder Traversal)는 트리 자료구조를 탐색하는 가장 기본적인 방법 중 하나이다.
전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태이다.
이 방법에서는 다음과 같은 순서로 노드를 방문한다:
현재 노드(루트)를 방문합니다. 왼쪽 서브트리를 전위 순회한다. 오른쪽 서브트리를 전위 순회한다. 이 과정은 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 “전위(Pre)“는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Preorder Traversal" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Inorder Traversal</h2></header><div class=entry-content><p>중위 순회(Inorder Traversal) 중위 순회(Inorder Traversal)는 트리 자료구조, 특히 이진 트리를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나이다. 이 순회 방식은 특유의 방문 순서 때문에 특별한 의미와 활용 가치를 지니고 있다.
왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.
이진 검색 트리에서 중위 순회를 수행하면 노드 값이 오름차순으로 방문되는 특성은 검색, 삽입, 삭제, 범위 쿼리 등 많은 작업에서 핵심적인 역할을 한다. 또한 표현식 트리에서 중위 표기법을 생성하거나 트리의 유효성을 검사하는 데에도 널리 사용된다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Inorder Traversal" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Postorder Traversal</h2></header><div class=entry-content><p>후위 순회(Postorder Traversal) 후위 순회(Postorder Traversal)는 트리 자료구조를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나로, 특별한 방문 순서와 특성을 가지고 있다.
후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.
트리 삭제, 표현식 평가, 디렉토리 크기 계산과 같은 작업에서 후위 순회의 특성이 자연스럽게 활용된다.
재귀적 구현이 가장 직관적이지만, 스택을 사용한 반복적 구현이나 모리스 순회와 같은 고급 기법을 통해 성능과 공간 효율성을 개선할 수 있다. 각 구현 방법은 상황에 따라 장단점이 있으므로, 문제의 성격과 제약 조건을 고려하여 적절한 방법을 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Postorder Traversal" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/postorder-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Level Order Traversal</h2></header><div class=entry-content><p>레벨 순서 순회 (Level Order Traversal) 트리 자료구조에서 레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.
이 순회 방식은 너비 우선 탐색(Breadth-First Search, BFS)의 일종으로 볼 수 있다.
레벨 순서 순회는 트리를 레벨별로 탐색하는 강력한 기법이다.
큐를 사용한 반복적 접근법이 가장 효율적인 구현 방식이며, 다양한 트리 문제를 해결하는 데 활용할 수 있다.
특히 트리의 구조적 특성을 분석하거나 레벨별 작업을 수행할 때 매우 유용하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Level Order Traversal" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/level-order-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Traversal 방법 비교</h2></header><div class=entry-content><p>Traversal 방법 비교 트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.
각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.
트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.
중위 순회(Inorder): 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다. 전위 순회(Preorder): 트리의 구조를 복제하거나 직렬화할 때 효과적이다. 후위 순회(Postorder): 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다. 레벨 순서 순회(Level Order): 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다. 각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.
...</p></div><footer class=entry-footer><span title='2024-12-06 11:54:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traversal 방법 비교" href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>