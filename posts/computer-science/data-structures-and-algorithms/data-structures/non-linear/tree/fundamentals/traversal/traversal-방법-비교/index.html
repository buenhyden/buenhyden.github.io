<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Traversal 방법 비교 | hyunyoun's Blog</title>
<meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Tree,Fundamentals,Traversal"><meta name=description content="트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Traversal 방법 비교"><meta property="og:description" content="트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-06T11:54:00+00:00"><meta property="article:modified_time" content="2024-12-06T11:54:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Tree"><meta property="article:tag" content="Fundamentals"><meta property="article:tag" content="Traversal"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Traversal 방법 비교"><meta name=twitter:description content="트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"기술 블로그","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"컴퓨터 과학","item":"https://buenhyden.github.io/posts/computer-science/"},{"@type":"ListItem","position":3,"name":"Data Structures and Algorithms","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/"},{"@type":"ListItem","position":4,"name":"Data Structures","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/"},{"@type":"ListItem","position":6,"name":"트리 (Tree)","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/"},{"@type":"ListItem","position":7,"name":"Fundamentals of Tree","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/"},{"@type":"ListItem","position":8,"name":"Traversal","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/"},{"@type":"ListItem","position":9,"name":"Traversal 방법 비교","item":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Traversal 방법 비교","name":"Traversal 방법 비교","description":"트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Tree","Fundamentals","Traversal"],"articleBody":"Traversal 방법 비교 트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.\n각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.\n트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.\n중위 순회(Inorder): 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다. 전위 순회(Preorder): 트리의 구조를 복제하거나 직렬화할 때 효과적이다. 후위 순회(Postorder): 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다. 레벨 순서 순회(Level Order): 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다. 각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.\n트리 순회의 주요 유형 트리 순회는 크게 깊이 우선 탐색(DFS, Depth-First Search)과 너비 우선 탐색(BFS, Breadth-First Search) 두 가지 방식으로 나뉜다.\n깊이 우선 탐색(DFS, Depth-First Search) 기반 순회 DFS 기반의 순회 방식은 트리의 깊이를 우선적으로 탐색하는 방식으로 다음과 같은 3가지 유형이 있다.\n순회 유형 방문 순서 탐색 원리 전위 순회 (Preorder Traversal) 루트 → 왼쪽 → 오른쪽 루트를 가장 먼저 방문 중위 순회 (Inorder Traversal) 왼쪽 → 루트 → 오른쪽 이진 탐색 트리(BST)에서 정렬된 순서로 방문 후위 순회 (Postorder Traversal) 왼쪽 → 오른쪽 → 루트 하위 노드를 모두 방문한 후 루트를 방문 재귀(Recursion) 또는 스택(Stack)을 사용하여 구현 가능 너비 우선 탐색(BFS, Breadth-First Search) 기반 순회 BFS 기반의 순회 방식은 트리의 레벨(층)을 순차적으로 탐색하는 방식으로, 레벨 순회(Level Order Traversal) 가 대표적이다.\n순회 유형 방문 순서 탐색 원리 레벨 순회 (Level Order Traversal) 층(Level)별로 왼쪽에서 오른쪽으로 순회 큐(Queue)를 사용하여 한 레벨씩 방문 큐(Queue)를 사용하여 구현 트리 순회 유형별 예제 다음과 같은 이진 트리를 가정해보면:\n1 2 3 4 5 A / \\ B C / \\ \\ D E F 각 순회 방법에 따라 방문 순서는 다음과 같다.\n순회 유형 방문 순서 전위 순회 (Preorder) A → B → D → E → C → F 중위 순회 (Inorder) D → B → E → A → C → F 후위 순회 (Postorder) D → E → B → F → C → A 레벨 순회 (Level Order) A → B → C → D → E → F 다음과 같은 이진 트리를 예로 들어보면:\n1 2 3 4 5 6 7 1 / \\ 2 3 / \\ \\ 4 5 6 / 7 각 순회 방법의 결과는 다음과 같다:\n중위 순회(Inorder): [4, 2, 7, 5, 1, 3, 6] 전위 순회(Preorder): [1, 2, 4, 5, 7, 3, 6] 후위 순회(Postorder): [4, 7, 5, 2, 6, 3, 1] 레벨 순서 순회(Level Order): [[1], [2, 3], [4, 5, 6], [7]] 트리 순회 전위 순회 (Preorder Traversal) 구조: 루트 → 왼쪽 서브트리 → 오른쪽 서브트리 순서: 현재 노드(루트)를 방문 왼쪽 서브트리 탐색 오른쪽 서브트리 탐색 특징: 트리의 구조를 그대로 유지하며 복사하거나, 연산자 우선순위가 없는 표현식 트리(Polish Notation)를 탐색할 때 사용됨 DFS 방식으로 구현되며 재귀 또는 스택을 이용한 반복적 방법으로 구현 가능 예제 (다음과 같은 트리를 전위 순회한다고 가정) 1 2 3 4 5 A / \\ B C / \\ \\ D E F 전위 순회 결과:\nA → B → D → E → C → F\nPython 구현\n1 2 3 4 5 6 def preorder_traversal(node): if node is None: return print(node.value, end=\" \") preorder_traversal(node.left) preorder_traversal(node.right) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def preorder_traversal(root): result = [] def preorder(node): if node: # 1. 현재 노드 방문 result.append(node.val) # 2. 왼쪽 서브트리 방문 preorder(node.left) # 3. 오른쪽 서브트리 방문 preorder(node.right) preorder(root) return result # 반복적(비재귀) 방식 def preorder_traversal_iterative(root): if not root: return [] result = [] stack = [root] while stack: # 스택에서 노드를 꺼내고 방문 node = stack.pop() result.append(node.val) # 오른쪽 자식을 먼저 스택에 넣어 왼쪽 자식이 먼저 처리되도록 함 if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result 전위 순회는 트리 구조를 복제하거나 직렬화할 때 특히 유용하다. 루트 노드가 먼저 방문되기 때문에, 트리의 구조를 먼저 설정한 후 자식 노드를 처리할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function preorderTraversal(root) { if (!root) return []; const result = []; const stack = [root]; while (stack.length \u003e 0) { const node = stack.pop(); result.push(node.val); // 오른쪽 자식을 먼저 스택에 넣어 왼쪽이 먼저 처리되도록 함 if (node.right) stack.push(node.right); if (node.left) stack.push(node.left); } return result; } 전위 순회의 응용 트리 직렬화: 전위 순회 결과와 중위 순회 결과만 있으면 이진 트리를 완전히 재구성할 수 있다. 트리의 깊은 복사(Deep Copy): 전위 순회를 사용하여 트리의 구조를 그대로 복제할 수 있다. 접두사 표기법(Prefix Notation): 수식 트리에서 전위 순회는 접두사 표기법(폴란드 표기법)으로 수식을 표현한다. 중위 순회 (Inorder Traversal) 구조: 왼쪽 서브트리 → 루트 → 오른쪽 서브트리 순서: 왼쪽 서브트리 탐색 현재 노드(루트) 방문 오른쪽 서브트리 탐색 특징: 이진 탐색 트리(Binary Search Tree, BST) 에서 오름차순 정렬된 결과를 얻을 수 있음 DFS 방식으로 구현되며 재귀 또는 스택을 이용한 반복적 방법으로 구현 가능 예제 중위 순회 결과:\nD → B → E → A → C → F\nPython 구현\n1 2 3 4 5 6 def inorder_traversal(node): if node is None: return inorder_traversal(node.left) print(node.value, end=\" \") inorder_traversal(node.right) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def inorder_traversal(root): result = [] def inorder(node): if node: # 1. 왼쪽 서브트리 방문 inorder(node.left) # 2. 현재 노드 방문 result.append(node.val) # 3. 오른쪽 서브트리 방문 inorder(node.right) inorder(root) return result # 반복적(비재귀) 방식 def inorder_traversal_iterative(root): result = [] stack = [] current = root while current or stack: # 가장 왼쪽 노드까지 이동 while current: stack.append(current) current = current.left # 스택에서 노드를 꺼내고 방문 current = stack.pop() result.append(current.val) # 오른쪽 서브트리로 이동 current = current.right return result 중위 순회는 이진 탐색 트리(BST)에서 특히 유용하다.\nBST에서 중위 순회를 수행하면 노드가 오름차순으로 방문되는데, 이는 정렬된 배열이 필요할 때 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function inorderTraversal(root) { const result = []; const stack = []; let current = root; while (current || stack.length \u003e 0) { // 왼쪽 끝까지 이동 while (current) { stack.push(current); current = current.left; } // 스택에서 노드를 꺼내고 값 추가 current = stack.pop(); result.push(current.val); // 오른쪽으로 이동 current = current.right; } return result; } 중위 순회의 응용 이진 탐색 트리 검증: 중위 순회 결과가 정렬되어 있는지 확인하여 BST의 유효성을 검사할 수 있다. 모리스 순회(Morris Traversal): 추가 공간 사용 없이 O(1) 공간 복잡도로 중위 순회를 수행할 수 있는 고급 기법이다. k번째 작은 요소 찾기: BST에서 중위 순회를 수행하며 k번째 노드를 찾을 수 있다. 후위 순회 (Postorder Traversal) 구조: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트 순서: 왼쪽 서브트리 탐색 오른쪽 서브트리 탐색 현재 노드(루트) 방문 특징: 트리의 모든 자식 노드를 먼저 처리한 후 루트를 방문하는 구조 폴더 삭제, 수식 트리 계산(연산자 우선순위 적용) 등에 많이 사용 DFS 방식으로 구현되며 재귀 또는 스택을 이용한 반복적 방법으로 구현 가능 예제 후위 순회 결과:\nD → E → B → F → C → A\nPython 구현\n1 2 3 4 5 6 def postorder_traversal(node): if node is None: return postorder_traversal(node.left) postorder_traversal(node.right) print(node.value, end=\" \") 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def postorder_traversal(root): result = [] def postorder(node): if node: # 1. 왼쪽 서브트리 방문 postorder(node.left) # 2. 오른쪽 서브트리 방문 postorder(node.right) # 3. 현재 노드 방문 result.append(node.val) postorder(root) return result # 반복적(비재귀) 방식 def postorder_traversal_iterative(root): if not root: return [] result = [] stack = [root] visited = [] # 방문한 노드 저장 while stack: current = stack[-1] # 스택 최상단 노드 확인 # 자식 노드가 없거나 이미 방문했다면 현재 노드 방문 if (not current.left and not current.right) or \\ (current.left in visited and current.right in visited): node = stack.pop() visited.append(node) result.append(node.val) else: # 오른쪽 자식이 있다면 스택에 추가 if current.right and current.right not in visited: stack.append(current.right) # 왼쪽 자식이 있다면 스택에 추가 if current.left and current.left not in visited: stack.append(current.left) return result 후위 순회는 자식 노드를 모두 처리한 후에야 부모 노드를 처리한다.\n이는 트리의 각 노드에서 수행된 작업의 결과를 부모 노드에서 사용해야 할 때 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function postorderTraversal(root) { if (!root) return []; const result = []; const stack1 = [root]; const stack2 = []; // 첫 번째 스택에서 노드를 꺼내 두 번째 스택에 넣음 while (stack1.length \u003e 0) { const node = stack1.pop(); stack2.push(node); // 왼쪽 자식을 먼저 스택1에 넣어 오른쪽이 먼저 스택2에 들어가도록 함 if (node.left) stack1.push(node.left); if (node.right) stack1.push(node.right); } // 두 번째 스택에서 노드를 꺼내 결과에 추가 while (stack2.length \u003e 0) { result.push(stack2.pop().val); } return result; } 후위 순회의 응용 트리 삭제: 자식 노드를 먼저 제거한 후 부모 노드를 제거하는 방식으로 트리 전체를 안전하게 삭제할 수 있다. 수식 계산: 후위 표기법(역폴란드 표기법)으로 표현된 수식을 계산할 때 사용된다. 디렉토리 크기 계산: 파일 시스템에서 디렉토리의 총 크기를 계산할 때, 각 하위 디렉토리의 크기를 먼저 계산한 후 합산한다. 레벨 순회 (Level Order Traversal) 구조: 루트부터 시작하여 같은 레벨의 노드를 왼쪽에서 오른쪽으로 탐색 순서: 루트 노드 방문 첫 번째 레벨의 노드들 방문 (좌 → 우) 두 번째 레벨의 노드들 방문 (좌 → 우) 더 이상 노드가 없을 때까지 반복 특징: 큐(Queue)를 이용하여 구현 최단 경로 탐색, AI 탐색(미니맥스, 알파베타 가지치기) 등에 사용됨 예제 레벨 순회 결과:\nA → B → C → D → E → F\nPython 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 from collections import deque def level_order_traversal(root): if root is None: return queue = deque([root]) while queue: node = queue.popleft() print(node.value, end=\" \") if node.left: queue.append(node.left) if node.right: queue.append(node.right) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from collections import deque def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result 레벨 순서 순회는 너비 우선 탐색(BFS)을 사용하여 레벨별로 노드를 방문한다. 이는 최단 경로 문제나 트리의 구조적 특성을 분석할 때 유용하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function levelOrderTraversal(root) { if (!root) return []; const result = []; const queue = [root]; while (queue.length \u003e 0) { const levelSize = queue.length; const currentLevel = []; for (let i = 0; i \u003c levelSize; i++) { const node = queue.shift(); currentLevel.push(node.val); if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } result.push(currentLevel); } return result; } 레벨 순서 순회의 응용 최소 높이 트리: 트리를 레벨 순으로 구축하면 최소 높이를 보장할 수 있다. 트리의 너비 계산: 각 레벨의 노드 수를 세어 트리의 최대 너비를 찾을 수 있다. 지그재그 순회(Zigzag Traversal): 레벨 순회의 변형으로, 홀수 레벨에서는 왼쪽에서 오른쪽으로, 짝수 레벨에서는 오른쪽에서 왼쪽으로 순회한다. 트리 순회의 비교 분석 순회 유형 구조 순서 사용 목적 시간 복잡도 공간 복잡도 장점 단점 전위 순회 (Preorder) DFS 루트 → 왼쪽 → 오른쪽 트리 복사, 표현식 변환 O(N) O(N) (재귀) 루트를 먼저 방문하여 빠른 탐색 가능 정렬된 순서로 데이터를 가져올 수 없음 중위 순회 (Inorder) DFS 왼쪽 → 루트 → 오른쪽 BST에서 정렬된 데이터 탐색 O(N) O(N) (재귀) BST에서 오름차순 정렬이 가능 이진 탐색 트리에만 적절 후위 순회 (Postorder) DFS 왼쪽 → 오른쪽 → 루트 폴더 삭제, 수식 계산 O(N) O(N) (재귀) 하위 구조를 먼저 처리하여 안정적인 삭제 가능 루트를 마지막에 방문하여 즉시 처리하기 어려움 레벨 순회 (Level Order) BFS 층별로 탐색 최단 경로 탐색, AI 탐색 O(N) O(N) (큐) 한 층씩 방문하여 직관적 탐색 가능 큐 사용으로 인해 메모리 사용량 증가 참고 및 출처 ","wordCount":"1988","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-12-06T11:54:00Z","dateModified":"2024-12-06T11:54:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>기술 블로그</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/>컴퓨터 과학</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/>Data Structures and Algorithms</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/>Data Structures</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/>트리 (Tree)</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/>Fundamentals of Tree</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/>Traversal</a></div><h1 class="post-title entry-hint-parent">Traversal 방법 비교</h1><div class=post-description>트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다.</div><div class=post-meta><span title='2024-12-06 11:54:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science/Data%20Structures%20and%20Algorithms/Data%20Structures/Non-Linear/Tree/Fundamentals/Traversal/traversal-%eb%b0%a9%eb%b2%95-%eb%b9%84%ea%b5%90.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#traversal-방법-비교>Traversal 방법 비교</a><ul><li><a href=#트리-순회의-주요-유형>트리 순회의 주요 유형</a></li><li><a href=#트리-순회-유형별-예제>트리 순회 유형별 예제</a></li><li><a href=#트리-순회>트리 순회</a></li><li><a href=#트리-순회의-비교-분석>트리 순회의 비교 분석</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=traversal-방법-비교>Traversal 방법 비교<a hidden class=anchor aria-hidden=true href=#traversal-방법-비교>#</a></h2><p>트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.<br>각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.</p><p>트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.</p><ul><li><strong>중위 순회(Inorder)</strong>: 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다.</li><li><strong>전위 순회(Preorder)</strong>: 트리의 구조를 복제하거나 직렬화할 때 효과적이다.</li><li><strong>후위 순회(Postorder)</strong>: 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다.</li><li><strong>레벨 순서 순회(Level Order)</strong>: 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다.</li></ul><p>각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.</p><h3 id=트리-순회의-주요-유형>트리 순회의 주요 유형<a hidden class=anchor aria-hidden=true href=#트리-순회의-주요-유형>#</a></h3><p>트리 순회는 크게 <strong>깊이 우선 탐색(DFS, Depth-First Search)과 너비 우선 탐색(BFS, Breadth-First Search)</strong> 두 가지 방식으로 나뉜다.</p><h4 id=깊이-우선-탐색dfs-depth-first-search-기반-순회>깊이 우선 탐색(DFS, Depth-First Search) 기반 순회<a hidden class=anchor aria-hidden=true href=#깊이-우선-탐색dfs-depth-first-search-기반-순회>#</a></h4><p>DFS 기반의 순회 방식은 <strong>트리의 깊이를 우선적으로 탐색하는 방식</strong>으로 다음과 같은 3가지 유형이 있다.</p><table><thead><tr><th>순회 유형</th><th>방문 순서</th><th>탐색 원리</th></tr></thead><tbody><tr><td><strong>전위 순회 (Preorder Traversal)</strong></td><td><strong>루트 → 왼쪽 → 오른쪽</strong></td><td>루트를 가장 먼저 방문</td></tr><tr><td><strong>중위 순회 (Inorder Traversal)</strong></td><td><strong>왼쪽 → 루트 → 오른쪽</strong></td><td>이진 탐색 트리(BST)에서 정렬된 순서로 방문</td></tr><tr><td><strong>후위 순회 (Postorder Traversal)</strong></td><td><strong>왼쪽 → 오른쪽 → 루트</strong></td><td>하위 노드를 모두 방문한 후 루트를 방문</td></tr></tbody></table><ul><li>재귀(Recursion) 또는 스택(Stack)을 사용하여 구현 가능</li></ul><h4 id=너비-우선-탐색bfs-breadth-first-search-기반-순회>너비 우선 탐색(BFS, Breadth-First Search) 기반 순회<a hidden class=anchor aria-hidden=true href=#너비-우선-탐색bfs-breadth-first-search-기반-순회>#</a></h4><p>BFS 기반의 순회 방식은 <strong>트리의 레벨(층)을 순차적으로 탐색하는 방식</strong>으로, <strong>레벨 순회(Level Order Traversal)</strong> 가 대표적이다.</p><table><thead><tr><th>순회 유형</th><th>방문 순서</th><th>탐색 원리</th></tr></thead><tbody><tr><td><strong>레벨 순회 (Level Order Traversal)</strong></td><td><strong>층(Level)별로 왼쪽에서 오른쪽으로 순회</strong></td><td>큐(Queue)를 사용하여 한 레벨씩 방문</td></tr></tbody></table><ul><li>큐(Queue)를 사용하여 구현</li></ul><h3 id=트리-순회-유형별-예제>트리 순회 유형별 예제<a hidden class=anchor aria-hidden=true href=#트리-순회-유형별-예제>#</a></h3><ol><li><p>다음과 같은 이진 트리를 가정해보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        A
</span></span><span class=line><span class=cl>       / \
</span></span><span class=line><span class=cl>      B   C
</span></span><span class=line><span class=cl>     / \   \
</span></span><span class=line><span class=cl>    D   E   F
</span></span></code></pre></td></tr></table></div></div><p>각 순회 방법에 따라 방문 순서는 다음과 같다.</p></li></ol><table><thead><tr><th>순회 유형</th><th>방문 순서</th></tr></thead><tbody><tr><td><strong>전위 순회 (Preorder)</strong></td><td><code>A → B → D → E → C → F</code></td></tr><tr><td><strong>중위 순회 (Inorder)</strong></td><td><code>D → B → E → A → C → F</code></td></tr><tr><td><strong>후위 순회 (Postorder)</strong></td><td><code>D → E → B → F → C → A</code></td></tr><tr><td><strong>레벨 순회 (Level Order)</strong></td><td><code>A → B → C → D → E → F</code></td></tr></tbody></table><ol><li><p>다음과 같은 이진 트리를 예로 들어보면:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>       1
</span></span><span class=line><span class=cl>     /   \
</span></span><span class=line><span class=cl>    2     3
</span></span><span class=line><span class=cl>   / \     \
</span></span><span class=line><span class=cl>  4   5     6
</span></span><span class=line><span class=cl>     /
</span></span><span class=line><span class=cl>    7
</span></span></code></pre></td></tr></table></div></div><p>각 순회 방법의 결과는 다음과 같다:</p><ul><li>중위 순회(Inorder): <code>[4, 2, 7, 5, 1, 3, 6]</code></li><li>전위 순회(Preorder): <code>[1, 2, 4, 5, 7, 3, 6]</code></li><li>후위 순회(Postorder): <code>[4, 7, 5, 2, 6, 3, 1]</code></li><li>레벨 순서 순회(Level Order): <code>[[1], [2, 3], [4, 5, 6], [7]]</code></li></ul></li></ol><h3 id=트리-순회>트리 순회<a hidden class=anchor aria-hidden=true href=#트리-순회>#</a></h3><h4 id=전위-순회-preorder-traversal>전위 순회 (Preorder Traversal)<a hidden class=anchor aria-hidden=true href=#전위-순회-preorder-traversal>#</a></h4><ul><li><strong>구조:</strong><ul><li><strong>루트 → 왼쪽 서브트리 → 오른쪽 서브트리</strong></li></ul></li><li><strong>순서:</strong><ol><li>현재 노드(루트)를 방문</li><li>왼쪽 서브트리 탐색</li><li>오른쪽 서브트리 탐색</li></ol></li><li><strong>특징:</strong><ul><li>트리의 구조를 그대로 유지하며 복사하거나, <strong>연산자 우선순위가 없는 표현식 트리(Polish Notation)를 탐색할 때 사용</strong>됨</li><li>DFS 방식으로 구현되며 <strong>재귀 또는 스택을 이용한 반복적 방법으로 구현 가능</strong></li></ul></li><li><strong>예제</strong> (다음과 같은 트리를 전위 순회한다고 가정)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>        A
</span></span><span class=line><span class=cl>       / \
</span></span><span class=line><span class=cl>      B   C
</span></span><span class=line><span class=cl>     / \   \
</span></span><span class=line><span class=cl>    D   E   F
</span></span></code></pre></td></tr></table></div></div><p><strong>전위 순회 결과:</strong><br><code>A → B → D → E → C → F</code></p><p><strong>Python 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>preorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>preorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>preorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1> 1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2> 2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3> 3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4> 4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5> 5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6> 6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7> 7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8> 8</a>
</span><span class=lnt id=hl-4-9><a class=lnlinks href=#hl-4-9> 9</a>
</span><span class=lnt id=hl-4-10><a class=lnlinks href=#hl-4-10>10</a>
</span><span class=lnt id=hl-4-11><a class=lnlinks href=#hl-4-11>11</a>
</span><span class=lnt id=hl-4-12><a class=lnlinks href=#hl-4-12>12</a>
</span><span class=lnt id=hl-4-13><a class=lnlinks href=#hl-4-13>13</a>
</span><span class=lnt id=hl-4-14><a class=lnlinks href=#hl-4-14>14</a>
</span><span class=lnt id=hl-4-15><a class=lnlinks href=#hl-4-15>15</a>
</span><span class=lnt id=hl-4-16><a class=lnlinks href=#hl-4-16>16</a>
</span><span class=lnt id=hl-4-17><a class=lnlinks href=#hl-4-17>17</a>
</span><span class=lnt id=hl-4-18><a class=lnlinks href=#hl-4-18>18</a>
</span><span class=lnt id=hl-4-19><a class=lnlinks href=#hl-4-19>19</a>
</span><span class=lnt id=hl-4-20><a class=lnlinks href=#hl-4-20>20</a>
</span><span class=lnt id=hl-4-21><a class=lnlinks href=#hl-4-21>21</a>
</span><span class=lnt id=hl-4-22><a class=lnlinks href=#hl-4-22>22</a>
</span><span class=lnt id=hl-4-23><a class=lnlinks href=#hl-4-23>23</a>
</span><span class=lnt id=hl-4-24><a class=lnlinks href=#hl-4-24>24</a>
</span><span class=lnt id=hl-4-25><a class=lnlinks href=#hl-4-25>25</a>
</span><span class=lnt id=hl-4-26><a class=lnlinks href=#hl-4-26>26</a>
</span><span class=lnt id=hl-4-27><a class=lnlinks href=#hl-4-27>27</a>
</span><span class=lnt id=hl-4-28><a class=lnlinks href=#hl-4-28>28</a>
</span><span class=lnt id=hl-4-29><a class=lnlinks href=#hl-4-29>29</a>
</span><span class=lnt id=hl-4-30><a class=lnlinks href=#hl-4-30>30</a>
</span><span class=lnt id=hl-4-31><a class=lnlinks href=#hl-4-31>31</a>
</span><span class=lnt id=hl-4-32><a class=lnlinks href=#hl-4-32>32</a>
</span><span class=lnt id=hl-4-33><a class=lnlinks href=#hl-4-33>33</a>
</span><span class=lnt id=hl-4-34><a class=lnlinks href=#hl-4-34>34</a>
</span><span class=lnt id=hl-4-35><a class=lnlinks href=#hl-4-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>preorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>preorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 현재 노드 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 2. 왼쪽 서브트리 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>preorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 3. 오른쪽 서브트리 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>preorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>preorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 반복적(비재귀) 방식</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>preorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 스택에서 노드를 꺼내고 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 자식을 먼저 스택에 넣어 왼쪽 자식이 먼저 처리되도록 함</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>전위 순회는 트리 구조를 복제하거나 직렬화할 때 특히 유용하다. 루트 노드가 먼저 방문되기 때문에, 트리의 구조를 먼저 설정한 후 자식 노드를 처리할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>preorderTraversal</span><span class=p>(</span><span class=nx>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>root</span><span class=p>)</span> <span class=k>return</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>stack</span> <span class=o>=</span> <span class=p>[</span><span class=nx>root</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nx>stack</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>node</span> <span class=o>=</span> <span class=nx>stack</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 오른쪽 자식을 먼저 스택에 넣어 왼쪽이 먼저 처리되도록 함
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>)</span> <span class=nx>stack</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>)</span> <span class=nx>stack</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=전위-순회의-응용>전위 순회의 응용<a hidden class=anchor aria-hidden=true href=#전위-순회의-응용>#</a></h5><ol><li><strong>트리 직렬화</strong>: 전위 순회 결과와 중위 순회 결과만 있으면 이진 트리를 완전히 재구성할 수 있다.</li><li><strong>트리의 깊은 복사(Deep Copy)</strong>: 전위 순회를 사용하여 트리의 구조를 그대로 복제할 수 있다.</li><li><strong>접두사 표기법(Prefix Notation)</strong>: 수식 트리에서 전위 순회는 접두사 표기법(폴란드 표기법)으로 수식을 표현한다.</li></ol><h4 id=중위-순회-inorder-traversal>중위 순회 (Inorder Traversal)<a hidden class=anchor aria-hidden=true href=#중위-순회-inorder-traversal>#</a></h4><ul><li><strong>구조:</strong><ul><li><strong>왼쪽 서브트리 → 루트 → 오른쪽 서브트리</strong></li></ul></li><li><strong>순서:</strong><ol><li>왼쪽 서브트리 탐색</li><li>현재 노드(루트) 방문</li><li>오른쪽 서브트리 탐색</li></ol></li><li><strong>특징:</strong><ul><li><strong>이진 탐색 트리(Binary Search Tree, BST)</strong> 에서 <strong>오름차순 정렬된 결과를 얻을 수 있음</strong></li><li>DFS 방식으로 구현되며 <strong>재귀 또는 스택을 이용한 반복적 방법으로 구현 가능</strong></li></ul></li><li><strong>예제</strong></li></ul><p><strong>중위 순회 결과:</strong><br><code>D → B → E → A → C → F</code></p><p><strong>Python 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=n>inorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>inorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>inorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 왼쪽 서브트리 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 2. 현재 노드 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 3. 오른쪽 서브트리 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>inorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>inorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 반복적(비재귀) 방식</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>inorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>current</span> <span class=o>=</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>current</span> <span class=ow>or</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 가장 왼쪽 노드까지 이동</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>current</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 스택에서 노드를 꺼내고 방문</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 오른쪽 서브트리로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>중위 순회는 이진 탐색 트리(BST)에서 특히 유용하다.<br>BST에서 중위 순회를 수행하면 노드가 오름차순으로 방문되는데, 이는 정렬된 배열이 필요할 때 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>inorderTraversal</span><span class=p>(</span><span class=nx>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>stack</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>current</span> <span class=o>=</span> <span class=nx>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nx>current</span> <span class=o>||</span> <span class=nx>stack</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 왼쪽 끝까지 이동
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=p>(</span><span class=nx>current</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>stack</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nx>current</span> <span class=o>=</span> <span class=nx>current</span><span class=p>.</span><span class=nx>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 스택에서 노드를 꺼내고 값 추가
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>current</span> <span class=o>=</span> <span class=nx>stack</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>current</span><span class=p>.</span><span class=nx>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 오른쪽으로 이동
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>current</span> <span class=o>=</span> <span class=nx>current</span><span class=p>.</span><span class=nx>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=중위-순회의-응용>중위 순회의 응용<a hidden class=anchor aria-hidden=true href=#중위-순회의-응용>#</a></h5><ol><li><strong>이진 탐색 트리 검증</strong>: 중위 순회 결과가 정렬되어 있는지 확인하여 BST의 유효성을 검사할 수 있다.</li><li><strong>모리스 순회(Morris Traversal)</strong>: 추가 공간 사용 없이 O(1) 공간 복잡도로 중위 순회를 수행할 수 있는 고급 기법이다.</li><li><strong>k번째 작은 요소 찾기</strong>: BST에서 중위 순회를 수행하며 k번째 노드를 찾을 수 있다.</li></ol><h4 id=후위-순회-postorder-traversal>후위 순회 (Postorder Traversal)<a hidden class=anchor aria-hidden=true href=#후위-순회-postorder-traversal>#</a></h4><ul><li><strong>구조:</strong><ul><li><strong>왼쪽 서브트리 → 오른쪽 서브트리 → 루트</strong></li></ul></li><li><strong>순서:</strong><ol><li>왼쪽 서브트리 탐색</li><li>오른쪽 서브트리 탐색</li><li>현재 노드(루트) 방문</li></ol></li><li><strong>특징:</strong><ul><li><strong>트리의 모든 자식 노드를 먼저 처리한 후 루트를 방문하는 구조</strong></li><li><strong>폴더 삭제, 수식 트리 계산(연산자 우선순위 적용)</strong> 등에 많이 사용</li><li>DFS 방식으로 구현되며 <strong>재귀 또는 스택을 이용한 반복적 방법으로 구현 가능</strong></li></ul></li><li><strong>예제</strong></li></ul><p><strong>후위 순회 결과:</strong><br><code>D → E → B → F → C → A</code></p><p><strong>Python 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=n>postorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>postorder_traversal</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span><span class=lnt id=hl-10-32><a class=lnlinks href=#hl-10-32>32</a>
</span><span class=lnt id=hl-10-33><a class=lnlinks href=#hl-10-33>33</a>
</span><span class=lnt id=hl-10-34><a class=lnlinks href=#hl-10-34>34</a>
</span><span class=lnt id=hl-10-35><a class=lnlinks href=#hl-10-35>35</a>
</span><span class=lnt id=hl-10-36><a class=lnlinks href=#hl-10-36>36</a>
</span><span class=lnt id=hl-10-37><a class=lnlinks href=#hl-10-37>37</a>
</span><span class=lnt id=hl-10-38><a class=lnlinks href=#hl-10-38>38</a>
</span><span class=lnt id=hl-10-39><a class=lnlinks href=#hl-10-39>39</a>
</span><span class=lnt id=hl-10-40><a class=lnlinks href=#hl-10-40>40</a>
</span><span class=lnt id=hl-10-41><a class=lnlinks href=#hl-10-41>41</a>
</span><span class=lnt id=hl-10-42><a class=lnlinks href=#hl-10-42>42</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>postorder</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 왼쪽 서브트리 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 2. 오른쪽 서브트리 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>postorder</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 3. 현재 노드 방문</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>postorder</span><span class=p>(</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 반복적(비재귀) 방식</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>postorder_traversal_iterative</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>stack</span> <span class=o>=</span> <span class=p>[</span><span class=n>root</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>visited</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 방문한 노드 저장</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>stack</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current</span> <span class=o>=</span> <span class=n>stack</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>  <span class=c1># 스택 최상단 노드 확인</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 자식 노드가 없거나 이미 방문했다면 현재 노드 방문</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=ow>not</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span><span class=p>)</span> <span class=ow>or</span> \
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>left</span> <span class=ow>in</span> <span class=n>visited</span> <span class=ow>and</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>stack</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>visited</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 오른쪽 자식이 있다면 스택에 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span> <span class=ow>and</span> <span class=n>current</span><span class=o>.</span><span class=n>right</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># 왼쪽 자식이 있다면 스택에 추가</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span> <span class=ow>and</span> <span class=n>current</span><span class=o>.</span><span class=n>left</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>visited</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>stack</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>후위 순회는 자식 노드를 모두 처리한 후에야 부모 노드를 처리한다.<br>이는 트리의 각 노드에서 수행된 작업의 결과를 부모 노드에서 사용해야 할 때 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span><span class=lnt id=hl-11-14><a class=lnlinks href=#hl-11-14>14</a>
</span><span class=lnt id=hl-11-15><a class=lnlinks href=#hl-11-15>15</a>
</span><span class=lnt id=hl-11-16><a class=lnlinks href=#hl-11-16>16</a>
</span><span class=lnt id=hl-11-17><a class=lnlinks href=#hl-11-17>17</a>
</span><span class=lnt id=hl-11-18><a class=lnlinks href=#hl-11-18>18</a>
</span><span class=lnt id=hl-11-19><a class=lnlinks href=#hl-11-19>19</a>
</span><span class=lnt id=hl-11-20><a class=lnlinks href=#hl-11-20>20</a>
</span><span class=lnt id=hl-11-21><a class=lnlinks href=#hl-11-21>21</a>
</span><span class=lnt id=hl-11-22><a class=lnlinks href=#hl-11-22>22</a>
</span><span class=lnt id=hl-11-23><a class=lnlinks href=#hl-11-23>23</a>
</span><span class=lnt id=hl-11-24><a class=lnlinks href=#hl-11-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>postorderTraversal</span><span class=p>(</span><span class=nx>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>root</span><span class=p>)</span> <span class=k>return</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>stack1</span> <span class=o>=</span> <span class=p>[</span><span class=nx>root</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>stack2</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 첫 번째 스택에서 노드를 꺼내 두 번째 스택에 넣음
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=nx>stack1</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>node</span> <span class=o>=</span> <span class=nx>stack1</span><span class=p>.</span><span class=nx>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=nx>stack2</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1>// 왼쪽 자식을 먼저 스택1에 넣어 오른쪽이 먼저 스택2에 들어가도록 함
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>)</span> <span class=nx>stack1</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>)</span> <span class=nx>stack1</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// 두 번째 스택에서 노드를 꺼내 결과에 추가
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=nx>stack2</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>stack2</span><span class=p>.</span><span class=nx>pop</span><span class=p>().</span><span class=nx>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=후위-순회의-응용>후위 순회의 응용<a hidden class=anchor aria-hidden=true href=#후위-순회의-응용>#</a></h5><ol><li><strong>트리 삭제</strong>: 자식 노드를 먼저 제거한 후 부모 노드를 제거하는 방식으로 트리 전체를 안전하게 삭제할 수 있다.</li><li><strong>수식 계산</strong>: 후위 표기법(역폴란드 표기법)으로 표현된 수식을 계산할 때 사용된다.</li><li><strong>디렉토리 크기 계산</strong>: 파일 시스템에서 디렉토리의 총 크기를 계산할 때, 각 하위 디렉토리의 크기를 먼저 계산한 후 합산한다.</li></ol><h4 id=레벨-순회-level-order-traversal>레벨 순회 (Level Order Traversal)<a hidden class=anchor aria-hidden=true href=#레벨-순회-level-order-traversal>#</a></h4><ul><li><strong>구조:</strong><ul><li><strong>루트부터 시작하여 같은 레벨의 노드를 왼쪽에서 오른쪽으로 탐색</strong></li></ul></li><li><strong>순서:</strong><ol><li>루트 노드 방문</li><li>첫 번째 레벨의 노드들 방문 (좌 → 우)</li><li>두 번째 레벨의 노드들 방문 (좌 → 우)</li><li>더 이상 노드가 없을 때까지 반복</li></ol></li><li><strong>특징:</strong><ul><li><strong>큐(Queue)를 이용하여 구현</strong></li><li><strong>최단 경로 탐색, AI 탐색(미니맥스, 알파베타 가지치기) 등에 사용됨</strong></li></ul></li><li><strong>예제</strong></li></ul><p><strong>레벨 순회 결과:</strong><br><code>A → B → C → D → E → F</code></p><p><strong>Python 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>level_order_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>root</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>value</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34; &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span><span class=lnt id=hl-13-25><a class=lnlinks href=#hl-13-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>level_order_traversal</span><span class=p>(</span><span class=n>root</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span> <span class=o>=</span> <span class=n>deque</span><span class=p>([</span><span class=n>root</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>level_size</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>current_level</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>level_size</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>current_level</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=o>.</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>current_level</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>레벨 순서 순회는 너비 우선 탐색(BFS)을 사용하여 레벨별로 노드를 방문한다. 이는 최단 경로 문제나 트리의 구조적 특성을 분석할 때 유용하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>levelOrderTraversal</span><span class=p>(</span><span class=nx>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>root</span><span class=p>)</span> <span class=k>return</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>queue</span> <span class=o>=</span> <span class=p>[</span><span class=nx>root</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nx>queue</span><span class=p>.</span><span class=nx>length</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>levelSize</span> <span class=o>=</span> <span class=nx>queue</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kr>const</span> <span class=nx>currentLevel</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>levelSize</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kr>const</span> <span class=nx>node</span> <span class=o>=</span> <span class=nx>queue</span><span class=p>.</span><span class=nx>shift</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=nx>currentLevel</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>)</span> <span class=nx>queue</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>)</span> <span class=nx>queue</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>node</span><span class=p>.</span><span class=nx>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=nx>result</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>currentLevel</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=레벨-순서-순회의-응용>레벨 순서 순회의 응용<a hidden class=anchor aria-hidden=true href=#레벨-순서-순회의-응용>#</a></h5><ol><li><strong>최소 높이 트리</strong>: 트리를 레벨 순으로 구축하면 최소 높이를 보장할 수 있다.</li><li><strong>트리의 너비 계산</strong>: 각 레벨의 노드 수를 세어 트리의 최대 너비를 찾을 수 있다.</li><li><strong>지그재그 순회(Zigzag Traversal)</strong>: 레벨 순회의 변형으로, 홀수 레벨에서는 왼쪽에서 오른쪽으로, 짝수 레벨에서는 오른쪽에서 왼쪽으로 순회한다.</li></ol><h3 id=트리-순회의-비교-분석>트리 순회의 비교 분석<a hidden class=anchor aria-hidden=true href=#트리-순회의-비교-분석>#</a></h3><table><thead><tr><th>순회 유형</th><th>구조</th><th>순서</th><th>사용 목적</th><th>시간 복잡도</th><th>공간 복잡도</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td><strong>전위 순회 (Preorder)</strong></td><td>DFS</td><td>루트 → 왼쪽 → 오른쪽</td><td>트리 복사, 표현식 변환</td><td>O(N)</td><td>O(N) (재귀)</td><td>루트를 먼저 방문하여 빠른 탐색 가능</td><td>정렬된 순서로 데이터를 가져올 수 없음</td></tr><tr><td><strong>중위 순회 (Inorder)</strong></td><td>DFS</td><td>왼쪽 → 루트 → 오른쪽</td><td>BST에서 정렬된 데이터 탐색</td><td>O(N)</td><td>O(N) (재귀)</td><td>BST에서 오름차순 정렬이 가능</td><td>이진 탐색 트리에만 적절</td></tr><tr><td><strong>후위 순회 (Postorder)</strong></td><td>DFS</td><td>왼쪽 → 오른쪽 → 루트</td><td>폴더 삭제, 수식 계산</td><td>O(N)</td><td>O(N) (재귀)</td><td>하위 구조를 먼저 처리하여 안정적인 삭제 가능</td><td>루트를 마지막에 방문하여 즉시 처리하기 어려움</td></tr><tr><td><strong>레벨 순회 (Level Order)</strong></td><td>BFS</td><td>층별로 탐색</td><td>최단 경로 탐색, AI 탐색</td><td>O(N)</td><td>O(N) (큐)</td><td>한 층씩 방문하여 직관적 탐색 가능</td><td>큐 사용으로 인해 메모리 사용량 증가</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/tree/>Tree</a></li><li><a href=https://buenhyden.github.io/tags/fundamentals/>Fundamentals</a></li><li><a href=https://buenhyden.github.io/tags/traversal/>Traversal</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/><span class=title>« Prev</span><br><span>Back Tracking vs. Depth-First Search</span>
</a><a class=next href=https://buenhyden.github.io/posts/computer-science/fundamentals/runtime/><span class=title>Next »</span><br><span>Runtime</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>