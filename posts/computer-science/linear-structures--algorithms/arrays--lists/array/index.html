<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>배열 (Array) | hyunyoun's Blog</title><meta name=keywords content="Data-Structures-and-Algorithms,Data-Structures,Array"><meta name=description content="배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/arrays--lists/array/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/arrays--lists/array/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/arrays--lists/array/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="배열 (Array)"><meta property="og:description" content="배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-07T05:52:00+00:00"><meta property="article:modified_time" content="2024-10-07T05:52:00+00:00"><meta property="article:tag" content="Data-Structures-and-Algorithms"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Array"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="배열 (Array)"><meta name=twitter:description content="배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"배열 (Array)","item":"https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/arrays--lists/array/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"배열 (Array)","name":"배열 (Array)","description":"배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.","keywords":["Data-Structures-and-Algorithms","Data-Structures","Array"],"articleBody":"배열 (Array) 배열은 동일한 데이터 타입의 여러 값을 연속적인 메모리 공간에 순차적으로 저장하는 선형 자료구조로, 인덱스를 통해 빠른 접근이 가능한 특징이 있다.\n배열은 초기 한 번 선언 시 정해진 크기를 가지며, 이 크기를 변경하기 어렵기 때문에 메모리 관리와 연산 측면에서 장단점을 지니고 있다.\n배열은 같은 데이터 타입의 값들을 하나의 변수명으로 관리하며, 각 요소는 메모리상에 연속된 위치에 저장된다. **인덱스(index)**를 이용하여 원하는 위치의 데이터를 빠르게 검색할 수 있으며, 대부분 0번부터 시작하는 경우가 많다. 배열은 선형 자료구조이므로, 요소들이 순차적으로 배치되어 있어 특정 인덱스에 접근할 때 기본 위치에 오프셋을 더하는 방식으로 계산된다. 배열의 특징 연속성\n배열의 요소들은 메모리상에 연속적으로 저장된다.\n이는 요소에 빠르게 접근할 수 있게 해주지만, 크기 변경에는 제약이 있다.\n인덱싱\n배열의 각 요소는 고유한 인덱스 번호를 가지며, 이 인덱스를 통해 O(1) 시간 복잡도로 직접 접근이 가능하다.\n고정된 크기(일부 언어)\nC와 같은 일부 언어에서는 배열 선언 시 크기를 미리 지정해야 하며, 이후 변경이 불가능하다.\n반면 JavaScript, Python 등 동적 언어에서는 크기가 자유롭게 변할 수 있다.\n동일한 데이터 타입\n전통적인 배열은 모든 요소가 동일한 데이터 타입을 가져야 한다. 이는 메모리 계산을 단순화하고 효율적인 저장을 가능하게 한다.\n배열의 장점 빠른 검색 및 접근: 인덱스를 통한 직접 접근(random access)이 가능하여 데이터 검색이 빠르다. 캐시 효율성: 메모리 공간이 연속적이기 때문에 캐시 지역성(Cache Locality) 활용하여 캐시 적중률이 높아 성능에 유리하다. 구현이 간단함: 한 번 선언하면 요소 관리가 용이하며, 복잡한 부가정보 없이 데이터를 저장할 수 있다. 배열의 캐시 인접성(Cache Locality)이 왜 중요할까?\n배열은 메모리 내에 연속적으로 배치되기 때문에 하나의 원소에 접근할 때 인접한 여러 원소들이 동시에 캐시에 로드되어, 이후의 접근 시 빠른 데이터 처리가 가능해진다. 배열과 캐시 인접성의 개념 배열은 메모리 상에 연속된 블록에 데이터를 저장한다. 한 번의 메모리 접근으로 캐시 라인에 로드된 데이터를 활용해 여러 원소에 빠르게 접근할 수 있다. 인접한 데이터들이 캐시에 함께 로드되므로, 순차적인 데이터 접근(예: 반복문을 통한 처리)이 효율적으로 동작한다. 캐시 인접성이 중요한 이유 빠른 메모리 접근: 배열 원소 접근 시 인접한 원소들도 함께 로드되어, 추가 메모리 접근 없이도 빠른 데이터 처리를 할 수 있다. 캐시 히트율 증가: 순차적 접근은 캐시 미스 횟수를 줄여 전체 연산 시간을 단축시키며, 이는 응용 프로그램의 성능 향상에 크게 기여한다. 효율적인 데이터 처리: 특히 대량의 데이터를 다루는 경우, 캐시 인접성이 높은 구조인 배열은 포인터 기반의 분산형 자료구조(예: 연결 리스트)보다 훨씬 효율적이다. 실무적 예시와 고려사항 배열에 저장된 정수형 데이터에 대해 반복문으로 순차적으로 접근하는 경우, 첫 번째 원소 접근 시 인접한 여러 값들이 캐시에 로드되어 이후 반복문 내에서 빠른 접근이 가능하다. 이는 데이터 분석, 이미지 처리, 과학 연산 등 많은 분야에서 성능 최적화의 핵심 요소로 작용한다. 반면, 연결 리스트와 같이 메모리 내에 비연속적으로 분산된 자료구조는 캐시 미스가 잦아 접근 속도가 저하되므로, 데이터 구조 선택 시 캐시 인접성을 중요한 고려 요소로 삼아야 한다. 캐시 인접성을 최대한 활용하기 위해서는 순차적인 데이터 접근 패턴을 유지하는 것이 좋으며, 이를 위해 필요한 경우 배열 혹은 행 우선(row-major) 방식의 2D 배열과 같은 캐시 친화적 자료구조를 선택하는 것이 유리하다. 배열의 단점 크기 변경의 어려움: 한 번 선언된 크기를 변경하기 어렵기 때문에, 데이터 추가 시 크기 초과 문제가 발생할 수 있다. 삽입 및 삭제의 비효율성: 중간에 요소를 삽입하거나 삭제할 때 해당 인덱스 이후의 모든 요소 이동이 필요하여 연산 비용이 증가한다. 메모리 활용의 한계: 고정된 크기로 인해 할당한 메모리 공간의 일부가 사용되지 않을 경우 메모리 낭비가 발생할 수 있다. 배열의 주요 연산 및 시간 복잡도 연산 설명 시간 복잡도 접근 (Access) 배열[index]를 이용한 요소 접근 O(1) 탐색 (Search) 특정 값을 찾기 위해 전체 배열을 순회 O(n) 삽입 (Insert) 배열 중간에 요소 삽입 (이동이 필요) O(n) 삭제 (Delete) 특정 요소 삭제 후 이동 필요 O(n) 접근: 배열의 인덱스를 알고 있다면 즉시 접근 가능 (O(1)) 탐색: 배열에서 특정 값을 찾기 위해 선형 탐색이 필요 (O(n)) 삽입 및 삭제: 요소 이동이 필요하므로 최악의 경우 O(n) 이다. 배열과 연결 리스트 비교 비교 항목 배열 (Array) 연결 리스트 (Linked List) 메모리 할당 연속된 공간에 할당 노드별 개별 할당 접근 속도 빠름 (O(1)) 느림 (O(n)) 크기 조절 불가능 (고정 크기) 가능 (동적 크기) 삽입/삭제 비효율적 (O(n)) 효율적 (O(1) ~ O(n)) 메모리 사용 효율적 (오버헤드 없음) 비효율적 (포인터 필요) 배열은 고정된 크기로 선언되며, 크기 변경이 어렵지만 빠른 데이터 접근이 가능하다. 연결 리스트는 동적으로 크기 변경이 가능하지만 노드 탐색이 느리다. 배열의 종류 1차원 배열: 가장 기본적인 형태로, 한 줄로 데이터가 나열된다.\n1 2 # Python에서의 1차원 배열 예시 numbers = [1, 2, 3, 4, 5] 다차원 배열: 2차원, 3차원 등 여러 차원으로 구성된 배열이다. 2차원 배열은 행과 열을 가진 표 형태로 생각할 수 있다.\n1 2 3 4 5 6 7 # Python에서의 2차원 배열 예시 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # matrix[1][2]는 6을 반환합니다 희소 배열(Sparse Array): 대부분의 요소가 기본값(보통 0)인 배열을 효율적으로 저장하기 위한 특수한 형태이다.\n배열의 구현 방식 정적 배열: 메모리에 고정된 크기로 할당되며, 크기 변경이 불가능하다.\n1 2 // C에서의 정적 배열 선언 int numbers[5] = {1, 2, 3, 4, 5}; 동적 배열: 필요에 따라 크기가 조정되는 배열이다. 많은 현대 언어들은 내부적으로 동적 배열을 구현하고 있다.\n1 2 3 // JavaScript에서의 동적 배열 let numbers = [1, 2, 3]; numbers.push(4); // 배열에 새 요소 추가 동적 배열의 확장 원리:\n배열이 가득 차면 더 큰 크기(보통 2배)의 새 배열을 할당 기존 배열의 모든 요소를 새 배열로 복사 기존 배열 메모리 해제 새 배열 참조로 업데이트 언어별 배열 구현 특징 C/C++\n정적 크기 배열과 동적 할당 배열 모두 지원 메모리 직접 관리 필요 포인터 연산을 통한 접근 가능 1 2 3 4 // C에서의 동적 배열 할당 int* arr = (int*)malloc(5 * sizeof(int)); // 사용 후 반드시 해제 free(arr); Java\n배열은 객체로 취급 기본형, 참조형 배열 모두 지원 ArrayList로 동적 크기 지원 1 2 3 4 // Java에서의 배열 선언 int[] numbers = new int[5]; // 동적 배열은 ArrayList 사용 ArrayList\u003cInteger\u003e dynamicNumbers = new ArrayList\u003c\u003e(); Python\n리스트(List)가 동적 배열 역할 다양한 타입의 요소 저장 가능 내장 메서드가 풍부함 1 2 3 # Python 리스트 numbers = [1, 2, 3] numbers.append(4) # 요소 추가 JavaScript\n배열은 객체의 특수한 형태 동적 크기와 다양한 타입 지원 희소 배열 지원 1 2 3 // JavaScript 배열 let numbers = [1, 2, 3]; numbers.push(4); // 요소 추가 배열의 응용 벡터(Vector): 동적 크기를 가진 배열의 추상화된 형태로, C++의 STL vector나 Java의 ArrayList 등이 있다. 행렬(Matrix): 2차원 배열을 활용한 수학적 객체로, 선형대수학에서 중요하게 사용된다. 스택과 큐: 배열을 기반으로 구현될 수 있는 또 다른 자료구조. 대표적인 배열 알고리즘 정렬 알고리즘 배열 요소를 특정 순서로 재배열하는 알고리즘.\n버블 정렬, 선택 정렬, 삽입 정렬: O(n²) 퀵 정렬, 합병 정렬: O(n log n) 1 2 3 4 5 6 # Python에서의 배열 정렬 numbers = [5, 2, 8, 1, 9] # 내장 정렬 함수 사용 sorted_numbers = sorted(numbers) # [1, 2, 5, 8, 9] # 또는 원본 배열 정렬 numbers.sort() # numbers는 이제 [1, 2, 5, 8, 9] 검색 알고리즘 선형 검색: 배열의 모든 요소를 순차적으로 확인 이진 검색: 정렬된 배열에서 중간값 비교를 통해 검색 범위를 절반씩 줄여가는 방식 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Python에서의 이진 검색 def binary_search(arr, target): left, right = 0, len(arr) - 1 while left \u003c= right: mid = (left + right) // 2 if arr[mid] == target: return mid # 찾은 요소의 인덱스 반환 elif arr[mid] \u003c target: left = mid + 1 else: right = mid - 1 return -1 # 요소가 없을 경우 # 정렬된 배열에서 사용 sorted_arr = [1, 2, 3, 5, 8] index = binary_search(sorted_arr, 5) # 3 반환 실무에서의 배열 활용 팁 적절한 초기 크기 설정: 동적 배열을 사용할 때도 예상되는 데이터 크기에 맞게 초기 크기를 설정하면 불필요한 재할당을 줄일 수 있다.\n슬라이싱(Slicing) 활용: 많은 언어에서 배열의 일부분을 쉽게 추출할 수 있는 슬라이싱 기능을 제공한다.\n1 2 3 # Python에서의 슬라이싱 numbers = [0, 1, 2, 3, 4, 5] sub_array = numbers[1:4] # [1, 2, 3] 배열 복사 시 주의점: 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이를 이해하고 적절히 활용해야 한다.\n1 2 3 4 5 6 7 8 9 10 11 # Python에서의 배열 복사 import copy original = [1, [2, 3], 4] shallow_copy = original.copy() # 또는 original[:] deep_copy = copy.deepcopy(original) # 중첩된 배열 수정 시 차이 발생 original[1][0] = 99 print(shallow_copy) # [1, [99, 3], 4] print(deep_copy) # [1, [2, 3], 4] 참고 및 출처 ","wordCount":"1312","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-10-07T05:52:00Z","dateModified":"2024-10-07T05:52:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/arrays--lists/array/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">배열 (Array)</h1><div class=post-description>배열은 동일한 데이터 타입의 요소들을 연속된 메모리 공간에 저장하는 가장 기본적인 데이터 구조.</div><div class=post-meta><span title='2024-10-07 05:52:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/buenhyden/blog-data/main/content/posts/Computer%20Science/Linear%20Structures%20&%20Algorithms/Arrays%20&%20Lists/Array.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#배열-array>배열 (Array)</a><ul><li><a href=#배열의-특징>배열의 특징</a></li><li><a href=#배열의-장점>배열의 장점</a></li><li><a href=#배열의-단점>배열의 단점</a></li><li><a href=#배열의-주요-연산-및-시간-복잡도>배열의 주요 연산 및 시간 복잡도</a></li><li><a href=#배열과-연결-리스트-비교>배열과 연결 리스트 비교</a></li><li><a href=#배열의-종류>배열의 종류</a></li><li><a href=#배열의-구현-방식>배열의 구현 방식</a></li><li><a href=#언어별-배열-구현-특징>언어별 배열 구현 특징</a></li><li><a href=#배열의-응용>배열의 응용</a></li><li><a href=#대표적인-배열-알고리즘>대표적인 배열 알고리즘</a></li><li><a href=#실무에서의-배열-활용-팁>실무에서의 배열 활용 팁</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=배열-array>배열 (Array)<a hidden class=anchor aria-hidden=true href=#배열-array>#</a></h2><p>배열은 동일한 데이터 타입의 여러 값을 연속적인 메모리 공간에 순차적으로 저장하는 선형 자료구조로, 인덱스를 통해 빠른 접근이 가능한 특징이 있다.<br>배열은 초기 한 번 선언 시 정해진 크기를 가지며, 이 크기를 변경하기 어렵기 때문에 메모리 관리와 연산 측면에서 장단점을 지니고 있다.</p><ul><li>배열은 <strong>같은 데이터 타입</strong>의 값들을 하나의 변수명으로 관리하며, 각 요소는 메모리상에 연속된 위치에 저장된다.</li><li>**인덱스(index)**를 이용하여 원하는 위치의 데이터를 빠르게 검색할 수 있으며, 대부분 0번부터 시작하는 경우가 많다.</li><li>배열은 <strong>선형 자료구조</strong>이므로, 요소들이 순차적으로 배치되어 있어 특정 인덱스에 접근할 때 기본 위치에 오프셋을 더하는 방식으로 계산된다.</li></ul><p><img alt="Memory Representation of Array" loading=lazy src=Memory-Representation-of-Array.webp title=https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/></p><h3 id=배열의-특징>배열의 특징<a hidden class=anchor aria-hidden=true href=#배열의-특징>#</a></h3><ol><li><p>연속성<br>배열의 요소들은 메모리상에 연속적으로 저장된다.<br>이는 요소에 빠르게 접근할 수 있게 해주지만, 크기 변경에는 제약이 있다.</p></li><li><p>인덱싱<br>배열의 각 요소는 고유한 인덱스 번호를 가지며, 이 인덱스를 통해 O(1) 시간 복잡도로 직접 접근이 가능하다.</p></li><li><p>고정된 크기(일부 언어)<br>C와 같은 일부 언어에서는 배열 선언 시 크기를 미리 지정해야 하며, 이후 변경이 불가능하다.<br>반면 JavaScript, Python 등 동적 언어에서는 크기가 자유롭게 변할 수 있다.</p></li><li><p>동일한 데이터 타입<br>전통적인 배열은 모든 요소가 동일한 데이터 타입을 가져야 한다. 이는 메모리 계산을 단순화하고 효율적인 저장을 가능하게 한다.</p></li></ol><h3 id=배열의-장점>배열의 장점<a hidden class=anchor aria-hidden=true href=#배열의-장점>#</a></h3><ul><li><strong>빠른 검색 및 접근</strong>: 인덱스를 통한 직접 접근(random access)이 가능하여 데이터 검색이 빠르다.</li><li><strong>캐시 효율성</strong>: 메모리 공간이 연속적이기 때문에 캐시 지역성(Cache Locality) 활용하여 캐시 적중률이 높아 성능에 유리하다.</li><li><strong>구현이 간단함</strong>: 한 번 선언하면 요소 관리가 용이하며, 복잡한 부가정보 없이 데이터를 저장할 수 있다.</li></ul><blockquote><p>배열의 캐시 인접성(Cache Locality)이 왜 중요할까?</p><ul><li>배열은 메모리 내에 연속적으로 배치되기 때문에 하나의 원소에 접근할 때 인접한 여러 원소들이 동시에 캐시에 로드되어, 이후의 접근 시 빠른 데이터 처리가 가능해진다.</li></ul><h4 id=배열과-캐시-인접성의-개념>배열과 캐시 인접성의 개념<a hidden class=anchor aria-hidden=true href=#배열과-캐시-인접성의-개념>#</a></h4><ul><li>배열은 메모리 상에 연속된 블록에 데이터를 저장한다.</li><li>한 번의 메모리 접근으로 캐시 라인에 로드된 데이터를 활용해 여러 원소에 빠르게 접근할 수 있다.</li><li>인접한 데이터들이 캐시에 함께 로드되므로, 순차적인 데이터 접근(예: 반복문을 통한 처리)이 효율적으로 동작한다.</li></ul><h4 id=캐시-인접성이-중요한-이유>캐시 인접성이 중요한 이유<a hidden class=anchor aria-hidden=true href=#캐시-인접성이-중요한-이유>#</a></h4><ul><li><strong>빠른 메모리 접근</strong>: 배열 원소 접근 시 인접한 원소들도 함께 로드되어, 추가 메모리 접근 없이도 빠른 데이터 처리를 할 수 있다.</li><li><strong>캐시 히트율 증가</strong>: 순차적 접근은 캐시 미스 횟수를 줄여 전체 연산 시간을 단축시키며, 이는 응용 프로그램의 성능 향상에 크게 기여한다.</li><li><strong>효율적인 데이터 처리</strong>: 특히 대량의 데이터를 다루는 경우, 캐시 인접성이 높은 구조인 배열은 포인터 기반의 분산형 자료구조(예: 연결 리스트)보다 훨씬 효율적이다.</li></ul><h4 id=실무적-예시와-고려사항>실무적 예시와 고려사항<a hidden class=anchor aria-hidden=true href=#실무적-예시와-고려사항>#</a></h4><ul><li>배열에 저장된 정수형 데이터에 대해 반복문으로 순차적으로 접근하는 경우, 첫 번째 원소 접근 시 인접한 여러 값들이 캐시에 로드되어 이후 반복문 내에서 빠른 접근이 가능하다. 이는 데이터 분석, 이미지 처리, 과학 연산 등 많은 분야에서 성능 최적화의 핵심 요소로 작용한다.</li><li>반면, 연결 리스트와 같이 메모리 내에 비연속적으로 분산된 자료구조는 캐시 미스가 잦아 접근 속도가 저하되므로, 데이터 구조 선택 시 캐시 인접성을 중요한 고려 요소로 삼아야 한다.</li><li>캐시 인접성을 최대한 활용하기 위해서는 순차적인 데이터 접근 패턴을 유지하는 것이 좋으며, 이를 위해 필요한 경우 배열 혹은 행 우선(row-major) 방식의 2D 배열과 같은 캐시 친화적 자료구조를 선택하는 것이 유리하다.</li></ul></blockquote><h3 id=배열의-단점>배열의 단점<a hidden class=anchor aria-hidden=true href=#배열의-단점>#</a></h3><ul><li><strong>크기 변경의 어려움</strong>: 한 번 선언된 크기를 변경하기 어렵기 때문에, 데이터 추가 시 크기 초과 문제가 발생할 수 있다.</li><li><strong>삽입 및 삭제의 비효율성</strong>: 중간에 요소를 삽입하거나 삭제할 때 해당 인덱스 이후의 모든 요소 이동이 필요하여 연산 비용이 증가한다.</li><li><strong>메모리 활용의 한계</strong>: 고정된 크기로 인해 할당한 메모리 공간의 일부가 사용되지 않을 경우 메모리 낭비가 발생할 수 있다.</li></ul><h3 id=배열의-주요-연산-및-시간-복잡도>배열의 주요 연산 및 시간 복잡도<a hidden class=anchor aria-hidden=true href=#배열의-주요-연산-및-시간-복잡도>#</a></h3><table><thead><tr><th>연산</th><th>설명</th><th>시간 복잡도</th></tr></thead><tbody><tr><td>접근 (Access)</td><td><code>배열[index]</code>를 이용한 요소 접근</td><td>O(1)</td></tr><tr><td>탐색 (Search)</td><td>특정 값을 찾기 위해 전체 배열을 순회</td><td>O(n)</td></tr><tr><td>삽입 (Insert)</td><td>배열 중간에 요소 삽입 (이동이 필요)</td><td>O(n)</td></tr><tr><td>삭제 (Delete)</td><td>특정 요소 삭제 후 이동 필요</td><td>O(n)</td></tr></tbody></table><ul><li><strong>접근</strong>: 배열의 인덱스를 알고 있다면 즉시 접근 가능 (<code>O(1)</code>)</li><li><strong>탐색</strong>: 배열에서 특정 값을 찾기 위해 선형 탐색이 필요 (<code>O(n)</code>)</li><li><strong>삽입 및 삭제</strong>: 요소 이동이 필요하므로 최악의 경우 <strong>O(n)</strong> 이다.</li></ul><h3 id=배열과-연결-리스트-비교>배열과 연결 리스트 비교<a hidden class=anchor aria-hidden=true href=#배열과-연결-리스트-비교>#</a></h3><table><thead><tr><th>비교 항목</th><th>배열 (Array)</th><th>연결 리스트 (Linked List)</th></tr></thead><tbody><tr><td>메모리 할당</td><td>연속된 공간에 할당</td><td>노드별 개별 할당</td></tr><tr><td>접근 속도</td><td>빠름 (<code>O(1)</code>)</td><td>느림 (<code>O(n)</code>)</td></tr><tr><td>크기 조절</td><td>불가능 (고정 크기)</td><td>가능 (동적 크기)</td></tr><tr><td>삽입/삭제</td><td>비효율적 (<code>O(n)</code>)</td><td>효율적 (<code>O(1) ~ O(n)</code>)</td></tr><tr><td>메모리 사용</td><td>효율적 (오버헤드 없음)</td><td>비효율적 (포인터 필요)</td></tr></tbody></table><ul><li>배열은 <strong>고정된 크기</strong>로 선언되며, 크기 변경이 어렵지만 <strong>빠른 데이터 접근</strong>이 가능하다.</li><li>연결 리스트는 <strong>동적으로 크기 변경</strong>이 가능하지만 <strong>노드 탐색이 느리다</strong>.</li></ul><h3 id=배열의-종류>배열의 종류<a hidden class=anchor aria-hidden=true href=#배열의-종류>#</a></h3><ol><li><p>1차원 배열: 가장 기본적인 형태로, 한 줄로 데이터가 나열된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 1차원 배열 예시</span>
</span></span><span class=line><span class=cl><span class=n>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>다차원 배열: 2차원, 3차원 등 여러 차원으로 구성된 배열이다. 2차원 배열은 행과 열을 가진 표 형태로 생각할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span><span class=lnt id=hl-1-6><a class=lnlinks href=#hl-1-6>6</a>
</span><span class=lnt id=hl-1-7><a class=lnlinks href=#hl-1-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 2차원 배열 예시</span>
</span></span><span class=line><span class=cl><span class=n>matrix</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>9</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># matrix[1][2]는 6을 반환합니다</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>희소 배열(Sparse Array): 대부분의 요소가 기본값(보통 0)인 배열을 효율적으로 저장하기 위한 특수한 형태이다.</p></li></ol><h3 id=배열의-구현-방식>배열의 구현 방식<a hidden class=anchor aria-hidden=true href=#배열의-구현-방식>#</a></h3><ol><li><p>정적 배열: 메모리에 고정된 크기로 할당되며, 크기 변경이 불가능하다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// C에서의 정적 배열 선언
</span></span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>numbers</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>동적 배열: 필요에 따라 크기가 조정되는 배열이다. 많은 현대 언어들은 내부적으로 동적 배열을 구현하고 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// JavaScript에서의 동적 배열
</span></span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>numbers</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span> <span class=c1>// 배열에 새 요소 추가
</span></span></span></code></pre></td></tr></table></div></div><p>동적 배열의 확장 원리:</p><ol><li>배열이 가득 차면 더 큰 크기(보통 2배)의 새 배열을 할당</li><li>기존 배열의 모든 요소를 새 배열로 복사</li><li>기존 배열 메모리 해제</li><li>새 배열 참조로 업데이트</li></ol></li></ol><h3 id=언어별-배열-구현-특징>언어별 배열 구현 특징<a hidden class=anchor aria-hidden=true href=#언어별-배열-구현-특징>#</a></h3><ol><li><p>C/C++</p><ul><li>정적 크기 배열과 동적 할당 배열 모두 지원</li><li>메모리 직접 관리 필요</li><li>포인터 연산을 통한 접근 가능</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// C에서의 동적 배열 할당
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>arr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=mi>5</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// 사용 후 반드시 해제
</span></span></span><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>arr</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Java</p><ul><li>배열은 객체로 취급</li><li>기본형, 참조형 배열 모두 지원</li><li>ArrayList로 동적 크기 지원</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// Java에서의 배열 선언</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>numbers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>5</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 동적 배열은 ArrayList 사용</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>dynamicNumbers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>Python</p><ul><li>리스트(List)가 동적 배열 역할</li><li>다양한 타입의 요소 저장 가능</li><li>내장 메서드가 풍부함</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python 리스트</span>
</span></span><span class=line><span class=cl><span class=n>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>numbers</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span>  <span class=c1># 요소 추가</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>JavaScript</p><ul><li>배열은 객체의 특수한 형태</li><li>동적 크기와 다양한 타입 지원</li><li>희소 배열 지원</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=c1>// JavaScript 배열
</span></span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nx>numbers</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>  <span class=c1>// 요소 추가
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=배열의-응용>배열의 응용<a hidden class=anchor aria-hidden=true href=#배열의-응용>#</a></h3><ol><li>벡터(Vector): 동적 크기를 가진 배열의 추상화된 형태로, C++의 STL vector나 Java의 ArrayList 등이 있다.</li><li>행렬(Matrix): 2차원 배열을 활용한 수학적 객체로, 선형대수학에서 중요하게 사용된다.</li><li>스택과 큐: 배열을 기반으로 구현될 수 있는 또 다른 자료구조.</li></ol><h3 id=대표적인-배열-알고리즘>대표적인 배열 알고리즘<a hidden class=anchor aria-hidden=true href=#대표적인-배열-알고리즘>#</a></h3><h4 id=정렬-알고리즘>정렬 알고리즘<a hidden class=anchor aria-hidden=true href=#정렬-알고리즘>#</a></h4><p>배열 요소를 특정 순서로 재배열하는 알고리즘.</p><ul><li>버블 정렬, 선택 정렬, 삽입 정렬: O(n²)</li><li>퀵 정렬, 합병 정렬: O(n log n)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 배열 정렬</span>
</span></span><span class=line><span class=cl><span class=n>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>9</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># 내장 정렬 함수 사용</span>
</span></span><span class=line><span class=cl><span class=n>sorted_numbers</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span>  <span class=c1># [1, 2, 5, 8, 9]</span>
</span></span><span class=line><span class=cl><span class=c1># 또는 원본 배열 정렬</span>
</span></span><span class=line><span class=cl><span class=n>numbers</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span>  <span class=c1># numbers는 이제 [1, 2, 5, 8, 9]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=검색-알고리즘>검색 알고리즘<a hidden class=anchor aria-hidden=true href=#검색-알고리즘>#</a></h4><ul><li>선형 검색: 배열의 모든 요소를 순차적으로 확인</li><li>이진 검색: 정렬된 배열에서 중간값 비교를 통해 검색 범위를 절반씩 줄여가는 방식</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 이진 검색</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>binary_search</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>left</span><span class=p>,</span> <span class=n>right</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>arr</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>left</span> <span class=o>&lt;=</span> <span class=n>right</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>left</span> <span class=o>+</span> <span class=n>right</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span>  <span class=c1># 찾은 요소의 인덱스 반환</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>arr</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>left</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>  <span class=c1># 요소가 없을 경우</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 정렬된 배열에서 사용</span>
</span></span><span class=line><span class=cl><span class=n>sorted_arr</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>index</span> <span class=o>=</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>sorted_arr</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>  <span class=c1># 3 반환</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=실무에서의-배열-활용-팁>실무에서의 배열 활용 팁<a hidden class=anchor aria-hidden=true href=#실무에서의-배열-활용-팁>#</a></h3><ol><li><p>적절한 초기 크기 설정: 동적 배열을 사용할 때도 예상되는 데이터 크기에 맞게 초기 크기를 설정하면 불필요한 재할당을 줄일 수 있다.</p></li><li><p>슬라이싱(Slicing) 활용: 많은 언어에서 배열의 일부분을 쉽게 추출할 수 있는 슬라이싱 기능을 제공한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 슬라이싱</span>
</span></span><span class=line><span class=cl><span class=n>numbers</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>sub_array</span> <span class=o>=</span> <span class=n>numbers</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>  <span class=c1># [1, 2, 3]</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>배열 복사 시 주의점: 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이를 이해하고 적절히 활용해야 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python에서의 배열 복사</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>copy</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>original</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>shallow_copy</span> <span class=o>=</span> <span class=n>original</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  <span class=c1># 또는 original[:]</span>
</span></span><span class=line><span class=cl><span class=n>deep_copy</span> <span class=o>=</span> <span class=n>copy</span><span class=o>.</span><span class=n>deepcopy</span><span class=p>(</span><span class=n>original</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 중첩된 배열 수정 시 차이 발생</span>
</span></span><span class=line><span class=cl><span class=n>original</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>99</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>shallow_copy</span><span class=p>)</span>  <span class=c1># [1, [99, 3], 4]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>deep_copy</span><span class=p>)</span>     <span class=c1># [1, [2, 3], 4]</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-structures-and-algorithms/>Data-Structures-and-Algorithms</a></li><li><a href=https://buenhyden.github.io/tags/data-structures/>Data-Structures</a></li><li><a href=https://buenhyden.github.io/tags/array/>Array</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-science/theoretical-computer-science/computational-complexity/complexity-classes/><span class=title>« Prev</span><br><span>복잡도 클래스(Complexity Classes)</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-development/development-practices/version-control/collaboration-workflows/branch-strategies/github-flow/><span class=title>Next »</span><br><span>GitHub Flow</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>