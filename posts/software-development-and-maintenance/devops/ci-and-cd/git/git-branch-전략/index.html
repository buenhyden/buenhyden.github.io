<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git Branch 전략 | hyunyoun's Blog</title>
<meta name=keywords content="Software-Development,Software-Maintenance,DevOps,CI-CD,Version-Control,Git,Git-Branch,Git-Flow,Github-Flow,Gitlab-Flow"><meta name=description content="Git 브랜치 전략 (Git Flow, Github Flow, Gitlab Flow)"><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Git Branch 전략"><meta property="og:description" content="Git 브랜치 전략 (Git Flow, Github Flow, Gitlab Flow)"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-22T10:28:00+00:00"><meta property="article:modified_time" content="2024-09-22T10:28:00+00:00"><meta property="article:tag" content="Software-Development"><meta property="article:tag" content="Software-Maintenance"><meta property="article:tag" content="DevOps"><meta property="article:tag" content="CI-CD"><meta property="article:tag" content="Version-Control"><meta property="article:tag" content="Git"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Git Branch 전략"><meta name=twitter:description content="Git 브랜치 전략 (Git Flow, Github Flow, Gitlab Flow)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Development and Maintenance","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/"},{"@type":"ListItem","position":3,"name":"DevOps","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/"},{"@type":"ListItem","position":4,"name":"CI/CD","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/"},{"@type":"ListItem","position":5,"name":"Git 기본 사용법","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/"},{"@type":"ListItem","position":6,"name":"Git Branch 전략","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git Branch 전략","name":"Git Branch 전략","description":"Git 브랜치 전략 (Git Flow, Github Flow, Gitlab Flow)","keywords":["Software-Development","Software-Maintenance","DevOps","CI-CD","Version-Control","Git","Git-Branch","Git-Flow","Github-Flow","Gitlab-Flow"],"articleBody":"Git Branch 전략 Git Flow Source: https://nvie.com/posts/a-successful-git-branching-model/\n특징 Vincent Driessen이 2010년에 제안한 브랜치 전략 엄격하고 체계적인 브랜치 관리 구조 장기적인 릴리즈 주기와 버전 관리에 적합 여러 개의 프로덕션 버전을 동시에 지원. 명확한 역할 분담과 작업 흐름 제공. 핵심 원칙 master(main) 브랜치는 항상 배포 가능한 상태로 유지 모든 개발은 develop 브랜치를 기반으로 진행 새로운 기능 개발은 항상 feature 브랜치에서 수행 release 브랜치는 릴리즈 준비가 완료된 후에만 master로 병합 구조 및 Branch 종류 주요 브랜치 master(main): 제품 출시 버전을 관리 항상 배포 가능한 상태를 유지 모든 커밋에 태그로 버전 번호 부여 직접적인 커밋 금지 release 또는 hotfix에서 병합만 가능 develop: 다음 버전 개발 코드 관리 feature 브랜치의 기준점. 기능 개발 완료된 코드 통합 다음 릴리즈를 위한 코드베이스 보조 브랜치 feature: 새로운 기능 개발 develop에서 분기 기능 단위로 생성 개발 완료 후 develop에 병합 네이밍: feature/기능명 release: 출시 준비 develop에서 분기 버그 수정, 문서 작업 등 릴리즈 준비 작업만 허용 완료시 master(main)와 develop에 병합 네이밍: release-버전 hotfix: 긴급 버그 수정 master(main)에서 분기 수정 후 master(main)와 develop에 병합 네이밍: hotfix-버전\n각 브랜치의 명명 규칙을 정하여 따르도록 한다.\n예) feature/*: 기능 이름 사용 release/*: 버전 번호 사용 hotfix/*: 버그 식별자 사용 작업 시나리오 신규 시나리오 develop 브랜치에서 시작 feature 브랜치 생성 기능 개발 및 테스트 develop에 병합 feature 브랜치 삭제 릴리즈 프로세스 develop에서 release 브랜치 생성 버전 번호 업데이트 최종 테스트 및 버그 수정 master와 develop에 병합 태그 생성 및 release 브랜치 삭제 긴급 버그 수정 master에서 hotfix 브랜치 생성 버그 수정 및 버전 업데이트 master와 develop에 병합 태그 생성 및 hotfix 브랜치 삭제 장단점 장점 단점 체계적이고 예측 가능한 개발 프로세스\n버전 관리와 유지보수가 용이\n대규모 프로젝트와 팀에 적합\n릴리즈 주기가 긴 프로젝트에 효과적\n엄격한 코드 품질 관리\n명확한 역할 분담 복잡한 브랜치 구조로 인한 학습 곡선\n소규모 프로젝트나 빠른 배포가 필요한 경우 과도할 수 있다.\n브랜치 관리에 시간과 노력이 많이 소요될 수 있음. 적용 적합성 프로젝트 규모 팀 규모 배포 빈도 품질 관리 수준 중대형 프로젝트 5인 이상 주/월 단위 정기적인 릴리즈 높은 수준의 QA 프로세스 필요\n체계적인 테스트 체계 필요\n코드 리뷰 문화 필수 리스크 요소 통합 리스크 배포 리스크 품질 리스크 관리 리스크 장기 실행 브랜치의 병합 충돌\nfeature 브랜치 간의 의존성\n큰 규모의 병합으로 인한 위험 복잡한 배포 프로세스\n릴리즈 준비 기간 장기화\nhotfix 적용의 복잡성 브랜치 간 코드 동기화 문제\n테스트 커버리지 확보 어려움\n코드 리뷰 병목 현상 브랜치 관리에 많은 시간이 노력이 필요 복잡도 증가 요인 다양한 종류의 브랜치 사용 엄격한 브랜치 생성 및 병합 규칙 릴리스 및 핫픽스 프로세스의 복잡성 CI/CD를 위한 요구 사항 자동화된 테스트 시스템 각 브랜치 별 자동 빌드 및 테스트 환경 릴리즈 브랜치에 대한 자동 배포 파이프라인 브랜치 상태 모니터링 시스템 통합 방법 브랜치 전략과 CI/CD 파이프라인 연동 master(main)와 develop 브랜치에 대한 자동 빌드 및 테스트 파이프라인 구성 feature, release, hotfix 브랜치에 대한 별도의 CI 파이프라인 설정. 자동화된 테스트 모든 브랜치에 대해 자동화된 단위 테스트, 통합 테스트 실행 develop 브랜치로의 병합 시 추가적인 테스트 수행 환경별 배포 develop 브랜치는 개발/테스트 환경에 자동 배포 release 브랜치는 스테이징 환경에 배포 master 브랜치는 프로덕션 환경에 배포 코드 리뷰 프로세스 Pull Request 생성 시 자동으로 CI 파이프라인 실행 코드 리뷰 승인 후 자동 병합 및 배포 버전 관리 release 브랜치 생성 시 자동으로 버전 태그 생성 배포 시 해당 버전 정보 포함 모니터링 및 롤백 배포 후 자동화된 모니터링 시스템 연동 문제 발생 시 빠른 롤백 메커니즘 구현 문서화 CI/CD 파이프라인 실행 결과 자동 문서화 릴리즈 노트 자동 생성 버전 관리 방식 버전 관리 체계 Semantic Versioning(SemVer)을 사용\n1 MAJOR.MINOR.PATCH 주 버전(Major): 호환성이 깨지는 변경사항 부 버전(Minor): 기능 추가 패치 버전(Patch): 버그 수정\n예: 1.2.3 (주 버전 1, 부 버전 2, 패치 3) 태그 관리 모든 릴리즈에 태그 부여 버전 정보 포함 릴리즈 노트 연결 이력 관리 릴리즈 노트 작성 변경 이력 문서화 주요 변경 사항 추적 GitHub Flow https://github.com/SvanBoxel/release-based-workflow/issues/1\n특징 단순한 브랜치 전략 main 브랜치 중심의 지속적 배포 Pull Request 기반 코드 리뷰 빠른 피드백과 지속적 통합 자동화된 테스트와 배포 강조 핵심 원칙 main 브랜치는 항상 배포 가능한 상태 유지 새로운 작업은 항상 기능 브랜치에서 수행 기능 브랜치는 자주 push하고 Pull Request 생성 Pull Request를 통한 코드 리뷰 필수 승인된 Pull Request는 즉시 main에 병합 main에 병합된 변경사항은 즉시 배포 구조 및 Branch 종류 main (master) 항상 배포 가능한 상태 유지 모든 코드는 리뷰를 거쳐 병합 feature Branches 모든 개발은 feature 브랜치에서 진행 기능/버그수정/문서 등 모든 변경사항. 작업 시나리오 새로운 기능 개발 main에서 feature 브랜치 생성 기능 개발 및 테스트 PR 생성 및 리뷰 main에 병합 및 배포 버그 수정 main에서 hotfix 브랜치 생성 수정 및 테스트 PR 생성 및 긴급 리뷰 main에 병합 및 즉시 배포 실험적 기능 prototype 브랜치 생성 기능 구현 및 검증 성공 시 정식 feature로 전환 장단점 장점 단점 간단하고 이해하기 쉬움\n빠른 개발과 배포 주기 지원\n지속적인 통합과 배포 용이\n코드 리뷰 문화 강화 버전 관리가 명시적이지 않음\n대규모 프로젝트나 복잡한 릴리스 관리에는 부적합할 수 있음\nhotfix 처리를 위한 별도 프로세스 부재\n환경별 배포 관리 어려움\n롤백 복잡성 적용 적합성 프로젝트 규모 팀 규모 배포 빈도 품질 관리 수준 소규모 ~ 중규모 프로젝트 작은 팀 ~ 중간 규모 팀 (5-20명) 매우 빈번 (일 단위 또는 그 이상) 자동화된 테스트 필수\n코드 리뷰 문화 중요\nCI/CD 파이프라인 필요 리스크 요소 통합 리스크 배포 리스크 품질 리스크 관리 리스크 동시 다발적 PR 충돌\n테스트 커버리지 부족\n리뷰 병목 현상\n잦은 배포로 인한 불안정성\n롤백 복잡성\n환경 설정 관리 어려움\n빠른 개발로 인한 품질 저하\n문서화 부족\n기술 부채 누적\n명시적인 버전 관리의 어려움 복잡도 증가 요인 동시 진행 PR 수 증가 팀 규모 증가 환경 설정 다양화 CI/CD를 위한 요구 사항 자동화된 빌드 및 테스트 시스템 지속적 통합(CI) 도구 (예: Jenkins, GitHub Actions) 자동화된 배포 파이프라인 코드 품질 검사 도구 (예: SonarQube) 모니터링 및 로깅 시스템 통합 방법 GitHub Actions 활용: GitHub에서 제공하는 CI/CD 도구인 GitHub Actions를 사용하여 워크플로우를 자동화 .github/workflows 디렉토리에 YAML 파일로 워크플로우를 정의. 자동화된 테스트 구현: 풀 리퀘스트가 생성될 때마다 자동으로 빌드 및 테스트를 실행하도록 설정. 단위 테스트, 통합 테스트, 코드 스타일 검사 등을 포함. 지속적 통합 (CI) 설정: 모든 코드 변경사항에 대해 자동으로 빌드와 테스트를 실행. 메인 브랜치에 병합하기 전에 모든 테스트를 통과해야 한다. 지속적 배포 (CD) 구현: 테스트를 통과한 코드를 자동으로 스테이징 또는 프로덕션 환경에 배포. 필요에 따라 수동 승인 단계를 추가할 수 있다. 환경 변수 및 시크릿 관리: GitHub의 시크릿 기능을 사용하여 민감한 정보를 안전하게 관리. 모니터링 및 알림 설정: 워크플로우 상태, 실패, 중요 이벤트에 대한 알림을 설정. 코드 품질 검사 통합: 정적 코드 분석, 코드 커버리지 검사 등을 워크플로우에 포함. 병렬 실행 및 매트릭스 빌드 활용: 여러 환경에서 동시에 테스트를 실행하여 효율성을 높인다. 캐싱 활용: 의존성 및 빌드 결과물을 캐싱하여 빌드 시간을 단축한다. 정기적인 워크플로우 검토 및 최적화: CI/CD 파이프라인을 주기적으로 검토하고 개선한다. 버전 관리 방식 명시적인 버전 관리보다는 커밋 해시나 배포 시간을 이용 필요시 Git 태그를 활용하여 주요 릴리스 표시 GitLab Flow https://blog.programster.org/git-workflows\nhttps://www.linkedin.com/pulse/gitlab-flow-jadson-santos\n특징 Git Flow의 복잡성을 줄이고, GitHub Flow의 단순성을 결합 환경별 브랜치 전략 채택 지속적 배포와 안정성 균형 단방향 워크플로우 main → staging → pre-production → production 개발, 스테이징, 프로덕션 환경을 위한 브랜치 구조 지원 핵심 원칙 모든 코드 변경은 이슈 트래킹 시스템과 연결 main 브랜치는 항상 안정적이고 배포 가능한 상태 유지 환경별로 명확한 테스트 및 배포 절차 준수 Merge Request를 통한 코드 리뷰 필수 구조 및 Branch 종류 Main 개발의 기준점 통합된 코드 관리 CI 통과 필수 feature 브랜치의 병합 대상 Production 실제 운영 환경 코드 안정성 검증 완료 배포 이력 관리 main에서 테스트 완료된 코드를 병합 pre-production/staging 운영 환경 검증용 QA 테스트 진행 성능/부하 테스트 main에서 분기하여 테스트 후 production으로 병합. Feature 기능 개발용 main에서 분기하여 작업 후 Merge Request 생성. Hotfix 긴급 버그 수정 production에서 분기 모든 환경에 반영 작업 시나리오 새로운 기능 개발 Main에서 Feature 브랜치 생성 개발 및 테스트 Main에 MR 생성 리뷰 및 CI 통과 단계적 환경 배포 버그 수정 Production에서 Hotfix 브랜치 생성 수정 및 테스트 Production에 병합 하위 환경에 백포트 정기 배포 Main 브랜치 안정화 Staging 환경 배포 QA 검증 Pre-production 검증 Production 배포 장단점 장점 단점 유연한 환경 관리\n이슈 트래킹과의 통합으로 투명한 개발 프로세스\n다양한 배포 시나리오 지원\n안정성 Git Flow보다는 단순하지만 GitHub Flow보다는 복잡\n환경별 브랜치 관리에 따른 추가 작업 필요 적용 적합성 프로젝트 규모 팀 규모 배포 빈도 품질 관리 수준 중소규모 ~ 대규모 프로젝트 5-50명 정도의 중소규모 팀 주 단위 또는 2주 단위 배포 중간 ~ 높은 수준의 품질 관리 필요 리스크 요소 통합 리스크 배포 리스크 품질 리스크 관리 리스크 브랜치 간 동기화 문제\n환경별 설정 불일치\n병합 충돌 환경별 배포 실패\n설정 오류\n성능 저하 여러 환경에서의 일관된 품질 유지 필요 브랜치 관리 복잡성\n환경 설정 부담\n문서화 필요성 복잡도 증가 요인 브랜치 관리 다중 환경 구성 동기화 필요성 버전 관리 배포 프로세스 단계적 검증 환경별 설정 롤백 절차 설정 관리 환경별 변수 접근 권한 보안 설정 CI/CD를 위한 요구 사항 자동화된 테스트 시스템 환경별 자동 배포 파이프라인 코드 품질 검사 도구 모니터링 및 로깅 시스템 통합 방법 .gitlab-ci.yml 파일 생성: 프로젝트 루트에.gitlab-ci.yml 파일을 생성하여 CI/CD 파이프라인을 정의한다. 파이프라인 구조 정의: stages를 정의하여 파이프라인의 단계를 구성한다 (예: build, test, deploy). 각 stage에 해당하는 job을 정의한다. 브랜치별 파이프라인 설정: main, production 등 주요 브랜치에 대한 파이프라인을 별도로 구성한다. rules 키워드를 사용하여 브랜치별로 다른 job을 실행하도록 설정한다. 자동화된 테스트 구현: 단위 테스트, 통합 테스트 등을 파이프라인에 포함시킨다. test stage에서 다양한 테스트를 실행하도록 구성한다. 환경별 배포 자동화: 개발, 스테이징, 프로덕션 환경에 대한 자동 배포 job을 구성한다. environment 키워드를 사용하여 배포 환경을 지정한다. 품질 검사 도구 통합: 코드 품질, 보안 검사 등을 수행하는 job을 추가한다. 아티팩트 및 캐시 활용: artifacts와 cache를 사용하여 빌드 결과물을 저장하고 재사용한다. CI/CD 변수 활용: GitLab의 CI/CD 변수 기능을 사용하여 민감한 정보를 안전하게 관리한다. 모니터링 및 알림 설정: 파이프라인 실행 결과에 대한 알림을 구성한다. GitLab Runner 설정: 프로젝트에 적합한 Runner를 구성하여 CI/CD 작업을 실행한다. 버전 관리 방식 시맨틱 버저닝 (MAJOR.MINOR.PATCH) 환경별 태그 관리 배포 이력 추적 Scaled Trunk-Based Development https://trunkbaseddevelopment.com/\n특징 단일 메인 브랜치(trunk)를 중심으로 개발 짧은 수명의 기능 브랜치 사용 빈번한 통합과 배포 기능 플래그를 활용한 기능 관리 대규모 팀과 프로젝트에 적합 마이크로서비스 아키텍처 지원 핵심 원칙 trunk는 항상 안정적이고 배포 가능한 상태 유지 기능 브랜치는 짧게 유지 (1-2일 이내) 빈번한 통합과 배포 자동화된 테스트와 CI/CD 파이프라인 필수 기능 플래그를 활용한 미완성 기능 관리 구조 및 Branch 종류 Trunk 브랜치:\n항상 배포 가능한 상태 유지 모든 개발 작업의 최종 목적지 기능 브랜치:\n개별 기능 개발을 위해 trunk에서 분기 빠르게 개발 완료 후 trunk로 병합 (보통 1-2일 이내) 릴리스 브랜치:\n필요시에만 생성 릴리스 준비 및 핫픽스를 위해 사용 작업 시나리오 새로운 기능 개발 Feature Flag 생성 임시 브랜치 생성 기능 구현 (1-2일) 테스트 및 리뷰 main 병합 단계적 Flag 활성화 긴급 수정 main에서 직접 수정 테스트 자동화 즉시 배포 모니터링 장단점 장점 단점 빠른 통합과 피드백\n병합 충돌 최소화\n지속적 배포 용이\n대규모 팀 협업에 적합 높은 수준의 자동화 필요\n기능 플래그 관리의 복잡성\n팀원들의 높은 기술력과 규율 필요 적용 적합성 프로젝트 규모 팀 규모 배포 빈도 품질 관리 수준 중대형 프로젝트 대규모 팀 (50명 이상) 매우 빈번 (일일 또는 그 이상) 높은 수준의 자동화된 테스트 필요 리스크 요소 통합 리스크 배포 리스크 품질 리스크 관리 리스크 빈번한 통합으로 인한 일시적 불안정성 잦은 배포로 인한 운영 부담 증가 빠른 개발 주기로 인한 품질 저하 가능성 기능 플래그 관리의 복잡성 복잡도 증가 요인 전반적으로 중간 수준의 복잡도 기능 플래그 관리와 대규모 팀 조정에서 복잡도 증가 CI/CD를 위한 요구 사항 강력한 자동화된 테스트 시스템 빠른 빌드 및 배포 파이프라인 코드 품질 검사 도구 실시간 모니터링 시스템 기능 플래그 관리 시스템 통합 방법 자동화된 빌드 및 테스트 파이프라인 구축: 모든 커밋에 대해 자동으로 빌드 및 테스트를 실행하는 CI 파이프라인 구성 단위 테스트, 통합 테스트, 성능 테스트 등 다양한 테스트 자동화 짧은 수명의 기능 브랜치 사용: 기능 브랜치에서 작업 후 빠르게 trunk로 병합 (보통 1-2일 이내) 각 기능 브랜치에 대해 자동화된 테스트 실행 트렁크 브랜치 보호: 트렁크 브랜치에 직접 푸시 금지 모든 변경사항은 코드 리뷰와 자동화된 테스트를 거친 후 병합 지속적 배포(CD) 구현: 트렁크 브랜치에 병합된 코드를 자동으로 스테이징 환경에 배포 스테이징 환경에서 추가 테스트 후 문제가 없으면 프로덕션 환경으로 자동 배포 기능 플래그 사용: 미완성 기능을 트렁크에 안전하게 병합할 수 있도록 기능 플래그 구현 CI/CD 파이프라인에서 기능 플래그 상태를 제어 모니터링 및 롤백 메커니즘: 배포 후 실시간 모니터링 시스템 구축 문제 발생 시 빠른 롤백이 가능한 시스템 구현 릴리스 관리 자동화: 버전 관리 및 릴리스 노트 생성 자동화 릴리스 프로세스를 CI/CD 파이프라인에 통합 코드 품질 검사 통합: 정적 코드 분석 도구를 CI/CD 파이프라인에 통합 코드 커버리지, 복잡도 등의 메트릭을 지속적으로 모니터링 환경 구성 관리: 인프라스트럭처 as 코드(IaC) 도구를 사용하여 환경 구성 자동화 개발, 스테이징, 프로덕션 환경의 일관성 유지 버전 관리 방식 지속적 배포로 인해 세밀한 버전 관리가 필요 Semantic Versioning 사용 권장 자동화된 버전 증가 시스템 구축 Feature Branch Workflow Vs Trunk-Based Development 비교 항목 Feature Branch Workflow Trunk-Based Development 기본 철학 기능별 격리 개발 통합 중심 개발 브랜치 수명 긴 수명 (days-weeks) 짧은 수명 (hours-days) 주요 브랜치 main, feature, release 등 main(trunk) 중심 코드 리뷰 PR/MR 기반 공식 리뷰 실시간/페어 리뷰 배포 주기 계획된 정기 배포 수시 배포 (continuous) 적합 팀 규모 중/대규모 (5인 이상) 소규모 (5인 이하) 품질 관리 단계적 검증 자동화된 검증 통합 빈도 낮음 (주단위) 높음 (일단위) 자동화 수준 중간 높음 버그 수정 bugfix/hotfix 브랜치 직접 main 수정 기능 격리 브랜치로 격리 Feature Toggle 사용 충돌 관리 병합 시 해결 수시로 해결 릴리즈 관리 명시적 릴리즈 지속적 릴리즈 복잡도 높음 낮음 학습 곡선 가파름 완만함 CI/CD 요구사항 중간 높음 롤백 전략 브랜치 전환 Feature Toggle/배포 롤백 문서화 수준 높음 중간 적합 프로젝트 복잡한 대형 프로젝트 단순한 소형 프로젝트 배포 안정성 높음 변동적 계열 Git Flow\nGitHub Flow\nGitLab Flow\n기본 Feature Branch Workflow Single Trunk Development\nScaled Trunk Development\nShort-Lived Feature Branches\nRelease Branch Model 핵심 차이점 개발 프로세스 Feature Branch: 격리 → 개발 → 리뷰 → 병합 → 배포 Trunk-Based: 개발 → 통합 → 배포 → 모니터링 품질 관리 Feature Branch: 사전 검증 중심 Trunk-Based: 사후 모니터링 중심 배포 전략 Feature Branch: 계획적 배포 Trunk-Based: 지속적 배포 팀 문화 Feature Branch: 체계적/계획적 Trunk-Based: 애자일/유연함 도구 요구사항 Feature Branch: 브랜치 관리 도구 Trunk-Based: 자동화 도구 Git Branch 전략별 비교 특성 Git Flow GitHub Flow GitLab Flow Scaled Trunk-Based 특징 엄격한 브랜치 관리\n장기 릴리즈 주기\n체계적 구조 단순한 구조\n지속적 배포\nPR 기반 리뷰 환경별 브랜치\n단방향 워크플로우\n이슈 트래킹 통합 단일 트렁크 중심\n짧은 브랜치 수명\n기능 플래그 활용 브랜치 종류 master\ndevelop\nfeature\nrelease\nhotfix main\nfeature main\nproduction\npre-production\nfeature\nhotfix trunk\nfeature(1-2일)\nrelease 핵심 원칙 master 안정성\ndevelop 기반 개발\nfeature 격리 main 안정성\nfeature 분리\nPR 필수 환경별 배포\n단방향 흐름\nMR 필수 빠른 통합\n짧은 브랜치\n기능 플래그 장점 체계적 버전관리\n안정적 배포\n명확한 역할구분 단순성\n빠른 배포\n쉬운 학습곡선 환경 관리 용이\n단계적 배포\n안정성 빠른 통합\n최소 충돌\n지속적 배포 단점 복잡한 구조\n느린 배포\n관리 부담 버전관리 어려움\n복잡한 릴리즈\n환경구분 없음 복잡한 구조\n관리 부담\n느린 배포 높은 자동화 필요\n기능플래그 복잡성\n높은 기술력 요구 적합 규모 중대형 프로젝트\n5인 이상 팀 소중규모 프로젝트\n5-20인 팀 중대형 프로젝트\n5-50인 팀 대규모 프로젝트\n50인 이상 팀 배포 주기 주/월 단위 수시 배포 주/2주 단위 매일/수시 CI/CD 요구사항 중간 수준\n브랜치별 파이프라인 높은 수준\n자동화 필수 높은 수준\n환경별 파이프라인 매우 높은 수준\n완전 자동화 버전 관리 Semantic Versioning\n태그 필수 커밋 해시/배포시간 환경별 태그\nSemantic Versioning 지속적 버전관리\n자동화된 증가 복잡도 높음 낮음 중간 중간-높음 Git Branch 전략 선택 시 고려사항 영역 주요 고려사항 프로젝트 컨텍스트 • 프로젝트 규모/복잡도\n• 안정성 요구사항\n• 릴리스 주기\n• 마이크로서비스 여부\n• 유지보수 용이성 팀 구성 및 문화 • 팀 규모 (현재/미래)\n• Git 사용 경험 수준\n• 개발자 숙련도\n• 분산 팀 여부\n• 협업/코드 리뷰 문화\n• 학습 곡선 배포 프로세스 • 배포 빈도\n• 환경 구성\n• 롤백 필요성\n• 버전 관리 요구사항\n• 무중단 배포 필요성 품질 관리 • 테스트 자동화 수준\n• 코드 리뷰 정책\n• 품질 게이트\n• 문서화 요구사항\n• 모니터링 체계 인프라 및 기술 • CI/CD 인프라 수준\n• 자동화 도구 활용\n• 테스트 인프라\n• 운영 환경 구성\n• 기존 시스템 호환성 비즈니스 요구사항 • Time to Market\n• 고객 피드백 반영\n• 버그 수정 우선순위\n• 보안/규제 요구사항\n• 회사 정책 리스크 관리 • 통합 리스크\n• 배포 리스크\n• 품질 리스크\n• 운영 리스크\n• 롤백 계획 확장성 • 팀/프로젝트 확장 계획\n• 기술 스택 변화 대응\n• 요구사항 변화 대응\n• 장기적 유지보수 참고 및 출처 ","wordCount":"2639","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-22T10:28:00Z","dateModified":"2024-09-22T10:28:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/>Software Development and Maintenance</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/>DevOps</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/>CI/CD</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/>Git 기본 사용법</a></div><h1 class="post-title entry-hint-parent">Git Branch 전략</h1><div class=post-description>Git 브랜치 전략 (Git Flow, Github Flow, Gitlab Flow)</div><div class=post-meta><span title='2024-09-22 10:28:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2639 words&nbsp;·&nbsp;Me</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git-branch-전략>Git Branch 전략</a><ul><li><a href=#git-flow>Git Flow</a></li><li><a href=#github-flow>GitHub Flow</a></li><li><a href=#gitlab-flow>GitLab Flow</a></li><li><a href=#scaled-trunk-based-development>Scaled Trunk-Based Development</a></li><li><a href=#feature-branch-workflow-vs-trunk-based-development-비교>Feature Branch Workflow Vs Trunk-Based Development 비교</a></li><li><a href=#git-branch-전략별-비교>Git Branch 전략별 비교</a></li><li><a href=#git-branch-전략-선택-시-고려사항>Git Branch 전략 선택 시 고려사항</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=git-branch-전략>Git Branch 전략<a hidden class=anchor aria-hidden=true href=#git-branch-전략>#</a></h2><h3 id=git-flow>Git Flow<a hidden class=anchor aria-hidden=true href=#git-flow>#</a></h3><p><figure><img alt="Git Flow" loading=lazy src=/img/git-model@2x.png><figcaption>Source: https://nvie.com/posts/a-successful-git-branching-model/</figcaption></figure></p><h4 id=특징>특징<a hidden class=anchor aria-hidden=true href=#특징>#</a></h4><ul><li>Vincent Driessen이 2010년에 제안한 브랜치 전략</li><li>엄격하고 체계적인 브랜치 관리 구조</li><li>장기적인 릴리즈 주기와 버전 관리에 적합</li><li>여러 개의 프로덕션 버전을 동시에 지원.</li><li>명확한 역할 분담과 작업 흐름 제공.</li></ul><h4 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h4><ol><li><code>master(main)</code> 브랜치는 항상 배포 가능한 상태로 유지</li><li>모든 개발은 <code>develop</code> 브랜치를 기반으로 진행</li><li>새로운 기능 개발은 항상 <code>feature</code> 브랜치에서 수행</li><li><code>release</code> 브랜치는 릴리즈 준비가 완료된 후에만 <code>master</code>로 병합</li></ol><h4 id=구조-및-branch-종류>구조 및 Branch 종류<a hidden class=anchor aria-hidden=true href=#구조-및-branch-종류>#</a></h4><h5 id=주요-브랜치>주요 브랜치<a hidden class=anchor aria-hidden=true href=#주요-브랜치>#</a></h5><ol><li><code>master(main)</code>: 제품 출시 버전을 관리<ol><li>항상 배포 가능한 상태를 유지</li><li>모든 커밋에 태그로 버전 번호 부여</li><li>직접적인 커밋 금지</li><li><code>release</code> 또는 <code>hotfix</code>에서 병합만 가능</li></ol></li><li><code>develop</code>: 다음 버전 개발 코드 관리<ol><li><code>feature</code> 브랜치의 기준점.</li><li>기능 개발 완료된 코드 통합</li><li>다음 릴리즈를 위한 코드베이스</li></ol></li></ol><h5 id=보조-브랜치>보조 브랜치<a hidden class=anchor aria-hidden=true href=#보조-브랜치>#</a></h5><ol><li><code>feature</code>: 새로운 기능 개발<ol><li><code>develop</code>에서 분기</li><li>기능 단위로 생성</li><li>개발 완료 후 <code>develop</code>에 병합</li><li>네이밍: <code>feature/기능명</code></li></ol></li><li><code>release</code>: 출시 준비<ol><li><code>develop</code>에서 분기</li><li>버그 수정, 문서 작업 등 릴리즈 준비 작업만 허용</li><li>완료시 <code>master(main)</code>와 <code>develop</code>에 병합</li><li>네이밍: <code>release-버전</code></li></ol></li><li><code>hotfix</code>: 긴급 버그 수정<ol><li><code>master(main)</code>에서 분기</li><li>수정 후 <code>master(main)</code>와 <code>develop</code>에 병합</li><li>네이밍: hotfix-버전<br>각 브랜치의 명명 규칙을 정하여 따르도록 한다.<br>예)</li></ol></li></ol><ul><li><code>feature/*</code>: 기능 이름 사용</li><li><code>release/*</code>: 버전 번호 사용</li><li><code>hotfix/*</code>: 버그 식별자 사용</li></ul><h4 id=작업-시나리오>작업 시나리오<a hidden class=anchor aria-hidden=true href=#작업-시나리오>#</a></h4><h5 id=신규-시나리오>신규 시나리오<a hidden class=anchor aria-hidden=true href=#신규-시나리오>#</a></h5><ol><li>develop 브랜치에서 시작</li><li>feature 브랜치 생성</li><li>기능 개발 및 테스트</li><li>develop에 병합</li><li>feature 브랜치 삭제</li></ol><h5 id=릴리즈-프로세스>릴리즈 프로세스<a hidden class=anchor aria-hidden=true href=#릴리즈-프로세스>#</a></h5><ol><li>develop에서 release 브랜치 생성</li><li>버전 번호 업데이트</li><li>최종 테스트 및 버그 수정</li><li>master와 develop에 병합</li><li>태그 생성 및 release 브랜치 삭제</li></ol><h5 id=긴급-버그-수정>긴급 버그 수정<a hidden class=anchor aria-hidden=true href=#긴급-버그-수정>#</a></h5><ol><li>master에서 hotfix 브랜치 생성</li><li>버그 수정 및 버전 업데이트</li><li>master와 develop에 병합</li><li>태그 생성 및 hotfix 브랜치 삭제</li></ol><h4 id=장단점>장단점<a hidden class=anchor aria-hidden=true href=#장단점>#</a></h4><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>체계적이고 예측 가능한 개발 프로세스<br>버전 관리와 유지보수가 용이<br>대규모 프로젝트와 팀에 적합<br>릴리즈 주기가 긴 프로젝트에 효과적<br>엄격한 코드 품질 관리<br>명확한 역할 분담</td><td>복잡한 브랜치 구조로 인한 학습 곡선<br>소규모 프로젝트나 빠른 배포가 필요한 경우 과도할 수 있다.<br>브랜치 관리에 시간과 노력이 많이 소요될 수 있음.</td></tr></tbody></table><h4 id=적용-적합성>적용 적합성<a hidden class=anchor aria-hidden=true href=#적용-적합성>#</a></h4><table><thead><tr><th>프로젝트 규모</th><th>팀 규모</th><th>배포 빈도</th><th>품질 관리 수준</th></tr></thead><tbody><tr><td>중대형 프로젝트</td><td>5인 이상</td><td>주/월 단위 정기적인 릴리즈</td><td>높은 수준의 QA 프로세스 필요<br>체계적인 테스트 체계 필요<br>코드 리뷰 문화 필수</td></tr></tbody></table><h4 id=리스크-요소>리스크 요소<a hidden class=anchor aria-hidden=true href=#리스크-요소>#</a></h4><table><thead><tr><th>통합 리스크</th><th>배포 리스크</th><th>품질 리스크</th><th>관리 리스크</th></tr></thead><tbody><tr><td>장기 실행 브랜치의 병합 충돌<br><code>feature</code> 브랜치 간의 의존성<br>큰 규모의 병합으로 인한 위험</td><td>복잡한 배포 프로세스<br>릴리즈 준비 기간 장기화<br><code>hotfix</code> 적용의 복잡성</td><td>브랜치 간 코드 동기화 문제<br>테스트 커버리지 확보 어려움<br>코드 리뷰 병목 현상</td><td>브랜치 관리에 많은 시간이 노력이 필요</td></tr></tbody></table><h5 id=복잡도-증가-요인>복잡도 증가 요인<a hidden class=anchor aria-hidden=true href=#복잡도-증가-요인>#</a></h5><ul><li>다양한 종류의 브랜치 사용</li><li>엄격한 브랜치 생성 및 병합 규칙</li><li>릴리스 및 핫픽스 프로세스의 복잡성</li></ul><h4 id=cicd를-위한-요구-사항>CI/CD를 위한 요구 사항<a hidden class=anchor aria-hidden=true href=#cicd를-위한-요구-사항>#</a></h4><ul><li>자동화된 테스트 시스템</li><li>각 브랜치 별 자동 빌드 및 테스트 환경</li><li>릴리즈 브랜치에 대한 자동 배포 파이프라인</li><li>브랜치 상태 모니터링 시스템</li></ul><h5 id=통합-방법>통합 방법<a hidden class=anchor aria-hidden=true href=#통합-방법>#</a></h5><ol><li>브랜치 전략과 CI/CD 파이프라인 연동<ul><li><code>master(main)</code>와 <code>develop</code> 브랜치에 대한 자동 빌드 및 테스트 파이프라인 구성</li><li><code>feature</code>, <code>release</code>, <code>hotfix</code> 브랜치에 대한 별도의 CI 파이프라인 설정.</li></ul></li><li>자동화된 테스트<ul><li>모든 브랜치에 대해 자동화된 단위 테스트, 통합 테스트 실행</li><li><code>develop</code> 브랜치로의 병합 시 추가적인 테스트 수행</li></ul></li><li>환경별 배포<ul><li><code>develop</code> 브랜치는 개발/테스트 환경에 자동 배포</li><li><code>release</code> 브랜치는 스테이징 환경에 배포</li><li><code>master</code> 브랜치는 프로덕션 환경에 배포</li></ul></li><li>코드 리뷰 프로세스<ul><li>Pull Request 생성 시 자동으로 CI 파이프라인 실행</li><li>코드 리뷰 승인 후 자동 병합 및 배포</li></ul></li><li>버전 관리<ul><li><code>release</code> 브랜치 생성 시 자동으로 버전 태그 생성</li><li>배포 시 해당 버전 정보 포함</li></ul></li><li>모니터링 및 롤백<ul><li>배포 후 자동화된 모니터링 시스템 연동</li><li>문제 발생 시 빠른 롤백 메커니즘 구현</li></ul></li><li>문서화<ul><li>CI/CD 파이프라인 실행 결과 자동 문서화</li><li>릴리즈 노트 자동 생성</li></ul></li></ol><h4 id=버전-관리-방식>버전 관리 방식<a hidden class=anchor aria-hidden=true href=#버전-관리-방식>#</a></h4><h5 id=버전-관리-체계>버전 관리 체계<a hidden class=anchor aria-hidden=true href=#버전-관리-체계>#</a></h5><p>Semantic Versioning(SemVer)을 사용</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>MAJOR.MINOR.PATCH
</span></span></code></pre></td></tr></table></div></div><ul><li>주 버전(Major): 호환성이 깨지는 변경사항</li><li>부 버전(Minor): 기능 추가</li><li>패치 버전(Patch): 버그 수정<br>예: 1.2.3 (주 버전 1, 부 버전 2, 패치 3)</li></ul><h5 id=태그-관리>태그 관리<a hidden class=anchor aria-hidden=true href=#태그-관리>#</a></h5><ul><li>모든 릴리즈에 태그 부여</li><li>버전 정보 포함</li><li>릴리즈 노트 연결</li></ul><h5 id=이력-관리>이력 관리<a hidden class=anchor aria-hidden=true href=#이력-관리>#</a></h5><ul><li>릴리즈 노트 작성</li><li>변경 이력 문서화</li><li>주요 변경 사항 추적</li></ul><h3 id=github-flow>GitHub Flow<a hidden class=anchor aria-hidden=true href=#github-flow>#</a></h3><p><figure><img alt="Github Flow" loading=lazy src=/img/48032310-63842400-e114-11e8-8db0-06dc0504dcb5.png><figcaption>https://github.com/SvanBoxel/release-based-workflow/issues/1</figcaption></figure></p><h4 id=특징-1>특징<a hidden class=anchor aria-hidden=true href=#특징-1>#</a></h4><ul><li>단순한 브랜치 전략</li><li><code>main</code> 브랜치 중심의 지속적 배포</li><li>Pull Request 기반 코드 리뷰</li><li>빠른 피드백과 지속적 통합</li><li>자동화된 테스트와 배포 강조</li></ul><h4 id=핵심-원칙-1>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙-1>#</a></h4><ol><li>main 브랜치는 항상 배포 가능한 상태 유지</li><li>새로운 작업은 항상 기능 브랜치에서 수행</li><li>기능 브랜치는 자주 push하고 Pull Request 생성</li><li>Pull Request를 통한 코드 리뷰 필수</li><li>승인된 Pull Request는 즉시 main에 병합</li><li>main에 병합된 변경사항은 즉시 배포</li></ol><h4 id=구조-및-branch-종류-1>구조 및 Branch 종류<a hidden class=anchor aria-hidden=true href=#구조-및-branch-종류-1>#</a></h4><h5 id=main-master><code>main (master)</code><a hidden class=anchor aria-hidden=true href=#main-master>#</a></h5><ul><li>항상 배포 가능한 상태 유지</li><li>모든 코드는 리뷰를 거쳐 병합</li></ul><h5 id=feature-branches><code>feature Branches</code><a hidden class=anchor aria-hidden=true href=#feature-branches>#</a></h5><ul><li>모든 개발은 <code>feature</code> 브랜치에서 진행</li><li>기능/버그수정/문서 등 모든 변경사항.</li></ul><h4 id=작업-시나리오-1>작업 시나리오<a hidden class=anchor aria-hidden=true href=#작업-시나리오-1>#</a></h4><h5 id=새로운-기능-개발>새로운 기능 개발<a hidden class=anchor aria-hidden=true href=#새로운-기능-개발>#</a></h5><ol><li>main에서 feature 브랜치 생성</li><li>기능 개발 및 테스트</li><li>PR 생성 및 리뷰</li><li>main에 병합 및 배포</li></ol><h5 id=버그-수정>버그 수정<a hidden class=anchor aria-hidden=true href=#버그-수정>#</a></h5><ol><li>main에서 hotfix 브랜치 생성</li><li>수정 및 테스트</li><li>PR 생성 및 긴급 리뷰</li><li>main에 병합 및 즉시 배포</li></ol><h5 id=실험적-기능>실험적 기능<a hidden class=anchor aria-hidden=true href=#실험적-기능>#</a></h5><ol><li>prototype 브랜치 생성</li><li>기능 구현 및 검증</li><li>성공 시 정식 feature로 전환</li></ol><h4 id=장단점-1>장단점<a hidden class=anchor aria-hidden=true href=#장단점-1>#</a></h4><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>간단하고 이해하기 쉬움<br>빠른 개발과 배포 주기 지원<br>지속적인 통합과 배포 용이<br>코드 리뷰 문화 강화</td><td>버전 관리가 명시적이지 않음<br>대규모 프로젝트나 복잡한 릴리스 관리에는 부적합할 수 있음<br>hotfix 처리를 위한 별도 프로세스 부재<br>환경별 배포 관리 어려움<br>롤백 복잡성</td></tr></tbody></table><h4 id=적용-적합성-1>적용 적합성<a hidden class=anchor aria-hidden=true href=#적용-적합성-1>#</a></h4><table><thead><tr><th>프로젝트 규모</th><th>팀 규모</th><th>배포 빈도</th><th>품질 관리 수준</th></tr></thead><tbody><tr><td>소규모 ~ 중규모 프로젝트</td><td>작은 팀 ~ 중간 규모 팀 (5-20명)</td><td>매우 빈번 (일 단위 또는 그 이상)</td><td>자동화된 테스트 필수<br>코드 리뷰 문화 중요<br>CI/CD 파이프라인 필요</td></tr></tbody></table><h4 id=리스크-요소-1>리스크 요소<a hidden class=anchor aria-hidden=true href=#리스크-요소-1>#</a></h4><table><thead><tr><th>통합 리스크</th><th>배포 리스크</th><th>품질 리스크</th><th>관리 리스크</th></tr></thead><tbody><tr><td>동시 다발적 PR 충돌<br>테스트 커버리지 부족<br>리뷰 병목 현상<br><br></td><td>잦은 배포로 인한 불안정성<br>롤백 복잡성<br>환경 설정 관리 어려움<br><br></td><td>빠른 개발로 인한 품질 저하<br>문서화 부족<br>기술 부채 누적<br><br></td><td>명시적인 버전 관리의 어려움</td></tr></tbody></table><h5 id=복잡도-증가-요인-1>복잡도 증가 요인<a hidden class=anchor aria-hidden=true href=#복잡도-증가-요인-1>#</a></h5><ul><li>동시 진행 PR 수 증가</li><li>팀 규모 증가</li><li>환경 설정 다양화</li></ul><h4 id=cicd를-위한-요구-사항-1>CI/CD를 위한 요구 사항<a hidden class=anchor aria-hidden=true href=#cicd를-위한-요구-사항-1>#</a></h4><ul><li>자동화된 빌드 및 테스트 시스템</li><li>지속적 통합(CI) 도구 (예: Jenkins, GitHub Actions)</li><li>자동화된 배포 파이프라인</li><li>코드 품질 검사 도구 (예: SonarQube)</li><li>모니터링 및 로깅 시스템</li></ul><h5 id=통합-방법-1>통합 방법<a hidden class=anchor aria-hidden=true href=#통합-방법-1>#</a></h5><ol><li>GitHub Actions 활용:<ul><li>GitHub에서 제공하는 CI/CD 도구인 GitHub Actions를 사용하여 워크플로우를 자동화</li><li>.github/workflows 디렉토리에 YAML 파일로 워크플로우를 정의.</li></ul></li><li>자동화된 테스트 구현:<ul><li>풀 리퀘스트가 생성될 때마다 자동으로 빌드 및 테스트를 실행하도록 설정.</li><li>단위 테스트, 통합 테스트, 코드 스타일 검사 등을 포함.</li></ul></li><li>지속적 통합 (CI) 설정:<ul><li>모든 코드 변경사항에 대해 자동으로 빌드와 테스트를 실행.</li><li>메인 브랜치에 병합하기 전에 모든 테스트를 통과해야 한다.</li></ul></li><li>지속적 배포 (CD) 구현:<ul><li>테스트를 통과한 코드를 자동으로 스테이징 또는 프로덕션 환경에 배포.</li><li>필요에 따라 수동 승인 단계를 추가할 수 있다.</li></ul></li><li>환경 변수 및 시크릿 관리:<ul><li>GitHub의 시크릿 기능을 사용하여 민감한 정보를 안전하게 관리.</li></ul></li><li>모니터링 및 알림 설정:<ul><li>워크플로우 상태, 실패, 중요 이벤트에 대한 알림을 설정.</li></ul></li><li>코드 품질 검사 통합:<ul><li>정적 코드 분석, 코드 커버리지 검사 등을 워크플로우에 포함.</li></ul></li><li>병렬 실행 및 매트릭스 빌드 활용:<ul><li>여러 환경에서 동시에 테스트를 실행하여 효율성을 높인다.</li></ul></li><li>캐싱 활용:<ul><li>의존성 및 빌드 결과물을 캐싱하여 빌드 시간을 단축한다.</li></ul></li><li>정기적인 워크플로우 검토 및 최적화:<ul><li>CI/CD 파이프라인을 주기적으로 검토하고 개선한다.</li></ul></li></ol><h4 id=버전-관리-방식-1>버전 관리 방식<a hidden class=anchor aria-hidden=true href=#버전-관리-방식-1>#</a></h4><ul><li>명시적인 버전 관리보다는 커밋 해시나 배포 시간을 이용</li><li>필요시 Git 태그를 활용하여 주요 릴리스 표시</li></ul><h3 id=gitlab-flow>GitLab Flow<a hidden class=anchor aria-hidden=true href=#gitlab-flow>#</a></h3><p><figure><img alt="Gitlab Flow" loading=lazy src=/img/image-9.png><figcaption>https://blog.programster.org/git-workflows</figcaption></figure></p><p><figure><img alt="Gitlab Flow" loading=lazy src=/img/image-10-1024x707.png><figcaption>https://www.linkedin.com/pulse/gitlab-flow-jadson-santos</figcaption></figure></p><h4 id=특징-2>특징<a hidden class=anchor aria-hidden=true href=#특징-2>#</a></h4><ul><li>Git Flow의 복잡성을 줄이고, GitHub Flow의 단순성을 결합</li><li>환경별 브랜치 전략 채택</li><li>지속적 배포와 안정성 균형</li><li>단방향 워크플로우<ul><li><code>main</code> → <code>staging</code> → <code>pre-production</code> → <code>production</code></li></ul></li><li>개발, 스테이징, 프로덕션 환경을 위한 브랜치 구조 지원</li></ul><h4 id=핵심-원칙-2>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙-2>#</a></h4><ul><li>모든 코드 변경은 이슈 트래킹 시스템과 연결</li><li><code>main</code> 브랜치는 항상 안정적이고 배포 가능한 상태 유지</li><li>환경별로 명확한 테스트 및 배포 절차 준수</li><li>Merge Request를 통한 코드 리뷰 필수</li></ul><h4 id=구조-및-branch-종류-2>구조 및 Branch 종류<a hidden class=anchor aria-hidden=true href=#구조-및-branch-종류-2>#</a></h4><h5 id=main>Main<a hidden class=anchor aria-hidden=true href=#main>#</a></h5><ul><li>개발의 기준점</li><li>통합된 코드 관리</li><li>CI 통과 필수</li><li><code>feature</code> 브랜치의 병합 대상</li></ul><h5 id=production>Production<a hidden class=anchor aria-hidden=true href=#production>#</a></h5><ul><li>실제 운영 환경 코드</li><li>안정성 검증 완료</li><li>배포 이력 관리</li><li><code>main</code>에서 테스트 완료된 코드를 병합</li></ul><h5 id=pre-productionstaging>pre-production/staging<a hidden class=anchor aria-hidden=true href=#pre-productionstaging>#</a></h5><ul><li>운영 환경 검증용</li><li>QA 테스트 진행</li><li>성능/부하 테스트</li><li><code>main</code>에서 분기하여 테스트 후 <code>production</code>으로 병합.</li></ul><h5 id=feature>Feature<a hidden class=anchor aria-hidden=true href=#feature>#</a></h5><ul><li>기능 개발용</li><li><code>main</code>에서 분기하여 작업 후 Merge Request 생성.</li></ul><h5 id=hotfix>Hotfix<a hidden class=anchor aria-hidden=true href=#hotfix>#</a></h5><ul><li>긴급 버그 수정</li><li><code>production</code>에서 분기</li><li>모든 환경에 반영</li></ul><h4 id=작업-시나리오-2>작업 시나리오<a hidden class=anchor aria-hidden=true href=#작업-시나리오-2>#</a></h4><h5 id=새로운-기능-개발-1>새로운 기능 개발<a hidden class=anchor aria-hidden=true href=#새로운-기능-개발-1>#</a></h5><ol><li>Main에서 Feature 브랜치 생성</li><li>개발 및 테스트</li><li>Main에 MR 생성</li><li>리뷰 및 CI 통과</li><li>단계적 환경 배포</li></ol><h5 id=버그-수정-1>버그 수정<a hidden class=anchor aria-hidden=true href=#버그-수정-1>#</a></h5><ol><li>Production에서 Hotfix 브랜치 생성</li><li>수정 및 테스트</li><li>Production에 병합</li><li>하위 환경에 백포트</li></ol><h5 id=정기-배포>정기 배포<a hidden class=anchor aria-hidden=true href=#정기-배포>#</a></h5><ol><li>Main 브랜치 안정화</li><li>Staging 환경 배포</li><li>QA 검증</li><li>Pre-production 검증</li><li>Production 배포</li></ol><h4 id=장단점-2>장단점<a hidden class=anchor aria-hidden=true href=#장단점-2>#</a></h4><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>유연한 환경 관리<br>이슈 트래킹과의 통합으로 투명한 개발 프로세스<br>다양한 배포 시나리오 지원<br>안정성</td><td>Git Flow보다는 단순하지만 GitHub Flow보다는 복잡<br>환경별 브랜치 관리에 따른 추가 작업 필요</td></tr></tbody></table><h4 id=적용-적합성-2>적용 적합성<a hidden class=anchor aria-hidden=true href=#적용-적합성-2>#</a></h4><table><thead><tr><th>프로젝트 규모</th><th>팀 규모</th><th>배포 빈도</th><th>품질 관리 수준</th></tr></thead><tbody><tr><td>중소규모 ~ 대규모 프로젝트</td><td>5-50명 정도의 중소규모 팀</td><td>주 단위 또는 2주 단위 배포</td><td>중간 ~ 높은 수준의 품질 관리 필요</td></tr></tbody></table><h4 id=리스크-요소-2>리스크 요소<a hidden class=anchor aria-hidden=true href=#리스크-요소-2>#</a></h4><table><thead><tr><th>통합 리스크</th><th>배포 리스크</th><th>품질 리스크</th><th>관리 리스크</th></tr></thead><tbody><tr><td>브랜치 간 동기화 문제<br>환경별 설정 불일치<br>병합 충돌</td><td>환경별 배포 실패<br>설정 오류<br>성능 저하</td><td>여러 환경에서의 일관된 품질 유지 필요</td><td>브랜치 관리 복잡성<br>환경 설정 부담<br>문서화 필요성</td></tr></tbody></table><h5 id=복잡도-증가-요인-2>복잡도 증가 요인<a hidden class=anchor aria-hidden=true href=#복잡도-증가-요인-2>#</a></h5><ul><li><strong>브랜치 관리</strong><ul><li>다중 환경 구성</li><li>동기화 필요성</li><li>버전 관리</li></ul></li><li><strong>배포 프로세스</strong><ul><li>단계적 검증</li><li>환경별 설정</li><li>롤백 절차</li></ul></li><li><strong>설정 관리</strong><ul><li>환경별 변수</li><li>접근 권한</li><li>보안 설정</li></ul></li></ul><h4 id=cicd를-위한-요구-사항-2>CI/CD를 위한 요구 사항<a hidden class=anchor aria-hidden=true href=#cicd를-위한-요구-사항-2>#</a></h4><ul><li>자동화된 테스트 시스템</li><li>환경별 자동 배포 파이프라인</li><li>코드 품질 검사 도구</li><li>모니터링 및 로깅 시스템</li></ul><h5 id=통합-방법-2>통합 방법<a hidden class=anchor aria-hidden=true href=#통합-방법-2>#</a></h5><ol><li>.gitlab-ci.yml 파일 생성:<ul><li>프로젝트 루트에.gitlab-ci.yml 파일을 생성하여 CI/CD 파이프라인을 정의한다.</li></ul></li><li>파이프라인 구조 정의:<ul><li>stages를 정의하여 파이프라인의 단계를 구성한다 (예: build, test, deploy).</li><li>각 stage에 해당하는 job을 정의한다.</li></ul></li><li>브랜치별 파이프라인 설정:<ul><li>main, production 등 주요 브랜치에 대한 파이프라인을 별도로 구성한다.</li><li>rules 키워드를 사용하여 브랜치별로 다른 job을 실행하도록 설정한다.</li></ul></li><li>자동화된 테스트 구현:<ul><li>단위 테스트, 통합 테스트 등을 파이프라인에 포함시킨다.</li><li>test stage에서 다양한 테스트를 실행하도록 구성한다.</li></ul></li><li>환경별 배포 자동화:<ul><li>개발, 스테이징, 프로덕션 환경에 대한 자동 배포 job을 구성한다.</li><li>environment 키워드를 사용하여 배포 환경을 지정한다.</li></ul></li><li>품질 검사 도구 통합:<ul><li>코드 품질, 보안 검사 등을 수행하는 job을 추가한다.</li></ul></li><li>아티팩트 및 캐시 활용:<ul><li>artifacts와 cache를 사용하여 빌드 결과물을 저장하고 재사용한다.</li></ul></li><li>CI/CD 변수 활용:<ul><li>GitLab의 CI/CD 변수 기능을 사용하여 민감한 정보를 안전하게 관리한다.</li></ul></li><li>모니터링 및 알림 설정:<ul><li>파이프라인 실행 결과에 대한 알림을 구성한다.</li></ul></li><li>GitLab Runner 설정:<ul><li>프로젝트에 적합한 Runner를 구성하여 CI/CD 작업을 실행한다.</li></ul></li></ol><h4 id=버전-관리-방식-2>버전 관리 방식<a hidden class=anchor aria-hidden=true href=#버전-관리-방식-2>#</a></h4><ul><li>시맨틱 버저닝 (MAJOR.MINOR.PATCH)</li><li>환경별 태그 관리</li><li>배포 이력 추적</li></ul><h3 id=scaled-trunk-based-development>Scaled Trunk-Based Development<a hidden class=anchor aria-hidden=true href=#scaled-trunk-based-development>#</a></h3><p><figure><img alt="Scaled Trunk-Based Development" loading=lazy src=/img/trunk1c.png><figcaption>https://trunkbaseddevelopment.com/</figcaption></figure></p><h4 id=특징-3>특징<a hidden class=anchor aria-hidden=true href=#특징-3>#</a></h4><ul><li>단일 메인 브랜치(trunk)를 중심으로 개발</li><li>짧은 수명의 기능 브랜치 사용</li><li>빈번한 통합과 배포</li><li>기능 플래그를 활용한 기능 관리</li><li>대규모 팀과 프로젝트에 적합</li><li>마이크로서비스 아키텍처 지원</li></ul><h4 id=핵심-원칙-3>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙-3>#</a></h4><ul><li>trunk는 항상 안정적이고 배포 가능한 상태 유지</li><li>기능 브랜치는 짧게 유지 (1-2일 이내)</li><li>빈번한 통합과 배포</li><li>자동화된 테스트와 CI/CD 파이프라인 필수</li><li>기능 플래그를 활용한 미완성 기능 관리</li></ul><h4 id=구조-및-branch-종류-3>구조 및 Branch 종류<a hidden class=anchor aria-hidden=true href=#구조-및-branch-종류-3>#</a></h4><ul><li><p>Trunk 브랜치:</p><ul><li>항상 배포 가능한 상태 유지</li><li>모든 개발 작업의 최종 목적지</li></ul></li><li><p>기능 브랜치:</p><ul><li>개별 기능 개발을 위해 trunk에서 분기</li><li>빠르게 개발 완료 후 trunk로 병합 (보통 1-2일 이내)</li></ul></li><li><p>릴리스 브랜치:</p><ul><li>필요시에만 생성</li><li>릴리스 준비 및 핫픽스를 위해 사용</li></ul></li></ul><h4 id=작업-시나리오-3>작업 시나리오<a hidden class=anchor aria-hidden=true href=#작업-시나리오-3>#</a></h4><h5 id=새로운-기능-개발-2>새로운 기능 개발<a hidden class=anchor aria-hidden=true href=#새로운-기능-개발-2>#</a></h5><ol><li>Feature Flag 생성</li><li>임시 브랜치 생성</li><li>기능 구현 (1-2일)</li><li>테스트 및 리뷰</li><li>main 병합</li><li>단계적 Flag 활성화</li></ol><h5 id=긴급-수정>긴급 수정<a hidden class=anchor aria-hidden=true href=#긴급-수정>#</a></h5><ol><li>main에서 직접 수정</li><li>테스트 자동화</li><li>즉시 배포</li><li>모니터링</li></ol><h4 id=장단점-3>장단점<a hidden class=anchor aria-hidden=true href=#장단점-3>#</a></h4><table><thead><tr><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>빠른 통합과 피드백<br>병합 충돌 최소화<br>지속적 배포 용이<br>대규모 팀 협업에 적합</td><td>높은 수준의 자동화 필요<br>기능 플래그 관리의 복잡성<br>팀원들의 높은 기술력과 규율 필요</td></tr></tbody></table><h4 id=적용-적합성-3>적용 적합성<a hidden class=anchor aria-hidden=true href=#적용-적합성-3>#</a></h4><table><thead><tr><th>프로젝트 규모</th><th>팀 규모</th><th>배포 빈도</th><th>품질 관리 수준</th></tr></thead><tbody><tr><td>중대형 프로젝트</td><td>대규모 팀 (50명 이상)</td><td>매우 빈번 (일일 또는 그 이상)</td><td>높은 수준의 자동화된 테스트 필요</td></tr></tbody></table><h4 id=리스크-요소-3>리스크 요소<a hidden class=anchor aria-hidden=true href=#리스크-요소-3>#</a></h4><table><thead><tr><th>통합 리스크</th><th>배포 리스크</th><th>품질 리스크</th><th>관리 리스크</th></tr></thead><tbody><tr><td>빈번한 통합으로 인한 일시적 불안정성</td><td>잦은 배포로 인한 운영 부담 증가</td><td>빠른 개발 주기로 인한 품질 저하 가능성</td><td>기능 플래그 관리의 복잡성</td></tr></tbody></table><h5 id=복잡도-증가-요인-3>복잡도 증가 요인<a hidden class=anchor aria-hidden=true href=#복잡도-증가-요인-3>#</a></h5><ul><li>전반적으로 중간 수준의 복잡도</li><li>기능 플래그 관리와 대규모 팀 조정에서 복잡도 증가</li></ul><h4 id=cicd를-위한-요구-사항-3>CI/CD를 위한 요구 사항<a hidden class=anchor aria-hidden=true href=#cicd를-위한-요구-사항-3>#</a></h4><ul><li>강력한 자동화된 테스트 시스템</li><li>빠른 빌드 및 배포 파이프라인</li><li>코드 품질 검사 도구</li><li>실시간 모니터링 시스템</li><li>기능 플래그 관리 시스템</li></ul><h5 id=통합-방법-3>통합 방법<a hidden class=anchor aria-hidden=true href=#통합-방법-3>#</a></h5><ol><li>자동화된 빌드 및 테스트 파이프라인 구축:<ul><li>모든 커밋에 대해 자동으로 빌드 및 테스트를 실행하는 CI 파이프라인 구성</li><li>단위 테스트, 통합 테스트, 성능 테스트 등 다양한 테스트 자동화</li></ul></li><li>짧은 수명의 기능 브랜치 사용:<ul><li>기능 브랜치에서 작업 후 빠르게 trunk로 병합 (보통 1-2일 이내)</li><li>각 기능 브랜치에 대해 자동화된 테스트 실행</li></ul></li><li>트렁크 브랜치 보호:<ul><li>트렁크 브랜치에 직접 푸시 금지</li><li>모든 변경사항은 코드 리뷰와 자동화된 테스트를 거친 후 병합</li></ul></li><li>지속적 배포(CD) 구현:<ul><li>트렁크 브랜치에 병합된 코드를 자동으로 스테이징 환경에 배포</li><li>스테이징 환경에서 추가 테스트 후 문제가 없으면 프로덕션 환경으로 자동 배포</li></ul></li><li>기능 플래그 사용:<ul><li>미완성 기능을 트렁크에 안전하게 병합할 수 있도록 기능 플래그 구현</li><li>CI/CD 파이프라인에서 기능 플래그 상태를 제어</li></ul></li><li>모니터링 및 롤백 메커니즘:<ul><li>배포 후 실시간 모니터링 시스템 구축</li><li>문제 발생 시 빠른 롤백이 가능한 시스템 구현</li></ul></li><li>릴리스 관리 자동화:<ul><li>버전 관리 및 릴리스 노트 생성 자동화</li><li>릴리스 프로세스를 CI/CD 파이프라인에 통합</li></ul></li><li>코드 품질 검사 통합:<ul><li>정적 코드 분석 도구를 CI/CD 파이프라인에 통합</li><li>코드 커버리지, 복잡도 등의 메트릭을 지속적으로 모니터링</li></ul></li><li>환경 구성 관리:<ul><li>인프라스트럭처 as 코드(IaC) 도구를 사용하여 환경 구성 자동화</li><li>개발, 스테이징, 프로덕션 환경의 일관성 유지</li></ul></li></ol><h4 id=버전-관리-방식-3>버전 관리 방식<a hidden class=anchor aria-hidden=true href=#버전-관리-방식-3>#</a></h4><ul><li>지속적 배포로 인해 세밀한 버전 관리가 필요</li><li>Semantic Versioning 사용 권장</li><li>자동화된 버전 증가 시스템 구축</li></ul><h3 id=feature-branch-workflow-vs-trunk-based-development-비교>Feature Branch Workflow Vs Trunk-Based Development 비교<a hidden class=anchor aria-hidden=true href=#feature-branch-workflow-vs-trunk-based-development-비교>#</a></h3><table><thead><tr><th>항목</th><th>Feature Branch Workflow</th><th>Trunk-Based Development</th></tr></thead><tbody><tr><td><strong>기본 철학</strong></td><td>기능별 격리 개발</td><td>통합 중심 개발</td></tr><tr><td><strong>브랜치 수명</strong></td><td>긴 수명 (days-weeks)</td><td>짧은 수명 (hours-days)</td></tr><tr><td><strong>주요 브랜치</strong></td><td>main, feature, release 등</td><td>main(trunk) 중심</td></tr><tr><td><strong>코드 리뷰</strong></td><td>PR/MR 기반 공식 리뷰</td><td>실시간/페어 리뷰</td></tr><tr><td><strong>배포 주기</strong></td><td>계획된 정기 배포</td><td>수시 배포 (continuous)</td></tr><tr><td><strong>적합 팀 규모</strong></td><td>중/대규모 (5인 이상)</td><td>소규모 (5인 이하)</td></tr><tr><td><strong>품질 관리</strong></td><td>단계적 검증</td><td>자동화된 검증</td></tr><tr><td><strong>통합 빈도</strong></td><td>낮음 (주단위)</td><td>높음 (일단위)</td></tr><tr><td><strong>자동화 수준</strong></td><td>중간</td><td>높음</td></tr><tr><td><strong>버그 수정</strong></td><td>bugfix/hotfix 브랜치</td><td>직접 main 수정</td></tr><tr><td><strong>기능 격리</strong></td><td>브랜치로 격리</td><td>Feature Toggle 사용</td></tr><tr><td><strong>충돌 관리</strong></td><td>병합 시 해결</td><td>수시로 해결</td></tr><tr><td><strong>릴리즈 관리</strong></td><td>명시적 릴리즈</td><td>지속적 릴리즈</td></tr><tr><td><strong>복잡도</strong></td><td>높음</td><td>낮음</td></tr><tr><td><strong>학습 곡선</strong></td><td>가파름</td><td>완만함</td></tr><tr><td><strong>CI/CD 요구사항</strong></td><td>중간</td><td>높음</td></tr><tr><td><strong>롤백 전략</strong></td><td>브랜치 전환</td><td>Feature Toggle/배포 롤백</td></tr><tr><td><strong>문서화 수준</strong></td><td>높음</td><td>중간</td></tr><tr><td><strong>적합 프로젝트</strong></td><td>복잡한 대형 프로젝트</td><td>단순한 소형 프로젝트</td></tr><tr><td><strong>배포 안정성</strong></td><td>높음</td><td>변동적</td></tr><tr><td>계열</td><td>Git Flow<br>GitHub Flow<br>GitLab Flow<br>기본 Feature Branch Workflow</td><td>Single Trunk Development<br>Scaled Trunk Development<br>Short-Lived Feature Branches<br>Release Branch Model</td></tr></tbody></table><h4 id=핵심-차이점>핵심 차이점<a hidden class=anchor aria-hidden=true href=#핵심-차이점>#</a></h4><h5 id=개발-프로세스>개발 프로세스<a hidden class=anchor aria-hidden=true href=#개발-프로세스>#</a></h5><ul><li><strong>Feature Branch</strong>: 격리 → 개발 → 리뷰 → 병합 → 배포</li><li><strong>Trunk-Based</strong>: 개발 → 통합 → 배포 → 모니터링</li></ul><h5 id=품질-관리>품질 관리<a hidden class=anchor aria-hidden=true href=#품질-관리>#</a></h5><ul><li><strong>Feature Branch</strong>: 사전 검증 중심</li><li><strong>Trunk-Based</strong>: 사후 모니터링 중심</li></ul><h5 id=배포-전략>배포 전략<a hidden class=anchor aria-hidden=true href=#배포-전략>#</a></h5><ul><li><strong>Feature Branch</strong>: 계획적 배포</li><li><strong>Trunk-Based</strong>: 지속적 배포</li></ul><h5 id=팀-문화>팀 문화<a hidden class=anchor aria-hidden=true href=#팀-문화>#</a></h5><ul><li><strong>Feature Branch</strong>: 체계적/계획적</li><li><strong>Trunk-Based</strong>: 애자일/유연함</li></ul><h5 id=도구-요구사항>도구 요구사항<a hidden class=anchor aria-hidden=true href=#도구-요구사항>#</a></h5><ul><li><strong>Feature Branch</strong>: 브랜치 관리 도구</li><li><strong>Trunk-Based</strong>: 자동화 도구</li></ul><h3 id=git-branch-전략별-비교>Git Branch 전략별 비교<a hidden class=anchor aria-hidden=true href=#git-branch-전략별-비교>#</a></h3><table><thead><tr><th>특성</th><th>Git Flow</th><th>GitHub Flow</th><th>GitLab Flow</th><th>Scaled Trunk-Based</th></tr></thead><tbody><tr><td><strong>특징</strong></td><td>엄격한 브랜치 관리<br>장기 릴리즈 주기<br>체계적 구조</td><td>단순한 구조<br>지속적 배포<br>PR 기반 리뷰</td><td>환경별 브랜치<br>단방향 워크플로우<br>이슈 트래킹 통합</td><td>단일 트렁크 중심<br>짧은 브랜치 수명<br>기능 플래그 활용</td></tr><tr><td><strong>브랜치 종류</strong></td><td>master<br>develop<br>feature<br>release<br>hotfix</td><td>main<br>feature</td><td>main<br>production<br>pre-production<br>feature<br>hotfix</td><td>trunk<br>feature(1-2일)<br>release</td></tr><tr><td><strong>핵심 원칙</strong></td><td>master 안정성<br>develop 기반 개발<br>feature 격리</td><td>main 안정성<br>feature 분리<br>PR 필수</td><td>환경별 배포<br>단방향 흐름<br>MR 필수</td><td>빠른 통합<br>짧은 브랜치<br>기능 플래그</td></tr><tr><td><strong>장점</strong></td><td>체계적 버전관리<br>안정적 배포<br>명확한 역할구분</td><td>단순성<br>빠른 배포<br>쉬운 학습곡선</td><td>환경 관리 용이<br>단계적 배포<br>안정성</td><td>빠른 통합<br>최소 충돌<br>지속적 배포</td></tr><tr><td><strong>단점</strong></td><td>복잡한 구조<br>느린 배포<br>관리 부담</td><td>버전관리 어려움<br>복잡한 릴리즈<br>환경구분 없음</td><td>복잡한 구조<br>관리 부담<br>느린 배포</td><td>높은 자동화 필요<br>기능플래그 복잡성<br>높은 기술력 요구</td></tr><tr><td><strong>적합 규모</strong></td><td>중대형 프로젝트<br>5인 이상 팀</td><td>소중규모 프로젝트<br>5-20인 팀</td><td>중대형 프로젝트<br>5-50인 팀</td><td>대규모 프로젝트<br>50인 이상 팀</td></tr><tr><td><strong>배포 주기</strong></td><td>주/월 단위</td><td>수시 배포</td><td>주/2주 단위</td><td>매일/수시</td></tr><tr><td><strong>CI/CD 요구사항</strong></td><td>중간 수준<br>브랜치별 파이프라인</td><td>높은 수준<br>자동화 필수</td><td>높은 수준<br>환경별 파이프라인</td><td>매우 높은 수준<br>완전 자동화</td></tr><tr><td><strong>버전 관리</strong></td><td>Semantic Versioning<br>태그 필수</td><td>커밋 해시/배포시간</td><td>환경별 태그<br>Semantic Versioning</td><td>지속적 버전관리<br>자동화된 증가</td></tr><tr><td><strong>복잡도</strong></td><td>높음</td><td>낮음</td><td>중간</td><td>중간-높음</td></tr></tbody></table><h3 id=git-branch-전략-선택-시-고려사항>Git Branch 전략 선택 시 고려사항<a hidden class=anchor aria-hidden=true href=#git-branch-전략-선택-시-고려사항>#</a></h3><table><thead><tr><th>영역</th><th>주요 고려사항</th></tr></thead><tbody><tr><td><strong>프로젝트 컨텍스트</strong></td><td>• 프로젝트 규모/복잡도<br>• 안정성 요구사항<br>• 릴리스 주기<br>• 마이크로서비스 여부<br>• 유지보수 용이성</td></tr><tr><td><strong>팀 구성 및 문화</strong></td><td>• 팀 규모 (현재/미래)<br>• Git 사용 경험 수준<br>• 개발자 숙련도<br>• 분산 팀 여부<br>• 협업/코드 리뷰 문화<br>• 학습 곡선</td></tr><tr><td><strong>배포 프로세스</strong></td><td>• 배포 빈도<br>• 환경 구성<br>• 롤백 필요성<br>• 버전 관리 요구사항<br>• 무중단 배포 필요성</td></tr><tr><td><strong>품질 관리</strong></td><td>• 테스트 자동화 수준<br>• 코드 리뷰 정책<br>• 품질 게이트<br>• 문서화 요구사항<br>• 모니터링 체계</td></tr><tr><td><strong>인프라 및 기술</strong></td><td>• CI/CD 인프라 수준<br>• 자동화 도구 활용<br>• 테스트 인프라<br>• 운영 환경 구성<br>• 기존 시스템 호환성</td></tr><tr><td><strong>비즈니스 요구사항</strong></td><td>• Time to Market<br>• 고객 피드백 반영<br>• 버그 수정 우선순위<br>• 보안/규제 요구사항<br>• 회사 정책</td></tr><tr><td><strong>리스크 관리</strong></td><td>• 통합 리스크<br>• 배포 리스크<br>• 품질 리스크<br>• 운영 리스크<br>• 롤백 계획</td></tr><tr><td><strong>확장성</strong></td><td>• 팀/프로젝트 확장 계획<br>• 기술 스택 변화 대응<br>• 요구사항 변화 대응<br>• 장기적 유지보수</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-development/>Software-Development</a></li><li><a href=https://buenhyden.github.io/tags/software-maintenance/>Software-Maintenance</a></li><li><a href=https://buenhyden.github.io/tags/devops/>DevOps</a></li><li><a href=https://buenhyden.github.io/tags/ci-cd/>CI-CD</a></li><li><a href=https://buenhyden.github.io/tags/version-control/>Version-Control</a></li><li><a href=https://buenhyden.github.io/tags/git/>Git</a></li><li><a href=https://buenhyden.github.io/tags/git-branch/>Git-Branch</a></li><li><a href=https://buenhyden.github.io/tags/git-flow/>Git-Flow</a></li><li><a href=https://buenhyden.github.io/tags/github-flow/>Github-Flow</a></li><li><a href=https://buenhyden.github.io/tags/gitlab-flow/>Gitlab-Flow</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-hierarchy/><span class=title>« Prev</span><br><span>메모리의 계층 구조 (Memory Hierarchy)</span>
</a><a class=next href=https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/><span class=title>Next »</span><br><span>클린 코드 (Clean Code)</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>