<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git 원격 저장소와 Branch | hyunyoun's Blog</title>
<meta name=keywords content="Software-Development,Software-Maintenance,DevOps,CI-CD,Version-Control,Git,branch,remote"><meta name=description content="소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Git 원격 저장소와 Branch"><meta property="og:description" content="소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-20T07:28:00+00:00"><meta property="article:modified_time" content="2024-09-20T07:28:00+00:00"><meta property="article:tag" content="Software-Development"><meta property="article:tag" content="Software-Maintenance"><meta property="article:tag" content="DevOps"><meta property="article:tag" content="CI-CD"><meta property="article:tag" content="Version-Control"><meta property="article:tag" content="Git"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Git 원격 저장소와 Branch"><meta name=twitter:description content="소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Software Development and Maintenance","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/"},{"@type":"ListItem","position":3,"name":"DevOps","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/"},{"@type":"ListItem","position":4,"name":"CI/CD","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/"},{"@type":"ListItem","position":5,"name":"Git 기본 사용법","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/"},{"@type":"ListItem","position":6,"name":"Git 원격 저장소와 Branch","item":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git 원격 저장소와 Branch","name":"Git 원격 저장소와 Branch","description":"소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다.","keywords":["Software-Development","Software-Maintenance","DevOps","CI-CD","Version-Control","Git","branch","remote"],"articleBody":"Git의 원격 저장소와 Branch 원격 저장소와 협업 원격 저장소 기본 명령어 명령어 설명 사용 예시 git remote 원격 저장소 목록 조회 git remote git remote -v 상세 정보(URL) 조회 git remote -v git remote add 원격 저장소 추가 git remote add origin git remote rename 원격 저장소 이름 변경 git remote rename old new git remote remove 원격 저장소 삭제 git remote remove name 원격 저장소 목록 조회 git remote 명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인\n1 2 $ git remote origin 원격 저장소 URL 조회 리모트 저장소가 여러 개 있다면 이 명령은 등록된 전부를 보여준다.\n1 2 3 $ git remote -v origin\thttps://github.com/schacon/ticgit (fetch) origin\thttps://github.com/schacon/ticgit (push) 원격 저장소 추가하기 1 2 3 4 5 6 $ git remote add pb https://github.com/paulboone/ticgit $ git remote -v origin\thttps://github.com/schacon/ticgit (fetch) origin\thttps://github.com/schacon/ticgit (push) pb\thttps://github.com/paulboone/ticgit (fetch) pb\thttps://github.com/paulboone/ticgit (push) 원격 저장소 이름을 바꾸기 ```bash\n$ git remote rename pb paul\n$ git remote\norigin\npaul\n1 2 3 4 5 6 7 8 9 ##### 원격 저장소 삭제하기 원격 저장소를 삭제하면 해당 원격 저장소에 관련된 추적 브랜치 정보나 모든 설정 내용도 함께 삭제된다. ```bash $ git remote remove paul $ git remote origin 원격 저장소에서 데이터 가져오기 데이터 가져오기: git fetch git fetch 명령을 실행하면 서버에는 존재하지만, 로컬에는 아직 없는 데이터를 받아와서 저장한다. 이 때 워킹 디렉토리의 파일 내용은 변경되지 않고 그대로 남는다. 서버로부터 데이터를 가져와서 저장해두고 사용자가 Merge 하도록 준비만 해둔다.\n데이터 가져오기 및 병합: git pull git fetch 명령을 실행하고 나서 자동으로 git merge 명령을 수행\n추적 브랜치가 설정되면 git pull 명령은 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 추적 브랜치를 Merge 한다. 일반적으로 fetch 와 merge 명령을 명시적으로 사용하는 것이 pull 명령으로 한번에 두 작업을 하는 것보다 낫다.\n1 2 3 4 5 6 7 8 # 원격 데이터 가져오기만 (병합 없음) $ git fetch origin # 가져오기 + 자동 병합 $ git pull origin master # 특정 브랜치만 가져오기 $ git fetch origin branch-name 원격 저장소에 데이터 내보내기 로컬 브랜치에서 작업한 내용을 서버로 전송하려면 원격 서버에 Push해야 한다.\n명시적으로 브랜치를 정해서 Push해야 정보가 전송된다.\ngit push \u003c리모트 저장소 이름\u003e \u003c브랜치 이름\u003e\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 기본 푸시 $ git push origin master $ git push origin serverfix Counting objects: 24, done. Delta compression using up to 8 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done. Total 24 (delta 2), reused 0 (delta 0) To https://github.com/schacon/simplegit * [new branch] serverfix -\u003e serverfix # 새 브랜치 푸시 $ git push -u origin new-branch # 강제 푸시 (주의 필요) $ git push -f origin master 원격 저장소 상세 정보 확인 git remote show \u003c리모트 저장소 이름\u003e\n명령어 보여주는 정보 용도 git remote show origin - 원격 URL\n- 브랜치 정보\n- 추적 관계 저장소 구성 확인 1 2 3 4 5 6 7 8 9 10 11 12 $ git remote show origin * remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked dev-branch tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 협업 워크플로우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1. 원격 저장소 복제 $ git clone # 2. 브랜치 생성 및 작업 $ git checkout -b feature-branch # 3. 변경사항 커밋 $ git add . $ git commit -m \"Add feature\" # 4. 원격 저장소 최신화 $ git fetch origin $ git rebase origin/master # 5. 변경사항 푸시 $ git push origin feature-branch 주요 협업 시나리오 시나리오 명령어 sequence 설명 코드 리뷰 1. git push\n2. Pull Request 생성\n3. 리뷰 및 토론\n4. 변경사항 반영 팀 협업시 코드 품질 관리 충돌 해결 1. git pull\n2. 충돌 해결\n3. git add\n4. git commit\n5. git push 동시 수정으로 인한 충돌 처리 모범 사례와 주의사항 영역 권장사항 주의사항 푸시 전 fetch/pull로 최신화\n- 로컬 테스트 수행 - 강제 푸시 주의\n- 대용량 파일 확인 브랜치 관리 - 기능별 브랜치 사용\n- 정기적인 동기화 - 오래된 브랜치 정리\n- 명확한 이름 사용 충돌 관리 - 작은 단위로 커밋\n- 정기적인 동기화 - 충돌 해결 시 신중\n- 팀과 소통 Branch 브랜치의 기본 개념과 내부 구조 구성 요소 설명 특징 커밋 객체 - 파일의 스냅샷\n- 메타데이터\n- 이전 커밋 포인터 변경 이력 추적의 기본 단위 브랜치 포인터 - 특정 커밋을 가리키는 포인터\n- 최신 커밋을 추적 가볍고 빠른 전환 가능 HEAD - 현재 작업 중인 브랜치를 가리킴\n- 워킹 디렉토리의 기준 브랜치 전환의 기준점 브랜치 작업 흐름 단계 명령어 설명 브랜치 생성 git branch 새 브랜치 생성 브랜치 전환 git checkout 작업 브랜치 변경 생성과 전환 git checkout -b 생성과 전환을 동시에 변경사항 커밋 git commit -m \"message\" 브랜치에 변경사항 저장 브랜치 병합 git merge 다른 브랜치 내용 통합 Branch 생성 새로 만든 브랜치는 지금 작업하고 있던 마지막 커밋을 가리킨다.\n1 git branch testing Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80\n파일이 3개 있는 디렉토리가 하나 있고 이 파일을 Staging Area에 저장하고 커밋하는 예제\ngit commit으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다. 1 2 $ git add README test.rb LICENSE $ git commit -m 'The initial commit of my project' 그 다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다.\nGit 저장소에는 다섯 개의 데이터 개체가 생긴다.\n각 파일에 대한 Blob 세 개 파일과 디렉토리 구조가 들어 있는 트리 개체 하나 메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 개체 하나.\n![커밋과 트리 데이터](commit-and-tree.png “https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80 _ 파일을 수정하고 커밋하면 이전 커밋이 무엇인지도 저장한다.\nhttps://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80\nBranch 전환하기 git checkout 명령으로 다른 브랜치로 이동할 수 있다\nHEAD는 testing 브랜치를 가리킨다.\n1 $ git checkout testing Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80\n브랜치를 만들면서 Checkout까지 한 번에 하려면 git checkout 명령에 -b 라는 옵션을 추가한다.\n1 2 $ git checkout -b testing Switched to a new branch \"testing\" 변경사항 커밋 파일을 수정하고 새롭게 커밋을 하면,\n1 2 $ vim test.rb $ git commit -a -m 'made a change' Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80\n1 $ git checkout master 다시, master 브랜치로 되돌아가서,\nSource: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80\n파일을 수정하고, 다시 커밋을 하면,\n1 2 $ vim test.rb $ git commit -a -m 'made other changes' Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80\n두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다.\ngit log 명령으로 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지 확인할 수 있다.\ngit log --oneline --decorate --graph --all 이라고 실행하면 히스토리를 출력한다.\n1 2 3 4 5 6 7 $ git log --oneline --decorate --graph --all * c2b9e (HEAD, master) made other changes | * 87ab2 (testing) made a change |/ * f30ab add feature #32 - ability to add new formats to the * 34ac2 fixed bug #1328 - stack overflow under certain conditions * 98ca9 initial commit of my project 브랜치 병합하기 Fast-forward Merge : 브랜치가 가리키는 커밋이 현재 브랜치 이후의 커밋인 경우\n브랜치와 Merge의 기본적인 진행 전략은\n웹사이트가 있고 작업을 진행중임.\n새로운 이슈를 처리할 새 Branch를 하나 생성함.\n새로운 이슈를 위한 브랜치 이름은 iss53이라고 한다.\n1 2 3 4 5 $ git checkout -b iss53 Switched to a new branch \"iss53\" $ git branch iss53 $ git checkout iss53 https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88\n새로 만든 Branch에서 작업을 진행함.\niss53 브랜치를 Checkout 했기 때문에(즉, HEAD 는 iss53 브랜치를 가리킨다) 작업을 하고 커밋을 하면 iss53 브랜치가 앞으로 나아간다.\nhttps://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88\n이 상황에서 문제를 해결해야할 상황이 생겨 Hotfix를 해야할 상황이라고 가정해보자.\n새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다.\n1 2 $ git checkout master Switched to branch 'master' Hotfix 브랜치를 새로 하나 생성한다.\n1 2 3 4 5 6 $ git checkout -b hotfix Switched to a new branch 'hotfix' $ vim index.html $ git commit -a -m 'fixed the broken email address' [hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+) https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88\n3. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge한다. ```bash $ git checkout master $ git merge hotfix Updating f42c576.a0874c Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) ``` Merge 메시지에서 \"Fast-forward\" `hotfix` 브랜치가 가리키는 `C4` 커밋이 `C2` 커밋에 기반한 브랜치이기 때문에 브랜치 포인터는 Merge 과정 없이 최신 커밋으로 이동한다. A 브랜치에서 다른 B 브랜치를 Merge 할 때 B 브랜치가 A 브랜치 이후의 커밋을 가리키고 있으면 그저 A 브랜치가 B 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐이다. 문제를 해결하고 `master` 브랜치에 적용하고 나면 다시 일하던 브랜치로 돌아가야 한다. 이제 더 이상 필요없는 `hotfix` 브랜치는 삭제한다. ```bash $ git branch -d hotfix Deleted branch hotfix (3a0874c). ``` 4. 다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다. ```bash $ git checkout iss53 Switched to branch \"iss53\" $ vim index.html $ git commit -a -m 'finished the new footer [issue 53]' [iss53 ad82d7a] finished the new footer [issue 53] 1 file changed, 1 insertion(+) ``` Source: https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88\n3-way Merge : 각 브랜치의 커밋 두 개와 공통 조상 하나를 사용하여 병합\n53번 이슈를 다 구현하고 master 브랜치에 Merge를 한다고 가정해보자.\ngit merge 명령으로 합칠 브랜치에서 합쳐질 브랜치를 Merge 하면 된다.\n1 2 3 4 5 6 $ git checkout master Switched to branch 'master' $ git merge iss53 Merge made by the 'recursive' strategy. index.html | 1 + 1 file changed, 1 insertion(+) 현재 브랜치가 가리키는 커밋이 Merge 할 브랜치의 조상이 아니므로 Git은 ‘Fast-forward’로 Merge 하지 않는다.\nhttps://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88\n3-way Merge 의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고 Merge 커밋이라고 부른다.\nhttps://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88\niss53 브랜치를 master에 Merge 하고 나면 더는 iss53 브랜치가 필요 없다. 다음 명령으로 브랜치를 삭제하고 이슈의 상태를 처리 완료로 표시한다.\n1 $ git branch -d iss53 충돌 3-way Merge가 실패할 때가 있다.\nMerge 하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge 하면 Git은 해당 부분을 Merge 하지 못한다. 예를 들어, 53번 이슈와 hotfix 가 같은 부분을 수정했다면 Git은 Merge 하지 못하고 아래와 같은 충돌(Conflict) 메시지를 출력한다.\n1 2 3 4 $ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. Git은 자동으로 Merge 하지 못해서 새 커밋이 생기지 않는다.\n변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다.\nMerge 충돌이 일어났을 때 Git이 어떤 파일을 Merge 할 수 없었는지 살펴보려면 git status 명령을 이용한다.\n1 2 3 4 5 6 7 8 9 10 11 $ git status On branch master You have unmerged paths. (fix conflicts and run \"git commit\") Unmerged paths: (use \"git add …\" to mark resolution) both modified: index.html no changes added to commit (use \"git add\" and/or \"git commit -a\") 충돌이 일어난 파일은 unmerged 상태로 표시된다.\n1 2 3 4 5 6 7 \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD:index.html contact : email.support@github.com ======= please contact us at support@github.com \u003e\u003e\u003e\u003e\u003e\u003e\u003e iss53:index.html ======= 기준으로\n위쪽의 내용은 HEAD 버전(merge 명령을 실행할 때 작업하던 master 브랜치)의 내용\n아래쪽은 iss53 브랜치의 내용\n충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 새로 작성하여 Merge 한다\n그리고 \u003c\u003c\u003c\u003c\u003c\u003c\u003c, =======, \u003e\u003e\u003e\u003e\u003e\u003e\u003e 가 포함된 행을 삭제\nMerge 도구도 충돌을 해결할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ git mergetool This message is displayed because 'merge.tool' is not configured. See 'git mergetool --tool-help' or 'git help config' for more details. 'git mergetool' will now attempt to use one of the following tools: opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge Merging: index.html Normal merge conflict for 'index.html': {local}: modified file {remote}: modified file Hit return to start merge resolution tool (opendiff): 브랜치 관리 브랜치의 목록 1 2 3 4 $ git branch iss53 * master testing * 기호가 붙어 있는 master 브랜치는 현재 Checkout 해서 작업하는 브랜치.\n지금 수정한 내용을 커밋하면 master 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다.\n브랜치마다 마지막 커밋 메시지 확인 각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션\n1 2 3 4 $ git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes Merge한 브랜치 목록 1 2 3 $ git branch --merged iss53 * master iss53 브랜치는 앞에서 이미 Merge 했기 때문에 목록에 나타난다.\n* 기호가 붙어 있지 않은 브랜치는 git branch -d 명령으로 삭제해도 되는 브랜치다.\n이미 다른 브랜치와 Merge 했기 때문에 삭제해도 정보를 잃지 않는다.\n현재 Checkout한 브랜치에 Merge하지 않은 브랜치 목록 1 2 $ git branch --no-merged testing 아직 Merge 하지 않은 커밋을 담고 있기 때문에 git branch -d 명령으로 삭제되지 않는다.\n1 2 3 $ git branch -d testing error: The branch 'testing' is not fully merged. If you are sure you want to delete it, run 'git branch -D testing'. Merge 하지 않은 브랜치를 강제로 삭제하려면 -D 옵션으로 삭제한다.\nRemote 브랜치 리모트 Refs: 원격 저장소에 있는 포인터인 레퍼런스로 원격 저장소에 있는 브랜치, 태그 등등을 의미. 리모트 트래킹 브랜치: 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 레퍼런스이며 브랜치이다. 로컬에 있지만 임의로 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신만 된다. 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다. / 형식으로 원격 저장소 origin 의 master 브랜치를 보고 싶다면 origin/master 라는 이름으로 브랜치를 확인하면 된다. git ls-remote [remote] 명령으로 모든 리모트 Refs를 조회할 수 있다.\ngit remote show [remote] 명령은 모든 리모트 브랜치와 그 정보를 보여준다.\ngit.ourcompany.com 이라는 Git 서버가 있고 이 서버의 저장소를 하나 Clone 하면 Git은 자동으로 origin 이라는 이름을 붙인다. origin 으로부터 저장소 데이터를 모두 내려받고 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/master 라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 master 브랜치가 origin/master 를 가리키게 한다. 이제 이 master 브랜치에서 작업을 시작할 수 있다.\nhttps://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%a6%ac%eb%aa%a8%ed%8a%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98\n로컬 저장소에 작업중 동시에 다른 팀원이 git.ourcompany.com 서버에 push하고 master 브랜치를 업데이트하면 팀원 간의 히스토리는 달라진다.\n로컬과 원격 서버의 커밋 히스토리는 독립적으로 이뤄지며 원격 서버로부터 저장소 정보를 동기화하려면 git fetch origin 명령을 사용한다.\n“origin” 서버의 주소 정보를 찾아서, 현재 로컬 저장소가 갖고 있지 않은 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서, origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.\nhttps://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%a6%ac%eb%aa%a8%ed%8a%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98\n원격 저장소를 여러 개 운영하는 상황을 가정해서 확인해보면,\ngit remote add 명령을 통해 새로운 원격 저장소를 추가한다.\n그리고, git fetch teamone 명령을 실행해도 teamone 서버의 데이터는 모두 origin 서버에도 있는 것들이라서 아무것도 내려받지 않는다.\n리모트 트래킹 브랜치 teamone/master 가 teamone 서버의 master 브랜치가 가리키는 커밋을 가리키게 한다.\n브랜치 추적 리모트 트래킹 브랜치를 로컬 브랜치로 Checkout 하면 자동으로 “트래킹(Tracking) 브랜치” 가 만들어진다 (트래킹 하는 대상 브랜치를 “Upstream 브랜치” 라고 부른다).\n트래킹 브랜치는 리모트 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다.\n트래킹 브랜치에서 git pull 명령을 내리면 리모트 저장소로부터 데이터를 내려받아 연결된 리모트 브랜치와 자동으로 Merge 한다.\n서버로부터 저장소를 Clone을 하면 Git은 자동으로 master 브랜치를 origin/master 브랜치의 트래킹 브랜치로 만든다.\n트래킹 브랜치를 직접 만들 수 있는데 리모트를 origin 이 아닌 다른 리모트로 할 수도 있고, 브랜치도 master 가 아닌 다른 브랜치로 추적하게 할 수 있다.\ngit checkout -b / 명령으로 간단히 트래킹 브랜치를 만들 수 있다.\n--track 옵션을 사용하여 로컬 브랜치 이름을 자동으로 생성할 수 있다.\n1 2 3 $ git checkout --track origin/serverfix Branch serverfix set up to track remote branch serverfix from origin. Switched to a new branch 'serverfix' 이 명령은 매우 자주 쓰여서 더 생략할 수 있다. 입력한 브랜치가 있는 (a) 리모트가 딱 하나 있고 (b) 로컬에는 없으면 Git은 트래킹 브랜치를 만들어 준다.\n1 2 3 $ git checkout serverfix Branch serverfix set up to track remote branch serverfix from origin. Switched to a new branch 'serverfix' 리모트 브랜치와 다른 이름으로 브랜치를 만들려면 로컬 브랜치의 이름을 아래와 같이 다르게 지정한다.\n1 2 3 $ git checkout -b sf origin/serverfix Branch sf set up to track remote branch serverfix from origin. Switched to a new branch 'sf' 이제 sf 브랜치에서 Push 나 Pull 하면 자동으로 origin/serverfix 로 데이터를 보내거나 가져온다.\n로컬 브랜치가 특정 Remote 브랜치를 추적하게 하기 로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 git branch 명령에 -u 나 --set-upstream-to 옵션을 붙여서 아래와 같이 설정한다.\n1 2 $ git branch -u origin/serverfix Branch serverfix set up to track remote branch serverfix from origin. 추적 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 git branch 명령에 -vv 옵션을 더한다.\n이 명령을 실행하면 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함께 보여준다.\n게다가, 로컬 브랜치가 앞서가는지 뒤쳐지는지에 대한 내용도 보여준다.\n1 2 3 4 5 $ git branch -vv iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets master 1ae2a45 [origin/master] deploying index fix * serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it testing 5ea463a trying something new iss53 브랜치: origin/iss53 리모트 브랜치를 추적 “ahead” 표시를 통해 로컬 브랜치가 커밋 2개 앞서 있다(리모트 브랜치에는 없는 커밋이 로컬에는 존재) master 브랜치: origin/master 브랜치를 추적 두 브랜치가 가리키는 커밋 내용이 같은 상태. serverfix 브랜치: server-fix-good 이라는 teamone 리모트 서버의 브랜치를 추적 커밋 3개 앞서 있으며 동시에 커밋 1개로 뒤쳐져 있다. serverfix 브랜치에 서버로 보내지 않은 커밋이 3개, 서버의 브랜치에서 아직 로컬 브랜치로 머지하지 않은 커밋이 1개 있다 testing 브랜치: 추적하는 브랜치가 없는 상태. 여기서 중요한 점은 명령을 실행했을 때 나타나는 결과는 모두 마지막으로 서버에서 데이터를 가져온(fetch) 시점을 바탕으로 계산한다.\n서버의 최신 데이터를 반영하지는 않으며 로컬에 저장된 서버의 캐시 데이터를 사용한다.\n현재 시점에서 진짜 최신 데이터로 추적 상황을 알아보려면 먼저 서버로부터 최신 데이터를 받아온 후에 추적 상황을 확인해야 한다.\n1 $ git fetch --all; git branch -vv 원격 브랜치 삭제 git push 명령에 --delete 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다.\nserverfix 라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.\n1 2 3 $ git push origin --delete serverfix To https://github.com/schacon/simplegit - [deleted] serverfix 위 명령을 실행하면 서버에서 브랜치(즉 커밋을 가리키는 포인터) 하나가 사라진다.\n서버에서 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기 때문에 종종 의도치 않게 삭제한 경우에도 커밋한 데이터를 살릴 수 있다.\n참고 및 출처 Git Git\n시작하기 - Git 기초\nGit 시작하기 - 최초 설정\nGit Submodule\nGit Submodule 사용하기\nGit 200% 활용하기\nGit / GitHub 안내서 핵심만 제대로 배우기\ngit 충돌 해결..어떤 시각적 비교 도구 쓰시나요?\nGit 워크플로 향상하는 15가지 팁\nGit 형상관리 잘하는 법\nGN⁺: .git 디렉토리안에는 무엇이 있을까?\n좋은 git commit 메시지를 위한 영어 사전\nGit / GitHub 안내서 핵심만 제대로 배우기\nGit 기본 정복 실전 연습 – 1편 : 정의와 개념\nGit 기본 정복 실전 연습 – 2편 : 기본명령어\nGit 실전 연습 1편 + 2편 개봉!\n","wordCount":"2971","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2024-09-20T07:28:00Z","dateModified":"2024-09-20T07:28:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C%EC%99%80-branch/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>posts</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/>Software Development and Maintenance</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/>DevOps</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/>CI/CD</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/>Git 기본 사용법</a></div><h1 class="post-title entry-hint-parent">Git 원격 저장소와 Branch</h1><div class=post-description>소프트웨어 개발에서 널리 사용되는 분산 버전 관리 시스템으로, 코드의 변경 이력을 효율적으로 관리하고 협업을 지원한다.</div><div class=post-meta><span title='2024-09-20 07:28:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2971 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Software%20Development%20and%20Maintenance/DevOps/CI%20and%20CD/Git/Git-%ec%9b%90%ea%b2%a9-%ec%a0%80%ec%9e%a5%ec%86%8c%ec%99%80-Branch.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#git의-원격-저장소와-branch>Git의 원격 저장소와 Branch</a><ul><li><a href=#원격-저장소와-협업>원격 저장소와 협업</a></li><li><a href=#branch>Branch</a></li></ul></li><li><a href=#참고-및-출처>참고 및 출처</a><ul><li><a href=#git>Git</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=git의-원격-저장소와-branch>Git의 원격 저장소와 Branch<a hidden class=anchor aria-hidden=true href=#git의-원격-저장소와-branch>#</a></h2><h3 id=원격-저장소와-협업>원격 저장소와 협업<a hidden class=anchor aria-hidden=true href=#원격-저장소와-협업>#</a></h3><h4 id=원격-저장소-기본-명령어>원격 저장소 기본 명령어<a hidden class=anchor aria-hidden=true href=#원격-저장소-기본-명령어>#</a></h4><table><thead><tr><th>명령어</th><th>설명</th><th>사용 예시</th></tr></thead><tbody><tr><td>git remote</td><td>원격 저장소 목록 조회</td><td><code>git remote</code></td></tr><tr><td>git remote -v</td><td>상세 정보(URL) 조회</td><td><code>git remote -v</code></td></tr><tr><td>git remote add</td><td>원격 저장소 추가</td><td><code>git remote add origin &lt;url></code></td></tr><tr><td>git remote rename</td><td>원격 저장소 이름 변경</td><td><code>git remote rename old new</code></td></tr><tr><td>git remote remove</td><td>원격 저장소 삭제</td><td><code>git remote remove name</code></td></tr></tbody></table><h5 id=원격-저장소-목록-조회>원격 저장소 목록 조회<a hidden class=anchor aria-hidden=true href=#원격-저장소-목록-조회>#</a></h5><p><code>git remote</code> 명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git remote
</span></span><span class=line><span class=cl>origin
</span></span></code></pre></td></tr></table></div></div><h5 id=원격-저장소-url-조회>원격 저장소 URL 조회<a hidden class=anchor aria-hidden=true href=#원격-저장소-url-조회>#</a></h5><p>리모트 저장소가 여러 개 있다면 이 명령은 등록된 전부를 보여준다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git remote -v
</span></span><span class=line><span class=cl>origin	https://github.com/schacon/ticgit <span class=o>(</span>fetch<span class=o>)</span>
</span></span><span class=line><span class=cl>origin	https://github.com/schacon/ticgit <span class=o>(</span>push<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=원격-저장소-추가하기>원격 저장소 추가하기<a hidden class=anchor aria-hidden=true href=#원격-저장소-추가하기>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2>2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3>3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4>4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5>5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git remote add pb https://github.com/paulboone/ticgit
</span></span><span class=line><span class=cl>$ git remote -v
</span></span><span class=line><span class=cl>origin	https://github.com/schacon/ticgit <span class=o>(</span>fetch<span class=o>)</span>
</span></span><span class=line><span class=cl>origin	https://github.com/schacon/ticgit <span class=o>(</span>push<span class=o>)</span>
</span></span><span class=line><span class=cl>pb	https://github.com/paulboone/ticgit <span class=o>(</span>fetch<span class=o>)</span>
</span></span><span class=line><span class=cl>pb	https://github.com/paulboone/ticgit <span class=o>(</span>push<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=원격-저장소-이름을-바꾸기>원격 저장소 이름을 바꾸기<a hidden class=anchor aria-hidden=true href=#원격-저장소-이름을-바꾸기>#</a></h5><p> ```bash<br>$ git remote rename pb paul<br>$ git remote<br>origin<br>paul</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span><span class=lnt id=hl-3-3><a class=lnlinks href=#hl-3-3>3</a>
</span><span class=lnt id=hl-3-4><a class=lnlinks href=#hl-3-4>4</a>
</span><span class=lnt id=hl-3-5><a class=lnlinks href=#hl-3-5>5</a>
</span><span class=lnt id=hl-3-6><a class=lnlinks href=#hl-3-6>6</a>
</span><span class=lnt id=hl-3-7><a class=lnlinks href=#hl-3-7>7</a>
</span><span class=lnt id=hl-3-8><a class=lnlinks href=#hl-3-8>8</a>
</span><span class=lnt id=hl-3-9><a class=lnlinks href=#hl-3-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl>##### 원격 저장소 삭제하기
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> 원격 저장소를 삭제하면 해당 원격 저장소에 관련된 추적 브랜치 정보나 모든 설정 내용도 함께 삭제된다.
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>```bash
</span></span><span class=line><span class=cl>$ git remote remove paul
</span></span><span class=line><span class=cl>$ git remote
</span></span><span class=line><span class=cl>origin
</span></span></code></pre></td></tr></table></div></div><h4 id=원격-저장소에서-데이터-가져오기>원격 저장소에서 데이터 가져오기<a hidden class=anchor aria-hidden=true href=#원격-저장소에서-데이터-가져오기>#</a></h4><p>데이터 가져오기: <code>git fetch &lt;remote></code></p><ul><li><code>git fetch</code> 명령을 실행하면 서버에는 존재하지만, 로컬에는 아직 없는 데이터를 받아와서 저장한다.<ul><li>이 때 워킹 디렉토리의 파일 내용은 변경되지 않고 그대로 남는다.</li><li>서버로부터 데이터를 가져와서 저장해두고 사용자가 Merge 하도록 준비만 해둔다.<br>데이터 가져오기 및 병합: <code>git pull &lt;remote> &lt;branch></code><br><code>git fetch</code> 명령을 실행하고 나서 자동으로 <code>git merge</code> 명령을 수행<br>추적 브랜치가 설정되면 <code>git pull</code> 명령은 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 추적 브랜치를 Merge 한다.</li></ul></li></ul><p>일반적으로 <code>fetch</code> 와 <code>merge</code> 명령을 명시적으로 사용하는 것이 <code>pull</code> 명령으로 한번에 두 작업을 하는 것보다 낫다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span><span class=lnt id=hl-4-8><a class=lnlinks href=#hl-4-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 원격 데이터 가져오기만 (병합 없음)</span>
</span></span><span class=line><span class=cl>$ git fetch origin
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 가져오기 + 자동 병합</span>
</span></span><span class=line><span class=cl>$ git pull origin master
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 특정 브랜치만 가져오기</span>
</span></span><span class=line><span class=cl>$ git fetch origin branch-name
</span></span></code></pre></td></tr></table></div></div><h4 id=원격-저장소에-데이터-내보내기>원격 저장소에 데이터 내보내기<a hidden class=anchor aria-hidden=true href=#원격-저장소에-데이터-내보내기>#</a></h4><p>로컬 브랜치에서 작업한 내용을 서버로 전송하려면 원격 서버에 Push해야 한다.<br>명시적으로 브랜치를 정해서 Push해야 정보가 전송된다.</p><p> <code>git push &lt;리모트 저장소 이름> &lt;브랜치 이름></code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 기본 푸시</span>
</span></span><span class=line><span class=cl>$ git push origin master
</span></span><span class=line><span class=cl>$ git push origin serverfix
</span></span><span class=line><span class=cl>Counting objects: 24, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Delta compression using up to <span class=m>8</span> threads.
</span></span><span class=line><span class=cl>Compressing objects: 100% <span class=o>(</span>15/15<span class=o>)</span>, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Writing objects: 100% <span class=o>(</span>24/24<span class=o>)</span>, 1.91 KiB <span class=p>|</span> <span class=m>0</span> bytes/s, <span class=k>done</span>.
</span></span><span class=line><span class=cl>Total <span class=m>24</span> <span class=o>(</span>delta 2<span class=o>)</span>, reused <span class=m>0</span> <span class=o>(</span>delta 0<span class=o>)</span>
</span></span><span class=line><span class=cl>To https://github.com/schacon/simplegit
</span></span><span class=line><span class=cl> * <span class=o>[</span>new branch<span class=o>]</span>      serverfix -&gt; serverfix
</span></span><span class=line><span class=cl><span class=c1># 새 브랜치 푸시</span>
</span></span><span class=line><span class=cl>$ git push -u origin new-branch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 강제 푸시 (주의 필요)</span>
</span></span><span class=line><span class=cl>$ git push -f origin master
</span></span></code></pre></td></tr></table></div></div><h4 id=원격-저장소-상세-정보-확인>원격 저장소 상세 정보 확인<a hidden class=anchor aria-hidden=true href=#원격-저장소-상세-정보-확인>#</a></h4><p><code>git remote show &lt;리모트 저장소 이름></code></p><table><thead><tr><th>명령어</th><th>보여주는 정보</th><th>용도</th></tr></thead><tbody><tr><td><code>git remote show origin</code></td><td>- 원격 URL<br>- 브랜치 정보<br>- 추적 관계</td><td>저장소 구성 확인</td></tr></tbody></table><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git remote show origin
</span></span><span class=line><span class=cl>* remote origin
</span></span><span class=line><span class=cl>  Fetch URL: https://github.com/schacon/ticgit
</span></span><span class=line><span class=cl>  Push  URL: https://github.com/schacon/ticgit
</span></span><span class=line><span class=cl>  HEAD branch: master
</span></span><span class=line><span class=cl>  Remote branches:
</span></span><span class=line><span class=cl>    master                               tracked
</span></span><span class=line><span class=cl>    dev-branch                           tracked
</span></span><span class=line><span class=cl>  Local branch configured <span class=k>for</span> <span class=s1>&#39;git pull&#39;</span>:
</span></span><span class=line><span class=cl>    master merges with remote master
</span></span><span class=line><span class=cl>  Local ref configured <span class=k>for</span> <span class=s1>&#39;git push&#39;</span>:
</span></span><span class=line><span class=cl>    master pushes to master <span class=o>(</span>up to date<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=협업-워크플로우>협업 워크플로우<a hidden class=anchor aria-hidden=true href=#협업-워크플로우>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 1. 원격 저장소 복제</span>
</span></span><span class=line><span class=cl>$ git clone &lt;url&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 2. 브랜치 생성 및 작업</span>
</span></span><span class=line><span class=cl>$ git checkout -b feature-branch
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 3. 변경사항 커밋</span>
</span></span><span class=line><span class=cl>$ git add .
</span></span><span class=line><span class=cl>$ git commit -m <span class=s2>&#34;Add feature&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 4. 원격 저장소 최신화</span>
</span></span><span class=line><span class=cl>$ git fetch origin
</span></span><span class=line><span class=cl>$ git rebase origin/master
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 5. 변경사항 푸시</span>
</span></span><span class=line><span class=cl>$ git push origin feature-branch
</span></span></code></pre></td></tr></table></div></div><h4 id=주요-협업-시나리오>주요 협업 시나리오<a hidden class=anchor aria-hidden=true href=#주요-협업-시나리오>#</a></h4><table><thead><tr><th>시나리오</th><th>명령어 sequence</th><th>설명</th></tr></thead><tbody><tr><td>코드 리뷰</td><td>1. <code>git push</code><br>2. Pull Request 생성<br>3. 리뷰 및 토론<br>4. 변경사항 반영</td><td>팀 협업시 코드 품질 관리</td></tr><tr><td>충돌 해결</td><td>1. <code>git pull</code><br>2. 충돌 해결<br>3. <code>git add</code><br>4. <code>git commit</code><br>5. <code>git push</code></td><td>동시 수정으로 인한 충돌 처리</td></tr></tbody></table><h4 id=모범-사례와-주의사항>모범 사례와 주의사항<a hidden class=anchor aria-hidden=true href=#모범-사례와-주의사항>#</a></h4><table><thead><tr><th>영역</th><th>권장사항</th><th>주의사항</th></tr></thead><tbody><tr><td>푸시 전</td><td>fetch/pull로 최신화<br>- 로컬 테스트 수행</td><td>- 강제 푸시 주의<br>- 대용량 파일 확인</td></tr><tr><td>브랜치 관리</td><td>- 기능별 브랜치 사용<br>- 정기적인 동기화</td><td>- 오래된 브랜치 정리<br>- 명확한 이름 사용</td></tr><tr><td>충돌 관리</td><td>- 작은 단위로 커밋<br>- 정기적인 동기화</td><td>- 충돌 해결 시 신중<br>- 팀과 소통</td></tr></tbody></table><h3 id=branch>Branch<a hidden class=anchor aria-hidden=true href=#branch>#</a></h3><h4 id=브랜치의-기본-개념과-내부-구조>브랜치의 기본 개념과 내부 구조<a hidden class=anchor aria-hidden=true href=#브랜치의-기본-개념과-내부-구조>#</a></h4><table><thead><tr><th>구성 요소</th><th>설명</th><th>특징</th></tr></thead><tbody><tr><td>커밋 객체</td><td>- 파일의 스냅샷<br>- 메타데이터<br>- 이전 커밋 포인터</td><td>변경 이력 추적의 기본 단위</td></tr><tr><td>브랜치 포인터</td><td>- 특정 커밋을 가리키는 포인터<br>- 최신 커밋을 추적</td><td>가볍고 빠른 전환 가능</td></tr><tr><td>HEAD</td><td>- 현재 작업 중인 브랜치를 가리킴<br>- 워킹 디렉토리의 기준</td><td>브랜치 전환의 기준점</td></tr></tbody></table><h4 id=브랜치-작업-흐름>브랜치 작업 흐름<a hidden class=anchor aria-hidden=true href=#브랜치-작업-흐름>#</a></h4><table><thead><tr><th>단계</th><th>명령어</th><th>설명</th></tr></thead><tbody><tr><td>브랜치 생성</td><td><code>git branch &lt;name></code></td><td>새 브랜치 생성</td></tr><tr><td>브랜치 전환</td><td><code>git checkout &lt;name></code></td><td>작업 브랜치 변경</td></tr><tr><td>생성과 전환</td><td><code>git checkout -b &lt;name></code></td><td>생성과 전환을 동시에</td></tr><tr><td>변경사항 커밋</td><td><code>git commit -m "message"</code></td><td>브랜치에 변경사항 저장</td></tr><tr><td>브랜치 병합</td><td><code>git merge &lt;branch></code></td><td>다른 브랜치 내용 통합</td></tr></tbody></table><h5 id=branch-생성>Branch 생성<a hidden class=anchor aria-hidden=true href=#branch-생성>#</a></h5><p>새로 만든 브랜치는 지금 작업하고 있던 마지막 커밋을 가리킨다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git branch testing
</span></span></code></pre></td></tr></table></div></div><p><figure><img alt="현재 작업 중인 브랜치를 가리키는 HEAD" loading=lazy src=/img/head-to-master.png><figcaption>Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</figcaption></figure></p><ul><li>파일이 3개 있는 디렉토리가 하나 있고 이 파일을 Staging Area에 저장하고 커밋하는 예제<br><code>git commit</code>으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git add README test.rb LICENSE  
</span></span><span class=line><span class=cl>$ git commit -m <span class=s1>&#39;The initial commit of my project&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>그 다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다.<br>Git 저장소에는 다섯 개의 데이터 개체가 생긴다.</p><ul><li>각 파일에 대한 Blob 세 개</li><li>파일과 디렉토리 구조가 들어 있는 트리 개체 하나</li><li>메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 개체 하나.<br>![커밋과 트리 데이터](commit-and-tree.png &ldquo;<a href=https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80>https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</a> _</li></ul><p>파일을 수정하고 커밋하면 이전 커밋이 무엇인지도 저장한다.</p><p><figure><img alt="커밋과 이전 커밋" loading=lazy src=/img/commits-and-parents.png><figcaption>https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</figcaption></figure></p><h5 id=branch-전환하기>Branch 전환하기<a hidden class=anchor aria-hidden=true href=#branch-전환하기>#</a></h5><p><code>git checkout</code> 명령으로 다른 브랜치로 이동할 수 있다<br>HEAD는 testing 브랜치를 가리킨다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout testing
</span></span></code></pre></td></tr></table></div></div><p><figure><img alt="HEAD는 testijng 브랜치를 가리킴" loading=lazy src=/img/head-to-testing.png><figcaption>Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</figcaption></figure></p><p>브랜치를 만들면서 Checkout까지 한 번에 하려면 <code>git checkout</code> 명령에 <code>-b</code> 라는 옵션을 추가한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b testing
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s2>&#34;testing&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=변경사항-커밋>변경사항 커밋<a hidden class=anchor aria-hidden=true href=#변경사항-커밋>#</a></h5><p>파일을 수정하고 새롭게 커밋을 하면,</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ vim test.rb
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s1>&#39;made a change&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><figure><img alt="HEAD가 가리키는 testing 브랜치가 새 커밋을 가리킴" loading=lazy src=/img/advance-testing.png><figcaption>Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</figcaption></figure></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout master
</span></span></code></pre></td></tr></table></div></div><p>다시, master 브랜치로 되돌아가서,<br><figure><img alt="HEAD가 Checkout한 브랜치로 이동함" loading=lazy src=/img/checkout-master.png><figcaption>Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</figcaption></figure></p><p>파일을 수정하고, 다시 커밋을 하면,</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ vim test.rb
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s1>&#39;made other changes&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p><figure><img alt="갈라지는 브랜치" loading=lazy src=/img/advance-master.png><figcaption>Source: https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%b8%8c%eb%9e%9c%ec%b9%98%eb%9e%80-%eb%ac%b4%ec%97%87%ec%9d%b8%ea%b0%80</figcaption></figure></p><p>두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다.</p><p><code>git log</code> 명령으로 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지 확인할 수 있다.<br><code>git log --oneline --decorate --graph --all</code> 이라고 실행하면 히스토리를 출력한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5>5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6>6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git log --oneline --decorate --graph --all
</span></span><span class=line><span class=cl>* c2b9e <span class=o>(</span>HEAD, master<span class=o>)</span> made other changes
</span></span><span class=line><span class=cl><span class=p>|</span> * 87ab2 <span class=o>(</span>testing<span class=o>)</span> made a change
</span></span><span class=line><span class=cl><span class=p>|</span>/
</span></span><span class=line><span class=cl>* f30ab add feature <span class=c1>#32 - ability to add new formats to the</span>
</span></span><span class=line><span class=cl>* 34ac2 fixed bug <span class=c1>#1328 - stack overflow under certain conditions</span>
</span></span><span class=line><span class=cl>* 98ca9 initial commit of my project
</span></span></code></pre></td></tr></table></div></div><h5 id=브랜치-병합하기>브랜치 병합하기<a hidden class=anchor aria-hidden=true href=#브랜치-병합하기>#</a></h5><h6 id=fast-forward-merge>Fast-forward Merge<a hidden class=anchor aria-hidden=true href=#fast-forward-merge>#</a></h6><p>: 브랜치가 가리키는 커밋이 현재 브랜치 이후의 커밋인 경우<br>브랜치와 Merge의 기본적인 진행 전략은</p><ol><li><p>웹사이트가 있고 작업을 진행중임.</p></li><li><p>새로운 이슈를 처리할 새 Branch를 하나 생성함.<br>새로운 이슈를 위한 브랜치 이름은 iss53이라고 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4>4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> $ git checkout -b iss53
</span></span><span class=line><span class=cl> Switched to a new branch <span class=s2>&#34;iss53&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> $ git branch iss53
</span></span><span class=line><span class=cl> $ git checkout iss53
</span></span></code></pre></td></tr></table></div></div></li></ol><p><figure><img alt="브랜치 포인터를 새로 만듦" loading=lazy src=/img/basic-branching-2.png><figcaption>https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88</figcaption></figure></p><ol start=3><li><p>새로 만든 Branch에서 작업을 진행함.<br><code>iss53</code> 브랜치를 Checkout 했기 때문에(즉, <code>HEAD</code> 는 <code>iss53</code> 브랜치를 가리킨다) 작업을 하고 커밋을 하면 <code>iss53</code> 브랜치가 앞으로 나아간다.<br><figure><img alt="진행 중인\u00a0<code>iss53</code>\u00a0브랜치" loading=lazy src=/img/basic-branching-3.png><figcaption>https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88</figcaption></figure></p><p>이 상황에서 문제를 해결해야할 상황이 생겨 Hotfix를 해야할 상황이라고 가정해보자.</p><ol><li><p>새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;master&#39;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Hotfix 브랜치를 새로 하나 생성한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b hotfix
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s1>&#39;hotfix&#39;</span>
</span></span><span class=line><span class=cl>$ vim index.html
</span></span><span class=line><span class=cl>$ git commit -a -m <span class=s1>&#39;fixed the broken email address&#39;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>hotfix 1fb7853<span class=o>]</span> fixed the broken email address
</span></span><span class=line><span class=cl> <span class=m>1</span> file changed, <span class=m>2</span> insertions<span class=o>(</span>+<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol></li></ol><p><figure><img alt="master 브랜치에서 갈라져 나온 hotfix 브랜치" loading=lazy src=/img/basic-branching-4.png><figcaption>https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88</figcaption></figure></p><pre><code>3. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge한다.  
	```bash
	$ git checkout master
	$ git merge hotfix
	Updating f42c576.a0874c
	Fast-forward
	 index.html | 2 ++
	 1 file changed, 2 insertions(+)
	```
	
	Merge 메시지에서 &quot;Fast-forward&quot;  
	`hotfix` 브랜치가 가리키는 `C4` 커밋이 `C2` 커밋에 기반한 브랜치이기 때문에 브랜치 포인터는 Merge 과정 없이 최신 커밋으로 이동한다.  
	A 브랜치에서 다른 B 브랜치를 Merge 할 때 B 브랜치가 A 브랜치 이후의 커밋을 가리키고 있으면 그저 A 브랜치가 B 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐이다.
</code></pre><p><figure><img alt="Merge후 hotfix와 같은 것을 가리키는 master 브랜치" loading=lazy src=/img/basic-branching-5.png></figure></p><pre><code>	문제를 해결하고  `master` 브랜치에 적용하고 나면 다시 일하던 브랜치로 돌아가야 한다. 이제 더 이상 필요없는 `hotfix` 브랜치는 삭제한다.
	
	```bash
	$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).
	```

4. 다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다.
   
	```bash
	$ git checkout iss53
	Switched to branch &quot;iss53&quot;
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53 ad82d7a] finished the new footer [issue 53]
	1 file changed, 1 insertion(+)
	```
</code></pre><p><figure><img alt="master와 별개로 진행하는 iss53 브랜치" loading=lazy src=/img/basic-branching-6.png><figcaption>Source: https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88</figcaption></figure></p><h6 id=3-way-merge>3-way Merge<a hidden class=anchor aria-hidden=true href=#3-way-merge>#</a></h6><p>: 각 브랜치의 커밋 두 개와 공통 조상 하나를 사용하여 병합<br>53번 이슈를 다 구현하고 master 브랜치에 Merge를 한다고 가정해보자.<br><code>git merge</code> 명령으로 합칠 브랜치에서 합쳐질 브랜치를 Merge 하면 된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4>4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5>5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl>Switched to branch <span class=s1>&#39;master&#39;</span>
</span></span><span class=line><span class=cl>$ git merge iss53
</span></span><span class=line><span class=cl>Merge made by the <span class=s1>&#39;recursive&#39;</span> strategy.
</span></span><span class=line><span class=cl>index.html <span class=p>|</span>    <span class=m>1</span> +
</span></span><span class=line><span class=cl><span class=m>1</span> file changed, <span class=m>1</span> insertion<span class=o>(</span>+<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>현재 브랜치가 가리키는 커밋이 Merge 할 브랜치의 조상이 아니므로 Git은 &lsquo;Fast-forward&rsquo;로 Merge 하지 않는다.<br><figure><img alt="커밋 3개를 Merge" loading=lazy src=/img/basic-merging-1.png><figcaption>https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88</figcaption></figure></p><p>3-way Merge 의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고 Merge 커밋이라고 부른다.<br><figure><img alt="Merge 커밋" loading=lazy src=/img/basic-merging-2.png><figcaption>https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88</figcaption></figure></p><p>iss53 브랜치를 master에 Merge 하고 나면 더는 iss53 브랜치가 필요 없다. 다음 명령으로 브랜치를 삭제하고 이슈의 상태를 처리 완료로 표시한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -d iss53
</span></span></code></pre></td></tr></table></div></div><h6 id=충돌>충돌<a hidden class=anchor aria-hidden=true href=#충돌>#</a></h6><p>3-way Merge가 실패할 때가 있다.<br>Merge 하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge 하면 Git은 해당 부분을 Merge 하지 못한다. 예를 들어, 53번 이슈와 <code>hotfix</code> 가 같은 부분을 수정했다면 Git은 Merge 하지 못하고 아래와 같은 충돌(Conflict) 메시지를 출력한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git merge iss53
</span></span><span class=line><span class=cl>Auto-merging index.html
</span></span><span class=line><span class=cl>CONFLICT <span class=o>(</span>content<span class=o>)</span>: Merge conflict in index.html
</span></span><span class=line><span class=cl>Automatic merge failed<span class=p>;</span> fix conflicts and <span class=k>then</span> commit the result.
</span></span></code></pre></td></tr></table></div></div><p>Git은 자동으로 Merge 하지 못해서 새 커밋이 생기지 않는다.<br>변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다.<br>Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge 할 수 없었는지 살펴보려면 <code>git status</code> 명령을 이용한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>You have unmerged paths.
</span></span><span class=line><span class=cl>  <span class=o>(</span>fix conflicts and run <span class=s2>&#34;git commit&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Unmerged paths:
</span></span><span class=line><span class=cl>  <span class=o>(</span>use <span class=s2>&#34;git add &lt;file&gt;…&#34;</span> to mark resolution<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    both modified:      index.html
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>no changes added to commit <span class=o>(</span>use <span class=s2>&#34;git add&#34;</span> and/or <span class=s2>&#34;git commit -a&#34;</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>충돌이 일어난 파일은 unmerged 상태로 표시된다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4>4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5>5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6>6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
</span></span><span class=line><span class=cl>&lt;div id=&#34;footer&#34;&gt;contact : email.support@github.com&lt;/div&gt;
</span></span><span class=line><span class=cl>=======
</span></span><span class=line><span class=cl>&lt;div id=&#34;footer&#34;&gt;
</span></span><span class=line><span class=cl> please contact us at support@github.com
</span></span><span class=line><span class=cl>&lt;/div&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html
</span></span></code></pre></td></tr></table></div></div><p><code>=======</code> 기준으로<br>위쪽의 내용은 <code>HEAD</code> 버전(merge 명령을 실행할 때 작업하던 <code>master</code> 브랜치)의 내용<br>아래쪽은 <code>iss53</code> 브랜치의 내용<br>충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 새로 작성하여 Merge 한다<br>그리고 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>>>>>>>></code> 가 포함된 행을 삭제</p><p>Merge 도구도 충돌을 해결할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1> 1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2> 2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3> 3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4> 4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5> 5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6> 6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7> 7</a>
</span><span class=lnt id=hl-24-8><a class=lnlinks href=#hl-24-8> 8</a>
</span><span class=lnt id=hl-24-9><a class=lnlinks href=#hl-24-9> 9</a>
</span><span class=lnt id=hl-24-10><a class=lnlinks href=#hl-24-10>10</a>
</span><span class=lnt id=hl-24-11><a class=lnlinks href=#hl-24-11>11</a>
</span><span class=lnt id=hl-24-12><a class=lnlinks href=#hl-24-12>12</a>
</span><span class=lnt id=hl-24-13><a class=lnlinks href=#hl-24-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git mergetool
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>This message is displayed because <span class=s1>&#39;merge.tool&#39;</span> is not configured.
</span></span><span class=line><span class=cl>See <span class=s1>&#39;git mergetool --tool-help&#39;</span> or <span class=s1>&#39;git help config&#39;</span> <span class=k>for</span> more details.
</span></span><span class=line><span class=cl><span class=s1>&#39;git mergetool&#39;</span> will now attempt to use one of the following tools:
</span></span><span class=line><span class=cl>opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
</span></span><span class=line><span class=cl>Merging:
</span></span><span class=line><span class=cl>index.html
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Normal merge conflict <span class=k>for</span> <span class=s1>&#39;index.html&#39;</span>:
</span></span><span class=line><span class=cl>  <span class=o>{</span>local<span class=o>}</span>: modified file
</span></span><span class=line><span class=cl>  <span class=o>{</span>remote<span class=o>}</span>: modified file
</span></span><span class=line><span class=cl>Hit <span class=k>return</span> to start merge resolution tool <span class=o>(</span>opendiff<span class=o>)</span>:
</span></span></code></pre></td></tr></table></div></div><h4 id=브랜치-관리>브랜치 관리<a hidden class=anchor aria-hidden=true href=#브랜치-관리>#</a></h4><h5 id=브랜치의-목록>브랜치의 목록<a hidden class=anchor aria-hidden=true href=#브랜치의-목록>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span><span class=lnt id=hl-25-3><a class=lnlinks href=#hl-25-3>3</a>
</span><span class=lnt id=hl-25-4><a class=lnlinks href=#hl-25-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch
</span></span><span class=line><span class=cl>  iss53
</span></span><span class=line><span class=cl>* master
</span></span><span class=line><span class=cl>  testing
</span></span></code></pre></td></tr></table></div></div><p><code>*</code> 기호가 붙어 있는 <code>master</code> 브랜치는 현재 Checkout 해서 작업하는 브랜치.<br>지금 수정한 내용을 커밋하면 <code>master</code> 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다.</p><h5 id=브랜치마다-마지막-커밋-메시지-확인>브랜치마다 마지막 커밋 메시지 확인<a hidden class=anchor aria-hidden=true href=#브랜치마다-마지막-커밋-메시지-확인>#</a></h5><p>각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -v
</span></span><span class=line><span class=cl>  iss53   93b412c fix javascript issue
</span></span><span class=line><span class=cl>* master  7a98805 Merge branch <span class=s1>&#39;iss53&#39;</span>
</span></span><span class=line><span class=cl>  testing 782fd34 add scott to the author list in the readmes
</span></span></code></pre></td></tr></table></div></div><h5 id=merge한-브랜치-목록>Merge한 브랜치 목록<a hidden class=anchor aria-hidden=true href=#merge한-브랜치-목록>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2>2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch --merged
</span></span><span class=line><span class=cl>  iss53
</span></span><span class=line><span class=cl>* master
</span></span></code></pre></td></tr></table></div></div><p><code>iss53</code> 브랜치는 앞에서 이미 Merge 했기 때문에 목록에 나타난다.<br><code>*</code> 기호가 붙어 있지 않은 브랜치는 <code>git branch -d</code> 명령으로 삭제해도 되는 브랜치다.<br>이미 다른 브랜치와 Merge 했기 때문에 삭제해도 정보를 잃지 않는다.</p><h5 id=현재-checkout한-브랜치에-merge하지-않은-브랜치-목록>현재 Checkout한 브랜치에 Merge하지 않은 브랜치 목록<a hidden class=anchor aria-hidden=true href=#현재-checkout한-브랜치에-merge하지-않은-브랜치-목록>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch --no-merged
</span></span><span class=line><span class=cl>  testing
</span></span></code></pre></td></tr></table></div></div><p>아직 Merge 하지 않은 커밋을 담고 있기 때문에 <code>git branch -d</code> 명령으로 삭제되지 않는다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1>1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2>2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -d testing
</span></span><span class=line><span class=cl>error: The branch <span class=s1>&#39;testing&#39;</span> is not fully merged.
</span></span><span class=line><span class=cl>If you are sure you want to delete it, run <span class=s1>&#39;git branch -D testing&#39;</span>.
</span></span></code></pre></td></tr></table></div></div><p>Merge 하지 않은 브랜치를 강제로 삭제하려면 <code>-D</code> 옵션으로 삭제한다.</p><h4 id=remote-브랜치>Remote 브랜치<a hidden class=anchor aria-hidden=true href=#remote-브랜치>#</a></h4><ul><li><strong>리모트 Refs</strong>: 원격 저장소에 있는 포인터인 레퍼런스로 원격 저장소에 있는 브랜치, 태그 등등을 의미.</li><li><strong>리모트 트래킹 브랜치</strong>: 리모트 트래킹 브랜치는 리모트 브랜치를 추적하는 레퍼런스이며 브랜치이다.<ul><li>로컬에 있지만 임의로 움직일 수 없다.</li><li>리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신만 된다.</li><li>리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있었는지를 나타낸다.</li><li><code>&lt;remote>/&lt;branch></code> 형식으로 원격 저장소 <code>origin</code> 의 <code>master</code> 브랜치를 보고 싶다면 <code>origin/master</code> 라는 이름으로 브랜치를 확인하면 된다.</li></ul></li></ul><p><code>git ls-remote [remote]</code> 명령으로 모든 리모트 Refs를 조회할 수 있다.<br><code>git remote show [remote]</code> 명령은 모든 리모트 브랜치와 그 정보를 보여준다.</p><p> <code>git.ourcompany.com</code> 이라는 Git 서버가 있고 이 서버의 저장소를 하나 Clone 하면 Git은 자동으로 <code>origin</code> 이라는 이름을 붙인다. <code>origin</code> 으로부터 저장소 데이터를 모두 내려받고 <code>master</code> 브랜치를 가리키는 포인터를 만든다. 이 포인터는 <code>origin/master</code> 라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 <code>master</code> 브랜치가 <code>origin/master</code> 를 가리키게 한다. 이제 이 <code>master</code> 브랜치에서 작업을 시작할 수 있다.</p><p><figure><img alt="Clone 이후 서버와 로컬의 master 브랜치" loading=lazy src=/img/remote-branches-1.png><figcaption>https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%a6%ac%eb%aa%a8%ed%8a%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98</figcaption></figure></p><p>로컬 저장소에 작업중 동시에 다른 팀원이 <code>git.ourcompany.com</code> 서버에 push하고 <code>master</code> 브랜치를 업데이트하면 팀원 간의 히스토리는 달라진다.<br>로컬과 원격 서버의 커밋 히스토리는 독립적으로 이뤄지며 원격 서버로부터 저장소 정보를 동기화하려면 <code>git fetch origin</code> 명령을 사용한다.<br>&ldquo;origin&rdquo; 서버의 주소 정보를 찾아서, 현재 로컬 저장소가 갖고 있지 않은 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서, <code>origin/master</code> 포인터의 위치를 최신 커밋으로 이동시킨다.</p><p><figure><img alt="<code>git fetch</code> 명령은 리모트 브랜치 정보를 업데이트" loading=lazy src=/img/remote-branches-3.png><figcaption>https://git-scm.com/book/ko/v2/Git-%eb%b8%8c%eb%9e%9c%ec%b9%98-%eb%a6%ac%eb%aa%a8%ed%8a%b8-%eb%b8%8c%eb%9e%9c%ec%b9%98</figcaption></figure></p><p>원격 저장소를 여러 개 운영하는 상황을 가정해서 확인해보면,<br><code>git remote add</code> 명령을 통해 새로운 원격 저장소를 추가한다.<br>그리고, <code>git fetch teamone</code> 명령을 실행해도 <code>teamone</code> 서버의 데이터는 모두 <code>origin</code> 서버에도 있는 것들이라서 아무것도 내려받지 않는다.<br>리모트 트래킹 브랜치 <code>teamone/master</code> 가 <code>teamone</code> 서버의 <code>master</code> 브랜치가 가리키는 커밋을 가리키게 한다.<br><figure><img alt="<code>teamone/master</code>의 리모트 트래킹 브랜치" loading=lazy src=/img/remote-branches-5.png></figure></p><h5 id=브랜치-추적>브랜치 추적<a hidden class=anchor aria-hidden=true href=#브랜치-추적>#</a></h5><p>리모트 트래킹 브랜치를 로컬 브랜치로 Checkout 하면 자동으로 &ldquo;트래킹(Tracking) 브랜치&rdquo; 가 만들어진다 (트래킹 하는 대상 브랜치를 &ldquo;Upstream 브랜치&rdquo; 라고 부른다).<br>트래킹 브랜치는 리모트 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다.<br>트래킹 브랜치에서 <code>git pull</code> 명령을 내리면 리모트 저장소로부터 데이터를 내려받아 연결된 리모트 브랜치와 자동으로 Merge 한다.</p><p>서버로부터 저장소를 Clone을 하면 Git은 자동으로 <code>master</code> 브랜치를 <code>origin/master</code> 브랜치의 트래킹 브랜치로 만든다.<br>트래킹 브랜치를 직접 만들 수 있는데 리모트를 <code>origin</code> 이 아닌 다른 리모트로 할 수도 있고, 브랜치도 <code>master</code> 가 아닌 다른 브랜치로 추적하게 할 수 있다.<br><code>git checkout -b &lt;branch> &lt;remote>/&lt;branch></code> 명령으로 간단히 트래킹 브랜치를 만들 수 있다.<br><code>--track</code> 옵션을 사용하여 로컬 브랜치 이름을 자동으로 생성할 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2>2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout --track origin/serverfix
</span></span><span class=line><span class=cl>Branch serverfix <span class=nb>set</span> up to track remote branch serverfix from origin.
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s1>&#39;serverfix&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>이 명령은 매우 자주 쓰여서 더 생략할 수 있다. 입력한 브랜치가 있는 (a) 리모트가 딱 하나 있고 (b) 로컬에는 없으면 Git은 트래킹 브랜치를 만들어 준다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout serverfix
</span></span><span class=line><span class=cl>Branch serverfix <span class=nb>set</span> up to track remote branch serverfix from origin.
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s1>&#39;serverfix&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>리모트 브랜치와 다른 이름으로 브랜치를 만들려면 로컬 브랜치의 이름을 아래와 같이 다르게 지정한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1>1</a>
</span><span class=lnt id=hl-32-2><a class=lnlinks href=#hl-32-2>2</a>
</span><span class=lnt id=hl-32-3><a class=lnlinks href=#hl-32-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b sf origin/serverfix
</span></span><span class=line><span class=cl>Branch sf <span class=nb>set</span> up to track remote branch serverfix from origin.
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s1>&#39;sf&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>이제 <code>sf</code> 브랜치에서 Push 나 Pull 하면 자동으로 <code>origin/serverfix</code> 로 데이터를 보내거나 가져온다.</p><h6 id=로컬-브랜치가-특정-remote-브랜치를-추적하게-하기>로컬 브랜치가 특정 Remote 브랜치를 추적하게 하기<a hidden class=anchor aria-hidden=true href=#로컬-브랜치가-특정-remote-브랜치를-추적하게-하기>#</a></h6><p>로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 <code>git branch</code> 명령에 <code>-u</code> 나 <code>--set-upstream-to</code> 옵션을 붙여서 아래와 같이 설정한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1>1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -u origin/serverfix
</span></span><span class=line><span class=cl>Branch serverfix <span class=nb>set</span> up to track remote branch serverfix from origin.
</span></span></code></pre></td></tr></table></div></div><p>추적 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 <code>git branch</code> 명령에 <code>-vv</code> 옵션을 더한다.<br>이 명령을 실행하면 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함께 보여준다.<br>게다가, 로컬 브랜치가 앞서가는지 뒤쳐지는지에 대한 내용도 보여준다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span><span class=lnt id=hl-34-3><a class=lnlinks href=#hl-34-3>3</a>
</span><span class=lnt id=hl-34-4><a class=lnlinks href=#hl-34-4>4</a>
</span><span class=lnt id=hl-34-5><a class=lnlinks href=#hl-34-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git branch -vv
</span></span><span class=line><span class=cl>  iss53     7e424c3 <span class=o>[</span>origin/iss53: ahead 2<span class=o>]</span> forgot the brackets
</span></span><span class=line><span class=cl>  master    1ae2a45 <span class=o>[</span>origin/master<span class=o>]</span> deploying index fix
</span></span><span class=line><span class=cl>* serverfix f8674d9 <span class=o>[</span>teamone/server-fix-good: ahead 3, behind 1<span class=o>]</span> this should <span class=k>do</span> it
</span></span><span class=line><span class=cl>  testing   5ea463a trying something new
</span></span></code></pre></td></tr></table></div></div><ul><li><code>iss53</code> 브랜치:<ul><li><code>origin/iss53</code> 리모트 브랜치를 추적</li><li>&ldquo;ahead&rdquo; 표시를 통해 로컬 브랜치가 커밋 2개 앞서 있다(리모트 브랜치에는 없는 커밋이 로컬에는 존재)</li></ul></li><li><code>master</code> 브랜치:<ul><li><code>origin/master</code> 브랜치를 추적</li><li>두 브랜치가 가리키는 커밋 내용이 같은 상태.</li></ul></li><li><code>serverfix</code> 브랜치:<ul><li><code>server-fix-good</code> 이라는 <code>teamone</code> 리모트 서버의 브랜치를 추적</li><li>커밋 3개 앞서 있으며 동시에 커밋 1개로 뒤쳐져 있다.<ul><li><code>serverfix</code> 브랜치에 서버로 보내지 않은 커밋이 3개, 서버의 브랜치에서 아직 로컬 브랜치로 머지하지 않은 커밋이 1개 있다</li></ul></li></ul></li><li><code>testing</code> 브랜치: 추적하는 브랜치가 없는 상태.</li></ul><p>여기서 중요한 점은 <strong>명령을 실행했을 때 나타나는 결과는 모두 마지막으로 서버에서 데이터를 가져온(fetch) 시점을 바탕으로 계산한다</strong>.<br>서버의 최신 데이터를 반영하지는 않으며 로컬에 저장된 서버의 캐시 데이터를 사용한다.<br>현재 시점에서 진짜 최신 데이터로 추적 상황을 알아보려면 먼저 서버로부터 최신 데이터를 받아온 후에 추적 상황을 확인해야 한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git fetch --all<span class=p>;</span> git branch -vv
</span></span></code></pre></td></tr></table></div></div><h5 id=원격-브랜치-삭제>원격 브랜치 삭제<a hidden class=anchor aria-hidden=true href=#원격-브랜치-삭제>#</a></h5><p><code>git push</code> 명령에 <code>--delete</code> 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다.<br><code>serverfix</code> 라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1>1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2>2</a>
</span><span class=lnt id=hl-36-3><a class=lnlinks href=#hl-36-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-b data-lang=b><span class=line><span class=cl><span class=c>$ git push origin </span><span class=nb>--</span><span class=c>delete serverfix
</span></span></span><span class=line><span class=cl><span class=c>To https://github</span><span class=nt>.</span><span class=c>com/schacon/simplegit
</span></span></span><span class=line><span class=cl><span class=c> </span><span class=nb>-</span><span class=c> </span><span class=k>[</span><span class=c>deleted</span><span class=k>]</span><span class=c>         serverfix
</span></span></span></code></pre></td></tr></table></div></div><p>위 명령을 실행하면 서버에서 브랜치(즉 커밋을 가리키는 포인터) 하나가 사라진다.<br>서버에서 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기 때문에 종종 의도치 않게 삭제한 경우에도 커밋한 데이터를 살릴 수 있다.</p><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><h3 id=git>Git<a hidden class=anchor aria-hidden=true href=#git>#</a></h3><p><a href=https://git-scm.com/book/ko/v2>Git</a><br><a href=https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EA%B8%B0%EC%B4%88>시작하기 - Git 기초</a><br><a href=https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Git-%EC%B5%9C%EC%B4%88-%EC%84%A4%EC%A0%95>Git 시작하기 - 최초 설정</a><br><a href=https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-%EC%84%9C%EB%B8%8C%EB%AA%A8%EB%93%88>Git Submodule</a><br><a href="https://devocean.sk.com/search/techBoardDetail.do?ID=165172&amp;boardType=">Git Submodule 사용하기</a><br><a href=https://yozm.wishket.com/magazine/detail/1743/>Git 200% 활용하기</a><br><a href="https://subicura.com/git/?utm_source=subicura.com&amp;utm_medium=referral&amp;utm_campaign=blog">Git / GitHub 안내서 핵심만 제대로 배우기</a><br><a href="https://devocean.sk.com/blog/techBoardDetail.do?ID=163875&amp;boardType=techBlog">git 충돌 해결..어떤 시각적 비교 도구 쓰시나요?</a><br><a href="https://news.hada.io/topic?id=11595">Git 워크플로 향상하는 15가지 팁</a><br><a href="https://news.hada.io/topic?id=11403">Git 형상관리 잘하는 법</a><br><a href="https://news.hada.io/topic?id=11232">GN⁺: .git 디렉토리안에는 무엇이 있을까?</a><br><a href=https://blog.ull.im/engineering/2019/03/10/logs-on-git.html>좋은 git commit 메시지를 위한 영어 사전</a><br><a href=https://subicura.com/git/>Git / GitHub 안내서 핵심만 제대로 배우기</a><br><a href=https://www.hanl.tech/blog/git-%ea%b8%b0%eb%b3%b8-%ec%a0%95%eb%b3%b5-%ec%8b%a4%ec%a0%84-%ec%97%b0%ec%8a%b5-1%ed%8e%b8-%ec%a0%95%ec%9d%98%ec%99%80-%ea%b0%9c%eb%85%90/>Git 기본 정복 실전 연습 – 1편 : 정의와 개념</a><br><a href=https://www.hanl.tech/blog/git-%ea%b8%b0%eb%b3%b8-%ec%a0%95%eb%b3%b5-%ec%8b%a4%ec%a0%84-%ec%97%b0%ec%8a%b5-2%ed%8e%b8-%ea%b8%b0%eb%b3%b8%eb%aa%85%eb%a0%b9%ec%96%b4/>Git 기본 정복 실전 연습 – 2편 : 기본명령어</a><br><a href=https://www.hanl.tech/blog/git-%ea%b8%b0%eb%b3%b8-%ec%a0%95%eb%b3%b5-%ec%8b%a4%ec%a0%84-%ec%97%b0%ec%8a%b5-1%ed%8e%b8-2%ed%8e%b8-%ea%b0%9c%eb%b4%89/>Git 실전 연습 1편 + 2편 개봉!</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/software-development/>Software-Development</a></li><li><a href=https://buenhyden.github.io/tags/software-maintenance/>Software-Maintenance</a></li><li><a href=https://buenhyden.github.io/tags/devops/>DevOps</a></li><li><a href=https://buenhyden.github.io/tags/ci-cd/>CI-CD</a></li><li><a href=https://buenhyden.github.io/tags/version-control/>Version-Control</a></li><li><a href=https://buenhyden.github.io/tags/git/>Git</a></li><li><a href=https://buenhyden.github.io/tags/branch/>Branch</a></li><li><a href=https://buenhyden.github.io/tags/remote/>Remote</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/version-control/><span class=title>« Prev</span><br><span>Version Control</span>
</a><a class=next href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/><span class=title>Next »</span><br><span>Primitive</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>