<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Styles | hyunyoun's Blog</title><meta name=keywords content="Software-Engineering,Design-and-Architecture,Architecture-Styles-and-Patterns,Architecture-Styles,Data-Flow,Styles,Batch-Sequential,Pipe-and-Filter,Process-Control"><meta name=description content="데이터 플로우 아키텍처의 세 가지 주요 스타일로, Batch Sequential 은 순차적 배치 처리, Pipe and Filter 는 스트림 기반 동시 처리, Process Control 은 피드백 루프 기반 제어 처리를 특징으로 하며, 각각 다른 데이터 처리 요구사항과 성능 특성을 가진다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Styles"><meta property="og:description" content="데이터 플로우 아키텍처의 세 가지 주요 스타일로, Batch Sequential 은 순차적 배치 처리, Pipe and Filter 는 스트림 기반 동시 처리, Process Control 은 피드백 루프 기반 제어 처리를 특징으로 하며, 각각 다른 데이터 처리 요구사항과 성능 특성을 가진다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Styles"><meta name=twitter:description content="데이터 플로우 아키텍처의 세 가지 주요 스타일로, Batch Sequential 은 순차적 배치 처리, Pipe and Filter 는 스트림 기반 동시 처리, Process Control 은 피드백 루프 기반 제어 처리를 특징으로 하며, 각각 다른 데이터 처리 요구사항과 성능 특성을 가진다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":5,"name":"Styles","item":"https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Styles</h1><div class=post-description>데이터 플로우 아키텍처의 세 가지 주요 스타일로, Batch Sequential 은 순차적 배치 처리, Pipe and Filter 는 스트림 기반 동시 처리, Process Control 은 피드백 루프 기반 제어 처리를 특징으로 하며, 각각 다른 데이터 처리 요구사항과 성능 특성을 가진다.</div></header><div class=post-content><h2 id=styles>Styles<a hidden class=anchor aria-hidden=true href=#styles>#</a></h2><p>Batch Sequential, Pipe and Filter, Process Control 은 소프트웨어 아키텍처에서 데이터 흐름 (Data-Flow) 을 중심으로 시스템을 설계하는 대표적인 스타일이다. Batch Sequential 은 일괄 처리, Pipe and Filter 는 연속적 데이터 변환, Process Control 은 실시간 제어 및 피드백에 적합하다. 각각의 구조, 구성 요소, 작동 원리, 장단점, 실무 적용 시 고려사항을 이해하면 다양한 시스템 요구에 맞는 최적의 아키텍처를 설계할 수 있다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><table><thead><tr><th>항목</th><th><strong>Batch Sequential</strong></th><th><strong>Pipe and Filter</strong></th><th><strong>Process Control</strong></th></tr></thead><tbody><tr><td><strong>핵심 개념</strong></td><td>전체 데이터를 일괄 처리하고 순차적으로 모듈 실행</td><td>데이터를 연속적으로 처리하며 필터 간 파이프를 통해 전달</td><td>출력 결과를 입력으로 피드백하여 실시간 제어 수행</td></tr><tr><td><strong>처리 단위</strong></td><td>배치 단위 데이터 집합</td><td>필터 (Filter) 단위의 증분 처리</td><td>제어 단위 (센서 + 컨트롤러 + 액추에이터)</td></tr><tr><td><strong>데이터 흐름</strong></td><td>단방향, 고정된 순서의 처리 흐름</td><td>연속적 스트림 처리 (Pull 또는 Push)</td><td>루프 기반의 순환 흐름 (Feedback Loop)</td></tr><tr><td><strong>동작 방식</strong></td><td>각 단계가 완전히 종료된 후 다음 단계 실행</td><td>각 필터가 독립적으로 병렬 실행 가능</td><td>실시간 감지 → 조정 → 피드백 → 반영 반복</td></tr><tr><td><strong>상태성</strong></td><td>보통 상태 없음 (Stateless), 단계별 상태는 파일로 유지</td><td>무상태 필터 기반 처리 또는 선택적 상태 유지 가능</td><td>상태 기반 처리 필수 (시스템 상태 지속 추적)</td></tr><tr><td><strong>컴포넌트 간 연결 방식</strong></td><td>중간 파일, 큐, 임시 저장소 등 간접 연결</td><td>파이프 (Pipe) 를 통한 직접 연결</td><td>센서, 액추에이터, 컨트롤러 간 밀접 연결</td></tr><tr><td><strong>병렬성 및 확장성</strong></td><td>병렬 처리 어려움, 순차 구조</td><td>병렬성 우수, 필터 단위 확장 가능</td><td>병렬성 제한적, 실시간 응답성과 안정성이 중요</td></tr><tr><td><strong>기술 예시</strong></td><td>Airflow, Spring Batch, cron 기반 ETL</td><td>Kafka, Flink, GStreamer, Unix Pipe (`cat</td><td>grep</td></tr><tr><td><strong>실무 적용 분야</strong></td><td>ETL 파이프라인 - 금융 일마감 처리 - 로그 집계</td><td>- 실시간 스트리밍 파이프라인 - 미디어 변환 - 컴파일러 (프론트엔드 처리)</td><td>- 임베디드 시스템 제어 IoT 자동화 - 클라우드 오토스케일링 시스템</td></tr><tr><td><strong>장점</strong></td><td>단순 명확한 처리, 디버깅 용이</td><td>모듈화, 병렬성, 재사용성, 스트림 처리 적합</td><td>실시간 제어, 동적 적응력, 외부 환경 대응 가능</td></tr><tr><td><strong>단점</strong></td><td>지연 큼, 실시간성 부족, 병목 발생 가능</td><td>복잡한 필터 설계 필요, 상태 공유 어려움</td><td>복잡한 제어 설계 필요, 높은 실시간성 요구</td></tr></tbody></table><ul><li><strong>Batch Sequential</strong>: 전통적 일괄 처리 구조. 단순하고 명확하지만 실시간성 부족. ETL, 로그 처리 등 대량 데이터를 주기적으로 처리할 때 적합.</li><li><strong>Pipe and Filter</strong>: 유연하고 모듈화된 스트림 중심 아키텍처. 컴포넌트 재사용성과 병렬성 뛰어나며, 데이터 스트리밍/컴파일러 등 실시간 처리에 적합.</li><li><strong>Process Control</strong>: 물리 시스템이나 제어 시스템에 필수. 상태 기반의 피드백 구조로, 실시간 반응성과 지속적인 조정이 필요한 환경에 이상적.</li></ul><h3 id=batch-sequential-vs-pipe-and-filter-vs-process-control-비교>Batch Sequential vs. Pipe and Filter vs. Process Control 비교<a hidden class=anchor aria-hidden=true href=#batch-sequential-vs-pipe-and-filter-vs-process-control-비교>#</a></h3><table><thead><tr><th>항목</th><th><strong>Batch Sequential</strong></th><th><strong>Pipe and Filter</strong></th><th><strong>Process Control</strong></th></tr></thead><tbody><tr><td><strong>데이터 처리 방식</strong></td><td>일괄 처리 (Batch)</td><td>스트림 단위의 점진적 처리</td><td>센서 기반 실시간 데이터 감지 및 제어</td></tr><tr><td><strong>처리 흐름 제어</strong></td><td>단계별 순차 실행 (Strict Order)</td><td>필터 독립 실행, 파이프 연결 (Loosely Coupled)</td><td>지속적 피드백 루프 기반 제어</td></tr><tr><td><strong>동시성 및 실행 모델</strong></td><td>순차적 실행만 가능</td><td>필터 단위 병렬 처리 가능</td><td>실시간 제어 루프 → 제한적 동시성</td></tr><tr><td><strong>주요 구성 요소</strong></td><td>배치 모듈, 스케줄러, 중간 저장소 (파일/DB 등)</td><td>필터 (Filter), 파이프 (Pipe), 스트림 큐</td><td>센서, 컨트롤러, 액추에이터</td></tr><tr><td><strong>데이터 흐름 방향</strong></td><td>일방향 (One-way)</td><td>일방향 스트림 처리 (Stream Push/Pull)</td><td>양방향 (센서 입력 → 제어 출력 → 피드백)</td></tr><tr><td><strong>상태 관리</strong></td><td>대부분 무상태 (Stateless), 파일 기반 중간 상태 유지</td><td>대부분 무상태, 필요 시 로컬 상태 유지 가능</td><td>상태 기반 필수 (센서값 기반 처리 상태 유지)</td></tr><tr><td><strong>지연 시간 (Latency)</strong></td><td>높음 (일괄 처리 후 전달)</td><td>낮음 (도착 즉시 처리)</td><td>매우 낮음 (즉시 제어 반응)</td></tr><tr><td><strong>처리량 (Throughput)</strong></td><td>낮음 (단계 간 대기 시간 존재)</td><td>높음 (병렬 필터 구성 가능)</td><td>중간 (I/O 와 센서 반응 속도에 따라 달라짐)</td></tr><tr><td><strong>확장성 (Scalability)</strong></td><td>제한적 (스케일 아웃 어려움)</td><td>높음 (필터 단위 수평 확장 용이)</td><td>구조적 제약으로 제한적</td></tr><tr><td><strong>유지보수성</strong></td><td>높음 (단계별 모듈 분리, 디버깅 쉬움)</td><td>높음 (모듈화 구조, 필터 재사용 가능)</td><td>낮음~중간 (센서/제어 로직 디버깅 복잡)</td></tr><tr><td><strong>오류 처리 및 복구</strong></td><td>단순 (실패 시 배치 전체 재처리 가능)</td><td>복잡 (스트림 상태 기반 오류 처리 필요)</td><td>매우 복잡 (센서 신호 오류, 루프 불안정 등 실시간 복구 필요)</td></tr><tr><td><strong>적용 분야</strong></td><td>- 데이터 웨어하우스 정산<br>- 보고서 생성<br>- 일간/월간 배치 작업</td><td>- 로그 처리 파이프라인<br>- 미디어 변환 시스템<br>- 컴파일러 (전처리~코드생성)</td><td>- 임베디드 시스템<br>- IoT 디바이스<br>- 공정 자동화 및 실시간 모니터링 시스템</td></tr><tr><td><strong>대표 구현 기술</strong></td><td>Airflow, Spring Batch, CRON</td><td>Apache Kafka, Apache Flink, Unix Pipeline, GStreamer</td><td>RTOS, PID/Kalman Filter, ROS, MQTT, Arduino</td></tr><tr><td><strong>설계 및 구현 난이도</strong></td><td>낮음 (구현 구조 단순)</td><td>중간 (병렬 구조, backpressure 등 고려 필요)</td><td>높음 (실시간 제어 알고리즘과 장치 제어 설계 필요)</td></tr><tr><td><strong>최적화 포인트</strong></td><td>배치 주기 조정, 병렬 배치 설계, 디스크 I/O 최적화</td><td>backpressure 조정, 병렬 필터 구성, 메시지 처리량 최적화</td><td>루프 주기 튜닝, 센서 정확도 향상, 실시간 스케줄링</td></tr></tbody></table><h4 id=강점과-약점-비교>강점과 약점 비교<a hidden class=anchor aria-hidden=true href=#강점과-약점-비교>#</a></h4><table><thead><tr><th>구분</th><th>Batch Sequential</th><th>Pipe and Filter</th><th>Process Control</th></tr></thead><tbody><tr><td><strong>강점</strong></td><td>• 단순하고 안정적인 구조<br>• 독립적인 모듈 테스트<br>• 높은 신뢰성<br>• 명확한 데이터 추적</td><td>• 높은 모듈화와 재사용성<br>• 동시 처리로 높은 처리량<br>• 유연한 파이프라인 구성<br>• 증분 처리 가능</td><td>• 실시간 적응 능력<br>• 외부 변화에 동적 대응<br>• 안정적인 출력 유지<br>• 자동 조정 기능</td></tr><tr><td><strong>약점</strong></td><td>• 높은 지연시간<br>• 동시성 부족<br>• 상호작용 불가<br>• 실시간 처리 어려움</td><td>• 동적 상호작용 제한<br>• 데이터 형식 표준화 필요<br>• 동적 구성 어려움<br>• 오류 전파 위험</td><td>• 높은 구현 복잡성<br>• 예측 불가능한 동작<br>• 디버깅 어려움<br>• 안정성 보장 어려움</td></tr></tbody></table><h4 id=핵심-차이점-요약>핵심 차이점 요약<a hidden class=anchor aria-hidden=true href=#핵심-차이점-요약>#</a></h4><table><thead><tr><th>기준</th><th>Batch Sequential</th><th>Pipe and Filter</th><th>Process Control</th></tr></thead><tbody><tr><td><strong>시간 흐름</strong></td><td>느림 (대기 후 일괄)</td><td>중간 (지연 허용)</td><td>빠름 (즉시 제어 필요)</td></tr><tr><td><strong>병렬성</strong></td><td>없음</td><td>우수 (필터 단위)</td><td>제한적 (제어 루프)</td></tr><tr><td><strong>복잡도</strong></td><td>낮음</td><td>중간</td><td>높음</td></tr><tr><td><strong>실무 적용 우선순위</strong></td><td>데이터 분석/정산</td><td>스트리밍 처리/ETL</td><td>실시간 제어/IoT</td></tr></tbody></table><h3 id=구조-및-아키텍처>구조 및 아키텍처<a hidden class=anchor aria-hidden=true href=#구조-및-아키텍처>#</a></h3><p>Batch 는 정해진 순서대로 단계별 처리, Pipe-and-Filter 는 스트림 단위로 연속 처리, Process Control 은 피드백 루프를 통한 실시간 제어 구조이다.</p><h4 id=batch-sequential-구조>Batch Sequential 구조<a hidden class=anchor aria-hidden=true href=#batch-sequential-구조>#</a></h4><ul><li>모듈 A → B → C 순차 실행</li><li>각 모듈은 입력 전체 보유 후 처리</li><li>스케줄러가 실행 타임 조정</li></ul><pre class=mermaid>flowchart LR
    Input[입력 데이터]
    Step1[처리 단계 1]
    Step2[처리 단계 2]
    Step3[처리 단계 3]
    Output[출력 데이터]
    Input --&gt; Step1 --&gt; Step2 --&gt; Step3 --&gt; Output
</pre><ul><li>각 단계는 전체 데이터를 처리 후 다음 단계로 넘긴다.</li></ul><h4 id=pipe-and-filter-구조>Pipe and Filter 구조<a hidden class=anchor aria-hidden=true href=#pipe-and-filter-구조>#</a></h4><ul><li>필터 (작업 단위) 들이 파이프 (데이터 스트림) 로 연결됨</li><li>필터는 스트림 데이터를 즉시 소비 및 출력</li><li>병렬/비동기 처리 가능</li></ul><pre class=mermaid>flowchart LR
    Source[데이터 소스]
    Filter1[필터 1]
    Filter2[필터 2]
    Filter3[필터 3]
    Sink[데이터 싱크]
    Source --&gt; Filter1 --&gt; Filter2 --&gt; Filter3 --&gt; Sink
</pre><ul><li>데이터가 파이프를 통해 필터를 거치며 점진적으로 변환된다.</li></ul><h4 id=process-control-구조>Process Control 구조<a hidden class=anchor aria-hidden=true href=#process-control-구조>#</a></h4><ul><li>센서 입력 → 컨트롤러 → 액추에이터 → 물리 시스템 → 센서</li><li>지속적 피드백 루프</li><li>실시간 제약조건 준수 필요</li></ul><pre class=mermaid>flowchart TD
    Sensor[센서]
    Controller[컨트롤러]
    Actuator[액추에이터]
    Process[프로세스]
    Sensor --&gt; Controller --&gt; Actuator --&gt; Process
    Process --&gt; Sensor
</pre><ul><li><strong>설명:</strong> 센서 데이터 → 컨트롤러 → 액추에이터 → 프로세스 → 다시 센서로 피드백 루프 형성.</li></ul><h4 id=구성-요소>구성 요소<a hidden class=anchor aria-hidden=true href=#구성-요소>#</a></h4><table><thead><tr><th>스타일</th><th>필수 구성 요소</th><th>선택 구성 요소</th></tr></thead><tbody><tr><td>Batch Sequential</td><td>배치 모듈, 스케줄러</td><td>로깅, 모니터링, 리트라이</td></tr><tr><td>Pipe-and-Filter</td><td>필터, 파이프, 메시지 큐</td><td>백프레셔, 체크포인트</td></tr><tr><td>Process Control</td><td>센서, 컨트롤러, 액추에이터, 타이머</td><td>시뮬레이터, RTOS, 안전 모듈</td></tr></tbody></table><h3 id=실무-사용-예시>실무 사용 예시<a hidden class=anchor aria-hidden=true href=#실무-사용-예시>#</a></h3><table><thead><tr><th><strong>도메인</strong></th><th><strong>적용 아키텍처</strong></th><th><strong>대표 사례 / 시스템 구성</strong></th><th><strong>주요 목적</strong></th><th><strong>기대 효과</strong></th></tr></thead><tbody><tr><td><strong>데이터 처리</strong></td><td>Batch Sequential</td><td>ETL, 로그 수집 및 정제 → 집계 → 저장 → 리포트 생성</td><td>대용량 일괄 처리 / 정합성 확보</td><td>안정성, 자동화, 자원 효율성</td></tr><tr><td></td><td>Pipe-and-Filter</td><td>실시간 로그 파이프라인 (ingest → transform → enrich → route)</td><td>스트림 데이터 모듈화 처리</td><td>낮은 지연시간, 독립적 확장성, 구성 유연성</td></tr><tr><td></td><td>Pipe-and-Filter</td><td>Spark Streaming 기반 필터 체인 구성</td><td>실시간 변환 및 가공</td><td>병렬 처리, 모듈 재사용, 장애 격리 구조화</td></tr><tr><td><strong>멀티미디어</strong></td><td>Pipe-and-Filter</td><td>오디오/비디오 처리 (디코딩 → 효과 적용 → 인코딩)</td><td>실시간 미디어 가공</td><td>처리 단계 분리, 고속 처리, 필터 재조합 가능성</td></tr><tr><td></td><td>Pipe-and-Filter</td><td>컴파일러 구조 (lex → parse → semantic → optimize → generate)</td><td>복잡한 처리 단계를 모듈화</td><td>유지보수 용이성, 기능 재사용, 독립 테스트 가능</td></tr><tr><td><strong>제어 시스템</strong></td><td>Process Control</td><td>로봇 제어 시스템 (센서 → 제어기 → 액추에이터 → 결과 피드백)</td><td>실시간 피드백 기반 동작 제어</td><td>고속 응답성, 안정성 확보, 안전 동작</td></tr><tr><td></td><td>Process Control</td><td>클라우드 오토스케일링 (CPU 감시 → 제어기 → 인스턴스 조정)</td><td>동적 자원 제어 / 비용 최적화</td><td>자원 최적화, SLA 보장, 무중단 확장성</td></tr><tr><td></td><td>Process Control</td><td>자동차 크루즈 컨트롤 (속도센서 → 제어기 → 스로틀 조절)</td><td>실시간 입력 기반 자동 제어</td><td>속도 안정화, 연비 개선, 사용자 편의성</td></tr><tr><td></td><td>Process Control</td><td>HVAC 기반 건물 온도 제어 시스템</td><td>환경 상태 기반 실시간 조절</td><td>에너지 절약, 쾌적한 실내 유지</td></tr><tr><td><strong>금융</strong></td><td>Batch Sequential</td><td>일일 마감 정산 (거래 기록 → 검증 → 청구서 생성 → 보고서 제출)</td><td>정기적, 정확한 회계 처리</td><td>대용량 검증, 오류 재처리 용이, 감사 용이성</td></tr><tr><td></td><td>Pipe-and-Filter</td><td>실시간 이상 거래 탐지 (Kafka → Flink 필터 체인 → 알림 전송)</td><td>이상 탐지 및 반응의 실시간화</td><td>빠른 사기 탐지, 유연한 탐지 로직 변경 가능</td></tr><tr><td></td><td>Hybrid</td><td>Lambda 구조 (실시간 탐지 + 배치 보정)</td><td>정확성 + 실시간성의 균형</td><td>즉각 대응 + 분석 정합성 확보</td></tr><tr><td><strong>IoT/산업제어</strong></td><td>Process Control</td><td>PLC 기반 센서 제어 및 반응 시스템</td><td>공정 자동화, 피드백 기반 제어</td><td>안전성 강화, 자동 반응, 생산성 향상</td></tr><tr><td></td><td>Hybrid</td><td>IoT 센서 데이터: 실시간 제어 + 주기적 분석</td><td>스트림 + 배치 융합</td><td>제어 정확도, 시계열 분석, 장비 유지보수 효율화</td></tr></tbody></table><ul><li><strong>Batch Sequential</strong>은 <em>정확성, 추적 가능성, 대용량 정기 처리</em> 에 탁월하며, 특히 금융, 공공기관, 로그 분석 시스템 등에서 강점을 가짐.</li><li><strong>Pipe-and-Filter</strong>는 <em>낮은 지연, 모듈성, 독립성, 유연한 조합</em> 을 통해 <em>미디어 처리, 스트림 데이터 분석, 컴파일러 설계</em> 등에서 활용됨.</li><li><strong>Process Control</strong>은 <em>피드백 루프, 실시간 반응성</em> 이 요구되는 <em>제어 시스템, IoT, 로봇 제어</em> 등에서 필수적.</li><li><strong>하이브리드 구성 (Lambda, Kappa 등)</strong> 은 <em>정확성과 실시간성</em> 을 동시에 요구하는 복합 시스템에 적합.</li></ul><h3 id=하이브리드-아키텍처-구성-및-확장-사례>하이브리드 아키텍처 구성 및 확장 사례<a hidden class=anchor aria-hidden=true href=#하이브리드-아키텍처-구성-및-확장-사례>#</a></h3><p>많은 실무 시스템에서는 단일 아키텍처 스타일로는 복잡한 요구사항을 모두 만족시키기 어려워 <strong>혼합 (hybrid)</strong> 구성이 일반적이다.</p><h4 id=lambda-architecture-batch--pipe-and-filter>Lambda Architecture (Batch + Pipe-and-Filter)<a hidden class=anchor aria-hidden=true href=#lambda-architecture-batch--pipe-and-filter>#</a></h4><table><thead><tr><th>구성 요소</th><th>설명</th></tr></thead><tbody><tr><td>Batch Layer</td><td>대용량 데이터의 정확하고 완전한 처리</td></tr><tr><td>Speed Layer</td><td>실시간 스트림 처리를 통해 지연 최소화</td></tr><tr><td>Serving Layer</td><td>최종 결과를 사용자에게 빠르게 제공</td></tr></tbody></table><pre class=mermaid>graph LR
  UserQuery --&gt; ServingLayer
  ServingLayer --&gt; BatchView
  ServingLayer --&gt; RealtimeView
  RealtimeView --&gt; StreamProcessor --&gt; Kafka
  BatchView --&gt; BatchProcessor --&gt; HDFS
</pre><blockquote><p>☑️ <strong>결합 효과:</strong> 정확성 (Batch) + 실시간 응답 (Stream) 의 균형을 맞출 수 있음</p></blockquote><h3 id=실무-적용-고려사항>실무 적용 고려사항<a hidden class=anchor aria-hidden=true href=#실무-적용-고려사항>#</a></h3><h3 id=실무에서-효과적으로-적용하기-위한-고려사항>실무에서 효과적으로 적용하기 위한 고려사항<a hidden class=anchor aria-hidden=true href=#실무에서-효과적으로-적용하기-위한-고려사항>#</a></h3><table><thead><tr><th>아키텍처 스타일</th><th>고려 항목</th><th>위험 요소 / 제약 조건</th><th>권장 방안</th></tr></thead><tbody><tr><td><strong>Batch Sequential</strong></td><td><strong>데이터 일관성</strong></td><td>장애 발생 시 전체 배치 실패 → 데이터 무결성 손상</td><td>트랜잭션 처리 도입, 체크포인트 삽입, 단계별 검증 로그 기록</td></tr><tr><td></td><td><strong>지연 허용 범위</strong></td><td>전체 데이터 처리 후 결과 산출로 인한 <strong>고지연 구조</strong></td><td>비동기 분산 배치 설계, Lambda/Kappa 구조 혼합 적용</td></tr><tr><td></td><td><strong>장애 대응 전략</strong></td><td>단계 실패 시 전체 흐름 중단, 리커버리 어려움</td><td>재시도/롤백 로직, 에러 핸들러 구성, 배치 작업 단위 분할</td></tr><tr><td></td><td><strong>모니터링 체계</strong></td><td>전체 실행 시간 및 작업 실패 원인 파악 어려움</td><td>배치 로그 집계, Job 상태 대시보드 구성 (예: Airflow UI)</td></tr><tr><td></td><td><strong>유지보수성</strong></td><td>스크립트 중심 설계 시 변경 대응 어려움</td><td>워크플로우 엔진 사용 (Airflow), 명확한 모듈화</td></tr><tr><td><strong>Pipe and Filter</strong></td><td><strong>데이터 포맷 관리</strong></td><td>필터 간 호환성 부족, 포맷 변환 비용 증가</td><td>공통 스키마 (JSON/Avro 등) 정의, 스키마 레지스트리 사용</td></tr><tr><td></td><td><strong>지연 및 병목 관리</strong></td><td>느린 필터로 인해 backpressure → 전체 흐름 지연</td><td>동적 버퍼 조절, 필터 단위 autoscaling, Reactive Streams 도입</td></tr><tr><td></td><td><strong>일관성 및 전달 보장</strong></td><td>중간 필터 실패 시 메시지 손실 위험</td><td>Exactly-once 보장 (Kafka), checkpoint 기반 메시지 복구</td></tr><tr><td></td><td><strong>모니터링 및 관측성</strong></td><td>필터 간 스트림 흐름 추적 어려움</td><td>스트림 대시보드 (Grafana, Prometheus), Kafka Lag 모니터링</td></tr><tr><td></td><td><strong>유지보수성</strong></td><td>필터 추가/변경 시 테스트 범위 증가</td><td>인터페이스 표준화, 통합 테스트 자동화 (CI/CD 연동)</td></tr><tr><td><strong>Process Control</strong></td><td><strong>실시간성 보장</strong></td><td>하드웨어 지연, RTOS 미사용 시 타이밍 이슈</td><td>우선순위 기반 실시간 스케줄링, RTOS 기반 태스크 설계</td></tr><tr><td></td><td><strong>센서 신뢰성</strong></td><td>센서 노이즈 및 고장 시 제어 루프 불안정</td><td>Kalman Filter, 센서 이중화, 이상 탐지 알고리즘 적용</td></tr><tr><td></td><td><strong>디버깅 및 유지보수</strong></td><td>실시간 제어 루프 디버깅 어려움</td><td>시뮬레이터 기반 테스트, 실시간 디버거, 로그 기반 리플레이 환경 구축</td></tr><tr><td></td><td><strong>에러 복구 전략</strong></td><td>센서/액추에이터 장애 시 전체 제어 실패</td><td>펌웨어 핫스왑, Failover 제어 로직 구현, Watchdog 사용</td></tr><tr><td></td><td><strong>프로토콜/인터페이스</strong></td><td>하드웨어 종속성 및 시스템 간 통신 불일치 가능성</td><td>표준 통신 프로토콜 (MQTT, CAN 등) 사용, 인터페이스 추상화 계층 도입</td></tr></tbody></table><p><strong>공통적으로 중요한 고려사항</strong>:</p><ul><li><strong>모니터링 체계</strong>와 <strong>장애 대응 전략</strong>은 모든 아키텍처에서 실무 적용 시 핵심</li><li><strong>유지보수성 확보</strong>를 위해서는 명확한 모듈화, 표준화된 인터페이스, 자동화된 테스트 체계 필수</li><li><strong>지연 허용 범위</strong>에 따라 아키텍처 스타일이 명확히 구분되어야 함<br>→ <em>Batch: 고지연 허용 / Pipe: 중간지연 / Process: 거의 무지연</em></li></ul><h4 id=아키텍처-스타일-선택-가이드라인>아키텍처 스타일 선택 가이드라인<a hidden class=anchor aria-hidden=true href=#아키텍처-스타일-선택-가이드라인>#</a></h4><table><thead><tr><th>기준 항목</th><th>Batch Sequential</th><th>Pipe-and-Filter</th><th>Process Control</th></tr></thead><tbody><tr><td>실시간성</td><td>낮음</td><td>중간 (지연 허용)</td><td>매우 높음</td></tr><tr><td>처리 데이터 유형</td><td>정적, 대용량</td><td>연속적인 스트림</td><td>센서 이벤트 기반</td></tr><tr><td>확장성</td><td>낮음 (병렬화 필요)</td><td>높음 (필터 병렬 구성 용이)</td><td>중간 (RT 설계에 따라 다름)</td></tr><tr><td>설계 복잡도</td><td>낮음</td><td>중간</td><td>높음 (상태·센서 고려)</td></tr><tr><td>장애 대응</td><td>비교적 단순</td><td>스트림 제어 필요</td><td>하드웨어·펌웨어에 따라 대응 방식 복잡</td></tr></tbody></table><h4 id=실무-적용-프레임워크-및-도구-정리>실무 적용 프레임워크 및 도구 정리<a hidden class=anchor aria-hidden=true href=#실무-적용-프레임워크-및-도구-정리>#</a></h4><table><thead><tr><th>스타일</th><th>프레임워크 / 도구</th><th>설명</th></tr></thead><tbody><tr><td>Batch Sequential</td><td>Apache Airflow, Spring Batch</td><td>워크플로우 기반 배치 스케줄링 및 트리거링</td></tr><tr><td>Pipe-and-Filter</td><td>Apache Kafka, Flink, NiFi</td><td>실시간 스트리밍, 파이프라인 처리</td></tr><tr><td>Process Control</td><td>ROS, FreeRTOS, Arduino, Simulink</td><td>제어 시스템, RTOS, 센서 시뮬레이션 도구</td></tr></tbody></table><h4 id=테스트-및-검증-전략>테스트 및 검증 전략<a hidden class=anchor aria-hidden=true href=#테스트-및-검증-전략>#</a></h4><table><thead><tr><th>스타일</th><th>테스트 전략</th><th>도구 예시</th></tr></thead><tbody><tr><td>Batch Sequential</td><td>샘플 데이터 기반 결과 비교 테스트</td><td>PyTest, JUnit + Test DB</td></tr><tr><td>Pipe-and-Filter</td><td>필터 단위 테스트 + 스트림 E2E 테스트</td><td>Kafka TestKit, TestContainers</td></tr><tr><td>Process Control</td><td>HIL (Hardware-in-the-Loop), 시뮬레이터</td><td>MATLAB Simulink, Gazebo</td></tr></tbody></table><h3 id=최적화를-위한-고려사항>최적화를 위한 고려사항<a hidden class=anchor aria-hidden=true href=#최적화를-위한-고려사항>#</a></h3><table><thead><tr><th><strong>범주</strong></th><th><strong>최적화 항목</strong></th><th><strong>Batch Sequential</strong></th><th><strong>Pipe and Filter</strong></th><th><strong>Process Control</strong></th></tr></thead><tbody><tr><td><strong>성능 최적화</strong></td><td>처리 효율</td><td>멀티스레드 / 워커 스케일 아웃 / 샤딩</td><td>병렬 필터 구조 / 비동기 파이프 / 백프레셔 조정</td><td>루프 주기 조정 / 읽기 최적화 / RT 우선순위 스케줄링</td></tr><tr><td><strong>리소스 관리</strong></td><td>CPU/메모리 활용</td><td>스레드 풀 튜닝 / 가비지 컬렉션 조정 / 일괄 버퍼 처리</td><td>필터 내 메모리 재사용 / 스트림 버퍼 최적화 / GC 압축 주기 조정</td><td>실시간 태스크 우선순위 / RTOS 메모리 풀 활용</td></tr><tr><td><strong>스토리지 최적화</strong></td><td>I/O 성능</td><td>SSD 기반 스토리지 / 파티셔닝 / 정렬된 일괄 저장</td><td>결과 버퍼링 / 임시 데이터 파이프 최적화</td><td>실시간 로그 압축 저장 / 로컬 버퍼 사용</td></tr><tr><td><strong>네트워크 최적화</strong></td><td>전송 효율성</td><td>일괄 전송 / 압축 패킷 처리 / 네트워크 토폴로지 고려</td><td>파이프 내 압축 및 버퍼 조정 / 메타데이터 캐싱</td><td>피드백 루프 전송 최소화 / 실시간 메시지 경량화</td></tr><tr><td><strong>확장성</strong></td><td>수평/수직 확장 전략</td><td>마스터 - 슬레이브 구조 / 병렬 단계 확장 / Airflow 병렬 실행</td><td>모듈 독립 확장 / 이벤트 기반 동적 연결 / 필터 재조합 설계</td><td>제어 루프 분리 배치 / 노드 단위 확장 / FaaS 제어 로직 분산화</td></tr><tr><td><strong>장애 대응</strong></td><td>복구 및 자동화</td><td>체크포인트 저장 / 롤백 포인트 지정 / 재처리 설계</td><td>모듈 단위 장애 격리 / 큐 기반 장애 리다이렉션</td><td>장애 감지 및 자동 전환 / 제어 변수 디폴트 구성</td></tr><tr><td><strong>모니터링</strong></td><td>지표 추적 및 튜닝 포인트</td><td>실행 시간, 큐 길이, 오류율 추적</td><td>필터 처리 지연, 스트림 처리량, 실패율 모니터링</td><td>응답 지연, 이벤트 누락, 상태 불일치 모니터링</td></tr></tbody></table><p><strong>요약</strong>:</p><ul><li><strong>Batch Sequential</strong>은 _ 처리량 최적화 _ 와 _ 복원력 확보 _ 가 핵심 → 병렬화 구조, 체크포인트 전략 필수.</li><li><strong>Pipe and Filter</strong>는 _ 병목 제거 _ 와 _ 스트림 동시성 조절 _ 이 관건 → 백프레셔, 큐 크기, 필터 병렬 처리 조율 필요.</li><li><strong>Process Control</strong>은 _ 실시간 반응성 보장 _ 이 최우선 → RTOS 활용, 피드백 루프 최적화, 장애 복원 빠른 설계 요구.</li><li>모든 아키텍처 공통적으로 <strong>리소스 효율화</strong>, <strong>스케일 전략</strong>, <strong>모니터링 지표 기반 운영</strong>은 필수 고려 대상.</li></ul><p><strong>권장 전략</strong>:</p><ul><li><strong>자동 스케일링 (Auto-Scaling)</strong>, **리소스 모니터링 도구 (Prometheus, Grafana 등)**와의 연계는 모든 유형에서 필수.</li><li>병목 구간 분석을 위해 <strong>성능 부하 테스트 (JMeter, Locust, k6 등)</strong> 주기적 실시 권장.</li><li>장애 시나리오 기반 <strong>복원 시뮬레이션 테스트</strong> 설계 및 자동화 필요.</li></ul><h3 id=주목할-내용>주목할 내용<a hidden class=anchor aria-hidden=true href=#주목할-내용>#</a></h3><table><thead><tr><th><strong>카테고리</strong></th><th><strong>항목</strong></th><th><strong>적용 아키텍처</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>제어 및 복구 전략</strong></td><td>Checkpointing</td><td>Batch Sequential, Stream</td><td>오류 발생 시 중간 상태부터 재처리를 가능하게 하는 상태 보존 기법</td></tr><tr><td></td><td>CRON Scheduling</td><td>Batch Sequential</td><td>배치 프로세스의 반복 실행을 자동화하는 예약 스케줄링 도구</td></tr><tr><td></td><td>Back-pressure</td><td>Pipe-and-Filter, Stream</td><td>처리량이 낮은 필터의 부하를 조절해 상류로 전달하는 흐름 제어 메커니즘</td></tr><tr><td></td><td>Fault Isolation</td><td>공통</td><td>각 필터 혹은 처리 단위의 장애를 전체 시스템 장애로 확산되지 않도록 격리하는 설계</td></tr><tr><td><strong>처리 구조 및 특성</strong></td><td>Stateless Filters</td><td>Pipe-and-Filter</td><td>상태 비보존형 필터로서 병렬 확장성과 분산 처리가 용이함</td></tr><tr><td></td><td>동적 확장성</td><td>Pipe-and-Filter</td><td>런타임 중 필터를 추가/제거하여 유연한 처리 파이프라인 구성 가능</td></tr><tr><td></td><td>트랜잭션 관리</td><td>Batch Sequential</td><td>일괄 처리 중 ACID 보장 및 오류 발생 시 롤백 처리를 위한 전략</td></tr><tr><td><strong>아키텍처 구현 기술</strong></td><td>Kafka Streams</td><td>Pipe-and-Filter, Stream</td><td>Kafka 기반 분산 스트림 처리로 Pipe 구조 구현에 활용 가능</td></tr><tr><td></td><td>PID Control</td><td>Process Control</td><td>실시간 제어에서 입력값에 따라 출력을 자동 조정하는 고전적 제어 알고리즘</td></tr><tr><td></td><td>Real-Time Constraints</td><td>Process Control</td><td>일정 시간 내 응답 보장을 요구하는 시스템 제약 조건</td></tr><tr><td><strong>아키텍처 발전 흐름</strong></td><td>Lambda Architecture</td><td>Hybrid</td><td>배치와 스트림을 병합한 대표적 하이브리드 데이터 처리 아키텍처</td></tr><tr><td></td><td>Kappa Architecture</td><td>Stream-centric</td><td>스트림 중심의 단순화된 아키텍처로 유지보수성과 실시간성을 강화</td></tr><tr><td></td><td>Event-Driven Architecture</td><td>Stream-centric, Process</td><td>이벤트 트리거 기반의 비동기, 실시간 데이터 흐름을 처리하는 구조</td></tr><tr><td><strong>클라우드 연계 기술</strong></td><td>Serverless Computing</td><td>All (특히 Process, Stream)</td><td>이벤트 발생 시 함수 단위로 실행되는 서버리스 환경, FaaS 기반 처리 모델</td></tr><tr><td></td><td>Container Orchestration</td><td>All</td><td>Kubernetes 기반의 컨테이너 파이프라인 자동화 및 확장</td></tr><tr><td></td><td>Managed Services</td><td>All</td><td>GCP Dataflow, AWS Glue 등 클라우드에서 제공하는 데이터 파이프라인 관리형 서비스 활용</td></tr><tr><td><strong>AI/ML 통합 구조</strong></td><td>MLOps Pipeline</td><td>Pipe-and-Filter, Hybrid</td><td>머신러닝 모델 학습/서빙 파이프라인을 자동화하고 모니터링하는 구조</td></tr><tr><td></td><td>Real-time Inference</td><td>Process Control, Stream</td><td>실시간 이벤트에 반응하여 모델 추론 결과를 즉시 제공하는 시스템 구조</td></tr><tr><td></td><td>AutoML</td><td>Batch, Hybrid</td><td>자동 모델링, 튜닝, 학습 파이프라인 구축을 통해 AI 파이프라인 처리 효율화</td></tr><tr><td><strong>공통 품질 속성</strong></td><td>모듈화 (Modularity)</td><td>공통</td><td>각 처리 단위를 독립 모듈로 분리하여 재사용성과 유지보수성 향상</td></tr></tbody></table><h3 id=반드시-학습해야할-내용>반드시 학습해야할 내용<a hidden class=anchor aria-hidden=true href=#반드시-학습해야할-내용>#</a></h3><table><thead><tr><th>카테고리</th><th>아키텍처 스타일</th><th>핵심 개념</th><th>반드시 학습해야 할 항목</th><th>설명</th></tr></thead><tbody><tr><td><strong>데이터 흐름 아키텍처</strong></td><td><strong>Batch Sequential</strong></td><td>일괄 처리, 단계적 흐름</td><td>ETL/ELT, 스케줄링, Airflow, Spring Batch</td><td>고정된 순서의 단계별 처리에 적합하며, 주기적인 대량 처리에 사용</td></tr><tr><td></td><td><strong>Pipe and Filter</strong></td><td>스트림 기반 처리, 모듈화, 필터 연결</td><td>Kafka, Flink, 모듈화, 백프레셔, Reactive Streams</td><td>각 처리 단계가 독립적인 필터로 구성되어 있어 유지보수가 용이하며 스트림 처리에 유리</td></tr><tr><td></td><td><strong>Process Control</strong></td><td>실시간 피드백 루프, 상태 기반 처리</td><td>PID 제어, Kalman Filter, RTOS, 실시간 스케줄링</td><td>제어 시스템 (예: IoT, 공정 제어) 에서 사용되며 실시간 반응성과 안정성 보장이 핵심</td></tr><tr><td><strong>스트림 처리 기술</strong></td><td>-</td><td>실시간 처리, 이벤트 기반</td><td>Apache Kafka, Flink, Storm</td><td>Pipe and Filter 및 Process Control 의 기반 처리 엔진</td></tr><tr><td><strong>제어 이론</strong></td><td>-</td><td>시스템 제어, 상태 공간 분석</td><td>PID, Kalman Filter, 전달함수, 안정성 분석</td><td>Process Control 의 이론적 기반이며 동적 시스템 제어에 필수</td></tr><tr><td><strong>소프트웨어 설계 원칙</strong></td><td>-</td><td>모듈화, 장애 허용성</td><td>모듈 독립성, Fault Tolerance, 유지보수성 향상</td><td>Pipe and Filter 아키텍처의 설계 품질을 좌우</td></tr><tr><td><strong>스케줄링/실시간 처리</strong></td><td>-</td><td>시간 기반 또는 우선순위 기반 실행</td><td>RTOS, Priority Scheduling, 체크포인트</td><td>Batch/Process Control 에서 중요한 실행 전략</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th><strong>카테고리</strong></th><th><strong>용어</strong></th><th><strong>설명</strong></th></tr></thead><tbody><tr><td><strong>아키텍처 패턴</strong></td><td>Data-Flow Architecture</td><td>데이터 흐름 중심으로 구성되는 아키텍처 스타일 (예: Pipe-and-Filter 등)</td></tr><tr><td></td><td>Batch Sequential</td><td>순차적인 일괄 처리 단계로 구성된 아키텍처 스타일</td></tr><tr><td></td><td>Pipe-and-Filter</td><td>처리 기능을 필터로 분리하고 데이터는 파이프를 통해 흐르는 구조</td></tr><tr><td></td><td>Process Control</td><td>실시간 제어 및 피드백 루프를 기반으로 동작하는 아키텍처 스타일</td></tr><tr><td></td><td>Lambda Architecture</td><td>배치와 스트림 경로를 병행 운영하여 실시간성과 정확성을 조화시키는 아키텍처</td></tr><tr><td></td><td>Kappa Architecture</td><td>스트림 기반 단일 경로에서 모든 처리를 수행하는 단순화된 아키텍처</td></tr><tr><td><strong>처리 컴포넌트</strong></td><td>Filter (필터)</td><td>데이터를 가공하거나 변환하는 독립적 처리 유닛</td></tr><tr><td></td><td>Pipe (파이프)</td><td>필터 간 데이터를 연결하는 전송 경로 또는 채널</td></tr><tr><td></td><td>Stream (스트림)</td><td>연속적으로 생성되어 전달되는 데이터 흐름</td></tr><tr><td></td><td>Temporal File (임시 파일)</td><td>배치나 모듈 간 처리 중간 결과를 저장하기 위한 임시 저장소</td></tr><tr><td><strong>시스템 개념</strong></td><td>트랜잭션 관리</td><td>데이터의 무결성과 일관성을 보장하기 위한 처리 단위 및 커밋 메커니즘</td></tr><tr><td></td><td>Checkpoint</td><td>스트림 또는 배치 처리 중 복구 가능한 상태를 저장하는 기술</td></tr><tr><td></td><td>Exactly-once</td><td>데이터가 중복 없이 정확히 한 번만 처리되는 보장 방식</td></tr><tr><td></td><td>Event Sourcing</td><td>시스템의 상태 변경을 이벤트 로그로 기록하는 설계 패턴</td></tr><tr><td></td><td>CQRS</td><td>읽기 모델과 쓰기 모델을 분리하여 확장성과 성능을 향상시키는 설계 방식</td></tr><tr><td></td><td>우선순위 스케줄링</td><td>실시간 시스템에서 중요한 작업을 먼저 처리하는 스케줄링 전략</td></tr><tr><td></td><td>RTOS</td><td>Real-time Operating System, 정해진 시간 내 응답을 보장하는 운영체제</td></tr><tr><td><strong>품질 속성</strong></td><td>Modularity (모듈화)</td><td>시스템을 독립적이고 재사용 가능한 단위로 분리하는 설계 원칙</td></tr><tr><td></td><td>Reusability (재사용성)</td><td>컴포넌트의 재사용 가능성을 높이는 구조적 특성</td></tr><tr><td></td><td>Scalability (확장성)</td><td>시스템이 데이터 증가 및 요청 증가에 유연하게 대응할 수 있는 능력</td></tr><tr><td></td><td>Maintainability (유지보수성)</td><td>시스템을 쉽게 수정하고 확장할 수 있는 능력</td></tr><tr><td><strong>제어 시스템</strong></td><td>Feedback Loop</td><td>출력값을 입력으로 다시 사용하는 제어 메커니즘</td></tr><tr><td></td><td>PID Controller</td><td>비례 (Proportional), 적분 (Integral), 미분 (Derivative) 제어 알고리즘</td></tr><tr><td></td><td>Set Point</td><td>제어 시스템이 도달해야 할 목표값</td></tr><tr><td></td><td>Control Variable</td><td>제어 대상이 되는 시스템 변수</td></tr><tr><td></td><td>Sensor</td><td>시스템 상태를 측정하는 장치</td></tr><tr><td></td><td>Actuator</td><td>제어 신호를 기반으로 물리적 동작을 수행하는 장치</td></tr><tr><td><strong>처리 특성 및 메트릭</strong></td><td>Latency (지연시간)</td><td>데이터가 입력되어 출력되기까지 걸리는 시간</td></tr><tr><td></td><td>Throughput (처리량)</td><td>단위 시간 내 처리할 수 있는 데이터 양</td></tr><tr><td></td><td>Back-pressure</td><td>소비자 처리량이 부족할 때 생산자의 전송 속도를 제어하는 메커니즘</td></tr><tr><td><strong>운영 기술</strong></td><td>Kafka</td><td>스트림 기반 메시지 브로커로 실시간 데이터 처리에 활용</td></tr><tr><td></td><td>Flink</td><td>상태 기반 스트림 및 배치 처리를 지원하는 분산 데이터 처리 엔진</td></tr><tr><td></td><td>Spark</td><td>대규모 배치 처리 및 스트리밍을 지원하는 범용 데이터 처리 프레임워크</td></tr><tr><td></td><td>RabbitMQ, Pulsar</td><td>메시지 큐 기반의 비동기 메시징 미들웨어</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.geeksforgeeks.org/software-engineering/software-engineering-architectural-design/>Architectural Design – Software Engineering (GeeksforGeeks)</a></li><li><a href=https://www.tutorialride.com/software-architecture-and-design/data-flow-architecture.htm>Data Flow Architecture – TutorialRide</a></li><li><a href=https://www.tutorialspoint.com/software_architecture_design/data_flow_architecture.htm>Data Flow Architecture – Tutorialspoint</a></li><li><a href=https://www.geeksforgeeks.org/pipe-and-filter-architecture-system-design/>Pipe and Filter Architecture – System Design (GeeksforGeeks)</a></li><li><a href=https://kisztof.medium.com/mastering-the-pipes-and-filters-architecture-5743ed26f5e0>Mastering the Pipes and Filters Architecture – Medium</a></li><li><a href=https://learn.microsoft.com/en-us/azure/architecture/patterns/pipes-and-filters>Pipes and Filters Pattern – Azure Architecture Center (Microsoft Learn)</a></li><li><a href=https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_%28Woolf%29/11:_Control_Architectures/11.01:_Feedback_control-_What_is_it_When_useful_When_not_Common_usage.>Feedback Control Loop – Engineering LibreTexts</a></li><li><a href=https://www.redhat.com/architect/feedback-loops-software-development>5 Feedback Loops That Avoid Software Architecture Chaos – Red Hat</a></li><li><a href=https://en.wikipedia.org/wiki/Pipeline_%28computing%29>Unix Pipe/Filter Architecture – Wikipedia</a></li><li><a href=https://www.confluent.io/blog/stream-processing-vs-batch-processing/>Batch vs. Stream Processing Comparison – Confluent Blog</a></li><li><a href=https://www.redpanda.com/blog/batch-vs-streaming-data-processing>Batch vs. Stream Processing Explanation – Redpanda</a></li><li><a href=https://martinfowler.com/architecture/>Software Architecture Styles Overview – Martin Fowler</a></li><li><a href=https://en.wikipedia.org/wiki/Pipe_and_filter_architecture>Data-Flow Architecture Styles – Wikipedia</a></li><li><a href=https://www.geeksforgeeks.org/software-engineering-data-flow-architecture/>Real-Time and Process Control Architectures Explained – GeeksforGeeks</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Batch Sequential</h2></header><div class=entry-content><p>Batch Sequential Batch Sequential 은 데이터‑플로우 아키텍처의 전통적 형태로, 큰 단위의 데이터를 일괄 처리 (batch) 하면서 순차적 단계 (연속 처리) 를 거치는 구조다. 각 단계는 독립 실행되며 임시 저장을 통해 이전 단계 결과를 전달한다. 과거 메인프레임 및 비즈니스 시스템 (회계, 청구 등) 에 널리 사용되었으며, 오늘날에도 대량 데이터 처리, ETL, 스케줄 기반 작업 등에서 활용된다. 장점으로 모듈화∙재사용성, 단순화된 디버깅 등이 있으며 단점으로 높은 지연 시간, 낮은 실시간 대응성, 병렬 처리 부족이 있다.
...</p></div><footer class=entry-footer><span title='2025-07-12 10:15:00 +0000 UTC'>July 12, 2025</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Batch Sequential" href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/batch-sequential/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process Control</h2></header><div class=entry-content><p>Process Control Process Control(프로세스 제어) 은 배치 처리 및 데이터 플로우 기반 시스템에서 각 작업 단계의 실행 순서, 상태, 예외 상황을 관리하는 기술이다. 프로세스 제어는 데이터 흐름의 일관성과 신뢰성을 유지하며, 오류 발생 시 빠른 감지와 복구를 지원한다. 실무에서는 워크플로우 자동화, 대용량 데이터 파이프라인, ETL(Extract, Transform, Load) 시스템 등 다양한 분야에서 활용되며, 운영 자동화와 장애 복원력을 높이는 데 중요한 역할을 한다.
배경 및 목적 대규모 데이터 처리에서 각 단계의 정확한 실행 순서와 오류 감지가 필요 장애 발생 시 빠른 복구와 재처리 지원 전체 데이터 흐름의 신뢰성과 일관성 보장 핵심 개념 프로세스 제어 (Process Control) 는 데이터 처리 시스템에서 각 처리 단계 (프로세스) 의 실행, 상태, 예외, 흐름을 관리하는 기능 또는 메커니즘이다. 배치 처리, 데이터 플로우 아키텍처 등에서 각 단계의 시작, 종료, 오류, 재시도, 의존성 등을 통제한다. 실무 구현과의 연관성 워크플로우 엔진 (Airflow, Control-M 등), 배치 스케줄러 (Cron 등) 에서 프로세스 제어가 핵심적으로 사용된다. 데이터 파이프라인, ETL, 대규모 로그 처리 등에서 각 단계의 자동 실행, 모니터링, 장애 복구에 활용된다. 각 단계별로 상태 (성공, 실패, 진행 중 등) 와 의존성 (선행/후행 작업) 을 관리하여 전체 시스템의 신뢰성을 높인다. 주요 기능 및 역할 작업 실행 및 상태 관리 오류 감지 및 알림 의존성 및 순서 제어 재시도 및 복구 모니터링 및 로깅 특징 자동화된 실행 및 예외 처리 상태 기반 제어 (State-driven Control) 유연한 확장성 (다양한 작업 추가/변경 용이) 핵심 원칙 명확한 상태 관리: 각 작업의 상태 (성공, 실패, 대기 등) 를 명확히 기록 및 관리 의존성 기반 실행: 선행 작업이 완료되어야 후행 작업이 실행 자동 복구 및 재시도: 실패 시 자동 재시도 및 복구 지원 주요 원리 및 작동 원리 각 작업은 상태 머신 (State Machine) 이나 워크플로우 엔진에 의해 제어됨 작업 실행 → 상태 기록 → 성공/실패에 따른 후속 처리 → 전체 워크플로우 완료 flowchart TD Start[시작] Step1[작업 1 실행] Check1[작업 1 상태 확인] Step2[작업 2 실행] Check2[작업 2 상태 확인] Success[전체 성공] Error[오류 처리 및 재시도] Start --> Step1 --> Check1 Check1 -- 성공 --> Step2 Check1 -- 실패 --> Error Step2 --> Check2 Check2 -- 성공 --> Success Check2 -- 실패 --> Error Error --> Step1 각 단계는 실행 후 상태를 확인하고, 실패 시 오류 처리 및 재시도가 이루어짐 구조 및 아키텍처 Process Control Architecture 는 다음과 같은 필수 구성요소와 선택 구성요소로 이루어진다.
...</p></div><footer class=entry-footer><span title='2025-07-12 10:15:00 +0000 UTC'>July 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process Control" href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/process-control/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pipe-and-Filter</h2></header><div class=entry-content><p>Pipe-and-Filter Pipe-and-Filter 는 데이터를 처리 흐름에 따라 독립된 필터 (Filter) 모듈로 나누고, 각 모듈 간 데이터를 파이프 (Pipe) 를 통해 전달하며 시스템 전체를 구성하는 아키텍처 스타일이다. 각 필터는 특정 작업 (검증, 변환, 집계 등) 에 집중하며, 파이프는 데이터를 순서대로 전달한다. 이런 설계는 모듈성, 재사용성, 조합성 등을 극대화해 유지보수와 확장을 용이하게 한다. 반면, 필터의 수가 많아질수록 오버헤드, 지연 (latency), 디버깅 복잡도, 포맷 호환 문제 등이 발생할 수 있다. 실무에서는 컴파일러, Unix 셸 명령어, ETL 파이프라인, 미디어 처리 시스템 등에 주로 적용된다.
...</p></div><footer class=entry-footer><span title='2025-07-08 14:33:00 +0000 UTC'>July 8, 2025</span>&nbsp;·&nbsp;53 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe-and-Filter" href=https://buenhyden.github.io/posts/data--database-systems/data-architecture/data-processing-architecture/data-flow-styles/pipe-and-filter/></a></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>