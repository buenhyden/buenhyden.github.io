<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lost Update | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Transaction,Transaction-Isolation,Concurrency-Anomalies,Transaction-Anomaly"><meta name=description content="로스트 업데이트는 여러 트랜잭션이 동일 데이터를 동시 수정할 때 읽기→수정→쓰기 과정의 비원자성으로 인해 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어써지는 현상이다. 원자적 SQL, 잠금(선점적), 낙관적 버저닝, 직렬화 등으로 예방한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Lost Update"><meta property="og:description" content="로스트 업데이트는 여러 트랜잭션이 동일 데이터를 동시 수정할 때 읽기→수정→쓰기 과정의 비원자성으로 인해 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어써지는 현상이다. 원자적 SQL, 잠금(선점적), 낙관적 버저닝, 직렬화 등으로 예방한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-12T03:49:00+00:00"><meta property="article:modified_time" content="2025-09-12T03:49:00+00:00"><meta property="article:tag" content="Data-and-Database-Systems"><meta property="article:tag" content="Data-Operations"><meta property="article:tag" content="Transaction-Management"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Transaction-Isolation"><meta property="article:tag" content="Concurrency-Anomalies"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Lost Update"><meta name=twitter:description content="로스트 업데이트는 여러 트랜잭션이 동일 데이터를 동시 수정할 때 읽기→수정→쓰기 과정의 비원자성으로 인해 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어써지는 현상이다. 원자적 SQL, 잠금(선점적), 낙관적 버저닝, 직렬화 등으로 예방한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":8,"name":"Lost Update","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Lost Update","name":"Lost Update","description":"로스트 업데이트는 여러 트랜잭션이 동일 데이터를 동시 수정할 때 읽기→수정→쓰기 과정의 비원자성으로 인해 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어써지는 현상이다. 원자적 SQL, 잠금(선점적), 낙관적 버저닝, 직렬화 등으로 예방한다.","keywords":["Data-and-Database-Systems","Data-Operations","Transaction-Management","Transaction","Transaction-Isolation","Concurrency-Anomalies","Transaction-Anomaly"],"articleBody":"Lost Update Lost Update 는 여러 트랜잭션이 같은 행을 동시에 읽어 수정할 때 한쪽 갱신이 나중 갱신에 의해 덮여 사라지는 현상이다.\nMVCC(스냅샷) 는 일부 읽기 문제를 막지만, 클라이언트 측에서 Read–Modify–Write 패턴을 쓰면 여전히 발생할 수 있다.\n실무 대응은\n가능한 경우 UPDATE … SET v = v + 1 처럼 원자적 SQL 사용 충돌이 잦지 않으면 낙관적 잠금(버전/타임스탬프 비교) 으로 충돌 감지 후 재시도 핫스팟엔 비관적 잠금(SELECT … FOR UPDATE) 사용 강제 일관성이 필요하면 DBMS 의 Serializable/SSI 선택이다 운영에서는 충돌률·재시도율·락 대기 시간을 관측하고 재시도·백오프 정책을 설계해야 한다.\n핵심 개념 개념 (한글·약어) 정의 왜 중요한가 실무 적용 예 트랜잭션 (Transaction) 작업의 원자적 묶음 (ACID) 부분 적용 방지, 일관성 유지 DB 트랜잭션 블록 (BEGIN/COMMIT) 격리 (Isolation) 동시 트랜잭션 간 상호제한 수준 정합성 vs 성능 트레이드오프 Read Committed / Serializable 선택 동시성 제어 (Concurrency Control) 충돌 방지 정책 (락/MVCC 등) 데이터 무결성 보장 Lock manager, MVCC 구현 MVCC (다중 버전) 데이터의 여러 버전으로 읽기 제공 읽기 성능 향상, 교착 위험 완화 Snapshot 기반 읽기 잠금 (Locking) 자원 접근 권한 제어 동시 쓰기 충돌 직접 방지 행 잠금, 테이블 잠금 로스트 업데이트 (Lost Update) 갱신 덮어쓰기 현상 핵심 데이터 손상 가능 카운터/잔액 오류 비관적 잠금 (Pessimistic Lock) 미리 잠금으로 충돌 차단 충돌 빈도↑ 안정성↑ SELECT … FOR UPDATE 낙관적 잠금 (Optimistic Lock) 커밋 시 버전 비교로 충돌 판별 성능 유리, 재시도 필요 version 컬럼 + WHERE version=? 직렬화 (Serializable) 직렬 실행과 동등한 결과 보장 최고 수준의 정합성 Serializable 격리 설정 아이덤포턴시 (Idempotency) 중복 요청해도 동일 결과 재시도 안전성 확보 idempotency key 사용 트랜잭션·격리·동시성 제어가 Lost Update 문제의 근본 구조. 비관적 vs 낙관적은 충돌 빈도와 성능 요구로 선택. 실무 적용은 DBMS 특성·비즈니스 중요도 (돈·재고 개념 간 상호관계표 출발 개념 → 대상 개념 방향성 (무엇을 위해) 관계 설명 (요약) 트랜잭션 → 격리 수준 트랜잭션의 동시성 보호를 위해 트랜잭션은 격리 수준을 통해 다른 트랜잭션과의 간섭 범위를 규정 격리 수준 → 동시성 제어 규칙을 실현하기 위해 특정 격리 수준은 락/MVCC 같은 메커니즘으로 구현됨 동시성 제어 → 잠금/MVCC 충돌을 실제로 제어하기 위해 락은 직관적 차단, MVCC 는 버전 기반 읽기 일관성 제공 잠금/MVCC → Lost Update 예방 또는 허용 (구현의존) 적절한 락/충돌검출 없으면 Lost Update 발생 낙관적 잠금 → 애플리케이션 재시도 충돌시 정합 복구 위해 충돌 감지 후 재시도/사용자 피드백 루틴 필요 분산 시스템 → 아이덤포턴시 메시지/재시도 안전성 위해 네트워크 실패·중복 전송 환경에서 정합 유지 방향성 포인트: 상위 개념 (트랜잭션/격리) 이 정책을 규정하고, 하위 메커니즘 (락/MVCC/버전) 이 이를 실현. 실무적으로는 이 방향을 따라 ’ 정책 선택 → 메커니즘 적용 → 보완 (재시도/아이덤포턴시)’ 의 흐름으로 설계한다. 상호관계 (개념 맵):\nflowchart LR A[Transaction] --\u003e B[Isolation] B --\u003e C[Concurrency Control] C --\u003e D[Locking] C --\u003e E[MVCC] B --\u003e F[Anomalies] F --\u003e G[Lost Update] G --\u003e H[Prevention] H --\u003e H1[Atomic Update] H --\u003e H2[Pessimistic Lock] H --\u003e H3[Optimistic Lock] H --\u003e H4[Serializable] 핵심 개념의 실무 연관성 개념 실무에서 무엇 (무엇을 다루는가) 어떻게 (적용 방식) 왜 (리스크/이점) 구현 예 (기술·패턴) Lost Update 동시 갱신으로 인한 덮어쓰기 충돌검출 또는 잠금 적용 정합성 확보 (중요) / 성능 저하 가능 버전검사, FOR UPDATE 비관적 잠금 충돌 높은 작업의 안전성 보장 행 단위 잠금 후 갱신 안정성↑, 동시성↓ SELECT … FOR UPDATE 낙관적 잠금 충돌 적은 작업에 적합 버전비교 → 실패 시 재시도 확장성↑, 재시도 로직 필요 version 컬럼 + UPDATE WHERE 조건부 UPDATE 원자적 계산을 DB 에서 실행 UPDATE t SET v = v +? WHERE id=? 원자성 확보, 네트워크 왕복 최소 SQL 단일 문장 아이덤포턴시 재시도 안전성 보장 idempotency-key + 저장 재시도시 중복 방지 idempotency key 저장소 분산 트랜잭션 여러 노드/서비스 간 정합 2PC / Saga 패턴 복잡성↑ / 일관성 확보 수단 Saga(보상), 2PC(동기) 성능·정합성·충돌확률을 기준으로 적절한 기법을 선택. 단일 DB 환경에선 조건부 UPDATE 나 버전검사로 충분한 경우가 많고, 분산 환경에선 Saga·아이덤포턴시와 같은 추가 패턴이 필수적이다. 기초 조사 및 개념 정립 갱신 손실 (Lost Update) 의 본질과 대응원리 갱신 손실 (Lost Update) 은 동시성 환경에서 두 개 이상의 트랜잭션이 동일한 데이터 항목을 읽은 뒤 각각 수정해 저장할 때, 나중에 커밋된 쓰기 (Last Write) 가 먼저 커밋된 쓰기를 덮어써서 앞선 변경이 데이터베이스에서 사라지는 현상이다.\n실무에서는 다음 특징으로 파악된다.\n본질: 읽기 시점의 값을 기반으로 수정하는 로직이 여러 트랜잭션에서 겹치면, 커밋 순서에 따라 일부 변경이 유실된다. 이는 데이터 무결성·비즈니스 규칙 위배로 이어진다. 재현 시퀀스 (간단): 두 트랜잭션이 같은 초기값을 읽고, 서로 다른 값을 저장 → 마지막 커밋이 최종 값이 되는 패턴. 근본적 해결 방향: 동시성 제어를 통해 \" 동일 데이터에 대한 경쟁적 수정 \" 을 감지하거나 차단하는 것 (락, 버전 비교, 표준 격리 수준 활용 등). 각 기법은 성능·확장성·복잡도 측면에서 상충하므로 시스템 요구 (충돌 빈도·응답성·스루풋) 에 따라 선택해야 한다. Lost Update: 발생·진화·실무 대응 Lost Update 는 두 사람이 같은 값을 동시에 읽어 수정할 때, 마지막으로 쓴 쪽만 남아 앞선 수정이 사라지는 문제이다.\n예를 들어:\n재고가 5 일 때 A 와 B 가 동시에 읽어 A 는 -1, B 는 -2 를 계산해 각각 업데이트하면, 둘 중 마지막 커밋만 반영돼 한 변경이 손실된다.\n초기 DB 는 락으로 막았지만 락은 성능을 저하시켜서 MVCC(여러 버전 저장) 나 낙관적 제어 같은 접근이 생겼다.\n그런데 MVCC 도 설정이나 충돌 감지 없이는 lost update 를 완전히 막지 못한다. 그래서 시스템은 충돌 검출이나 격리 수준, 또는 애플리케이션 레벨의 조건부 업데이트 같은 보완책을 함께 쓴다.\n등장 배경 동시성 환경에서 데이터 무결성을 지키려는 요구가 커지면서 Lost Update 문제가 부각되었다. 초기 DBMS 는 **단일 버전 + 잠금 (락)**으로 동시 접근을 통제했지만, 읽기·쓰기 동시성 증가로 락 경합과 성능 저하가 심해졌다. 이를 해결하려 **낙관적 접근 (OCC)**과 **다중 버전 (MVCC)**이 도입되었고, 이들 기술은 읽기와 쓰기를 분리하거나 커밋 시 충돌을 검증함으로써 성능을 올렸다. 그러나 MVCC 나 낮은 격리 수준은 설정에 따라 lost update 를 여전히 허용할 수 있어, 제품/구현별로 추가적인 쓰기 - 쓰기 충돌 검출이나 격리 강화가 필요하게 되었다. (Alibaba Cloud)\n발전 과정 단계 (시기·개념) 핵심 아이디어 Lost Update 에 대한 영향 (장단점) 개선 포인트 1. 단일버전 락 (초기) 읽기/쓰기 시 락으로 배타적 접근 완전 방지하지만 성능 저하·교착 우려 병목과 락 경합 완화 필요 2. 2PL(엄격 2-Phase Locking) 트랜잭션 전반에 락 유지로 직렬화 보장 일관성 보장, 하지만 확장성 한계 락 최소화·락 지속시간 관리 3. 낙관적 동시성 제어 (OCC) 작업 후 검증으로 충돌 감지·재시도 락 감소, 충돌 시 재시도 비용 발생 충돌률 낮은 워크로드에 효과적 4. MVCC (Snapshot) 읽기는 스냅샷 사용, 쓰기는 새 버전 생성 읽기 - 쓰기 충돌 완화, 그러나 쓰기 - 쓰기 충돌 관리 필요 write-conflict 감지/격리 설정 추가 5. Snapshot Isolation(SI) 트랜잭션별 일관된 스냅샷 보장, 특정 이상 방지 Lost Update 유형 회피 가능, 그러나 기타 이상 (예: write skew) 존재 SI 강화 또는 serializable 로 보완 6. Serializable/고급 CC 완전 직렬화 보장 (검증 또는 강한 락) 모든 이상 차단, 성능·복잡도 비용 성능 최적화, 병렬성 확보 연구 7. 애플리케이션 패턴 개선 조건부 UPDATE, 서버측 계산, 버전 비교 클라이언트 - 사이드 계산 문제 완화 디자인 패턴·계약으로 안전성 확보 timeline title Lost Update의 발전 타임라인 1970s : 락 기반 DB와 직렬화(초기 DBMS) 1980s : 2PL과 전통적 동시성 제어 정착 1980s-1990s : 낙관적 동시성(OCC) 연구·도입 1980s-2000s : MVCC 개념 등장·실무화 1995 : \"ANSI SQL 격리 수준\" 비판 및 Snapshot Isolation 정의(관련 논문) 2000s- : SI·MVCC 상호작용 및 write-conflict 연구 2010s- : 고성능 MVCC/Serializable 기법(메인메모리 DB 등) 2020s- : 분산·레이크하우스 환경에서의 CC 재설계 (경량 충돌관리 등) Lost Update 는 동시 수정 시 한 쪽의 변경이 덮여 사라지는 문제로, 초기 락 기반 설계에서 시작해 성능 문제로 인해 낙관적 제어와 MVCC 같은 접근이 등장했다.\nMVCC 는 읽기 성능을 크게 개선했지만, 쓰기 - 쓰기 충돌을 제대로 통제하지 않으면 여전히 업데이트 손실이 발생할 수 있다.\nSnapshot Isolation 은 lost update 유형의 이상을 막는 성질이 있어 널리 주목받았으나, 그 자체로 모든 이상을 제거하지는 못한다.\n따라서 실전에서는 **충돌 검출 (데이터베이스 레벨)**과 **애플리케이션 레벨 설계 (조건부 업데이트, 서버측 계산 등)**을 함께 조합해 안정성을 확보한다.\nLost Update 예방·보장 전략 총괄 개념 한줄: 두 트랜잭션이 같은 데이터를 동시에 갱신하면, 한쪽의 변경이 다른 쪽에 의해 덮어써져 ’ 유효한 갱신이 사라지는 ’ 현상이 Lost Update 이다.\n왜 문제인가?\n예: 계좌 잔액이 0 일 때, T1 이 +100, T2 가 +200 을 동시에 처리하면 기대값은 300 인데 설계/동작에 따라 100 이나 200 만 남을 수 있음 → 금전적 손실. 어떻게 발생하나 (간단 시나리오)\nT1 읽 (balance=0) → T2 읽 (balance=0) → T1 쓰 (balance=100) 커밋 → T2 쓰 (balance=200) 커밋 → 결과 200 (T1 결과 손실). 실무적 해결 전략 (비유로 설명)\n비관적 락: 물건을 집을 때 ’ 잠궈두기 ‘(다른 사람 접근 차단). → 안전하지만 줄 서는 시간이 늘어남. 낙관적 버전검사: 물건 위에 포스트잇 (버전) 을 붙여두고 결제할 때 버전이 바뀌었으면 다시 검사·재시도. → 충돌 적으면 빠름. 격리 수준/DB 정책: 상점 규칙 (데이터베이스가 자체 규칙으로 충돌을 감지해 후발 커밋을 거부). 간단 체크리스트 (초심자용)\n비즈니스상 동시 갱신 위험이 큰가? → 예면 락/버전/격리수준 설계 필요. 충돌 빈도와 성능 트레이드오프를 비교하라 (낙관적 vs 비관적). 테스트에서 동시성 케이스를 포함시켜 재현 가능한지 확인. Lost Update 이 야기하는 문제 요약 문제 항목 핵심 설명 실무 영향 검출 방법 덮어쓰기 (Overwrite) 동시 갱신으로 선행 커밋 내용이 후속 커밋에 의해 덮어짐. 금전 손실, 재고 오차. 동시성 테스트, 로그 비교 불일치 (Inconsistency) 기대값 (비즈니스 규칙) 과 DB 상태 불일치. 규정·회계 오류, 신뢰도 하락. 무결성 검증, 회계 조정 재현성 낮음 경쟁 상황은 간헐적으로만 발생 → 디버깅 어려움. 버그 추적 비용 증가. 스트레스 테스트, 시뮬레이션 트랜잭션 실패 가능 충돌 해결 정책 부족 시 데이터 손실·오류 발생. 운영 중단/수정 작업 증대. 트랜잭션 모니터링 Lost Update 문제는 동시 갱신이 있을 때 일부 유효한 변경이 사라지는 ’ 덮어쓰기 ’ 현상을 핵심으로 하며, 그 결과로 재무·재고 등 비즈니스 핵심 값이 왜곡된다. 재현성이 낮아 진단이 힘들고, 운영·법규상 리스크로 이어질 수 있으므로 동시성 테스트와 적절한 제어 (락/버전/격리 수준) 가 필요하다.\nLost Update 방지 핵심 목적 핵심 목적 설명 기대 효과 모든 유효 갱신 보존 충돌 시에도 커밋된 변경이 소실되지 않도록 보장. 데이터 무결성 보장, 금전적 손실 방지. ([Microsoft][6]) 직관적 일관성 확보 사용자가 기대하는 결과와 DB 상태 일치. 운영·디버깅 편의성 향상. 경쟁 조건 예방 race condition 발생 빈도 저감 (설계/운영 수준). 시스템 안정성 및 신뢰도 향상. 핵심 목적은 데이터가 의도치 않게 덮어써지지 않도록 보장하는 것과, 이를 통해 비즈니스 관점에서 ’ 예상 가능한 ’ 일관성을 제공하는 데 있다. 이를 위해서는 트랜잭션 설계, 락·버전 전략, DB 격리 정책의 적절한 조합이 필요하다.\n문제와 목적의 연결맵 문제 (원인/증상) 직접 대응되는 핵심 목적 적용 가능한 해결책 덮어쓰기 (Overwrite) 모든 유효 갱신 보존 버전검사 (optimistic), first-committer-wins, exclusive lock. ([Microsoft][6]) 불일치 (Inconsistency) 직관적 일관성 확보 Serializable 격리, 검증 로직, 컨플릭트 감지/재시도 재현성 낮음 (간헐성) 경쟁 조건 예방 스트레스 테스트, 시뮬레이션, 모니터링 운영적 충돌/데드락 위험 안정성·무결성 보장 데드락 탐지·타임아웃·백오프 전략 각 문제는 특정 목적과 직접 연계되어 있으며, 해결책은 목표에 맞춰 선택되어야 한다. 예컨대 덮어쓰기를 막는 것이 핵심이라면 버전검사나 first-committer-wins 같은 충돌감지 정책이 우선이고, 전체 시스템 일관성이 최우선이면 Serializable 격리 등이 적절하다. 트레이드오프 (성능 vs 안전) 를 항상 고려해야 한다. ([Microsoft][6])\n동시 갱신 전제와 대응 설계 동시 수정으로 일부 업데이트가 사라지는 문제는 다음이 갖춰질 때 특히 발생한다.\n두 개 이상의 트랜잭션이 같은 행을 읽는다. 각 트랜잭션이 읽은 값을 기반으로 계산하여 다시 쓴다. 이 과정이 원자적으로 묶여 있지 않거나 (=격리 불충분), 명시적 잠금을 사용하지 않아 동시성 제어가 되지 않을 때다. 설계 요구사항은 성능과 일관성의 균형을 맞추는 것이다—짧고 원자적인 갱신은 단일 SQL 로 해결하고, 사용자의 응답 대기가 포함되면 낙관적 버전 검사와 재시도, 엄격한 무결성이 필요하면 높은 격리나 비즈니스 락을 적용한다.\nLost Update 전제·요구사항 항목 설명 실무적 근거/영향 경쟁 조건 존재 여부 동일 Row/Key 에 동시 접근 발생 로스트업데이트 기본 전제. 트랜잭션 격리 수준 보통 RC 이상에서 문제 발생 빈도 감소 (하지만 DB 별 차이 존재) Read Committed 에서 자주 관찰, Serializable·적절한 잠금으로 예방 가능. MVCC 유무 및 동작 MVCC 는 읽기 스냅샷 제공—쓰기 충돌은 별도 처리 필요 MVCC 자체만으로는 로스트업데이트를 자동 차단하지 않음. 트랜잭션 길이 (think-time 포함) 긴 트랜잭션/사용자 대기 시 DB 락만으로 해결 어려움 낙관적 버전·재시도 패턴 권장. 성능 vs 무결성 요구 낮은 지연/높은 동시성 필요 vs 데이터 일관성 보장 요구 설계 시 트레이드오프로 의사결정 필요. 권장 대응 패턴 원자적 SQL, SELECT FOR UPDATE, 낙관적 버저닝, Serializable 상황별 장단점 존재 (성능·교착·재시도). 동일 행을 동시에 읽고 계산해 쓰는 패턴이 있고, 트랜잭션 격리나 잠금이 없으면 로스트 업데이트가 빈발한다.\nMVCC 는 읽기 성능을 개선하지만 쓰기 충돌 방지는 별도 전략이 필요하다.\n설계 시 우선으로 고려할 것은\n해당 업데이트를 단일 원자 SQL 로 처리할 수 있는지 사용자 think-time 이 있어 트랜잭션이 길어지는지 데이터 무결성의 우선순위에 따라 비관적 잠금·낙관적 버저닝·혹은 높은 격리 선택지를 결정하는 것이다. Lost Update: 원인·기술·운영 대응 총괄 Lost Update 는 여러 사용자가 같은 데이터를 동시에 읽어 수정할 때, 한쪽의 수정이 다른 쪽의 수정으로 덮여 사라지는 문제다.\nMVCC 나 Repeatable Read 같은 기술이 일부 읽기 문제를 막아도, 클라이언트가 직접 읽고 계산해 쓰는 (Read–Modify–Write) 패턴에서는 여전히 발생 가능하다.\n해결책은\n가능한 한 DB 의 원자적 문장 (UPDATE … SET v = v + 1) 을 사용해 RMW 를 없애기 충돌 감지가 필요한 경우 버전 기반 낙관적 잠금으로 감지→재시도 충돌 빈도가 높거나 강제 일관성이 필요하면 SELECT … FOR UPDATE 같은 비관적 잠금 또는 DB 의 Serializable 격리 수준을 선택하는 것이다. 운영에서는 충돌률·재시도율·락 대기시간을 모니터링하고 적절한 재시도/백오프 정책을 적용해야 안정적이다.\nLost Update 의 기술적 특징 분석 원자적 갱신 가능성\n설명: DB 가 UPDATE … SET v = v + 1 처럼 읽기·계산·쓰기 단계를 내부적으로 처리하면 애플리케이션 RMW 가 필요 없어짐. 근거: DB 엔진 내부의 단일 문장은 트랜잭션 원자성을 보장하므로 중간 충돌 소지가 제거됨. 차별점: 애플리케이션 로직 단순화·성능 우위—다만 복잡한 비즈니스 로직은 SQL 로 표현하기 어려울 수 있음. 격리 수준의 영향 (Repeatable Read/Read Committed 등)\n설명: 낮은 격리 수준에서는 Lost Update 가 쉽게 발생; 그러나 MVCC 기반 DB 도 구현·설정에 따라 차이가 있음 (예: MySQL 의 일부 동작). 근거: DBMS 별로 Repeatable Read 가 다르게 동작해 Lost Update 방지 여부가 달라짐. 차별점: 단순히 격리 수준 하나로 해결이 안 되는 경우가 있어 애플리케이션 레벨 설계 병행 필요. 낙관적 vs 비관적 락의 적합성\n설명: 낙관적 락은 읽기 위주·충돌 적은 환경에 효율적, 비관적 락은 충돌 많은 핫스팟에 안전. 근거: 낙관적은 버전 비교·예외·재시도 흐름, 비관적은 즉시 락 획득으로 설계된다. 차별점: 락 유지 유무 (성능/대기) 와 재시도 책임 (애플리케이션) 에 따라 선택이 갈림. 운영적 관측·재시도 정책의 중대성\n설명: 충돌을 단순히 기술로만 막을 수 없으므로 충돌률·재시도율·평균 락 대기시간 같은 지표로 시스템 동작을 실시간 파악해야 함. 근거: 재시도 폭주 (backoff 필요) 와 지표 기반 대응은 산업 권장 관행. 차별점: 기술 선택 이후 운영 설계가 실 서비스 안정성에 결정적 영향을 줌. Lost Update 대응 기술 비교표 특성 요약 설명 기술적 근거 장단점 (차별점) 원자적 SQL 갱신 DB 내부에서 읽기/계산/쓰기 동작을 단일 문장으로 처리 단일 트랜잭션 문장으로 원자성 보장. UPDATE … SET v = v + 1 등. 장: 간단·성능 우수. 단: 모든 비즈니스 로직 표현 불가. 낙관적 잠금 버전/타임스탬프로 충돌 감지 → 실패 시 재시도 ORM·JPA 의 version 필드 등 널리 사용. 충돌 시 예외 발생. 장: 락 없음 (읽기 성능). 단: 충돌 시 애플리케이션 재시도 필요. 비관적 잠금 SELECT … FOR UPDATE 로 선점 락 획득 DB 락 메커니즘 사용, 즉시 배타성 보장. 장: 충돌 방지 확실. 단: 대기·데드락·성능 저하 위험. 격리 수준 (Serializable) DB 차원에서 이상현상 차단 (Abort+ 재시도) SQL 표준 최고 격리. DBMS 구현 (락/SSI) 따라 작동. 장: 안전성 우수. 단: 성능·재시도 비용 발생. 운영 설계 (재시도·관측) 재시도 정책 (백오프), 충돌률·재시도율 모니터링 필수 재시도 폭주 방지 사례·권장 (지수적 백오프 등). 장: 현장 안전성 확보. 단: 모니터링·운영 부담 증가. Lost Update 방지는 단일한 정답이 아니라 상황에 맞춘 조합 설계다.\n간단한 카운터 증감 등은 원자적 UPDATE 로 해결하고, 읽기 위주 시스템에서는 낙관적 잠금을, 쓰기 핫스팟이나 강한 동시성 요구 환경에서는 비관적 잠금 또는 DB 의 Serializable 을 선택한다. 무엇보다 충돌이 현실화될 때를 대비한 재시도·백오프 전략과 충돌률·락 대기시간 같은 관측 지표를 설계해 운영하면 안정성이 크게 향상된다.\n핵심 원리 및 이론적 기반 Lost Update 통합 원칙·설계 문제의 본질: 여러 클라이언트가 같은 데이터를 동시에 고쳐서 한쪽 변경이 사라지는 상황이 Lost Update 다. 가장 쉬운 해결법: 가능한 한 한 문장으로 DB 에서 갱신하라. (UPDATE accounts SET balance = balance +? WHERE id =?) 충돌이 잦다면: 다른 트랜잭션이 접근하지 못하게 미리 잠그는 비관적 잠금(SELECT FOR UPDATE) 을 쓴다. 충돌이 드물다면: 버전 숫자 (또는 timestamp) 를 두고 커밋 시 비교하는 낙관적 잠금을 써 재시도한다. 분산/재시도 환경: 요청에 idempotency key를 도입해 중복 실행을 방지한다. 운영에서: 충돌 비율을 모니터링하고, 테스트로 정책을 검증해 최적의 전략을 선택한다. Lost Update 핵심 원칙표 원칙 설명 (요약) 목적 (무엇을 위해) 왜 필요한가 (이점) 실무 적용 예 원자적 갱신 DB 단일 문으로 갱신 수행 중간 상태 제거, 원자성 보장 충돌·재시도 비용 감소 UPDATE … SET v=v+? WHERE id=? 비관적 잠금 접근 전에 리소스 잠금 동시 쓰기 차단 충돌 위험 최소화 SELECT … FOR UPDATE 낙관적 잠금 버전 비교로 충돌 감지 높은 동시성·확장성 확보 성능 우위, 충돌 시 재시도 UPDATE … WHERE version=? 충돌 재시도 지수 백오프 + 재시도 transient 충돌 복구 사용자 경험 향상 재시도 루프 + 지터 아이덤포턴시 중복 요청에 동일 결과 보장 재시도 안전성 확보 중복 적용 방지 idempotency key 저장 관찰성 충돌/재시도 지표 수집 정책 튜닝 근거 확보 핫스팟 식별·최적화 메트릭 (충돌률) 수집 원자적 갱신을 우선으로, 충돌 빈도에 따라 비관적/낙관적을 선택한다. 재시도·아이덤포턴시·관찰성은 실무에서 항상 함께 적용해야 하는 보완 메커니즘이다. 설계 철학과 적용 방향 철학 설명 (요약) 목적 (무엇을 위해) 왜 필요한가 (실무적 의미) 최소 권한 트랜잭션 트랜잭션 범위·잠금 최소화 대기시간·교착 감소 동시성 성능 향상 정합성 - 성능 균형 비즈니스 요구에 따른 일관성 선택 비용·복잡성 최적화 불필요한 직렬화 회피 DB 우선 위임 DB 의 원자성/제약 활용 복잡도 감소·안정성 확보 이미 검증된 메커니즘 재사용 방어적 앱 설계 재시도·보상·중복방지 내장 장애 내성 강화 분산 환경의 현실적 요구 충족 측정 기반 튜닝 실측 데이터로 정책 조정 근거 있는 최적화 운영 효율성 극대화 설계 철학은 어떤 기술을 왜 선택하는가에 대한 근본 원칙을 제공한다. 실무에서는 이 철학을 기준으로 구체적 기법 (원자적 SQL, 버전관리, idempotency 등) 을 조합해 운영 요건을 충족시킨다. 갱신 손실 (Lost Update) 동작과 해법 갱신 손실은 트랜잭션이 읽기-계산-쓰기 의 비원자적 흐름을 따를 때 발생한다.\n두 트랜잭션이 동일한 초기값을 읽고 각자 계산한 값을 쓸 경우, 커밋 순서에 따라 한 쪽의 변경이 데이터베이스에서 유실된다. 데이터베이스는 이를 제어하기 위해 잠금 (lock), 격리 수준 (isolation), MVCC/스냅샷, 또는 애플리케이션 레벨의 낙관적 검사 (versioning) 같은 메커니즘을 제공한다.\n각 기법은 일관성 보장 능력과 성능·확장성 사이에 트레이드오프가 존재한다.\n갱신 손실의 원리와 제어 메커니즘 아래는 Lost Update 의 기본 동작 원리와 시스템/애플리케이션 수준 메커니즘을 정리한 핵심 목록이다.\n비원자 흐름 (핵심 원리)\n트랜잭션은 통상 READ → COMPUTE → WRITE → COMMIT 의 흐름을 따름. 이 중 READ 와 WRITE 사이가 비원자 (atomic 이 아님) 이기 때문에, 다른 트랜잭션이 같은 레코드를 변경하면 앞선 트랜잭션의 계산 결과가 무의미해질 수 있다. (예: 두 트랜잭션이 동일한 초기값 10 을 읽어 서로 다른 갱신을 하면 커밋 순서에 따라 하나가 소실). DB 메커니즘 관점\n락 기반 (비관적): SELECT … FOR UPDATE 등으로 행 락을 얻어 다른 업데이트를 대기시킴 → Lost Update 방지 (대기/충돌). 단점: 대기·교착 가능성·스루풋 저하. MVCC(스냅샷 기반): 트랜잭션은 스냅샷을 읽음 (읽기 중 다른 트랜잭션의 커밋은 스냅샷에 영향 없음). MVCC 자체는 읽기 일관성 제공하지만, 격리 수준과 구현에 따라 Lost Update 를 막지 못할 수 있음 (예: READ COMMITTED 에서 발생 가능). 낙관적 (버전) 검사: 레코드에 version 또는 updated_at 을 두고, UPDATE … WHERE id =? AND version =:old 형태로 수행해 업데이트 성공 여부로 충돌을 감지 → 실패 시 재시도/오류 반환. 격리 수준 영향 (개략)\nREAD UNCOMMITTED: 가장 약함 (일부 DB 는 구현 안 함)—여러 동시성 이상 허용. READ COMMITTED: 대부분 DB 의 기본—Lost Update 가 발생할 수 있음 (특히 단순 READ→UPDATE 패턴). REPEATABLE READ / SERIALIZABLE: 더 강한 보장—SERIALIZABLE 은 논리적 직렬화 보장 (대부분 Lost Update 방지 가능). 단, DB 구현마다 세부 동작 차이 있음. 애플리케이션 레벨 권장 패턴 (요약)\n충돌 가능성이 높으면 비관적 락. 충돌이 낮고 성능이 중요하면 낙관적 버전 검사 + 재시도. 분산 환경·복잡한 비즈니스 로직은 도메인 이벤트/CQRS/애그리게이트 수준에서 충돌 제어 고려. 갱신 손실 단계별 메커니즘 단계 동작 (시점) 문제 발생 지점 DB/앱 차원의 처리 (대표 메커니즘) 1 READ (스냅샷 읽기) 읽은 값이 곧 유효성 기준이 됨 MVCC 로 스냅샷 제공 (읽기 일관성)—단, 이후 쓰기 충돌 가능. 2 COMPUTE (애플리케이션 계산) 계산은 로컬에서 이루어져 다른 트랜잭션 영향 반영 안 됨 애플리케이션 레벨에서 버전 체크 설계 (낙관적). 3 WRITE (UPDATE) 다른 트랜잭션이 이미 커밋했으면 덮어쓰기 발생 비관적 락 (SELECT FOR UPDATE) 로 덮어쓰기 차단 / 낙관적 WHERE version 검사로 실패 감지. 4 COMMIT 커밋 순서가 최종값 결정 높은 격리 수준 (Serializable) 또는 트랜잭션 재시도 정책으로 무결성 확보. READ 단계: 트랜잭션이 읽을 때 DB 는 스냅샷을 줄 수 있지만, 이 스냅샷은 그 시점 이후의 변경을 반영하지 않음. 따라서 읽은 값에 기반한 계산은 ’ 구 버전 ’ 을 기초로 하는 것이고, 다른 트랜잭션의 동시 변경을 놓칠 수 있다.\nCOMPUTE 단계: 애플리케이션이 로컬에서 계산 (예: 재고 감소 계산) 을 하는 동안 다른 트랜잭션이 같은 데이터에 대해 변경을 하면, 계산 결과가 더 이상 최신 상태에 맞지 않게 된다. 낙관적 패턴은 이 시점의 불일치를 커밋 시 검사로 처리한다.\nWRITE 단계: 업데이트 시에 DB 가 행 락을 요구하지 않으면 다른 트랜잭션이 덮어쓸 수 있다. SELECT … FOR UPDATE 는 업데이트 전 행 락을 확보해 두 번째 업데이트를 대기시키거나 실패시킴으로써 Lost Update 를 방지한다. 그러나 락은 동시성 손실을 초래하므로 신중히 사용해야 한다.\nCOMMIT 단계: 커밋 순서가 데이터의 최종 상태를 결정한다. SERIALIZABLE 같은 강한 격리 수준은 논리적 직렬화를 보장해 Lost Update 를 근본적으로 차단하지만 성능/확장성 측면에서 비용이 따른다.\nLost Update 동작 흐름과 제어 분기 아래는 기본 시퀀스와 함께 비관적 락, 낙관적 검사, MVCC/격리 수준 분기가 포함된 흐름도다.\nsequenceDiagram participant T1 as Txn1 participant DB as DB participant T2 as Txn2 T1-\u003e\u003eDB: BEGIN T2-\u003e\u003eDB: BEGIN T1-\u003e\u003eDB: SELECT value FROM counter WHERE id=1 (reads v=10, snapshot_s1) T2-\u003e\u003eDB: SELECT value FROM counter WHERE id=1 (reads v=10, snapshot_s2) activate T1 T1-\u003e\u003eT1: compute -\u003e new_v1 = 11 alt 비관적 락 사용 T1-\u003e\u003eDB: SELECT ... FOR UPDATE (locks row) T1-\u003e\u003eDB: UPDATE counter SET value=11 WHERE id=1 T1-\u003e\u003eDB: COMMIT DB--\u003e\u003eT1: OK T2-\u003e\u003eDB: (blocked or lock timeout) =\u003e waits/errors else 낙관적 검사 사용 T1-\u003e\u003eDB: UPDATE counter SET value=11 WHERE id=1 AND version=old_ver DB--\u003e\u003eT1: success =\u003e commit T2-\u003e\u003eDB: UPDATE counter SET value=15 WHERE id=1 AND version=old_ver DB--\u003e\u003eT2: fail (version mismatch) =\u003e T2 must re-read/retry else 기본(MVCC, 낮은 격리) T1-\u003e\u003eDB: UPDATE counter SET value=11 WHERE id=1 T1-\u003e\u003eDB: COMMIT T2-\u003e\u003eDB: UPDATE counter SET value=15 WHERE id=1 T2-\u003e\u003eDB: COMMIT DB--\u003e\u003eAll: final value = 15 (T1 업데이트 소실) end deactivate T1 흐름도 상단은 두 트랜잭션이 동시에 BEGIN → SELECT 로 같은 값을 읽는 초기 상태를 보여준다. 이후 세 가지 대표 대응 방식(비관적 락 / 낙관적 검사 / 아무 제어 없음 (MVCC+ 낮은 격리)) 을 분기해 비교했다. 비관적 락: 첫 트랜잭션이 락을 획득하면 두 번째는 락 해제까지 대기하거나 오류 (타임아웃) 를 받는다. 즉, 덮어쓰기가 원천 차단된다. 단점은 락 대기 및 성능 저하. 낙관적 검사: 업데이트 시점에 버전 일치 여부를 검사해서 실패하면 재시도한다. 고동시성·저충돌 환경에서 유리. 재시도 로직 필요. 기본 (MVCC + 낮은 격리): 방어 장치가 없으면 두 트랜잭션의 커밋 순서로 덮어쓰기가 발생하여 Lost Update 가 발생한다. MVCC 가 읽기 일관성은 제공하지만, 격리 수준에 따라 덮어쓰기를 막아주지 않을 수 있다. Lost Update: 흐름·생명주기·대응 트랜잭션은 ’ 읽기 → 계산 → 쓰기 ’ 로 동작한다.\n두 트랜잭션이 같은 값을 읽어 각자 계산하면, 먼저 커밋한 결과를 나중 트랜잭션이 덮어버릴 수 있다.\n이를 막으려면\nDB 가 충돌을 감지해 후발 트랜잭션을 abort(또는 재시도) 하거나 먼저 쓰려는 쪽이 락을 걸어 다른 쪽을 대기시키는 방법을 쓴다. MVCC 는 읽기 성능을 높이지만, 쓰기 - 쓰기 충돌을 어떻게 처리하느냐에 따라 Lost Update 발생 여부가 달라진다.\n읽기→계산→쓰기: Lost Update 흐름 핵심 흐름 (상태/제어 관점) 읽기 단계 (Read / Snapshot): 트랜잭션이 시작되면 자신의 읽기 스냅샷 (또는 현재 데이터) 을 가져온다. 계산 단계 (Application): 애플리케이션이 읽은 값을 바탕으로 계산을 수행 (예: 잔액 차감). 이 간격에서 다른 트랜잭션이 커밋하여 데이터가 바뀔 수 있음 (스테일 데이터). 쓰기 단계 (Commit-time / Update): 업데이트 시 DB 의 충돌정책에 따라 두 갈래로 진행된다. DB 가 쓰기 - 쓰기 충돌 감지(commit-time) 하면 후발 트랜잭션을 abort/재시도. 또는 **선점 락 (비관적)**을 사용하면 후발자가 대기해 충돌을 피함. 안전화 권장 패턴 가능한 경우 서버 측 원자 연산으로 읽기 - 계산 - 쓰기를 합쳐라 (UPDATE … SET x = x - 1 WHERE x \u003e 0). 충돌이 드물면 버전/낙관적 패턴(UPDATE WHERE version=old + 재시도) 을 사용하라. 충돌이 빈번하거나 절대적 순서가 필요하면 비관적 락(FOR UPDATE) 채택을 검토하라. Lost Update 의 데이터·제어 단계표 단계 주요 액션 DB 동작 (대표) 결과 (충돌 시) 1. Read T1, T2 가 동일 행을 읽음 각 트랜잭션은 스냅샷 (또는 현재값) 확보 스냅샷은 이후 변경과 불일치 가능 2. Application Compute 애플리케이션에서 계산 수행 DB 는 관여하지 않음 (스테일 가능) 다른 트랜잭션이 중간에 커밋 가능 3. Update 시도 UPDATE/COMMIT 호출 (a) FOR UPDATE: 락 보유로 대기·직렬화 (b) OCC/MVCC: 커밋 시 충돌 검사 (a) 대기 후 적용 (b) 충돌이면 abort/retry 또는 덮어쓰기 (Lost Update) 4. Commit 결과 커밋 혹은 롤백 DB 정책에 따라 상태 반영 또는 재시도 최종값이 누구 커밋인지에 따라 결정 ’ 읽기→계산→쓰기 ’ 의 취약 지점을 명확히 보여준다. 핵심은 애플리케이션 계산 구간에서 데이터가 바뀔 수 있다는 점이며, 이를 막는 방법은 DB 레벨 (락·commit-time 충돌검사) 또는 애플리케이션 레벨 (원자 쿼리·버전 체크) 로 나뉜다. 선택은 워크로드 특성 (충돌 빈도, 지연 허용치, 정확성 우선순위) 에 따라 달라진다. 트랜잭션 데이터·제어 흐름 다이어그램 아래 흐름도는 일반적인 두 트랜잭션 (T1/T2) 의 읽기 - 계산 - 쓰기 경로와 DB 충돌 처리 분기를 보여준다.\nflowchart TD Start[트랜잭션 시작] Read1[\"T1: Read (snapshot)\"] Read2[\"T2: Read (snapshot)\"] Calc1[T1: Application 계산] Calc2[T2: Application 계산] Attempt1[T1: UPDATE -\u003e COMMIT 시도] Attempt2[T2: UPDATE -\u003e COMMIT 시도] DBCheck1{DB 충돌 정책} DBCheck2{DB 충돌 정책} Apply1[커밋: 변경 반영] Apply2[커밋: 변경 반영] Abort2[T2: 충돌 감지 -\u003e ABORT/재시도] Wait2[T2: 락 대기 -\u003e 적용] Start --\u003e Read1 Start --\u003e Read2 Read1 --\u003e Calc1 Read2 --\u003e Calc2 Calc1 --\u003e Attempt1 Calc2 --\u003e Attempt2 Attempt1 --\u003e DBCheck1 DBCheck1 --\u003e|비관적 락 존재| Apply1 DBCheck1 --\u003e|낙관적/MVCC| Apply1 Apply1 --\u003e Attempt2 Attempt2 --\u003e DBCheck2 DBCheck2 --\u003e|\"충돌 감지 (MVCC/OCC)\"| Abort2 DBCheck2 --\u003e|\"락으로 대기(FOR UPDATE)\"| Wait2 --\u003e Apply2 DBCheck2 --\u003e|충돌 미감지| Apply2 Abort2 --\u003e Retry2{재시도?} Retry2 --\u003e|예| Read2 Retry2 --\u003e|아니오| End2[트랜잭션 종료: 실패] Apply2 --\u003e End1[All Done] 트랜잭션은 독립적으로 읽고 계산을 수행한 뒤 업데이트를 시도한다. 첫 트랜잭션이 커밋되면 DB 상태가 바뀌고, 후발 트랜잭션의 커밋 시 DB 의 충돌정책에 따라 (1) 충돌 감지 → abort/재시도, (2) 락에 의해 대기 → 적용, (3) 충돌 미감지 → 덮어쓰기 (Lost Update) 중 하나가 결정된다. 애플리케이션은 재시도·백오프·아이덴포턴시 등의 정책으로 실패 상황을 견고하게 처리해야 한다. 트랜잭션 생명주기 (충돌 관점) 트랜잭션의 상태 변화 (시작 → 읽기 → 계산 → 준비 (검증) → 커밋/롤백) 를 생명주기 중심으로 표현한다.\nstateDiagram-v2 [*] --\u003e Started: BEGIN Started --\u003e Reading: Read(snapshot) Reading --\u003e Computing: Application 계산 Computing --\u003e Preparing: Update 시도 (Update/Prepare) Preparing --\u003e Committed: 충돌 없음 / COMMIT -\u003e 반영 Preparing --\u003e RolledBack: 충돌 감지 / ABORT -\u003e 재시도 가능 Preparing --\u003e Waiting: 락 대기 / Lock Wait Waiting --\u003e Committed: 락 해제 -\u003e 반영 RolledBack --\u003e Decision state Decision { [*] --\u003e Check Check --\u003e Retry: 재시도 Check --\u003e Stop: 중지 Retry --\u003e Reading Stop --\u003e [*] } Committed --\u003e [*] 이 생명주기는 트랜잭션이 읽기 → 계산 → 준비 (검증) → 커밋/롤백으로 진행된다는 점을 강조한다. Preparing 단계 (커밋 직전) 가 충돌검출의 핵심 지점이며, 여기서 DB 정책에 따라 롤백이 발생하면 애플리케이션이 재시도 여부를 결정한다. 락 기반이면 Waiting 상태가 생겨 대기 후 커밋될 수 있다. 특성 분석 및 평가 동시갱신 보호의 효용과 선택지 동시 갱신 상황에서 Lost Update 를 막는 기법들은 목적에 따라 선택된다.\n단순 값 증감 등은 데이터베이스의 원자적 UPDATE 로 해결하는 것이 가장 간단하고 효율적이다.\n사용자가 여러 단계 (예: 웹 폼 → 확인 → 커밋) 를 거쳐 트랜잭션이 길어지는 경우 낙관적 버저닝 (버전 비교 후 재시도) 이 적합하다.\n절대적 일관성이 필요하면 격리 수준을 Serializable 로 올리거나 비관적 잠금을 사용하되 성능·교착 리스크를 고려해야 한다.\n각 기법은 ’ 어떤 문제를 줄여주고 어떤 비용을 발생시키는지 ’ 로 판단하면 된다.\nLost Update 방지 장점 정리표 장점 상세 설명 기술 근거 적용 상황 실무적 가치 데이터 정합성 보호 동시 갱신 시 덮어쓰기 방지로 무결성 유지 격리 (Serializable), 비관적 락 동작 금융·재고·결제 분쟁·오류 리스크 저감. 자동 롤백·재시도 충돌 감지 시 트랜잭션 실패 후 재시도 가능 DB/애플리케이션 재시도 패턴 대량 트랜잭션 시스템 운영 안정성·회복력 향상. 원자적 갱신 UPDATE col = col + X 등 단일문으로 안전 갱신 SQL 원자성 보장 카운터·잔액 업데이트 간단·고성능·정확성 확보. 낙관적 버저닝 버전 비교로 충돌 탐지 후 재시도 버전/timestamp 비교 패턴 사용자 think-time·분산 트랜잭션 락 부담 감소·확장성 확보. 유연한 DB 별 전략 DB 특성에 따라 적절한 조합 적용 가능 MVCC vs 2PL 차이 존재 여러 DBMS 혼재 환경 이식성·운영 유연성 확보. Lost Update 방지 기법은 ’ 어떤 상황에서 ’ 와 ’ 어떤 비용이 드는가 ’ 를 기준으로 선택해야 한다.\n간단한 산술 갱신은 원자적 SQL 로 해결하고, 사용자 상호작용으로 트랜잭션이 길면 낙관적 버저닝을 도입하며, 규제·금융처럼 무결성이 최우선이면 높은 격리 수준이나 비관적 락을 적용한다. MVCC 는 읽기 성능을 크게 향상시키지만 쓰기 충돌 문제는 별도의 정책으로 처리해야 한다.\nLost Update: 한계·제약과 실무적 완화책 Lost Update 의 단점과 제약은 크게 두 축으로 본다.\n본질적 단점(예: 비관적 락은 락 경쟁·데드락을 만들고, 낙관적 락은 충돌 시 재시도 비용이 든다) 은 기술 선택 자체가 가져오는 트레이드오프다. 환경 제약(ORM 기본 설정, 읽기 - 쓰기 분리, DBMS 별 구현 차이) 은 운영·설계로 인해 문제가 커지는 요인이다. 실무에서는 원자적 UPDATE 로 단순 카운터 문제를 해결하고, 충돌이 흔한 곳은 비관적 락·파티셔닝을 적용하며, 낙관적 접근에는 지수적 백오프와 멱등성을 도입해 재시도 비용을 완화한다. 또한 리플리카 읽기 사용 시 세션 고정·마스터 읽기 등으로 스테일 리드를 피해야 한다.\nLost Update 의 본질적 단점 비교 단점 설명 원인 실무문제 완화/해결 방안 대안 기술 성능 저하 (비관적) 락으로 동시성 감소·대기 발생. 장시간 락 보유 지연·타임아웃·데드락 트랜잭션 단축, 인덱스 정리, 락 범위 축소 낙관적 락, 원자적 UPDATE 재시도 비용 (낙관적) 충돌 시 재시도·롤백 필요. 버전 비교 실패 사용자 지연·리소스 소모 지수적 백오프, 멱등 설계, 재시도 제한 비관적 락 표현 한계 (원자적 갱신) 복잡 로직을 원자 SQL 로 표현 어려움. SQL 표현력 한계 애플리케이션 RMW 유발 저장 프로시저, 로직 재설계 CQRS, 이벤트 소싱 성능 비용 (Serializable) 완전 보장 but 비용 큼. 충돌 탐지·재시도 TPS 저하 중요한 경로만 적용, 파티셔닝 혼합 격리 전략 각 기법은 반드시 트레이드오프를 동반한다. 낮은 충돌 환경에서는 낙관적 방식이 효율적이고, 핫스팟엔 비관적 락이나 파티셔닝이 적합하다. 원자적 SQL 은 가장 간단·효율적이지만 표현 한계가 있어 복잡한 도메인은 다른 패턴 병행이 필요하다.\n환경적 제약사항과 완화책 제약사항 설명 원인 영향 완화/해결 방안 대안 기술 ORM 기본 설정 기본 낙관 잠금 비활성화로 LWW 발생. 프레임워크 기본값 의도치 않은 덮어쓰기 @Version 등 명시, 테스트 DB 트리거 읽기/쓰기 분리 (리플리카) 복제 지연으로 스테일 리드 발생. 비동기 복제 지연 스테일 기반 갱신·데이터 불일치 마스터 읽기, 세션 고정 단일 라이터, 분산 락 DBMS 별 동작 차이 격리 수준·MVCC 구현 차이로 결과 상이. 내부 엔진 설계 차이 이식성·디버깅 난이도 증가 환경별 테스트·정책 문서화 DB 별 설계 패턴 적용 환경 제약은 설계·운영 관행으로 완화할 수 있다. ORM 설정·읽기 전략·DB 선택은 초기에 설계·테스트로 확정해야 런타임 문제를 줄일 수 있다.\nLost Update: 트레이드오프와 하이브리드 전략 문제 요약:\n일관성 (Consistency) 을 올리면 동시성 (throughput) 이 떨어지고, 동시성을 높이면 Lost Update 같은 데이터 오류 위험이 커진다.\n결정 원칙:\n중요한 데이터 (돈·재고) 는 강한 정합성 우선, 그렇지 않은 데이터는 성능 우선 (낙관적) 으로 설계.\n현실적 해법:\n전사적 한 가지 방식보다 핫스팟 식별 → 해당 키에 강한 제어 적용 → 일반 작업은 낙관적 처리 하는 하이브리드가 효과적.\n운영 포인트:\n충돌/재시도 메트릭, 아이덤포턴시, 지수 백오프를 필수로 도입해 돌발 상황 관리.\n고격리 Vs 저격리 트레이드오프 항목 고격리 / 비관적 (A) 저격리 / 낙관적 (B) 일관성 수준 매우 높음 (직렬화 가능) 낮음/중간 (eventual 가능) 처리량/동시성 낮음 높음 레이턴시 높음 낮음 충돌 처리 차단 (잠금) 으로 사전 예방 검출 후 재시도/보상 구현 복잡도 상대적 단순 (DB 에 위임) 애플리케이션 동작 필요 확장성 제한적 (글로벌 락 비용) 우수 (파티셔닝·분산에 친화) 적합 사례 금전·재고·주문 결제 등 좋아요·통계·카운터 등 핵심: A 는 안전 (정합성) 을 우선, B 는 성능 (처리량) 을 우선. 실무 추천: 중요한 도메인은 A 성향으로, 그렇지 않은 도메인은 B 성향으로 분류해 혼합 적용하라. 하이브리드 트레이드오프 패턴 패턴 적용 목적 장점 고려사항 선택적 비관적 잠금 핫스팟 보호 전체 성능 손실 최소화 핫스팟 탐지·잠금 범위 파티셔닝 + 로컬 직렬화 샤드 내 강한 정합 확장성 + 로컬 정합성 샤드 키 설계·크로스샤드 비용 CQRS 쓰기 정합성 + 읽기 성능 경로별 최적화 가능 동기화 지연·복잡도 리더 기반 업데이트 키 단위 직렬화 단순하고 확장 가능 leader failover 복잡 CRDT 분산 병합이 가능한 연산 네트워크 분할에 강함 비즈니스 제약 (모든 연산 불가) 조건부 SQL + 재시도 DB 원자성 우선 네트워크 왕복 최소화 재시도 정책 필요 핵심: 하이브리드 패턴들은 \" 어디에 강한 정합을 둬야 하나 \" 라는 질문에 실용적 대답을 준다. 실무 팁: 핫스팟은 선별적으로 강한 제어 (비관적/리더), 나머지는 낙관적/원자적 SQL 로 처리하는 조합이 빈번히 효과적이다. 갱신 전략 선택 기준과 실무 적용 문제: 여러 프로세스가 동시에 같은 값을 읽고 수정하면, 마지막으로 커밋된 값이 이전 변경을 덮어써서 일부 변경이 사라질 수 있다 (= Lost Update).\n해결 아이디어 요약:\n충돌 드묾 → 낙관적: 읽을 때는 락 안 걸고, 쓸 때 버전 비교. 실패하면 다시 읽고 재시도. 충돌 잦음 → 비관적: 업데이트 전에 락을 걸어 다른 업데이트를 차단. 단순 증감 → 원자적 연산: UPDATE t SET cnt = cnt + 1 WHERE id=? 같은 한 문장으로 처리. 중대한 금전/원장 → 강한 격리: Serializable/SSI 로 논리적 직렬화 보장. 실무 팁 한 줄: 먼저 충돌이 자주 발생하는 워크플로우를 찾아 (모니터링), 해당 워크플로우에 맞는 전략을 부분 적용해 보는 것이 가장 안전하다.\n갱신 전략별 적용 적합성 표 시나리오/속성 추천 전략 이유 단점/주의점 충돌 빈도 낮음 (대다수 웹 CRUD) 낙관적 잠금 (버전 기반) 높은 동시성 유지, 락 대기 없음. 충돌 시 재시도 로직 필요 (복잡도 증가) 충돌 빈도 높음 / 희귀·고가치 자원 비관적 잠금 (행락/분산락) 덮어쓰기 원천 차단, 데이터 손실 방지. 락 대기·교착·성능 저하 단순 누적·증감 (카운터, 재고 감소 등) 원자적 DB 연산 (single UPDATE) DB 가 원자 처리, 스케일 대비 우수. 설계가 단순해야 적용 쉬움 금융·원장·정합성 최우선 Serializable / SSI 논리적 직렬화로 무결성 보장. 성능·확장성 비용 큼 고성능 분산 시스템 애플리케이션 레이어 CQRS/이벤트 소싱 충돌 경계 축소·비동기 처리로 확장성 확보. 아키텍처 복잡도 증가 핵심 규칙: 데이터의 **가치 (정합성 중요도)**와 충돌 빈도를 교차표로 놓고 전략을 결정하라. 실무 우선순위: (1) 중요한 트랜잭션 경로 식별 → (2) 충돌률·재시도 비용 계측 → (3) 전략 (원자/낙관적/비관적/격리) 적용 → (4) 모니터링·조정. 실무 적용 및 사례 실습 예제 및 코드 구현 실습 예제: 문제 재현 (잘못된 패턴) 목적: Read-Modify-Write 의 위험 이해\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -- 테이블 CREATE TABLE counter ( id BIGINT PRIMARY KEY, value INT NOT NULL, updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ); INSERT INTO counter(id, value) VALUES (1, 10); -- Txn1 BEGIN; SELECT value FROM counter WHERE id=1; -- 10 읽음 -- (애플리케이션에서 +1 계산) -- 일부 지연… -- Txn2 BEGIN; SELECT value FROM counter WHERE id=1; -- 10 읽음 -- (애플리케이션에서 +5 계산) UPDATE counter SET value = 15 WHERE id=1; -- Txn2 커밋 COMMIT; -- Txn1 계속 UPDATE counter SET value = 11 WHERE id=1; -- Txn1 커밋 COMMIT; -- 최종 값 11 (Txn2의 갱신 소실) 수정안 1: 원자적 갱신 1 2 3 -- 동시 실행되어도 안전 UPDATE counter SET value = value + 1 WHERE id=1; -- Txn1 UPDATE counter SET value = value + 5 WHERE id=1; -- Txn2 수정안 2: 비관적 잠금 1 2 3 4 5 BEGIN; SELECT value FROM counter WHERE id=1 FOR UPDATE; -- Row 잠금 획득 -- 계산 수행 UPDATE counter SET value = value + 1 WHERE id=1; COMMIT; 수정안 3: 낙관적 잠금 (버전 컬럼) 1 2 3 4 5 6 7 8 ALTER TABLE counter ADD COLUMN version BIGINT NOT NULL DEFAULT 0; -- 읽기 시 현재 version도 읽어둔다(예: v=10, ver=3) -- 쓰기 시 조건부 업데이트 UPDATE counter SET value = :new_value, version = version + 1 WHERE id = :id AND version = :old_version; -- 영향 행이 0이면 충돌로 간주, 재시도 실습 예제: Lost Update 상황과 해결 - SQL 트랜잭션 목적 동시 실행되는 트랜잭션에서 갱신 손실 현상과 방지 전략 비교 실습 사전 요구사항 MySQL 또는 PostgreSQL DBMS 준비 계정 및 트랜잭션 권한 필요 단계별 구현 갱신 손실 발생 예시\n1 2 3 4 5 6 7 8 9 10 11 12 -- 트랜잭션 A START TRANSACTION; SELECT balance FROM accounts WHERE id = 1; -- balance = 100 UPDATE accounts SET balance = balance + 50 WHERE id = 1; COMMIT; -- 트랜잭션 B START TRANSACTION; SELECT balance FROM accounts WHERE id = 1; -- balance = 100 UPDATE accounts SET balance = balance + 100 WHERE id = 1; COMMIT; -- 최종 balance = 150, 트랜잭션 A의 작업 소실 명시적 락으로 해결\n1 2 3 4 5 6 7 8 9 10 11 12 -- 트랜잭션 A START TRANSACTION; SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- balance = 100 UPDATE accounts SET balance = balance + 50 WHERE id = 1; COMMIT; -- 트랜잭션 B START TRANSACTION; SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- 락 대기, balance = 150 UPDATE accounts SET balance = balance + 100 WHERE id = 1; COMMIT; -- 두 트랜잭션 작업 모두 보존 실행 결과 첫 번째 예시에서는 두 트랜잭션 중 한쪽 작업이 소실 두 번째 예시에서는 명시적 잠금으로 모든 작업이 제대로 반영 추가 실험 MVCC 환경에서 트랜잭션 버전 충돌 감지 (Repeatable Read 등) 낙관적/비관적 Lock 방식 비교 실습 Phase 6: 운영 및 최적화 Lost Update 관측·탐지·대응 체계 Lost Update 를 운영에서 잡아내려면 락/데드락/재시도 실패/장기 트랜잭션/핫로우 같은 지표를 정기적으로 관찰해야 한다.\nDB 로그 (예: deadlock detected, serialization failure) 는 즉각적인 경고이고, 애플리케이션 로그 (ORM 예외) 는 재시도 로직의 실패를 알려준다.\n이들을 대시보드에 연결해 임계값을 정하고 (예: 데드락 \u003e 1/min, 재시도율 \u003e 1%), 이상 발생 시 원인 분석 (핫로우·쿼리·트랜잭션 패턴) 을 해 문제를 해결한다.\nLost Update 관측 카테고리 체계 실시간 탐지 메트릭 실시간 지표는 문제 탐지 (또는 이상 징후 알림) 에 사용된다.\n핵심 지표와 수집 방법:\n락 대기 시간: 평균/90/99 백분위; DB 활동 테이블 (pg_stat_activity/performance_schema) 에서 집계. 데드락 수: 분/시간 단위 deadlock 발생 건수 (로그·엔진 카운터 기반). Retry 율 (낙관적 실패율): 애플리케이션 로그에서 재시도 이벤트 비율; SQLSTATE 40001 또는 ORM 예외로 집계. 장기 트랜잭션 수: 트랜잭션 연령이 임계값 (예: 30s/60s) 을 초과한 개수. 지표 목적 수집 방법 (요약) 권장 경보 임계값 (예시) 락 대기 시간 (P50/P90/P99) 동시성 병목 탐지 pg_stat_activity / performance_schema P99 \u003e 500ms 경고 데드락 수 (분단위) 충돌 심각도 표시 DB 로그 / 엔진 카운터 \u003e1 / min 심각 Retry 율 OCC/SI 실패 지표 애플리케이션 로그 / SQLSTATE \u003e1% 경고 장기 트랜잭션 수 스냅샷/리소스 고정 원인 pg_stat_activity(xact_start) \u003e5 건 경고 실시간 메트릭은 빠른 탐지와 알림을 위해 설정한다. 락 대기·데드락·재시도 실패가 늘면 Lost Update 나 동시성 버그를 의심하고 즉시 진단 루틴 (쿼리·트레이스 확인) 을 실행해야 한다. 로그 및 이벤트 (증거) 수집 로그는 진단·포렌식의 근거가 된다. 수집·보존·분석 프로세스가 중요하다.\nDB 에러 로그: deadlock detected, serialization failure, deadlock victim stack. 로그 수준을 운영에 맞춰 (일시적 증가 시 ROTATION/샘플링). 애플리케이션 로그: ORM 예외 (StaleObject, OptimisticLockException), 재시도 이벤트, SQL 에러코드 (40001 등). 로그 파이프라인: 중앙 로그 스토리지 (ELK, Loki 등) 로 전송하고, 쿼리 가능한 지표로 추출. 로그 타입 왜 중요한가 수집 방식 활용 DB 데드락 로그 누가 victim 인지, 쿼리 확인 파일→로그수집기 (ELK) 원인 쿼리/트랜잭션 재구성 Serialization Failure 낙관적 충돌 증거 앱 로그/DB 에러코드 재시도 로직 점검 ORM StaleObject 애플리케이션 레벨 충돌 앱 로그 비즈니스 로직 개선 포인트 로그는 이벤트의 증거를 제공한다. 자동화된 로그 분석 (패턴 추출, 상관관계) 으로 높은 재시도율이나 특정 쿼리의 반복성을 찾아내라. 트레이스·쿼리 수준 진단 심층 원인 분석을 위해 쿼리 플랜·트레이스·샘플링을 사용한다.\nTop updating queries: 가장 자주 update 되는 쿼리 목록, 쿼리별 평균 대기/응답 시간. 쿼리 플랜 분석: 인덱스 누락, 풀스캔, 행 잠금 범위 확대 여부 확인. 분산 트레이스: 트랜잭션 경로 (서비스 → DB) 에서 지연·재시도 지점 식별. 진단 항목 목적 도구/방법 Top update queries Hot row·빈발 업데이트 탐지 pg_stat_statements, Percona Toolkit 쿼리 플랜 잠금 범위·비효율 판별 EXPLAIN ANALYZE 분산 트레이스 서비스 -DB 상호작용 확인 OpenTelemetry, Jaeger 업데이트를 많이 발생시키는 쿼리와 그 플랜을 보면 Hot row, 범위 락, 잘못된 인덱스 등의 근본 원인을 찾기 쉽다. 대시보드·알림·자동화 (대응) 탐지 → 진단 후 즉시 조치·장기 개선으로 연결.\n대시보드: 실시간 메트릭 (P99, deadlocks/min, retry%) + 트렌드 (1h/24h). 알림 규칙: 단계별 (Warning → Critical) 알림, 자동화 (예: 초과 시 자동 샘플 트레이스 활성화). 자동화 플레이북: 높은 재시도율 시 자동 트래픽 셰이핑, Hot row 발견 시 DB 스키마/쿼리 변경 제안 알림. 항목 목적 예시 자동화 알림 룰 조기 경보 P99 lock wait \u003e 500ms -\u003e 경고 샘플 트레이스 문제 재현 데이터 확보 알림 시 5 분간 트레이스 샘플링 운영 플레이북 즉시 대응 deadlock 급증 -\u003e 특정 서비스 일시 차단 (스로틀) 탐지에서 끝나지 않고 자동화된 진단·임시 완화 조치 (스로틀링·배치 조정) 로 문제의 영향 범위를 줄이는 것이 핵심이다. Lost Update 관측 통합 체크리스트 카테고리 주요 지표/로그 목적 (탐지/진단/대응) 수집 방법 대표 대응 실시간 탐지 락 대기, 데드락, Retry 율, 장기 TX 탐지 pg_stat_activity, perf_schema, 앱 로그 알림, 샘플링 트레이스 로그·이벤트 deadlock detected, serialization failure, ORM 예외 진단 (증거) DB 로그, 로그 수집기 (ELK) 로그 상관분석, 원인 쿼리 식별 트레이스·쿼리 진단 Top update queries, EXPLAIN 심층 원인분석 pg_stat_statements, EXPLAIN, Tracing 쿼리 수정, 인덱스/스키마 변경 대시보드·자동화 알림 규칙, 샘플 트레이스 대응/완화 모니터링 시스템 (Grafana/Prometheus) 자동 샘플·스로틀·운영 플레이북 Lost Update 보안·감사 통합 설계 Lost Update 를 예방하려면 누가 언제 어떤 변경을 했는지 (감사 로그), 누가 그 권한을 갖는지 (접근 제어), 그리고 어떤 방식으로 충돌을 막는지 (트랜잭션 제어) 를 함께 설계해야 한다.\n운영 체크리스트 (초급) 중요한 테이블에 대해 변경 전/후 상태를 기록하는 감사 로그가 있는가? 로그는 중앙에 모이고 무결성 (해시/서명) 으로 보호되는가? 민감 테이블 (금융·원장) 에는 강한 격리 (예: Serializable) 또는 버전검사 패턴을 적용하는가? 권한은 최소화되어 있고, 락 취득 권한은 관리되는가? 이상징후 (충돌 증가 등) 를 모니터링·알람으로 감지하는가? Lost Update 보안·컴플라이언스 카테고리 감사 추적 (Audit \u0026 Immutable Trail) 변경 전후 상태 (Before/After), 트랜잭션 ID, 사용자/서비스계정, 타임스탬프, 변경 쿼리, 로그 해시 (무결성) 를 필수로 기록.\n감사 로그는 append-only(변조 불가) 스토리지 또는 외부 SIEM 으로 전송. DB 내 트리거 (pgAudit 등) 혹은 애플리케이션 레벨 이벤트 소싱을 병행.\n항목 목적 구현 포인트 before/after 변경 증빙 및 복원 근거 트리거/애플리케이션에서 캡처 트랜잭션 ID/유저 책임 추적 (Who) UUID 트랜잭션 식별자 포함 타임스탬프 변경 시점 증빙 정밀 타임스탬프 (UTC) 로그 무결성 변조 방지 해시·서명, WORM 저장소 중앙집중화 조사·대응 효율 SIEM/로그 스토리지 전송 감사 추적은 Lost Update 의 발생 근거를 입증하고 재구성하기 위한 핵심 수단이다. 변경 전·후 상태와 트랜잭션 식별자를 보존하면 누가 무엇을 덮어썼는지 검증 가능하며, 로그 무결성은 규제 대응에서 필수다. 접근 제어 (Access Control \u0026 Privilege) 최소 권한 원칙으로 트랜잭션·락 취득 권한을 분리.\n애플리케이션 계정과 운영 (관리) 계정을 분리하고, 권한 변경은 감사 로그로 남김.\n클라우드 DB 의 IAM 연동과 역할 기반 접근 제어 권장.\n항목 목적 구현 포인트 최소 권한 우발적·악의적 변경 방지 역할·권한 세분화 락 권한 분리 임의 락 사용 통제 관리자 전용 락 정책 계정 분리 책임 구분 서비스 계정/운영 계정 분리 권한 변경 감사 변경 추적 권한 변경 로그 보존 권한을 적절히 제한하면 의도치 않은 동시 변경을 줄일 수 있다. 특히 락 (SELECT FOR UPDATE 등) 권한을 통제하면 시스템 안정성·감사성이 동시에 개선된다. 트랜잭션 제어 (Transactional Integrity) 비즈니스 중요도에 따라 Serializable 등 강한 격리 적용 또는 낙관적 버전검사 (버전 필드/ETag) 사용.\n분산 환경은 conditional writes(조건부 업데이트) 나 이벤트 소싱/Saga 패턴으로 설계. 충돌 시 재시도 정책과 감사 로그를 연계.\n항목 목적 구현 포인트 격리 수준 (Serializable) 완전한 일관성 보장 성능 영향 검토 후 적용 낙관적 락 충돌시 재시도 통한 보존 버전 필드, 조건부 업데이트 비관적 락 쓰기 동시성 완전 차단 SELECT FOR UPDATE 등 분산 패턴 글로벌 일관성 확보 conditional writes, Saga 트랜잭션 제어는 Lost Update 를 직접 예방하는 계층이다. 강한 격리는 안전하지만 성능 영향이 있으므로, 낙관적/비관적 기법을 조합해 적용하는 것이 실무적이다. 운영 모니터링·탐지 (Ops \u0026 Detection) 충돌률·재시도율·비정상적 다중 쓰기 이벤트를 지표화하고 SIEM/알람으로 연결.\n로그 무결성 검사 (정기 해시 비교) 및 포렌식 워크플로를 수립.\n항목 목적 구현 포인트 충돌률 모니터링 이상 탐지 충돌 지표 → 알람 로그 무결성 검사 변조 탐지 정기 해시/서명 확인 자동 대응 빠른 격리/복구 재시도·차단·알람 워크플로 대시보드 운영 가시성 충돌·성능 지표 시각화 Lost Update 는 간헐적으로 나타나므로 계측과 자동화된 탐지·대응 체계가 있어야 실제 리스크를 줄일 수 있다. 중앙화된 로그·SIEM 통합이 효과적이다. 규정준수·보존 (Compliance \u0026 Retention) 규제별 로그 보존기간·무결성 요구를 정책화 (예: PCI 의 로그 보존 권고·SOX 의 재무 증빙 요건).\n보존은 암호화·WORM·백업 전략과 함께 운영.\n항목 목적 구현 포인트 보존 기간 규제 준수 규제별 정책 문서화 무결성 보장 법적 증빙 확보 WORM/해시/서명 저장 문서화 감사 대비 정책·절차·증적 파일화 정기 감사 규정 지속 충족 내부·외부 감사 리포트 보존·무결성 요구는 규제 리스크를 줄이는 핵심 요소다. 로그 정책·보존·증빙 체계를 미리 설계하면 감사 시 빠르게 대응 가능하다. Lost Update 보안·컴플라이언스 통합표 카테고리 핵심 수단 규제·실무 목적 구현 우선순위 감사 추적 before/after, 트랜잭션 ID, 해시 증빙·포렌식·감사대응 높음 접근 제어 최소권한, 계정 분리 무단 변경 방지 높음 트랜잭션 제어 Serializable, 버전검사, conditional write Lost Update 예방 높음 (데이터 중요도에 따라) 운영 모니터링 충돌률 지표, SIEM 알람 신속 탐지·대응 중~높 규정준수 보존정책, WORM, 감사 리포트 법적·회계적 증빙 높음 (규제 산업 필수) 모든 항목은 상호보완적이다.\n감사 로그와 접근 제어가 있어야 증빙과 책임 추적이 가능하고, 트랜잭션 제어가 있어야 실제 Lost Update 를 예방할 수 있다.\n운영 모니터링은 문제가 발생했을 때 빠르게 포착하게 해주며, 규정준수는 법적·회계적 요구를 만족시킨다. 우선순위는 데이터의 민감도와 규제 요건에 따라 조정하라.\nLost Update 성능·확장성 전략 성능을 유지하면서 Lost Update 를 줄이려면 먼저 트랜잭션을 가능한 짧게 만들고, 단순한 증감 연산은 DB 의 원자적 UPDATE 로 처리한다.\n쓰기 집중 (핫스팟) 이 문제면 파티셔닝/샤딩으로 분산하고, 데이터 무결성이 더 중요하면 특정 경로에 한해 격리 수준을 높인다.\n충돌은 낙관적 버전 검사와 재시도로 다루고, 핫스팟은 샤드키·리밸런싱·모니터링으로 해결한다.\n성능·확장성 최적화 핵심 카테고리 트랜잭션 단축 \u0026 원자적 연산 짧은 트랜잭션은 락 시간과 충돌 창을 줄여 성능을 개선한다.\n가능한 연산을 원자적 SQL(예: UPDATE t SET v = v +?) 로 표현해 애플리케이션 레벨의 read→compute→write 패턴을 제거하면 Lost Update 위험이 낮아진다.\n트랜잭션 내 I/O(외부 API 호출, 파일 등) 는 비동기로 분리한다.\n동시성 제어 전략 선택지 비관적 락 (SELECT FOR UPDATE) 은 충돌을 예방하지만 대기·교착 가능성이 있으므로 중요 자원에 한해 사용한다.\n낙관적 버저닝은 충돌 탐지 후 재시도로 확장성에 유리하며, 동적 격리 조절로 핵심 경로만 높은 격리를 적용하면 전체 성능 영향을 줄일 수 있다.\n데이터 분산 및 핫스팟 대응 파티셔닝/샤딩으로 쓰기 부담을 분산하되 샤드키·파티션 전략을 접근 패턴에 맞춰 설계해야 한다.\n핫스팟은 키 재설계, 라운드로빈·해시 기반 분배, 리밸런싱으로 완화한다.\n모니터링으로 핫스팟을 조기 발견해야 한다.\n운영·재시도·모니터링 전략 충돌 감지 시 애플리케이션 레벨 재시도 (지수 백오프), 충돌률·재시도 횟수 모니터링, 자동 리밸런싱 정책을 운영에 포함한다.\nJepsen 스타일 동시성 테스트로 검증하면 믿을 만한 안정성을 확보할 수 있다.\n성능·확장성 통합 실행표 카테고리 핵심 기법 목적 (무엇을 해결) 실무 적용 포인트 A 트랜잭션 단축 원자적 UPDATE, 트랜잭션 범위 최소화 락 시간·충돌 창 감소 외부 I/O 분리, 가능한 연산을 SQL 로 옮김. B 동시성 제어 SELECT FOR UPDATE, 낙관적 버전, 동적 격리 충돌 예방/탐지·성능 균형 충돌 빈도 기반 전략 선택, 재시도 정책 필요. C 분산 구조 파티셔닝/샤딩, 샤드키 설계 핫스팟 완화·수평 확장 샤드키 분석, 리밸런싱·모니터링 중요. D 운영·재시도 재시도 (백오프), 충돌 모니터링, 테스트 일시적 충돌 자동 복구 지표 (충돌률) 기준 경보·Jepsen 스타일 검증. 핵심 방식은 ’ 충돌을 구조적으로 줄이기 (A/C)’, ’ 충돌 발생 시 자동 복구 (B/D)’, ’ 부하 분산으로 근본 원인 제거 (C)’ 세 축으로 이해하면 된다. Lost Update 문제 해결 (탐지·대응·예방) Lost Update 문제는 여러 트랜잭션이 같은 데이터를 동시에 읽어 업데이트할 때 한쪽 변경이 덮여 사라지는 현상이다.\n우선 원자적 SQL(예: UPDATE … SET v = v + 1) 로 애플리케이션 RMW 를 제거하고, 충돌이 적으면 낙관적 락 (버전 비교 + 재시도), 충돌이 잦거나 핫스팟이면 비관적 락 (SELECT … FOR UPDATE) 을 사용한다.\n운영에서는 충돌률·재시도율·락 대기시간을 모니터링하고 재시도 정책 (지수적 백오프·멱등성) 을 명확히 설계해야 문제를 안정적으로 제어할 수 있다.\nLost Update 트러블슈팅 분류 탐지 (Detection) 동시성 이상을 빠르게 감지하는 단계.\n핵심 행동: 슬로우 쿼리, 트랜잭션 롱런, 락 보유 보고서, 애플리케이션 예외 집계 확인.\n진단 쿼리 (실무 예시):\nPostgreSQL: SELECT pid, query, state, now() - query_start AS duration FROM pg_stat_activity WHERE state \u003c\u003e 'idle'; PostgreSQL 락: SELECT * FROM pg_locks l JOIN pg_stat_activity a ON l.pid = a.pid; MySQL: SHOW PROCESSLIST; SHOW ENGINE INNODB STATUS; 지표: 충돌률 (%), 평균 락 대기 (ms), 트랜잭션 95/99 백분위 지연, 리플리카 지연 (ms)\n탐지 항목 증상 점검 방법 우선 알람 기준 트랜잭션 롱런 트랜잭션 실행 시간이 정상보다 큼 DB 트랜잭션 뷰 쿼리 (위 예시) p95 트랜잭션 \u003e 5s 락 보유 특정 세션이 락을 오래 가짐 pg_locks / INNODB STATUS 락 보유 \u003e 2s 충돌 예외 애플리케이션에서 version 충돌 예외 애플리케이션 로그 집계 충돌률 \u003e 0.5% 리플리카 지연 읽기 복제본 지연 replica status 조회 지연 \u003e 200ms 요약: 탐지는 DB·애플리케이션 로그와 실시간 지표를 결합해 조기 경보를 만들고, 문제 발생 시 즉시 원인 범위를 좁힌다. 즉시 대응 (Immediate Remediation) 현장 첫 대응 절차 (서비스 영향 최소화 목적).\n절차:\n영향을 받는 트랜잭션/세션 식별 위험 트랜잭션 강제 롤백 또는 타임아웃 설정 세션 단위로 세션 읽기 강제 (master read) 또는 트래픽 셰이드 오프 임시로 핵심 경로의 격리 수준 상향 (단기). 권장 우선순위: 트랜잭션 범위 축소 → 원자적 SQL 적용 (가능 시) → 재시도 정책 활성화\n대응 단계 행동 효과 검증 식별 문제가 되는 세션/쿼리 찾기 영향 범위 확인 세션 종료 후 시스템 정상화 여부 롤백/타임아웃 세션 강제 종료 또는 타임아웃 단축 즉시 락 해제 락 해제 로그 확인 읽기 강제 리플리카 대신 마스터에서 읽기 스테일 리드 제거 일관성 확인 임시 격리 변경 특정 경로에만 Serializable 적용 일관성 확보 성공적 커밋율 확인 요약: 즉시 대응은 운영 중단을 최소화하면서 일관성 확보를 목표로 한다. 근본 해결 전 임시 조치로 사용한다. 근본 해결 (Root-cause Fixes) 재발 방지를 위한 설계/코드 수정.\n기술 옵션:\n원자적 SQL: 가능한 연산은 DB 에서 처리. 낙관적 락: version 컬럼 + 애플리케이션 재시도 (지수적 백오프). 비관적 락: 핫스팟이 명확한 경우에만 사용. 격리 수준 조정: 핵심 트랜잭션에만 Serializable 적용. 아키텍처 변경: CQRS, 이벤트 소싱, 단일 라이터 패턴 (샤드별). 구현 체크리스트: 멱등성, 최대 재시도 횟수, 지수 백오프, 트랜잭션 시간 단축, 인덱스 최적화\n해결책 적용 조건 장점 단점/비고 원자적 SQL 연산이 DB 로 표현 가능할 때 단순·성능 우수 복잡 로직 한계 낙관적 락 충돌 빈도 낮음 락 없음·읽기 성능 우수 재시도 로직 필요 비관적 락 핫스팟 존재 시 충돌 회피 확실 락 대기·데드락 위험 아키텍처 변경 복잡 일관성 요구 근본적 스케일·일관성 개선 구현 비용 큼 요약: 근본 해결은 서비스 요구 (성능·일관성) 에 따라 적절한 방식으로 선택·혼합해야 하며, 멱등성·재시도 설계가 중요하다. 운영·예방 (Operational \u0026 Prevention) 장기적 안정화를 위한 모니터링·정책·테스트.\n핵심 요소: 충돌률·재시도율 알림, 락 대기 임계값 알림, 리플리카 지연 경고, 정기적 재현 테스트 (부하·카오스).\n자동화: 자동 재시도 엔진 (재시도 제한·백오프), 운영 runbook(발생 시 체크리스트), 데드락 자동 탐지·알림.\n항목 지표 알람 임계값 예시 운영 조치 충돌률 충돌 예외 수 / 트랜잭션 수 \u003e 0.5% 경고 우선순위 분석, 코드·쿼리 점검 재시도율 재시도 이벤트 비율 \u003e 2% 경고 백오프 조정, 재시도 한도 설정 락 대기 평균 락 대기 (ms) p95 \u003e 2000ms 트랜잭션 분해, 인덱스 점검 리플리카 지연 초 단위 지연 \u003e 0.2s 경고 세션 고정, 복제 토폴로지 점검 요약: 운영은 탐지→대응→근본 해결 사이클을 자동화·측정화하여 재발을 줄이는 것이 목표다. Lost Update 종합 트러블슈팅 표 카테고리 핵심 목표 주요 행동 주요 지표/검증 탐지 조기 인지 슬로우 쿼리/락 뷰/충돌 예외 집계 충돌률, 락 대기, 트랜잭션 p95 즉시 대응 서비스 영향 최소화 세션 롤백/타임아웃, 마스터 읽기 강제 락 해제 여부, 정상 커밋율 근본 해결 재발 방지 원자적 SQL, 낙관·비관적 락, 아키텍처 변경 재시도율, 충돌률 감소 운영·예방 장기 안정화 모니터링/알람, 카오스 테스트, 자동화 알람 빈도 감소, 회귀 테스트 통과율 최종 정리 및 학습 가이드 내용 종합 Lost Update 는 트랜잭션 동시성 제어에서 자주 마주치는 일관성 오류다.\n문제의 핵심은 트랜잭션이 ’ 읽기 → 애플리케이션 계산 → 쓰기 ’ 의 흐름을 가질 때, 계산에 쓰인 입력이 이미 다른 트랜잭션에 의해 변경될 수 있다는 점이다.\n초기 DBMS 는 락 (비관적) 으로 강하게 막았고, 이후 성능을 위해 낙관적 기법과 MVCC 가 도입됐다.\nMVCC 는 읽기 성능을 개선하지만, 쓰기 - 쓰기 충돌을 엔진이 어떻게 처리하느냐에 따라 Lost Update 가 여전히 발생할 수 있다.\n그래서 실무에서는 가능한 연산을 DB 에서 원자적으로 처리하고 (예: UPDATE … SET x = x - 1 WHERE x \u003e 0), 충돌이 드물면 버전 기반 낙관적 재시도 패턴을 채택하며, 충돌이 잦거나 순서 보장이 필수적이면 비관적 락 또는 Serializable 과 같은 강한 격리 수준을 선택한다.\n관찰·운영 측면에서는 락 대기·데드락·재시도 실패율·장기 트랜잭션·핫로우를 모니터링하고, 로그·트레이스와 결합해 근본 원인을 규명하는 것이 효과적인 관리의 핵심이다.\n분산 환경에서는 추가로 타임스탬프 분배, 2PC, 이벤트 드리븐 아키텍처 같은 설계적 선택이 필요하다.\n실무 적용 가이드 체크리스트 항목 목적 구체적 조치 (예시) 참고/비고 갱신 경로에 상수 UPDATE 존재 여부 점검 불필요한 덮어쓰기 제거 코드 리뷰로 고정 UPDATE 제거, 데이터 흐름 리팩토링 고정값 덮어쓰기 주의 ORM 낙관 잠금 활성화 충돌 감지 (낙관적) JPA @Version, SQLAlchemy version_id_col 설정 및 예외 처리 로직 구현. 충돌 잦으면 성능 고려 재시도·멱등 구현 네트워크/분산 실패 안전화 Idempotency key 저장 (데이터베이스/캐시), 재시도 백오프·한계 구현. 외부 API 포함 시 필수 격리 레벨·락 정책 문서화 일관성·운영 예측성 확보 DB 별 격리 특징 문서화 (예: PostgreSQL Serializable 등), 업무별 권장 격리 적용. 운영 정책으로 고정 핵심 테이블에 FOR UPDATE 적용 덮어쓰기 방지 (단일 DB 환경) 트랜잭션에서 SELECT … FOR UPDATE 로 행 선점 후 빠르게 업데이트 커밋. 분산 샤딩 환경 신중 적용 데드락/타임아웃 정책 시스템 안정성 확보 트랜잭션 타임아웃 설정, 데드락 감지 시 재시도 전략 복구 시나리오 필요 모니터링 지표 설정 조기 경고·운영 대응 충돌률, 재시도율, 롱 트랜잭션 비율, 데드락 카운트 대시보드 구성 SIEM/모니터 통합 권장 테스트 케이스 (동시성) 포함 재현·검증 용이성 확보 멀티클라이언트 동시성 테스트 스크립트 작성·자동화 CI 파이프라인 연계 권장 학습 로드맵 Phase 핵심 목표 핵심 주제 (예시) 학습 목표 실무 연관성 권장 학습 방식 1 기초 Lost Update 의 원인·정의 이해 트랜잭션·ACID·격리 수준·이상 유형 개념 숙지, 사례 분석 매우 높음 읽기 + 짧은 실습 (트랜잭션 실험) 2 핵심 방지 기법의 원리 이해·선택 기준 습득 원자적 SQL, 비관적 락, 낙관적 버전, MVCC 기법별 트레이드오프 판단 높음 실습 (쿼리·잠금·버전 구현) 3 응용 프레임워크·운영 적용 능력 ORM 동작, 메시징, 캐시 일관성, 재시도 정책 코드·운영 적용, 테스트 설계 중간~높음 프로젝트형 실습, 통합 테스트 4 고급 분산·확장 아키텍처 설계·검증 샤딩·파티셔닝, 분산 락, 2PC/Saga, CRDT, Jepsen 설계·검증·모니터링 능력 높음 (대규모) 아키텍처 실습, 스트레스·Jepsen 테스트 학습 항목 정리 Phase 항목 (세부) 중요도 학습 목표 실무 연관성 설명 / 실습 제안 1 트랜잭션과 ACID 필수 트랜잭션 기본 이해 매우 높음 BEGIN/COMMIT/ROLLBACK 실습 1 격리 수준 \u0026 이상 유형 필수 Read Committed 등과 Lost Update 관계 이해 매우 높음 4 가지 이상 (Dirty/Non-repeatable/Phantom/Lost Update) 재현 실습 2 원자적 UPDATE 패턴 필수 산술 갱신을 안전하게 처리 높음 UPDATE t SET v = v +? 실험 2 비관적 락 (FOR UPDATE) 필수 선점 방식의 장단점 습득 높음 동시성 시나리오로 교착/대기 관찰 2 낙관적 버저닝 필수 버전 비교·재시도 패턴 설계 높음 version 컬럼 + UPDATE WHERE version=? 구현 2 MVCC 내부 개념 권장 스냅샷·커밋 타이밍 이해 중간 PostgreSQL/InnoDB 행동 비교 실습 3 ORM 과 락/버저닝 연동 권장 프레임워크 계층의 동작 이해 중간 Hibernate/JPA 예제 적용 3 메시지 기반 처리·Sagas 권장 비동기 워크플로우로 트랜잭션 분해 중간 간단한 SAGA 설계·시뮬레이션 3 캐시 일관성 전략 권장 캐시 무효화/쓰기 전략 이해 중간 read-through/write-through 패턴 실습 3 재시도 정책·백오프 필수 충돌시 자동 복구 설계 높음 지수 백오프 구현·테스트 4 파티셔닝·샤딩 설계 필수 샤드키·리밸런싱 고려 높음 샤딩 시뮬레이션, 핫스팟 재현 4 분산 락·2PC·Sagas 권장 분산 일관성 패턴 이해 높음 분산 트랜잭션 시나리오 분석 4 SSI/Serializable 내부 권장 격리 수준의 내부 동작 파악 중간~높음 실패 시나리오 (Serialization failure) 실험 4 CRDT·Event Sourcing 선택 충돌 허용·수렴 모델 이해 중간 간단한 CRDT 예제 구현 4 동시성 검증 (Jepsen) 권장 시스템 검증·문제 노출 능력 매우 높음 Jepsen 스타일 테스트·블랙박스 검증 4 모니터링 지표 설계 필수 충돌률·재시도율 등 지표 정의 높음 Grafana/Prometheus 대시보드 설계 용어 정리 카테고리 용어 (한글 (영어 풀네임, 약어)) 정의 관련 개념 실무 활용 핵심 갱신 손실 (Lost Update) 동시 트랜잭션이 동일 행을 읽어 각각 갱신할 때, 한쪽의 변경이 나중 커밋에 의해 덮여 일부 변경이 소실되는 현상 동시성 제어, RMW, LWW 장애 원인 진단, 대응 전략 (원자적 SQL/락/버전) 결정 핵심 읽기 - 수정 - 쓰기 패턴 (Read-Modify-Write, RMW) 애플리케이션이 먼저 읽고 계산한 뒤 쓰는 순서의 패턴—Lost Update 취약점의 대표적 원인 원자적 UPDATE, 낙관적/비관적 락 가능하면 DB 원자 연산으로 대체 핵심 격리 수준 (Isolation Level) 트랜잭션 간 상호작용 규칙 (예: Read Committed, Repeatable Read, Serializable) 스냅샷 격리, SSI 일관성 요구에 따라 적절한 격리 설정 구현 원자적 갱신 (Atomic Update) DB 내부에서 읽기·계산·쓰기를 단일 연산으로 수행하는 패턴 (UPDATE … SET v = v + 1) RMW 회피, SQL 원자성 카운터·증감 연산 등 간단 연산에 최우선 적용 구현 비관적 잠금 (Pessimistic Lock) / 명시적 락 (Explicit Lock) SELECT … FOR UPDATE 등으로 먼저 락을 획득해 다른 트랜잭션 접근 차단 Row Lock, Deadlock 핫스팟·중요 자원 보호에 사용 (단, 락 대기/데드락 모니터링 필수) 구현 낙관적 잠금 (Optimistic Lock) 버전/타임스탬프 비교로 충돌을 감지, 실패 시 재시도 버전 컬럼, ORM @Version 충돌 낮은 환경에서 효율적—재시도·멱등성 설계 필요 구현 MVCC (Multi-Version Concurrency Control) 트랜잭션별 스냅샷 (버전) 을 제공해 읽기와 쓰기를 분리하는 동시성 제어 Snapshot Isolation, SSI 읽기 성능 우수, RMW 취약 케이스 주의 구현 스냅샷 격리 (Snapshot Isolation) MVCC 방식의 읽기 일관성 모델—특정 상황에서 Lost Update/Write Skew 에 취약 MVCC, Write Skew DB 별 구현 차이로 테스트 필요 구현 SSI (Serializable Snapshot Isolation, SSI) 스냅샷 기반으로 직렬화 보장을 제공하는 기법 (충돌 탐지·Abort) Serializable, MVCC 금융·원장 등 강한 일관성 경로에 사용 (성능 영향 고려) 운영 재시도 및 백오프 (Retry \u0026 Backoff) 충돌 시 재시도 전략, 보통 지수적 백오프와 재시도 한도 적용 멱등성, 재시도 폭주 방지 낙관적 잠금 사용 시 필수—재시도 횟수·백오프 정책 설계 운영 멱등성 (Idempotency) 동일 요청을 여러 번 실행해도 결과가 동일하도록 보장하는 특성 재시도, 메시지 처리 재시도 로직 설계 시 핵심 (특히 외부 API/결제) 운영 복제 지연 (Replication lag) 비동기 복제에서 쓰기→읽기 일관성 지연이 발생하는 시간 읽기/쓰기 분리, 스테일 리드 읽기 리플리카 이용 시 세션 고정 또는 마스터 읽기 권장 운영 충돌률 (Conflict rate) 일정 기간 내 충돌 (재시도/예외) 발생 비율 재시도율, 트랜잭션 실패 모니터링 지표로 알람·개선 우선순위 결정 아키텍처·패턴 CQRS (Command Query Responsibility Segregation) 쓰기 (명령) 와 읽기 (조회) 를 분리해 일관성/확장성 문제 완화 이벤트 소싱, 단일 라이터 복잡 도메인에서 일관성 처리 전략으로 사용 아키텍처·패턴 이벤트 소싱 (Event Sourcing) 상태를 이벤트 로그로 기록하고 재구성하는 패턴 CQRS, 멱등성 복잡 충돌 회피·감사 추적에 유리 보조 LWW (Last Write Wins) 마지막 쓰기를 우선으로 하는 정책 (의도치 않게 데이터 손실 유발 가능) 덮어쓰기 정책 설계 시 주의—데이터 손실 허용되는 영역에서만 사용 참고 및 출처 PostgreSQL Documentation — Explicit Locking / Transaction Isolation / Serializable MySQL Reference Manual — InnoDB Locking and Transaction Model Microsoft SQL Docs — Transaction Isolation Levels / Optimistic Concurrency Oracle Documentation — Data Concurrency and Consistency 트랜잭션 격리 수준 완벽 가이드 (notavoid.tistory) PostgreSQL, MySQL 에서의 Lost update 대처 방안 (2tsumo-hitori.tistory) Lost update와 serializable (mirrorofcode.tistory) MVCC (Multiversion Concurrency Control) (kyoulho.tistory) 낙관적 락, 비관적 락 - 동시성 제어 (techforme.tistory) 데이터베이스 동시성 문제와 ANSI SQL 표준화 (blog.xiyo.dev) ","wordCount":"9244","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-09-12T03:49:00Z","dateModified":"2025-09-12T03:49:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Lost Update</h1><div class=post-description>로스트 업데이트는 여러 트랜잭션이 동일 데이터를 동시 수정할 때 읽기→수정→쓰기 과정의 비원자성으로 인해 한 트랜잭션의 변경이 다른 트랜잭션에 의해 덮어써지는 현상이다. 원자적 SQL, 잠금(선점적), 낙관적 버저닝, 직렬화 등으로 예방한다.</div><div class=post-meta><span title='2025-09-12 03:49:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;44 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20&%20Database%20Systems/Data%20Operations/Transaction%20Management/Transaction/Transaction%20Isolation/Concurrency%20Anomalies/lost-update.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#lost-update>Lost Update</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#기초-조사-및-개념-정립>기초 조사 및 개념 정립</a></li><li><a href=#핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반</a></li><li><a href=#특성-분석-및-평가>특성 분석 및 평가</a></li><li><a href=#실무-적용-및-사례>실무 적용 및 사례</a></li><li><a href=#phase-6-운영-및-최적화>Phase 6: 운영 및 최적화</a></li></ul></li><li><a href=#최종-정리-및-학습-가이드>최종 정리 및 학습 가이드</a><ul><li><a href=#내용-종합>내용 종합</a></li><li><a href=#실무-적용-가이드>실무 적용 가이드</a></li><li><a href=#학습-로드맵>학습 로드맵</a></li><li><a href=#학습-항목-정리>학습 항목 정리</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=lost-update>Lost Update<a hidden class=anchor aria-hidden=true href=#lost-update>#</a></h2><p>Lost Update 는 여러 트랜잭션이 같은 행을 동시에 읽어 수정할 때 한쪽 갱신이 나중 갱신에 의해 덮여 사라지는 현상이다.<br>MVCC(스냅샷) 는 일부 읽기 문제를 막지만, 클라이언트 측에서 Read–Modify–Write 패턴을 쓰면 여전히 발생할 수 있다.<br>실무 대응은</p><ol><li>가능한 경우 <code>UPDATE … SET v = v + 1</code> 처럼 <strong>원자적 SQL</strong> 사용</li><li>충돌이 잦지 않으면 <strong>낙관적 잠금</strong>(버전/타임스탬프 비교) 으로 충돌 감지 후 재시도</li><li>핫스팟엔 <strong>비관적 잠금</strong>(<code>SELECT … FOR UPDATE</code>) 사용</li><li>강제 일관성이 필요하면 DBMS 의 <strong>Serializable/SSI</strong> 선택이다</li></ol><p>운영에서는 충돌률·재시도율·락 대기 시간을 관측하고 재시도·백오프 정책을 설계해야 한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><table><thead><tr><th>개념 (한글·약어)</th><th style=text-align:right>정의</th><th>왜 중요한가</th><th>실무 적용 예</th></tr></thead><tbody><tr><td>트랜잭션 (Transaction)</td><td style=text-align:right>작업의 원자적 묶음 (ACID)</td><td>부분 적용 방지, 일관성 유지</td><td>DB 트랜잭션 블록 (BEGIN/COMMIT)</td></tr><tr><td>격리 (Isolation)</td><td style=text-align:right>동시 트랜잭션 간 상호제한 수준</td><td>정합성 vs 성능 트레이드오프</td><td>Read Committed / Serializable 선택</td></tr><tr><td>동시성 제어 (Concurrency Control)</td><td style=text-align:right>충돌 방지 정책 (락/MVCC 등)</td><td>데이터 무결성 보장</td><td>Lock manager, MVCC 구현</td></tr><tr><td>MVCC (다중 버전)</td><td style=text-align:right>데이터의 여러 버전으로 읽기 제공</td><td>읽기 성능 향상, 교착 위험 완화</td><td>Snapshot 기반 읽기</td></tr><tr><td>잠금 (Locking)</td><td style=text-align:right>자원 접근 권한 제어</td><td>동시 쓰기 충돌 직접 방지</td><td>행 잠금, 테이블 잠금</td></tr><tr><td>로스트 업데이트 (Lost Update)</td><td style=text-align:right>갱신 덮어쓰기 현상</td><td>핵심 데이터 손상 가능</td><td>카운터/잔액 오류</td></tr><tr><td>비관적 잠금 (Pessimistic Lock)</td><td style=text-align:right>미리 잠금으로 충돌 차단</td><td>충돌 빈도↑ 안정성↑</td><td>SELECT … FOR UPDATE</td></tr><tr><td>낙관적 잠금 (Optimistic Lock)</td><td style=text-align:right>커밋 시 버전 비교로 충돌 판별</td><td>성능 유리, 재시도 필요</td><td>version 컬럼 + WHERE version=?</td></tr><tr><td>직렬화 (Serializable)</td><td style=text-align:right>직렬 실행과 동등한 결과 보장</td><td>최고 수준의 정합성</td><td>Serializable 격리 설정</td></tr><tr><td>아이덤포턴시 (Idempotency)</td><td style=text-align:right>중복 요청해도 동일 결과</td><td>재시도 안전성 확보</td><td>idempotency key 사용</td></tr></tbody></table><ul><li><strong>트랜잭션·격리·동시성 제어</strong>가 Lost Update 문제의 근본 구조.</li><li><strong>비관적 vs 낙관적</strong>은 충돌 빈도와 성능 요구로 선택.</li><li><strong>실무 적용</strong>은 DBMS 특성·비즈니스 중요도 (돈·재고</li></ul><h4 id=개념-간-상호관계표>개념 간 상호관계표<a hidden class=anchor aria-hidden=true href=#개념-간-상호관계표>#</a></h4><table><thead><tr><th>출발 개념 → 대상 개념</th><th>방향성 (무엇을 위해)</th><th>관계 설명 (요약)</th></tr></thead><tbody><tr><td>트랜잭션 → 격리 수준</td><td>트랜잭션의 동시성 보호를 위해</td><td>트랜잭션은 격리 수준을 통해 다른 트랜잭션과의 간섭 범위를 규정</td></tr><tr><td>격리 수준 → 동시성 제어</td><td>규칙을 실현하기 위해</td><td>특정 격리 수준은 락/MVCC 같은 메커니즘으로 구현됨</td></tr><tr><td>동시성 제어 → 잠금/MVCC</td><td>충돌을 실제로 제어하기 위해</td><td>락은 직관적 차단, MVCC 는 버전 기반 읽기 일관성 제공</td></tr><tr><td>잠금/MVCC → Lost Update</td><td>예방 또는 허용 (구현의존)</td><td>적절한 락/충돌검출 없으면 Lost Update 발생</td></tr><tr><td>낙관적 잠금 → 애플리케이션 재시도</td><td>충돌시 정합 복구 위해</td><td>충돌 감지 후 재시도/사용자 피드백 루틴 필요</td></tr><tr><td>분산 시스템 → 아이덤포턴시</td><td>메시지/재시도 안전성 위해</td><td>네트워크 실패·중복 전송 환경에서 정합 유지</td></tr></tbody></table><ul><li><strong>방향성 포인트</strong>: 상위 개념 (트랜잭션/격리) 이 정책을 규정하고, 하위 메커니즘 (락/MVCC/버전) 이 이를 실현. 실무적으로는 이 방향을 따라 &rsquo; 정책 선택 → 메커니즘 적용 → 보완 (재시도/아이덤포턴시)&rsquo; 의 흐름으로 설계한다.</li></ul><p>상호관계 (개념 맵):</p><pre class=mermaid>flowchart LR
  A[Transaction] --&gt; B[Isolation]
  B --&gt; C[Concurrency Control]
  C --&gt; D[Locking]
  C --&gt; E[MVCC]
  B --&gt; F[Anomalies]
  F --&gt; G[Lost Update]
  G --&gt; H[Prevention]
  H --&gt; H1[Atomic Update]
  H --&gt; H2[Pessimistic Lock]
  H --&gt; H3[Optimistic Lock]
  H --&gt; H4[Serializable]
</pre><h4 id=핵심-개념의-실무-연관성>핵심 개념의 실무 연관성<a hidden class=anchor aria-hidden=true href=#핵심-개념의-실무-연관성>#</a></h4><table><thead><tr><th>개념</th><th style=text-align:right>실무에서 무엇 (무엇을 다루는가)</th><th>어떻게 (적용 방식)</th><th>왜 (리스크/이점)</th><th>구현 예 (기술·패턴)</th></tr></thead><tbody><tr><td>Lost Update</td><td style=text-align:right>동시 갱신으로 인한 덮어쓰기</td><td>충돌검출 또는 잠금 적용</td><td>정합성 확보 (중요) / 성능 저하 가능</td><td>버전검사, FOR UPDATE</td></tr><tr><td>비관적 잠금</td><td style=text-align:right>충돌 높은 작업의 안전성 보장</td><td>행 단위 잠금 후 갱신</td><td>안정성↑, 동시성↓</td><td>SELECT … FOR UPDATE</td></tr><tr><td>낙관적 잠금</td><td style=text-align:right>충돌 적은 작업에 적합</td><td>버전비교 → 실패 시 재시도</td><td>확장성↑, 재시도 로직 필요</td><td>version 컬럼 + UPDATE WHERE</td></tr><tr><td>조건부 UPDATE</td><td style=text-align:right>원자적 계산을 DB 에서 실행</td><td><code>UPDATE t SET v = v +? WHERE id=?</code></td><td>원자성 확보, 네트워크 왕복 최소</td><td>SQL 단일 문장</td></tr><tr><td>아이덤포턴시</td><td style=text-align:right>재시도 안전성 보장</td><td>idempotency-key + 저장</td><td>재시도시 중복 방지</td><td>idempotency key 저장소</td></tr><tr><td>분산 트랜잭션</td><td style=text-align:right>여러 노드/서비스 간 정합</td><td>2PC / Saga 패턴</td><td>복잡성↑ / 일관성 확보 수단</td><td>Saga(보상), 2PC(동기)</td></tr></tbody></table><ul><li>성능·정합성·충돌확률을 기준으로 적절한 기법을 선택. 단일 DB 환경에선 조건부 UPDATE 나 버전검사로 충분한 경우가 많고, 분산 환경에선 Saga·아이덤포턴시와 같은 추가 패턴이 필수적이다.</li></ul><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=갱신-손실-lost-update-의-본질과-대응원리>갱신 손실 (Lost Update) 의 본질과 대응원리<a hidden class=anchor aria-hidden=true href=#갱신-손실-lost-update-의-본질과-대응원리>#</a></h4><p><strong>갱신 손실 (Lost Update)</strong> 은 동시성 환경에서 두 개 이상의 트랜잭션이 동일한 데이터 항목을 읽은 뒤 각각 수정해 저장할 때, <strong>나중에 커밋된 쓰기 (Last Write) 가 먼저 커밋된 쓰기를 덮어써서</strong> 앞선 변경이 데이터베이스에서 사라지는 현상이다.<br>실무에서는 다음 특징으로 파악된다.</p><ul><li><strong>본질</strong>: 읽기 시점의 값을 기반으로 수정하는 로직이 여러 트랜잭션에서 겹치면, 커밋 순서에 따라 일부 변경이 유실된다. 이는 데이터 무결성·비즈니스 규칙 위배로 이어진다.</li><li><strong>재현 시퀀스 (간단)</strong>: 두 트랜잭션이 같은 초기값을 읽고, 서로 다른 값을 저장 → 마지막 커밋이 최종 값이 되는 패턴.</li><li><strong>근본적 해결 방향</strong>: <em>동시성 제어를 통해 " 동일 데이터에 대한 경쟁적 수정 " 을 감지하거나 차단</em>하는 것 (락, 버전 비교, 표준 격리 수준 활용 등). 각 기법은 성능·확장성·복잡도 측면에서 상충하므로 시스템 요구 (충돌 빈도·응답성·스루풋) 에 따라 선택해야 한다.</li></ul><h4 id=lost-update-발생진화실무-대응>Lost Update: 발생·진화·실무 대응<a hidden class=anchor aria-hidden=true href=#lost-update-발생진화실무-대응>#</a></h4><p>Lost Update 는 <strong>두 사람이 같은 값을 동시에 읽어 수정할 때</strong>, 마지막으로 쓴 쪽만 남아 앞선 수정이 사라지는 문제이다.</p><p>예를 들어:<br>재고가 5 일 때 A 와 B 가 동시에 읽어 A 는 -1, B 는 -2 를 계산해 각각 업데이트하면, 둘 중 마지막 커밋만 반영돼 한 변경이 손실된다.</p><p>초기 DB 는 락으로 막았지만 락은 성능을 저하시켜서 MVCC(여러 버전 저장) 나 낙관적 제어 같은 접근이 생겼다.<br>그런데 MVCC 도 설정이나 충돌 감지 없이는 lost update 를 완전히 막지 못한다. 그래서 시스템은 <strong>충돌 검출</strong>이나 <strong>격리 수준</strong>, 또는 애플리케이션 레벨의 조건부 업데이트 같은 보완책을 함께 쓴다.</p><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>동시성 환경에서 데이터 무결성을 지키려는 요구가 커지면서 Lost Update 문제가 부각되었다. 초기 DBMS 는 **단일 버전 + 잠금 (락)**으로 동시 접근을 통제했지만, 읽기·쓰기 동시성 증가로 락 경합과 성능 저하가 심해졌다. 이를 해결하려 **낙관적 접근 (OCC)**과 **다중 버전 (MVCC)**이 도입되었고, 이들 기술은 읽기와 쓰기를 분리하거나 커밋 시 충돌을 검증함으로써 성능을 올렸다. 그러나 MVCC 나 낮은 격리 수준은 설정에 따라 lost update 를 여전히 허용할 수 있어, 제품/구현별로 추가적인 쓰기 - 쓰기 충돌 검출이나 격리 강화가 필요하게 되었다. (<a href="https://www.alibabacloud.com/blog/a-deep-dive-into-database-concurrency-control_596779?utm_source=chatgpt.com" title="A Deep Dive into Database Concurrency Control">Alibaba Cloud</a>)</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th>단계 (시기·개념)</th><th style=text-align:right>핵심 아이디어</th><th>Lost Update 에 대한 영향 (장단점)</th><th>개선 포인트</th></tr></thead><tbody><tr><td>1. 단일버전 락 (초기)</td><td style=text-align:right>읽기/쓰기 시 락으로 배타적 접근</td><td><strong>완전 방지</strong>하지만 성능 저하·교착 우려</td><td>병목과 락 경합 완화 필요</td></tr><tr><td>2. 2PL(엄격 2-Phase Locking)</td><td style=text-align:right>트랜잭션 전반에 락 유지로 직렬화 보장</td><td>일관성 보장, 하지만 확장성 한계</td><td>락 최소화·락 지속시간 관리</td></tr><tr><td>3. 낙관적 동시성 제어 (OCC)</td><td style=text-align:right>작업 후 검증으로 충돌 감지·재시도</td><td>락 감소, 충돌 시 재시도 비용 발생</td><td>충돌률 낮은 워크로드에 효과적</td></tr><tr><td>4. MVCC (Snapshot)</td><td style=text-align:right>읽기는 스냅샷 사용, 쓰기는 새 버전 생성</td><td>읽기 - 쓰기 충돌 완화, 그러나 쓰기 - 쓰기 충돌 관리 필요</td><td>write-conflict 감지/격리 설정 추가</td></tr><tr><td>5. Snapshot Isolation(SI)</td><td style=text-align:right>트랜잭션별 일관된 스냅샷 보장, 특정 이상 방지</td><td>Lost Update 유형 회피 가능, 그러나 기타 이상 (예: write skew) 존재</td><td>SI 강화 또는 serializable 로 보완</td></tr><tr><td>6. Serializable/고급 CC</td><td style=text-align:right>완전 직렬화 보장 (검증 또는 강한 락)</td><td>모든 이상 차단, 성능·복잡도 비용</td><td>성능 최적화, 병렬성 확보 연구</td></tr><tr><td>7. 애플리케이션 패턴 개선</td><td style=text-align:right>조건부 UPDATE, 서버측 계산, 버전 비교</td><td>클라이언트 - 사이드 계산 문제 완화</td><td>디자인 패턴·계약으로 안전성 확보</td></tr></tbody></table><pre class=mermaid>timeline
    title Lost Update의 발전 타임라인
    1970s : 락 기반 DB와 직렬화(초기 DBMS)
    1980s : 2PL과 전통적 동시성 제어 정착
    1980s-1990s : 낙관적 동시성(OCC) 연구·도입
    1980s-2000s : MVCC 개념 등장·실무화
    1995 : &#34;ANSI SQL 격리 수준&#34; 비판 및 Snapshot Isolation 정의(관련 논문)
    2000s- : SI·MVCC 상호작용 및 write-conflict 연구
    2010s- : 고성능 MVCC/Serializable 기법(메인메모리 DB 등)
    2020s- : 분산·레이크하우스 환경에서의 CC 재설계 (경량 충돌관리 등)
</pre><p>Lost Update 는 동시 수정 시 <strong>한 쪽의 변경이 덮여 사라지는 문제</strong>로, 초기 락 기반 설계에서 시작해 성능 문제로 인해 낙관적 제어와 MVCC 같은 접근이 등장했다.<br>MVCC 는 읽기 성능을 크게 개선했지만, 쓰기 - 쓰기 충돌을 제대로 통제하지 않으면 여전히 업데이트 손실이 발생할 수 있다.<br>Snapshot Isolation 은 lost update 유형의 이상을 막는 성질이 있어 널리 주목받았으나, 그 자체로 모든 이상을 제거하지는 못한다.<br>따라서 실전에서는 **충돌 검출 (데이터베이스 레벨)**과 **애플리케이션 레벨 설계 (조건부 업데이트, 서버측 계산 등)**을 함께 조합해 안정성을 확보한다.</p><h4 id=lost-update-예방보장-전략-총괄>Lost Update 예방·보장 전략 총괄<a hidden class=anchor aria-hidden=true href=#lost-update-예방보장-전략-총괄>#</a></h4><blockquote><p><strong>개념 한줄:</strong> 두 트랜잭션이 같은 데이터를 동시에 갱신하면, 한쪽의 변경이 다른 쪽에 의해 덮어써져 &rsquo; 유효한 갱신이 사라지는 &rsquo; 현상이 <em>Lost Update</em> 이다.</p></blockquote><ol><li><p><strong>왜 문제인가?</strong></p><ul><li>예: 계좌 잔액이 0 일 때, T1 이 +100, T2 가 +200 을 동시에 처리하면 기대값은 300 인데 설계/동작에 따라 100 이나 200 만 남을 수 있음 → 금전적 손실.</li></ul></li><li><p><strong>어떻게 발생하나 (간단 시나리오)</strong></p><ul><li>T1 읽 (balance=0) → T2 읽 (balance=0) → T1 쓰 (balance=100) 커밋 → T2 쓰 (balance=200) 커밋 → 결과 200 (T1 결과 손실).</li></ul></li><li><p><strong>실무적 해결 전략 (비유로 설명)</strong></p><ul><li><strong>비관적 락</strong>: 물건을 집을 때 &rsquo; 잠궈두기 &lsquo;(다른 사람 접근 차단). → 안전하지만 줄 서는 시간이 늘어남.</li><li><strong>낙관적 버전검사</strong>: 물건 위에 포스트잇 (버전) 을 붙여두고 결제할 때 버전이 바뀌었으면 다시 검사·재시도. → 충돌 적으면 빠름.</li><li><strong>격리 수준/DB 정책</strong>: 상점 규칙 (데이터베이스가 자체 규칙으로 충돌을 감지해 후발 커밋을 거부).</li></ul></li><li><p><strong>간단 체크리스트 (초심자용)</strong></p><ul><li>비즈니스상 동시 갱신 위험이 큰가? → 예면 락/버전/격리수준 설계 필요.</li><li>충돌 빈도와 성능 트레이드오프를 비교하라 (낙관적 vs 비관적).</li><li>테스트에서 동시성 케이스를 포함시켜 재현 가능한지 확인.</li></ul></li></ol><h5 id=lost-update-이-야기하는-문제-요약>Lost Update 이 야기하는 문제 요약<a hidden class=anchor aria-hidden=true href=#lost-update-이-야기하는-문제-요약>#</a></h5><table><thead><tr><th>문제 항목</th><th style=text-align:right>핵심 설명</th><th>실무 영향</th><th>검출 방법</th></tr></thead><tbody><tr><td>덮어쓰기 (Overwrite)</td><td style=text-align:right>동시 갱신으로 선행 커밋 내용이 후속 커밋에 의해 덮어짐.</td><td>금전 손실, 재고 오차.</td><td>동시성 테스트, 로그 비교</td></tr><tr><td>불일치 (Inconsistency)</td><td style=text-align:right>기대값 (비즈니스 규칙) 과 DB 상태 불일치.</td><td>규정·회계 오류, 신뢰도 하락.</td><td>무결성 검증, 회계 조정</td></tr><tr><td>재현성 낮음</td><td style=text-align:right>경쟁 상황은 간헐적으로만 발생 → 디버깅 어려움.</td><td>버그 추적 비용 증가.</td><td>스트레스 테스트, 시뮬레이션</td></tr><tr><td>트랜잭션 실패 가능</td><td style=text-align:right>충돌 해결 정책 부족 시 데이터 손실·오류 발생.</td><td>운영 중단/수정 작업 증대.</td><td>트랜잭션 모니터링</td></tr></tbody></table><p>Lost Update 문제는 <strong>동시 갱신이 있을 때 일부 유효한 변경이 사라지는 &rsquo; 덮어쓰기 &rsquo; 현상</strong>을 핵심으로 하며, 그 결과로 재무·재고 등 비즈니스 핵심 값이 왜곡된다. 재현성이 낮아 진단이 힘들고, 운영·법규상 리스크로 이어질 수 있으므로 동시성 테스트와 적절한 제어 (락/버전/격리 수준) 가 필요하다.</p><h5 id=lost-update-방지-핵심-목적>Lost Update 방지 핵심 목적<a hidden class=anchor aria-hidden=true href=#lost-update-방지-핵심-목적>#</a></h5><table><thead><tr><th>핵심 목적</th><th style=text-align:right>설명</th><th>기대 효과</th></tr></thead><tbody><tr><td>모든 유효 갱신 보존</td><td style=text-align:right>충돌 시에도 커밋된 변경이 소실되지 않도록 보장.</td><td>데이터 무결성 보장, 금전적 손실 방지. ([Microsoft][6])</td></tr><tr><td>직관적 일관성 확보</td><td style=text-align:right>사용자가 기대하는 결과와 DB 상태 일치.</td><td>운영·디버깅 편의성 향상.</td></tr><tr><td>경쟁 조건 예방</td><td style=text-align:right>race condition 발생 빈도 저감 (설계/운영 수준).</td><td>시스템 안정성 및 신뢰도 향상.</td></tr></tbody></table><p>핵심 목적은 <strong>데이터가 의도치 않게 덮어써지지 않도록 보장</strong>하는 것과, 이를 통해 비즈니스 관점에서 &rsquo; 예상 가능한 &rsquo; 일관성을 제공하는 데 있다. 이를 위해서는 트랜잭션 설계, 락·버전 전략, DB 격리 정책의 적절한 조합이 필요하다.</p><h5 id=문제와-목적의-연결맵>문제와 목적의 연결맵<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연결맵>#</a></h5><table><thead><tr><th>문제 (원인/증상)</th><th style=text-align:right>직접 대응되는 핵심 목적</th><th>적용 가능한 해결책</th></tr></thead><tbody><tr><td>덮어쓰기 (Overwrite)</td><td style=text-align:right>모든 유효 갱신 보존</td><td>버전검사 (optimistic), first-committer-wins, exclusive lock. ([Microsoft][6])</td></tr><tr><td>불일치 (Inconsistency)</td><td style=text-align:right>직관적 일관성 확보</td><td>Serializable 격리, 검증 로직, 컨플릭트 감지/재시도</td></tr><tr><td>재현성 낮음 (간헐성)</td><td style=text-align:right>경쟁 조건 예방</td><td>스트레스 테스트, 시뮬레이션, 모니터링</td></tr><tr><td>운영적 충돌/데드락 위험</td><td style=text-align:right>안정성·무결성 보장</td><td>데드락 탐지·타임아웃·백오프 전략</td></tr></tbody></table><p>각 문제는 특정 목적과 직접 연계되어 있으며, 해결책은 목표에 맞춰 선택되어야 한다. 예컨대 덮어쓰기를 막는 것이 핵심이라면 버전검사나 first-committer-wins 같은 충돌감지 정책이 우선이고, 전체 시스템 일관성이 최우선이면 Serializable 격리 등이 적절하다. 트레이드오프 (성능 vs 안전) 를 항상 고려해야 한다. ([Microsoft][6])</p><h4 id=동시-갱신-전제와-대응-설계>동시 갱신 전제와 대응 설계<a hidden class=anchor aria-hidden=true href=#동시-갱신-전제와-대응-설계>#</a></h4><p>동시 수정으로 일부 업데이트가 사라지는 문제는 다음이 갖춰질 때 특히 발생한다.</p><ol><li>두 개 이상의 트랜잭션이 같은 행을 읽는다.</li><li>각 트랜잭션이 읽은 값을 기반으로 계산하여 다시 쓴다.</li><li>이 과정이 원자적으로 묶여 있지 않거나 (=격리 불충분), 명시적 잠금을 사용하지 않아 동시성 제어가 되지 않을 때다.</li></ol><p>설계 요구사항은 성능과 일관성의 균형을 맞추는 것이다—짧고 원자적인 갱신은 단일 SQL 로 해결하고, 사용자의 응답 대기가 포함되면 낙관적 버전 검사와 재시도, 엄격한 무결성이 필요하면 높은 격리나 비즈니스 락을 적용한다.</p><h5 id=lost-update-전제요구사항>Lost Update 전제·요구사항<a hidden class=anchor aria-hidden=true href=#lost-update-전제요구사항>#</a></h5><table><thead><tr><th>항목</th><th style=text-align:right>설명</th><th>실무적 근거/영향</th></tr></thead><tbody><tr><td>경쟁 조건 존재 여부</td><td style=text-align:right>동일 Row/Key 에 동시 접근 발생</td><td>로스트업데이트 기본 전제.</td></tr><tr><td>트랜잭션 격리 수준</td><td style=text-align:right>보통 RC 이상에서 문제 발생 빈도 감소 (하지만 DB 별 차이 존재)</td><td>Read Committed 에서 자주 관찰, Serializable·적절한 잠금으로 예방 가능.</td></tr><tr><td>MVCC 유무 및 동작</td><td style=text-align:right>MVCC 는 읽기 스냅샷 제공—쓰기 충돌은 별도 처리 필요</td><td>MVCC 자체만으로는 로스트업데이트를 자동 차단하지 않음.</td></tr><tr><td>트랜잭션 길이 (think-time 포함)</td><td style=text-align:right>긴 트랜잭션/사용자 대기 시 DB 락만으로 해결 어려움</td><td>낙관적 버전·재시도 패턴 권장.</td></tr><tr><td>성능 vs 무결성 요구</td><td style=text-align:right>낮은 지연/높은 동시성 필요 vs 데이터 일관성 보장 요구</td><td>설계 시 트레이드오프로 의사결정 필요.</td></tr><tr><td>권장 대응 패턴</td><td style=text-align:right>원자적 SQL, SELECT FOR UPDATE, 낙관적 버저닝, Serializable</td><td>상황별 장단점 존재 (성능·교착·재시도).</td></tr></tbody></table><p>동일 행을 동시에 읽고 계산해 쓰는 패턴이 있고, 트랜잭션 격리나 잠금이 없으면 로스트 업데이트가 빈발한다.<br>MVCC 는 읽기 성능을 개선하지만 쓰기 충돌 방지는 별도 전략이 필요하다.<br>설계 시 우선으로 고려할 것은</p><ol><li>해당 업데이트를 단일 원자 SQL 로 처리할 수 있는지</li><li>사용자 think-time 이 있어 트랜잭션이 길어지는지</li><li>데이터 무결성의 우선순위에 따라 비관적 잠금·낙관적 버저닝·혹은 높은 격리 선택지를 결정하는 것이다.</li></ol><h4 id=lost-update-원인기술운영-대응-총괄>Lost Update: 원인·기술·운영 대응 총괄<a hidden class=anchor aria-hidden=true href=#lost-update-원인기술운영-대응-총괄>#</a></h4><p>Lost Update 는 여러 사용자가 같은 데이터를 동시에 읽어 수정할 때, 한쪽의 수정이 다른 쪽의 수정으로 덮여 사라지는 문제다.<br>MVCC 나 Repeatable Read 같은 기술이 일부 읽기 문제를 막아도, 클라이언트가 직접 읽고 계산해 쓰는 (Read–Modify–Write) 패턴에서는 여전히 발생 가능하다.<br>해결책은</p><ol><li>가능한 한 DB 의 원자적 문장 (<code>UPDATE … SET v = v + 1</code>) 을 사용해 RMW 를 없애기</li><li>충돌 감지가 필요한 경우 버전 기반 낙관적 잠금으로 감지→재시도</li><li>충돌 빈도가 높거나 강제 일관성이 필요하면 <code>SELECT … FOR UPDATE</code> 같은 비관적 잠금 또는 DB 의 Serializable 격리 수준을 선택하는 것이다.</li></ol><p>운영에서는 충돌률·재시도율·락 대기시간을 모니터링하고 적절한 재시도/백오프 정책을 적용해야 안정적이다.</p><h5 id=lost-update-의-기술적-특징-분석>Lost Update 의 기술적 특징 분석<a hidden class=anchor aria-hidden=true href=#lost-update-의-기술적-특징-분석>#</a></h5><ol><li><p><strong>원자적 갱신 가능성</strong></p><ul><li>설명: DB 가 <code>UPDATE … SET v = v + 1</code> 처럼 읽기·계산·쓰기 단계를 내부적으로 처리하면 애플리케이션 RMW 가 필요 없어짐.</li><li>근거: DB 엔진 내부의 단일 문장은 트랜잭션 원자성을 보장하므로 중간 충돌 소지가 제거됨.</li><li>차별점: 애플리케이션 로직 단순화·성능 우위—다만 복잡한 비즈니스 로직은 SQL 로 표현하기 어려울 수 있음.</li></ul></li><li><p><strong>격리 수준의 영향 (Repeatable Read/Read Committed 등)</strong></p><ul><li>설명: 낮은 격리 수준에서는 Lost Update 가 쉽게 발생; 그러나 MVCC 기반 DB 도 구현·설정에 따라 차이가 있음 (예: MySQL 의 일부 동작).</li><li>근거: DBMS 별로 Repeatable Read 가 다르게 동작해 Lost Update 방지 여부가 달라짐.</li><li>차별점: 단순히 격리 수준 하나로 해결이 안 되는 경우가 있어 애플리케이션 레벨 설계 병행 필요.</li></ul></li><li><p><strong>낙관적 vs 비관적 락의 적합성</strong></p><ul><li>설명: 낙관적 락은 읽기 위주·충돌 적은 환경에 효율적, 비관적 락은 충돌 많은 핫스팟에 안전.</li><li>근거: 낙관적은 버전 비교·예외·재시도 흐름, 비관적은 즉시 락 획득으로 설계된다.</li><li>차별점: 락 유지 유무 (성능/대기) 와 재시도 책임 (애플리케이션) 에 따라 선택이 갈림.</li></ul></li><li><p><strong>운영적 관측·재시도 정책의 중대성</strong></p><ul><li>설명: 충돌을 단순히 기술로만 막을 수 없으므로 충돌률·재시도율·평균 락 대기시간 같은 지표로 시스템 동작을 실시간 파악해야 함.</li><li>근거: 재시도 폭주 (backoff 필요) 와 지표 기반 대응은 산업 권장 관행.</li><li>차별점: 기술 선택 이후 운영 설계가 실 서비스 안정성에 결정적 영향을 줌.</li></ul></li></ol><h5 id=lost-update-대응-기술-비교표>Lost Update 대응 기술 비교표<a hidden class=anchor aria-hidden=true href=#lost-update-대응-기술-비교표>#</a></h5><table><thead><tr><th>특성</th><th style=text-align:right>요약 설명</th><th>기술적 근거</th><th>장단점 (차별점)</th></tr></thead><tbody><tr><td>원자적 SQL 갱신</td><td style=text-align:right>DB 내부에서 읽기/계산/쓰기 동작을 단일 문장으로 처리</td><td>단일 트랜잭션 문장으로 원자성 보장. <code>UPDATE … SET v = v + 1</code> 등.</td><td>장: 간단·성능 우수. 단: 모든 비즈니스 로직 표현 불가.</td></tr><tr><td>낙관적 잠금</td><td style=text-align:right>버전/타임스탬프로 충돌 감지 → 실패 시 재시도</td><td>ORM·JPA 의 version 필드 등 널리 사용. 충돌 시 예외 발생.</td><td>장: 락 없음 (읽기 성능). 단: 충돌 시 애플리케이션 재시도 필요.</td></tr><tr><td>비관적 잠금</td><td style=text-align:right>SELECT … FOR UPDATE 로 선점 락 획득</td><td>DB 락 메커니즘 사용, 즉시 배타성 보장.</td><td>장: 충돌 방지 확실. 단: 대기·데드락·성능 저하 위험.</td></tr><tr><td>격리 수준 (Serializable)</td><td style=text-align:right>DB 차원에서 이상현상 차단 (Abort+ 재시도)</td><td>SQL 표준 최고 격리. DBMS 구현 (락/SSI) 따라 작동.</td><td>장: 안전성 우수. 단: 성능·재시도 비용 발생.</td></tr><tr><td>운영 설계 (재시도·관측)</td><td style=text-align:right>재시도 정책 (백오프), 충돌률·재시도율 모니터링 필수</td><td>재시도 폭주 방지 사례·권장 (지수적 백오프 등).</td><td>장: 현장 안전성 확보. 단: 모니터링·운영 부담 증가.</td></tr></tbody></table><p>Lost Update 방지는 단일한 정답이 아니라 상황에 맞춘 조합 설계다.<br>간단한 카운터 증감 등은 원자적 UPDATE 로 해결하고, 읽기 위주 시스템에서는 낙관적 잠금을, 쓰기 핫스팟이나 강한 동시성 요구 환경에서는 비관적 잠금 또는 DB 의 Serializable 을 선택한다. 무엇보다 충돌이 현실화될 때를 대비한 재시도·백오프 전략과 충돌률·락 대기시간 같은 관측 지표를 설계해 운영하면 안정성이 크게 향상된다.</p><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=lost-update-통합-원칙설계>Lost Update 통합 원칙·설계<a hidden class=anchor aria-hidden=true href=#lost-update-통합-원칙설계>#</a></h4><ol><li><strong>문제의 본질</strong>: 여러 클라이언트가 같은 데이터를 동시에 고쳐서 한쪽 변경이 사라지는 상황이 Lost Update 다.</li><li><strong>가장 쉬운 해결법</strong>: 가능한 한 <em>한 문장으로</em> DB 에서 갱신하라. (<code>UPDATE accounts SET balance = balance +? WHERE id =?</code>)</li><li><strong>충돌이 잦다면</strong>: 다른 트랜잭션이 접근하지 못하게 미리 잠그는 <strong>비관적 잠금</strong>(SELECT FOR UPDATE) 을 쓴다.</li><li><strong>충돌이 드물다면</strong>: 버전 숫자 (또는 timestamp) 를 두고 커밋 시 비교하는 <strong>낙관적 잠금</strong>을 써 재시도한다.</li><li><strong>분산/재시도 환경</strong>: 요청에 <strong>idempotency key</strong>를 도입해 중복 실행을 방지한다.</li><li><strong>운영에서</strong>: 충돌 비율을 모니터링하고, 테스트로 정책을 검증해 최적의 전략을 선택한다.</li></ol><h5 id=lost-update-핵심-원칙표>Lost Update 핵심 원칙표<a hidden class=anchor aria-hidden=true href=#lost-update-핵심-원칙표>#</a></h5><table><thead><tr><th>원칙</th><th style=text-align:right>설명 (요약)</th><th>목적 (무엇을 위해)</th><th>왜 필요한가 (이점)</th><th>실무 적용 예</th></tr></thead><tbody><tr><td>원자적 갱신</td><td style=text-align:right>DB 단일 문으로 갱신 수행</td><td>중간 상태 제거, 원자성 보장</td><td>충돌·재시도 비용 감소</td><td><code>UPDATE … SET v=v+? WHERE id=?</code></td></tr><tr><td>비관적 잠금</td><td style=text-align:right>접근 전에 리소스 잠금</td><td>동시 쓰기 차단</td><td>충돌 위험 최소화</td><td><code>SELECT … FOR UPDATE</code></td></tr><tr><td>낙관적 잠금</td><td style=text-align:right>버전 비교로 충돌 감지</td><td>높은 동시성·확장성 확보</td><td>성능 우위, 충돌 시 재시도</td><td><code>UPDATE … WHERE version=?</code></td></tr><tr><td>충돌 재시도</td><td style=text-align:right>지수 백오프 + 재시도</td><td>transient 충돌 복구</td><td>사용자 경험 향상</td><td>재시도 루프 + 지터</td></tr><tr><td>아이덤포턴시</td><td style=text-align:right>중복 요청에 동일 결과 보장</td><td>재시도 안전성 확보</td><td>중복 적용 방지</td><td>idempotency key 저장</td></tr><tr><td>관찰성</td><td style=text-align:right>충돌/재시도 지표 수집</td><td>정책 튜닝 근거 확보</td><td>핫스팟 식별·최적화</td><td>메트릭 (충돌률) 수집</td></tr></tbody></table><ul><li><strong>원자적 갱신</strong>을 우선으로, 충돌 빈도에 따라 <strong>비관적/낙관적</strong>을 선택한다.</li><li><strong>재시도·아이덤포턴시·관찰성</strong>은 실무에서 항상 함께 적용해야 하는 보완 메커니즘이다.</li></ul><h5 id=설계-철학과-적용-방향>설계 철학과 적용 방향<a hidden class=anchor aria-hidden=true href=#설계-철학과-적용-방향>#</a></h5><table><thead><tr><th>철학</th><th style=text-align:right>설명 (요약)</th><th>목적 (무엇을 위해)</th><th>왜 필요한가 (실무적 의미)</th></tr></thead><tbody><tr><td>최소 권한 트랜잭션</td><td style=text-align:right>트랜잭션 범위·잠금 최소화</td><td>대기시간·교착 감소</td><td>동시성 성능 향상</td></tr><tr><td>정합성 - 성능 균형</td><td style=text-align:right>비즈니스 요구에 따른 일관성 선택</td><td>비용·복잡성 최적화</td><td>불필요한 직렬화 회피</td></tr><tr><td>DB 우선 위임</td><td style=text-align:right>DB 의 원자성/제약 활용</td><td>복잡도 감소·안정성 확보</td><td>이미 검증된 메커니즘 재사용</td></tr><tr><td>방어적 앱 설계</td><td style=text-align:right>재시도·보상·중복방지 내장</td><td>장애 내성 강화</td><td>분산 환경의 현실적 요구 충족</td></tr><tr><td>측정 기반 튜닝</td><td style=text-align:right>실측 데이터로 정책 조정</td><td>근거 있는 최적화</td><td>운영 효율성 극대화</td></tr></tbody></table><ul><li>설계 철학은 <strong>어떤 기술을 왜 선택하는가</strong>에 대한 근본 원칙을 제공한다.</li><li>실무에서는 이 철학을 기준으로 구체적 기법 (원자적 SQL, 버전관리, idempotency 등) 을 조합해 운영 요건을 충족시킨다.</li></ul><h4 id=갱신-손실-lost-update-동작과-해법>갱신 손실 (Lost Update) 동작과 해법<a hidden class=anchor aria-hidden=true href=#갱신-손실-lost-update-동작과-해법>#</a></h4><p>갱신 손실은 트랜잭션이 <code>읽기-계산-쓰기</code> 의 비원자적 흐름을 따를 때 발생한다.<br>두 트랜잭션이 동일한 초기값을 읽고 각자 계산한 값을 쓸 경우, <strong>커밋 순서에 따라 한 쪽의 변경이 데이터베이스에서 유실</strong>된다. 데이터베이스는 이를 제어하기 위해 <strong>잠금 (lock)</strong>, <strong>격리 수준 (isolation)</strong>, <strong>MVCC/스냅샷</strong>, 또는 <strong>애플리케이션 레벨의 낙관적 검사 (versioning)</strong> 같은 메커니즘을 제공한다.<br>각 기법은 일관성 보장 능력과 성능·확장성 사이에 트레이드오프가 존재한다.</p><h5 id=갱신-손실의-원리와-제어-메커니즘>갱신 손실의 원리와 제어 메커니즘<a hidden class=anchor aria-hidden=true href=#갱신-손실의-원리와-제어-메커니즘>#</a></h5><p>아래는 <strong>Lost Update 의 기본 동작 원리와 시스템/애플리케이션 수준 메커니즘</strong>을 정리한 핵심 목록이다.</p><ol><li><p><strong>비원자 흐름 (핵심 원리)</strong></p><ul><li>트랜잭션은 통상 <code>READ → COMPUTE → WRITE → COMMIT</code> 의 흐름을 따름.</li><li>이 중 <code>READ</code> 와 <code>WRITE</code> 사이가 비원자 (atomic 이 아님) 이기 때문에, 다른 트랜잭션이 같은 레코드를 변경하면 앞선 트랜잭션의 계산 결과가 무의미해질 수 있다. (예: 두 트랜잭션이 동일한 초기값 10 을 읽어 서로 다른 갱신을 하면 커밋 순서에 따라 하나가 소실).</li></ul></li><li><p><strong>DB 메커니즘 관점</strong></p><ul><li><strong>락 기반 (비관적)</strong>: <code>SELECT … FOR UPDATE</code> 등으로 행 락을 얻어 다른 업데이트를 대기시킴 → Lost Update 방지 (대기/충돌). 단점: 대기·교착 가능성·스루풋 저하.</li><li><strong>MVCC(스냅샷 기반)</strong>: 트랜잭션은 스냅샷을 읽음 (읽기 중 다른 트랜잭션의 커밋은 스냅샷에 영향 없음). MVCC 자체는 읽기 일관성 제공하지만, <strong>격리 수준과 구현에 따라</strong> Lost Update 를 막지 못할 수 있음 (예: READ COMMITTED 에서 발생 가능).</li><li><strong>낙관적 (버전) 검사</strong>: 레코드에 <code>version</code> 또는 <code>updated_at</code> 을 두고, <code>UPDATE … WHERE id =? AND version =:old</code> 형태로 수행해 업데이트 성공 여부로 충돌을 감지 → 실패 시 재시도/오류 반환.</li></ul></li><li><p><strong>격리 수준 영향 (개략)</strong></p><ul><li><strong>READ UNCOMMITTED</strong>: 가장 약함 (일부 DB 는 구현 안 함)—여러 동시성 이상 허용.</li><li><strong>READ COMMITTED</strong>: 대부분 DB 의 기본—Lost Update 가 발생할 수 있음 (특히 단순 READ→UPDATE 패턴).</li><li><strong>REPEATABLE READ / SERIALIZABLE</strong>: 더 강한 보장—SERIALIZABLE 은 논리적 직렬화 보장 (대부분 Lost Update 방지 가능). 단, DB 구현마다 세부 동작 차이 있음.</li></ul></li><li><p><strong>애플리케이션 레벨 권장 패턴 (요약)</strong></p><ul><li>충돌 가능성이 높으면 <strong>비관적 락</strong>.</li><li>충돌이 낮고 성능이 중요하면 <strong>낙관적 버전 검사 + 재시도</strong>.</li><li>분산 환경·복잡한 비즈니스 로직은 <strong>도메인 이벤트/CQRS/애그리게이트 수준에서 충돌 제어</strong> 고려.</li></ul></li></ol><h5 id=갱신-손실-단계별-메커니즘>갱신 손실 단계별 메커니즘<a hidden class=anchor aria-hidden=true href=#갱신-손실-단계별-메커니즘>#</a></h5><table><thead><tr><th style=text-align:right>단계</th><th>동작 (시점)</th><th>문제 발생 지점</th><th>DB/앱 차원의 처리 (대표 메커니즘)</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>READ (스냅샷 읽기)</td><td>읽은 값이 곧 유효성 기준이 됨</td><td>MVCC 로 스냅샷 제공 (읽기 일관성)—단, 이후 쓰기 충돌 가능.</td></tr><tr><td style=text-align:right>2</td><td>COMPUTE (애플리케이션 계산)</td><td>계산은 로컬에서 이루어져 다른 트랜잭션 영향 반영 안 됨</td><td>애플리케이션 레벨에서 버전 체크 설계 (낙관적).</td></tr><tr><td style=text-align:right>3</td><td>WRITE (UPDATE)</td><td>다른 트랜잭션이 이미 커밋했으면 덮어쓰기 발생</td><td>비관적 락 (SELECT FOR UPDATE) 로 덮어쓰기 차단 / 낙관적 WHERE version 검사로 실패 감지.</td></tr><tr><td style=text-align:right>4</td><td>COMMIT</td><td>커밋 순서가 최종값 결정</td><td>높은 격리 수준 (Serializable) 또는 트랜잭션 재시도 정책으로 무결성 확보.</td></tr></tbody></table><ul><li><p><strong>READ 단계</strong>: 트랜잭션이 읽을 때 DB 는 스냅샷을 줄 수 있지만, 이 스냅샷은 그 시점 이후의 변경을 반영하지 않음. 따라서 읽은 값에 기반한 계산은 &rsquo; 구 버전 &rsquo; 을 기초로 하는 것이고, 다른 트랜잭션의 동시 변경을 놓칠 수 있다.</p></li><li><p><strong>COMPUTE 단계</strong>: 애플리케이션이 로컬에서 계산 (예: 재고 감소 계산) 을 하는 동안 다른 트랜잭션이 같은 데이터에 대해 변경을 하면, 계산 결과가 더 이상 최신 상태에 맞지 않게 된다. 낙관적 패턴은 이 시점의 불일치를 커밋 시 검사로 처리한다.</p></li><li><p><strong>WRITE 단계</strong>: 업데이트 시에 DB 가 행 락을 요구하지 않으면 다른 트랜잭션이 덮어쓸 수 있다. <code>SELECT … FOR UPDATE</code> 는 업데이트 전 행 락을 확보해 두 번째 업데이트를 대기시키거나 실패시킴으로써 Lost Update 를 방지한다. 그러나 락은 동시성 손실을 초래하므로 신중히 사용해야 한다.</p></li><li><p><strong>COMMIT 단계</strong>: 커밋 순서가 데이터의 최종 상태를 결정한다. SERIALIZABLE 같은 강한 격리 수준은 논리적 직렬화를 보장해 Lost Update 를 근본적으로 차단하지만 성능/확장성 측면에서 비용이 따른다.</p></li></ul><h5 id=lost-update-동작-흐름과-제어-분기>Lost Update 동작 흐름과 제어 분기<a hidden class=anchor aria-hidden=true href=#lost-update-동작-흐름과-제어-분기>#</a></h5><p>아래는 기본 시퀀스와 함께 <strong>비관적 락</strong>, <strong>낙관적 검사</strong>, <strong>MVCC/격리 수준</strong> 분기가 포함된 흐름도다.</p><pre class=mermaid>sequenceDiagram
  participant T1 as Txn1
  participant DB as DB
  participant T2 as Txn2

  T1-&gt;&gt;DB: BEGIN
  T2-&gt;&gt;DB: BEGIN

  T1-&gt;&gt;DB: SELECT value FROM counter WHERE id=1  (reads v=10, snapshot_s1)
  T2-&gt;&gt;DB: SELECT value FROM counter WHERE id=1  (reads v=10, snapshot_s2)

  activate T1
  T1-&gt;&gt;T1: compute -&gt; new_v1 = 11

  alt 비관적 락 사용
    T1-&gt;&gt;DB: SELECT ... FOR UPDATE (locks row)
    T1-&gt;&gt;DB: UPDATE counter SET value=11 WHERE id=1
    T1-&gt;&gt;DB: COMMIT
    DB--&gt;&gt;T1: OK
    T2-&gt;&gt;DB: (blocked or lock timeout) =&gt; waits/errors
  else 낙관적 검사 사용
    T1-&gt;&gt;DB: UPDATE counter SET value=11 WHERE id=1 AND version=old_ver
    DB--&gt;&gt;T1: success =&gt; commit
    T2-&gt;&gt;DB: UPDATE counter SET value=15 WHERE id=1 AND version=old_ver
    DB--&gt;&gt;T2: fail (version mismatch) =&gt; T2 must re-read/retry
  else 기본(MVCC, 낮은 격리)
    T1-&gt;&gt;DB: UPDATE counter SET value=11 WHERE id=1
    T1-&gt;&gt;DB: COMMIT
    T2-&gt;&gt;DB: UPDATE counter SET value=15 WHERE id=1
    T2-&gt;&gt;DB: COMMIT
    DB--&gt;&gt;All: final value = 15 (T1 업데이트 소실)
  end
  deactivate T1
</pre><ul><li>흐름도 상단은 두 트랜잭션이 동시에 <code>BEGIN</code> → <code>SELECT</code> 로 같은 값을 읽는 초기 상태를 보여준다.</li><li>이후 세 가지 <strong>대표 대응 방식</strong>(비관적 락 / 낙관적 검사 / 아무 제어 없음 (MVCC+ 낮은 격리)) 을 분기해 비교했다.<ul><li><strong>비관적 락</strong>: 첫 트랜잭션이 락을 획득하면 두 번째는 락 해제까지 대기하거나 오류 (타임아웃) 를 받는다. 즉, 덮어쓰기가 원천 차단된다. 단점은 락 대기 및 성능 저하.</li><li><strong>낙관적 검사</strong>: 업데이트 시점에 버전 일치 여부를 검사해서 실패하면 재시도한다. 고동시성·저충돌 환경에서 유리. 재시도 로직 필요.</li><li><strong>기본 (MVCC + 낮은 격리)</strong>: 방어 장치가 없으면 두 트랜잭션의 커밋 순서로 덮어쓰기가 발생하여 Lost Update 가 발생한다. MVCC 가 읽기 일관성은 제공하지만, 격리 수준에 따라 덮어쓰기를 막아주지 않을 수 있다.</li></ul></li></ul><h4 id=lost-update-흐름생명주기대응>Lost Update: 흐름·생명주기·대응<a hidden class=anchor aria-hidden=true href=#lost-update-흐름생명주기대응>#</a></h4><p>트랜잭션은 &rsquo; 읽기 → 계산 → 쓰기 &rsquo; 로 동작한다.<br>두 트랜잭션이 같은 값을 읽어 각자 계산하면, 먼저 커밋한 결과를 나중 트랜잭션이 덮어버릴 수 있다.<br>이를 막으려면</p><ol><li>DB 가 충돌을 감지해 후발 트랜잭션을 abort(또는 재시도) 하거나</li><li>먼저 쓰려는 쪽이 락을 걸어 다른 쪽을 대기시키는 방법을 쓴다.</li></ol><p>MVCC 는 읽기 성능을 높이지만, 쓰기 - 쓰기 충돌을 어떻게 처리하느냐에 따라 Lost Update 발생 여부가 달라진다.</p><h5 id=읽기계산쓰기-lost-update-흐름>읽기→계산→쓰기: Lost Update 흐름<a hidden class=anchor aria-hidden=true href=#읽기계산쓰기-lost-update-흐름>#</a></h5><h6 id=핵심-흐름-상태제어-관점>핵심 흐름 (상태/제어 관점)<a hidden class=anchor aria-hidden=true href=#핵심-흐름-상태제어-관점>#</a></h6><ul><li><strong>읽기 단계 (Read / Snapshot)</strong>: 트랜잭션이 시작되면 자신의 읽기 스냅샷 (또는 현재 데이터) 을 가져온다.</li><li><strong>계산 단계 (Application)</strong>: 애플리케이션이 읽은 값을 바탕으로 계산을 수행 (예: 잔액 차감). 이 간격에서 다른 트랜잭션이 커밋하여 데이터가 바뀔 수 있음 (스테일 데이터).</li><li><strong>쓰기 단계 (Commit-time / Update)</strong>: 업데이트 시 DB 의 충돌정책에 따라 두 갈래로 진행된다.<ul><li>DB 가 <strong>쓰기 - 쓰기 충돌 감지</strong>(commit-time) 하면 후발 트랜잭션을 abort/재시도.</li><li>또는 **선점 락 (비관적)**을 사용하면 후발자가 대기해 충돌을 피함.</li></ul></li></ul><h6 id=안전화-권장-패턴>안전화 권장 패턴<a hidden class=anchor aria-hidden=true href=#안전화-권장-패턴>#</a></h6><ul><li>가능한 경우 <strong>서버 측 원자 연산</strong>으로 읽기 - 계산 - 쓰기를 합쳐라 (<code>UPDATE … SET x = x - 1 WHERE x > 0</code>).</li><li>충돌이 드물면 <strong>버전/낙관적 패턴</strong>(UPDATE WHERE version=old + 재시도) 을 사용하라.</li><li>충돌이 빈번하거나 절대적 순서가 필요하면 <strong>비관적 락</strong>(FOR UPDATE) 채택을 검토하라.</li></ul><h5 id=lost-update-의-데이터제어-단계표>Lost Update 의 데이터·제어 단계표<a hidden class=anchor aria-hidden=true href=#lost-update-의-데이터제어-단계표>#</a></h5><table><thead><tr><th>단계</th><th style=text-align:right>주요 액션</th><th>DB 동작 (대표)</th><th>결과 (충돌 시)</th></tr></thead><tbody><tr><td>1. Read</td><td style=text-align:right>T1, T2 가 동일 행을 읽음</td><td>각 트랜잭션은 스냅샷 (또는 현재값) 확보</td><td>스냅샷은 이후 변경과 불일치 가능</td></tr><tr><td>2. Application Compute</td><td style=text-align:right>애플리케이션에서 계산 수행</td><td>DB 는 관여하지 않음 (스테일 가능)</td><td>다른 트랜잭션이 중간에 커밋 가능</td></tr><tr><td>3. Update 시도</td><td style=text-align:right>UPDATE/COMMIT 호출</td><td>(a) FOR UPDATE: 락 보유로 대기·직렬화 (b) OCC/MVCC: 커밋 시 충돌 검사</td><td>(a) 대기 후 적용 (b) 충돌이면 abort/retry 또는 덮어쓰기 (Lost Update)</td></tr><tr><td>4. Commit 결과</td><td style=text-align:right>커밋 혹은 롤백</td><td>DB 정책에 따라 상태 반영 또는 재시도</td><td>최종값이 누구 커밋인지에 따라 결정</td></tr></tbody></table><ul><li>&rsquo; 읽기→계산→쓰기 &rsquo; 의 취약 지점을 명확히 보여준다. 핵심은 <strong>애플리케이션 계산 구간</strong>에서 데이터가 바뀔 수 있다는 점이며, 이를 막는 방법은 DB 레벨 (락·commit-time 충돌검사) 또는 애플리케이션 레벨 (원자 쿼리·버전 체크) 로 나뉜다. 선택은 워크로드 특성 (충돌 빈도, 지연 허용치, 정확성 우선순위) 에 따라 달라진다.</li></ul><h5 id=트랜잭션-데이터제어-흐름-다이어그램>트랜잭션 데이터·제어 흐름 다이어그램<a hidden class=anchor aria-hidden=true href=#트랜잭션-데이터제어-흐름-다이어그램>#</a></h5><p>아래 흐름도는 일반적인 두 트랜잭션 (T1/T2) 의 읽기 - 계산 - 쓰기 경로와 DB 충돌 처리 분기를 보여준다.</p><pre class=mermaid>flowchart TD
  Start[트랜잭션 시작]
  Read1[&#34;T1: Read (snapshot)&#34;]
  Read2[&#34;T2: Read (snapshot)&#34;]
  Calc1[T1: Application 계산]
  Calc2[T2: Application 계산]
  Attempt1[T1: UPDATE -&gt; COMMIT 시도]
  Attempt2[T2: UPDATE -&gt; COMMIT 시도]
  DBCheck1{DB 충돌 정책}
  DBCheck2{DB 충돌 정책}
  Apply1[커밋: 변경 반영]
  Apply2[커밋: 변경 반영]
  Abort2[T2: 충돌 감지 -&gt; ABORT/재시도]
  Wait2[T2: 락 대기 -&gt; 적용]
  
  Start --&gt; Read1
  Start --&gt; Read2
  Read1 --&gt; Calc1
  Read2 --&gt; Calc2
  Calc1 --&gt; Attempt1
  Calc2 --&gt; Attempt2
  Attempt1 --&gt; DBCheck1
  DBCheck1 --&gt;|비관적 락 존재| Apply1
  DBCheck1 --&gt;|낙관적/MVCC| Apply1
  Apply1 --&gt; Attempt2
  Attempt2 --&gt; DBCheck2
  DBCheck2 --&gt;|&#34;충돌 감지 (MVCC/OCC)&#34;| Abort2
  DBCheck2 --&gt;|&#34;락으로 대기(FOR UPDATE)&#34;| Wait2 --&gt; Apply2
  DBCheck2 --&gt;|충돌 미감지| Apply2
  Abort2 --&gt; Retry2{재시도?}
  Retry2 --&gt;|예| Read2
  Retry2 --&gt;|아니오| End2[트랜잭션 종료: 실패]
  Apply2 --&gt; End1[All Done]
</pre><ul><li>트랜잭션은 독립적으로 읽고 계산을 수행한 뒤 업데이트를 시도한다. 첫 트랜잭션이 커밋되면 DB 상태가 바뀌고, 후발 트랜잭션의 커밋 시 DB 의 충돌정책에 따라 <strong>(1) 충돌 감지 → abort/재시도</strong>, <strong>(2) 락에 의해 대기 → 적용</strong>, <strong>(3) 충돌 미감지 → 덮어쓰기 (Lost Update)</strong> 중 하나가 결정된다. 애플리케이션은 재시도·백오프·아이덴포턴시 등의 정책으로 실패 상황을 견고하게 처리해야 한다.</li></ul><h5 id=트랜잭션-생명주기-충돌-관점>트랜잭션 생명주기 (충돌 관점)<a hidden class=anchor aria-hidden=true href=#트랜잭션-생명주기-충돌-관점>#</a></h5><p>트랜잭션의 상태 변화 (시작 → 읽기 → 계산 → 준비 (검증) → 커밋/롤백) 를 생명주기 중심으로 표현한다.</p><pre class=mermaid>stateDiagram-v2
  [*] --&gt; Started: BEGIN
  Started --&gt; Reading: Read(snapshot)
  Reading --&gt; Computing: Application 계산
  Computing --&gt; Preparing: Update 시도 (Update/Prepare)

  Preparing --&gt; Committed: 충돌 없음 / COMMIT -&gt; 반영
  Preparing --&gt; RolledBack: 충돌 감지 / ABORT -&gt; 재시도 가능
  Preparing --&gt; Waiting: 락 대기 / Lock Wait
  Waiting --&gt; Committed: 락 해제 -&gt; 반영

  RolledBack --&gt; Decision

  state Decision {
    [*] --&gt; Check
    Check --&gt; Retry: 재시도
    Check --&gt; Stop: 중지
    Retry --&gt; Reading
    Stop --&gt; [*]
  }

  Committed --&gt; [*]
</pre><ul><li>이 생명주기는 트랜잭션이 <strong>읽기 → 계산 → 준비 (검증) → 커밋/롤백</strong>으로 진행된다는 점을 강조한다. <code>Preparing</code> 단계 (커밋 직전) 가 충돌검출의 핵심 지점이며, 여기서 DB 정책에 따라 롤백이 발생하면 애플리케이션이 재시도 여부를 결정한다. 락 기반이면 <code>Waiting</code> 상태가 생겨 대기 후 커밋될 수 있다.</li></ul><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=동시갱신-보호의-효용과-선택지>동시갱신 보호의 효용과 선택지<a hidden class=anchor aria-hidden=true href=#동시갱신-보호의-효용과-선택지>#</a></h4><p>동시 갱신 상황에서 Lost Update 를 막는 기법들은 목적에 따라 선택된다.<br>단순 값 증감 등은 데이터베이스의 원자적 UPDATE 로 해결하는 것이 가장 간단하고 효율적이다.<br>사용자가 여러 단계 (예: 웹 폼 → 확인 → 커밋) 를 거쳐 트랜잭션이 길어지는 경우 낙관적 버저닝 (버전 비교 후 재시도) 이 적합하다.<br>절대적 일관성이 필요하면 격리 수준을 Serializable 로 올리거나 비관적 잠금을 사용하되 성능·교착 리스크를 고려해야 한다.<br>각 기법은 &rsquo; 어떤 문제를 줄여주고 어떤 비용을 발생시키는지 &rsquo; 로 판단하면 된다.</p><h5 id=lost-update-방지-장점-정리표>Lost Update 방지 장점 정리표<a hidden class=anchor aria-hidden=true href=#lost-update-방지-장점-정리표>#</a></h5><table><thead><tr><th>장점</th><th>상세 설명</th><th>기술 근거</th><th>적용 상황</th><th>실무적 가치</th></tr></thead><tbody><tr><td>데이터 정합성 보호</td><td>동시 갱신 시 덮어쓰기 방지로 무결성 유지</td><td>격리 (Serializable), 비관적 락 동작</td><td>금융·재고·결제</td><td>분쟁·오류 리스크 저감.</td></tr><tr><td>자동 롤백·재시도</td><td>충돌 감지 시 트랜잭션 실패 후 재시도 가능</td><td>DB/애플리케이션 재시도 패턴</td><td>대량 트랜잭션 시스템</td><td>운영 안정성·회복력 향상.</td></tr><tr><td>원자적 갱신</td><td>UPDATE col = col + X 등 단일문으로 안전 갱신</td><td>SQL 원자성 보장</td><td>카운터·잔액 업데이트</td><td>간단·고성능·정확성 확보.</td></tr><tr><td>낙관적 버저닝</td><td>버전 비교로 충돌 탐지 후 재시도</td><td>버전/timestamp 비교 패턴</td><td>사용자 think-time·분산 트랜잭션</td><td>락 부담 감소·확장성 확보.</td></tr><tr><td>유연한 DB 별 전략</td><td>DB 특성에 따라 적절한 조합 적용 가능</td><td>MVCC vs 2PL 차이 존재</td><td>여러 DBMS 혼재 환경</td><td>이식성·운영 유연성 확보.</td></tr></tbody></table><p>Lost Update 방지 기법은 &rsquo; 어떤 상황에서 &rsquo; 와 &rsquo; 어떤 비용이 드는가 &rsquo; 를 기준으로 선택해야 한다.<br>간단한 산술 갱신은 원자적 SQL 로 해결하고, 사용자 상호작용으로 트랜잭션이 길면 낙관적 버저닝을 도입하며, 규제·금융처럼 무결성이 최우선이면 높은 격리 수준이나 비관적 락을 적용한다. MVCC 는 읽기 성능을 크게 향상시키지만 쓰기 충돌 문제는 별도의 정책으로 처리해야 한다.</p><h4 id=lost-update-한계제약과-실무적-완화책>Lost Update: 한계·제약과 실무적 완화책<a hidden class=anchor aria-hidden=true href=#lost-update-한계제약과-실무적-완화책>#</a></h4><p>Lost Update 의 단점과 제약은 크게 두 축으로 본다.</p><ol><li><strong>본질적 단점</strong>(예: 비관적 락은 락 경쟁·데드락을 만들고, 낙관적 락은 충돌 시 재시도 비용이 든다) 은 기술 선택 자체가 가져오는 트레이드오프다.</li><li><strong>환경 제약</strong>(ORM 기본 설정, 읽기 - 쓰기 분리, DBMS 별 구현 차이) 은 운영·설계로 인해 문제가 커지는 요인이다.</li></ol><p>실무에서는 원자적 UPDATE 로 단순 카운터 문제를 해결하고, 충돌이 흔한 곳은 비관적 락·파티셔닝을 적용하며, 낙관적 접근에는 지수적 백오프와 멱등성을 도입해 재시도 비용을 완화한다. 또한 리플리카 읽기 사용 시 세션 고정·마스터 읽기 등으로 스테일 리드를 피해야 한다.</p><h5 id=lost-update-의-본질적-단점-비교>Lost Update 의 본질적 단점 비교<a hidden class=anchor aria-hidden=true href=#lost-update-의-본질적-단점-비교>#</a></h5><table><thead><tr><th>단점</th><th style=text-align:right>설명</th><th>원인</th><th>실무문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>성능 저하 (비관적)</td><td style=text-align:right>락으로 동시성 감소·대기 발생.</td><td>장시간 락 보유</td><td>지연·타임아웃·데드락</td><td>트랜잭션 단축, 인덱스 정리, 락 범위 축소</td><td>낙관적 락, 원자적 UPDATE</td></tr><tr><td>재시도 비용 (낙관적)</td><td style=text-align:right>충돌 시 재시도·롤백 필요.</td><td>버전 비교 실패</td><td>사용자 지연·리소스 소모</td><td>지수적 백오프, 멱등 설계, 재시도 제한</td><td>비관적 락</td></tr><tr><td>표현 한계 (원자적 갱신)</td><td style=text-align:right>복잡 로직을 원자 SQL 로 표현 어려움.</td><td>SQL 표현력 한계</td><td>애플리케이션 RMW 유발</td><td>저장 프로시저, 로직 재설계</td><td>CQRS, 이벤트 소싱</td></tr><tr><td>성능 비용 (Serializable)</td><td style=text-align:right>완전 보장 but 비용 큼.</td><td>충돌 탐지·재시도</td><td>TPS 저하</td><td>중요한 경로만 적용, 파티셔닝</td><td>혼합 격리 전략</td></tr></tbody></table><p>각 기법은 반드시 트레이드오프를 동반한다. 낮은 충돌 환경에서는 낙관적 방식이 효율적이고, 핫스팟엔 비관적 락이나 파티셔닝이 적합하다. 원자적 SQL 은 가장 간단·효율적이지만 표현 한계가 있어 복잡한 도메인은 다른 패턴 병행이 필요하다.</p><h5 id=환경적-제약사항과-완화책>환경적 제약사항과 완화책<a hidden class=anchor aria-hidden=true href=#환경적-제약사항과-완화책>#</a></h5><table><thead><tr><th>제약사항</th><th style=text-align:right>설명</th><th>원인</th><th>영향</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>ORM 기본 설정</td><td style=text-align:right>기본 낙관 잠금 비활성화로 LWW 발생.</td><td>프레임워크 기본값</td><td>의도치 않은 덮어쓰기</td><td><code>@Version</code> 등 명시, 테스트</td><td>DB 트리거</td></tr><tr><td>읽기/쓰기 분리 (리플리카)</td><td style=text-align:right>복제 지연으로 스테일 리드 발생.</td><td>비동기 복제 지연</td><td>스테일 기반 갱신·데이터 불일치</td><td>마스터 읽기, 세션 고정</td><td>단일 라이터, 분산 락</td></tr><tr><td>DBMS 별 동작 차이</td><td style=text-align:right>격리 수준·MVCC 구현 차이로 결과 상이.</td><td>내부 엔진 설계 차이</td><td>이식성·디버깅 난이도 증가</td><td>환경별 테스트·정책 문서화</td><td>DB 별 설계 패턴 적용</td></tr></tbody></table><p>환경 제약은 설계·운영 관행으로 완화할 수 있다. ORM 설정·읽기 전략·DB 선택은 초기에 설계·테스트로 확정해야 런타임 문제를 줄일 수 있다.</p><h4 id=lost-update-트레이드오프와-하이브리드-전략>Lost Update: 트레이드오프와 하이브리드 전략<a hidden class=anchor aria-hidden=true href=#lost-update-트레이드오프와-하이브리드-전략>#</a></h4><ol><li><p><strong>문제 요약</strong>:<br>일관성 (Consistency) 을 올리면 동시성 (throughput) 이 떨어지고, 동시성을 높이면 Lost Update 같은 데이터 오류 위험이 커진다.</p></li><li><p><strong>결정 원칙</strong>:<br>중요한 데이터 (돈·재고) 는 강한 정합성 우선, 그렇지 않은 데이터는 성능 우선 (낙관적) 으로 설계.</p></li><li><p><strong>현실적 해법</strong>:<br>전사적 한 가지 방식보다 <em>핫스팟 식별 → 해당 키에 강한 제어 적용 → 일반 작업은 낙관적 처리</em> 하는 하이브리드가 효과적.</p></li><li><p><strong>운영 포인트</strong>:<br>충돌/재시도 메트릭, 아이덤포턴시, 지수 백오프를 필수로 도입해 돌발 상황 관리.</p></li></ol><h5 id=고격리-vs-저격리-트레이드오프>고격리 Vs 저격리 트레이드오프<a hidden class=anchor aria-hidden=true href=#고격리-vs-저격리-트레이드오프>#</a></h5><table><thead><tr><th>항목</th><th style=text-align:right>고격리 / 비관적 (A)</th><th>저격리 / 낙관적 (B)</th></tr></thead><tbody><tr><td>일관성 수준</td><td style=text-align:right>매우 높음 (직렬화 가능)</td><td>낮음/중간 (eventual 가능)</td></tr><tr><td>처리량/동시성</td><td style=text-align:right>낮음</td><td>높음</td></tr><tr><td>레이턴시</td><td style=text-align:right>높음</td><td>낮음</td></tr><tr><td>충돌 처리</td><td style=text-align:right>차단 (잠금) 으로 사전 예방</td><td>검출 후 재시도/보상</td></tr><tr><td>구현 복잡도</td><td style=text-align:right>상대적 단순 (DB 에 위임)</td><td>애플리케이션 동작 필요</td></tr><tr><td>확장성</td><td style=text-align:right>제한적 (글로벌 락 비용)</td><td>우수 (파티셔닝·분산에 친화)</td></tr><tr><td>적합 사례</td><td style=text-align:right>금전·재고·주문 결제 등</td><td>좋아요·통계·카운터 등</td></tr></tbody></table><ul><li><strong>핵심</strong>: A 는 안전 (정합성) 을 우선, B 는 성능 (처리량) 을 우선.</li><li><strong>실무 추천</strong>: 중요한 도메인은 A 성향으로, 그렇지 않은 도메인은 B 성향으로 분류해 혼합 적용하라.</li></ul><h5 id=하이브리드-트레이드오프-패턴>하이브리드 트레이드오프 패턴<a hidden class=anchor aria-hidden=true href=#하이브리드-트레이드오프-패턴>#</a></h5><table><thead><tr><th>패턴</th><th style=text-align:right>적용 목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>선택적 비관적 잠금</td><td style=text-align:right>핫스팟 보호</td><td>전체 성능 손실 최소화</td><td>핫스팟 탐지·잠금 범위</td></tr><tr><td>파티셔닝 + 로컬 직렬화</td><td style=text-align:right>샤드 내 강한 정합</td><td>확장성 + 로컬 정합성</td><td>샤드 키 설계·크로스샤드 비용</td></tr><tr><td>CQRS</td><td style=text-align:right>쓰기 정합성 + 읽기 성능</td><td>경로별 최적화 가능</td><td>동기화 지연·복잡도</td></tr><tr><td>리더 기반 업데이트</td><td style=text-align:right>키 단위 직렬화</td><td>단순하고 확장 가능</td><td>leader failover 복잡</td></tr><tr><td>CRDT</td><td style=text-align:right>분산 병합이 가능한 연산</td><td>네트워크 분할에 강함</td><td>비즈니스 제약 (모든 연산 불가)</td></tr><tr><td>조건부 SQL + 재시도</td><td style=text-align:right>DB 원자성 우선</td><td>네트워크 왕복 최소화</td><td>재시도 정책 필요</td></tr></tbody></table><ul><li><strong>핵심</strong>: 하이브리드 패턴들은 " 어디에 강한 정합을 둬야 하나 " 라는 질문에 실용적 대답을 준다.</li><li><strong>실무 팁</strong>: 핫스팟은 선별적으로 강한 제어 (비관적/리더), 나머지는 낙관적/원자적 SQL 로 처리하는 조합이 빈번히 효과적이다.</li></ul><h4 id=갱신-전략-선택-기준과-실무-적용>갱신 전략 선택 기준과 실무 적용<a hidden class=anchor aria-hidden=true href=#갱신-전략-선택-기준과-실무-적용>#</a></h4><ol><li><p><strong>문제</strong>: 여러 프로세스가 동시에 같은 값을 읽고 수정하면, 마지막으로 커밋된 값이 이전 변경을 덮어써서 일부 변경이 사라질 수 있다 (= Lost Update).</p></li><li><p><strong>해결 아이디어 요약</strong>:</p><ul><li><strong>충돌 드묾 → 낙관적</strong>: 읽을 때는 락 안 걸고, 쓸 때 버전 비교. 실패하면 다시 읽고 재시도.</li><li><strong>충돌 잦음 → 비관적</strong>: 업데이트 전에 락을 걸어 다른 업데이트를 차단.</li><li><strong>단순 증감 → 원자적 연산</strong>: <code>UPDATE t SET cnt = cnt + 1 WHERE id=?</code> 같은 한 문장으로 처리.</li><li><strong>중대한 금전/원장 → 강한 격리</strong>: Serializable/SSI 로 논리적 직렬화 보장.</li></ul></li><li><p><strong>실무 팁 한 줄</strong>: 먼저 충돌이 자주 발생하는 워크플로우를 찾아 (모니터링), 해당 워크플로우에 맞는 전략을 부분 적용해 보는 것이 가장 안전하다.</p></li></ol><h5 id=갱신-전략별-적용-적합성-표>갱신 전략별 적용 적합성 표<a hidden class=anchor aria-hidden=true href=#갱신-전략별-적용-적합성-표>#</a></h5><table><thead><tr><th style=text-align:right>시나리오/속성</th><th>추천 전략</th><th>이유</th><th>단점/주의점</th></tr></thead><tbody><tr><td style=text-align:right>충돌 빈도 <strong>낮음</strong> (대다수 웹 CRUD)</td><td>낙관적 잠금 (버전 기반)</td><td>높은 동시성 유지, 락 대기 없음.</td><td>충돌 시 재시도 로직 필요 (복잡도 증가)</td></tr><tr><td style=text-align:right>충돌 빈도 <strong>높음</strong> / 희귀·고가치 자원</td><td>비관적 잠금 (행락/분산락)</td><td>덮어쓰기 원천 차단, 데이터 손실 방지.</td><td>락 대기·교착·성능 저하</td></tr><tr><td style=text-align:right>단순 누적·증감 (카운터, 재고 감소 등)</td><td>원자적 DB 연산 (single UPDATE)</td><td>DB 가 원자 처리, 스케일 대비 우수.</td><td>설계가 단순해야 적용 쉬움</td></tr><tr><td style=text-align:right>금융·원장·정합성 최우선</td><td>Serializable / SSI</td><td>논리적 직렬화로 무결성 보장.</td><td>성능·확장성 비용 큼</td></tr><tr><td style=text-align:right>고성능 분산 시스템</td><td>애플리케이션 레이어 CQRS/이벤트 소싱</td><td>충돌 경계 축소·비동기 처리로 확장성 확보.</td><td>아키텍처 복잡도 증가</td></tr></tbody></table><ul><li><strong>핵심 규칙</strong>: 데이터의 **가치 (정합성 중요도)**와 <strong>충돌 빈도</strong>를 교차표로 놓고 전략을 결정하라.</li><li><strong>실무 우선순위</strong>: (1) 중요한 트랜잭션 경로 식별 → (2) 충돌률·재시도 비용 계측 → (3) 전략 (원자/낙관적/비관적/격리) 적용 → (4) 모니터링·조정.</li></ul><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-문제-재현-잘못된-패턴>실습 예제: 문제 재현 (잘못된 패턴)<a hidden class=anchor aria-hidden=true href=#실습-예제-문제-재현-잘못된-패턴>#</a></h5><p><strong>목적</strong>: Read-Modify-Write 의 위험 이해</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span><span class=lnt id=hl-5-16><a class=lnlinks href=#hl-5-16>16</a>
</span><span class=lnt id=hl-5-17><a class=lnlinks href=#hl-5-17>17</a>
</span><span class=lnt id=hl-5-18><a class=lnlinks href=#hl-5-18>18</a>
</span><span class=lnt id=hl-5-19><a class=lnlinks href=#hl-5-19>19</a>
</span><span class=lnt id=hl-5-20><a class=lnlinks href=#hl-5-20>20</a>
</span><span class=lnt id=hl-5-21><a class=lnlinks href=#hl-5-21>21</a>
</span><span class=lnt id=hl-5-22><a class=lnlinks href=#hl-5-22>22</a>
</span><span class=lnt id=hl-5-23><a class=lnlinks href=#hl-5-23>23</a>
</span><span class=lnt id=hl-5-24><a class=lnlinks href=#hl-5-24>24</a>
</span><span class=lnt id=hl-5-25><a class=lnlinks href=#hl-5-25>25</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 테이블
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>BIGINT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>value</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>updated_at</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=k>CURRENT_TIMESTAMP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>counter</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Txn1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 10 읽음
</span></span></span><span class=line><span class=cl><span class=c1>-- (애플리케이션에서 +1 계산)
</span></span></span><span class=line><span class=cl><span class=c1>-- 일부 지연…
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Txn2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 10 읽음
</span></span></span><span class=line><span class=cl><span class=c1>-- (애플리케이션에서 +5 계산)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>15</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- Txn2 커밋
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Txn1 계속
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>11</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- Txn1 커밋
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 최종 값 11 (Txn2의 갱신 소실)
</span></span></span></code></pre></td></tr></table></div></div><h6 id=수정안-1-원자적-갱신>수정안 1: <strong>원자적 갱신</strong><a hidden class=anchor aria-hidden=true href=#수정안-1-원자적-갱신>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 동시 실행되어도 안전
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- Txn1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- Txn2
</span></span></span></code></pre></td></tr></table></div></div><h6 id=수정안-2-비관적-잠금>수정안 2: <strong>비관적 잠금</strong><a hidden class=anchor aria-hidden=true href=#수정안-2-비관적-잠금>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- Row 잠금 획득
</span></span></span><span class=line><span class=cl><span class=c1>-- 계산 수행
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h6 id=수정안-3-낙관적-잠금-버전-컬럼>수정안 3: <strong>낙관적 잠금 (버전 컬럼)</strong><a hidden class=anchor aria-hidden=true href=#수정안-3-낙관적-잠금-버전-컬럼>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7>7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>COLUMN</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=nb>BIGINT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 읽기 시 현재 version도 읽어둔다(예: v=10, ver=3)
</span></span></span><span class=line><span class=cl><span class=c1>-- 쓰기 시 조건부 업데이트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>counter</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SET</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>:</span><span class=n>new_value</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>version</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>:</span><span class=n>id</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>:</span><span class=n>old_version</span><span class=p>;</span><span class=w> </span><span class=c1>-- 영향 행이 0이면 충돌로 간주, 재시도
</span></span></span></code></pre></td></tr></table></div></div><h5 id=실습-예제-lost-update-상황과-해결---sql-트랜잭션>실습 예제: Lost Update 상황과 해결 - SQL 트랜잭션<a hidden class=anchor aria-hidden=true href=#실습-예제-lost-update-상황과-해결---sql-트랜잭션>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>동시 실행되는 트랜잭션에서 갱신 손실 현상과 방지 전략 비교 실습</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>MySQL 또는 PostgreSQL DBMS 준비</li><li>계정 및 트랜잭션 권한 필요</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>갱신 손실 발생 예시</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 트랜잭션 A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- balance = 100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>50</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 트랜잭션 B
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- balance = 100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 최종 balance = 150, 트랜잭션 A의 작업 소실
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>명시적 락으로 해결</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 트랜잭션 A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- balance = 100
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>50</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 트랜잭션 B
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 락 대기, balance = 150
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 두 트랜잭션 작업 모두 보존
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>첫 번째 예시에서는 두 트랜잭션 중 한쪽 작업이 소실</li><li>두 번째 예시에서는 명시적 잠금으로 모든 작업이 제대로 반영</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>MVCC 환경에서 트랜잭션 버전 충돌 감지 (Repeatable Read 등)</li><li>낙관적/비관적 Lock 방식 비교 실습</li></ul><h3 id=phase-6-운영-및-최적화>Phase 6: 운영 및 최적화<a hidden class=anchor aria-hidden=true href=#phase-6-운영-및-최적화>#</a></h3><h4 id=lost-update-관측탐지대응-체계>Lost Update 관측·탐지·대응 체계<a hidden class=anchor aria-hidden=true href=#lost-update-관측탐지대응-체계>#</a></h4><p>Lost Update 를 운영에서 잡아내려면 <strong>락/데드락/재시도 실패/장기 트랜잭션/핫로우</strong> 같은 지표를 정기적으로 관찰해야 한다.<br>DB 로그 (예: <code>deadlock detected</code>, <code>serialization failure</code>) 는 즉각적인 경고이고, 애플리케이션 로그 (ORM 예외) 는 재시도 로직의 실패를 알려준다.<br>이들을 대시보드에 연결해 임계값을 정하고 (예: 데드락 > 1/min, 재시도율 > 1%), 이상 발생 시 원인 분석 (핫로우·쿼리·트랜잭션 패턴) 을 해 문제를 해결한다.</p><h5 id=lost-update-관측-카테고리-체계>Lost Update 관측 카테고리 체계<a hidden class=anchor aria-hidden=true href=#lost-update-관측-카테고리-체계>#</a></h5><h6 id=실시간-탐지-메트릭>실시간 탐지 메트릭<a hidden class=anchor aria-hidden=true href=#실시간-탐지-메트릭>#</a></h6><p>실시간 지표는 문제 탐지 (또는 이상 징후 알림) 에 사용된다.</p><p>핵심 지표와 수집 방법:</p><ul><li><strong>락 대기 시간</strong>: 평균/90/99 백분위; DB 활동 테이블 (<code>pg_stat_activity</code>/<code>performance_schema</code>) 에서 집계.</li><li><strong>데드락 수</strong>: 분/시간 단위 deadlock 발생 건수 (로그·엔진 카운터 기반).</li><li><strong>Retry 율 (낙관적 실패율)</strong>: 애플리케이션 로그에서 재시도 이벤트 비율; SQLSTATE 40001 또는 ORM 예외로 집계.</li><li><strong>장기 트랜잭션 수</strong>: 트랜잭션 연령이 임계값 (예: 30s/60s) 을 초과한 개수.</li></ul><table><thead><tr><th>지표</th><th style=text-align:right>목적</th><th>수집 방법 (요약)</th><th style=text-align:right>권장 경보 임계값 (예시)</th></tr></thead><tbody><tr><td>락 대기 시간 (P50/P90/P99)</td><td style=text-align:right>동시성 병목 탐지</td><td>pg_stat_activity / performance_schema</td><td style=text-align:right>P99 > 500ms 경고</td></tr><tr><td>데드락 수 (분단위)</td><td style=text-align:right>충돌 심각도 표시</td><td>DB 로그 / 엔진 카운터</td><td style=text-align:right>>1 / min 심각</td></tr><tr><td>Retry 율</td><td style=text-align:right>OCC/SI 실패 지표</td><td>애플리케이션 로그 / SQLSTATE</td><td style=text-align:right>>1% 경고</td></tr><tr><td>장기 트랜잭션 수</td><td style=text-align:right>스냅샷/리소스 고정 원인</td><td>pg_stat_activity(xact_start)</td><td style=text-align:right>>5 건 경고</td></tr></tbody></table><ul><li>실시간 메트릭은 빠른 탐지와 알림을 위해 설정한다. 락 대기·데드락·재시도 실패가 늘면 Lost Update 나 동시성 버그를 의심하고 즉시 진단 루틴 (쿼리·트레이스 확인) 을 실행해야 한다.</li></ul><h6 id=로그-및-이벤트-증거-수집>로그 및 이벤트 (증거) 수집<a hidden class=anchor aria-hidden=true href=#로그-및-이벤트-증거-수집>#</a></h6><p>로그는 진단·포렌식의 근거가 된다. 수집·보존·분석 프로세스가 중요하다.</p><ul><li><strong>DB 에러 로그</strong>: <code>deadlock detected</code>, <code>serialization failure</code>, deadlock victim stack. 로그 수준을 운영에 맞춰 (일시적 증가 시 ROTATION/샘플링).</li><li><strong>애플리케이션 로그</strong>: ORM 예외 (<code>StaleObject</code>, <code>OptimisticLockException</code>), 재시도 이벤트, SQL 에러코드 (40001 등).</li><li><strong>로그 파이프라인</strong>: 중앙 로그 스토리지 (ELK, Loki 등) 로 전송하고, 쿼리 가능한 지표로 추출.</li></ul><table><thead><tr><th>로그 타입</th><th style=text-align:right>왜 중요한가</th><th>수집 방식</th><th>활용</th></tr></thead><tbody><tr><td>DB 데드락 로그</td><td style=text-align:right>누가 victim 인지, 쿼리 확인</td><td>파일→로그수집기 (ELK)</td><td>원인 쿼리/트랜잭션 재구성</td></tr><tr><td>Serialization Failure</td><td style=text-align:right>낙관적 충돌 증거</td><td>앱 로그/DB 에러코드</td><td>재시도 로직 점검</td></tr><tr><td>ORM StaleObject</td><td style=text-align:right>애플리케이션 레벨 충돌</td><td>앱 로그</td><td>비즈니스 로직 개선 포인트</td></tr></tbody></table><ul><li>로그는 이벤트의 증거를 제공한다. 자동화된 로그 분석 (패턴 추출, 상관관계) 으로 높은 재시도율이나 특정 쿼리의 반복성을 찾아내라.</li></ul><h6 id=트레이스쿼리-수준-진단>트레이스·쿼리 수준 진단<a hidden class=anchor aria-hidden=true href=#트레이스쿼리-수준-진단>#</a></h6><p>심층 원인 분석을 위해 쿼리 플랜·트레이스·샘플링을 사용한다.</p><ul><li><strong>Top updating queries</strong>: 가장 자주 update 되는 쿼리 목록, 쿼리별 평균 대기/응답 시간.</li><li><strong>쿼리 플랜 분석</strong>: 인덱스 누락, 풀스캔, 행 잠금 범위 확대 여부 확인.</li><li><strong>분산 트레이스</strong>: 트랜잭션 경로 (서비스 → DB) 에서 지연·재시도 지점 식별.</li></ul><table><thead><tr><th>진단 항목</th><th style=text-align:right>목적</th><th>도구/방법</th></tr></thead><tbody><tr><td>Top update queries</td><td style=text-align:right>Hot row·빈발 업데이트 탐지</td><td>pg_stat_statements, Percona Toolkit</td></tr><tr><td>쿼리 플랜</td><td style=text-align:right>잠금 범위·비효율 판별</td><td>EXPLAIN ANALYZE</td></tr><tr><td>분산 트레이스</td><td style=text-align:right>서비스 -DB 상호작용 확인</td><td>OpenTelemetry, Jaeger</td></tr></tbody></table><ul><li>업데이트를 많이 발생시키는 쿼리와 그 플랜을 보면 Hot row, 범위 락, 잘못된 인덱스 등의 근본 원인을 찾기 쉽다.</li></ul><h6 id=대시보드알림자동화-대응>대시보드·알림·자동화 (대응)<a hidden class=anchor aria-hidden=true href=#대시보드알림자동화-대응>#</a></h6><p>탐지 → 진단 후 즉시 조치·장기 개선으로 연결.</p><ul><li><strong>대시보드</strong>: 실시간 메트릭 (P99, deadlocks/min, retry%) + 트렌드 (1h/24h).</li><li><strong>알림 규칙</strong>: 단계별 (Warning → Critical) 알림, 자동화 (예: 초과 시 자동 샘플 트레이스 활성화).</li><li><strong>자동화 플레이북</strong>: 높은 재시도율 시 자동 트래픽 셰이핑, Hot row 발견 시 DB 스키마/쿼리 변경 제안 알림.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>예시 자동화</th></tr></thead><tbody><tr><td>알림 룰</td><td style=text-align:right>조기 경보</td><td>P99 lock wait > 500ms -> 경고</td></tr><tr><td>샘플 트레이스</td><td style=text-align:right>문제 재현 데이터 확보</td><td>알림 시 5 분간 트레이스 샘플링</td></tr><tr><td>운영 플레이북</td><td style=text-align:right>즉시 대응</td><td>deadlock 급증 -> 특정 서비스 일시 차단 (스로틀)</td></tr></tbody></table><ul><li>탐지에서 끝나지 않고 자동화된 진단·임시 완화 조치 (스로틀링·배치 조정) 로 문제의 영향 범위를 줄이는 것이 핵심이다.</li></ul><h5 id=lost-update-관측-통합-체크리스트>Lost Update 관측 통합 체크리스트<a hidden class=anchor aria-hidden=true href=#lost-update-관측-통합-체크리스트>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>주요 지표/로그</th><th>목적 (탐지/진단/대응)</th><th>수집 방법</th><th>대표 대응</th></tr></thead><tbody><tr><td>실시간 탐지</td><td style=text-align:right>락 대기, 데드락, Retry 율, 장기 TX</td><td>탐지</td><td>pg_stat_activity, perf_schema, 앱 로그</td><td>알림, 샘플링 트레이스</td></tr><tr><td>로그·이벤트</td><td style=text-align:right>deadlock detected, serialization failure, ORM 예외</td><td>진단 (증거)</td><td>DB 로그, 로그 수집기 (ELK)</td><td>로그 상관분석, 원인 쿼리 식별</td></tr><tr><td>트레이스·쿼리 진단</td><td style=text-align:right>Top update queries, EXPLAIN</td><td>심층 원인분석</td><td>pg_stat_statements, EXPLAIN, Tracing</td><td>쿼리 수정, 인덱스/스키마 변경</td></tr><tr><td>대시보드·자동화</td><td style=text-align:right>알림 규칙, 샘플 트레이스</td><td>대응/완화</td><td>모니터링 시스템 (Grafana/Prometheus)</td><td>자동 샘플·스로틀·운영 플레이북</td></tr></tbody></table><h4 id=lost-update-보안감사-통합-설계>Lost Update 보안·감사 통합 설계<a hidden class=anchor aria-hidden=true href=#lost-update-보안감사-통합-설계>#</a></h4><p>Lost Update 를 예방하려면 <em>누가</em> 언제 어떤 변경을 했는지 (감사 로그), <em>누가</em> 그 권한을 갖는지 (접근 제어), 그리고 <em>어떤 방식으로</em> 충돌을 막는지 (트랜잭션 제어) 를 함께 설계해야 한다.</p><ul><li><strong>운영 체크리스트 (초급)</strong><ol><li>중요한 테이블에 대해 <strong>변경 전/후 상태를 기록하는 감사 로그</strong>가 있는가?</li><li>로그는 중앙에 모이고 무결성 (해시/서명) 으로 보호되는가?</li><li>민감 테이블 (금융·원장) 에는 강한 격리 (예: Serializable) 또는 버전검사 패턴을 적용하는가?</li><li>권한은 최소화되어 있고, 락 취득 권한은 관리되는가?</li><li>이상징후 (충돌 증가 등) 를 모니터링·알람으로 감지하는가?</li></ol></li></ul><h5 id=lost-update-보안컴플라이언스-카테고리>Lost Update 보안·컴플라이언스 카테고리<a hidden class=anchor aria-hidden=true href=#lost-update-보안컴플라이언스-카테고리>#</a></h5><h6 id=감사-추적-audit--immutable-trail>감사 추적 (Audit & Immutable Trail)<a hidden class=anchor aria-hidden=true href=#감사-추적-audit--immutable-trail>#</a></h6><p>변경 전후 상태 (Before/After), 트랜잭션 ID, 사용자/서비스계정, 타임스탬프, 변경 쿼리, 로그 해시 (무결성) 를 필수로 기록.<br>감사 로그는 append-only(변조 불가) 스토리지 또는 외부 SIEM 으로 전송. DB 내 트리거 (pgAudit 등) 혹은 애플리케이션 레벨 이벤트 소싱을 병행.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>before/after</td><td style=text-align:right>변경 증빙 및 복원 근거</td><td>트리거/애플리케이션에서 캡처</td></tr><tr><td>트랜잭션 ID/유저</td><td style=text-align:right>책임 추적 (Who)</td><td>UUID 트랜잭션 식별자 포함</td></tr><tr><td>타임스탬프</td><td style=text-align:right>변경 시점 증빙</td><td>정밀 타임스탬프 (UTC)</td></tr><tr><td>로그 무결성</td><td style=text-align:right>변조 방지</td><td>해시·서명, WORM 저장소</td></tr><tr><td>중앙집중화</td><td style=text-align:right>조사·대응 효율</td><td>SIEM/로그 스토리지 전송</td></tr></tbody></table><ul><li>감사 추적은 Lost Update 의 발생 근거를 입증하고 재구성하기 위한 핵심 수단이다. 변경 전·후 상태와 트랜잭션 식별자를 보존하면 누가 무엇을 덮어썼는지 검증 가능하며, 로그 무결성은 규제 대응에서 필수다.</li></ul><h6 id=접근-제어-access-control--privilege>접근 제어 (Access Control & Privilege)<a hidden class=anchor aria-hidden=true href=#접근-제어-access-control--privilege>#</a></h6><p>최소 권한 원칙으로 트랜잭션·락 취득 권한을 분리.<br>애플리케이션 계정과 운영 (관리) 계정을 분리하고, 권한 변경은 감사 로그로 남김.<br>클라우드 DB 의 IAM 연동과 역할 기반 접근 제어 권장.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>최소 권한</td><td style=text-align:right>우발적·악의적 변경 방지</td><td>역할·권한 세분화</td></tr><tr><td>락 권한 분리</td><td style=text-align:right>임의 락 사용 통제</td><td>관리자 전용 락 정책</td></tr><tr><td>계정 분리</td><td style=text-align:right>책임 구분</td><td>서비스 계정/운영 계정 분리</td></tr><tr><td>권한 변경 감사</td><td style=text-align:right>변경 추적</td><td>권한 변경 로그 보존</td></tr></tbody></table><ul><li>권한을 적절히 제한하면 의도치 않은 동시 변경을 줄일 수 있다. 특히 락 (SELECT FOR UPDATE 등) 권한을 통제하면 시스템 안정성·감사성이 동시에 개선된다.</li></ul><h6 id=트랜잭션-제어-transactional-integrity>트랜잭션 제어 (Transactional Integrity)<a hidden class=anchor aria-hidden=true href=#트랜잭션-제어-transactional-integrity>#</a></h6><p>비즈니스 중요도에 따라 Serializable 등 강한 격리 적용 또는 낙관적 버전검사 (버전 필드/ETag) 사용.<br>분산 환경은 conditional writes(조건부 업데이트) 나 이벤트 소싱/Saga 패턴으로 설계. 충돌 시 재시도 정책과 감사 로그를 연계.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>격리 수준 (Serializable)</td><td style=text-align:right>완전한 일관성 보장</td><td>성능 영향 검토 후 적용</td></tr><tr><td>낙관적 락</td><td style=text-align:right>충돌시 재시도 통한 보존</td><td>버전 필드, 조건부 업데이트</td></tr><tr><td>비관적 락</td><td style=text-align:right>쓰기 동시성 완전 차단</td><td>SELECT FOR UPDATE 등</td></tr><tr><td>분산 패턴</td><td style=text-align:right>글로벌 일관성 확보</td><td>conditional writes, Saga</td></tr></tbody></table><ul><li>트랜잭션 제어는 Lost Update 를 직접 예방하는 계층이다. 강한 격리는 안전하지만 성능 영향이 있으므로, 낙관적/비관적 기법을 조합해 적용하는 것이 실무적이다.</li></ul><h6 id=운영-모니터링탐지-ops--detection>운영 모니터링·탐지 (Ops & Detection)<a hidden class=anchor aria-hidden=true href=#운영-모니터링탐지-ops--detection>#</a></h6><p>충돌률·재시도율·비정상적 다중 쓰기 이벤트를 지표화하고 SIEM/알람으로 연결.<br>로그 무결성 검사 (정기 해시 비교) 및 포렌식 워크플로를 수립.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>충돌률 모니터링</td><td style=text-align:right>이상 탐지</td><td>충돌 지표 → 알람</td></tr><tr><td>로그 무결성 검사</td><td style=text-align:right>변조 탐지</td><td>정기 해시/서명 확인</td></tr><tr><td>자동 대응</td><td style=text-align:right>빠른 격리/복구</td><td>재시도·차단·알람 워크플로</td></tr><tr><td>대시보드</td><td style=text-align:right>운영 가시성</td><td>충돌·성능 지표 시각화</td></tr></tbody></table><ul><li>Lost Update 는 간헐적으로 나타나므로 계측과 자동화된 탐지·대응 체계가 있어야 실제 리스크를 줄일 수 있다. 중앙화된 로그·SIEM 통합이 효과적이다.</li></ul><h6 id=규정준수보존-compliance--retention>규정준수·보존 (Compliance & Retention)<a hidden class=anchor aria-hidden=true href=#규정준수보존-compliance--retention>#</a></h6><p>규제별 로그 보존기간·무결성 요구를 정책화 (예: PCI 의 로그 보존 권고·SOX 의 재무 증빙 요건).<br>보존은 암호화·WORM·백업 전략과 함께 운영.</p><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>보존 기간</td><td style=text-align:right>규제 준수</td><td>규제별 정책 문서화</td></tr><tr><td>무결성 보장</td><td style=text-align:right>법적 증빙 확보</td><td>WORM/해시/서명 저장</td></tr><tr><td>문서화</td><td style=text-align:right>감사 대비</td><td>정책·절차·증적 파일화</td></tr><tr><td>정기 감사</td><td style=text-align:right>규정 지속 충족</td><td>내부·외부 감사 리포트</td></tr></tbody></table><ul><li>보존·무결성 요구는 규제 리스크를 줄이는 핵심 요소다. 로그 정책·보존·증빙 체계를 미리 설계하면 감사 시 빠르게 대응 가능하다.</li></ul><h5 id=lost-update-보안컴플라이언스-통합표>Lost Update 보안·컴플라이언스 통합표<a hidden class=anchor aria-hidden=true href=#lost-update-보안컴플라이언스-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>핵심 수단</th><th style=text-align:right>규제·실무 목적</th><th>구현 우선순위</th></tr></thead><tbody><tr><td>감사 추적</td><td style=text-align:right>before/after, 트랜잭션 ID, 해시</td><td style=text-align:right>증빙·포렌식·감사대응</td><td>높음</td></tr><tr><td>접근 제어</td><td style=text-align:right>최소권한, 계정 분리</td><td style=text-align:right>무단 변경 방지</td><td>높음</td></tr><tr><td>트랜잭션 제어</td><td style=text-align:right>Serializable, 버전검사, conditional write</td><td style=text-align:right>Lost Update 예방</td><td>높음 (데이터 중요도에 따라)</td></tr><tr><td>운영 모니터링</td><td style=text-align:right>충돌률 지표, SIEM 알람</td><td style=text-align:right>신속 탐지·대응</td><td>중~높</td></tr><tr><td>규정준수</td><td style=text-align:right>보존정책, WORM, 감사 리포트</td><td style=text-align:right>법적·회계적 증빙</td><td>높음 (규제 산업 필수)</td></tr></tbody></table><p>모든 항목은 상호보완적이다.<br>감사 로그와 접근 제어가 있어야 증빙과 책임 추적이 가능하고, 트랜잭션 제어가 있어야 실제 Lost Update 를 예방할 수 있다.<br>운영 모니터링은 문제가 발생했을 때 빠르게 포착하게 해주며, 규정준수는 법적·회계적 요구를 만족시킨다. 우선순위는 데이터의 민감도와 규제 요건에 따라 조정하라.</p><h4 id=lost-update-성능확장성-전략>Lost Update 성능·확장성 전략<a hidden class=anchor aria-hidden=true href=#lost-update-성능확장성-전략>#</a></h4><p>성능을 유지하면서 Lost Update 를 줄이려면 먼저 트랜잭션을 가능한 짧게 만들고, 단순한 증감 연산은 DB 의 원자적 UPDATE 로 처리한다.<br>쓰기 집중 (핫스팟) 이 문제면 파티셔닝/샤딩으로 분산하고, 데이터 무결성이 더 중요하면 특정 경로에 한해 격리 수준을 높인다.<br>충돌은 낙관적 버전 검사와 재시도로 다루고, 핫스팟은 샤드키·리밸런싱·모니터링으로 해결한다.</p><h5 id=성능확장성-최적화-핵심-카테고리>성능·확장성 최적화 핵심 카테고리<a hidden class=anchor aria-hidden=true href=#성능확장성-최적화-핵심-카테고리>#</a></h5><h6 id=트랜잭션-단축--원자적-연산>트랜잭션 단축 & 원자적 연산<a hidden class=anchor aria-hidden=true href=#트랜잭션-단축--원자적-연산>#</a></h6><p>짧은 트랜잭션은 락 시간과 충돌 창을 줄여 성능을 개선한다.<br>가능한 연산을 원자적 SQL(예: <code>UPDATE t SET v = v +?</code>) 로 표현해 애플리케이션 레벨의 read→compute→write 패턴을 제거하면 Lost Update 위험이 낮아진다.<br>트랜잭션 내 I/O(외부 API 호출, 파일 등) 는 비동기로 분리한다.</p><h6 id=동시성-제어-전략-선택지>동시성 제어 전략 선택지<a hidden class=anchor aria-hidden=true href=#동시성-제어-전략-선택지>#</a></h6><p>비관적 락 (SELECT FOR UPDATE) 은 충돌을 예방하지만 대기·교착 가능성이 있으므로 중요 자원에 한해 사용한다.<br>낙관적 버저닝은 충돌 탐지 후 재시도로 확장성에 유리하며, 동적 격리 조절로 핵심 경로만 높은 격리를 적용하면 전체 성능 영향을 줄일 수 있다.</p><h6 id=데이터-분산-및-핫스팟-대응>데이터 분산 및 핫스팟 대응<a hidden class=anchor aria-hidden=true href=#데이터-분산-및-핫스팟-대응>#</a></h6><p>파티셔닝/샤딩으로 쓰기 부담을 분산하되 샤드키·파티션 전략을 접근 패턴에 맞춰 설계해야 한다.<br>핫스팟은 키 재설계, 라운드로빈·해시 기반 분배, 리밸런싱으로 완화한다.<br>모니터링으로 핫스팟을 조기 발견해야 한다.</p><h6 id=운영재시도모니터링-전략>운영·재시도·모니터링 전략<a hidden class=anchor aria-hidden=true href=#운영재시도모니터링-전략>#</a></h6><p>충돌 감지 시 애플리케이션 레벨 재시도 (지수 백오프), 충돌률·재시도 횟수 모니터링, 자동 리밸런싱 정책을 운영에 포함한다.<br>Jepsen 스타일 동시성 테스트로 검증하면 믿을 만한 안정성을 확보할 수 있다.</p><h5 id=성능확장성-통합-실행표>성능·확장성 통합 실행표<a hidden class=anchor aria-hidden=true href=#성능확장성-통합-실행표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 기법</th><th style=text-align:right>목적 (무엇을 해결)</th><th>실무 적용 포인트</th></tr></thead><tbody><tr><td>A 트랜잭션 단축</td><td>원자적 UPDATE, 트랜잭션 범위 최소화</td><td style=text-align:right>락 시간·충돌 창 감소</td><td>외부 I/O 분리, 가능한 연산을 SQL 로 옮김.</td></tr><tr><td>B 동시성 제어</td><td>SELECT FOR UPDATE, 낙관적 버전, 동적 격리</td><td style=text-align:right>충돌 예방/탐지·성능 균형</td><td>충돌 빈도 기반 전략 선택, 재시도 정책 필요.</td></tr><tr><td>C 분산 구조</td><td>파티셔닝/샤딩, 샤드키 설계</td><td style=text-align:right>핫스팟 완화·수평 확장</td><td>샤드키 분석, 리밸런싱·모니터링 중요.</td></tr><tr><td>D 운영·재시도</td><td>재시도 (백오프), 충돌 모니터링, 테스트</td><td style=text-align:right>일시적 충돌 자동 복구</td><td>지표 (충돌률) 기준 경보·Jepsen 스타일 검증.</td></tr></tbody></table><ul><li>핵심 방식은 &rsquo; 충돌을 구조적으로 줄이기 (A/C)&rsquo;, &rsquo; 충돌 발생 시 자동 복구 (B/D)&rsquo;, &rsquo; 부하 분산으로 근본 원인 제거 (C)&rsquo; 세 축으로 이해하면 된다.</li></ul><h4 id=lost-update-문제-해결-탐지대응예방>Lost Update 문제 해결 (탐지·대응·예방)<a hidden class=anchor aria-hidden=true href=#lost-update-문제-해결-탐지대응예방>#</a></h4><p>Lost Update 문제는 여러 트랜잭션이 같은 데이터를 동시에 읽어 업데이트할 때 한쪽 변경이 덮여 사라지는 현상이다.<br>우선 원자적 SQL(예: <code>UPDATE … SET v = v + 1</code>) 로 애플리케이션 RMW 를 제거하고, 충돌이 적으면 낙관적 락 (버전 비교 + 재시도), 충돌이 잦거나 핫스팟이면 비관적 락 (<code>SELECT … FOR UPDATE</code>) 을 사용한다.<br>운영에서는 충돌률·재시도율·락 대기시간을 모니터링하고 재시도 정책 (지수적 백오프·멱등성) 을 명확히 설계해야 문제를 안정적으로 제어할 수 있다.</p><h5 id=lost-update-트러블슈팅-분류>Lost Update 트러블슈팅 분류<a hidden class=anchor aria-hidden=true href=#lost-update-트러블슈팅-분류>#</a></h5><h6 id=탐지-detection>탐지 (Detection)<a hidden class=anchor aria-hidden=true href=#탐지-detection>#</a></h6><p>동시성 이상을 빠르게 감지하는 단계.</p><ul><li><p>핵심 행동: 슬로우 쿼리, 트랜잭션 롱런, 락 보유 보고서, 애플리케이션 예외 집계 확인.</p></li><li><p>진단 쿼리 (실무 예시):</p><ul><li>PostgreSQL: <code>SELECT pid, query, state, now() - query_start AS duration FROM pg_stat_activity WHERE state &lt;> 'idle';</code></li><li>PostgreSQL 락: <code>SELECT * FROM pg_locks l JOIN pg_stat_activity a ON l.pid = a.pid;</code></li><li>MySQL: <code>SHOW PROCESSLIST; SHOW ENGINE INNODB STATUS;</code></li></ul></li><li><p>지표: 충돌률 (%), 평균 락 대기 (ms), 트랜잭션 95/99 백분위 지연, 리플리카 지연 (ms)</p></li></ul><table><thead><tr><th>탐지 항목</th><th style=text-align:right>증상</th><th>점검 방법</th><th style=text-align:right>우선 알람 기준</th></tr></thead><tbody><tr><td>트랜잭션 롱런</td><td style=text-align:right>트랜잭션 실행 시간이 정상보다 큼</td><td>DB 트랜잭션 뷰 쿼리 (위 예시)</td><td style=text-align:right>p95 트랜잭션 > 5s</td></tr><tr><td>락 보유</td><td style=text-align:right>특정 세션이 락을 오래 가짐</td><td>pg_locks / INNODB STATUS</td><td style=text-align:right>락 보유 > 2s</td></tr><tr><td>충돌 예외</td><td style=text-align:right>애플리케이션에서 version 충돌 예외</td><td>애플리케이션 로그 집계</td><td style=text-align:right>충돌률 > 0.5%</td></tr><tr><td>리플리카 지연</td><td style=text-align:right>읽기 복제본 지연</td><td>replica status 조회</td><td style=text-align:right>지연 > 200ms</td></tr></tbody></table><ul><li>요약: 탐지는 DB·애플리케이션 로그와 실시간 지표를 결합해 조기 경보를 만들고, 문제 발생 시 즉시 원인 범위를 좁힌다.</li></ul><h6 id=즉시-대응-immediate-remediation>즉시 대응 (Immediate Remediation)<a hidden class=anchor aria-hidden=true href=#즉시-대응-immediate-remediation>#</a></h6><p>현장 첫 대응 절차 (서비스 영향 최소화 목적).</p><ul><li><p>절차:</p><ol><li>영향을 받는 트랜잭션/세션 식별</li><li>위험 트랜잭션 강제 롤백 또는 타임아웃 설정</li><li>세션 단위로 세션 읽기 강제 (master read) 또는 트래픽 셰이드 오프</li><li>임시로 핵심 경로의 격리 수준 상향 (단기).</li></ol></li><li><p>권장 우선순위: 트랜잭션 범위 축소 → 원자적 SQL 적용 (가능 시) → 재시도 정책 활성화</p></li></ul><table><thead><tr><th>대응 단계</th><th style=text-align:right>행동</th><th style=text-align:right>효과</th><th style=text-align:right>검증</th></tr></thead><tbody><tr><td>식별</td><td style=text-align:right>문제가 되는 세션/쿼리 찾기</td><td style=text-align:right>영향 범위 확인</td><td style=text-align:right>세션 종료 후 시스템 정상화 여부</td></tr><tr><td>롤백/타임아웃</td><td style=text-align:right>세션 강제 종료 또는 타임아웃 단축</td><td style=text-align:right>즉시 락 해제</td><td style=text-align:right>락 해제 로그 확인</td></tr><tr><td>읽기 강제</td><td style=text-align:right>리플리카 대신 마스터에서 읽기</td><td style=text-align:right>스테일 리드 제거</td><td style=text-align:right>일관성 확인</td></tr><tr><td>임시 격리 변경</td><td style=text-align:right>특정 경로에만 Serializable 적용</td><td style=text-align:right>일관성 확보</td><td style=text-align:right>성공적 커밋율 확인</td></tr></tbody></table><ul><li>요약: 즉시 대응은 운영 중단을 최소화하면서 일관성 확보를 목표로 한다. 근본 해결 전 임시 조치로 사용한다.</li></ul><h6 id=근본-해결-root-cause-fixes>근본 해결 (Root-cause Fixes)<a hidden class=anchor aria-hidden=true href=#근본-해결-root-cause-fixes>#</a></h6><p>재발 방지를 위한 설계/코드 수정.</p><ul><li><p>기술 옵션:</p><ul><li><strong>원자적 SQL</strong>: 가능한 연산은 DB 에서 처리.</li><li><strong>낙관적 락</strong>: <code>version</code> 컬럼 + 애플리케이션 재시도 (지수적 백오프).</li><li><strong>비관적 락</strong>: 핫스팟이 명확한 경우에만 사용.</li><li><strong>격리 수준 조정</strong>: 핵심 트랜잭션에만 Serializable 적용.</li><li><strong>아키텍처 변경</strong>: CQRS, 이벤트 소싱, 단일 라이터 패턴 (샤드별).</li></ul></li><li><p>구현 체크리스트: 멱등성, 최대 재시도 횟수, 지수 백오프, 트랜잭션 시간 단축, 인덱스 최적화</p></li></ul><table><thead><tr><th>해결책</th><th style=text-align:right>적용 조건</th><th>장점</th><th>단점/비고</th></tr></thead><tbody><tr><td>원자적 SQL</td><td style=text-align:right>연산이 DB 로 표현 가능할 때</td><td>단순·성능 우수</td><td>복잡 로직 한계</td></tr><tr><td>낙관적 락</td><td style=text-align:right>충돌 빈도 낮음</td><td>락 없음·읽기 성능 우수</td><td>재시도 로직 필요</td></tr><tr><td>비관적 락</td><td style=text-align:right>핫스팟 존재 시</td><td>충돌 회피 확실</td><td>락 대기·데드락 위험</td></tr><tr><td>아키텍처 변경</td><td style=text-align:right>복잡 일관성 요구</td><td>근본적 스케일·일관성 개선</td><td>구현 비용 큼</td></tr></tbody></table><ul><li>요약: 근본 해결은 서비스 요구 (성능·일관성) 에 따라 적절한 방식으로 선택·혼합해야 하며, 멱등성·재시도 설계가 중요하다.</li></ul><h6 id=운영예방-operational--prevention>운영·예방 (Operational & Prevention)<a hidden class=anchor aria-hidden=true href=#운영예방-operational--prevention>#</a></h6><p>장기적 안정화를 위한 모니터링·정책·테스트.</p><ul><li><p>핵심 요소: 충돌률·재시도율 알림, 락 대기 임계값 알림, 리플리카 지연 경고, 정기적 재현 테스트 (부하·카오스).</p></li><li><p>자동화: 자동 재시도 엔진 (재시도 제한·백오프), 운영 runbook(발생 시 체크리스트), 데드락 자동 탐지·알림.</p></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>지표</th><th style=text-align:right>알람 임계값 예시</th><th>운영 조치</th></tr></thead><tbody><tr><td>충돌률</td><td style=text-align:right>충돌 예외 수 / 트랜잭션 수</td><td style=text-align:right>> 0.5% 경고</td><td>우선순위 분석, 코드·쿼리 점검</td></tr><tr><td>재시도율</td><td style=text-align:right>재시도 이벤트 비율</td><td style=text-align:right>> 2% 경고</td><td>백오프 조정, 재시도 한도 설정</td></tr><tr><td>락 대기</td><td style=text-align:right>평균 락 대기 (ms)</td><td style=text-align:right>p95 > 2000ms</td><td>트랜잭션 분해, 인덱스 점검</td></tr><tr><td>리플리카 지연</td><td style=text-align:right>초 단위 지연</td><td style=text-align:right>> 0.2s 경고</td><td>세션 고정, 복제 토폴로지 점검</td></tr></tbody></table><ul><li>요약: 운영은 탐지→대응→근본 해결 사이클을 자동화·측정화하여 재발을 줄이는 것이 목표다.</li></ul><h5 id=lost-update-종합-트러블슈팅-표>Lost Update 종합 트러블슈팅 표<a hidden class=anchor aria-hidden=true href=#lost-update-종합-트러블슈팅-표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>핵심 목표</th><th>주요 행동</th><th>주요 지표/검증</th></tr></thead><tbody><tr><td>탐지</td><td style=text-align:right>조기 인지</td><td>슬로우 쿼리/락 뷰/충돌 예외 집계</td><td>충돌률, 락 대기, 트랜잭션 p95</td></tr><tr><td>즉시 대응</td><td style=text-align:right>서비스 영향 최소화</td><td>세션 롤백/타임아웃, 마스터 읽기 강제</td><td>락 해제 여부, 정상 커밋율</td></tr><tr><td>근본 해결</td><td style=text-align:right>재발 방지</td><td>원자적 SQL, 낙관·비관적 락, 아키텍처 변경</td><td>재시도율, 충돌률 감소</td></tr><tr><td>운영·예방</td><td style=text-align:right>장기 안정화</td><td>모니터링/알람, 카오스 테스트, 자동화</td><td>알람 빈도 감소, 회귀 테스트 통과율</td></tr></tbody></table><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>Lost Update 는 트랜잭션 동시성 제어에서 자주 마주치는 일관성 오류다.<br>문제의 핵심은 트랜잭션이 &rsquo; 읽기 → 애플리케이션 계산 → 쓰기 &rsquo; 의 흐름을 가질 때, 계산에 쓰인 입력이 이미 다른 트랜잭션에 의해 변경될 수 있다는 점이다.</p><p>초기 DBMS 는 락 (비관적) 으로 강하게 막았고, 이후 성능을 위해 낙관적 기법과 MVCC 가 도입됐다.<br>MVCC 는 읽기 성능을 개선하지만, 쓰기 - 쓰기 충돌을 엔진이 어떻게 처리하느냐에 따라 Lost Update 가 여전히 발생할 수 있다.<br>그래서 실무에서는 가능한 연산을 DB 에서 원자적으로 처리하고 (예: <code>UPDATE … SET x = x - 1 WHERE x > 0</code>), 충돌이 드물면 버전 기반 낙관적 재시도 패턴을 채택하며, 충돌이 잦거나 순서 보장이 필수적이면 비관적 락 또는 Serializable 과 같은 강한 격리 수준을 선택한다.<br>관찰·운영 측면에서는 락 대기·데드락·재시도 실패율·장기 트랜잭션·핫로우를 모니터링하고, 로그·트레이스와 결합해 근본 원인을 규명하는 것이 효과적인 관리의 핵심이다.<br>분산 환경에서는 추가로 타임스탬프 분배, 2PC, 이벤트 드리븐 아키텍처 같은 설계적 선택이 필요하다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>체크리스트 항목</th><th style=text-align:right>목적</th><th>구체적 조치 (예시)</th><th>참고/비고</th></tr></thead><tbody><tr><td>갱신 경로에 상수 UPDATE 존재 여부 점검</td><td style=text-align:right>불필요한 덮어쓰기 제거</td><td>코드 리뷰로 고정 UPDATE 제거, 데이터 흐름 리팩토링</td><td>고정값 덮어쓰기 주의</td></tr><tr><td>ORM 낙관 잠금 활성화</td><td style=text-align:right>충돌 감지 (낙관적)</td><td>JPA <code>@Version</code>, SQLAlchemy <code>version_id_col</code> 설정 및 예외 처리 로직 구현.</td><td>충돌 잦으면 성능 고려</td></tr><tr><td>재시도·멱등 구현</td><td style=text-align:right>네트워크/분산 실패 안전화</td><td>Idempotency key 저장 (데이터베이스/캐시), 재시도 백오프·한계 구현.</td><td>외부 API 포함 시 필수</td></tr><tr><td>격리 레벨·락 정책 문서화</td><td style=text-align:right>일관성·운영 예측성 확보</td><td>DB 별 격리 특징 문서화 (예: PostgreSQL Serializable 등), 업무별 권장 격리 적용.</td><td>운영 정책으로 고정</td></tr><tr><td>핵심 테이블에 FOR UPDATE 적용</td><td style=text-align:right>덮어쓰기 방지 (단일 DB 환경)</td><td>트랜잭션에서 <code>SELECT … FOR UPDATE</code> 로 행 선점 후 빠르게 업데이트 커밋.</td><td>분산 샤딩 환경 신중 적용</td></tr><tr><td>데드락/타임아웃 정책</td><td style=text-align:right>시스템 안정성 확보</td><td>트랜잭션 타임아웃 설정, 데드락 감지 시 재시도 전략</td><td>복구 시나리오 필요</td></tr><tr><td>모니터링 지표 설정</td><td style=text-align:right>조기 경고·운영 대응</td><td>충돌률, 재시도율, 롱 트랜잭션 비율, 데드락 카운트 대시보드 구성</td><td>SIEM/모니터 통합 권장</td></tr><tr><td>테스트 케이스 (동시성) 포함</td><td style=text-align:right>재현·검증 용이성 확보</td><td>멀티클라이언트 동시성 테스트 스크립트 작성·자동화</td><td>CI 파이프라인 연계 권장</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th>핵심 목표</th><th>핵심 주제 (예시)</th><th>학습 목표</th><th>실무 연관성</th><th>권장 학습 방식</th></tr></thead><tbody><tr><td style=text-align:right>1 기초</td><td>Lost Update 의 원인·정의 이해</td><td>트랜잭션·ACID·격리 수준·이상 유형</td><td>개념 숙지, 사례 분석</td><td>매우 높음</td><td>읽기 + 짧은 실습 (트랜잭션 실험)</td></tr><tr><td style=text-align:right>2 핵심</td><td>방지 기법의 원리 이해·선택 기준 습득</td><td>원자적 SQL, 비관적 락, 낙관적 버전, MVCC</td><td>기법별 트레이드오프 판단</td><td>높음</td><td>실습 (쿼리·잠금·버전 구현)</td></tr><tr><td style=text-align:right>3 응용</td><td>프레임워크·운영 적용 능력</td><td>ORM 동작, 메시징, 캐시 일관성, 재시도 정책</td><td>코드·운영 적용, 테스트 설계</td><td>중간~높음</td><td>프로젝트형 실습, 통합 테스트</td></tr><tr><td style=text-align:right>4 고급</td><td>분산·확장 아키텍처 설계·검증</td><td>샤딩·파티셔닝, 분산 락, 2PC/Saga, CRDT, Jepsen</td><td>설계·검증·모니터링 능력</td><td>높음 (대규모)</td><td>아키텍처 실습, 스트레스·Jepsen 테스트</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th>항목 (세부)</th><th style=text-align:right>중요도</th><th>학습 목표</th><th style=text-align:right>실무 연관성</th><th>설명 / 실습 제안</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>트랜잭션과 ACID</td><td style=text-align:right>필수</td><td>트랜잭션 기본 이해</td><td style=text-align:right>매우 높음</td><td>BEGIN/COMMIT/ROLLBACK 실습</td></tr><tr><td style=text-align:right>1</td><td>격리 수준 & 이상 유형</td><td style=text-align:right>필수</td><td>Read Committed 등과 Lost Update 관계 이해</td><td style=text-align:right>매우 높음</td><td>4 가지 이상 (Dirty/Non-repeatable/Phantom/Lost Update) 재현 실습</td></tr><tr><td style=text-align:right>2</td><td>원자적 UPDATE 패턴</td><td style=text-align:right>필수</td><td>산술 갱신을 안전하게 처리</td><td style=text-align:right>높음</td><td><code>UPDATE t SET v = v +?</code> 실험</td></tr><tr><td style=text-align:right>2</td><td>비관적 락 (FOR UPDATE)</td><td style=text-align:right>필수</td><td>선점 방식의 장단점 습득</td><td style=text-align:right>높음</td><td>동시성 시나리오로 교착/대기 관찰</td></tr><tr><td style=text-align:right>2</td><td>낙관적 버저닝</td><td style=text-align:right>필수</td><td>버전 비교·재시도 패턴 설계</td><td style=text-align:right>높음</td><td>version 컬럼 + UPDATE WHERE version=? 구현</td></tr><tr><td style=text-align:right>2</td><td>MVCC 내부 개념</td><td style=text-align:right>권장</td><td>스냅샷·커밋 타이밍 이해</td><td style=text-align:right>중간</td><td>PostgreSQL/InnoDB 행동 비교 실습</td></tr><tr><td style=text-align:right>3</td><td>ORM 과 락/버저닝 연동</td><td style=text-align:right>권장</td><td>프레임워크 계층의 동작 이해</td><td style=text-align:right>중간</td><td>Hibernate/JPA 예제 적용</td></tr><tr><td style=text-align:right>3</td><td>메시지 기반 처리·Sagas</td><td style=text-align:right>권장</td><td>비동기 워크플로우로 트랜잭션 분해</td><td style=text-align:right>중간</td><td>간단한 SAGA 설계·시뮬레이션</td></tr><tr><td style=text-align:right>3</td><td>캐시 일관성 전략</td><td style=text-align:right>권장</td><td>캐시 무효화/쓰기 전략 이해</td><td style=text-align:right>중간</td><td>read-through/write-through 패턴 실습</td></tr><tr><td style=text-align:right>3</td><td>재시도 정책·백오프</td><td style=text-align:right>필수</td><td>충돌시 자동 복구 설계</td><td style=text-align:right>높음</td><td>지수 백오프 구현·테스트</td></tr><tr><td style=text-align:right>4</td><td>파티셔닝·샤딩 설계</td><td style=text-align:right>필수</td><td>샤드키·리밸런싱 고려</td><td style=text-align:right>높음</td><td>샤딩 시뮬레이션, 핫스팟 재현</td></tr><tr><td style=text-align:right>4</td><td>분산 락·2PC·Sagas</td><td style=text-align:right>권장</td><td>분산 일관성 패턴 이해</td><td style=text-align:right>높음</td><td>분산 트랜잭션 시나리오 분석</td></tr><tr><td style=text-align:right>4</td><td>SSI/Serializable 내부</td><td style=text-align:right>권장</td><td>격리 수준의 내부 동작 파악</td><td style=text-align:right>중간~높음</td><td>실패 시나리오 (Serialization failure) 실험</td></tr><tr><td style=text-align:right>4</td><td>CRDT·Event Sourcing</td><td style=text-align:right>선택</td><td>충돌 허용·수렴 모델 이해</td><td style=text-align:right>중간</td><td>간단한 CRDT 예제 구현</td></tr><tr><td style=text-align:right>4</td><td>동시성 검증 (Jepsen)</td><td style=text-align:right>권장</td><td>시스템 검증·문제 노출 능력</td><td style=text-align:right>매우 높음</td><td>Jepsen 스타일 테스트·블랙박스 검증</td></tr><tr><td style=text-align:right>4</td><td>모니터링 지표 설계</td><td style=text-align:right>필수</td><td>충돌률·재시도율 등 지표 정의</td><td style=text-align:right>높음</td><td>Grafana/Prometheus 대시보드 설계</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글 (영어 풀네임, 약어))</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심</td><td>갱신 손실 (Lost Update)</td><td>동시 트랜잭션이 동일 행을 읽어 각각 갱신할 때, 한쪽의 변경이 나중 커밋에 의해 덮여 일부 변경이 소실되는 현상</td><td>동시성 제어, RMW, LWW</td><td>장애 원인 진단, 대응 전략 (원자적 SQL/락/버전) 결정</td></tr><tr><td>핵심</td><td>읽기 - 수정 - 쓰기 패턴 (Read-Modify-Write, RMW)</td><td>애플리케이션이 먼저 읽고 계산한 뒤 쓰는 순서의 패턴—Lost Update 취약점의 대표적 원인</td><td>원자적 UPDATE, 낙관적/비관적 락</td><td>가능하면 DB 원자 연산으로 대체</td></tr><tr><td>핵심</td><td>격리 수준 (Isolation Level)</td><td>트랜잭션 간 상호작용 규칙 (예: Read Committed, Repeatable Read, Serializable)</td><td>스냅샷 격리, SSI</td><td>일관성 요구에 따라 적절한 격리 설정</td></tr><tr><td>구현</td><td>원자적 갱신 (Atomic Update)</td><td>DB 내부에서 읽기·계산·쓰기를 단일 연산으로 수행하는 패턴 (<code>UPDATE … SET v = v + 1</code>)</td><td>RMW 회피, SQL 원자성</td><td>카운터·증감 연산 등 간단 연산에 최우선 적용</td></tr><tr><td>구현</td><td>비관적 잠금 (Pessimistic Lock) / 명시적 락 (Explicit Lock)</td><td><code>SELECT … FOR UPDATE</code> 등으로 먼저 락을 획득해 다른 트랜잭션 접근 차단</td><td>Row Lock, Deadlock</td><td>핫스팟·중요 자원 보호에 사용 (단, 락 대기/데드락 모니터링 필수)</td></tr><tr><td>구현</td><td>낙관적 잠금 (Optimistic Lock)</td><td>버전/타임스탬프 비교로 충돌을 감지, 실패 시 재시도</td><td>버전 컬럼, ORM @Version</td><td>충돌 낮은 환경에서 효율적—재시도·멱등성 설계 필요</td></tr><tr><td>구현</td><td>MVCC (Multi-Version Concurrency Control)</td><td>트랜잭션별 스냅샷 (버전) 을 제공해 읽기와 쓰기를 분리하는 동시성 제어</td><td>Snapshot Isolation, SSI</td><td>읽기 성능 우수, RMW 취약 케이스 주의</td></tr><tr><td>구현</td><td>스냅샷 격리 (Snapshot Isolation)</td><td>MVCC 방식의 읽기 일관성 모델—특정 상황에서 Lost Update/Write Skew 에 취약</td><td>MVCC, Write Skew</td><td>DB 별 구현 차이로 테스트 필요</td></tr><tr><td>구현</td><td>SSI (Serializable Snapshot Isolation, SSI)</td><td>스냅샷 기반으로 직렬화 보장을 제공하는 기법 (충돌 탐지·Abort)</td><td>Serializable, MVCC</td><td>금융·원장 등 강한 일관성 경로에 사용 (성능 영향 고려)</td></tr><tr><td>운영</td><td>재시도 및 백오프 (Retry & Backoff)</td><td>충돌 시 재시도 전략, 보통 지수적 백오프와 재시도 한도 적용</td><td>멱등성, 재시도 폭주 방지</td><td>낙관적 잠금 사용 시 필수—재시도 횟수·백오프 정책 설계</td></tr><tr><td>운영</td><td>멱등성 (Idempotency)</td><td>동일 요청을 여러 번 실행해도 결과가 동일하도록 보장하는 특성</td><td>재시도, 메시지 처리</td><td>재시도 로직 설계 시 핵심 (특히 외부 API/결제)</td></tr><tr><td>운영</td><td>복제 지연 (Replication lag)</td><td>비동기 복제에서 쓰기→읽기 일관성 지연이 발생하는 시간</td><td>읽기/쓰기 분리, 스테일 리드</td><td>읽기 리플리카 이용 시 세션 고정 또는 마스터 읽기 권장</td></tr><tr><td>운영</td><td>충돌률 (Conflict rate)</td><td>일정 기간 내 충돌 (재시도/예외) 발생 비율</td><td>재시도율, 트랜잭션 실패</td><td>모니터링 지표로 알람·개선 우선순위 결정</td></tr><tr><td>아키텍처·패턴</td><td>CQRS (Command Query Responsibility Segregation)</td><td>쓰기 (명령) 와 읽기 (조회) 를 분리해 일관성/확장성 문제 완화</td><td>이벤트 소싱, 단일 라이터</td><td>복잡 도메인에서 일관성 처리 전략으로 사용</td></tr><tr><td>아키텍처·패턴</td><td>이벤트 소싱 (Event Sourcing)</td><td>상태를 이벤트 로그로 기록하고 재구성하는 패턴</td><td>CQRS, 멱등성</td><td>복잡 충돌 회피·감사 추적에 유리</td></tr><tr><td>보조</td><td>LWW (Last Write Wins)</td><td>마지막 쓰기를 우선으로 하는 정책 (의도치 않게 데이터 손실 유발 가능)</td><td>덮어쓰기 정책</td><td>설계 시 주의—데이터 손실 허용되는 영역에서만 사용</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/>PostgreSQL Documentation — Explicit Locking / Transaction Isolation / Serializable</a></li><li><a href=https://dev.mysql.com/doc/>MySQL Reference Manual — InnoDB Locking and Transaction Model</a></li><li><a href=https://learn.microsoft.com/sql/>Microsoft SQL Docs — Transaction Isolation Levels / Optimistic Concurrency</a></li><li><a href=https://docs.oracle.com/>Oracle Documentation — Data Concurrency and Consistency</a></li><li><a href=https://notavoid.tistory.com/48>트랜잭션 격리 수준 완벽 가이드 (notavoid.tistory)</a></li><li><a href=https://2tsumo-hitori.tistory.com/55>PostgreSQL, MySQL 에서의 Lost update 대처 방안 (2tsumo-hitori.tistory)</a></li><li><a href=https://mirrorofcode.tistory.com/416>Lost update와 serializable (mirrorofcode.tistory)</a></li><li><a href=https://kyoulho.tistory.com/275>MVCC (Multiversion Concurrency Control) (kyoulho.tistory)</a></li><li><a href=https://techforme.tistory.com/61>낙관적 락, 비관적 락 - 동시성 제어 (techforme.tistory)</a></li><li><a href=https://blog.xiyo.dev/posts/development/database/database-concurrency-concepts>데이터베이스 동시성 문제와 ANSI SQL 표준화 (blog.xiyo.dev)</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-and-database-systems/>Data-and-Database-Systems</a></li><li><a href=https://buenhyden.github.io/tags/data-operations/>Data-Operations</a></li><li><a href=https://buenhyden.github.io/tags/transaction-management/>Transaction-Management</a></li><li><a href=https://buenhyden.github.io/tags/transaction/>Transaction</a></li><li><a href=https://buenhyden.github.io/tags/transaction-isolation/>Transaction-Isolation</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-anomalies/>Concurrency-Anomalies</a></li><li><a href=https://buenhyden.github.io/tags/transaction-anomaly/>Transaction-Anomaly</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/testing-fundamentals/quality-assurance-vs-quality-control-vs-testing/><span class=title>« Prev</span><br><span>QA vs QC vs Testing</span>
</a><a class=next href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/dirty-read/><span class=title>Next »</span><br><span>Dirty Read</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>