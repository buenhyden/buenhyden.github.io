<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Write Skew | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Transaction,Transaction-Isolation,Concurrency-Anomalies,Write-Skew,Transaction-Anomaly,snapshot-isolation"><meta name=description content="Write Skew는 스냅샷 격리에서 서로 다른 행을 동시에 수정해 전체 불변식(예: 최소 인원 유지)을 깨뜨리는 동시성 이상이다. 직접적인 쓰기-쓰기 충돌이 없어 SI에서 감지되지 않으며, 해결책으로는 Serializable/SSI, 읽은 집합 잠금(SELECT FOR UPDATE), 데이터베이스 제약 또는 커밋 전 재검증이 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Write Skew"><meta property="og:description" content="Write Skew는 스냅샷 격리에서 서로 다른 행을 동시에 수정해 전체 불변식(예: 최소 인원 유지)을 깨뜨리는 동시성 이상이다. 직접적인 쓰기-쓰기 충돌이 없어 SI에서 감지되지 않으며, 해결책으로는 Serializable/SSI, 읽은 집합 잠금(SELECT FOR UPDATE), 데이터베이스 제약 또는 커밋 전 재검증이 있다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-12T03:49:00+00:00"><meta property="article:modified_time" content="2025-09-12T03:49:00+00:00"><meta property="article:tag" content="Data-and-Database-Systems"><meta property="article:tag" content="Data-Operations"><meta property="article:tag" content="Transaction-Management"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Transaction-Isolation"><meta property="article:tag" content="Concurrency-Anomalies"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Write Skew"><meta name=twitter:description content="Write Skew는 스냅샷 격리에서 서로 다른 행을 동시에 수정해 전체 불변식(예: 최소 인원 유지)을 깨뜨리는 동시성 이상이다. 직접적인 쓰기-쓰기 충돌이 없어 SI에서 감지되지 않으며, 해결책으로는 Serializable/SSI, 읽은 집합 잠금(SELECT FOR UPDATE), 데이터베이스 제약 또는 커밋 전 재검증이 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":8,"name":"Write Skew","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Write Skew","name":"Write Skew","description":"Write Skew는 스냅샷 격리에서 서로 다른 행을 동시에 수정해 전체 불변식(예: 최소 인원 유지)을 깨뜨리는 동시성 이상이다. 직접적인 쓰기-쓰기 충돌이 없어 SI에서 감지되지 않으며, 해결책으로는 Serializable/SSI, 읽은 집합 잠금(SELECT FOR UPDATE), 데이터베이스 제약 또는 커밋 전 재검증이 있다.","keywords":["Data-and-Database-Systems","Data-Operations","Transaction-Management","Transaction","Transaction-Isolation","Concurrency-Anomalies","Write-Skew","Transaction-Anomaly","snapshot-isolation"],"articleBody":"Write Skew Write Skew 는 두 트랜잭션이 같은 **판단 (읽기)**을 하고 각자 다른 레코드를 갱신해서 결과적으로 비즈니스 규칙이 깨지는 현상이다.\n예: 두 의사가 동시에 당직 해제 판단 → 최종적으로 아무도 남지 않는 상황. Snapshot Isolation 은 읽기는 스냅샷에서 빠르게 처리하고 쓰기 충돌 (같은 행을 동시에 쓰는 경우) 만 검사하기 때문에 이런 상황을 허용할 수 있다.\n예방은 DB 수준 (Serializable/SSI, predicate/next-key locks) 이나 애플리케이션 수준 (guard row, 명시적 락, 집계 테이블) 으로 수행하며, 운영적으로는 직렬화 오류율을 모니터링하고 재시도 정책을 설계해야 한다.\n핵심 개념 Write Skew 는 두 개 이상의 트랜잭션이 같은 ’ 판단 근거 ‘(예: 현재 참가자 수) 를 보고 각자 다른 행을 수정해, 최종적으로 시스템 규칙 (예: 최대 인원) 이 깨지는 경우를 말한다.\nSI(스냅샷 격리) 는 읽기 성능이 좋아 실무에서 자주 쓰이지만 이런 상황을 막지 못한다.\n문제를 막으려면\n핵심 트랜잭션엔 직렬 가능성 (Serializable) 또는 SSI 사용 범위/프레디케이트 락 (예: SELECT FOR UPDATE, next-key lock) 적용 애플리케이션 레벨 제약 (버전 체크·재시도)\n을 조합해 보완한다. 핵심 개념 (한글·약어) 정의 무슨 문제 해결? 실무 적용 방식 다중버전 동시성 제어 (MVCC) 스냅샷 기반 읽기, 각 트랜잭션은 고유 버전 사용 읽기 성능 향상, 락 경합 감소 PostgreSQL/InnoDB 등 기본 메커니즘 활용 스냅샷 격리 (SI) WW 충돌을 거부, 스냅샷에서 읽음 대부분의 쓰기 충돌 방지 (그러나 RW 허용) 기본 격리로 많이 사용 (성능 우수) 쓰기 스큐 (Write Skew) 서로 다른 행을 수정해 전역 제약 위반 SI 환경에서 발생 가능한 논리 위반 Serializable/범위락/애플리케이션 제약으로 보완 직렬 가능성 (Serializable) 어떤 순차 실행과 동일한 결과 보장 모든 동시성 이상 제거 성능 비용 수용 시 적용 Serializable SI (SSI) SI 위에 위험 구조 탐지 추가 SI 장점 유지하면서 직렬성 수준 안전화 PostgreSQL SSI 등에서 지원 2 단계 잠금 (2PL) / 프레디케이트 락 획득/해제 규칙으로 락 관리, 범위 락 포함 팬텀·범위 삽입 방지 SELECT FOR UPDATE, next-key lock 등 쓰기 스큐는 SI 환경의 대표적 논리 이상이며, MVCC/SI 가 읽기 성능을 확보하는 동안 남는 빈틈을 SSI·Serializable·범위 락·애플리케이션 제약으로 막는다. 실무선택은 무결성 중요도와 성능 요구에 따라 달라진다.\n개념 관계와 방지 메커니즘 출발 (원인) → 작용 대상 목적 (왜) 결과 (어떤 영향) MVCC → SI 동작 기반 제공 읽기 동시성 확보 스냅샷 읽기 (읽기 경합 감소) SI → 트랜잭션 간 상호작용 WW 충돌 거부, RW 허용 Write Skew 가능성 발생 Write Skew 발생 → 시스템 무결성 위험 비즈니스 규칙 위반 필요시 Serializable 로 보완 SSI → SI 에 검출 층 추가 RW 사이클 탐지·차단 직렬성 보장 (성능 - 무결성 균형) 2PL/Predicate Lock → 범위/조건 보호 팬텀/삽입 차단 락 경합·교착 가능성 증가 관계의 핵심은 \" 어떤 메커니즘이 어떤 이상을 막고, 그 대가로 어떤 비용 (성능/복잡도) 을 초래하는가 \" 를 명확히 하고 적절히 조합하는 것이다.\nWrite Skew 실무 대책 매핑표 개념 실무에서 무엇을 적용 (무엇) 어떻게 적용 (방법) 왜 적용 (비즈니스 이유) SI (스냅샷 격리) 기본 격리로 사용 DB 기본값 또는 설정 읽기 성능 우선, 대부분 충분 Write Skew 위험 거래에 대해 보호 해당 트랜잭션을 Serializable 로 전환 또는 범위락 적용 무결성·규정 준수 확보 SSI 핵심 트랜잭션에 권장 PostgreSQL 의 SSI 사용 (재시도 처리) SI 장점 유지 + 직렬성 보장 범위 락 (next-key/gap) 예약·유니크 제약에 적용 SELECT FOR UPDATE / 인덱스 설계 병행 과예약·삽입 충돌 차단 애플리케이션 제약 (버전) UI·API 경계에서 검증 version 컬럼 + UPDATE WHERE version=? 사용자 think-time 시 실무적 보완 모니터링/검증 충돌률·직렬화 실패 측정 Prometheus/Grafana 지표, Jepsen 스타일 테스트 정책 결정 근거 제공 실무에서는 SI 를 기본으로 두되, 비즈니스 영향이 큰 트랜잭션에 대해서만 Serializable/SSI 또는 범위 락을 적용하는 ’ 선택적 엄격화 ’ 전략이 현실적이다. 애플리케이션 레벨 방어와 운영 모니터링은 필수 보완책이다.\n기초 조사 및 개념 정립 Write Skew 이해와 실무적 대응 두 사람이 같은 규칙을 기준으로 동시에 판단해서 서로 다른 레코드를 바꾸면, 합쳐진 결과가 규칙을 깨는 경우가 있다.\n예를 들어 \" 항상 두 명의 담당자가 있어야 한다 \" 는 규칙에서, A 와 B 가 동시에 서로를 대신할 수 있다고 판단해 각자 업무를 내려놓으면 결과적으로 둘 다 없어져 규칙을 위반하게 된다. 이런 현상이 바로 Write Skew 다.\n방지하려면 DB 의 직렬화 격리 (Serializable/SSI) 를 사용하거나, 애플리케이션에서 명시적 잠금 (SELECT … FOR UPDATE) 또는 불변식 검증을 원자적으로 수행해야 한다.\n왜 발생하는가 MVCC/Snapshot Isolation 에서는 각 트랜잭션이 자신만의 읽기 스냅샷을 가짐. T1 과 T2 가 같은 프레디킷 P 를 읽어 \" 조건 충족 \" 으로 판단 → 각각 서로 다른 행 R1, R2 를 업데이트. 서로의 업데이트를 보지 못했기 때문에 둘 다 커밋 가능 → 합쳐진 결과 (두 행의 상태 조합) 가 시스템 불변식을 위반할 수 있음. 간단한 재현 예제 (의사 SQL, 단계별 주석) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -- 전제: 테이블 on_call(user_id, oncall boolean) -- 불변식: 항상 on_call에서 oncall = true 인 사용자가 최소 1명은 존재해야 함 -- 트랜잭션 T1 시작 BEGIN; -- T1은 현재 자신(1번)의 oncall 상태를 확인 SELECT * FROM on_call WHERE user_id = 1 AND oncall = true; -- 결과: row exists -- 트랜잭션 T2 거의 동시에 시작 BEGIN; SELECT * FROM on_call WHERE user_id = 2 AND oncall = true; -- 결과: row exists -- T1: 자신을 off로 변경 (다른 사람이 여전히 on이라고 판단) UPDATE on_call SET oncall = false WHERE user_id = 1; COMMIT; -- 커밋 성공 (T1은 T2의 변경을 보지 못함) -- T2: 자신을 off로 변경 UPDATE on_call SET oncall = false WHERE user_id = 2; COMMIT; -- 커밋 성공 -- 결과: 모든 oncall이 false가 되어 '최소 1명 on' 불변식 위반 위는 Snapshot Isolation 환경에서 전형적으로 발생하는 Write Skew 사례다. 방지 방법 Serializable / SSI 사용: DB 가 의존성 (읽기→쓰기 간 의존) 을 탐지해 충돌 시 하나를 Abort → 재시도 유도. 근본적 해결이나 성능·재시도 비용 존재.\n명시적 락: 문제 구간에서 SELECT … FOR UPDATE 등으로 관련 행 또는 범위를 잠금 → 다른 트랜잭션의 동시 판단 차단.\n원자적 불변식 검사·갱신: 애플리케이션이 불변식 검사와 갱신을 DB 내부 (예: 저장 프로시저) 에서 원자적으로 수행.\n데이터 모델/제약 강화: DB 제약 (예: 체크 제약, 트리거, 고유성) 으로 불변식을 강제할 수 있으면 애플리케이션 레벨 위험 감소.\n혼합 전략: 핵심 경로는 직렬화, 나머지는 SI + 검증으로 성능과 일관성 균형.\n탐지·운영 관점 탐지 신호: 도메인 규칙 위반 알림, 애플리케이션 레벨 검증 실패, 재시도 패턴 이상. 진단 도구: 트랜잭션 로그, 직렬화 실패 (예: SQLSTATE 40001) 로그, APM 으로 긴 트랜잭션/동시성 패턴 분석. 런북 (즉시 대처): 문제 트랜잭션 롤백/재시도 유도, 임시로 중요 경로의 격리 수준 올리기, 해당 기능의 트래픽 셰이딩. 등장 배경 및 발전 과정 무엇이 문제인가?\n두 트랜잭션이 같은 데이터를 읽고 서로 다른 행을 _ 갱신 _ 하면, 충돌 (같은 행을 쓰는 경우) 이 없어 보이지만 결과적으로 데이터 제약이 깨질 수 있다. 이 현상이 write-skew다.\n왜 SI 에서 발생하나?\nSI 는 각 트랜잭션에 시작 시점 스냅샷을 보여주고, 서로 다른 행을 갱신할 때 쓰기 - 쓰기 충돌이 발생하지 않으면 커밋을 허용한다. 그 결과 스냅샷 기반으로 보았을 때 정합성 제약을 위반할 수 있다.\n어떤 기술이 해결했나?\n전통적 락 (2PL) 로 막을 수 있지만 비용이 크다. SI 의 장점은 살리되 write-skew 를 차단하려고 SSI 같은 런타임 충돌 검출 기법이 도입되었다.\n등장 배경 대규모 OLTP 와 MVCC 기반 DB 의 확산으로 읽기 성능을 중시하는 설계가 보편화되었다.\n이 과정에서 SI 는 읽기 성능과 일관성의 좋은 절충을 제공했지만, 현실 비즈니스 제약 (예: \" 적어도 한 명은 on-call 이어야 한다 “) 에서 SI 가 허용하는 특정 병렬 패턴이 제약을 깨뜨리는 사례가 발견되었다.\n이 문제 (동시성 패턴으로 인한 제약 위반) 가 바로 write-skew이며, 이로 인해 SI 의 한계를 보완하는 연구·기술 (SSI 등) 이 촉발되었다.\n발전 과정 시기 (개념 순서) 기술/개념 등장 이유 (문제) 개선/효과 1 2PL / 전통적 락 동시 쓰기 충돌·정합성 보장 직렬성 보장, 락 경합·교착 발생 2 MVCC 읽기 경합·성능 문제 완화 읽기 스냅샷 제공, 읽기 성능 향상 3 Snapshot Isolation (SI) MVCC 기반 읽기 일관성 강화 스냅샷 읽기 제공, 동시성↑ (하지만 write-skew 가능) 4 Write-Skew 문제 인식 SI 하에서 비직렬화 사례 보고 SI 의 한계 (비즈니스 제약 훼손) 드러남 5 Serializable SI (SSI) SI 의 취약점 보완 필요 런타임 충돌 검출로 직렬성 보장 (일부 트랜잭션 abort) 6 애플리케이션/설계 보완 모든 트랜잭션 강제 직렬화 비용 회피 하이브리드 설계 (CQRS, 제약, 샤딩) 적용 timeline title Write-Skew 등장과 대응 진화 \"2PL / 락 중심\" : 1 \"MVCC 도입\" : 2 \"Snapshot Isolation (SI)\" : 3 \"Write-Skew 문제 인식\" : 4 \"Serializable SI / SSI\" : 5 \"애플리케이션/설계 보완\" : 6 전통적 락 (2PL) 은 write-skew 같은 문제를 막지만 읽기 성능 저하라는 비용이 따라왔다. MVCC 와 SI 는 읽기 성능을 대폭 개선했으나 SI 는 write-skew 를 허용할 수 있어 비즈니스 제약을 손상시킬 소지가 드러났다. 이를 보완하기 위해 **SSI(런타임 충돌 검출)**가 등장했고, 실제 시스템에서는 비용과 효과를 고려해 **DB 수준의 SSI + 애플리케이션 설계 보완 (제약·검증·샤딩)**을 혼용하는 방식이 널리 채택된다. 또한 같은 이름의 격리 수준이라도 DB 별 구현 차이를 반드시 검증해야 한다. Write Skew 문제·목적·해결 Write Skew 는 서로 다른 행을 동시에 업데이트한 두 트랜잭션이 합쳐져 전체 규칙 (불변식) 을 깨는 문제로, 주로 Snapshot Isolation 같은 격리 환경에서 발생한다.\n간단 예시 (의료 온콜):\nT1: 읽기—의사 A on_call? yes; T2: 읽기—의사 B on_call? yes T1: A.on_call = false; 커밋 T2: B.on_call = false; 커밋 → 결과: 병동에 on_call 담당자 0 명 (불변식 위반). 해결 아이디어 (직관): 두 트랜잭션이 서로의 판단에 영향을 주지 못하도록 _ 공유 자원에 대한 동시성 제어 _ 를 적용하거나 (락/직렬화), 애플리케이션 단에서 집계를 단일화해 원자적으로 갱신한다.\nWrite Skew 가 유발하는 문제들 문제 유형 구체 증상 비즈니스 영향 도메인 불변식 위반 서로 다른 행 동시 변경 → 전체 제약 (예: 최소 1 명 유지) 위반 규정 위반, 서비스 중단, 안전사고 가능 상태 불일치 트랜잭션 간 상태 판단 불일치 (스냅샷에 의존) 예측 불가능한 동작, 버그 발생 탐지 어려움 각 트랜잭션 자체론 정상 → 문제는 합쳐졌을 때 발생 디버깅·감사 곤란 Write Skew 는 ’ 부분적으로 보면 정상 ’ 이지만 전체 규칙엔 치명적인 오류**를 만드는 동시성 결함이다. 특히 안전·규제·금융 같은 도메인에서 즉시 문제로 이어질 수 있어 주의 깊은 설계가 필요하다. Write Skew 해결의 핵심 목적 목적 구체 목표 기대 효과 도메인 불변식 보장 시스템 상태가 불변식 항상 만족하게 함 안전성·무결성 확보 합성 동작 신뢰도 향상 다중 트랜잭션 합성 결과 예측 가능 오류·사후 처리 비용 감소 운영·감사 용이성 이상상황 희소화로 디버깅 용이 규정 준수·감사 준비성 강화 핵심: 목적은 단순히 오류를 줄이는 게 아니라 시스템 레벨에서 규칙 (불변식) 을 항상 지키게 만들어 비즈니스 신뢰성을 확보하는 것이다. 문제와 목적의 연계 (Write Skew) 문제 (증상) 대응 목적 연계 방식 도메인 불변식 위반 도메인 불변식 보장 트랜잭션 수준 충돌 차단 또는 불변식 단일화 상태 불일치 합성 동작 신뢰도 향상 읽기/쓰기 가시성 조정 (격리 수준/락) 탐지 어려움 운영·감사 용이성 실패 시 재시도·로그·경보 체계 구축 핵심 연결: 각 문제는 불변식 보장·가시성 제어·운영 지원이라는 목적에 직접적으로 매핑된다. 해결책은 문제 유형에 맞춘 기술 (격리·락·애플리케이션 설계) 과 운영 정책 (재시도·모니터링) 을 조합하는 것이다. Write Skew 발생요건과 확인 체크리스트 무슨 문제인가?\n두 트랜잭션이 같은 _ 읽기 결과 _ 를 기반으로 서로 다른 행을 수정하면, 최종 상태가 시스템의 규칙 (불변식) 을 깨는 현상이 생길 수 있다. 이 현상이 바로 Write Skew다.\n언제 발생하나? (체크리스트)\nDB 가 MVCC/Snapshot 기반 (스냅샷 읽기) 을 사용한다. 불변식이 여러 행/범위에 걸쳐 정의되어 있다. 동시 트랜잭션들이 같은 읽기 집합을 읽고 서로 다른 행을 쓴다 (WW 충돌 없음). 격리 수준이 SERIALIZABLE 이 아니거나 SI 만 적용되어 있는 경우. 가장 쉬운 예: 두 의사가 각각 다른 레코드를 지워서 결국 아무도 남지 않는 상황 (Doctors on-call 예).\n단기·실무적 대처: 애플리케이션 수준에서 검증 및 재시도, SELECT FOR UPDATE 또는 의도적 업데이트 (충돌 물질화) 사용. 장기적으로는 SERIALIZABLE/SSI 도입 검토.\nWrite Skew 발생 전제·요구조건 체크표 항목 요구사항 (명세) 왜 필요한가 (핵심 이유) 검증 방법 / 지표 실행 모델 MVCC / Snapshot Isolation 또는 비잠금 읽기 환경 스냅샷 읽기로 다른 트랜잭션의 중간 쓰기를 보지 못함. DB 문서 확인 (SHOW transaction_isolation 등). 불변식 형태 불변식이 여러 행/범위에 걸쳐 표현됨 (조합적 제약) 조합적 제약은 단일 행 잠금으로는 보장 불가. 비즈니스 규칙 분석 (제약 SQL/유즈케이스 확인). 동시성 패턴 여러 트랜잭션이 동시에 동일한 읽기 집합을 읽음 읽기 기반 의사결정이 서로를 인지하지 못하는 상황 생성. 부하/동시성 로그, 트랜잭션 타임라인. 쓰기 충돌 각 트랜잭션의 쓰기 집합이 서로 서로 다른 행(WW 충돌 없음) WW 충돌이 없으면 DB 가 둘 다 커밋시키고 write-skew 발생 가능. 쓰기 대상 분석, EXPLAIN/트랜잭션 로그. 격리 수준 격리 수준이 SERIALIZABLE 보다 약함 (예: SI/REPEATABLE READ 등) SERIALIZABLE 이면 이 클래스의 이상을 방지하거나 탐지 가능. 격리설정 확인 및 SSI 여부 점검. Write Skew 가 발생하려면\nMVCC/Snapshot 기반 읽기 모델이면서 불변식이 여러 행/범위에 걸쳐 정의되어 있고 동시 트랜잭션들이 같은 읽기 집합을 읽은 뒤 서로 다른 행을 수정 (즉, WW 충돌이 없을 때) 해야 하며, 격리 수준이 완전한 직렬성을 보장하지 않을 때 발생 가능성이 높다.\n위 항목을 하나하나 점검하면 write-skew 취약성을 판단할 수 있다. Write Skew: 원인·특징·실무 대응 Write Skew 는 서로 다른 행을 동시에 바꾸는 두 트랜잭션이 함께 실행될 때, 각각은 정당해도 합치면 전체 규칙 (예: 최소 인원 유지) 을 깨는 문제다.\n스냅샷 격리 (SI) 는 이런 상황에서 종종 탐지하지 못한다. 해결하려면 직렬성 보장 (Serializable/SSI) 을 쓰거나, 중요한 읽기 집합을 잠그거나, 커밋 전에 규칙을 다시 확인해 실패 시 재시도하는 패턴을 적용한다.\nWrite Skew 특징·근거·차별표 핵심 특징 기술적 근거 다른 동시성 이상과의 차별점 실무적 의미 (대응 포인트) 발생 조건: 다른 행 동시 갱신 MVCC 스냅샷 + WW 검사만 수행 Lost Update/Dirty Write 는 동일 행 충돌 중요 불변식 관련 트랜잭션 식별 직렬성 위반 (비가시적) 의존성 그래프에서 read–write 로 사이클 생성 Phantom 은 범위 변화 연계, Write Skew 는 불변식 초점 자동화된 동시성 테스트 필요 탐지 어려움 WW 가 없어 SI 검사 누락 버전비교/WW 기반 검사로는 탐지 불가 Serializable/SSI 또는 읽은 집합 잠금 권장 대응의 비용 - 효과 트레이드오프 SSI(오버헤드), FOR UPDATE(락 경합), 제약 (단순화) 다른 이상보다 복합적 대응 요구 우선순위: DB 제약 → 잠금 → 격리상향 순 적용 Write Skew 는 SI 환경에서 특히 주의해야 할 동시성 이상으로, 탐지·예방이 단순 충돌 검사로는 어렵다. 실무에서는 불변식 관련 트랜잭션을 식별해 우선적으로 DB 제약이나 읽은 집합 잠금으로 보호하되, 필요한 경우 Serializable/SSI 전환을 검토해 전체 무결성을 확보한다. 각 선택은 성능·운영 비용을 동반하므로 테스트로 트레이드오프를 확인해야 한다.\nPhase 2: 핵심 원리 및 이론적 기반 Write Skew 대응 원칙과 설계 전략 Write Skew 는 트랜잭션 A 와 B 가 같은 판단 근거 (읽기 결과) 를 보고 각자 다른 레코드를 수정했을 때 발생하는 일관성 위반 현상이다.\nSI 는 읽기는 스냅샷에서 빠르게 처리하고, 같은 행을 동시에 쓸 때만 충돌을 막기 때문에 이런 시나리오가 가능하다.\n해결책은\nDB 가 직렬성 보장 (SSI/Serializable) 하도록 설정하거나 중요한 판단 구간에 **명시적 잠금 (SELECT FOR UPDATE)**을 거는 것 스키마/애플리케이션 레벨로 제약을 물질화 (guard row/집계 테이블) 하거나 재시도·모니터링 정책을 운영하는 것이다. 실무에서는 비용·성능을 고려해 핵심 트랜잭션에만 강한 제어를 적용하는 전략이 일반적이다.\nWrite Skew 핵심 원칙 요약표 핵심 원칙 설명 목적 왜 필요한가 SI: 스냅샷 읽기 + WW 검사 트랜잭션은 시작 스냅샷을 읽고, 동일 튜플 동시 쓰기만 충돌로 처리. 읽기 성능 극대화 높은 동시성 환경에서 락 경합 최소화 필요 Write Skew 조건 동일 상태 읽기 → 서로 다른 객체 쓰기 → 전체 불변식 위배. 이상 현상 식별 SI 의 WW 전제 때문에 발생 가능 직렬화 (Serializable/SSI) 반의존성 추적 후 직렬성 위반 시 abort 근본적 예방 SI 로는 잡히지 않는 패턴 제거 충돌 물질화 (guard row) 논리 제약을 실제 쓰기로 표현 DB 충돌 검사 활용 SI 의 한계 보완, 단순·효과적 핵심 원칙은 **SI 의 설계 (스냅샷 +WW 검사)**와 그로 인해 생기는 write-skew 조건을 이해하는 데 초점이 있다. 예방은 DB 수준 (직렬성 보장), 스키마 보강 (충돌 물질화), 애플리케이션 수준 (명시적 락/재시도) 으로 나뉘며, 실무는 성능 비용을 고려해 선택적으로 적용한다.\nWrite Skew 대응 설계 철학 요약 설계 철학 핵심 아이디어 적용 목적 고려사항 선택적 강화 핵심 트랜잭션만 Serializable 적용 비용 절감 + 정합성 보장 분류 정확성·테스트 필요 충돌 물질화 가드 행/집계 업데이트로 충돌 유도 SI 환경에서 안전성 확보 정규화 위배·운영 복잡성 애플리케이션 락 \u0026 재시도 FOR UPDATE/분산 락·재시도 정책 외부 사이드이펙트 포함 작업 보호 재시도 안전성 (idempotency) 확보 필요 설계 철학은 \" 전부를 포기하지 않되, 중요한 것만 강하게 지킨다 \" 는 실무적 균형을 표현한다. 각 방식은 장단이 뚜렷하므로 워크로드·제약·운영문화에 맞춰 조합 적용해야 최적의 결과를 얻는다.\nWrite Skew 작동원리와 방지전략 Write Skew 는 두 사용자가 같은 기준으로 \" 괜찮다 \" 고 판단한 뒤 각각 다른 데이터를 바꿔서, 최종적으로 전체 규칙이 깨지는 상황이다. 예: 병동에 on_call 담당자가 1 명인데 A 와 B 가 각각 자신을 off 로 바꾸면 결과적으로 0 명이 된다. Snapshot Isolation 은 보통 이 상황을 막지 못하니, 중요한 규칙이 있다면 범위 잠금이나 직렬화 (Serializable/SSI) 를 적용하거나 애플리케이션에서 버전 검증·재시도를 구현해야 한다.\n쓰기스큐 동작 원리와 메커니즘 핵심 메커니즘 (순서 기준) 트랜잭션 A/B 가 동일 조건의 쿼리 (SELECT) 를 각자 스냅샷에서 수행해 같은 판정 (예: 참가자 수 = 1) 을 얻음. 각 트랜잭션은 서로 다른 row(또는 객체) 를 업데이트 (또는 삭제) 함—WW 충돌은 없음. 트랜잭션들이 독립적으로 커밋되면, 시스템 전체에선 전역 제약 (invariant) 이 깨지게 됨 (예: 온콜 담당자 수 = 0). 발생 이유는 SI/Repeatable Read 에서 RW 반의존성(read→other write) 경로가 허용되어 직렬성 그래프에 RW 엣지들이 사이클을 형성할 수 있기 때문. 방지 옵션 (요약) 직렬 가능성 확보 (Serializable): 모든 이상을 차단하지만 비용 큼. SSI (Serializable Snapshot Isolation): SI 기반에서 위험 구조를 런타임 탐지·차단해 재시도 유도. 범위 락 (Next-Key / Predicate / SELECT FOR UPDATE): 조건 단위를 잠가 삽입/삭제로 인한 변화 방지. 애플리케이션 레벨 검증 (버전·제약): 사용자 think-time 포함 시 실무적 보완. Write Skew 동작요약 표 단계 동작 핵심 기술적 포인트 왜 문제가 되는가 1 동일 조건 SELECT 스냅샷 (SI/MVCC) 기반 읽기 각 트랜잭션이 같은 판단을 함 2 서로 다른 row 에 WRITE WW 는 거부되지만 RW 는 허용될 수 있음 서로 다른 행 쓰기여도 전역 규칙 위반 가능 3 동시 COMMIT 커밋 시점에 최종 상태 확정 최종 상태가 불변식 위반으로 귀결 4 결과 전역 비즈니스 규칙 (제약) 위반 심각한 비즈니스 오류 초래 쓰기 스큐는 \" 같은 판단 근거 \" 를 읽고 서로 다른 객체를 변경하는 패턴에서 발생한다. 핵심은 WW 충돌만 차단하는 SI 가 RW 에 의한 논리적 위반을 허용할 수 있다는 점이며, 이를 막으려면 조건 단위를 보호하거나 직렬화를 보장해야 한다.\n쓰기스큐 흐름도 flowchart TD Start([시작]) --\u003e T1_BEGIN[\"T1: BEGIN (SI)\"] Start --\u003e T2_BEGIN[\"T2: BEGIN (SI)\"] T1_BEGIN --\u003e T1_SELECT[T1: SELECT count WHERE predicate -\u003e v] T2_BEGIN --\u003e T2_SELECT[T2: SELECT count WHERE predicate -\u003e v] T1_SELECT --\u003e T1_DECIDE[\"T1: 판단 (조건 충족?) -\u003e 예\"] T2_SELECT --\u003e T2_DECIDE[\"T2: 판단 (조건 충족?) -\u003e 예\"] T1_DECIDE --\u003e T1_WRITE[T1: UPDATE/DELETE 다른 row] T2_DECIDE --\u003e T2_WRITE[T2: UPDATE/DELETE 다른 row] T1_WRITE --\u003e DB_OK1[\"DB: 쓰기 OK (WW 없음)\"] T2_WRITE --\u003e DB_OK2[\"DB: 쓰기 OK (WW 없음)\"] DB_OK1 --\u003e T1_COMMIT[T1: COMMIT] DB_OK2 --\u003e T2_COMMIT[T2: COMMIT] T1_COMMIT --\u003e FinalCheck[DB: 최종제약 검증] T2_COMMIT --\u003e FinalCheck FinalCheck --\u003e Violation{제약 위반?} Violation -- Yes --\u003e InvariantBroken[\"결과: 불변식 위반 (Write Skew 발생)\"] Violation -- No --\u003e OK[결과: 무결성 유지] %% 방지 지점(검사/대응) subgraph Mitigations [방지/완화 지점] M1[\"선택지: SELECT … FOR UPDATE(범위락)\"] M2[선택지: SERIALIZABLE / SSI] M3[선택지: 애플리케이션 버전검사 + UPDATE WHERE version=?] end T1_SELECT -.-\u003e M1 T2_SELECT -.-\u003e M1 T1_SELECT -.-\u003e M3 T2_SELECT -.-\u003e M3 T1_COMMIT -.-\u003e M2 T2_COMMIT -.-\u003e M2 위 흐름도는 쓰기 스큐의 전형적 시나리오를 단계별로 보여준다.\n핵심은 트랜잭션이 같은 predicate 를 읽고 (스냅샷 기반) 서로 다른 대상에 쓰기를 한 뒤 동시 커밋하면 전역 불변식이 깨지는 지점이다.\n방지 옵션은 세 가지 주요 지점에서 개입한다:\nSELECT 직후 범위락 (SELECT … FOR UPDATE) 로 조건을 보호 커밋 단계에서 Serializable/SSI 로 위험 구조를 검출해 재시도 유도 애플리케이션 레벨에서 버전검사 (UPDATE WHERE version=?) 로 충돌을 탐지하고 재시도한다. 실무에서는 이들을 혼합해 ’ 성능 - 무결성 ’ 의 균형을 맞춘다. 또한 운영상 충돌률·재시도 통계를 수집해 정책 (예: 일시적 격리 상향, 샤드 리밸런싱) 을 동적으로 적용하는 것이 권장된다.\nWrite Skew 흐름·생명주기·탐지 트랜잭션 A 와 B 가 같은 규칙을 보고 각각 다른 레코드를 수정하면, 서로의 변경을 보지 못한 채 둘 다 커밋해 합쳐진 결과가 규칙을 깨는 경우가 생긴다.\n핵심은 _ 읽기 시점의 스냅샷 가시성 _ 과 _ 커밋 시 검사 범위 _ 가 불일치한다는 점이다.\n이를 막으려면 DB 의 직렬화 또는 명시적 잠금, 또는 불변식을 원자적으로 검사·갱신하는 설계가 필요하다.\nWrite Skew 생명주기 흐름 트랜잭션 시작 (Start)\n트랜잭션이 시작되고, MVCC 환경이면 읽기 스냅샷이 고정된다. 타이밍: 스냅샷은 일반적으로 트랜잭션 시작 시점 (또는 첫 읽기 시점) 에 결정된다. 읽기·검증 (Read \u0026 Validate)\n동일한 Predicate(예: currentParticipants \u003c maxParticipants) 을 읽음. 판단은 스냅샷 기준으로 이루어짐 (다른 트랜잭션의 미커밋/커밋된 변경을 보지 못할 수 있음). 업데이트 (Update)\nT1 은 행 R1 을, T2 는 행 R2 를 업데이트 (서로 다른 행). 변경 내용은 각자의 쓰기 버퍼에 저장 (커밋 전까지 다른 트랜잭션에 보이지 않음). 커밋 (Commit)\nDB 는 보통 WW 충돌 (동일 행에 대한 동시 쓰기) 만 검사하거나 격리 정책에 따라 추가 검사. 두 트랜잭션이 서로 다른 행을 썼다면 둘 다 커밋될 가능성이 높음. 합성 상태 (Composite State) 노출\n커밋 후의 전체 상태가 비즈니스 불변식을 위반하면 Write Skew 발생. 문제는 단일 트랜잭션의 관점에서는 정당하지만 전체 관점에서 불일치가 발생하는 것. Write Skew 단계별 제어·데이터 흐름표 단계 동작 (데이터 흐름) 제어 포인트 (검증·잠금) 발생 위험 운영적 체크 Start 트랜잭션 시작 → 스냅샷 고정 트랜잭션 시작 시점 스냅샷 시점 불일치 트랜잭션 시작 로그 Read \u0026 Validate Predicate 기준 읽기 (스냅샷) 애플리케이션 불변식 검사 (스냅샷 기준) 잘못된 ‘OK’ 판단 동시 요청 패턴 모니터링 Update 서로 다른 행 업데이트 (쓰기 버퍼) (보통 잠금 없음) 서로의 변경 미가시성 쓰기 패턴·대상 분포 분석 Commit DB 가 충돌 검사 (주로 WW) → 커밋 격리 정책별 충돌 검증 합성 불변식 위반 노출 직렬화 실패/불변식 알람 Post-Commit 합성 상태로 불변식 위반 확인 애플리케이션·감시 시스템 비즈니스 규칙 위반 자동 롤백 불가 → 수동 대응/패치 핵심: **스냅샷 시점 (읽기 기준)**과 커밋 시 충돌 검사 범위가 달라 발생한다. 탐지 포인트는 동시 읽기 패턴, 특정 API 의 동시 호출, 커밋 시점의 불변식 위반 로그다. 운영에서는 트랜잭션 길이·동시성 패턴·직렬화 실패 및 애플리케이션 레벨 불일치 알람을 주의 깊게 모니터링해야 한다.\nWrite Skew 기본 흐름도 sequenceDiagram participant T1 as 트랜잭션 T1 participant T2 as 트랜잭션 T2 participant DB as 데이터베이스 T1-\u003e\u003eDB: BEGIN (스냅샷 고정) T2-\u003e\u003eDB: BEGIN (스냅샷 고정) T1-\u003e\u003eDB: SELECT predicate (스냅샷 기준) -\u003e OK T2-\u003e\u003eDB: SELECT predicate (스냅샷 기준) -\u003e OK T1-\u003e\u003eDB: UPDATE row R1 (쓰기 버퍼) T2-\u003e\u003eDB: UPDATE row R2 (쓰기 버퍼) T1-\u003e\u003eDB: COMMIT DB--\u003e\u003eT1: COMMIT 성공 T2-\u003e\u003eDB: COMMIT DB--\u003e\u003eT2: COMMIT 성공 DB--\u003e\u003eAll: 결과 상태 불변식 위반 -\u003e Write Skew 발생 위 순서도는 MVCC/Snapshot 환경에서 전형적인 Write Skew 발생 경로를 보여준다. 핵심은 두 트랜잭션이 동일한 판단 (스냅샷 기준) 을 내리고 서로 다른 행을 수정한 뒤 둘 다 커밋되어 합쳐진 결과가 규칙을 깨는 것이다. 흐름도 개선 시점은 스냅샷 확정 타이밍, 격리 수준 분기 (Abort 가능성), 그리고 명시적 락 도입 지점이다.\nWrite Skew 생명주기 상태도 stateDiagram-v2 [*] --\u003e Started: 트랜잭션 시작\\n(스냅샷 고정) Started --\u003e ReadValidate: Predicate 읽기/검증 ReadValidate --\u003e Update: 행 업데이트 Update --\u003e CommitAttempt: 커밋 시도 CommitAttempt --\u003e Committed: 커밋 성공 CommitAttempt --\u003e Aborted: 충돌 탐지 → Abort (Serializable/SSI) Committed --\u003e PostState: 합성 상태 노출 PostState --\u003e [*]: 정합성 확인 / 운영 알람 생명주기 다이어그램은 트랜잭션 상태 전이를 중심으로 Write Skew 의 가능 지점을 보여준다. 핵심은 CommitAttempt 에서의 분기 (Committed vs Aborted) 이며, Abort 는 직렬화 보장 메커니즘에서 발생해 재시도 로직을 요구한다. PostState 에서의 운영 감시와 회복 루프는 실제 서비스 안정성 확보에 필수적이다.\n특성 분석 및 평가 Write-Skew 방지: 이점·현실적 선택 핵심 요지:\n동시성을 높이면 성능이 좋아지지만 일부 상황에서는 write-skew 같은 보이지 않는 오류가 생긴다.\n무엇을 얻나:\nMVCC/SI 같은 기법으로 읽기 성능과 동시성을 크게 올릴 수 있다.\n무엇을 더해야 안전한가:\nSSI(런타임 검출), 범위락, DB 제약, 애플리케이션 락 같은 보완으로 중요한 비즈니스 규칙을 지켜야 한다.\n실무 규칙 (간단):\n성능 우선이면 낙관적 접근 (SI) + 모니터링, 정합성 우선이면 강한 격리 (SSI/2PL/제약).\nWrite-Skew 대응 기법의 장점 한눈표 장점 기술 근거 (Why) 실무 효과 (So what) 적용 조건 / 예시 동시성 향상 (MVCC/SI) 스냅샷 읽기로 읽기 - 쓰기 경합 회피 읽기 많은 서비스에서 처리량·응답성 개선 읽기 우선 시스템, 통계·로그 집계 성능 최적화 (낮은 격리) 락 최소화로 짧은 트랜잭션 유지 P99·TPS 개선, 인프라 효율성 낮은 정합성 요구, 캐주얼 데이터 개발 유연성 격리 수준/명시적 락 선택으로 정책화 가능 빠른 기능 출시·도메인별 처리 다양한 도메인 요구 공존 SSI (직렬성 보장) 런타임 의존성 그래프 검출로 위험 패턴 차단 SI 성능 확보 + 정합성 보장 (일부 abort) 핵심 금융 트랜잭션 (부분 적용 권장) 2PL / 범위락 predicate/next-key lock 으로 범위 변경 차단 팬텀/Write-Skew 예방, 예측 가능성↑ 고정 규칙·작업 범위가 명확한 도메인 스키마 제약 · 집계 행 DB 가 불변식 원자적으로 보장 애플리케이션 오류 감소, 무결성 강화 불변식이 DB 수준으로 표현 가능한 경우 애플리케이션 락 도메인 키 기반 락 (Advisory) 핫스팟만 보호·점진적 도입 가능 분산·마이크로서비스 환경 요약: 성능 향상 (동시성) 은 MVCC/SI 가 주로 담당하고, 정합성 확보는 SSI·범위락·DB 제약·애플리케이션 락으로 보완한다.\n실무 권장 패턴: 대부분 시스템은 혼합 전략(일반 작업은 SI/낙관적, 핵심 트랜잭션은 SSI/범위락 또는 DB 제약) 으로 운영한다. 적용 전에는 충돌률·핫스팟·비즈니스 민감도를 계량화해 정책을 정하라.\nWrite Skew 의 한계와 실무적 완화책 Write Skew 를 막으려면 _ 일관성 확보 수단 _ 을 도입해야 하는데, 그 수단들은 보통 성능 저하·운영 복잡성·확장성 제약을 함께 가져온다.\n강한 일관성 (Serializable/범위 락) 은 안전하지만 느리고, 느슨한 일관성 (SI/낙관적) 은 빠르지만 write skew 가 생길 수 있다. 실무에서는 * 비용 (성능)* 과 * 리스크 (무결성)* 를 저울질해 부분 적용 또는 애플리케이션 레벨 보완을 사용한다.\nWrite Skew 의 주요 단점 표 단점 설명 원인 실무 영향 완화/해결 방안 대안 기술 재시도 비용 (SSI) 충돌 시 트랜잭션 롤백 (예: SQLSTATE 40001) 직렬화/충돌 탐지 메커니즘 지연·재시도 폭주·자원 낭비 지수 백오프, 멱등 설계, 재시도 한계 2PL, 애플리케이션 집계 락 경합 (2PL) 강한 락으로 동시성 저하·데드락 장기간 락 보유, 넓은 범위 잠금 Throughput 저하·타임아웃 인덱스 최적화, 트랜잭션 단축, 락 순서 규약 SSI(부분 보완) 제약 복잡성 복잡 불변식으로 운영·유지보수 부담 복합 도메인 규칙 코드·DB 동기화 문제, 버그 증가 불변식 단순화, 설계 가이드, 테스트 강화 SSI(자동 보호 일부) 분산 확장성 한계 샤딩된 환경에서 전역 불변식 유지 어려움 데이터 분산·파티션 전역 트랜잭션 필요, 높은 지연 파티션 재설계, Sagas, 합의 스토어 Spanner/Calvin, 이벤트 소싱 핵심: 단점은 _ 일관성을 위해 투입한 비용 _ 이 곧 발생하는 문제들 (지연·대기·복잡도) 이다. 완화는 기술적 (백오프, 인덱스, 재설계)·운영적 (재시도 정책, 테스트) 조합으로 수행해야 효과적이다. 환경 기반 제약사항 표 제약사항 설명 원인 영향 완화/해결 방안 대안 기술 ORM 기본 설정 Lazy load·비잠금 읽기 기본값 노출 프레임워크 편의성 Write Skew 노출, 트랜잭션 오용 트랜잭션 경계 명확화, 락 힌트, 명시적 SQL 명시 SQL/Stored Proc 인덱스 부재 범위 잠금 비효율·스캔 증가 설계 미비 잠금 범위 확대·성능 저하 복합 인덱스, 통계 갱신 SSI(일부 보완) 격리 수준 선택 한계 Serializable 은 성능 저하 유발 성능·일관성 트레이드오프 처리량 감소·재시도 증가 선택적 직렬화, 하이브리드 전략 분산 일관성 DB 샤딩/마이크로서비스 전역 불변식 구현 난해 데이터 분산 전역 락/2PC 필요, 지연 파티션 재설계, Sagas 글로벌 일관성 DB 핵심: 제약사항은 환경 (도구·구조) 이 제공하는 한계로 인해 특정 해법 적용이 어렵게 만든다. 이를 해결하려면 **설계 (인덱스·파티셔닝) 와 운영 (트랜잭션 경계·ORM 설정)**을 함께 고쳐야 한다. Write Skew 트레이드오프 \u0026 하이브리드 전략 문제 맥락: 데이터베이스에서 ’ 정확한 상태 ’ 를 보장하려면 트랜잭션 격리 수준을 높여야 하지만, 격리 수준을 높이면 동시에 처리할 수 있는 작업 수가 줄어들어 성능이 떨어진다. Write Skew 는 이런 트레이드오프가 실제로 문제를 일으키는 대표 사례다.\n핵심 쟁점 (짧게):\nSI: 빠르지만 일부 복합 제약 위반 허용 → Write Skew 가능. SERIALIZABLE/SSI: 안전하지만 재시도·오버헤드 발생. 실무: 모든 트랜잭션을 직렬화하기보다 중요 트랜잭션 식별 → 고격리 적용, 또는 애플리케이션 레벨 해결을 조합해 사용. SI Vs Serializable 비교표 비교 축 Snapshot Isolation (SI) Serializable / SSI 핵심 장점 높은 동시성·읽기 성능 완전한 직렬성·정확성 핵심 단점 write-skew 등 이상 허용 충돌·abort 로 처리량 저하 성능 영향 낮은 지연, 높은 처리량 재시도·락으로 처리량 감소 구현·운영 복잡도 낮음 (일반 MVCC) 높음 (충돌 탐지·모니터링) 적합 사례 웹 트래픽, 읽기많은 서비스 금융, 핵심 비즈니스 트랜잭션 실무 대안 애플리케이션 검증·재시도 선택적 직렬화, 모니터링 성능 (처리량/지연) 과 일관성 (데이터 무결성) 은 반비례 경향이 있다. SI 는 처리량을, Serializable 은 무결성을 우선한다. 실무에서는 워크로드별로 어느 쪽을 우선할지 기준을 세우고 (예: 금전·법적 영향이 큰 트랜잭션은 무결성 우선), 하이브리드로 보완하는 것이 현실적 해법이다.\nWrite Skew 하이브리드 대안 비교표 방법 구성 요소 적용 목적 장점 고려사항/단점 선택적 직렬화 (Selective) 트랜잭션 분류 (critical vs normal), 격리 설정 정책 핵심 불변식만 강제해 전체 성능 보전 중요한 경로 무결성 확보·전체 성능 저하 제한 트랜잭션 분류 실수 위험, 복잡한 정책 관리. SELECT FOR UPDATE / 명시잠금 읽기 시점 행 잠금, 잠금 해제 시점 관리 읽은 정보로 결정하는 트랜잭션 간 충돌 방지 확실한 충돌 차단 (애플리케이션 제어) 잠금 경합·데드락·지연 유발. Sentinel / Materialize Conflict sentinel 행/집계 같이 업데이트 충돌을 강제하여 DB 가 하나를 abort 하게 유도 DB 수준 충돌 감지 활용, 간단 구현 사례 많음 추가 업데이트 오버헤드, 설계·정합성 유지 필요. 낙관적 버전 + 재시도 버전 칼럼/ETag, 재시도 로직 (백오프) 충돌 드문 환경에서 효율 유지 높은 처리량 유지, 단순 구현 가능 재시도 비용·사용자 영향·복잡성 존재. 엔진 수준 개선 (SSI 등) SSI 알고리즘·충돌 추적·인덱스 최적화 MVCC 장점 유지하면서 직렬성 보장 읽기·쓰기 분리 이점 유지, 일관성 보장 엔진 복잡도·운영 오버헤드·abort 가능. 요약: 하이브리드 방법은 **정확성 향상 (또는 충돌 회피)**과 성능 유지 사이에서 서로 다른 지점을 선택한다. 운영에서는 트랜잭션 특성 (충돌 가능성, 응답성 요구, 실패 복구 용이성) 에 따라 적절한 하이브리드 조합을 설계해야 한다. 예를 들어 빈번한 충돌이 예상되는 경로에선 SELECT FOR UPDATE 나 직렬화 적용, 충돌이 드문 대량 처리 경로에선 SI+ 재시도 전략을 택하는 식이다.\nWrite Skew: 적용 적합성·운영 가이드 Write Skew 대응은 한마디로 위험도 기반 선택이다. 읽기 많은 서비스에선 Snapshot Isolation 을 써서 성능을 확보하고, 돈·안전처럼 핵심 규칙이 깨지면 안 되는 영역만 격리 수준을 올리거나 잠금/애플리케이션 검증을 더해 보호한다. 적용 전에는 어떤 쿼리와 불변식이 위험한지 찾아내고 (분석), 변경은 단계적으로 적용해 (설계) 모니터링 (운영) 으로 검증해야 한다.\nWrite Skew 적용 적합성 평가와 운영 전략 읽기 중심이면서 불변식 위험이 낮고 핫스팟이 크지 않은 서비스: Snapshot Isolation(혹은 SSI 로 성능 - 정합 균형) 을 1 차 선택. 핵심 무결성이 최우선인 서비스 (금융·의료·결제 등): Serializable(혹은 SSI + 추가 잠금/재검증) 적용 권장. 대규모 혼합 워크로드: Hybrid(선별적 직렬화 + 애플리케이션 레벨 검증 + 파티셔닝) 전략 권장. 설계 관점 (Design) 데이터 경계 정의: 불변식이 적용되는 도메인 경계를 명확히 나눠, 핵심 도메인만 강격리 적용. 모델 선택: 충돌 가능 영역은 집계 행 (single-row counters) 혹은 CQRS 로 분리해 충돌률을 낮춘다. 락 전략 설계: 범위·읽은 집합을 잠그는 전략 (선택적 SELECT … FOR UPDATE) 을 설계해 불변식 보호. 분석 관점 (Analysis) 리스크 평가: 불변식 위반 시 비즈니스 영향 (금전·안전·법적 리스크) 을 정량화해 격리 레벨 결정 근거로 사용. 성능 트레이드오프 분석: SSI/Serializable 적용 전후로 벤치마크 (throughput, latency, abort rate) 비교. 데이터 분포 분석: 핫 - 키, 파티션 스키마, 쓰기 집중 구간을 분석해 파티셔닝/샤딩 필요 여부 판단. 운영 관점 (Operations) 모니터링·알림: 재시도율, serialization failures, deadlocks, 비즈니스 무결성 체크 실패 등을 실시간 모니터링. 운영 플레이북: 무결성 위반 발생 시 우선격리 상향, 트래픽 셰이핑, 롤백·수정 절차 등 대응 시나리오 준비. 점진 적용·테스트: Canary/배치별로 격리 설정 변경 후 관측 (사전 자동 동시성 테스트 권장). Write Skew 적용 적합성 판단표 시나리오 유형 권장 기본 전략 보완 조치 (필요 시) 고려 포인트 (설계·운영) 읽기 - 중심 대규모 서비스 (예: 콘텐츠, 피드) Snapshot Isolation (SI) 모니터링, 불변식 테스트 핫스팟 여부, 낮은 불변식 민감도 사용자 참여 많은 실시간 서비스 (예: 예약, 이벤트) SI 우선 + 핫 - 스팟 차단 (파티셔닝) 특정 경합 영역에 FOR UPDATE 동시 쓰기 패턴, 배치 삽입 시간대 핵심 금융/의료/결제 Serializable 또는 SSI 읽은 집합 잠금, DB 제약, 애플리케이션 재검증 비즈니스 리스크·감사요구 혼합 워크로드 (읽기 + 쓰기 모두 높음) Hybrid(선별적 격리 상향) CQRS/집계 분리, 파티셔닝 도메인 경계 정의·테스트 계획 배치/ETL 중심 (대량 삽입) SI + 배치 격리 처리 (창구화) 일괄처리 창구·동시성 제어 배치 시간대·리소스 스케줄링 원칙: 성능 우선인가, 무결성 우선인가를 먼저 결정하고 그에 따라 격리 전략을 선택하라.\n실무흐름: 위험 식별 → 기본 전략 (SI 권장) 적용 → 핵심 도메인에 보완 (잠금/Serializable) → 성능·무결성 테스트 → 운영 모니터링.\n운영 팁: 격리 상향은 전체 시스템에 적용하기보다 도메인 단위로 점진 적용하고, 재시도·abort 상황을 자동화·관측해야 안전하다.\n실무 적용 및 사례 실습 예제 및 코드 구현 실습 예제: 병동 온콜 불변식 (최소 1 명) 목적 SI 에서 Write Skew 발생을 재현하고, SERIALIZABLE 과 잠금 기반 해결을 체득. 사전 요구사항 PostgreSQL 14+ (로컬), psql 단계별 구현 스키마 및 시드\n1 2 3 4 5 6 7 8 9 10 DROP TABLE IF EXISTS doctors; CREATE TABLE doctors ( id SERIAL PRIMARY KEY, ward TEXT NOT NULL, name TEXT NOT NULL, on_call BOOLEAN NOT NULL ); INSERT INTO doctors(ward, name, on_call) VALUES ('A','Alice', TRUE), ('A','Bob', TRUE); Write Skew 재현 (REPEATABLE READ≈SI)\n세션 1:\n1 2 3 4 BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT count(*) FROM doctors WHERE ward='A' AND on_call=TRUE; -- 기대: 2 UPDATE doctors SET on_call=FALSE WHERE name='Alice'; -- COMMIT는 잠시 보류 세션 2:\n1 2 3 4 BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT count(*) FROM doctors WHERE ward='A' AND on_call=TRUE; -- 기대: 2 (스냅샷) UPDATE doctors SET on_call=FALSE WHERE name='Bob'; COMMIT; -- 성공 세션 1:\n1 2 COMMIT; -- 성공 → 결과적으로 on_call=0 (불변식 위반) SELECT count(*) FROM doctors WHERE ward='A' AND on_call=TRUE; -- 0 해결 1: SERIALIZABLE(SSI)\n초기화 후 재실행, 차이만 표시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 TRUNCATE doctors RESTART IDENTITY; INSERT INTO doctors(ward, name, on_call) VALUES ('A','Alice',TRUE),('A','Bob',TRUE); -- 세션1 BEGIN ISOLATION LEVEL SERIALIZABLE; SELECT count(*) FROM doctors WHERE ward='A' AND on_call=TRUE; -- 2 UPDATE doctors SET on_call=FALSE WHERE name='Alice'; -- 세션2 BEGIN ISOLATION LEVEL SERIALIZABLE; SELECT count(*) FROM doctors WHERE ward='A' AND on_call=TRUE; -- 2 UPDATE doctors SET on_call=FALSE WHERE name='Bob'; COMMIT; -- 둘 중 한 세션이 여기 또는 다음 COMMIT에서 40001로 롤백됨 -- 세션1 COMMIT; -- 40001 Serialization failure 발생 가능 → 재시도 필요 해결 2: 가드 행 + 명시적 잠금\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- 가드 테이블: 병동별 on_call 수 카운트 CREATE TABLE ward_guard ( ward TEXT PRIMARY KEY, on_call_count INT NOT NULL ); INSERT INTO ward_guard VALUES ('A', 2); -- 트리거로 유지(단순화 예시) CREATE OR REPLACE FUNCTION upd_guard() RETURNS trigger AS $$ BEGIN IF NEW.on_call \u003c\u003e OLD.on_call THEN UPDATE ward_guard SET on_call_count = on_call_count + (CASE WHEN NEW.on_call THEN 1 ELSE -1 END) WHERE ward = NEW.ward; END IF; RETURN NEW; END; $$ LANGUAGE plpgsql; DROP TRIGGER IF EXISTS trg_doctors_guard ON doctors; CREATE TRIGGER trg_doctors_guard AFTER UPDATE ON doctors FOR EACH ROW EXECUTE FUNCTION upd_guard(); -- 세션1 BEGIN; SELECT on_call_count FROM ward_guard WHERE ward='A' FOR UPDATE; -- 가드 행 잠금 UPDATE doctors SET on_call=FALSE WHERE name='Alice'; -- 세션2는 같은 가드 행에서 대기 또는 타임아웃 실행 결과 REPEATABLE READ: Write Skew 재현. SERIALIZABLE: 한 트랜잭션이 **Serialization Failure(40001)** 로 중단 → 재시도 시 불변식 유지. 가드 행: 두 세션이 동일 행에 WW 충돌 → 순차화. 추가 실험 SELECT … FOR UPDATE 로 프레디킷을 인덱스 범위로 잠그는 설계 비교. 충돌 빈도에 따른 재시도 백오프 파라미터 실험. Phase 6: 운영 및 최적화 Write Skew 관측·모니터링 실무 가이드 Write Skew 등의 직렬성 이상을 잡으려면 직렬화 실패 (40001), 데드락 (40P01), 락 대기 시간, 애플리케이션 재시도 빈도, 그리고 핫 로우 (키별 집중) 같은 지표를 모니터링해야 한다.\nDB 내 pg_locks·pg_stat_activity 를 정기 조회하고, 에러 로그와 exporter(예: postgres_exporter) 를 통해 메트릭을 Prometheus/Grafana 나 SIEM 으로 집계하면 실시간 탐지·알람·포렌식이 가능하다.\n임계값 (알람) 은 워크로드·SLA 에 맞춰 실험적으로 정하라.\nWrite Skew 관측 카테고리 시그널 메트릭 (에러·지연 중심) serialization_failure_rate(SQLSTATE 40001), deadlock_rate(40P01), lock_wait_ms(avg/95p), retry_count.\n이 지표들은 직렬성 위반·락 경합·재시도 과부하를 조기에 감지한다. 알람 예: 5 분간 serialization_failure_rate \u003e 0.5% → P1 알람.\n지표 왜 보는가 구현 예 serialization_failure_rate 직렬성 위반 (직접 신호) DB 로그/애플리케이션 에러 → Prometheus counter deadlock_rate 락 정책 문제·교착 DB 로그 (40P01) 파싱 → SIEM 이벤트 lock_wait_ms 성능저하 전조 pg_locks/pg_stat_activity → exporter metric retry_count 재시도 과부하 앱 레이어 로그 → central metrics 시그널 메트릭은 Write Skew 가능성 뿐 아니라 운영성 문제 (지연·재시도 과부하) 를 빠르게 알려주는 역할을 한다. 직렬화 오류 (40001) 는 반드시 수집·집계해 재시도 정책과 연동하라. 락·세션 관측 (상태·그래프 중심) pg_locks, pg_stat_activity 정기 스냅샷 및 deadlock 그래프 캡처.\n블로킹/대기 세션 트리거 시 자동 스냅샷 (locks + queries) 저장.\n항목 왜 보는가 구현 예 pg_locks 스냅샷 누가 무엇을 잠그는지 파악 주기 cron job 또는 트리거 시 수집 pg_stat_activity 세션별 현재 쿼리 상태 대기 중인 쿼리·트랜잭션 길이 확인 deadlock graph 교착 원인 분석 deadlock 발생 시 자동 수집 스크립트 락·세션 관측은 문제의 근본 원인 (누가, 어떤 쿼리가 락을 잡고 있는지) 을 파악하는 데 필수적이다. deadlock 발생 시 즉시 그래프를 캡처해 원인분석에 사용하라. 애플리케이션 레벨 지표 (재시도·비즈니스 실패) 애플리케이션에서 발생한 retry_count, 재시도 후 성공률, idempotency 실패 로그, 비즈니스 규칙 위반 알람 등.\n재시도 로직의 폭주 여부를 감지해 자동 백오프·큐잉 유도.\n항목 왜 보는가 구현 예 retry_count 재시도 과부하 감지 미들웨어/라이브러리에서 카운트 노출 retry_success_rate 재시도 효과성 평가 성공/총 재시도 비율 계산 business_violation_events 규칙 위반 감지 애플리케이션 레벨 감사 이벤트 애플리케이션 지표는 DB 알람과 결합해 전체 워크플로의 건강도를 판단하게 해준다. 재시도 증가와 직렬화 실패가 함께 나타나면 자동화 대책을 검토하자. 핫스팟/스케일 지표 (키·노드 중심) 특정 키·인덱스에 집중된 요청 (QPS), 노드별 리소스·latch contention, 샤드별 트래픽 편중 등. 핫스팟이 확인되면 샤딩·파티셔닝·레디스 캐시 등 아키텍처적 대응을 검토.\n항목 왜 보는가 구현 예 key QPS 분포 특정 키 집중 확인 pg_stat_statements + 로그 파싱 node contention 분산 DB 노드 문제 벤더 콘솔/노드 메트릭 index contention 인덱스 락 집중 index-level statistics 수집 핫스팟은 시스템 전반 성능·정합성에 악영향을 준다. 조기 탐지로 샤드·캐시·데이터 모델 변경을 통해 충돌을 국지화하라. Write Skew 관측 통합 대시보드 항목 카테고리 핵심 메트릭/로그 목적 우선순위 시그널 메트릭 serialization_failure_rate(40001), deadlock_rate(40P01), lock_wait_ms, retry_count 이상 탐지·알람 높음 락·세션 관측 pg_locks, pg_stat_activity, deadlock graph 원인 분석 (누가,무엇을) 높음 애플리케이션 지표 retry_count, retry_success_rate, business_violation_events 재시도/비즈니스 영향 파악 높음 핫스팟 지표 key QPS 분포, index contention, node resource 확장성·샤딩 판단 근거 중~높 이 네 카테고리를 통합한 대시보드는 Write Skew·직렬성 이상을 조기에 탐지하고, 원인 분석→자동화 대응→아키텍처 개선으로 이어지는 운영 루프를 완성한다. 먼저 serialization_failure_rate 와 pg_locks 기반 알람을 구성하고, 이후 애플리케이션 재시도·핫스팟 분석을 추가하라.\n6.2 보안 및 컴플라이언스 Write Skew 는 동시 트랜잭션이 같은 판단 근거로 행동해 전역 규칙을 깨는 현상이다.\n보안·컴플라이언스 관점에서는 단순 성능 조치로 해결되지 않으므로, 권한 통제, 트랜잭션 복구 정책, 멱등성/아웃박스 패턴, 불변의 감사 로그, 데이터 암호화, 그리고 모니터링을 조합해 리스크를 관리해야 한다.\n규제 업종은 특히 증적 보관·무결성·접근 통제가 엄격하다.\nWrite Skew 보안·컴플라이언스 카테고리 접근 제어 \u0026 거버넌스 접근 제어는 누가 어떤 트랜잭션을 실행할 수 있는지를 제한해, 권한 남용이나 오작동으로 인한 불변식 위반을 방지한다. 실무적 적용으로는 RBAC, 최소 권한, 서비스 계정 분리, 운영자 액션 감사 (log of admin actions) 를 둔다. 규제 요건 (감사·접근 통제) 을 매핑해 권한 부여·검토 주기를 정한다.\n트랜잭션 안전성 \u0026 롤백 트랜잭션 안전성은 실패 시 데이터 일관성을 보장하는 메커니즘과 복구 절차를 포함한다. 자동 재시도는 멱등성 전제하에 적용하고, 복구 불가능한 실패엔 보상 (Saga) 또는 수동 복구 절차를 문서화한다. 또한 트랜잭션 실패에 대한 알림·수정 프로세스를 운영에 포함한다.\n멱등성 \u0026 아웃박스 멱등성은 동일 요청을 여러 번 적용해도 결과가 동일하도록 설계하는 것 (요청 토큰, idempotency key). 아웃박스 패턴은 DB 트랜잭션과 이벤트 발행을 원자적으로 묶어 분산 불일치 위험을 줄인다. 두 패턴은 재시도·비동기 통합에서 필수적이다.\n감사 추적 \u0026 증적 보존 트랜잭션 로그·변경 이력·트랜잭션 ID·버전 정보를 불변 (append-only) 으로 보관하고, 보관 기간·무결성 (암호화·서명) 을 규정에 맞춰 설정한다. 포렌식·감사 요청 시 재현 가능하도록 메타데이터를 포함해 저장한다.\n데이터 보호 (암호화·키관리) 민감 데이터는 전송·저장에서 암호화하고, 키 관리는 중앙화 (KMS/HSM) 하여 접근·사용을 통제한다. 데이터 최소화·익명화 정책도 병행해 규제 위험을 축소한다.\n모니터링·경보·운영 정책 충돌률, 재시도 실패율, 직렬화 실패 (HTTP 40001 등), lock-wait 등을 지표로 수집하고, 임계치 초과 시 자동 정책 (일시적 격리 상향, 트래픽 제한) 실행한다. Jepsen 스타일 검증을 주기적으로 실행해 실환경 가설 검증을 권장한다.\n쓰기스큐 보안 종합 실행표 영역 주요 조치 목적 운영 지표 (예시) 접근 통제 RBAC, 세분화된 DB 권한 권한 오남용 방지 관리자 액션 로그 수, 권한 변경 빈도 트랜잭션 복구 멱등 재시도, Saga, 보상 실패 시 무결성 유지 재시도율, 보상 성공률 아웃박스·멱등성 Outbox 테이블, idempotency key 분산 이벤트 일관성 Outbox 미전송 건수, 소비자 중복률 감사·증적 변경 이력, 불변 로그, 서명 규제 증빙·포렌식 감사로그 보관완료율, 검색 응답시간 데이터 보호 TLS/TDE, KMS 관리 데이터 유출 방지 암호화 적용률, 키 회전 주기 모니터링 충돌률, serial failures, lock-wait 조기 경보·자동 조치 충돌률 (%), 직렬화 실패 건수 Write Skew 성능·확장 최적화 전략 Write Skew 같은 동시성 문제는 일관성 강화를 위해 모든 트랜잭션을 무조건 직렬화하면 성능이 급격히 떨어진다.\n그래서 실무에서는 짧은 트랜잭션 유지·인덱스 튜닝으로 락 범위를 줄이고, 핵심 경로만 높은 격리 적용, 지수 백오프 재시도와 같이 성능과 일관성의 균형을 맞춘다. 대규모일수록 샤딩·캐시·비동기 처리를 통해 충돌 표면을 분할·완화하는 것이 핵심이다.\nWrite Skew 성능·확장 카테고리 재시도·백오프 정책 내용: 충돌 (직렬화 실패·낙관적 잠금 충돌) 시 재시도 로직을 지수 백오프로 구현하고 재시도 횟수 제한과 랜덤 지터를 추가한다. 재시도 시 멱등성(idempotency key) 확보가 필수.\n구현 팁: base=100ms, 재시도 n 일 때 delay = base * 2^n ± rand(0, base); 최대 재시도 3~5 회; 실패 시 사용자 피드백 또는 작업 큐로 이관.\n항목 목적 구현 예 주의점 지수 백오프 + 지터 재시도 폭주 방지 base*2^n ± jitter 멱등성 미보장 시 중복 문제 최대 재시도 제한 자원 낭비 방지 maxRetries=3~5 사용자 경험 고려 멱등키 중복 처리 방지 request_id 토큰 토큰 저장소 필요 (짧은 TTL) 요약: 재시도는 필수지만 제어하지 않으면 시스템을 망가뜨린다. 지수 백오프·지터·멱등성 조합으로 안전하게. 트랜잭션·락 설계 내용: 트랜잭션을 짧게 유지하고, 불가피한 경우 핵심 행만 SELECT … FOR UPDATE 로 잠그거나 핵심 경로만 Serializable 로 설정한다. 인덱스를 통해 락 범위를 좁힌다.\n구현 팁: EXPLAIN 으로 범위 스캔 확인, 트랜잭션 내 외부 호출 제거, 필요 시 저장 프로시저로 원자화.\n항목 목적 구현 예 주의점 트랜잭션 단축 락 보유 시간 최소화 읽기 후 계산, 쓰기만 트랜잭션 외부 I/O 제거 필요 행 수준 잠금 충돌 방지 (핫스팟) SELECT … FOR UPDATE 동시성 저하 가능 혼합 격리 부분적 직렬화 적용 핵심 API 만 Serializable 운영 복잡성 증가 요약: 락·격리 수준을 좁게·선택적으로 적용해 성능을 지켜라. 데이터 접근 패턴 (인덱스·캐시) 내용: 인덱스를 통한 범위 축소로 락 효과를 높이고, 읽기 부담은 캐시로 오프로드한다. 쓰기 직후의 일관성 보장은 세션 강제 마스터 읽기나 캐시 무효화 전략으로 보완.\n구현 팁: EXPLAIN → 복합 인덱스 추가, 캐시에는 쓰기 후 즉시 무효화 또는 이벤트 기반 동기화.\n항목 목적 구현 예 주의점 인덱스 튜닝 락 범위 축소 복합 인덱스, 커버링 인덱스 인덱스 비용 (쓰기 비용) 캐싱 읽기 부하 완화 Redis, TTL, pub/sub 무효화 캐시 일관성 관리 필요 마스터 강제 읽기 스테일 리드 방지 세션 레벨 설정 리플리카 부하 고려 요약: 선제적 인덱스와 캐시 전략으로 DB 충돌 표면을 줄여라. 아키텍처적 확장 (샤딩·분산락·CQRS) 내용: 도메인 분할 (샤딩) 으로 충돌 범위를 줄이고, 글로벌 불변식은 분산 락이나 이벤트 방식으로 처리. 쓰기·읽기 분리, CQRS 로 확장성 확보.\n구현 팁: 샤드 키는 균등 분포 목표, 분산 락은 TTL·리더 선출로 안전성 확보, CQRS 시 보상 트랜잭션 설계.\n항목 목적 구현 예 주의점 샤딩 충돌 도메인 분리 user_id % N 샤드 크로스샤드 트랜잭션 비용 분산 락 글로벌 불변식 보장 etcd / Redis RedLock 네트워크 지연·가용성 고려 CQRS / 이벤트 확장성·비동기 처리 Command queue + read model 복잡성·운영 부담 증가 요약: 샤딩·분산락·CQRS 는 강력하지만 설계·운영 비용이 크다—꼭 필요한 곳에만 적용하라. 운영·모니터링 내용: 재시도율, 직렬화 실패율, 락 대기 p95/p99, 트랜잭션 길이 등의 지표로 성능·충돌을 관측하고 자동화된 런북으로 1 차 대응을 실행.\n구현 팁: Prometheus + Grafana, OpenTelemetry, 알람 임계값 (예: 직렬화 실패 \u003e0.5% 경고).\n지표 목적 임계값 예시 대응 재시도율 충돌 빈도 감지 \u003e2% 경고 백오프 조정, 패치 직렬화 실패율 SSI/Serializable 문제 신호 \u003e0.5% 심각 핵심 경로 점검 락 대기 p95 락 경합 탐지 p95 \u003e 2000ms 트랜잭션 분해 요약: 계측 (모니터링) 은 모든 설계의 필수 전제—지표 기반으로 조치하라. Write Skew 대응 종합 전략표 카테고리 핵심 기법 목적 구현 포인트 재시도 · 백오프 지수 백오프 + 지터, 멱등키, 재시도 한도 재시도 폭주/리소스 낭비 방지 base delay, maxRetries, 멱등성 확보 트랜잭션·락 설계 트랜잭션 단축, 행 잠금, 혼합 격리 락 보유시간·경합 최소화 EXPLAIN, FOR UPDATE, 핵심만 Serializable 데이터 접근 인덱스 튜닝, 캐시, 마스터 강제 읽기 락 범위 축소·읽기 부하 완화 복합 인덱스, 캐시 무효화 전략 아키텍처 확장 샤딩, 분산 락, CQRS 샤드 단위 충돌 축소·확장성 확보 샤드키 설계, TTL 락, 이벤트소싱 운영·관측 재시도율·직렬화 실패·락 p95 모니터링 조기 경보·자동화 대응 Prometheus/Grafana, Runbook 6.4 트러블슈팅 및 문제 해결 Write-Skew 트러블슈팅 종합 가이드 증상: 간헐적으로 집계·제약이 깨져 결과가 틀림. 원인: 동시 트랜잭션이 같은 스냅샷을 보고 서로 다른 행을 바꿔도 DB 가 이를 막지 못하는 상황 (=write-skew). 당장 해야 할 일: 문제 트랜잭션 찾아 재현 → 임시로 해당 경로에 락 적용 또는 격리 상향 → 근본적으로는 버전검사·원자적 업데이트·DB 제약으로 해결. 중요: 프로덕션 격리 변경은 비용 (성능/가용성) 을 수반하므로 단계적으로 적용하고 모니터링해야 한다. 왜 발생하는가 (근본 원인) 동시 트랜잭션이 같은 시점의 스냅샷을 읽고 서로 다른 행을 갱신할 때, 쓰기 - 쓰기 충돌이 명시적으로 없으면 SI 등 낮은 격리에서 커밋을 허용하여 비즈니스 불변식을 위배한다 (=write-skew). 또한 핫 파티션 (동일 키/범위에 집중된 트래픽), 잘못된 인덱스 또는 조건 기반 업데이트가 원인을 악화시킨다. 무엇으로 어떻게 해결하는가 (구체적 수단) 단기 완화 (빠른 대응)\n문제 트랜잭션을 식별해 임시로 해당 경로에 SELECT … FOR UPDATE 같은 비관적 잠금 적용. 문제 범위가 좁으면 격리 수준을 Serializable(또는 DB 의 SSI 활성화) 로 높여 보수적으로 처리 (단, 카나리아/제한 적용). 임시로 해당 키에 애플리케이션 락 (Advisory lock) 적용. 근본 해결 (설계/코드 변경)\n원자적 SQL로 표현 가능한 연산은 DB 쪽으로 위임 (UPDATE … WHERE version = x 또는 UPDATE accounts SET bal = bal +? WHERE id=?). 낙관적 락 (버전 컬럼) + 재시도 로직 도입 (지수 백오프 + 지터). 비즈니스 불변식은 DB 제약 (CHECK, EXCLUSION, UNIQUE) 또는 가드 행 (집계 행) 으로 모델링. 핵심 트랜잭션은 SSI/Serializable 로 처리하고 일반 트랜잭션은 SI 로 운영하는 하이브리드 전략 도입. 운영 보완\n충돌·재시도·abort 지표화 (모니터링→경보). 정기적 동시성 스트레스 테스트 및 재현 시나리오 자동화. 감사 로그·CDC 기반 포렌식과 복구 절차 준비. Write-Skew 트러블슈팅 탐지·탐색 (Detection \u0026 Triage) 증상 식별과 우선순위 분류 단계.\n핵심 활동: 사용자 리포트·경고 수집 (에러/무결성 불일치) 관련 트랜잭션 ID·타임스탬프·쿼리 패턴 확보 초기 영향 범위 결정 (테이블/파티션/서비스) 도구/명령 예: PostgreSQL: pg_stat_activity, pg_locks, pg_stat_wal MySQL: SHOW PROCESSLIST, SHOW ENGINE INNODB STATUS 애플리케이션 로그, APM(트레이스) 항목 목적 도구/증거 에러/리포트 수집 문제 인지 Sentry/로그/유저 리포트 트랜잭션 식별 원인 트래픽 타겟 tx id, timestamp 초기 영향 범위 긴급도 판정 테이블/파티션 목록 핵심: 문제를 빠르게 탐지하고 영향 범위를 좁혀 우선순위를 정하라. 재현·분석 (Reproduction \u0026 Root Cause) 원인 재현과 근본 원인 분석 단계.\n핵심 활동: 스테이징에서 동시성 재현 (다중 세션, sleep 타이밍) EXPLAIN ANALYZE 로 실행계획 확인 락/대기 로그, deadlock 로그 분석 WAL/Redo 또는 CDC 로 커밋 시퀀스 검증 도구/명령 예: SQL 스크립트 (동시 트랜잭션), EXPLAIN, SHOW ENGINE INNODB STATUS, pg_waldump 항목 목적 도구/증거 동시성 재현 문제 원인 확인 동시 스크립트/트랜잭션 시뮬레이터 락·대기 분석 잠금 원인 규명 pg_locks / innodb status 로그 타임라인 커밋 시퀀스 검증 WAL / binlog / CDC 핵심: 재현 가능한 시나리오를 만들고 로그로 타임라인을 검증하면 근본 원인을 정확히 파악할 수 있다. 단기 완화 (임시 대책) (Immediate Mitigation) 프로덕션 영향 최소화를 위한 신속한 조치.\n핵심 활동: 문제 트랜잭션에 대한 SELECT … FOR UPDATE 적용 (범위 제한) 키·범위에 advisory lock(앱 레벨) 적용 제한적 격리 상향 (카나리아/특정 서비스에만) 트래픽 셰이딩 (핫파티션 임시 분리) 도구/명령 예: SQL 변경 (롤링 적용), 앱 레벨 락 코드, 트래픽 라우팅 항목 목적 실행 예 FOR UPDATE 적용 즉시 일관성 확보 특정 쿼리 변경 Advisory Lock 분산 락 적용 Redis/DB advisory lock 격리 상향 (카나리아) 근본 변경 전 임시 보호 SERIALIZABLE on subset 핵심: 임시완화는 최소범위·단기간 적용하고 영향 (성능) 을 면밀히 모니터링하라. 근본 해결 (설계/코드) (Permanent Fixes) 재발 방지 위한 설계·코드 변경.\n핵심 활동: 원자적 SQL 또는 version 기반 낙관적 락 구현 DB 제약 (CHECK/EXCLUSION/UNIQUE) 추가 핵심 트랜잭션을 SSI/Serializable 로 전환 (선별 적용) CQRS/파티셔닝/leader-per-shard 등 아키텍처 변경 도구/명령 예: DB 마이그레이션 (제약 추가), 코드 배포, 테스트 자동화 항목 목적 구현 예 원자적 SQL 네트워크/중간상태 제거 UPDATE … WHERE version =? DB 제약 추가 무결성 강제 CHECK / UNIQUE / EXCLUSION 하이브리드 격리 비용 - 효율적 정합성 SSI for critical 핵심: 설계 변경은 충분한 테스트·롤아웃 계획 (카나리아) 과 모니터링을 동반해야 안전하다. 운영·모니터링 (Monitoring \u0026 Prevention) 지표 기반 탐지와 예방적 운영.\n핵심 활동: 충돌률 (abort rate), 재시도 횟수, lock wait, P99 레이턴시 지표 수집 경보 임계치 설정 및 자동화 대응 (서킷브레이커) 정기 동시성 스트레스 테스트 및 회귀 테스트 도구/명령 예: Prometheus/Grafana, APM, Synthetic Tests 항목 목적 구현 예 충돌률 지표 이상탐지 prometheus metric 자동 경보 신속 알림 PagerDuty 정기 테스트 회귀 방지 CI 스트레스 테스트 핵심: 측정 가능한 지표를 정하고 자동 경보와 주기적 테스트로 사전 예방하라. 회복·감사 (복구/포렌식) (Recovery \u0026 Forensics) 사건의 복구와 원인 증거 확보.\n핵심 활동: WAL/binlog/CDC 기반 타임라인 복원 및 증거 수집 무결성 검증 (체크섬), 복구 시나리오 실행 (restore drill) 사후보고 (RCA) 와 교훈 문서화 도구/명령 예: pg_waldump, mysqlbinlog, Debezium CDC, WORM 보관소 항목 목적 도구 로그 기반 복구 시계열 재구성 WAL / binlog / CDC 복구 연습 복구 능력 검증 복원 시나리오 사후보고 프로세스 개선 RCA 문서 핵심: 사건 증거를 안전히 보관하고 정기적으로 복구 능력을 검증하라. Write-Skew 문제해결 요약표 카테고리 핵심 목표 대표 조치 (단기 → 중기 → 장기) 대표 도구/지표 탐지·탐색 빠르게 문제 인지·영향파악 로그 수집 → tx id 확보 → 영향도 분류 Sentry, pg_stat_activity, SHOW ENGINE 재현·분석 근본 원인 규명 스테이징 재현 → EXPLAIN/락 로그 분석 EXPLAIN, pg_locks, innodb status 단기 완화 프로덕션 영향 최소화 FOR UPDATE / advisory lock / 카나리아 격리 SQL 변경, App lock 근본 해결 재발 방지 설계 적용 version lock, DB 제약, SSI 적용 마이그레이션, 코드배포 운영·모니터링 사전 탐지·자동화 대응 지표 채택 → 경보 → 정기 테스트 Prometheus, Grafana, APM 회복·감사 복구·증거 확보 WAL/binlog 복구 → RCA → 문서화 pg_waldump, mysqlbinlog, CDC 핵심 흐름: 탐지 → 재현·분석 → 임시완화 → 근본해결 → 모니터링 → 회복 (사후분석).\n운영 규칙: 프로덕션 변경은 항상 제한적 (카나리아)·모니터링 기반으로 수행하고, 근본 해결은 충분한 재현·테스트 후 단계적으로 롤아웃하라.\n최종 정리 및 학습 가이드 내용 종합 Write Skew 는 실무에서 특히 위험한 동시성 버그다. 두 트랜잭션이 동일한 조건을 읽고 (예: \" 이 병동에 on_call 이 있나?”) 서로 다른 행을 변경하면, 각각의 로컬 판단은 옳지만 합쳐진 결과가 도메인 규칙을 위반할 수 있다. 예컨대 의사 A 와 B 가 각자 \" 나만 off 처리하면 다른 사람이 남아있다 \" 는 판단으로 동시에 off 를 처리하면 실제로는 아무도 남지 않는다.\n기술적으로 SI(스냅샷 격리) 는 각 트랜잭션에 안정된 읽기 스냅샷을 제공하지만, 서로의 쓰기를 보지 못하므로 전역 불변식을 보장하지 못한다. 따라서 실무에서는 다음 중 하나 혹은 조합을 택한다.\n직렬화 (Serializable): DB 가 논리적 직렬화를 보장하지만 충돌 시 트랜잭션을 롤백하므로 재시도 비용 발생. 비관적 락: 관련 리소스에 락을 걸어 문제를 예방하나 동시성·스루풋 손실과 데드락 위험 존재. 애플리케이션 설계 변경: 불변식 경계를 좁혀 단일 행으로 묶거나 원자적 연산으로 처리하면 비용을 줄일 수 있다. 분산 시스템 대책: 샤딩 경계 재설계나 Sagas 와 같은 보상 패턴을 통해 전역 일관성 요구를 낮추는 방법도 있다. 결론적으로 현실적 운영에서는 SSI/2PL/스키마 개선/앱 락의 혼합 전략으로 안전성과 성능을 균형 맞춘다.\n실무 적용 가이드 단계 작업 항목 대상 (레벨) 구현 예시 장점 주의사항 1 불변식 식별 및 우선순위화 비즈니스/도메인 불변식 목록, 영향도 점수 (금전·안전성) 보호 우선순위 명확화 식별 누락 위험—리뷰 필요 2 인덱스·범위 설계 DB 쿼리/스키마 인덱스 추가·쿼리 리팩토링, EXPLAIN 범위 노출 축소 → 위험 감소 인덱스 과다로 쓰기 비용 증가 3 방어전략 선택 (권장 조합) DB / App / Infra DB: SERIALIZABLE/SSIApp: SELECT FOR UPDATE, sentinel rowInfra: Redis 분산락 불변식 보호 (여러 층의 보강) 성능 영향, 데드락·가용성 고려 4 재시도·멱등성 애플리케이션 지수 백오프 + 지터, 멱등 토큰, max 3~5 회 충돌 시 자동 복구·사용자 영향 최소화 재시도 비용·UX 지연 5 관측·알람·튜닝 운영/모니터링 지표: tx_latency, abort_rate, long_tx_count, undo_size 조기탐지·원인분석 용이 임계치 설정과 노이즈 관리 필요 6 테스트·검증 QA/스테이징 재현 시나리오 (동시 트랜잭션 스크립트), 격리수준별 A/B 테스트 실제 영향 확인·정책 검증 스테이징이 프로덕션과 다를 수 있음 7 운영 룰북 작성 운영팀/개발팀 deadlock victim 정책, 자동 rollback 기준 문서화 신속 대응·책임소재 명확화 룰 유지보수 필요 학습 로드맵 단계 주제 범위 학습 목표 실습 (구체) 평가 지표 권장 도구 1 기초 ACID, Read Committed / Repeatable Read / Serializable, MVCC 개념 격리 수준과 이상 종류 이해 두 세션 동시 UPDATE 재현 (Lost Update) 데이터 일관성 위반 여부 Postgres, MySQL 2 핵심 Serialization Graph, Write Skew, Phantom 읽기 - 쓰기 의존성 이해 및 재현 On-call Write Skew 시나리오 실행 무결성 위반 재현 여부 Postgres(SI) 3 응용 SELECT FOR UPDATE, 가드 행, 트리거·제약 불변식 보호 패턴 적용 능력 FOR UPDATE 적용 후 재검증, 집계 행 모델 적용 abort 률, P99, 무결성 유지 pgbench, EXPLAIN 4 고급 SSI, Predicate Lock, Index Range Lock, 분산 트랜잭션 고급 직렬성, 분산 불변식 설계 SSI 켜고 성능 비교, 분산 트랜잭션 (2PC) 시뮬 throughput, abort rate, 운영 복잡도 OpenTelemetry, Jaeger, 2PC 툴 학습 항목 정리 단계 항목 목표 실습/과제 실무 연관성 비고 기초 ACID/트랜잭션 시작/종료 트랜잭션 흐름 파악 BEGIN/COMMIT/ROLLBACK 실습 모든 서비스 필수 문서 숙지 기초 격리 수준 차이 이상별 차이 재현 Dirty/Lost/Non-repeatable 실습 디버깅용 EXPLAIN 병행 핵심 Write Skew 재현 SI 한계 직접 체감 의사 on-call 예제 (2TX) 예약/의료 SQL 스크립트 제공 핵심 Serialization Graph 사이클 탐지 이해 그래프 작성 연습 설계 검토 도구 수기 그래프/자동화 스크립트 응용 SELECT FOR UPDATE 읽은 집합 잠금 적용 적용 후 성능/무결성 비교 트랜잭션 보호 록 웨이트 관찰 응용 가드 행/집계 행 충돌 영역 축소 모델 변경 후 테스트 이벤트·카운터 시스템 CQRS 연계 고급 SSI 내부 충돌 검출 원리 학습 SSI 활성화로 비교 실험 고신뢰 시스템 Postgres SSI 고급 Predicate/Index Range Lock 범위 잠금 이해 INDEX 기반 갭락 실험 범위 쿼리 많은 시스템 인덱스 설계 병행 고급 분산 불변식 설계 전역 불변식 유지 전략 2PC/사건 소싱 시나리오 샤드된 시스템 conflict resolution 설계 용어 정리 카테고리 용어 (한글)—(영어 풀네임, 약어) 정의 (간략) 관련 개념 실무 활용 핵심 쓰기 스큐—(Write Skew) 동일 판단 기반의 분산 쓰기로 비즈니스 제약 위반 SI, RW 사이클 핵심 트랜잭션 직렬화/락 적용 핵심 팬텀—(Phantom) 범위 쿼리 결과 집합이 다른 트랜잭션으로 바뀜 Predicate/Range Lock, Gap Lock 범위 락/인덱스 설계, 트랜잭션 검증 핵심 스냅샷 격리—(Snapshot Isolation, SI) 시작 시점 스냅샷 읽기, WW 만 충돌 검사 MVCC, Write Skew 허용 가능 읽기 중심 워크로드 성능 최적화 구현 명시적 잠금—(Explicit Lock / SELECT FOR UPDATE) 쿼리 수준의 선점 락 제어 Lock granularity, Deadlock 민감 판단구간 락 적용 구현 2 단계 잠금—(Two-Phase Locking, 2PL) 락 확장/축소로 직렬성 보장 Predicate Lock, Phantom 방지 강한 일관성 트랜잭션에 적용 구현 갭/넥스트키 락—(Gap / Next-Key Lock) 인덱스 gap 잠금으로 범위 삽입 차단 Phantom 방지, 인덱스 의존 인덱스 기반 범위 보호 (InnoDB) 고급 SSI—(Serializable Snapshot Isolation, SSI) SI 에 직렬성 위반 탐지 추가 Serializable, abort/retry 고성능과 정확성 균형 적용 운영 멱등성—(Idempotency) 동일 요청 반복시 결과 불변성 보장 재시도 정책, 외부 사이드이펙트 재시도 안전화, API 설계 운영 직렬성 격리—(Serializable Isolation) 모든 트랜잭션이 직렬 실행 결과와 동일 2PL, MVCC+SSI 금융·원장 등 최고 수준 보장 참고 및 출처 PostgreSQL Documentation — Transaction Isolation MySQL :: MySQL Documentation Microsoft SQL Documentation - SQL Server | Microsoft Learn 트랜잭션 격리 수준 완벽 가이드: 실무에서 만나는 문제와 해결법 [MySQL] Lost Update와 Write Skew 데이터 중심 애플리케이션 설계 Ch 7. 트랜잭션 | BLOG concurrency control 3 : transaction isolation level 트랜잭션의 동시성 문제를 알아보자 JPA의 낙관적 락과 비관적 락을 통해 엔티티에 대한 동시성 제어에 대해 알아보자 (Spring/JPA/Transaction) 쓰기 스큐, 팬텀. Write skew, Phantom 트랜잭션 격리 수준과 실무에서의 활용 InnoDB의 REPEATABLE READ가 PHANTOM READ를 방지하는 원리 Spring JPA Transactional과 Transaction Isolation Level 격리수준 실습 Phantom Read 부정합문제 해결방안 In PostgreSQL, MSSQL Server ","wordCount":"8626","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-09-12T03:49:00Z","dateModified":"2025-09-12T03:49:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Write Skew</h1><div class=post-description>Write Skew는 스냅샷 격리에서 서로 다른 행을 동시에 수정해 전체 불변식(예: 최소 인원 유지)을 깨뜨리는 동시성 이상이다. 직접적인 쓰기-쓰기 충돌이 없어 SI에서 감지되지 않으며, 해결책으로는 Serializable/SSI, 읽은 집합 잠금(SELECT FOR UPDATE), 데이터베이스 제약 또는 커밋 전 재검증이 있다.</div><div class=post-meta><span title='2025-09-12 03:49:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;41 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20&%20Database%20Systems/Data%20Operations/Transaction%20Management/Transaction/Transaction%20Isolation/Concurrency%20Anomalies/write-skew.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#write-skew>Write Skew</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#기초-조사-및-개념-정립>기초 조사 및 개념 정립</a></li><li><a href=#phase-2-핵심-원리-및-이론적-기반>Phase 2: 핵심 원리 및 이론적 기반</a></li><li><a href=#특성-분석-및-평가>특성 분석 및 평가</a></li><li><a href=#실무-적용-및-사례>실무 적용 및 사례</a></li><li><a href=#phase-6-운영-및-최적화>Phase 6: 운영 및 최적화</a></li><li><a href=#62-보안-및-컴플라이언스>6.2 보안 및 컴플라이언스</a></li><li><a href=#write-skew-성능확장-최적화-전략>Write Skew 성능·확장 최적화 전략</a></li><li><a href=#64-트러블슈팅-및-문제-해결>6.4 트러블슈팅 및 문제 해결</a></li></ul></li><li><a href=#최종-정리-및-학습-가이드>최종 정리 및 학습 가이드</a><ul><li><a href=#내용-종합>내용 종합</a></li><li><a href=#실무-적용-가이드>실무 적용 가이드</a></li><li><a href=#학습-로드맵>학습 로드맵</a></li><li><a href=#학습-항목-정리>학습 항목 정리</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=write-skew>Write Skew<a hidden class=anchor aria-hidden=true href=#write-skew>#</a></h2><p>Write Skew 는 두 트랜잭션이 같은 **판단 (읽기)**을 하고 각자 다른 레코드를 <strong>갱신</strong>해서 결과적으로 비즈니스 규칙이 깨지는 현상이다.<br>예: 두 의사가 동시에 당직 해제 판단 → 최종적으로 아무도 남지 않는 상황. Snapshot Isolation 은 읽기는 스냅샷에서 빠르게 처리하고 쓰기 충돌 (같은 행을 동시에 쓰는 경우) 만 검사하기 때문에 이런 상황을 허용할 수 있다.<br>예방은 DB 수준 (Serializable/SSI, predicate/next-key locks) 이나 애플리케이션 수준 (guard row, 명시적 락, 집계 테이블) 으로 수행하며, 운영적으로는 직렬화 오류율을 모니터링하고 재시도 정책을 설계해야 한다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>Write Skew 는 두 개 이상의 트랜잭션이 같은 &rsquo; 판단 근거 &lsquo;(예: 현재 참가자 수) 를 보고 각자 다른 행을 수정해, 최종적으로 시스템 규칙 (예: 최대 인원) 이 깨지는 경우를 말한다.<br>SI(스냅샷 격리) 는 읽기 성능이 좋아 실무에서 자주 쓰이지만 이런 상황을 막지 못한다.<br>문제를 막으려면</p><ol><li>핵심 트랜잭션엔 직렬 가능성 (Serializable) 또는 SSI 사용</li><li>범위/프레디케이트 락 (예: SELECT FOR UPDATE, next-key lock) 적용</li><li>애플리케이션 레벨 제약 (버전 체크·재시도)<br>을 조합해 보완한다.</li></ol><table><thead><tr><th>핵심 개념 (한글·약어)</th><th>정의</th><th style=text-align:right>무슨 문제 해결?</th><th>실무 적용 방식</th></tr></thead><tbody><tr><td>다중버전 동시성 제어 (MVCC)</td><td>스냅샷 기반 읽기, 각 트랜잭션은 고유 버전 사용</td><td style=text-align:right>읽기 성능 향상, 락 경합 감소</td><td>PostgreSQL/InnoDB 등 기본 메커니즘 활용</td></tr><tr><td>스냅샷 격리 (SI)</td><td>WW 충돌을 거부, 스냅샷에서 읽음</td><td style=text-align:right>대부분의 쓰기 충돌 방지 (그러나 RW 허용)</td><td>기본 격리로 많이 사용 (성능 우수)</td></tr><tr><td>쓰기 스큐 (Write Skew)</td><td>서로 다른 행을 수정해 전역 제약 위반</td><td style=text-align:right>SI 환경에서 발생 가능한 논리 위반</td><td>Serializable/범위락/애플리케이션 제약으로 보완</td></tr><tr><td>직렬 가능성 (Serializable)</td><td>어떤 순차 실행과 동일한 결과 보장</td><td style=text-align:right>모든 동시성 이상 제거</td><td>성능 비용 수용 시 적용</td></tr><tr><td>Serializable SI (SSI)</td><td>SI 위에 위험 구조 탐지 추가</td><td style=text-align:right>SI 장점 유지하면서 직렬성 수준 안전화</td><td>PostgreSQL SSI 등에서 지원</td></tr><tr><td>2 단계 잠금 (2PL) / 프레디케이트 락</td><td>획득/해제 규칙으로 락 관리, 범위 락 포함</td><td style=text-align:right>팬텀·범위 삽입 방지</td><td>SELECT FOR UPDATE, next-key lock 등</td></tr></tbody></table><p>쓰기 스큐는 SI 환경의 대표적 논리 이상이며, MVCC/SI 가 읽기 성능을 확보하는 동안 남는 빈틈을 SSI·Serializable·범위 락·애플리케이션 제약으로 막는다. 실무선택은 무결성 중요도와 성능 요구에 따라 달라진다.</p><h4 id=개념-관계와-방지-메커니즘>개념 관계와 방지 메커니즘<a hidden class=anchor aria-hidden=true href=#개념-관계와-방지-메커니즘>#</a></h4><table><thead><tr><th>출발 (원인)</th><th>→ 작용 대상</th><th style=text-align:right>목적 (왜)</th><th>결과 (어떤 영향)</th></tr></thead><tbody><tr><td>MVCC</td><td>→ SI 동작 기반 제공</td><td style=text-align:right>읽기 동시성 확보</td><td>스냅샷 읽기 (읽기 경합 감소)</td></tr><tr><td>SI</td><td>→ 트랜잭션 간 상호작용</td><td style=text-align:right>WW 충돌 거부, RW 허용</td><td>Write Skew 가능성 발생</td></tr><tr><td>Write Skew 발생</td><td>→ 시스템 무결성 위험</td><td style=text-align:right>비즈니스 규칙 위반</td><td>필요시 Serializable 로 보완</td></tr><tr><td>SSI</td><td>→ SI 에 검출 층 추가</td><td style=text-align:right>RW 사이클 탐지·차단</td><td>직렬성 보장 (성능 - 무결성 균형)</td></tr><tr><td>2PL/Predicate Lock</td><td>→ 범위/조건 보호</td><td style=text-align:right>팬텀/삽입 차단</td><td>락 경합·교착 가능성 증가</td></tr></tbody></table><p>관계의 핵심은 " 어떤 메커니즘이 어떤 이상을 막고, 그 대가로 어떤 비용 (성능/복잡도) 을 초래하는가 " 를 명확히 하고 적절히 조합하는 것이다.</p><h4 id=write-skew-실무-대책-매핑표>Write Skew 실무 대책 매핑표<a hidden class=anchor aria-hidden=true href=#write-skew-실무-대책-매핑표>#</a></h4><table><thead><tr><th>개념</th><th>실무에서 무엇을 적용 (무엇)</th><th>어떻게 적용 (방법)</th><th>왜 적용 (비즈니스 이유)</th></tr></thead><tbody><tr><td>SI (스냅샷 격리)</td><td>기본 격리로 사용</td><td>DB 기본값 또는 설정</td><td>읽기 성능 우선, 대부분 충분</td></tr><tr><td>Write Skew</td><td>위험 거래에 대해 보호</td><td>해당 트랜잭션을 Serializable 로 전환 또는 범위락 적용</td><td>무결성·규정 준수 확보</td></tr><tr><td>SSI</td><td>핵심 트랜잭션에 권장</td><td>PostgreSQL 의 SSI 사용 (재시도 처리)</td><td>SI 장점 유지 + 직렬성 보장</td></tr><tr><td>범위 락 (next-key/gap)</td><td>예약·유니크 제약에 적용</td><td>SELECT FOR UPDATE / 인덱스 설계 병행</td><td>과예약·삽입 충돌 차단</td></tr><tr><td>애플리케이션 제약 (버전)</td><td>UI·API 경계에서 검증</td><td>version 컬럼 + UPDATE WHERE version=?</td><td>사용자 think-time 시 실무적 보완</td></tr><tr><td>모니터링/검증</td><td>충돌률·직렬화 실패 측정</td><td>Prometheus/Grafana 지표, Jepsen 스타일 테스트</td><td>정책 결정 근거 제공</td></tr></tbody></table><p>실무에서는 SI 를 기본으로 두되, 비즈니스 영향이 큰 트랜잭션에 대해서만 Serializable/SSI 또는 범위 락을 적용하는 &rsquo; 선택적 엄격화 &rsquo; 전략이 현실적이다. 애플리케이션 레벨 방어와 운영 모니터링은 필수 보완책이다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=write-skew-이해와-실무적-대응>Write Skew 이해와 실무적 대응<a hidden class=anchor aria-hidden=true href=#write-skew-이해와-실무적-대응>#</a></h4><p>두 사람이 같은 규칙을 기준으로 동시에 판단해서 서로 다른 레코드를 바꾸면, 합쳐진 결과가 규칙을 깨는 경우가 있다.<br>예를 들어 " 항상 두 명의 담당자가 있어야 한다 " 는 규칙에서, A 와 B 가 동시에 서로를 대신할 수 있다고 판단해 각자 업무를 내려놓으면 결과적으로 둘 다 없어져 규칙을 위반하게 된다. 이런 현상이 바로 Write Skew 다.<br>방지하려면 DB 의 <strong>직렬화 격리 (Serializable/SSI)</strong> 를 사용하거나, 애플리케이션에서 <strong>명시적 잠금 (SELECT … FOR UPDATE)</strong> 또는 불변식 검증을 원자적으로 수행해야 한다.</p><h5 id=왜-발생하는가>왜 발생하는가<a hidden class=anchor aria-hidden=true href=#왜-발생하는가>#</a></h5><ul><li>MVCC/Snapshot Isolation 에서는 각 트랜잭션이 자신만의 읽기 스냅샷을 가짐.</li><li>T1 과 T2 가 같은 프레디킷 P 를 읽어 " 조건 충족 " 으로 판단 → 각각 서로 다른 행 R1, R2 를 업데이트.</li><li>서로의 업데이트를 보지 못했기 때문에 둘 다 커밋 가능 → 합쳐진 결과 (두 행의 상태 조합) 가 시스템 불변식을 위반할 수 있음.</li></ul><h5 id=간단한-재현-예제-의사-sql-단계별-주석>간단한 재현 예제 (의사 SQL, 단계별 주석)<a hidden class=anchor aria-hidden=true href=#간단한-재현-예제-의사-sql-단계별-주석>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 전제: 테이블 on_call(user_id, oncall boolean)
</span></span></span><span class=line><span class=cl><span class=c1>-- 불변식: 항상 on_call에서 oncall = true 인 사용자가 최소 1명은 존재해야 함
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 트랜잭션 T1 시작
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- T1은 현재 자신(1번)의 oncall 상태를 확인
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>on_call</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>oncall</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>true</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 결과: row exists
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 트랜잭션 T2 거의 동시에 시작
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>on_call</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>oncall</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>true</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 결과: row exists
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- T1: 자신을 off로 변경 (다른 사람이 여전히 on이라고 판단)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>on_call</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>oncall</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>false</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 커밋 성공 (T1은 T2의 변경을 보지 못함)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- T2: 자신을 off로 변경
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>on_call</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>oncall</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>false</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 커밋 성공
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 결과: 모든 oncall이 false가 되어 &#39;최소 1명 on&#39; 불변식 위반
</span></span></span></code></pre></td></tr></table></div></div><ul><li>위는 Snapshot Isolation 환경에서 전형적으로 발생하는 Write Skew 사례다.</li></ul><h5 id=방지-방법>방지 방법<a hidden class=anchor aria-hidden=true href=#방지-방법>#</a></h5><ul><li><p><strong>Serializable / SSI 사용</strong>: DB 가 의존성 (읽기→쓰기 간 의존) 을 탐지해 충돌 시 하나를 Abort → 재시도 유도. 근본적 해결이나 성능·재시도 비용 존재.</p></li><li><p><strong>명시적 락</strong>: 문제 구간에서 <code>SELECT … FOR UPDATE</code> 등으로 관련 행 또는 범위를 잠금 → 다른 트랜잭션의 동시 판단 차단.</p></li><li><p><strong>원자적 불변식 검사·갱신</strong>: 애플리케이션이 불변식 검사와 갱신을 DB 내부 (예: 저장 프로시저) 에서 원자적으로 수행.</p></li><li><p><strong>데이터 모델/제약 강화</strong>: DB 제약 (예: 체크 제약, 트리거, 고유성) 으로 불변식을 강제할 수 있으면 애플리케이션 레벨 위험 감소.</p></li><li><p><strong>혼합 전략</strong>: 핵심 경로는 직렬화, 나머지는 SI + 검증으로 성능과 일관성 균형.</p></li></ul><h5 id=탐지운영-관점>탐지·운영 관점<a hidden class=anchor aria-hidden=true href=#탐지운영-관점>#</a></h5><ul><li><strong>탐지 신호</strong>: 도메인 규칙 위반 알림, 애플리케이션 레벨 검증 실패, 재시도 패턴 이상.</li><li><strong>진단 도구</strong>: 트랜잭션 로그, 직렬화 실패 (예: SQLSTATE 40001) 로그, APM 으로 긴 트랜잭션/동시성 패턴 분석.</li><li><strong>런북 (즉시 대처)</strong>: 문제 트랜잭션 롤백/재시도 유도, 임시로 중요 경로의 격리 수준 올리기, 해당 기능의 트래픽 셰이딩.</li></ul><h4 id=등장-배경-및-발전-과정>등장 배경 및 발전 과정<a hidden class=anchor aria-hidden=true href=#등장-배경-및-발전-과정>#</a></h4><ul><li><p><strong>무엇이 문제인가?</strong><br>두 트랜잭션이 같은 데이터를 <em>읽고</em> 서로 다른 행을 _ 갱신 _ 하면, 충돌 (같은 행을 쓰는 경우) 이 없어 보이지만 결과적으로 데이터 제약이 깨질 수 있다. 이 현상이 <strong>write-skew</strong>다.</p></li><li><p><strong>왜 SI 에서 발생하나?</strong><br>SI 는 각 트랜잭션에 시작 시점 스냅샷을 보여주고, 서로 다른 행을 갱신할 때 쓰기 - 쓰기 충돌이 발생하지 않으면 커밋을 허용한다. 그 결과 스냅샷 기반으로 보았을 때 정합성 제약을 위반할 수 있다.</p></li><li><p><strong>어떤 기술이 해결했나?</strong><br>전통적 락 (2PL) 로 막을 수 있지만 비용이 크다. SI 의 장점은 살리되 write-skew 를 차단하려고 <strong>SSI</strong> 같은 런타임 충돌 검출 기법이 도입되었다.</p></li></ul><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>대규모 OLTP 와 MVCC 기반 DB 의 확산으로 읽기 성능을 중시하는 설계가 보편화되었다.<br>이 과정에서 SI 는 읽기 성능과 일관성의 좋은 절충을 제공했지만, 현실 비즈니스 제약 (예: " 적어도 한 명은 on-call 이어야 한다 &ldquo;) 에서 SI 가 허용하는 특정 병렬 패턴이 제약을 깨뜨리는 사례가 발견되었다.<br>이 문제 (동시성 패턴으로 인한 제약 위반) 가 바로 <strong>write-skew</strong>이며, 이로 인해 SI 의 한계를 보완하는 연구·기술 (SSI 등) 이 촉발되었다.</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>시기 (개념 순서)</th><th>기술/개념</th><th>등장 이유 (문제)</th><th>개선/효과</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>2PL / 전통적 락</td><td>동시 쓰기 충돌·정합성 보장</td><td>직렬성 보장, 락 경합·교착 발생</td></tr><tr><td style=text-align:right>2</td><td>MVCC</td><td>읽기 경합·성능 문제 완화</td><td>읽기 스냅샷 제공, 읽기 성능 향상</td></tr><tr><td style=text-align:right>3</td><td>Snapshot Isolation (SI)</td><td>MVCC 기반 읽기 일관성 강화</td><td>스냅샷 읽기 제공, 동시성↑ (하지만 write-skew 가능)</td></tr><tr><td style=text-align:right>4</td><td>Write-Skew 문제 인식</td><td>SI 하에서 비직렬화 사례 보고</td><td>SI 의 한계 (비즈니스 제약 훼손) 드러남</td></tr><tr><td style=text-align:right>5</td><td>Serializable SI (SSI)</td><td>SI 의 취약점 보완 필요</td><td>런타임 충돌 검출로 직렬성 보장 (일부 트랜잭션 abort)</td></tr><tr><td style=text-align:right>6</td><td>애플리케이션/설계 보완</td><td>모든 트랜잭션 강제 직렬화 비용 회피</td><td>하이브리드 설계 (CQRS, 제약, 샤딩) 적용</td></tr></tbody></table><pre class=mermaid>timeline
    title Write-Skew 등장과 대응 진화
    &#34;2PL / 락 중심&#34; : 1
    &#34;MVCC 도입&#34; : 2
    &#34;Snapshot Isolation (SI)&#34; : 3
    &#34;Write-Skew 문제 인식&#34; : 4
    &#34;Serializable SI / SSI&#34; : 5
    &#34;애플리케이션/설계 보완&#34; : 6
</pre><ul><li>전통적 락 (2PL) 은 write-skew 같은 문제를 막지만 읽기 성능 저하라는 비용이 따라왔다. MVCC 와 SI 는 읽기 성능을 대폭 개선했으나 SI 는 write-skew 를 허용할 수 있어 비즈니스 제약을 손상시킬 소지가 드러났다. 이를 보완하기 위해 **SSI(런타임 충돌 검출)**가 등장했고, 실제 시스템에서는 비용과 효과를 고려해 **DB 수준의 SSI + 애플리케이션 설계 보완 (제약·검증·샤딩)**을 혼용하는 방식이 널리 채택된다. 또한 같은 이름의 격리 수준이라도 <strong>DB 별 구현 차이</strong>를 반드시 검증해야 한다.</li></ul><h4 id=write-skew-문제목적해결>Write Skew 문제·목적·해결<a hidden class=anchor aria-hidden=true href=#write-skew-문제목적해결>#</a></h4><p>Write Skew 는 서로 다른 행을 동시에 업데이트한 두 트랜잭션이 합쳐져 전체 규칙 (불변식) 을 깨는 문제로, 주로 Snapshot Isolation 같은 격리 환경에서 발생한다.</p><ul><li><p><strong>간단 예시 (의료 온콜)</strong>:</p><ul><li>T1: 읽기—의사 A on_call? yes; T2: 읽기—의사 B on_call? yes</li><li>T1: A.on_call = false; 커밋</li><li>T2: B.on_call = false; 커밋 → 결과: 병동에 on_call 담당자 0 명 (불변식 위반).</li></ul></li><li><p><strong>해결 아이디어 (직관)</strong>: 두 트랜잭션이 서로의 판단에 영향을 주지 못하도록 _ 공유 자원에 대한 동시성 제어 _ 를 적용하거나 (락/직렬화), 애플리케이션 단에서 집계를 단일화해 원자적으로 갱신한다.</p></li></ul><h5 id=write-skew-가-유발하는-문제들>Write Skew 가 유발하는 문제들<a hidden class=anchor aria-hidden=true href=#write-skew-가-유발하는-문제들>#</a></h5><table><thead><tr><th>문제 유형</th><th>구체 증상</th><th>비즈니스 영향</th></tr></thead><tbody><tr><td>도메인 불변식 위반</td><td>서로 다른 행 동시 변경 → 전체 제약 (예: 최소 1 명 유지) 위반</td><td>규정 위반, 서비스 중단, 안전사고 가능</td></tr><tr><td>상태 불일치</td><td>트랜잭션 간 상태 판단 불일치 (스냅샷에 의존)</td><td>예측 불가능한 동작, 버그 발생</td></tr><tr><td>탐지 어려움</td><td>각 트랜잭션 자체론 정상 → 문제는 합쳐졌을 때 발생</td><td>디버깅·감사 곤란</td></tr></tbody></table><ul><li>Write Skew 는 &rsquo; 부분적으로 보면 정상 &rsquo; 이지만 전체 규칙엔 치명적인 오류**를 만드는 동시성 결함이다. 특히 안전·규제·금융 같은 도메인에서 즉시 문제로 이어질 수 있어 주의 깊은 설계가 필요하다.</li></ul><h5 id=write-skew-해결의-핵심-목적>Write Skew 해결의 핵심 목적<a hidden class=anchor aria-hidden=true href=#write-skew-해결의-핵심-목적>#</a></h5><table><thead><tr><th>목적</th><th style=text-align:right>구체 목표</th><th>기대 효과</th></tr></thead><tbody><tr><td>도메인 불변식 보장</td><td style=text-align:right>시스템 상태가 불변식 항상 만족하게 함</td><td>안전성·무결성 확보</td></tr><tr><td>합성 동작 신뢰도 향상</td><td style=text-align:right>다중 트랜잭션 합성 결과 예측 가능</td><td>오류·사후 처리 비용 감소</td></tr><tr><td>운영·감사 용이성</td><td style=text-align:right>이상상황 희소화로 디버깅 용이</td><td>규정 준수·감사 준비성 강화</td></tr></tbody></table><ul><li>핵심: 목적은 단순히 오류를 줄이는 게 아니라 <strong>시스템 레벨에서 규칙 (불변식) 을 항상 지키게 만들어 비즈니스 신뢰성을 확보하는 것</strong>이다.</li></ul><h5 id=문제와-목적의-연계-write-skew>문제와 목적의 연계 (Write Skew)<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연계-write-skew>#</a></h5><table><thead><tr><th>문제 (증상)</th><th>대응 목적</th><th>연계 방식</th></tr></thead><tbody><tr><td>도메인 불변식 위반</td><td>도메인 불변식 보장</td><td>트랜잭션 수준 충돌 차단 또는 불변식 단일화</td></tr><tr><td>상태 불일치</td><td>합성 동작 신뢰도 향상</td><td>읽기/쓰기 가시성 조정 (격리 수준/락)</td></tr><tr><td>탐지 어려움</td><td>운영·감사 용이성</td><td>실패 시 재시도·로그·경보 체계 구축</td></tr></tbody></table><ul><li>핵심 연결: 각 문제는 <strong>불변식 보장·가시성 제어·운영 지원</strong>이라는 목적에 직접적으로 매핑된다. 해결책은 문제 유형에 맞춘 기술 (격리·락·애플리케이션 설계) 과 운영 정책 (재시도·모니터링) 을 조합하는 것이다.</li></ul><h4 id=write-skew-발생요건과-확인-체크리스트>Write Skew 발생요건과 확인 체크리스트<a hidden class=anchor aria-hidden=true href=#write-skew-발생요건과-확인-체크리스트>#</a></h4><ul><li><p><strong>무슨 문제인가?</strong><br>두 트랜잭션이 같은 _ 읽기 결과 _ 를 기반으로 서로 다른 행을 수정하면, 최종 상태가 시스템의 규칙 (불변식) 을 깨는 현상이 생길 수 있다. 이 현상이 바로 <strong>Write Skew</strong>다.</p></li><li><p><strong>언제 발생하나? (체크리스트)</strong></p><ol><li>DB 가 MVCC/Snapshot 기반 (스냅샷 읽기) 을 사용한다.</li><li>불변식이 여러 행/범위에 걸쳐 정의되어 있다.</li><li>동시 트랜잭션들이 같은 읽기 집합을 읽고 서로 다른 행을 쓴다 (WW 충돌 없음).</li><li>격리 수준이 <code>SERIALIZABLE</code> 이 아니거나 SI 만 적용되어 있는 경우.</li></ol></li><li><p><strong>가장 쉬운 예:</strong> 두 의사가 각각 다른 레코드를 지워서 결국 아무도 남지 않는 상황 (Doctors on-call 예).</p></li><li><p><strong>단기·실무적 대처:</strong> 애플리케이션 수준에서 검증 및 재시도, <code>SELECT FOR UPDATE</code> 또는 의도적 업데이트 (충돌 물질화) 사용. 장기적으로는 <code>SERIALIZABLE</code>/SSI 도입 검토.</p></li></ul><h5 id=write-skew-발생-전제요구조건-체크표>Write Skew 발생 전제·요구조건 체크표<a hidden class=anchor aria-hidden=true href=#write-skew-발생-전제요구조건-체크표>#</a></h5><table><thead><tr><th>항목</th><th style=text-align:right>요구사항 (명세)</th><th>왜 필요한가 (핵심 이유)</th><th>검증 방법 / 지표</th></tr></thead><tbody><tr><td>실행 모델</td><td style=text-align:right>MVCC / Snapshot Isolation 또는 비잠금 읽기 환경</td><td>스냅샷 읽기로 다른 트랜잭션의 중간 쓰기를 보지 못함.</td><td>DB 문서 확인 (<code>SHOW transaction_isolation</code> 등).</td></tr><tr><td>불변식 형태</td><td style=text-align:right>불변식이 <strong>여러 행/범위</strong>에 걸쳐 표현됨 (조합적 제약)</td><td>조합적 제약은 단일 행 잠금으로는 보장 불가.</td><td>비즈니스 규칙 분석 (제약 SQL/유즈케이스 확인).</td></tr><tr><td>동시성 패턴</td><td style=text-align:right>여러 트랜잭션이 <strong>동시에</strong> 동일한 읽기 집합을 읽음</td><td>읽기 기반 의사결정이 서로를 인지하지 못하는 상황 생성.</td><td>부하/동시성 로그, 트랜잭션 타임라인.</td></tr><tr><td>쓰기 충돌</td><td style=text-align:right>각 트랜잭션의 쓰기 집합이 서로 <strong>서로 다른 행</strong>(WW 충돌 없음)</td><td>WW 충돌이 없으면 DB 가 둘 다 커밋시키고 write-skew 발생 가능.</td><td>쓰기 대상 분석, EXPLAIN/트랜잭션 로그.</td></tr><tr><td>격리 수준</td><td style=text-align:right>격리 수준이 <code>SERIALIZABLE</code> 보다 약함 (예: SI/REPEATABLE READ 등)</td><td><code>SERIALIZABLE</code> 이면 이 클래스의 이상을 방지하거나 탐지 가능.</td><td>격리설정 확인 및 SSI 여부 점검.</td></tr></tbody></table><p>Write Skew 가 발생하려면</p><ol><li>MVCC/Snapshot 기반 읽기 모델이면서</li><li>불변식이 여러 행/범위에 걸쳐 정의되어 있고</li><li>동시 트랜잭션들이 같은 읽기 집합을 읽은 뒤 서로 다른 행을 수정 (즉, WW 충돌이 없을 때) 해야 하며,</li><li>격리 수준이 완전한 직렬성을 보장하지 않을 때 발생 가능성이 높다.<br>위 항목을 하나하나 점검하면 write-skew 취약성을 판단할 수 있다.</li></ol><h4 id=write-skew-원인특징실무-대응>Write Skew: 원인·특징·실무 대응<a hidden class=anchor aria-hidden=true href=#write-skew-원인특징실무-대응>#</a></h4><p>Write Skew 는 서로 다른 행을 동시에 바꾸는 두 트랜잭션이 함께 실행될 때, 각각은 정당해도 합치면 전체 규칙 (예: 최소 인원 유지) 을 깨는 문제다.<br>스냅샷 격리 (SI) 는 이런 상황에서 종종 탐지하지 못한다. 해결하려면 직렬성 보장 (Serializable/SSI) 을 쓰거나, 중요한 읽기 집합을 잠그거나, 커밋 전에 규칙을 다시 확인해 실패 시 재시도하는 패턴을 적용한다.</p><h5 id=write-skew-특징근거차별표>Write Skew 특징·근거·차별표<a hidden class=anchor aria-hidden=true href=#write-skew-특징근거차별표>#</a></h5><table><thead><tr><th>핵심 특징</th><th>기술적 근거</th><th>다른 동시성 이상과의 차별점</th><th>실무적 의미 (대응 포인트)</th></tr></thead><tbody><tr><td>발생 조건: 다른 행 동시 갱신</td><td>MVCC 스냅샷 + WW 검사만 수행</td><td>Lost Update/Dirty Write 는 동일 행 충돌</td><td>중요 불변식 관련 트랜잭션 식별</td></tr><tr><td>직렬성 위반 (비가시적)</td><td>의존성 그래프에서 read–write 로 사이클 생성</td><td>Phantom 은 범위 변화 연계, Write Skew 는 불변식 초점</td><td>자동화된 동시성 테스트 필요</td></tr><tr><td>탐지 어려움</td><td>WW 가 없어 SI 검사 누락</td><td>버전비교/WW 기반 검사로는 탐지 불가</td><td>Serializable/SSI 또는 읽은 집합 잠금 권장</td></tr><tr><td>대응의 비용 - 효과 트레이드오프</td><td>SSI(오버헤드), FOR UPDATE(락 경합), 제약 (단순화)</td><td>다른 이상보다 복합적 대응 요구</td><td>우선순위: DB 제약 → 잠금 → 격리상향 순 적용</td></tr></tbody></table><p>Write Skew 는 SI 환경에서 특히 주의해야 할 동시성 이상으로, 탐지·예방이 단순 충돌 검사로는 어렵다. 실무에서는 불변식 관련 트랜잭션을 식별해 우선적으로 DB 제약이나 읽은 집합 잠금으로 보호하되, 필요한 경우 Serializable/SSI 전환을 검토해 전체 무결성을 확보한다. 각 선택은 성능·운영 비용을 동반하므로 테스트로 트레이드오프를 확인해야 한다.</p><h3 id=phase-2-핵심-원리-및-이론적-기반>Phase 2: 핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#phase-2-핵심-원리-및-이론적-기반>#</a></h3><h4 id=write-skew-대응-원칙과-설계-전략>Write Skew 대응 원칙과 설계 전략<a hidden class=anchor aria-hidden=true href=#write-skew-대응-원칙과-설계-전략>#</a></h4><p>Write Skew 는 트랜잭션 A 와 B 가 같은 판단 근거 (읽기 결과) 를 보고 각자 다른 레코드를 수정했을 때 발생하는 일관성 위반 현상이다.<br>SI 는 읽기는 스냅샷에서 빠르게 처리하고, <strong>같은 행을 동시에 쓸 때만 충돌</strong>을 막기 때문에 이런 시나리오가 가능하다.<br>해결책은</p><ol><li>DB 가 직렬성 보장 (SSI/Serializable) 하도록 설정하거나</li><li>중요한 판단 구간에 **명시적 잠금 (SELECT FOR UPDATE)**을 거는 것</li><li>스키마/애플리케이션 레벨로 제약을 물질화 (guard row/집계 테이블) 하거나</li><li>재시도·모니터링 정책을 운영하는 것이다.</li></ol><p>실무에서는 비용·성능을 고려해 핵심 트랜잭션에만 강한 제어를 적용하는 전략이 일반적이다.</p><h5 id=write-skew-핵심-원칙-요약표>Write Skew 핵심 원칙 요약표<a hidden class=anchor aria-hidden=true href=#write-skew-핵심-원칙-요약표>#</a></h5><table><thead><tr><th>핵심 원칙</th><th style=text-align:right>설명</th><th>목적</th><th>왜 필요한가</th></tr></thead><tbody><tr><td>SI: 스냅샷 읽기 + WW 검사</td><td style=text-align:right>트랜잭션은 시작 스냅샷을 읽고, 동일 튜플 동시 쓰기만 충돌로 처리.</td><td>읽기 성능 극대화</td><td>높은 동시성 환경에서 락 경합 최소화 필요</td></tr><tr><td>Write Skew 조건</td><td style=text-align:right>동일 상태 읽기 → 서로 다른 객체 쓰기 → 전체 불변식 위배.</td><td>이상 현상 식별</td><td>SI 의 WW 전제 때문에 발생 가능</td></tr><tr><td>직렬화 (Serializable/SSI)</td><td style=text-align:right>반의존성 추적 후 직렬성 위반 시 abort</td><td>근본적 예방</td><td>SI 로는 잡히지 않는 패턴 제거</td></tr><tr><td>충돌 물질화 (guard row)</td><td style=text-align:right>논리 제약을 실제 쓰기로 표현</td><td>DB 충돌 검사 활용</td><td>SI 의 한계 보완, 단순·효과적</td></tr></tbody></table><p>핵심 원칙은 **SI 의 설계 (스냅샷 +WW 검사)**와 그로 인해 생기는 <strong>write-skew 조건</strong>을 이해하는 데 초점이 있다. 예방은 DB 수준 (직렬성 보장), 스키마 보강 (충돌 물질화), 애플리케이션 수준 (명시적 락/재시도) 으로 나뉘며, 실무는 성능 비용을 고려해 선택적으로 적용한다.</p><h5 id=write-skew-대응-설계-철학-요약>Write Skew 대응 설계 철학 요약<a hidden class=anchor aria-hidden=true href=#write-skew-대응-설계-철학-요약>#</a></h5><table><thead><tr><th>설계 철학</th><th style=text-align:right>핵심 아이디어</th><th>적용 목적</th><th>고려사항</th></tr></thead><tbody><tr><td>선택적 강화</td><td style=text-align:right>핵심 트랜잭션만 Serializable 적용</td><td>비용 절감 + 정합성 보장</td><td>분류 정확성·테스트 필요</td></tr><tr><td>충돌 물질화</td><td style=text-align:right>가드 행/집계 업데이트로 충돌 유도</td><td>SI 환경에서 안전성 확보</td><td>정규화 위배·운영 복잡성</td></tr><tr><td>애플리케이션 락 & 재시도</td><td style=text-align:right>FOR UPDATE/분산 락·재시도 정책</td><td>외부 사이드이펙트 포함 작업 보호</td><td>재시도 안전성 (idempotency) 확보 필요</td></tr></tbody></table><p>설계 철학은 " 전부를 포기하지 않되, 중요한 것만 강하게 지킨다 " 는 실무적 균형을 표현한다. 각 방식은 장단이 뚜렷하므로 워크로드·제약·운영문화에 맞춰 조합 적용해야 최적의 결과를 얻는다.</p><h4 id=write-skew-작동원리와-방지전략>Write Skew 작동원리와 방지전략<a hidden class=anchor aria-hidden=true href=#write-skew-작동원리와-방지전략>#</a></h4><p>Write Skew 는 두 사용자가 같은 기준으로 " 괜찮다 " 고 판단한 뒤 각각 다른 데이터를 바꿔서, 최종적으로 전체 규칙이 깨지는 상황이다. 예: 병동에 on_call 담당자가 1 명인데 A 와 B 가 각각 자신을 off 로 바꾸면 결과적으로 0 명이 된다. Snapshot Isolation 은 보통 이 상황을 막지 못하니, 중요한 규칙이 있다면 범위 잠금이나 직렬화 (Serializable/SSI) 를 적용하거나 애플리케이션에서 버전 검증·재시도를 구현해야 한다.</p><h5 id=쓰기스큐-동작-원리와-메커니즘>쓰기스큐 동작 원리와 메커니즘<a hidden class=anchor aria-hidden=true href=#쓰기스큐-동작-원리와-메커니즘>#</a></h5><h6 id=핵심-메커니즘-순서-기준>핵심 메커니즘 (순서 기준)<a hidden class=anchor aria-hidden=true href=#핵심-메커니즘-순서-기준>#</a></h6><ol><li>트랜잭션 A/B 가 동일 조건의 쿼리 (SELECT) 를 <strong>각자 스냅샷</strong>에서 수행해 같은 판정 (예: 참가자 수 = 1) 을 얻음.</li><li>각 트랜잭션은 <strong>서로 다른 row(또는 객체)</strong> 를 업데이트 (또는 삭제) 함—WW 충돌은 없음.</li><li>트랜잭션들이 독립적으로 커밋되면, 시스템 전체에선 <strong>전역 제약 (invariant)</strong> 이 깨지게 됨 (예: 온콜 담당자 수 = 0).</li><li>발생 이유는 SI/Repeatable Read 에서 <strong>RW 반의존성</strong>(read→other write) 경로가 허용되어 <strong>직렬성 그래프에 RW 엣지들이 사이클을 형성</strong>할 수 있기 때문.</li></ol><h6 id=방지-옵션-요약>방지 옵션 (요약)<a hidden class=anchor aria-hidden=true href=#방지-옵션-요약>#</a></h6><ul><li><strong>직렬 가능성 확보 (Serializable)</strong>: 모든 이상을 차단하지만 비용 큼.</li><li><strong>SSI (Serializable Snapshot Isolation)</strong>: SI 기반에서 위험 구조를 런타임 탐지·차단해 재시도 유도.</li><li><strong>범위 락 (Next-Key / Predicate / SELECT FOR UPDATE)</strong>: 조건 단위를 잠가 삽입/삭제로 인한 변화 방지.</li><li><strong>애플리케이션 레벨 검증 (버전·제약)</strong>: 사용자 think-time 포함 시 실무적 보완.</li></ul><h5 id=write-skew-동작요약-표>Write Skew 동작요약 표<a hidden class=anchor aria-hidden=true href=#write-skew-동작요약-표>#</a></h5><table><thead><tr><th>단계</th><th>동작</th><th style=text-align:right>핵심 기술적 포인트</th><th>왜 문제가 되는가</th></tr></thead><tbody><tr><td>1</td><td>동일 조건 SELECT</td><td style=text-align:right>스냅샷 (SI/MVCC) 기반 읽기</td><td>각 트랜잭션이 같은 판단을 함</td></tr><tr><td>2</td><td>서로 다른 row 에 WRITE</td><td style=text-align:right>WW 는 거부되지만 RW 는 허용될 수 있음</td><td>서로 다른 행 쓰기여도 전역 규칙 위반 가능</td></tr><tr><td>3</td><td>동시 COMMIT</td><td style=text-align:right>커밋 시점에 최종 상태 확정</td><td>최종 상태가 불변식 위반으로 귀결</td></tr><tr><td>4</td><td>결과</td><td style=text-align:right>전역 비즈니스 규칙 (제약) 위반</td><td>심각한 비즈니스 오류 초래</td></tr></tbody></table><p>쓰기 스큐는 " 같은 판단 근거 " 를 읽고 서로 다른 객체를 변경하는 패턴에서 발생한다. 핵심은 WW 충돌만 차단하는 SI 가 RW 에 의한 논리적 위반을 허용할 수 있다는 점이며, 이를 막으려면 조건 단위를 보호하거나 직렬화를 보장해야 한다.</p><h5 id=쓰기스큐-흐름도>쓰기스큐 흐름도<a hidden class=anchor aria-hidden=true href=#쓰기스큐-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  Start([시작]) --&gt; T1_BEGIN[&#34;T1: BEGIN (SI)&#34;]
  Start --&gt; T2_BEGIN[&#34;T2: BEGIN (SI)&#34;]

  T1_BEGIN --&gt; T1_SELECT[T1: SELECT count WHERE predicate -&gt; v]
  T2_BEGIN --&gt; T2_SELECT[T2: SELECT count WHERE predicate -&gt; v]

  T1_SELECT --&gt; T1_DECIDE[&#34;T1: 판단 (조건 충족?) -&gt; 예&#34;]
  T2_SELECT --&gt; T2_DECIDE[&#34;T2: 판단 (조건 충족?) -&gt; 예&#34;]

  T1_DECIDE --&gt; T1_WRITE[T1: UPDATE/DELETE 다른 row]
  T2_DECIDE --&gt; T2_WRITE[T2: UPDATE/DELETE 다른 row]

  T1_WRITE --&gt; DB_OK1[&#34;DB: 쓰기 OK (WW 없음)&#34;]
  T2_WRITE --&gt; DB_OK2[&#34;DB: 쓰기 OK (WW 없음)&#34;]

  DB_OK1 --&gt; T1_COMMIT[T1: COMMIT]
  DB_OK2 --&gt; T2_COMMIT[T2: COMMIT]

  T1_COMMIT --&gt; FinalCheck[DB: 최종제약 검증]
  T2_COMMIT --&gt; FinalCheck

  FinalCheck --&gt; Violation{제약 위반?}
  Violation -- Yes --&gt; InvariantBroken[&#34;결과: 불변식 위반 (Write Skew 발생)&#34;]
  Violation -- No --&gt; OK[결과: 무결성 유지]

  %% 방지 지점(검사/대응)
  subgraph Mitigations [방지/완화 지점]
    M1[&#34;선택지: SELECT … FOR UPDATE(범위락)&#34;] 
    M2[선택지: SERIALIZABLE / SSI]
    M3[선택지: 애플리케이션 버전검사 + UPDATE WHERE version=?]
  end

  T1_SELECT -.-&gt; M1
  T2_SELECT -.-&gt; M1
  T1_SELECT -.-&gt; M3
  T2_SELECT -.-&gt; M3
  T1_COMMIT -.-&gt; M2
  T2_COMMIT -.-&gt; M2
</pre><p>위 흐름도는 쓰기 스큐의 전형적 시나리오를 단계별로 보여준다.<br>핵심은 트랜잭션이 같은 predicate 를 읽고 (스냅샷 기반) 서로 다른 대상에 쓰기를 한 뒤 동시 커밋하면 전역 불변식이 깨지는 지점이다.<br>방지 옵션은 세 가지 주요 지점에서 개입한다:</p><ol><li>SELECT 직후 범위락 (<code>SELECT … FOR UPDATE</code>) 로 조건을 보호</li><li>커밋 단계에서 Serializable/SSI 로 위험 구조를 검출해 재시도 유도</li><li>애플리케이션 레벨에서 버전검사 (UPDATE WHERE version=?) 로 충돌을 탐지하고 재시도한다.</li></ol><p>실무에서는 이들을 혼합해 &rsquo; 성능 - 무결성 &rsquo; 의 균형을 맞춘다. 또한 운영상 충돌률·재시도 통계를 수집해 정책 (예: 일시적 격리 상향, 샤드 리밸런싱) 을 동적으로 적용하는 것이 권장된다.</p><h4 id=write-skew-흐름생명주기탐지>Write Skew 흐름·생명주기·탐지<a hidden class=anchor aria-hidden=true href=#write-skew-흐름생명주기탐지>#</a></h4><p>트랜잭션 A 와 B 가 같은 규칙을 보고 각각 다른 레코드를 수정하면, 서로의 변경을 보지 못한 채 둘 다 커밋해 <strong>합쳐진 결과가 규칙을 깨는 경우</strong>가 생긴다.<br>핵심은 _ 읽기 시점의 스냅샷 가시성 _ 과 _ 커밋 시 검사 범위 _ 가 불일치한다는 점이다.<br>이를 막으려면 DB 의 직렬화 또는 명시적 잠금, 또는 불변식을 원자적으로 검사·갱신하는 설계가 필요하다.</p><h5 id=write-skew-생명주기-흐름>Write Skew 생명주기 흐름<a hidden class=anchor aria-hidden=true href=#write-skew-생명주기-흐름>#</a></h5><ol><li><p><strong>트랜잭션 시작 (Start)</strong></p><ul><li>트랜잭션이 시작되고, MVCC 환경이면 읽기 스냅샷이 고정된다.</li><li>타이밍: 스냅샷은 일반적으로 트랜잭션 시작 시점 (또는 첫 읽기 시점) 에 결정된다.</li></ul></li><li><p><strong>읽기·검증 (Read & Validate)</strong></p><ul><li>동일한 Predicate(예: <code>currentParticipants &lt; maxParticipants</code>) 을 읽음.</li><li>판단은 스냅샷 기준으로 이루어짐 (다른 트랜잭션의 미커밋/커밋된 변경을 보지 못할 수 있음).</li></ul></li><li><p><strong>업데이트 (Update)</strong></p><ul><li>T1 은 행 R1 을, T2 는 행 R2 를 업데이트 (서로 다른 행).</li><li>변경 내용은 각자의 쓰기 버퍼에 저장 (커밋 전까지 다른 트랜잭션에 보이지 않음).</li></ul></li><li><p><strong>커밋 (Commit)</strong></p><ul><li>DB 는 보통 WW 충돌 (동일 행에 대한 동시 쓰기) 만 검사하거나 격리 정책에 따라 추가 검사.</li><li>두 트랜잭션이 서로 다른 행을 썼다면 둘 다 커밋될 가능성이 높음.</li></ul></li><li><p><strong>합성 상태 (Composite State) 노출</strong></p><ul><li>커밋 후의 전체 상태가 비즈니스 불변식을 위반하면 Write Skew 발생.</li><li>문제는 단일 트랜잭션의 관점에서는 정당하지만 <strong>전체 관점에서 불일치</strong>가 발생하는 것.</li></ul></li></ol><h5 id=write-skew-단계별-제어데이터-흐름표>Write Skew 단계별 제어·데이터 흐름표<a hidden class=anchor aria-hidden=true href=#write-skew-단계별-제어데이터-흐름표>#</a></h5><table><thead><tr><th>단계</th><th style=text-align:right>동작 (데이터 흐름)</th><th>제어 포인트 (검증·잠금)</th><th style=text-align:right>발생 위험</th><th style=text-align:right>운영적 체크</th></tr></thead><tbody><tr><td>Start</td><td style=text-align:right>트랜잭션 시작 → 스냅샷 고정</td><td>트랜잭션 시작 시점</td><td style=text-align:right>스냅샷 시점 불일치</td><td style=text-align:right>트랜잭션 시작 로그</td></tr><tr><td>Read & Validate</td><td style=text-align:right>Predicate 기준 읽기 (스냅샷)</td><td>애플리케이션 불변식 검사 (스냅샷 기준)</td><td style=text-align:right>잘못된 &lsquo;OK&rsquo; 판단</td><td style=text-align:right>동시 요청 패턴 모니터링</td></tr><tr><td>Update</td><td style=text-align:right>서로 다른 행 업데이트 (쓰기 버퍼)</td><td>(보통 잠금 없음)</td><td style=text-align:right>서로의 변경 미가시성</td><td style=text-align:right>쓰기 패턴·대상 분포 분석</td></tr><tr><td>Commit</td><td style=text-align:right>DB 가 충돌 검사 (주로 WW) → 커밋</td><td>격리 정책별 충돌 검증</td><td style=text-align:right>합성 불변식 위반 노출</td><td style=text-align:right>직렬화 실패/불변식 알람</td></tr><tr><td>Post-Commit</td><td style=text-align:right>합성 상태로 불변식 위반 확인</td><td>애플리케이션·감시 시스템</td><td style=text-align:right>비즈니스 규칙 위반</td><td style=text-align:right>자동 롤백 불가 → 수동 대응/패치</td></tr></tbody></table><p>핵심: **스냅샷 시점 (읽기 기준)**과 <strong>커밋 시 충돌 검사 범위</strong>가 달라 발생한다. 탐지 포인트는 동시 읽기 패턴, 특정 API 의 동시 호출, 커밋 시점의 불변식 위반 로그다. 운영에서는 트랜잭션 길이·동시성 패턴·직렬화 실패 및 애플리케이션 레벨 불일치 알람을 주의 깊게 모니터링해야 한다.</p><h5 id=write-skew-기본-흐름도>Write Skew 기본 흐름도<a hidden class=anchor aria-hidden=true href=#write-skew-기본-흐름도>#</a></h5><pre class=mermaid>sequenceDiagram
    participant T1 as 트랜잭션 T1
    participant T2 as 트랜잭션 T2
    participant DB as 데이터베이스

    T1-&gt;&gt;DB: BEGIN (스냅샷 고정)
    T2-&gt;&gt;DB: BEGIN (스냅샷 고정)
    T1-&gt;&gt;DB: SELECT predicate (스냅샷 기준) -&gt; OK
    T2-&gt;&gt;DB: SELECT predicate (스냅샷 기준) -&gt; OK
    T1-&gt;&gt;DB: UPDATE row R1 (쓰기 버퍼)
    T2-&gt;&gt;DB: UPDATE row R2 (쓰기 버퍼)
    T1-&gt;&gt;DB: COMMIT
    DB--&gt;&gt;T1: COMMIT 성공
    T2-&gt;&gt;DB: COMMIT
    DB--&gt;&gt;T2: COMMIT 성공
    DB--&gt;&gt;All: 결과 상태 불변식 위반 -&gt; Write Skew 발생
</pre><p>위 순서도는 MVCC/Snapshot 환경에서 전형적인 Write Skew 발생 경로를 보여준다. 핵심은 두 트랜잭션이 동일한 판단 (스냅샷 기준) 을 내리고 서로 다른 행을 수정한 뒤 둘 다 커밋되어 <strong>합쳐진 결과가 규칙을 깨는 것</strong>이다. 흐름도 개선 시점은 스냅샷 확정 타이밍, 격리 수준 분기 (Abort 가능성), 그리고 명시적 락 도입 지점이다.</p><h5 id=write-skew-생명주기-상태도>Write Skew 생명주기 상태도<a hidden class=anchor aria-hidden=true href=#write-skew-생명주기-상태도>#</a></h5><pre class=mermaid>stateDiagram-v2
    [*] --&gt; Started: 트랜잭션 시작\n(스냅샷 고정)
    Started --&gt; ReadValidate: Predicate 읽기/검증
    ReadValidate --&gt; Update: 행 업데이트
    Update --&gt; CommitAttempt: 커밋 시도
    CommitAttempt --&gt; Committed: 커밋 성공
    CommitAttempt --&gt; Aborted: 충돌 탐지 → Abort (Serializable/SSI)
    Committed --&gt; PostState: 합성 상태 노출
    PostState --&gt; [*]: 정합성 확인 / 운영 알람
</pre><p>생명주기 다이어그램은 트랜잭션 상태 전이를 중심으로 Write Skew 의 가능 지점을 보여준다. 핵심은 CommitAttempt 에서의 분기 (Committed vs Aborted) 이며, Abort 는 직렬화 보장 메커니즘에서 발생해 재시도 로직을 요구한다. PostState 에서의 운영 감시와 회복 루프는 실제 서비스 안정성 확보에 필수적이다.</p><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=write-skew-방지-이점현실적-선택>Write-Skew 방지: 이점·현실적 선택<a hidden class=anchor aria-hidden=true href=#write-skew-방지-이점현실적-선택>#</a></h4><ul><li><p><strong>핵심 요지</strong>:<br>동시성을 높이면 성능이 좋아지지만 일부 상황에서는 <code>write-skew</code> 같은 보이지 않는 오류가 생긴다.</p></li><li><p><strong>무엇을 얻나</strong>:<br>MVCC/SI 같은 기법으로 읽기 성능과 동시성을 크게 올릴 수 있다.</p></li><li><p><strong>무엇을 더해야 안전한가</strong>:<br>SSI(런타임 검출), 범위락, DB 제약, 애플리케이션 락 같은 보완으로 중요한 비즈니스 규칙을 지켜야 한다.</p></li><li><p><strong>실무 규칙 (간단)</strong>:<br>성능 우선이면 낙관적 접근 (SI) + 모니터링, 정합성 우선이면 강한 격리 (SSI/2PL/제약).</p></li></ul><h5 id=write-skew-대응-기법의-장점-한눈표>Write-Skew 대응 기법의 장점 한눈표<a hidden class=anchor aria-hidden=true href=#write-skew-대응-기법의-장점-한눈표>#</a></h5><table><thead><tr><th>장점</th><th style=text-align:right>기술 근거 (Why)</th><th>실무 효과 (So what)</th><th>적용 조건 / 예시</th></tr></thead><tbody><tr><td>동시성 향상 (MVCC/SI)</td><td style=text-align:right>스냅샷 읽기로 읽기 - 쓰기 경합 회피</td><td>읽기 많은 서비스에서 처리량·응답성 개선</td><td>읽기 우선 시스템, 통계·로그 집계</td></tr><tr><td>성능 최적화 (낮은 격리)</td><td style=text-align:right>락 최소화로 짧은 트랜잭션 유지</td><td>P99·TPS 개선, 인프라 효율성</td><td>낮은 정합성 요구, 캐주얼 데이터</td></tr><tr><td>개발 유연성</td><td style=text-align:right>격리 수준/명시적 락 선택으로 정책화 가능</td><td>빠른 기능 출시·도메인별 처리</td><td>다양한 도메인 요구 공존</td></tr><tr><td>SSI (직렬성 보장)</td><td style=text-align:right>런타임 의존성 그래프 검출로 위험 패턴 차단</td><td>SI 성능 확보 + 정합성 보장 (일부 abort)</td><td>핵심 금융 트랜잭션 (부분 적용 권장)</td></tr><tr><td>2PL / 범위락</td><td style=text-align:right>predicate/next-key lock 으로 범위 변경 차단</td><td>팬텀/Write-Skew 예방, 예측 가능성↑</td><td>고정 규칙·작업 범위가 명확한 도메인</td></tr><tr><td>스키마 제약 · 집계 행</td><td style=text-align:right>DB 가 불변식 원자적으로 보장</td><td>애플리케이션 오류 감소, 무결성 강화</td><td>불변식이 DB 수준으로 표현 가능한 경우</td></tr><tr><td>애플리케이션 락</td><td style=text-align:right>도메인 키 기반 락 (Advisory)</td><td>핫스팟만 보호·점진적 도입 가능</td><td>분산·마이크로서비스 환경</td></tr></tbody></table><ul><li><p><strong>요약</strong>: 성능 향상 (동시성) 은 MVCC/SI 가 주로 담당하고, 정합성 확보는 SSI·범위락·DB 제약·애플리케이션 락으로 보완한다.</p></li><li><p><strong>실무 권장 패턴</strong>: 대부분 시스템은 <strong>혼합 전략</strong>(일반 작업은 SI/낙관적, 핵심 트랜잭션은 SSI/범위락 또는 DB 제약) 으로 운영한다. 적용 전에는 충돌률·핫스팟·비즈니스 민감도를 계량화해 정책을 정하라.</p></li></ul><h4 id=write-skew-의-한계와-실무적-완화책>Write Skew 의 한계와 실무적 완화책<a hidden class=anchor aria-hidden=true href=#write-skew-의-한계와-실무적-완화책>#</a></h4><p>Write Skew 를 막으려면 _ 일관성 확보 수단 _ 을 도입해야 하는데, 그 수단들은 보통 <strong>성능 저하·운영 복잡성·확장성 제약</strong>을 함께 가져온다.</p><p>강한 일관성 (Serializable/범위 락) 은 안전하지만 느리고, 느슨한 일관성 (SI/낙관적) 은 빠르지만 write skew 가 생길 수 있다. 실무에서는 * 비용 (성능)* 과 * 리스크 (무결성)* 를 저울질해 <strong>부분 적용</strong> 또는 <strong>애플리케이션 레벨 보완</strong>을 사용한다.</p><h5 id=write-skew-의-주요-단점-표>Write Skew 의 주요 단점 표<a hidden class=anchor aria-hidden=true href=#write-skew-의-주요-단점-표>#</a></h5><table><thead><tr><th>단점</th><th>설명</th><th>원인</th><th>실무 영향</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>재시도 비용 (SSI)</td><td>충돌 시 트랜잭션 롤백 (예: SQLSTATE 40001)</td><td>직렬화/충돌 탐지 메커니즘</td><td>지연·재시도 폭주·자원 낭비</td><td>지수 백오프, 멱등 설계, 재시도 한계</td><td>2PL, 애플리케이션 집계</td></tr><tr><td>락 경합 (2PL)</td><td>강한 락으로 동시성 저하·데드락</td><td>장기간 락 보유, 넓은 범위 잠금</td><td>Throughput 저하·타임아웃</td><td>인덱스 최적화, 트랜잭션 단축, 락 순서 규약</td><td>SSI(부분 보완)</td></tr><tr><td>제약 복잡성</td><td>복잡 불변식으로 운영·유지보수 부담</td><td>복합 도메인 규칙</td><td>코드·DB 동기화 문제, 버그 증가</td><td>불변식 단순화, 설계 가이드, 테스트 강화</td><td>SSI(자동 보호 일부)</td></tr><tr><td>분산 확장성 한계</td><td>샤딩된 환경에서 전역 불변식 유지 어려움</td><td>데이터 분산·파티션</td><td>전역 트랜잭션 필요, 높은 지연</td><td>파티션 재설계, Sagas, 합의 스토어</td><td>Spanner/Calvin, 이벤트 소싱</td></tr></tbody></table><ul><li>핵심: 단점은 _ 일관성을 위해 투입한 비용 _ 이 곧 발생하는 문제들 (지연·대기·복잡도) 이다. 완화는 기술적 (백오프, 인덱스, 재설계)·운영적 (재시도 정책, 테스트) 조합으로 수행해야 효과적이다.</li></ul><h5 id=환경-기반-제약사항-표>환경 기반 제약사항 표<a hidden class=anchor aria-hidden=true href=#환경-기반-제약사항-표>#</a></h5><table><thead><tr><th>제약사항</th><th>설명</th><th>원인</th><th>영향</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>ORM 기본 설정</td><td>Lazy load·비잠금 읽기 기본값 노출</td><td>프레임워크 편의성</td><td>Write Skew 노출, 트랜잭션 오용</td><td>트랜잭션 경계 명확화, 락 힌트, 명시적 SQL</td><td>명시 SQL/Stored Proc</td></tr><tr><td>인덱스 부재</td><td>범위 잠금 비효율·스캔 증가</td><td>설계 미비</td><td>잠금 범위 확대·성능 저하</td><td>복합 인덱스, 통계 갱신</td><td>SSI(일부 보완)</td></tr><tr><td>격리 수준 선택 한계</td><td>Serializable 은 성능 저하 유발</td><td>성능·일관성 트레이드오프</td><td>처리량 감소·재시도 증가</td><td>선택적 직렬화, 하이브리드 전략</td><td>분산 일관성 DB</td></tr><tr><td>샤딩/마이크로서비스</td><td>전역 불변식 구현 난해</td><td>데이터 분산</td><td>전역 락/2PC 필요, 지연</td><td>파티션 재설계, Sagas</td><td>글로벌 일관성 DB</td></tr></tbody></table><ul><li>핵심: 제약사항은 환경 (도구·구조) 이 제공하는 한계로 인해 특정 해법 적용이 어렵게 만든다. 이를 해결하려면 **설계 (인덱스·파티셔닝) 와 운영 (트랜잭션 경계·ORM 설정)**을 함께 고쳐야 한다.</li></ul><h4 id=write-skew-트레이드오프--하이브리드-전략>Write Skew 트레이드오프 & 하이브리드 전략<a hidden class=anchor aria-hidden=true href=#write-skew-트레이드오프--하이브리드-전략>#</a></h4><ul><li><p><strong>문제 맥락:</strong> 데이터베이스에서 &rsquo; 정확한 상태 &rsquo; 를 보장하려면 트랜잭션 격리 수준을 높여야 하지만, 격리 수준을 높이면 동시에 처리할 수 있는 작업 수가 줄어들어 성능이 떨어진다. Write Skew 는 이런 트레이드오프가 실제로 문제를 일으키는 대표 사례다.</p></li><li><p><strong>핵심 쟁점 (짧게):</strong></p><ul><li>SI: 빠르지만 일부 복합 제약 위반 허용 → Write Skew 가능.</li><li>SERIALIZABLE/SSI: 안전하지만 재시도·오버헤드 발생.</li><li>실무: 모든 트랜잭션을 직렬화하기보다 <strong>중요 트랜잭션 식별 → 고격리 적용</strong>, 또는 <strong>애플리케이션 레벨 해결</strong>을 조합해 사용.</li></ul></li></ul><h5 id=si-vs-serializable-비교표>SI Vs Serializable 비교표<a hidden class=anchor aria-hidden=true href=#si-vs-serializable-비교표>#</a></h5><table><thead><tr><th>비교 축</th><th style=text-align:right>Snapshot Isolation (SI)</th><th style=text-align:right>Serializable / SSI</th></tr></thead><tbody><tr><td>핵심 장점</td><td style=text-align:right>높은 동시성·읽기 성능</td><td style=text-align:right>완전한 직렬성·정확성</td></tr><tr><td>핵심 단점</td><td style=text-align:right>write-skew 등 이상 허용</td><td style=text-align:right>충돌·abort 로 처리량 저하</td></tr><tr><td>성능 영향</td><td style=text-align:right>낮은 지연, 높은 처리량</td><td style=text-align:right>재시도·락으로 처리량 감소</td></tr><tr><td>구현·운영 복잡도</td><td style=text-align:right>낮음 (일반 MVCC)</td><td style=text-align:right>높음 (충돌 탐지·모니터링)</td></tr><tr><td>적합 사례</td><td style=text-align:right>웹 트래픽, 읽기많은 서비스</td><td style=text-align:right>금융, 핵심 비즈니스 트랜잭션</td></tr><tr><td>실무 대안</td><td style=text-align:right>애플리케이션 검증·재시도</td><td style=text-align:right>선택적 직렬화, 모니터링</td></tr></tbody></table><p><strong>성능 (처리량/지연) 과 일관성 (데이터 무결성) 은 반비례 경향</strong>이 있다. SI 는 처리량을, Serializable 은 무결성을 우선한다. 실무에서는 워크로드별로 어느 쪽을 우선할지 기준을 세우고 (예: 금전·법적 영향이 큰 트랜잭션은 무결성 우선), 하이브리드로 보완하는 것이 현실적 해법이다.</p><h5 id=write-skew-하이브리드-대안-비교표>Write Skew 하이브리드 대안 비교표<a hidden class=anchor aria-hidden=true href=#write-skew-하이브리드-대안-비교표>#</a></h5><table><thead><tr><th>방법</th><th style=text-align:right>구성 요소</th><th style=text-align:right>적용 목적</th><th style=text-align:right>장점</th><th>고려사항/단점</th></tr></thead><tbody><tr><td>선택적 직렬화 (Selective)</td><td style=text-align:right>트랜잭션 분류 (critical vs normal), 격리 설정 정책</td><td style=text-align:right>핵심 불변식만 강제해 전체 성능 보전</td><td style=text-align:right>중요한 경로 무결성 확보·전체 성능 저하 제한</td><td>트랜잭션 분류 실수 위험, 복잡한 정책 관리.</td></tr><tr><td>SELECT FOR UPDATE / 명시잠금</td><td style=text-align:right>읽기 시점 행 잠금, 잠금 해제 시점 관리</td><td style=text-align:right>읽은 정보로 결정하는 트랜잭션 간 충돌 방지</td><td style=text-align:right>확실한 충돌 차단 (애플리케이션 제어)</td><td>잠금 경합·데드락·지연 유발.</td></tr><tr><td>Sentinel / Materialize Conflict</td><td style=text-align:right>sentinel 행/집계 같이 업데이트</td><td style=text-align:right>충돌을 강제하여 DB 가 하나를 abort 하게 유도</td><td style=text-align:right>DB 수준 충돌 감지 활용, 간단 구현 사례 많음</td><td>추가 업데이트 오버헤드, 설계·정합성 유지 필요.</td></tr><tr><td>낙관적 버전 + 재시도</td><td style=text-align:right>버전 칼럼/ETag, 재시도 로직 (백오프)</td><td style=text-align:right>충돌 드문 환경에서 효율 유지</td><td style=text-align:right>높은 처리량 유지, 단순 구현 가능</td><td>재시도 비용·사용자 영향·복잡성 존재.</td></tr><tr><td>엔진 수준 개선 (SSI 등)</td><td style=text-align:right>SSI 알고리즘·충돌 추적·인덱스 최적화</td><td style=text-align:right>MVCC 장점 유지하면서 직렬성 보장</td><td style=text-align:right>읽기·쓰기 분리 이점 유지, 일관성 보장</td><td>엔진 복잡도·운영 오버헤드·abort 가능.</td></tr></tbody></table><p>요약: 하이브리드 방법은 **정확성 향상 (또는 충돌 회피)**과 <strong>성능 유지</strong> 사이에서 서로 다른 지점을 선택한다. 운영에서는 트랜잭션 특성 (충돌 가능성, 응답성 요구, 실패 복구 용이성) 에 따라 적절한 하이브리드 조합을 설계해야 한다. 예를 들어 빈번한 충돌이 예상되는 경로에선 SELECT FOR UPDATE 나 직렬화 적용, 충돌이 드문 대량 처리 경로에선 SI+ 재시도 전략을 택하는 식이다.</p><h4 id=write-skew-적용-적합성운영-가이드>Write Skew: 적용 적합성·운영 가이드<a hidden class=anchor aria-hidden=true href=#write-skew-적용-적합성운영-가이드>#</a></h4><p>Write Skew 대응은 한마디로 <strong>위험도 기반 선택</strong>이다. 읽기 많은 서비스에선 Snapshot Isolation 을 써서 성능을 확보하고, 돈·안전처럼 핵심 규칙이 깨지면 안 되는 영역만 격리 수준을 올리거나 잠금/애플리케이션 검증을 더해 보호한다. 적용 전에는 어떤 쿼리와 불변식이 위험한지 찾아내고 (분석), 변경은 단계적으로 적용해 (설계) 모니터링 (운영) 으로 검증해야 한다.</p><h5 id=write-skew-적용-적합성-평가와-운영-전략>Write Skew 적용 적합성 평가와 운영 전략<a hidden class=anchor aria-hidden=true href=#write-skew-적용-적합성-평가와-운영-전략>#</a></h5><ul><li><strong>읽기 중심이면서 불변식 위험이 낮고 핫스팟이 크지 않은 서비스</strong>: Snapshot Isolation(혹은 SSI 로 성능 - 정합 균형) 을 1 차 선택.</li><li><strong>핵심 무결성이 최우선인 서비스 (금융·의료·결제 등)</strong>: Serializable(혹은 SSI + 추가 잠금/재검증) 적용 권장.</li><li><strong>대규모 혼합 워크로드</strong>: Hybrid(선별적 직렬화 + 애플리케이션 레벨 검증 + 파티셔닝) 전략 권장.</li></ul><h6 id=설계-관점-design>설계 관점 (Design)<a hidden class=anchor aria-hidden=true href=#설계-관점-design>#</a></h6><ul><li><strong>데이터 경계 정의</strong>: 불변식이 적용되는 도메인 경계를 명확히 나눠, 핵심 도메인만 강격리 적용.</li><li><strong>모델 선택</strong>: 충돌 가능 영역은 집계 행 (single-row counters) 혹은 CQRS 로 분리해 충돌률을 낮춘다.</li><li><strong>락 전략 설계</strong>: 범위·읽은 집합을 잠그는 전략 (선택적 <code>SELECT … FOR UPDATE</code>) 을 설계해 불변식 보호.</li></ul><h6 id=분석-관점-analysis>분석 관점 (Analysis)<a hidden class=anchor aria-hidden=true href=#분석-관점-analysis>#</a></h6><ul><li><strong>리스크 평가</strong>: 불변식 위반 시 비즈니스 영향 (금전·안전·법적 리스크) 을 정량화해 격리 레벨 결정 근거로 사용.</li><li><strong>성능 트레이드오프 분석</strong>: SSI/Serializable 적용 전후로 벤치마크 (throughput, latency, abort rate) 비교.</li><li><strong>데이터 분포 분석</strong>: 핫 - 키, 파티션 스키마, 쓰기 집중 구간을 분석해 파티셔닝/샤딩 필요 여부 판단.</li></ul><h6 id=운영-관점-operations>운영 관점 (Operations)<a hidden class=anchor aria-hidden=true href=#운영-관점-operations>#</a></h6><ul><li><strong>모니터링·알림</strong>: 재시도율, serialization failures, deadlocks, 비즈니스 무결성 체크 실패 등을 실시간 모니터링.</li><li><strong>운영 플레이북</strong>: 무결성 위반 발생 시 우선격리 상향, 트래픽 셰이핑, 롤백·수정 절차 등 대응 시나리오 준비.</li><li><strong>점진 적용·테스트</strong>: Canary/배치별로 격리 설정 변경 후 관측 (사전 자동 동시성 테스트 권장).</li></ul><h5 id=write-skew-적용-적합성-판단표>Write Skew 적용 적합성 판단표<a hidden class=anchor aria-hidden=true href=#write-skew-적용-적합성-판단표>#</a></h5><table><thead><tr><th>시나리오 유형</th><th style=text-align:right>권장 기본 전략</th><th>보완 조치 (필요 시)</th><th>고려 포인트 (설계·운영)</th></tr></thead><tbody><tr><td>읽기 - 중심 대규모 서비스 (예: 콘텐츠, 피드)</td><td style=text-align:right>Snapshot Isolation (SI)</td><td>모니터링, 불변식 테스트</td><td>핫스팟 여부, 낮은 불변식 민감도</td></tr><tr><td>사용자 참여 많은 실시간 서비스 (예: 예약, 이벤트)</td><td style=text-align:right>SI 우선 + 핫 - 스팟 차단 (파티셔닝)</td><td>특정 경합 영역에 FOR UPDATE</td><td>동시 쓰기 패턴, 배치 삽입 시간대</td></tr><tr><td>핵심 금융/의료/결제</td><td style=text-align:right>Serializable 또는 SSI</td><td>읽은 집합 잠금, DB 제약, 애플리케이션 재검증</td><td>비즈니스 리스크·감사요구</td></tr><tr><td>혼합 워크로드 (읽기 + 쓰기 모두 높음)</td><td style=text-align:right>Hybrid(선별적 격리 상향)</td><td>CQRS/집계 분리, 파티셔닝</td><td>도메인 경계 정의·테스트 계획</td></tr><tr><td>배치/ETL 중심 (대량 삽입)</td><td style=text-align:right>SI + 배치 격리 처리 (창구화)</td><td>일괄처리 창구·동시성 제어</td><td>배치 시간대·리소스 스케줄링</td></tr></tbody></table><ul><li><p><strong>원칙</strong>: 성능 우선인가, 무결성 우선인가를 먼저 결정하고 그에 따라 격리 전략을 선택하라.</p></li><li><p><strong>실무흐름</strong>: 위험 식별 → 기본 전략 (SI 권장) 적용 → 핵심 도메인에 보완 (잠금/Serializable) → 성능·무결성 테스트 → 운영 모니터링.</p></li><li><p><strong>운영 팁</strong>: 격리 상향은 전체 시스템에 적용하기보다 도메인 단위로 점진 적용하고, 재시도·abort 상황을 자동화·관측해야 안전하다.</p></li></ul><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-병동-온콜-불변식-최소-1-명>실습 예제: 병동 온콜 불변식 (최소 1 명)<a hidden class=anchor aria-hidden=true href=#실습-예제-병동-온콜-불변식-최소-1-명>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>SI 에서 Write Skew 발생을 재현하고, SERIALIZABLE 과 잠금 기반 해결을 체득.</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>PostgreSQL 14+ (로컬), psql</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>스키마 및 시드</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>DROP</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>doctors</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>SERIAL</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ward</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>name</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>on_call</span><span class=w> </span><span class=nb>BOOLEAN</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>doctors</span><span class=p>(</span><span class=n>ward</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>on_call</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span><span class=s1>&#39;Alice&#39;</span><span class=p>,</span><span class=w> </span><span class=k>TRUE</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span><span class=s1>&#39;Bob&#39;</span><span class=p>,</span><span class=w>   </span><span class=k>TRUE</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Write Skew 재현 (REPEATABLE READ≈SI)</strong></p><ul><li><p>세션 1:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>REPEATABLE</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=o>=</span><span class=s1>&#39;A&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>TRUE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 기대: 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>FALSE</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- COMMIT는 잠시 보류
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>세션 2:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>REPEATABLE</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=o>=</span><span class=s1>&#39;A&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>TRUE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 기대: 2 (스냅샷)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>FALSE</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Bob&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- 성공
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>세션 1:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- 성공 → 결과적으로 on_call=0 (불변식 위반)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=o>=</span><span class=s1>&#39;A&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>TRUE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 0
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><strong>해결 1: SERIALIZABLE(SSI)</strong></p><ul><li><p>초기화 후 재실행, 차이만 표시:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>TRUNCATE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>RESTART</span><span class=w> </span><span class=k>IDENTITY</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>doctors</span><span class=p>(</span><span class=n>ward</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>on_call</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span><span class=s1>&#39;Alice&#39;</span><span class=p>,</span><span class=k>TRUE</span><span class=p>),(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span><span class=s1>&#39;Bob&#39;</span><span class=p>,</span><span class=k>TRUE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 세션1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>SERIALIZABLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=o>=</span><span class=s1>&#39;A&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>TRUE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>FALSE</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 세션2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>SERIALIZABLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=o>=</span><span class=s1>&#39;A&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>TRUE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>FALSE</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Bob&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- 둘 중 한 세션이 여기 또는 다음 COMMIT에서 40001로 롤백됨
</span></span></span><span class=line><span class=cl><span class=c1>-- 세션1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- 40001 Serialization failure 발생 가능 → 재시도 필요
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><strong>해결 2: 가드 행 + 명시적 잠금</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 가드 테이블: 병동별 on_call 수 카운트
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>ward_guard</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ward</span><span class=w> </span><span class=nb>TEXT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>on_call_count</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>ward_guard</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 트리거로 유지(단순화 예시)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>upd_guard</span><span class=p>()</span><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=k>trigger</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>IF</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>on_call</span><span class=w> </span><span class=o>&lt;&gt;</span><span class=w> </span><span class=k>OLD</span><span class=p>.</span><span class=n>on_call</span><span class=w> </span><span class=k>THEN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UPDATE</span><span class=w> </span><span class=n>ward_guard</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>on_call_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>on_call_count</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=p>(</span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>on_call</span><span class=w> </span><span class=k>THEN</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>ELSE</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=w> </span><span class=k>END</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>ward</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>END</span><span class=w> </span><span class=k>IF</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>END</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DROP</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=k>IF</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=n>trg_doctors_guard</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>doctors</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>trg_doctors_guard</span><span class=w> </span><span class=k>AFTER</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>doctors</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w> </span><span class=k>EXECUTE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>upd_guard</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 세션1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>on_call_count</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>ward_guard</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>ward</span><span class=o>=</span><span class=s1>&#39;A&#39;</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 가드 행 잠금
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>doctors</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>on_call</span><span class=o>=</span><span class=k>FALSE</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Alice&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 세션2는 같은 가드 행에서 대기 또는 타임아웃
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>REPEATABLE READ: Write Skew 재현.</li><li>SERIALIZABLE: 한 트랜잭션이 **Serialization Failure(40001)** 로 중단 → 재시도 시 불변식 유지.</li><li>가드 행: 두 세션이 <strong>동일 행</strong>에 WW 충돌 → 순차화.</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li><code>SELECT … FOR UPDATE</code> 로 프레디킷을 인덱스 범위로 잠그는 설계 비교.</li><li>충돌 빈도에 따른 <strong>재시도 백오프</strong> 파라미터 실험.</li></ul><h3 id=phase-6-운영-및-최적화>Phase 6: 운영 및 최적화<a hidden class=anchor aria-hidden=true href=#phase-6-운영-및-최적화>#</a></h3><h4 id=write-skew-관측모니터링-실무-가이드>Write Skew 관측·모니터링 실무 가이드<a hidden class=anchor aria-hidden=true href=#write-skew-관측모니터링-실무-가이드>#</a></h4><p>Write Skew 등의 직렬성 이상을 잡으려면 <strong>직렬화 실패 (40001)</strong>, <strong>데드락 (40P01)</strong>, <strong>락 대기 시간</strong>, <strong>애플리케이션 재시도 빈도</strong>, 그리고 <strong>핫 로우 (키별 집중)</strong> 같은 지표를 모니터링해야 한다.<br>DB 내 <code>pg_locks</code>·<code>pg_stat_activity</code> 를 정기 조회하고, 에러 로그와 exporter(예: postgres_exporter) 를 통해 메트릭을 Prometheus/Grafana 나 SIEM 으로 집계하면 실시간 탐지·알람·포렌식이 가능하다.<br>임계값 (알람) 은 워크로드·SLA 에 맞춰 실험적으로 정하라.</p><h5 id=write-skew-관측-카테고리>Write Skew 관측 카테고리<a hidden class=anchor aria-hidden=true href=#write-skew-관측-카테고리>#</a></h5><h6 id=시그널-메트릭-에러지연-중심>시그널 메트릭 (에러·지연 중심)<a hidden class=anchor aria-hidden=true href=#시그널-메트릭-에러지연-중심>#</a></h6><p><code>serialization_failure_rate</code>(SQLSTATE 40001), <code>deadlock_rate</code>(40P01), <code>lock_wait_ms</code>(avg/95p), <code>retry_count</code>.<br>이 지표들은 직렬성 위반·락 경합·재시도 과부하를 조기에 감지한다. 알람 예: 5 분간 serialization_failure_rate > 0.5% → P1 알람.</p><table><thead><tr><th>지표</th><th style=text-align:right>왜 보는가</th><th>구현 예</th></tr></thead><tbody><tr><td>serialization_failure_rate</td><td style=text-align:right>직렬성 위반 (직접 신호)</td><td>DB 로그/애플리케이션 에러 → Prometheus counter</td></tr><tr><td>deadlock_rate</td><td style=text-align:right>락 정책 문제·교착</td><td>DB 로그 (40P01) 파싱 → SIEM 이벤트</td></tr><tr><td>lock_wait_ms</td><td style=text-align:right>성능저하 전조</td><td>pg_locks/pg_stat_activity → exporter metric</td></tr><tr><td>retry_count</td><td style=text-align:right>재시도 과부하</td><td>앱 레이어 로그 → central metrics</td></tr></tbody></table><ul><li>시그널 메트릭은 Write Skew 가능성 뿐 아니라 운영성 문제 (지연·재시도 과부하) 를 빠르게 알려주는 역할을 한다. 직렬화 오류 (40001) 는 반드시 수집·집계해 재시도 정책과 연동하라.</li></ul><h6 id=락세션-관측-상태그래프-중심>락·세션 관측 (상태·그래프 중심)<a hidden class=anchor aria-hidden=true href=#락세션-관측-상태그래프-중심>#</a></h6><p><code>pg_locks</code>, <code>pg_stat_activity</code> 정기 스냅샷 및 deadlock 그래프 캡처.<br>블로킹/대기 세션 트리거 시 자동 스냅샷 (locks + queries) 저장.</p><table><thead><tr><th>항목</th><th style=text-align:right>왜 보는가</th><th>구현 예</th></tr></thead><tbody><tr><td>pg_locks 스냅샷</td><td style=text-align:right>누가 무엇을 잠그는지 파악</td><td>주기 cron job 또는 트리거 시 수집</td></tr><tr><td>pg_stat_activity</td><td style=text-align:right>세션별 현재 쿼리 상태</td><td>대기 중인 쿼리·트랜잭션 길이 확인</td></tr><tr><td>deadlock graph</td><td style=text-align:right>교착 원인 분석</td><td>deadlock 발생 시 자동 수집 스크립트</td></tr></tbody></table><ul><li>락·세션 관측은 문제의 근본 원인 (누가, 어떤 쿼리가 락을 잡고 있는지) 을 파악하는 데 필수적이다. deadlock 발생 시 즉시 그래프를 캡처해 원인분석에 사용하라.</li></ul><h6 id=애플리케이션-레벨-지표-재시도비즈니스-실패>애플리케이션 레벨 지표 (재시도·비즈니스 실패)<a hidden class=anchor aria-hidden=true href=#애플리케이션-레벨-지표-재시도비즈니스-실패>#</a></h6><p>애플리케이션에서 발생한 <code>retry_count</code>, 재시도 후 성공률, idempotency 실패 로그, 비즈니스 규칙 위반 알람 등.<br>재시도 로직의 폭주 여부를 감지해 자동 백오프·큐잉 유도.</p><table><thead><tr><th>항목</th><th style=text-align:right>왜 보는가</th><th>구현 예</th></tr></thead><tbody><tr><td>retry_count</td><td style=text-align:right>재시도 과부하 감지</td><td>미들웨어/라이브러리에서 카운트 노출</td></tr><tr><td>retry_success_rate</td><td style=text-align:right>재시도 효과성 평가</td><td>성공/총 재시도 비율 계산</td></tr><tr><td>business_violation_events</td><td style=text-align:right>규칙 위반 감지</td><td>애플리케이션 레벨 감사 이벤트</td></tr></tbody></table><ul><li>애플리케이션 지표는 DB 알람과 결합해 전체 워크플로의 건강도를 판단하게 해준다. 재시도 증가와 직렬화 실패가 함께 나타나면 자동화 대책을 검토하자.</li></ul><h6 id=핫스팟스케일-지표-키노드-중심>핫스팟/스케일 지표 (키·노드 중심)<a hidden class=anchor aria-hidden=true href=#핫스팟스케일-지표-키노드-중심>#</a></h6><p>특정 키·인덱스에 집중된 요청 (QPS), 노드별 리소스·latch contention, 샤드별 트래픽 편중 등. 핫스팟이 확인되면 샤딩·파티셔닝·레디스 캐시 등 아키텍처적 대응을 검토.</p><table><thead><tr><th>항목</th><th style=text-align:right>왜 보는가</th><th>구현 예</th></tr></thead><tbody><tr><td>key QPS 분포</td><td style=text-align:right>특정 키 집중 확인</td><td>pg_stat_statements + 로그 파싱</td></tr><tr><td>node contention</td><td style=text-align:right>분산 DB 노드 문제</td><td>벤더 콘솔/노드 메트릭</td></tr><tr><td>index contention</td><td style=text-align:right>인덱스 락 집중</td><td>index-level statistics 수집</td></tr></tbody></table><ul><li>핫스팟은 시스템 전반 성능·정합성에 악영향을 준다. 조기 탐지로 샤드·캐시·데이터 모델 변경을 통해 충돌을 국지화하라.</li></ul><h5 id=write-skew-관측-통합-대시보드-항목>Write Skew 관측 통합 대시보드 항목<a hidden class=anchor aria-hidden=true href=#write-skew-관측-통합-대시보드-항목>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>핵심 메트릭/로그</th><th>목적</th><th>우선순위</th></tr></thead><tbody><tr><td>시그널 메트릭</td><td style=text-align:right>serialization_failure_rate(40001), deadlock_rate(40P01), lock_wait_ms, retry_count</td><td>이상 탐지·알람</td><td>높음</td></tr><tr><td>락·세션 관측</td><td style=text-align:right>pg_locks, pg_stat_activity, deadlock graph</td><td>원인 분석 (누가,무엇을)</td><td>높음</td></tr><tr><td>애플리케이션 지표</td><td style=text-align:right>retry_count, retry_success_rate, business_violation_events</td><td>재시도/비즈니스 영향 파악</td><td>높음</td></tr><tr><td>핫스팟 지표</td><td style=text-align:right>key QPS 분포, index contention, node resource</td><td>확장성·샤딩 판단 근거</td><td>중~높</td></tr></tbody></table><p>이 네 카테고리를 통합한 대시보드는 Write Skew·직렬성 이상을 조기에 탐지하고, 원인 분석→자동화 대응→아키텍처 개선으로 이어지는 운영 루프를 완성한다. 먼저 <code>serialization_failure_rate</code> 와 <code>pg_locks</code> 기반 알람을 구성하고, 이후 애플리케이션 재시도·핫스팟 분석을 추가하라.</p><h3 id=62-보안-및-컴플라이언스>6.2 보안 및 컴플라이언스<a hidden class=anchor aria-hidden=true href=#62-보안-및-컴플라이언스>#</a></h3><p>Write Skew 는 동시 트랜잭션이 같은 판단 근거로 행동해 전역 규칙을 깨는 현상이다.<br>보안·컴플라이언스 관점에서는 단순 성능 조치로 해결되지 않으므로, 권한 통제, 트랜잭션 복구 정책, 멱등성/아웃박스 패턴, 불변의 감사 로그, 데이터 암호화, 그리고 모니터링을 조합해 리스크를 관리해야 한다.<br>규제 업종은 특히 증적 보관·무결성·접근 통제가 엄격하다.</p><h4 id=write-skew-보안컴플라이언스-카테고리>Write Skew 보안·컴플라이언스 카테고리<a hidden class=anchor aria-hidden=true href=#write-skew-보안컴플라이언스-카테고리>#</a></h4><h5 id=접근-제어--거버넌스>접근 제어 & 거버넌스<a hidden class=anchor aria-hidden=true href=#접근-제어--거버넌스>#</a></h5><p>접근 제어는 누가 어떤 트랜잭션을 실행할 수 있는지를 제한해, 권한 남용이나 오작동으로 인한 불변식 위반을 방지한다. 실무적 적용으로는 RBAC, 최소 권한, 서비스 계정 분리, 운영자 액션 감사 (log of admin actions) 를 둔다. 규제 요건 (감사·접근 통제) 을 매핑해 권한 부여·검토 주기를 정한다.</p><h5 id=트랜잭션-안전성--롤백>트랜잭션 안전성 & 롤백<a hidden class=anchor aria-hidden=true href=#트랜잭션-안전성--롤백>#</a></h5><p>트랜잭션 안전성은 실패 시 데이터 일관성을 보장하는 메커니즘과 복구 절차를 포함한다. 자동 재시도는 멱등성 전제하에 적용하고, 복구 불가능한 실패엔 보상 (Saga) 또는 수동 복구 절차를 문서화한다. 또한 트랜잭션 실패에 대한 알림·수정 프로세스를 운영에 포함한다.</p><h5 id=멱등성--아웃박스>멱등성 & 아웃박스<a hidden class=anchor aria-hidden=true href=#멱등성--아웃박스>#</a></h5><p>멱등성은 동일 요청을 여러 번 적용해도 결과가 동일하도록 설계하는 것 (요청 토큰, idempotency key). 아웃박스 패턴은 DB 트랜잭션과 이벤트 발행을 원자적으로 묶어 분산 불일치 위험을 줄인다. 두 패턴은 재시도·비동기 통합에서 필수적이다.</p><h5 id=감사-추적--증적-보존>감사 추적 & 증적 보존<a hidden class=anchor aria-hidden=true href=#감사-추적--증적-보존>#</a></h5><p>트랜잭션 로그·변경 이력·트랜잭션 ID·버전 정보를 불변 (append-only) 으로 보관하고, 보관 기간·무결성 (암호화·서명) 을 규정에 맞춰 설정한다. 포렌식·감사 요청 시 재현 가능하도록 메타데이터를 포함해 저장한다.</p><h5 id=데이터-보호-암호화키관리>데이터 보호 (암호화·키관리)<a hidden class=anchor aria-hidden=true href=#데이터-보호-암호화키관리>#</a></h5><p>민감 데이터는 전송·저장에서 암호화하고, 키 관리는 중앙화 (KMS/HSM) 하여 접근·사용을 통제한다. 데이터 최소화·익명화 정책도 병행해 규제 위험을 축소한다.</p><h5 id=모니터링경보운영-정책>모니터링·경보·운영 정책<a hidden class=anchor aria-hidden=true href=#모니터링경보운영-정책>#</a></h5><p>충돌률, 재시도 실패율, 직렬화 실패 (HTTP 40001 등), lock-wait 등을 지표로 수집하고, 임계치 초과 시 자동 정책 (일시적 격리 상향, 트래픽 제한) 실행한다. Jepsen 스타일 검증을 주기적으로 실행해 실환경 가설 검증을 권장한다.</p><h4 id=쓰기스큐-보안-종합-실행표>쓰기스큐 보안 종합 실행표<a hidden class=anchor aria-hidden=true href=#쓰기스큐-보안-종합-실행표>#</a></h4><table><thead><tr><th>영역</th><th>주요 조치</th><th style=text-align:right>목적</th><th>운영 지표 (예시)</th></tr></thead><tbody><tr><td>접근 통제</td><td>RBAC, 세분화된 DB 권한</td><td style=text-align:right>권한 오남용 방지</td><td>관리자 액션 로그 수, 권한 변경 빈도</td></tr><tr><td>트랜잭션 복구</td><td>멱등 재시도, Saga, 보상</td><td style=text-align:right>실패 시 무결성 유지</td><td>재시도율, 보상 성공률</td></tr><tr><td>아웃박스·멱등성</td><td>Outbox 테이블, idempotency key</td><td style=text-align:right>분산 이벤트 일관성</td><td>Outbox 미전송 건수, 소비자 중복률</td></tr><tr><td>감사·증적</td><td>변경 이력, 불변 로그, 서명</td><td style=text-align:right>규제 증빙·포렌식</td><td>감사로그 보관완료율, 검색 응답시간</td></tr><tr><td>데이터 보호</td><td>TLS/TDE, KMS 관리</td><td style=text-align:right>데이터 유출 방지</td><td>암호화 적용률, 키 회전 주기</td></tr><tr><td>모니터링</td><td>충돌률, serial failures, lock-wait</td><td style=text-align:right>조기 경보·자동 조치</td><td>충돌률 (%), 직렬화 실패 건수</td></tr></tbody></table><h3 id=write-skew-성능확장-최적화-전략>Write Skew 성능·확장 최적화 전략<a hidden class=anchor aria-hidden=true href=#write-skew-성능확장-최적화-전략>#</a></h3><p>Write Skew 같은 동시성 문제는 <strong>일관성 강화를 위해 모든 트랜잭션을 무조건 직렬화하면 성능이 급격히 떨어진다</strong>.<br>그래서 실무에서는 <strong>짧은 트랜잭션 유지·인덱스 튜닝으로 락 범위를 줄이고</strong>, <strong>핵심 경로만 높은 격리 적용</strong>, <strong>지수 백오프 재시도</strong>와 같이 성능과 일관성의 균형을 맞춘다. 대규모일수록 <strong>샤딩·캐시·비동기 처리</strong>를 통해 충돌 표면을 분할·완화하는 것이 핵심이다.</p><h4 id=write-skew-성능확장-카테고리>Write Skew 성능·확장 카테고리<a hidden class=anchor aria-hidden=true href=#write-skew-성능확장-카테고리>#</a></h4><h5 id=재시도백오프-정책>재시도·백오프 정책<a hidden class=anchor aria-hidden=true href=#재시도백오프-정책>#</a></h5><ul><li><p>내용: 충돌 (직렬화 실패·낙관적 잠금 충돌) 시 재시도 로직을 지수 백오프로 구현하고 재시도 횟수 제한과 랜덤 지터를 추가한다. 재시도 시 <strong>멱등성</strong>(idempotency key) 확보가 필수.</p></li><li><p>구현 팁: base=100ms, 재시도 n 일 때 delay = base * 2^n ± rand(0, base); 최대 재시도 3~5 회; 실패 시 사용자 피드백 또는 작업 큐로 이관.</p></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 예</th><th>주의점</th></tr></thead><tbody><tr><td>지수 백오프 + 지터</td><td style=text-align:right>재시도 폭주 방지</td><td>base*2^n ± jitter</td><td>멱등성 미보장 시 중복 문제</td></tr><tr><td>최대 재시도 제한</td><td style=text-align:right>자원 낭비 방지</td><td>maxRetries=3~5</td><td>사용자 경험 고려</td></tr><tr><td>멱등키</td><td style=text-align:right>중복 처리 방지</td><td>request_id 토큰</td><td>토큰 저장소 필요 (짧은 TTL)</td></tr></tbody></table><ul><li>요약: 재시도는 필수지만 제어하지 않으면 시스템을 망가뜨린다. 지수 백오프·지터·멱등성 조합으로 안전하게.</li></ul><h5 id=트랜잭션락-설계>트랜잭션·락 설계<a hidden class=anchor aria-hidden=true href=#트랜잭션락-설계>#</a></h5><ul><li><p>내용: 트랜잭션을 짧게 유지하고, 불가피한 경우 핵심 행만 <code>SELECT … FOR UPDATE</code> 로 잠그거나 핵심 경로만 Serializable 로 설정한다. 인덱스를 통해 락 범위를 좁힌다.</p></li><li><p>구현 팁: EXPLAIN 으로 범위 스캔 확인, 트랜잭션 내 외부 호출 제거, 필요 시 저장 프로시저로 원자화.</p></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 예</th><th>주의점</th></tr></thead><tbody><tr><td>트랜잭션 단축</td><td style=text-align:right>락 보유 시간 최소화</td><td>읽기 후 계산, 쓰기만 트랜잭션</td><td>외부 I/O 제거 필요</td></tr><tr><td>행 수준 잠금</td><td style=text-align:right>충돌 방지 (핫스팟)</td><td>SELECT … FOR UPDATE</td><td>동시성 저하 가능</td></tr><tr><td>혼합 격리</td><td style=text-align:right>부분적 직렬화 적용</td><td>핵심 API 만 Serializable</td><td>운영 복잡성 증가</td></tr></tbody></table><ul><li>요약: 락·격리 수준을 좁게·선택적으로 적용해 성능을 지켜라.</li></ul><h5 id=데이터-접근-패턴-인덱스캐시>데이터 접근 패턴 (인덱스·캐시)<a hidden class=anchor aria-hidden=true href=#데이터-접근-패턴-인덱스캐시>#</a></h5><ul><li><p>내용: 인덱스를 통한 범위 축소로 락 효과를 높이고, 읽기 부담은 캐시로 오프로드한다. 쓰기 직후의 일관성 보장은 세션 강제 마스터 읽기나 캐시 무효화 전략으로 보완.</p></li><li><p>구현 팁: EXPLAIN → 복합 인덱스 추가, 캐시에는 쓰기 후 즉시 무효화 또는 이벤트 기반 동기화.</p></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 예</th><th>주의점</th></tr></thead><tbody><tr><td>인덱스 튜닝</td><td style=text-align:right>락 범위 축소</td><td>복합 인덱스, 커버링 인덱스</td><td>인덱스 비용 (쓰기 비용)</td></tr><tr><td>캐싱</td><td style=text-align:right>읽기 부하 완화</td><td>Redis, TTL, pub/sub 무효화</td><td>캐시 일관성 관리 필요</td></tr><tr><td>마스터 강제 읽기</td><td style=text-align:right>스테일 리드 방지</td><td>세션 레벨 설정</td><td>리플리카 부하 고려</td></tr></tbody></table><ul><li>요약: 선제적 인덱스와 캐시 전략으로 DB 충돌 표면을 줄여라.</li></ul><h5 id=아키텍처적-확장-샤딩분산락cqrs>아키텍처적 확장 (샤딩·분산락·CQRS)<a hidden class=anchor aria-hidden=true href=#아키텍처적-확장-샤딩분산락cqrs>#</a></h5><ul><li><p>내용: 도메인 분할 (샤딩) 으로 충돌 범위를 줄이고, 글로벌 불변식은 분산 락이나 이벤트 방식으로 처리. 쓰기·읽기 분리, CQRS 로 확장성 확보.</p></li><li><p>구현 팁: 샤드 키는 균등 분포 목표, 분산 락은 TTL·리더 선출로 안전성 확보, CQRS 시 보상 트랜잭션 설계.</p></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 예</th><th>주의점</th></tr></thead><tbody><tr><td>샤딩</td><td style=text-align:right>충돌 도메인 분리</td><td>user_id % N 샤드</td><td>크로스샤드 트랜잭션 비용</td></tr><tr><td>분산 락</td><td style=text-align:right>글로벌 불변식 보장</td><td>etcd / Redis RedLock</td><td>네트워크 지연·가용성 고려</td></tr><tr><td>CQRS / 이벤트</td><td style=text-align:right>확장성·비동기 처리</td><td>Command queue + read model</td><td>복잡성·운영 부담 증가</td></tr></tbody></table><ul><li>요약: 샤딩·분산락·CQRS 는 강력하지만 설계·운영 비용이 크다—꼭 필요한 곳에만 적용하라.</li></ul><h5 id=운영모니터링>운영·모니터링<a hidden class=anchor aria-hidden=true href=#운영모니터링>#</a></h5><ul><li><p>내용: 재시도율, 직렬화 실패율, 락 대기 p95/p99, 트랜잭션 길이 등의 지표로 성능·충돌을 관측하고 자동화된 런북으로 1 차 대응을 실행.</p></li><li><p>구현 팁: Prometheus + Grafana, OpenTelemetry, 알람 임계값 (예: 직렬화 실패 >0.5% 경고).</p></li></ul><table><thead><tr><th>지표</th><th style=text-align:right>목적</th><th>임계값 예시</th><th>대응</th></tr></thead><tbody><tr><td>재시도율</td><td style=text-align:right>충돌 빈도 감지</td><td>>2% 경고</td><td>백오프 조정, 패치</td></tr><tr><td>직렬화 실패율</td><td style=text-align:right>SSI/Serializable 문제 신호</td><td>>0.5% 심각</td><td>핵심 경로 점검</td></tr><tr><td>락 대기 p95</td><td style=text-align:right>락 경합 탐지</td><td>p95 > 2000ms</td><td>트랜잭션 분해</td></tr></tbody></table><ul><li>요약: 계측 (모니터링) 은 모든 설계의 필수 전제—지표 기반으로 조치하라.</li></ul><h4 id=write-skew-대응-종합-전략표>Write Skew 대응 종합 전략표<a hidden class=anchor aria-hidden=true href=#write-skew-대응-종합-전략표>#</a></h4><table><thead><tr><th>카테고리</th><th>핵심 기법</th><th>목적</th><th>구현 포인트</th></tr></thead><tbody><tr><td>재시도 · 백오프</td><td>지수 백오프 + 지터, 멱등키, 재시도 한도</td><td>재시도 폭주/리소스 낭비 방지</td><td>base delay, maxRetries, 멱등성 확보</td></tr><tr><td>트랜잭션·락 설계</td><td>트랜잭션 단축, 행 잠금, 혼합 격리</td><td>락 보유시간·경합 최소화</td><td>EXPLAIN, FOR UPDATE, 핵심만 Serializable</td></tr><tr><td>데이터 접근</td><td>인덱스 튜닝, 캐시, 마스터 강제 읽기</td><td>락 범위 축소·읽기 부하 완화</td><td>복합 인덱스, 캐시 무효화 전략</td></tr><tr><td>아키텍처 확장</td><td>샤딩, 분산 락, CQRS</td><td>샤드 단위 충돌 축소·확장성 확보</td><td>샤드키 설계, TTL 락, 이벤트소싱</td></tr><tr><td>운영·관측</td><td>재시도율·직렬화 실패·락 p95 모니터링</td><td>조기 경보·자동화 대응</td><td>Prometheus/Grafana, Runbook</td></tr></tbody></table><h3 id=64-트러블슈팅-및-문제-해결>6.4 트러블슈팅 및 문제 해결<a hidden class=anchor aria-hidden=true href=#64-트러블슈팅-및-문제-해결>#</a></h3><h4 id=write-skew-트러블슈팅-종합-가이드>Write-Skew 트러블슈팅 종합 가이드<a hidden class=anchor aria-hidden=true href=#write-skew-트러블슈팅-종합-가이드>#</a></h4><ul><li><strong>증상</strong>: 간헐적으로 집계·제약이 깨져 결과가 틀림.</li><li><strong>원인</strong>: 동시 트랜잭션이 같은 스냅샷을 보고 서로 다른 행을 바꿔도 DB 가 이를 막지 못하는 상황 (=write-skew).</li><li><strong>당장 해야 할 일</strong>: 문제 트랜잭션 찾아 재현 → 임시로 해당 경로에 락 적용 또는 격리 상향 → 근본적으로는 버전검사·원자적 업데이트·DB 제약으로 해결.</li><li><strong>중요</strong>: 프로덕션 격리 변경은 비용 (성능/가용성) 을 수반하므로 단계적으로 적용하고 모니터링해야 한다.</li></ul><h5 id=왜-발생하는가-근본-원인>왜 발생하는가 (근본 원인)<a hidden class=anchor aria-hidden=true href=#왜-발생하는가-근본-원인>#</a></h5><ul><li><strong>동시 트랜잭션이 같은 시점의 스냅샷을 읽고 서로 다른 행을 갱신</strong>할 때, 쓰기 - 쓰기 충돌이 명시적으로 없으면 SI 등 낮은 격리에서 커밋을 허용하여 비즈니스 불변식을 위배한다 (=write-skew).</li><li>또한 <strong>핫 파티션 (동일 키/범위에 집중된 트래픽)</strong>, 잘못된 인덱스 또는 조건 기반 업데이트가 원인을 악화시킨다.</li></ul><h5 id=무엇으로-어떻게-해결하는가-구체적-수단>무엇으로 어떻게 해결하는가 (구체적 수단)<a hidden class=anchor aria-hidden=true href=#무엇으로-어떻게-해결하는가-구체적-수단>#</a></h5><ul><li><p><strong>단기 완화 (빠른 대응)</strong></p><ol><li>문제 트랜잭션을 식별해 임시로 해당 경로에 <code>SELECT … FOR UPDATE</code> 같은 비관적 잠금 적용.</li><li>문제 범위가 좁으면 격리 수준을 <code>Serializable</code>(또는 DB 의 SSI 활성화) 로 높여 보수적으로 처리 (단, 카나리아/제한 적용).</li><li>임시로 해당 키에 애플리케이션 락 (Advisory lock) 적용.</li></ol></li><li><p><strong>근본 해결 (설계/코드 변경)</strong></p><ol><li><strong>원자적 SQL</strong>로 표현 가능한 연산은 DB 쪽으로 위임 (<code>UPDATE … WHERE version = x</code> 또는 <code>UPDATE accounts SET bal = bal +? WHERE id=?</code>).</li><li><strong>낙관적 락 (버전 컬럼)</strong> + 재시도 로직 도입 (지수 백오프 + 지터).</li><li>비즈니스 불변식은 <strong>DB 제약 (CHECK, EXCLUSION, UNIQUE)</strong> 또는 가드 행 (집계 행) 으로 모델링.</li><li>핵심 트랜잭션은 SSI/Serializable 로 처리하고 일반 트랜잭션은 SI 로 운영하는 <strong>하이브리드 전략</strong> 도입.</li></ol></li><li><p><strong>운영 보완</strong></p><ol><li>충돌·재시도·abort 지표화 (모니터링→경보).</li><li>정기적 동시성 스트레스 테스트 및 재현 시나리오 자동화.</li><li>감사 로그·CDC 기반 포렌식과 복구 절차 준비.</li></ol></li></ul><h5 id=write-skew-트러블슈팅>Write-Skew 트러블슈팅<a hidden class=anchor aria-hidden=true href=#write-skew-트러블슈팅>#</a></h5><h6 id=탐지탐색-detection--triage>탐지·탐색 (Detection & Triage)<a hidden class=anchor aria-hidden=true href=#탐지탐색-detection--triage>#</a></h6><p>증상 식별과 우선순위 분류 단계.</p><ul><li>핵심 활동:<ul><li>사용자 리포트·경고 수집 (에러/무결성 불일치)</li><li>관련 트랜잭션 ID·타임스탬프·쿼리 패턴 확보</li><li>초기 영향 범위 결정 (테이블/파티션/서비스)</li></ul></li><li>도구/명령 예:<ul><li>PostgreSQL: pg_stat_activity, pg_locks, pg_stat_wal</li><li>MySQL: SHOW PROCESSLIST, SHOW ENGINE INNODB STATUS</li><li>애플리케이션 로그, APM(트레이스)</li></ul></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>도구/증거</th></tr></thead><tbody><tr><td>에러/리포트 수집</td><td style=text-align:right>문제 인지</td><td>Sentry/로그/유저 리포트</td></tr><tr><td>트랜잭션 식별</td><td style=text-align:right>원인 트래픽 타겟</td><td>tx id, timestamp</td></tr><tr><td>초기 영향 범위</td><td style=text-align:right>긴급도 판정</td><td>테이블/파티션 목록</td></tr></tbody></table><ul><li>핵심: 문제를 빠르게 탐지하고 영향 범위를 좁혀 우선순위를 정하라.</li></ul><h6 id=재현분석-reproduction--root-cause>재현·분석 (Reproduction & Root Cause)<a hidden class=anchor aria-hidden=true href=#재현분석-reproduction--root-cause>#</a></h6><p>원인 재현과 근본 원인 분석 단계.</p><ul><li>핵심 활동:<ul><li>스테이징에서 동시성 재현 (다중 세션, sleep 타이밍)</li><li>EXPLAIN ANALYZE 로 실행계획 확인</li><li>락/대기 로그, deadlock 로그 분석</li><li>WAL/Redo 또는 CDC 로 커밋 시퀀스 검증</li></ul></li><li>도구/명령 예:<ul><li>SQL 스크립트 (동시 트랜잭션), EXPLAIN, SHOW ENGINE INNODB STATUS, pg_waldump</li></ul></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>도구/증거</th></tr></thead><tbody><tr><td>동시성 재현</td><td style=text-align:right>문제 원인 확인</td><td>동시 스크립트/트랜잭션 시뮬레이터</td></tr><tr><td>락·대기 분석</td><td style=text-align:right>잠금 원인 규명</td><td>pg_locks / innodb status</td></tr><tr><td>로그 타임라인</td><td style=text-align:right>커밋 시퀀스 검증</td><td>WAL / binlog / CDC</td></tr></tbody></table><ul><li>핵심: 재현 가능한 시나리오를 만들고 로그로 타임라인을 검증하면 근본 원인을 정확히 파악할 수 있다.</li></ul><h6 id=단기-완화-임시-대책-immediate-mitigation>단기 완화 (임시 대책) (Immediate Mitigation)<a hidden class=anchor aria-hidden=true href=#단기-완화-임시-대책-immediate-mitigation>#</a></h6><p>프로덕션 영향 최소화를 위한 신속한 조치.</p><ul><li>핵심 활동:<ul><li>문제 트랜잭션에 대한 <code>SELECT … FOR UPDATE</code> 적용 (범위 제한)</li><li>키·범위에 advisory lock(앱 레벨) 적용</li><li>제한적 격리 상향 (카나리아/특정 서비스에만)</li><li>트래픽 셰이딩 (핫파티션 임시 분리)</li></ul></li><li>도구/명령 예:<ul><li>SQL 변경 (롤링 적용), 앱 레벨 락 코드, 트래픽 라우팅</li></ul></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>실행 예</th></tr></thead><tbody><tr><td>FOR UPDATE 적용</td><td style=text-align:right>즉시 일관성 확보</td><td>특정 쿼리 변경</td></tr><tr><td>Advisory Lock</td><td style=text-align:right>분산 락 적용</td><td>Redis/DB advisory lock</td></tr><tr><td>격리 상향 (카나리아)</td><td style=text-align:right>근본 변경 전 임시 보호</td><td>SERIALIZABLE on subset</td></tr></tbody></table><ul><li>핵심: 임시완화는 최소범위·단기간 적용하고 영향 (성능) 을 면밀히 모니터링하라.</li></ul><h6 id=근본-해결-설계코드-permanent-fixes>근본 해결 (설계/코드) (Permanent Fixes)<a hidden class=anchor aria-hidden=true href=#근본-해결-설계코드-permanent-fixes>#</a></h6><p>재발 방지 위한 설계·코드 변경.</p><ul><li>핵심 활동:<ul><li>원자적 SQL 또는 version 기반 낙관적 락 구현</li><li>DB 제약 (CHECK/EXCLUSION/UNIQUE) 추가</li><li>핵심 트랜잭션을 SSI/Serializable 로 전환 (선별 적용)</li><li>CQRS/파티셔닝/leader-per-shard 등 아키텍처 변경</li></ul></li><li>도구/명령 예:<ul><li>DB 마이그레이션 (제약 추가), 코드 배포, 테스트 자동화</li></ul></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>원자적 SQL</td><td style=text-align:right>네트워크/중간상태 제거</td><td>UPDATE … WHERE version =?</td></tr><tr><td>DB 제약 추가</td><td style=text-align:right>무결성 강제</td><td>CHECK / UNIQUE / EXCLUSION</td></tr><tr><td>하이브리드 격리</td><td style=text-align:right>비용 - 효율적 정합성</td><td>SSI for critical</td></tr></tbody></table><ul><li>핵심: 설계 변경은 충분한 테스트·롤아웃 계획 (카나리아) 과 모니터링을 동반해야 안전하다.</li></ul><h6 id=운영모니터링-monitoring--prevention>운영·모니터링 (Monitoring & Prevention)<a hidden class=anchor aria-hidden=true href=#운영모니터링-monitoring--prevention>#</a></h6><p>지표 기반 탐지와 예방적 운영.</p><ul><li>핵심 활동:<ul><li>충돌률 (abort rate), 재시도 횟수, lock wait, P99 레이턴시 지표 수집</li><li>경보 임계치 설정 및 자동화 대응 (서킷브레이커)</li><li>정기 동시성 스트레스 테스트 및 회귀 테스트</li></ul></li><li>도구/명령 예:<ul><li>Prometheus/Grafana, APM, Synthetic Tests</li></ul></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>충돌률 지표</td><td style=text-align:right>이상탐지</td><td>prometheus metric</td></tr><tr><td>자동 경보</td><td style=text-align:right>신속 알림</td><td>PagerDuty</td></tr><tr><td>정기 테스트</td><td style=text-align:right>회귀 방지</td><td>CI 스트레스 테스트</td></tr></tbody></table><ul><li>핵심: 측정 가능한 지표를 정하고 자동 경보와 주기적 테스트로 사전 예방하라.</li></ul><h6 id=회복감사-복구포렌식-recovery--forensics>회복·감사 (복구/포렌식) (Recovery & Forensics)<a hidden class=anchor aria-hidden=true href=#회복감사-복구포렌식-recovery--forensics>#</a></h6><p>사건의 복구와 원인 증거 확보.</p><ul><li>핵심 활동:<ul><li>WAL/binlog/CDC 기반 타임라인 복원 및 증거 수집</li><li>무결성 검증 (체크섬), 복구 시나리오 실행 (restore drill)</li><li>사후보고 (RCA) 와 교훈 문서화</li></ul></li><li>도구/명령 예:<ul><li>pg_waldump, mysqlbinlog, Debezium CDC, WORM 보관소</li></ul></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>목적</th><th>도구</th></tr></thead><tbody><tr><td>로그 기반 복구</td><td style=text-align:right>시계열 재구성</td><td>WAL / binlog / CDC</td></tr><tr><td>복구 연습</td><td style=text-align:right>복구 능력 검증</td><td>복원 시나리오</td></tr><tr><td>사후보고</td><td style=text-align:right>프로세스 개선</td><td>RCA 문서</td></tr></tbody></table><ul><li>핵심: 사건 증거를 안전히 보관하고 정기적으로 복구 능력을 검증하라.</li></ul><h5 id=write-skew-문제해결-요약표>Write-Skew 문제해결 요약표<a hidden class=anchor aria-hidden=true href=#write-skew-문제해결-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>핵심 목표</th><th>대표 조치 (단기 → 중기 → 장기)</th><th>대표 도구/지표</th></tr></thead><tbody><tr><td>탐지·탐색</td><td style=text-align:right>빠르게 문제 인지·영향파악</td><td>로그 수집 → tx id 확보 → 영향도 분류</td><td>Sentry, pg_stat_activity, SHOW ENGINE</td></tr><tr><td>재현·분석</td><td style=text-align:right>근본 원인 규명</td><td>스테이징 재현 → EXPLAIN/락 로그 분석</td><td>EXPLAIN, pg_locks, innodb status</td></tr><tr><td>단기 완화</td><td style=text-align:right>프로덕션 영향 최소화</td><td>FOR UPDATE / advisory lock / 카나리아 격리</td><td>SQL 변경, App lock</td></tr><tr><td>근본 해결</td><td style=text-align:right>재발 방지 설계 적용</td><td>version lock, DB 제약, SSI 적용</td><td>마이그레이션, 코드배포</td></tr><tr><td>운영·모니터링</td><td style=text-align:right>사전 탐지·자동화 대응</td><td>지표 채택 → 경보 → 정기 테스트</td><td>Prometheus, Grafana, APM</td></tr><tr><td>회복·감사</td><td style=text-align:right>복구·증거 확보</td><td>WAL/binlog 복구 → RCA → 문서화</td><td>pg_waldump, mysqlbinlog, CDC</td></tr></tbody></table><ul><li><p><strong>핵심 흐름</strong>: 탐지 → 재현·분석 → 임시완화 → 근본해결 → 모니터링 → 회복 (사후분석).</p></li><li><p><strong>운영 규칙</strong>: 프로덕션 변경은 항상 제한적 (카나리아)·모니터링 기반으로 수행하고, 근본 해결은 충분한 재현·테스트 후 단계적으로 롤아웃하라.</p></li></ul><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>Write Skew 는 실무에서 특히 위험한 동시성 버그다. 두 트랜잭션이 동일한 조건을 읽고 (예: " 이 병동에 on_call 이 있나?&rdquo;) 서로 다른 행을 변경하면, 각각의 로컬 판단은 옳지만 합쳐진 결과가 도메인 규칙을 위반할 수 있다. 예컨대 의사 A 와 B 가 각자 " 나만 off 처리하면 다른 사람이 남아있다 " 는 판단으로 동시에 off 를 처리하면 실제로는 아무도 남지 않는다.</p><p>기술적으로 SI(스냅샷 격리) 는 각 트랜잭션에 안정된 읽기 스냅샷을 제공하지만, 서로의 쓰기를 보지 못하므로 전역 불변식을 보장하지 못한다. 따라서 실무에서는 다음 중 하나 혹은 조합을 택한다.</p><ul><li><strong>직렬화 (Serializable)</strong>: DB 가 논리적 직렬화를 보장하지만 충돌 시 트랜잭션을 롤백하므로 재시도 비용 발생.</li><li><strong>비관적 락</strong>: 관련 리소스에 락을 걸어 문제를 예방하나 동시성·스루풋 손실과 데드락 위험 존재.</li><li><strong>애플리케이션 설계 변경</strong>: 불변식 경계를 좁혀 단일 행으로 묶거나 원자적 연산으로 처리하면 비용을 줄일 수 있다.</li><li><strong>분산 시스템 대책</strong>: 샤딩 경계 재설계나 Sagas 와 같은 보상 패턴을 통해 전역 일관성 요구를 낮추는 방법도 있다.</li></ul><p>결론적으로 현실적 운영에서는 <strong>SSI/2PL/스키마 개선/앱 락의 혼합 전략</strong>으로 안전성과 성능을 균형 맞춘다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>단계</th><th>작업 항목</th><th style=text-align:right>대상 (레벨)</th><th>구현 예시</th><th>장점</th><th>주의사항</th></tr></thead><tbody><tr><td>1</td><td>불변식 식별 및 우선순위화</td><td style=text-align:right>비즈니스/도메인</td><td>불변식 목록, 영향도 점수 (금전·안전성)</td><td>보호 우선순위 명확화</td><td>식별 누락 위험—리뷰 필요</td></tr><tr><td>2</td><td>인덱스·범위 설계</td><td style=text-align:right>DB 쿼리/스키마</td><td>인덱스 추가·쿼리 리팩토링, EXPLAIN</td><td>범위 노출 축소 → 위험 감소</td><td>인덱스 과다로 쓰기 비용 증가</td></tr><tr><td>3</td><td>방어전략 선택 (권장 조합)</td><td style=text-align:right>DB / App / Infra</td><td>DB: SERIALIZABLE/SSIApp: SELECT FOR UPDATE, sentinel rowInfra: Redis 분산락</td><td>불변식 보호 (여러 층의 보강)</td><td>성능 영향, 데드락·가용성 고려</td></tr><tr><td>4</td><td>재시도·멱등성</td><td style=text-align:right>애플리케이션</td><td>지수 백오프 + 지터, 멱등 토큰, max 3~5 회</td><td>충돌 시 자동 복구·사용자 영향 최소화</td><td>재시도 비용·UX 지연</td></tr><tr><td>5</td><td>관측·알람·튜닝</td><td style=text-align:right>운영/모니터링</td><td>지표: tx_latency, abort_rate, long_tx_count, undo_size</td><td>조기탐지·원인분석 용이</td><td>임계치 설정과 노이즈 관리 필요</td></tr><tr><td>6</td><td>테스트·검증</td><td style=text-align:right>QA/스테이징</td><td>재현 시나리오 (동시 트랜잭션 스크립트), 격리수준별 A/B 테스트</td><td>실제 영향 확인·정책 검증</td><td>스테이징이 프로덕션과 다를 수 있음</td></tr><tr><td>7</td><td>운영 룰북 작성</td><td style=text-align:right>운영팀/개발팀</td><td>deadlock victim 정책, 자동 rollback 기준 문서화</td><td>신속 대응·책임소재 명확화</td><td>룰 유지보수 필요</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th>단계</th><th>주제 범위</th><th>학습 목표</th><th>실습 (구체)</th><th style=text-align:right>평가 지표</th><th>권장 도구</th></tr></thead><tbody><tr><td>1 기초</td><td>ACID, Read Committed / Repeatable Read / Serializable, MVCC 개념</td><td>격리 수준과 이상 종류 이해</td><td>두 세션 동시 UPDATE 재현 (Lost Update)</td><td style=text-align:right>데이터 일관성 위반 여부</td><td>Postgres, MySQL</td></tr><tr><td>2 핵심</td><td>Serialization Graph, Write Skew, Phantom</td><td>읽기 - 쓰기 의존성 이해 및 재현</td><td>On-call Write Skew 시나리오 실행</td><td style=text-align:right>무결성 위반 재현 여부</td><td>Postgres(SI)</td></tr><tr><td>3 응용</td><td>SELECT FOR UPDATE, 가드 행, 트리거·제약</td><td>불변식 보호 패턴 적용 능력</td><td>FOR UPDATE 적용 후 재검증, 집계 행 모델 적용</td><td style=text-align:right>abort 률, P99, 무결성 유지</td><td>pgbench, EXPLAIN</td></tr><tr><td>4 고급</td><td>SSI, Predicate Lock, Index Range Lock, 분산 트랜잭션</td><td>고급 직렬성, 분산 불변식 설계</td><td>SSI 켜고 성능 비교, 분산 트랜잭션 (2PC) 시뮬</td><td style=text-align:right>throughput, abort rate, 운영 복잡도</td><td>OpenTelemetry, Jaeger, 2PC 툴</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th>단계</th><th>항목</th><th>목표</th><th>실습/과제</th><th>실무 연관성</th><th>비고</th></tr></thead><tbody><tr><td>기초</td><td>ACID/트랜잭션 시작/종료</td><td>트랜잭션 흐름 파악</td><td>BEGIN/COMMIT/ROLLBACK 실습</td><td>모든 서비스 필수</td><td>문서 숙지</td></tr><tr><td>기초</td><td>격리 수준 차이</td><td>이상별 차이 재현</td><td>Dirty/Lost/Non-repeatable 실습</td><td>디버깅용</td><td>EXPLAIN 병행</td></tr><tr><td>핵심</td><td>Write Skew 재현</td><td>SI 한계 직접 체감</td><td>의사 on-call 예제 (2TX)</td><td>예약/의료</td><td>SQL 스크립트 제공</td></tr><tr><td>핵심</td><td>Serialization Graph</td><td>사이클 탐지 이해</td><td>그래프 작성 연습</td><td>설계 검토 도구</td><td>수기 그래프/자동화 스크립트</td></tr><tr><td>응용</td><td>SELECT FOR UPDATE</td><td>읽은 집합 잠금 적용</td><td>적용 후 성능/무결성 비교</td><td>트랜잭션 보호</td><td>록 웨이트 관찰</td></tr><tr><td>응용</td><td>가드 행/집계 행</td><td>충돌 영역 축소</td><td>모델 변경 후 테스트</td><td>이벤트·카운터 시스템</td><td>CQRS 연계</td></tr><tr><td>고급</td><td>SSI 내부</td><td>충돌 검출 원리 학습</td><td>SSI 활성화로 비교 실험</td><td>고신뢰 시스템</td><td>Postgres SSI</td></tr><tr><td>고급</td><td>Predicate/Index Range Lock</td><td>범위 잠금 이해</td><td>INDEX 기반 갭락 실험</td><td>범위 쿼리 많은 시스템</td><td>인덱스 설계 병행</td></tr><tr><td>고급</td><td>분산 불변식 설계</td><td>전역 불변식 유지 전략</td><td>2PC/사건 소싱 시나리오</td><td>샤드된 시스템</td><td>conflict resolution 설계</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글)—(영어 풀네임, 약어)</th><th>정의 (간략)</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심</td><td>쓰기 스큐—(Write Skew)</td><td>동일 판단 기반의 분산 쓰기로 비즈니스 제약 위반</td><td>SI, RW 사이클</td><td>핵심 트랜잭션 직렬화/락 적용</td></tr><tr><td>핵심</td><td>팬텀—(Phantom)</td><td>범위 쿼리 결과 집합이 다른 트랜잭션으로 바뀜</td><td>Predicate/Range Lock, Gap Lock</td><td>범위 락/인덱스 설계, 트랜잭션 검증</td></tr><tr><td>핵심</td><td>스냅샷 격리—(Snapshot Isolation, SI)</td><td>시작 시점 스냅샷 읽기, WW 만 충돌 검사</td><td>MVCC, Write Skew 허용 가능</td><td>읽기 중심 워크로드 성능 최적화</td></tr><tr><td>구현</td><td>명시적 잠금—(Explicit Lock / SELECT FOR UPDATE)</td><td>쿼리 수준의 선점 락 제어</td><td>Lock granularity, Deadlock</td><td>민감 판단구간 락 적용</td></tr><tr><td>구현</td><td>2 단계 잠금—(Two-Phase Locking, 2PL)</td><td>락 확장/축소로 직렬성 보장</td><td>Predicate Lock, Phantom 방지</td><td>강한 일관성 트랜잭션에 적용</td></tr><tr><td>구현</td><td>갭/넥스트키 락—(Gap / Next-Key Lock)</td><td>인덱스 gap 잠금으로 범위 삽입 차단</td><td>Phantom 방지, 인덱스 의존</td><td>인덱스 기반 범위 보호 (InnoDB)</td></tr><tr><td>고급</td><td>SSI—(Serializable Snapshot Isolation, SSI)</td><td>SI 에 직렬성 위반 탐지 추가</td><td>Serializable, abort/retry</td><td>고성능과 정확성 균형 적용</td></tr><tr><td>운영</td><td>멱등성—(Idempotency)</td><td>동일 요청 반복시 결과 불변성 보장</td><td>재시도 정책, 외부 사이드이펙트</td><td>재시도 안전화, API 설계</td></tr><tr><td>운영</td><td>직렬성 격리—(Serializable Isolation)</td><td>모든 트랜잭션이 직렬 실행 결과와 동일</td><td>2PL, MVCC+SSI</td><td>금융·원장 등 최고 수준 보장</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/current/transaction-iso.html>PostgreSQL Documentation — Transaction Isolation</a></li><li><a href=https://dev.mysql.com/doc/>MySQL :: MySQL Documentation</a></li><li><a href=https://learn.microsoft.com/sql/>Microsoft SQL Documentation - SQL Server | Microsoft Learn</a></li><li><a href=https://notavoid.tistory.com/48>트랜잭션 격리 수준 완벽 가이드: 실무에서 만나는 문제와 해결법</a></li><li><a href=https://mag1c.tistory.com/547>[MySQL] Lost Update와 Write Skew</a></li><li><a href=https://pompitzz.github.io/blog/ComputerScience/DesigningDataIntensiveApplication/ch7.html>데이터 중심 애플리케이션 설계 Ch 7. 트랜잭션 | BLOG</a></li><li><a href=https://velog.io/@dlgurwls0529/concurrency-control-3-transaction-isolation-level>concurrency control 3 : transaction isolation level</a></li><li><a href=https://velog.io/@jeong_hun_hui/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90>트랜잭션의 동시성 문제를 알아보자</a></li><li><a href=https://hiege.tistory.com/entry/JPA%EC%9D%98-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD%EA%B3%BC-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%97%94%ED%8B%B0%ED%8B%B0%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90>JPA의 낙관적 락과 비관적 락을 통해 엔티티에 대한 동시성 제어에 대해 알아보자</a></li><li><a href=https://lion-king.tistory.com/entry/SpringJPATransaction-Write-skew-Phantom-1>(Spring/JPA/Transaction) 쓰기 스큐, 팬텀. Write skew, Phantom</a></li><li><a href=https://f-lab.kr/insight/transaction-isolation-levels-20241231>트랜잭션 격리 수준과 실무에서의 활용</a></li><li><a href=https://velog.io/@libienz/InnoDB%EC%9D%98-REPEATABLE-READ%EA%B0%80-PHANTOM-READ%EB%A5%BC-%EB%B0%A9%EC%A7%80%ED%95%98%EB%8A%94-%EC%9B%90%EB%A6%AC>InnoDB의 REPEATABLE READ가 PHANTOM READ를 방지하는 원리</a></li><li><a href=https://jw92.tistory.com/60>Spring JPA Transactional과 Transaction Isolation Level 격리수준 실습</a></li><li><a href=https://coding-review.tistory.com/304>Phantom Read 부정합문제 해결방안 In PostgreSQL, MSSQL Server</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-and-database-systems/>Data-and-Database-Systems</a></li><li><a href=https://buenhyden.github.io/tags/data-operations/>Data-Operations</a></li><li><a href=https://buenhyden.github.io/tags/transaction-management/>Transaction-Management</a></li><li><a href=https://buenhyden.github.io/tags/transaction/>Transaction</a></li><li><a href=https://buenhyden.github.io/tags/transaction-isolation/>Transaction-Isolation</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-anomalies/>Concurrency-Anomalies</a></li><li><a href=https://buenhyden.github.io/tags/write-skew/>Write-Skew</a></li><li><a href=https://buenhyden.github.io/tags/transaction-anomaly/>Transaction-Anomaly</a></li><li><a href=https://buenhyden.github.io/tags/snapshot-isolation/>Snapshot-Isolation</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/><span class=title>« Prev</span><br><span>Phantom Read</span>
</a><a class=next href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/dirty-read/><span class=title>Next »</span><br><span>Dirty Read</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>