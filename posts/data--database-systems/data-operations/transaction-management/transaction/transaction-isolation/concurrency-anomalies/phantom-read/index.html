<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Phantom Read | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Transaction,Transaction-Isolation,Concurrency-Anomalies,Database-Anomaly,Phantom-Read"><meta name=description content="팬텀 리드는 한 트랜잭션이 동일 조건으로 반복 조회할 때 다른 트랜잭션의 삽입·삭제로 결과가 달라지는 동시성 이상이다. SQL 표준의 SERIALIZABLE이 팬텀을 방지하며, 구현체는 키-범위 잠금, 프레디케이트 잠금 또는 스냅샷 기반 직렬화(SSI)로 대응한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Phantom Read"><meta property="og:description" content="팬텀 리드는 한 트랜잭션이 동일 조건으로 반복 조회할 때 다른 트랜잭션의 삽입·삭제로 결과가 달라지는 동시성 이상이다. SQL 표준의 SERIALIZABLE이 팬텀을 방지하며, 구현체는 키-범위 잠금, 프레디케이트 잠금 또는 스냅샷 기반 직렬화(SSI)로 대응한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-12T03:49:00+00:00"><meta property="article:modified_time" content="2025-09-12T03:49:00+00:00"><meta property="article:tag" content="Data-and-Database-Systems"><meta property="article:tag" content="Data-Operations"><meta property="article:tag" content="Transaction-Management"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Transaction-Isolation"><meta property="article:tag" content="Concurrency-Anomalies"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Phantom Read"><meta name=twitter:description content="팬텀 리드는 한 트랜잭션이 동일 조건으로 반복 조회할 때 다른 트랜잭션의 삽입·삭제로 결과가 달라지는 동시성 이상이다. SQL 표준의 SERIALIZABLE이 팬텀을 방지하며, 구현체는 키-범위 잠금, 프레디케이트 잠금 또는 스냅샷 기반 직렬화(SSI)로 대응한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":8,"name":"Phantom Read","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Phantom Read","name":"Phantom Read","description":"팬텀 리드는 한 트랜잭션이 동일 조건으로 반복 조회할 때 다른 트랜잭션의 삽입·삭제로 결과가 달라지는 동시성 이상이다. SQL 표준의 SERIALIZABLE이 팬텀을 방지하며, 구현체는 키-범위 잠금, 프레디케이트 잠금 또는 스냅샷 기반 직렬화(SSI)로 대응한다.","keywords":["Data-and-Database-Systems","Data-Operations","Transaction-Management","Transaction","Transaction-Isolation","Concurrency-Anomalies","Database-Anomaly","Phantom-Read"],"articleBody":" Phantom Read Phantom Read 는 한 트랜잭션이 같은 조건으로 반복 조회할 때, 다른 트랜잭션의 삽입·삭제로 인해 결과 행 집합이 달라지는 현상이다.\n예컨대 \" 잔여 재고가 0 이면 주문 허용 \" 을 검사할 때 다른 트랜잭션이 새 주문을 추가하면 최초 조건이 깨질 수 있다.\n전통적 2PL 은 키 - 범위 잠금으로 갭을 막아 phantom 을 예방하고, MVCC 기반 DB 는 **스냅샷 + 직렬화 (Serializable/SSI)**로 충돌을 감지해 해결한다. 하지만 강한 격리는 동시성·지연·교착 비용을 키우므로, 실무에서는 위험 쿼리를 먼저 식별하고 (업무 불변식), 범위 인덱스·명시적 락·트랜잭션 경계 재설계 또는 애플리케이션 레벨 보완을 조합해 적용하는 것이 현실적이다.\n핵심 개념 Phantom Read 는 같은 조건의 조회를 트랜잭션 내에서 두 번 실행했을 때, 다른 사용자가 중간에 행을 추가하거나 삭제해서 결과 수가 달라지는 문제다.\n집계·예약·범위 제약이 있는 비즈니스에서 오류로 이어지므로, 이를 막으려면 격리 수준을 높이거나 (Serializable), DB 의 범위 락 (next-key/gap lock) 을 사용하거나, 애플리케이션 쪽에서 버전 검사나 재시도 로직을 추가한다.\nMVCC 는 읽기 성능을 도와주지만 모든 직렬화 위반을 자동으로 해결하진 않는다.\n핵심 개념 (한글·약어) 정의 왜 중요한가 대표적 예방/대응 팬텀 리드 (Phantom Read) 동일 조건 재조회 시 행 집합이 INSERT/DELETE 로 변하는 현상 집계·범위 제약 무결성 파괴 Serializable, 범위 락 (next-key), 제약조건 더티 리드 (Dirty Read) 커밋되지 않은 데이터 읽기 신뢰 불가 데이터 사용 방지 필요 Read Committed 이상으로 회피 비반복 읽기 (Non-Repeatable Read) 같은 PK 재조회 시 값 변경 읽기 일관성 저하 Repeatable Read / SI 쓰기 스큐 (Write Skew) 서로 다른 행 기반 의사결정 후 커밋으로 규칙 위반 SI 에서 발생 가능한 직렬성 위반 Serializable / 명시적 락 MVCC (다중버전 동시성) 트랜잭션마다 스냅샷으로 읽기 제공 높은 읽기 동시성 제공 SI 기반, 추가 충돌관리 필요 넥스트키 락 (Next-Key Lock) 인덱스 레코드 + 앞 gap 락 범위 삽입 (팬텀) 차단 InnoDB gap/next-key locking 적용 팬텀 리드는 \" 범위 기반 \" 문제로, 단순한 행 업데이트와 달리 행의 존재 여부가 바뀌어 집계·제약에 직접 영향을 준다. 이를 제어하려면 격리 수준·DB 락 메커니즘·제약조건을 적절히 조합해야 하며, MVCC 사용 시에도 write skew 등은 별도 고려 대상이다.\n개념 관계와 상호 영향 표 출발 (원인) 작용 대상 (→) 목적/효과 (왜) 결과 (어떤 이상 제거/유지) 트랜잭션의 동시 INSERT/DELETE → 동일 조건 SELECT (다른 트랜잭션) 범위 결과 변경 (존재 여부 변경) Phantom Read 발생 가능 MVCC / Snapshot Isolation → 읽기 동작 스냅샷으로 읽기 일관성 제공 Dirty/Non-Repeatable/기본 Phantom 일부 감소, 그러나 Write Skew 잔존. Next-Key/GAP Lock (InnoDB) → 인덱스 범위 범위 내 삽입 차단 → 팬텀 예방 Phantom Read 억제 (대신 락 경합↑). Serializable 격리 → 트랜잭션 커밋 검증 직렬화 보장 (또는 재시도) 모든 이상 억제 (대가: 성능/재시도 비용). 애플리케이션 버전검사 → 쓰기 시점 충돌 탐지 후 재시도 팬텀 관련 비즈니스 규칙 보완 가능 핵심은 ’ 무엇이 (어떤 동작) → 무엇에 (어떤 대상) → 왜 (무슨 목적) → 결과 (어떤 이상을 억제/유지)’ 의 흐름을 명확히 해두면, 어떤 계층 (DB/락/애플리케이션) 에서 개입해야 할지 판단이 쉬워진다.\n개념·실무 적용 매핑표 ` 개념 실무에서 무엇을 (무엇을 적용) 어떻게 적용 (구체) 왜 (비즈니스 이유) Phantom Read 예약/범위 제약 무결성 확보 Serializable 또는 범위 락 (next-key), 유니크/체크 제약 병행 과예약·집계 오류 방지 Write Skew 다중조건 규칙 보존 명시적 락 또는 Serializable, 업무 규칙 분해 규칙 위반 (예: 온콜 인원 0 명) 방지 MVCC / SI 높은 읽기 동시성 유지 MVCC 기반 DB 사용, 중요한 쓰기 경로는 별도 처리 성능·스케일 고려 Gap/Next-Key Lock 범위 삽입 방지 인덱스 설계와 함께 범위 락 허용 (필요시) 팬텀 삽입 차단 애플리케이션 검증 추가 안전장치 버전컬럼 체크 + 재시도, 사전 유효성 검사 사용자 think-time 환경에서 실무적 유연성 제공 실무에서는 ‘DB 격리/락 ’ 만으로는 충분하지 않은 경우가 많아, 유니크 제약·애플리케이션 레벨 검증·재시도 정책을 조합해 현실적 무결성을 확보한다. 특히 예약·금융·집계 경로는 높은 우선순위로 강화해야 한다.\n기초 조사 및 개념 정립 Phantom Read 이해와 실무 대응 팬텀 리드는 같은 조건의 조회를 여러 번 했을 때 결과에 ’ 유령 (phantom)’ 처럼 새 레코드가 나타나거나 사라지는 문제다.\n예컨대 A 트랜잭션이 \" 잔액\u003c100 인 모든 계좌 \" 를 조회한 뒤 다른 트랜잭션이 조건을 만족하는 새 계좌를 삽입하면, A 트랜잭션이 같은 쿼리를 다시 실행했을 때 처음과 다른 행 수가 나온다.\n이 문제는 단순한 값 변경이 아니라 결과 집합의 추가/삭제가 발생하는 것이 핵심이다.\n해결하려면 범위 (프레디케이트) 단위로 보호하는 락 기법이나 데이터베이스의 직렬화 (Serializable) 를 사용한다.\nMVCC/Snapshot 만으로는 모든 케이스를 막지 못하므로, 실제 시스템에서는 격리 수준과 쿼리 설계를 함께 고려해야 한다.\n핵심 포인트 팬텀은 ’ 집합 변화 ’ 문제다.\nNon-Repeatable Read 는 동일 행의 컬럼 값이 달라지는 반면, Phantom 은 결과 집합에 _ 새로운 행의 추가/삭제 _ 가 발생한다. 범위 (Predicate) 락·다음 - 키 (Next-key) 락이 본질적 해결 수단이다.\n전통적 락 기반 DB 는 범위 락을 사용해 특정 조건 범위에 대한 삽입을 차단함으로써 팬텀을 방지한다. 격리 수준별 차이\n낮은 격리 수준 (Read Committed 등) 에서는 팬텀 발생 가능. Serializable(또는 DB 의 SSI 등 구현) 은 팬텀을 차단 (또는 충돌 검출 후 Abort) 한다. MVCC(스냅샷) 는 읽기 일관성을 제공하지만 _ 새로 삽입된 행이 결과에 나타나는 팬텀 _ 을 항상 막지 못한다 (구현·메커니즘에 의존). 실무적 완화책\n범위 쿼리를 변경 (예: 포괄적 인덱스 사용, 명시적 락) 하거나 트랜잭션 범위 좁힘, 필요 시 Serializable 적용. 또한 테스트로 재현 가능한 사례를 만들어 회귀 방지. Phantom Read 등장과 동시성 진화 팬텀 리드란?:\n같은 조건의 쿼리를 다시 실행했을 때 이전에 없던 (또는 사라진) 행이 보이는 현상.\n왜 문제인가?:\n집계·조건 로직의 일관성을 깬다—예: \" 잔액이 0 보다 작은 고객이 없다 \" 는 조건이 트랜잭션 간 달라질 수 있다.\n어떻게 해결해왔나?:\n처음엔 **락 (2PL)**으로 물리적 차단 → 이후 **격리 수준 (ANSI SQL-92)**으로 표준화 → 읽기 성능 개선을 위해 MVCC/SI 도입 → SI 의 일부 문제를 해결하기 위해 SSI 같은 검출/차단 기법 도입 → 분산 환경에서는 샤딩/리더/보상 패턴 병용.\n핵심 포인트:\n성능과 일관성 사이에서 균형을 맞추는 것이 핵심이며, 각 DBMS·환경에 맞춰 적절한 기법을 선택해야 한다.\n등장 배경 팬텀 리드는 프레디케이트 (조건) 기반의 조회와 그 범위에 대한 동시 변경 때문에 발생한다. 단일 행 잠금 (row lock) 은 이미 존재하는 행의 동시 수정은 막지만, 다른 트랜잭션이 새로운 행을 삽입하거나 삭제해 범위가 변하는 경우엔 충분하지 않다.\n따라서 데이터베이스 연구자들과 엔지니어들은 다음과 같은 요구에 의해 진화해왔다.\n읽기 성능을 희생하지 않으면서 일관성을 보장할 방법 범위/색인 기반의 변경을 안전하게 처리하는 방법 분산·대규모 환경에서 확장성을 확보하면서도 중요한 도메인의 정합성 유지 이 요구들이 2PL·MVCC·SI·SSI·샤딩 같은 기술 발전을 촉발했다.\n발전 과정 단계 핵심 기술/개념 등장 이유 (문제) 개선점 (무엇을 해결) 1 2PL (Two-Phase Locking) / 행·범위 락 동시 쓰기 충돌 및 일관성 보장 필요 트랜잭션 직렬화 보장 (범위 락으로 팬텀 방지 가능) 2 ANSI SQL-92 격리 수준 규정 (P1–P3) 이상 현상 표준화 및 선택 기준 필요 개발자·DBMS 간 기대 동작 표준화 3 MVCC (Multi-Version Concurrency Control) 읽기 경합으로 인한 성능 저하 해결 필요 읽기 일관성 제공, 읽기 성능/동시성 개선 4 Snapshot Isolation (SI) MVCC 기반에서 더 강한 읽기 일관성 요구 스냅샷 기반 읽기 제공 (많은 이상 제거) 5 SSI (Serializable SI) / 충돌 검출 SI 가 허용하는 일부 비직렬성 해결 필요 런타임 충돌 검출로 직렬성 보장 (더 강한 일관성) 6 분산 패턴 (샤딩, CQRS, Saga 등) 대규모 확장성 및 분산 일관성 요구 파티셔닝·비동기 보상으로 확장성 확보, 도메인별 정합성 유지 timeline title 팬텀 리드 등장과 동시성 제어 진화 2PL/락 : 1 SQL-92 격리 규정 : 2 MVCC 등장 : 3 Snapshot Isolation (SI) : 4 Serializable SI (SSI) : 5 분산 패턴(CQRS/Saga/샤딩) : 6 팬텀 문제는 \" 범위 기반 변경 \" 에서 발생하며, 이를 해결하기 위해 락 기반 (완전 차단) 에서 시작해 읽기 성능을 고려한 MVCC/SI 로 진화했고, SI 의 남은 취약점을 런타임 검출 방식 (SSI) 으로 보완했다. 마지막으로 분산·확장 요구는 파티셔닝·CQRS·보상 트랜잭션 같은 설계 패턴으로 문제를 완화한다.\n운영적 시사점: 특정 DBMS 의 구현 세부 (예: 어떤 격리 수준이 어떤 이상을 막는지) 를 반드시 확인하고, 비즈니스 민감도에 따라 직렬화 (또는 SSI) 수준을 적용하거나 하이브리드 패턴을 설계해야 한다.\nPhantom Read 문제와 해결 목적 총정리 Phantom Read 는 트랜잭션 A 가 같은 범위 질의를 반복했을 때 다른 트랜잭션 B 의 삽입/삭제로 결과가 달라지는 현상으로, 집계·재고·원장 등에서 심각한 오류를 일으킨다.\n왜 해결해야 하나:\n트랜잭션 내부 예측성·집계 정확성·비즈니스 불변성이 깨지면 금전적·운영적 손실 발생. 어떻게 해결하나 (직관):\n범위 잠금이나 Serializable 같은 강한 격리로 삽입/삭제 간섭을 차단하거나, MVCC+ 직렬화 충돌 감지로 문제 발생 시 트랜잭션을 되돌려 일관성을 지킨다. 팬텀 리드가 유발하는 문제들 문제 유형 구체적 증상 비즈니스 영향 범위 질의 비재현성 동일 트랜잭션에서 같은 질의 두 번 시 결과 변경 (새 행 추가/삭제) 집계 불일치, 중복 집계, 보고 오류 집계 오차 기간별/조건별 집계 결과가 트랜잭션 간 달라짐 결산·리포트 신뢰도 저하 불변식 위반 좌석 초과 판매, 이중 승인 등 금전적 손실, 규정 위반 트랜잭션 로그 불일치 트랜잭션 내부 데이터 상태 예측 불가 디버깅·감사 어려움 팬텀 리드는 ’ 범위 (조건) 기반 ’ 조회에서 발생하는 비재현성 문제로, 집계·원장·예약 시스템처럼 ’ 집계 결과의 정확성 ’ 이 중요한 영역에서 특히 치명적이다. 발생하면 단순한 값 오류를 넘어 비즈니스 로직 (예: 재고·금전 흐름) 전체의 신뢰를 무너뜨린다. 팬텀 리드 해결의 핵심 목적 목적 구체 목표 기대 효과 범위 질의 재현성 확보 트랜잭션 내 반복 조회 결과 고정 집계·리포트의 일관성 보장 불변식 보호 좌석/한도/동시성 규칙 유지 비즈니스 무결성 보장 (금전·규정) 예측 가능한 처리 트랜잭션 결과 예측 가능성 향상 디버깅·감사·운영 용이 선택적 성능 통제 필요한 트랜잭션만 강격리 적용 성능 - 일관성 균형 조정 목적은 단순히 ’ 이상 현상 제거 ’ 가 아니라 비즈니스 무결성 보장 + 집계 신뢰성 확보 + 운영 가능성 (테스트·감사) 향상이다. 필요 시 전체 시스템 성능을 희생하지 않고도 ’ 중요 트랜잭션 ’ 만 선택적으로 보호하는 운영 전략이 중요하다. 문제 ⇄ 목적 연계 표 문제 (증상) 대응 목적 어떻게 연계되는가 범위 질의 비재현성 범위 질의 재현성 확보 동일 질의의 결과 고정 → 집계 정확성 달성 집계 오차 예측 가능한 처리 정확한 집계 → 리포트/결산 신뢰성 확보 불변식 위반 불변식 보호 트랜잭션 레벨 무결성 검사로 비즈니스 규칙 유지 트랜잭션 로그 불일치 예측 가능한 처리 + 감사 용이성 일관된 트랜잭션 결과 → 디버깅·감사 가능 ’ 재현성 확보 ’ 가 모든 목적의 핵심 축이다. 재현성이 확보되면 집계 정확성·불변식 유지·운영상 감사·디버깅 등 모든 목적이 실현된다. 따라서 해결 방안은 항상 ’ 어떤 수준의 재현성 ’ 을 보장할지 (전체 트랜잭션/선택적 트랜잭션 등) 를 먼저 설계하는 것부터 시작해야 한다. Phantom Read 전제·대응 이해하기 팬텀 리드는 같은 트랜잭션 내에서 같은 조건으로 두 번 조회했을 때, 다른 트랜잭션의 삽입·삭제 때문에 결과가 바뀌는 현상이다. 이유는 데이터베이스가 개별 행만 잠그거나 읽기 스냅샷을 사용하면 ’ 범위 자체 ’ 의 변화를 막지 못하기 때문이다. 이 문제를 막으려면 범위를 잠그는 키 - 범위 락이나, 스냅샷 직렬화 (SSI) 또는 최고격리도 (Serializable) 를 사용하거나, 애플리케이션 쪽에서 쿼리 재설계 (명시적 락, 집계용 별도 테이블 등) 를 적용해야 한다.\nPhantom Read 전제·요구·대응 정리 전제 조건 (언제 발생하는가)\n범위 기반 조건을 사용하는 쿼리 (범위 검색, 집계, 페이징 등) 가 존재할 것. 두 개 이상 트랜잭션이 동시에 동일 범위에 접근하고, 적어도 하나가 삽입 또는 삭제를 수행할 가능성이 있을 것. DB 의 격리 수준/락 정책이 범위 변경을 차단하지 못할 것 (예: Read Committed, 일부 Repeatable Read 구현). 특징 (그런 특징이 나타나는 근거)\n범위 질의는 \" 집합 \" 을 대상으로 하므로, 개별 행 (row) 단위 잠금만으로는 범위 밖에서 새로 생성된 행을 통제할 수 없다. 이로 인해 최초 쿼리의 결과셋과 이후 쿼리의 결과셋이 달라짐. (근거: 락의 범위와 갭 (gap) 문제) MVCC 기반 DB 는 읽기 시점에 스냅샷을 제공해 읽기 블로킹을 피하지만, 삽입된 레코드는 스냅샷에 포함되지 않아 후속 조회 결과가 달라질 수 있다. 스냅샷만으로 팬텀을 완전 방지하지 못하는 이유다. (근거: MVCC 의 스냅샷 타이밍) 키 - 범위 락 (next-key) 이나 predicate locking 은 **범위 자체 (갭)**를 잠금으로써 삽입/삭제를 막아 팬텀을 방지한다. (근거: 락의 확장성/범위 개념) 등장 이전 관련 기술과 차별점\n행 (row) 락 / 단일 레코드 잠금: 개별 행 보호는 가능하지만 범위 삽입/삭제는 막지 못한다 → 팬텀 취약. 키 - 범위 락 (Next-Key Lock): 행 락 + 갭 락을 결합하여 범위 삽입을 차단 → 팬텀 방지 (단점: 병행성 저하). Predicate Locking(프레디케이트 락): 쿼리의 조건 (프레디케이트) 자체를 잠금으로 표현—이론상 더 정밀하지만 구현이 복잡. MVCC + SSI(스냅샷 기반 직렬화): 스냅샷 기반으로 트랜잭션 간 의존성을 추적해 직렬화 보장 (팬텀 포함)—병행성은 키 - 범위 락보다 상대적으로 좋으나 구현 복잡도·오버헤드 존재. Serializable 격리 (강한 락 또는 검증 기반): 가장 강력한 무결성 보장. 구현 방식에 따라 성능 영향이 크다. Phantom Read 전제·요구사항 요약표 전제·요구사항 구체 내용 왜 (근거) 운영 시 징후 / 실무 고려사항 범위 기반 조건의 존재 WHERE amount BETWEEN …, WHERE date \u003c … 등 범위 연산은 집합 변화 (삽입/삭제) 에 민감 집계값·페이지네이션 결과 변화 관찰 동시 쓰기 트래픽 동시 삽입/삭제 또는 배치 삽입 가능성 동시 삽입이 있으면 최초 쿼리와 결과 불일치 높은 동시 INSERT/DELETE 비율, 배치 시간대 체크 격리 수준 설정 DB 가 Read Committed/Repeatable Read 등으로 동작 일부 격리 수준은 팬텀 방지 불충분 격리 수준 문서 확인, 엔진별 구현 차이 주의 락 범위/정책 행 락만인지, 갭 락 (Next-Key) 지원인지 여부 행 락만으론 갭 삽입 차단 불가 DB 의 락 정책 확인 (Next-Key 지원 여부) MVCC/스냅샷 동작 스냅샷 생성 시점과 커밋 처리 방식 스냅샷은 삽입된 새 레코드 미포함 가능 MVCC 동작 문서 검토 필요 성능·무결성 트레이드오프 성능 저하 허용 범위와 무결성 요구도 키 - 범위 락/Serializable 은 병행성 저하 비즈니스 우선순위에 따라 선택 핵심은 ’ 범위 질의 + 동시 삽입/삭제 ’ 라는 조합이 팬텀을 만든다는 것. 운영자는 해당 쿼리 패턴이 존재하는지 먼저 찾고 (예: 페이징, 집계 쿼리), 동시 쓰기 부하와 DB 의 락·스냅샷 동작을 점검해야 한다. 무결성이 절대적으로 필요하면 키 - 범위 락이나 Serializable/SSI 를 선택하되 병행성 저하를 감수해야 하고, 성능 우선이면 애플리케이션 레벨에서 쿼리 재설계 (명시적 잠금, 집계 캐시 등) 를 고려하라.\nPhantom Read 의 핵심 이해와 대응 Phantom Read 는 트랜잭션 A 가 어떤 조건으로 조회 (예: WHERE price \u003e 100) 한 뒤 같은 트랜잭션에서 다시 조회했을 때, 트랜잭션 B 가 그 사이에 새 행을 삽입하거나 삭제해서 결과 행 수나 목록이 달라지는 문제다.\nNon-repeatable Read 는 같은 행의 값이 바뀌는 문제라 다르다. 전통적 잠금 (2PL) 의 키 - 범위 잠금은 삽입을 막아 phantom 을 예방하고, MVCC 기반 DB 는 스냅샷 + 직렬화 (SSI/Serializable) 로 런타임 충돌을 잡아내는 방식으로 해결한다.\n강한 격리는 정확성을 올리지만 동시성·지연·교착 비용이 늘어나므로, 실무에서는 위험 쿼리 식별→범위 인덱스 확보→격리/락 정책·트랜잭션 경계 재설계를 조합해 적용한다.\nPhantom 핵심특징과 기술 비교 존재 집합 변화가 핵심\n설명: Phantom 은 행의 * 존재 여부 (출현/소멸)* 가 달라지는 문제. 기술 근거: SQL 표준과 DB 문서에서 Phantom 을 ’ 집합 변화 ’ 로 정의. 차별점: Non-repeatable Read 는 동일 행의 값 변경 (수정) 에 국한된다. 범위 (프레디케이트) 기반 쿼리에서 발생\n설명: SELECT … WHERE 같은 조건 스캔 시 new/delete 가 문제. 기술 근거: 갭 잠금/next-key 잠금은 인덱스 범위 스캔에 적용되어 phantom 을 방지. 차별점: 단일 행 잠금만으로는 삽입 (phantom) 을 차단 불가 → 범위 잠금 필요. DBMS 별 해결 방식 차이 (락 vs MVCC+ 직렬화)\n설명: 2PL(범위 락) vs MVCC+SSI(스냅샷 + 충돌검사). 기술 근거: MySQL/InnoDB 는 next-key lock 을, PostgreSQL 은 SSI 를 통해 직렬화 보장. 차별점: 락은 예측 가능한 차단 (하지만 동시성 저하), SSI 는 낙관적 충돌감지 (하지만 재시도 가능성). 인덱스 구조가 영향\n설명: 범위 인덱스가 없으면 테이블 스캔으로 광범위 잠금·성능 저하. 기술 근거: 갭 잠금은 인덱스 스캔 시 적용되므로 인덱스 설계 중요. 차별점: 잘 설계된 인덱스는 잠금 범위를 좁혀 비용을 줄인다. 정합성·성능의 트레이드오프가 큼\n설명: 격리 수준을 올리면 정확성↑, 동시성↓·지연↑. 기술 근거: SQL 표준·DB 문서의 격리 수준 비교 및 교과서적 설명. 차별점: 비즈니스 민감도에 따라 정책 선택 (금융은 강한 일관성 선호). Phantom 특성·기술 근거 비교표 핵심 특징 기술적 근거 실무적 차별점 (대응 방식) 존재 집합 변화 SQL 표준·DB 문서: phantom = 행 출현/소실. Non-repeatable read(값 변화) 와 구분 범위 기반 발생 인덱스 스캔/프레디케이트 쿼리에서 삽입·삭제가 문제 단일 행 락으론 방지 불가 → 범위 잠금 필요 갭/next-key 잠금 InnoDB next-key: 레코드 락 + gap 락 적용. 강력하지만 데드락·지연 부하 유발 MVCC + SSI PostgreSQL SSI: 스냅샷 읽기 + 직렬화 충돌 검출. 락 의존성 낮음, 충돌시 재시도 필요 인덱스 의존성 인덱스 없으면 테이블스캔→광범위 잠금·비용 증가. 인덱스 설계로 잠금 범위 최소화 가능 성능·정합성 트레이드오프 격리 강화 → 정확성↑ / 동시성↓·지연↑. 업무 민감도 따라 정책 결정 필요 Phantom 은 범위 쿼리에서 행의 존재가 바뀌어 결과가 달라지는 문제로, 해결책은 DBMS 의 동시성 제어 방식 (범위 락 vs MVCC+ 직렬화) 에 의해 달라진다. 인덱스 설계·트랜잭션 경계·격리 정책의 조합으로 비용을 최소화하면서 정합성을 확보해야 한다.\nPhase 2: 핵심 원리 및 이론적 기반 팬텀리드 방지 원칙과 설계전략 팬텀 리드는 트랜잭션 중 같은 조건으로 조회했을 때 다른 트랜잭션이 새 행을 만들거나 삭제해서 결과 행이 달라지는 문제다.\n이를 막으려면\n결과가 어떤 순차 실행과 동일하게 나오도록 보장하는 직렬 가능성 (Serializable) 을 확보하거나, 조건 자체를 보호하는 범위/프레디케이트 락을 사용하거나, 애플리케이션 차원에서 버전 검사·제약·재시도 로직을 조합해 위험을 보완해야 한다. 실무에서는 성능·무결성의 균형을 맞추기 위해 민감 경로만 엄격 처리하고 나머지는 경량 대책을 쓰는 방식이 일반적이다.\n팬텀리드 핵심 원칙 정리표 핵심 원칙 설명 목적 왜 필요한가 적용 예시 직렬 가능성 (Serializability) 동시 실행 결과가 어떤 순차 실행과 동일하도록 보장 모든 동시성 이상 제거 전역 규칙 (집계·제약) 안전 보장 Serializable 격리 적용 조건 보호 (Predicate Protection) WHERE 조건 (범위) 을 잠그거나 검증 동일 조건 재조회에서 결과 안정화 팬텀 (행 존재 변화) 직접 방지 범위 락 (next-key)/프레디케이트 락 최소 트랜잭션 범위 불필요한 연산을 트랜잭션 밖으로 분리 락 시간·충돌 창 축소 성능·동시성 개선 외부 I/O 비동기화 혼합 전략 적용 MVCC·락·애플리케이션 검증 조합 성능과 무결성의 균형 각 기법의 한계 보완 MVCC + 버전검사 + 범위락 핵심은 ’ 무엇을 전부 막을지 ‘(직렬화) 와 ’ 어느 범위를 반드시 보호할지 ‘(조건 보호) 를 명확히 한 뒤, 성능을 지키기 위해 트랜잭션 범위를 줄이고 여러 기법을 조합하는 것이다.\n팬텀리드 설계 철학 정리표 설계 철학 설명 목적 왜 필요한가 실무 적용 포인트 방어적 설계 여러 계층에 걸쳐 중복 방어선 배치 한 계층 실패시 안전망 역할 운영환경 불확실성 대응 DB 제약 + 앱 검증 병행 최소 락 원칙 필요한 최소 범위만 잠금 동시성 유지, 대기 최소화 과도한 락은 병목 초래 행/범위 최소화, 빠른 커밋 선택적 엄격화 민감 경로만 강화 전체 성능 유지하면서 핵심 보호 비용 - 편익 최적화 결제·예약 경로 우선 엄격화 관찰 기반 운영 지표로 정책 동적 조정 현실 워크로드에 맞춘 최적화 설계 가정과 현실 차이 보정 충돌률 기반 자동화/알람 설계 철학은 \" 어디에 비용을 쓸 것인가 \" 의 문제다. 핵심 무결성에는 비용을 들이고, 나머지는 경량·관찰 기반으로 운영해 효율을 높이는 접근이 실무에선 효과적이다.\nPhantom Read: 원리·탐지·방지 전략 팬텀 리드는 같은 조건으로 쿼리를 여러 번 실행할 때 결과 집합(레코드의 존재 여부) 이 달라지는 문제다.\n예: 트랜잭션 A 가 SELECT * FROM orders WHERE amount \u003c 100 을 두 번 실행하는 사이에 트랜잭션 B 가 조건에 맞는 새 주문을 INSERT 하면 A 의 두 번째 조회에서 그 새 행이 ’ 유령’ 처럼 보인다.\n이를 방지하려면 범위 단위로 삽입/삭제를 차단(키- 범위 락 또는 predicate lock) 하거나 데이터베이스 수준에서 **직렬성(Serializable/SSI)**을 선택해 충돌을 탐지·차단해야 한다.\n단, 이런 보호는 성능 비용을 유발하므로 쿼리·인덱스 설계와 함께 적절히 선택해야 한다.\nPhantom Read 방지 메커니즘 비교표 메커니즘 어떻게 동작하는가 장점 단점 팬텀 방지 여부 키- 범위 / 넥스트키 락 (2PL) 인덱스 스캔 범위와 그 사이의 gap 까지 잠궈 다른 트랜잭션의 삽입 차단 확실한 범위 차단 락 대기·데드락·동시성 저하 방지 Predicate Locking (논리적 범위 락) 쿼리 조건(술어) 에 해당하는 논리적 범위를 잠금 직관적 범위 보호 구현 복잡성(일부 DB 만 지원) 방지 MVCC(스냅샷 읽기) 트랜잭션별 읽기 스냅샷으로 값 안정화 읽기 성능 우수 새 삽입 제어 불가 → 팬텀 발생 가능 부분적(완전 방지 아님) SSI(Serializable Snapshot Isolation) MVCC 위에서 충돌(의존성) 탐지 → 직렬성 보장(충돌 시 Abort) 직렬성 보장(스냅샷 장점 유지) 충돌 탐지 비용, 재시도 발생 방지(검출·차단) 쿼리/인덱스 리팩터링 조건을 더 구체화하거나 인덱스 사용으로 범위 고정 성능 및 예측 가능성 향상 모든 케이스에 적용 불가 간접적 예방 핵심은 \" 범위(프레디케이트) 를 어떻게 제어하느냐\" 다. 전통적 락(키- 범위, predicate) 은 직접적으로 삽입을 막아 팬텀을 차단하지만 동시성 비용이 든다. MVCC 는 읽기 성능을 보장하지만 삽입 제어가 약해 팬텀이 발생할 수 있으며, 이 경우 SSI 같은 충돌 탐지 기법으로 보완한다. 실무에서는 쿼리·인덱스 설계, 락 사용과 직렬화의 성능 트레이드오프를 고려해 혼합 적용한다.\nPhantom Read 발생·방지 흐름도 flowchart TD A[\"트랜잭션 A: SELECT (조건 P)\"] --\u003e B[트랜잭션 B 발생?] B --\u003e|B: INSERT/DELETE 조건 P에 부합| C[트랜잭션 B 커밋] C --\u003e D[트랜잭션 A: 동일 SELECT 재실행] D --\u003e E{결과셋 변화?} E --\u003e|예: 신규 행 포함| F[팬텀 발생] E --\u003e|아니오| G[No Phantom] %% 방지 분기 A --\u003e H{방지 전략 적용 여부} H --\u003e|키-범위 락| I[트랜잭션 B의 INSERT 차단 -\u003e No Phantom] H --\u003e|Serializable/SSI| J[\"충돌 탐지시 B 또는 A Abort -\u003e No Phantom(또는 재시도)\"] H --\u003e|MVCC만| K[스냅샷으로 값 안정화하지만 삽입 통제 불가 -\u003e Phantom 가능] H --\u003e|쿼리/인덱스 개선| L[범위 고정/인덱스 사용 -\u003e 삽입 가능성 축소] style F fill:#ffe6e6,stroke:#ff3333 style I fill:#e6ffe6,stroke:#33aa33 style J fill:#e6ffe6,stroke:#33aa33 style K fill:#fff3cc,stroke:#ff9900 트랜잭션 A 가 조건 P 로 SELECT 를 수행한다. 그 사이 트랜잭션 B 가 조건 P 에 맞는 INSERT/DELETE 를 수행하고 커밋하면, A 가 재조회할 때 결과 집합이 바뀔 수 있다(팬텀 발생). 방지책으로는 (a) 키 - 범위 락으로 B 의 삽입을 막거나, (b) Serializable/SSI로 의존성 충돌을 탐지해 트랜잭션 중 하나를 Abort 시키는 방법, (c) 쿼리·인덱스 개선으로 범위를 고정해 삽입 가능성을 줄이는 방법이 있다. MVCC 만 사용하면 읽기값은 스냅샷으로 안정되지만 삽입 자체를 막지 못하면 팬텀이 발생할 수 있다. 따라서 MVCC 환경에서도 필요한 경우 범위 제어 또는 SSI 같은 보강이 필요하다. Phantom Read: 흐름·대응·생명주기 트랜잭션 A 가 SELECT * FROM T WHERE cond 를 실행한다. 트랜잭션 B 가 같은 조건에 해당하는 새 행을 삽입(혹은 삭제) 하고 커밋한다. 트랜잭션 A 가 동일 쿼리를 재실행하면, 이전에 없던 행이 나타나거나 사라져 결과가 달라진다. 이 현상이 Phantom Read. 해결책은: (a) 범위 잠금, (b) 높은 격리 수준(Serializable/SSI), (c) 설계적 완화(샤딩·CQRS·집계 컬럼) 중 적절히 선택하는 것. Phantom Read: 흐름과 대응 포인트 핵심 흐름:\n트랜잭션 A: BEGIN; SELECT … WHERE P; (스냅샷 또는 읽기 시점 확보) 트랜잭션 B: BEGIN; INSERT INTO … WHERE P satisfies; COMMIT 트랜잭션 A: SELECT … WHERE P; → 결과에 신규 행 포함 → 내부 일관성 위반 → Phantom 발생 대응 포인트:\n읽기 - 쓰기 충돌이 아니라 범위 삽입/삭제라는 점을 인지(따라서 행잠금만으론 부족). DB 레벨: predicate/range lock, next-key lock, SI/SSI, Serializable. 설계 레벨: 쿼리 범위 축소(파티셔닝), 집계 컬럼, CQRS 로 읽기/쓰기 분리. Phantom Read 흐름 표 단계 주체 DB 연산(예시) 의도/결과 문제 발생 지점 1 T1 (조회 트랜잭션) BEGIN; SELECT * FROM A WHERE balance \u003e 100 조건에 맞는 행 집합 읽음 — 2 T2 (변경 트랜잭션) BEGIN; INSERT INTO A(id,balance) VALUES(9,150); COMMIT 새로운 행 삽입 후 커밋 범위(프레디케이트) 변경 3 T1 SELECT * FROM A WHERE balance \u003e 100 (재조회) 결과 집합에 신규 행 등장 Phantom 발생(일관성 훼손) 4 대응(옵션) SELECT … FOR UPDATE / 범위 락 / SERIALIZABLE / SSI 재조회 시 일관성 보장 또는 충돌 검출 잠금 비용/성능 영향 트랜잭션 A 가 관찰한 범위가 트랜잭션 B 의 커밋으로 바뀌는 것이 핵심이다. 예방은 범위레벨 제어(락 또는 높은 격리) 또는 설계적 완화(파티셔닝·CQRS) 로 이뤄진다. Phantom Read 흐름도` flowchart TD Start([T1 시작: SELECT WHERE P]) T1_SELECT[\"T1: SELECT * WHERE P (스냅샷/읽기)\"] Parallel{동시 트랜잭션 T2 존재?} T2_INS[T2: INSERT/DELETE affecting P -\u003e COMMIT] Requery[T1: 동일 SELECT 재실행] Detection{결과 불일치?} Remedy1[범위 락 / predicate lock 적용] Remedy2[Serializable / SSI 격리 적용] Remedy3[설계적 완화: 파티셔닝 / CQRS / 집계 컬럼] End([종료: 일관성 보장/재시도/오류 보고]) Start --\u003e T1_SELECT --\u003e Parallel Parallel -- yes --\u003e T2_INS --\u003e Requery Parallel -- no --\u003e Requery Requery --\u003e Detection Detection -- yes --\u003e Remedy1 Detection -- yes --\u003e Remedy2 Detection -- yes --\u003e Remedy3 Detection -- no --\u003e End Remedy1 --\u003e End Remedy2 --\u003e End Remedy3 --\u003e End T1 이 범위 쿼리 (프레디케이트 P) 를 실행한 후, T2 가 같은 범위에 해당하는 삽입/삭제를 커밋하면 T1 의 재조회에서 결과가 달라질 수 있다. Detection 단계에서 불일치가 확인되면 세 가지 대응 중 하나 또는 조합을 선택하여 일관성을 확보한다: (1) 범위 락으로 물리적 차단, (2) Serializable/SSI 로 격리 수준 강화, (3) 파티셔닝/CQRS 등 설계 변경으로 범위 변경 가능성을 제거. 각 대응은 비용 (성능/복잡도) 이 다르므로 비즈니스 요건에 맞게 선택해야 한다. Phantom Read 생명주기 다이어그램 stateDiagram-v2 [*] --\u003e T1_Begin: T1 BEGIN T1_Begin --\u003e T1_Read: SELECT WHERE P (snapshot or current) T1_Read --\u003e Waiting: T1 작업 중 (기타 연산) Waiting --\u003e T2_Begin: T2 BEGIN (동시) T2_Begin --\u003e T2_Write: INSERT/DELETE affecting P T2_Write --\u003e T2_Commit: COMMIT T2_Commit --\u003e DB_State_Changed: DB 변경(범위 변경) DB_State_Changed --\u003e T1_Requery: T1 재조회 T1_Requery --\u003e Check: 결과 비교 Check --\u003e PhantomDetected: 불일치일 경우 Check --\u003e NoPhantom: 불일치 없을 경우 PhantomDetected --\u003e Action: 대응(락/직렬화/재시도/오류) Action --\u003e [*] NoPhantom --\u003e [*] 트랜잭션 간 시간축에서 T1 이 처음 읽은 후 T2 가 삽입/삭제를 하여 DB 상태가 변하면, T1 의 재조회에서 팬텀이 발생할 수 있다.\nSI 라면 T1 이 시작 시점 스냅샷을 유지해 ’ 재조회 시에도 같은 스냅샷 ’ 이 보일 수 있으나, 범위 삽입의 관점에서는 SI 구현 방식과 DB 의 쓰기 충돌 정책에 따라 결과가 달라진다.\n결과 불일치가 감지되면 설계·운영 차원에서 적절한 보상 (재시도·Rollback) 또는 예방 (격리 수준 상향/락 적용) 조치를 취한다.\n특성 분석 및 평가 팬텀 방지 기법의 가치와 실무 적용 팬텀을 방지하면 집계·리포트·원장 등에서 같은 트랜잭션이 반복 조회해도 항상 같은 결과를 보장할 수 있다. 이를 위해 사용할 수 있는 대표 수단 네 가지 (직렬화, 범위잠금, MVCC/스냅샷, DB 제약) 는 각기 **장점 (무결성·안정성)**과 **단점 (성능·복잡도)**이 있으므로, **중요도 (데이터 가치)**와 **트래픽 특성 (충돌 빈도/응답성 요구)**을 보고 선택한다. Phantom 방지 기법별 장점 표 장점 기술 근거 (메커니즘) 실무 효과 (비즈니스·운영) 적용 예시 주의점 직렬 가능 정합성 Serializable / SSI(직렬화 보장 또는 충돌 감지 후 롤백) 정산·감사 리스크 최소화, 완전한 일관성 보장 금융원장, 결제정산 성능 저하·재시도 로직 필요 범위 안전성 키 - 범위/Next-Key Lock(범위 삽입 차단) 과예약/중복 삽입 방지, 예약·재고 안전성 확보 항공 좌석, 예약 시스템 락 대기·교착 가능성 증가 스냅샷 읽기 안정성 MVCC / Snapshot Isolation(읽기 일관성 제공) 리포팅·장기 읽기 시 읽기 - 쓰기 충돌 감소 리포팅, 장기 조회 범위 삽입 팬텀은 격리 수준 의존 선언적 제약 보완 Unique, Check, 트리거 (도메인 규칙 강제) 애플리케이션 단순화·데이터 무결성 보강 유일키·고유제약·간단 불변식 복잡 집계 불변식엔 한계 각 기법은 서로 보완적이다. 직렬화 는 완전한 무결성을 제공하나 비용이 크고, 범위 잠금 은 특정 도메인 (예약 등) 에 효과적이지만 동시성 손실을 낳는다. MVCC 는 읽기 성능을 유지하면서 많은 읽기 - 쓰기 충돌을 줄여주지만, 팬텀을 완전 차단하려면 격리 수준이나 추가 메커니즘이 필요하다. 선언적 제약 은 기본적인 도메인 규칙을 강제해 실수로 인한 데이터 오류를 줄여준다. 따라서 **도메인 중요도 (금융 vs 로그)**와 **시스템 트래픽 특성 (충돌 빈도, 응답성 요구)**을 기준으로 혼합 적용하는 것이 실무상 최적이다. Phantom Read 단점·제약과 실무 대책 Phantom Read 를 방지하려면 강한 일관성을 위한 기법들이 필요하지만, 이들 기법은 성능 저하·락 경합·운영 복잡성 같은 단점을 동반한다.\n트랜잭션을 짧게 유지하고 (장기 트랜잭션 회피), 핵심 쿼리에만 격리 상향을 적용하거나 (부분적 적용), 인덱스·쿼리 최적화로 범위 락의 비용을 줄이는 것이 현실적 해법이다. 대규모 데이터나 높은 쓰기 부하 환경에서는 파티셔닝·CQRS·비동기 처리 같은 아키텍처 대안도 고려해야 한다.\nPhantom Read 관련 주요 단점 단점 설명 원인 실무 문제 완화/해결책 대안 기술 동시성 저하 강한 격리·범위잠금 사용 시 처리량 감소 트랜잭션 직렬화·범위 락 TPS 감소, 응답 지연 파티셔닝·트랜잭션 최소화·쿼리 최적화 MVCC(SSI), CQRS 락 경합·교착 잠금 충돌로 대기/교착 발생 락 순서 불일치·핫로우 롤백·재시도 증가 락 순서 표준화·타임아웃·재시도 정책 낙관적 제어 (OCC) 구현·운영 복잡성 락·격리 기법 튜닝·디버깅 난이도 DB 별 구현 차이·내부 메커니즘 복잡 설정 오류·성능 이슈 자동화·관측성·운영 가이드 Managed DB / 자동화 기능 강한 일관성을 보장하려 할수록 동시성·운영 복잡성이 증가한다. 따라서 실무에서는 핵심 도메인만 강격리를 적용하고, 대부분은 성능 최적화·원자 쿼리·낙관적 패턴을 우선 적용해 비용을 줄이는 전략이 바람직하다.\nPhantom Read 관련 주요 제약사항 제약사항 설명 원인 영향 해결 방안 대안 기술 트랜잭션 지속 시간 장시간 트랜잭션은 리소스 고정 복잡한 쿼리·외부 I/O 블로킹·버전/UNDO 팽창 트랜잭션 분해·리포트 분리 ETL/리플리카 리드 범위 락의 한계 (인덱스 의존) 범위잠금은 인덱스 기반으로만 효율 인덱스 미비 시 풀스캔 발생 광범위 락 → 성능 악화 인덱스 설계·커버링 인덱스 데이터 모델 변경 (NoSQL) DBMS 별 구현 차이 동일 격리명칭도 동작 불일치 표준 해석·역사적 구현 차이 이식성·테스트 복잡도 증가 엔진별 테스트·문서화 운영 표준화 / Managed DB 제약사항은 환경·데이터 모델·DB 선택으로부터 기인하므로, 설계 초기부터 데이터 분포 (핫키 여부), 쿼리 패턴, DB 엔진의 특성을 고려해야 한다. 인덱스와 트랜잭션 길이를 설계 요건에 맞추는 것이 가장 실효성 높은 완화책이다.\n격리·락 전략의 트레이드오프와 해법 격리 수준을 높이면 데이터 일관성은 좋아지지만 동시에 처리량과 응답 속도가 떨어지는 일이 흔하다.\n락 (비관적) 은 즉시 충돌을 막지만 기다림과 교착이 생기고, 낙관적 (버전검사/SSI) 은 빠르게 동작하다가 충돌될 때 롤백·재시도가 필요하다.\n실무에서는 핵심 트랜잭션만 강하게 보호하고 (선택적 직렬화), 나머지는 낙관적으로 운영해 두 방식의 균형을 맞춘다.\n정합성 Vs 동시성: 선택 비교표 선택 장점 단점 고려 기준 (언제 선택) 정합성 강화 (Serializable / FOR UPDATE) 이상현상 (phantom, lost update) 직접 차단 TPS 감소, 지연·데드락↑, 확장성↓ 금융·원장·회계 등 강한 무결성 요구 동시성 우선 (MVCC + 낙관적 재시도) 높은 동시성·스냅샷 읽기 성능, 락 경합 감소 충돌시 직렬화 오류·재시도 필요, 애플리케이션 복잡성 쓰기 충돌 낮은 워크로드, 대규모 읽기 중심 정합성 강화는 안전하지만 비용이 크고, 동시성 우선은 효율적이나 충돌 발생 시 후처리가 필요하다.\n실무에서는 두 극단 사이에서 워크로드 특성에 따라 적절히 섞어 적용 (핵심 트랜잭션만 강하게 보호 등) 하는 것이 일반적이다.\n부분적 교차 및 하이브리드 방법 하이브리드 기법은 트레이드오프 해소를 목표로 통상 다음 요소를 조합한다:\n선택적 직렬화, 낙관적 기본 + 비관적 폴백, 파티셔닝/샤딩, 운영 최적화 (읽기 전용 표시·풀 크기 제한). 방법은 특정 트레이드오프를 줄여준다.\n선택적 직렬화 (Selective Serializable)\n구성 요소: 트랜잭션 분류 (핵심 vs 비핵심), DB 레벨 또는 애플리케이션 레벨에서 격리 적용. 목적: 전체 TPS 희생 없이 핵심 데이터 정합성 보장. 장점: 정합성 확보 범위를 좁혀 비용 최소화. 고려사항: 트랜잭션 분류 정확성 필요, 운영·테스트 복잡성 증가. 낙관적 → 비관적 폴백\n구성 요소: 엔티티 버전 (ETag), 충돌 빈도 감지, 자동으로 FOR UPDATE 전환 규칙. 목적: 대부분의 경우 빠른 낙관적 처리, 충돌이 잦은 경로는 강제 락. 장점: 전체 성능 유지 + 충돌 경로 안전성. 고려사항: 경로 탐지 로직과 전환 비용, 복잡한 예외 처리. 파티셔닝/샤딩 기반 분리\n구성 요소: 샤드 키 설계, 라우팅, 로컬 트랜잭션 선호. 목적: 충돌 영역을 분리해 전역 직렬화 필요성 축소. 장점: 확장성 확보, 로컬 성능 향상. 고려사항: 복잡한 분산 트랜잭션, 핫스팟 관리 필요. MVCC(SSI) + 운영 최적화\n구성 요소: 읽기 전용 선언, 연결 풀 관리, 활성 트랜잭션 제한. 목적: SSI 의 재시도·오버헤드를 최소화. 장점: 스냅샷 읽기 성능 유지하면서 충돌 제어. 고려사항: 운영 정책 엄수 필요 (예: read-only 선언 누락 시 성능 저하). 부분적 교차·하이브리드 전략 비교 방법 구성 요소 적용 목적 장점 고려사항 선택적 직렬화 트랜잭션 분류 + 격리 정책 핵심만 강화해 비용 최소화 정합성 확보 + 전체 TPS 피해 감소 분류 오판 위험, 테스트 복잡성 낙관→비관 폴백 버전검사 + 자동 전환 규칙 충돌 경로만 락 처리 평소 성능 유지, 충돌 경로 안전 전환 기준·추적 필요 파티셔닝/샤딩 샤드 키, 라우팅 충돌 도메인 분리 확장성↑, 로컬 충돌↓ 핫스팟·분산 트랜잭션 복잡 MVCC+ 운영 최적화 read-only, 풀 제한 SSI 오버헤드 저감 스냅샷 읽기 유지, 충돌 감소 운영 규율·모니터링 필수 하이브리드 전략은 정합성 보장 범위를 좁히거나 충돌을 국지화함으로써 전체 성능 저하를 줄이는 실무적 해법이다.\n각 방법은 설계·운영 복잡성을 대가로 가져가므로 사전 분석·테스트·모니터링이 필수다.\n비즈니스 기반 팬텀 적용 결정표 팬텀 리드 문제는 특정 범위 (예: 특정 날짜 범위, 특정 조건) 의 데이터 집합이 트랜잭션 중간에 다른 트랜잭션으로 인해 바뀌는 것이다.\n핵심 질문은 \" 이 데이터의 일관성이 비즈니스적으로 얼마나 중요한가?\" 다.\n중요하면 Serializable 또는 범위 락으로 강하게 보호하고, 중요도가 낮고 충돌이 드물면 Snapshot Isolation 에 재시도 로직을 더해 성능을 유지한다. NoSQL 을 선택할 때는 DB 가 보장하지 못하는 제약을 애플리케이션이 어떻게 보완할지 미리 설계해야 한다.\n팬텀리드 적용 권장 매트릭스 적용 대상 (유스케이스) 권장 접근 방식 장점 단점/리스크 선택 기준 (언제 선택) 금융 결제·정산 (불변식 필수) Serializable / 범위 락 완전한 논리적 일관성 보장 성능 저하·재시도 증가 무결성 비용이 매우 큰 경우 예약·좌석·재고 (중요) 범위 락 또는 SI+ 엄격 검증 과예약 방지 (직렬화성 확보 가능) 락 경합·대기 발생 가능 동시 쓰기 빈도·핫스팟 여부 검토 집계 보고서 (일관성 중요) SI + OLAP 용 스냅샷, 혹은 배치 집계 읽기 성능 우수, 시점 일관성 제공 최신 데이터 반영 지연 가능 실시간성 필요성에 따라 결정 일반 로그·이력 데이터 (읽기 위주) Read Committed / Eventually Consistent 높은 처리량·낮은 비용 일관성 약화 허용 무결성 요구 낮음 분산/샤딩 환경 샤드 설계 + 애플리케이션 검증, 필요시 분산 락 수평확장 분산 트랜잭션 복잡성 샤드 범위에 제약 존재 시 신중 적용 충돌 드문 쓰기 (성능 우선) SI + 낙관적 락 (버전) + 재시도 높은 처리량·낮은 락 부담 재시도 코드 필요, 충돌 시 비용 충돌률이 낮을 때 핵심은 \" 비즈니스 손실 발생 가능성 (무결성 비용)\" 과 \" 실제 충돌 패턴 (충돌률·핫스팟)\" 을 기준으로 기술을 선택하는 것이다. 무결성 위험이 크면 성능 희생을 감수하고 강격리를 택하고, 그렇지 않으면 성능 쪽으로 기울이며 애플리케이션 레벨 보완을 적용한다.\n실무 적용 및 사례 실습 예제 및 코드 구현 실습 예제: 팬텀 재현과 방지 (PostgreSQL) 목적 RC/REPEATABLE READ 에서 팬텀/스냅샷 동작을 관찰하고, SERIALIZABLE(SSI) 에서 방지 확인 사전 요구사항 PostgreSQL 14+ / psql, 적절한 인덱스 단계별 구현 스키마 준비\n1 2 3 4 5 6 7 CREATE TABLE booking ( id SERIAL PRIMARY KEY, room_id INT NOT NULL, start_ts TIMESTAMP NOT NULL, end_ts TIMESTAMP NOT NULL ); CREATE INDEX ix_booking_room_time ON booking(room_id, start_ts, end_ts); 팬텀 후보 질의 (겹침 금지 체크)\n1 2 3 4 5 -- T1: 가용성 확인 (REPEATABLE READ) BEGIN ISOLATION LEVEL REPEATABLE READ; SELECT COUNT(*) FROM booking WHERE room_id=101 AND NOT (end_ts\u003c=:new_start OR start_ts\u003e=:new_end); -- 결과가 0이면 가용 동시 삽입\n1 2 3 4 5 -- T2: 새 예약 삽입 후 커밋 (겹침) BEGIN; INSERT INTO booking(room_id,start_ts,end_ts) VALUES(101, '2025-09-12 10:00','2025-09-12 11:00'); COMMIT; 재조회\n1 2 3 4 5 -- T1: 동일 조건 재조회 SELECT COUNT(*) FROM booking WHERE room_id=101 AND NOT (end_ts\u003c=:new_start OR start_ts\u003e=:new_end); -- Postgres REPEATABLE READ(SI): 스냅샷 고정 → 여전히 0(겹침을 못 봄) -- SERIALIZABLE로 실행 시 충돌 감지로 T1 또는 T2 중 하나가 에러로 롤백됨 방지: SERIALIZABLE + 재시도\n1 2 3 4 5 6 -- 애플리케이션 의사코드 RETRY: BEGIN ISOLATION LEVEL SERIALIZABLE; -- 동일 가용성 체크 + 삽입 -- … COMMIT; -- serialization_failure 발생 시 재시도 실행 결과 RR: 팬텀을 보지 않지만 쓰기 스큐 위험 SERIALIZABLE: 충돌 시 ERROR: could not serialize access due to concurrent update → 재시도로 정합성 보장 추가 실험 pg_locks 에서 SIReadLock 관찰, 인덱스 제거 후 경합 관찰 실습 예제: InnoDB Next-Key 로 범위 보호 (MySQL) 목적 REPEATABLE READ + 잠금 조회로 팬텀 방지 단계 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CREATE TABLE inventory ( sku VARCHAR(32) PRIMARY KEY, qty INT NOT NULL, price DECIMAL(10,2) NOT NULL, category INT NOT NULL, KEY ix_cat_price (category, price) ) ENGINE=InnoDB; -- T1 (RR): 가격대 범위 잠금 START TRANSACTION; SELECT * FROM inventory WHERE category=7 AND price BETWEEN 10 AND 20 FOR UPDATE; -- Next-Key로 범위+갭 잠금 -- T2: 동일 범위 신규 삽입 시도 → 블록 또는 대기 INSERT INTO inventory VALUES('N-001', 5, 12.00, 7); 결과 T2 가 커밋 전까지 대기/타임아웃 → 팬텀 방지 추가 실험 인덱스 제거 후 범위 잠금 확장과 경합 관찰 실습 예제: 팬텀 리드 발생 및 방지 실험 목적 팬텀 리드의 발생 원리와 Next-Key Lock 으로 방지하는 과정을 직접 체험. 사전 요구사항 MySQL 8.x(InnoDB) 설치 orders 테이블, 기본 트랜잭션 권한 단계별 구현 Step 1: 팬텀 리드 발생 테스트\n1 2 3 4 5 6 7 8 9 10 11 -- 트랜잭션 A START TRANSACTION; SELECT COUNT(*) FROM orders WHERE status='pending'; -- 결과 예: 5 -- 트랜잭션 B START TRANSACTION; INSERT INTO orders(status, amount) VALUES ('pending', 10000); COMMIT; -- 트랜잭션 A SELECT COUNT(*) FROM orders WHERE status='pending'; -- 결과 예: 6 (팬텀 리드 발생) Step 2: Next-Key Lock 을 통한 팬텀 리드 방지\n1 2 3 4 5 6 7 8 9 10 11 12 -- 트랜잭션 A START TRANSACTION; SELECT * FROM orders WHERE status='pending' FOR UPDATE; -- 트랜잭션 B START TRANSACTION; INSERT INTO orders(status, amount) VALUES ('pending', 20000); -- 대기 상태, 팬텀 리드 방지됨 -- 트랜잭션 A SELECT COUNT(*) FROM orders WHERE status='pending'; -- 변동 없음 COMMIT; 실행 결과 첫 예제: 트랜잭션 B 의 INSERT 결과가 트랜잭션 A 의 조건 검색에 새로 반영됨 (팬텀 리드). 두 번째 예제: Next-Key Lock 이 범위 내 신규 데이터 삽입을 차단, 결과 일치. 추가 실험 격리 수준 (Read Committed, Repeatable Read, Serializable) 변경해 트랜잭션 결과 비교. 장기/대량 트랜잭션에서 Lock 경합, 성능 변화 측정. 운영 및 최적화 Phantom Read 관측성 설계와 런북 운영에서 팬텀 리드를 잡으려면 트랜잭션 실행 시간, 락 상태, 직렬화 실패 (또는 앱에서의 serialization 예외), 특정 INSERT/DELETE 패턴, 리플리카 지연, 그리고 **쿼리 플랜 (인덱스 사용 여부)**를 함께 관측해야 한다.\n이들을 대시보드로 모아 p95 트랜잭션 시간, 락 대기, 직렬화 실패율 같은 알람을 설정하면 문제를 조기에 탐지하고, 런북 (세션 종료·마스터 강제 읽기·임시 격리 수준 변경) 으로 즉시 완화할 수 있다.\nPhantom Read 모니터링 분류 메트릭 (Metrics) 핵심 목적: 상태를 수치로 관측해 추세·이상 탐지.\n주요 항목: 트랜잭션 p95/p99 지연, 락 대기 평균·p95, 직렬화 실패율 (%), INSERT/DELETE 빈도 (조건별), 리플리카 지연 (ms).\n임계값 예시 (환경에 따라 조정):\n트랜잭션 p95 \u003e 5s → 경고 락 대기 p95 \u003e 2000ms → 경고 직렬화 실패율 \u003e 0.5% (전체 트랜잭션 대비) → 심각 리플리카 지연 \u003e 200ms → 주의 메트릭 목적 수집 위치/방법 예시 임계값 트랜잭션 지연 (p95) 긴 트랜잭션 탐지 DB pg_stat_activity / Query Store p95 \u003e 5s 락 대기 (p95) 범위 락/경합 탐지 pg_locks / performance_schema p95 \u003e 2000ms 직렬화 실패율 Serializable 실패 신호 DB 로그 / 앱 에러 코드 (40001) \u003e 0.5% INSERT 빈도 (조건별) 핫 인서트 감지 Slow query / perf schema 증가율 급증 감지 리플리카 지연 스테일 리드 탐지 replica status \u003e 200ms 요약: 메트릭은 조기 경보 역할. 수치 이상시 로그·트레이스로 원인 분석으로 넘어가라. 로그 (Logs) 핵심 목적: 구체적 오류·deadlock·serialization 메시지로 근본 원인 추적.\n수집 포인트: DB 서버 로그 (“could not serialize access” 등), InnoDB deadlock history, 앱 예외 로그 (재시도/40001).\n활용: 알람 시 샘플 로그 자동 수집 (최근 N 건) → 루트 원인 판별\n로그 유형 목적 수집 위치 활용 예 직렬화 실패 메시지 팬텀·직렬성 충돌 증거 Postgres log / app log 트랜잭션 ID 분석 Deadlock trace 락 충돌 상세 InnoDB status / SQL Server deadlock graph 리소스·쿼리 식별 Slow query sample 어떤 쿼리가 범위 스캔하는지 확인 slow query log / Query Store 인덱스 리팩터링 대상 선별 요약: 로그는 ’ 증거 ’ 다. 메트릭 알람과 함께 로그 샘플을 자동으로 집계하라. 트레이스/프로파일 (Traces) 핵심 목적: 요청 -DB- 트랜잭션의 end-to-end 흐름 이해.\n수집 포인트: APM(예: OpenTelemetry), DB 플레인 텍스트 트레이스, 쿼리 태깅 (트랜잭션 ID).\n활용: 어떤 API 가 어떤 쿼리를 호출하며 트랜잭션이 길어지는지 식별\n트레이스 항목 목적 수집 방법 활용 예 분산 트레이스 서비스→DB 호출 흐름 APM/OpenTelemetry 특정 API 가 긴 트랜잭션 유발 식별 쿼리 태그 트랜잭션 매핑 트랜잭션 ID 로깅 문제 트랜잭션 역추적 요약: 트레이스는 메트릭·로그를 연결하는 고리로, 재현 및 원인 규명 속도를 높임. 쿼리플랜·인덱스 검사 핵심 목적: 팬텀 방지 가능성 (범위 락 적용 여부) 사전 확인.\n수집 포인트: EXPLAIN/EXPLAIN ANALYZE, 자동화된 쿼리 검사 툴\n점검 포인트: 범위 쿼리가 인덱스를 타는지, 풀 스캔이 발생하면 범위를 잠그기 어렵다는 점\n점검 항목 목적 검사 방법 권장 조치 인덱스 사용 여부 범위 락 유효성 판단 EXPLAIN 인덱스 추가/쿼리 리팩터링 범위 조건 변경 predicate 고정화 쿼리 리팩터링 범위 잠금 가능성 증가 요약: 예방적 관점에서 가장 중요한 작업. 운영 도중 패치 전 반드시 점검. 알람·런북 (Alerts \u0026 Runbook) 핵심 목적: 이상 징후 발생 시 일관된 즉시 대응 수행.\n알람 예시: 트랜잭션 p95 초과, 직렬화 실패율 초과, 리플리카 지연 초과 등\n런북 요약 (우선 순위):\n알람 수신 → 관련 세션/쿼리 조회 영향 범위 판단 (영향 API/사용자) 단기 완화: 문제 세션 강제 종료 / 마스터에서 읽기 강제 / 트랜잭션 타임아웃 단축 근본 대책 적용 (쿼리 수정·인덱스·원자적 UPDATE·격리 수준 변경) 사후 분석·회귀 테스트 알람 유형 1 차 대응 2 차 대응 복구 검증 트랜잭션 p95 초과 문제 세션 식별/강제 종료 트랜잭션 범위 축소 패치 p95 정상화 확인 직렬화 실패율↑ 재시도 정책 점검 (앱) 임시 격리 조정/쿼리 수정 실패율 하락 확인 리플리카 지연↑ 세션 세팅으로 마스터 강제 읽기 복제 토폴로지 점검 리플리카 lag 정상화 요약: 알람은 자동화된 정확한 1 차 대응 (세션 종료·마스터 강제 읽기) 이 중요. 근본 패치는 별도 변경 프로세스로 진행. Phantom Read 모니터링 종합표 카테고리 주요 지표·로그 수집 위치/방법 알람 임계값 (예시) 즉시 대응 Metrics txn p95/p99, 락 대기 p95, 직렬화 실패율, INSERT 빈도, replica lag DB stat views, perf schema, app metrics p95 txn \u003e5s / lock p95 \u003e2s / 직렬화 실패 \u003e0.5% / replica lag \u003e200ms 세션 종료, 트랜잭션 범위 축소 Logs 직렬화 실패 메시지, deadlock trace, slow query samples DB logs, InnoDB status, app logs N/A (이벤트 기반) 샘플 수집 → 원인 분석 Traces 분산 트레이스, 쿼리→API 매핑 APM/OpenTelemetry, query tagging N/A (추적 기반) 문제 API 차단/트래픽 셰이딩 Query Plan EXPLAIN 결과 (인덱스 사용 여부) EXPLAIN/ANALYZE N/A (검사 필요) 인덱스 추가/쿼리 리팩터링 Alerts \u0026 Runbook 자동 알람 규칙, 대응 절차 Alerting system + Runbook 위 임계값 기반 마스터 강제 읽기, 임시 격리 변경 Phantom 보안·컴플라이언스 통제체계 팬텀 리드는 단순한 버그가 아니라 데이터 무결성 (Integrity) 관점의 보안·컴플라이언스 리스크다. 규제 민감 도메인 (금융·회계 등) 은 기술 (격리 설정, 락) 과 운영 (감사 로그, 접근 통제) 을 함께 설계해야 한다. 실무에서는 모든 트랜잭션에 강한 격리를 적용하기보다 리스크 기반으로 핵심 데이터에만 강제 적용하고, 나머지는 애플리케이션 방어·모니터링으로 보완한다. Phantom 보안·컴플라이언스 통제 분류 트랜잭션·무결성 제어 트랜잭션 수준에서 팬텀·갱신 손실을 방지하기 위한 제어들이다.\n적용 대상: 금융 거래, 회계 집계, 재고 변동 등 핵심 도메인 트랜잭션 주요 수단: 격리 수준 정책: 핵심 트랜잭션에 SERIALIZABLE 또는 SSI 적용 범위 락/next-key lock 사용 (지원 DB 에 한함) 원자적 SQL(조건부 UPDATE/INSERT) 사용으로 서버 측 연산 위임 DB 제약 (FOREIGN KEY, CHECK) 및 트리거로 논리 무결성 보강 구현 예 (요약): SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 또는 SELECT … FOR UPDATE 사용 통제 항목 목적 구현 예 격리 수준 강화 팬텀/비직렬성 방지 SERIALIZABLE / SSI 범위 락 프레디케이트 삽입 차단 next-key lock 원자적 SQL 네트워크 왕복·중간 상태 제거 UPDATE … SET v=v+? WHERE id=? 핵심: 핵심 도메인에는 DB 레벨에서 강한 격리·원자성 제어를 우선 적용하라. 카테고리 B: 접근·권한 관리 사용자 및 서비스의 권한을 최소화하고 역할을 분리하여 무단 변경을 방지한다.\n적용 대상: DB 관리자, 애플리케이션 서비스 계정, 배치/운영 스크립트 주요 수단: RBAC(역할 기반 접근 제어) 와 최소권한 원칙 적용 운영/개발/감사 계정 분리 및 임시 권한 발급 프로세스 세션·연동 인증 (예: Kerberos, OAuth2) 및 TLS 적용 구현 예: 권한 변경은 변경관리 티켓과 매핑, 권한 부여는 최소 권한 템플릿 사용 통제 항목 목적 구현 예 RBAC / 최소권한 권한 오·남용 방지 역할 템플릿, 정기 권한 리뷰 계정 분리 책임 분리 및 감사 용이 운영/개발/감사 계정 분리 인증·통신 보안 자격증명 탈취 방지 TLS, Kerberos 핵심: 권한은 최소화하고 변경 절차를 엄격히 관리해 누가 무엇을 변경했는지 증빙 가능하게 하라. 감사·증거 보관 팬텀 등 무결성 위반에 대한 증거 확보와 변조 방지를 위한 로그·기록체계.\n적용 대상: 모든 변경 이벤트, 범위 쿼리 결과 변화, 재시도/실패 이력 주요 수단: DB 감사 확장 (pgaudit, Oracle Audit) 활성화 CDC(Change Data Capture) 로 변경 히스토리 저장 로그 무결성: 서명, WORM 스토리지, HSM 기반 키 관리 보존 정책: 규제에 맞춘 보관 기간과 접근 통제 구현 예: 감사 로그는 별도 보관소에 적재하고 읽기 전용 보관 통제 항목 목적 구현 예 감사 로그 증거 확보 pgaudit, Oracle Audit CDC 변경 내역 추적 Debezium, AWS DMS 로그 무결성 변조 방지 로그 서명, WORM 핵심: 변경의 ’ 누가·언제·무엇을 ’ 증명할 수 있도록 로그와 변경 히스토리를 안전하게 보관하라. 모니터링·운영 대응 팬텀 관련 이상 징후를 조기에 탐지하고 운영적으로 대응하는 체계.\n적용 대상: 운영팀, SRE, 개발팀 주요 수단: 지표 수집: 충돌률, 재시도 횟수, 범위 쿼리 불일치 카운트 경보/대시보드: 임계치 초과 시 알림 및 자동화된 제한 (서킷브레이커) 정기 검증: 복구 연습, 재현 테스트, 회귀 테스트 구현 예: Prometheus + Grafana, 알림은 PagerDuty/Slack 연동 통제 항목 목적 구현 예 지표 수집 이상 조기탐지 충돌률/재시도 메트릭 자동 경보 신속 대응 PagerDuty 알림 복구 연습 복구능력 검증 정기 restore drill 핵심: 메트릭 기반으로 문제를 조기에 발견하고 절차화된 대응을 준비하라. 애플리케이션 방어·설계 애플리케이션에서 재시도·중복·보상 등으로 데이터 무결성을 보조하는 체계.\n적용 대상: API 레이어, 배치 작업, 메시지 처리 파이프라인 주요 수단: Idempotency keys 로 중복 요청 방지 재시도 정책: 지수 백오프 + 지터, 실패 시 보상 트랜잭션 조건부 업데이트 (WHERE version = x) + 재시도 루프 Saga 패턴 (분산 트랜잭션 보상) 구현 예: idempotency key 테이블, version 컬럼 기반 낙관적 락 통제 항목 목적 구현 예 Idempotency 중복 적용 방지 idempotency key 저장 재시도 정책 transient 충돌 복구 backoff+jitter 보상 트랜잭션 분산 정합성 확보 Saga 패턴 핵심: DB 통제만으로는 충분치 않다—애플리케이션 레벨에서 재시도·중복·보상을 설계하라. 규제·거버넌스 컴플라이언스 요구를 충족시키기 위한 문서화·검증·보고 체계.\n적용 대상: 리스크·규제 준수팀, 보안·감사 부서 주요 수단: 정책 문서화: 격리 정책, 보존 정책, 권한 정책 증거 준비: 감사 로그, 변경이력, 테스트 기록 정기 감사: 내부·외부 감사 준비 및 대응 프로세스 구현 예: 규제별 체크리스트 (PCI/SOX/GDPR) 와 매핑된 통제 매트릭스 통제 항목 목적 구현 예 정책 문서화 규제 대응 근거 통제 매트릭스 증거 보관 규제 감사 대응 감사 로그, 변경 이력 정기 감사 규정 준수 검증 내부·외부 감사 핵심: 기술 통제와 함께 문서·증거를 체계적으로 관리해 규제 요구를 만족시켜라. Phantom 관련 보안·컴플라이언스 요약표 카테고리 핵심 통제 목적 대표 구현 수단 트랜잭션·무결성 격리·범위락·원자적 SQL 팬텀/비직렬성 방지 SERIALIZABLE/SSI, FOR UPDATE, 조건부 UPDATE 접근·권한 관리 RBAC·최소권한 변경 권한 통제 역할 템플릿, 권한 리뷰 감사·증거 보관 감사 로그·CDC·무결성 보관 증거 확보·포렌식 pgaudit, CDC, 로그 서명 모니터링·운영 지표·경보·복구 연습 조기탐지·대응 Prometheus, 복구 드릴 앱 방어·설계 idempotency·재시도·보상 중복·충돌 안전화 idempotency key, Saga 규제·거버넌스 정책·감사 준비 규제 준수 통제 매트릭스, 감사 문서 팬텀 대응을 위한 성능·확장 전략 핵심 요지: 팬텀·동시성 문제를 막으려면 ’ 일관성 보장 ’ 과 ’ 성능/확장성 ’ 사이 균형을 맞춰야 한다.\n자주 업데이트되는 핵심 데이터는 트랜잭션을 짧게 하고 원자적 연산을 사용. 반복 조회가 많으면 레플리카/캐시로 읽기 분리. 데이터 규모가 성장하면 샤딩·파티셔닝과 키 분산으로 확장. 모든 전략은 트레이드오프 (지연·복잡도·재시도) 를 수반하므로 측정 (모니터링) 후 적용해야 안전. 팬텀 대비 성능·확장성 카테고리 데이터 모델 및 인덱스 내용: 쿼리 패턴을 우선 분석해 인덱스 설계 (복합 인덱스에서 선행 컬럼 = 범위 필터 우선, 통계 기반 컬럼 선택) 를 수행한다. 범위 검색이 많으면 범위 컬럼을 인덱스 앞쪽에 두지 않고, 대신 정렬/조인 패턴을 고려해 설계. 적절한 커버링 인덱스는 디스크 IO·잠금 범위를 줄여 성능 향상과 잠금 폭 축소 (팬텀 완화) 에 기여한다.\n구체적 권장:\n쿼리 로그에서 상위 slow query 추출 → 인덱스 후보 도출 복합 인덱스 설계 규칙: equality 칼럼 먼저, range 칼럼 뒤 인덱스 대신 물리적 파티션 (시계열 등) 고려 주의: 인덱스 과다 (쓰기 비용 증가) 와 핫스팟 (같은 인덱스 리프 집중) 을 균형있게 관리.\n항목 권장 조치 효과 인덱스 순서 Equality 먼저, Range 뒤 스캔·잠금 범위 감소 커버링 인덱스 SELECT 컬럼 포함 디스크 IO 감소, 읽기 빠름 파티셔닝 연계 날짜/해시 파티션 적용 스캔 파티션 축소, 병렬 처리 요약: 인덱스와 파티셔닝을 쿼리 패턴 기반으로 설계하면 범위 검색 비용과 잠금 범위를 줄여 팬텀 발생 가능성과 지연을 낮출 수 있다. 트랜잭션 설계·격리 최적화 내용: 트랜잭션을 가능한 짧게 유지하고, 읽기/쓰기 경계 (읽기 전용은 별도 처리) 를 정리한다. 격리 수준은 워크로드에 따라 선택 (READ COMMITTED → REPEATABLE READ → SERIALIZABLE). 필요 시 동적으로 높은 격리 (Serializable) 를 특정 트랜잭션에만 적용한다. 애플리케이션 레벨에서 낙관적 버전 체크를 포함해 충돌 시 재시도 로직을 설계한다.\n구체적 권장:\n트랜잭션 범위 최소화 (읽기→계산→짧은 쓰기) 낙관적 버전 검사 (버전컬럼) + 재시도 백오프 선택적 격리 강화: 중요한 트랜잭션만 SERIALIZABLE 로 실행 주의: 직렬화 적용 시 직렬화 오류 증가에 대비한 재시도 정책 필요.\n항목 권장 조치 효과 트랜잭션 길이 짧게 유지 (필요 최소 쿼리만) 락 시간·MVCC 스냅샷 최소화 격리 수준 상황별 선택적 강화 팬텀/비반복 읽기 완화 낙관적 검사 version 컬럼 + WHERE version =? 충돌 감지 → 재시도 처리 요약: 트랜잭션 설계를 경량화하고 필요 시에만 높은 격리를 적용하면 성능과 일관성 사이의 적절한 균형을 달성할 수 있다. 동시성 제어 (락 / MVCC / 원자화) 내용: 동시성 제어는 세부 전략 (비관적 락, MVCC, 원자적 연산) 으로 구현한다. 비관적 락은 범위 잠금 (next-key/gap lock) 으로 삽입을 차단해 팬텀을 방지한다. MVCC 는 읽기 일관성을 제공하지만 범위 삽입에 대한 보호는 격리 수준에 의존한다. 단일값·증감 연산은 원자적 SQL 로 처리해 충돌을 줄인다.\n구체적 권장:\n핫스팟엔 비관적 잠금 또는 분산락 적용 읽기 중심엔 MVCC + 낮은 격리로 성능 확보 간단 증감은 원자적 UPDATE 사용 주의: 락은 교착·대기 초래, MVCC 는 버전 보존 및 VACUUM 등 관리 비용 유발.\n항목 권장 조치 효과 비관적 락 SELECT FOR UPDATE / range lock 범위 삽입 차단, 팬텀 방지 MVCC 스냅샷 읽기 (읽기 성능) 읽기 - 쓰기 충돌 완화 원자 연산 UPDATE … = … + 1 충돌 최소화, 간단 안전 요약: 상황에 따라 락·MVCC·원자화를 조합하면 동시성 요구를 충족하면서도 팬텀을 제어할 수 있다. 핫스팟은 특별 처리 필요. 스케일 아웃 (샤딩·레플리카·캐시) 내용: 수평 확장으로 처리량을 늘리되 데이터 접근 패턴에 맞춘 파티셔닝·샤딩 설계가 핵심. 읽기 집중 서비스는 캐시·레플리카로 분산. 쓰기 집중·원자성 필요 작업은 샤드 경계 내에서 처리하도록 도메인 경계 설계. CQRS·이벤트 소싱 적용으로 읽기/쓰기 패스를 분리하면 확장성↑.\n구체적 권장:\n샤딩 키는 접근 패턴·균등 분포 기준 선정 읽기 레이어: 레플리카 + 캐시 조합 CQRS 적용 검토 (읽기 스케일과 쓰기 일관성 분리) 주의: 분산 트랜잭션 회피 설계 필요, 샤딩 재분배 비용 고려.\n항목 권장 조치 효과 샤딩/파티션 해시/범위 기반 샤딩 수평 확장, 병렬 처리 레플리카/캐시 읽기 분산, 캐시 계층 읽기 처리량 증가 CQRS/이벤트 읽기/쓰기 분리 확장성 향상, 복잡도 증가 요약: 확장은 데이터 분할과 읽기 분산이 핵심. 설계 실패 (핫스팟·재분배 비용) 는 오히려 병목 유발하므로 신중한 키 선정과 테스트가 필요하다. 운영·모니터링·테스트 내용: 성능과 일관성을 관리하려면 지표·알람·재현 테스트가 필수다. 주요 지표는 락 대기 시간, deadlock 빈도, 직렬화 오류 (제거해야할 충돌) 수, 재시도율, 트랜잭션 지연 분포, 레플리카 지연 (repl lag) 등이다. 재현 시나리오를 만들어 부하 상태에서 팬텀·직렬화 오류를 검증하고 재시도 정책을 검증한다.\n구체적 권장:\n모니터링: DB 락/txn metrics + 애플리케이션 재시도 로그 (예: Prometheus/Grafana 대시보드) 부하 테스트: 고충돌 시나리오 (동시 삽입/범위 조회) 로 재현 운영 정책: 재시도 횟수 제한, 지수 백오프, 긴 락 알림/자동화 조치 주의: 모니터링 수치만으로 결정하지 말고, 실제 재현 테스트와 결합해 정책 조정.\n지표 모니터링 항목 목표/임계값 예시 락 대기 avg lock wait ms \u003c 100ms (서비스 특성에 따라 조정) deadlock deadlocks / min 0 (허용치 낮게) 직렬화 오류 serializable failures / min 낮게 유지, 재시도율 모니터링 repl lag replica lag seconds \u003c 1s (강일관성 요구시) 요약: 모니터링 + 재현 테스트 + 정책 (재시도·알림) 이 성능·일관성 운영의 핵심이다. 수치와 재현 결과를 통해 전략을 점진 적용하자. 팬텀 대비 핵심 전략 통합표 카테고리 핵심 전략 기대 효과 주의사항 데이터 모델/인덱스 복합 인덱스 (Equality 앞), 파티셔닝 I/O·잠금 범위 감소, 쿼리 성능 개선 인덱스 과다·쓰기 비용 트랜잭션 설계 짧은 트랜잭션, 낙관적 검사, 선택적 격리 강화 락 시간 최소화, 충돌 재시도 처리 직렬화 오류·재시도 비용 동시성 제어 비관적 락/MVCC/원자 연산 조합 팬텀·삽입 충돌 차단, 읽기 성능 확보 락 대기·버전 관리 비용 스케일 아웃 샤딩·레플리카·캐시·CQRS 처리량 수평 확장, 읽기 분산 샤드 설계 실패·복잡성 증가 운영·모니터링 락/직렬화 오류/재시도 지표 모니터링 조기 탐지·정책 기반 대응 지표 기반 오판 주의, 재현 필요 팬텀 리드 예방·해결 종합전략 현상 인식:\n동일 쿼리 (보통 범위나 집계) 를 같은 트랜잭션 내에서 두 번 실행했을 때 결과가 달라진다 → 집계 수치 변화, 중복/누락 레코드 의심. 원인 확인 체크리스트:\n동시성 높은 작업? 장기 트랜잭션? 인덱스가 범위 스캔을 유발? DB 격리 수준은? 빠른 대응 (단기):\n트랜잭션을 짧게 유지, 문제 쿼리에 대해 일시적으로 높은 격리 수준 적용 (테스트 환경 먼저), 재시도 로직 추가. 근본 대응 (중장기):\n격리 수준 설계 (워크로드에 맞는 전략 선택), 인덱스/쿼리 재설계, 범위락/SSI 도입 검토. 운영·모니터링:\nDeadlock/lock-wait/long-transactions/undo tablespace 모니터링 및 알람, 재생성 가능한 테스트 케이스로 재현 및 검증. 팬텀 리드 트러블슈팅 핵심 카테고리 원인 분석 및 탐지 목표: 팬텀 리드가 발생하는 구체적 원인을 찾아 재현 가능한 증거 (쿼리·트랜잭션 시퀀스·타임라인) 를 확보한다.\n주요 점검 항목:\n문제 쿼리의 유형 (범위 쿼리, 집계, COUNT 등) 확인 동시성 수준 (동시 트랜잭션 수, 빈도) 확인 트랜잭션 길이 (커밋까지 걸리는 시간) 확인 DB 격리 수준 설정 확인 인덱스 존재 여부 및 사용계획 (EXPLAIN) 확인 로그/모니터 (Deadlock, lock waits, long queries, undo growth) 확인 재현 방법: 개발/스테이징에서 재연 스크립트를 만들어 T1(읽기) / T2(삽입) 순서로 실행해 결과 비교.\n점검항목 무엇을 확인할 것인가 재현/검증 방법 쿼리유형 범위/집계 여부 EXPLAIN, 쿼리 실행 로그 동시성 동시 트랜잭션 수 부하 테스트, pgrep/pgbench/sysbench 트랜잭션 길이 오래 열린 트랜잭션 여부 DB 의 active tx 검사 격리수준 현재 설정값 SHOW transaction_isolation 등 인덱스 인덱스가 범위 스캔 유발 여부 EXPLAIN, 인덱스 통계 로그 Deadlock/lock wait 감지 DB 로그, APM 알람 핵심 요약: 원인부터 확인하면 적절한 대응 (격리수준 또는 인덱스 재설계 등) 을 정확히 선택할 수 있다. 데이터베이스 (엔진) 수준 대책 목표: DB 엔진의 격리·락 메커니즘을 활용해 팬텀 발생을 원천 차단하거나 안전하게 감지·해결한다.\n주요 기법:\n격리 수준 조정: SERIALIZABLE 사용 (원천 차단)—트랜잭션 충돌 시 abort 발생. 범위락: index-range / gap lock(엔진 지원 시) 으로 삽입 차단. 스냅샷 + SSI: 충돌감지를 통한 낙관적 정합 보장 (Postgres 등). 행수준 vs 범위 수준 락 설계: 필요 시 predicate locking 사용 검토. DB 파라미터 튜닝: undo/txnlog 크기, lock wait timeout, deadlock detection 주기 등. 장단점 트레이드오프: 높은 일관성은 동시성 저하 초래 → 워크로드에 맞게 섬세한 튜닝 필요.\n방법 효과 트레이드오프 SERIALIZABLE 팬텀 원천 방지 성능·충돌 증가 범위락 (gap lock) 삽입 차단으로 동일 결과 보장 락 경쟁 증가 SSI (Snapshot SI) 낙관적 충돌감지로 안전성 확보 abort 비용 · 복잡도 파라미터 튜닝 GC/UNDO 팽창 완화 운영 복잡성 증가 핵심 요약: DB 엔진의 보호 기능을 우선 고려하되, 성능 영향과 충돌 확률을 반드시 검토. 애플리케이션·비즈니스 레벨 대책 목표: 애플리케이션 설계로 팬텀·교착의 영향을 완화하고 사용자 경험을 보장한다.\n주요 기법:\n낙관적 동시성 제어 (버전 컬럼)—업데이트 충돌 시 재시도 또는 사용자 알림. 짧은 트랜잭션 권장—트랜잭션 내 불필요한 작업 분리. 재시도 정책 (지수 백오프)—트랜잭션 충돌시 안전하게 재시도. 변경 토큰/페이징 설계—범위 기반 집계 대신 토큰 기반 페이지네이션으로 불일치 최소화. 업데이트/삭제 대신 논리삭제·상태관리—의도치 않은 범위 변동 통제. 구현 팁: 재시도 시 idempotency 확보, 사용자 영향 (UX) 고려.\n기법 사용 시나리오 주의사항 낙관적 동시성 충돌 드문 시스템 버전 불일치 처리 로직 필요 트랜잭션 분리 긴 처리 작업 트랜잭션의 원자성 보장 재검토 재시도 (백오프) 충돌 빈도 낮음 idempotent 설계 필수 페이지네이션 토큰 대량 데이터 목록 토큰 보존/유효성 관리 필요 핵심 요약: 애플리케이션 레벨 대책은 DB 의 강력한 격리 없이도 실무적으로 일관성을 확보할 수 있는 현실적인 방법. 운영·모니터링·성능 예방 목표: 문제 발생 전 조기탐지, 발생 시 신속대응, 장기적 성능·스토리지 영향 최소화.\n중점 항목:\n장기 트랜잭션 감시—오래 열린 tx 는 undo/버전스토어 팽창 유발. Deadlock/lock wait 모니터링—자동 알림 및 로그 보관. Undo/Txn 로그 관리—크기 모니터링, GC 주기 조정. 성능·집계 이상 탐지—집계값 변동 (예: 하루 평균 대비 급증) 알람. 운영 정책: 타임아웃, deadlock-victim 정책, 재시도 표준화. 도구: DB 내장 모니터, APM(예: NewRelic 등), 커스텀 스크립트.\n항목 지표/알람 대응 장기 트랜잭션 tx open 시간 자동 경고·강제 rollback Deadlock deadlock 이벤트 재시도/원인 트레이스 Undo growth undo 사용량 GC/배치 윈도우 재조정 집계 이상 집계 급증 자동 롤백/알람 핵심 요약: 운영 관점의 예방·감시는 팬텀 문제를 조기 차단하고 장기적 비용 (스토리지·성능) 을 줄인다. 팬텀 리드 트러블슈팅 통합표 카테고리 핵심 문제 권장 해결책 우선순위 (권장) 장단점 원인 분석 및 탐지 재현 불가·원인 불명 재현 스크립트·EXPLAIN·로그분석 1 문제 진단 정확↑ / 초기 비용 필요 DB 수준 대책 팬텀 발생 (원천) SERIALIZABLE / 범위락 / SSI 2 일관성↑ / 성능·충돌↑ 애플리케이션 레벨 운영 현실성·UX 낙관적 버전·재시도·트랜잭션 분리 2 실용적·융통성↑ / 설계 복잡성↑ 운영·모니터링 장기적 비용·감지 모니터·알람·정책 (타임아웃 등) 1 조기탐지·비용↓ / 운영 부담 증가 최종 정리 및 학습 가이드 내용 종합 Phantom Read 는 동일 조건으로 반복 조회하는 트랜잭션에서 다른 트랜잭션의 삽입이나 삭제로 인해 결과 집합이 달라지는 동시성 이상이다.\n이 현상은 범위 기반 쿼리 (예: 날짜·금액 범위, 페이징, 집계) 를 사용할 때 특히 취약하며, 개별 행 락이나 단순한 스냅샷만으로는 완전 방지할 수 없다.\n근본적 해결은 ’ 조건 보호 ’ 로, 구현 방식으로는 키 - 범위 잠금 (next-key lock) 처럼 갭을 잠그는 방법이나 predicate locking, 또는 MVCC 위에서 동작하는 스냅샷 기반 직렬화 (SSI) 같은 기법이 있다.\n각 방식은 성능·복잡도 측면에서 트레이드오프가 있으므로 실무에서는 인덱스·파티셔닝·집계 테이블 등으로 범위 노출을 줄인 뒤, 핵심 도메인에 한해 격리 수준을 올리거나 범위잠금을 적용하는 전략을 권장한다.\n운영 측면에서는 팬텀 징후를 모니터링하고 (집계 불일치, 페이지네이션 이상 등) 필요한 경우 즉시 원인 쿼리와 데이터 분포를 점검해 설계 변경을 적용해야 한다.\n실무 적용 가이드 단계 목적 핵심 액션 (구체적) 우선순위 도메인 불변식 정의 어떤 데이터가 절대적 일관성 필요 비즈니스 규칙 문서화, 트랜잭션 매핑 높음 위험 쿼리 식별 Phantom/집계 오류 리스크 발견 쿼리 카탈로그 작성, 범위 쿼리 우선 점검 높음 격리·락 전략 선택 정합성 vs 성능 균형 결정 핵심=Serializable/FOR UPDATE, 일반=낙관적 높음 인덱스·파티션 설계 락 범위 축소·충돌 완화 범위 인덱스, 샤딩·파티션으로 핫스팟 분리 중~높 재시도·멱등 정책 충돌 시 안전한 복구 보장 idempotency key, 재시도 백오프 정책 높음 모니터링·알람 조기 탐지·운영 대응 직렬화 오류·데드락·롱 트랜잭션 지표 대시보드 높음 운영 튜닝 정책의 지속적 최적화 벤치마크 (throughput/latency)·A/B 테스트 중 학습 로드맵 Phase 학습 주제 중요도 학습 목표 실무 연관성 권장 실습 (구체) 1 팬텀 리드 개념 / 트랜잭션 이상 유형 필수 이상 분류·원인 파악 매우 높음 동일 WHERE 재조회 전후 INSERT/DELETE 로 변화 재현 (SQL) 1 ACID 와 격리 수준 비교 (RC/RR/SI/SERIAL) 필수 각 레벨이 막는/허용하는 이상 이해 높음 DB 설정 변경으로 동작 비교 (3 회 반복) 2 MVCC, Snapshot Isolation 동작 필수 스냅샷 읽기·쓰기 충돌 원리 파악 높음 Postgres SI 재현, write-skew 예제 2 키 - 범위 락 (Next-Key/GAP) 과 프레디케이트 락 필수 범위 락이 팬텀을 어떻게 막는지 이해 높음 InnoDB gap/next-key 락 실습 2 Serializable(직렬화) 내부 동작과 비용 필수 직렬화 실패/재시도 패턴 이해 높음 Serializable 모드에서 직렬화 실패 재현 3 낙관적 락 (버전컬럼) + 재시도 패턴 권장 애플리케이션 레벨 방어 구현 높음 Python/Java 재시도 템플릿 구현 3 ORM 연동 (예: JPA/Hibernate behavior) 권장 프레임워크 레벨 동작 이해 중간 ORM 에서의 버전관리 예제 3 집계·배치 전략 (스냅샷/배치 집계) 권장 일관성 - 성능 트레이드오프 관리 중간 배치 집계 스크립트, OLAP 스냅샷 사용 4 파티셔닝/샤딩 설계 원칙 필수 (대규모) 핫스팟 완화·리밸런싱 이해 높음 (대규모 서비스) 샤드키 실험 (데이터 분포 시뮬레이션) 4 분산 일관성 패턴 (2PC, Saga) 권장 분산 트랜잭션 대안 설계 높음 Saga 시뮬레이션, 보상 트랜잭션 설계 5 검증·테스트 (Jepsen 스타일) 권장 동시성 결함 노출·검증 능력 확보 높음 간단한 Jepsen-lite 테스트 케이스 작성 6 모니터링·운영 지표 설계 필수 (운영) 충돌률·재시도율·lock-wait 지표 정의 높음 Prometheus/Grafana 지표 대시보드 설계 7 최신 연구/대체기술 (CRDT 등) 선택 분산수렴 모델 이해 중간 CRDT 샘플 구현 (간단한 G-Counter) 학습 항목 정리 Phase 항목 ID 항목 (세부) 중요도 학습 목표 실무 연관성 실습/설명 1 1.1 팬텀 리드 개념 정의 필수 재현·구분 능력 매우 높음 동일 조건 SELECT 전후 INSERT/DELETE 로 변화 관찰 1 1.2 트랜잭션·ACID 기본 필수 트랜잭션 모델 이해 매우 높음 BEGIN/COMMIT/ROLLBACK 실습 1 1.3 이상 유형 재현 (D/R/N-R/Phantom) 필수 차이점·원인 파악 높음 4 가지 이상 각각 재현 스크립트 2 2.1 MVCC/Snapshot Isolation 필수 스냅샷·커밋 타이밍 이해 높음 Postgres SI 예제 (스냅샷 읽기) 2 2.2 Write Skew 사례 분석 필수 SI 한계 이해 높음 두 트랜잭션 write-skew 재현 2 2.3 Next-Key / Gap Lock (InnoDB) 필수 범위 락 동작 파악 높음 InnoDB 에서 gap lock 재현 2 2.4 Serializable 내부 (검증/재시도) 필수 직렬화 실패 처리 이해 높음 Serializable 모드 시나리오 3 3.1 낙관적 락 (버전) + 재시도 설계 필수 애플리케이션 레벨 보호 구현 높음 버전컬럼 + UPDATE WHERE version=? 구현 3 3.2 ORM 행동 (예: JPA/Hibernate) 권장 프레임워크 영향 이해 중간 ORM 에서의 영속성 컨텍스트 테스트 3 3.3 배치 집계·OLAP 스냅샷 권장 집계 일관성 전략 수립 중간 배치 스냅샷 집계 예제 3 3.4 재시도·백오프 정책 필수 운영 안정성 확보 높음 지수 백오프 + jitter 구현 4 4.1 샤딩·파티셔닝 설계 필수 (대규모) 핫스팟 회피 설계 높음 샤드키 테스트, 리밸런싱 시나리오 4 4.2 분산 트랜잭션 대안 (Saga/2PC) 권장 분산 무결성 패턴 적용 높음 Saga 워크플로우 설계 연습 4 4.3 분산 락/조정 서비스 설계 권장 샤드 경계 제약 유지 높음 분산 락 (Etcd/Consul) 간단 사용 예 5 5.1 동시성 검증 (Jepsen 스타일) 권장 진단·검증 능력 확보 높음 Jepsen-lite 테스트 케이스 5 5.2 모니터링 지표 및 알림 필수 (운영) 충돌·재시도 모니터링 높음 Prometheus 지표 템플릿 작성 6 6.1 성능·비용 트레이드오프 분석 권장 의사결정 능력 중간 A/B 테스트 설계, 비용 모델링 7 7.1 최신 대안 기술 (CRDT 등) 선택 분산 수렴 이해 낮음~중간 G-Counter 등 간단 CRDT 구현 용어 정리 카테고리 용어 (한글 (영어 풀네임, 약어)) 정의 관련 개념 실무 활용 핵심 개념 팬텀 리드 (Phantom Read) 동일 트랜잭션 내 반복 조회 사이에 다른 트랜잭션의 INSERT/DELETE 로 결과 집합 (행의 존재/부재) 이 변하는 동시성 이상 트랜잭션, 격리 수준, 집합 불변성 집계·재고·이벤트 등에서 결과 불일치 탐지·격리 수준 결정 핵심 개념 격리 수준 (Isolation Level) 트랜잭션 간 상호작용 허용 범위를 정의하는 설정 (예: Read Committed, Repeatable Read, Serializable) ACID, Dirty Read, Non-Repeatable Read, Phantom 일관성/성능 트레이드오프에 따라 운영 정책 선정 패턴 읽기 - 수정 - 쓰기 패턴 (Read-Modify-Write, RMW) 앱이 먼저 읽고 계산한 뒤 다시 쓰는 순서의 패턴—덮어쓰기 취약점 유발 원자적 UPDATE, 낙관적/비관적 락 가능하면 DB 원자 연산으로 대체 (예: UPDATE … SET v = v+1) 정책/관행 마지막 쓰기 우선 (Last Write Wins, LWW) 충돌 시 마지막 커밋을 우선하는 단순 정책—데이터 소실 가능 덮어쓰기, 일관성 정책 허용 가능한 경우에만 사용 (충돌 허용 영역) 구현 (락) 키 - 범위 / 넥스트키 락 (Key-Range / Next-Key Lock) 인덱스 레코드와 인덱스 사이의 gap 까지 잠가 범위 내 삽입을 차단 Gap Lock, 2PL, 인덱스 스캔 MySQL InnoDB 에서 팬텀 방지에 사용 (단, 락 경합 유의) 구현 (락) 갭 락 (Gap Lock) 실제 로우가 아닌 인덱스 간의 간격 (gap) 을 잠금으로써 그 위치에 대한 삽입을 차단 Next-Key Lock, 범위 락 범위 삽입 제어 필요시 사용 (데이터베이스별 동작 차이 있음) 구현 (락) 프레디케이트 락 (Predicate Lock) 쿼리 술어 (조건) 를 논리적으로 잠금—정확한 범위 보호 시도 Predicate Locking, Serializable 일부 DB/실험적 기능에서 사용, 구현 복잡성 존재 구현 (MVCC) MVCC (Multi-Version Concurrency Control, MVCC) 트랜잭션별로 데이터의 스냅샷을 제공해 읽기 일관성 보장 Snapshot Isolation (SI), SSI 읽기 성능 우수, 삽입 제어에는 한계 (팬텀 가능성) 구현 (MVCC) 스냅샷 격리 (Snapshot Isolation, SI) MVCC 기반의 읽기 일관성 모델—특정 상황에서 팬텀/Write-Skew 가 발생할 수 있음 MVCC, Repeatable Read 대량 동시성 환경에 유리, 팬텀 완전 차단 아님 구현 (직렬화) 직렬화 스냅샷 격리 (Serializable Snapshot Isolation, SSI) MVCC 위에서 의존성 그래프 충돌 탐지로 직렬성 보장—충돌 시 트랜잭션 Abort Serializable, MVCC 금융·원장 등 강한 일관성 경로에 적용 (성능·재시도 고려) 운영 (지표) 락 경합 (Lock Contention) 여러 트랜잭션이 동일 락 자원 요청으로 대기 또는 교착이 발생하는 현상 Deadlock, Timeout 모니터링 (락 대기 시간) → 쿼리/인덱스·트랜잭션 설계 개선 운영 (지표) 직렬화 실패 (Serialization Failure / SQLSTATE 40001) DB 가 직렬성 보장을 위해 트랜잭션을 Abort 할 때 발생하는 예외/로그 SSI, Serializable 애플리케이션 재시도 로직·백오프 필요 (모니터링 대상) 운영 (지표) 복제 지연 (Replication Lag) 비동기 복제에서 마스터 커밋과 리플리카 반영 간 지연 시간 읽기/쓰기 분리, 스테일 리드 읽기 리플리카 사용 시 세션 고정·마스터 우선 읽기 권장 진단 도구 쿼리 실행 계획 (EXPLAIN / EXPLAIN ANALYZE) 쿼리의 실행 경로 및 인덱스 사용 여부를 보여주는 도구 인덱스, 범위 스캔, 풀 스캔 범위 락 적용 가능성 판단·쿼리 리팩터링 근거 아키텍처 CQRS (Command Query Responsibility Segregation) 쓰기 (command) 와 읽기 (query) 를 분리하여 일관성·확장성 관리 이벤트 소싱, 단일 라이터 복잡한 일관성 요구 시스템에서 충돌 축소 패턴 보조 멱등성 (Idempotency) 같은 요청을 여러 번 실행해도 결과가 동일하도록 보장되는 성질 재시도, 외부 API 재시도 설계 시 필수 (직렬화 실패·재시도폭주 완화) 보조 EXPLAIN 기반 인덱스 점검 범위 쿼리가 인덱스를 타는지 확인하는 실무 절차 EXPLAIN, 인덱스 설계 팬텀 방지용 범위 락 유효성 사전검증 참고 및 출처 PostgreSQL Docs—Transaction Isolation \u0026 Serializable (SSI). PostgreSQL Docs—Explicit Locking/LOCK. MySQL Docs—InnoDB Locking Reads/Next-Key. MySQL Docs—InnoDB Next-Key Locking (Phantom Rows). SQL Server—SET TRANSACTION ISOLATION LEVEL (Transact-SQL). SQL Server—Snapshot Isolation (ADO.NET). Oracle—Data Concurrency \u0026 Consistency (Serializable). Berenson et al., A Critique of ANSI SQL Isolation Levels (PDF). Wikipedia—Isolation (database systems). Phantom Read \u003c 도리의 디지털라이프. 팬텀 리드(Phantom Read) 란? - 개발하는 동그리. InnoDB의 REPEATABLE READ가 PHANTOM READ를 방지하는 원리 (Velog). 트랜잭션 격리 수준 완벽 가이드 (notavoid.tistory). Phantom Read - 비트코기의 IT Note. MySQL InnoDB 갭락과 넥스트키 락 정의 및 팬텀 리드 방지. Phantom Read 부정합문제 해결방안 In PostgreSQL, MSSQL Server. 트랜잭션 격리 수준 \u0026 동시성 제어 (rnrwk0502.tistory). 과연 MySQL의 REPEATABLE READ에서는 PHANTOM READ 발생할까? (parkmuhyeun.github.io). ","wordCount":"9970","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-09-12T03:49:00Z","dateModified":"2025-09-12T03:49:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/phantom-read/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Phantom Read</h1><div class=post-description>팬텀 리드는 한 트랜잭션이 동일 조건으로 반복 조회할 때 다른 트랜잭션의 삽입·삭제로 결과가 달라지는 동시성 이상이다. SQL 표준의 SERIALIZABLE이 팬텀을 방지하며, 구현체는 키-범위 잠금, 프레디케이트 잠금 또는 스냅샷 기반 직렬화(SSI)로 대응한다.</div><div class=post-meta><span title='2025-09-12 03:49:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;47 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20&%20Database%20Systems/Data%20Operations/Transaction%20Management/Transaction/Transaction%20Isolation/Concurrency%20Anomalies/phantom-read.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#phantom-read>Phantom Read</a><ul><li><a href=#핵심-개념>핵심 개념</a></li><li><a href=#기초-조사-및-개념-정립>기초 조사 및 개념 정립</a></li><li><a href=#phase-2-핵심-원리-및-이론적-기반>Phase 2: 핵심 원리 및 이론적 기반</a></li><li><a href=#특성-분석-및-평가>특성 분석 및 평가</a></li><li><a href=#실무-적용-및-사례>실무 적용 및 사례</a></li><li><a href=#운영-및-최적화>운영 및 최적화</a></li></ul></li><li><a href=#최종-정리-및-학습-가이드>최종 정리 및 학습 가이드</a><ul><li><a href=#내용-종합>내용 종합</a></li><li><a href=#실무-적용-가이드>실무 적용 가이드</a></li><li><a href=#학습-로드맵>학습 로드맵</a></li><li><a href=#학습-항목-정리>학습 항목 정리</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><p><code></code></p><h2 id=phantom-read>Phantom Read<a hidden class=anchor aria-hidden=true href=#phantom-read>#</a></h2><p>Phantom Read 는 한 트랜잭션이 같은 조건으로 반복 조회할 때, 다른 트랜잭션의 <strong>삽입·삭제</strong>로 인해 결과 행 집합이 달라지는 현상이다.<br>예컨대 " 잔여 재고가 0 이면 주문 허용 " 을 검사할 때 다른 트랜잭션이 새 주문을 추가하면 최초 조건이 깨질 수 있다.<br>전통적 2PL 은 <strong>키 - 범위 잠금</strong>으로 갭을 막아 phantom 을 예방하고, MVCC 기반 DB 는 **스냅샷 + 직렬화 (Serializable/SSI)**로 충돌을 감지해 해결한다. 하지만 강한 격리는 동시성·지연·교착 비용을 키우므로, 실무에서는 위험 쿼리를 먼저 식별하고 (업무 불변식), 범위 인덱스·명시적 락·트랜잭션 경계 재설계 또는 애플리케이션 레벨 보완을 조합해 적용하는 것이 현실적이다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><p>Phantom Read 는 같은 조건의 조회를 트랜잭션 내에서 두 번 실행했을 때, 다른 사용자가 중간에 행을 추가하거나 삭제해서 결과 수가 달라지는 문제다.<br>집계·예약·범위 제약이 있는 비즈니스에서 오류로 이어지므로, 이를 막으려면 격리 수준을 높이거나 (Serializable), DB 의 범위 락 (next-key/gap lock) 을 사용하거나, 애플리케이션 쪽에서 버전 검사나 재시도 로직을 추가한다.<br>MVCC 는 읽기 성능을 도와주지만 모든 직렬화 위반을 자동으로 해결하진 않는다.</p><table><thead><tr><th>핵심 개념 (한글·약어)</th><th>정의</th><th style=text-align:right>왜 중요한가</th><th>대표적 예방/대응</th></tr></thead><tbody><tr><td>팬텀 리드 (Phantom Read)</td><td>동일 조건 재조회 시 행 집합이 INSERT/DELETE 로 변하는 현상</td><td style=text-align:right>집계·범위 제약 무결성 파괴</td><td>Serializable, 범위 락 (next-key), 제약조건</td></tr><tr><td>더티 리드 (Dirty Read)</td><td>커밋되지 않은 데이터 읽기</td><td style=text-align:right>신뢰 불가 데이터 사용 방지 필요</td><td>Read Committed 이상으로 회피</td></tr><tr><td>비반복 읽기 (Non-Repeatable Read)</td><td>같은 PK 재조회 시 값 변경</td><td style=text-align:right>읽기 일관성 저하</td><td>Repeatable Read / SI</td></tr><tr><td>쓰기 스큐 (Write Skew)</td><td>서로 다른 행 기반 의사결정 후 커밋으로 규칙 위반</td><td style=text-align:right>SI 에서 발생 가능한 직렬성 위반</td><td>Serializable / 명시적 락</td></tr><tr><td>MVCC (다중버전 동시성)</td><td>트랜잭션마다 스냅샷으로 읽기 제공</td><td style=text-align:right>높은 읽기 동시성 제공</td><td>SI 기반, 추가 충돌관리 필요</td></tr><tr><td>넥스트키 락 (Next-Key Lock)</td><td>인덱스 레코드 + 앞 gap 락</td><td style=text-align:right>범위 삽입 (팬텀) 차단</td><td>InnoDB gap/next-key locking 적용</td></tr></tbody></table><p>팬텀 리드는 " 범위 기반 " 문제로, 단순한 행 업데이트와 달리 행의 존재 여부가 바뀌어 집계·제약에 직접 영향을 준다. 이를 제어하려면 격리 수준·DB 락 메커니즘·제약조건을 적절히 조합해야 하며, MVCC 사용 시에도 write skew 등은 별도 고려 대상이다.</p><h4 id=개념-관계와-상호-영향-표>개념 관계와 상호 영향 표<a hidden class=anchor aria-hidden=true href=#개념-관계와-상호-영향-표>#</a></h4><table><thead><tr><th>출발 (원인)</th><th>작용 대상 (→)</th><th style=text-align:right>목적/효과 (왜)</th><th>결과 (어떤 이상 제거/유지)</th></tr></thead><tbody><tr><td>트랜잭션의 동시 INSERT/DELETE</td><td>→ 동일 조건 SELECT (다른 트랜잭션)</td><td style=text-align:right>범위 결과 변경 (존재 여부 변경)</td><td>Phantom Read 발생 가능</td></tr><tr><td>MVCC / Snapshot Isolation</td><td>→ 읽기 동작</td><td style=text-align:right>스냅샷으로 읽기 일관성 제공</td><td>Dirty/Non-Repeatable/기본 Phantom 일부 감소, 그러나 Write Skew 잔존.</td></tr><tr><td>Next-Key/GAP Lock (InnoDB)</td><td>→ 인덱스 범위</td><td style=text-align:right>범위 내 삽입 차단 → 팬텀 예방</td><td>Phantom Read 억제 (대신 락 경합↑).</td></tr><tr><td>Serializable 격리</td><td>→ 트랜잭션 커밋 검증</td><td style=text-align:right>직렬화 보장 (또는 재시도)</td><td>모든 이상 억제 (대가: 성능/재시도 비용).</td></tr><tr><td>애플리케이션 버전검사</td><td>→ 쓰기 시점</td><td style=text-align:right>충돌 탐지 후 재시도</td><td>팬텀 관련 비즈니스 규칙 보완 가능</td></tr></tbody></table><p>핵심은 &rsquo; 무엇이 (어떤 동작) → 무엇에 (어떤 대상) → 왜 (무슨 목적) → 결과 (어떤 이상을 억제/유지)&rsquo; 의 흐름을 명확히 해두면, 어떤 계층 (DB/락/애플리케이션) 에서 개입해야 할지 판단이 쉬워진다.</p><h4 id=개념실무-적용-매핑표->개념·실무 적용 매핑표 `<a hidden class=anchor aria-hidden=true href=#개념실무-적용-매핑표->#</a></h4><table><thead><tr><th>개념</th><th>실무에서 무엇을 (무엇을 적용)</th><th style=text-align:right>어떻게 적용 (구체)</th><th>왜 (비즈니스 이유)</th></tr></thead><tbody><tr><td>Phantom Read</td><td>예약/범위 제약 무결성 확보</td><td style=text-align:right>Serializable 또는 범위 락 (next-key), 유니크/체크 제약 병행</td><td>과예약·집계 오류 방지</td></tr><tr><td>Write Skew</td><td>다중조건 규칙 보존</td><td style=text-align:right>명시적 락 또는 Serializable, 업무 규칙 분해</td><td>규칙 위반 (예: 온콜 인원 0 명) 방지</td></tr><tr><td>MVCC / SI</td><td>높은 읽기 동시성 유지</td><td style=text-align:right>MVCC 기반 DB 사용, 중요한 쓰기 경로는 별도 처리</td><td>성능·스케일 고려</td></tr><tr><td>Gap/Next-Key Lock</td><td>범위 삽입 방지</td><td style=text-align:right>인덱스 설계와 함께 범위 락 허용 (필요시)</td><td>팬텀 삽입 차단</td></tr><tr><td>애플리케이션 검증</td><td>추가 안전장치</td><td style=text-align:right>버전컬럼 체크 + 재시도, 사전 유효성 검사</td><td>사용자 think-time 환경에서 실무적 유연성 제공</td></tr></tbody></table><p>실무에서는 &lsquo;DB 격리/락 &rsquo; 만으로는 충분하지 않은 경우가 많아, 유니크 제약·애플리케이션 레벨 검증·재시도 정책을 조합해 현실적 무결성을 확보한다. 특히 예약·금융·집계 경로는 높은 우선순위로 강화해야 한다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=phantom-read-이해와-실무-대응>Phantom Read 이해와 실무 대응<a hidden class=anchor aria-hidden=true href=#phantom-read-이해와-실무-대응>#</a></h4><p>팬텀 리드는 같은 조건의 조회를 여러 번 했을 때 결과에 &rsquo; 유령 (phantom)&rsquo; 처럼 새 레코드가 나타나거나 사라지는 문제다.<br>예컨대 A 트랜잭션이 " 잔액&lt;100 인 모든 계좌 " 를 조회한 뒤 다른 트랜잭션이 조건을 만족하는 새 계좌를 삽입하면, A 트랜잭션이 같은 쿼리를 다시 실행했을 때 처음과 다른 행 수가 나온다.<br>이 문제는 단순한 값 변경이 아니라 <strong>결과 집합의 추가/삭제</strong>가 발생하는 것이 핵심이다.<br>해결하려면 범위 (프레디케이트) 단위로 보호하는 락 기법이나 데이터베이스의 직렬화 (Serializable) 를 사용한다.<br>MVCC/Snapshot 만으로는 모든 케이스를 막지 못하므로, 실제 시스템에서는 격리 수준과 쿼리 설계를 함께 고려해야 한다.</p><h5 id=핵심-포인트>핵심 포인트<a hidden class=anchor aria-hidden=true href=#핵심-포인트>#</a></h5><ol><li><p><strong>팬텀은 &rsquo; 집합 변화 &rsquo; 문제다.</strong></p><ul><li>Non-Repeatable Read 는 동일 행의 컬럼 값이 달라지는 반면, Phantom 은 결과 집합에 _ 새로운 행의 추가/삭제 _ 가 발생한다.</li></ul></li><li><p><strong>범위 (Predicate) 락·다음 - 키 (Next-key) 락이 본질적 해결 수단이다.</strong></p><ul><li>전통적 락 기반 DB 는 범위 락을 사용해 특정 조건 범위에 대한 삽입을 차단함으로써 팬텀을 방지한다.</li></ul></li><li><p><strong>격리 수준별 차이</strong></p><ul><li>낮은 격리 수준 (Read Committed 등) 에서는 팬텀 발생 가능. Serializable(또는 DB 의 SSI 등 구현) 은 팬텀을 차단 (또는 충돌 검출 후 Abort) 한다.</li><li>MVCC(스냅샷) 는 읽기 일관성을 제공하지만 _ 새로 삽입된 행이 결과에 나타나는 팬텀 _ 을 항상 막지 못한다 (구현·메커니즘에 의존).</li></ul></li><li><p><strong>실무적 완화책</strong></p><ul><li>범위 쿼리를 변경 (예: 포괄적 인덱스 사용, 명시적 락) 하거나 트랜잭션 범위 좁힘, 필요 시 Serializable 적용. 또한 테스트로 재현 가능한 사례를 만들어 회귀 방지.</li></ul></li></ol><h4 id=phantom-read-등장과-동시성-진화>Phantom Read 등장과 동시성 진화<a hidden class=anchor aria-hidden=true href=#phantom-read-등장과-동시성-진화>#</a></h4><ul><li><p><strong>팬텀 리드란?</strong>:<br>같은 조건의 쿼리를 다시 실행했을 때 이전에 없던 (또는 사라진) 행이 보이는 현상.</p></li><li><p><strong>왜 문제인가?</strong>:<br>집계·조건 로직의 일관성을 깬다—예: " 잔액이 0 보다 작은 고객이 없다 " 는 조건이 트랜잭션 간 달라질 수 있다.</p></li><li><p><strong>어떻게 해결해왔나?</strong>:<br>처음엔 **락 (2PL)**으로 물리적 차단 → 이후 **격리 수준 (ANSI SQL-92)**으로 표준화 → 읽기 성능 개선을 위해 <strong>MVCC/SI</strong> 도입 → SI 의 일부 문제를 해결하기 위해 <strong>SSI</strong> 같은 검출/차단 기법 도입 → 분산 환경에서는 <strong>샤딩/리더/보상 패턴</strong> 병용.</p></li><li><p><strong>핵심 포인트</strong>:<br>성능과 일관성 사이에서 균형을 맞추는 것이 핵심이며, 각 DBMS·환경에 맞춰 적절한 기법을 선택해야 한다.</p></li></ul><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>팬텀 리드는 <strong>프레디케이트 (조건) 기반의 조회와 그 범위에 대한 동시 변경</strong> 때문에 발생한다. 단일 행 잠금 (row lock) 은 이미 존재하는 행의 동시 수정은 막지만, <strong>다른 트랜잭션이 새로운 행을 삽입하거나 삭제해 범위가 변하는 경우</strong>엔 충분하지 않다.<br>따라서 데이터베이스 연구자들과 엔지니어들은 다음과 같은 요구에 의해 진화해왔다.</p><ul><li>읽기 성능을 희생하지 않으면서 일관성을 보장할 방법</li><li>범위/색인 기반의 변경을 안전하게 처리하는 방법</li><li>분산·대규모 환경에서 확장성을 확보하면서도 중요한 도메인의 정합성 유지</li></ul><p>이 요구들이 2PL·MVCC·SI·SSI·샤딩 같은 기술 발전을 촉발했다.</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th>단계</th><th style=text-align:right>핵심 기술/개념</th><th>등장 이유 (문제)</th><th>개선점 (무엇을 해결)</th></tr></thead><tbody><tr><td>1</td><td style=text-align:right>2PL (Two-Phase Locking) / 행·범위 락</td><td>동시 쓰기 충돌 및 일관성 보장 필요</td><td>트랜잭션 직렬화 보장 (범위 락으로 팬텀 방지 가능)</td></tr><tr><td>2</td><td style=text-align:right>ANSI SQL-92 격리 수준 규정 (P1–P3)</td><td>이상 현상 표준화 및 선택 기준 필요</td><td>개발자·DBMS 간 기대 동작 표준화</td></tr><tr><td>3</td><td style=text-align:right>MVCC (Multi-Version Concurrency Control)</td><td>읽기 경합으로 인한 성능 저하 해결 필요</td><td>읽기 일관성 제공, 읽기 성능/동시성 개선</td></tr><tr><td>4</td><td style=text-align:right>Snapshot Isolation (SI)</td><td>MVCC 기반에서 더 강한 읽기 일관성 요구</td><td>스냅샷 기반 읽기 제공 (많은 이상 제거)</td></tr><tr><td>5</td><td style=text-align:right>SSI (Serializable SI) / 충돌 검출</td><td>SI 가 허용하는 일부 비직렬성 해결 필요</td><td>런타임 충돌 검출로 직렬성 보장 (더 강한 일관성)</td></tr><tr><td>6</td><td style=text-align:right>분산 패턴 (샤딩, CQRS, Saga 등)</td><td>대규모 확장성 및 분산 일관성 요구</td><td>파티셔닝·비동기 보상으로 확장성 확보, 도메인별 정합성 유지</td></tr></tbody></table><pre class=mermaid>timeline
    title 팬텀 리드 등장과 동시성 제어 진화
    2PL/락 : 1
    SQL-92 격리 규정 : 2
    MVCC 등장 : 3
    Snapshot Isolation (SI) : 4
    Serializable SI (SSI) : 5
    분산 패턴(CQRS/Saga/샤딩) : 6
</pre><ul><li><p>팬텀 문제는 " 범위 기반 변경 " 에서 발생하며, 이를 해결하기 위해 락 기반 (완전 차단) 에서 시작해 읽기 성능을 고려한 MVCC/SI 로 진화했고, SI 의 남은 취약점을 런타임 검출 방식 (SSI) 으로 보완했다. 마지막으로 분산·확장 요구는 파티셔닝·CQRS·보상 트랜잭션 같은 설계 패턴으로 문제를 완화한다.</p></li><li><p><strong>운영적 시사점</strong>: 특정 DBMS 의 구현 세부 (예: 어떤 격리 수준이 어떤 이상을 막는지) 를 반드시 확인하고, 비즈니스 민감도에 따라 직렬화 (또는 SSI) 수준을 적용하거나 하이브리드 패턴을 설계해야 한다.</p></li></ul><h4 id=phantom-read-문제와-해결-목적-총정리>Phantom Read 문제와 해결 목적 총정리<a hidden class=anchor aria-hidden=true href=#phantom-read-문제와-해결-목적-총정리>#</a></h4><p>Phantom Read 는 트랜잭션 A 가 같은 범위 질의를 반복했을 때 다른 트랜잭션 B 의 삽입/삭제로 결과가 달라지는 현상으로, 집계·재고·원장 등에서 심각한 오류를 일으킨다.</p><p><strong>왜 해결해야 하나</strong>:</p><ul><li>트랜잭션 내부 예측성·집계 정확성·비즈니스 불변성이 깨지면 금전적·운영적 손실 발생.</li></ul><p><strong>어떻게 해결하나 (직관)</strong>:</p><ul><li>범위 잠금이나 Serializable 같은 강한 격리로 삽입/삭제 간섭을 차단하거나, MVCC+ 직렬화 충돌 감지로 문제 발생 시 트랜잭션을 되돌려 일관성을 지킨다.</li></ul><h5 id=팬텀-리드가-유발하는-문제들>팬텀 리드가 유발하는 문제들<a hidden class=anchor aria-hidden=true href=#팬텀-리드가-유발하는-문제들>#</a></h5><table><thead><tr><th>문제 유형</th><th>구체적 증상</th><th>비즈니스 영향</th></tr></thead><tbody><tr><td>범위 질의 비재현성</td><td>동일 트랜잭션에서 같은 질의 두 번 시 결과 변경 (새 행 추가/삭제)</td><td>집계 불일치, 중복 집계, 보고 오류</td></tr><tr><td>집계 오차</td><td>기간별/조건별 집계 결과가 트랜잭션 간 달라짐</td><td>결산·리포트 신뢰도 저하</td></tr><tr><td>불변식 위반</td><td>좌석 초과 판매, 이중 승인 등</td><td>금전적 손실, 규정 위반</td></tr><tr><td>트랜잭션 로그 불일치</td><td>트랜잭션 내부 데이터 상태 예측 불가</td><td>디버깅·감사 어려움</td></tr></tbody></table><ul><li><strong>팬텀 리드는 &rsquo; 범위 (조건) 기반 &rsquo; 조회에서 발생하는 비재현성 문제</strong>로, 집계·원장·예약 시스템처럼 &rsquo; 집계 결과의 정확성 &rsquo; 이 중요한 영역에서 특히 치명적이다. 발생하면 단순한 값 오류를 넘어 비즈니스 로직 (예: 재고·금전 흐름) 전체의 신뢰를 무너뜨린다.</li></ul><h5 id=팬텀-리드-해결의-핵심-목적>팬텀 리드 해결의 핵심 목적<a hidden class=anchor aria-hidden=true href=#팬텀-리드-해결의-핵심-목적>#</a></h5><table><thead><tr><th>목적</th><th style=text-align:right>구체 목표</th><th>기대 효과</th></tr></thead><tbody><tr><td>범위 질의 재현성 확보</td><td style=text-align:right>트랜잭션 내 반복 조회 결과 고정</td><td>집계·리포트의 일관성 보장</td></tr><tr><td>불변식 보호</td><td style=text-align:right>좌석/한도/동시성 규칙 유지</td><td>비즈니스 무결성 보장 (금전·규정)</td></tr><tr><td>예측 가능한 처리</td><td style=text-align:right>트랜잭션 결과 예측 가능성 향상</td><td>디버깅·감사·운영 용이</td></tr><tr><td>선택적 성능 통제</td><td style=text-align:right>필요한 트랜잭션만 강격리 적용</td><td>성능 - 일관성 균형 조정</td></tr></tbody></table><ul><li>목적은 단순히 &rsquo; 이상 현상 제거 &rsquo; 가 아니라 <strong>비즈니스 무결성 보장 + 집계 신뢰성 확보 + 운영 가능성 (테스트·감사) 향상</strong>이다.</li><li>필요 시 전체 시스템 성능을 희생하지 않고도 &rsquo; 중요 트랜잭션 &rsquo; 만 선택적으로 보호하는 운영 전략이 중요하다.</li></ul><h5 id=문제--목적-연계-표>문제 ⇄ 목적 연계 표<a hidden class=anchor aria-hidden=true href=#문제--목적-연계-표>#</a></h5><table><thead><tr><th>문제 (증상)</th><th>대응 목적</th><th>어떻게 연계되는가</th></tr></thead><tbody><tr><td>범위 질의 비재현성</td><td>범위 질의 재현성 확보</td><td>동일 질의의 결과 고정 → 집계 정확성 달성</td></tr><tr><td>집계 오차</td><td>예측 가능한 처리</td><td>정확한 집계 → 리포트/결산 신뢰성 확보</td></tr><tr><td>불변식 위반</td><td>불변식 보호</td><td>트랜잭션 레벨 무결성 검사로 비즈니스 규칙 유지</td></tr><tr><td>트랜잭션 로그 불일치</td><td>예측 가능한 처리 + 감사 용이성</td><td>일관된 트랜잭션 결과 → 디버깅·감사 가능</td></tr></tbody></table><ul><li><strong>&rsquo; 재현성 확보 &rsquo; 가 모든 목적의 핵심 축</strong>이다. 재현성이 확보되면 집계 정확성·불변식 유지·운영상 감사·디버깅 등 모든 목적이 실현된다. 따라서 해결 방안은 항상 &rsquo; 어떤 수준의 재현성 &rsquo; 을 보장할지 (전체 트랜잭션/선택적 트랜잭션 등) 를 먼저 설계하는 것부터 시작해야 한다.</li></ul><h4 id=phantom-read-전제대응-이해하기>Phantom Read 전제·대응 이해하기<a hidden class=anchor aria-hidden=true href=#phantom-read-전제대응-이해하기>#</a></h4><p>팬텀 리드는 같은 트랜잭션 내에서 같은 조건으로 두 번 조회했을 때, 다른 트랜잭션의 삽입·삭제 때문에 결과가 바뀌는 현상이다. 이유는 데이터베이스가 개별 행만 잠그거나 읽기 스냅샷을 사용하면 &rsquo; 범위 자체 &rsquo; 의 변화를 막지 못하기 때문이다. 이 문제를 막으려면 범위를 잠그는 키 - 범위 락이나, 스냅샷 직렬화 (SSI) 또는 최고격리도 (Serializable) 를 사용하거나, 애플리케이션 쪽에서 쿼리 재설계 (명시적 락, 집계용 별도 테이블 등) 를 적용해야 한다.</p><h5 id=phantom-read-전제요구대응-정리>Phantom Read 전제·요구·대응 정리<a hidden class=anchor aria-hidden=true href=#phantom-read-전제요구대응-정리>#</a></h5><ul><li><p><strong>전제 조건 (언제 발생하는가)</strong></p><ol><li>범위 기반 조건을 사용하는 쿼리 (범위 검색, 집계, 페이징 등) 가 존재할 것.</li><li>두 개 이상 트랜잭션이 동시에 동일 범위에 접근하고, 적어도 하나가 삽입 또는 삭제를 수행할 가능성이 있을 것.</li><li>DB 의 격리 수준/락 정책이 범위 변경을 차단하지 못할 것 (예: Read Committed, 일부 Repeatable Read 구현).</li></ol></li><li><p><strong>특징 (그런 특징이 나타나는 근거)</strong></p><ul><li>범위 질의는 " 집합 " 을 대상으로 하므로, 개별 행 (row) 단위 잠금만으로는 범위 밖에서 새로 생성된 행을 통제할 수 없다. 이로 인해 최초 쿼리의 결과셋과 이후 쿼리의 결과셋이 달라짐. (근거: 락의 범위와 갭 (gap) 문제)</li><li>MVCC 기반 DB 는 읽기 시점에 스냅샷을 제공해 읽기 블로킹을 피하지만, 삽입된 레코드는 스냅샷에 포함되지 않아 후속 조회 결과가 달라질 수 있다. 스냅샷만으로 팬텀을 완전 방지하지 못하는 이유다. (근거: MVCC 의 스냅샷 타이밍)</li><li>키 - 범위 락 (next-key) 이나 predicate locking 은 **범위 자체 (갭)**를 잠금으로써 삽입/삭제를 막아 팬텀을 방지한다. (근거: 락의 확장성/범위 개념)</li></ul></li><li><p><strong>등장 이전 관련 기술과 차별점</strong></p><ul><li><strong>행 (row) 락 / 단일 레코드 잠금</strong>: 개별 행 보호는 가능하지만 범위 삽입/삭제는 막지 못한다 → 팬텀 취약.</li><li><strong>키 - 범위 락 (Next-Key Lock)</strong>: 행 락 + 갭 락을 결합하여 범위 삽입을 차단 → 팬텀 방지 (단점: 병행성 저하).</li><li><strong>Predicate Locking(프레디케이트 락)</strong>: 쿼리의 조건 (프레디케이트) 자체를 잠금으로 표현—이론상 더 정밀하지만 구현이 복잡.</li><li><strong>MVCC + SSI(스냅샷 기반 직렬화)</strong>: 스냅샷 기반으로 트랜잭션 간 의존성을 추적해 직렬화 보장 (팬텀 포함)—병행성은 키 - 범위 락보다 상대적으로 좋으나 구현 복잡도·오버헤드 존재.</li><li><strong>Serializable 격리 (강한 락 또는 검증 기반)</strong>: 가장 강력한 무결성 보장. 구현 방식에 따라 성능 영향이 크다.</li></ul></li></ul><h5 id=phantom-read-전제요구사항-요약표>Phantom Read 전제·요구사항 요약표<a hidden class=anchor aria-hidden=true href=#phantom-read-전제요구사항-요약표>#</a></h5><table><thead><tr><th>전제·요구사항</th><th style=text-align:right>구체 내용</th><th>왜 (근거)</th><th>운영 시 징후 / 실무 고려사항</th></tr></thead><tbody><tr><td>범위 기반 조건의 존재</td><td style=text-align:right>WHERE amount BETWEEN …, WHERE date &lt; … 등</td><td>범위 연산은 집합 변화 (삽입/삭제) 에 민감</td><td>집계값·페이지네이션 결과 변화 관찰</td></tr><tr><td>동시 쓰기 트래픽</td><td style=text-align:right>동시 삽입/삭제 또는 배치 삽입 가능성</td><td>동시 삽입이 있으면 최초 쿼리와 결과 불일치</td><td>높은 동시 INSERT/DELETE 비율, 배치 시간대 체크</td></tr><tr><td>격리 수준 설정</td><td style=text-align:right>DB 가 Read Committed/Repeatable Read 등으로 동작</td><td>일부 격리 수준은 팬텀 방지 불충분</td><td>격리 수준 문서 확인, 엔진별 구현 차이 주의</td></tr><tr><td>락 범위/정책</td><td style=text-align:right>행 락만인지, 갭 락 (Next-Key) 지원인지 여부</td><td>행 락만으론 갭 삽입 차단 불가</td><td>DB 의 락 정책 확인 (Next-Key 지원 여부)</td></tr><tr><td>MVCC/스냅샷 동작</td><td style=text-align:right>스냅샷 생성 시점과 커밋 처리 방식</td><td>스냅샷은 삽입된 새 레코드 미포함 가능</td><td>MVCC 동작 문서 검토 필요</td></tr><tr><td>성능·무결성 트레이드오프</td><td style=text-align:right>성능 저하 허용 범위와 무결성 요구도</td><td>키 - 범위 락/Serializable 은 병행성 저하</td><td>비즈니스 우선순위에 따라 선택</td></tr></tbody></table><p>핵심은 &rsquo; 범위 질의 + 동시 삽입/삭제 &rsquo; 라는 조합이 팬텀을 만든다는 것. 운영자는 해당 쿼리 패턴이 존재하는지 먼저 찾고 (예: 페이징, 집계 쿼리), 동시 쓰기 부하와 DB 의 락·스냅샷 동작을 점검해야 한다. 무결성이 절대적으로 필요하면 키 - 범위 락이나 Serializable/SSI 를 선택하되 병행성 저하를 감수해야 하고, 성능 우선이면 애플리케이션 레벨에서 쿼리 재설계 (명시적 잠금, 집계 캐시 등) 를 고려하라.</p><h4 id=phantom-read-의-핵심-이해와-대응>Phantom Read 의 핵심 이해와 대응<a hidden class=anchor aria-hidden=true href=#phantom-read-의-핵심-이해와-대응>#</a></h4><p>Phantom Read 는 트랜잭션 A 가 어떤 조건으로 조회 (예: <code>WHERE price > 100</code>) 한 뒤 같은 트랜잭션에서 다시 조회했을 때, 트랜잭션 B 가 그 사이에 새 행을 삽입하거나 삭제해서 결과 행 수나 목록이 달라지는 문제다.<br>Non-repeatable Read 는 같은 행의 값이 바뀌는 문제라 다르다. 전통적 잠금 (2PL) 의 키 - 범위 잠금은 삽입을 막아 phantom 을 예방하고, MVCC 기반 DB 는 스냅샷 + 직렬화 (SSI/Serializable) 로 런타임 충돌을 잡아내는 방식으로 해결한다.<br>강한 격리는 정확성을 올리지만 동시성·지연·교착 비용이 늘어나므로, 실무에서는 위험 쿼리 식별→범위 인덱스 확보→격리/락 정책·트랜잭션 경계 재설계를 조합해 적용한다.</p><h5 id=phantom-핵심특징과-기술-비교>Phantom 핵심특징과 기술 비교<a hidden class=anchor aria-hidden=true href=#phantom-핵심특징과-기술-비교>#</a></h5><ol><li><p><strong>존재 집합 변화가 핵심</strong></p><ul><li>설명: Phantom 은 행의 * 존재 여부 (출현/소멸)* 가 달라지는 문제.</li><li>기술 근거: SQL 표준과 DB 문서에서 Phantom 을 &rsquo; 집합 변화 &rsquo; 로 정의.</li><li>차별점: Non-repeatable Read 는 동일 행의 값 변경 (수정) 에 국한된다.</li></ul></li><li><p><strong>범위 (프레디케이트) 기반 쿼리에서 발생</strong></p><ul><li>설명: <code>SELECT … WHERE</code> 같은 조건 스캔 시 new/delete 가 문제.</li><li>기술 근거: 갭 잠금/next-key 잠금은 인덱스 범위 스캔에 적용되어 phantom 을 방지.</li><li>차별점: 단일 행 잠금만으로는 삽입 (phantom) 을 차단 불가 → 범위 잠금 필요.</li></ul></li><li><p><strong>DBMS 별 해결 방식 차이 (락 vs MVCC+ 직렬화)</strong></p><ul><li>설명: 2PL(범위 락) vs MVCC+SSI(스냅샷 + 충돌검사).</li><li>기술 근거: MySQL/InnoDB 는 next-key lock 을, PostgreSQL 은 SSI 를 통해 직렬화 보장.</li><li>차별점: 락은 예측 가능한 차단 (하지만 동시성 저하), SSI 는 낙관적 충돌감지 (하지만 재시도 가능성).</li></ul></li><li><p><strong>인덱스 구조가 영향</strong></p><ul><li>설명: 범위 인덱스가 없으면 테이블 스캔으로 광범위 잠금·성능 저하.</li><li>기술 근거: 갭 잠금은 인덱스 스캔 시 적용되므로 인덱스 설계 중요.</li><li>차별점: 잘 설계된 인덱스는 잠금 범위를 좁혀 비용을 줄인다.</li></ul></li><li><p><strong>정합성·성능의 트레이드오프가 큼</strong></p><ul><li>설명: 격리 수준을 올리면 정확성↑, 동시성↓·지연↑.</li><li>기술 근거: SQL 표준·DB 문서의 격리 수준 비교 및 교과서적 설명.</li><li>차별점: 비즈니스 민감도에 따라 정책 선택 (금융은 강한 일관성 선호).</li></ul></li></ol><h5 id=phantom-특성기술-근거-비교표>Phantom 특성·기술 근거 비교표<a hidden class=anchor aria-hidden=true href=#phantom-특성기술-근거-비교표>#</a></h5><table><thead><tr><th>핵심 특징</th><th style=text-align:right>기술적 근거</th><th>실무적 차별점 (대응 방식)</th></tr></thead><tbody><tr><td>존재 집합 변화</td><td style=text-align:right>SQL 표준·DB 문서: phantom = 행 출현/소실.</td><td>Non-repeatable read(값 변화) 와 구분</td></tr><tr><td>범위 기반 발생</td><td style=text-align:right>인덱스 스캔/프레디케이트 쿼리에서 삽입·삭제가 문제</td><td>단일 행 락으론 방지 불가 → 범위 잠금 필요</td></tr><tr><td>갭/next-key 잠금</td><td style=text-align:right>InnoDB next-key: 레코드 락 + gap 락 적용.</td><td>강력하지만 데드락·지연 부하 유발</td></tr><tr><td>MVCC + SSI</td><td style=text-align:right>PostgreSQL SSI: 스냅샷 읽기 + 직렬화 충돌 검출.</td><td>락 의존성 낮음, 충돌시 재시도 필요</td></tr><tr><td>인덱스 의존성</td><td style=text-align:right>인덱스 없으면 테이블스캔→광범위 잠금·비용 증가.</td><td>인덱스 설계로 잠금 범위 최소화 가능</td></tr><tr><td>성능·정합성 트레이드오프</td><td style=text-align:right>격리 강화 → 정확성↑ / 동시성↓·지연↑.</td><td>업무 민감도 따라 정책 결정 필요</td></tr></tbody></table><p>Phantom 은 <strong>범위 쿼리에서 행의 존재가 바뀌어 결과가 달라지는 문제</strong>로, 해결책은 DBMS 의 동시성 제어 방식 (범위 락 vs MVCC+ 직렬화) 에 의해 달라진다. 인덱스 설계·트랜잭션 경계·격리 정책의 조합으로 비용을 최소화하면서 정합성을 확보해야 한다.</p><h3 id=phase-2-핵심-원리-및-이론적-기반>Phase 2: 핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#phase-2-핵심-원리-및-이론적-기반>#</a></h3><h4 id=팬텀리드-방지-원칙과-설계전략>팬텀리드 방지 원칙과 설계전략<a hidden class=anchor aria-hidden=true href=#팬텀리드-방지-원칙과-설계전략>#</a></h4><p>팬텀 리드는 트랜잭션 중 같은 조건으로 조회했을 때 다른 트랜잭션이 새 행을 만들거나 삭제해서 결과 행이 달라지는 문제다.<br>이를 막으려면</p><ol><li>결과가 어떤 순차 실행과 동일하게 나오도록 보장하는 직렬 가능성 (Serializable) 을 확보하거나,</li><li>조건 자체를 보호하는 범위/프레디케이트 락을 사용하거나,</li><li>애플리케이션 차원에서 버전 검사·제약·재시도 로직을 조합해 위험을 보완해야 한다.</li></ol><p>실무에서는 성능·무결성의 균형을 맞추기 위해 민감 경로만 엄격 처리하고 나머지는 경량 대책을 쓰는 방식이 일반적이다.</p><h5 id=팬텀리드-핵심-원칙-정리표>팬텀리드 핵심 원칙 정리표<a hidden class=anchor aria-hidden=true href=#팬텀리드-핵심-원칙-정리표>#</a></h5><table><thead><tr><th>핵심 원칙</th><th>설명</th><th style=text-align:right>목적</th><th>왜 필요한가</th><th>적용 예시</th></tr></thead><tbody><tr><td>직렬 가능성 (Serializability)</td><td>동시 실행 결과가 어떤 순차 실행과 동일하도록 보장</td><td style=text-align:right>모든 동시성 이상 제거</td><td>전역 규칙 (집계·제약) 안전 보장</td><td>Serializable 격리 적용</td></tr><tr><td>조건 보호 (Predicate Protection)</td><td>WHERE 조건 (범위) 을 잠그거나 검증</td><td style=text-align:right>동일 조건 재조회에서 결과 안정화</td><td>팬텀 (행 존재 변화) 직접 방지</td><td>범위 락 (next-key)/프레디케이트 락</td></tr><tr><td>최소 트랜잭션 범위</td><td>불필요한 연산을 트랜잭션 밖으로 분리</td><td style=text-align:right>락 시간·충돌 창 축소</td><td>성능·동시성 개선</td><td>외부 I/O 비동기화</td></tr><tr><td>혼합 전략 적용</td><td>MVCC·락·애플리케이션 검증 조합</td><td style=text-align:right>성능과 무결성의 균형</td><td>각 기법의 한계 보완</td><td>MVCC + 버전검사 + 범위락</td></tr></tbody></table><p>핵심은 &rsquo; 무엇을 전부 막을지 &lsquo;(직렬화) 와 &rsquo; 어느 범위를 반드시 보호할지 &lsquo;(조건 보호) 를 명확히 한 뒤, 성능을 지키기 위해 트랜잭션 범위를 줄이고 여러 기법을 조합하는 것이다.</p><h5 id=팬텀리드-설계-철학-정리표>팬텀리드 설계 철학 정리표<a hidden class=anchor aria-hidden=true href=#팬텀리드-설계-철학-정리표>#</a></h5><table><thead><tr><th>설계 철학</th><th>설명</th><th style=text-align:right>목적</th><th>왜 필요한가</th><th>실무 적용 포인트</th></tr></thead><tbody><tr><td>방어적 설계</td><td>여러 계층에 걸쳐 중복 방어선 배치</td><td style=text-align:right>한 계층 실패시 안전망 역할</td><td>운영환경 불확실성 대응</td><td>DB 제약 + 앱 검증 병행</td></tr><tr><td>최소 락 원칙</td><td>필요한 최소 범위만 잠금</td><td style=text-align:right>동시성 유지, 대기 최소화</td><td>과도한 락은 병목 초래</td><td>행/범위 최소화, 빠른 커밋</td></tr><tr><td>선택적 엄격화</td><td>민감 경로만 강화</td><td style=text-align:right>전체 성능 유지하면서 핵심 보호</td><td>비용 - 편익 최적화</td><td>결제·예약 경로 우선 엄격화</td></tr><tr><td>관찰 기반 운영</td><td>지표로 정책 동적 조정</td><td style=text-align:right>현실 워크로드에 맞춘 최적화</td><td>설계 가정과 현실 차이 보정</td><td>충돌률 기반 자동화/알람</td></tr></tbody></table><p>설계 철학은 " 어디에 비용을 쓸 것인가 " 의 문제다. 핵심 무결성에는 비용을 들이고, 나머지는 경량·관찰 기반으로 운영해 효율을 높이는 접근이 실무에선 효과적이다.</p><h4 id=phantom-read-원리탐지방지-전략>Phantom Read: 원리·탐지·방지 전략<a hidden class=anchor aria-hidden=true href=#phantom-read-원리탐지방지-전략>#</a></h4><p>팬텀 리드는 같은 조건으로 쿼리를 여러 번 실행할 때 결과 집합(레코드의 존재 여부) 이 달라지는 문제다.<br>예: 트랜잭션 A 가 <code>SELECT * FROM orders WHERE amount &lt; 100</code> 을 두 번 실행하는 사이에 트랜잭션 B 가 조건에 맞는 새 주문을 INSERT 하면 A 의 두 번째 조회에서 그 새 행이 &rsquo; 유령&rsquo; 처럼 보인다.<br>이를 방지하려면 <strong>범위 단위로 삽입/삭제를 차단</strong>(키- 범위 락 또는 predicate lock) 하거나 데이터베이스 수준에서 **직렬성(Serializable/SSI)**을 선택해 충돌을 탐지·차단해야 한다.<br>단, 이런 보호는 성능 비용을 유발하므로 쿼리·인덱스 설계와 함께 적절히 선택해야 한다.</p><h5 id=phantom-read-방지-메커니즘-비교표>Phantom Read 방지 메커니즘 비교표<a hidden class=anchor aria-hidden=true href=#phantom-read-방지-메커니즘-비교표>#</a></h5><table><thead><tr><th>메커니즘</th><th style=text-align:right>어떻게 동작하는가</th><th>장점</th><th>단점</th><th style=text-align:right>팬텀 방지 여부</th></tr></thead><tbody><tr><td>키- 범위 / 넥스트키 락 (2PL)</td><td style=text-align:right>인덱스 스캔 범위와 그 사이의 gap 까지 잠궈 다른 트랜잭션의 삽입 차단</td><td>확실한 범위 차단</td><td>락 대기·데드락·동시성 저하</td><td style=text-align:right>방지</td></tr><tr><td>Predicate Locking (논리적 범위 락)</td><td style=text-align:right>쿼리 조건(술어) 에 해당하는 논리적 범위를 잠금</td><td>직관적 범위 보호</td><td>구현 복잡성(일부 DB 만 지원)</td><td style=text-align:right>방지</td></tr><tr><td>MVCC(스냅샷 읽기)</td><td style=text-align:right>트랜잭션별 읽기 스냅샷으로 값 안정화</td><td>읽기 성능 우수</td><td>새 삽입 제어 불가 → 팬텀 발생 가능</td><td style=text-align:right>부분적(완전 방지 아님)</td></tr><tr><td>SSI(Serializable Snapshot Isolation)</td><td style=text-align:right>MVCC 위에서 충돌(의존성) 탐지 → 직렬성 보장(충돌 시 Abort)</td><td>직렬성 보장(스냅샷 장점 유지)</td><td>충돌 탐지 비용, 재시도 발생</td><td style=text-align:right>방지(검출·차단)</td></tr><tr><td>쿼리/인덱스 리팩터링</td><td style=text-align:right>조건을 더 구체화하거나 인덱스 사용으로 범위 고정</td><td>성능 및 예측 가능성 향상</td><td>모든 케이스에 적용 불가</td><td style=text-align:right>간접적 예방</td></tr></tbody></table><p>핵심은 " 범위(프레디케이트) 를 어떻게 제어하느냐" 다. 전통적 락(키- 범위, predicate) 은 직접적으로 삽입을 막아 팬텀을 차단하지만 동시성 비용이 든다. MVCC 는 읽기 성능을 보장하지만 삽입 제어가 약해 팬텀이 발생할 수 있으며, 이 경우 SSI 같은 충돌 탐지 기법으로 보완한다. 실무에서는 쿼리·인덱스 설계, 락 사용과 직렬화의 성능 트레이드오프를 고려해 혼합 적용한다.</p><h5 id=phantom-read-발생방지-흐름도>Phantom Read 발생·방지 흐름도<a hidden class=anchor aria-hidden=true href=#phantom-read-발생방지-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  A[&#34;트랜잭션 A: SELECT (조건 P)&#34;] --&gt; B[트랜잭션 B 발생?]
  B --&gt;|B: INSERT/DELETE 조건 P에 부합| C[트랜잭션 B 커밋]
  C --&gt; D[트랜잭션 A: 동일 SELECT 재실행]
  D --&gt; E{결과셋 변화?}
  E --&gt;|예: 신규 행 포함| F[팬텀 발생]
  E --&gt;|아니오| G[No Phantom]

  %% 방지 분기
  A --&gt; H{방지 전략 적용 여부}
  H --&gt;|키-범위 락| I[트랜잭션 B의 INSERT 차단 -&gt; No Phantom]
  H --&gt;|Serializable/SSI| J[&#34;충돌 탐지시 B 또는 A Abort -&gt; No Phantom(또는 재시도)&#34;]
  H --&gt;|MVCC만| K[스냅샷으로 값 안정화하지만 삽입 통제 불가 -&gt; Phantom 가능]
  H --&gt;|쿼리/인덱스 개선| L[범위 고정/인덱스 사용 -&gt; 삽입 가능성 축소]

  style F fill:#ffe6e6,stroke:#ff3333
  style I fill:#e6ffe6,stroke:#33aa33
  style J fill:#e6ffe6,stroke:#33aa33
  style K fill:#fff3cc,stroke:#ff9900
</pre><ol><li>트랜잭션 A 가 조건 P 로 SELECT 를 수행한다.</li><li>그 사이 트랜잭션 B 가 조건 P 에 맞는 INSERT/DELETE 를 수행하고 커밋하면, A 가 재조회할 때 결과 집합이 바뀔 수 있다(팬텀 발생).</li><li>방지책으로는 (a) <strong>키 - 범위 락</strong>으로 B 의 삽입을 막거나, (b) <strong>Serializable/SSI</strong>로 의존성 충돌을 탐지해 트랜잭션 중 하나를 Abort 시키는 방법, (c) <strong>쿼리·인덱스 개선</strong>으로 범위를 고정해 삽입 가능성을 줄이는 방법이 있다.</li><li>MVCC 만 사용하면 읽기값은 스냅샷으로 안정되지만 <strong>삽입 자체를 막지 못하면 팬텀이 발생</strong>할 수 있다. 따라서 MVCC 환경에서도 필요한 경우 범위 제어 또는 SSI 같은 보강이 필요하다.</li></ol><h4 id=phantom-read-흐름대응생명주기>Phantom Read: 흐름·대응·생명주기<a hidden class=anchor aria-hidden=true href=#phantom-read-흐름대응생명주기>#</a></h4><ol><li>트랜잭션 A 가 <code>SELECT * FROM T WHERE cond</code> 를 실행한다.</li><li>트랜잭션 B 가 같은 조건에 해당하는 <strong>새 행을 삽입</strong>(혹은 삭제) 하고 커밋한다.</li><li>트랜잭션 A 가 동일 쿼리를 재실행하면, 이전에 없던 행이 나타나거나 사라져 <strong>결과가 달라진다</strong>.</li><li>이 현상이 <strong>Phantom Read</strong>.</li><li>해결책은: (a) 범위 잠금, (b) 높은 격리 수준(Serializable/SSI), (c) 설계적 완화(샤딩·CQRS·집계 컬럼) 중 적절히 선택하는 것.</li></ol><h5 id=phantom-read-흐름과-대응-포인트>Phantom Read: 흐름과 대응 포인트<a hidden class=anchor aria-hidden=true href=#phantom-read-흐름과-대응-포인트>#</a></h5><p><strong>핵심 흐름</strong>:</p><ul><li>트랜잭션 A: <code>BEGIN; SELECT … WHERE P;</code> (스냅샷 또는 읽기 시점 확보)</li><li>트랜잭션 B: <code>BEGIN; INSERT INTO … WHERE P satisfies; COMMIT</code></li><li>트랜잭션 A: <code>SELECT … WHERE P;</code> → 결과에 신규 행 포함 → 내부 일관성 위반 → Phantom 발생</li></ul><p><strong>대응 포인트</strong>:</p><ul><li><strong>읽기 - 쓰기 충돌</strong>이 아니라 <strong>범위 삽입/삭제</strong>라는 점을 인지(따라서 행잠금만으론 부족).</li><li>DB 레벨: predicate/range lock, next-key lock, SI/SSI, Serializable.</li><li>설계 레벨: 쿼리 범위 축소(파티셔닝), 집계 컬럼, CQRS 로 읽기/쓰기 분리.</li></ul><h5 id=phantom-read-흐름-표>Phantom Read 흐름 표<a hidden class=anchor aria-hidden=true href=#phantom-read-흐름-표>#</a></h5><table><thead><tr><th style=text-align:right>단계</th><th>주체</th><th>DB 연산(예시)</th><th>의도/결과</th><th>문제 발생 지점</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>T1 (조회 트랜잭션)</td><td><code>BEGIN; SELECT * FROM A WHERE balance > 100</code></td><td>조건에 맞는 행 집합 읽음</td><td>—</td></tr><tr><td style=text-align:right>2</td><td>T2 (변경 트랜잭션)</td><td><code>BEGIN; INSERT INTO A(id,balance) VALUES(9,150); COMMIT</code></td><td>새로운 행 삽입 후 커밋</td><td>범위(프레디케이트) 변경</td></tr><tr><td style=text-align:right>3</td><td>T1</td><td><code>SELECT * FROM A WHERE balance > 100</code> (재조회)</td><td>결과 집합에 신규 행 등장</td><td>Phantom 발생(일관성 훼손)</td></tr><tr><td style=text-align:right>4</td><td>대응(옵션)</td><td><code>SELECT … FOR UPDATE</code> / 범위 락 / SERIALIZABLE / SSI</td><td>재조회 시 일관성 보장 또는 충돌 검출</td><td>잠금 비용/성능 영향</td></tr></tbody></table><ul><li>트랜잭션 A 가 관찰한 범위가 트랜잭션 B 의 커밋으로 바뀌는 것이 핵심이다.</li><li>예방은 범위레벨 제어(락 또는 높은 격리) 또는 설계적 완화(파티셔닝·CQRS) 로 이뤄진다.</li></ul><h5 id=phantom-read-흐름도>Phantom Read 흐름도`<a hidden class=anchor aria-hidden=true href=#phantom-read-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  Start([T1 시작: SELECT WHERE P])
  T1_SELECT[&#34;T1: SELECT * WHERE P (스냅샷/읽기)&#34;]
  Parallel{동시 트랜잭션 T2 존재?}
  T2_INS[T2: INSERT/DELETE affecting P -&gt; COMMIT]
  Requery[T1: 동일 SELECT 재실행]
  Detection{결과 불일치?}
  Remedy1[범위 락 / predicate lock 적용]
  Remedy2[Serializable / SSI 격리 적용]
  Remedy3[설계적 완화: 파티셔닝 / CQRS / 집계 컬럼]
  End([종료: 일관성 보장/재시도/오류 보고])

  Start --&gt; T1_SELECT --&gt; Parallel
  Parallel -- yes --&gt; T2_INS --&gt; Requery
  Parallel -- no --&gt; Requery
  Requery --&gt; Detection
  Detection -- yes --&gt; Remedy1
  Detection -- yes --&gt; Remedy2
  Detection -- yes --&gt; Remedy3
  Detection -- no --&gt; End
  Remedy1 --&gt; End
  Remedy2 --&gt; End
  Remedy3 --&gt; End
</pre><ul><li>T1 이 범위 쿼리 (프레디케이트 P) 를 실행한 후, T2 가 같은 범위에 해당하는 삽입/삭제를 커밋하면 T1 의 재조회에서 결과가 달라질 수 있다.</li><li>Detection 단계에서 불일치가 확인되면 세 가지 대응 중 하나 또는 조합을 선택하여 일관성을 확보한다: (1) 범위 락으로 물리적 차단, (2) Serializable/SSI 로 격리 수준 강화, (3) 파티셔닝/CQRS 등 설계 변경으로 범위 변경 가능성을 제거.</li><li>각 대응은 비용 (성능/복잡도) 이 다르므로 비즈니스 요건에 맞게 선택해야 한다.</li></ul><h5 id=phantom-read-생명주기-다이어그램>Phantom Read 생명주기 다이어그램<a hidden class=anchor aria-hidden=true href=#phantom-read-생명주기-다이어그램>#</a></h5><pre class=mermaid>stateDiagram-v2
    [*] --&gt; T1_Begin: T1 BEGIN
    T1_Begin --&gt; T1_Read: SELECT WHERE P (snapshot or current)
    T1_Read --&gt; Waiting: T1 작업 중 (기타 연산)
    Waiting --&gt; T2_Begin: T2 BEGIN (동시)
    T2_Begin --&gt; T2_Write: INSERT/DELETE affecting P
    T2_Write --&gt; T2_Commit: COMMIT
    T2_Commit --&gt; DB_State_Changed: DB 변경(범위 변경)
    DB_State_Changed --&gt; T1_Requery: T1 재조회
    T1_Requery --&gt; Check: 결과 비교
    Check --&gt; PhantomDetected: 불일치일 경우
    Check --&gt; NoPhantom: 불일치 없을 경우
    PhantomDetected --&gt; Action: 대응(락/직렬화/재시도/오류)
    Action --&gt; [*]
    NoPhantom --&gt; [*]
</pre><ul><li><p>트랜잭션 간 시간축에서 T1 이 처음 읽은 후 T2 가 삽입/삭제를 하여 DB 상태가 변하면, T1 의 재조회에서 팬텀이 발생할 수 있다.</p></li><li><p>SI 라면 T1 이 시작 시점 스냅샷을 유지해 &rsquo; 재조회 시에도 같은 스냅샷 &rsquo; 이 보일 수 있으나, 범위 삽입의 관점에서는 SI 구현 방식과 DB 의 쓰기 충돌 정책에 따라 결과가 달라진다.</p></li><li><p>결과 불일치가 감지되면 설계·운영 차원에서 적절한 보상 (재시도·Rollback) 또는 예방 (격리 수준 상향/락 적용) 조치를 취한다.</p></li></ul><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=팬텀-방지-기법의-가치와-실무-적용>팬텀 방지 기법의 가치와 실무 적용<a hidden class=anchor aria-hidden=true href=#팬텀-방지-기법의-가치와-실무-적용>#</a></h4><ul><li>팬텀을 방지하면 <strong>집계·리포트·원장 등에서 같은 트랜잭션이 반복 조회해도 항상 같은 결과</strong>를 보장할 수 있다.</li><li>이를 위해 사용할 수 있는 대표 수단 네 가지 (직렬화, 범위잠금, MVCC/스냅샷, DB 제약) 는 각기 **장점 (무결성·안정성)**과 **단점 (성능·복잡도)**이 있으므로, **중요도 (데이터 가치)**와 **트래픽 특성 (충돌 빈도/응답성 요구)**을 보고 선택한다.</li></ul><h5 id=phantom-방지-기법별-장점-표>Phantom 방지 기법별 장점 표<a hidden class=anchor aria-hidden=true href=#phantom-방지-기법별-장점-표>#</a></h5><table><thead><tr><th>장점</th><th>기술 근거 (메커니즘)</th><th style=text-align:right>실무 효과 (비즈니스·운영)</th><th>적용 예시</th><th>주의점</th></tr></thead><tbody><tr><td>직렬 가능 정합성</td><td>Serializable / SSI(직렬화 보장 또는 충돌 감지 후 롤백)</td><td style=text-align:right>정산·감사 리스크 최소화, 완전한 일관성 보장</td><td>금융원장, 결제정산</td><td>성능 저하·재시도 로직 필요</td></tr><tr><td>범위 안전성</td><td>키 - 범위/Next-Key Lock(범위 삽입 차단)</td><td style=text-align:right>과예약/중복 삽입 방지, 예약·재고 안전성 확보</td><td>항공 좌석, 예약 시스템</td><td>락 대기·교착 가능성 증가</td></tr><tr><td>스냅샷 읽기 안정성</td><td>MVCC / Snapshot Isolation(읽기 일관성 제공)</td><td style=text-align:right>리포팅·장기 읽기 시 읽기 - 쓰기 충돌 감소</td><td>리포팅, 장기 조회</td><td>범위 삽입 팬텀은 격리 수준 의존</td></tr><tr><td>선언적 제약 보완</td><td>Unique, Check, 트리거 (도메인 규칙 강제)</td><td style=text-align:right>애플리케이션 단순화·데이터 무결성 보강</td><td>유일키·고유제약·간단 불변식</td><td>복잡 집계 불변식엔 한계</td></tr></tbody></table><ul><li>각 기법은 서로 보완적이다.</li><li><code>직렬화</code> 는 완전한 무결성을 제공하나 비용이 크고, <code>범위 잠금</code> 은 특정 도메인 (예약 등) 에 효과적이지만 동시성 손실을 낳는다.</li><li><code>MVCC</code> 는 읽기 성능을 유지하면서 많은 읽기 - 쓰기 충돌을 줄여주지만, 팬텀을 완전 차단하려면 격리 수준이나 추가 메커니즘이 필요하다.</li><li><code>선언적 제약</code> 은 기본적인 도메인 규칙을 강제해 실수로 인한 데이터 오류를 줄여준다. 따라서 **도메인 중요도 (금융 vs 로그)**와 **시스템 트래픽 특성 (충돌 빈도, 응답성 요구)**을 기준으로 혼합 적용하는 것이 실무상 최적이다.</li></ul><h4 id=phantom-read-단점제약과-실무-대책>Phantom Read 단점·제약과 실무 대책<a hidden class=anchor aria-hidden=true href=#phantom-read-단점제약과-실무-대책>#</a></h4><p>Phantom Read 를 방지하려면 강한 일관성을 위한 기법들이 필요하지만, 이들 기법은 <strong>성능 저하·락 경합·운영 복잡성</strong> 같은 단점을 동반한다.<br>트랜잭션을 짧게 유지하고 (장기 트랜잭션 회피), 핵심 쿼리에만 격리 상향을 적용하거나 (부분적 적용), 인덱스·쿼리 최적화로 범위 락의 비용을 줄이는 것이 현실적 해법이다. 대규모 데이터나 높은 쓰기 부하 환경에서는 파티셔닝·CQRS·비동기 처리 같은 아키텍처 대안도 고려해야 한다.</p><h5 id=phantom-read-관련-주요-단점>Phantom Read 관련 주요 단점<a hidden class=anchor aria-hidden=true href=#phantom-read-관련-주요-단점>#</a></h5><table><thead><tr><th>단점</th><th>설명</th><th>원인</th><th>실무 문제</th><th>완화/해결책</th><th>대안 기술</th></tr></thead><tbody><tr><td>동시성 저하</td><td>강한 격리·범위잠금 사용 시 처리량 감소</td><td>트랜잭션 직렬화·범위 락</td><td>TPS 감소, 응답 지연</td><td>파티셔닝·트랜잭션 최소화·쿼리 최적화</td><td>MVCC(SSI), CQRS</td></tr><tr><td>락 경합·교착</td><td>잠금 충돌로 대기/교착 발생</td><td>락 순서 불일치·핫로우</td><td>롤백·재시도 증가</td><td>락 순서 표준화·타임아웃·재시도 정책</td><td>낙관적 제어 (OCC)</td></tr><tr><td>구현·운영 복잡성</td><td>락·격리 기법 튜닝·디버깅 난이도</td><td>DB 별 구현 차이·내부 메커니즘 복잡</td><td>설정 오류·성능 이슈</td><td>자동화·관측성·운영 가이드</td><td>Managed DB / 자동화 기능</td></tr></tbody></table><p>강한 일관성을 보장하려 할수록 동시성·운영 복잡성이 증가한다. 따라서 실무에서는 핵심 도메인만 강격리를 적용하고, 대부분은 성능 최적화·원자 쿼리·낙관적 패턴을 우선 적용해 비용을 줄이는 전략이 바람직하다.</p><h5 id=phantom-read-관련-주요-제약사항>Phantom Read 관련 주요 제약사항<a hidden class=anchor aria-hidden=true href=#phantom-read-관련-주요-제약사항>#</a></h5><table><thead><tr><th>제약사항</th><th>설명</th><th>원인</th><th>영향</th><th>해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>트랜잭션 지속 시간</td><td>장시간 트랜잭션은 리소스 고정</td><td>복잡한 쿼리·외부 I/O</td><td>블로킹·버전/UNDO 팽창</td><td>트랜잭션 분해·리포트 분리</td><td>ETL/리플리카 리드</td></tr><tr><td>범위 락의 한계 (인덱스 의존)</td><td>범위잠금은 인덱스 기반으로만 효율</td><td>인덱스 미비 시 풀스캔 발생</td><td>광범위 락 → 성능 악화</td><td>인덱스 설계·커버링 인덱스</td><td>데이터 모델 변경 (NoSQL)</td></tr><tr><td>DBMS 별 구현 차이</td><td>동일 격리명칭도 동작 불일치</td><td>표준 해석·역사적 구현 차이</td><td>이식성·테스트 복잡도 증가</td><td>엔진별 테스트·문서화</td><td>운영 표준화 / Managed DB</td></tr></tbody></table><p>제약사항은 환경·데이터 모델·DB 선택으로부터 기인하므로, 설계 초기부터 데이터 분포 (핫키 여부), 쿼리 패턴, DB 엔진의 특성을 고려해야 한다. 인덱스와 트랜잭션 길이를 설계 요건에 맞추는 것이 가장 실효성 높은 완화책이다.</p><h4 id=격리락-전략의-트레이드오프와-해법>격리·락 전략의 트레이드오프와 해법<a hidden class=anchor aria-hidden=true href=#격리락-전략의-트레이드오프와-해법>#</a></h4><p>격리 수준을 높이면 데이터 일관성은 좋아지지만 동시에 처리량과 응답 속도가 떨어지는 일이 흔하다.<br>락 (비관적) 은 즉시 충돌을 막지만 기다림과 교착이 생기고, 낙관적 (버전검사/SSI) 은 빠르게 동작하다가 충돌될 때 롤백·재시도가 필요하다.<br>실무에서는 핵심 트랜잭션만 강하게 보호하고 (선택적 직렬화), 나머지는 낙관적으로 운영해 두 방식의 균형을 맞춘다.</p><h5 id=정합성-vs-동시성-선택-비교표>정합성 Vs 동시성: 선택 비교표<a hidden class=anchor aria-hidden=true href=#정합성-vs-동시성-선택-비교표>#</a></h5><table><thead><tr><th>선택</th><th style=text-align:right>장점</th><th>단점</th><th>고려 기준 (언제 선택)</th></tr></thead><tbody><tr><td>정합성 강화 (Serializable / FOR UPDATE)</td><td style=text-align:right>이상현상 (phantom, lost update) 직접 차단</td><td>TPS 감소, 지연·데드락↑, 확장성↓</td><td>금융·원장·회계 등 강한 무결성 요구</td></tr><tr><td>동시성 우선 (MVCC + 낙관적 재시도)</td><td style=text-align:right>높은 동시성·스냅샷 읽기 성능, 락 경합 감소</td><td>충돌시 직렬화 오류·재시도 필요, 애플리케이션 복잡성</td><td>쓰기 충돌 낮은 워크로드, 대규모 읽기 중심</td></tr></tbody></table><p>정합성 강화는 안전하지만 비용이 크고, 동시성 우선은 효율적이나 충돌 발생 시 후처리가 필요하다.<br>실무에서는 두 극단 사이에서 워크로드 특성에 따라 적절히 섞어 적용 (핵심 트랜잭션만 강하게 보호 등) 하는 것이 일반적이다.</p><h5 id=부분적-교차-및-하이브리드-방법>부분적 교차 및 하이브리드 방법<a hidden class=anchor aria-hidden=true href=#부분적-교차-및-하이브리드-방법>#</a></h5><p>하이브리드 기법은 트레이드오프 해소를 목표로 통상 다음 요소를 조합한다:</p><ul><li><strong>선택적 직렬화, 낙관적 기본 + 비관적 폴백, 파티셔닝/샤딩, 운영 최적화 (읽기 전용 표시·풀 크기 제한)</strong>.</li></ul><p>방법은 특정 트레이드오프를 줄여준다.</p><ol><li><p><strong>선택적 직렬화 (Selective Serializable)</strong></p><ul><li>구성 요소: 트랜잭션 분류 (핵심 vs 비핵심), DB 레벨 또는 애플리케이션 레벨에서 격리 적용.</li><li>목적: 전체 TPS 희생 없이 핵심 데이터 정합성 보장.</li><li>장점: 정합성 확보 범위를 좁혀 비용 최소화.</li><li>고려사항: 트랜잭션 분류 정확성 필요, 운영·테스트 복잡성 증가.</li></ul></li><li><p><strong>낙관적 → 비관적 폴백</strong></p><ul><li>구성 요소: 엔티티 버전 (ETag), 충돌 빈도 감지, 자동으로 FOR UPDATE 전환 규칙.</li><li>목적: 대부분의 경우 빠른 낙관적 처리, 충돌이 잦은 경로는 강제 락.</li><li>장점: 전체 성능 유지 + 충돌 경로 안전성.</li><li>고려사항: 경로 탐지 로직과 전환 비용, 복잡한 예외 처리.</li></ul></li><li><p><strong>파티셔닝/샤딩 기반 분리</strong></p><ul><li>구성 요소: 샤드 키 설계, 라우팅, 로컬 트랜잭션 선호.</li><li>목적: 충돌 영역을 분리해 전역 직렬화 필요성 축소.</li><li>장점: 확장성 확보, 로컬 성능 향상.</li><li>고려사항: 복잡한 분산 트랜잭션, 핫스팟 관리 필요.</li></ul></li><li><p><strong>MVCC(SSI) + 운영 최적화</strong></p><ul><li>구성 요소: 읽기 전용 선언, 연결 풀 관리, 활성 트랜잭션 제한.</li><li>목적: SSI 의 재시도·오버헤드를 최소화.</li><li>장점: 스냅샷 읽기 성능 유지하면서 충돌 제어.</li><li>고려사항: 운영 정책 엄수 필요 (예: read-only 선언 누락 시 성능 저하).</li></ul></li></ol><h5 id=부분적-교차하이브리드-전략-비교>부분적 교차·하이브리드 전략 비교<a hidden class=anchor aria-hidden=true href=#부분적-교차하이브리드-전략-비교>#</a></h5><table><thead><tr><th>방법</th><th style=text-align:right>구성 요소</th><th>적용 목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>선택적 직렬화</td><td style=text-align:right>트랜잭션 분류 + 격리 정책</td><td>핵심만 강화해 비용 최소화</td><td>정합성 확보 + 전체 TPS 피해 감소</td><td>분류 오판 위험, 테스트 복잡성</td></tr><tr><td>낙관→비관 폴백</td><td style=text-align:right>버전검사 + 자동 전환 규칙</td><td>충돌 경로만 락 처리</td><td>평소 성능 유지, 충돌 경로 안전</td><td>전환 기준·추적 필요</td></tr><tr><td>파티셔닝/샤딩</td><td style=text-align:right>샤드 키, 라우팅</td><td>충돌 도메인 분리</td><td>확장성↑, 로컬 충돌↓</td><td>핫스팟·분산 트랜잭션 복잡</td></tr><tr><td>MVCC+ 운영 최적화</td><td style=text-align:right>read-only, 풀 제한</td><td>SSI 오버헤드 저감</td><td>스냅샷 읽기 유지, 충돌 감소</td><td>운영 규율·모니터링 필수</td></tr></tbody></table><p>하이브리드 전략은 <strong>정합성 보장 범위를 좁히거나 충돌을 국지화</strong>함으로써 전체 성능 저하를 줄이는 실무적 해법이다.<br>각 방법은 설계·운영 복잡성을 대가로 가져가므로 사전 분석·테스트·모니터링이 필수다.</p><h4 id=비즈니스-기반-팬텀-적용-결정표>비즈니스 기반 팬텀 적용 결정표<a hidden class=anchor aria-hidden=true href=#비즈니스-기반-팬텀-적용-결정표>#</a></h4><p>팬텀 리드 문제는 특정 범위 (예: 특정 날짜 범위, 특정 조건) 의 데이터 집합이 트랜잭션 중간에 다른 트랜잭션으로 인해 바뀌는 것이다.<br>핵심 질문은 " 이 데이터의 일관성이 비즈니스적으로 얼마나 중요한가?" 다.<br>중요하면 Serializable 또는 범위 락으로 강하게 보호하고, 중요도가 낮고 충돌이 드물면 Snapshot Isolation 에 재시도 로직을 더해 성능을 유지한다. NoSQL 을 선택할 때는 DB 가 보장하지 못하는 제약을 애플리케이션이 어떻게 보완할지 미리 설계해야 한다.</p><h5 id=팬텀리드-적용-권장-매트릭스>팬텀리드 적용 권장 매트릭스<a hidden class=anchor aria-hidden=true href=#팬텀리드-적용-권장-매트릭스>#</a></h5><table><thead><tr><th>적용 대상 (유스케이스)</th><th>권장 접근 방식</th><th>장점</th><th style=text-align:right>단점/리스크</th><th>선택 기준 (언제 선택)</th></tr></thead><tbody><tr><td>금융 결제·정산 (불변식 필수)</td><td>Serializable / 범위 락</td><td>완전한 논리적 일관성 보장</td><td style=text-align:right>성능 저하·재시도 증가</td><td>무결성 비용이 매우 큰 경우</td></tr><tr><td>예약·좌석·재고 (중요)</td><td>범위 락 또는 SI+ 엄격 검증</td><td>과예약 방지 (직렬화성 확보 가능)</td><td style=text-align:right>락 경합·대기 발생 가능</td><td>동시 쓰기 빈도·핫스팟 여부 검토</td></tr><tr><td>집계 보고서 (일관성 중요)</td><td>SI + OLAP 용 스냅샷, 혹은 배치 집계</td><td>읽기 성능 우수, 시점 일관성 제공</td><td style=text-align:right>최신 데이터 반영 지연 가능</td><td>실시간성 필요성에 따라 결정</td></tr><tr><td>일반 로그·이력 데이터 (읽기 위주)</td><td>Read Committed / Eventually Consistent</td><td>높은 처리량·낮은 비용</td><td style=text-align:right>일관성 약화 허용</td><td>무결성 요구 낮음</td></tr><tr><td>분산/샤딩 환경</td><td>샤드 설계 + 애플리케이션 검증, 필요시 분산 락</td><td>수평확장</td><td style=text-align:right>분산 트랜잭션 복잡성</td><td>샤드 범위에 제약 존재 시 신중 적용</td></tr><tr><td>충돌 드문 쓰기 (성능 우선)</td><td>SI + 낙관적 락 (버전) + 재시도</td><td>높은 처리량·낮은 락 부담</td><td style=text-align:right>재시도 코드 필요, 충돌 시 비용</td><td>충돌률이 낮을 때</td></tr></tbody></table><p>핵심은 " 비즈니스 손실 발생 가능성 (무결성 비용)" 과 " 실제 충돌 패턴 (충돌률·핫스팟)" 을 기준으로 기술을 선택하는 것이다. 무결성 위험이 크면 성능 희생을 감수하고 강격리를 택하고, 그렇지 않으면 성능 쪽으로 기울이며 애플리케이션 레벨 보완을 적용한다.</p><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-팬텀-재현과-방지-postgresql>실습 예제: 팬텀 재현과 방지 (PostgreSQL)<a hidden class=anchor aria-hidden=true href=#실습-예제-팬텀-재현과-방지-postgresql>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>RC/REPEATABLE READ 에서 팬텀/스냅샷 동작을 관찰하고, SERIALIZABLE(SSI) 에서 방지 확인</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>PostgreSQL 14+ / psql, 적절한 인덱스</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p>스키마 준비</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span><span class=lnt id=hl-4-3><a class=lnlinks href=#hl-4-3>3</a>
</span><span class=lnt id=hl-4-4><a class=lnlinks href=#hl-4-4>4</a>
</span><span class=lnt id=hl-4-5><a class=lnlinks href=#hl-4-5>5</a>
</span><span class=lnt id=hl-4-6><a class=lnlinks href=#hl-4-6>6</a>
</span><span class=lnt id=hl-4-7><a class=lnlinks href=#hl-4-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>booking</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>SERIAL</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>room_id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>start_ts</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>end_ts</span><span class=w>   </span><span class=k>TIMESTAMP</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>ix_booking_room_time</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>booking</span><span class=p>(</span><span class=n>room_id</span><span class=p>,</span><span class=w> </span><span class=n>start_ts</span><span class=p>,</span><span class=w> </span><span class=n>end_ts</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>팬텀 후보 질의 (겹침 금지 체크)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- T1: 가용성 확인 (REPEATABLE READ)
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>REPEATABLE</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>booking</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>room_id</span><span class=o>=</span><span class=mi>101</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=p>(</span><span class=n>end_ts</span><span class=o>&lt;=</span><span class=p>:</span><span class=n>new_start</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>start_ts</span><span class=o>&gt;=</span><span class=p>:</span><span class=n>new_end</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 결과가 0이면 가용
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>동시 삽입</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- T2: 새 예약 삽입 후 커밋 (겹침)
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>booking</span><span class=p>(</span><span class=n>room_id</span><span class=p>,</span><span class=n>start_ts</span><span class=p>,</span><span class=n>end_ts</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>VALUES</span><span class=p>(</span><span class=mi>101</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;2025-09-12 10:00&#39;</span><span class=p>,</span><span class=s1>&#39;2025-09-12 11:00&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>재조회</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- T1: 동일 조건 재조회
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>booking</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>room_id</span><span class=o>=</span><span class=mi>101</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=p>(</span><span class=n>end_ts</span><span class=o>&lt;=</span><span class=p>:</span><span class=n>new_start</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>start_ts</span><span class=o>&gt;=</span><span class=p>:</span><span class=n>new_end</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- Postgres REPEATABLE READ(SI): 스냅샷 고정 → 여전히 0(겹침을 못 봄)
</span></span></span><span class=line><span class=cl><span class=c1>-- SERIALIZABLE로 실행 시 충돌 감지로 T1 또는 T2 중 하나가 에러로 롤백됨
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>방지: SERIALIZABLE + 재시도</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 애플리케이션 의사코드
</span></span></span><span class=line><span class=cl><span class=n>RETRY</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>SERIALIZABLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- 동일 가용성 체크 + 삽입
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- …
</span></span></span><span class=line><span class=cl><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- serialization_failure 발생 시 재시도
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>RR: 팬텀을 보지 않지만 <strong>쓰기 스큐</strong> 위험</li><li>SERIALIZABLE: 충돌 시 <code>ERROR: could not serialize access due to concurrent update</code> → 재시도로 정합성 보장</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li><code>pg_locks</code> 에서 <code>SIReadLock</code> 관찰, 인덱스 제거 후 경합 관찰</li></ul><h5 id=실습-예제-innodb-next-key-로-범위-보호-mysql>실습 예제: InnoDB Next-Key 로 범위 보호 (MySQL)<a hidden class=anchor aria-hidden=true href=#실습-예제-innodb-next-key-로-범위-보호-mysql>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>REPEATABLE READ + <strong>잠금 조회</strong>로 팬텀 방지</li></ul><h6 id=단계>단계<a hidden class=anchor aria-hidden=true href=#단계>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>inventory</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>sku</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>qty</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>price</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>2</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>category</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=n>ix_cat_price</span><span class=w> </span><span class=p>(</span><span class=n>category</span><span class=p>,</span><span class=w> </span><span class=n>price</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- T1 (RR): 가격대 범위 잠금
</span></span></span><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>inventory</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>category</span><span class=o>=</span><span class=mi>7</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=mi>20</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- Next-Key로 범위+갭 잠금
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- T2: 동일 범위 신규 삽입 시도 → 블록 또는 대기
</span></span></span><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>inventory</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=s1>&#39;N-001&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=mi>12</span><span class=p>.</span><span class=mi>00</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h6 id=결과>결과<a hidden class=anchor aria-hidden=true href=#결과>#</a></h6><ul><li>T2 가 커밋 전까지 대기/타임아웃 → 팬텀 방지</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>인덱스 제거 후 범위 잠금 확장과 경합 관찰</li></ul><h5 id=실습-예제-팬텀-리드-발생-및-방지-실험>실습 예제: 팬텀 리드 발생 및 방지 실험<a hidden class=anchor aria-hidden=true href=#실습-예제-팬텀-리드-발생-및-방지-실험>#</a></h5><h6 id=목적-2>목적<a hidden class=anchor aria-hidden=true href=#목적-2>#</a></h6><ul><li>팬텀 리드의 발생 원리와 Next-Key Lock 으로 방지하는 과정을 직접 체험.</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>MySQL 8.x(InnoDB) 설치</li><li>orders 테이블, 기본 트랜잭션 권한</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>Step 1: 팬텀 리드 발생 테스트</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 트랜잭션 A
</span></span></span><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;pending&#39;</span><span class=p>;</span><span class=w> </span><span class=c1>-- 결과 예: 5
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 트랜잭션 B
</span></span></span><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>orders</span><span class=p>(</span><span class=n>status</span><span class=p>,</span><span class=w> </span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;pending&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>10000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 트랜잭션 A
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;pending&#39;</span><span class=p>;</span><span class=w> </span><span class=c1>-- 결과 예: 6 (팬텀 리드 발생)
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Step 2: Next-Key Lock 을 통한 팬텀 리드 방지</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 트랜잭션 A
</span></span></span><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;pending&#39;</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 트랜잭션 B
</span></span></span><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>orders</span><span class=p>(</span><span class=n>status</span><span class=p>,</span><span class=w> </span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;pending&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>20000</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 대기 상태, 팬텀 리드 방지됨
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- 트랜잭션 A
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;pending&#39;</span><span class=p>;</span><span class=w> </span><span class=c1>-- 변동 없음
</span></span></span><span class=line><span class=cl><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><ul><li>첫 예제: 트랜잭션 B 의 INSERT 결과가 트랜잭션 A 의 조건 검색에 새로 반영됨 (팬텀 리드).</li><li>두 번째 예제: Next-Key Lock 이 범위 내 신규 데이터 삽입을 차단, 결과 일치.</li></ul><h6 id=추가-실험-2>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-2>#</a></h6><ul><li>격리 수준 (Read Committed, Repeatable Read, Serializable) 변경해 트랜잭션 결과 비교.</li><li>장기/대량 트랜잭션에서 Lock 경합, 성능 변화 측정.</li></ul><h3 id=운영-및-최적화>운영 및 최적화<a hidden class=anchor aria-hidden=true href=#운영-및-최적화>#</a></h3><h4 id=phantom-read-관측성-설계와-런북>Phantom Read 관측성 설계와 런북<a hidden class=anchor aria-hidden=true href=#phantom-read-관측성-설계와-런북>#</a></h4><p>운영에서 팬텀 리드를 잡으려면 <strong>트랜잭션 실행 시간</strong>, <strong>락 상태</strong>, <strong>직렬화 실패 (또는 앱에서의 serialization 예외)</strong>, <strong>특정 INSERT/DELETE 패턴</strong>, <strong>리플리카 지연</strong>, 그리고 **쿼리 플랜 (인덱스 사용 여부)**를 함께 관측해야 한다.<br>이들을 대시보드로 모아 p95 트랜잭션 시간, 락 대기, 직렬화 실패율 같은 알람을 설정하면 문제를 조기에 탐지하고, 런북 (세션 종료·마스터 강제 읽기·임시 격리 수준 변경) 으로 즉시 완화할 수 있다.</p><h5 id=phantom-read-모니터링-분류>Phantom Read 모니터링 분류<a hidden class=anchor aria-hidden=true href=#phantom-read-모니터링-분류>#</a></h5><h6 id=메트릭-metrics>메트릭 (Metrics)<a hidden class=anchor aria-hidden=true href=#메트릭-metrics>#</a></h6><p>핵심 목적: 상태를 수치로 관측해 추세·이상 탐지.</p><ul><li><p>주요 항목: 트랜잭션 p95/p99 지연, 락 대기 평균·p95, 직렬화 실패율 (%), INSERT/DELETE 빈도 (조건별), 리플리카 지연 (ms).</p></li><li><p>임계값 예시 (환경에 따라 조정):</p><ul><li>트랜잭션 p95 > 5s → 경고</li><li>락 대기 p95 > 2000ms → 경고</li><li>직렬화 실패율 > 0.5% (전체 트랜잭션 대비) → 심각</li><li>리플리카 지연 > 200ms → 주의</li></ul></li></ul><table><thead><tr><th>메트릭</th><th style=text-align:right>목적</th><th>수집 위치/방법</th><th style=text-align:right>예시 임계값</th></tr></thead><tbody><tr><td>트랜잭션 지연 (p95)</td><td style=text-align:right>긴 트랜잭션 탐지</td><td>DB <code>pg_stat_activity</code> / Query Store</td><td style=text-align:right>p95 > 5s</td></tr><tr><td>락 대기 (p95)</td><td style=text-align:right>범위 락/경합 탐지</td><td><code>pg_locks</code> / performance_schema</td><td style=text-align:right>p95 > 2000ms</td></tr><tr><td>직렬화 실패율</td><td style=text-align:right>Serializable 실패 신호</td><td>DB 로그 / 앱 에러 코드 (40001)</td><td style=text-align:right>> 0.5%</td></tr><tr><td>INSERT 빈도 (조건별)</td><td style=text-align:right>핫 인서트 감지</td><td>Slow query / perf schema</td><td style=text-align:right>증가율 급증 감지</td></tr><tr><td>리플리카 지연</td><td style=text-align:right>스테일 리드 탐지</td><td>replica status</td><td style=text-align:right>> 200ms</td></tr></tbody></table><ul><li>요약: 메트릭은 조기 경보 역할. 수치 이상시 로그·트레이스로 원인 분석으로 넘어가라.</li></ul><h6 id=로그-logs>로그 (Logs)<a hidden class=anchor aria-hidden=true href=#로그-logs>#</a></h6><p>핵심 목적: 구체적 오류·deadlock·serialization 메시지로 근본 원인 추적.</p><ul><li><p>수집 포인트: DB 서버 로그 (&ldquo;could not serialize access&rdquo; 등), InnoDB deadlock history, 앱 예외 로그 (재시도/40001).</p></li><li><p>활용: 알람 시 샘플 로그 자동 수집 (최근 N 건) → 루트 원인 판별</p></li></ul><table><thead><tr><th>로그 유형</th><th style=text-align:right>목적</th><th>수집 위치</th><th style=text-align:right>활용 예</th></tr></thead><tbody><tr><td>직렬화 실패 메시지</td><td style=text-align:right>팬텀·직렬성 충돌 증거</td><td>Postgres log / app log</td><td style=text-align:right>트랜잭션 ID 분석</td></tr><tr><td>Deadlock trace</td><td style=text-align:right>락 충돌 상세</td><td>InnoDB status / SQL Server deadlock graph</td><td style=text-align:right>리소스·쿼리 식별</td></tr><tr><td>Slow query sample</td><td style=text-align:right>어떤 쿼리가 범위 스캔하는지 확인</td><td>slow query log / Query Store</td><td style=text-align:right>인덱스 리팩터링 대상 선별</td></tr></tbody></table><ul><li>요약: 로그는 &rsquo; 증거 &rsquo; 다. 메트릭 알람과 함께 로그 샘플을 자동으로 집계하라.</li></ul><h6 id=트레이스프로파일-traces>트레이스/프로파일 (Traces)<a hidden class=anchor aria-hidden=true href=#트레이스프로파일-traces>#</a></h6><p>핵심 목적: 요청 -DB- 트랜잭션의 end-to-end 흐름 이해.</p><ul><li><p>수집 포인트: APM(예: OpenTelemetry), DB 플레인 텍스트 트레이스, 쿼리 태깅 (트랜잭션 ID).</p></li><li><p>활용: 어떤 API 가 어떤 쿼리를 호출하며 트랜잭션이 길어지는지 식별</p></li></ul><table><thead><tr><th>트레이스 항목</th><th style=text-align:right>목적</th><th>수집 방법</th><th style=text-align:right>활용 예</th></tr></thead><tbody><tr><td>분산 트레이스</td><td style=text-align:right>서비스→DB 호출 흐름</td><td>APM/OpenTelemetry</td><td style=text-align:right>특정 API 가 긴 트랜잭션 유발 식별</td></tr><tr><td>쿼리 태그</td><td style=text-align:right>트랜잭션 매핑</td><td>트랜잭션 ID 로깅</td><td style=text-align:right>문제 트랜잭션 역추적</td></tr></tbody></table><ul><li>요약: 트레이스는 메트릭·로그를 연결하는 고리로, 재현 및 원인 규명 속도를 높임.</li></ul><h6 id=쿼리플랜인덱스-검사>쿼리플랜·인덱스 검사<a hidden class=anchor aria-hidden=true href=#쿼리플랜인덱스-검사>#</a></h6><p>핵심 목적: 팬텀 방지 가능성 (범위 락 적용 여부) 사전 확인.</p><ul><li><p>수집 포인트: EXPLAIN/EXPLAIN ANALYZE, 자동화된 쿼리 검사 툴</p></li><li><p>점검 포인트: 범위 쿼리가 인덱스를 타는지, 풀 스캔이 발생하면 범위를 잠그기 어렵다는 점</p></li></ul><table><thead><tr><th>점검 항목</th><th style=text-align:right>목적</th><th>검사 방법</th><th>권장 조치</th></tr></thead><tbody><tr><td>인덱스 사용 여부</td><td style=text-align:right>범위 락 유효성 판단</td><td>EXPLAIN</td><td>인덱스 추가/쿼리 리팩터링</td></tr><tr><td>범위 조건 변경</td><td style=text-align:right>predicate 고정화</td><td>쿼리 리팩터링</td><td>범위 잠금 가능성 증가</td></tr></tbody></table><ul><li>요약: 예방적 관점에서 가장 중요한 작업. 운영 도중 패치 전 반드시 점검.</li></ul><h6 id=알람런북-alerts--runbook>알람·런북 (Alerts & Runbook)<a hidden class=anchor aria-hidden=true href=#알람런북-alerts--runbook>#</a></h6><p>핵심 목적: 이상 징후 발생 시 일관된 즉시 대응 수행.</p><ul><li><p>알람 예시: 트랜잭션 p95 초과, 직렬화 실패율 초과, 리플리카 지연 초과 등</p></li><li><p>런북 요약 (우선 순위):</p><ol><li>알람 수신 → 관련 세션/쿼리 조회</li><li>영향 범위 판단 (영향 API/사용자)</li><li>단기 완화: 문제 세션 강제 종료 / 마스터에서 읽기 강제 / 트랜잭션 타임아웃 단축</li><li>근본 대책 적용 (쿼리 수정·인덱스·원자적 UPDATE·격리 수준 변경)</li><li>사후 분석·회귀 테스트</li></ol></li></ul><table><thead><tr><th>알람 유형</th><th style=text-align:right>1 차 대응</th><th style=text-align:right>2 차 대응</th><th style=text-align:right>복구 검증</th></tr></thead><tbody><tr><td>트랜잭션 p95 초과</td><td style=text-align:right>문제 세션 식별/강제 종료</td><td style=text-align:right>트랜잭션 범위 축소 패치</td><td style=text-align:right>p95 정상화 확인</td></tr><tr><td>직렬화 실패율↑</td><td style=text-align:right>재시도 정책 점검 (앱)</td><td style=text-align:right>임시 격리 조정/쿼리 수정</td><td style=text-align:right>실패율 하락 확인</td></tr><tr><td>리플리카 지연↑</td><td style=text-align:right>세션 세팅으로 마스터 강제 읽기</td><td style=text-align:right>복제 토폴로지 점검</td><td style=text-align:right>리플리카 lag 정상화</td></tr></tbody></table><ul><li>요약: 알람은 자동화된 정확한 1 차 대응 (세션 종료·마스터 강제 읽기) 이 중요. 근본 패치는 별도 변경 프로세스로 진행.</li></ul><h5 id=phantom-read-모니터링-종합표>Phantom Read 모니터링 종합표<a hidden class=anchor aria-hidden=true href=#phantom-read-모니터링-종합표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>주요 지표·로그</th><th style=text-align:right>수집 위치/방법</th><th style=text-align:right>알람 임계값 (예시)</th><th>즉시 대응</th></tr></thead><tbody><tr><td>Metrics</td><td style=text-align:right>txn p95/p99, 락 대기 p95, 직렬화 실패율, INSERT 빈도, replica lag</td><td style=text-align:right>DB stat views, perf schema, app metrics</td><td style=text-align:right>p95 txn >5s / lock p95 >2s / 직렬화 실패 >0.5% / replica lag >200ms</td><td>세션 종료, 트랜잭션 범위 축소</td></tr><tr><td>Logs</td><td style=text-align:right>직렬화 실패 메시지, deadlock trace, slow query samples</td><td style=text-align:right>DB logs, InnoDB status, app logs</td><td style=text-align:right>N/A (이벤트 기반)</td><td>샘플 수집 → 원인 분석</td></tr><tr><td>Traces</td><td style=text-align:right>분산 트레이스, 쿼리→API 매핑</td><td style=text-align:right>APM/OpenTelemetry, query tagging</td><td style=text-align:right>N/A (추적 기반)</td><td>문제 API 차단/트래픽 셰이딩</td></tr><tr><td>Query Plan</td><td style=text-align:right>EXPLAIN 결과 (인덱스 사용 여부)</td><td style=text-align:right>EXPLAIN/ANALYZE</td><td style=text-align:right>N/A (검사 필요)</td><td>인덱스 추가/쿼리 리팩터링</td></tr><tr><td>Alerts & Runbook</td><td style=text-align:right>자동 알람 규칙, 대응 절차</td><td style=text-align:right>Alerting system + Runbook</td><td style=text-align:right>위 임계값 기반</td><td>마스터 강제 읽기, 임시 격리 변경</td></tr></tbody></table><h4 id=phantom-보안컴플라이언스-통제체계>Phantom 보안·컴플라이언스 통제체계<a hidden class=anchor aria-hidden=true href=#phantom-보안컴플라이언스-통제체계>#</a></h4><ul><li>팬텀 리드는 단순한 버그가 아니라 <strong>데이터 무결성 (Integrity)</strong> 관점의 보안·컴플라이언스 리스크다.</li><li>규제 민감 도메인 (금융·회계 등) 은 기술 (격리 설정, 락) 과 운영 (감사 로그, 접근 통제) 을 함께 설계해야 한다.</li><li>실무에서는 모든 트랜잭션에 강한 격리를 적용하기보다 <strong>리스크 기반</strong>으로 핵심 데이터에만 강제 적용하고, 나머지는 애플리케이션 방어·모니터링으로 보완한다.</li></ul><h5 id=phantom-보안컴플라이언스-통제-분류>Phantom 보안·컴플라이언스 통제 분류<a hidden class=anchor aria-hidden=true href=#phantom-보안컴플라이언스-통제-분류>#</a></h5><h6 id=트랜잭션무결성-제어>트랜잭션·무결성 제어<a hidden class=anchor aria-hidden=true href=#트랜잭션무결성-제어>#</a></h6><p>트랜잭션 수준에서 팬텀·갱신 손실을 방지하기 위한 제어들이다.</p><ul><li>적용 대상: 금융 거래, 회계 집계, 재고 변동 등 핵심 도메인 트랜잭션</li><li>주요 수단:<ul><li>격리 수준 정책: 핵심 트랜잭션에 <code>SERIALIZABLE</code> 또는 SSI 적용</li><li>범위 락/next-key lock 사용 (지원 DB 에 한함)</li><li>원자적 SQL(조건부 UPDATE/INSERT) 사용으로 서버 측 연산 위임</li><li>DB 제약 (FOREIGN KEY, CHECK) 및 트리거로 논리 무결성 보강</li></ul></li><li>구현 예 (요약): <code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code> 또는 <code>SELECT … FOR UPDATE</code> 사용</li></ul><table><thead><tr><th>통제 항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>격리 수준 강화</td><td style=text-align:right>팬텀/비직렬성 방지</td><td>SERIALIZABLE / SSI</td></tr><tr><td>범위 락</td><td style=text-align:right>프레디케이트 삽입 차단</td><td>next-key lock</td></tr><tr><td>원자적 SQL</td><td style=text-align:right>네트워크 왕복·중간 상태 제거</td><td>UPDATE … SET v=v+? WHERE id=?</td></tr></tbody></table><ul><li>핵심: 핵심 도메인에는 DB 레벨에서 강한 격리·원자성 제어를 우선 적용하라.</li></ul><h6 id=카테고리-b-접근권한-관리>카테고리 B: 접근·권한 관리<a hidden class=anchor aria-hidden=true href=#카테고리-b-접근권한-관리>#</a></h6><p>사용자 및 서비스의 권한을 최소화하고 역할을 분리하여 무단 변경을 방지한다.</p><ul><li>적용 대상: DB 관리자, 애플리케이션 서비스 계정, 배치/운영 스크립트</li><li>주요 수단:<ul><li>RBAC(역할 기반 접근 제어) 와 최소권한 원칙 적용</li><li>운영/개발/감사 계정 분리 및 임시 권한 발급 프로세스</li><li>세션·연동 인증 (예: Kerberos, OAuth2) 및 TLS 적용</li></ul></li><li>구현 예: 권한 변경은 변경관리 티켓과 매핑, 권한 부여는 최소 권한 템플릿 사용</li></ul><table><thead><tr><th>통제 항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>RBAC / 최소권한</td><td style=text-align:right>권한 오·남용 방지</td><td>역할 템플릿, 정기 권한 리뷰</td></tr><tr><td>계정 분리</td><td style=text-align:right>책임 분리 및 감사 용이</td><td>운영/개발/감사 계정 분리</td></tr><tr><td>인증·통신 보안</td><td style=text-align:right>자격증명 탈취 방지</td><td>TLS, Kerberos</td></tr></tbody></table><ul><li>핵심: 권한은 최소화하고 변경 절차를 엄격히 관리해 누가 무엇을 변경했는지 증빙 가능하게 하라.</li></ul><h6 id=감사증거-보관>감사·증거 보관<a hidden class=anchor aria-hidden=true href=#감사증거-보관>#</a></h6><p>팬텀 등 무결성 위반에 대한 증거 확보와 변조 방지를 위한 로그·기록체계.</p><ul><li>적용 대상: 모든 변경 이벤트, 범위 쿼리 결과 변화, 재시도/실패 이력</li><li>주요 수단:<ul><li>DB 감사 확장 (pgaudit, Oracle Audit) 활성화</li><li>CDC(Change Data Capture) 로 변경 히스토리 저장</li><li>로그 무결성: 서명, WORM 스토리지, HSM 기반 키 관리</li><li>보존 정책: 규제에 맞춘 보관 기간과 접근 통제</li></ul></li><li>구현 예: 감사 로그는 별도 보관소에 적재하고 읽기 전용 보관</li></ul><table><thead><tr><th>통제 항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>감사 로그</td><td style=text-align:right>증거 확보</td><td>pgaudit, Oracle Audit</td></tr><tr><td>CDC</td><td style=text-align:right>변경 내역 추적</td><td>Debezium, AWS DMS</td></tr><tr><td>로그 무결성</td><td style=text-align:right>변조 방지</td><td>로그 서명, WORM</td></tr></tbody></table><ul><li>핵심: 변경의 &rsquo; 누가·언제·무엇을 &rsquo; 증명할 수 있도록 로그와 변경 히스토리를 안전하게 보관하라.</li></ul><h6 id=모니터링운영-대응>모니터링·운영 대응<a hidden class=anchor aria-hidden=true href=#모니터링운영-대응>#</a></h6><p>팬텀 관련 이상 징후를 조기에 탐지하고 운영적으로 대응하는 체계.</p><ul><li>적용 대상: 운영팀, SRE, 개발팀</li><li>주요 수단:<ul><li>지표 수집: 충돌률, 재시도 횟수, 범위 쿼리 불일치 카운트</li><li>경보/대시보드: 임계치 초과 시 알림 및 자동화된 제한 (서킷브레이커)</li><li>정기 검증: 복구 연습, 재현 테스트, 회귀 테스트</li></ul></li><li>구현 예: Prometheus + Grafana, 알림은 PagerDuty/Slack 연동</li></ul><table><thead><tr><th>통제 항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>지표 수집</td><td style=text-align:right>이상 조기탐지</td><td>충돌률/재시도 메트릭</td></tr><tr><td>자동 경보</td><td style=text-align:right>신속 대응</td><td>PagerDuty 알림</td></tr><tr><td>복구 연습</td><td style=text-align:right>복구능력 검증</td><td>정기 restore drill</td></tr></tbody></table><ul><li>핵심: 메트릭 기반으로 문제를 조기에 발견하고 절차화된 대응을 준비하라.</li></ul><h6 id=애플리케이션-방어설계>애플리케이션 방어·설계<a hidden class=anchor aria-hidden=true href=#애플리케이션-방어설계>#</a></h6><p>애플리케이션에서 재시도·중복·보상 등으로 데이터 무결성을 보조하는 체계.</p><ul><li>적용 대상: API 레이어, 배치 작업, 메시지 처리 파이프라인</li><li>주요 수단:<ul><li>Idempotency keys 로 중복 요청 방지</li><li>재시도 정책: 지수 백오프 + 지터, 실패 시 보상 트랜잭션</li><li>조건부 업데이트 (WHERE version = x) + 재시도 루프</li><li>Saga 패턴 (분산 트랜잭션 보상)</li></ul></li><li>구현 예: idempotency key 테이블, version 컬럼 기반 낙관적 락</li></ul><table><thead><tr><th>통제 항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>Idempotency</td><td style=text-align:right>중복 적용 방지</td><td>idempotency key 저장</td></tr><tr><td>재시도 정책</td><td style=text-align:right>transient 충돌 복구</td><td>backoff+jitter</td></tr><tr><td>보상 트랜잭션</td><td style=text-align:right>분산 정합성 확보</td><td>Saga 패턴</td></tr></tbody></table><ul><li>핵심: DB 통제만으로는 충분치 않다—애플리케이션 레벨에서 재시도·중복·보상을 설계하라.</li></ul><h6 id=규제거버넌스>규제·거버넌스<a hidden class=anchor aria-hidden=true href=#규제거버넌스>#</a></h6><p>컴플라이언스 요구를 충족시키기 위한 문서화·검증·보고 체계.</p><ul><li>적용 대상: 리스크·규제 준수팀, 보안·감사 부서</li><li>주요 수단:<ul><li>정책 문서화: 격리 정책, 보존 정책, 권한 정책</li><li>증거 준비: 감사 로그, 변경이력, 테스트 기록</li><li>정기 감사: 내부·외부 감사 준비 및 대응 프로세스</li></ul></li><li>구현 예: 규제별 체크리스트 (PCI/SOX/GDPR) 와 매핑된 통제 매트릭스</li></ul><table><thead><tr><th>통제 항목</th><th style=text-align:right>목적</th><th>구현 예</th></tr></thead><tbody><tr><td>정책 문서화</td><td style=text-align:right>규제 대응 근거</td><td>통제 매트릭스</td></tr><tr><td>증거 보관</td><td style=text-align:right>규제 감사 대응</td><td>감사 로그, 변경 이력</td></tr><tr><td>정기 감사</td><td style=text-align:right>규정 준수 검증</td><td>내부·외부 감사</td></tr></tbody></table><ul><li>핵심: 기술 통제와 함께 문서·증거를 체계적으로 관리해 규제 요구를 만족시켜라.</li></ul><h5 id=phantom-관련-보안컴플라이언스-요약표>Phantom 관련 보안·컴플라이언스 요약표<a hidden class=anchor aria-hidden=true href=#phantom-관련-보안컴플라이언스-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>핵심 통제</th><th>목적</th><th>대표 구현 수단</th></tr></thead><tbody><tr><td>트랜잭션·무결성</td><td style=text-align:right>격리·범위락·원자적 SQL</td><td>팬텀/비직렬성 방지</td><td>SERIALIZABLE/SSI, FOR UPDATE, 조건부 UPDATE</td></tr><tr><td>접근·권한 관리</td><td style=text-align:right>RBAC·최소권한</td><td>변경 권한 통제</td><td>역할 템플릿, 권한 리뷰</td></tr><tr><td>감사·증거 보관</td><td style=text-align:right>감사 로그·CDC·무결성 보관</td><td>증거 확보·포렌식</td><td>pgaudit, CDC, 로그 서명</td></tr><tr><td>모니터링·운영</td><td style=text-align:right>지표·경보·복구 연습</td><td>조기탐지·대응</td><td>Prometheus, 복구 드릴</td></tr><tr><td>앱 방어·설계</td><td style=text-align:right>idempotency·재시도·보상</td><td>중복·충돌 안전화</td><td>idempotency key, Saga</td></tr><tr><td>규제·거버넌스</td><td style=text-align:right>정책·감사 준비</td><td>규제 준수</td><td>통제 매트릭스, 감사 문서</td></tr></tbody></table><h4 id=팬텀-대응을-위한-성능확장-전략>팬텀 대응을 위한 성능·확장 전략<a hidden class=anchor aria-hidden=true href=#팬텀-대응을-위한-성능확장-전략>#</a></h4><ul><li><p><strong>핵심 요지</strong>: 팬텀·동시성 문제를 막으려면 &rsquo; 일관성 보장 &rsquo; 과 &rsquo; 성능/확장성 &rsquo; 사이 균형을 맞춰야 한다.</p><ul><li>자주 업데이트되는 핵심 데이터는 트랜잭션을 짧게 하고 원자적 연산을 사용.</li><li>반복 조회가 많으면 레플리카/캐시로 읽기 분리.</li><li>데이터 규모가 성장하면 샤딩·파티셔닝과 키 분산으로 확장.</li><li>모든 전략은 트레이드오프 (지연·복잡도·재시도) 를 수반하므로 측정 (모니터링) 후 적용해야 안전.</li></ul></li></ul><h5 id=팬텀-대비-성능확장성-카테고리>팬텀 대비 성능·확장성 카테고리<a hidden class=anchor aria-hidden=true href=#팬텀-대비-성능확장성-카테고리>#</a></h5><h6 id=데이터-모델-및-인덱스>데이터 모델 및 인덱스<a hidden class=anchor aria-hidden=true href=#데이터-모델-및-인덱스>#</a></h6><ul><li><p><strong>내용</strong>: 쿼리 패턴을 우선 분석해 인덱스 설계 (복합 인덱스에서 선행 컬럼 = 범위 필터 우선, 통계 기반 컬럼 선택) 를 수행한다. 범위 검색이 많으면 범위 컬럼을 인덱스 앞쪽에 두지 않고, 대신 정렬/조인 패턴을 고려해 설계. 적절한 커버링 인덱스는 디스크 IO·잠금 범위를 줄여 성능 향상과 잠금 폭 축소 (팬텀 완화) 에 기여한다.</p></li><li><p><strong>구체적 권장</strong>:</p><ul><li>쿼리 로그에서 상위 slow query 추출 → 인덱스 후보 도출</li><li>복합 인덱스 설계 규칙: equality 칼럼 먼저, range 칼럼 뒤</li><li>인덱스 대신 물리적 파티션 (시계열 등) 고려</li></ul></li><li><p><strong>주의</strong>: 인덱스 과다 (쓰기 비용 증가) 와 핫스팟 (같은 인덱스 리프 집중) 을 균형있게 관리.</p></li></ul><table><thead><tr><th>항목</th><th>권장 조치</th><th>효과</th></tr></thead><tbody><tr><td>인덱스 순서</td><td>Equality 먼저, Range 뒤</td><td>스캔·잠금 범위 감소</td></tr><tr><td>커버링 인덱스</td><td>SELECT 컬럼 포함</td><td>디스크 IO 감소, 읽기 빠름</td></tr><tr><td>파티셔닝 연계</td><td>날짜/해시 파티션 적용</td><td>스캔 파티션 축소, 병렬 처리</td></tr></tbody></table><ul><li><strong>요약</strong>: 인덱스와 파티셔닝을 쿼리 패턴 기반으로 설계하면 범위 검색 비용과 잠금 범위를 줄여 팬텀 발생 가능성과 지연을 낮출 수 있다.</li></ul><h6 id=트랜잭션-설계격리-최적화>트랜잭션 설계·격리 최적화<a hidden class=anchor aria-hidden=true href=#트랜잭션-설계격리-최적화>#</a></h6><ul><li><p><strong>내용</strong>: 트랜잭션을 가능한 짧게 유지하고, 읽기/쓰기 경계 (읽기 전용은 별도 처리) 를 정리한다. 격리 수준은 워크로드에 따라 선택 (READ COMMITTED → REPEATABLE READ → SERIALIZABLE). 필요 시 동적으로 높은 격리 (Serializable) 를 특정 트랜잭션에만 적용한다. 애플리케이션 레벨에서 낙관적 버전 체크를 포함해 충돌 시 재시도 로직을 설계한다.</p></li><li><p><strong>구체적 권장</strong>:</p><ul><li>트랜잭션 범위 최소화 (읽기→계산→짧은 쓰기)</li><li>낙관적 버전 검사 (버전컬럼) + 재시도 백오프</li><li>선택적 격리 강화: 중요한 트랜잭션만 SERIALIZABLE 로 실행</li></ul></li><li><p><strong>주의</strong>: 직렬화 적용 시 직렬화 오류 증가에 대비한 재시도 정책 필요.</p></li></ul><table><thead><tr><th>항목</th><th>권장 조치</th><th>효과</th></tr></thead><tbody><tr><td>트랜잭션 길이</td><td>짧게 유지 (필요 최소 쿼리만)</td><td>락 시간·MVCC 스냅샷 최소화</td></tr><tr><td>격리 수준</td><td>상황별 선택적 강화</td><td>팬텀/비반복 읽기 완화</td></tr><tr><td>낙관적 검사</td><td>version 컬럼 + WHERE version =?</td><td>충돌 감지 → 재시도 처리</td></tr></tbody></table><ul><li><strong>요약</strong>: 트랜잭션 설계를 경량화하고 필요 시에만 높은 격리를 적용하면 성능과 일관성 사이의 적절한 균형을 달성할 수 있다.</li></ul><h6 id=동시성-제어-락--mvcc--원자화>동시성 제어 (락 / MVCC / 원자화)<a hidden class=anchor aria-hidden=true href=#동시성-제어-락--mvcc--원자화>#</a></h6><ul><li><p><strong>내용</strong>: 동시성 제어는 세부 전략 (비관적 락, MVCC, 원자적 연산) 으로 구현한다. 비관적 락은 범위 잠금 (next-key/gap lock) 으로 삽입을 차단해 팬텀을 방지한다. MVCC 는 읽기 일관성을 제공하지만 범위 삽입에 대한 보호는 격리 수준에 의존한다. 단일값·증감 연산은 원자적 SQL 로 처리해 충돌을 줄인다.</p></li><li><p><strong>구체적 권장</strong>:</p><ul><li>핫스팟엔 비관적 잠금 또는 분산락 적용</li><li>읽기 중심엔 MVCC + 낮은 격리로 성능 확보</li><li>간단 증감은 원자적 UPDATE 사용</li></ul></li><li><p><strong>주의</strong>: 락은 교착·대기 초래, MVCC 는 버전 보존 및 VACUUM 등 관리 비용 유발.</p></li></ul><table><thead><tr><th>항목</th><th>권장 조치</th><th>효과</th></tr></thead><tbody><tr><td>비관적 락</td><td>SELECT FOR UPDATE / range lock</td><td>범위 삽입 차단, 팬텀 방지</td></tr><tr><td>MVCC</td><td>스냅샷 읽기 (읽기 성능)</td><td>읽기 - 쓰기 충돌 완화</td></tr><tr><td>원자 연산</td><td>UPDATE … = … + 1</td><td>충돌 최소화, 간단 안전</td></tr></tbody></table><ul><li><strong>요약</strong>: 상황에 따라 락·MVCC·원자화를 조합하면 동시성 요구를 충족하면서도 팬텀을 제어할 수 있다. 핫스팟은 특별 처리 필요.</li></ul><h6 id=스케일-아웃-샤딩레플리카캐시>스케일 아웃 (샤딩·레플리카·캐시)<a hidden class=anchor aria-hidden=true href=#스케일-아웃-샤딩레플리카캐시>#</a></h6><ul><li><p><strong>내용</strong>: 수평 확장으로 처리량을 늘리되 데이터 접근 패턴에 맞춘 파티셔닝·샤딩 설계가 핵심. 읽기 집중 서비스는 캐시·레플리카로 분산. 쓰기 집중·원자성 필요 작업은 샤드 경계 내에서 처리하도록 도메인 경계 설계. CQRS·이벤트 소싱 적용으로 읽기/쓰기 패스를 분리하면 확장성↑.</p></li><li><p><strong>구체적 권장</strong>:</p><ul><li>샤딩 키는 접근 패턴·균등 분포 기준 선정</li><li>읽기 레이어: 레플리카 + 캐시 조합</li><li>CQRS 적용 검토 (읽기 스케일과 쓰기 일관성 분리)</li></ul></li><li><p><strong>주의</strong>: 분산 트랜잭션 회피 설계 필요, 샤딩 재분배 비용 고려.</p></li></ul><table><thead><tr><th>항목</th><th>권장 조치</th><th>효과</th></tr></thead><tbody><tr><td>샤딩/파티션</td><td>해시/범위 기반 샤딩</td><td>수평 확장, 병렬 처리</td></tr><tr><td>레플리카/캐시</td><td>읽기 분산, 캐시 계층</td><td>읽기 처리량 증가</td></tr><tr><td>CQRS/이벤트</td><td>읽기/쓰기 분리</td><td>확장성 향상, 복잡도 증가</td></tr></tbody></table><ul><li><strong>요약</strong>: 확장은 데이터 분할과 읽기 분산이 핵심. 설계 실패 (핫스팟·재분배 비용) 는 오히려 병목 유발하므로 신중한 키 선정과 테스트가 필요하다.</li></ul><h6 id=운영모니터링테스트>운영·모니터링·테스트<a hidden class=anchor aria-hidden=true href=#운영모니터링테스트>#</a></h6><ul><li><p><strong>내용</strong>: 성능과 일관성을 관리하려면 지표·알람·재현 테스트가 필수다. 주요 지표는 락 대기 시간, deadlock 빈도, 직렬화 오류 (제거해야할 충돌) 수, 재시도율, 트랜잭션 지연 분포, 레플리카 지연 (repl lag) 등이다. 재현 시나리오를 만들어 부하 상태에서 팬텀·직렬화 오류를 검증하고 재시도 정책을 검증한다.</p></li><li><p><strong>구체적 권장</strong>:</p><ul><li>모니터링: DB 락/txn metrics + 애플리케이션 재시도 로그 (예: Prometheus/Grafana 대시보드)</li><li>부하 테스트: 고충돌 시나리오 (동시 삽입/범위 조회) 로 재현</li><li>운영 정책: 재시도 횟수 제한, 지수 백오프, 긴 락 알림/자동화 조치</li></ul></li><li><p><strong>주의</strong>: 모니터링 수치만으로 결정하지 말고, 실제 재현 테스트와 결합해 정책 조정.</p></li></ul><table><thead><tr><th>지표</th><th>모니터링 항목</th><th>목표/임계값 예시</th></tr></thead><tbody><tr><td>락 대기</td><td>avg lock wait ms</td><td>&lt; 100ms (서비스 특성에 따라 조정)</td></tr><tr><td>deadlock</td><td>deadlocks / min</td><td>0 (허용치 낮게)</td></tr><tr><td>직렬화 오류</td><td>serializable failures / min</td><td>낮게 유지, 재시도율 모니터링</td></tr><tr><td>repl lag</td><td>replica lag seconds</td><td>&lt; 1s (강일관성 요구시)</td></tr></tbody></table><ul><li><strong>요약</strong>: 모니터링 + 재현 테스트 + 정책 (재시도·알림) 이 성능·일관성 운영의 핵심이다. 수치와 재현 결과를 통해 전략을 점진 적용하자.</li></ul><h5 id=팬텀-대비-핵심-전략-통합표>팬텀 대비 핵심 전략 통합표<a hidden class=anchor aria-hidden=true href=#팬텀-대비-핵심-전략-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 전략</th><th style=text-align:right>기대 효과</th><th>주의사항</th></tr></thead><tbody><tr><td>데이터 모델/인덱스</td><td>복합 인덱스 (Equality 앞), 파티셔닝</td><td style=text-align:right>I/O·잠금 범위 감소, 쿼리 성능 개선</td><td>인덱스 과다·쓰기 비용</td></tr><tr><td>트랜잭션 설계</td><td>짧은 트랜잭션, 낙관적 검사, 선택적 격리 강화</td><td style=text-align:right>락 시간 최소화, 충돌 재시도 처리</td><td>직렬화 오류·재시도 비용</td></tr><tr><td>동시성 제어</td><td>비관적 락/MVCC/원자 연산 조합</td><td style=text-align:right>팬텀·삽입 충돌 차단, 읽기 성능 확보</td><td>락 대기·버전 관리 비용</td></tr><tr><td>스케일 아웃</td><td>샤딩·레플리카·캐시·CQRS</td><td style=text-align:right>처리량 수평 확장, 읽기 분산</td><td>샤드 설계 실패·복잡성 증가</td></tr><tr><td>운영·모니터링</td><td>락/직렬화 오류/재시도 지표 모니터링</td><td style=text-align:right>조기 탐지·정책 기반 대응</td><td>지표 기반 오판 주의, 재현 필요</td></tr></tbody></table><h4 id=팬텀-리드-예방해결-종합전략>팬텀 리드 예방·해결 종합전략<a hidden class=anchor aria-hidden=true href=#팬텀-리드-예방해결-종합전략>#</a></h4><ol><li><strong>현상 인식:</strong><br>동일 쿼리 (보통 범위나 집계) 를 같은 트랜잭션 내에서 두 번 실행했을 때 결과가 달라진다 → 집계 수치 변화, 중복/누락 레코드 의심.</li><li><strong>원인 확인 체크리스트:</strong><br>동시성 높은 작업? 장기 트랜잭션? 인덱스가 범위 스캔을 유발? DB 격리 수준은?</li><li><strong>빠른 대응 (단기):</strong><br>트랜잭션을 짧게 유지, 문제 쿼리에 대해 일시적으로 높은 격리 수준 적용 (테스트 환경 먼저), 재시도 로직 추가.</li><li><strong>근본 대응 (중장기):</strong><br>격리 수준 설계 (워크로드에 맞는 전략 선택), 인덱스/쿼리 재설계, 범위락/SSI 도입 검토.</li><li><strong>운영·모니터링:</strong><br>Deadlock/lock-wait/long-transactions/undo tablespace 모니터링 및 알람, 재생성 가능한 테스트 케이스로 재현 및 검증.</li></ol><h5 id=팬텀-리드-트러블슈팅-핵심-카테고리>팬텀 리드 트러블슈팅 핵심 카테고리<a hidden class=anchor aria-hidden=true href=#팬텀-리드-트러블슈팅-핵심-카테고리>#</a></h5><h6 id=원인-분석-및-탐지>원인 분석 및 탐지<a hidden class=anchor aria-hidden=true href=#원인-분석-및-탐지>#</a></h6><ul><li><p><strong>목표:</strong> 팬텀 리드가 발생하는 구체적 원인을 찾아 재현 가능한 증거 (쿼리·트랜잭션 시퀀스·타임라인) 를 확보한다.</p></li><li><p><strong>주요 점검 항목:</strong></p><ol><li>문제 쿼리의 유형 (범위 쿼리, 집계, COUNT 등) 확인</li><li>동시성 수준 (동시 트랜잭션 수, 빈도) 확인</li><li>트랜잭션 길이 (커밋까지 걸리는 시간) 확인</li><li>DB 격리 수준 설정 확인</li><li>인덱스 존재 여부 및 사용계획 (EXPLAIN) 확인</li><li>로그/모니터 (Deadlock, lock waits, long queries, undo growth) 확인</li></ol></li><li><p><strong>재현 방법:</strong> 개발/스테이징에서 재연 스크립트를 만들어 T1(읽기) / T2(삽입) 순서로 실행해 결과 비교.</p></li></ul><table><thead><tr><th>점검항목</th><th style=text-align:right>무엇을 확인할 것인가</th><th>재현/검증 방법</th></tr></thead><tbody><tr><td>쿼리유형</td><td style=text-align:right>범위/집계 여부</td><td>EXPLAIN, 쿼리 실행 로그</td></tr><tr><td>동시성</td><td style=text-align:right>동시 트랜잭션 수</td><td>부하 테스트, pgrep/pgbench/sysbench</td></tr><tr><td>트랜잭션 길이</td><td style=text-align:right>오래 열린 트랜잭션 여부</td><td>DB 의 active tx 검사</td></tr><tr><td>격리수준</td><td style=text-align:right>현재 설정값</td><td>SHOW transaction_isolation 등</td></tr><tr><td>인덱스</td><td style=text-align:right>인덱스가 범위 스캔 유발 여부</td><td>EXPLAIN, 인덱스 통계</td></tr><tr><td>로그</td><td style=text-align:right>Deadlock/lock wait 감지</td><td>DB 로그, APM 알람</td></tr></tbody></table><ul><li><strong>핵심 요약:</strong> 원인부터 확인하면 적절한 대응 (격리수준 또는 인덱스 재설계 등) 을 정확히 선택할 수 있다.</li></ul><h6 id=데이터베이스-엔진-수준-대책>데이터베이스 (엔진) 수준 대책<a hidden class=anchor aria-hidden=true href=#데이터베이스-엔진-수준-대책>#</a></h6><ul><li><p><strong>목표:</strong> DB 엔진의 격리·락 메커니즘을 활용해 팬텀 발생을 원천 차단하거나 안전하게 감지·해결한다.</p></li><li><p><strong>주요 기법:</strong></p><ol><li><strong>격리 수준 조정</strong>: <code>SERIALIZABLE</code> 사용 (원천 차단)—트랜잭션 충돌 시 abort 발생.</li><li><strong>범위락</strong>: index-range / gap lock(엔진 지원 시) 으로 삽입 차단.</li><li><strong>스냅샷 + SSI</strong>: 충돌감지를 통한 낙관적 정합 보장 (Postgres 등).</li><li><strong>행수준 vs 범위 수준 락 설계</strong>: 필요 시 predicate locking 사용 검토.</li><li><strong>DB 파라미터 튜닝</strong>: undo/txnlog 크기, lock wait timeout, deadlock detection 주기 등.</li></ol></li><li><p><strong>장단점 트레이드오프:</strong> 높은 일관성은 동시성 저하 초래 → 워크로드에 맞게 섬세한 튜닝 필요.</p></li></ul><table><thead><tr><th>방법</th><th style=text-align:right>효과</th><th>트레이드오프</th></tr></thead><tbody><tr><td>SERIALIZABLE</td><td style=text-align:right>팬텀 원천 방지</td><td>성능·충돌 증가</td></tr><tr><td>범위락 (gap lock)</td><td style=text-align:right>삽입 차단으로 동일 결과 보장</td><td>락 경쟁 증가</td></tr><tr><td>SSI (Snapshot SI)</td><td style=text-align:right>낙관적 충돌감지로 안전성 확보</td><td>abort 비용 · 복잡도</td></tr><tr><td>파라미터 튜닝</td><td style=text-align:right>GC/UNDO 팽창 완화</td><td>운영 복잡성 증가</td></tr></tbody></table><ul><li><strong>핵심 요약:</strong> DB 엔진의 보호 기능을 우선 고려하되, 성능 영향과 충돌 확률을 반드시 검토.</li></ul><h6 id=애플리케이션비즈니스-레벨-대책>애플리케이션·비즈니스 레벨 대책<a hidden class=anchor aria-hidden=true href=#애플리케이션비즈니스-레벨-대책>#</a></h6><ul><li><p><strong>목표:</strong> 애플리케이션 설계로 팬텀·교착의 영향을 완화하고 사용자 경험을 보장한다.</p></li><li><p><strong>주요 기법:</strong></p><ol><li><strong>낙관적 동시성 제어 (버전 컬럼)</strong>—업데이트 충돌 시 재시도 또는 사용자 알림.</li><li><strong>짧은 트랜잭션 권장</strong>—트랜잭션 내 불필요한 작업 분리.</li><li><strong>재시도 정책 (지수 백오프)</strong>—트랜잭션 충돌시 안전하게 재시도.</li><li><strong>변경 토큰/페이징 설계</strong>—범위 기반 집계 대신 토큰 기반 페이지네이션으로 불일치 최소화.</li><li><strong>업데이트/삭제 대신 논리삭제·상태관리</strong>—의도치 않은 범위 변동 통제.</li></ol></li><li><p><strong>구현 팁:</strong> 재시도 시 idempotency 확보, 사용자 영향 (UX) 고려.</p></li></ul><table><thead><tr><th>기법</th><th style=text-align:right>사용 시나리오</th><th>주의사항</th></tr></thead><tbody><tr><td>낙관적 동시성</td><td style=text-align:right>충돌 드문 시스템</td><td>버전 불일치 처리 로직 필요</td></tr><tr><td>트랜잭션 분리</td><td style=text-align:right>긴 처리 작업</td><td>트랜잭션의 원자성 보장 재검토</td></tr><tr><td>재시도 (백오프)</td><td style=text-align:right>충돌 빈도 낮음</td><td>idempotent 설계 필수</td></tr><tr><td>페이지네이션 토큰</td><td style=text-align:right>대량 데이터 목록</td><td>토큰 보존/유효성 관리 필요</td></tr></tbody></table><ul><li><strong>핵심 요약:</strong> 애플리케이션 레벨 대책은 DB 의 강력한 격리 없이도 실무적으로 일관성을 확보할 수 있는 현실적인 방법.</li></ul><h6 id=운영모니터링성능-예방>운영·모니터링·성능 예방<a hidden class=anchor aria-hidden=true href=#운영모니터링성능-예방>#</a></h6><ul><li><p><strong>목표:</strong> 문제 발생 전 조기탐지, 발생 시 신속대응, 장기적 성능·스토리지 영향 최소화.</p></li><li><p><strong>중점 항목:</strong></p><ol><li><strong>장기 트랜잭션 감시</strong>—오래 열린 tx 는 undo/버전스토어 팽창 유발.</li><li><strong>Deadlock/lock wait 모니터링</strong>—자동 알림 및 로그 보관.</li><li><strong>Undo/Txn 로그 관리</strong>—크기 모니터링, GC 주기 조정.</li><li><strong>성능·집계 이상 탐지</strong>—집계값 변동 (예: 하루 평균 대비 급증) 알람.</li><li><strong>운영 정책</strong>: 타임아웃, deadlock-victim 정책, 재시도 표준화.</li></ol></li><li><p><strong>도구:</strong> DB 내장 모니터, APM(예: NewRelic 등), 커스텀 스크립트.</p></li></ul><table><thead><tr><th>항목</th><th style=text-align:right>지표/알람</th><th>대응</th></tr></thead><tbody><tr><td>장기 트랜잭션</td><td style=text-align:right>tx open 시간</td><td>자동 경고·강제 rollback</td></tr><tr><td>Deadlock</td><td style=text-align:right>deadlock 이벤트</td><td>재시도/원인 트레이스</td></tr><tr><td>Undo growth</td><td style=text-align:right>undo 사용량</td><td>GC/배치 윈도우 재조정</td></tr><tr><td>집계 이상</td><td style=text-align:right>집계 급증</td><td>자동 롤백/알람</td></tr></tbody></table><ul><li><strong>핵심 요약:</strong> 운영 관점의 예방·감시는 팬텀 문제를 조기 차단하고 장기적 비용 (스토리지·성능) 을 줄인다.</li></ul><h5 id=팬텀-리드-트러블슈팅-통합표>팬텀 리드 트러블슈팅 통합표<a hidden class=anchor aria-hidden=true href=#팬텀-리드-트러블슈팅-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th style=text-align:right>핵심 문제</th><th>권장 해결책</th><th style=text-align:right>우선순위 (권장)</th><th>장단점</th></tr></thead><tbody><tr><td>원인 분석 및 탐지</td><td style=text-align:right>재현 불가·원인 불명</td><td>재현 스크립트·EXPLAIN·로그분석</td><td style=text-align:right>1</td><td>문제 진단 정확↑ / 초기 비용 필요</td></tr><tr><td>DB 수준 대책</td><td style=text-align:right>팬텀 발생 (원천)</td><td>SERIALIZABLE / 범위락 / SSI</td><td style=text-align:right>2</td><td>일관성↑ / 성능·충돌↑</td></tr><tr><td>애플리케이션 레벨</td><td style=text-align:right>운영 현실성·UX</td><td>낙관적 버전·재시도·트랜잭션 분리</td><td style=text-align:right>2</td><td>실용적·융통성↑ / 설계 복잡성↑</td></tr><tr><td>운영·모니터링</td><td style=text-align:right>장기적 비용·감지</td><td>모니터·알람·정책 (타임아웃 등)</td><td style=text-align:right>1</td><td>조기탐지·비용↓ / 운영 부담 증가</td></tr></tbody></table><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>Phantom Read 는 동일 조건으로 반복 조회하는 트랜잭션에서 다른 트랜잭션의 삽입이나 삭제로 인해 결과 집합이 달라지는 동시성 이상이다.<br>이 현상은 범위 기반 쿼리 (예: 날짜·금액 범위, 페이징, 집계) 를 사용할 때 특히 취약하며, 개별 행 락이나 단순한 스냅샷만으로는 완전 방지할 수 없다.<br>근본적 해결은 &rsquo; 조건 보호 &rsquo; 로, 구현 방식으로는 키 - 범위 잠금 (next-key lock) 처럼 갭을 잠그는 방법이나 predicate locking, 또는 MVCC 위에서 동작하는 스냅샷 기반 직렬화 (SSI) 같은 기법이 있다.<br>각 방식은 성능·복잡도 측면에서 트레이드오프가 있으므로 실무에서는 인덱스·파티셔닝·집계 테이블 등으로 범위 노출을 줄인 뒤, 핵심 도메인에 한해 격리 수준을 올리거나 범위잠금을 적용하는 전략을 권장한다.<br>운영 측면에서는 팬텀 징후를 모니터링하고 (집계 불일치, 페이지네이션 이상 등) 필요한 경우 즉시 원인 쿼리와 데이터 분포를 점검해 설계 변경을 적용해야 한다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>단계</th><th style=text-align:right>목적</th><th>핵심 액션 (구체적)</th><th style=text-align:right>우선순위</th></tr></thead><tbody><tr><td>도메인 불변식 정의</td><td style=text-align:right>어떤 데이터가 절대적 일관성 필요</td><td>비즈니스 규칙 문서화, 트랜잭션 매핑</td><td style=text-align:right>높음</td></tr><tr><td>위험 쿼리 식별</td><td style=text-align:right>Phantom/집계 오류 리스크 발견</td><td>쿼리 카탈로그 작성, 범위 쿼리 우선 점검</td><td style=text-align:right>높음</td></tr><tr><td>격리·락 전략 선택</td><td style=text-align:right>정합성 vs 성능 균형 결정</td><td>핵심=Serializable/FOR UPDATE, 일반=낙관적</td><td style=text-align:right>높음</td></tr><tr><td>인덱스·파티션 설계</td><td style=text-align:right>락 범위 축소·충돌 완화</td><td>범위 인덱스, 샤딩·파티션으로 핫스팟 분리</td><td style=text-align:right>중~높</td></tr><tr><td>재시도·멱등 정책</td><td style=text-align:right>충돌 시 안전한 복구 보장</td><td>idempotency key, 재시도 백오프 정책</td><td style=text-align:right>높음</td></tr><tr><td>모니터링·알람</td><td style=text-align:right>조기 탐지·운영 대응</td><td>직렬화 오류·데드락·롱 트랜잭션 지표 대시보드</td><td style=text-align:right>높음</td></tr><tr><td>운영 튜닝</td><td style=text-align:right>정책의 지속적 최적화</td><td>벤치마크 (throughput/latency)·A/B 테스트</td><td style=text-align:right>중</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th>학습 주제</th><th style=text-align:right>중요도</th><th>학습 목표</th><th>실무 연관성</th><th>권장 실습 (구체)</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>팬텀 리드 개념 / 트랜잭션 이상 유형</td><td style=text-align:right>필수</td><td>이상 분류·원인 파악</td><td>매우 높음</td><td>동일 WHERE 재조회 전후 INSERT/DELETE 로 변화 재현 (SQL)</td></tr><tr><td style=text-align:right>1</td><td>ACID 와 격리 수준 비교 (RC/RR/SI/SERIAL)</td><td style=text-align:right>필수</td><td>각 레벨이 막는/허용하는 이상 이해</td><td>높음</td><td>DB 설정 변경으로 동작 비교 (3 회 반복)</td></tr><tr><td style=text-align:right>2</td><td>MVCC, Snapshot Isolation 동작</td><td style=text-align:right>필수</td><td>스냅샷 읽기·쓰기 충돌 원리 파악</td><td>높음</td><td>Postgres SI 재현, write-skew 예제</td></tr><tr><td style=text-align:right>2</td><td>키 - 범위 락 (Next-Key/GAP) 과 프레디케이트 락</td><td style=text-align:right>필수</td><td>범위 락이 팬텀을 어떻게 막는지 이해</td><td>높음</td><td>InnoDB gap/next-key 락 실습</td></tr><tr><td style=text-align:right>2</td><td>Serializable(직렬화) 내부 동작과 비용</td><td style=text-align:right>필수</td><td>직렬화 실패/재시도 패턴 이해</td><td>높음</td><td>Serializable 모드에서 직렬화 실패 재현</td></tr><tr><td style=text-align:right>3</td><td>낙관적 락 (버전컬럼) + 재시도 패턴</td><td style=text-align:right>권장</td><td>애플리케이션 레벨 방어 구현</td><td>높음</td><td>Python/Java 재시도 템플릿 구현</td></tr><tr><td style=text-align:right>3</td><td>ORM 연동 (예: JPA/Hibernate behavior)</td><td style=text-align:right>권장</td><td>프레임워크 레벨 동작 이해</td><td>중간</td><td>ORM 에서의 버전관리 예제</td></tr><tr><td style=text-align:right>3</td><td>집계·배치 전략 (스냅샷/배치 집계)</td><td style=text-align:right>권장</td><td>일관성 - 성능 트레이드오프 관리</td><td>중간</td><td>배치 집계 스크립트, OLAP 스냅샷 사용</td></tr><tr><td style=text-align:right>4</td><td>파티셔닝/샤딩 설계 원칙</td><td style=text-align:right>필수 (대규모)</td><td>핫스팟 완화·리밸런싱 이해</td><td>높음 (대규모 서비스)</td><td>샤드키 실험 (데이터 분포 시뮬레이션)</td></tr><tr><td style=text-align:right>4</td><td>분산 일관성 패턴 (2PC, Saga)</td><td style=text-align:right>권장</td><td>분산 트랜잭션 대안 설계</td><td>높음</td><td>Saga 시뮬레이션, 보상 트랜잭션 설계</td></tr><tr><td style=text-align:right>5</td><td>검증·테스트 (Jepsen 스타일)</td><td style=text-align:right>권장</td><td>동시성 결함 노출·검증 능력 확보</td><td>높음</td><td>간단한 Jepsen-lite 테스트 케이스 작성</td></tr><tr><td style=text-align:right>6</td><td>모니터링·운영 지표 설계</td><td style=text-align:right>필수 (운영)</td><td>충돌률·재시도율·lock-wait 지표 정의</td><td>높음</td><td>Prometheus/Grafana 지표 대시보드 설계</td></tr><tr><td style=text-align:right>7</td><td>최신 연구/대체기술 (CRDT 등)</td><td style=text-align:right>선택</td><td>분산수렴 모델 이해</td><td>중간</td><td>CRDT 샘플 구현 (간단한 G-Counter)</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th style=text-align:right>항목 ID</th><th>항목 (세부)</th><th style=text-align:right>중요도</th><th>학습 목표</th><th style=text-align:right>실무 연관성</th><th>실습/설명</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td style=text-align:right>1.1</td><td>팬텀 리드 개념 정의</td><td style=text-align:right>필수</td><td>재현·구분 능력</td><td style=text-align:right>매우 높음</td><td>동일 조건 SELECT 전후 INSERT/DELETE 로 변화 관찰</td></tr><tr><td style=text-align:right>1</td><td style=text-align:right>1.2</td><td>트랜잭션·ACID 기본</td><td style=text-align:right>필수</td><td>트랜잭션 모델 이해</td><td style=text-align:right>매우 높음</td><td>BEGIN/COMMIT/ROLLBACK 실습</td></tr><tr><td style=text-align:right>1</td><td style=text-align:right>1.3</td><td>이상 유형 재현 (D/R/N-R/Phantom)</td><td style=text-align:right>필수</td><td>차이점·원인 파악</td><td style=text-align:right>높음</td><td>4 가지 이상 각각 재현 스크립트</td></tr><tr><td style=text-align:right>2</td><td style=text-align:right>2.1</td><td>MVCC/Snapshot Isolation</td><td style=text-align:right>필수</td><td>스냅샷·커밋 타이밍 이해</td><td style=text-align:right>높음</td><td>Postgres SI 예제 (스냅샷 읽기)</td></tr><tr><td style=text-align:right>2</td><td style=text-align:right>2.2</td><td>Write Skew 사례 분석</td><td style=text-align:right>필수</td><td>SI 한계 이해</td><td style=text-align:right>높음</td><td>두 트랜잭션 write-skew 재현</td></tr><tr><td style=text-align:right>2</td><td style=text-align:right>2.3</td><td>Next-Key / Gap Lock (InnoDB)</td><td style=text-align:right>필수</td><td>범위 락 동작 파악</td><td style=text-align:right>높음</td><td>InnoDB 에서 gap lock 재현</td></tr><tr><td style=text-align:right>2</td><td style=text-align:right>2.4</td><td>Serializable 내부 (검증/재시도)</td><td style=text-align:right>필수</td><td>직렬화 실패 처리 이해</td><td style=text-align:right>높음</td><td>Serializable 모드 시나리오</td></tr><tr><td style=text-align:right>3</td><td style=text-align:right>3.1</td><td>낙관적 락 (버전) + 재시도 설계</td><td style=text-align:right>필수</td><td>애플리케이션 레벨 보호 구현</td><td style=text-align:right>높음</td><td>버전컬럼 + UPDATE WHERE version=? 구현</td></tr><tr><td style=text-align:right>3</td><td style=text-align:right>3.2</td><td>ORM 행동 (예: JPA/Hibernate)</td><td style=text-align:right>권장</td><td>프레임워크 영향 이해</td><td style=text-align:right>중간</td><td>ORM 에서의 영속성 컨텍스트 테스트</td></tr><tr><td style=text-align:right>3</td><td style=text-align:right>3.3</td><td>배치 집계·OLAP 스냅샷</td><td style=text-align:right>권장</td><td>집계 일관성 전략 수립</td><td style=text-align:right>중간</td><td>배치 스냅샷 집계 예제</td></tr><tr><td style=text-align:right>3</td><td style=text-align:right>3.4</td><td>재시도·백오프 정책</td><td style=text-align:right>필수</td><td>운영 안정성 확보</td><td style=text-align:right>높음</td><td>지수 백오프 + jitter 구현</td></tr><tr><td style=text-align:right>4</td><td style=text-align:right>4.1</td><td>샤딩·파티셔닝 설계</td><td style=text-align:right>필수 (대규모)</td><td>핫스팟 회피 설계</td><td style=text-align:right>높음</td><td>샤드키 테스트, 리밸런싱 시나리오</td></tr><tr><td style=text-align:right>4</td><td style=text-align:right>4.2</td><td>분산 트랜잭션 대안 (Saga/2PC)</td><td style=text-align:right>권장</td><td>분산 무결성 패턴 적용</td><td style=text-align:right>높음</td><td>Saga 워크플로우 설계 연습</td></tr><tr><td style=text-align:right>4</td><td style=text-align:right>4.3</td><td>분산 락/조정 서비스 설계</td><td style=text-align:right>권장</td><td>샤드 경계 제약 유지</td><td style=text-align:right>높음</td><td>분산 락 (Etcd/Consul) 간단 사용 예</td></tr><tr><td style=text-align:right>5</td><td style=text-align:right>5.1</td><td>동시성 검증 (Jepsen 스타일)</td><td style=text-align:right>권장</td><td>진단·검증 능력 확보</td><td style=text-align:right>높음</td><td>Jepsen-lite 테스트 케이스</td></tr><tr><td style=text-align:right>5</td><td style=text-align:right>5.2</td><td>모니터링 지표 및 알림</td><td style=text-align:right>필수 (운영)</td><td>충돌·재시도 모니터링</td><td style=text-align:right>높음</td><td>Prometheus 지표 템플릿 작성</td></tr><tr><td style=text-align:right>6</td><td style=text-align:right>6.1</td><td>성능·비용 트레이드오프 분석</td><td style=text-align:right>권장</td><td>의사결정 능력</td><td style=text-align:right>중간</td><td>A/B 테스트 설계, 비용 모델링</td></tr><tr><td style=text-align:right>7</td><td style=text-align:right>7.1</td><td>최신 대안 기술 (CRDT 등)</td><td style=text-align:right>선택</td><td>분산 수렴 이해</td><td style=text-align:right>낮음~중간</td><td>G-Counter 등 간단 CRDT 구현</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글 (영어 풀네임, 약어))</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심 개념</td><td>팬텀 리드 (Phantom Read)</td><td>동일 트랜잭션 내 반복 조회 사이에 다른 트랜잭션의 INSERT/DELETE 로 결과 집합 (행의 존재/부재) 이 변하는 동시성 이상</td><td>트랜잭션, 격리 수준, 집합 불변성</td><td>집계·재고·이벤트 등에서 결과 불일치 탐지·격리 수준 결정</td></tr><tr><td>핵심 개념</td><td>격리 수준 (Isolation Level)</td><td>트랜잭션 간 상호작용 허용 범위를 정의하는 설정 (예: Read Committed, Repeatable Read, Serializable)</td><td>ACID, Dirty Read, Non-Repeatable Read, Phantom</td><td>일관성/성능 트레이드오프에 따라 운영 정책 선정</td></tr><tr><td>패턴</td><td>읽기 - 수정 - 쓰기 패턴 (Read-Modify-Write, RMW)</td><td>앱이 먼저 읽고 계산한 뒤 다시 쓰는 순서의 패턴—덮어쓰기 취약점 유발</td><td>원자적 UPDATE, 낙관적/비관적 락</td><td>가능하면 DB 원자 연산으로 대체 (예: <code>UPDATE … SET v = v+1</code>)</td></tr><tr><td>정책/관행</td><td>마지막 쓰기 우선 (Last Write Wins, LWW)</td><td>충돌 시 마지막 커밋을 우선하는 단순 정책—데이터 소실 가능</td><td>덮어쓰기, 일관성 정책</td><td>허용 가능한 경우에만 사용 (충돌 허용 영역)</td></tr><tr><td>구현 (락)</td><td>키 - 범위 / 넥스트키 락 (Key-Range / Next-Key Lock)</td><td>인덱스 레코드와 인덱스 사이의 gap 까지 잠가 범위 내 삽입을 차단</td><td>Gap Lock, 2PL, 인덱스 스캔</td><td>MySQL InnoDB 에서 팬텀 방지에 사용 (단, 락 경합 유의)</td></tr><tr><td>구현 (락)</td><td>갭 락 (Gap Lock)</td><td>실제 로우가 아닌 인덱스 간의 간격 (gap) 을 잠금으로써 그 위치에 대한 삽입을 차단</td><td>Next-Key Lock, 범위 락</td><td>범위 삽입 제어 필요시 사용 (데이터베이스별 동작 차이 있음)</td></tr><tr><td>구현 (락)</td><td>프레디케이트 락 (Predicate Lock)</td><td>쿼리 술어 (조건) 를 논리적으로 잠금—정확한 범위 보호 시도</td><td>Predicate Locking, Serializable</td><td>일부 DB/실험적 기능에서 사용, 구현 복잡성 존재</td></tr><tr><td>구현 (MVCC)</td><td>MVCC (Multi-Version Concurrency Control, MVCC)</td><td>트랜잭션별로 데이터의 스냅샷을 제공해 읽기 일관성 보장</td><td>Snapshot Isolation (SI), SSI</td><td>읽기 성능 우수, 삽입 제어에는 한계 (팬텀 가능성)</td></tr><tr><td>구현 (MVCC)</td><td>스냅샷 격리 (Snapshot Isolation, SI)</td><td>MVCC 기반의 읽기 일관성 모델—특정 상황에서 팬텀/Write-Skew 가 발생할 수 있음</td><td>MVCC, Repeatable Read</td><td>대량 동시성 환경에 유리, 팬텀 완전 차단 아님</td></tr><tr><td>구현 (직렬화)</td><td>직렬화 스냅샷 격리 (Serializable Snapshot Isolation, SSI)</td><td>MVCC 위에서 의존성 그래프 충돌 탐지로 직렬성 보장—충돌 시 트랜잭션 Abort</td><td>Serializable, MVCC</td><td>금융·원장 등 강한 일관성 경로에 적용 (성능·재시도 고려)</td></tr><tr><td>운영 (지표)</td><td>락 경합 (Lock Contention)</td><td>여러 트랜잭션이 동일 락 자원 요청으로 대기 또는 교착이 발생하는 현상</td><td>Deadlock, Timeout</td><td>모니터링 (락 대기 시간) → 쿼리/인덱스·트랜잭션 설계 개선</td></tr><tr><td>운영 (지표)</td><td>직렬화 실패 (Serialization Failure / SQLSTATE 40001)</td><td>DB 가 직렬성 보장을 위해 트랜잭션을 Abort 할 때 발생하는 예외/로그</td><td>SSI, Serializable</td><td>애플리케이션 재시도 로직·백오프 필요 (모니터링 대상)</td></tr><tr><td>운영 (지표)</td><td>복제 지연 (Replication Lag)</td><td>비동기 복제에서 마스터 커밋과 리플리카 반영 간 지연 시간</td><td>읽기/쓰기 분리, 스테일 리드</td><td>읽기 리플리카 사용 시 세션 고정·마스터 우선 읽기 권장</td></tr><tr><td>진단 도구</td><td>쿼리 실행 계획 (EXPLAIN / EXPLAIN ANALYZE)</td><td>쿼리의 실행 경로 및 인덱스 사용 여부를 보여주는 도구</td><td>인덱스, 범위 스캔, 풀 스캔</td><td>범위 락 적용 가능성 판단·쿼리 리팩터링 근거</td></tr><tr><td>아키텍처</td><td>CQRS (Command Query Responsibility Segregation)</td><td>쓰기 (command) 와 읽기 (query) 를 분리하여 일관성·확장성 관리</td><td>이벤트 소싱, 단일 라이터</td><td>복잡한 일관성 요구 시스템에서 충돌 축소 패턴</td></tr><tr><td>보조</td><td>멱등성 (Idempotency)</td><td>같은 요청을 여러 번 실행해도 결과가 동일하도록 보장되는 성질</td><td>재시도, 외부 API</td><td>재시도 설계 시 필수 (직렬화 실패·재시도폭주 완화)</td></tr><tr><td>보조</td><td>EXPLAIN 기반 인덱스 점검</td><td>범위 쿼리가 인덱스를 타는지 확인하는 실무 절차</td><td>EXPLAIN, 인덱스 설계</td><td>팬텀 방지용 범위 락 유효성 사전검증</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/current/transaction-iso.html>PostgreSQL Docs—Transaction Isolation & Serializable (SSI)</a>.</li><li><a href=https://www.postgresql.org/docs/current/explicit-locking.html>PostgreSQL Docs—Explicit Locking/LOCK</a>.</li><li><a href=https://dev.mysql.com/doc/en/innodb-locking-reads.html>MySQL Docs—InnoDB Locking Reads/Next-Key</a>.</li><li><a href=https://dev.mysql.com/doc/refman/8.4/en/innodb-next-key-locking.html>MySQL Docs—InnoDB Next-Key Locking (Phantom Rows)</a>.</li><li><a href=https://learn.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql>SQL Server—SET TRANSACTION ISOLATION LEVEL (Transact-SQL)</a>.</li><li><a href=https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server>SQL Server—Snapshot Isolation (ADO.NET)</a>.</li><li><a href=https://docs.oracle.com/cd/E25054_01/server.1111/e25789/consist.htm>Oracle—Data Concurrency & Consistency (Serializable)</a>.</li><li><a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf>Berenson et al., A Critique of ANSI SQL Isolation Levels (PDF)</a>.</li><li><a href=https://en.wikipedia.org/wiki/Isolation_%28database_systems%29>Wikipedia—Isolation (database systems)</a>.</li><li><a href=https://blog.skby.net/phantom-read/>Phantom Read &lt; 도리의 디지털라이프</a>.</li><li><a href=https://choonsik-lab.tistory.com/entry/%EB%A7%A4%EC%9D%BC%EB%A9%94%EC%9D%BC-%ED%8C%AC%ED%85%80-%EB%A6%AC%EB%93%9CPhantom-Read-%EB%9E%80>팬텀 리드(Phantom Read) 란? - 개발하는 동그리</a>.</li><li><a href=https://velog.io/%40libienz/InnoDB%EC%9D%98-REPEATABLE-READ%EA%B0%80-PHANTOM-READ%EB%A5%BC-%EB%B0%A9%EC%A7%80%ED%95%98%EB%8A%94-%EC%9B%90%EB%A6%AC>InnoDB의 REPEATABLE READ가 PHANTOM READ를 방지하는 원리 (Velog)</a>.</li><li><a href=https://notavoid.tistory.com/48>트랜잭션 격리 수준 완벽 가이드 (notavoid.tistory)</a>.</li><li><a href=https://itpenote.tistory.com/616>Phantom Read - 비트코기의 IT Note</a>.</li><li><a href=https://cojyeon.tistory.com/427>MySQL InnoDB 갭락과 넥스트키 락 정의 및 팬텀 리드 방지</a>.</li><li><a href=https://coding-review.tistory.com/304>Phantom Read 부정합문제 해결방안 In PostgreSQL, MSSQL Server</a>.</li><li><a href=https://rnrwk0502.tistory.com/53>트랜잭션 격리 수준 & 동시성 제어 (rnrwk0502.tistory)</a>.</li><li><a href=https://parkmuhyeun.github.io/woowacourse/2023-11-28-Repeatable-Read/>과연 MySQL의 REPEATABLE READ에서는 PHANTOM READ 발생할까? (parkmuhyeun.github.io)</a>.</li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-and-database-systems/>Data-and-Database-Systems</a></li><li><a href=https://buenhyden.github.io/tags/data-operations/>Data-Operations</a></li><li><a href=https://buenhyden.github.io/tags/transaction-management/>Transaction-Management</a></li><li><a href=https://buenhyden.github.io/tags/transaction/>Transaction</a></li><li><a href=https://buenhyden.github.io/tags/transaction-isolation/>Transaction-Isolation</a></li><li><a href=https://buenhyden.github.io/tags/concurrency-anomalies/>Concurrency-Anomalies</a></li><li><a href=https://buenhyden.github.io/tags/database-anomaly/>Database-Anomaly</a></li><li><a href=https://buenhyden.github.io/tags/phantom-read/>Phantom-Read</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/lost-update/><span class=title>« Prev</span><br><span>Lost Update</span>
</a><a class=next href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/write-skew/><span class=title>Next »</span><br><span>Write Skew</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>