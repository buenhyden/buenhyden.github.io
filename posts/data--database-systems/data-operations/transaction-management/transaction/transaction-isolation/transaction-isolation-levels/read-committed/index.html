<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Read Committed | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Transaction,Transaction-Isolation,Transaction-Isolation-Levels,Read-Committed"><meta name=description content="Read Committed은 트랜잭션이 커밋된 데이터만 읽도록 보장해 Dirty Read를 방지하는 표준 격리 수준이다. 다만 동일 트랜잭션 내 반복 조회에서 값이 달라지는 Non-Repeatable Read와 레코드 추가/삭제로 인한 Phantom은 허용한다. 구현은 락 기반과 MVCC 기반으로 달라지므로 적용 전 엔진 동작·재현 테스트·보완 패턴(재검증, FOR UPDATE, 상향 격리)을 설계해야 한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Read Committed"><meta property="og:description" content="Read Committed은 트랜잭션이 커밋된 데이터만 읽도록 보장해 Dirty Read를 방지하는 표준 격리 수준이다. 다만 동일 트랜잭션 내 반복 조회에서 값이 달라지는 Non-Repeatable Read와 레코드 추가/삭제로 인한 Phantom은 허용한다. 구현은 락 기반과 MVCC 기반으로 달라지므로 적용 전 엔진 동작·재현 테스트·보완 패턴(재검증, FOR UPDATE, 상향 격리)을 설계해야 한다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-12T03:46:00+00:00"><meta property="article:modified_time" content="2025-09-12T03:46:00+00:00"><meta property="article:tag" content="Data-and-Database-Systems"><meta property="article:tag" content="Data-Operations"><meta property="article:tag" content="Transaction-Management"><meta property="article:tag" content="Transaction"><meta property="article:tag" content="Transaction-Isolation"><meta property="article:tag" content="Transaction-Isolation-Levels"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Read Committed"><meta name=twitter:description content="Read Committed은 트랜잭션이 커밋된 데이터만 읽도록 보장해 Dirty Read를 방지하는 표준 격리 수준이다. 다만 동일 트랜잭션 내 반복 조회에서 값이 달라지는 Non-Repeatable Read와 레코드 추가/삭제로 인한 Phantom은 허용한다. 구현은 락 기반과 MVCC 기반으로 달라지므로 적용 전 엔진 동작·재현 테스트·보완 패턴(재검증, FOR UPDATE, 상향 격리)을 설계해야 한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":8,"name":"Read Committed","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Read Committed","name":"Read Committed","description":"Read Committed은 트랜잭션이 커밋된 데이터만 읽도록 보장해 Dirty Read를 방지하는 표준 격리 수준이다. 다만 동일 트랜잭션 내 반복 조회에서 값이 달라지는 Non-Repeatable Read와 레코드 추가/삭제로 인한 Phantom은 허용한다. 구현은 락 기반과 MVCC 기반으로 달라지므로 적용 전 엔진 동작·재현 테스트·보완 패턴(재검증, FOR UPDATE, 상향 격리)을 설계해야 한다.","keywords":["Data-and-Database-Systems","Data-Operations","Transaction-Management","Transaction","Transaction-Isolation","Transaction-Isolation-Levels","Read-Committed"],"articleBody":"Read Committed Read Committed(읽기 커밋) 는 실무에서 널리 쓰이는 기본 격리 수준으로, 항상 커밋된 데이터만 읽게 해 Dirty Read 를 차단한다.\n다만 트랜잭션 내 여러 문장은 서로 다른 시점의 커밋 상태를 볼 수 있어 Non-repeatable Read 와 Phantom이 발생할 수 있다.\n내부 구현은 DB 마다 달라 (PostgreSQL/Oracle 은 MVCC 스냅샷 기반, SQL Server 는 기본 락 기반에 RCSI 옵션 존재) 동일 명칭이라도 동작이 다르므로 DB 별로 테스트·검증해야 한다.\n일반 웹·OLTP 는 Read Committed 가 성능·정합성의 균형이지만, 회계·결제 등 강한 일관성이 필요한 도메인에서는 Repeatable Read 나 Serializable 을 사용하는 것이 추천된다.\n운영 시 장기 트랜잭션 회피, 락 대기·데드락 모니터링, 읽기 풀 설계로 위험을 완화하는 것이 추천된다.\nRead Committed 핵심 개념과 실무 적용 Read Committed 는 많은 상용 DB 에서 기본으로 쓰이는 격리 수준으로, **\" 각 쿼리는 그 순간 커밋된 값만 본다 “**는 규칙을 따른다.\n이로써 **Dirty Read(미커밋 데이터 읽기)**는 차단되어 실무 데이터 신뢰성이 보장되지만, 같은 트랜잭션 내에서 반복 조회를 하면 값이 바뀔 수 있다 (Non-repeatable) 거나, 조건에 맞는 행 수가 달라질 수 있다 (Phantom).\n성능과 정합성의 균형점으로 대부분 OLTP 에 적합하다.\n핵심 개념 (한글, 약어) 정의 실무적 중요성 트랜잭션 (Transaction) 원자적 작업 단위 실패/성공 일관성 보장 (비즈니스 불변식 보호) 격리 수준 (Isolation Level) 트랜잭션 간 중간 상태 노출 규칙 성능·정합성 결정 요인 읽기 커밋 (Read Committed, RC) 각 쿼리는 그 시점의 커밋된 값만 읽음 Dirty Read 차단, 대부분 OLTP 기본값 더티 리드 (Dirty Read) 미커밋 값 읽기 심각한 데이터 오류 초래 가능 반복 불가 읽기 (Non-repeatable Read) 동일 조회 반복 시 값 변경 일관된 리포트·계산에 문제 팬텀 (Phantom) 같은 조건 재조회 시 행 집합 변화 집계·범위 쿼리에 영향 다중버전 동시성 (MVCC) 스냅샷 버전으로 읽기 제공 읽기 비차단으로 성능 향상 락 (Shared/Exclusive Lock) 동시 접근 제어 수단 강한 일관성 확보 (대가: 대기) RC 는 실용적 균형을 제공하므로 대부분의 OLTP 에서 기본이 된다.\n핵심은 비즈니스 요구에 맞춰 \" 어떤 이상현상을 허용할 것인가 \" 를 명확히 하는 것.\n개념 상호관계 매핑표 출발 → 도착 방향성/의미 목적·효과 격리 수준 ↑ → 허용 이상현상 ↓ 단방향 더 높은 격리로 데이터 정합성 향상 (대가: 성능↓) MVCC → Dirty Read 차단 구현 수단 → 결과 읽기 스냅샷으로 미커밋 노출 방지 락 (2PL) → Dirty Write/Read 방지 구현 수단 → 결과 동시 쓰기 충돌 차단 (단, 대기/데드락 유발) Statement snapshot → Read Committed 성격 의미 해석 쿼리 단위로 최신 커밋값 반영 Transaction snapshot → Repeatable Read 성격 의미 해석 트랜잭션 전체에서 동일 스냅샷 보장 관계는 대부분 정책 (격리 수준) → 구현 (MVCC/락) → 결과 (허용/차단되는 이상현상) 구조로 이해하면 실무 설계에 적용하기 쉽다.\n관계 다이어그램\nflowchart LR A[Client] --\u003e|SQL| T[Transaction] T --\u003e|READ| V[Visibility Rules] V --\u003e|MVCC Snapshot or S-Lock| D[(Data Pages)] T --\u003e|WRITE| L[Locking / Row Versions] L --\u003e D D --\u003e|Commit| C[Durability] 핵심 개념의 실무 적용 매핑 개념 DB 에서 어떻게 구현되는가 실무에서 무엇을 의미하나 (이유) 운영시 고려사항 Read Committed 문장단위 스냅샷 (MVCC) 또는 락 기반 Dirty Read 방지, 반복불가 허용 트랜잭션 길이·장기 트랜잭션 주의 MVCC 버전관리·Undo/Visibility 규칙 읽기 비차단, 낮은 지연 GC(vacuum)·스토리지 증가 관리 락 S/X 락 (행·페이지) 강한 직렬성 보장 수단 데드락·대기 모니터링 필요 ORM 설정 세션/트랜잭션 격리 레벨 지정 애플리케이션 레벨 정책 반영 세션 캐시·자동 커밋 영향 검사 모니터링 지표 txn_duration, rollback_rate 등 RC 적용의 운영 위험 탐지 알람·SLO 설계 필요 실무 적용은 **DB 특성 (엔진 별 동작)**과 **애플리케이션 프레임워크 (ORM)**의 조합으로 결정된다. 운영 시 장기 트랜잭션·GC·데드락·롤백률을 면밀히 관찰해야 한다.\n기초 조사 및 개념 정립 Read Committed—개념·실무 적용 무엇을 보장하나?:\n한 SQL 문이 실행될 때 그 시점에 커밋된 값만 읽도록 보장한다.\n무엇을 막나?:\n아직 커밋되지 않은 (임시) 값은 읽지 못하므로 Dirty Read 를 막는다.\n무엇이 남나?:\n같은 트랜잭션에서 두 번 읽으면 값이 바뀔 수 있다 (다른 트랜잭션이 사이에 커밋했기 때문).\n언제 쓸까?:\n대부분의 OLTP 에서 기본값으로 널리 사용—성능과 일관성의 현실적 절충.\n주의점:\n장기 트랜잭션이나 다단계 검증이 필요한 로직 (예: 잔액 확인→결제) 에는 더 강한 격리 (또는 애플리케이션 레벨 보정) 가 필요.\nRead Committed(읽기 커밋) 는 각 SQL 문이 실행되는 시점의 커밋된 스냅샷을 읽도록 보장하는 격리 수준이다.\n이는 트랜잭션 간의 Dirty Read 를 방지하여 기본적인 데이터 정합성을 확보하면서도, 문 수준에서 최신성을 확보하기 때문에 성능과 동시성 측면에서 합리적인 선택지다.\n다만 트랜잭션 내에서 반복 조회 시 다른 트랜잭션의 커밋에 의해 값이 변할 수 있으므로 (Non-repeatable Read), 반복적 비교나 복합 검증을 요구하는 로직에는 Snapshot Isolation 혹은 Serializable 사용을 권장한다.\n또한 DBMS 별 구현 (락 기반 vs MVCC, row-versioning 옵션) 에 따라 동작·성능이 달라지므로 적용 전 확인·테스트가 필요하다.\nRead Committed: 기원·진화·실무 포인트 무엇인가?\nRead Committed 는 다른 트랜잭션이 아직 커밋하지 않은 변경 (미확정) 을 읽지 못하게 하여 Dirty Read 를 방지하는 격리 수준.\n왜 쓰나?\n락으로 인한 심한 대기 없이도 기본적인 일관성을 보장하려는 현실적 타협.\n무엇이 변했나?\n초기 락 기반 구현에서 MVCC 기반의 ’ 쿼리 시점 스냅샷 ’ 구현으로 발전하여 읽기 성능을 개선.\n등장 배경 복수 사용자가 동시에 데이터에 접근하는 환경에서 읽기 작업이 쓰기 작업의 잠금 때문에 지연되면 전체 처리량과 응답성이 저하된다.\n실무에서 ’ 어느 정도의 일관성은 유지하되 지나친 동시성 비용은 피하자 ’ 는 요구가 커지자 SQL 표준과 DB 벤더들은 Dirty Read 를 차단하면서도 읽기 지연을 완화하는 Read Committed를 도입·보급했다.\n이후 MVCC 의 도입으로 Read Committed 는 읽기 비차단 (스냅샷) 방식으로 개선되어 대다수 엔진에서 널리 쓰이게 되었다.\n발전 과정 시기 (대략) 변화/이유 기술적 개선/결과 1970s–1980s 초기 RDBMS·락 기반 운영 → 읽기 지연 문제 약격리/락 전략으로 성능 - 정합성 타협 시도 1992 (SQL-92) 격리 수준 표준화 필요 Read Uncommitted → Read Committed 등 표준화. 1990s–2000s MVCC 확산 Read Committed 가 스냅샷 기반으로 구현되어 읽기 비차단화 (예: Oracle/Postgres) (Oracle Docs) 2000s 이후 엔진별 최적화·기본값 변화 MySQL/InnoDB·Postgres·Oracle 등 벤더별 기본·동작 차이 존재 (운영시 검증 필요). (MySQL Developer Zone) gantt dateFormat YYYY title Read Committed 발전 타임라인 1970s-1980s :a1, 1975, 1989 1992 :a2, 1992, 1992 1995-2005 :a3, 1995, 2005 2005-2025 :a4, 2005, 2025 section 사건 락기반 RDBMS와 성능문제 :a1, 1975, 1989 SQL-92 격리 수준 표준화 :a2, 1992, 1992 MVCC 보급 및 스냅샷 구현 확산 :a3, 1995, 2005 벤더별 최적화·기본 설정 확립 :a4, 2005, 2025 Read Committed 는 ’ 읽기 지연을 줄이되 Dirty Read 는 방지 ’ 라는 목표로 등장했고, MVCC 의 보급으로 읽기 비차단 (스냅샷 기반) 형태로 진화했다.\n오늘날 대부분의 DB 엔진은 Read Committed 를 지원하거나 그에 상응하는 동작을 제공하지만, 엔진별 세부 동작과 기본값이 다르므로 적용 전 검증이 필수다.\n운영 환경에서는 Read Committed 가 제공하는 일관성 범위 (커밋 시점 일관성) 를 이해하고, 재조회 시 값이 달라질 수 있음을 설계에 반영해야 한다.\nRead Committed: 실무적 문제·목적 정리 Read Committed 는 데이터베이스의 격리 수준 중 하나로, 읽을 때 오직 이미 커밋된 데이터만 볼 수 있게 보장한다.\n이것으로 미커밋 데이터 (Dirty data) 를 읽어 발생하는 잘못된 집계나 의사결정 문제를 막을 수 있다.\n다만 트랜잭션 내에서 같은 쿼리를 다시 실행하면 결과가 달라질 수 있으니 (Non-repeatable read) 재현성 (동일 트랜잭션에서의 반복 일관성) 이 중요한 작업에는 더 강한 격리 수준을 선택해야 한다.\n또한 DB 엔진별 구현 차이를 반드시 확인해야 한다 (예: PostgreSQL 의 특성).\nRead Committed 이 해결하는 문제들 해결되는 문제 원인 (문제 발생 상황) Read Committed 이 해결하는 방식 Dirty Read(미커밋 데이터 노출) 트랜잭션 A 가 변경한 데이터를 트랜잭션 B 가 커밋 전 읽음 읽기 시 커밋 여부만 허용 → 미커밋 변경 필터링하여 노출 차단. 잘못된 리포트/집계 발생 미확정값을 기반으로 집계가 산출됨 집계 시점에 커밋된 값만 사용하도록 보장 운영 위험 (롤백 전파·오판단) 미커밋 값에 의존해 트랜잭션으로 의사결정 커밋된 데이터만 읽게 하여 의사결정 안정성 확보 Read Committed 는 **미커밋 데이터 노출이 가져오는 직접적 위험들 (잘못된 집계, 의사결정, 롤백 후 불일치)**을 차단하는 데 집중한다. 이를 통해 운영 안정성을 높이되, 반복 읽기 일관성까지 보장하지는 않으므로 필요에 따라 더 높은 격리가 요구된다.\nRead Committed 의 핵심 목적 핵심 목적 설명 기대 효과 Dirty Read 방지 미커밋 변경을 다른 트랜잭션이 보지 못하게 함 잘못된 집계/오판단 방지, 안정적 운영 성능·동시성 균형 Serializable 보다 낮은 오버헤드로 동시성 확보 높은 처리량 유지, 경미한 일관성 손실 허용 운영 안전성 확보 실무 시스템의 실시간 안정성 확보 운영상 오류/롤백으로 인한 사이드이펙트 축소 핵심 목적은 **정확성 (Dirty Read 방지)**과 성능 (동시성 확보) 사이의 실무적 절충을 제공하는 것이다. OLTP 에서 흔히 채택되는 이유는 _ 충분한 일관성 _ 을 보장하면서도 _ 높은 처리량 _ 을 잃지 않기 때문이다.\n문제와 목적의 연관성 맵 해결되는 문제 관련 핵심 목적 어떻게 목적 달성에 기여하는가 Dirty Read 차단 Dirty Read 방지 읽기 가시성에서 미커밋을 배제하여 직접 차단 잘못된 집계 방지 운영 안전성 확보 결산·리포트의 신뢰도 향상 읽기 지연·동시성 문제 성능·동시성 균형 Dirty Read 차단하면서도 낮은 락 오버헤드로 동시성 유지 각 문제는 Read Committed 가 제공하는 핵심 목적 (정확성 확보·운영 안정성·성능 균형) 과 직접적으로 연결된다. 즉, 문제 해결 (Dirty Read 차단) 은 곧 핵심 목적 (신뢰성 확보) 에 기여하며, 동시에 시스템은 더 높은 격리 수준 대비 성능을 유지한다. 다만 Non-repeatable/Phantom 같은 다른 이상현상은 별도 대책이 필요하다.\n격리 적용을 위한 필수 전제조건 Read Committed 를 안전하게 쓰려면 네 가지가 준비되어야 한다.\nDB 가 커밋 상태를 판별할 수 있는 저장·버전 메커니즘 (undo/redo 또는 MVCC) 이 있어야 한다. 격리 수준을 세션 혹은 트랜잭션 단위로 설정할 수 있어야 해서 특정 쿼리만 RC 로 돌릴 수 있어야 한다. 인덱스·통계 등 튜닝이 되어야 불필요한 스캔으로 락이 오래 걸리는 문제를 줄일 수 있다. 운영 정책 (누가 변경 권한을 가지는지) 과 모니터링 (롱 트랜잭션·버전 bloat 감시) 을 갖춰야 안정적으로 운영할 수 있다. Read Committed 적용 필수요건표 항목 요구사항 실무 설명 / 근거 저장·버전 메커니즘 undo/redo 로그 또는 MVCC 버전 저장소 필요 읽기 시 \" 커밋된 버전 \" 을 판별하려면 커밋 메타데이터 (LSN/commit ts) 또는 undo 체인 참조 필요 격리 설정 제어 기본값 + 세션/트랜잭션/쿼리 단위 변경 가능 특정 쿼리만 RC 로 적용해 리스크 국소화 가능 (SET TRANSACTION ISOLATION LEVEL READ COMMITTED) 인덱스·통계 적절한 인덱스, 최신 통계 유지 스캔 범위 축소로 락 범위/버전 스캔 비용 감소, 성능·정합성 영향 완화 트랜잭션 길이 관리 짧은 트랜잭션 권장, 배치 청크 처리 긴 트랜잭션은 락 유지·MVCC bloat 유발 → 운영 리스크 증가 권한·변경 절차 격리 변경 권한·검증 절차 정의 임의 변경 방지, 변경 시 테스트·로그·롤백 절차 필요 모니터링·알림 lock wait, long tx, version bloat 지표 수집·알림 문제 조기 탐지·자동화된 대응 (runbook) 필요 엔진별 확인 DB 엔진의 RC 구현 방식 문서화 동일 표기라도 내부 동작 (락 vs 문장 스냅샷) 이 달라 적용 결과 차이 발생 Read Committed 를 안전하게 운영하려면 기술 (저장·버전), 설계 (트랜잭션 길이·인덱스), 그리고 운영 (권한·모니터링) 세 축이 모두 준비되어야 한다. 특히 엔진별 동작 차이는 실무 영향이 크므로 적용 전 엔진 문서 확인과 테스트 재현이 필수다. Read Committed: 본질·근거·실무 Read Committed 는 항상 커밋된 데이터만 읽는 격리 수준으로, Dirty Read 를 차단해 일상적 데이터 왜곡을 막는다.\n그러나 각 SQL 문장은 그 시점의 최신 커밋 상태를 참조하므로 같은 트랜잭션 내에서 값이 달라질 수 있어 Non-repeatable Read 나 Phantom 이 발생할 수 있다.\n많은 RDBMS 에서 기본값으로 사용되며, 성능과 일관성의 균형이 필요한 웹·OLTP 에서 적합하지만 회계·정산처럼 강한 일관성이 필요한 곳에서는 상위 격리를 선택해야 한다.\nDB 별 구현 (MVCC vs 락 기반) 에 따라 동작 차이가 있으니 실제 환경에서 검증하는 것이 필요하다.\nRead Committed 특징 정리표 특징 설명 기술적 근거 타 수준 대비 차별점 Dirty Read 금지 미커밋 값 노출 차단 문장 단위 스냅샷 or 짧은 S-lock RU 와 달리 더티 리드 차단 문장 단위 스냅샷 / 짧은 S-lock 각 문장은 최신 커밋값 참조 MVCC 의 statement-snapshot / 락 유지 시간 최소화 Repeatable Read/Serializable 의 tx 전체 스냅샷과 다름 Non-repeatable / Phantom 허용 같은 트랜잭션 내 결과 변화 가능 트랜잭션 전체 스냅샷 미고정 Serializable 에서 방지됨 성능·확장성 우수 락·버전 오버헤드 적음 짧은 락 유지·경량 스냅샷 상위 격리보다 처리량 우수 DB 별 구현 차이 MVCC vs 락 기반 동작 차이 PostgreSQL/Oracle vs SQL Server(RCSI 옵션) 동일 레벨이라도 동작·운영 차이 존재 Read Committed 는 실무에서 가장 현실적인 균형점이다. 핵심은 Dirty Read 를 막으면서도 트랜잭션 내부 일관성 (Repeatability) 은 보장하지 않는다는 점이며, MVCC 와 락 기반 엔진 간 구현 차이가 실제 동작과 성능에 큰 영향을 준다. 따라서 기본값으로서 적합하지만, 민감 도메인은 상위 격리를 적용해야 한다.\n핵심 원리 및 이론적 기반 Read Committed 원칙·철학 완전정리 Read Committed 는 커밋된 데이터만 읽는다는 간단한 규칙을 따라 Dirty Read 를 차단하면서도, 각 SQL 문장 실행 시점의 최신 커밋 상태를 읽도록 하는 격리 수준이다.\n즉, 트랜잭션 내에서 같은 쿼리를 반복하면 다른 트랜잭션의 커밋 때문에 결과가 달라질 수 있다 (Non-repeatable/Phantom 허용).\n이 방식은 데이터 무결성은 확보하면서도 성능을 지나치게 희생하지 않는 실무적 균형을 제공하므로 대부분의 OLTP 에서 기본값으로 쓰인다.\n적용 시에는 DB 엔진별 동작 차이를 이해하고, 범위·모니터링·검증 정책을 준비하는 것이 핵심이다.\n핵심 원칙 요약표 핵심 원칙 정의 목적 (무엇을 위해) 왜 필요한가 (이유) 커밋된 것만 읽는다 미커밋 변경 노출 금지 중간 상태 노출로 인한 오작동 방지 롤백될 수 있는 값으로 시스템이 잘못 동작하는 것을 방지 문장 단위 일관성 각 SQL 문은 실행 시점의 커밋값을 참조 성능 저하 없이 최신 커밋 반영 트랜잭션 전체 스냅샷보다 경량화된 일관성 제공 핵심 원칙은 **정확성 (Dirty Read 차단)**과 실용성 (문장 단위로 성능 보전) 사이의 균형을 직접 규정한다. 이 두 원칙이 RC 의 동작과 실무 장점을 설명한다.\n설계 철학 요약표 설계 철학 핵심 내용 목적 (무엇을 위해) 왜 필요한가 (이유) 데이터 무결성 우선 잘못된 데이터 노출 차단을 우선 핵심 도메인 신뢰성 확보 결제·재고 등 치명적 오류 방지 실용적 균형 성능과 정합성의 현실적 타협 사용자 경험과 안정성 동시 확보 모든 트랜잭션에 최고 격리는 비용 과다 정책 기반 적용 적용 범위·검증·모니터링으로 통제 오용 방지·운영 안전성 확보 설정 실수·확산으로 인한 사고 예방 설계 철학은 RC 를 ’ 왜 ’ 선택하는지 (비즈니스 목표) 와 ’ 어떻게 ’ 적용할지 (운영 정책) 를 규정한다. 단순 기술 결정이 아니라 조직·운영 정책과 연결되는 의사결정 프레임워크를 제공하는 것이 핵심이다.\nRead Committed: 원리·흐름도 문장 단위 스냅샷: Read Committed 는 각 SQL 문이 시작될 때 해당 문이 읽을 ’ 커밋된 상태 스냅샷 ’ 을 결정한다. 이는 MVCC 기반 DB 에서 주로 사용되는 방식이며, 읽으려는 시점에 커밋된 버전만 볼 수 있게 한다.\n가시성 규칙: 읽기 작업은 문 시작 시점의 commit flag 에 따라 버전을 선택한다. 따라서 다른 트랜잭션이 문 이후에 커밋한 변경은 다음 문에서 보이지만, 현재 문에서는 보이지 않는다.\n락 기반 예외: 일부 RDBMS(예: SQL Server 기본) 는 읽기 시 공유락을 잡아 쓰기 트랜잭션을 블로킹해 동일한 효과 (Dirty Read 차단) 를 달성한다. 이 경우는 블로킹과 성능 영향이 크다.\nNon-repeatable / Phantom 가능: 문 단위 스냅샷 때문에 트랜잭션 내 반복 조회 시 값이 달라질 수 있고 (Non-repeatable), 반복되는 집계범위가 바뀌어 Phantom 이 발생 가능.\nUndo/Redo 와 상호작용: MVCC 는 변경 전 값 (또는 이전 버전) 을 유지 (undo/version store) 해 문 시점의 결과를 재구성한다. Read Committed 가 \" 로그가 없음 \" 을 의미하지는 않음.\n실무 권장: 반복 읽기 불변이 필요한 경우 Snapshot Isolation 또는 Serializable 을 고려하고, 읽기 전용 복제본을 사용해 리포팅 부하를 분리하라.\nRead Committed 메커니즘 요약표 메커니즘 무슨 일인가 영향 (특성) 실무 메모 문장 시점 스냅샷 생성 각 SQL 문 시작 시 읽을 커밋 상태 결정 그 문은 그 시점의 커밋된 값만 본다 긴 문은 오래된 스냅샷 기준으로 읽음 Dirty Read 차단 커밋되지 않은 변경은 보이지 않음 데이터 무결성 향상 Dirty Read 위험 제거 Non-repeatable 가능 같은 트랜잭션 내 후속 문이 다른 결과를 볼 수 있음 트랜잭션 내 일관성 불완전 필요한 경우 SI/Serializable 권장 MVCC(undo/version) 사용 이전 버전으로 문 시점 값 재구성 읽기 블로킹 최소화 버전 보관 비용 존재 락 기반 (예: SQL Server 기본) 읽기 시 공유락 획득 → 쓰기와 충돌 시 블로킹 블로킹 가능성 ↑ RCSI 옵션으로 버전 기반 전환 가능 SELECT FOR UPDATE 강제 락 획득 → 다른 트랜잭션 차단 행 수준 일관성 확보 잠금으로 동시성 저하 가능 Read Committed 는 문장 단위의 일관성 강화를 통해 Dirty Read 를 차단하면서도 시스템에 따라 버전 (Non-blocking) 또는 락 (블로킹) 기반으로 동작한다. 결과적으로 속도와 정합성의 균형을 제공하지만 트랜잭션 내부 반복 읽기에서의 값 변화 (Non-repeatable) 와 팬텀을 허용하므로, 필요한 경우 더 강한 격리로 보완해야 한다.\nRead Committed 동작 흐름도 (분기) sequenceDiagram participant T1 as \"T1 (Writer)\" participant DB as \"DB Engine\" participant T2 as \"T2 (Reader)\" T1-\u003e\u003eDB: BEGIN T1-\u003e\u003eDB: UPDATE item SET stock = 0 WHERE id = 1 Note over DB: 변경 생성 → 버퍼/undo 버전 생성 alt DB uses MVCC (versioning) T2-\u003e\u003eDB: BEGIN T2-\u003e\u003eDB: SELECT … // 문 시작 시 스냅샷 생성 Note over DB: statement-level read view(문 시점의 커밋된 버전) DB--\u003e\u003eT2: 반환값 = (이전 커밋값) T1-\u003e\u003eDB: COMMIT Note over DB: 변경이 커밋되어 이후 문에서 보임 else DB uses Lock-based (shared locks) T2-\u003e\u003eDB: BEGIN T2-\u003e\u003eDB: SELECT … // 공유락 시도 Note over DB: SELECT는 shared lock 획득 시도 → Writer의 X-lock이 있으면 블로킹 DB--\u003e\u003eT2: (blocked until Writer COMMIT/ROLLBACK) T1-\u003e\u003eDB: COMMIT DB--\u003e\u003eT2: shared lock granted → SELECT returns committed value end MVCC 는 문 시작 시 스냅샷 생성 → 그 스냅샷에 따라 값 반환하는 흐름이며, 이 경우 Reader 는 Writer 의 미커밋 변경을 보지 못한다. Writer 가 COMMIT 하면 그 변경은 다음 문에서 보이게 된다.\n락 기반는 Reader 의 SELECT 가 공유락을 획득하려 할 때 Writer 가 이미 배타적 락을 가진 상황이면 Reader 가 블로킹되어 Writer 가 COMMIT/ROLLBACK 할 때까지 대기한다. 이로 인해 Dirty Read 는 방지되지만 블로킹과 성능 저하가 발생할 수 있다.\n이 흐름은 DB 종류와 설정 (RCSI 등) 에 따라 달라지므로, 운영 환경에 맞춰 분기 중 해당 케이스를 선택해 이해해야 한다.\nRead Committed: 흐름·생명주기·실무포인트 트랜잭션을 시작한 후 SELECT 할 때마다 DB 는 그 순간 커밋된 최신값을 보여준다. 만약 다른 트랜잭션이 중간에 값을 바꾸고 커밋하면, 다음 SELECT 에서 그 변경이 보인다. 장점: Dirty Read 차단, 높은 동시성. 단점: 같은 트랜잭션 내에서 값이 바뀔 수 있으니 재조회할 때 주의해야 함. RC 의 문단위 가시성 설명 핵심 흐름 (문장 단위)\n문 시작 → DB 는 그 문에 대한 **가시성 기준 (스냅샷 또는 락 판정)**을 확보. 읽기 수행 → 커밋된 버전만 스캔하여 결과 반환 (미커밋 변경은 숨김). 문 종료 → 해당 문 단위의 스냅샷 폐기 또는 공유 락 해제. 트랜잭션이 계속되는 동안 다음 문은 새 가시성 기준으로 다시 평가되므로 이전 문에서 보지 못한 커밋이 이후 문에서 보일 수 있다. Read Committed 데이터 흐름표 단계 주체 동작 가시성 규칙 비고 1 트랜잭션 시작 트랜잭션 활성화 — 트랜잭션 컨텍스트 생성 2 문 (statement) 시작 스냅샷 획득 또는 락 판정 그 문 시점의 커밋 값만 엔진별 스냅샷/락 방식 다름 3 읽기 수행 SELECT 실행 커밋된 버전 스캔 미커밋 값은 보이지 않음 4 문 종료 스냅샷 폐기 / 락 해제 — 다음 문은 새 기준으로 평가 5 트랜잭션 계속/종료 추가 문 실행 또는 COMMIT/ROLLBACK 각 문마다 가시성 재평가 동일 트랜잭션 내 재조회 값 변경 가능 표는 RC 의 핵심: 각 문은 그 문이 시작될 때의 커밋 상태만 본다는 점을 단계별로 정리한 것이다. 적용 시 엔진별 구현 (락 기반 vs MVCC statement-snapshot) 을 확인하고, 같은 트랜잭션 내 재조회 불일치에 대해 애플리케이션 레벨에서 대비하라.\nRC 문단위 가시성 흐름도 flowchart LR Start[트랜잭션 시작] --\u003e S1[문1 시작: 스냅샷/락 획득] S1 --\u003e Q1[문1: SELECT -\u003e 커밋된 값 반환] Q1 --\u003e End1[문1 종료: 스냅샷 폐기/락 해제] End1 --\u003e S2[문2 시작: 새 스냅샷/락 판정] S2 --\u003e Q2{다른 트랜잭션이 커밋했나?} Q2 -- 아니오 --\u003e Q2a[문2: 이전 값 반환] Q2 -- 예 --\u003e Q2b[문2: 커밋된 새 값 반환] Q2a \u0026 Q2b --\u003e End2[문2 종료] End2 --\u003e Continue[트랜잭션 계속/종료] 이 흐름도는 한 트랜잭션 내에서 각 문 (statement) 이 시작될 때마다 새 가시성 판단을 거쳐 커밋된 값을 읽는다는 RC 의 핵심을 시각화한다. 다른 트랜잭션이 중간에 커밋하면 다음 문에서 그 변경이 보이며, 그렇지 않으면 이전 값이 유지된다.\nRC 트랜잭션 생명주기 stateDiagram-v2 [*] --\u003e Active: 트랜잭션 시작 Active --\u003e Statement: 문 시작 (스냅샷/락 획득) Statement --\u003e Read: SELECT 수행 (커밋 버전 스캔) Read --\u003e EndStatement: 문 종료 (스냅샷 폐기/락 해제) EndStatement --\u003e Decision: 트랜잭션 계속? Decision --\u003e Statement: 문 시작 Decision --\u003e Commit: COMMIT Decision --\u003e Rollback: ROLLBACK Commit --\u003e [*] Rollback --\u003e [*] 이 상태도는 트랜잭션이 문 (statement) 을 시작 → 읽기 수행 → 문 종료 패턴을 반복하다가 최종적으로 COMMIT/ROLLBACK 으로 종료되는 생명주기를 보여준다. RC 에서는 각 문이 독립적으로 가시성을 평가하므로 동일 트랜잭션 내에서도 문마다 다른 커밋 상태를 반영할 수 있다.\n특성 분석 및 평가 Read Committed: 장점·실무적 가치 Read Committed 는 읽을 때마다 ’ 확정된 ‘(커밋된) 데이터만 보여줘서 잘못된 (미확정) 값을 읽는 위험을 없애고, 동시에 읽기 작업을 차단하지 않아 많은 사용자가 동시에 조회할 때 처리량을 높여준다.\n즉, ’ 데이터 신뢰성 (Dirty Read 차단)’ 과 ’ 실무적 성능 (높은 동시성)’ 사이에서 균형을 맞춘 현실적 선택이다.\n하지만 동일 트랜잭션 내에서 값이 바뀔 수 있으니 (재조회 불일치) 중요 연산에는 적절한 보완이 필요하다.\nRead Committed 장점 요약표 장점 기술적 근거 기대되는 실무 효과 Dirty Read 차단 문 (statement) 시점의 커밋된 버전만 가시화 (MVCC 스냅샷 또는 S-lock) 잘못된 데이터 기반 처리 방지 → 데이터 신뢰성 유지 높은 동시성 읽기 비차단 (짧은 락/스냅샷) 으로 읽기 병렬화 TPS·동시 사용자 수 증가, 응답시간 개선 예측 가능한 성능 강격리에서 발생하는 직렬화/재시도 오버헤드 회피 성능 변동성 감소 → 안정적 SLA 수립 용이 구현·운영 용이성 대부분 DB 에서 기본값 또는 간단 설정 도입·운영 비용 절감, 마이그레이션 편의성 표는 RC 가 어떤 기술 메커니즘(MVCC/락) 으로 동작하는지와, 그 결과로 **운영에서 어떤 개선 (신뢰도·처리량·예측 가능성·도입 용이성)**을 기대할 수 있는지를 요약한다. 현실적으로는 워크로드 특성 (읽기 비율, 트랜잭션 길이, 핫스팟 유무) 에 따라 효과의 크기가 달라지므로, 실제 적용 전 성능 측정과 재조회 불일치 (Non-repeatable Read) 에 대한 애플리케이션 보호 방안 (재검증·낙관적 재시도 등) 을 준비해야 한다.\nRead Committed 의 한계·운영 대비체계 Read Committed 는 미커밋 데이터 (Dirty Read) 를 차단해 일상적인 OLTP 에서 안정적인 읽기를 제공한다.\n다만 트랜잭션 전체의 재현성 (같은 트랜잭션 내에서 여러 번 읽었을 때 항상 같은 결과) 은 보장하지 못한다 (Non-Repeatable, Phantom). 따라서 보고·회계처럼 재현성이 필수인 작업은 더 강한 격리 수준이나 스냅샷 기반 리포트로 분리해야 한다.\n실무에서는 문제 범위를 좁히고 (테이블·쿼리 화이트리스트), DB 별 동작을 테스트 후 적절한 완화책을 적용하는 것이 안전한 접근 방식이다.\nRead Committed 단점 개요표 단점 핵심 영향 핵심 완화책 Non-Repeatable Read 트랜잭션 내 반복 읽기 결과 불일치 (재현 불가) Repeatable Read/Snapshot, 트랜잭션 축소 Phantom Read 범위 질의 결과의 변화 (행 추가/삭제) Serializable/범위 락 또는 Predicate Locking 쓰기 충돌 증가 락 경합·데드락·타임아웃 가능 MVCC, 짧은 TX, 재시도 로직 단점들은 RC 자체의 설계 한계에서 비롯된다. 운영상 영향은 **재현성 결여 (회계/감사 위험)**와 **범위 질의 불안정 (집계/페이징 문제)**이며, 해결책은 필요 수준에 맞춰 격리 수준 상향 또는 아키텍처 (리플리카/스냅샷) 분리로 보통 처리한다.\nRead Committed 제약사항 개요표 제약사항 핵심 현상 권장 대응 시점 일관성 한계 트랜잭션 전체 스냅샷이 없음 중요한 계산은 상위 격리로 처리 보고 정확도 요구 불일치 규제·회계 리포트 부적합 OLAP/리플리카 기반 리포트 DB 별 구현 차이 동일 명세라도 엔진별 행위 상이 배포 전 DB 별 테스트·문서화 제약사항은 환경·정책·엔진 특성에서 발생하므로 시스템 설계 단계에서 요구사항 (정확성·성능·규제) 을 바탕으로 격리 수준 정책을 수립하고, DB 별 특성을 반영한 운영 매뉴얼을 만들어야 한다.\nRC 트레이드오프·혼합 전략 안내 Read Committed 는 \" 커밋된 데이터만 읽게 해서 더티 리드는 막지만, 같은 트랜잭션에서 반복해서 읽을 때 값이 바뀔 수는 있는 \" 중간 수준의 격리다.\n장점은 빠른 응답과 높은 동시성, 단점은 일부 일관성 문제가 남는 것이다.\n실무에서는 중요한 결정 (결제·정산) 경로엔 더 높은 격리를 쓰고, 대시보드·로그처럼 정확도가 덜 중요한 읽기에는 RC 를 적용하는 식으로 균형을 맞춘다.\nRead Committed 주요 선택별 트레이드오프 비교 쌍 선택 장점 단점 고려 기준 일관성 vs 성능 Serializable 완전한 일관성, 이상현상 차단 높은 지연·낮은 처리량 금전·회계·법적 요구 Read Committed 낮은 지연, 높은 동시성 Non-repeatable/Phantom 허용 대시보드·로그·근사치 허용 영역 락 vs MVCC 락 기반 직접 제어·예측 용이 데드락·대기 짧은 트랜잭션·소규모 동시성 MVCC 읽기 비차단, 높은 읽기 처리량 버전 bloat·정리 비용 읽기 중심 워크로드 Replica vs Master read Replica+Recheck 읽기 분산, 낮은 응답 지연 (staleness)·재검증 필요 보고·비결정적 조회 Master 즉시 일관성 마스터 부하 증가 결정적 조치 필요 경로 핵심은 비즈니스 민감도(금전/상태 변경 여부) 와 성능 목표 (p95/p99) 를 기준으로 선택하는 것. 대부분 시스템은 전역 한가지만 택하지 않고 핵심 경로는 상향 격리, 나머지는 RC/Replica 기반으로 하이브리드 운영한다. RC 완화용 하이브리드 패턴 비교표 패턴 구성요소 적용목적 장점 고려사항 Selective Elevation 정책 매핑, RBAC 핵심경로 강일관성 확보 전체 성능 유지 경로 식별·테스트 필요 Replica + Recheck 비동기 복제, 재검증 읽기 오프로드 + 결정 신뢰성 읽기 성능↑, 결정 시 안전 재검증 비용·복제 지연 OCC + Retry 버전태그·재시도 로직 락 회피, 높은 동시성 낮은 락 오버헤드 충돌률 관리·idempotency Snapshot + Verify 스냅샷 읽기, 재조회 빠른 조회 + 결정 신뢰 UX 유지 + 안전성 강화 추가 쿼리 비용 Escrow/Quota 토큰/쿼터 저장소 자원 분할으로 충돌 완화 충돌 최소화 설계·수송 복잡 Materialized View 뷰 + refresh 정책 집계/리포트 성능 확보 대시보드 성능 극대화 신선도·갱신 비용 하이브리드 패턴들은 RC 의 성능 장점은 살리고 결정적 경로의 일관성은 보장하도록 설계된 현실적 방법들이다. 선택은 비즈니스 위험도, 허용 가능한 지연 (신선도), 개발·운영 복잡도를 저울질해 결정해야 한다. Read Committed 적용성·운영 전략 Read Committed 는 항상 커밋된 데이터만 읽어 Dirty Read 를 방지하면서도, 트랜잭션 내부 여러 문장 사이의 값 일관성은 보장하지 않는다.\n그래서 웹 UI 조회·OLTP 처럼 성능과 합리적 정합성의 균형이 필요한 곳에 적합하다. 반면 회계·정산·재고처럼 같은 트랜잭션 내 반복 읽기 일관성이 필수인 도메인엔 부적합하다.\n실무에서는 읽기 전용 풀, CQRS, 결과 재검증, 모니터링·자동격상 같은 설계·운영 가드레일을 결합해 리스크를 관리한다.\nRead Committed 적용 적합성 표 시나리오 / 도메인 적합성 설계 관점 판단 분석 (측정) 포인트 운영 권장 대책 권장 대안 (부적합 시) UI 조회 (제품 상세, 리스트) 적합 짧은 단건 쿼리, 리드리플리카 활용 응답지연, stale-read 비율 리플리카 라우팅·staleness 표시 (필요시) 마스터 조회 일반 OLTP(주문 조회) 보통 적합 주문 조회는 적합, 다단계 정산은 비적합 재시도율·deadlock rate 읽기 풀 분리·검증 로직 트랜잭션 격상 일부 단계 로그 집계 / 분석 (근사치) 적합 높은 처리량 우선 throughput, accuracy gap 주기적 재집계·샘플검증 배치 ETL 이벤트 소싱 읽기 모델 적합 프로젝션 읽기 용이 projection lag projection 재빌드 자동화 N/A 재무 결제 / 정산 부적합 동일 tx 반복 읽기 필수 계산 불일치, rollback 빈도 사용 금지 (정책 차단) Repeatable Read / Serializable 재고 재할당 (동시성 민감) 부적합 (주의) 충돌 가능성 높음 오더 컨플릭트 비율 유니크 제약, 분산 락, 격상 Serializable / 분산 토큰 Read Committed 는 UI·일반 OLTP·로그/프로젝션 등 대다수 읽기 시나리오에 적합하지만, 금융/정산/재고 같은 동일 트랜잭션 반복 읽기가 요구되는 도메인에는 부적합하다. 적용 시엔 **설계 (읽기 풀/CQRS), 분석 (성능·일관성 지표 측정), 운영 (모니터링·자동격상)**의 삼중 방어선으로 리스크를 관리하라. DB 별 Read Committed 동작 비교 모두 Dirty Read 는 차단한다. 차이점은 ’ 어떻게 ’ 차단하는지 (락 vs 버전관리) 와 성능·블로킹 특성: Postgres / Oracle / MySQL(RC) → MVCC/문 수준 스냅샷 (읽기 블로킹 거의 없음, 같은 트랜잭션 내 Non-repeatable 발생). SQL Server 기본 RC → 락 기반 (읽기 시 공유락) 으로 쓰기와 충돌 시 블로킹 발생; RCSI 켜면 row-versioning 동작으로 블로킹 완화. DB Read Committed 구현 방식 (요지) Dirty Read Non-repeatable / Phantom 설정 방식 (세션/DB) 실무 포인트 PostgreSQL 기본값 = Read Committed, MVCC 기반 → 문 (statement) 시점의 스냅샷을 읽음 차단 가능 (문 수준 스냅샷이므로 같은 트랜잭션 내 후속 SELECT 는 다른 트랜잭션 커밋을 볼 수 있음) SET TRANSACTION ISOLATION LEVEL READ COMMITTED; (세션/트랜잭션) MVCC 라서 읽기 블로킹 없음. RU 와 혼동하지 말 것. MySQL (InnoDB) 기본값은 REPEATABLE READ(InnoDB). RC로 세션/트랜잭션 변경 가능. InnoDB 의 RC 는 statement-level MVCC(각 문은 최신 커밋 버전 참조) 차단 가능 (RC 로 설정하면 문 수준 동작) SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; 기본이 RR 임을 유의. RC 로 변경 시 동작·성능 차이 테스트 필수. SQL Server (MSSQL) 기본 Read Committed 는 락 기반 (읽기 시 공유락) → 읽기 - 쓰기 블로킹 발생. READ_COMMITTED_SNAPSHOT (RCSI) ON 시에는 row-versioning(statement-level snapshot) 으로 동작 차단 가능 (락 기반이면 블로킹, RCSI 면 문 수준 스냅샷으로 Non-repeatable 발생) SET TRANSACTION ISOLATION LEVEL READ COMMITTED; DB 레벨: ALTER DATABASE … SET READ_COMMITTED_SNAPSHOT ON; 운영 DB 에서 RCSI 전환은 주의 (데이터베이스 설정 영향). 블로킹 특성 이해해야 함. Oracle 기본값 READ COMMITTED, undo 기반의 read-consistency로 각 SQL 문은 그 문 시작 시점의 스냅샷을 읽음 (MVCC 유사) 차단 가능 (문 수준 스냅샷) ALTER SESSION SET ISOLATION_LEVEL = READ COMMITTED; (세션) Oracle 은 항상 statement consistency 유지. Flashback/Undo 이해 필요. PostgreSQL (psql)—재현 스크립트 준비 (한 번만) 1 2 3 4 5 -- psql로 접속 후 CREATE TABLE item (id serial PRIMARY KEY, stock int); INSERT INTO item(stock) VALUES (10); -- 확인 SELECT * FROM item; 시나리오 1: Dirty Read 방지 (T1: Writer, T2: Reader) T1 (세션 A):\n1 2 3 BEGIN; UPDATE item SET stock = 0 WHERE id = 1; -- 아직 COMMIT 하지 않음 T2 (세션 B):\n1 2 3 4 -- 기본이 Read Committed인 경우 BEGIN; SELECT stock FROM item WHERE id = 1; -- 결과: 10 (원래 커밋된 값) -\u003e Dirty Read가 발생하지 않음 COMMIT; T1 (세션 A):\n1 ROLLBACK; 시나리오 2: Non-repeatable Read (T1 가 두 번 읽는 케이스) T1 (세션 A):\n1 2 3 BEGIN; SELECT stock FROM item WHERE id = 1; -- A1: 10 -- **다른 세션에서 커밋된 변경이 발생하면** T2 (세션 B):\n1 2 3 BEGIN; UPDATE item SET stock = 5 WHERE id = 1; COMMIT; T1 (세션 A):\n1 2 SELECT stock FROM item WHERE id = 1; -- A2: 5 (값 변경 확인 -\u003e Non-repeatable Read) COMMIT; 시나리오 3: Phantom Read (간단) T1 (세션 A):\n1 2 BEGIN; SELECT count(*) FROM item WHERE stock \u003e 0; -- e.g., 1 T2 (세션 B):\n1 2 3 BEGIN; INSERT INTO item(stock) VALUES(7); COMMIT; T1 (세션 A):\n1 2 SELECT count(*) FROM item WHERE stock \u003e 0; -- 값 증가 -\u003e Phantom 발생 가능 COMMIT; 메모: PostgreSQL 은 MVCC 로 동작하므로 Read Committed 의 의미는 \" 문장 시점의 커밋된 스냅샷 \" 을 보는 것. 위 결과는 그 의미에 부합함.\nMySQL (InnoDB)—재현 스크립트 참고: MySQL(InnoDB) 기본 격리 수준은 REPEATABLE READ. Read Committed 로 테스트하려면 세션 또는 글로벌 격리 수준을 변경해야 한다.\n준비 1 2 3 -- mysql 클라이언트 접속 CREATE TABLE item (id INT AUTO_INCREMENT PRIMARY KEY, stock INT); INSERT INTO item(stock) VALUES (10); 세션을 Read Committed 로 설정 (각 세션에서) 1 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; Dirty Read 방지 T1 (세션 A):\n1 2 3 START TRANSACTION; UPDATE item SET stock = 0 WHERE id = 1; -- 아직 COMMIT 없음 T2 (세션 B):\n1 2 3 4 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; SELECT stock FROM item WHERE id = 1; -- 결과: 10 (커밋된 값) -\u003e Dirty Read 없음 COMMIT; T1 (세션 A):\n1 ROLLBACK; Non-repeatable Read T1 (세션 A):\n1 2 3 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; SELECT stock FROM item WHERE id = 1; -- 10 T2 (세션 B):\n1 2 3 4 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; UPDATE item SET stock = 5 WHERE id = 1; COMMIT; T1 (세션 A):\n1 2 SELECT stock FROM item WHERE id = 1; -- 5 (값 변경 관찰) COMMIT; Phantom Read T1 (세션 A):\n1 2 3 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; SELECT COUNT(*) FROM item WHERE stock \u003e 0; -- e.g., 1 T2 (세션 B):\n1 2 3 4 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; INSERT INTO item(stock) VALUES (7); COMMIT; T1 (세션 A):\n1 2 SELECT COUNT(*) FROM item WHERE stock \u003e 0; -- 값 증가 -\u003e Phantom COMMIT; 메모: InnoDB 는 gap-lock 등으로 phantom 을 제어하려는 메커니즘이 있으나, 동작은 격리 수준 및 쿼리 형태에 따라 달라짐. REPEATABLE READ 와 비교해 동작이 다르므로 실제 적용 전 테스트가 필수.\nSQL Server (T-SQL)—재현 스크립트 참고: SQL Server 기본은 Read Committed(락 기반). DB 수준에서 READ_COMMITTED_SNAPSHOT 을 ON 으로 하면 Read Committed 가 row-versioning(스냅샷 기반) 으로 동작해 블로킹을 줄임. (설정 전 주의: DB 재기동/활성 연결 처리 필요)\n준비 1 2 CREATE TABLE item (id INT IDENTITY PRIMARY KEY, stock INT); INSERT INTO item(stock) VALUES (10); 기본 Read Committed (락 기반)—Dirty Read 방지 T1 (세션 A):\n1 2 3 BEGIN TRAN; UPDATE item SET stock = 0 WHERE id = 1; -- 미커밋 상태 T2 (세션 B):\n1 2 3 4 5 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; BEGIN TRAN; SELECT stock FROM item WHERE id = 1; -- 블로킹 발생(쓰기가 풀릴 때까지 기다리거나 타임아웃) -- 즉, Dirty Read 없음(읽기 시 공유락으로 쓰기 차단) COMMIT; T1 (세션 A):\n1 ROLLBACK TRAN; Non-repeatable Read T1 (세션 A):\n1 2 3 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; BEGIN TRAN; SELECT stock FROM item WHERE id = 1; -- 10 T2 (세션 B):\n1 2 3 BEGIN TRAN; UPDATE item SET stock = 5 WHERE id = 1; COMMIT; T1 (세션 A):\n1 2 SELECT stock FROM item WHERE id = 1; -- 5 (Non-repeatable) COMMIT; Phantom Read T1 (세션 A):\n1 2 3 SET TRANSACTION ISOLATION LEVEL READ COMMITTED; BEGIN TRAN; SELECT COUNT(*) FROM item WHERE stock \u003e 0; -- e.g., 1 T2 (세션 B):\n1 2 3 BEGIN TRAN; INSERT INTO item(stock) VALUES (7); COMMIT; T1 (세션 A):\n1 2 SELECT COUNT(*) FROM item WHERE stock \u003e 0; -- 증가 -\u003e Phantom COMMIT; Read Committed Snapshot (RCSI) 예 (옵션) DB 에 RCSI 를 켜면 읽기 시 버전 기반으로 동작하여 읽기 - 쓰기 블로킹 완화:\n1 2 ALTER DATABASE YourDB SET READ_COMMITTED_SNAPSHOT ON; -- 주의: 변경은 DB에 따라 재기동/활성 연결 영향 있음 메모: RCSI 를 켜면 읽기 시 writer 와 블로킹을 피하고 statement-level snapshot 을 제공하므로 성능/일관성 트레이드오프가 달라짐.\n실무 적용 및 사례 실습 예제 및 코드 구현 실습 예제: RC 에서 비반복 읽기/팬텀 관찰 (PostgreSQL) 목적 RC 의 문장 단위 스냅샷, 비반복/팬텀 현상 체험 사전 요구사항 PostgreSQL 14+ / psycopg[binary] 3.x / 두 개의 세션 또는 아래 파이썬 스크립트 단계별 구현 스키마 준비\n1 2 CREATE TABLE inv(id int primary key, qty int); INSERT INTO inv VALUES (1, 10), (2, 10); 파이썬 동시 시나리오 (두 커넥션)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # pip install psycopg[binary] import psycopg, time DSN = \"postgresql://user:pass@localhost:5432/db\" # 각 줄 주석으로 RC의 동작을 설명합니다. with psycopg.connect(DSN) as conn1, psycopg.connect(DSN) as conn2: conn1.autocommit = False conn2.autocommit = False with conn1.cursor() as c1, conn2.cursor() as c2: # 세션 1: 트랜잭션 시작 c1.execute(\"BEGIN;\") # 첫 번째 읽기(문장 스냅샷 1) c1.execute(\"SELECT SUM(qty) FROM inv;\") print(\"T1 sum-1:\", c1.fetchone()[0]) # 20 # 세션 2: 다른 트랜잭션에서 업데이트 후 커밋 c2.execute(\"BEGIN;\") c2.execute(\"UPDATE inv SET qty = qty + 10 WHERE id = 1;\") c2.execute(\"COMMIT;\") # 이제부터 새로운 문은 변경을 볼 수 있음 time.sleep(0.5) # 세션 1: 같은 트랜잭션에서 두 번째 읽기(문장 스냅샷 2) c1.execute(\"SELECT SUM(qty) FROM inv;\") print(\"T1 sum-2:\", c1.fetchone()[0]) # 30 (비반복 읽기) # 팬텀 관찰: 행 추가 c2.execute(\"BEGIN;\") c2.execute(\"INSERT INTO inv VALUES (3, 5);\") c2.execute(\"COMMIT;\") c1.execute(\"SELECT COUNT(*) FROM inv WHERE qty \u003e= 5;\") print(\"T1 count after phantom:\", c1.fetchone()[0]) # 3 (팬텀) c1.execute(\"ROLLBACK;\") 실행 결과/검증 sum-1=20, sum-2=30 → Non-Repeatable Read count=3 → Phantom Read 추가 실험 같은 시나리오를 SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; 로 비교 실행 실습 예제: Read Committed 트랜잭션 테스트 목적 커밋된 데이터만 읽는 Read Committed 의 특징과 Non-Repeatable Read 현상을 직접 코드로 검증. 사전 요구사항 데이터베이스: MySQL, PostgreSQL 등 (격리 수준 변경 가능) 계정 권한: 트랜잭션 및 테이블 조회/변경 권한 실습 환경: CLI 또는 DB 툴, AUTOCOMMIT OFF 단계별 구현 트랜잭션 시작 및 데이터 조회\n1 2 3 4 -- 세션 A SET TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; SELECT price FROM product WHERE id = 100; -- ex: 1000원 다른 트랜잭션에서 데이터 변경 및 커밋\n1 2 3 4 5 -- 세션 B SET TRANSACTION ISOLATION LEVEL READ COMMITTED; START TRANSACTION; UPDATE product SET price = 1200 WHERE id = 100; COMMIT; 원래 트랜잭션에서 재조회\n1 2 3 -- 세션 A SELECT price FROM product WHERE id = 100; -- 1200원으로 변경됨 COMMIT; 실행 결과 같은 트랜잭션 내에서 SELECT 결과가 바뀌는 Non-Repeatable Read(반복 읽기 불가능) 확인. 추가 실험 REPEATABLE READ 로 격리 수준을 변경하면 반복 조회 시 동일 결과가 반환됨. 최종 정리 및 학습 가이드 내용 종합 Read Committed 는 데이터베이스 격리 수준 중 실무에서 널리 쓰이는 균형점이다.\n이 모드는 트랜잭션이 다른 트랜잭션의 미커밋 변경을 볼 수 없도록 보장해서 Dirty Read 로 인한 잘못된 보고·오류를 예방한다. 대신, RC 는 문장 (statement) 단위 가시성을 제공하므로 동일 트랜잭션에서 같은 쿼리를 반복하면 결과가 달라질 수 있는 Non-Repeatable Read 와 범위 질의에서 행의 추가·삭제로 결과가 달라지는 Phantom Read 를 허용한다.\n실무에서는 다음 원칙을 권장한다.\n핵심 데이터 (금융·결제·사용자 상태) 는 반드시 더 높은 격리 수준 (예: Repeatable Read, Serializable 또는 Snapshot 기반 트랜잭션) 에서 처리하고, 리포트·집계·로그 같은 읽기 중심 워크로드는 RC 적용을 검토하되 DB 별 동작 차이 확인, 재현 테스트, 모니터링·롤백 계획을 필수로 준비하라.\n또한 필요한 경우 특정 쿼리나 트랜잭션만 선별적으로 상향 적용하는 접근 (쿼리 힌트·세션 단위 변경) 이 현실적이며 안전한 운영으로 이어진다.\n실무 적용 가이드 가이드 항목 적용 대상 / 조건 구체 조치 (설정·패턴) 운영 체크포인트 기본 선택 대시보드·로그·근사치 허용 조회 DB 세션 기본 RC, 쿼리별 명시 가능 (SET TRANSACTION ISOLATION LEVEL READ COMMITTED) p95 응답시간, 쿼리 타임아웃 핵심 경로 보호 결제·재고·정산 등 결정적 경로 상향 격리 (Repeatable/Serializable) 또는 유니크 제약 + outbox/compensation 실패율, 재시도/보상 로그 트랜잭션 설계 외부 I/O 포함 작업 금지 트랜잭션은 짧게, 외부 호출은 outbox/비동기화 long-running tx 수, lock wait 보완 패턴 읽기 - 리플리카 사용 가능 시 Replica + commit-time recheck(결정 전 마스터 확인) replica lag, 재검증 실패율 DB 별 운영 PostgreSQL/Oracle 등 Postgres: VACUUM/oldest xmin 모니터; Oracle: undo 관리 version bloat, vacuum lag SQL Server 특이 RCSI 사용 시 TempDB 용량/IO 설계 및 모니터링 TempDB 사용량 임계치 ORM/앱 설정 프레임워크별 세션 제어 ORM 세션 격리 명시화, 트랜잭션 경계 문서화 코드 리뷰 체크리스트, CI 동시성 테스트 변경 절차 격리 변경 시 PR→테스트 (재현 포함)→운영 승인→롤아웃 변경 로그, 자동 롤백 정책 모니터링 지표 전체 공통 tx latency(p50/p95/p99), lock wait, long tx, replica lag 알람 임계치, runbook 링크 학습 로드맵 Phase 단계명 목표 (학습 결과) 권장 기간 핵심 활동 (핵심 산출물) 실무 연관성 1 개념/현상 이해 Dirty / Non-repeatable / Phantom 현상 정의·사례 설명 가능 1–2 일 이론 학습, 간단 시나리오 작성 (문장별 예) 격리수준 선택 근거 2 MVCC vs 락 기반 각 아키텍처의 동작 원리·장단점 비교·예상 영향 설명 2–3 일 아키텍처 다이어그램, 장단점 표 성능/정합성 판단 3 DBMS 별 설정·옵션 Postgres/Oracle/MySQL/SQL Server 의 RC 동작·옵션 이해 2–4 일 DB 별 설정 요약문서, 실전 설정 스니펫 프로덕션 설정·이식성 4 실습 재현 동시성 문제 재현 (2 세션) 및 관찰/재현 능력 확보 2–5 일 재현 스크립트 + 결과 레포트 버그 재현·검증 능력 5 운영/모니터링 운영지표 수집·알람·가드레일 설계/자동화 3–7 일 대시보드 (예: Prometheus+Grafana), 알람 룰 운영 안정성·SLA 준수 6 고급 대안·최적화 SSI/HLC/Serializable 등 고급 기법 이해·적용 시나리오 4–14 일 설계 노트, 비교 평가표, 테스트 결과 민감 도메인 보호·최적화 학습 항목 정리 단계 항목 중요도 학습 목표 실무 연관성 구체 활동 (실습/검증) 1: 개념 격리수준 개요 (4 단계) 필수 각 수준의 이상현상 구분 매우 높음 표준 정의 정리, 예시 쿼리 작성 1: 개념 Dirty / Non-repeatable / Phantom 필수 재현 가능한 시나리오 이해 매우 높음 2 세션 쿼리로 재현 (짧은 스크립트) 2: 구현 차이 MVCC 내부 (버전 관리, GC) 필수 버전 읽기/가시성 규칙 이해 높음 버전 스냅샷 다이어그램 작성, VACUUM 영향 실험 2: 구현 차이 2PL/Lock Manager(Shared/Exclusive) 필수 락 테이블·대기 그래프 이해 높음 락 대기/데드락 재현 실습 3: DB 별 PostgreSQL Read Committed 특징 필수 statement-level snapshot 동작 파악 매우 높음 psql 스크립트로 reprod. 3: DB 별 Oracle(undo 기반 읽기 일관성) 권장 undo 와 스냅샷 개념 이해 높음 Oracle 환경 예제 (또는 시뮬레이션) 3: DB 별 SQL Server 기본 락 / RCSI 옵션 권장 RCSI 동작·NOLOCK 위험 파악 높음 RCSI 켜고 비교 테스트 3: DB 별 MySQL/InnoDB isolation 옵션 권장 autocommit·isolation 설정 효과 중간 InnoDB 테스트 환경 4: 실습 재현 스크립트 (2 세션) 필수 Dirty/Non-repeatable/Phantom 실증 매우 높음 Docker Compose 로 2 세션 시나리오 실행 4: 실습 복합 케이스 (페이징·집계 후 업데이트) 권장 실무 취약점 파악 높음 시나리오 - 결과 분석 리포트 5: 운영 모니터링 지표 설계 필수 lock-wait, deadlock, long tx, snapshot age 매우 높음 Prometheus + Grafana 대시보드 5: 운영 가드레일 구현 필수 읽기 풀 분리, 쿼리 화이트리스트, 자동격상 매우 높음 미들웨어 라우팅 정책 구현 6: 고급 SSI / Serializable 심층 선택 SSI 작동 원리·장단점 이해 중간 논문/문서 요약 + 실험 (가능하면) 6: 고급 분산 시간 (HLC)·글로벌 일관성 선택 HLC/TrueTime 개념 이해 중간 분산 DB 사례 연구 (Spanner) 전 단계 공통 도구·환경 필수 Docker, psql, mysql, sqlserver 컨테이너 사용법 매우 높음 예제 환경 템플릿 제공 (Compose) 전 단계 공통 검증 기준 필수 성공/실패 판정 기준 (재현률, KPI 변화) 매우 높음 체크리스트 + 자동화 테스트 용어 정리 카테고리 용어 (한글 (영문 풀네임, 약어)) 정의 관련 개념 실무 활용 핵심 읽기 커밋 (Read Committed, RC) 각 SQL 문장은 실행 시점에 커밋된 값만 읽음 (Dirty Read 방지). Dirty Read, Non-repeatable Read, MVCC, Statement-level snapshot 대부분 OLTP 의 기본 격리, 성능·정합성 균형 핵심 읽기 미완료 (Read Uncommitted, RU) 커밋되지 않은 데이터도 읽을 수 있음. Dirty Read 발생 가능. Dirty Read, 낮은 격리 로그·임시 분석 등 비정합 허용 영역 (제한적) 핵심 반복 가능 읽기 (Repeatable Read, RR) 트랜잭션 전체에서 같은 행 조회 시 동일한 값 보장 (일부 DB 에서 팬텀 허용 여부 차이). Phantom, MVCC, Snapshot Isolation 강한 읽기 일관성 필요 시 핵심 직렬화 가능 (Serializable, S) 모든 트랜잭션을 직렬 실행한 것과 동일한 결과 보장 (최고 격리). 검증·락·비관적 제어 회계·재무·정산 등 최고 신뢰가 필요한 영역 핵심 더티 리드 (Dirty Read,—) 다른 트랜잭션의 미커밋 변경을 읽는 현상. Read Uncommitted, Read Committed 방지 대상 (프로덕션 핵심) 핵심 반복 불가 읽기 (Non-Repeatable Read,—) 동일 쿼리 반복 시 값이 달라지는 현상 (다른 트랜잭션 커밋 영향). Read Committed, Repeatable Read 집계·계산 신뢰성 고려 핵심 팬텀 (Phantom Read,—) 동일 조건 재조회 시 행 집합이 달라지는 현상 (INSERT/DELETE 영향). Serializable, RR 범위 집계·쿼리 일관성 주의 구현 다중버전 동시성 제어 (Multi-Version Concurrency Control, MVCC) 데이터의 여러 버전을 유지해 읽기를 스냅샷으로 제공, 읽기 - 쓰기 충돌 완화. Snapshot, Undo Log, GC(vacuum) PostgreSQL/Oracle 등에서 읽기 비차단 구현 구현 문장 단위 스냅샷 (Statement-level Snapshot,—) 각 SQL 문장 시점의 커밋 상태를 기준으로 읽음 (대표: Read Committed 형태 동작 해석 시 사용). Read Committed, MVCC RC 동작 이해 시 유의점 구현 트랜잭션 단위 스냅샷 (Transaction-level Snapshot,—) 트랜잭션 시작 시점의 스냅샷으로 전체 트랜잭션 동안 일관된 읽기 제공. Repeatable Read, Snapshot Isolation 트랜잭션 단위 일관성 필요 시 구현 2 단계 잠금 (Two-Phase Locking, 2PL) 잠금 획득 단계와 해제 단계를 분리해 직렬화 보장 (비관적 락 방식). S/X Lock, Deadlock 락 기반 DB/특정 리소스 보호 구현 공유/배타 락 (Shared/Exclusive Lock, S/X) 읽기 시 공유락, 쓰기 시 배타락으로 동시성 제어. 2PL, Deadlock 락 정책 설계 및 데드락 모니터링 구현 RCSI (Read Committed Snapshot Isolation, RCSI) SQL Server 의 버전 기반 Read Committed 구현 옵션 (TempDB 에 버전 저장). MVCC, TempDB SQL Server 에서 격리·성능 조정 운영 트랜잭션 (Transaction,—) 연산의 원자적 단위: Begin → (작업) → Commit/Rollback. ACID, Isolation Level 모든 DB 작업의 기본 단위 운영 격리 수준 (Isolation Level,—) 트랜잭션 간 중간 상태 노출 규칙의 집합 (표준: RU/RC/RR/S). ACID, SQL 표준 DB/ORM 정책 설정 운영 언두/리두 로그 (Undo/Redo Log,—) 변경 이전 상태/이후 상태를 기록해 복구·롤백 지원. WAL, ARIES 복구·체크포인트 설계 운영 Snapshot Isolation (Snapshot Isolation, SI) 트랜잭션 단위 스냅샷을 제공해 읽기 일관성 확보 (정확한 동작은 DB 별 상이). MVCC, Repeatable Read 중간 수준 일관성 (엔진별 차이 주의) 참고 및 출처 PostgreSQL: Transaction Isolation Oracle Database: Data Concurrency and Consistency Microsoft Learn: SET TRANSACTION ISOLATION LEVEL (Transact-SQL) MySQL Reference Manual: InnoDB Transaction Isolation Levels A Critique of ANSI SQL Isolation Levels (Berenson et al., 1995) — PDF Weak Consistency: A Generalized Theory and Optimistic Implementations (Atul Adya, 1999) — PDF 트랜잭션의 격리 수준(Isolation Level)에 대해 쉽고 이해하기 — mangkyu.tistory.com 트랜잭션의 격리 수준(Isolation Level) — chaewsscode.tistory.com ","wordCount":"6834","inLanguage":"en","image":"https://buenhyden.github.io/images","datePublished":"2025-09-12T03:46:00Z","dateModified":"2025-09-12T03:46:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/"},"publisher":{"@type":"Organization","name":"hyunyoun's Blog","logo":{"@type":"ImageObject","url":"https://buenhyden.github.io/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1 class="post-title entry-hint-parent">Read Committed</h1><div class=post-description>Read Committed은 트랜잭션이 커밋된 데이터만 읽도록 보장해 Dirty Read를 방지하는 표준 격리 수준이다. 다만 동일 트랜잭션 내 반복 조회에서 값이 달라지는 Non-Repeatable Read와 레코드 추가/삭제로 인한 Phantom은 허용한다. 구현은 락 기반과 MVCC 기반으로 달라지므로 적용 전 엔진 동작·재현 테스트·보완 패턴(재검증, FOR UPDATE, 상향 격리)을 설계해야 한다.</div><div class=post-meta><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/buenhyden/blog-data/main/content/posts/Data%20&%20Database%20Systems/Data%20Operations/Transaction%20Management/Transaction/Transaction%20Isolation/Transaction%20Isolation%20Levels/read-committed.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#read-committed>Read Committed</a><ul><li><a href=#read-committed-핵심-개념과-실무-적용>Read Committed 핵심 개념과 실무 적용</a></li><li><a href=#기초-조사-및-개념-정립>기초 조사 및 개념 정립</a></li><li><a href=#핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반</a></li><li><a href=#특성-분석-및-평가>특성 분석 및 평가</a></li><li><a href=#db-별-read-committed-동작-비교>DB 별 Read Committed 동작 비교</a></li><li><a href=#실무-적용-및-사례>실무 적용 및 사례</a></li></ul></li><li><a href=#최종-정리-및-학습-가이드>최종 정리 및 학습 가이드</a><ul><li><a href=#내용-종합>내용 종합</a></li><li><a href=#실무-적용-가이드>실무 적용 가이드</a></li><li><a href=#학습-로드맵>학습 로드맵</a></li><li><a href=#학습-항목-정리>학습 항목 정리</a></li></ul></li><li><a href=#용어-정리>용어 정리</a></li><li><a href=#참고-및-출처>참고 및 출처</a></li></ul></nav></div></details></div><div class=post-content><h2 id=read-committed>Read Committed<a hidden class=anchor aria-hidden=true href=#read-committed>#</a></h2><p>Read Committed(읽기 커밋) 는 실무에서 널리 쓰이는 기본 격리 수준으로, <strong>항상 커밋된 데이터만 읽게 해 Dirty Read 를 차단</strong>한다.<br>다만 트랜잭션 내 여러 문장은 서로 다른 시점의 커밋 상태를 볼 수 있어 <strong>Non-repeatable Read 와 Phantom</strong>이 발생할 수 있다.<br>내부 구현은 DB 마다 달라 (PostgreSQL/Oracle 은 MVCC 스냅샷 기반, SQL Server 는 기본 락 기반에 RCSI 옵션 존재) 동일 명칭이라도 동작이 다르므로 <strong>DB 별로 테스트·검증</strong>해야 한다.</p><p>일반 웹·OLTP 는 Read Committed 가 성능·정합성의 균형이지만, 회계·결제 등 강한 일관성이 필요한 도메인에서는 Repeatable Read 나 Serializable 을 사용하는 것이 추천된다.<br>운영 시 장기 트랜잭션 회피, 락 대기·데드락 모니터링, 읽기 풀 설계로 위험을 완화하는 것이 추천된다.</p><h3 id=read-committed-핵심-개념과-실무-적용>Read Committed 핵심 개념과 실무 적용<a hidden class=anchor aria-hidden=true href=#read-committed-핵심-개념과-실무-적용>#</a></h3><p>Read Committed 는 많은 상용 DB 에서 기본으로 쓰이는 격리 수준으로, **" 각 쿼리는 그 순간 커밋된 값만 본다 &ldquo;**는 규칙을 따른다.<br>이로써 **Dirty Read(미커밋 데이터 읽기)**는 차단되어 실무 데이터 신뢰성이 보장되지만, 같은 트랜잭션 내에서 반복 조회를 하면 값이 바뀔 수 있다 (Non-repeatable) 거나, 조건에 맞는 행 수가 달라질 수 있다 (Phantom).</p><p>성능과 정합성의 균형점으로 대부분 OLTP 에 적합하다.</p><table><thead><tr><th>핵심 개념 (한글, 약어)</th><th style=text-align:right>정의</th><th>실무적 중요성</th></tr></thead><tbody><tr><td>트랜잭션 (Transaction)</td><td style=text-align:right>원자적 작업 단위</td><td>실패/성공 일관성 보장 (비즈니스 불변식 보호)</td></tr><tr><td>격리 수준 (Isolation Level)</td><td style=text-align:right>트랜잭션 간 중간 상태 노출 규칙</td><td>성능·정합성 결정 요인</td></tr><tr><td>읽기 커밋 (Read Committed, RC)</td><td style=text-align:right>각 쿼리는 그 시점의 커밋된 값만 읽음</td><td>Dirty Read 차단, 대부분 OLTP 기본값</td></tr><tr><td>더티 리드 (Dirty Read)</td><td style=text-align:right>미커밋 값 읽기</td><td>심각한 데이터 오류 초래 가능</td></tr><tr><td>반복 불가 읽기 (Non-repeatable Read)</td><td style=text-align:right>동일 조회 반복 시 값 변경</td><td>일관된 리포트·계산에 문제</td></tr><tr><td>팬텀 (Phantom)</td><td style=text-align:right>같은 조건 재조회 시 행 집합 변화</td><td>집계·범위 쿼리에 영향</td></tr><tr><td>다중버전 동시성 (MVCC)</td><td style=text-align:right>스냅샷 버전으로 읽기 제공</td><td>읽기 비차단으로 성능 향상</td></tr><tr><td>락 (Shared/Exclusive Lock)</td><td style=text-align:right>동시 접근 제어 수단</td><td>강한 일관성 확보 (대가: 대기)</td></tr></tbody></table><p>RC 는 <strong>실용적 균형</strong>을 제공하므로 대부분의 OLTP 에서 기본이 된다.<br>핵심은 비즈니스 요구에 맞춰 " 어떤 이상현상을 허용할 것인가 " 를 명확히 하는 것.</p><h4 id=개념-상호관계-매핑표>개념 상호관계 매핑표<a hidden class=anchor aria-hidden=true href=#개념-상호관계-매핑표>#</a></h4><table><thead><tr><th>출발 → 도착</th><th style=text-align:right>방향성/의미</th><th>목적·효과</th></tr></thead><tbody><tr><td>격리 수준 ↑ → 허용 이상현상 ↓</td><td style=text-align:right>단방향</td><td>더 높은 격리로 데이터 정합성 향상 (대가: 성능↓)</td></tr><tr><td>MVCC → Dirty Read 차단</td><td style=text-align:right>구현 수단 → 결과</td><td>읽기 스냅샷으로 미커밋 노출 방지</td></tr><tr><td>락 (2PL) → Dirty Write/Read 방지</td><td style=text-align:right>구현 수단 → 결과</td><td>동시 쓰기 충돌 차단 (단, 대기/데드락 유발)</td></tr><tr><td>Statement snapshot → Read Committed 성격</td><td style=text-align:right>의미 해석</td><td>쿼리 단위로 최신 커밋값 반영</td></tr><tr><td>Transaction snapshot → Repeatable Read 성격</td><td style=text-align:right>의미 해석</td><td>트랜잭션 전체에서 동일 스냅샷 보장</td></tr></tbody></table><p>관계는 대부분 <strong>정책 (격리 수준) → 구현 (MVCC/락) → 결과 (허용/차단되는 이상현상)</strong> 구조로 이해하면 실무 설계에 적용하기 쉽다.</p><p><strong>관계 다이어그램</strong></p><pre class=mermaid>flowchart LR
  A[Client] --&gt;|SQL| T[Transaction]
  T --&gt;|READ| V[Visibility Rules]
  V --&gt;|MVCC Snapshot or S-Lock| D[(Data Pages)]
  T --&gt;|WRITE| L[Locking / Row Versions]
  L --&gt; D
  D --&gt;|Commit| C[Durability]
</pre><h4 id=핵심-개념의-실무-적용-매핑>핵심 개념의 실무 적용 매핑<a hidden class=anchor aria-hidden=true href=#핵심-개념의-실무-적용-매핑>#</a></h4><table><thead><tr><th>개념</th><th style=text-align:right>DB 에서 어떻게 구현되는가</th><th>실무에서 무엇을 의미하나 (이유)</th><th>운영시 고려사항</th></tr></thead><tbody><tr><td>Read Committed</td><td style=text-align:right>문장단위 스냅샷 (MVCC) 또는 락 기반</td><td>Dirty Read 방지, 반복불가 허용</td><td>트랜잭션 길이·장기 트랜잭션 주의</td></tr><tr><td>MVCC</td><td style=text-align:right>버전관리·Undo/Visibility 규칙</td><td>읽기 비차단, 낮은 지연</td><td>GC(vacuum)·스토리지 증가 관리</td></tr><tr><td>락</td><td style=text-align:right>S/X 락 (행·페이지)</td><td>강한 직렬성 보장 수단</td><td>데드락·대기 모니터링 필요</td></tr><tr><td>ORM 설정</td><td style=text-align:right>세션/트랜잭션 격리 레벨 지정</td><td>애플리케이션 레벨 정책 반영</td><td>세션 캐시·자동 커밋 영향 검사</td></tr><tr><td>모니터링 지표</td><td style=text-align:right>txn_duration, rollback_rate 등</td><td>RC 적용의 운영 위험 탐지</td><td>알람·SLO 설계 필요</td></tr></tbody></table><p>실무 적용은 **DB 특성 (엔진 별 동작)**과 **애플리케이션 프레임워크 (ORM)**의 조합으로 결정된다. 운영 시 장기 트랜잭션·GC·데드락·롤백률을 면밀히 관찰해야 한다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=read-committed개념실무-적용>Read Committed—개념·실무 적용<a hidden class=anchor aria-hidden=true href=#read-committed개념실무-적용>#</a></h4><ul><li><p><strong>무엇을 보장하나?</strong>:<br>한 SQL 문이 실행될 때 그 시점에 <em>커밋된</em> 값만 읽도록 보장한다.</p></li><li><p><strong>무엇을 막나?</strong>:<br>아직 커밋되지 않은 (임시) 값은 읽지 못하므로 Dirty Read 를 막는다.</p></li><li><p><strong>무엇이 남나?</strong>:<br>같은 트랜잭션에서 두 번 읽으면 값이 바뀔 수 있다 (다른 트랜잭션이 사이에 커밋했기 때문).</p></li><li><p><strong>언제 쓸까?</strong>:<br>대부분의 OLTP 에서 기본값으로 널리 사용—성능과 일관성의 현실적 절충.</p></li><li><p><strong>주의점</strong>:<br>장기 트랜잭션이나 다단계 검증이 필요한 로직 (예: 잔액 확인→결제) 에는 더 강한 격리 (또는 애플리케이션 레벨 보정) 가 필요.</p></li></ul><p>Read Committed(읽기 커밋) 는 각 SQL 문이 실행되는 시점의 <strong>커밋된 스냅샷</strong>을 읽도록 보장하는 격리 수준이다.<br>이는 트랜잭션 간의 Dirty Read 를 방지하여 기본적인 데이터 정합성을 확보하면서도, 문 수준에서 최신성을 확보하기 때문에 성능과 동시성 측면에서 합리적인 선택지다.<br>다만 트랜잭션 내에서 반복 조회 시 다른 트랜잭션의 커밋에 의해 값이 변할 수 있으므로 (Non-repeatable Read), 반복적 비교나 복합 검증을 요구하는 로직에는 Snapshot Isolation 혹은 Serializable 사용을 권장한다.<br>또한 DBMS 별 구현 (락 기반 vs MVCC, row-versioning 옵션) 에 따라 동작·성능이 달라지므로 적용 전 확인·테스트가 필요하다.</p><h4 id=read-committed-기원진화실무-포인트>Read Committed: 기원·진화·실무 포인트<a hidden class=anchor aria-hidden=true href=#read-committed-기원진화실무-포인트>#</a></h4><ul><li><p><strong>무엇인가?</strong><br>Read Committed 는 다른 트랜잭션이 아직 커밋하지 않은 변경 (미확정) 을 읽지 못하게 하여 Dirty Read 를 방지하는 격리 수준.</p></li><li><p><strong>왜 쓰나?</strong><br>락으로 인한 심한 대기 없이도 기본적인 일관성을 보장하려는 현실적 타협.</p></li><li><p><strong>무엇이 변했나?</strong><br>초기 락 기반 구현에서 MVCC 기반의 &rsquo; 쿼리 시점 스냅샷 &rsquo; 구현으로 발전하여 읽기 성능을 개선.</p></li></ul><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>복수 사용자가 동시에 데이터에 접근하는 환경에서 <strong>읽기 작업이 쓰기 작업의 잠금 때문에 지연되면 전체 처리량과 응답성이 저하</strong>된다.<br>실무에서 &rsquo; 어느 정도의 일관성은 유지하되 지나친 동시성 비용은 피하자 &rsquo; 는 요구가 커지자 SQL 표준과 DB 벤더들은 <strong>Dirty Read 를 차단하면서도 읽기 지연을 완화하는 Read Committed</strong>를 도입·보급했다.<br>이후 MVCC 의 도입으로 Read Committed 는 읽기 비차단 (스냅샷) 방식으로 개선되어 대다수 엔진에서 널리 쓰이게 되었다.</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>시기 (대략)</th><th>변화/이유</th><th>기술적 개선/결과</th></tr></thead><tbody><tr><td style=text-align:right>1970s–1980s</td><td>초기 RDBMS·락 기반 운영 → 읽기 지연 문제</td><td>약격리/락 전략으로 성능 - 정합성 타협 시도</td></tr><tr><td style=text-align:right>1992 (SQL-92)</td><td>격리 수준 표준화 필요</td><td>Read Uncommitted → Read Committed 등 표준화.</td></tr><tr><td style=text-align:right>1990s–2000s</td><td>MVCC 확산</td><td>Read Committed 가 스냅샷 기반으로 구현되어 읽기 비차단화 (예: Oracle/Postgres) (<a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html?utm_source=chatgpt.com" title="Data Concurrency and Consistency">Oracle Docs</a>)</td></tr><tr><td style=text-align:right>2000s 이후</td><td>엔진별 최적화·기본값 변화</td><td>MySQL/InnoDB·Postgres·Oracle 등 벤더별 기본·동작 차이 존재 (운영시 검증 필요). (<a href="https://dev.mysql.com/doc/refman/en/innodb-transaction-isolation-levels.html?utm_source=chatgpt.com" title="17.7.2.1 Transaction Isolation Levels">MySQL Developer Zone</a>)</td></tr></tbody></table><pre class=mermaid>gantt
  dateFormat  YYYY
  title Read Committed 발전 타임라인
  1970s-1980s :a1, 1975, 1989
  1992       :a2, 1992, 1992
  1995-2005  :a3, 1995, 2005
  2005-2025  :a4, 2005, 2025

  section 사건
  락기반 RDBMS와 성능문제         :a1, 1975, 1989
  SQL-92 격리 수준 표준화       :a2, 1992, 1992
  MVCC 보급 및 스냅샷 구현 확산  :a3, 1995, 2005
  벤더별 최적화·기본 설정 확립  :a4, 2005, 2025
</pre><p>Read Committed 는 &rsquo; 읽기 지연을 줄이되 Dirty Read 는 방지 &rsquo; 라는 목표로 등장했고, MVCC 의 보급으로 읽기 비차단 (스냅샷 기반) 형태로 진화했다.<br>오늘날 대부분의 DB 엔진은 Read Committed 를 지원하거나 그에 상응하는 동작을 제공하지만, <strong>엔진별 세부 동작과 기본값이 다르므로 적용 전 검증이 필수</strong>다.<br>운영 환경에서는 Read Committed 가 제공하는 일관성 범위 (커밋 시점 일관성) 를 이해하고, 재조회 시 값이 달라질 수 있음을 설계에 반영해야 한다.</p><h4 id=read-committed-실무적-문제목적-정리>Read Committed: 실무적 문제·목적 정리<a hidden class=anchor aria-hidden=true href=#read-committed-실무적-문제목적-정리>#</a></h4><p><code>Read Committed</code> 는 데이터베이스의 격리 수준 중 하나로, <strong>읽을 때 오직 이미 커밋된 데이터만 볼 수 있게 보장</strong>한다.<br>이것으로 미커밋 데이터 (Dirty data) 를 읽어 발생하는 잘못된 집계나 의사결정 문제를 막을 수 있다.<br>다만 트랜잭션 내에서 같은 쿼리를 다시 실행하면 결과가 달라질 수 있으니 (Non-repeatable read) 재현성 (동일 트랜잭션에서의 반복 일관성) 이 중요한 작업에는 더 강한 격리 수준을 선택해야 한다.<br>또한 DB 엔진별 구현 차이를 반드시 확인해야 한다 (예: PostgreSQL 의 특성).</p><h5 id=read-committed-이-해결하는-문제들>Read Committed 이 해결하는 문제들<a hidden class=anchor aria-hidden=true href=#read-committed-이-해결하는-문제들>#</a></h5><table><thead><tr><th>해결되는 문제</th><th>원인 (문제 발생 상황)</th><th>Read Committed 이 해결하는 방식</th></tr></thead><tbody><tr><td>Dirty Read(미커밋 데이터 노출)</td><td>트랜잭션 A 가 변경한 데이터를 트랜잭션 B 가 커밋 전 읽음</td><td>읽기 시 커밋 여부만 허용 → 미커밋 변경 필터링하여 노출 차단.</td></tr><tr><td>잘못된 리포트/집계 발생</td><td>미확정값을 기반으로 집계가 산출됨</td><td>집계 시점에 커밋된 값만 사용하도록 보장</td></tr><tr><td>운영 위험 (롤백 전파·오판단)</td><td>미커밋 값에 의존해 트랜잭션으로 의사결정</td><td>커밋된 데이터만 읽게 하여 의사결정 안정성 확보</td></tr></tbody></table><p>Read Committed 는 **미커밋 데이터 노출이 가져오는 직접적 위험들 (잘못된 집계, 의사결정, 롤백 후 불일치)**을 차단하는 데 집중한다. 이를 통해 운영 안정성을 높이되, 반복 읽기 일관성까지 보장하지는 않으므로 필요에 따라 더 높은 격리가 요구된다.</p><h5 id=read-committed-의-핵심-목적>Read Committed 의 핵심 목적<a hidden class=anchor aria-hidden=true href=#read-committed-의-핵심-목적>#</a></h5><table><thead><tr><th>핵심 목적</th><th>설명</th><th>기대 효과</th></tr></thead><tbody><tr><td>Dirty Read 방지</td><td>미커밋 변경을 다른 트랜잭션이 보지 못하게 함</td><td>잘못된 집계/오판단 방지, 안정적 운영</td></tr><tr><td>성능·동시성 균형</td><td>Serializable 보다 낮은 오버헤드로 동시성 확보</td><td>높은 처리량 유지, 경미한 일관성 손실 허용</td></tr><tr><td>운영 안전성 확보</td><td>실무 시스템의 실시간 안정성 확보</td><td>운영상 오류/롤백으로 인한 사이드이펙트 축소</td></tr></tbody></table><p>핵심 목적은 **정확성 (Dirty Read 방지)**과 <strong>성능 (동시성 확보)</strong> 사이의 실무적 절충을 제공하는 것이다. OLTP 에서 흔히 채택되는 이유는 _ 충분한 일관성 _ 을 보장하면서도 _ 높은 처리량 _ 을 잃지 않기 때문이다.</p><h5 id=문제와-목적의-연관성-맵>문제와 목적의 연관성 맵<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연관성-맵>#</a></h5><table><thead><tr><th>해결되는 문제</th><th>관련 핵심 목적</th><th>어떻게 목적 달성에 기여하는가</th></tr></thead><tbody><tr><td>Dirty Read 차단</td><td>Dirty Read 방지</td><td>읽기 가시성에서 미커밋을 배제하여 직접 차단</td></tr><tr><td>잘못된 집계 방지</td><td>운영 안전성 확보</td><td>결산·리포트의 신뢰도 향상</td></tr><tr><td>읽기 지연·동시성 문제</td><td>성능·동시성 균형</td><td>Dirty Read 차단하면서도 낮은 락 오버헤드로 동시성 유지</td></tr></tbody></table><p>각 문제는 Read Committed 가 제공하는 핵심 목적 (정확성 확보·운영 안정성·성능 균형) 과 직접적으로 연결된다. 즉, 문제 해결 (Dirty Read 차단) 은 곧 핵심 목적 (신뢰성 확보) 에 기여하며, 동시에 시스템은 더 높은 격리 수준 대비 성능을 유지한다. 다만 Non-repeatable/Phantom 같은 다른 이상현상은 별도 대책이 필요하다.</p><h4 id=격리-적용을-위한-필수-전제조건>격리 적용을 위한 필수 전제조건<a hidden class=anchor aria-hidden=true href=#격리-적용을-위한-필수-전제조건>#</a></h4><p>Read Committed 를 안전하게 쓰려면 네 가지가 준비되어야 한다.</p><ol><li>DB 가 커밋 상태를 판별할 수 있는 저장·버전 메커니즘 (undo/redo 또는 MVCC) 이 있어야 한다.</li><li>격리 수준을 세션 혹은 트랜잭션 단위로 설정할 수 있어야 해서 특정 쿼리만 RC 로 돌릴 수 있어야 한다.</li><li>인덱스·통계 등 튜닝이 되어야 불필요한 스캔으로 락이 오래 걸리는 문제를 줄일 수 있다.</li><li>운영 정책 (누가 변경 권한을 가지는지) 과 모니터링 (롱 트랜잭션·버전 bloat 감시) 을 갖춰야 안정적으로 운영할 수 있다.</li></ol><h5 id=read-committed-적용-필수요건표>Read Committed 적용 필수요건표<a hidden class=anchor aria-hidden=true href=#read-committed-적용-필수요건표>#</a></h5><table><thead><tr><th>항목</th><th>요구사항</th><th>실무 설명 / 근거</th></tr></thead><tbody><tr><td>저장·버전 메커니즘</td><td>undo/redo 로그 또는 MVCC 버전 저장소 필요</td><td>읽기 시 " 커밋된 버전 " 을 판별하려면 커밋 메타데이터 (LSN/commit ts) 또는 undo 체인 참조 필요</td></tr><tr><td>격리 설정 제어</td><td>기본값 + 세션/트랜잭션/쿼리 단위 변경 가능</td><td>특정 쿼리만 RC 로 적용해 리스크 국소화 가능 (<code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED</code>)</td></tr><tr><td>인덱스·통계</td><td>적절한 인덱스, 최신 통계 유지</td><td>스캔 범위 축소로 락 범위/버전 스캔 비용 감소, 성능·정합성 영향 완화</td></tr><tr><td>트랜잭션 길이 관리</td><td>짧은 트랜잭션 권장, 배치 청크 처리</td><td>긴 트랜잭션은 락 유지·MVCC bloat 유발 → 운영 리스크 증가</td></tr><tr><td>권한·변경 절차</td><td>격리 변경 권한·검증 절차 정의</td><td>임의 변경 방지, 변경 시 테스트·로그·롤백 절차 필요</td></tr><tr><td>모니터링·알림</td><td>lock wait, long tx, version bloat 지표 수집·알림</td><td>문제 조기 탐지·자동화된 대응 (runbook) 필요</td></tr><tr><td>엔진별 확인</td><td>DB 엔진의 RC 구현 방식 문서화</td><td>동일 표기라도 내부 동작 (락 vs 문장 스냅샷) 이 달라 적용 결과 차이 발생</td></tr></tbody></table><ul><li>Read Committed 를 안전하게 운영하려면 기술 (저장·버전), 설계 (트랜잭션 길이·인덱스), 그리고 운영 (권한·모니터링) 세 축이 모두 준비되어야 한다. 특히 엔진별 동작 차이는 실무 영향이 크므로 적용 전 엔진 문서 확인과 테스트 재현이 필수다.</li></ul><h4 id=read-committed-본질근거실무>Read Committed: 본질·근거·실무<a hidden class=anchor aria-hidden=true href=#read-committed-본질근거실무>#</a></h4><p>Read Committed 는 <strong>항상 커밋된 데이터만 읽는</strong> 격리 수준으로, Dirty Read 를 차단해 일상적 데이터 왜곡을 막는다.<br>그러나 각 SQL 문장은 그 시점의 최신 커밋 상태를 참조하므로 같은 트랜잭션 내에서 값이 달라질 수 있어 Non-repeatable Read 나 Phantom 이 발생할 수 있다.<br>많은 RDBMS 에서 기본값으로 사용되며, 성능과 일관성의 균형이 필요한 웹·OLTP 에서 적합하지만 회계·정산처럼 강한 일관성이 필요한 곳에서는 상위 격리를 선택해야 한다.<br>DB 별 구현 (MVCC vs 락 기반) 에 따라 동작 차이가 있으니 실제 환경에서 검증하는 것이 필요하다.</p><h5 id=read-committed-특징-정리표>Read Committed 특징 정리표<a hidden class=anchor aria-hidden=true href=#read-committed-특징-정리표>#</a></h5><table><thead><tr><th>특징</th><th>설명</th><th style=text-align:right>기술적 근거</th><th>타 수준 대비 차별점</th></tr></thead><tbody><tr><td>Dirty Read 금지</td><td>미커밋 값 노출 차단</td><td style=text-align:right>문장 단위 스냅샷 or 짧은 S-lock</td><td>RU 와 달리 더티 리드 차단</td></tr><tr><td>문장 단위 스냅샷 / 짧은 S-lock</td><td>각 문장은 최신 커밋값 참조</td><td style=text-align:right>MVCC 의 statement-snapshot / 락 유지 시간 최소화</td><td>Repeatable Read/Serializable 의 tx 전체 스냅샷과 다름</td></tr><tr><td>Non-repeatable / Phantom 허용</td><td>같은 트랜잭션 내 결과 변화 가능</td><td style=text-align:right>트랜잭션 전체 스냅샷 미고정</td><td>Serializable 에서 방지됨</td></tr><tr><td>성능·확장성 우수</td><td>락·버전 오버헤드 적음</td><td style=text-align:right>짧은 락 유지·경량 스냅샷</td><td>상위 격리보다 처리량 우수</td></tr><tr><td>DB 별 구현 차이</td><td>MVCC vs 락 기반 동작 차이</td><td style=text-align:right>PostgreSQL/Oracle vs SQL Server(RCSI 옵션)</td><td>동일 레벨이라도 동작·운영 차이 존재</td></tr></tbody></table><p>Read Committed 는 실무에서 가장 현실적인 균형점이다. 핵심은 Dirty Read 를 막으면서도 트랜잭션 내부 일관성 (Repeatability) 은 보장하지 않는다는 점이며, MVCC 와 락 기반 엔진 간 구현 차이가 실제 동작과 성능에 큰 영향을 준다. 따라서 기본값으로서 적합하지만, 민감 도메인은 상위 격리를 적용해야 한다.</p><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=read-committed-원칙철학-완전정리>Read Committed 원칙·철학 완전정리<a hidden class=anchor aria-hidden=true href=#read-committed-원칙철학-완전정리>#</a></h4><p>Read Committed 는 <strong>커밋된 데이터만 읽는다</strong>는 간단한 규칙을 따라 <strong>Dirty Read 를 차단</strong>하면서도, 각 SQL 문장 실행 시점의 최신 커밋 상태를 읽도록 하는 격리 수준이다.<br>즉, 트랜잭션 내에서 같은 쿼리를 반복하면 다른 트랜잭션의 커밋 때문에 결과가 달라질 수 있다 (Non-repeatable/Phantom 허용).<br>이 방식은 <strong>데이터 무결성은 확보하면서도 성능을 지나치게 희생하지 않는 실무적 균형</strong>을 제공하므로 대부분의 OLTP 에서 기본값으로 쓰인다.<br>적용 시에는 DB 엔진별 동작 차이를 이해하고, 범위·모니터링·검증 정책을 준비하는 것이 핵심이다.</p><h5 id=핵심-원칙-요약표>핵심 원칙 요약표<a hidden class=anchor aria-hidden=true href=#핵심-원칙-요약표>#</a></h5><table><thead><tr><th>핵심 원칙</th><th style=text-align:right>정의</th><th>목적 (무엇을 위해)</th><th>왜 필요한가 (이유)</th></tr></thead><tbody><tr><td>커밋된 것만 읽는다</td><td style=text-align:right>미커밋 변경 노출 금지</td><td>중간 상태 노출로 인한 오작동 방지</td><td>롤백될 수 있는 값으로 시스템이 잘못 동작하는 것을 방지</td></tr><tr><td>문장 단위 일관성</td><td style=text-align:right>각 SQL 문은 실행 시점의 커밋값을 참조</td><td>성능 저하 없이 최신 커밋 반영</td><td>트랜잭션 전체 스냅샷보다 경량화된 일관성 제공</td></tr></tbody></table><p>핵심 원칙은 **정확성 (Dirty Read 차단)**과 <strong>실용성 (문장 단위로 성능 보전)</strong> 사이의 균형을 직접 규정한다. 이 두 원칙이 RC 의 동작과 실무 장점을 설명한다.</p><h5 id=설계-철학-요약표>설계 철학 요약표<a hidden class=anchor aria-hidden=true href=#설계-철학-요약표>#</a></h5><table><thead><tr><th>설계 철학</th><th style=text-align:right>핵심 내용</th><th>목적 (무엇을 위해)</th><th>왜 필요한가 (이유)</th></tr></thead><tbody><tr><td>데이터 무결성 우선</td><td style=text-align:right>잘못된 데이터 노출 차단을 우선</td><td>핵심 도메인 신뢰성 확보</td><td>결제·재고 등 치명적 오류 방지</td></tr><tr><td>실용적 균형</td><td style=text-align:right>성능과 정합성의 현실적 타협</td><td>사용자 경험과 안정성 동시 확보</td><td>모든 트랜잭션에 최고 격리는 비용 과다</td></tr><tr><td>정책 기반 적용</td><td style=text-align:right>적용 범위·검증·모니터링으로 통제</td><td>오용 방지·운영 안전성 확보</td><td>설정 실수·확산으로 인한 사고 예방</td></tr></tbody></table><p>설계 철학은 RC 를 &rsquo; 왜 &rsquo; 선택하는지 (비즈니스 목표) 와 &rsquo; 어떻게 &rsquo; 적용할지 (운영 정책) 를 규정한다. 단순 기술 결정이 아니라 조직·운영 정책과 연결되는 의사결정 프레임워크를 제공하는 것이 핵심이다.</p><h4 id=read-committed-원리흐름도>Read Committed: 원리·흐름도<a hidden class=anchor aria-hidden=true href=#read-committed-원리흐름도>#</a></h4><ul><li><p><strong>문장 단위 스냅샷</strong>: Read Committed 는 각 SQL 문이 시작될 때 해당 문이 읽을 &rsquo; 커밋된 상태 스냅샷 &rsquo; 을 결정한다. 이는 MVCC 기반 DB 에서 주로 사용되는 방식이며, 읽으려는 시점에 커밋된 버전만 볼 수 있게 한다.</p></li><li><p><strong>가시성 규칙</strong>: 읽기 작업은 문 시작 시점의 commit flag 에 따라 버전을 선택한다. 따라서 다른 트랜잭션이 <strong>문 이후에</strong> 커밋한 변경은 다음 문에서 보이지만, 현재 문에서는 보이지 않는다.</p></li><li><p><strong>락 기반 예외</strong>: 일부 RDBMS(예: SQL Server 기본) 는 읽기 시 공유락을 잡아 쓰기 트랜잭션을 블로킹해 동일한 효과 (Dirty Read 차단) 를 달성한다. 이 경우는 블로킹과 성능 영향이 크다.</p></li><li><p><strong>Non-repeatable / Phantom 가능</strong>: 문 단위 스냅샷 때문에 트랜잭션 내 반복 조회 시 값이 달라질 수 있고 (Non-repeatable), 반복되는 집계범위가 바뀌어 Phantom 이 발생 가능.</p></li><li><p><strong>Undo/Redo 와 상호작용</strong>: MVCC 는 변경 전 값 (또는 이전 버전) 을 유지 (undo/version store) 해 문 시점의 결과를 재구성한다. Read Committed 가 " 로그가 없음 " 을 의미하지는 않음.</p></li><li><p><strong>실무 권장</strong>: 반복 읽기 불변이 필요한 경우 Snapshot Isolation 또는 Serializable 을 고려하고, 읽기 전용 복제본을 사용해 리포팅 부하를 분리하라.</p></li></ul><h5 id=read-committed-메커니즘-요약표>Read Committed 메커니즘 요약표<a hidden class=anchor aria-hidden=true href=#read-committed-메커니즘-요약표>#</a></h5><table><thead><tr><th>메커니즘</th><th style=text-align:right>무슨 일인가</th><th>영향 (특성)</th><th>실무 메모</th></tr></thead><tbody><tr><td>문장 시점 스냅샷 생성</td><td style=text-align:right>각 SQL 문 시작 시 읽을 커밋 상태 결정</td><td>그 문은 그 시점의 커밋된 값만 본다</td><td>긴 문은 오래된 스냅샷 기준으로 읽음</td></tr><tr><td>Dirty Read 차단</td><td style=text-align:right>커밋되지 않은 변경은 보이지 않음</td><td>데이터 무결성 향상</td><td>Dirty Read 위험 제거</td></tr><tr><td>Non-repeatable 가능</td><td style=text-align:right>같은 트랜잭션 내 후속 문이 다른 결과를 볼 수 있음</td><td>트랜잭션 내 일관성 불완전</td><td>필요한 경우 SI/Serializable 권장</td></tr><tr><td>MVCC(undo/version) 사용</td><td style=text-align:right>이전 버전으로 문 시점 값 재구성</td><td>읽기 블로킹 최소화</td><td>버전 보관 비용 존재</td></tr><tr><td>락 기반 (예: SQL Server 기본)</td><td style=text-align:right>읽기 시 공유락 획득 → 쓰기와 충돌 시 블로킹</td><td>블로킹 가능성 ↑</td><td>RCSI 옵션으로 버전 기반 전환 가능</td></tr><tr><td>SELECT FOR UPDATE</td><td style=text-align:right>강제 락 획득 → 다른 트랜잭션 차단</td><td>행 수준 일관성 확보</td><td>잠금으로 동시성 저하 가능</td></tr></tbody></table><p>Read Committed 는 <strong>문장 단위의 일관성 강화를 통해 Dirty Read 를 차단</strong>하면서도 시스템에 따라 <strong>버전 (Non-blocking)</strong> 또는 <strong>락 (블로킹)</strong> 기반으로 동작한다. 결과적으로 속도와 정합성의 균형을 제공하지만 트랜잭션 내부 반복 읽기에서의 값 변화 (Non-repeatable) 와 팬텀을 허용하므로, 필요한 경우 더 강한 격리로 보완해야 한다.</p><h5 id=read-committed-동작-흐름도-분기>Read Committed 동작 흐름도 (분기)<a hidden class=anchor aria-hidden=true href=#read-committed-동작-흐름도-분기>#</a></h5><pre class=mermaid>sequenceDiagram
  participant T1 as &#34;T1 (Writer)&#34;
  participant DB as &#34;DB Engine&#34;
  participant T2 as &#34;T2 (Reader)&#34;

  T1-&gt;&gt;DB: BEGIN
  T1-&gt;&gt;DB: UPDATE item SET stock = 0 WHERE id = 1
  Note over DB: 변경 생성 → 버퍼/undo 버전 생성

  alt DB uses MVCC (versioning)
    T2-&gt;&gt;DB: BEGIN
    T2-&gt;&gt;DB: SELECT …  // 문 시작 시 스냅샷 생성
    Note over DB: statement-level read view(문 시점의 커밋된 버전)
    DB--&gt;&gt;T2: 반환값 = (이전 커밋값)
    T1-&gt;&gt;DB: COMMIT
    Note over DB: 변경이 커밋되어 이후 문에서 보임
  else DB uses Lock-based (shared locks)
    T2-&gt;&gt;DB: BEGIN
    T2-&gt;&gt;DB: SELECT …  // 공유락 시도
    Note over DB: SELECT는 shared lock 획득 시도 → Writer의 X-lock이 있으면 블로킹
    DB--&gt;&gt;T2: (blocked until Writer COMMIT/ROLLBACK)
    T1-&gt;&gt;DB: COMMIT
    DB--&gt;&gt;T2: shared lock granted → SELECT returns committed value
  end
</pre><ul><li><p>MVCC 는 <strong>문 시작 시 스냅샷 생성 → 그 스냅샷에 따라 값 반환</strong>하는 흐름이며, 이 경우 Reader 는 Writer 의 미커밋 변경을 보지 못한다. Writer 가 COMMIT 하면 그 변경은 다음 문에서 보이게 된다.</p></li><li><p>락 기반는 Reader 의 SELECT 가 공유락을 획득하려 할 때 Writer 가 이미 배타적 락을 가진 상황이면 <strong>Reader 가 블로킹</strong>되어 Writer 가 COMMIT/ROLLBACK 할 때까지 대기한다. 이로 인해 Dirty Read 는 방지되지만 블로킹과 성능 저하가 발생할 수 있다.</p></li><li><p>이 흐름은 DB 종류와 설정 (RCSI 등) 에 따라 달라지므로, 운영 환경에 맞춰 분기 중 해당 케이스를 선택해 이해해야 한다.</p></li></ul><h4 id=read-committed-흐름생명주기실무포인트>Read Committed: 흐름·생명주기·실무포인트<a hidden class=anchor aria-hidden=true href=#read-committed-흐름생명주기실무포인트>#</a></h4><ul><li>트랜잭션을 시작한 후 <code>SELECT</code> 할 때마다 DB 는 <strong>그 순간 커밋된 최신값</strong>을 보여준다.</li><li>만약 다른 트랜잭션이 중간에 값을 바꾸고 커밋하면, <strong>다음 <code>SELECT</code> 에서</strong> 그 변경이 보인다.</li><li>장점: Dirty Read 차단, 높은 동시성.</li><li>단점: 같은 트랜잭션 내에서 값이 바뀔 수 있으니 재조회할 때 주의해야 함.</li></ul><h5 id=rc-의-문단위-가시성-설명>RC 의 문단위 가시성 설명<a hidden class=anchor aria-hidden=true href=#rc-의-문단위-가시성-설명>#</a></h5><p><strong>핵심 흐름 (문장 단위)</strong></p><ol><li>문 시작 → DB 는 그 문에 대한 **가시성 기준 (스냅샷 또는 락 판정)**을 확보.</li><li>읽기 수행 → <strong>커밋된 버전</strong>만 스캔하여 결과 반환 (미커밋 변경은 숨김).</li><li>문 종료 → 해당 문 단위의 스냅샷 폐기 또는 공유 락 해제.</li><li>트랜잭션이 계속되는 동안 <strong>다음 문은 새 가시성 기준으로 다시 평가</strong>되므로 이전 문에서 보지 못한 커밋이 이후 문에서 보일 수 있다.</li></ol><h5 id=read-committed-데이터-흐름표>Read Committed 데이터 흐름표<a hidden class=anchor aria-hidden=true href=#read-committed-데이터-흐름표>#</a></h5><table><thead><tr><th style=text-align:right>단계</th><th>주체</th><th>동작</th><th>가시성 규칙</th><th>비고</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>트랜잭션 시작</td><td>트랜잭션 활성화</td><td>—</td><td>트랜잭션 컨텍스트 생성</td></tr><tr><td style=text-align:right>2</td><td>문 (statement) 시작</td><td>스냅샷 획득 또는 락 판정</td><td><strong>그 문 시점의 커밋 값만</strong></td><td>엔진별 스냅샷/락 방식 다름</td></tr><tr><td style=text-align:right>3</td><td>읽기 수행</td><td>SELECT 실행</td><td>커밋된 버전 스캔</td><td>미커밋 값은 보이지 않음</td></tr><tr><td style=text-align:right>4</td><td>문 종료</td><td>스냅샷 폐기 / 락 해제</td><td>—</td><td>다음 문은 새 기준으로 평가</td></tr><tr><td style=text-align:right>5</td><td>트랜잭션 계속/종료</td><td>추가 문 실행 또는 COMMIT/ROLLBACK</td><td>각 문마다 가시성 재평가</td><td>동일 트랜잭션 내 재조회 값 변경 가능</td></tr></tbody></table><p>표는 RC 의 핵심: <strong>각 문은 그 문이 시작될 때의 커밋 상태만 본다</strong>는 점을 단계별로 정리한 것이다. 적용 시 엔진별 구현 (락 기반 vs MVCC statement-snapshot) 을 확인하고, 같은 트랜잭션 내 재조회 불일치에 대해 애플리케이션 레벨에서 대비하라.</p><h5 id=rc-문단위-가시성-흐름도>RC 문단위 가시성 흐름도<a hidden class=anchor aria-hidden=true href=#rc-문단위-가시성-흐름도>#</a></h5><pre class=mermaid>flowchart LR
  Start[트랜잭션 시작] --&gt; S1[문1 시작: 스냅샷/락 획득]
  S1 --&gt; Q1[문1: SELECT -&gt; 커밋된 값 반환]
  Q1 --&gt; End1[문1 종료: 스냅샷 폐기/락 해제]
  End1 --&gt; S2[문2 시작: 새 스냅샷/락 판정]
  S2 --&gt; Q2{다른 트랜잭션이 커밋했나?}
  Q2 -- 아니오 --&gt; Q2a[문2: 이전 값 반환]
  Q2 -- 예 --&gt; Q2b[문2: 커밋된 새 값 반환]
  Q2a &amp; Q2b --&gt; End2[문2 종료]
  End2 --&gt; Continue[트랜잭션 계속/종료]
</pre><p>이 흐름도는 한 트랜잭션 내에서 각 문 (statement) 이 시작될 때마다 <strong>새 가시성 판단</strong>을 거쳐 커밋된 값을 읽는다는 RC 의 핵심을 시각화한다. 다른 트랜잭션이 중간에 커밋하면 다음 문에서 그 변경이 보이며, 그렇지 않으면 이전 값이 유지된다.</p><h5 id=rc-트랜잭션-생명주기>RC 트랜잭션 생명주기<a hidden class=anchor aria-hidden=true href=#rc-트랜잭션-생명주기>#</a></h5><pre class=mermaid>stateDiagram-v2
    [*] --&gt; Active: 트랜잭션 시작
    Active --&gt; Statement: 문 시작 (스냅샷/락 획득)
    Statement --&gt; Read: SELECT 수행 (커밋 버전 스캔)
    Read --&gt; EndStatement: 문 종료 (스냅샷 폐기/락 해제)
    EndStatement --&gt; Decision: 트랜잭션 계속?
    Decision --&gt; Statement: 문 시작
    Decision --&gt; Commit: COMMIT
    Decision --&gt; Rollback: ROLLBACK
    Commit --&gt; [*]
    Rollback --&gt; [*]
</pre><p>이 상태도는 트랜잭션이 <strong>문 (statement) 을 시작 → 읽기 수행 → 문 종료</strong> 패턴을 반복하다가 최종적으로 COMMIT/ROLLBACK 으로 종료되는 생명주기를 보여준다. RC 에서는 각 문이 독립적으로 가시성을 평가하므로 동일 트랜잭션 내에서도 문마다 다른 커밋 상태를 반영할 수 있다.</p><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=read-committed-장점실무적-가치>Read Committed: 장점·실무적 가치<a hidden class=anchor aria-hidden=true href=#read-committed-장점실무적-가치>#</a></h4><p>Read Committed 는 <strong>읽을 때마다 &rsquo; 확정된 &lsquo;(커밋된) 데이터만 보여줘서</strong> 잘못된 (미확정) 값을 읽는 위험을 없애고, 동시에 읽기 작업을 차단하지 않아 많은 사용자가 동시에 조회할 때 처리량을 높여준다.<br>즉, &rsquo; 데이터 신뢰성 (Dirty Read 차단)&rsquo; 과 &rsquo; 실무적 성능 (높은 동시성)&rsquo; 사이에서 균형을 맞춘 현실적 선택이다.<br>하지만 동일 트랜잭션 내에서 값이 바뀔 수 있으니 (재조회 불일치) 중요 연산에는 적절한 보완이 필요하다.</p><h5 id=read-committed-장점-요약표>Read Committed 장점 요약표<a hidden class=anchor aria-hidden=true href=#read-committed-장점-요약표>#</a></h5><table><thead><tr><th>장점</th><th>기술적 근거</th><th>기대되는 실무 효과</th></tr></thead><tbody><tr><td>Dirty Read 차단</td><td>문 (statement) 시점의 커밋된 버전만 가시화 (MVCC 스냅샷 또는 S-lock)</td><td>잘못된 데이터 기반 처리 방지 → 데이터 신뢰성 유지</td></tr><tr><td>높은 동시성</td><td>읽기 비차단 (짧은 락/스냅샷) 으로 읽기 병렬화</td><td>TPS·동시 사용자 수 증가, 응답시간 개선</td></tr><tr><td>예측 가능한 성능</td><td>강격리에서 발생하는 직렬화/재시도 오버헤드 회피</td><td>성능 변동성 감소 → 안정적 SLA 수립 용이</td></tr><tr><td>구현·운영 용이성</td><td>대부분 DB 에서 기본값 또는 간단 설정</td><td>도입·운영 비용 절감, 마이그레이션 편의성</td></tr></tbody></table><p>표는 RC 가 <strong>어떤 기술 메커니즘</strong>(MVCC/락) 으로 동작하는지와, 그 결과로 **운영에서 어떤 개선 (신뢰도·처리량·예측 가능성·도입 용이성)**을 기대할 수 있는지를 요약한다. 현실적으로는 워크로드 특성 (읽기 비율, 트랜잭션 길이, 핫스팟 유무) 에 따라 효과의 크기가 달라지므로, 실제 적용 전 성능 측정과 재조회 불일치 (Non-repeatable Read) 에 대한 애플리케이션 보호 방안 (재검증·낙관적 재시도 등) 을 준비해야 한다.</p><h4 id=read-committed-의-한계운영-대비체계>Read Committed 의 한계·운영 대비체계<a hidden class=anchor aria-hidden=true href=#read-committed-의-한계운영-대비체계>#</a></h4><p>Read Committed 는 <strong>미커밋 데이터 (Dirty Read) 를 차단</strong>해 일상적인 OLTP 에서 안정적인 읽기를 제공한다.<br>다만 트랜잭션 전체의 재현성 (같은 트랜잭션 내에서 여러 번 읽었을 때 항상 같은 결과) 은 보장하지 못한다 (Non-Repeatable, Phantom). 따라서 <strong>보고·회계처럼 재현성이 필수인 작업</strong>은 더 강한 격리 수준이나 스냅샷 기반 리포트로 분리해야 한다.<br>실무에서는 <strong>문제 범위를 좁히고 (테이블·쿼리 화이트리스트), DB 별 동작을 테스트 후</strong> 적절한 완화책을 적용하는 것이 안전한 접근 방식이다.</p><h5 id=read-committed-단점-개요표>Read Committed 단점 개요표<a hidden class=anchor aria-hidden=true href=#read-committed-단점-개요표>#</a></h5><table><thead><tr><th>단점</th><th>핵심 영향</th><th>핵심 완화책</th></tr></thead><tbody><tr><td>Non-Repeatable Read</td><td>트랜잭션 내 반복 읽기 결과 불일치 (재현 불가)</td><td>Repeatable Read/Snapshot, 트랜잭션 축소</td></tr><tr><td>Phantom Read</td><td>범위 질의 결과의 변화 (행 추가/삭제)</td><td>Serializable/범위 락 또는 Predicate Locking</td></tr><tr><td>쓰기 충돌 증가</td><td>락 경합·데드락·타임아웃 가능</td><td>MVCC, 짧은 TX, 재시도 로직</td></tr></tbody></table><p>단점들은 RC 자체의 설계 한계에서 비롯된다. 운영상 영향은 **재현성 결여 (회계/감사 위험)**와 **범위 질의 불안정 (집계/페이징 문제)**이며, 해결책은 필요 수준에 맞춰 <strong>격리 수준 상향 또는 아키텍처 (리플리카/스냅샷) 분리</strong>로 보통 처리한다.</p><h5 id=read-committed-제약사항-개요표>Read Committed 제약사항 개요표<a hidden class=anchor aria-hidden=true href=#read-committed-제약사항-개요표>#</a></h5><table><thead><tr><th>제약사항</th><th>핵심 현상</th><th>권장 대응</th></tr></thead><tbody><tr><td>시점 일관성 한계</td><td>트랜잭션 전체 스냅샷이 없음</td><td>중요한 계산은 상위 격리로 처리</td></tr><tr><td>보고 정확도 요구 불일치</td><td>규제·회계 리포트 부적합</td><td>OLAP/리플리카 기반 리포트</td></tr><tr><td>DB 별 구현 차이</td><td>동일 명세라도 엔진별 행위 상이</td><td>배포 전 DB 별 테스트·문서화</td></tr></tbody></table><p>제약사항은 환경·정책·엔진 특성에서 발생하므로 <strong>시스템 설계 단계에서 요구사항 (정확성·성능·규제) 을 바탕으로 격리 수준 정책을 수립</strong>하고, DB 별 특성을 반영한 운영 매뉴얼을 만들어야 한다.</p><h4 id=rc-트레이드오프혼합-전략-안내>RC 트레이드오프·혼합 전략 안내<a hidden class=anchor aria-hidden=true href=#rc-트레이드오프혼합-전략-안내>#</a></h4><p>Read Committed 는 " 커밋된 데이터만 읽게 해서 더티 리드는 막지만, 같은 트랜잭션에서 반복해서 읽을 때 값이 바뀔 수는 있는 " 중간 수준의 격리다.<br>장점은 빠른 응답과 높은 동시성, 단점은 일부 일관성 문제가 남는 것이다.<br>실무에서는 중요한 결정 (결제·정산) 경로엔 더 높은 격리를 쓰고, 대시보드·로그처럼 정확도가 덜 중요한 읽기에는 RC 를 적용하는 식으로 균형을 맞춘다.</p><h5 id=read-committed-주요-선택별-트레이드오프>Read Committed 주요 선택별 트레이드오프<a hidden class=anchor aria-hidden=true href=#read-committed-주요-선택별-트레이드오프>#</a></h5><table><thead><tr><th>비교 쌍</th><th>선택</th><th>장점</th><th>단점</th><th>고려 기준</th></tr></thead><tbody><tr><td>일관성 vs 성능</td><td>Serializable</td><td>완전한 일관성, 이상현상 차단</td><td>높은 지연·낮은 처리량</td><td>금전·회계·법적 요구</td></tr><tr><td></td><td>Read Committed</td><td>낮은 지연, 높은 동시성</td><td>Non-repeatable/Phantom 허용</td><td>대시보드·로그·근사치 허용 영역</td></tr><tr><td>락 vs MVCC</td><td>락 기반</td><td>직접 제어·예측 용이</td><td>데드락·대기</td><td>짧은 트랜잭션·소규모 동시성</td></tr><tr><td></td><td>MVCC</td><td>읽기 비차단, 높은 읽기 처리량</td><td>버전 bloat·정리 비용</td><td>읽기 중심 워크로드</td></tr><tr><td>Replica vs Master read</td><td>Replica+Recheck</td><td>읽기 분산, 낮은 응답</td><td>지연 (staleness)·재검증 필요</td><td>보고·비결정적 조회</td></tr><tr><td></td><td>Master</td><td>즉시 일관성</td><td>마스터 부하 증가</td><td>결정적 조치 필요 경로</td></tr></tbody></table><ul><li>핵심은 <strong>비즈니스 민감도</strong>(금전/상태 변경 여부) 와 <strong>성능 목표 (p95/p99)</strong> 를 기준으로 선택하는 것.</li><li>대부분 시스템은 전역 한가지만 택하지 않고 <strong>핵심 경로는 상향 격리, 나머지는 RC/Replica 기반</strong>으로 하이브리드 운영한다.</li></ul><h5 id=rc-완화용-하이브리드-패턴-비교표>RC 완화용 하이브리드 패턴 비교표<a hidden class=anchor aria-hidden=true href=#rc-완화용-하이브리드-패턴-비교표>#</a></h5><table><thead><tr><th>패턴</th><th>구성요소</th><th style=text-align:right>적용목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>Selective Elevation</td><td>정책 매핑, RBAC</td><td style=text-align:right>핵심경로 강일관성 확보</td><td>전체 성능 유지</td><td>경로 식별·테스트 필요</td></tr><tr><td>Replica + Recheck</td><td>비동기 복제, 재검증</td><td style=text-align:right>읽기 오프로드 + 결정 신뢰성</td><td>읽기 성능↑, 결정 시 안전</td><td>재검증 비용·복제 지연</td></tr><tr><td>OCC + Retry</td><td>버전태그·재시도 로직</td><td style=text-align:right>락 회피, 높은 동시성</td><td>낮은 락 오버헤드</td><td>충돌률 관리·idempotency</td></tr><tr><td>Snapshot + Verify</td><td>스냅샷 읽기, 재조회</td><td style=text-align:right>빠른 조회 + 결정 신뢰</td><td>UX 유지 + 안전성 강화</td><td>추가 쿼리 비용</td></tr><tr><td>Escrow/Quota</td><td>토큰/쿼터 저장소</td><td style=text-align:right>자원 분할으로 충돌 완화</td><td>충돌 최소화</td><td>설계·수송 복잡</td></tr><tr><td>Materialized View</td><td>뷰 + refresh 정책</td><td style=text-align:right>집계/리포트 성능 확보</td><td>대시보드 성능 극대화</td><td>신선도·갱신 비용</td></tr></tbody></table><ul><li>하이브리드 패턴들은 <strong>RC 의 성능 장점은 살리고 결정적 경로의 일관성은 보장</strong>하도록 설계된 현실적 방법들이다.</li><li>선택은 <strong>비즈니스 위험도, 허용 가능한 지연 (신선도), 개발·운영 복잡도</strong>를 저울질해 결정해야 한다.</li></ul><h4 id=read-committed-적용성운영-전략>Read Committed 적용성·운영 전략<a hidden class=anchor aria-hidden=true href=#read-committed-적용성운영-전략>#</a></h4><p>Read Committed 는 <strong>항상 커밋된 데이터만 읽어 Dirty Read 를 방지</strong>하면서도, 트랜잭션 내부 여러 문장 사이의 값 일관성은 보장하지 않는다.<br>그래서 웹 UI 조회·OLTP 처럼 <strong>성능과 합리적 정합성의 균형</strong>이 필요한 곳에 적합하다. 반면 회계·정산·재고처럼 같은 트랜잭션 내 반복 읽기 일관성이 필수인 도메인엔 부적합하다.<br>실무에서는 읽기 전용 풀, CQRS, 결과 재검증, 모니터링·자동격상 같은 설계·운영 가드레일을 결합해 리스크를 관리한다.</p><h5 id=read-committed-적용-적합성-표>Read Committed 적용 적합성 표<a hidden class=anchor aria-hidden=true href=#read-committed-적용-적합성-표>#</a></h5><table><thead><tr><th>시나리오 / 도메인</th><th style=text-align:right>적합성</th><th>설계 관점 판단</th><th style=text-align:right>분석 (측정) 포인트</th><th style=text-align:right>운영 권장 대책</th><th>권장 대안 (부적합 시)</th></tr></thead><tbody><tr><td>UI 조회 (제품 상세, 리스트)</td><td style=text-align:right>적합</td><td>짧은 단건 쿼리, 리드리플리카 활용</td><td style=text-align:right>응답지연, stale-read 비율</td><td style=text-align:right>리플리카 라우팅·staleness 표시</td><td>(필요시) 마스터 조회</td></tr><tr><td>일반 OLTP(주문 조회)</td><td style=text-align:right>보통 적합</td><td>주문 조회는 적합, 다단계 정산은 비적합</td><td style=text-align:right>재시도율·deadlock rate</td><td style=text-align:right>읽기 풀 분리·검증 로직</td><td>트랜잭션 격상 일부 단계</td></tr><tr><td>로그 집계 / 분석 (근사치)</td><td style=text-align:right>적합</td><td>높은 처리량 우선</td><td style=text-align:right>throughput, accuracy gap</td><td style=text-align:right>주기적 재집계·샘플검증</td><td>배치 ETL</td></tr><tr><td>이벤트 소싱 읽기 모델</td><td style=text-align:right>적합</td><td>프로젝션 읽기 용이</td><td style=text-align:right>projection lag</td><td style=text-align:right>projection 재빌드 자동화</td><td>N/A</td></tr><tr><td>재무 결제 / 정산</td><td style=text-align:right>부적합</td><td>동일 tx 반복 읽기 필수</td><td style=text-align:right>계산 불일치, rollback 빈도</td><td style=text-align:right>사용 금지 (정책 차단)</td><td>Repeatable Read / Serializable</td></tr><tr><td>재고 재할당 (동시성 민감)</td><td style=text-align:right>부적합 (주의)</td><td>충돌 가능성 높음</td><td style=text-align:right>오더 컨플릭트 비율</td><td style=text-align:right>유니크 제약, 분산 락, 격상</td><td>Serializable / 분산 토큰</td></tr></tbody></table><ul><li>Read Committed 는 <strong>UI·일반 OLTP·로그/프로젝션 등 대다수 읽기 시나리오에 적합</strong>하지만, <strong>금융/정산/재고 같은 동일 트랜잭션 반복 읽기</strong>가 요구되는 도메인에는 부적합하다.</li><li>적용 시엔 **설계 (읽기 풀/CQRS), 분석 (성능·일관성 지표 측정), 운영 (모니터링·자동격상)**의 삼중 방어선으로 리스크를 관리하라.</li></ul><h3 id=db-별-read-committed-동작-비교>DB 별 Read Committed 동작 비교<a hidden class=anchor aria-hidden=true href=#db-별-read-committed-동작-비교>#</a></h3><ul><li><strong>모두 Dirty Read 는 차단</strong>한다.</li><li><strong>차이점은 &rsquo; 어떻게 &rsquo; 차단하는지 (락 vs 버전관리)</strong> 와 <strong>성능·블로킹 특성</strong>:<ul><li>Postgres / Oracle / MySQL(RC) → MVCC/문 수준 스냅샷 (읽기 블로킹 거의 없음, 같은 트랜잭션 내 Non-repeatable 발생).</li><li>SQL Server 기본 RC → <strong>락 기반 (읽기 시 공유락)</strong> 으로 쓰기와 충돌 시 블로킹 발생; RCSI 켜면 row-versioning 동작으로 블로킹 완화.</li></ul></li></ul><table><thead><tr><th>DB</th><th>Read Committed 구현 방식 (요지)</th><th style=text-align:right>Dirty Read</th><th style=text-align:right>Non-repeatable / Phantom</th><th>설정 방식 (세션/DB)</th><th>실무 포인트</th></tr></thead><tbody><tr><td>PostgreSQL</td><td><strong>기본값 = Read Committed</strong>, MVCC 기반 → <strong>문 (statement) 시점의 스냅샷</strong>을 읽음</td><td style=text-align:right>차단</td><td style=text-align:right>가능 (문 수준 스냅샷이므로 같은 트랜잭션 내 후속 SELECT 는 다른 트랜잭션 커밋을 볼 수 있음)</td><td><code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code> (세션/트랜잭션)</td><td>MVCC 라서 읽기 블로킹 없음. RU 와 혼동하지 말 것.</td></tr><tr><td>MySQL (InnoDB)</td><td>기본값은 <strong>REPEATABLE READ</strong>(InnoDB). <strong>RC</strong>로 세션/트랜잭션 변경 가능. InnoDB 의 RC 는 <strong>statement-level MVCC</strong>(각 문은 최신 커밋 버전 참조)</td><td style=text-align:right>차단</td><td style=text-align:right>가능 (RC 로 설정하면 문 수준 동작)</td><td><code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></td><td>기본이 RR 임을 유의. RC 로 변경 시 동작·성능 차이 테스트 필수.</td></tr><tr><td>SQL Server (MSSQL)</td><td>기본 Read Committed 는 <strong>락 기반 (읽기 시 공유락)</strong> → 읽기 - 쓰기 블로킹 발생. <strong>READ_COMMITTED_SNAPSHOT (RCSI)</strong> ON 시에는 <strong>row-versioning</strong>(statement-level snapshot) 으로 동작</td><td style=text-align:right>차단</td><td style=text-align:right>가능 (락 기반이면 블로킹, RCSI 면 문 수준 스냅샷으로 Non-repeatable 발생)</td><td><code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</code> DB 레벨: <code>ALTER DATABASE … SET READ_COMMITTED_SNAPSHOT ON;</code></td><td>운영 DB 에서 RCSI 전환은 주의 (데이터베이스 설정 영향). 블로킹 특성 이해해야 함.</td></tr><tr><td>Oracle</td><td>기본값 <strong>READ COMMITTED</strong>, <strong>undo 기반의 read-consistency</strong>로 <strong>각 SQL 문은 그 문 시작 시점의 스냅샷</strong>을 읽음 (MVCC 유사)</td><td style=text-align:right>차단</td><td style=text-align:right>가능 (문 수준 스냅샷)</td><td><code>ALTER SESSION SET ISOLATION_LEVEL = READ COMMITTED;</code> (세션)</td><td>Oracle 은 항상 statement consistency 유지. Flashback/Undo 이해 필요.</td></tr></tbody></table><h4 id=postgresql-psql재현-스크립트>PostgreSQL (psql)—재현 스크립트<a hidden class=anchor aria-hidden=true href=#postgresql-psql재현-스크립트>#</a></h4><h5 id=준비-한-번만>준비 (한 번만)<a hidden class=anchor aria-hidden=true href=#준비-한-번만>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1>1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2>2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3>3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4>4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- psql로 접속 후
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>serial</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=nb>int</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>item</span><span class=p>(</span><span class=n>stock</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 확인
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=시나리오-1-dirty-read-방지-t1-writer-t2-reader>시나리오 1: Dirty Read 방지 (T1: Writer, T2: Reader)<a hidden class=anchor aria-hidden=true href=#시나리오-1-dirty-read-방지-t1-writer-t2-reader>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 아직 COMMIT 하지 않음
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 기본이 Read Committed인 경우
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 결과: 10 (원래 커밋된 값) -&gt; Dirty Read가 발생하지 않음
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=시나리오-2-non-repeatable-read-t1-가-두-번-읽는-케이스>시나리오 2: Non-repeatable Read (T1 가 두 번 읽는 케이스)<a hidden class=anchor aria-hidden=true href=#시나리오-2-non-repeatable-read-t1-가-두-번-읽는-케이스>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>  </span><span class=c1>-- A1: 10
</span></span></span><span class=line><span class=cl><span class=c1>-- **다른 세션에서 커밋된 변경이 발생하면**
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>  </span><span class=c1>-- A2: 5  (값 변경 확인 -&gt; Non-repeatable Read)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=시나리오-3-phantom-read-간단>시나리오 3: Phantom Read (간단)<a hidden class=anchor aria-hidden=true href=#시나리오-3-phantom-read-간단>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>  </span><span class=c1>-- e.g., 1
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>item</span><span class=p>(</span><span class=n>stock</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 값 증가 -&gt; Phantom 발생 가능
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>메모: PostgreSQL 은 MVCC 로 동작하므로 Read Committed 의 의미는 " 문장 시점의 커밋된 스냅샷 " 을 보는 것. 위 결과는 그 의미에 부합함.</p></blockquote><h4 id=mysql-innodb재현-스크립트>MySQL (InnoDB)—재현 스크립트<a hidden class=anchor aria-hidden=true href=#mysql-innodb재현-스크립트>#</a></h4><blockquote><p><strong>참고</strong>: MySQL(InnoDB) 기본 격리 수준은 <code>REPEATABLE READ</code>. Read Committed 로 테스트하려면 <strong>세션</strong> 또는 <strong>글로벌</strong> 격리 수준을 변경해야 한다.</p></blockquote><h5 id=준비>준비<a hidden class=anchor aria-hidden=true href=#준비>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- mysql 클라이언트 접속
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=nb>INT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>item</span><span class=p>(</span><span class=n>stock</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=세션을-read-committed-로-설정-각-세션에서>세션을 Read Committed 로 설정 (각 세션에서)<a hidden class=anchor aria-hidden=true href=#세션을-read-committed-로-설정-각-세션에서>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=dirty-read-방지>Dirty Read 방지<a hidden class=anchor aria-hidden=true href=#dirty-read-방지>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1>1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2>2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 아직 COMMIT 없음
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 결과: 10 (커밋된 값) -&gt; Dirty Read 없음
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=non-repeatable-read>Non-repeatable Read<a hidden class=anchor aria-hidden=true href=#non-repeatable-read>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1>1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2>2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 10
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1>1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2>2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3>3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 5 (값 변경 관찰)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=phantom-read>Phantom Read<a hidden class=anchor aria-hidden=true href=#phantom-read>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1>1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2>2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=c1>-- e.g., 1
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>item</span><span class=p>(</span><span class=n>stock</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-25-1><a class=lnlinks href=#hl-25-1>1</a>
</span><span class=lnt id=hl-25-2><a class=lnlinks href=#hl-25-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=c1>-- 값 증가 -&gt; Phantom
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>메모: InnoDB 는 gap-lock 등으로 phantom 을 제어하려는 메커니즘이 있으나, 동작은 격리 수준 및 쿼리 형태에 따라 달라짐. REPEATABLE READ 와 비교해 동작이 다르므로 실제 적용 전 테스트가 필수.</p></blockquote><h4 id=sql-server-t-sql재현-스크립트>SQL Server (T-SQL)—재현 스크립트<a hidden class=anchor aria-hidden=true href=#sql-server-t-sql재현-스크립트>#</a></h4><blockquote><p><strong>참고</strong>: SQL Server 기본은 Read Committed(락 기반). DB 수준에서 <code>READ_COMMITTED_SNAPSHOT</code> 을 ON 으로 하면 Read Committed 가 row-versioning(스냅샷 기반) 으로 동작해 블로킹을 줄임. (설정 전 주의: DB 재기동/활성 연결 처리 필요)</p></blockquote><h5 id=준비-1>준비<a hidden class=anchor aria-hidden=true href=#준비-1>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>IDENTITY</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=nb>INT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>item</span><span class=p>(</span><span class=n>stock</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=기본-read-committed-락-기반dirty-read-방지>기본 Read Committed (락 기반)—Dirty Read 방지<a hidden class=anchor aria-hidden=true href=#기본-read-committed-락-기반dirty-read-방지>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-27-1><a class=lnlinks href=#hl-27-1>1</a>
</span><span class=lnt id=hl-27-2><a class=lnlinks href=#hl-27-2>2</a>
</span><span class=lnt id=hl-27-3><a class=lnlinks href=#hl-27-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 미커밋 상태
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span><span class=lnt id=hl-28-3><a class=lnlinks href=#hl-28-3>3</a>
</span><span class=lnt id=hl-28-4><a class=lnlinks href=#hl-28-4>4</a>
</span><span class=lnt id=hl-28-5><a class=lnlinks href=#hl-28-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>  </span><span class=c1>-- 블로킹 발생(쓰기가 풀릴 때까지 기다리거나 타임아웃)
</span></span></span><span class=line><span class=cl><span class=c1>-- 즉, Dirty Read 없음(읽기 시 공유락으로 쓰기 차단)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ROLLBACK</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=non-repeatable-read-1>Non-repeatable Read<a hidden class=anchor aria-hidden=true href=#non-repeatable-read-1>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1>1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2>2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 10
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1>1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2>2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1>1</a>
</span><span class=lnt id=hl-32-2><a class=lnlinks href=#hl-32-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 5  (Non-repeatable)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=phantom-read-1>Phantom Read<a hidden class=anchor aria-hidden=true href=#phantom-read-1>#</a></h5><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-33-1><a class=lnlinks href=#hl-33-1>1</a>
</span><span class=lnt id=hl-33-2><a class=lnlinks href=#hl-33-2>2</a>
</span><span class=lnt id=hl-33-3><a class=lnlinks href=#hl-33-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SET</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=c1>-- e.g., 1
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T2 (세션 B)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-34-1><a class=lnlinks href=#hl-34-1>1</a>
</span><span class=lnt id=hl-34-2><a class=lnlinks href=#hl-34-2>2</a>
</span><span class=lnt id=hl-34-3><a class=lnlinks href=#hl-34-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=n>TRAN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>item</span><span class=p>(</span><span class=n>stock</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>7</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>T1 (세션 A)</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-35-1><a class=lnlinks href=#hl-35-1>1</a>
</span><span class=lnt id=hl-35-2><a class=lnlinks href=#hl-35-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>item</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>stock</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=c1>-- 증가 -&gt; Phantom
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=read-committed-snapshot-rcsi-예-옵션>Read Committed Snapshot (RCSI) 예 (옵션)<a hidden class=anchor aria-hidden=true href=#read-committed-snapshot-rcsi-예-옵션>#</a></h5><p>DB 에 RCSI 를 켜면 읽기 시 버전 기반으로 동작하여 읽기 - 쓰기 블로킹 완화:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-36-1><a class=lnlinks href=#hl-36-1>1</a>
</span><span class=lnt id=hl-36-2><a class=lnlinks href=#hl-36-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>DATABASE</span><span class=w> </span><span class=n>YourDB</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>READ_COMMITTED_SNAPSHOT</span><span class=w> </span><span class=k>ON</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 주의: 변경은 DB에 따라 재기동/활성 연결 영향 있음
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>메모: RCSI 를 켜면 읽기 시 writer 와 블로킹을 피하고 statement-level snapshot 을 제공하므로 성능/일관성 트레이드오프가 달라짐.</p></blockquote><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-rc-에서-비반복-읽기팬텀-관찰-postgresql>실습 예제: RC 에서 비반복 읽기/팬텀 관찰 (PostgreSQL)<a hidden class=anchor aria-hidden=true href=#실습-예제-rc-에서-비반복-읽기팬텀-관찰-postgresql>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>RC 의 문장 단위 스냅샷, 비반복/팬텀 현상 체험</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>PostgreSQL 14+ / <code>psycopg[binary]</code> 3.x / 두 개의 세션 또는 아래 파이썬 스크립트</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p>스키마 준비</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-37-1><a class=lnlinks href=#hl-37-1>1</a>
</span><span class=lnt id=hl-37-2><a class=lnlinks href=#hl-37-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>inv</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=w> </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>,</span><span class=w> </span><span class=n>qty</span><span class=w> </span><span class=nb>int</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>inv</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>파이썬 동시 시나리오 (두 커넥션)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-38-1><a class=lnlinks href=#hl-38-1> 1</a>
</span><span class=lnt id=hl-38-2><a class=lnlinks href=#hl-38-2> 2</a>
</span><span class=lnt id=hl-38-3><a class=lnlinks href=#hl-38-3> 3</a>
</span><span class=lnt id=hl-38-4><a class=lnlinks href=#hl-38-4> 4</a>
</span><span class=lnt id=hl-38-5><a class=lnlinks href=#hl-38-5> 5</a>
</span><span class=lnt id=hl-38-6><a class=lnlinks href=#hl-38-6> 6</a>
</span><span class=lnt id=hl-38-7><a class=lnlinks href=#hl-38-7> 7</a>
</span><span class=lnt id=hl-38-8><a class=lnlinks href=#hl-38-8> 8</a>
</span><span class=lnt id=hl-38-9><a class=lnlinks href=#hl-38-9> 9</a>
</span><span class=lnt id=hl-38-10><a class=lnlinks href=#hl-38-10>10</a>
</span><span class=lnt id=hl-38-11><a class=lnlinks href=#hl-38-11>11</a>
</span><span class=lnt id=hl-38-12><a class=lnlinks href=#hl-38-12>12</a>
</span><span class=lnt id=hl-38-13><a class=lnlinks href=#hl-38-13>13</a>
</span><span class=lnt id=hl-38-14><a class=lnlinks href=#hl-38-14>14</a>
</span><span class=lnt id=hl-38-15><a class=lnlinks href=#hl-38-15>15</a>
</span><span class=lnt id=hl-38-16><a class=lnlinks href=#hl-38-16>16</a>
</span><span class=lnt id=hl-38-17><a class=lnlinks href=#hl-38-17>17</a>
</span><span class=lnt id=hl-38-18><a class=lnlinks href=#hl-38-18>18</a>
</span><span class=lnt id=hl-38-19><a class=lnlinks href=#hl-38-19>19</a>
</span><span class=lnt id=hl-38-20><a class=lnlinks href=#hl-38-20>20</a>
</span><span class=lnt id=hl-38-21><a class=lnlinks href=#hl-38-21>21</a>
</span><span class=lnt id=hl-38-22><a class=lnlinks href=#hl-38-22>22</a>
</span><span class=lnt id=hl-38-23><a class=lnlinks href=#hl-38-23>23</a>
</span><span class=lnt id=hl-38-24><a class=lnlinks href=#hl-38-24>24</a>
</span><span class=lnt id=hl-38-25><a class=lnlinks href=#hl-38-25>25</a>
</span><span class=lnt id=hl-38-26><a class=lnlinks href=#hl-38-26>26</a>
</span><span class=lnt id=hl-38-27><a class=lnlinks href=#hl-38-27>27</a>
</span><span class=lnt id=hl-38-28><a class=lnlinks href=#hl-38-28>28</a>
</span><span class=lnt id=hl-38-29><a class=lnlinks href=#hl-38-29>29</a>
</span><span class=lnt id=hl-38-30><a class=lnlinks href=#hl-38-30>30</a>
</span><span class=lnt id=hl-38-31><a class=lnlinks href=#hl-38-31>31</a>
</span><span class=lnt id=hl-38-32><a class=lnlinks href=#hl-38-32>32</a>
</span><span class=lnt id=hl-38-33><a class=lnlinks href=#hl-38-33>33</a>
</span><span class=lnt id=hl-38-34><a class=lnlinks href=#hl-38-34>34</a>
</span><span class=lnt id=hl-38-35><a class=lnlinks href=#hl-38-35>35</a>
</span><span class=lnt id=hl-38-36><a class=lnlinks href=#hl-38-36>36</a>
</span><span class=lnt id=hl-38-37><a class=lnlinks href=#hl-38-37>37</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install psycopg[binary]</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>psycopg</span><span class=o>,</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DSN</span> <span class=o>=</span> <span class=s2>&#34;postgresql://user:pass@localhost:5432/db&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 각 줄 주석으로 RC의 동작을 설명합니다.</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=n>psycopg</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DSN</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn1</span><span class=p>,</span> <span class=n>psycopg</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DSN</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>conn1</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    <span class=n>conn2</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>conn1</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span> <span class=k>as</span> <span class=n>c1</span><span class=p>,</span> <span class=n>conn2</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span> <span class=k>as</span> <span class=n>c2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 세션 1: 트랜잭션 시작</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 첫 번째 읽기(문장 스냅샷 1)</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT SUM(qty) FROM inv;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1 sum-1:&#34;</span><span class=p>,</span> <span class=n>c1</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()[</span><span class=mi>0</span><span class=p>])</span>  <span class=c1># 20</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 세션 2: 다른 트랜잭션에서 업데이트 후 커밋</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UPDATE inv SET qty = qty + 10 WHERE id = 1;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT;&#34;</span><span class=p>)</span>  <span class=c1># 이제부터 새로운 문은 변경을 볼 수 있음</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 세션 1: 같은 트랜잭션에서 두 번째 읽기(문장 스냅샷 2)</span>
</span></span><span class=line><span class=cl>        <span class=n>c1</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT SUM(qty) FROM inv;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1 sum-2:&#34;</span><span class=p>,</span> <span class=n>c1</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()[</span><span class=mi>0</span><span class=p>])</span>  <span class=c1># 30 (비반복 읽기)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 팬텀 관찰: 행 추가</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;INSERT INTO inv VALUES (3, 5);&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>c2</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>c1</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT COUNT(*) FROM inv WHERE qty &gt;= 5;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T1 count after phantom:&#34;</span><span class=p>,</span> <span class=n>c1</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()[</span><span class=mi>0</span><span class=p>])</span>  <span class=c1># 3 (팬텀)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>c1</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;ROLLBACK;&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과검증>실행 결과/검증<a hidden class=anchor aria-hidden=true href=#실행-결과검증>#</a></h6><ul><li><code>sum-1=20</code>, <code>sum-2=30</code> → <strong>Non-Repeatable Read</strong></li><li><code>count=3</code> → <strong>Phantom Read</strong></li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>같은 시나리오를 <code>SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code> 로 비교 실행</li></ul><h5 id=실습-예제-read-committed-트랜잭션-테스트>실습 예제: Read Committed 트랜잭션 테스트<a hidden class=anchor aria-hidden=true href=#실습-예제-read-committed-트랜잭션-테스트>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>커밋된 데이터만 읽는 Read Committed 의 특징과 Non-Repeatable Read 현상을 직접 코드로 검증.</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>데이터베이스: MySQL, PostgreSQL 등 (격리 수준 변경 가능)</li><li>계정 권한: 트랜잭션 및 테이블 조회/변경 권한</li><li>실습 환경: CLI 또는 DB 툴, AUTOCOMMIT OFF</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>트랜잭션 시작 및 데이터 조회</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-39-1><a class=lnlinks href=#hl-39-1>1</a>
</span><span class=lnt id=hl-39-2><a class=lnlinks href=#hl-39-2>2</a>
</span><span class=lnt id=hl-39-3><a class=lnlinks href=#hl-39-3>3</a>
</span><span class=lnt id=hl-39-4><a class=lnlinks href=#hl-39-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션 A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SET</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>100</span><span class=p>;</span><span class=w> </span><span class=c1>-- ex: 1000원
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>다른 트랜잭션에서 데이터 변경 및 커밋</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-40-1><a class=lnlinks href=#hl-40-1>1</a>
</span><span class=lnt id=hl-40-2><a class=lnlinks href=#hl-40-2>2</a>
</span><span class=lnt id=hl-40-3><a class=lnlinks href=#hl-40-3>3</a>
</span><span class=lnt id=hl-40-4><a class=lnlinks href=#hl-40-4>4</a>
</span><span class=lnt id=hl-40-5><a class=lnlinks href=#hl-40-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션 B
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SET</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>READ</span><span class=w> </span><span class=k>COMMITTED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1200</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>100</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>원래 트랜잭션에서 재조회</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-41-1><a class=lnlinks href=#hl-41-1>1</a>
</span><span class=lnt id=hl-41-2><a class=lnlinks href=#hl-41-2>2</a>
</span><span class=lnt id=hl-41-3><a class=lnlinks href=#hl-41-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션 A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=n>price</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>product</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>100</span><span class=p>;</span><span class=w> </span><span class=c1>-- 1200원으로 변경됨
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>같은 트랜잭션 내에서 SELECT 결과가 바뀌는 Non-Repeatable Read(반복 읽기 불가능) 확인.</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>REPEATABLE READ 로 격리 수준을 변경하면 반복 조회 시 동일 결과가 반환됨.</li></ul><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>Read Committed 는 데이터베이스 격리 수준 중 실무에서 널리 쓰이는 균형점이다.<br>이 모드는 트랜잭션이 다른 트랜잭션의 <strong>미커밋 변경을 볼 수 없도록</strong> 보장해서 Dirty Read 로 인한 잘못된 보고·오류를 예방한다. 대신, RC 는 <strong>문장 (statement) 단위 가시성</strong>을 제공하므로 동일 트랜잭션에서 같은 쿼리를 반복하면 결과가 달라질 수 있는 <em>Non-Repeatable Read</em> 와 범위 질의에서 행의 추가·삭제로 결과가 달라지는 <em>Phantom Read</em> 를 허용한다.</p><p>실무에서는 다음 원칙을 권장한다.<br>핵심 데이터 (금융·결제·사용자 상태) 는 반드시 더 높은 격리 수준 (예: Repeatable Read, Serializable 또는 Snapshot 기반 트랜잭션) 에서 처리하고, 리포트·집계·로그 같은 읽기 중심 워크로드는 RC 적용을 검토하되 <strong>DB 별 동작 차이 확인, 재현 테스트, 모니터링·롤백 계획</strong>을 필수로 준비하라.<br>또한 필요한 경우 특정 쿼리나 트랜잭션만 선별적으로 상향 적용하는 접근 (쿼리 힌트·세션 단위 변경) 이 현실적이며 안전한 운영으로 이어진다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>가이드 항목</th><th>적용 대상 / 조건</th><th>구체 조치 (설정·패턴)</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>기본 선택</td><td>대시보드·로그·근사치 허용 조회</td><td>DB 세션 기본 RC, 쿼리별 명시 가능 (<code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED</code>)</td><td>p95 응답시간, 쿼리 타임아웃</td></tr><tr><td>핵심 경로 보호</td><td>결제·재고·정산 등 결정적 경로</td><td>상향 격리 (Repeatable/Serializable) 또는 유니크 제약 + outbox/compensation</td><td>실패율, 재시도/보상 로그</td></tr><tr><td>트랜잭션 설계</td><td>외부 I/O 포함 작업 금지</td><td>트랜잭션은 짧게, 외부 호출은 outbox/비동기화</td><td>long-running tx 수, lock wait</td></tr><tr><td>보완 패턴</td><td>읽기 - 리플리카 사용 가능 시</td><td>Replica + commit-time recheck(결정 전 마스터 확인)</td><td>replica lag, 재검증 실패율</td></tr><tr><td>DB 별 운영</td><td>PostgreSQL/Oracle 등</td><td>Postgres: VACUUM/oldest xmin 모니터; Oracle: undo 관리</td><td>version bloat, vacuum lag</td></tr><tr><td>SQL Server 특이</td><td>RCSI 사용 시</td><td>TempDB 용량/IO 설계 및 모니터링</td><td>TempDB 사용량 임계치</td></tr><tr><td>ORM/앱 설정</td><td>프레임워크별 세션 제어</td><td>ORM 세션 격리 명시화, 트랜잭션 경계 문서화</td><td>코드 리뷰 체크리스트, CI 동시성 테스트</td></tr><tr><td>변경 절차</td><td>격리 변경 시</td><td>PR→테스트 (재현 포함)→운영 승인→롤아웃</td><td>변경 로그, 자동 롤백 정책</td></tr><tr><td>모니터링 지표</td><td>전체 공통</td><td>tx latency(p50/p95/p99), lock wait, long tx, replica lag</td><td>알람 임계치, runbook 링크</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th>단계명</th><th>목표 (학습 결과)</th><th style=text-align:right>권장 기간</th><th>핵심 활동 (핵심 산출물)</th><th>실무 연관성</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>개념/현상 이해</td><td>Dirty / Non-repeatable / Phantom 현상 정의·사례 설명 가능</td><td style=text-align:right>1–2 일</td><td>이론 학습, 간단 시나리오 작성 (문장별 예)</td><td>격리수준 선택 근거</td></tr><tr><td style=text-align:right>2</td><td>MVCC vs 락 기반</td><td>각 아키텍처의 동작 원리·장단점 비교·예상 영향 설명</td><td style=text-align:right>2–3 일</td><td>아키텍처 다이어그램, 장단점 표</td><td>성능/정합성 판단</td></tr><tr><td style=text-align:right>3</td><td>DBMS 별 설정·옵션</td><td>Postgres/Oracle/MySQL/SQL Server 의 RC 동작·옵션 이해</td><td style=text-align:right>2–4 일</td><td>DB 별 설정 요약문서, 실전 설정 스니펫</td><td>프로덕션 설정·이식성</td></tr><tr><td style=text-align:right>4</td><td>실습 재현</td><td>동시성 문제 재현 (2 세션) 및 관찰/재현 능력 확보</td><td style=text-align:right>2–5 일</td><td>재현 스크립트 + 결과 레포트</td><td>버그 재현·검증 능력</td></tr><tr><td style=text-align:right>5</td><td>운영/모니터링</td><td>운영지표 수집·알람·가드레일 설계/자동화</td><td style=text-align:right>3–7 일</td><td>대시보드 (예: Prometheus+Grafana), 알람 룰</td><td>운영 안정성·SLA 준수</td></tr><tr><td style=text-align:right>6</td><td>고급 대안·최적화</td><td>SSI/HLC/Serializable 등 고급 기법 이해·적용 시나리오</td><td style=text-align:right>4–14 일</td><td>설계 노트, 비교 평가표, 테스트 결과</td><td>민감 도메인 보호·최적화</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th>항목</th><th style=text-align:right>중요도</th><th>학습 목표</th><th style=text-align:right>실무 연관성</th><th>구체 활동 (실습/검증)</th></tr></thead><tbody><tr><td style=text-align:right>1: 개념</td><td>격리수준 개요 (4 단계)</td><td style=text-align:right>필수</td><td>각 수준의 이상현상 구분</td><td style=text-align:right>매우 높음</td><td>표준 정의 정리, 예시 쿼리 작성</td></tr><tr><td style=text-align:right>1: 개념</td><td>Dirty / Non-repeatable / Phantom</td><td style=text-align:right>필수</td><td>재현 가능한 시나리오 이해</td><td style=text-align:right>매우 높음</td><td>2 세션 쿼리로 재현 (짧은 스크립트)</td></tr><tr><td style=text-align:right>2: 구현 차이</td><td>MVCC 내부 (버전 관리, GC)</td><td style=text-align:right>필수</td><td>버전 읽기/가시성 규칙 이해</td><td style=text-align:right>높음</td><td>버전 스냅샷 다이어그램 작성, VACUUM 영향 실험</td></tr><tr><td style=text-align:right>2: 구현 차이</td><td>2PL/Lock Manager(Shared/Exclusive)</td><td style=text-align:right>필수</td><td>락 테이블·대기 그래프 이해</td><td style=text-align:right>높음</td><td>락 대기/데드락 재현 실습</td></tr><tr><td style=text-align:right>3: DB 별</td><td>PostgreSQL Read Committed 특징</td><td style=text-align:right>필수</td><td>statement-level snapshot 동작 파악</td><td style=text-align:right>매우 높음</td><td>psql 스크립트로 reprod.</td></tr><tr><td style=text-align:right>3: DB 별</td><td>Oracle(undo 기반 읽기 일관성)</td><td style=text-align:right>권장</td><td>undo 와 스냅샷 개념 이해</td><td style=text-align:right>높음</td><td>Oracle 환경 예제 (또는 시뮬레이션)</td></tr><tr><td style=text-align:right>3: DB 별</td><td>SQL Server 기본 락 / RCSI 옵션</td><td style=text-align:right>권장</td><td>RCSI 동작·NOLOCK 위험 파악</td><td style=text-align:right>높음</td><td>RCSI 켜고 비교 테스트</td></tr><tr><td style=text-align:right>3: DB 별</td><td>MySQL/InnoDB isolation 옵션</td><td style=text-align:right>권장</td><td>autocommit·isolation 설정 효과</td><td style=text-align:right>중간</td><td>InnoDB 테스트 환경</td></tr><tr><td style=text-align:right>4: 실습</td><td>재현 스크립트 (2 세션)</td><td style=text-align:right>필수</td><td>Dirty/Non-repeatable/Phantom 실증</td><td style=text-align:right>매우 높음</td><td>Docker Compose 로 2 세션 시나리오 실행</td></tr><tr><td style=text-align:right>4: 실습</td><td>복합 케이스 (페이징·집계 후 업데이트)</td><td style=text-align:right>권장</td><td>실무 취약점 파악</td><td style=text-align:right>높음</td><td>시나리오 - 결과 분석 리포트</td></tr><tr><td style=text-align:right>5: 운영</td><td>모니터링 지표 설계</td><td style=text-align:right>필수</td><td>lock-wait, deadlock, long tx, snapshot age</td><td style=text-align:right>매우 높음</td><td>Prometheus + Grafana 대시보드</td></tr><tr><td style=text-align:right>5: 운영</td><td>가드레일 구현</td><td style=text-align:right>필수</td><td>읽기 풀 분리, 쿼리 화이트리스트, 자동격상</td><td style=text-align:right>매우 높음</td><td>미들웨어 라우팅 정책 구현</td></tr><tr><td style=text-align:right>6: 고급</td><td>SSI / Serializable 심층</td><td style=text-align:right>선택</td><td>SSI 작동 원리·장단점 이해</td><td style=text-align:right>중간</td><td>논문/문서 요약 + 실험 (가능하면)</td></tr><tr><td style=text-align:right>6: 고급</td><td>분산 시간 (HLC)·글로벌 일관성</td><td style=text-align:right>선택</td><td>HLC/TrueTime 개념 이해</td><td style=text-align:right>중간</td><td>분산 DB 사례 연구 (Spanner)</td></tr><tr><td style=text-align:right>전 단계 공통</td><td>도구·환경</td><td style=text-align:right>필수</td><td>Docker, psql, mysql, sqlserver 컨테이너 사용법</td><td style=text-align:right>매우 높음</td><td>예제 환경 템플릿 제공 (Compose)</td></tr><tr><td style=text-align:right>전 단계 공통</td><td>검증 기준</td><td style=text-align:right>필수</td><td>성공/실패 판정 기준 (재현률, KPI 변화)</td><td style=text-align:right>매우 높음</td><td>체크리스트 + 자동화 테스트</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글 (영문 풀네임, 약어))</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심</td><td>읽기 커밋 (Read Committed, RC)</td><td>각 SQL 문장은 실행 시점에 <strong>커밋된 값만</strong> 읽음 (Dirty Read 방지).</td><td>Dirty Read, Non-repeatable Read, MVCC, Statement-level snapshot</td><td>대부분 OLTP 의 기본 격리, 성능·정합성 균형</td></tr><tr><td>핵심</td><td>읽기 미완료 (Read Uncommitted, RU)</td><td>커밋되지 않은 데이터도 읽을 수 있음. Dirty Read 발생 가능.</td><td>Dirty Read, 낮은 격리</td><td>로그·임시 분석 등 비정합 허용 영역 (제한적)</td></tr><tr><td>핵심</td><td>반복 가능 읽기 (Repeatable Read, RR)</td><td>트랜잭션 전체에서 같은 행 조회 시 동일한 값 보장 (일부 DB 에서 팬텀 허용 여부 차이).</td><td>Phantom, MVCC, Snapshot Isolation</td><td>강한 읽기 일관성 필요 시</td></tr><tr><td>핵심</td><td>직렬화 가능 (Serializable, S)</td><td>모든 트랜잭션을 직렬 실행한 것과 동일한 결과 보장 (최고 격리).</td><td>검증·락·비관적 제어</td><td>회계·재무·정산 등 최고 신뢰가 필요한 영역</td></tr><tr><td>핵심</td><td>더티 리드 (Dirty Read,—)</td><td>다른 트랜잭션의 <strong>미커밋</strong> 변경을 읽는 현상.</td><td>Read Uncommitted, Read Committed</td><td>방지 대상 (프로덕션 핵심)</td></tr><tr><td>핵심</td><td>반복 불가 읽기 (Non-Repeatable Read,—)</td><td>동일 쿼리 반복 시 값이 달라지는 현상 (다른 트랜잭션 커밋 영향).</td><td>Read Committed, Repeatable Read</td><td>집계·계산 신뢰성 고려</td></tr><tr><td>핵심</td><td>팬텀 (Phantom Read,—)</td><td>동일 조건 재조회 시 행 집합이 달라지는 현상 (INSERT/DELETE 영향).</td><td>Serializable, RR</td><td>범위 집계·쿼리 일관성 주의</td></tr><tr><td>구현</td><td>다중버전 동시성 제어 (Multi-Version Concurrency Control, MVCC)</td><td>데이터의 여러 버전을 유지해 읽기를 스냅샷으로 제공, 읽기 - 쓰기 충돌 완화.</td><td>Snapshot, Undo Log, GC(vacuum)</td><td>PostgreSQL/Oracle 등에서 읽기 비차단 구현</td></tr><tr><td>구현</td><td>문장 단위 스냅샷 (Statement-level Snapshot,—)</td><td>각 SQL 문장 시점의 커밋 상태를 기준으로 읽음 (대표: Read Committed 형태 동작 해석 시 사용).</td><td>Read Committed, MVCC</td><td>RC 동작 이해 시 유의점</td></tr><tr><td>구현</td><td>트랜잭션 단위 스냅샷 (Transaction-level Snapshot,—)</td><td>트랜잭션 시작 시점의 스냅샷으로 전체 트랜잭션 동안 일관된 읽기 제공.</td><td>Repeatable Read, Snapshot Isolation</td><td>트랜잭션 단위 일관성 필요 시</td></tr><tr><td>구현</td><td>2 단계 잠금 (Two-Phase Locking, 2PL)</td><td>잠금 획득 단계와 해제 단계를 분리해 직렬화 보장 (비관적 락 방식).</td><td>S/X Lock, Deadlock</td><td>락 기반 DB/특정 리소스 보호</td></tr><tr><td>구현</td><td>공유/배타 락 (Shared/Exclusive Lock, S/X)</td><td>읽기 시 공유락, 쓰기 시 배타락으로 동시성 제어.</td><td>2PL, Deadlock</td><td>락 정책 설계 및 데드락 모니터링</td></tr><tr><td>구현</td><td>RCSI (Read Committed Snapshot Isolation, RCSI)</td><td>SQL Server 의 버전 기반 Read Committed 구현 옵션 (TempDB 에 버전 저장).</td><td>MVCC, TempDB</td><td>SQL Server 에서 격리·성능 조정</td></tr><tr><td>운영</td><td>트랜잭션 (Transaction,—)</td><td>연산의 원자적 단위: Begin → (작업) → Commit/Rollback.</td><td>ACID, Isolation Level</td><td>모든 DB 작업의 기본 단위</td></tr><tr><td>운영</td><td>격리 수준 (Isolation Level,—)</td><td>트랜잭션 간 중간 상태 노출 규칙의 집합 (표준: RU/RC/RR/S).</td><td>ACID, SQL 표준</td><td>DB/ORM 정책 설정</td></tr><tr><td>운영</td><td>언두/리두 로그 (Undo/Redo Log,—)</td><td>변경 이전 상태/이후 상태를 기록해 복구·롤백 지원.</td><td>WAL, ARIES</td><td>복구·체크포인트 설계</td></tr><tr><td>운영</td><td>Snapshot Isolation (Snapshot Isolation, SI)</td><td>트랜잭션 단위 스냅샷을 제공해 읽기 일관성 확보 (정확한 동작은 DB 별 상이).</td><td>MVCC, Repeatable Read</td><td>중간 수준 일관성 (엔진별 차이 주의)</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/current/transaction-iso.html>PostgreSQL: Transaction Isolation</a></li><li><a href=https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/data-concurrency-and-consistency.html>Oracle Database: Data Concurrency and Consistency</a></li><li><a href="https://learn.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql?view=sql-server-ver17">Microsoft Learn: SET TRANSACTION ISOLATION LEVEL (Transact-SQL)</a></li><li><a href=https://dev.mysql.com/doc/refman/en/innodb-transaction-isolation-levels.html>MySQL Reference Manual: InnoDB Transaction Isolation Levels</a></li><li><a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf>A Critique of ANSI SQL Isolation Levels (Berenson et al., 1995) — PDF</a></li><li><a href=https://pmg.csail.mit.edu/papers/adya-phd.pdf>Weak Consistency: A Generalized Theory and Optimistic Implementations (Atul Adya, 1999) — PDF</a></li><li><a href=https://mangkyu.tistory.com/299>트랜잭션의 격리 수준(Isolation Level)에 대해 쉽고 이해하기 — mangkyu.tistory.com</a></li><li><a href=https://chaewsscode.tistory.com/201>트랜잭션의 격리 수준(Isolation Level) — chaewsscode.tistory.com</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://buenhyden.github.io/tags/data-and-database-systems/>Data-and-Database-Systems</a></li><li><a href=https://buenhyden.github.io/tags/data-operations/>Data-Operations</a></li><li><a href=https://buenhyden.github.io/tags/transaction-management/>Transaction-Management</a></li><li><a href=https://buenhyden.github.io/tags/transaction/>Transaction</a></li><li><a href=https://buenhyden.github.io/tags/transaction-isolation/>Transaction-Isolation</a></li><li><a href=https://buenhyden.github.io/tags/transaction-isolation-levels/>Transaction-Isolation-Levels</a></li><li><a href=https://buenhyden.github.io/tags/read-committed/>Read-Committed</a></li></ul><nav class=paginav><a class=prev href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/serializable/><span class=title>« Prev</span><br><span>Serializable</span>
</a><a class=next href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-uncommitted/><span class=title>Next »</span><br><span>Read Uncommitted</span></a></nav></footer><div class=comments><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const n={src:"https://giscus.app/client.js","data-repo":"buenhyden/buenhyden.github.io","data-repo-id":"R_kgDONsSnFQ","data-category":"General","data-category-id":"DIC_kwDONsSnFc4CmK-R","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"en","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(n).forEach(([t,n])=>e.setAttribute(t,n)),console.log(e),document.querySelector(".comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme)})</script></div></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>