<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lock Compatibility Matrix | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Concurrency-Control,Locking,Lock-Modes,Lock-Compatibility-Matrix,lock-compatibility"><meta name=description content="락 호환성 매트릭스는 DB 트랜잭션이 동일 자원에 대해 요청하는 잠금 모드의 동시 허용·차단 관계를 표로 정리한 것. S/X/U와 의도 잠금(IS/IX/SIX), 키-범위 잠금과 함께 사용되어 충돌 최소화, 팬텀 방지, 일관성과 성능의 균형 설계의 기준이 된다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Lock Compatibility Matrix"><meta property="og:description" content="락 호환성 매트릭스는 DB 트랜잭션이 동일 자원에 대해 요청하는 잠금 모드의 동시 허용·차단 관계를 표로 정리한 것. S/X/U와 의도 잠금(IS/IX/SIX), 키-범위 잠금과 함께 사용되어 충돌 최소화, 팬텀 방지, 일관성과 성능의 균형 설계의 기준이 된다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Lock Compatibility Matrix"><meta name=twitter:description content="락 호환성 매트릭스는 DB 트랜잭션이 동일 자원에 대해 요청하는 잠금 모드의 동시 허용·차단 관계를 표로 정리한 것. S/X/U와 의도 잠금(IS/IX/SIX), 키-범위 잠금과 함께 사용되어 충돌 최소화, 팬텀 방지, 일관성과 성능의 균형 설계의 기준이 된다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":8,"name":"Lock Compatibility Matrix","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Lock Compatibility Matrix</h1><div class=post-description>락 호환성 매트릭스는 DB 트랜잭션이 동일 자원에 대해 요청하는 잠금 모드의 동시 허용·차단 관계를 표로 정리한 것. S/X/U와 의도 잠금(IS/IX/SIX), 키-범위 잠금과 함께 사용되어 충돌 최소화, 팬텀 방지, 일관성과 성능의 균형 설계의 기준이 된다.</div></header><div class=post-content><h2 id=lock-compatibility-matrix>Lock Compatibility Matrix<a hidden class=anchor aria-hidden=true href=#lock-compatibility-matrix>#</a></h2><p>**락 호환성 매트릭스 (Lock Compatibility Matrix, LCM)**는 트랜잭션이 리소스 (레코드/페이지/테이블) 를 특정 모드로 잠글 때, 다른 트랜잭션의 잠금 요청을 <strong>허용·대기·거부</strong>로 즉시 판정하는 규칙표다.<br>기본 모드는 <strong>S(공유)</strong>·**X(배타)**이며, 다중 그레뉼러리티에서 상·하위 객체를 안전히 함께 잠그기 위해 **IS/IX/SIX(의도 락)**을 사용한다.<br>일부 DBMS 는 갱신 경합을 줄이려 <strong>U(Update)</strong> 같은 확장 모드를 둔다.<br>Lock Compatibility Matrix(LCM) 은 격리 수준 (특히 2PL 기반 RC/RR/Serializable) 구현과 <strong>락 에스컬레이션·타임아웃·교착 탐지</strong>의 핵심 근거다.<br><strong>MVCC</strong> 환경에서도 쓰기 충돌·직렬가능성 (예: 프레디킷/범위 잠금) 보장을 위해 잠금이 병행 활용된다.</p><p>실무에선 &rsquo; 읽기 대부분 &rsquo; 워크로드에 S/IS 허용 폭을 넓히고, 쓰기 집중 구간에 X/IX 경합을 줄이도록 <strong>인덱스·범위 (갭/키 - 범위) 잠금 전략</strong>, 에스컬레이션 임계치, 트랜잭션 크기·재시도 정책을 조정해 지연과 교착을 최소화한다.</p><h3 id=락-호환성으로-여는-고성능-트랜잭션>락 호환성으로 여는 고성능 트랜잭션<a hidden class=anchor aria-hidden=true href=#락-호환성으로-여는-고성능-트랜잭션>#</a></h3><p>여러 트랜잭션이 같은 데이터를 동시에 만질 때, <strong>어떤 조합은 함께 가능 (호환)</strong> 하고 어떤 조합은 <strong>누군가 기다려야 (비호환)</strong> 해. 이 규칙표가 <strong>락 호환성 매트릭스</strong>야.<br>데이터는 테이블 → 레코드처럼 <strong>계층</strong>이라서, 아래에서 잠글 계획이면 위 (테이블) 에도 <strong>의도 락</strong>으로 알려줘야 충돌을 빨리 판단할 수 있어.<br>범위로 읽거나 쓸 때는 <strong>팬텀 (새 레코드가 끼어드는 현상)</strong> 을 막으려 범위 자체를 잠그는 방식 (키 - 범위/넥스트키/프레디케이트) 을 써.<br>이 모든 규칙을 지키면서 시스템은 속도를 최대화하고 (동시성), 잘못된 결과를 막아 (일관성). 제품마다 구현이 조금씩 달라서, 사용하는 DB 의 방식을 알아두면 장애 원인 파악과 튜닝이 쉬워져.</p><h4 id=lcm-핵심-개념-일람>LCM 핵심 개념 일람<a hidden class=anchor aria-hidden=true href=#lcm-핵심-개념-일람>#</a></h4><ul><li><strong>기본</strong><ul><li><strong>락 모드 (S/X/NL)</strong>: 읽기 공유 (S), 쓰기 배타 (X), 무 (Null, NL).<br>왜: 동시 읽기 허용·쓰기 충돌 차단의 최저 단위.</li><li><strong>호환성 매트릭스 (LCM)</strong>: 보유 락 vs 요청 락의 즉시 판정표.<br>왜: <strong>블로킹 여부</strong>를 O(1) 로 결정.</li></ul></li><li><strong>실무</strong><ul><li><strong>의도 락 (IS/IX/SIX)</strong>: 하위 리소스 잠금 의도 표시.<br>왜: 테이블↔레코드 <strong>계층 잠금 충돌</strong>을 빠르게 탐지.</li><li><strong>락 에스컬레이션</strong>: 다수의 미세 락→상위 그라뉼러리티로 승격.<br>왜: 메모리·메타데이터 부담 감소.</li></ul></li><li><strong>심화</strong><ul><li><strong>범위 기반 잠금</strong>: Key-Range/넥스트키/프레디케이트.<br>왜: 팬텀 방지 (범위 질의의 직렬성 보장).</li><li><strong>제품별 특수 모드</strong>: SQL Server 의 <strong>U 락</strong>, PostgreSQL 테이블 락 모드군.<br>왜: 데드락 저감·DDL/스키마 보호.</li></ul></li><li><strong>격리 수준과의 상호작용</strong>: RC/RR/Serializable 에 따라 필요한 락 범위·기간이 달라짐.<br>왜: 성능↔일관성 트레이드오프 관리.</li></ul><table><thead><tr><th>개념 (한글·약어)</th><th>정의</th><th>왜 중요한가</th><th>대표 구현/참조</th></tr></thead><tbody><tr><td>락 호환성 매트릭스 (LCM)</td><td>락 모드 간 동시 허용 여부를 표로 정의</td><td>블로킹/대기·경합 예측 및 제어</td><td>PG/SQL Server 공식 문서의 호환 표</td></tr><tr><td>공유 락·배타 락 (S/X)</td><td>읽기 공유/쓰기 배타</td><td>읽기 동시성↑/쓰기 충돌 차단</td><td>모든 RDBMS 공통</td></tr><tr><td>의도 락 (IS/IX/SIX)</td><td>하위 리소스 잠금 의도 표기</td><td>계층 충돌 O(1) 판정·스캔 성능</td><td>MGL 위키·교과 참고</td></tr><tr><td>널 락 (NL)</td><td>내부적 " 무 " 락</td><td>호환성 판단 단순화</td><td>SQL Server 문서</td></tr><tr><td>업데이트 락 (U)</td><td>S→X 전환 충돌 완화</td><td>데드락 저감</td><td>SQL Server 문서</td></tr><tr><td>범위 잠금 (Key-Range/넥스트키/프레디케이트)</td><td>인덱스 범위·조건에 대한 잠금</td><td>팬텀 방지·직렬성 확보</td><td>SQL Server 키 - 범위, MySQL 넥스트키, PG SIREAD</td></tr><tr><td>락 에스컬레이션</td><td>미세 락→상위로 승격</td><td>메모리·메타데이터 부담 완화</td><td>MGL·제품 가이드</td></tr><tr><td>격리 수준 (RC/RR/SR/SI)</td><td>트랜잭션 간 보장 수준</td><td>성능↔일관성 트레이드오프</td><td>강의 노트</td></tr></tbody></table><p>LCM 은 <strong>즉시 판정 규칙표</strong>이고, 의도 락·에스컬레이션은 <strong>계층 관리 비용과 충돌 판정 속도</strong>를 개선한다. 팬텀 방지는 제품별 <strong>범위 기반 잠금</strong> 방식이 다르므로 튜닝·장애 분석 시 제품 문서를 반드시 참조해야 한다.</p><h4 id=lcm-구성요소-상호작용-지도>LCM 구성요소 상호작용 지도<a hidden class=anchor aria-hidden=true href=#lcm-구성요소-상호작용-지도>#</a></h4><ul><li><strong>격리 수준</strong>이 요구하는 일관성 수준 → <strong>범위 잠금/의도 락 전략</strong> 선택 → <strong>LCM</strong>으로 즉시 호환성 판정 → 결과로 <strong>블로킹/대기</strong> 발생 → 과도 시 <strong>에스컬레이션/타임아웃/우선순위 조정</strong> 적용.</li></ul><table><thead><tr><th>출발 → 도착</th><th>방향/의미</th><th>무엇을 위해</th><th>메모 (제품 차이)</th></tr></thead><tbody><tr><td>격리 수준 → 범위 잠금</td><td>요구 일관성↑ ⇒ 강한 범위 제어</td><td>팬텀 방지·직렬성</td><td>PG=SIREAD, SQLS=Key-Range, MySQL=넥스트키</td></tr><tr><td>의도 락 → LCM 판정</td><td>상위에서 하위 계획 신호</td><td>계층 충돌 O(1) 판정</td><td>MGL 규칙 (격자형 호환)</td></tr><tr><td>인덱스 설계 → 범위 잠금 범위</td><td>스캔 패턴 결정</td><td>경합 최소화</td><td>InnoDB 는 " 스캔된 인덱스 범위 " 에 잠금</td></tr><tr><td>LCM 판정 → 블로킹/대기</td><td>비호환 시 대기</td><td>안정성/일관성 확보</td><td>모든 DBMS 공통</td></tr><tr><td>경합 증가 → 에스컬레이션</td><td>미세 잠금 폭주 완화</td><td>운영 비용 절감</td><td>정책·임계치 제품별 상이</td></tr></tbody></table><p>요구 <strong>일관성 수준</strong>이 강할수록 <strong>범위 잠금</strong>의 강도가 올라가고, 이는 <strong>인덱스·쿼리 패턴</strong>과 맞물려 경합을 좌우한다. <strong>의도 락</strong>은 이 모든 과정을 <strong>LCM</strong>으로 빠르게 판정하게 만드는 접착제 역할을 한다.</p><h4 id=lcm-기반-실무-적용-매핑>LCM 기반 실무 적용 매핑<a hidden class=anchor aria-hidden=true href=#lcm-기반-실무-적용-매핑>#</a></h4><ul><li><strong>성능 튜닝</strong>: 인덱스 설계·범위 질의 최적화로 <strong>범위 잠금 영역 최소화</strong> → 경합 감소.</li><li><strong>운영 안정성</strong>: 대기열·타임아웃·교착 탐지 정책으로 <strong>긴 대기/순환 대기</strong> 완화.</li><li><strong>스키마 작업</strong>: 테이블 락 모드 이해로 <strong>DDL 충돌 회피</strong>(예: ACCESS EXCLUSIVE 와의 충돌).</li><li><strong>제품별 디버깅</strong>: PostgreSQL 의 SIREAD 보기는 " 대기 원인 " 이 아님을 이해 → 잘못된 원인 추정 방지.</li></ul><table><thead><tr><th>상황 (무엇)</th><th>적용 방법 (어떻게)</th><th>기대 효과/리스크 (왜)</th><th>체크포인트/지표</th></tr></thead><tbody><tr><td>범위 질의 팬텀 발생</td><td>적절한 인덱싱 + 제품별 범위 잠금 이해 (키 - 범위/넥스트키/SIREAD)</td><td>직렬성 보장, 삽입 팬텀 제거</td><td>실행계획 스캔 범위·락 대기 시간</td></tr><tr><td>갱신 경합·데드락</td><td>SQL Server 의 U 락/락 순서 정규화</td><td>교착 가능성 감소</td><td>데드락 그래프·대기 타임아웃</td></tr><tr><td>대량 배치·ETL</td><td>에스컬레이션 임계/배치 크기 조정</td><td>메모리·락 테이블 부담 경감</td><td>락 수·메타데이터 사용량</td></tr><tr><td>DDL 과 DML 충돌</td><td>테이블 락 모드 충돌 표 확인 후 순서 조정</td><td>운영 중단·대기 급증 방지</td><td>PG 테이블 락 모드 충돌 매트릭스 확인</td></tr><tr><td>읽기 지연 급증</td><td>인덱스 재설계로 스캔 범위 축소</td><td>범위 잠금 면적↓ → 경합↓</td><td>InnoDB 스캔 - 락 상관 확인</td></tr></tbody></table><p>실무에서는 <strong>쿼리 패턴×인덱스×제품별 범위 잠금</strong>의 조합이 체감 성능을 좌우한다. LCM 을 전제로, <strong>락 순서/정책/임계치</strong>를 조정하면 교착·경합을 크게 줄일 수 있다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=락-호환성-매트릭스-제대로-이해하기>락 호환성 매트릭스, 제대로 이해하기<a hidden class=anchor aria-hidden=true href=#락-호환성-매트릭스-제대로-이해하기>#</a></h4><ul><li><strong>정의 한 줄:</strong> 락 호환성 매트릭스는 <strong>두 락 모드가 같은 자원에서 동시에 가능하냐</strong>를 보이는 표다.</li><li><strong>왜 중요한가:</strong> 트랜잭션이 많아질수록 <strong>충돌을 빠르게 판정</strong>해야 성능과 일관성을 지킬 수 있다.</li><li><strong>가장 단순한 규칙:</strong> <code>S</code> 끼리는 함께 가능, <code>X</code> 는 혼자만 가능.</li><li><strong>조금 더 나아가:</strong> 계층 구조 (테이블→행) 에서는 <strong>IS/IX/SIX</strong> 같은 <strong>의도 락</strong>으로 " 하위에서 잠글 계획 " 을 상위에 알려 <strong>충돌 탐색을 최적화</strong>한다.</li><li><strong>실무 팁:</strong> 사용 중인 DBMS 의 <strong>공식 호환성 표</strong>를 즐겨찾기해두고, 설계·튜닝·장애 분석 때 항상 참조하라.</li></ul><h5 id=락-호환성-정의원리맥락>락 호환성: 정의·원리·맥락<a hidden class=anchor aria-hidden=true href=#락-호환성-정의원리맥락>#</a></h5><p><strong>락 호환성 매트릭스 (정의)</strong><br>동일 자원에 대해 <strong>현재 보유된 락 모드</strong>와 <strong>새로 요청되는 락 모드</strong>의 <strong>동시 보유 가능성</strong>을 나타내는 2 차원 불린 (Boolean) 표다. 원소 <code>M[i][j]</code> 는 " 모드 i 가 보유 중일 때 모드 j 를 부여해도 되는가 " 를 의미한다. 이 표는 DBMS 의 <strong>락 부여 결정 규칙</strong>으로 동작한다.</p><p><strong>운영 원리</strong><br>DBMS 는 락 요청을 받을 때 자원·모드·보유 현황을 확인하고, 매트릭스를 조회해 <strong>허용/비허용을 즉시 판정</strong>한다. 허용이면 락을 부여하고, 비허용이면 대기열에 넣거나 에러를 낸다 (데드락 탐지/타임아웃 정책과 결합).</p><ul><li><strong>DBMS 의 판단 절차 (개념)</strong><ol><li>요청 자원 R 과 모드 m 확인</li><li>R 에 보유 중인 모든 모드 h 에 대해 <code>M[h][m]</code> 을 검사</li><li>전부 호환이면 <strong>grant</strong>, 하나라도 비호환이면 <strong>wait/deny</strong> (추가로 대기열·데드락 탐지/타임아웃 정책 작동).</li></ol></li></ul><p><strong>기본 예시 (S/X)</strong><br>공유 (S) 는 <strong>다른 공유와는 호환</strong>되지만 배타 (X) 와는 비호환이다. 배타 (X) 는 <strong>어느 모드와도 호환되지 않는다</strong>. 이 간단한 규칙만으로도 <strong>읽기 - 읽기 동시성</strong>과 <strong>쓰기 고립</strong>을 설명할 수 있다.</p><table><thead><tr><th>보유\요청</th><th style=text-align:right>S</th><th style=text-align:right>X</th></tr></thead><tbody><tr><td><strong>S</strong></td><td style=text-align:right>✔</td><td style=text-align:right>✖</td></tr><tr><td><strong>X</strong></td><td style=text-align:right>✖</td><td style=text-align:right>✖</td></tr></tbody></table><p>→ <strong>S 는 S 와만 호환</strong>, <strong>X 는 어떤 락과도 비호환</strong>이다.</p><p><strong>의도 락과 계층</strong><br>테이블·페이지·행 같은 <strong>다단계 자원</strong>에서는 **의도 락 (IS/IX/SIX)**을 상위 노드에 부여해 하위 노드에서의 잠금 계획을 알린다. 덕분에 상위 수준에서 광역 충돌 탐색을 빠르게 하고, <strong>락 에스컬레이션</strong> 같은 정책과도 자연스럽게 맞물린다. 대표 호환성은 위 표와 같으며, 예컨대 <code>IX</code> 는 <code>S/SIX</code> 와 비호환이다.</p><table><thead><tr><th>보유\요청</th><th style=text-align:right>IS</th><th style=text-align:right>IX</th><th style=text-align:right>S</th><th style=text-align:right>SIX</th><th style=text-align:right>X</th></tr></thead><tbody><tr><td><strong>IS</strong></td><td style=text-align:right>✔</td><td style=text-align:right>✔</td><td style=text-align:right>✔</td><td style=text-align:right>✔</td><td style=text-align:right>✖</td></tr><tr><td><strong>IX</strong></td><td style=text-align:right>✔</td><td style=text-align:right>✔</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td></tr><tr><td><strong>S</strong></td><td style=text-align:right>✔</td><td style=text-align:right>✖</td><td style=text-align:right>✔</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td></tr><tr><td><strong>SIX</strong></td><td style=text-align:right>✔</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td></tr><tr><td><strong>X</strong></td><td style=text-align:right>✖</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td><td style=text-align:right>✖</td></tr></tbody></table><p><strong>MVCC 와의 관계</strong><br>MVCC 시스템 (예: PostgreSQL) 은 다수의 읽기와 쓰기를 <strong>행 버전으로 분리</strong>해 충돌을 줄이지만, <strong>명시적 테이블 락/DDL 락</strong> 등에는 여전히 <strong>호환성 매트릭스</strong>가 적용된다. 즉, MVCC 는 <strong>행 버전 관리</strong>, 매트릭스는 <strong>락 부여 규칙</strong>으로 서로 다른 층위의 메커니즘이다.</p><p><strong>제품별 차이 유의</strong><br>SQL Server, DB2 등은 <code>U</code>/<code>Sch-S</code>/<code>Sch-M</code>/<code>Z</code> 같은 <strong>추가 모드</strong>를 정의하며, <strong>공식 표</strong>가 곧 진실의 원천이다. 개념은 동일하지만 <strong>모드·세부 호환성은 제품별 문서</strong>로 확인한다.</p><h4 id=락-호환성-매트릭스-배경과-진화>락 호환성 매트릭스: 배경과 진화<a hidden class=anchor aria-hidden=true href=#락-호환성-매트릭스-배경과-진화>#</a></h4><ul><li><strong>왜 필요?</strong> 동시에 읽고 쓰는 트랜잭션이 <strong>서로 방해하지 않게</strong> 하려면, 어떤 락이 함께 허용/금지되는지 표로 정의해야 한다 (= <strong>호환성 매트릭스</strong>).</li><li><strong>어떻게 발전?</strong><ol><li><strong>초기 S/X + 2PL</strong>: 단순·강력하지만 읽기 성능 저하·데드락·팬텀 이슈. → <strong>일관성의 최소 요건</strong>을 제시.</li><li><strong>의도 락·MGL</strong>: 트리형 자원에 다층 잠금 적용 시 <strong>부모/조상 충돌을 신속 탐지</strong>하여 <strong>락 수·충돌·오버헤드</strong>를 줄임. <strong>SIX</strong> 등 확장 모드로 <strong>대량 읽기 + 부분 쓰기</strong> 혼합 워크로드 최적화.</li><li><strong>팬텀 대응의 실용화</strong>: 프레디케이트 락의 비용 문제 → <strong>키 - 레인지/넥스트 - 키 락</strong>으로 <strong>삽입·삭제 팬텀</strong>까지 차단, 직렬 가능 격리 구현 용이.</li><li><strong>MVCC</strong>와 결합해 읽기 성능 향상, 필요시 <strong>범위잠금/SSI</strong>로 직렬 가능 보장.</li></ol></li><li><strong>실무 포인트</strong>: 락 모드 이름은 DB 마다 달라도 <strong>매트릭스가 본질</strong>. 호환/비호환만 정확히 이해하면 다른 엔진으로도 이식이 쉽다.</li></ul><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><ul><li>1960–70 년대 다중 사용자 DBMS 가 보편화되며, <strong>동시성·일관성·성능</strong>을 동시에 만족시킬 제어가 요구됐다. <strong>2PL</strong>은 " 락을 해제한 뒤에는 새 락을 요청하지 않는다 " 는 간명한 규칙으로 <strong>직렬 가능성</strong>을 충분조건으로 보장했다. 그러나 <strong>읽기 전용 트랜잭션의 차단</strong>, <strong>팬텀</strong>(범위 질의 재실행 시 새로운 행이 나타나는 현상), <strong>데드락</strong> 등의 부작용이 명확했다.</li><li>트리형 저장구조 (B-Tree 인덱스 등) 가 보편화되자, <strong>상위 노드와 하위 노드 잠금 간 충돌을 빠르게 탐지</strong>하고 불필요한 전체 락을 피하려는 요구가 커졌다. 이것이 <strong>의도 락·MGL</strong>과 <strong>호환성 매트릭스의 확장</strong>으로 이어졌다.</li></ul><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th>시기</th><th>핵심 제안/기술</th><th>왜 등장했나</th><th>무엇이 개선되었나 (매트릭스 관점)</th></tr></thead><tbody><tr><td>1976</td><td><strong>2PL + 프레디케이트 락</strong>(EGLT)</td><td>직렬 가능성 보장, 범위 질의의 <strong>팬텀</strong> 이론적 차단</td><td><strong>S/X 호환성</strong>의 기본 축 정립, <strong>범위 충돌</strong>을 개념적으로 포함.</td></tr><tr><td>1976</td><td><strong>의도 락 (IS/IX/SIX) + MGL</strong>(Gray)</td><td>계층 자원에 안전·효율 잠금 필요</td><td><strong>조상 노드와의 충돌</strong>을 매트릭스로 빨리 판정, <strong>대량 읽기 + 부분 쓰기</strong>에 <strong>SIX</strong>로 최적화.</td></tr><tr><td>1980s–1990s</td><td><strong>키 - 레인지/넥스트 - 키 락</strong></td><td>프레디케이트 락의 고비용·미구현 문제 해결</td><td><strong>삽입·삭제 팬텀</strong>까지 호환성 표에 반영 (레인지 단위 충돌). InnoDB 의 넥스트 - 키가 대표.</td></tr><tr><td>1990s–2000s</td><td><strong>MVCC/스냅샷 격리</strong></td><td>읽기 비차단·고성능 읽기</td><td>읽기 경합 감소. 다만 <strong>Serializable 보장</strong>엔 <strong>범위잠금/SSI</strong>가 보완.</td></tr><tr><td>2000s–현재</td><td><strong>엔진별 확장</strong>(예: SQL Server 키 - 레인지, Postgres 충돌 매트릭스, Spanner 의 락 기반 RW 트랜잭션)</td><td>워크로드·분산 요구 대응</td><td><strong>모드 명칭은 달라도 매트릭스 기반 판단</strong>은 동일. 운영·튜닝 지표로 정착.</td></tr></tbody></table><pre class=mermaid>timeline
    title 락 호환성 매트릭스의 등장과 진화
    1960s-1970s : 다중 사용자 DBMS 보급 · S/X 잠금 확산
    1976 : 2PL 정식화 · 프레디케이트 락 제안(팬텀 이론적 차단)
    1976 : 의도 락(IS/IX/SIX) · MGL 도입(계층 락킹·호환성 확장)
    1980s-1990s : 키-레인지/넥스트-키 락(프레디케이트의 실용화)
    1990s-2000s : MVCC/스냅샷 격리 확산(읽기 비차단) → Serializable엔 범위잠금/SSI 병행
    2000s-Now : 엔진·클라우드별 모드 다양화(이름은 달라도 매트릭스는 본질)
    Note 1976 : 문제점 보완 포인트 — 계층 충돌 탐지·락 수 감소 필요 → 의도 락·SIX로 개선
    Note 1990s : 문제점 보완 포인트 — 프레디케이트 구현 난이도·오버헤드 ↑ → 키-레인지/넥스트-키로 현실화
    Note Now : 운영 포인트 — 모드명 다름·락 에스컬레이션·데드락 관찰 필요(매트릭스 기반 튜닝)
</pre><ul><li><strong>핵심 축</strong>은 언제나 **" 어떤 모드가 공존 가능한가 &ldquo;**다. 이름이 아니라 <strong>호환성 매트릭스</strong>가 본질이다.</li><li><strong>이론 → 실용</strong> 전환의 핵심은 <strong>팬텀 방지</strong>를 <strong>키 - 레인지/넥스트 - 키</strong>로 구현해 **매트릭스에 " 범위 단위 충돌 &ldquo;**을 반영한 점이다.</li><li><strong>MVCC</strong>는 읽기 경합을 줄였지만, <strong>직렬 가능</strong>이 목표라면 <strong>범위잠금/SSI</strong>와 함께 설계해야 한다.</li></ul><h4 id=동시성-품질을-높이는-락-매트릭스-전략>동시성 품질을 높이는 락 매트릭스 전략<a hidden class=anchor aria-hidden=true href=#동시성-품질을-높이는-락-매트릭스-전략>#</a></h4><p>락 호환성 매트릭스는 특정 잠금 모드끼리가 함께 잡혀도 되는지, 아니면 서로 막는지를 표로 정리한 것이다.<br>이 표를 기준으로 읽기·쓰기 작업의 조합을 설계하면 더티리드·팬텀 같은 문제를 피하면서도 불필요한 대기를 줄일 수 있다.<br>나아가 의도락과 키 - 범위 락을 적절히 사용하면 대용량 환경에서도 예측 가능한 성능과 일관성을 확보할 수 있다.</p><h5 id=락-호환성-매트릭스의-목적과-효용>락 호환성 매트릭스의 목적과 효용<a hidden class=anchor aria-hidden=true href=#락-호환성-매트릭스의-목적과-효용>#</a></h5><ul><li>동시성 vs 일관성 딜레마: 모드 조합의 허용/충돌을 표로 명시해 불필요한 직렬화를 줄이면서 ACID 일관성 요구를 충족.</li><li>락 충돌·대기: S/X/U/의도락 (IS/IX/SIX)·키범위락 등 조합을 사전 설계해 대기열과 타임아웃을 감소.</li><li>팬텀·더티·반복불가능 읽기: 격리수준과 호환 규칙을 결합해 팬텀 방지 (키 - 범위), 더티/NRR 억제.</li><li>데드락 위험: 자원 획득 순서·모드 선택을 일관화하여 순환대기 가능성을 낮춤 (탐지·해결은 별도 메커니즘).</li><li>자원 활용 저하: 읽기 - 읽기 호환을 넓히고 그라뉼러리티를 조정해 처리량 향상.</li></ul><h5 id=락-매트릭스로-풀어내는-대표-문제들>락 매트릭스로 풀어내는 대표 문제들<a hidden class=anchor aria-hidden=true href=#락-매트릭스로-풀어내는-대표-문제들>#</a></h5><table><thead><tr><th>문제</th><th>주된 원인</th><th>매트릭스가 하는 일</th><th>개선/효과</th><th>관련 기능/예시</th></tr></thead><tbody><tr><td>더티 리드</td><td>갱신 중인 행을 다른 트랜잭션이 읽음</td><td>S/X/U 호환 규칙으로 읽기 - 쓰기 충돌 차단</td><td>데이터 일관성 보장</td><td>S vs X 비호환 규칙</td></tr><tr><td>반복 불가능 읽기</td><td>동일 행을 재조회 시 값 변경</td><td>읽기 락 유지·호환 제한</td><td>재조회 일관성 향상</td><td>Repeatable Read 설계</td></tr><tr><td>팬텀 리드</td><td>범위 조회 후 신규 행 삽입</td><td>키 - 범위 락 호환 규칙 적용</td><td>범위 일관성 확보</td><td>SERIALIZABLE+Key-Range</td></tr><tr><td>과도한 대기/타임아웃</td><td>불필요한 비호환 조합</td><td>호환 가능한 모드 채택·순서 정립</td><td>처리량↑, 지연↓</td><td>IS/IX/SIX 설계</td></tr><tr><td>데드락 위험</td><td>순환 대기</td><td>자원 획득 순서·모드 단순화</td><td>발생 확률 감소</td><td>블로킹 원인 분석 지침</td></tr></tbody></table><p>매트릭스는 어떤 조합이 막히는지 명확히 보여줌으로써 더티/팬텀 등 이상 현상을 억제하고, 대기·데드락을 줄여 처리량과 안정성을 함께 끌어올린다.</p><h5 id=락-매트릭스의-핵심-목적과-달성-수단>락 매트릭스의 핵심 목적과 달성 수단<a hidden class=anchor aria-hidden=true href=#락-매트릭스의-핵심-목적과-달성-수단>#</a></h5><table><thead><tr><th>목적</th><th>설명</th><th>설계/운영 포인트</th><th>참고 지표·도구</th></tr></thead><tbody><tr><td>일관성 보장</td><td>트랜잭션 격리 요구 충족</td><td>키 - 범위 락, 모드 호환성 준수</td><td>팬텀/NRR 발생률, 실패 케이스</td></tr><tr><td>성능 최적화</td><td>불필요한 직렬화 제거</td><td>의도락·그라뉼러리티 조정</td><td>평균 대기, 처리량, 타임아웃</td></tr><tr><td>예측 가능성</td><td>규칙 기반 사전 설계</td><td>자원 획득 순서 표준화</td><td>변경 전후 충돌 행렬 비교</td></tr><tr><td>운영 가시성</td><td>문제 진단·튜닝</td><td>DMV/뷰 모니터링</td><td>sys.dm_tran_locks, Locks 카운터</td></tr></tbody></table><p>목적 달성은 호환 규칙 준수, 적절한 락 모드·범위 선택, 모니터링·피드백 루프 구축이 핵심이다.</p><h5 id=문제와-목적의-11nm-연결성>문제와 목적의 1:1·N:M 연결성<a hidden class=anchor aria-hidden=true href=#문제와-목적의-11nm-연결성>#</a></h5><table><thead><tr><th>문제 → 목적</th><th style=text-align:right>일관성 보장</th><th style=text-align:right>성능 최적화</th><th style=text-align:right>예측 가능성</th><th style=text-align:right>운영 가시성</th></tr></thead><tbody><tr><td>더티/반복불가/팬텀</td><td style=text-align:right>높음</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td><td style=text-align:right>낮음</td></tr><tr><td>충돌·대기</td><td style=text-align:right>중간</td><td style=text-align:right>높음</td><td style=text-align:right>높음</td><td style=text-align:right>중간</td></tr><tr><td>데드락 위험</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td><td style=text-align:right>높음</td><td style=text-align:right>중간</td></tr><tr><td>자원 활용 저하</td><td style=text-align:right>낮음</td><td style=text-align:right>높음</td><td style=text-align:right>중간</td><td style=text-align:right>낮음</td></tr></tbody></table><p>이상 현상은 주로 일관성과 직결, 대기·데드락·자원 이슈는 성능·예측 가능성과 강하게 연결된다.</p><h4 id=lcm-실전-적용-핵심-요건-정리>LCM 실전 적용 핵심 요건 정리<a hidden class=anchor aria-hidden=true href=#lcm-실전-적용-핵심-요건-정리>#</a></h4><p>LCM(락 호환성 매트릭스) 은 " 지금 이 락을 줘도 되는가?&rdquo; 를 <strong>즉시 판정</strong>하는 규칙표다.<br>제대로 쓰려면 먼저 <strong>2PL 같은 직렬화 보장 방식</strong>을 전제로 하고, <strong>격리 수준</strong>에 맞춰 어떤 잠금을 쓰는지 알아야 한다.<br>예를 들어 READ COMMITTED 이상에서는 쓰기 충돌은 항상 조정되고, SERIALIZABLE 에서는 팬텀을 막기 위해 인덱스 <strong>키 - 범위/갭 잠금</strong>이 필요하다.<br>테이블 - 페이지 - 레코드처럼 <strong>여러 단계의 락 단위</strong>를 쓰면 의도 락 (IS/IX/SIX) 규칙이 들어가 충돌 판단이 더 정교해진다.<br>내부적으로는 락 테이블과 대기 큐를 다루는 <strong>락 관리자</strong>가 있고, 이 자료구조를 보호하는 <strong>래치</strong>가 필요하다.<br>또한 <strong>데드락</strong>이 생길 수 있으므로 탐지나 예방, 타임아웃 정책이 준비돼 있어야 한다.</p><p>마지막으로 DBMS 마다 구현이 다르니 (예: PostgreSQL 의 호환 표, SQL Server 의 키 - 범위, InnoDB 의 갭/넥스트키, Oracle 의 MVCC) 제품별 문서를 참고해 운영 환경에 맞게 조정한다.</p><h5 id=lcm-적용을-위한-필수-전제요구>LCM 적용을 위한 필수 전제·요구<a hidden class=anchor aria-hidden=true href=#lcm-적용을-위한-필수-전제요구>#</a></h5><h6 id=기술적-전제-조건>기술적 전제 조건<a hidden class=anchor aria-hidden=true href=#기술적-전제-조건>#</a></h6><ul><li><strong>2PL 또는 동등 직렬화 보장</strong>: 충돌 직렬가능성을 보장하기 위해 성장/축소 단계 구분이 필요하며, LCM 은 각 단계에서 허용/대기/거부 판정의 근거가 됨.<br><em>근거: 2PL 직렬화 정리</em></li><li><strong>격리 수준과 범위 잠금</strong>: RC 이상에서 읽기/쓰기 충돌을 판정, SERIALIZABLE 에선 팬텀 방지용 키 - 범위/갭 잠금 규칙이 요구됨.<br><em>근거: key-range/next-key 공식 문서</em></li><li><strong>다중 그레뉼러리티와 의도 락</strong>: 테이블→페이지→레코드 계층에서 상·하위 객체 보호를 위해 IS/IX/SIX 규칙이 필요.<br><em>근거: 계층적 락킹 규칙</em></li></ul><h6 id=시스템-요구사항>시스템 요구사항<a hidden class=anchor aria-hidden=true href=#시스템-요구사항>#</a></h6><ul><li><strong>락 관리자와 래치</strong>: 락 테이블/큐 조작의 원자성을 위한 래치가 필요, 없으면 레이스로 LCM 판정이 깨짐.<br><em>근거: 락 매니저 구현 논의</em></li><li><strong>메모리·스케줄링</strong>: 리소스/범위/메타데이터 잠금 증가에 대비한 메모리와 공정한 대기 큐 정책이 필요.<br><em>근거: 잠금 리소스 유형</em></li><li><strong>데드락 처리</strong>: 탐지 (주기적/사건 기반) 또는 예방 (wait-die, wound-wait), 타임아웃 병행.<br><em>근거: 고전적 처리 전략</em></li></ul><h6 id=학습환경-전제>학습/환경 전제<a hidden class=anchor aria-hidden=true href=#학습환경-전제>#</a></h6><ul><li><strong>트랜잭션·격리·인덱스 구조 이해</strong></li><li><strong>벤더 차이 인지</strong>: PostgreSQL(명시적/행락 호환 표), SQL Server(행·키 - 범위 호환 표), InnoDB(갭/넥스트키), Oracle(MVCC+ 락) 특성 차이를 인지.<br><em>근거: 각 공식 문서</em></li></ul><h5 id=lcm-전제요구-체크리스트>LCM 전제·요구 체크리스트<a hidden class=anchor aria-hidden=true href=#lcm-전제요구-체크리스트>#</a></h5><table><thead><tr><th>구분</th><th>항목</th><th>왜 필요한가 (근거)</th><th>구현 포인트/예시</th></tr></thead><tbody><tr><td>전제</td><td>2PL 또는 동등 직렬화</td><td>충돌 직렬가능성, 락 판정의 의미 확보</td><td>성장/축소 단계 준수, 업그레이드 교착 주의</td></tr><tr><td>전제</td><td>격리 수준 설정</td><td>RC 이상 충돌 제어, SERIALIZABLE 팬텀 방지 필요</td><td>Key-range/next-key 활성화</td></tr><tr><td>전제</td><td>다중 그레뉼러리티</td><td>상·하위 객체 동시 보호</td><td>IS/IX/SIX 규칙 적용, 에스컬레이션 안전화</td></tr><tr><td>시스템</td><td>락 관리자 래치</td><td>락 테이블 원자성·일관성</td><td>내부 동기화 (세마포어/래치) 설계</td></tr><tr><td>시스템</td><td>메모리/큐</td><td>리소스·범위 잠금 수 증가 대응</td><td>락 유형별 메모리 캡·모니터링</td></tr><tr><td>시스템</td><td>데드락 처리</td><td>순환 대기 해소</td><td>탐지 (그래프)/예방 (wait-die/wound-wait)/타임아웃</td></tr><tr><td>환경</td><td>벤더 차이</td><td>호환 표·락 모드 상이</td><td>PostgreSQL/SQL Server/InnoDB/Oracle 문서 준거</td></tr></tbody></table><p>LCM 을 실무에 적용하려면 **직렬화 보장 (2PL), 격리 수준별 잠금 규칙, 다중 그레뉼러리티 (의도 락)**가 전제돼야 한다. 운영 측면에선 <strong>락 관리자 동기화·메모리·데드락 처리</strong>가 필수이며, 제품마다 <strong>호환성 표와 잠금 모드</strong>가 달라 공식 문서를 기준으로 매개변수를 조정해야 안정적인 동시성과 일관성을 얻는다.</p><h5 id=관련-기술과의-차별점>관련 기술과의 차별점<a hidden class=anchor aria-hidden=true href=#관련-기술과의-차별점>#</a></h5><ul><li><strong>vs MVCC 단독</strong>: MVCC 는 읽기 일관성을 버전으로 해결하지만 <strong>쓰기/범위 충돌</strong> 판정은 결국 락/LCM 규칙을 함께 사용.</li><li><strong>vs 단일 그레뉼러리티 락</strong>: 의도 락 없는 단일 레벨은 에스컬레이션/동시성에 취약. LCM 은 IS/IX/SIX 로 <strong>충돌 판정과 에스컬레이션 안전성</strong>을 동시에 달성.</li><li><strong>vs 낙관적/타임스탬프 기법</strong>: 사후 검증/재시도 중심이라 LCM 기반의 <strong>사전 차단</strong>과 운영 특성이 다름 (충돌이 잦을수록 LCM 유리). <em>일반 이론 대비 관점</em></li></ul><h4 id=락-호환성-매트릭스-핵심>락 호환성 매트릭스 핵심<a hidden class=anchor aria-hidden=true href=#락-호환성-매트릭스-핵심>#</a></h4><ul><li><strong>무엇:</strong> LCM 은 &ldquo;<strong>어떤 락끼리 동시에 가능인지</strong>&rdquo; 를 미리 표로 정해둔 판정 규칙이야.</li><li><strong>왜:</strong> 요청이 들어올 때마다 <strong>즉시 블로킹 여부</strong>를 빠르게 판단해서 성능과 일관성을 동시에 잡기 위해.</li><li><strong>어떻게:</strong><ul><li>리소스가 계층 (테이블→레코드) 이라서 **의도 락 (IS/IX/SIX)**으로 상·하위 충돌을 빠르게 거른다.</li><li>범위 쿼리의 <strong>팬텀</strong>은 제품별 <strong>범위 잠금</strong>(SIREAD/키 - 범위/넥스트키) 으로 막는다.</li><li>같은 격리수준이라도 엔진이 <strong>여러 잠금 전략 중 하나</strong>를 골라 쓸 수 있다.</li></ul></li></ul><h5 id=lcm-핵심-특징-근거와-차이점>LCM 핵심 특징: 근거와 차이점<a hidden class=anchor aria-hidden=true href=#lcm-핵심-특징-근거와-차이점>#</a></h5><ol><li><p><strong>표 기반 즉시 판정</strong></p><ul><li><strong>근거:</strong> 각 DBMS 의 호환성 표/규칙 제공.</li><li><strong>차별점:</strong> 단일 뮤텍스와 달리 <strong>S/X/의도락 등 모드 조합</strong>을 구체 규칙으로 처리.</li></ul></li><li><p><strong>대칭적 호환성</strong></p><ul><li><strong>근거:</strong> 호환성 행렬은 <strong>대칭</strong>임 (고전 정리).</li><li><strong>차별점:</strong> " 요청↔보유 순서 " 와 무관하게 <strong>결과 동일</strong>—판정 단순화.</li></ul></li><li><p><strong>MGL/의도 락</strong></p><ul><li><strong>근거:</strong> IS/IX/SIX 정의와 조합 표, 에스컬레이션 규칙.</li><li><strong>차별점:</strong> 대규모 트리 구조에서 <strong>탐색·판정 비용 최소화</strong>.</li></ul></li><li><p><strong>범위 기반 잠금 (팬텀 방지)</strong></p><ul><li><strong>근거:</strong> PostgreSQL SIREAD(차단·데드락 미유발), SQL Server 키 - 범위, MySQL 넥스트키.</li><li><strong>차별점:</strong> 단순 행잠금 대비 <strong>삽입/삭제로 생기는 팬텀</strong>까지 차단.</li></ul></li><li><p><strong>엔진 선택성 (격리 충족 내 최적화)</strong></p><ul><li><strong>근거:</strong> 직렬화 격리에서도 잠금 형태는 <strong>엔진이 선택</strong>.</li><li><strong>차별점:</strong> " 격리수준=특정잠금 " 고정관념을 깨고 <strong>워크로드 적응</strong>.</li></ul></li><li><p><strong>에스컬레이션</strong></p><ul><li><strong>근거:</strong> MGL 의 승격 메커니즘.</li><li><strong>차별점:</strong> <strong>락 수/메모리</strong> 제어로 운영 안정성 확보.</li></ul></li><li><p><strong>MVCC/버저닝·OCC 와의 대비</strong></p><ul><li><strong>근거:</strong> SQL Server 락·버저닝 가이드.</li><li><strong>차별점:</strong> <strong>사전 차단 (LCM)</strong> vs <strong>사후 검증 (OCC)/버전 격리 (MVCC)</strong>.</li></ul></li></ol><h5 id=락-호환성-핵심-특징-표>락 호환성 핵심 특징 표<a hidden class=anchor aria-hidden=true href=#락-호환성-핵심-특징-표>#</a></h5><table><thead><tr><th>특징</th><th>설명 (요지)</th><th>기술적 근거</th><th>다른 기술 대비 차별점</th></tr></thead><tbody><tr><td>표 기반 즉시 판정</td><td>호환성 표로 보유/요청 조합을 상수 시간에 판정</td><td>SQL Server/PG 문서의 호환 규칙</td><td>모드 조합 규칙을 정형화 (뮤텍스 대비 정밀)</td></tr><tr><td>대칭적 호환성</td><td>호환성은 대칭 관계</td><td>Korth 정리 (행렬 대칭)</td><td>요청/보유 순서 무관 동일판정</td></tr><tr><td>MGL/의도 락</td><td>IS/IX/SIX 로 계층 충돌 빠른 차단</td><td>MGL 정의·호환성 표</td><td>대규모 트리 구조에서 탐색·판정 비용↓</td></tr><tr><td>범위 기반 잠금</td><td>팬텀 방지 위한 범위 보호</td><td>PG SIREAD, SQLS 키 - 범위, MySQL 넥스트키</td><td>행잠금만으로 못 막는 삽입/삭제 팬텀 차단</td></tr><tr><td>엔진 선택성</td><td>격리 충족 내에서 잠금 전략 선택</td><td>SQL Server 직렬화 해설</td><td>" 격리=특정잠금 " 고정관념 교정, 워크로드 적응</td></tr><tr><td>에스컬레이션</td><td>미세 락→상위 락 승격</td><td>MGL 승격 원리</td><td>락 수/메모리 제어로 안정성↑</td></tr><tr><td>MVCC/OCC 대비</td><td>비관적 제어의 핵심, 즉시 차단</td><td>락·버저닝 가이드</td><td>사전 차단 vs 사후 검증/버전 격리</td></tr></tbody></table><p>LCM 은 <strong>표 기반 판정</strong>과 **계층 제어 (MGL)**를 결합해 <strong>빠른 충돌 판정</strong>과 <strong>운영 비용 제어</strong>를 동시에 달성한다. 팬텀 방지는 <strong>제품별 범위락 전략</strong>으로 구현되며, 같은 격리수준이라도 <strong>엔진 선택성</strong>으로 잠금 패턴은 달라질 수 있다.</p><h4 id=호환성-매트릭스-읽기-sisixsixx-와-기본-파이프라인-요청판정대기해제>호환성 매트릭스 읽기 (S/IS/IX/SIX/X) 와 기본 파이프라인 (요청→판정→대기/해제)<a hidden class=anchor aria-hidden=true href=#호환성-매트릭스-읽기-sisixsixx-와-기본-파이프라인-요청판정대기해제>#</a></h4><h5 id=락-모드-핵심-요약>락 모드 핵심 요약<a hidden class=anchor aria-hidden=true href=#락-모드-핵심-요약>#</a></h5><ul><li><strong>S(Shared)</strong>: 읽기용. 다른 S 와 공존 가능.</li><li><strong>X(Exclusive)</strong>: 쓰기용. 어떤 락과도 공존 불가.</li><li><strong>IS(Intention Shared)</strong>: " 하위 레벨에서 S 를 잡을 의도 " 신호.</li><li><strong>IX(Intention Exclusive)</strong>: " 하위 레벨에서 X 를 잡을 의도 " 신호.</li><li><strong>SIX(Shared + Intention Exclusive)</strong>: 현재 노드는 S, 하위에선 일부 X 예정 (대량 읽기 + 부분 수정에 좋음).</li></ul><blockquote><p>의도 락 (IS/IX/SIX) 은 <strong>계층 (DB→스키마→테이블→페이지→행)</strong> 환경에서 " 아래에서 무슨 락을 잡을지 " 를 <strong>상위 노드에 미리 알리는 신호</strong>다.</p></blockquote><h5 id=호환성-매트릭스-읽는-법-3-단계>호환성 매트릭스 읽는 법 (3 단계)<a hidden class=anchor aria-hidden=true href=#호환성-매트릭스-읽는-법-3-단계>#</a></h5><ol><li>**요청 락 (행)**을 행 (가로줄) 에서 찾는다.</li><li>**이미 보유 중인 락 (열)**을 열 (세로줄) 에서 찾는다.</li><li><strong>모든 보유 락과 &ldquo;✔(허용)&rdquo; 이어야</strong> 부여 가능. 하나라도 &ldquo;✘(충돌)&rdquo; 이면 대기.</li></ol><table><thead><tr><th style=text-align:right>요청\보유</th><th style=text-align:center>IS</th><th style=text-align:center>IX</th><th style=text-align:center>S</th><th style=text-align:center>SIX</th><th style=text-align:center>X</th></tr></thead><tbody><tr><td style=text-align:right><strong>IS</strong></td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✘</td></tr><tr><td style=text-align:right><strong>IX</strong></td><td style=text-align:center>✔</td><td style=text-align:center>✔</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td></tr><tr><td style=text-align:right><strong>S</strong></td><td style=text-align:center>✔</td><td style=text-align:center>✘</td><td style=text-align:center>✔</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td></tr><tr><td style=text-align:right><strong>SIX</strong></td><td style=text-align:center>✔</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td></tr><tr><td style=text-align:right><strong>X</strong></td><td style=text-align:center>✘</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td><td style=text-align:center>✘</td></tr></tbody></table><p><strong>빠른 감각</strong></p><ul><li><strong>IS/IX 끼리는 대체로 호환</strong>(신호만 보내는 수준).</li><li><strong>S/X/SIX 는 실제 데이터 충돌에 민감</strong>해 호환성이 낮다.</li><li><strong>X 는 최강</strong>—거의 전부와 충돌.</li></ul><h5 id=계층적-잠금-mgl-에서의-적용-규칙>계층적 잠금 (MGL) 에서의 적용 규칙<a hidden class=anchor aria-hidden=true href=#계층적-잠금-mgl-에서의-적용-규칙>#</a></h5><ul><li><strong>상위→하위 순서로</strong> 의도 락부터: 예) 행에 X 를 잡고 싶다면 DB/스키마/테이블에 <strong>IX→…→행 X</strong>.</li><li>상위 노드에서 <strong>IS↔IX 는 호환</strong>이므로 서로 다른 트랜잭션이 같은 테이블에서 " 읽기용 하위 락 " 과 " 쓰기용 하위 락 " 을 <strong>서로 다른 범위</strong>에서 동시에 진행할 수 있다.</li></ul><h5 id=기본-파이프라인-요청판정대기해제>기본 파이프라인 (요청→판정→대기/해제)<a hidden class=anchor aria-hidden=true href=#기본-파이프라인-요청판정대기해제>#</a></h5><pre class=mermaid>flowchart TD
    A[&#34;락 요청(M on R)&#34;] --&gt; B{보유 락 존재?}
    B -- NO --&gt; C[&#34;Grant(즉시 부여)&#34;]
    B -- YES --&gt; D[호환성 매트릭스 검사]
    D -- 호환 ✔ --&gt; C
    D -- 충돌 ✘ --&gt; E[대기 큐 등록]
    E --&gt; F{데드락 탐지/예방}
    F -- 사이클 발견 --&gt; G[희생 TX 롤백]
    F -- 미발견 --&gt; H[기존 락 해제 대기]
    C --&gt; I[작업 수행]
    I --&gt; J{업그레이드/에스컬 필요?}
    J -- YES --&gt; D
    J -- NO --&gt; K[커밋/롤백]
    K --&gt; L[보유 락 해제]
    L --&gt; M[대기 큐 재평가·가능 요청 Grant]
</pre><p><strong>설명 포인트</strong></p><ul><li><strong>Grant</strong>는 " 요청 락이 현재 보유 락들과 전부 호환 " 일 때.</li><li><strong>충돌</strong>이면 <strong>대기 큐</strong>로 들어가고, 시스템은 <strong>데드락 탐지</strong>(또는 예방 규칙) 로 사이클을 끊는다.</li><li>작업 중 **락 업그레이드 (S→X 등)**나 <strong>에스컬레이션 (여러 행→테이블)</strong> 요청이 오면 <strong>다시 매트릭스 검사</strong>를 거친다.</li><li>트랜잭션 종료 시 <strong>해제→대기 큐 재평가</strong>로 다음 요청이 깨어난다.</li></ul><h5 id=미니-시나리오>미니 시나리오<a hidden class=anchor aria-hidden=true href=#미니-시나리오>#</a></h5><ul><li><strong>T1</strong>: <code>Orders</code> 일부 행 <strong>업데이트</strong><ul><li>상위 노드에 <strong>IX</strong>, 타깃 행에 <strong>X</strong> 요청.</li></ul></li><li><strong>T2</strong>: <code>Orders</code> <strong>풀 스캔 읽기</strong><ul><li>상위 노드에 <strong>IS</strong>, 각 범위/행에 <strong>S</strong> 요청.</li></ul></li><li><strong>판정</strong>: 테이블 수준 **IS(읽기 의도) ↔ IX(쓰기 의도)**는 <strong>호환</strong> → 두 TX 는 <strong>겹치지 않는 범위</strong>에서는 <strong>동시에 진행</strong>. 실제 충돌은 <strong>같은 행/키 - 레인지</strong>에서만 발생.</li></ul><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=락-호환성의-원칙과-철학>락 호환성의 원칙과 철학<a hidden class=anchor aria-hidden=true href=#락-호환성의-원칙과-철학>#</a></h4><ul><li><strong>무엇</strong>: 호환성 매트릭스는 " 지금 누가 어떤 락을 잡았을 때, 다른 락을 줄 수 있는가?&rdquo; 를 표로 정한 <strong>운영 규칙</strong>.</li><li><strong>핵심 생각</strong>:<ul><li>가능한 한 <strong>약한 락</strong>으로 <strong>동시성</strong>을 크게 하고 (최소 제한),</li><li>모든 판단은 <strong>표에 근거</strong>해 <strong>즉시·일관</strong>되게 하며 (명시적 규칙),</li><li><strong>의도 락</strong>으로 상·하위 자원 간 <strong>약속</strong>을 먼저 하고 (계층적 일관성),</li><li>필요하면 <strong>키 - 범위 락</strong>으로 범위까지 보호해 팬텀을 막는다 (범위 무결성).</li><li>스케줄의 안전한 직렬가능성은 <strong>2PL/Strict 2PL</strong> 같은 프로토콜과 <strong>함께</strong> 달성한다 (프로토콜 일관성).</li></ul></li></ul><h5 id=락-호환성-핵심-원칙-일람표>락 호환성 핵심 원칙 일람표<a hidden class=anchor aria-hidden=true href=#락-호환성-핵심-원칙-일람표>#</a></h5><table><thead><tr><th>원칙</th><th>목적</th><th>왜 필요한가 (요지)</th><th>근거</th></tr></thead><tbody><tr><td>최소 제한</td><td>동시성 최대화</td><td>불필요한 직렬화 감소, 처리량/응답성 향상</td><td>PostgreSQL: " 가장 덜 제한적인 모드 " 자동 선택</td></tr><tr><td>명시적 호환성</td><td>결정론적 판정</td><td>예측 가능·디버깅 용이·표준화</td><td>SQL Server 문서/서적의 호환성 매트릭스</td></tr><tr><td>계층적 일관성</td><td>자원 계층 합치</td><td>의도 락으로 상·하위 계획 공유, 광역 충돌 축소</td><td>MGL, InnoDB 의도 락</td></tr><tr><td>프로토콜 일관성</td><td>직렬가능성 보장</td><td>매트릭스 +2PL/Strict 2PL 결합 필요</td><td>2PL/Strict 2PL 문헌/논문</td></tr><tr><td>범위 무결성</td><td>팬텀 방지</td><td>범위 질의 일관성 확보 (Serializable 등)</td><td>키 - 범위 락 호환성 표</td></tr></tbody></table><p>핵심은 **" 약하게, 명시적으로, 계층적으로, 프로토콜과 함께, 필요 시 범위까지 &ldquo;**다.<br>이 다섯 축이 조합되어 <strong>높은 동시성과 강한 무결성</strong>을 동시에 달성한다.</p><h5 id=락-호환성-설계-철학-일람표>락 호환성 설계 철학 일람표<a hidden class=anchor aria-hidden=true href=#락-호환성-설계-철학-일람표>#</a></h5><table><thead><tr><th>설계 철학</th><th>설명</th><th>목적</th><th>왜 필요한가</th><th>근거</th></tr></thead><tbody><tr><td>충분히 허용·안전 방지</td><td>읽기=S, 쓰기=X 로 충돌만 차단</td><td>읽기 병렬화·쓰기 무결성</td><td>OLTP 에서 동시성·일관성 균형</td><td>S/X 개념 정리 문헌</td></tr><tr><td>명시적 규칙 기반</td><td>호환성 표를 단일 규칙으로 사용</td><td>예측 가능·자동화</td><td>제품/옵션 차이를 규칙 표로 캡슐화</td><td>SQL Server 호환성 표</td></tr><tr><td>계층·신호 기반</td><td>의도 락으로 상·하위 계획 공유</td><td>대규모에서도 성능 유지</td><td>광역 충돌·탐색 비용 최소화</td><td>MGL·InnoDB 의도 락</td></tr></tbody></table><p>세 철학은 각각 <strong>병렬성</strong>, <strong>예측 가능성</strong>, <strong>확장성</strong>을 책임진다.<br>셋이 맞물릴 때 복잡한 워크로드에서도 <strong>일관된 성능·안정성</strong>이 나온다.</p><h4 id=호환성-매트릭스로-여는-락-동작의-모든-것>호환성 매트릭스로 여는 락 동작의 모든 것<a hidden class=anchor aria-hidden=true href=#호환성-매트릭스로-여는-락-동작의-모든-것>#</a></h4><ul><li><strong>무엇을 결정하나?</strong><br>" 이 락과 저 락이 <strong>같이 있어도 되는가?</strong>&rdquo; 를 <strong>호환성 매트릭스</strong>로 즉시 결정한다. 예) S↔S <strong>허용</strong>, S↔X·X↔X <strong>거부</strong>.</li><li><strong>충돌 나면?</strong><br>대기 큐에서 <strong>순번 대기</strong>. 오래 멈춰 있으면 시스템이 <strong>데드락 탐지</strong>(또는 예방 규칙 적용) 로 한 트랜잭션을 <strong>중단</strong>해 막힌 고리를 푼다.</li><li><strong>계층 구조는?</strong><br>테이블·페이지·행 같은 <strong>계층 자원</strong>에선 <strong>의도 락</strong>으로 " 하위에서 잠글 의도 " 를 상위에 알려 <strong>빠른 판정과 안전한 에스컬레이션</strong>을 가능하게 한다.</li></ul><h5 id=기본-동작-원리-및-메커니즘>기본 동작 원리 및 메커니즘<a hidden class=anchor aria-hidden=true href=#기본-동작-원리-및-메커니즘>#</a></h5><ol><li><strong>락 요청·조회</strong>: T 가 R 에 모드 M 을 요청하면 락 관리자는 <strong>락 테이블</strong>(자원별 보유·대기 현황) 과 <strong>자원별 대기 큐</strong>를 조회한다.</li><li><strong>호환성 판정</strong>: <strong>매트릭스</strong>로 현재 보유 락들과의 <strong>전원 호환</strong>일 때만 부여. S↔S 는 허용, S↔X·X↔X 는 거부가 대표 규칙.</li><li><strong>대기·스케줄링</strong>: 불허 시 <strong>대기 큐</strong>에 넣고, 해제 신호가 오면 <strong>재평가→부여</strong>. 구현별로 <strong>FIFO/우선순위/락 변환 대기</strong> 등 세부 정책이 다를 수 있다.</li><li><strong>MGL·의도 락</strong>: 계층 자원에서는 <strong>상위→하위 순서</strong>로 <strong>IS/IX/SIX</strong>를 먼저 확보해 충돌을 상위에서 빠르게 탐지하고, 필요 시 <strong>에스컬레이션</strong>을 안전하게 수행한다.</li><li><strong>데드락 처리</strong>:<ul><li><strong>탐지 방식</strong>: 예를 들어 Postgres 는 일정 시간 대기 후 <strong>waits-for 그래프</strong>를 검사해 순환이 있으면 <strong>한 트랜잭션을 중단</strong>한다. SQL Server 는 <strong>Lock Monitor</strong>가 **주기 (기본 5 초)**로 탐지한다.</li><li><strong>예방 방식</strong>: <strong>Wait-Die/Wound-Wait</strong>처럼 타임스탬프 우선순위 규칙을 적용하면 <strong>사이클을 사전에 차단</strong>할 수 있다.</li></ul></li><li><strong>팬텀 대응 (필요 시)</strong>: 인덱스 범위를 동시 보호해야 하면 InnoDB 처럼 <strong>넥스트 - 키 락</strong>(레코드 + 앞 갭) 을 사용해 <strong>삽입 팬텀</strong>까지 막는다.</li></ol><h5 id=락-메커니즘-구성요소-한눈에-보기>락 메커니즘 구성요소 한눈에 보기<a hidden class=anchor aria-hidden=true href=#락-메커니즘-구성요소-한눈에-보기>#</a></h5><table><thead><tr><th>구성요소</th><th>역할</th><th>핵심 판정/정책</th><th>구현 사례·근거</th></tr></thead><tbody><tr><td><strong>락 테이블/큐</strong></td><td>자원별 보유/대기 상태 관리</td><td>자원별 <strong>대기 큐</strong> 유지, 해제 시 <strong>재평가</strong></td><td>PostgreSQL Explicit Locking 문서 흐름과 합치</td></tr><tr><td><strong>호환성 매트릭스</strong></td><td>허용/거부 즉시 판정</td><td>S↔S 허용, S↔X·X↔X 거부 (기본)</td><td>공식 문서의 충돌 표와 일치</td></tr><tr><td><strong>MGL·의도 락 (IS/IX/SIX)</strong></td><td>계층 자원에서 빠른 충돌 판정·에스컬레이션 안전화</td><td><strong>상위→하위 순차 취득</strong>, <strong>SIX</strong>로 대량 읽기 + 부분 쓰기 최적화</td><td>Gray 의 그레뉼러리티 논문 계열</td></tr><tr><td><strong>데드락 탐지</strong></td><td>교착 순환 발생 시 처리</td><td>Postgres: <strong>지연 후 탐지</strong> / SQL Server: <strong>주기 탐지 (≈5 초)</strong></td><td>설정·가이드 명시</td></tr><tr><td><strong>데드락 예방</strong></td><td>사이클 자체 회피</td><td><strong>Wait-Die / Wound-Wait</strong>(타임스탬프 우선순위)</td><td>CMU 15-445 강의 노트</td></tr><tr><td><strong>락 에스컬레이션</strong></td><td>미세 락→상위 락 전환으로 오버헤드 감소</td><td>조건/임계치 기반 (예: SQL Server)</td><td>MS 문서·사례 정리 다수</td></tr><tr><td><strong>범위 잠금</strong></td><td>팬텀 방지</td><td><strong>넥스트 - 키/갭 락</strong>으로 인덱스 범위 보호</td><td>InnoDB 공식 문서</td></tr></tbody></table><ul><li><strong>판정의 핵</strong>은 언제나 <strong>호환성 매트릭스</strong>다. MGL 에선 의도 락으로 <strong>상위에서 빠른 판정</strong>이 가능해진다. 데드락은 <strong>탐지</strong> 또는 <strong>예방 규칙</strong>으로 해결한다. 팬텀을 다뤄야 할 때는 <strong>범위 잠금</strong>을 병행한다. ([PostgreSQL][1])</li></ul><h5 id=락-요청에서-해제까지의-전체-흐름>락 요청에서 해제까지의 전체 흐름<a hidden class=anchor aria-hidden=true href=#락-요청에서-해제까지의-전체-흐름>#</a></h5><pre class=mermaid>flowchart TD
    %% 7.1 보완 반영: 데드락 탐지 타이머, 예방 규칙, 에스컬레이션/변환 경로 포함
    A[트랜잭션 T가 자원 R에 모드 M 요청] --&gt; B{자원 R에 보유 락 존재?}
    B -- NO --&gt; C[Grant: 락 부여]
    B -- YES --&gt; D[호환성 매트릭스 검사]
    D -- 호환 --&gt; C
    D -- 비호환 --&gt; E{정책 선택}
    E -- 대기정책 --&gt; F[자원별 대기 큐 등록]
    E -- 예방정책 --&gt; G{Wait-Die/Wound-Wait}
    G -- 대기 허용 --&gt; F
    G -- 중단/선점 --&gt; H[희생TX Abort·Rollback]
    F --&gt; I[대기]
    I --&gt; J{deadlock_timeout/주기적 탐지}
    J -- 데드락 검출 --&gt; H
    J -- 미검출 --&gt; I
    C --&gt; K[작업 수행]
    K --&gt; L{&#34;락 변환 필요? (업그레이드/SIX 등)&#34;}
    L -- YES --&gt; M[호환성 재검사·변환 시도]
    L -- NO --&gt; N[정상 진행]
    M -- 성공 --&gt; N
    M -- 실패 --&gt; F
    N --&gt; O{에스컬레이션 임계치 초과?}
    O -- YES --&gt; P[상위 락으로 에스컬레이션]
    O -- NO --&gt; Q[계속]
    Q --&gt; R[커밋/롤백 시 해제]
    P --&gt; R
    R --&gt; S[대기 큐 재평가·가능한 요청 부여]
</pre><ul><li><strong>핵심 분기점</strong>은 &ldquo;<strong>호환성 매트릭스 검사</strong>&rdquo; 와 &ldquo;<strong>정책 선택 (대기 vs 예방 규칙)</strong>&rdquo; 이다. Postgres 처럼 <strong>지연 후 데드락 탐지</strong>를 두거나 (SQL Server 는 주기적 Lock Monitor) 예방 규칙 (Wait-Die/Wound-Wait) 로 <strong>사이클을 사전 차단</strong>할 수 있다. 대량 미세 락이 누적되면 <strong>에스컬레이션</strong>으로 오버헤드를 줄인다.</li></ul><h4 id=호환성-매트릭스로-설계하는-락-처리>호환성 매트릭스로 설계하는 락 처리<a hidden class=anchor aria-hidden=true href=#호환성-매트릭스로-설계하는-락-처리>#</a></h4><p>애플리케이션이 데이터를 만지려면 먼저 락을 " 요청 " 하고, 락 관리자는 현재 잡혀 있는 락과의 " 호환성 표 " 를 보고 허용할지 판단한다.<br>되면 바로 " 부여 &ldquo;, 안 되면 " 대기 " 로 보낸다.<br>트랜잭션이 끝나면 락을 " 해제 " 하고, 기다리던 요청을 깨운다.<br>테이블–행 같은 계층 구조에서는 먼저 상위에 의도락을 걸고 하위에 실제 락을 건다.<br>직렬화 격리에서는 키 - 범위 규칙을 함께 적용한다.</p><h5 id=락-데이터제어-흐름-한눈에-보기>락 데이터·제어 흐름 한눈에 보기<a hidden class=anchor aria-hidden=true href=#락-데이터제어-흐름-한눈에-보기>#</a></h5><ul><li>단계: 요청 → 의도락 선취 → 호환성 검사 → 부여/대기/거부 → 대기 관리 (데드락/타임아웃/에스컬레이션) → 해제·깨우기.</li><li>판단 축: 모드 (S/X/U), 그라뉼러리티, 격리수준 (특히 직렬화의 키 - 범위), 현재 점유 현황.</li><li>산출: 락 상태 변화 (Granted/Waiting/Aborted/Released) 와 시스템 메트릭 (대기시간, 타임아웃 수).</li></ul><h5 id=락-데이터제어-흐름-단계별-정리>락 데이터·제어 흐름 단계별 정리<a hidden class=anchor aria-hidden=true href=#락-데이터제어-흐름-단계별-정리>#</a></h5><table><thead><tr><th>단계</th><th>입력/상태</th><th>핵심 로직 (의사결정)</th><th>산출/다음 상태</th><th>관련 포인트</th></tr></thead><tbody><tr><td>요청</td><td>Txn ID, 객체, 모드, 격리수준</td><td>상위 노드 의도락 (IS/IX/SIX) 필요 여부 판단</td><td>의도락 요청 또는 락 테이블 조회</td><td>다중 그라뉼러리티</td></tr><tr><td>호환성 검사</td><td>현재 보유 락 목록</td><td>매트릭스·격리수준 적용해 Compatible/Conflict</td><td>부여 또는 대기 큐 삽입</td><td>키 - 범위 (직렬화)</td></tr><tr><td>결정</td><td>Compatible</td><td>락 부여, 소유자 목록 갱신</td><td>Granted → 작업 실행</td><td>공유/배타 원칙</td></tr><tr><td>결정</td><td>Conflict</td><td>대기 큐 삽입, Wait-for 에지 추가</td><td>Waiting</td><td>데드락 가능성</td></tr><tr><td>관리</td><td>Waiting</td><td>데드락 탐지/타임아웃/에스컬레이션</td><td>Aborted 또는 Granted</td><td>DMV/모니터링</td></tr><tr><td>해제</td><td>커밋/롤백 또는 2PL 수축</td><td>소유 락 해제, 대기자 깨우기</td><td>Released → 다음 대기자 재평가</td><td>2PL 수축</td></tr></tbody></table><h5 id=호환성-기반-락-처리-플로우>호환성 기반 락 처리 플로우<a hidden class=anchor aria-hidden=true href=#호환성-기반-락-처리-플로우>#</a></h5><pre class=mermaid>flowchart TD
  A[Txn 시작] --&gt; B[자원 접근 필요]
  B --&gt; C[&#34;락 요청 생성&lt;br/&gt;(객체, 모드, 격리, 그라뉼러리티)&#34;]
  C --&gt; D{의도락 필요?}
  D -- 예 --&gt; D1[상위 노드 IS/IX/SIX 선취]
  D -- 아니오 --&gt; E[락 테이블 조회]
  D1 --&gt; E
  E --&gt; F{매트릭스 호환?}
  F -- 예 --&gt; G[Grant: 소유자 목록 갱신]
  G --&gt; H[연산 수행]
  H --&gt; I{커밋/롤백 또는 2PL 수축?}
  I -- 아니오 --&gt; B
  I -- 예 --&gt; J[Release: 보유 락 해제]
  J --&gt; K[&#34;대기 큐 깨우기(FIFO/우선순위)&#34;]
  K --&gt; E
  F -- 아니오 --&gt; L[대기 큐 삽입, Wait-for 에지 추가]
  L --&gt; M{데드락/타임아웃?}
  M -- 데드락/만료 --&gt; N[Victim abort 및 롤백]
  N --&gt; J
  M -- 없음 --&gt; L
</pre><p>요청 시 상위 노드 의도락을 통해 하위 잠금 의도를 알리고, 호환성 매트릭스가 즉시 부여 여부를 판정한다. 충돌 시 대기 큐에 넣고 Wait-for 그래프를 갱신해 데드락을 탐지한다. 커밋/롤백에서 락을 해제하고 대기자에게 기회를 준다. 직렬화 격리에서는 키 - 범위 규칙이 F 의 판정에 영향을 준다.</p><h5 id=락-상태-전이와-운영-이벤트>락 상태 전이와 운영 이벤트<a hidden class=anchor aria-hidden=true href=#락-상태-전이와-운영-이벤트>#</a></h5><pre class=mermaid>stateDiagram-v2
  [*] --&gt; Requested: 락 요청 도착
  Requested --&gt; Granted: 호환성=예
  Requested --&gt; Waiting: 호환성=아니오
  Waiting --&gt; Aborted: 데드락 감지/타임아웃
  Waiting --&gt; Granted: 선행 락 해제
  Granted --&gt; Escalating: 임계치 초과(행→페이지/테이블)
  Escalating --&gt; Granted: 에스컬레이션 성공
  Granted --&gt; Released: 커밋/롤백(2PL 수축)
  Released --&gt; [*]
  Aborted --&gt; [*]
</pre><p>기본 Requested–Granted–Waiting–Released 에 운영 이벤트 (에스컬레이션·타임아웃·데드락) 를 반영했다. 2PL 수축 단계에서 Released 로 전이되며, 에스컬레이션은 대기·경합 비용을 낮추려는 운영적 선택이다.</p><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=lcm-으로-성능과-정합성을-동시에>LCM 으로 성능과 정합성을 동시에<a hidden class=anchor aria-hidden=true href=#lcm-으로-성능과-정합성을-동시에>#</a></h4><ul><li><strong>무엇</strong>: LCM 은 &ldquo;<strong>어떤 락끼리 동시에 가능한지</strong>&rdquo; 를 미리 표로 정해 둔 규칙.</li><li><strong>왜 유용</strong>: 요청 순간 <strong>허용/대기</strong>를 즉시 판정해 <strong>처리량↑·오류↓</strong>.</li><li><strong>어떻게</strong>:<ul><li>리소스가 계층이라 **의도락 (IS/IX/SIX)**로 상·하위 충돌을 빠르게 거르고,</li><li>범위 질의의 <strong>팬텀</strong>은 제품별 <strong>범위락</strong>(키 - 범위/넥스트키/프레디케이트) 으로 막는다.</li><li>2PL 과 결합해 <strong>무결성/격리</strong>를 체계적으로 달성한다.</li></ul></li></ul><h5 id=lcm-장점효과-한눈에-보기>LCM 장점·효과 한눈에 보기<a hidden class=anchor aria-hidden=true href=#lcm-장점효과-한눈에-보기>#</a></h5><table><thead><tr><th>장점</th><th>상세 설명</th><th>기술 근거</th><th>적용 상황</th><th>실무 효과</th></tr></thead><tbody><tr><td>동시성 최적화</td><td>호환 조합은 즉시 승인, 불필요 대기 최소화</td><td>SQL Server/PG 호환성 표</td><td>읽기 집약·혼합 워크로드</td><td>QPS·동시 사용자↑</td></tr><tr><td>무결성/격리</td><td>2PL+LCM 으로 Dirty/Lost Update 차단</td><td>15-445 2PL 노트</td><td>금융/재고/결제</td><td>정합성·신뢰성 확보</td></tr><tr><td>예측 가능성</td><td>표 기반 규칙으로 성능/대기 예측 용이</td><td>락/버저닝 가이드</td><td>성능 점검·리뷰</td><td>디버깅·튜닝 시간↓</td></tr><tr><td>확장성 (MGL)</td><td>IS/IX/SIX·에스컬레이션으로 자원 제어</td><td>InnoDB 의도락·MGL</td><td>대규모 DML/배치</td><td>락 수·메모리 관리</td></tr><tr><td>팬텀 방지</td><td>범위 기반 잠금 (키 - 범위/넥스트키/SIREAD)</td><td>각 제품 문서</td><td>직렬성 요구 범위 질의</td><td>논리 오류 제거</td></tr><tr><td>자동 충돌/데드락</td><td>엔진이 그랜트/대기/롤백 자동 판단</td><td>SQL Server 가이드, 2PL</td><td>고동시성 트랜잭션</td><td>운영 비용↓, 안정성↑</td></tr><tr><td>엔진 선택성</td><td>격리 준수 내 잠금 전략 최적화</td><td>SQL Server 가이드</td><td>혼합 워크로드</td><td>성능 - 정합성 균형 최적화</td></tr></tbody></table><p>LCM 은 <strong>표 기반 즉시 판정</strong>을 중심축으로, <strong>MGL/의도락·범위락·2PL</strong>을 결합해 <strong>처리량을 높이면서도 정합성을 지키는</strong> 구조다. 제품별 범위락의 차이는 있지만 목표는 동일하며, 엔진은 같은 격리수준 안에서도 <strong>전략을 상황에 맞게 선택</strong>한다.</p><h4 id=락-호환성의-한계와-대응-전략>락 호환성의 한계와 대응 전략<a hidden class=anchor aria-hidden=true href=#락-호환성의-한계와-대응-전략>#</a></h4><ul><li>락 호환성 매트릭스는 <strong>충돌을 막는 강력한 규칙표</strong>지만, <strong>경합·대기/데드락/오버헤드/복잡성</strong>을 동반한다.</li><li><strong>직렬가능성</strong>을 원하면 보통 <strong>2PL/Strict 2PL</strong>을 함께 지켜야 하며, 이때 <strong>데드락</strong>이 생길 수 있다.</li><li><strong>팬텀</strong>을 막으려면 <strong>키 - 범위/넥스트키 락</strong>처럼 범위를 보호하는 락이 필요하다.</li><li><strong>실시간·대규모 분산</strong> 요구가 강하면, <strong>우선순위 역전/중앙 병목</strong> 문제를 고려해 <strong>분산 락·락프리·MVCC</strong> 등과 병행 설계한다.</li></ul><h5 id=락-호환성의-본질적-단점-일람표>락 호환성의 본질적 단점 일람표<a hidden class=anchor aria-hidden=true href=#락-호환성의-본질적-단점-일람표>#</a></h5><table><thead><tr><th>단점</th><th>설명</th><th>원인</th><th>실무 문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>경합·대기</td><td>충돌 시 대기·타임아웃 증가</td><td>비호환 락 경쟁</td><td>TPS 저하·장애성 타임아웃</td><td>인덱스/쿼리 재설계, 파티셔닝, 스냅샷 읽기 병행</td><td>MVCC, 낙관적 동시성</td></tr><tr><td>데드락</td><td>상호 대기로 진행 정지</td><td>2PL 락 순서 불일치</td><td>롤백·장애 알림</td><td>락 순서 표준화, 짧은 트랜잭션, 탐지/타임아웃</td><td>낙관적/타임스탬프 기법</td></tr><tr><td>복잡성 증가</td><td>모드·계층·규칙 증가</td><td>다중 모드/계층 설계</td><td>설계·테스트 난이도↑</td><td>표준 모드 사용, 문서화·교육</td><td>단순화된 버저닝 활용</td></tr><tr><td>오버헤드</td><td>락/대기열/탐지 비용</td><td>락 관리·모니터링</td><td>메모리/CPU 부담</td><td>락 수 절감, 파라미터 튜닝, 모니터링 (pg_locks)</td><td>RCU/락프리, MVCC</td></tr><tr><td>에스컬레이션 부작용</td><td>광범위 잠금으로 동시성↓</td><td>임계치·메모리 보호 정책</td><td>대규모 블로킹</td><td>임계치 조정, 파티셔닝·슬라이싱</td><td>파인 그래뉼러리티 유지</td></tr><tr><td>굶주림/우선순위 역전</td><td>특정 트랜잭션 지속 밀림</td><td>락 큐·우선순위 충돌</td><td>응답시간 편차·SLO 위반</td><td>우선순위 상속/큐 정책</td><td>RT 친화 락프리/RCU</td></tr></tbody></table><p>핵심 리스크는 <strong>경합·교착·오버헤드·복잡성</strong>이며, <strong>에스컬레이션</strong>과 <strong>우선순위 역전</strong>이 상황을 악화시킨다. 완화는 <strong>쿼리/인덱스 재설계·파티셔닝·정책 튜닝·모니터링</strong>과 <strong>버저닝·낙관적 기법</strong> 병행이 효과적이다.</p><h5 id=락-호환성의-구조적-제약-일람표>락 호환성의 구조적 제약 일람표<a hidden class=anchor aria-hidden=true href=#락-호환성의-구조적-제약-일람표>#</a></h5><table><thead><tr><th>제약사항</th><th>설명</th><th>원인</th><th>영향</th><th>해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>2PL 의존성</td><td>직렬가능성 위해 2PL/Strict 2PL 필요</td><td>규칙표만으로 스케줄 보장 한계</td><td>설계 제약·지연·교착</td><td>2PL 준수·락 순서·짧은 트랜잭션</td><td>SI/MVCC·타임스탬프</td></tr><tr><td>범위 무결성</td><td>팬텀 방지엔 범위 락 필요</td><td>삽입/삭제로 읽기집합 변동</td><td>Serializable 미달</td><td>키 - 범위/넥스트키 적용·인덱스</td><td>SSI 등 고급 격리</td></tr><tr><td>중앙 병목</td><td>단일 락 관리자 병목·SPOF</td><td>모든 요청 집결</td><td>확장성·가용성 저하</td><td>분산 락 매니저·샤딩</td><td>ZooKeeper/etcd/Chubby 연계</td></tr><tr><td>실시간 부적합</td><td>대기·역전으로 지연 비결정</td><td>락 기반 블로킹</td><td>데드라인 위반</td><td>우선순위 상속/ceiling</td><td>락프리/RCU·RT DB 기법</td></tr><tr><td>제품별 차이</td><td>모드/호환성/정책 상이</td><td>벤더 설계 차이</td><td>이식성·예측 난이도↑</td><td>벤더 문서 준수·추상화</td><td>CQRS/폴리글랏 저장소</td></tr></tbody></table><p><strong>직렬가능성 (2PL), 범위 일관성, 중앙 병목, RT 요구, 제품별 차이</strong>가 구조적 제약이다. 해결은 <strong>프로토콜 준수·범위락·분산화·RT 기법·추상화</strong> 조합으로 접근한다.</p><h4 id=락-트레이드오프의-전략적-설계>락 트레이드오프의 전략적 설계<a hidden class=anchor aria-hidden=true href=#락-트레이드오프의-전략적-설계>#</a></h4><ul><li><strong>작게 잠그면</strong> 많이 동시에 일함 (동시성↑) 대신 관리비와 데드락 위험이 늘 수 있다. <strong>크게 잠그면</strong> 반대로 단순·저비용이지만 서로 기다리게 된다. 이 기본 축에서 <strong>모드 강도</strong>(S/IS ↔ X/SIX), <strong>범위 보장</strong>, <strong>데드락 정책</strong>, <strong>에스컬레이션</strong>을 조합해 워크로드에 맞춘다.</li></ul><h5 id=락-선택의-양면성과-의사결정-기준>락 선택의 양면성과 의사결정 기준<a hidden class=anchor aria-hidden=true href=#락-선택의-양면성과-의사결정-기준>#</a></h5><table><thead><tr><th>축</th><th>선택 A</th><th>장점 (A)</th><th>단점 (A)</th><th>선택 B</th><th>장점 (B)</th><th>단점 (B)</th><th>트레이드오프/기준</th></tr></thead><tbody><tr><td>락 단위</td><td><strong>행/키 수준</strong></td><td>동시성↑, 충돌 국소화</td><td>락 수↑, 메모리/관리비↑, 데드락 위험↑</td><td><strong>테이블 수준</strong></td><td>관리 단순, 오버헤드↓</td><td>동시성↓, 대기 증가</td><td>트래픽 패턴·메모리 여유·핫스팟 분포.</td></tr><tr><td>락 모드</td><td><strong>S/IS</strong></td><td>읽기 병행↑</td><td>쓰기와 충돌, 갱신 지연</td><td><strong>X/SIX</strong></td><td>갱신 안전·일관성↑</td><td>동시성↓, 차단↑</td><td>읽기: 쓰기 비율·서비스 SLO.</td></tr><tr><td>범위 보장</td><td><strong>없음/최소</strong></td><td>읽기 성능↑, 차단↓</td><td>팬텀 가능</td><td><strong>키 - 레인지 (넥스트 - 키)</strong></td><td>팬텀 차단, 직렬화 용이</td><td>스캔 차단·성능↓</td><td>팬텀 민감도·인덱스 설계.</td></tr><tr><td>데드락</td><td><strong>탐지 위주</strong></td><td>동시성 유지, 유연</td><td>탐지 오버헤드, 롤백 발생</td><td><strong>예방 (Wait-Die/Wound-Wait)</strong></td><td>데드락 원천 차단</td><td>보수적 중단·기아 위험 관리 필요</td><td>충돌 빈도·응답시간 목표.</td></tr><tr><td>에스컬레이션</td><td><strong>사용</strong></td><td>락 수↓, 메모리 안정</td><td>동시성 급감 가능</td><td><strong>비활성/보수적</strong></td><td>동시성 유지</td><td>메모리/메타락 부담</td><td>테이블 크기·락 임계·엔진 정책.</td></tr></tbody></table><ul><li><strong>작게 + 약하게 + 범위 최소</strong>는 처리량 최적화에 유리하지만, <strong>데드락/관리비</strong>가 댓가다.</li><li><strong>크게 + 강하게 + 범위 보장</strong>은 일관성을 단단히 지키지만, <strong>대기·차단</strong>이 늘어난다.</li><li>운영에서는 <strong>에스컬레이션/예방 정책</strong>을 섞어 <strong>동시성–안정성</strong>의 균형점을 찾는다.</li></ul><h5 id=락-하이브리드-패턴과-적용-포인트>락 하이브리드 패턴과 적용 포인트<a hidden class=anchor aria-hidden=true href=#락-하이브리드-패턴과-적용-포인트>#</a></h5><table><thead><tr><th>하이브리드</th><th>구성 요소</th><th>적용 목적 (해결 트레이드오프)</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td><strong>MGL + 적응형 에스컬레이션</strong></td><td>행/페이지 락 + 임계 도달 시 테이블 락 승격</td><td>동시성 vs 관리비</td><td>평시 동시성↑, 피크 시 메모리 안정</td><td>승격 순간 차단폭↑·임계치 튜닝 필수.</td></tr><tr><td><strong>버전화 읽기 + 필요 시 범위락</strong></td><td>행 버전화 (ROW VERSIONING) + 직렬화 구간에만 레인지/테이블 LOCK</td><td>읽기 성능 vs 팬텀 방지</td><td>읽기 비차단·핵심 구간만 강보호</td><td>격리수준 혼용 시 일관성 규칙 명확화.</td></tr><tr><td><strong>예방 (Wait-Die/Wound-Wait) + 탐지 보조</strong></td><td>타임스탬프 우선순위 + 주기적 waits-for 탐지/타임아웃</td><td>데드락 제로 vs 불필요 중단</td><td>사이클 감소·잔여 케이스 신속 해소</td><td>재시도 폭주/기아 방지 정책 필요.</td></tr><tr><td><strong>인덱스 설계 + 넥스트 - 키 최소화</strong></td><td>선택도 높은 인덱스·조건 최적화로 스캔 폭 축소</td><td>범위락 비용 vs 팬텀 방지</td><td>잠금 범위·시간 단축</td><td>설계 품질에 민감, 실행계획 관찰 필요.</td></tr></tbody></table><ul><li>하이브리드는 <strong>매트릭스의 원리</strong>는 그대로 두고 <strong>정책 조합</strong>으로 균형을 맞춘다.</li><li>에스컬레이션·버전화·예방/탐지의 조합은 <strong>워크로드·SLO·자원 한계</strong>에 맞춰 조율한다.</li></ul><h4 id=업무-특성으로-판단하는-락-적용성>업무 특성으로 판단하는 락 적용성<a hidden class=anchor aria-hidden=true href=#업무-특성으로-판단하는-락-적용성>#</a></h4><p>데이터 정합성이 매우 중요한 시스템은 락 호환성 표를 기준으로 어떤 조합을 동시에 허용할지 설계하면 안전하다. 반대로 초저지연이나 폭주 쓰기처럼 잠금 대기가 치명적인 경우에는 MVCC 스냅샷이나 낙관적 검증 (OCC) 등 잠금을 최소화하는 방법이 더 맞다. 필요에 따라 읽기는 버전닝, 범위 보장은 키 - 범위 락으로 결합한다. ([PostgreSQL][3])</p><h5 id=락-호환성-매트릭스-적용-판단-프레임>락 호환성 매트릭스 적용 판단 프레임<a hidden class=anchor aria-hidden=true href=#락-호환성-매트릭스-적용-판단-프레임>#</a></h5><h6 id=설계-관점>설계 관점<a hidden class=anchor aria-hidden=true href=#설계-관점>#</a></h6><ul><li>높은 적합: 트랜잭션 간 쓰기 충돌이 현실적으로 빈번하고, 정합성 위반 비용이 큰 도메인 (금융/의료/ERP). 키 - 범위·의도락·그라뉼러리티로 스키마/인덱스·쿼리 패턴을 함께 설계. ([Microsoft Learn][2])</li><li>낮은 적합: 엄격한 마이크로초~밀리초 SLA(HFT)·폭주 쓰기 (IoT). OCC·배치 병합·로그 구조/파티션으로 충돌을 시간/공간 분리. ([eecs.harvard.edu][5])</li></ul><h6 id=분석-관점>분석 관점<a hidden class=anchor aria-hidden=true href=#분석-관점>#</a></h6><ul><li>읽기 지배 워크로드는 버전닝 기반 스냅샷 (Non-locking read) 로 대기를 줄이고, 필요한 지점만 잠금 강도를 올린다. ([PostgreSQL][3])</li><li>직렬화 필요한 범위 연산은 키 - 범위 락으로 팬텀 억제. 비용–효과를 트랜잭션 빈도·카디널리티로 산정. ([Microsoft Learn][2])</li></ul><h6 id=운영-관점>운영 관점<a hidden class=anchor aria-hidden=true href=#운영-관점>#</a></h6><ul><li>경합 증가 시: 락 대기/타임아웃 모니터링 (Perf counters/DMV) → 쿼리/인덱스/락 모드/그라뉼러리티 재조정 → 필요 시 에스컬레이션/버전닝 전환 (RCSI/SI) 검토. ([Microsoft Learn][7])</li></ul><h5 id=워크로드별-락-매트릭스-적용-판단>워크로드별 락 매트릭스 적용 판단<a hidden class=anchor aria-hidden=true href=#워크로드별-락-매트릭스-적용-판단>#</a></h5><table><thead><tr><th>시나리오</th><th style=text-align:right>적합성</th><th>주요 이유</th><th>권장 전략</th></tr></thead><tbody><tr><td>금융/의료 트랜잭션</td><td style=text-align:right>높음</td><td>강한 일관성·감사 추적 필요</td><td>의도락 + 키 - 범위, 직렬화 필요한 경로만 강화</td></tr><tr><td>ERP/OLTP(혼합 R/W)</td><td style=text-align:right>높음</td><td>쓰기 충돌·업데이트 경합</td><td>그라뉼러리티·락 모드 튜닝, 인덱스/쿼리 동시 설계</td></tr><tr><td>조회 위주 분석</td><td style=text-align:right>중간</td><td>읽기 다수·쓰기 적음</td><td>MVCC 스냅샷 기본, 필요한 부분만 잠금</td></tr><tr><td>초저지연 거래 (HFT)</td><td style=text-align:right>낮음</td><td>락 대기 자체가 SLA 위반</td><td>OCC·락프리·분할정복 (파티션)</td></tr><tr><td>IoT 대용량 쓰기</td><td style=text-align:right>낮음</td><td>삽입 폭주·락 경합</td><td>파티셔닝·비동기 적재·OCC/배치 병합</td></tr><tr><td>캐시·최종 일관성 허용</td><td style=text-align:right>낮음</td><td>일시적 불일치 허용</td><td>OCC/버전닝·TTL·리트라이/멱등 설계</td></tr></tbody></table><p>강한 일관성이 가치인 곳은 락 호환성 중심, 초저지연·폭주 쓰기는 버전닝·낙관적 검증·파티셔닝으로 잠금 의존도를 낮추는 쪽이 유리하다.</p><h3 id=구현-방법-및-분류>구현 방법 및 분류<a hidden class=anchor aria-hidden=true href=#구현-방법-및-분류>#</a></h3><h4 id=목표지향-lcm-구현-전략-로드맵>목표지향 LCM 구현 전략 로드맵<a hidden class=anchor aria-hidden=true href=#목표지향-lcm-구현-전략-로드맵>#</a></h4><p>호환성 판정은 크게 **&rdquo; 표로 즉시 보기 (매트릭스/비트)"**와 <strong>" 규칙으로 계산 (부분순서/함수)"</strong> 두 부류다.<br>표·비트는 <strong>빠르고 단순</strong>하며, 모드가 변하지 않는 일반 RDBMS 에 적합하다.<br>규칙·함수는 <strong>새 모드/새 리소스</strong>가 늘어나는 시스템에서 <strong>확장성</strong>이 강하다.<br>어떤 방식을 택하든 실무에선 <strong>의도락 (IS/IX/SIX)</strong>, <strong>U(Update)</strong>, <strong>키 - 범위/넥스트키</strong> 같은 <strong>벤더 확장 모드/범위 잠금</strong>도 함께 반영해야 실제 쿼리 현상을 정확히 판정할 수 있다.<br>근거는 각 DBMS 의 공식 문서 (락 모드·호환 표, U/키 - 범위/넥스트키 설명) 에서 확인된다.</p><h5 id=lcm-구현-4-대-방식>LCM 구현 4 대 방식<a hidden class=anchor aria-hidden=true href=#lcm-구현-4-대-방식>#</a></h5><h6 id=매트릭스-테이블-방식>매트릭스 테이블 방식<a hidden class=anchor aria-hidden=true href=#매트릭스-테이블-방식>#</a></h6><ul><li><strong>정의</strong>: 모드×모드 2 차원 배열 (또는 해시) 에 <strong>호환/충돌 비트</strong> 저장.</li><li><strong>특징</strong>: <strong>O(1)</strong> 룩업, 단순·안정적. 모드가 고정일 때 유리.</li><li><strong>목적</strong>: 런타임 판정 지연 최소화.</li><li><strong>사용</strong>: 범용 RDBMS(테이블·행/키 레벨 모두).</li><li><strong>예시 (Python)</strong>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># S=0, X=1, IS=2, IX=3, SIX=4</span>
</span></span><span class=line><span class=cl><span class=n>compat</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl><span class=c1># S  X  IS IX SIX</span>
</span></span><span class=line><span class=cl> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>  <span class=c1># S 요청</span>
</span></span><span class=line><span class=cl> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>  <span class=c1># X</span>
</span></span><span class=line><span class=cl> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>],</span>  <span class=c1># IS</span>
</span></span><span class=line><span class=cl> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>  <span class=c1># IX</span>
</span></span><span class=line><span class=cl> <span class=p>[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>],</span>  <span class=c1># SIX</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>compatible</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=n>hold</span><span class=p>):</span> <span class=k>return</span> <span class=nb>bool</span><span class=p>(</span><span class=n>compat</span><span class=p>[</span><span class=n>req</span><span class=p>][</span><span class=n>hold</span><span class=p>])</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>근거</strong>: DB 문서가 <strong>락 모드 호환성 표</strong>를 제공 (실제 엔진은 이 표를 빠르게 조회).</li></ul><h6 id=비트마스크-방식>비트마스크 방식<a hidden class=anchor aria-hidden=true href=#비트마스크-방식>#</a></h6><ul><li><strong>정의</strong>: 각 모드에 " 호환 가능한 상대 모드 집합 " 을 <strong>비트셋</strong>으로 부여, <code>mask[req] & (1&lt;&lt;hold)</code> 로 판정.</li><li><strong>특징</strong>: <strong>메모리 초절약</strong>·분기 최소, CPU 친화.</li><li><strong>목적</strong>: 고동시성/임베디드·인메모리에서 분기비용 절감.</li><li><strong>사용</strong>: 고성능 엔진·캐시형 락매니저.</li><li><strong>예시 (Python)</strong>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1>1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2>2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3>3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4>4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5>5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6>6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7>7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8>8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>S</span><span class=p>,</span><span class=n>X</span><span class=p>,</span><span class=n>IS</span><span class=p>,</span><span class=n>IX</span><span class=p>,</span><span class=n>SIX</span> <span class=o>=</span> <span class=nb>range</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>mask</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>S</span><span class=p>:</span>   <span class=mb>0b10101</span><span class=p>,</span>   <span class=c1># S와 IS,SIX 호환 등 가정 예시</span>
</span></span><span class=line><span class=cl>  <span class=n>X</span><span class=p>:</span>   <span class=mb>0b00000</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>IS</span><span class=p>:</span>  <span class=mb>0b11101</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>IX</span><span class=p>:</span>  <span class=mb>0b11010</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>SIX</span><span class=p>:</span> <span class=mb>0b10100</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>compatible</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=n>hold</span><span class=p>):</span> <span class=k>return</span> <span class=p>(</span><span class=n>mask</span><span class=p>[</span><span class=n>req</span><span class=p>]</span> <span class=o>&gt;&gt;</span> <span class=n>hold</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>근거</strong>: 상용/오픈소스 엔진이 내부적으로 <strong>비트/배열 기반</strong>으로 충돌 검사 최적화. PG 는 <strong>fast-path</strong>까지 두어 빠른 충돌 체크 경로를 둔다.</li></ul><h6 id=계층적-규칙-부분순서-방식>계층적 규칙 (부분순서) 방식<a hidden class=anchor aria-hidden=true href=#계층적-규칙-부분순서-방식>#</a></h6><ul><li><strong>정의</strong>: 락 강도 (partial order) 를 정의하고 <strong>의도락 (IS/IX/SIX)</strong> 규칙과 <strong>부모→자식 전파</strong>로 호환성을 <strong>계산</strong>.</li><li><strong>특징</strong>: <strong>동적 확장</strong>(새 모드 추가 용이), 다중 그레뉼러리티에 직관적.</li><li><strong>목적</strong>: 사용자 정의 모드·새 리소스 타입 추가 시 재컴파일 최소화.</li><li><strong>사용</strong>: 복잡한 계층/분산 잠금·플러그블 스토리지.</li><li><strong>예시 (의사코드)</strong>:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>strength</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;IS&#34;</span><span class=p>:</span><span class=mi>1</span><span class=p>,</span><span class=s2>&#34;S&#34;</span><span class=p>:</span><span class=mi>2</span><span class=p>,</span><span class=s2>&#34;IX&#34;</span><span class=p>:</span><span class=mi>3</span><span class=p>,</span><span class=s2>&#34;SIX&#34;</span><span class=p>:</span><span class=mi>4</span><span class=p>,</span><span class=s2>&#34;X&#34;</span><span class=p>:</span><span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>conflicts</span><span class=p>(</span><span class=n>m1</span><span class=p>,</span><span class=n>m2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 규칙 예: X와는 모두 충돌, IX는 S와 충돌 등 규칙 테이블/람다로 캡슐화</span>
</span></span><span class=line><span class=cl>    <span class=err>…</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>isCompatible</span><span class=p>(</span><span class=n>m1</span><span class=p>,</span><span class=n>m2</span><span class=p>):</span> <span class=k>return</span> <span class=ow>not</span> <span class=n>conflicts</span><span class=p>(</span><span class=n>m1</span><span class=p>,</span><span class=n>m2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>근거</strong>: <strong>Multiple Granularity/의도락</strong> 이론 (Gray & Reuter).</li></ul><h6 id=함수형-매핑-방식>함수형 매핑 방식<a hidden class=anchor aria-hidden=true href=#함수형-매핑-방식>#</a></h6><ul><li><strong>정의</strong>: <code>(mode1, mode2) -> bool</code> 을 <strong>순수 함수</strong>/패턴매칭으로 캡슐화.</li><li><strong>특징</strong>: 테스트 용이, 규칙 변경이 <strong>컴파일 타임</strong>에 드러남.</li><li><strong>목적</strong>: 코드 가독성·검증성 중시 환경.</li><li><strong>사용</strong>: 함수형 언어·정적 분석/프로퍼티 기반 테스트 병행.</li><li><strong>예시 (JavaScript)</strong></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3>3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4>4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// 간단 예시: U는 S와만 호환, 나머지와 충돌(SSMS 문서 패턴)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>comp</span> <span class=o>=</span> <span class=p>(</span><span class=nx>a</span><span class=p>,</span><span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>P</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Set</span><span class=p>([</span><span class=sb>`</span><span class=si>${</span><span class=s1>&#39;S&#39;</span><span class=si>}</span><span class=sb>-</span><span class=si>${</span><span class=s1>&#39;S&#39;</span><span class=si>}</span><span class=sb>`</span><span class=p>,</span> <span class=sb>`S-U`</span><span class=p>,</span> <span class=sb>`U-S`</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>P</span><span class=p>.</span><span class=nx>has</span><span class=p>(</span><span class=sb>`</span><span class=si>${</span><span class=nx>a</span><span class=si>}</span><span class=sb>-</span><span class=si>${</span><span class=nx>b</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>근거</strong>: <strong>U(Update)</strong>, <strong>키 - 범위</strong> 등 벤더 확장을 <strong>명시적 패턴</strong>으로 표현하기 적합 (SSMS 가이드의 모드 정의 근거).</li></ul><h6 id=실무-확장-판정-대상에-반영>실무 확장 (판정 대상에 반영)<a hidden class=anchor aria-hidden=true href=#실무-확장-판정-대상에-반영>#</a></h6><ul><li><strong>의도락 (IS/IX/SIX)</strong>: 상위 보호 신호로 <strong>계층 호환성</strong> 계산에 필수.</li><li><strong>U(Update)</strong>: <strong>S 와 호환, U 끼리는 비호환</strong> → 교착 감소를 위한 <strong>단계적 승격 (U→X)</strong>.</li><li><strong>키 - 범위/넥스트키</strong>: <strong>SERIALIZABLE</strong>에서 팬텀 방지 (인덱스 범위 자체를 자원으로 보고 호환성 평가).</li></ul><h5 id=lcm-구현-4-대-방식-요약표>LCM 구현 4 대 방식 요약표<a hidden class=anchor aria-hidden=true href=#lcm-구현-4-대-방식-요약표>#</a></h5><table><thead><tr><th>방식</th><th>정의</th><th>특징</th><th>목적</th><th>사용 상황</th><th>간단 예시</th><th>근거</th></tr></thead><tbody><tr><td>매트릭스</td><td>모드×모드 2 차원 표</td><td>O(1) 룩업, 단순</td><td>런타임 최소화</td><td>모드 고정형 RDBMS</td><td><code>compat[req][hold]</code></td><td>PG/SS 표 기반 판정</td></tr><tr><td>비트마스크</td><td>모드별 호환 집합 비트셋</td><td>메모리/분기 최소</td><td>고성능/임베디드</td><td>인메모리·캐시형</td><td><code>mask[req]>>hold &amp;1</code></td><td>PG fast-path 설계</td></tr><tr><td>부분순서</td><td>강도·의도 규칙 계산</td><td>동적 확장 용이</td><td>새 모드 대응</td><td>플러그블 스토리지</td><td><code>conflicts(strength)</code></td><td>의도락 이론</td></tr><tr><td>함수형</td><td>(m1,m2)→bool 함수</td><td>테스트 친화</td><td>가독성/검증성</td><td>함수형/정적분석</td><td>패턴매칭 스위치</td><td>모드 정의 근거</td></tr></tbody></table><h5 id=목표별-lcm-구현-분류>목표별 LCM 구현 분류<a hidden class=anchor aria-hidden=true href=#목표별-lcm-구현-분류>#</a></h5><h6 id=성능-최우선>성능 최우선<a hidden class=anchor aria-hidden=true href=#성능-최우선>#</a></h6><ul><li><strong>내용</strong>: 고정 모드 집합에서 <strong>캐시 친화 O(1) 판정</strong>. 비트마스크는 분기 최소·메모리 절약, 매트릭스는 디버깅 용이. <strong>키 - 범위/넥스트키</strong> 등 범위 자원도 <strong>자원 ID</strong>만 정규화하면 동일 프레임으로 판정 가능.</li></ul><table><thead><tr><th>기법</th><th>장점</th><th>주의점</th><th>적용 팁</th></tr></thead><tbody><tr><td>매트릭스</td><td>단순/O(1)</td><td>모드 추가 시 재배포</td><td>표 생성 코드 자동화</td></tr><tr><td>비트마스크</td><td>극저비용</td><td>가독성↓</td><td>생성 스크립트·테스트 벡터 병행</td></tr></tbody></table><ul><li>요약: <strong>지연 최소·예측 가능성</strong>이 필요하면 A.</li></ul><h6 id=확장성표현력>확장성/표현력<a hidden class=anchor aria-hidden=true href=#확장성표현력>#</a></h6><ul><li><strong>내용</strong>: <strong>의도락·U·키 - 범위</strong> 같은 확장을 규칙으로 캡슐화. 모드 추가/리소스 타입 추가가 쉬움.</li></ul><table><thead><tr><th>기법</th><th>장점</th><th>주의점</th><th>적용 팁</th></tr></thead><tbody><tr><td>부분순서</td><td>새 모드/자원에 유연</td><td>런타임 비용↑</td><td>규칙→캐시된 결정표로 컴파일</td></tr></tbody></table><ul><li>요약: <strong>변화 많은 엔진/플러그블 스토리지</strong>면 B.</li></ul><h6 id=검증가독성>검증/가독성<a hidden class=anchor aria-hidden=true href=#검증가독성>#</a></h6><ul><li><strong>내용</strong>: <strong>순수 함수/패턴매칭</strong>으로 테스트와 코드 리뷰가 쉽다. 정적분석·속성기반 테스트로 <strong>호환성 불변식</strong>을 검증.</li></ul><table><thead><tr><th>기법</th><th>장점</th><th>주의점</th><th>적용 팁</th></tr></thead><tbody><tr><td>함수형</td><td>테스트 용이</td><td>속도 최적화 필요</td><td>생성 시 테이블로 다운컴파일</td></tr></tbody></table><ul><li>요약: <strong>정확성·테스트 우선</strong>이면 C.</li></ul><h5 id=lcm-구현-선택-매트릭스>LCM 구현 선택 매트릭스<a hidden class=anchor aria-hidden=true href=#lcm-구현-선택-매트릭스>#</a></h5><table><thead><tr><th>카테고리</th><th>기법</th><th style=text-align:right>성능</th><th style=text-align:right>확장성</th><th style=text-align:right>가독/검증</th><th>주 용도</th><th>근거</th></tr></thead><tbody><tr><td>성능 최우선</td><td>매트릭스</td><td style=text-align:right>★★★★★</td><td style=text-align:right>★★☆</td><td style=text-align:right>★★★★</td><td>범용 RDBMS</td><td>PG/SS 호환 표</td></tr><tr><td>성능 최우선</td><td>비트마스크</td><td style=text-align:right>★★★★★</td><td style=text-align:right>★★☆</td><td style=text-align:right>★★★</td><td>인메모리/임베디드</td><td>PG fast-path 힌트</td></tr><tr><td>확장성/표현력</td><td>부분순서</td><td style=text-align:right>★★★</td><td style=text-align:right>★★★★★</td><td style=text-align:right>★★★</td><td>플러그블 스토리지</td><td>의도락 이론</td></tr><tr><td>검증/가독성</td><td>함수형</td><td style=text-align:right>★★★</td><td style=text-align:right>★★★★</td><td style=text-align:right>★★★★★</td><td>테스트·도메인 주도</td><td>모드 정의 명시</td></tr></tbody></table><h4 id=lcm-락-유형>LCM 락 유형<a hidden class=anchor aria-hidden=true href=#lcm-락-유형>#</a></h4><ul><li>락은 <strong>무엇을 하려는가 (읽기/쓰기/업데이트)</strong>, <strong>어디를 보호하나 (테이블~키범위)</strong>, **팬텀을 어떻게 막나 (범위/논리)**로 나눠 보면 빠르게 이해된다.</li><li>이 세 축이 만나 <strong>호환성 표</strong>가 되고, 엔진은 이 표로 <strong>허용/대기</strong>를 즉시 결정한다. PostgreSQL·MySQL·SQL Server 문서 모두 이 흐름을 전제로 한다.</li></ul><h5 id=lcm-락-유형-분류-표준안>LCM 락 유형 분류 표준안<a hidden class=anchor aria-hidden=true href=#lcm-락-유형-분류-표준안>#</a></h5><table><thead><tr><th>분류 축</th><th>유형</th><th>정의/핵심</th><th>대표 모드·예시</th><th>근거</th></tr></thead><tbody><tr><td><strong>의미/목적 (Access semantics)</strong></td><td><strong>공유/배타</strong></td><td>읽기 공유 (S), 쓰기 배타 (X)</td><td><code>FOR SHARE</code>/<code>FOR UPDATE</code></td><td>PG Explicit Locking, MySQL Locking Reads</td></tr><tr><td></td><td><strong>업데이트 (제품별)</strong></td><td>S→X 전환 교착 완화 (U)</td><td>SQL Server <strong>U</strong></td><td>SQL Server Locking Guide</td></tr><tr><td><strong>그라뉼러리티/의도 (MGL)</strong></td><td><strong>의도 락</strong></td><td>하위 잠금 의도 신호 (IS/IX/SIX)</td><td>InnoDB IS/IX, MGL 규칙</td><td>InnoDB Locking, CMU 노트</td></tr><tr><td><strong>범위/논리 (Phantom control)</strong></td><td><strong>범위 락 (물리)</strong></td><td>인덱스 키/갭 구간 보호</td><td>SQL Server Key-Range, InnoDB Next-Key</td><td>MS Guide, MySQL Next-Key</td></tr><tr><td></td><td><strong>프레디케이트 (논리)</strong></td><td>조건 (프레디케이트) 기반 보호</td><td>PostgreSQL <strong>SIREAD</strong></td><td>PG Isolation(Serializable)</td></tr><tr><td><strong>리소스 레벨 (Resource)</strong></td><td><strong>테이블/페이지/행/키범위</strong></td><td>보호 단위의 층위</td><td><code>LOCK TABLE</code> / 인덱스 레코드/갭</td><td>PG LOCK, MySQL InnoDB 설명</td></tr><tr><td><strong>관리 특성 (운용)</strong></td><td><strong>에스컬레이션/자동 판정</strong></td><td>미세락→상위 승격/그랜트·대기</td><td>엔진 자동화</td><td>MGL·제품 가이드 종합</td></tr></tbody></table><h5 id=lcm-실무형-분류-기준-4-축>LCM 실무형 분류 기준 4 축<a hidden class=anchor aria-hidden=true href=#lcm-실무형-분류-기준-4-축>#</a></h5><h6 id=의미목적-축>의미/목적 축<a hidden class=anchor aria-hidden=true href=#의미목적-축>#</a></h6><ul><li><strong>핵심</strong>: S(공유) 로 읽기 병행, X(배타) 로 쓰기 고립. 제품에 따라 **U(업데이트)**로 S→X 전환 시 교착 저감.</li><li><strong>주요 차이</strong>: 단순 S/X 모델은 이해 쉬우나, 갱신 경합이 잦은 시스템은 <strong>U</strong> 도입이 유리 (특히 SQL Server).</li></ul><table><thead><tr><th>모드</th><th>의도/효과</th><th>호환 포인트</th><th>대표 명령</th></tr></thead><tbody><tr><td>S</td><td>읽기 공유</td><td>S↔S 가능, S↔X 불가</td><td><code>FOR SHARE</code>(PG/MySQL)</td></tr><tr><td>X</td><td>쓰기 독점</td><td>X↔* 대부분 불가</td><td><code>FOR UPDATE</code>(PG/MySQL)</td></tr><tr><td>U(제품별)</td><td>S→X 전환 교착 완화</td><td>U 는 S 와 제한 호환</td><td>SQL Server U</td></tr></tbody></table><p><strong>요약</strong>: 읽기·쓰기의 <strong>의미적 목적</strong>이 LCM 의 1 차 축이다. U 는 갱신 경합에서 교착 위험을 줄이는 <strong>제품 특수 완충 모드</strong>다.</p><h6 id=그라뉼러리티의도-축>그라뉼러리티/의도 축<a hidden class=anchor aria-hidden=true href=#그라뉼러리티의도-축>#</a></h6><ul><li><strong>핵심</strong>: IS/IX/SIX 는 &ldquo;<strong>하위에 락을 둘 의도</strong>&rdquo; 를 상위 노드에 표시해 <strong>충돌 판정 비용을 상수화</strong>.</li><li><strong>운용</strong>: 다량의 행락은 <strong>에스컬레이션</strong>으로 상위로 승격해 메모리·메타데이터 사용을 제어.</li></ul><table><thead><tr><th>모드</th><th>의미</th><th>호환 핵심</th><th>사용 맥락</th></tr></thead><tbody><tr><td>IS</td><td>하위에 S 예정</td><td>X 와 충돌</td><td>대량 읽기 트리 탐색</td></tr><tr><td>IX</td><td>하위에 X 예정</td><td>S/X 와 폭넓게 충돌</td><td>대량 갱신 트리 탐색</td></tr><tr><td>SIX</td><td>상위 S + 하위 X 예정</td><td>IX/IS 일부 호환</td><td>혼합 워크로드</td></tr></tbody></table><p><strong>요약</strong>: <strong>의도 락</strong>은 계층 구조에서 <strong>충돌 사전 필터</strong>로 작동해 대규모 동시성에서 성능·안정성을 동시에 보장한다.</p><h6 id=범위논리-팬텀-방지-축>범위/논리 (팬텀 방지) 축<a hidden class=anchor aria-hidden=true href=#범위논리-팬텀-방지-축>#</a></h6><ul><li><strong>핵심</strong>: " 행만 " 잠그면 <strong>삽입/삭제로 생기는 팬텀</strong>을 못 막을 수 있어, <strong>범위/논리</strong>로 막는다.</li><li><strong>제품 차이</strong>: SQL Server=<strong>Key-Range</strong>, MySQL=<strong>Next-Key(레코드 + 갭)</strong>, PostgreSQL=<strong>Predicate(SIREAD)</strong>(차단·데드락 유발 없음).</li></ul><table><thead><tr><th>유형</th><th>보호 단위</th><th>특성</th><th>대표</th></tr></thead><tbody><tr><td>Key-Range</td><td>인덱스 키 구간</td><td>겹치는 범위끼리 호환 표로 판정</td><td>SQL Server ([Microsoft Learn][3])</td></tr><tr><td>Next-Key</td><td>레코드 + 앞 갭</td><td>스캔된 인덱스 범위를 넓게 보호</td><td>MySQL InnoDB ([MySQL 개발자 존][5])</td></tr><tr><td>Predicate</td><td>논리 조건</td><td>차단·데드락 미유발, 직렬성 검증용</td><td>PostgreSQL SIREAD ([PostgreSQL][6])</td></tr></tbody></table><p><strong>요약</strong>: 구현은 달라도 목표는 <strong>직렬성·팬텀 제거</strong>다. 워크로드·인덱스에 따라 <strong>잠금 면적</strong>이 달라져 성능이 변한다.</p><h6 id=리소스-레벨-축>리소스 레벨 축<a hidden class=anchor aria-hidden=true href=#리소스-레벨-축>#</a></h6><ul><li><strong>핵심</strong>: 테이블/페이지/행/인덱스 키 범위 등 <strong>보호 단위</strong>가 다르면 호환성과 비용이 달라진다.</li><li><strong>운용 포인트</strong>: <strong><code>LOCK TABLE</code> 모드 선택</strong> 오류는 DDL/DML 교착을 낳을 수 있어 충돌 표 확인이 필수.</li></ul><table><thead><tr><th>레벨</th><th>장점</th><th>유의점</th><th>예시</th></tr></thead><tbody><tr><td>테이블</td><td>관리 용이</td><td>동시성 저하</td><td><code>LOCK TABLE … MODE</code>(PG)</td></tr><tr><td>행/키</td><td>동시성↑</td><td>잠금 수↑</td><td><code>FOR UPDATE/SHARE</code></td></tr><tr><td>키 범위</td><td>팬텀 방지</td><td>잠금 면적↑</td><td>Next-Key/Key-Range ([MySQL 개발자 존][5])</td></tr></tbody></table><p><strong>요약</strong>: <strong>레벨 선택</strong>은 성능·정합성의 트레이드오프. 설계·튜닝 시 인덱스/스캔 패턴과 함께 본다.</p><h5 id=lcm-락-유형-통합-매트릭스>LCM 락 유형 통합 매트릭스<a hidden class=anchor aria-hidden=true href=#lcm-락-유형-통합-매트릭스>#</a></h5><table><thead><tr><th>축</th><th>유형</th><th>핵심 설명</th><th>대표 모드/예시</th><th>실무 포인트</th></tr></thead><tbody><tr><td>의미/목적</td><td>공유/배타/업데이트</td><td>읽기 공유 (S), 쓰기 배타 (X), 갱신 교착 완충 (U)</td><td><code>FOR SHARE</code>/<code>FOR UPDATE</code>/U</td><td>읽기/쓰기 경합 모델링</td></tr><tr><td>그라뉼러리티/의도</td><td>IS/IX/SIX</td><td>하위 잠금 의도 신호로 상수 시간 판정</td><td>InnoDB IS/IX, MGL</td><td>대규모 동시성·에스컬레이션</td></tr><tr><td>범위/논리</td><td>Key-Range/Next-Key/Predicate</td><td>팬텀 방지 (물리/논리)</td><td>SQLS Key-Range / MySQL Next-Key / PG SIREAD</td><td>직렬성·정합성 보장</td></tr><tr><td>리소스 레벨</td><td>테이블/페이지/행/키범위</td><td>보호 단위 계층</td><td><code>LOCK TABLE</code>, 행/키·범위락</td><td>성능↔정합성 균형</td></tr></tbody></table><h4 id=락-생태계-전개도-엔진orm운영분산>락 생태계 전개도: 엔진·ORM·운영·분산<a hidden class=anchor aria-hidden=true href=#락-생태계-전개도-엔진orm운영분산>#</a></h4><ul><li><strong>어디서 잠그고 어떻게 보나?</strong><br>DB 엔진은 <strong>호환성 매트릭스</strong>를 근거로 잠금을 부여하며, Postgres 는 <code>pg_locks</code>/<code>pg_stat_activity</code>, MySQL 은 <strong>갭/넥스트키</strong>+Performance Schema, SQL Server 는 <strong>DMV+Extended Events</strong>로 <strong>현황과 원인</strong>을 관측한다.</li><li><strong>애플리케이션에서는?</strong><br>Hibernate/Spring/EF Core/SQLAlchemy/Django 가 <strong>락 힌트</strong>와 <strong>격리수준</strong>을 노출해, **" 언제 어떤 락을 요구할지 &ldquo;**를 코드에서 선언한다.</li><li><strong>대규모/분산 환경은?</strong><br>ZooKeeper/etcd/Redisson 같은 <strong>분산 락</strong>으로 서비스 간 상호배타를 보완한다.</li></ul><h5 id=락-생태계-관측제어orm분산-총정리>락 생태계: 관측·제어·ORM·분산 총정리<a hidden class=anchor aria-hidden=true href=#락-생태계-관측제어orm분산-총정리>#</a></h5><h6 id=rdbms-내장-관측제어>RDBMS 내장 (관측·제어)<a hidden class=anchor aria-hidden=true href=#rdbms-내장-관측제어>#</a></h6><ul><li><strong>PostgreSQL</strong><ul><li><strong>기능/용도</strong>: <code>pg_locks</code> 로 보유/대기 락 조회, <code>pg_stat_activity</code> 교차로 대기 원인 추적.</li><li><strong>강점</strong>: SQL 만으로 즉시 진단 · 표준화된 뷰 제공.</li><li><strong>약점</strong>: 대용량 환경에선 결과 해석/상관관계 파악이 번거로움.</li></ul></li><li><strong>MySQL/InnoDB</strong><ul><li><strong>기능/용도</strong>: <strong>갭/넥스트키</strong>로 팬텀 방지; Performance Schema <code>data_locks</code>/<code>data_lock_waits</code> 로 락 가시화.</li><li><strong>강점</strong>: 범위 기반 충돌 통제 명확.</li><li><strong>약점</strong>: 인덱스 스캔 범위가 넓을 경우 과잉 락 가능.</li></ul></li><li><strong>SQL Server</strong><ul><li><strong>기능/용도</strong>: <strong>락 에스컬레이션 제어</strong>, <strong>스냅샷 격리 (행 버전)</strong>, DMV <code>sys.dm_tran_locks</code>/<strong>Extended Events</strong>로 락/블로킹 분석.</li><li><strong>강점</strong>: XE 기반의 세밀 추적과 행버전 격리 옵션.</li><li><strong>약점</strong>: Profiler 는 <strong>비권장</strong>(XE 로 대체).</li></ul></li><li><strong>Oracle</strong><ul><li><strong>기능/용도</strong>: <strong>MVCC 기반 읽기 일관성</strong> + 락 조합으로 동시성/일관성 조화.</li><li><strong>강점</strong>: 강력한 읽기 일관성과 성숙한 문서.</li><li><strong>약점</strong>: 기능 스펙트럼이 넓어 학습 곡선이 가파름.</li></ul></li></ul><h6 id=애플리케이션orm-계층>애플리케이션/ORM 계층<a hidden class=anchor aria-hidden=true href=#애플리케이션orm-계층>#</a></h6><ul><li><strong>Hibernate/JPA (@Lock, LockMode, 낙관/비관)</strong><ul><li><strong>역할/용도</strong>: 엔티티/쿼리 수준에서 락 힌트 전파, 버전 필드로 낙관적 검증.</li><li><strong>강점</strong>: 데이터 접근 계층에서 정책 일관화.</li><li><strong>약점</strong>: DB 별 락 의미 차이 반영 필요.</li></ul></li><li><strong>Spring <code>@Transactional</code></strong><ul><li><strong>역할/용도</strong>: <strong>격리수준/전파/타임아웃/읽기전용</strong> 등 트랜잭션 속성 지정.</li><li><strong>강점</strong>: 서비스 계층에서 선언적 일관성.</li><li><strong>약점</strong>: 실제 락 의미는 <strong>DB 엔진</strong>에 좌우됨.</li></ul></li><li><strong>EF Core</strong><ul><li><strong>역할/용도</strong>: <strong>낙관적 동시성</strong> 기본 제공 (버전/컨커런시 토큰).</li><li><strong>강점</strong>: 충돌시 예외로 탐지·재시도 로직 구성 용이.</li><li><strong>약점</strong>: 비관 잠금은 공급자/원격 DB 기능 의존.</li></ul></li><li><strong>SQLAlchemy / Django</strong><ul><li><strong>역할/용도</strong>: <code>with_for_update()</code> / <code>select_for_update()</code> 로 <strong>행 잠금</strong>.</li><li><strong>강점</strong>: SQL 힌트를 직접 노출해 제어력 높음.</li><li><strong>약점</strong>: 조인/지연로딩 상황에서 잠금 범위 예측 주의.</li></ul></li></ul><h6 id=운영모니터링-도구>운영·모니터링 도구<a hidden class=anchor aria-hidden=true href=#운영모니터링-도구>#</a></h6><ul><li><strong>Extended Events(XE) / DMV(SQL Server)</strong><ul><li><strong>역할/용도</strong>: 락/대기/데드락 이벤트 수집·분석, <code>sys.dm_tran_locks</code> 로 현재 상태 파악.</li><li><strong>강점</strong>: 저오버헤드·세밀 필터링, Profiler 공식 대체.</li><li><strong>약점</strong>: 학습 난이도.</li></ul></li><li><strong>sp_WhoIsActive(스크립트)</strong><ul><li><strong>역할/용도</strong>: 리드 블로커·블로킹 체인 빠른 파악.</li><li><strong>강점</strong>: 실전 대응 속도.</li><li><strong>약점</strong>: 설치·권한 필요, 히스토리 수집은 별도 구성.</li></ul></li><li><strong>PostgreSQL 생태 (예: pganalyze, 커뮤니티 스크립트)</strong><ul><li><strong>역할/용도</strong>: 락 트리/대기 분석, <code>pg_locks</code>+<code>pg_stat_activity</code> 상관.</li><li><strong>강점</strong>: 시각화·경보.</li><li><strong>약점</strong>: 상용 구독/에이전트·권한 필요 가능.</li></ul></li></ul><h6 id=분산-락조정-보완-레이어>분산 락/조정 (보완 레이어)<a hidden class=anchor aria-hidden=true href=#분산-락조정-보완-레이어>#</a></h6><ul><li><strong>ZooKeeper/Curator</strong><ul><li><strong>역할/용도</strong>: <strong>분산 락 레시피</strong>(클라이언트 협약 기반) 제공.</li><li><strong>강점</strong>: 고가용 분산 조정 표준.</li><li><strong>약점</strong>: 모델 복잡성·운영 부담.</li></ul></li><li><strong>etcd concurrency</strong><ul><li><strong>역할/용도</strong>: gRPC/Go 클라이언트로 <strong>분산 뮤텍스/선거</strong> 제공.</li><li><strong>강점</strong>: 간결한 API, 리스 만료로 자동 해제.</li><li><strong>약점</strong>: 올바른 리스·세션 관리 필요.</li></ul></li><li><strong>Redis/Redisson(RLock 등)</strong><ul><li><strong>역할/용도</strong>: 재진입/공정 락 등 다양한 분산 락 제공.</li><li><strong>강점</strong>: 적용·코드 통합 용이.</li><li><strong>약점</strong>: 네트워크 파티션·시계 드리프트 등 설계 주의 (알고리즘 선택).</li></ul></li></ul><h5 id=락-도구-분류-관측제어운영분산>락 도구 분류: 관측·제어·운영·분산<a hidden class=anchor aria-hidden=true href=#락-도구-분류-관측제어운영분산>#</a></h5><h6 id=관측-observability>관측 (Observability)<a hidden class=anchor aria-hidden=true href=#관측-observability>#</a></h6><ul><li><strong>내용</strong>: Postgres <code>pg_locks</code>/<code>pg_stat_activity</code>, MySQL Performance Schema(<code>data_locks</code>, <code>data_lock_waits</code>), SQL Server <code>sys.dm_tran_locks</code>+Extended Events.</li><li><strong>역할/용도</strong>: " 누가·무엇을·얼마나 오래 " 잠갔는지, <strong>블로킹 체인</strong>과 <strong>데드락</strong> 원인 파악.</li><li><strong>강점</strong>: 엔진 일차 정보, 실시간/저오버헤드 (XE). <strong>Profiler 는 비권장</strong>.</li></ul><table><thead><tr><th>도구</th><th>핵심 기능</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td><code>pg_locks</code>/<code>pg_stat_activity</code></td><td>현재 락/세션 상태 조회</td><td>바로 SQL 로 진단</td><td>상관분석 쿼리 필요</td></tr><tr><td>Performance Schema</td><td>데이터락/대기 추적</td><td>세밀 지표</td><td>설정·학습 필요</td></tr><tr><td>SQL Server DMV+XE</td><td>잠금/대기·데드락 이벤트</td><td>저오버헤드, Profiler 대체</td><td>XE 학습 곡선</td></tr></tbody></table><ul><li><strong>요약</strong>: 일단 <strong>엔진 내장 뷰/이벤트</strong>로 <strong>현황을 수치화</strong>하고, 필요 시 대시보드/경보를 더한다.</li></ul><h6 id=제어-control>제어 (Control)<a hidden class=anchor aria-hidden=true href=#제어-control>#</a></h6><ul><li><strong>내용</strong>: Hibernate @Lock/LockMode, Spring <code>@Transactional</code> 격리, EF Core 낙관적 동시성, SQLAlchemy <code>with_for_update</code>, Django <code>select_for_update</code>.</li><li><strong>역할/용도</strong>: <strong>행/테이블 수준 잠금 힌트</strong>와 <strong>트랜잭션 속성</strong>으로 충돌을 설계.</li><li><strong>강점</strong>: 도메인 코드에서 <strong>정책의 일관성</strong> 확보.</li><li><strong>약점</strong>: <strong>DB 별 의미 차이</strong> 반영·테스트 필수.</li></ul><table><thead><tr><th>프레임워크</th><th>정확한 기능 (예)</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Hibernate/JPA</td><td><code>@Lock</code>, LockMode, 버전필드</td><td>선언적/낙관·비관 병행</td><td>DB 차이 반영 필요</td></tr><tr><td>Spring</td><td><code>@Transactional(isolation=…)</code></td><td>서비스계 일관성</td><td>엔진 의존</td></tr><tr><td>EF Core</td><td>낙관적 컨커런시 토큰</td><td>충돌 감지·재시도 용이</td><td>비관잠금 제약</td></tr><tr><td>SQLAlchemy</td><td><code>.with_for_update()</code></td><td>SQL 직관성</td><td>조인시 범위 주의</td></tr><tr><td>Django</td><td><code>.select_for_update()</code></td><td>행 잠금 간편</td><td>트랜잭션 관리 필요</td></tr></tbody></table><ul><li><strong>요약</strong>: <strong>코드에서 락/격리</strong>를 명시하고, <strong>DB 별 테스트</strong>로 의미 일치 확인.</li></ul><h6 id=운영-operations>운영 (Operations)<a hidden class=anchor aria-hidden=true href=#운영-operations>#</a></h6><ul><li><strong>내용</strong>: Extended Events 세션·차단 보고, sp_WhoIsActive(리드 블로커), Postgres 전용 SaaS/스크립트 (pganalyze 등).</li><li><strong>역할/용도</strong>: <strong>블로킹/데드락</strong> 패턴 탐지·알림·원인 분석, <strong>에스컬레이션</strong> 점검.</li><li><strong>강점</strong>: 실전 대응 시간 단축.</li><li><strong>약점</strong>: 툴 학습/라이선스·권한 고려.</li></ul><table><thead><tr><th>도구</th><th>기능</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>Extended Events</td><td>락/대기/데드락 수집·분석</td><td>저오버헤드·정밀</td><td>설정 난이도</td></tr><tr><td>sp_WhoIsActive</td><td>블로킹 체인 실시간 파악</td><td>즉시 대응</td><td>설치 필요</td></tr><tr><td>pganalyze 등</td><td>락 트리 시각화·알림</td><td>편의성·대시보드</td><td>비용/에이전트</td></tr></tbody></table><ul><li><strong>요약</strong>: <strong>XE/DMV 또는 전용 도구</strong>로 <strong>원인→영향</strong>을 연결해 본질 문제를 고친다.</li></ul><h6 id=분산-distributed-coordination>분산 (Distributed Coordination)<a hidden class=anchor aria-hidden=true href=#분산-distributed-coordination>#</a></h6><ul><li><strong>내용</strong>: ZooKeeper/Curator 레시피, etcd concurrency API, Redisson RLock.</li><li><strong>역할/용도</strong>: DB 외부에서 <strong>서비스 간 상호배타</strong>·리더선출.</li><li><strong>강점</strong>: 마이크로서비스/잡 스케줄링 등에서 충돌 완화.</li><li><strong>약점</strong>: <strong>멱등성/네트워크 분할/타임아웃</strong> 설계가 필수.</li></ul><table><thead><tr><th>도구</th><th>기능</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>ZooKeeper/Curator</td><td>분산 락 레시피</td><td>표준성·성숙</td><td>운영 복잡</td></tr><tr><td>etcd concurrency</td><td>분산 Mutex/선거</td><td>간명한 API</td><td>리스 관리 필요</td></tr><tr><td>Redisson</td><td>RLock/공정락 등</td><td>통합 쉬움</td><td>클러스터 고려</td></tr></tbody></table><ul><li><strong>요약</strong>: <strong>DB 락 + 분산 락</strong>을 병행하여 <strong>데이터 내부/외부 경합</strong>을 모두 설계한다.</li></ul><h5 id=락-도구프레임워크-통합-일람표>락 도구·프레임워크 통합 일람표<a hidden class=anchor aria-hidden=true href=#락-도구프레임워크-통합-일람표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 도구/프레임워크</th><th>정확한 기능/용도</th><th>강점</th><th>약점</th></tr></thead><tbody><tr><td>관측</td><td>Postgres <code>pg_locks</code>/<code>pg_stat_activity</code></td><td>보유/대기 락·세션 상태 교차 분석</td><td>내장·즉시성</td><td>상관 쿼리 필요</td></tr><tr><td></td><td>MySQL Performance Schema</td><td><code>data_locks</code>/<code>data_lock_waits</code> 로 충돌 가시화</td><td>세밀 지표</td><td>학습/설정</td></tr><tr><td></td><td>SQL Server DMV+XE</td><td>잠금/대기/데드락 이벤트</td><td>저오버헤드</td><td>설정 난이도</td></tr><tr><td>제어</td><td>Hibernate/JPA</td><td><code>@Lock</code>/LockMode/낙관·비관</td><td>선언적 제어</td><td>DB 차이</td></tr><tr><td></td><td>Spring</td><td><code>@Transactional</code> 격리·전파</td><td>서비스계 일관성</td><td>엔진 의존</td></tr><tr><td></td><td>EF Core</td><td>낙관적 컨커런시</td><td>충돌 처리 용이</td><td>비관잠금 제약</td></tr><tr><td></td><td>SQLAlchemy/Django</td><td><code>with_for_update</code>/<code>select_for_update</code></td><td>SQL 직관성</td><td>범위 주의</td></tr><tr><td>운영</td><td>Extended Events</td><td>차단/데드락 수집·분석 (Profiler 대체)</td><td>공식 대체</td><td>학습 곡선</td></tr><tr><td></td><td>sp_WhoIsActive</td><td>블로킹 체인 파악</td><td>신속 대응</td><td>배포 필요</td></tr><tr><td>분산</td><td>ZooKeeper/Curator</td><td>분산 락/선거 레시피</td><td>성숙</td><td>운영 복잡</td></tr><tr><td></td><td>etcd concurrency</td><td>분산 Mutex/선거</td><td>간결</td><td>리스 관리</td></tr><tr><td></td><td>Redisson</td><td>RLock/공정락 등</td><td>통합 용이</td><td>네트워크 변수</td></tr></tbody></table><p>엔진 <strong>내장 관측→코드 수준 제어→운영 자동화→분산 조정</strong>으로 이어지는 계층을 맞물리면, <strong>락 호환성 매트릭스</strong>의 효과 (안전한 충돌 회피) 를 <strong>성능/확장성</strong>과 함께 가져갈 수 있다.</p><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-python-으로-sx-lock-호환성-매트릭스-구현>실습 예제: Python 으로 S/X Lock 호환성 매트릭스 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-python-으로-sx-lock-호환성-매트릭스-구현>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>락 호환성 매트릭스의 기본 원리를 코드로 직접 경험하고 여러 트랜잭션의 동시 접속 허용/차단을 시뮬레이션</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>Python 3.x, 표준 라이브러리만 필요</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>1 단계: 락 모드 및 호환성 매트릭스 설계</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 락 모드 정의 및 매트릭스 모델 (주석 포함)</span>
</span></span><span class=line><span class=cl><span class=n>LOCK_MODES</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>COMPATIBILITY_MATRIX</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>):</span> <span class=kc>True</span><span class=p>,</span>   <span class=c1># 공유끼리 허용</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>):</span> <span class=kc>False</span><span class=p>,</span>  <span class=c1># S와 X 충돌</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;X&#39;</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>):</span> <span class=kc>False</span><span class=p>,</span>  <span class=c1># X와 S 충돌</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=s1>&#39;X&#39;</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>):</span> <span class=kc>False</span><span class=p>,</span>  <span class=c1># 배타적끼리 충돌</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>check_compatibility</span><span class=p>(</span><span class=n>current_locks</span><span class=p>,</span> <span class=n>requested_lock</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;현재 락들 중 요청 락과 충돌 여부 검사 함수&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>lock</span> <span class=ow>in</span> <span class=n>current_locks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>COMPATIBILITY_MATRIX</span><span class=o>.</span><span class=n>get</span><span class=p>((</span><span class=n>lock</span><span class=p>,</span> <span class=n>requested_lock</span><span class=p>),</span> <span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 트랜잭션 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 트랜잭션별 데이터 락 요청 및 호환성 체크 (주석 포함)</span>
</span></span><span class=line><span class=cl><span class=n>current_locks</span> <span class=o>=</span> <span class=p>[</span><span class=s1>&#39;S&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>requested_lock</span> <span class=o>=</span> <span class=s1>&#39;X&#39;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>check_compatibility</span><span class=p>(</span><span class=n>current_locks</span><span class=p>,</span> <span class=n>requested_lock</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;호환됨: 락 획득 가능&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;충돌: 락 획득 불가&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><p>호환됨: S 락끼리는 동시 가능<br>충돌: S/X 또는 X/X 는 동시 불가</p><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>락 모드 추가 (IS/IX/SIX), 복수 트랜잭션 동시 접근, 데드락 상황 실험 등으로 확장 가능</li></ul><h5 id=실습-예제--동일-레코드-갱신-충돌-시-호환성-관찰-psql--python>실습 예제: " 동일 레코드 갱신 충돌 시 호환성 관찰 (PSQL + Python)&rdquo;<a hidden class=anchor aria-hidden=true href=#실습-예제--동일-레코드-갱신-충돌-시-호환성-관찰-psql--python>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>S/X/U 모드 호환성과 대기/타임아웃 관찰.</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>PostgreSQL 15+</li><li>psycopg</li><li>두 개 세션.</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p>세션 A: 트랜잭션 시작 후 <code>SELECT … FOR UPDATE</code> 로 레코드 잠금.</p></li><li><p>세션 B: 같은 레코드에 UPDATE 시도 → 대기/타임아웃.</p></li><li><p><code>SKIP LOCKED</code> 로 회피 패턴 실습.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1> 1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2> 2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3> 3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4> 4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5> 5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6> 6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7> 7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8> 8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9> 9</a>
</span><span class=lnt id=hl-11-10><a class=lnlinks href=#hl-11-10>10</a>
</span><span class=lnt id=hl-11-11><a class=lnlinks href=#hl-11-11>11</a>
</span><span class=lnt id=hl-11-12><a class=lnlinks href=#hl-11-12>12</a>
</span><span class=lnt id=hl-11-13><a class=lnlinks href=#hl-11-13>13</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 준비
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>demo</span><span class=p>(</span><span class=n>id</span><span class=w> </span><span class=nb>int</span><span class=w> </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=nb>int</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>demo</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=mi>100</span><span class=p>)</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>CONFLICT</span><span class=w> </span><span class=k>DO</span><span class=w> </span><span class=k>NOTHING</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 세션 A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>demo</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- X와 충돌하는 강한 잠금
</span></span></span><span class=line><span class=cl><span class=c1>-- 커밋 지연
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 세션 B (동시에)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>demo</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 세션 A가 해제할 때까지 대기
</span></span></span><span class=line><span class=cl><span class=c1>-- 타임아웃 설정 가능: SET lock_timeout = &#39;3s&#39;;
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Python 동시성 관찰(의사코드; psycopg 사용)</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>psycopg</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span><span class=o>,</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DSN</span> <span class=o>=</span> <span class=s2>&#34;postgresql://user:pw@localhost:5432/mydb&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>session_a</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>psycopg</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DSN</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT * FROM demo WHERE id=1 FOR UPDATE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>  <span class=c1># 잠금 유지</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>session_b</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>psycopg</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DSN</span><span class=p>,</span> <span class=n>autocommit</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SET lock_timeout = &#39;3000ms&#39;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UPDATE demo SET v=v+1 WHERE id=1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;B timeout/block:&#34;</span><span class=p>,</span> <span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;ROLLBACK&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>threads</span> <span class=o>=</span> <span class=p>[</span><span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>session_a</span><span class=p>),</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>session_b</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>t</span><span class=o>.</span><span class=n>start</span><span class=p>()</span> <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>t</span><span class=o>.</span><span class=n>join</span><span class=p>()</span> <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><ul><li>세션 B 는 A 의 X 급 잠금과 충돌로 <strong>대기→타임아웃</strong>. <code>SKIP LOCKED</code> 로 회피 가능.</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>인덱스 범위 질의 + SERIALIZABLE 에서 팬텀 방지 확인.</li></ul><h4 id=52-실제-도입-사례-분석>5.2 실제 도입 사례 분석<a hidden class=anchor aria-hidden=true href=#52-실제-도입-사례-분석>#</a></h4><h5 id=실제-도입-사례-postgresql-의-다중-그래뉼래리티-락킹>실제 도입 사례: PostgreSQL 의 다중 그래뉼래리티 락킹<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-postgresql-의-다중-그래뉼래리티-락킹>#</a></h5><h6 id=배경-및-도입-이유>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유>#</a></h6><p>PostgreSQL 은 테이블과 행 수준에서 동시에 락킹을 지원해야 하는 필요성에 직면했다.<br>단순한 테이블 레벨 락만으로는 동시성이 떨어지고, 행 레벨 락만으로는 대량 작업 시 오버헤드가 컸습니다.<br>이를 해결하기 위해 의도 락을 포함한 확장된 호환성 매트릭스를 도입했다.</p><h6 id=구현-아키텍처>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처>#</a></h6><pre class=mermaid>graph TB
    subgraph &#34;PostgreSQL Lock Architecture&#34;
        A[Transaction Manager] --&gt; B[Lock Manager]
        B --&gt; C[Lock Table]
        B --&gt; D[Wait Queue]
        C --&gt; E[Table Level Locks]
        C --&gt; F[Row Level Locks]
        E --&gt; G[ACCESS SHARE]
        E --&gt; H[ROW SHARE]
        E --&gt; I[ROW EXCLUSIVE]
        E --&gt; J[SHARE UPDATE EXCLUSIVE]
        E --&gt; K[SHARE]
        E --&gt; L[SHARE ROW EXCLUSIVE]
        E --&gt; M[EXCLUSIVE]
        E --&gt; N[ACCESS EXCLUSIVE]
    end
</pre><p>PostgreSQL 은 8 가지 테이블 레벨 락 모드와 이들 간의 복잡한 호환성 매트릭스를 구현했다.<br>각 락 모드는 특정 SQL 명령에 최적화되어 있다.</p><h6 id=핵심-구현-코드>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span><span class=lnt id=hl-14-24><a class=lnlinks href=#hl-14-24>24</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* PostgreSQL의 락 호환성 매트릭스 (간소화 버전) */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=kt>bool</span> <span class=n>LockConflicts</span><span class=p>[</span><span class=n>MAX_LOCKMODES</span><span class=p>][</span><span class=n>MAX_LOCKMODES</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* AccessShareLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* RowShareLock */</span>  
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* RowExclusiveLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ShareUpdateExclusiveLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ShareLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ShareRowExclusiveLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ExclusiveLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>false</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* AccessExclusiveLock */</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* 락 호환성 확인 함수 */</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>LockModeCompatible</span><span class=p>(</span><span class=n>LOCKMODE</span> <span class=n>lockmode1</span><span class=p>,</span> <span class=n>LOCKMODE</span> <span class=n>lockmode2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=n>LockConflicts</span><span class=p>[</span><span class=n>lockmode1</span><span class=p>][</span><span class=n>lockmode2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과>#</a></h6><ul><li><strong>정량 지표</strong>:<ul><li>동시성 30% 향상 (혼합 워크로드에서)</li><li>락 대기 시간 40% 감소</li><li>DDL 작업 중 SELECT 쿼리 처리 가능</li></ul></li><li><strong>정성 개선</strong>:<ul><li>애플리케이션 개발자의 락 이해도 향상</li><li>데드락 발생률 감소로 운영 안정성 개선</li></ul></li></ul><h6 id=교훈-및-시사점>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점>#</a></h6><p>PostgreSQL 사례에서 얻을 수 있는 핵심 교훈은 <strong>단순함과 완전성의 균형</strong>.<br>8 개의 락 모드는 복잡해 보이지만, 각각이 특정 SQL 명령에 최적화되어 있어 개발자가 명령별로 예상할 수 있는 락 동작을 제공한다.<br>또한 VIEW 를 통한 락 상태 모니터링 기능은 실무에서 매우 유용한 디버깅 도구가 되고 있다.</p><h5 id=실제-도입-사례-postgresql-대형-트랜잭션-db>실제 도입 사례: PostgreSQL 대형 트랜잭션 DB<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-postgresql-대형-트랜잭션-db>#</a></h5><h6 id=배경-및-도입-이유-1>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유-1>#</a></h6><ul><li>금융/쇼핑몰 등 대규모 환경에서 트랜잭션의 무결성과 동시성 보장 핵심 요구</li><li>S/X/Intention Lock 체계 도입으로 운영 효율과 확장성 확보</li></ul><h6 id=구현-아키텍처-1>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처-1>#</a></h6><pre class=mermaid>graph TB
    App[Application Server] --&gt; PG[PostgreSQL DBMS]
    PG --&gt; LockMgr[Lock Manager]
    LockMgr --&gt; Table[Table/Row]
</pre><h6 id=핵심-구현-코드-1>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드-1>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3>3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4>4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 실무에서는 Transaction Manager가 SQL 레벨에서 락 제어함</span>
</span></span><span class=line><span class=cl><span class=c1># (실제 코드로는 python ORM/SQL에서 read/write 전에 락 확인)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>acquire_lock</span><span class=p>(</span><span class=n>db</span><span class=p>,</span> <span class=n>table</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>,</span> <span class=n>txn</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># db 내 table의 lock manager가 현재 락 타입 확인 후 허용/거부</span>
</span></span><span class=line><span class=cl>    <span class=k>pass</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과-1>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과-1>#</a></h6><ul><li>여러 트랜잭션이 동시 처리돼도 Dirty Read/Lost Update 없이 안정적 운영</li><li>락 경합 발생시에도 빠른 탐지 및 자동 롤백으로 서비스 중단 대폭 감소</li></ul><h6 id=교훈-및-시사점-1>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점-1>#</a></h6><ul><li>락 호환성 및 매트릭스 관리가 자동화되어 있더라도, 고성능 시스템에서는 락 충돌/대기/데드락 이슈를 모니터링하고 최적화하는 절차가 반드시 필요하다</li></ul><h4 id=락-매트릭스-연계운영-아키텍처>락 매트릭스 연계·운영 아키텍처<a hidden class=anchor aria-hidden=true href=#락-매트릭스-연계운영-아키텍처>#</a></h4><p>락 매트릭스는 &ldquo;<strong>같이 잡아도 되는가?</strong>&rdquo; 를 표로 빠르게 판단한다. 하지만 <strong>실서비스</strong>에서는 이 판단이 <strong>MVCC·범위락·분산 합의·메시징·복구·관측</strong>과 <strong>함께</strong> 설계되어야 전체 일관성과 처리량이 나온다.</p><h5 id=락-매트릭스-연계-아키텍처-지도>락 매트릭스 연계 아키텍처 지도<a hidden class=anchor aria-hidden=true href=#락-매트릭스-연계-아키텍처-지도>#</a></h5><table><thead><tr><th>통합 축</th><th>왜 (문제/목표)</th><th>무엇 (핵심 개념)</th><th>어떻게 (연계 방식)</th><th>획득 가치</th></tr></thead><tbody><tr><td>DB 내부 (MVCC·범위락·MGL)</td><td>읽기 비차단·팬텀 방지·계층 충돌 최소화</td><td>MVCC, 넥스트 - 키/갭락, IS/IX/SIX</td><td>읽기는 MVCC, 직렬 필요 구간만 <strong>레인지락</strong> 활성·MGL 로 상→하 의도 잠금</td><td>동시성↑, 직렬성 요구 구간만 비용 지불.</td></tr><tr><td>분산/합의·복제</td><td>노드/리전 분산에서 동일 락·커밋 보장</td><td>2PC, Paxos/Raft, 분산 락 (세션/리스)</td><td>트랜잭션은 <strong>2PC</strong>, 메타데이터/리더선정· coarse lock 은 <strong>ZooKeeper/etcd</strong></td><td>일관성·가용성 균형, 리더 기반 직렬화.</td></tr><tr><td>메시징/이벤트</td><td>DB 변경과 이벤트 발행의 원자성</td><td>Outbox, CDC, Idempotent/Transactional Producer</td><td>DB 트랜잭션에 outbox 쓰기→CDC(Debezium)→Kafka 전송; 프로듀서 <strong>EOS</strong>/컨슈머 <strong>Idempotent</strong></td><td>이중쓰기 불일치 제거·재시도 안전.</td></tr><tr><td>로그/복구/CDC</td><td>충돌/장애 시 재실행과 데이터 복구</td><td>WAL/ARIES, Logical Decoding</td><td>변경을 WAL 에 선기록→복구·CDC 로 외부 파이프 전달</td><td>내구성·포렌식·아웃박스에 근거 제공.</td></tr><tr><td>관측/모니터링</td><td>락 대기·데드락 가시화·튜닝</td><td>pg_locks, Performance Schema, Extended Events, OTel</td><td>시스템 뷰/이벤트로 락·대기·데드락 수집, OTel 로 지표/트레이싱</td><td>원인 추적·임계치/에스컬레이션 튜닝 근거.</td></tr><tr><td>캐시 연계</td><td>읽기 경합·차단 완화</td><td>Cache-Aside</td><td>캐시 미스시 DB 조회·쓰기, 적절 만료/무효화</td><td>읽기 부하 우회·락 경합 감소.</td></tr></tbody></table><h5 id=락-연계-기술-6-대-카테고리>락 연계 기술 6 대 카테고리<a hidden class=anchor aria-hidden=true href=#락-연계-기술-6-대-카테고리>#</a></h5><h6 id=db-내부-일관성-보강>DB 내부 일관성 보강<a hidden class=anchor aria-hidden=true href=#db-내부-일관성-보강>#</a></h6><ul><li><strong>목적</strong>: 읽기 비차단과 직렬가능 구간의 공존.</li><li><strong>방법</strong>: 기본은 <strong>MVCC</strong>, 직렬성이 필요한 쿼리·구간은 <strong>넥스트 - 키/레인지락</strong> 활성. MGL(IS/IX/SIX) 로 상위에서 충돌 신호.</li></ul><table><thead><tr><th>요소</th><th>적용 포인트</th><th>주의</th></tr></thead><tbody><tr><td>MVCC</td><td>읽기 경합 완화</td><td>SI 는 비직렬 사례 존재→SSI/범위락 병행</td></tr><tr><td>넥스트 - 키</td><td>팬텀 방지</td><td>스캔 범위가 넓으면 차단↑</td></tr><tr><td>MGL</td><td>계층 충돌 최소</td><td>에스컬레이션 임계 튜닝</td></tr></tbody></table><ul><li><strong>요약</strong>: " 대부분은 MVCC 로, 꼭 필요한 범위만 강하게 잠근다."</li></ul><h6 id=분산-합의복제리더십분산-락>분산 합의·복제/리더십·분산 락<a hidden class=anchor aria-hidden=true href=#분산-합의복제리더십분산-락>#</a></h6><ul><li><strong>목적</strong>: 멀티노드에서 동일한 커밋·락 의미 보장.</li><li><strong>방법</strong>: 트랜잭션은 <strong>2PC</strong>, 메타데이터/리더·coarse 락은 <strong>ZooKeeper/etcd(리스 기반)</strong>, 글로벌 DB 는 <strong>합의 +2PC(Spanner)</strong>.</li></ul><table><thead><tr><th>요소</th><th>역할</th><th>포인트</th></tr></thead><tbody><tr><td>2PC</td><td>분산 커밋</td><td>가용성 - 일관성 트레이드오프</td></tr><tr><td>ZooKeeper/etcd 락</td><td>리더·분산 락</td><td>세션/리스 만료로 안전 해제</td></tr><tr><td>TrueTime+ 합의</td><td>외부일관성/직렬화</td><td>잠금 비용 줄인 강일관성 읽기</td></tr></tbody></table><ul><li><strong>요약</strong>: " 글로벌 일관성은 <strong>합의 +2PC</strong>로, 운영 락은 <strong>분산 락 서비스</strong>로."</li></ul><h6 id=메시징-연계-outboxkafka-eos멱등성>메시징 연계 (Outbox·Kafka EOS·멱등성)<a hidden class=anchor aria-hidden=true href=#메시징-연계-outboxkafka-eos멱등성>#</a></h6><ul><li><strong>목적</strong>: DB 상태와 이벤트 발행의 원자성, 중복 안전.</li><li><strong>방법</strong>: 서비스는 트랜잭션 안에서 <strong>Outbox</strong> 테이블에 기록→<strong>Debezium CDC</strong>가 Kafka 로 전송. <strong>Idempotent/Transactional Producer</strong>와 <strong>Idempotent Consumer</strong>로 재시도·중복 대응.</li></ul><table><thead><tr><th>요소</th><th>효과</th><th>포인트</th></tr></thead><tbody><tr><td>Outbox+CDC</td><td>이중쓰기 분리·원자성</td><td>DB 커밋=이벤트 발행 근거</td></tr><tr><td>Kafka EOS</td><td>다파티션 원자 쓰기</td><td>Tx Producer/Idempotent</td></tr><tr><td>멱등성 키 (API)</td><td>재시도 안전</td><td>요청 재실행=동일 결과</td></tr></tbody></table><ul><li><strong>요약</strong>: &ldquo;DB 커밋을 <strong>출발점</strong>으로, 메시지는 <strong>멱등·트랜잭션</strong>으로.&rdquo;</li></ul><h6 id=로그복구cdc-연동>로그·복구·CDC 연동<a hidden class=anchor aria-hidden=true href=#로그복구cdc-연동>#</a></h6><ul><li><strong>목적</strong>: 장애/재시도에서 <strong>정합 복원</strong>과 외부 연동.</li><li><strong>방법</strong>: <strong>WAL/ARIES</strong>로 선기록→복구, <strong>Logical Decoding</strong>으로 변경 스트림을 생성 (Outbox/데이터 파이프).</li></ul><table><thead><tr><th>요소</th><th>역할</th><th>포인트</th></tr></thead><tbody><tr><td>WAL/ARIES</td><td>내구성·복구</td><td>로그 우선·재실행</td></tr><tr><td>Logical Decoding</td><td>CDC 스트림</td><td>슬롯·플러그인 포맷</td></tr></tbody></table><ul><li><strong>요약</strong>: &ldquo;<strong>로그가 진실의 원천</strong>—복구·CDC 의 근거.&rdquo;</li></ul><h6 id=관측모니터링-시스템-뷰이벤트otel>관측/모니터링 (시스템 뷰·이벤트·OTel)<a hidden class=anchor aria-hidden=true href=#관측모니터링-시스템-뷰이벤트otel>#</a></h6><ul><li><strong>목적</strong>: 락 대기/데드락/에스컬레이션 <strong>가시화와 튜닝</strong>.</li><li><strong>방법</strong>: Postgres <strong>pg_locks</strong>/Wait Events, MySQL <strong>Performance Schema data_locks/data_lock_waits</strong>, SQL Server <strong>Extended Events(deadlock)</strong>, OTel <strong>DB span/metrics</strong>.<br>**</li></ul><table><thead><tr><th>요소</th><th>무엇을 봄</th><th>활용</th></tr></thead><tbody><tr><td>pg_locks</td><td>보유/대기 락</td><td>핫스팟·대기 그래프 파악</td></tr><tr><td>data_locks/_waits</td><td>보유↔대기 매핑</td><td>차단 체인 분석</td></tr><tr><td>Extended Events</td><td>데드락 그래프</td><td>원인 SQL·리소스 특정</td></tr><tr><td>OTel SemConv</td><td>지연/에러 지표</td><td>서비스 전반 트레이싱</td></tr></tbody></table><ul><li><strong>요약</strong>: " 잠금은 <strong>보이는 순간</strong> 해결이 빨라진다."</li></ul><h6 id=캐시-연계-cache-aside>캐시 연계 (Cache-Aside)<a hidden class=anchor aria-hidden=true href=#캐시-연계-cache-aside>#</a></h6><ul><li><strong>목적</strong>: 읽기 경합·락 대기 감소.</li><li><strong>방법</strong>: <strong>Cache-Aside</strong>로 캐시 미스시 DB 조회 후 캐시에 저장, 만료·무효화 정책 정립.**</li></ul><table><thead><tr><th>요소</th><th>효과</th><th>주의</th></tr></thead><tbody><tr><td>Cache-Aside</td><td>읽기 부하 우회</td><td>일관성/TTL·무효화</td></tr></tbody></table><ul><li><strong>요약</strong>: " 읽기는 캐시가, 무결성은 DB 가."</li></ul><h5 id=락-연계-기술-한눈에-보기>락 연계 기술 한눈에 보기<a hidden class=anchor aria-hidden=true href=#락-연계-기술-한눈에-보기>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 기술</th><th>왜</th><th>어떻게</th><th>기대 효과</th></tr></thead><tbody><tr><td>A DB 내부</td><td>MVCC·넥스트 - 키·MGL</td><td>읽기 비차단·팬텀 방지</td><td>MVCC 기본, 직렬 구간만 레인지락</td><td>동시성↑, 필요한 곳만 강보호</td></tr><tr><td>B 분산/합의</td><td>2PC·Paxos/Raft·분산락</td><td>노드 간 동일 의미</td><td>2PC 커밋, 리더·coarse 락은 ZooKeeper/etcd</td><td>글로벌 일관성·가용성 균형</td></tr><tr><td>C 메시징</td><td>Outbox·Debezium·Kafka EOS·멱등성</td><td>DB↔이벤트 원자성</td><td>트랜잭션 내 outbox, CDC→Kafka, EOS/Idempotent</td><td>이중쓰기 불일치 제거·중복 안전</td></tr><tr><td>D 로그/복구/CDC</td><td>WAL/ARIES·Logical Decoding</td><td>장애 복구/변경 전파</td><td>로그 선기록·복구, 로그 디코딩으로 스트림</td><td>내구성·데이터 파이프 기반</td></tr><tr><td>E 관측</td><td>pg_locks·PerfSchema·Ext.Events·OTel</td><td>원인 추적/튜닝</td><td>락/대기/데드락 수집·추적</td><td>병목 제거·임계치 최적화</td></tr><tr><td>F 캐시</td><td>Cache-Aside</td><td>읽기 락 경합 완화</td><td>캐시 미스시 로드·만료/무효화</td><td>대기 단축·처리량↑</td></tr></tbody></table><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>LCM 은 &ldquo;<strong>어떤 락끼리 같이 써도 되는가</strong>&rdquo; 를 미리 만든 <strong>표</strong>다. 데이터가 테이블→행→인덱스 키처럼 <strong>계층</strong>이기 때문에, 하위에서 락을 잡을 계획이면 상위에 <strong>의도 락 (IS/IX/SIX)</strong> 으로 신호를 준다. 읽기만 많이 할 땐 <strong>S↔S</strong>가 함께 가능해 처리량이 올라가고, 쓰기 경쟁은 <strong>X</strong>로 고립된다.<br>범위 검색에서는 새 행이 끼어드는 <strong>팬텀</strong>을 막아야 하는데, PostgreSQL 은 <strong>프레디케이트 (SIREAD)</strong>, SQL Server 는 <strong>키 - 범위</strong>, MySQL 은 <strong>넥스트키</strong>로 해결한다. 모든 엔진은 2PL 과 LCM 을 묶어, <strong>허용/대기</strong>를 즉시 결정해 <strong>정확성과 성능</strong>을 동시에 챙긴다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>단계/영역</th><th>핵심 체크포인트</th><th>주요 작업</th><th>핵심 지표/알림</th><th>대표 도구/명령</th><th>근거</th></tr></thead><tbody><tr><td>도입/설계</td><td>일관성·격리수준 정의, 경합 표면 최소화</td><td>인덱스/파티션 설계, 범위 보호 (필요 시)</td><td>예상 대기·타임아웃 예산</td><td>(공통) 설계 문서/아키텍처 리뷰</td><td>InnoDB 넥스트키, Oracle LOCK TABLE (<a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-next-key-locking.html?utm_source=chatgpt.com" title="MySQL 8.4 Reference Manual :: 17.7.4 Phantom Rows">MySQL 개발자 존</a>)</td></tr><tr><td>운영/모니터링</td><td>대기/데드락/에스컬레이션 상시 관측</td><td>대시보드/알림, 로그 기반 잠금 대기 추적</td><td>락 대기시간, 데드락 수, 타임아웃 수</td><td>Postgres <code>pg_locks</code>,<code>pg_stat_activity</code>,<code>log_lock_waits</code></td><td>PG 뷰·파라미터 문서 (<a href="https://www.postgresql.org/docs/current/view-pg-locks.html?utm_source=chatgpt.com" title="Documentation: 17: 52.12. pg_locks">PostgreSQL</a>)</td></tr><tr><td>〃</td><td>〃</td><td>〃</td><td>〃</td><td>MySQL <code>performance_schema.data_locks</code>/<code>data_lock_waits</code></td><td>InnoDB Locking/PS 문서 (<a href="https://dev.mysql.com/doc/refman/8.2/en/innodb-locking.html?utm_source=chatgpt.com" title="MySQL 8.4 Reference Manual :: 17.7.1 InnoDB Locking">MySQL 개발자 존</a>)</td></tr><tr><td>〃</td><td>〃</td><td>〃</td><td>〃</td><td>SQL Server <code>sys.dm_tran_locks</code> + Extended Events</td><td>DMV/XE 공식 문서 (<a href="https://learn.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-tran-locks-transact-sql?view=sql-server-ver17&amp;utm_source=chatgpt.com" title="sys.dm_tran_locks (Transact-SQL) - SQL Server">Microsoft Learn</a>)</td></tr><tr><td>트러블슈팅</td><td>블로킹 체인 파악, 범위 겹침 여부</td><td>긴 트랜잭션 분리, 락 순서 통일, 인덱스 보강</td><td>평균 대기/최장 대기, 차단 세션 수</td><td>엔진별 뷰/DMV/PS + 쿼리 재계획</td><td>InnoDB 스캔→락 범위 설명 (<a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locks-set.html?utm_source=chatgpt.com" title="17.7.3 Locks Set by Different SQL Statements in InnoDB">MySQL 개발자 존</a>)</td></tr><tr><td>확장/분산</td><td>읽기 - 쓰기 분리·샤딩, 최신 기능</td><td>읽기 복제본/RCSI·SI, 샤딩·파티션, Optimized Locking</td><td>대기 분포, 에스컬레이션 수</td><td>엔진 옵션 (RCSI/SI), SQL Server Optimized Locking</td><td>공식 가이드·기능 문서 (<a href="https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver17&amp;utm_source=chatgpt.com" title="Transaction locking and row versioning guide - SQL Server">Microsoft Learn</a>)</td></tr><tr><td>변경관리</td><td>정책·임계치·테스트 주기화</td><td>데드락 정책/로그 리뷰, 릴리스 전후 락 회귀 테스트</td><td>릴리스별 대기·데드락 추이</td><td>CI 파이프라인·부하테스트</td><td>PG <code>log_lock_waits</code> 활용 (<a href="https://www.postgresql.org/docs/current/runtime-config-locks.html?utm_source=chatgpt.com" title="Documentation: 17: 19.12. Lock Management">PostgreSQL</a>)</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th>Phase</th><th style=text-align:right>기간 (권장)</th><th>핵심 주제</th><th>성과물 (Outcome)</th><th>필수 레퍼런스</th></tr></thead><tbody><tr><td>1 기본</td><td style=text-align:right>1–2 주</td><td>모드 (S/X/IS/IX/SIX), 5×5 매트릭스, 2PL</td><td>미니 락 매니저 (요청→판정→대기/해제) 구현 노트</td><td>PG Explicit Locking, LOCK 문서 (<a href="https://www.postgresql.org/docs/current/explicit-locking.html?utm_source=chatgpt.com" title="Documentation: 17: 13.3. Explicit Locking">PostgreSQL</a>)</td></tr><tr><td>2 MGL</td><td style=text-align:right>2–3 주</td><td>의도 잠금·계층 락킹·에스컬레이션</td><td>IS/IX/SIX 시나리오 도식·호환성 퀴즈</td><td>Gray MGL 논문 (<a href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/GrayLocks.pdf?utm_source=chatgpt.com" title="Granularity of Locks and Degrees of Consistency in …">CMU 컴퓨터 과학 학교</a>)</td></tr><tr><td>3 범위</td><td style=text-align:right>3–4 주</td><td>프레디케이트·키 - 레인지·넥스트 - 키</td><td>InnoDB 데모 (갭/넥스트 - 키) 재현 스크립트</td><td>EGLT·MySQL 문서 (<a href="https://www.csd.uoc.gr/~hy460/pdf/p624-eswaran.pdf?utm_source=chatgpt.com" title="The Notions of Consistency and Predicate Locks in …">컴퓨터 과학 부서 - 크레타 대학교</a>)</td></tr><tr><td>4 MVCC/SSI</td><td style=text-align:right>4–5 주</td><td>SI 특성·SSI·범위락 병행</td><td>SI 에서의 비직렬 사례 재현·SSI/레인지락 비교표</td><td>Fekete 2005 (<a href="https://dsf.berkeley.edu/cs286/papers/ssi-tods2005.pdf?utm_source=chatgpt.com" title="Making Snapshot Isolation Serializable">버클리 데이터 시스템 및 기초 그룹</a>)</td></tr><tr><td>5 제품별/운영</td><td style=text-align:right>지속</td><td>엔진별 차이·모니터링·튜닝</td><td><code>pg_locks</code>/Perf Schema/Ext.Events 대기 분석 리포트, <code>SKIP LOCKED</code> 큐 소비기</td><td>PG/SQL Server 가이드 (<a href="https://www.postgresql.org/docs/current/sql-select.html?utm_source=chatgpt.com" title="Documentation: 17: SELECT">PostgreSQL</a>)</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th>단계</th><th>세부 항목</th><th>목표</th><th>실무 연관성</th><th>설명</th></tr></thead><tbody><tr><td>1 기본</td><td>모드 정의 (S/X/IS/IX/SIX)</td><td>각 모드 의미·의도 신호 이해</td><td>높음</td><td>상위→하위 의도 잠금, 실충돌은 S/X/SIX 위주.</td></tr><tr><td>1 기본</td><td>5×5 매트릭스 판독</td><td>허용/충돌 전부 판단</td><td>높음</td><td>" 요청×보유 " 전원 호환일 때만 부여.</td></tr><tr><td>1 기본</td><td>2PL 파이프라인</td><td>Growing/Shrinking·Grant/Wait/Detect</td><td>높음</td><td>데드락 탐지/예방 개념 포함.</td></tr><tr><td>2 MGL</td><td>IS/IX/SIX 규칙</td><td>계층 자원에서 빠른 충돌 판정</td><td>높음</td><td>의도 잠금으로 에스컬 안전화.</td></tr><tr><td>2 MGL</td><td>에스컬레이션</td><td>임계→상위 락 승격 기준</td><td>중간</td><td>메모리·차단 트레이드오프.</td></tr><tr><td>3 범위</td><td>프레디케이트 락</td><td>팬텀 이론 이해</td><td>중간</td><td>실무에선 비용↑, 개념적 기준점.</td></tr><tr><td>3 범위</td><td>넥스트 - 키 (레코드 + 갭)</td><td>팬텀 실무 방지</td><td>높음</td><td>인덱스 스캔 범위에 락 설정.</td></tr><tr><td>4 MVCC/SSI</td><td>SI 와 직렬성 간극</td><td>왜 SSI/범위락이 필요한가</td><td>높음</td><td>SI 만으로는 특정 패턴에서 비직렬.</td></tr><tr><td>4 MVCC/SSI</td><td>SSI/범위락 병행</td><td>직렬 가능 보장 설계</td><td>높음</td><td>워크로드에 맞춘 병용 전략.</td></tr><tr><td>5 제품/운영</td><td><code>SKIP LOCKED</code></td><td>큐 처리 경합 회피</td><td>중간</td><td>멀티 컨슈머 병행 처리.</td></tr><tr><td>5 제품/운영</td><td>관측 지표</td><td>보유/대기/데드락 시각화</td><td>높음</td><td><code>pg_locks</code>·Perf Schema·Ext.Events.</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글, 영문, 약어)</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심 개념</td><td>락 호환성 매트릭스 (Lock Compatibility Matrix, 없음)</td><td>락 모드 간 동시 보유 가능 여부를 2 차원 표로 정리한 규칙 집합. 부여/대기 판단의 기준.</td><td>트랜잭션, 충돌, 동시성</td><td>DDL/DML 설계, 충돌 예측, 성능 튜닝</td></tr><tr><td>프로토콜</td><td>두 단계 잠금 (Two-Phase Locking, 2PL)</td><td>확장 단계 (획득만) 와 수축 단계 (해제만) 로 잠금을 관리해 충돌 직렬성을 보장하는 방식.</td><td>직렬성, 교착</td><td>트랜잭션 정책 수립, 커밋 시 일괄 해제</td></tr><tr><td>락 모드</td><td>공유 락 (Shared Lock, S)</td><td>읽기 공유를 허용하나 쓰기와는 비호환인 잠금 모드.</td><td>읽기 일관성</td><td>SELECT 시 충돌 억제</td></tr><tr><td>락 모드</td><td>배타 락 (Exclusive Lock, X)</td><td>쓰기 전용으로, 다른 모든 락과 거의 비호환.</td><td>쓰기 일관성</td><td>UPDATE/DELETE 시 무결성 보장</td></tr><tr><td>락 모드</td><td>업데이트 락 (Update Lock, U)</td><td>S↔X 전환 시 데드락을 줄이기 위한 중간 모드</td><td>S/X 전환</td><td>갱신 후보 행 선점 시 유용</td></tr><tr><td>락 모드</td><td>의도 락 (Intention Lock, IS/IX/SIX)</td><td>하위 그라뉼러리티에서 잠금을 잡을 의도를 상위 노드에 선언하는 테이블 수준 잠금.</td><td>다중 그라뉼러리티</td><td>대용량 동시성에서 충돌 탐지·비용 절감</td></tr><tr><td>범위·격리</td><td>키 - 범위 락 (Key-Range Lock, 없음)</td><td>인덱스 키와 키 사이의 범위를 보호해 팬텀을 방지하는 잠금 (직렬화 격리 맥락).</td><td>팬텀 리드, SERIALIZABLE</td><td>범위 조회/갱신의 일관성 확보</td></tr><tr><td>범위·격리</td><td>스냅샷 격리 (Snapshot Isolation, SI/RCSI)</td><td>버전 읽기로 읽기 - 쓰기 충돌을 줄이는 격리. 필요 구간만 잠금 강화.</td><td>MVCC, 비차단 읽기</td><td>읽기 우세 워크로드의 대기 감소</td></tr><tr><td>운영·정책</td><td>잠금 에스컬레이션 (Lock Escalation, 없음)</td><td>많은 미세 락을 상위 (페이지/테이블) 락으로 승격해 리소스를 절약. Learn][5])</td><td>메모리 관리, 경합</td><td>대량 처리 시 자동/정책 기반 승격</td></tr><tr><td>운영·정책</td><td>데드락 (Deadlock, 없음)</td><td>트랜잭션들이 서로의 자원을 기다려 진행 불가인 순환 대기 상태.</td><td>Wait-for 그래프</td><td>감지기/피해자 선택, 재시도 설계</td></tr><tr><td>운영·정책</td><td>락 타임아웃 (Lock Timeout, 없음)</td><td>대기 시간이 임계치를 넘으면 요청을 중단하는 정책.</td><td>서비스 수준, 재시도</td><td>SLA 보호, 재시도·멱등 처리</td></tr><tr><td>모니터링·진단</td><td>락 관리자 (Lock Manager, 없음)</td><td>락 테이블·대기열을 관리하고 호환성 판정을 수행하는 엔진 구성요소.</td><td>호환성 매트릭스</td><td>부여/대기 결정, 통계 수집</td></tr><tr><td>모니터링·진단</td><td>락 테이블/대기열 (Lock Table/Queue, 없음)</td><td>현재 보유/대기 락의 상태 저장 구조.</td><td>Wait-for 그래프</td><td>병목 분석, 우선순위 조정</td></tr><tr><td>모니터링·진단</td><td>대기 - 그래프 (Wait-for Graph, 없음)</td><td>트랜잭션 간 대기 관계를 나타내는 그래프 (사이클=데드락).</td><td>데드락 감지</td><td>자동 감지·피해자 선정</td></tr><tr><td>모니터링·진단</td><td>잠금 모니터링 뷰 (pg_locks 등, 없음)</td><td>현재 잠금 현황을 조회하는 뷰/DMV. PostgreSQL 의 pg_locks 가 대표적.</td><td>블로킹, 경합</td><td>실시간 진단·튜닝</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/current/mvcc.html>PostgreSQL Documentation – Concurrency Control (MVCC & Locks)</a></li><li><a href=https://www.postgresql.org/docs/current/explicit-locking.html>PostgreSQL Documentation – Explicit Locking</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html>MySQL 8.0 Reference – InnoDB Locking</a></li><li><a href=https://learn.microsoft.com/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide>Microsoft SQL Server – Transaction Locking and Row Versioning Guide</a></li><li><a href=https://docs.oracle.com/en/database/oracle/oracle-database/21/cncpt/data-concurrency-and-consistency.html>Oracle Database Concepts – Data Concurrency and Consistency</a></li><li><a href="https://www.ibm.com/docs/en/db2/11.5?topic=isolation-locking">IBM Db2 Documentation – Locking</a></li><li><a href=https://docs.mongodb.com/manual/faq/concurrency/>MongoDB Manual – FAQ: Concurrency</a></li><li><a href=https://www.cockroachlabs.com/docs/stable/architecture/transaction-layer.html>CockroachDB Docs – Transaction Layer</a></li><li><a href=https://zookeeper.apache.org/doc/r3.7.0/recipes.html>Apache ZooKeeper – Recipes and Solutions (Locks 섹션 포함)</a></li><li><a href=https://research.google/pubs/pub39966/>Google Research – Spanner: TrueTime and External Consistency</a></li><li><a href=https://velog.io/@impala/DB-Concurrency-Control>Velog – DB Concurrency Control</a></li><li><a href=https://bako94.tistory.com/157>Tistory – Multiple Granularity Locking</a></li><li><a href=https://velog.io/@ekxk1234/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-JPA%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B0-Lock%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0>Velog – Lock의 종류와 적용 사례</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>