<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lock Modes | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Concurrency-Control,Locking,Lock-Modes"><meta name=description content="락 모드는 자원 접근의 허용 범위를 규정해 일관성과 동시성을 관리한다. S/X/U와 Intent 계열은 계층적 락 조정에, gap/next-key/predicate 등 범위형 락은 팬텀을 방지한다. DBMS별 용어·정책 차이를 확인하고 트랜잭션 패턴에 맞춰 레벨·격리·인덱스를 조정하면 성능과 일관성 균형을 맞출 수 있다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Lock Modes"><meta property="og:description" content="락 모드는 자원 접근의 허용 범위를 규정해 일관성과 동시성을 관리한다. S/X/U와 Intent 계열은 계층적 락 조정에, gap/next-key/predicate 등 범위형 락은 팬텀을 방지한다. DBMS별 용어·정책 차이를 확인하고 트랜잭션 패턴에 맞춰 레벨·격리·인덱스를 조정하면 성능과 일관성 균형을 맞출 수 있다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Lock Modes"><meta name=twitter:description content="락 모드는 자원 접근의 허용 범위를 규정해 일관성과 동시성을 관리한다. S/X/U와 Intent 계열은 계층적 락 조정에, gap/next-key/predicate 등 범위형 락은 팬텀을 방지한다. DBMS별 용어·정책 차이를 확인하고 트랜잭션 패턴에 맞춰 레벨·격리·인덱스를 조정하면 성능과 일관성 균형을 맞출 수 있다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"Lock Modes","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Lock Modes</h1><div class=post-description>락 모드는 자원 접근의 허용 범위를 규정해 일관성과 동시성을 관리한다. S/X/U와 Intent 계열은 계층적 락 조정에, gap/next-key/predicate 등 범위형 락은 팬텀을 방지한다. DBMS별 용어·정책 차이를 확인하고 트랜잭션 패턴에 맞춰 레벨·격리·인덱스를 조정하면 성능과 일관성 균형을 맞출 수 있다.</div></header><div class=post-content><h2 id=lock-modes>Lock Modes<a hidden class=anchor aria-hidden=true href=#lock-modes>#</a></h2><p>락 모드는 트랜잭션의 동시 접근을 제어해 일관성을 보장하는 핵심 수단이다.<br>기본적으로 S(공유) 와 X(배타) 를 시작으로 U(업데이트), Intent(IS/IX/SIX) 와 범위 락 (Range/Gap/Predicate), Schema 락 등으로 세분화된다. 범위 락은 인덱스의 빈 공간이나 조건 (프레디케이트) 에 대해 팬텀을 방지한다.</p><p>데이터베이스마다 구현이 다르다:</p><ul><li>PostgreSQL 은 논리적 predicate lock 으로 범위를 표현하고, MySQL InnoDB 는 레코드 락과 gap 락을 결합한 next-key 로 phantom 을 제어하며, SQL Server 는 Range 락을 통해 유사한 목적을 달성한다.</li></ul><p>락의 호환성 매트릭스 (예: S 끼리는 허용, S 와 X 는 충돌) 는 데드락과 성능에 직접 영향주며, 이를 완화하려면 적절한 인덱스 설계·짧은 트랜잭션·작업 분리·격리 수준 조정이 필요하다.<br>현대 시스템은 MVCC 나 SSI 같은 버전 기반 기법과 결합해 읽기 성능과 일관성 사이에서 균형을 맞춘다.<br>모니터링은 대기 그래프·블로킹 세션·데드락 로그를 확인해 병목과 정책을 개선하는 방향으로 진행한다.</p><h3 id=트랜잭션-락-모드와-실무-적용-구조>트랜잭션 락 모드와 실무 적용 구조<a hidden class=anchor aria-hidden=true href=#트랜잭션-락-모드와-실무-적용-구조>#</a></h3><p>데이터베이스의 동시성은 여러 트랜잭션이 같은 데이터를 동시에 다룰 때도 일관성을 보장해야 하는 문제다.<br>락 모드는 그 도구로, 읽기 전용엔 <strong>S(공유)</strong>, 쓰기 필요시엔 **X(배타)**를 사용하며, **U(업데이트)**는 읽은 후 갱신할 가능성이 있는 경우 데드락을 줄이기 위해 중간 역할을 한다.<br>상위 객체 (테이블) 에는 <strong>IS/IX</strong> 같은 의도 락을 두어 하위 (행) 락 존재를 빠르게 알 수 있다.</p><p>범위 검색이나 인덱스 스캔에는 단순 행 락만으로는 부족해 <strong>gap/next-key/predicate</strong> 같은 범위 락을 써서 새로운 행 (팬텀) 이 들어오는 걸 막고, 필요한 격리 수준 (Repeatable/Serializable) 을 만족시킨다.<br>실무에서는 락의 세분성 (행/페이지/테이블), 보유 기간 (문장/트랜잭션), 그리고 DBMS 별 정책을 함께 고려해 설계해야 안정성과 성능을 모두 얻을 수 있다.</p><h4 id=락-모드-핵심-개념-표>락 모드 핵심 개념 표<a hidden class=anchor aria-hidden=true href=#락-모드-핵심-개념-표>#</a></h4><table><thead><tr><th style=text-align:right>번호</th><th>핵심 개념 (한글 · 약어)</th><th>한 줄 정의</th><th>실무 핵심 포인트</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>공유 락 · S (Shared)</td><td>읽기 허용, 다중 보유 가능</td><td>다중 동시 조회 허용</td></tr><tr><td style=text-align:right>2</td><td>배타 락 · X (Exclusive)</td><td>읽기/쓰기 모두 배타적 점유</td><td>수정 시 반드시 필요</td></tr><tr><td style=text-align:right>3</td><td>업데이트 락 · U (Update)</td><td>S 와 호환되나 단일 보유, X 로 승격 가능</td><td>Deadlock 예방용 중간 모드</td></tr><tr><td style=text-align:right>4</td><td>의도 락 · IS/IX/SIX</td><td>상위 객체에 하위 락 의도 표시</td><td>계층적 충돌 검사 효율화</td></tr><tr><td style=text-align:right>5</td><td>행/페이지/테이블 락 · (Row/Page/Table)</td><td>락의 세분성 단위</td><td>세분성 - 동시성 트레이드오프</td></tr><tr><td style=text-align:right>6</td><td>키 - 레인지 (갭) 락 · Gap/Next-Key</td><td>인덱스 레코드 + 갭 잠금 (Next-Key)</td><td>팬텀 방지에 핵심 역할</td></tr><tr><td style=text-align:right>7</td><td>프레디케이트 락 · Predicate</td><td>조건식 단위의 범위 락</td><td>Serializable 구현 수단</td></tr><tr><td style=text-align:right>8</td><td>보유 기간 · Stmt/Txn/Session</td><td>락 해제 시점 분류</td><td>장기 락은 블로킹 유발</td></tr><tr><td style=text-align:right>9</td><td>락 호환성 · Compatibility</td><td>모드 간 동시 보유 가능성 행렬</td><td>블로킹/교착 분석의 근거</td></tr><tr><td style=text-align:right>10</td><td>락 확대 · Escalation</td><td>세밀 → 큰 단위로 자동 전환</td><td>메모리/관리 오버헤드 절감</td></tr></tbody></table><ul><li>S 는 읽기 동시성을, X 는 쓰기 무결성을 보장한다. U 는 두 모드 사이에서 데드락을 줄이는 역할을 한다.</li><li>Intent 락은 계층적 리소스 검사 비용을 줄이는 장치이며, gap/next-key/predicate 는 팬텀을 막아 격리 수준을 보장한다.</li><li>보유 기간과 락 확대 정책은 운영 (성능/자원) 과 직결되므로 트랜잭션 설계 시 신중히 고려해야 한다.</li></ul><h4 id=락-개념-상호관계>락 개념 상호관계<a hidden class=anchor aria-hidden=true href=#락-개념-상호관계>#</a></h4><p>트랜잭션은 특정 리소스에 대해 모드와 전략을 선택하고 (예: 인덱스 스캔 → next-key S locks), DBMS 의 호환성 매트릭스를 통해 허용 여부를 결정한다. Intent Locks 는 상위 레벨에서 빠른 충돌 판단을 도와준다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2>2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3>3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4>4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5>5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=p>[</span><span class=n>Workload</span><span class=p>]</span> <span class=err>→</span> <span class=p>[</span><span class=n>Transaction</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=err>→</span> <span class=err>요청</span><span class=p>:</span> <span class=p>(</span><span class=ne>Resource</span> <span class=n>Type</span><span class=p>:</span> <span class=n>Row</span><span class=o>/</span><span class=n>Page</span><span class=o>/</span><span class=n>Table</span><span class=o>/</span><span class=n>Key</span><span class=o>-</span><span class=ne>Range</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=err>→</span> <span class=err>요청</span><span class=p>:</span> <span class=p>(</span><span class=n>Lock</span> <span class=n>Mode</span><span class=p>:</span> <span class=n>NL</span><span class=o>/</span><span class=n>S</span><span class=o>/</span><span class=n>U</span><span class=o>/</span><span class=n>X</span> <span class=o>+</span> <span class=n>Intent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=err>→</span> <span class=err>요청</span><span class=p>:</span> <span class=p>(</span><span class=n>Strategy</span><span class=p>:</span> <span class=n>Gap</span><span class=o>/</span><span class=n>NextKey</span><span class=o>/</span><span class=n>Predicate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=err>→</span> <span class=n>Duration</span><span class=p>:</span> <span class=n>Statement</span><span class=o>/</span><span class=n>Transaction</span>
</span></span><span class=line><span class=cl>    <span class=err>→</span> <span class=err>결과</span><span class=p>:</span> <span class=n>Compatibility</span> <span class=err>검사</span> <span class=err>→</span> <span class=n>Grant</span> <span class=ow>or</span> <span class=n>Block</span>
</span></span></code></pre></td></tr></table></div></div><table><thead><tr><th>출발 개념 → 도착 개념</th><th style=text-align:right>방향성 (무엇을 위해)</th><th>요약 설명</th></tr></thead><tbody><tr><td>Transaction → Lock Mode</td><td style=text-align:right>트랜잭션의 동작을 보호하기 위해</td><td>트랜잭션이 읽기/갱신 정책에 따라 S/U/X 선택</td></tr><tr><td>Lock Mode → Compatibility Matrix</td><td style=text-align:right>블로킹 여부 판단을 위해</td><td>요청한 모드가 기존 락과 충돌하는지 검사</td></tr><tr><td>Resource Granularity → Intent Locks</td><td style=text-align:right>상위 수준 빠른 충돌 검사 위해</td><td>테이블에 IS/IX 두어 행 락 존재를 표시</td></tr><tr><td>Index Scan → Next-Key / Gap Lock</td><td style=text-align:right>팬텀 방지를 위해</td><td>인덱스 범위를 잠궈 삽입을 제어</td></tr><tr><td>Isolation Level → Lock Strategy</td><td style=text-align:right>격리 보장 위해 적절한 락 선택</td><td>Serializable → predicate/next-key 필요</td></tr><tr><td>Lock Acquisition → Lock Escalation</td><td style=text-align:right>자원 최적화 위해</td><td>많은 행 락 시 페이지/테이블로 승격</td></tr></tbody></table><ul><li>방향성은 항상 " 무엇을 보장하려는가 (무결성·동시성·성능)" 로 판단된다.<br>예: 팬텀 방지 (무결성) → next-key/predicate 적용, 대량 락 (성능) → escalation.</li></ul><h4 id=락-모드의-실무-연관성>락 모드의 실무 연관성<a hidden class=anchor aria-hidden=true href=#락-모드의-실무-연관성>#</a></h4><ul><li><p><strong>성능 (무엇)</strong>: 불필요한 X/U 를 줄이고 인덱싱을 개선해 키 - 레인지 (범위) 잠금 폭 감소<br><strong>어떻게</strong>: 적절한 인덱스 설계, 작은 트랜잭션, 필요한 곳만 UPDLOCK/ROWLOCK 등 힌트 적용 (신중히).<br><strong>왜</strong>: 대기·교착 감소, 처리량 향상.</p></li><li><p><strong>정확성 (무엇)</strong>: 팬텀 방지 (Serializable 필요 시 predicate/next-key)<br><strong>어떻게</strong>: 인덱스 기반 range locking / predicate lock(또는 SSI) 사용<br><strong>왜</strong>: 비즈니스 무결성 (예: 은행 계좌 집계) 의 보장.</p></li><li><p><strong>운영 (무엇)</strong>: 교착 탐지·타임아웃·로그/모니터링<br><strong>어떻게</strong>: 락 타임아웃 설정, 교착탐지 주기·알림, 블로킹 체인 분석 (프로파일링)<br><strong>왜</strong>: 시스템 가용성 및 SLA 유지.</p></li></ul><table><thead><tr><th>핵심 개념</th><th style=text-align:right>실무에서 무엇 (사례)</th><th>어떻게 (설계·운영)</th><th>왜 (비즈니스 영향)</th></tr></thead><tbody><tr><td>S/X/U</td><td style=text-align:right>은행 잔액조회/송금</td><td>조회는 S, 업데이트는 U→X 로 설계 (UPDLOCK 힌트 신중 사용)</td><td>무결성 (정확한 잔액) 과 동시성 균형</td></tr><tr><td>Intent Locks</td><td style=text-align:right>대형 테이블 DML 동시성</td><td>테이블 단위 IS/IX 사용해 충돌 검사 빠르게</td><td>잠금 검사 비용 절감으로 처리량 향상</td></tr><tr><td>Next-Key / Gap</td><td style=text-align:right>인덱스 범위 쿼리 (예: date BETWEEN)</td><td>인덱스 설계 + 트랜잭션 짧게 유지, 필요 시 gap lock 허용</td><td>삽입 (팬텀) 으로 인한 잘못된 집계 방지</td></tr><tr><td>Lock Duration</td><td style=text-align:right>배치 vs 실시간 트랜잭션</td><td>배치는 더 작은 배치로 쪼개고, 트랜잭션 짧게</td><td>장기 락은 전체 서비스 지연 초래</td></tr><tr><td>Escalation</td><td style=text-align:right>대량 업데이트 (대량 로깅)</td><td>임계치 조정/모니터링으로 불필요한 승격 방지</td><td>메모리·락 테이블 폭증 방지</td></tr><tr><td>Monitoring</td><td style=text-align:right>블로킹/Deadlock</td><td>DB 모니터링 + 타임아웃/교착테이블 확인</td><td>SLA 위반 방지, 원인 추적</td></tr></tbody></table><ul><li>실무 설계는 (1) 적절한 인덱스, (2) 트랜잭션 최소화, (3) DBMS 별 락 특성 숙지, (4) 모니터링·타임아웃 정책으로 요약된다. 이 네 가지가 성능·정확성·운영성의 핵심 축이다.</li></ul><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=데이터베이스-잠금-모드와-본질>데이터베이스 잠금 모드와 본질<a hidden class=anchor aria-hidden=true href=#데이터베이스-잠금-모드와-본질>#</a></h4><ol><li><p><strong>왜 잠금이 필요한가?</strong></p><ul><li>여러 작업이 동시에 같은 데이터를 읽고 쓰면 결과가 엉킬 수 있음 → 잠금으로 충돌을 조절.</li></ul></li><li><p><strong>잠금의 기본 아이디어</strong></p><ul><li>읽기엔 공유 (S), 쓰기엔 배타 (X). 어떤 조합이 동시에 가능한지 (호환성) 를 정의하는 것이 잠금 모드.</li></ul></li><li><p><strong>잠금의 단위</strong></p><ul><li>테이블/페이지/행/키/갭 등. 단위가 작을수록 동시성은 좋아지지만 관리비용은 커짐.</li></ul></li><li><p><strong>특수 모드와 문제</strong></p><ul><li>Intent: 상위 레벨에서 " 내가 곧 행을 잠금 " 이라고 표시.</li><li>Update: 읽고 나서 쓰려는 의도 표시 (데드락 완화).</li><li>Range/Gap: 팬텀 방지용 (범위 삽입 차단).</li></ul></li><li><p><strong>현대적 대안</strong></p><ul><li>MVCC(버전 기반)—읽기와 쓰기를 분리해 읽기 성능 향상, 단 쓰기 충돌 처리 필요.</li></ul></li></ol><p>잠금 모드 (Lock Mode) 는 데이터베이스 트랜잭션이 특정 자원 (테이블/행/키/범위 등) 에 대해 어떤 종류의 접근을 허용받는지를 규정하는 상태다.<br>각 모드는 **허용되는 연산 (읽기/쓰기/수정)**과 <strong>다른 잠금과의 호환성</strong>을 정의하며, 이 규칙을 통해 동시성 환경에서 데이터 일관성과 무결성을 확보한다.<br>일반적으로 읽기는 공유 (Shared) 잠금으로, 쓰기는 배타 (Exclusive) 잠금으로 보호된다. 그러나 현실적 운영에서는 성능과 동시성 확보를 위해 <strong>의도 (Intent) 잠금, 업데이트 (Update) 잠금, 범위/갭/술어 (Predicate) 잠금</strong> 등 다양한 보조 모드가 도입된다.<br>범위 잠금은 특히 팬텀 현상 (트랜잭션 A 가 보았던 검색 결과에 트랜잭션 B 가 새 레코드를 삽입해 결과가 달라지는 현상) 을 막기 위해 사용되며, 반면 MVCC 같은 버전 기반 기법은 읽기 성능을 높이는 다른 접근법을 제공한다.<br>잠금 설계는 &rsquo; 무결성 보장 &rsquo; 과 &rsquo; 동시성 (성능) 최적화 &rsquo; 사이의 균형을 찾는 작업이다.</p><h4 id=데이터베이스-락-모드의-역사와-진화>데이터베이스 락 모드의 역사와 진화<a hidden class=anchor aria-hidden=true href=#데이터베이스-락-모드의-역사와-진화>#</a></h4><p>데이터베이스에서 <strong>동시에 여러 사람이 같은 데이터를 쓰거나 읽을 때</strong> 문제가 생긴다 (예: 두 사람이 동시에 잔액을 수정하면 하나의 수정이 사라지는 <em>Lost Update</em>). 이를 방지하려고 <strong>락 (lock)</strong> 이라는 &rsquo; 사용·수정 권한표 &rsquo; 를 씌운다.<br>초기에는 단순히 공유 (S) 와 독점 (X) 만 있었지만, 성능과 동시성을 더 높이기 위해 <strong>잠금의 크기 (테이블/페이지/레코드)</strong>, <strong>의도 락 (상위에서 하위 락 존재를 알려주는 방법)</strong>, <strong>범위/프레디킷 락 (검색 조건에 따른 삽입 방지)</strong>, <strong>MVCC(읽기용 스냅샷을 만들어 읽기와 쓰기를 분리)</strong> 같은 여러 기법이 추가되었다.<br>최근에는 분산 시스템 환경에 맞춰 이들 기법을 조합·최적화하는 방향으로 발전 중이다.</p><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>다중 사용자가 동시에 같은 데이터에 접근하는 시스템에서는 읽기·쓰기 충돌로 인해 <strong>데이터 일관성</strong>이 깨질 수 있다.<br>데이터베이스는 이러한 충돌을 막아 <strong>직렬가능성 (Serializability)</strong> 과 Isolation 을 보장해야 한다.<br>초기에는 단순히 읽기/쓰기 충돌을 막는 <strong>공유 (S)</strong>·<strong>독점 (X)</strong> 락으로 대응했으나, 실무에서의 성능·동시성 요구로 인해 <strong>락의 그레인 (테이블→페이지→레코드)</strong>, <strong>의도 락</strong>, <strong>범위/프레디킷 락</strong>, 그리고 <strong>MVCC</strong>와 같은 더 정교한 메커니즘이 도입되어 왔다.</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>시기</th><th>기술/개념</th><th>등장 배경 (무엇을 해결하려고)</th><th>개선 포인트 (무엇이 좋아졌나)</th><th>대표 문헌/시스템</th></tr></thead><tbody><tr><td style=text-align:right>1970 년대</td><td>S/X 락, 2PL(두 단계 잠금)</td><td>동시 읽기/쓰기 충돌로부터 직렬성 보장</td><td>단순한 충돌 규칙으로 직렬성 보장</td><td>System R; 2PL 이론</td></tr><tr><td style=text-align:right>1976</td><td>Predicate locks (프레디킷 락)</td><td>팬텀 (조건에 맞는 레코드 삽입) 문제 해결</td><td>논리적 집합 단위 잠금으로 팬텀 방지 (이론적)</td><td>Eswaran et al. 1976</td></tr><tr><td style=text-align:right>1970s~1980s</td><td>락 그레인·의도 락</td><td>다양한 그레인에서 효율적 충돌 판별 필요</td><td>상위 - 하위 락 통합 검사로 불필요 대기 회피</td><td>Gray 등 연구, 상용 DB 구현 (예: SQL Server)</td></tr><tr><td style=text-align:right>1990 년대</td><td>정밀 락 / 키 - 레인지·범위 락, ARIES/KVL</td><td>인덱스·트리 탐색·구조변경시 동시성 보장</td><td>B-tree 등에서 높은 동시성·안정성 확보</td><td>Lomet, Mohan 등 논문 (ARIES/KVL)</td></tr><tr><td style=text-align:right>1980s~2000s</td><td>MVCC 상용화·발전</td><td>읽기 - 쓰기 충돌 최소화, 읽기 성능 향상</td><td>읽기 작업 블로킹 감소, 높은 동시성 제공</td><td>VAX Rdb/ELN(1984), PostgreSQL 등; MVCC 역사 정리</td></tr><tr><td style=text-align:right>2000 년대~현재</td><td>하이브리드·분산 최적화</td><td>분산·파티셔닝·대규모 처리 환경 대응</td><td>락 +MVCC 결합, 분산 트랜잭션 최적화, 일관성 조정</td><td>현대 RDB/NOSQL 의 혼합 설계</td></tr></tbody></table><pre class=mermaid>timeline
    title 락 모드 발전 타임라인
    1976 : System R / 2PL 및 S/X 모델 정립. 
    1976 : Eswaran et al. - Predicate locks 제안(팬텀 이슈). 
    1970s-1980s : 락 그레인·의도 락(계층적 잠금) 연구 및 도입. 
    1984 : MVCC 상용 제품(VAX Rdb/ELN) 등장(초기 상용화). 
    1990s : 키-레인지/정밀 락, ARIES/KVL 등 인덱스 기반 동시성 향상 기법 등장. 
    2000s~ : MVCC+락 하이브리드, 분산·클라우드 네이티브 최적화 진행. 
</pre><p>1970 년대에 S/X 와 2PL 이 등장해 직렬성의 이론적 토대를 닦았고 (실무: System R), 같은 시기 Eswaran 등은 <em>프레디킷 락</em>으로 팬텀 문제를 이론적으로 해결하려 했다.<br>이후 그레인 문제를 해결하기 위한 <strong>의도 락/계층적 락</strong>이 도입되었고, 1990 년대에는 인덱스·키 - 레인지 기반의 정밀 락과 ARIES/KVL 같은 트리 최적화 기법으로 동시성이 많이 개선되었다.<br>1980 년대 중반부터는 <strong>MVCC</strong>가 상용화되어 읽기 성능을 크게 개선했고, 2000 년대 이후 분산·클라우드 환경을 반영해 락과 MVCC 를 상황에 맞게 혼합·확장하는 설계가 주류가 되었다.</p><h4 id=잠금-모드-기반-동시성-설계-정석>잠금 모드 기반 동시성 설계 정석<a hidden class=anchor aria-hidden=true href=#잠금-모드-기반-동시성-설계-정석>#</a></h4><p>트랜잭션이 동시에 데이터베이스를 읽고 쓸 때 <strong>무엇이 문제인가</strong>?</p><ul><li>두 트랜잭션이 같은 데이터를 동시에 다루면 <strong>한쪽 변경이 다른 쪽에 이상한 결과를 만들거나</strong>, <strong>변경이 사라지거나</strong>, <strong>같은 쿼리가 다른 결과를 줄 수</strong> 있다. 이게 바로 Lost/Dirty/Non-repeatable/Phantom 문제들이다.</li></ul><p><strong>어떻게 방지하나?—직관적 비유</strong></p><ul><li><strong>X(배타) 잠금</strong> = 화장실 문을 잠그는 것. 한 사람이 들어가서 쓰는 동안 다른 사람은 못 들어온다 → 동시 쓰기 충돌 방지.</li><li><strong>S(공유) 잠금</strong> = 도서관의 참고자료. 여러 명이 동시에 읽을 수는 있지만, 수정 (책갈피 추가 등) 은 못 하게 한다 → 미완료 쓰기를 읽지 않게 함.</li><li><strong>범위잠금 (gap)</strong> = 공용 전시대 구역을 막아 새 전시물을 끼워 넣지 못하게 하는 것 → 범위 기반 삽입 (phantom) 방지.</li><li><strong>트레이드오프</strong>: 잠그면 안전하지만 동시성 (성능) 이 줄어든다. 그래서 필요한 최소한만 잠그는 전략 (짧게·작게) 이 중요하다.</li></ul><h5 id=동시성-이상-이슈-및-설명-표>동시성 이상 (이슈) 및 설명 표<a hidden class=anchor aria-hidden=true href=#동시성-이상-이슈-및-설명-표>#</a></h5><table><thead><tr><th style=text-align:right>문제 유형</th><th>증상 (무엇이 일어남)</th><th>잠금/기법으로의 해결 방식</th></tr></thead><tbody><tr><td style=text-align:right>Lost Update</td><td>두 트랜잭션이 같은 행을 동시에 갱신 → 한 쪽 변경이 덮어짐</td><td>X 잠금으로 동시에 쓰기 차단</td></tr><tr><td style=text-align:right>Dirty Read</td><td>커밋 전 다른 트랜잭션의 변경을 읽음 → 잘못된 판단 가능</td><td>S 잠금 (또는 커밋된 스냅샷) 으로 미커밋 읽기 차단</td></tr><tr><td style=text-align:right>Non-repeatable Read</td><td>트랜잭션 내 동일 쿼리 결과가 변경됨</td><td>트랜잭션 동안 S 잠금 유지 또는 스냅샷 격리 사용</td></tr><tr><td style=text-align:right>Phantom Read</td><td>범위 조건의 결과셋에 새 행이 생김/사라짐</td><td>Range/Gap/Next-key 잠금으로 범위 보호</td></tr></tbody></table><p>이 표는 각 동시성 이상 현상에 대해 <strong>무슨 일이 발생하는지</strong>와 <strong>잠금 관점에서 어떻게 대응하는지</strong>를 직접 연결한다. 실제 DB 에서는 MVCC 나 스냅샷 격리 같은 기법이 같은 문제를 다른 방식으로 해결할 수 있으므로 (예: 스냅샷은 반복 읽기 일관성을 제공) 설계 시 DB 특성을 고려해야 한다.</p><h5 id=잠금-도입의-핵심-목적-표>잠금 도입의 핵심 목적 표<a hidden class=anchor aria-hidden=true href=#잠금-도입의-핵심-목적-표>#</a></h5><table><thead><tr><th style=text-align:right>핵심 목적</th><th>목표 (구체적 의미)</th><th>실행 수단 (잠금/정책)</th></tr></thead><tbody><tr><td style=text-align:right>데이터 일관성 보장</td><td>트랜잭션 격리로 잘못된 데이터 흐름 차단</td><td>적절한 S/X, Range 잠금 / 격리 수준 설정</td></tr><tr><td style=text-align:right>동시성 (throughput) 극대화</td><td>불필요한 차단을 줄여 처리량 유지</td><td>최소 범위·짧은 유지, MVCC 활용</td></tr><tr><td style=text-align:right>데드락·무결성 완화</td><td>교착·무결성 위협을 설계로 흡수</td><td>잠금 순서, 타임아웃, 낙관적 동시성 제어</td></tr><tr><td style=text-align:right>예측 가능한 동작</td><td>비즈니스 로직이 동시 실행 시에도 예측됨</td><td>격리 수준·스냅샷·원자적 트랜잭션 설계</td></tr></tbody></table><p>핵심 목적은 단순히 &rsquo; 잠금 &rsquo; 을 많이 거는 것이 아니라 <strong>어떤 문제를 막고 어떤 수준의 동시성을 허용할지 균형을 잡는 것</strong>이다. 즉, 일관성과 성능 사이의 트레이드오프를 운영 목표에 맞게 조정하는 것이 관건이다.</p><h5 id=문제와-목적-간-연관성-매핑>문제와 목적 간 연관성 매핑<a hidden class=anchor aria-hidden=true href=#문제와-목적-간-연관성-매핑>#</a></h5><table><thead><tr><th style=text-align:right>문제 유형</th><th>주요 관련 핵심 목적</th><th>연관 설명</th></tr></thead><tbody><tr><td style=text-align:right>Lost Update</td><td>데이터 일관성 보장</td><td>덮어쓰기 방지로 무결성 확보</td></tr><tr><td style=text-align:right>Dirty Read</td><td>데이터 일관성 보장, 예측성</td><td>미완료 데이터 노출 제거 → 신뢰성 확보</td></tr><tr><td style=text-align:right>Non-repeatable Read</td><td>예측 가능한 동작, 데이터 일관성</td><td>같은 트랜잭션 내 반복 일관성 제공</td></tr><tr><td style=text-align:right>Phantom Read</td><td>데이터 일관성 보장, 예측성</td><td>범위 안정성 확보로 쿼리 예측성 향상</td></tr></tbody></table><p>각 문제는 대부분 <strong>데이터 일관성 보장</strong>과 직결되며, 일부 (특히 Non-repeatable/Phantom) 는 <strong>트랜잭션의 예측성</strong>과도 깊게 연결된다. 따라서 목적을 우선순위로 두고 (예: 금융권은 강한 일관성 우선) 잠금·격리 전략을 선택해야 한다.</p><h4 id=락-모드-전제와-성능-요구사항>락 모드 전제와 성능 요구사항<a hidden class=anchor aria-hidden=true href=#락-모드-전제와-성능-요구사항>#</a></h4><ol><li><p>핵심 전제</p><ul><li>트랜잭션 경계의 존재: 트랜잭션 시작·커밋·롤백을 기준으로 락 획득·해제가 정의되어야 함. (근거: ACID 모델)</li><li>정의된 격리 수준: 어떤 격리 (Serializable, Repeatable Read 등) 를 지원할지 명확히 해야 락 모드와 범위가 결정됨. (근거: 팬텀/갭 락 의존)</li><li>일관된 락 관리 엔티티: Lock Manager 와 Deadlock Detector 는 일관된 정책으로 동작해야 함. (근거: 충돌 판단·희생자 선정 필요)</li></ul></li><li><p>성능 요구사항 및 특징 (근거 포함)</p><ul><li>낮은 락 오버헤드: 락 획득/해제는 경합 없는 경로가 빠르고, 락 구조체 크기를 작게 유지해야 함. (근거: 소형 락이 많을수록 메모리·캐시 오버헤드 증가)</li><li>메모리 관리: 락 테이블의 해시·버킷 수와 정리 (garbage collection) 정책을 정해 메모리 상한을 보장해야 함. (근거: 무제한 증가 시 OOM 유발)</li><li>빠른 데드락 탐지/해결: 탐지 주기와 탐지 알고리즘 (Wait-For 그래프 등) 을 정의해 평균 복구 시간을 제한해야 함. (근거: 긴 데드락 회복은 트랜잭션 지연과 자원 낭비 증가)</li><li>에스컬레이션 제어: 에스컬레이션 임계값·예외 규칙으로 과도한 테이블 락 전이를 방지해야 함. (근거: 에스컬레이션은 동시성 저하 주원인)</li><li>분산 고려: 네트워크 지연·부분 장애를 반영한 분산 락 (혹은 분산 트랜잭션) 전략을 마련해야 함. (근거: 분산 환경에서는 단일 노드 가정 불가)</li></ul></li><li><p>등장 이전 관련 기술 및 차별점</p><ul><li>MVCC(다중 버전 동시성 제어): 읽기 - 쓰기 충돌을 버전으로 해결하여 읽기 락을 피함.<br>차별점: 락 기반보다 읽기 성능 우수하지만 쓰기 충돌 처리·갱신 비용을 갖음.</li><li>낙관적 동시성 제어 (OCC): 트랜잭션을 검증 시점에만 충돌 체크.<br>차별점: 충돌이 적은 워크로드에 유리, 충돌 많으면 재시도 비용 큼.</li><li>타임스탬프 순서화: 타임스탬프 기반으로 직렬화 순서를 강제.<br>차별점: 락 의존성 제거 가능, 구현 복잡성 및 롤백/충돌 처리 필요.</li></ul></li><li><p>설계 체크포인트 (실무)</p><ul><li>목표 격리 수준 선정 → 락 모드·범위 정의 → Lock Manager 자료구조 설계 → 데드락 정책 수립 → 에스컬레이션·모니터링 지표 정의 → 성능 목표 (숫자) 설정 → 테스트 (부하·장기 운전) 및 운영계 모니터링.</li></ul></li></ol><h5 id=락-모드-전제요구사항-표>락 모드 전제·요구사항 표<a hidden class=anchor aria-hidden=true href=#락-모드-전제요구사항-표>#</a></h5><table><thead><tr><th>구분</th><th>항목</th><th style=text-align:right>설명</th><th>설계/운영 영향 (근거)</th></tr></thead><tbody><tr><td>전제</td><td>트랜잭션 경계</td><td style=text-align:right>시작/커밋/롤백 정의 필요</td><td>락의 범위·유효기간이 트랜잭션 경계에 의존</td></tr><tr><td>전제</td><td>격리 수준 정의</td><td style=text-align:right>Serializable, Repeatable Read 등 선택</td><td>팬텀·갭 락 필요성 결정</td></tr><tr><td>전제</td><td>Lock Manager 구현</td><td style=text-align:right>해시·대기 큐·소유자 관리</td><td>메모리·성능 핵심 요소</td></tr><tr><td>전제</td><td>Deadlock Detector</td><td style=text-align:right>탐지 방식·희생자 정책 명시</td><td>복구 시간과 트랜잭션 손실 영향</td></tr><tr><td>성능</td><td>획득/해제 오버헤드 최소화</td><td style=text-align:right>락 구조 최적화, 경합 회피</td><td>응답성·처리량 개선</td></tr><tr><td>성능</td><td>메모리 관리</td><td style=text-align:right>락 테이블 한도·GC 정책</td><td>OOM·성능 저하 방지</td></tr><tr><td>성능</td><td>데드락 탐지 지연 최소화</td><td style=text-align:right>탐지 주기·정책 설정</td><td>SLA 준수, 지연 감소</td></tr><tr><td>성능</td><td>에스컬레이션 제어</td><td style=text-align:right>임계치와 예외 규칙 정의</td><td>동시성 급락 예방</td></tr><tr><td>운영</td><td>호환성 매트릭스</td><td style=text-align:right>락 충돌 규칙 구현·테스트</td><td>논리적 정합성 확보</td></tr><tr><td>운영</td><td>모니터링 지표</td><td style=text-align:right>대기수·평균대기·에스컬레이션 등</td><td>운영·튜닝 빠른 대응 가능</td></tr><tr><td>운영</td><td>분산 고려</td><td style=text-align:right>분산 락/네트워크 불확실성 대응</td><td>분산 시스템 안정성 확보</td></tr><tr><td>검증</td><td>성능 목표 수치화</td><td style=text-align:right>지연/메모리/탐지시간 목표 설정</td><td>검증·테스트 기준 제공</td></tr></tbody></table><p>위 표는 락 모드 설계에서 반드시 점검해야 할 전제와 요구사항을 카테고리별로 묶은 것이다. 설계는 먼저 전제 (트랜잭션 경계·격리 수준·락·데드락 매니저) 를 명확히 하고, 성능 목표 (오버헤드·메모리·에스컬레이션) 를 수치화한 뒤 운영·모니터링 요소로 검증·튜닝하는 순서로 진행해야 한다. 분산 환경이라면 추가적으로 네트워크 불확실성과 분산 조정 비용을 반영해 정책을 조정해야 한다.</p><h4 id=동시성-제어를-위한-락-모드의-설계-특성>동시성 제어를 위한 락 모드의 설계 특성<a hidden class=anchor aria-hidden=true href=#동시성-제어를-위한-락-모드의-설계-특성>#</a></h4><p>락 모드는 데이터에 대한 접근 권한을 규정해 여러 트랜잭션이 동시에 일할 때 일관성을 지키도록 한다.<br>의도 (상위) 잠금은 테이블·페이지 같은 상위 단위에서 하위 충돌을 미리 검출해 비용을 줄이고, 세분화된 행/키 단위 잠금은 서로 다른 레코드를 동시에 건드릴 수 있게 해 동시성을 높인다.<br>필요에 따라 잠금 강도를 올리거나 (업그레이드) 낮추는 기능은 초기 과도한 배타를 피하고 효율을 높인다.<br>다만 세밀한 잠금은 메타데이터 관리 오버헤드와 업그레이드 경쟁으로 인한 데드락 가능성을 낳는다.<br>범위·프레디케이트 락은 삽입·팬텀 문제를 해결하며, MVCC 같은 버전 기법과 함께 쓰이면 읽기 성능과 일관성 사이에서 균형을 맞출 수 있다.</p><h5 id=락-모드의-핵심-설계-특성>락 모드의 핵심 설계 특성<a hidden class=anchor aria-hidden=true href=#락-모드의-핵심-설계-특성>#</a></h5><ol><li><p><strong>계층적 잠금 (의도 잠금)—빠른 상위 충돌 판정</strong></p><ul><li>설명: 상위 (테이블) 레벨에 Intent(IS/IX) 락을 두어 하위 (행/키) 락 충돌을 상위에서 빠르게 판별.</li><li>기술적 근거: 상위 노드의 의도 표시만으로도 하위 충돌 가능성 판단이 가능하므로 전체 스캔 없이 충돌 검사 비용을 절감.</li><li>차별점: 단순 전역 배타락과 달리 하위 단위 동시성을 보존하면서도 충돌 검사 비용을 낮춤.</li></ul></li><li><p><strong>세분화된 그레뉴러리티—충돌 표면 축소</strong></p><ul><li>설명: 행/키/페이지 등 세밀한 대상에 락을 걸어 동시성 향상.</li><li>기술적 근거: 잠금 단위가 작을수록 두 트랜잭션이 서로 다른 단위를 건드릴 확률 증가 → 충돌 감소.</li><li>차별점: 전체 테이블 락과 비교해 동시 처리량이 높지만 락 관리 오버헤드가 증가.</li></ul></li><li><p><strong>업그레이드/다운그레이드—필요시 권한 조정</strong></p><ul><li>설명: 트랜잭션 흐름에 따라 더 강한 (또는 약한) 락으로 변환해 초기 과도한 락을 회피.</li><li>기술적 근거: 변환 시점까지 공유를 유지하다가 쓰기 필요 시 배타로 전환 → 불필요한 배타 기간 축소.</li><li>차별점: 항상 처음부터 배타락을 잡는 설계보다 동시성을 더 잘 보존하나 업그레이드 경쟁에서 데드락 발생 가능.</li></ul></li><li><p><strong>범위/프레디케이트 락—팬텀 제어의 정밀성</strong></p><ul><li>설명: 조건 (프레디케이트) 이나 인덱스 간격 (gap) 에 대한 락으로 삽입·팬텀 방지.</li><li>기술적 근거: 단순 행락으로는 팬텀을 막기 어려워 범위 단위를 잠그면 팬텀 현상 방지 가능.</li><li>차별점: 논리적 predicate(정밀) vs 물리적 gap(효율) 의 구현 차이로 DBMS 별 장단 존재.</li></ul></li><li><p><strong>MVCC/버전 기법과의 보완적 관계</strong></p><ul><li>설명: MVCC 는 읽기 성능을 높이나, 직렬화 보장이 필요할 때는 predicate/range 락 같은 락 메커니즘이 병행 사용됨.</li><li>기술적 근거: MVCC 는 읽기 - 읽기 충돌을 제거하지만, 삽입/팬텀 관련 문제는 전통적 락으로 제어해야 함.</li><li>차별점: 순수 락 기반 (2PL) 대비 읽기 부하에서 이득을 얻지만, 완전 대체는 아님—하이브리드 적용이 보편적.</li></ul></li></ol><h5 id=락-모드-핵심-특징-비교표>락 모드 핵심 특징 비교표<a hidden class=anchor aria-hidden=true href=#락-모드-핵심-특징-비교표>#</a></h5><table><thead><tr><th>핵심 특징</th><th style=text-align:right>기술적 근거</th><th>다른 기술과의 차별점 (요지)</th></tr></thead><tbody><tr><td>계층적 잠금 (Intent)</td><td style=text-align:right>상위 의도 표시로 하위 충돌 사전판정 → 충돌 검사 비용 절감</td><td>전역 배타락보다 충돌 검사 비용 적고 동시성 보존</td></tr><tr><td>그레뉴러리티 (세분화)</td><td style=text-align:right>작은 단위 잠금 → 충돌 표면 축소 → 동시성 증가</td><td>테이블 락 대비 처리량↑, 락 관리 오버헤드↑</td></tr><tr><td>업그레이드/다운그레이드</td><td style=text-align:right>초기 공유 유지 후 필요시 배타 전환 → 배타 기간 최소화</td><td>초기부터 X 잡는 설계보다 유연, 업그레이드 경쟁으로 데드락 가능</td></tr><tr><td>범위/프레디케이트 락</td><td style=text-align:right>범위 삽입/검색에 대한 잠금으로 팬텀 방지</td><td>논리적 predicate(정밀) vs 물리적 gap(효율) 선택지</td></tr><tr><td>MVCC 보완성</td><td style=text-align:right>버전으로 읽기 충돌 제거, 삽입/팬텀은 락으로 보완</td><td>순수 락 기반보다 읽기 성능 유리하지만 완전 대체 아님</td></tr></tbody></table><ul><li><strong>핵심 결론:</strong> 락 모드는 &rsquo; 권한의 계층화 &rsquo; 와 &rsquo; 잠금 단위의 세분화 &rsquo; 를 통해 동시성과 일관성 사이에서 균형을 만든다.</li><li><strong>트레이드오프:</strong> 세분화·유연성은 동시성 개선을 주지만 메타데이터·운영 복잡성을 증가시켜 데드락·관리 비용을 유발할 수 있다.</li><li><strong>실무 시사점:</strong> 인덱스·트랜잭션 설계로 충돌 표면을 줄이고, 필요시 MVCC 나 격리 모드 선택으로 성능/정합성 균형을 맞춰야 함.</li></ul><h4 id=락-매니저-성능을-결정하는-hwsw-요인>락 매니저 성능을 결정하는 HW·SW 요인<a hidden class=anchor aria-hidden=true href=#락-매니저-성능을-결정하는-hwsw-요인>#</a></h4><p>데이터베이스에서 많은 트랜잭션이 동시에 락을 요구하면, 락을 관리하는 테이블 (또는 매니저) 은 메모리에 락 상태를 유지한다.<br>따라서 충분한 RAM 이 필요하고, 많은 CPU 코어가 있어도 락을 둘러싼 경쟁이 심하면 성능은 오히려 떨어질 수 있다. 또한 트랜잭션의 영속성은 WAL 에 의존하므로 WAL 을 쓸 디스크 용량과 I/O 성능도 중요하다.<br>마지막으로, 물리적 서버의 NUMA 구조와 CPU 캐시 동작 방식 (캐시 라인 경쟁) 은 락 처리 지연과 확장성에 직접적인 영향을 준다.</p><h5 id=시스템-요구사항>시스템 요구사항<a hidden class=anchor aria-hidden=true href=#시스템-요구사항>#</a></h5><ol><li><p><strong>메모리—Lock Table 저장용</strong></p><ul><li>설명: 각 락 (행/레인지/인텐트 등) 마다 메타 데이터 (트랜잭션 id, 모드, 대상 등) 를 유지.</li><li>이유: 동시 락 수가 증가하면 메모리 사용량이 선형으로 증가. 부족 시 <code>lock table</code> 초과 또는 성능 저하 발생. (예: InnoDB 관련 사례)</li></ul></li><li><p><strong>CPU—멀티코어 및 동기화 처리 능력</strong></p><ul><li>설명: 락 획득/해제, 트랜잭션 관리, 스케줄링은 CPU 연산으로 처리됨.</li><li>이유: 코어 수가 많아도 락 경쟁으로 캐시 라인 이동과 컨텍스트 스위칭이 늘어나면 오히려 처리량이 제한된다. 올바른 락 알고리듬 (스핀 vs 블록) 선택 필요.</li></ul></li><li><p><strong>스토리지—WAL 저장 및 fsync 성능</strong></p><ul><li>설명: 커밋 전 WAL 에 기록하고 fsync 로 디스크에 보장. WAL 파일 보관 공간 필요.</li><li>이유: WAL 쓰기·동기화가 느리면 커밋 지연→트랜잭션 체류 시간 증가→락 보유 시간 증가→블로킹 확대.</li></ul></li></ol><h5 id=하드웨어-의존성>하드웨어 의존성<a hidden class=anchor aria-hidden=true href=#하드웨어-의존성>#</a></h5><ol><li><p><strong>NUMA</strong></p><ul><li>설명: CPU 소켓마다 로컬 메모리 뱅크가 있고, 원격 노드 접근은 지연/대역폭 비용이 큼.</li><li>이유: 락 메타데이터나 버퍼가 원격 노드에 위치하면 락 획득 지연 증가. NUMA-unaware 설계는 성능 저하로 직결.</li></ul></li><li><p><strong>캐시 일관성 / 캐시 라인 경쟁</strong></p><ul><li>설명: 락 변수 (예: spinlock) 하나가 여러 코어의 캐시에 자주 반영되면 캐시 라인이 이동하며 성능이 나빠짐.</li><li>이유: 캐시 라인 핑퐁과 false sharing 은 락 대기 시간을 크게 늘려 전체 처리량을 낮춘다. 설계 단계에서 패딩·슬로팅·분산락 등으로 회피해야 함.</li></ul></li><li><p><strong>하드웨어 원자 연산</strong></p><ul><li>설명: CPU 레벨의 CAS, atomic inc/dec 등 연산은 락 없는 (혹은 경량 락) 동기화의 기반.</li><li>이유: 효율적 원자 연산이 없으면 락 구현이 폴백되어 스케일링이 제한된다. 소프트웨어 동기화 기법 선택에 직접 영향.</li></ul></li></ol><h5 id=락-매니저-필수-시스템하드웨어-항목>락 매니저 필수 시스템·하드웨어 항목<a hidden class=anchor aria-hidden=true href=#락-매니저-필수-시스템하드웨어-항목>#</a></h5><table><thead><tr><th style=text-align:right>분류</th><th>항목</th><th>설명</th><th>영향 (무엇이 나빠지는가)</th><th>대응/검토 포인트</th></tr></thead><tbody><tr><td style=text-align:right>시스템 요구</td><td>메모리 (Lock Table)</td><td>락 메타데이터·대기 큐 저장</td><td>메모리 부족 → lock table 초과/오류, 성능저하</td><td>락 수 모니터링, 메모리 할당 증대, 트랜잭션 축소.</td></tr><tr><td style=text-align:right>시스템 요구</td><td>CPU (멀티코어)</td><td>동시 스레드 처리, 동기화 연산</td><td>락 경쟁 → 캐시 라인 이동·컨텍스트 스위치 증가</td><td>락 설계 (스핀/블록), 스레드 배치, 프로파일링.</td></tr><tr><td style=text-align:right>시스템 요구</td><td>스토리지 (WAL)</td><td>WAL 용량·fsync 처리 성능</td><td>느린 WAL → 커밋 지연 → 락 장기화</td><td>고성능 디스크, WAL 로테이션/아카이브 정책.</td></tr><tr><td style=text-align:right>하드웨어 의존</td><td>NUMA</td><td>메모리 지역성 (로컬 vs 원격)</td><td>원격 접근 지연 → 락 획득 지연/불균형</td><td>NUMA 바인딩, 메모리/스레드 배치, NUMA-aware 설계.</td></tr><tr><td style=text-align:right>하드웨어 의존</td><td>캐시 일관성 (캐시라인)</td><td>캐시 라인 이동·false sharing</td><td>핑퐁 현상 → 락 대기 시간 증가</td><td>패딩, 분산 락, backoff 전략.</td></tr><tr><td style=text-align:right>하드웨어 의존</td><td>원자 연산 지원</td><td>CAS/LL-SC/메모리 배리어</td><td>비효율적 동기화 구현 → 확장성 저하</td><td>HW 기능 확인, 경량 동기화 설계.</td></tr></tbody></table><ul><li>핵심은 <strong>락 보유 객체 수 (메모리)</strong>, <strong>락 경쟁을 다루는 CPU/캐시 설계</strong>, <strong>WAL 에 의한 I/O 요구</strong> 그리고 <strong>NUMA 로 인한 메모리 지역성</strong>이다.</li><li>실무에서는 먼저 워크로드 (동시 트랜잭션 수, 트랜잭션 길이, 읽기/쓰기 비율) 를 측정한 뒤 위 항목들을 용량/배치·설계 관점에서 맞추는 것이 효과적이다.</li></ul><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=잠금-모드의-원칙철학개요>잠금 모드의 원칙·철학·개요<a hidden class=anchor aria-hidden=true href=#잠금-모드의-원칙철학개요>#</a></h4><ol><li><strong>문제 (왜 필요한가?)</strong>—여러 트랜잭션이 동시에 같은 데이터에 접근하면 결과가 꼬일 수 있다.</li><li><strong>해결 아이디어 (무엇을 하는가?)</strong>—잠금을 이용해 어떤 트랜잭션이 언제 어떤 연산을 할지 제어 (읽기/쓰기 충돌 방지).</li><li><strong>핵심 규칙 (어떤 원칙이 있나?)</strong><ul><li>2PL 로 직렬화 보장,</li><li>호환성 매트릭스로 허용 조합 판정,</li><li>최소한의 잠금 원칙으로 성능 유지,</li><li>계층적 잠금으로 상하위 충돌 효율화.</li></ul></li><li><strong>실무 팁</strong>—읽기가 많으면 공유 읽기/또는 MVCC 고려, 잦은 작은 업데이트면 락 경합·에스컬레이션 모니터링 필요.</li></ol><h5 id=락-모드-핵심-원칙-표>락 모드 핵심 원칙 표<a hidden class=anchor aria-hidden=true href=#락-모드-핵심-원칙-표>#</a></h5><ol><li><p><strong>Two-Phase Locking (2PL)</strong></p><ul><li>설명: 잠금 획득 (확장) 단계와 잠금 해제 (축소) 단계로 동작.</li><li>목적: 트랜잭션 스케줄의 직렬화 가능성 보장.</li><li>왜 필요한가: 동시 실행이지만 결과가 마치 순차 실행인 것처럼 보장하여 데이터 무결성 확보.</li></ul></li><li><p><strong>호환성 기반 제어 (Compatibility Matrix)</strong></p><ul><li>설명: 각 잠금 모드 간 허용·비허용 조합을 표로 정의해 충돌을 판정.</li><li>목적: 충돌 여부를 빠르게 결정해 올바른 동작을 허용/차단.</li><li>왜 필요한가: 불필요한 차단을 줄이고, 동시에 허용 가능한 작업은 병렬로 실행시켜 성능 확보.</li></ul></li><li><p><strong>최소 제한의 원칙 (Minimize Locks)</strong></p><ul><li>설명: 잠금의 범위 (단위) 와 지속시간을 최소화.</li><li>목적: 동시성 (throughput) 극대화 및 대기 시간 최소화.</li><li>왜 필요한가: 불필요한 동시성 제약은 처리량 감소와 응답성 악화를 야기하므로 최소화 필요.</li></ul></li><li><p><strong>계층적 (다중 그레인) 잠금 (Multiple Granularity)</strong></p><ul><li>설명: 데이터 계층에 맞춰 Intent(IS/IX/SIX) 등으로 상하위 잠금을 조정.</li><li>목적: 상위 - 하위 충돌을 효율적으로 판정하고, 대규모 연산에 유연성 제공.</li><li>왜 필요한가: 전체 테이블을 무조건 잠그는 단순 방식은 병목이므로 계층적 제어가 실무에서 효과적.</li></ul></li></ol><table><thead><tr><th>원칙명</th><th style=text-align:right>간단 설명</th><th>목적 (무엇을 위한가)</th><th>필요한 이유 (왜 필요한가)</th></tr></thead><tbody><tr><td>Two-Phase Locking (2PL)</td><td style=text-align:right>획득 단계 / 해제 단계로 잠금 관리</td><td>직렬화 (Serializability) 보장</td><td>동시 실행의 결과를 순차 실행 결과와 동일하게 만들어 무결성 확보.</td></tr><tr><td>호환성 기반 제어</td><td style=text-align:right>잠금 모드 간 허용/차단 매트릭스 사용</td><td>충돌 판정의 표준화</td><td>불필요한 차단 최소화·허용 가능한 병렬성 확보.</td></tr><tr><td>최소 제한 원칙</td><td style=text-align:right>잠금 범위·기간 최소화</td><td>처리량 (throughput) 극대화</td><td>과도한 잠금은 응답성·처리량 저하 초래.</td></tr><tr><td>다중 그레인 잠금</td><td style=text-align:right>계층적 (Intent) 잠금 사용</td><td>상하위 잠금 충돌 효율적 관리</td><td>대형 연산에서 전체 잠금 대신 부분 잠금으로 유연성 제공.</td></tr></tbody></table><p>2PL 은 일관성 (직렬화) 을 보장하는 구조적 규약이고, 호환성 매트릭스와 다중 그레인 설계는 그 규약을 현실의 트리 구조 데이터에 적용해 성능과 안전성을 조정한다. 최소 제한 원칙은 실무에서의 성능 판단 기준으로 항상 고려되어야 하는 트레이드오프다.</p><h5 id=잠금-설계-철학-개요>잠금 설계 철학 개요<a hidden class=anchor aria-hidden=true href=#잠금-설계-철학-개요>#</a></h5><ol><li><p><strong>가능한 한 공유 읽기 허용</strong></p><ul><li>설명: 읽기에는 공유 잠금을 넓게 허용해 동시 읽기를 살린다.</li><li>목적: 읽기 중심 워크로드에서 처리량 극대화.</li><li>왜 필요한가: 많은 시스템이 읽기 비중이 높아 읽기 동시성이 전체 성능에 큰 영향.</li></ul></li><li><p><strong>갱신 시에는 명확한 배타 확보</strong></p><ul><li>설명: 쓰기·갱신 작업은 배타 (X) 혹은 업데이트 (U) 로 보장.</li><li>목적: 쓰기 충돌로 인한 일관성 손상을 차단.</li><li>왜 필요한가: 쓰기 동작이 데이터 무결성에 직접적 영향을 주므로 확실한 보호 필요.</li></ul></li><li><p><strong>성능과 일관성의 명확한 트레이드오프 관리</strong></p><ul><li>설명: 락 강도·단위를 조정해 일관성 (강) vs 동시성 (높음) 사이 균형 선택.</li><li>목적: 애플리케이션 요구 (응답성, 일관성 수준) 에 맞춰 최적화.</li><li>왜 필요한가: 모든 환경에 최적인 단일 설정은 없으므로 설계 시 정책 결정이 필수.</li></ul></li></ol><table><thead><tr><th>철학명</th><th style=text-align:right>설명</th><th>목적 (무엇을 위한가)</th><th>필요한 이유 (왜 필요한가)</th></tr></thead><tbody><tr><td>공유 읽기 최우선</td><td style=text-align:right>읽기 작업은 넓게 허용</td><td>읽기 중심 성능 최적화</td><td>대부분 시스템에서 읽기 비중이 높아 전체 처리량에 큰 영향.</td></tr><tr><td>갱신은 배타 확보</td><td style=text-align:right>쓰기/갱신은 강한 배타 보장</td><td>데이터 무결성 보장</td><td>쓰기는 직접적인 상태 변경이므로 충돌 방지 필수.</td></tr><tr><td>명확한 트레이드오프 정책</td><td style=text-align:right>일관성·성능 사이 정책화</td><td>시스템 요구에 맞춘 최적화</td><td>단일 설정으로 모든 상황 해결 불가, 설계 결정 필요.</td></tr></tbody></table><p>설계 철학은 운영 환경 (읽기/쓰기 비율, 응답성 요구) 에 따라 어떤 잠금 전략을 택할지 결정하는 가치판단이다. 읽기 우선은 성능, 갱신 배타는 무결성, 그 사이에서 적절한 타협을 정책으로 명확히 해야 한다.</p><h4 id=락-기반-동시성-제어의-구조와-동작>락 기반 동시성 제어의 구조와 동작<a hidden class=anchor aria-hidden=true href=#락-기반-동시성-제어의-구조와-동작>#</a></h4><p>트랜잭션이 데이터를 읽거나 쓸 때는 먼저 <strong>어떤 종류의 락을 걸 것인지</strong> 락 관리자에게 요청한다.<br>락 관리자는 <strong>어떤 락들이 서로 함께 존재할 수 있는지</strong>를 담은 표 (호환성 매트릭스) 를 보고 요청을 허용하거나 대기시킨다.<br>만약 트랜잭션들이 서로의 락을 기다리다가 원형으로 얽히면 (데드락) 시스템이 이를 탐지해 한 트랜잭션을 강제로 취소하여 풀어준다.<br><code>U</code>(update) 락처럼 특별한 모드는 데드락을 줄이기 위해 설계되어 있으며, 구체적 규칙은 사용하는 DBMS 문서를 참고해야 한다.</p><h5 id=락-관리자와-호환성-메커니즘-핵심>락 관리자와 호환성 메커니즘 핵심<a hidden class=anchor aria-hidden=true href=#락-관리자와-호환성-메커니즘-핵심>#</a></h5><ol><li><p><strong>트랜잭션 (클라이언트)</strong></p><ul><li>동작: 리소스 접근 전 락 요청 (모드 지정).</li><li>목적: 필요한 격리 수준 달성.</li></ul></li><li><p><strong>락 관리자 (Lock Manager)</strong></p><ul><li>동작: 요청 수신 → 현재 리소스 락 상태 확인 → 호환성 매트릭스 검사 → 즉시 허용/대기 큐 삽입 → 락 테이블 갱신.</li><li>비고: 락 승격/변환, 락 에스컬레이션 (예: 행→페이지→테이블) 관리.</li></ul></li><li><p><strong>호환성 매트릭스</strong></p><ul><li>동작: 요청 모드 × 보유 모드 조합으로 허용 여부 결정.</li><li>예: U 는 S 와 호환되나 U-U 는 불허 (또는 제한). 실제 규칙은 DBMS 문서 참조 필요.</li></ul></li><li><p><strong>대기 큐 및 데드락 탐지</strong></p><ul><li>동작: 충돌 시 대기큐에 삽입 → 주기적/이벤트 기반 데드락 검사 (Wait-for 그래프) → 사이클 감지 시 희생자 선정·롤백.</li></ul></li><li><p><strong>락 해제·신호</strong></p><ul><li>동작: 트랜잭션 커밋/롤백시 락 해제 → 대기 큐에 신호 → 재시도/승인.</li></ul></li></ol><h5 id=락-관리자-구성요소와-동작-요약>락 관리자 구성요소와 동작 요약<a hidden class=anchor aria-hidden=true href=#락-관리자-구성요소와-동작-요약>#</a></h5><table><thead><tr><th>구성 요소</th><th style=text-align:right>역할</th><th>주요 행동 (알고리듬 관점)</th><th>핵심 고려사항</th></tr></thead><tbody><tr><td>트랜잭션</td><td style=text-align:right>락 요청자</td><td>리소스 접근 전 락 (mode) 요청</td><td>필요한 격리 수준에 맞는 모드 선택</td></tr><tr><td>락 관리자</td><td style=text-align:right>중앙 결제자</td><td>현재 락 상태 조회 → 호환성 검사 → grant/queue → 락 테이블 갱신</td><td>락 테이블 동기화, 승격/변환 로직</td></tr><tr><td>호환성 매트릭스</td><td style=text-align:right>정책 (테이블)</td><td>mode×mode → 허용/거부 판단</td><td>DBMS 별 차이 존재 (U, SIX 등)</td></tr><tr><td>대기 큐</td><td style=text-align:right>블로킹 관리</td><td>충돌 시 큐 삽입, 우선순위/타임아웃 정책</td><td>공정성·우선순위 설계 필요</td></tr><tr><td>데드락 탐지기</td><td style=text-align:right>안전성 보장</td><td>Wait-for 그래프 또는 주기 검사 → 희생자 선정</td><td>검사 주기, 성능·탐지 지연 트레이드오프</td></tr><tr><td>락 해제/신호</td><td style=text-align:right>진행 재개</td><td>트랜잭션 종료시 락 해제 → 대기 후보 신호</td><td>락 에스컬레이션/수동 해제 이슈</td></tr></tbody></table><p>트랜잭션은 락을 &rsquo; 요청 &rsquo; 하고, 락 관리자는 호환성 매트릭스로 즉시 허용 혹은 대기를 결정한다.<br>대기 상태가 길어지면 데드락 탐지기가 그래프 기반으로 사이클을 찾고, 희생자를 골라 트랜잭션을 롤백해 교착을 해소한다.<br>락 승격 (예: U→X), 에스컬레이션 (행→페이지→테이블), 우선순위/타임아웃 정책 등은 전체 동작에 성능·공정성에 큰 영향을 준다. 또한 모드별 호환성 규칙은 DBMS 문서에서 정의된 상세 규칙을 따르는 것이 안전하다.</p><h5 id=락-처리-흐름과-데드락-대응-흐름도>락 처리 흐름과 데드락 대응 흐름도<a hidden class=anchor aria-hidden=true href=#락-처리-흐름과-데드락-대응-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  T[트랜잭션 요청] --&gt;|&#34;LOCK_REQ(mode)&#34;| LM[Lock Manager]
  LM --&gt; CK{호환성 검사}
  CK --&gt;|허용| GRANT[락 부여 및 테이블 갱신]
  CK --&gt;|불허| QUEUE[대기 큐에 삽입]
  QUEUE --&gt; DF[데드락 탐지기]
  DF --&gt;|사이클 없음| WAIT[대기 상태 유지]
  DF --&gt;|사이클 있음| VICTIM[희생자 선정]
  VICTIM --&gt; ROLLBACK[트랜잭션 롤백]
  ROLLBACK --&gt; RELEASE[락 해제 -&gt; 큐에 신호]
  GRANT --&gt; EXEC[트랜잭션 수행]
  EXEC --&gt;|커밋/롤백| RELEASE
  RELEASE --&gt; CK
  %% 보완 항목 표시
  subgraph 보완요소
    ESC[락 에스컬레이션/승격]
    METRICS[모니터링/메트릭 수집]
    TIMEOUT[타임아웃/우선순위 정책]
  end
  GRANT --&gt; ESC
  QUEUE --&gt; TIMEOUT
  LM --&gt; METRICS
</pre><p>트랜잭션이 락 요청을 보내면 락 관리자는 호환성 매트릭스 기반으로 즉시 부여하거나 대기 큐에 넣는다.<br>대기 큐에 들어간 트랜잭션들은 주기적 (또는 이벤트 기반) 으로 데드락 탐지기의 검사를 받는다.<br>사이클이 발견되면 희생자를 골라 롤백하고 그 결과로 락이 해제되어 대기 큐의 다음 후보가 재검사된다.<br>운영 관점에서는 락 승격 (예: U→X), 락 에스컬레이션 (세분화→거시화), 탐지 주기, 대기 타임아웃/우선순위 정책, 그리고 모니터링 지표가 전체 동작·성능에 큰 영향을 준다.<br>실제 구현 세부는 DBMS 문서를 따르는 것이 안전하다.</p><h4 id=잠금-제어-흐름과-생명주기-핵심>잠금 제어 흐름과 생명주기 핵심<a hidden class=anchor aria-hidden=true href=#잠금-제어-흐름과-생명주기-핵심>#</a></h4><p>트랜잭션이 락을 다루는 흐름은 <strong>요청 → 검사 → (대기 또는 부여) → 사용 → 해제</strong> 로 단순화할 수 있다.</p><ul><li>요청할 때는 " 무엇을 (행/범위/테이블), 왜 (읽기/쓰기) 잠그는지 " 를 명시.</li><li>DB 내부의 락 매니저는 <strong>호환성 표</strong>를 보고 즉시 부여할지 대기열에 넣을지 결정.</li><li>대기열에 들어가면 오래 기다리면 데드락 검출 알고리즘에 걸려 트랜잭션이 강제로 종료될 수 있다 (한 쪽을 죽여 문제를 풀음).</li><li>트랜잭션이 끝나면 보유한 락을 해제하고 대기 중인 트랜잭션을 깨운다.</li></ul><p>이 전체 과정에서 <strong>의도 락, 락 변환, 락 승격</strong> 같은 기법들이 동시성과 안전을 균형 있게 맞추도록 돕는다.</p><h5 id=잠금-데이터제어-흐름-요약>잠금 데이터·제어 흐름 요약<a hidden class=anchor aria-hidden=true href=#잠금-데이터제어-흐름-요약>#</a></h5><ul><li><strong>요청</strong>: 트랜잭션이 대상 객체 (테이블/행/범위) 에 S/IS/X/IX 등 모드로 락 요청.</li><li><strong>평가 (락 매니저)</strong>: 현재 부여/대기된 락들과 비교해 호환성 판별 (호환 → Granted, 불호환 → Waiting).</li><li><strong>대기 정책</strong>: 일반적으로 FIFO 지만 우선순위 (예: 트랜잭션 우선순위, 타임아웃) 로직을 둘 수 있음. 교착 가능성 판단을 위해 대기 그래프를 유지.</li><li><strong>락 변환</strong>: S→X 같은 변환 요청 시 재검사. 변환 대기 중 교착 가능성 주의.</li><li><strong>해제 & 깨움</strong>: 트랜잭션 종료 (커밋/롤백) 시 락 해제 → 큐에서 부합하는 요청을 깨워서 부여.</li><li><strong>운영 팁</strong>: 의도 락 사용, 최소 범위 (행 수준), 가능한 MVCC 활용, 락 승격 모니터링 권장.</li></ul><h5 id=잠금-제어-흐름-단계와-핵심-처리>잠금 제어 흐름 단계와 핵심 처리<a hidden class=anchor aria-hidden=true href=#잠금-제어-흐름-단계와-핵심-처리>#</a></h5><table><thead><tr><th style=text-align:right>단계</th><th>작업 내용</th><th>핵심 고려 사항 / 효과</th></tr></thead><tbody><tr><td style=text-align:right>요청 (Request)</td><td>잠금 대상/모드 지정 (S/IS/X/IX 등)</td><td>명확한 모드 선택으로 불필요한 대기 최소화</td></tr><tr><td style=text-align:right>평가 (Compatibility)</td><td>락 매니저가 기존 락과 비교</td><td>의도 락·호환성 매트릭스로 빠른 판별 가능. ([MySQL Developer Zone][2])</td></tr><tr><td style=text-align:right>대기 (Waiting)</td><td>불호환 시 큐에 삽입 (FIFO/우선순위)</td><td>데드락 가능성 → 데드락 탐지/타임아웃 필요. ([dsf.berkeley.edu][4])</td></tr><tr><td style=text-align:right>변환 (Conversion)</td><td>S→X 등 모드 변환 요청 및 재평가</td><td>변환 대기 중 교착 유의; 구현별 정책 차이. ([MySQL Developer Zone][5])</td></tr><tr><td style=text-align:right>부여/사용 (Granted)</td><td>락 부여 후 작업 수행</td><td>최소 범위로 락 유지 (성능 보전)</td></tr><tr><td style=text-align:right>해제 (Release)</td><td>커밋/롤백 시 락 해제 → 대기자 깨움</td><td>해제로 인한 깨움 순서가 전체 성능에 영향</td></tr></tbody></table><p>이 표는 락 획득·처리의 <strong>단계적 흐름</strong>과 각 단계에서 반드시 고려해야 할 운영·성능 요소를 연결한다. 특히 <strong>호환성 평가</strong>, <strong>대기 정책</strong>, <strong>변환 시 교착 위험</strong>은 실무 튜닝의 핵심 포인트다.</p><h5 id=락-제어-흐름-다이어그램>락 제어 흐름 다이어그램<a hidden class=anchor aria-hidden=true href=#락-제어-흐름-다이어그램>#</a></h5><pre class=mermaid>flowchart TD
  A[&#34;트랜잭션 요청: 잠금(R/W, 대상, 모드)&#34;] --&gt; B[락 매니저: 의도락/호환성 검사]
  B --&gt; |호환 가능| C[&#34;부여(Granted)&#34;]
  B --&gt; |충돌| D[&#34;대기열(Waiting)&#34;]
  D --&gt; E{대기 정책}
  E --&gt; |FIFO| D
  E --&gt; |우선순위/타임아웃| F[타임아웃 검사]
  F --&gt; |타임아웃 발생| G[Abort / 트랜잭션 중단]
  D --&gt; H[데드락 탐지]
  H --&gt; |사이클 발견| G
  C --&gt; I[작업 수행]
  I --&gt; J{변환 요청?}
  J --&gt; |예| K[&#34;잠금 변환 요청(S→X 등)&#34;]
  K --&gt; B
  J --&gt; |아니오| L[트랜잭션 완료?]
  L --&gt; |예| M[락 해제 → 대기자 깨움]
  L --&gt; |아니오| I
  G --&gt; N[롤백 &amp; 락 해제]
  N --&gt; M
</pre><h5 id=락-생명주기-상태도>락 생명주기 상태도<a hidden class=anchor aria-hidden=true href=#락-생명주기-상태도>#</a></h5><pre class=mermaid>stateDiagram-v2
    [*] --&gt; Requested : 잠금 요청
    Requested --&gt; Evaluating : 의도락/호환성 검사
    Evaluating --&gt; Granted : 호환성 통과 (부여)
    Evaluating --&gt; Waiting : 충돌 → 대기열 삽입
    Waiting --&gt; DeadlockCheck : 대기 중 데드락 탐지
    DeadlockCheck --&gt; Aborted : 데드락 victim 선정 (Abort)
    DeadlockCheck --&gt; Waiting : 이상 없음
    Waiting --&gt; TimeoutCheck : 타임아웃 검사
    TimeoutCheck --&gt; Aborted : 타임아웃 → Abort
    TimeoutCheck --&gt; Granted : 락 해제 후 부여
    Granted --&gt; Converting : 변환 요청(S-&gt;X 등)
    Converting --&gt; Evaluating : 변환 재평가
    Converting --&gt; Granted : 변환 부여
    Granted --&gt; Released : 트랜잭션 완료(커밋/롤백)
    Released --&gt; [*]
    Aborted --&gt; Released
</pre><h4 id=운영-중심-락-시스템-아키텍처>운영 중심 락 시스템 아키텍처<a hidden class=anchor aria-hidden=true href=#운영-중심-락-시스템-아키텍처>#</a></h4><p>간단히 말하면, 락 시스템은 트랜잭션이 데이터에 안전하게 접근하도록 중앙에서 조정하는 매커니즘이다.<br>트랜잭션이 락을 요청하면 Lock Manager 가 리소스를 빠르게 찾기 위해 Resource Hash 를 조회하고, Lock Table 에서 현재 상태를 확인한다.<br>충돌이 있으면 요청은 Wait Queue 에 들어가고, 여러 트랜잭션이 서로 기다리면 Deadlock Detector 가 이를 찾아서 희생자를 선정해 회복한다.<br>의도 락은 상위 레벨에서 하위 요청을 효율적으로 조절하도록 돕고, 모니터링은 운영 중 문제를 감지·해결할 근거를 제공한다.</p><h5 id=안정적-락-시스템-구조-설계>안정적 락 시스템 구조 설계<a hidden class=anchor aria-hidden=true href=#안정적-락-시스템-구조-설계>#</a></h5><ul><li>트랜잭션 → 락 요청 → Lock Manager 가 Resource Hash 로 위치 파악 → Lock Table 에서 허용/거부 판정 → 허용이면 사용, 거부면 Wait Queue → Deadlock Detector 감시 → 트랜잭션 종료 시 락 해제 → 모니터링 기록.</li></ul><h6 id=락-구조별-역할기능-요약표>락 구조별 역할·기능 요약표<a hidden class=anchor aria-hidden=true href=#락-구조별-역할기능-요약표>#</a></h6><table><thead><tr><th>구조 요소</th><th>설명</th><th>역할</th><th style=text-align:right>기능</th><th>특징</th><th>상호관계</th></tr></thead><tbody><tr><td>Lock Manager</td><td>중앙 제어 엔진</td><td>요청 수락/거부·에스컬레이션</td><td style=text-align:right>Lock Table·Wait Queue 제어</td><td>고동시성 최적화 필요</td><td>Transaction/Resource Manager 와 연동</td></tr><tr><td>Resource Hash</td><td>리소스 인덱스</td><td>빠른 리소스 조회</td><td style=text-align:right>해시 버킷·리샤이징</td><td>해시 충돌 관리 필요</td><td>Lock Table 을 색인</td></tr><tr><td>Lock Table</td><td>락 상태 저장소</td><td>리소스별 상태 유지</td><td style=text-align:right>레코드 CRUD, 소유자 목록</td><td>메모리 중심, GC 필요</td><td>Wait Queue·Deadlock Detector 공유</td></tr><tr><td>Wait Queue</td><td>대기열</td><td>거부된 요청 보관·정렬</td><td style=text-align:right>대기 항목 삽입/우선순위</td><td>대기 정책에 따라 성능 달라짐</td><td>Deadlock Detector 의 입력</td></tr><tr><td>Deadlock Detector</td><td>데드락 탐지기</td><td>사이클 탐지·회복 트리거</td><td style=text-align:right>그래프 생성·사이클 탐지</td><td>탐지 빈도에 비용</td><td>Wait Queue·Transaction List 참조</td></tr><tr><td>Intent Locks</td><td>상위 의도 표시</td><td>계층적 충돌 빠른 판정</td><td style=text-align:right>IS/IX/SIX 처리</td><td>경량·성능 최적화용</td><td>Lock Manager 호환성 검사에 사용</td></tr><tr><td>Transaction Manager</td><td>트랜잭션 상태 유지</td><td>락 보유 목록·복구</td><td style=text-align:right>락 해제·복구 트리거</td><td>트랜잭션 메타데이터와 결합</td><td>Lock Manager 와 직접 통신</td></tr><tr><td>Monitoring API</td><td>계측·노출 계층</td><td>운영·튜닝 데이터 제공</td><td style=text-align:right>실시간/집계 지표 노출</td><td>낮은 오버헤드 필요</td><td>모든 모듈에서 계측데이터 제공</td></tr></tbody></table><p>이 표는 락 시스템의 핵심 구조별로 무엇을 담당하고 어떤 기능을 수행하는지 정리했다. 설계 시 각 요소의 특징 (메모리 민감도, 동시성 부담, 비용) 을 고려해 자료구조·주기·정책을 설정해야 한다.</p><h6 id=구조별-설계운영-고려사항>구조별 설계·운영 고려사항<a hidden class=anchor aria-hidden=true href=#구조별-설계운영-고려사항>#</a></h6><table><thead><tr><th>구조 요소</th><th>설계 고려사항</th><th style=text-align:right>운영 고려 지표</th><th>실패 시 영향</th></tr></thead><tbody><tr><td>Lock Manager</td><td>락 - 프리 vs 버킷 락, 스케일 아웃</td><td style=text-align:right>평균 응답시간, CPU 사용량</td><td>전체 시스템 응답 지연</td></tr><tr><td>Resource Hash</td><td>해시 함수·버킷수, 리사이징 정책</td><td style=text-align:right>버킷 충돌률, 메모리 사용</td><td>검색 지연·경합 증가</td></tr><tr><td>Lock Table</td><td>레코드 포맷·GC 주기</td><td style=text-align:right>메모리 점유, 레코드 수</td><td>OOM, 성능 저하</td></tr><tr><td>Wait Queue</td><td>우선순위 정책, 스핀 vs 블록</td><td style=text-align:right>대기 길이, 평균 대기시간</td><td>트랜잭션 병목</td></tr><tr><td>Deadlock Detector</td><td>탐지 주기, 희생자 정책</td><td style=text-align:right>데드락 발생률, 복구 시간</td><td>장시간 블로킹</td></tr><tr><td>Intent Locks</td><td>계층 매핑 방식</td><td style=text-align:right>의도 락 비율</td><td>과도하면 상위 충돌 유발</td></tr><tr><td>Transaction Manager</td><td>락 리스트 스냅샷 빈도</td><td style=text-align:right>트랜잭션당 락 수</td><td>회복 복잡성 증가</td></tr><tr><td>Monitoring API</td><td>집계 레벨·노출 주기</td><td style=text-align:right>알람 빈도, 데이터 신뢰성</td><td>운영 판단 지연</td></tr></tbody></table><p>구조별로 설계 시 선택해야 하는 옵션들과 운영에서 모니터링해야 할 지표들, 실패 시 발생 가능한 영향을 정리했다. 초기 설계 시 이 고려사항들을 명시해두면 운영 중 문제 추적과 튜닝이 수월해진다.</p><h6 id=락-시스템-상호작용-구조도>락 시스템 상호작용 구조도<a hidden class=anchor aria-hidden=true href=#락-시스템-상호작용-구조도>#</a></h6><p>(점검·보완 사항 반영: 의도 락 표시, 모니터링 라인, Deadlock Detector 의 그래프 입력 포함)</p><pre class=mermaid>flowchart TB
    subgraph ClientLayer
        T[Transaction Start/End]
    end

    subgraph TransactionManager
        TM[Transaction State]
        TL[Lock List per Txn]
    end

    subgraph LockSubsystem
        RM[Resource Hash Table]
        LT[Lock Table]
        WQ[Wait Queue]
        CM[Compatibility Matrix]
        ID[Intent Locks Handler]
        DD[Deadlock Detector]
        LM[Lock Manager Core]
    end

    subgraph Monitoring
        MA[Metrics API / Collector]
        Dashboard[Dashboard / Alerts]
    end

    T --&gt;|요청 락| LM
    LM --&gt; RM
    RM --&gt; LT
    LM --&gt;|호환성 조회| CM
    LM --&gt; ID
    LT --&gt; WQ
    WQ --&gt; DD
    TL --&gt; LT
    TM --&gt; TL
    DD --&gt; LM
    LT --&gt; MA
    WQ --&gt; MA
    DD --&gt; MA
    MA --&gt; Dashboard
</pre><ul><li>트랜잭션은 Lock Manager 에 락 요청을 보낸다. Lock Manager 는 Resource Hash 로 리소스 레코드를 찾아 Lock Table 을 조회하고, Compatibility Matrix 와 Intent Locks 핸들러를 통해 허용 여부를 판단한다.</li><li>거부된 요청은 Wait Queue 에 등록되고, Deadlock Detector 는 Wait Queue 와 Transaction 의 락 리스트를 참고해 그래프를 구성하여 사이클 (데드락) 을 탐지한다.</li><li>모든 핵심 상태 (락 테이블, 대기열, 데드락 이벤트) 는 Metrics API 로 집계되어 대시보드와 알람으로 노출된다. 이 도식은 의도 락을 통한 계층적 판정, 모니터링의 위치, 데드락 탐지 입력 흐름을 명확히 반영한다.</li></ul><h5 id=락-구성-요소-및-운영-속성>락 구성 요소 및 운영 속성<a hidden class=anchor aria-hidden=true href=#락-구성-요소-및-운영-속성>#</a></h5><p>구성 요소는 락 시스템을 실제로 동작시키는 모듈들이다. 간단히: Lock Table 은 현재 누가 어떤 락을 갖고 있는지 저장하고, Resource Hash 는 빠르게 그 레코드를 찾게 해준다. Wait Queue 는 대기하는 요청을 보관하고, Deadlock Detector 는 서로 기다리는 트랜잭션 간 순환을 찾아 회복을 트리거한다. Intent Locks 는 상위 레벨에서 하위 요청을 효율화하고, Transaction Manager 는 트랜잭션별 보유 락을 정리해서 커밋/롤백 시 일괄 해제한다. Monitoring 은 운영자가 시스템 상태를 볼 수 있게 조직화된 데이터를 제공한다.</p><h6 id=락-구성요소-상세-속성-표>락 구성요소 상세 속성 표<a hidden class=anchor aria-hidden=true href=#락-구성요소-상세-속성-표>#</a></h6><table><thead><tr><th>구성 요소</th><th>설명</th><th>역할</th><th style=text-align:right>기능</th><th>특징</th><th>상호관계</th><th>필수/선택</th><th>속하는 구조</th></tr></thead><tbody><tr><td>Lock Table</td><td>락 레코드 저장소</td><td>리소스 상태 저장</td><td style=text-align:right>레코드 CRUD, 소유자 목록</td><td>메모리 중심, GC 필요</td><td>Resource Hash, Wait Queue 연동</td><td>필수</td><td>LockSubsystem</td></tr><tr><td>Resource Hash</td><td>리소스 인덱스</td><td>빠른 레코드 검색</td><td style=text-align:right>해시/버킷 관리</td><td>확장성 중요</td><td>Lock Table 사용</td><td>필수</td><td>LockSubsystem</td></tr><tr><td>Wait Queue</td><td>대기열</td><td>대기 요청 관리</td><td style=text-align:right>대기 삽입/우선순위</td><td>우선정책 영향 큼</td><td>Lock Table, DD 참조</td><td>필수</td><td>LockSubsystem</td></tr><tr><td>Deadlock Detector</td><td>탐지기</td><td>데드락 식별·회복</td><td style=text-align:right>그래프 구성, 사이클 탐지</td><td>비용 - 정확도 트레이드오프</td><td>Wait Queue, Transaction List</td><td>필수</td><td>LockSubsystem</td></tr><tr><td>Compatibility Matrix</td><td>충돌 규칙</td><td>모드간 허용 판단</td><td style=text-align:right>행렬 조회</td><td>DB 별 커스터마이징</td><td>Lock Manager 핵심 입력</td><td>필수</td><td>LockSubsystem</td></tr><tr><td>Intent Locks Handler</td><td>의도 락 처리기</td><td>계층적 의도 관리</td><td style=text-align:right>IS/IX/SIX 관리</td><td>상위 - 하위 최적화</td><td>Lock Manager, Lock Table</td><td>필수 (계층 락 시)</td><td>LockSubsystem</td></tr><tr><td>Transaction Lock List</td><td>Tx 보유 락 목록</td><td>트랜잭션별 정리</td><td style=text-align:right>락 해제·회복</td><td>복구시 중요</td><td>Transaction Manager ↔ Lock Table</td><td>필수</td><td>TransactionManager</td></tr><tr><td>Monitoring API</td><td>계측 인터페이스</td><td>운영 지표 제공</td><td style=text-align:right>집계·쿼리·알람</td><td>낮은 오버헤드 필요</td><td>모든 모듈 데이터 수집</td><td>필수 (운영)</td><td>Monitoring</td></tr><tr><td>Timeouts/Backoff</td><td>대기 정책 모듈</td><td>대기 제어</td><td style=text-align:right>타임아웃, 재시도 정책</td><td>정책 튜닝 필요</td><td>Wait Queue, Transaction Manager</td><td>선택 (정책에 따라)</td><td>LockSubsystem</td></tr></tbody></table><p>구성 요소별로 필수성, 상호연결, 그리고 속한 구조를 명시했다. 기본적인 락 시스템을 운영하려면 Lock Table, Resource Hash, Wait Queue, Deadlock Detector, Compatibility Matrix, Transaction Lock List, Monitoring API 는 반드시 필요하다. Timeouts/Backoff 등은 정책 선택에 따라 도입한다.</p><h6 id=구성요소-구현운영-고려사항>구성요소 구현·운영 고려사항<a hidden class=anchor aria-hidden=true href=#구성요소-구현운영-고려사항>#</a></h6><table><thead><tr><th>구성 요소</th><th>구현 고려사항</th><th style=text-align:right>운영 고려지표</th><th>확장성 이슈</th><th>보안/권한 고려</th></tr></thead><tbody><tr><td>Lock Table</td><td>메모리 포맷, GC, 동시성 제어</td><td style=text-align:right>레코드 수, 메모리 점유</td><td>리샤딩 필요 시 복잡</td><td>권한별 락 열람 제어</td></tr><tr><td>Resource Hash</td><td>해시 함수, 리사이징</td><td style=text-align:right>버킷 충돌률</td><td>노드 간 분산 인덱스</td><td>정보 노출 최소화</td></tr><tr><td>Wait Queue</td><td>우선순위 정책</td><td style=text-align:right>대기길이, 재시도율</td><td>큐 분할 필요성</td><td>공격성 요청 방지</td></tr><tr><td>Deadlock Detector</td><td>탐지 주기·알고리즘</td><td style=text-align:right>탐지시간, 회복시간</td><td>대규모 그래프 비용</td><td>로그/증적 보호</td></tr><tr><td>Compatibility Matrix</td><td>버전 관리</td><td style=text-align:right>매트릭스 변경 빈도</td><td>DB 별 커스터마이징</td><td>변경 권한 통제</td></tr><tr><td>Intent Locks</td><td>계층 매핑·오버헤드</td><td style=text-align:right>IS/IX 비율</td><td>계층 깊이 증가 시 복잡</td><td>적절한 권한 정보 포함</td></tr><tr><td>Monitoring API</td><td>데이터 집계 방식</td><td style=text-align:right>수집 지연, 오버헤드</td><td>높은 왕복시 성능 문제</td><td>민감 데이터 마스킹</td></tr><tr><td>Timeouts/Backoff</td><td>정책 파라미터</td><td style=text-align:right>타임아웃 빈도</td><td>글로벌 정책 적용 문제</td><td>정책 변경 권한 관리</td></tr></tbody></table><p>구성요소별로 구현 시 고려해야 할 기술적 사항과 운영지표, 확장성·보안 관련 주의점을 정리했다. 초기 설계 단계에서 이 표의 항목들을 검토하면 운영 이전 위험을 줄일 수 있다.</p><h6 id=락-구성요소-상호관계도>락 구성요소 상호관계도<a hidden class=anchor aria-hidden=true href=#락-구성요소-상호관계도>#</a></h6><pre class=mermaid>graph LR
    subgraph TransactionManager
        TState[Transaction State]
        TLockList[Lock List per Txn]
    end

    subgraph LockSubsystem
        ResourceHash[Resource Hash]
        LockTable[Lock Table]
        CompatMatrix[Compatibility Matrix]
        IntentHandler[Intent Locks Handler]
        WaitQueue[Wait Queue]
        Deadlock[Deadlock Detector]
        Timeouts[Timeouts/Backoff]
    end

    MonitoringAPI[Monitoring API]

    TState --&gt;|보유/요청| TLockList
    TLockList --&gt;|요청| LockTable
    TState --&gt;|요청| LockTable
    LockTable --&gt;|색인 요청| ResourceHash
    LockTable --&gt;|호환성 조회| CompatMatrix
    LockTable --&gt; IntentHandler
    LockTable --&gt;|거부 시| WaitQueue
    WaitQueue --&gt; Deadlock
    WaitQueue --&gt; Timeouts
    Deadlock --&gt;|희생자| TransactionManager
    LockTable --&gt; MonitoringAPI
    WaitQueue --&gt; MonitoringAPI
    Deadlock --&gt; MonitoringAPI
    Timeouts --&gt; MonitoringAPI
</pre><ul><li>트랜잭션은 자신의 락 목록을 통해 락 획득/반환을 관리하며, Lock Table 에 요청을 보낸다. Lock Table 은 Resource Hash 로 리소스 매핑을 수행하고 Compatibility Matrix 및 Intent Handler 를 참조해 결정한다.</li><li>거부된 요청은 Wait Queue 로 가며, Timeouts/Backoff 와 Deadlock Detector 가 이를 관리한다. Monitoring API 는 핵심 상태를 수집해 운영 대시보드에 제공한다.</li></ul><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=락-모드의-실무적-가치와-설계-원리>락 모드의 실무적 가치와 설계 원리<a hidden class=anchor aria-hidden=true href=#락-모드의-실무적-가치와-설계-원리>#</a></h4><p>락은 여러 트랜잭션이 동시에 데이터에 접근할 때 발생할 수 있는 충돌과 이상현상을 막는 규칙이다.<br>올바른 락 모드 설계는</p><ol><li>데이터의 정합성을 보장하고</li><li>동시에 가능한 작업 수를 늘려 성능 효율을 높이며</li><li>운영 중 문제를 추적·해결하기 쉽게 만든다.</li></ol><p>핵심 기법으로는 상위 레벨에서 충돌을 미리 알게 해주는 의도잠금, 행 단위로 충돌 면적을 좁히는 세분화, 삽입·팬텀을 막는 범위락, 그리고 필요에 따른 락 강도 전환이 있다.<br>실무에서는 적절한 인덱스와 짧은 트랜잭션 경계가 이 장점들을 실제 성능으로 연결한다.</p><h5 id=락-모드의-장점근거실무-효과-표>락 모드의 장점·근거·실무 효과 표<a hidden class=anchor aria-hidden=true href=#락-모드의-장점근거실무-효과-표>#</a></h5><table><thead><tr><th>장점</th><th>기술적 근거</th><th>실무 효과 / 기대치</th><th>적용 상황</th></tr></thead><tbody><tr><td>정합성 보장</td><td>2PL, Predicate/Key-range/gap 락</td><td>Dirty/Non-repeatable/Phantom 방지 → 결과 예측 가능성↑</td><td>금융·회계·주문 처리</td></tr><tr><td>세밀한 동시성 제어</td><td>행/키 그레뉼러리티, 호환성 매트릭스</td><td>동시 처리량 증가, 응답시간 개선</td><td>OLTP, 다중 사용자 시스템</td></tr><tr><td>계층적 효율성</td><td>Intent(IS/IX/SIX) 으로 상위 충돌 판정</td><td>충돌 검사 비용·CPU 사용량 감소</td><td>대용량 테이블 수정</td></tr><tr><td>문제 진단 용이성</td><td>Lock Manager·대기 그래프 구조</td><td>블로킹 원인 추적·MTTR 단축</td><td>운영 장애 대응</td></tr><tr><td>범위 보호 (팬텀 차단)</td><td>Key-range / Predicate 락</td><td>SERIALIZABLE 수준 보장 → 집계·정산 신뢰성 확보</td><td>리포팅·정산·통계 연산</td></tr><tr><td>적응형 세분성 (에스컬레이션)</td><td>락 승격/강등, Escalation 정책</td><td>메모리·성능 균형 최적화 (단, 정책 오류 위험)</td><td>혼합 워크로드 환경</td></tr></tbody></table><ul><li>락 모드는 <strong>정합성 확보</strong>와 <strong>동시성 개선</strong>이라는 상반된 목표를 균형 있게 관리한다.</li><li>의도 잠금과 그레뉼러리티 조절은 동시성 향상에 직접 기여하고, 락 메타데이터·에스컬레이션 정책은 운영 비용·리스크를 결정한다.</li><li>실무에서는 인덱스·트랜잭션 길이·격리 수준을 함께 조율해 위 장점들을 실효성 있게 활용해야 한다.</li></ul><h4 id=락-기반-동시성의-한계와-완화-전략>락 기반 동시성의 한계와 완화 전략<a hidden class=anchor aria-hidden=true href=#락-기반-동시성의-한계와-완화-전략>#</a></h4><p>락 기반 동시성 제어는 단순하고 강력하지만, 몇 가지 피할 수 없는 비용과 한계가 있다.<br>락을 얻고 푸는 비용 (오버헤드), 서로를 기다리게 만드는 상황 (데드락), 락이 집중되어 시스템 전체를 느리게 만드는 병목이 대표적이다.<br>하드웨어 관점에선 메모리·CPU·캐시 구조 (NUMA, 캐시라인) 가 성능에 직접적인 영향을 주며, 분산 환경에서는 노드 간 락 동기화 자체가 큰 제약이 된다.<br>그래서 실무에서는 <strong>락을 줄이는 설계 (MVCC, 낙관적 방법), 트랜잭션 단축, 파티셔닝, 그리고 하드웨어 특성 반영</strong>을 조합해 문제를 완화한다.</p><h5 id=락-방식의-주요-단점>락 방식의 주요 단점<a hidden class=anchor aria-hidden=true href=#락-방식의-주요-단점>#</a></h5><table><thead><tr><th>단점</th><th>설명</th><th style=text-align:right>원인</th><th>실무에서 발생되는 문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>락 오버헤드</td><td>락 획득/해제·메타데이터 관리 비용</td><td style=text-align:right>Lock Manager·lock table</td><td>처리량 감소, CPU/메모리 소모</td><td>트랜잭션 단축·그라뉼러티 조정·락 풀링</td><td>MVCC, Optimistic Concurrency</td></tr><tr><td>데드락</td><td>순환 대기로 진행 불가 상태</td><td style=text-align:right>리소스 접근 순서 불일치</td><td>트랜잭션 롤백·지연</td><td>자원 순서 규칙·탐지 (Wait-For Graph)·타임아웃</td><td>Timestamp/OCC, Snapshot</td></tr><tr><td>병목/확장성 저하</td><td>특정 리소스에 락 집중</td><td style=text-align:right>과도한 X/Range 락·긴 TX</td><td>Throughput 저하·응답 지연</td><td>인덱스 개선·파티셔닝·샤딩</td><td>MVCC, Sharding</td></tr><tr><td>복잡성 증가</td><td>락 모드·계층·정책 복잡</td><td style=text-align:right>다양한 모드·의도락 등</td><td>운영·유지보수 비용 증가</td><td>정책 표준화·자동화 툴</td><td>MVCC 기반 단순화</td></tr><tr><td>락 확대 문제</td><td>세부 락 → 상위 락 승격으로 동시성 하락</td><td style=text-align:right>DBMS 임계치·메모리 부족</td><td>갑작스런 블로킹·데드락</td><td>임계치 조정·쿼리 리팩토링</td><td>샤딩, Lock-free 구조</td></tr></tbody></table><ul><li>단점은 <strong>락 방식 자체의 비용과 상호작용</strong>에서 비롯된다.</li><li>실무에서는 우선적으로 트랜잭션 설계 (짧게), 적절한 인덱스·파티셔닝, 그리고 MVCC/낙관적 접근을 고려해 완화한다. 또한 모니터링으로 이상 징후 (데드락 빈도·락 확대 발생) 를 조기 포착해야 한다.</li></ul><h5 id=락-시스템의-환경하드웨어-제약>락 시스템의 환경·하드웨어 제약<a hidden class=anchor aria-hidden=true href=#락-시스템의-환경하드웨어-제약>#</a></h5><table><thead><tr><th>제약사항</th><th>설명</th><th style=text-align:right>원인</th><th>영향</th><th>해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>자원 제한</td><td>락 테이블·대기큐가 메모리·CPU 를 사용</td><td style=text-align:right>동시 트랜잭션 폭증</td><td>lock table overflow·성능저하</td><td>메모리 증설·거버닝·트랜잭션 규모 축소</td><td>분산 DB·샤딩</td></tr><tr><td>대용량·분산 한계</td><td>노드 간 락 동기화의 비용·복잡성</td><td style=text-align:right>네트워크 지연·분산 일관성 요구</td><td>응답지연·복잡한 운영</td><td>지역성 설계·분산 락 서비스 사용</td><td>분산 MVCC·이벤트 기반 아키텍처</td></tr><tr><td>NUMA·캐시 제약</td><td>메모리 지역성·캐시라인 경쟁</td><td style=text-align:right>하드웨어 아키텍처</td><td>락 획득 지연, 스케일링 실패</td><td>NUMA 바인딩·패딩·분산 락 설계</td><td>lock-free 알고리즘</td></tr><tr><td>단일 노드 중심</td><td>중앙 Lock Manager 의 확장 한계</td><td style=text-align:right>중앙 집중형 설계</td><td>확장성·가용성 제한</td><td>분산락 (zk/etcd), 파티셔닝</td><td>분산 합의 기반 시스템</td></tr></tbody></table><ul><li>제약사항은 <strong>하드웨어·아키텍처 선택</strong>과 직결된다.</li><li>이를 완화하려면 애초 아키텍처 (샤딩·지역성·분산락 서비스) 를 고려해 설계하거나, 하드웨어 (메모리·디스크·NUMA 배치) 를 워크로드에 맞춰 조정해야 한다.</li></ul><h4 id=잠금-트레이드오프와-혼합-전략-해법>잠금 트레이드오프와 혼합 전략 해법<a hidden class=anchor aria-hidden=true href=#잠금-트레이드오프와-혼합-전략-해법>#</a></h4><ol><li><strong>무엇이 문제인가?</strong>—동시에 여러 트랜잭션이 같은 데이터를 다루면 충돌·불일치가 발생.</li><li><strong>어떤 선택이 있나?</strong>—강한 락 (직렬성 보장) vs 약한 락 (높은 동시성) vs MVCC/낙관적 방식.</li><li><strong>결정 기준은?</strong>—읽기/쓰기 비율, 응답성 요구, 데이터 일관성 중요도 (예: 금융은 강한 일관성), 배치 크기 등.</li><li><strong>실무 패턴</strong>—MVCC 로 읽기 최적화 + 행 잠금으로 쓰기 통제, 필요 시 락 에스컬레이션.</li></ol><h5 id=잠금-선택지별-장단점-표>잠금 선택지별 장단점 표<a hidden class=anchor aria-hidden=true href=#잠금-선택지별-장단점-표>#</a></h5><table><thead><tr><th>A(선택지)</th><th style=text-align:right>B(선택지)</th><th>주요 고려 기준</th><th>A 의 장점</th><th>A 의 단점</th><th>B 의 장점</th><th>B 의 단점</th><th>권장 상황</th></tr></thead><tbody><tr><td>행 단위 잠금</td><td style=text-align:right>테이블 단위 잠금</td><td>동시성 vs 오버헤드</td><td>높은 동시성, 세밀 통제</td><td>락 수·메모리·관리 오버헤드 증가</td><td>단순·낮은 오버헤드, 빠른 대형 작업 처리</td><td>동시성 낮고 병목 유발 가능</td><td>OLTP(행 단위) vs 배치/간단 스크립트 (테이블)</td></tr><tr><td>S/X 기본 모드</td><td style=text-align:right>Intent + Update 모드</td><td>단순성 vs 성능·안정성</td><td>구현·운영 단순, 예측 쉬움</td><td>데드락·경합 관리 한계</td><td>데드락 완화, 복잡한 트랜잭션에서 성능 우위</td><td>설계·디버깅 복잡</td><td>단순 앱 (S/X) vs 복잡 트랜잭션·다중레벨 데이터 (Intent)</td></tr><tr><td>Pessimistic(락)</td><td style=text-align:right>Optimistic/MVCC</td><td>일관성 보장 vs 처리량</td><td>강한 충돌 차단 (일관성 우수)</td><td>동시성 저하·대기·데드락</td><td>읽기 동시성 우수, 낮은 락 오버헤드</td><td>쓰기 충돌·재시도/직렬화 추가 필요</td><td>금융/정산 (비관적) vs 읽기중심 서비스 (MVCC)</td></tr></tbody></table><ul><li><strong>행 단위</strong>는 동시성 극대화, 하지만 락 추적·메모리 비용과 관리 난이도가 올라간다. <strong>테이블 단위</strong>는 단순·저비용이나 병목 유발.</li><li><strong>Intent/Update</strong> 모드는 다단계·복잡 트랜잭션에 유리하며, S/X 기본 모델은 단순 애플리케이션에서 충분할 때가 많다.</li><li><strong>MVCC/낙관적</strong>은 읽기가 많은 워크로드에 필수적 선택지이며, <strong>비관적 (락)</strong> 방식은 변경이 잦고 일관성이 최우선인 시스템에서 선호된다.</li></ul><h5 id=하이브리드-동시성-제어-패턴>하이브리드 동시성 제어 패턴<a hidden class=anchor aria-hidden=true href=#하이브리드-동시성-제어-패턴>#</a></h5><table><thead><tr><th>패턴명</th><th style=text-align:right>구성 요소</th><th>적용 목적</th><th>장점</th><th>고려/주의사항</th></tr></thead><tbody><tr><td>MVCC + 행락 혼합</td><td style=text-align:right>MVCC(읽기 스냅샷) + 행잠금 (쓰기)</td><td>읽기 병렬성 확보 + 쓰기 일관성</td><td>읽기 부하에 탁월, 읽기 지연 최소화</td><td>쓰기 충돌·재시도 관리 필요, 복잡도 증가.</td></tr><tr><td>세분화 + 에스컬레이션</td><td style=text-align:right>행/키 잠금 → 임계치 시 테이블/페이지로 에스컬레이션</td><td>평상시 동시성 유지, 대형 작업 비용 완화</td><td>운영 오버헤드 제어, 평상시 고성능</td><td>에스컬레이션 시 병목 급증 가능, 정책 튜닝 필요.</td></tr><tr><td>Intent + Range 락 혼합</td><td style=text-align:right>다중 그레인 Intent + 범위 (갭) 락</td><td>팬텀 방지 + ancestor 충돌 판정 가속</td><td>트리 구조에서 효율적, 팬텀 제어</td><td>설계·디버깅 복잡, DBMS 별 세부 동작 차이.</td></tr><tr><td>OCC + 재시도 정책</td><td style=text-align:right>낙관적 트랜잭션 + commit 시 검증/재시도</td><td>쓰기 충돌 적은 환경에서 높은 처리량</td><td>낮은 락 오버헤드, 간단한 읽기</td><td>재시도 비용·응답 지연, 충돌 빈도 높으면 비효율.</td></tr></tbody></table><ul><li>하이브리드 전략은 <strong>워크로드 특성 (읽기/쓰기 비율, 배치 주기, 응답성 요구)</strong> 에 따라 선택된다.</li><li>운영환경에서는 보통 <strong>MVCC 기반 읽기 + 부분적 락 (쓰기 안전장치)</strong> 또는 <strong>세분화된 락 + 에스컬레이션</strong> 조합이 널리 쓰인다.</li><li>각 패턴은 **장점과 복잡성 (디버깅/튜닝 부담)**을 동시에 가져오기 때문에, 모니터링·메트릭 (락 대기시간, 재시도율 등) 을 기반으로 정책을 조정해야 한다.</li></ul><h4 id=워크로드-기반-락-전략과-권장>워크로드 기반 락 전략과 권장<a hidden class=anchor aria-hidden=true href=#워크로드-기반-락-전략과-권장>#</a></h4><p>락 (또는 MVCC) 은 <strong>누가 언제 데이터를 읽고 쓰는지</strong>를 조정하는 도구다.</p><ul><li>트랜잭션이 많고 변경이 잦은 <strong>OLTP</strong>에서는 전통적 락 (S/X/U 등) 으로 정확성을 우선한다.</li><li>데이터 읽기가 많고 긴 쿼리가 많은 <strong>OLAP</strong>은 스냅샷 (MVCC) 을 써서 읽기를 차단하지 않는 방식을 선호한다.</li><li><strong>분산 환경</strong>에서는 전역 락을 남발하면 확장성이 깨지니, 분산 락·샤딩·낙관적 제어를 적절히 조합해야 한다.</li></ul><h5 id=락-모드-적용-적합성-평가>락 모드 적용 적합성 평가<a hidden class=anchor aria-hidden=true href=#락-모드-적용-적합성-평가>#</a></h5><h6 id=설계-관점-design>설계 관점 (Design)<a hidden class=anchor aria-hidden=true href=#설계-관점-design>#</a></h6><ul><li><strong>OLTP</strong>: 트랜잭션 짧게 설계, 가능한 한 행 단위 락 (row-level) 사용, 인덱스 설계로 범위 스캔 최소화—S/X/U/IS/IX 조합 권장.</li><li><strong>OLAP</strong>: 스냅샷 기반 조회 (읽기 전용 복제/머티리얼라이즈드 뷰) 우선, 필요 시 Read-only S 나 Range Lock 최소 사용.</li><li><strong>분산</strong>: 글로벌 동기화는 비용이 크므로 파티셔닝·서브시스템별 일관성 경계 (최종일관성 허용 가능한 영역) 설계, 필요 시 분산 락 서비스 적용.</li></ul><h6 id=분석-관점-analysis--trade-offs>분석 관점 (Analysis / Trade-offs)<a hidden class=anchor aria-hidden=true href=#분석-관점-analysis--trade-offs>#</a></h6><ul><li><strong>일관성 vs 성능</strong>: 락 (비관적) 은 일관성 높지만 대기·데드락 발생 가능. MVCC(비락) 는 읽기 성능 우수하지만 버전 GC·쓰기 충돌 비용 존재. 워크로드 특성 (읽기/쓰기 비율, 트랜잭션 길이) 에 따라 선택.</li><li><strong>운영 복잡도</strong>: 락 에스컬레이션·승격 정책, 데드락 빈도와 탐지/해결 전략이 운영 부담을 결정.</li></ul><h6 id=운영-관점-ops--runbook>운영 관점 (Ops / Runbook)<a hidden class=anchor aria-hidden=true href=#운영-관점-ops--runbook>#</a></h6><ul><li><strong>OLTP 운영 지표</strong>: 락 대기 시간, 데드락 빈도, 에스컬레이션 횟수 모니터링 필요. 긴 트랜잭션은 피하고, 인덱스·쿼리 튜닝으로 락 획득 범위를 줄여야 함.</li><li><strong>분산 운영</strong>: 분산 락 (예: Redis, ZK) 사용 시 TTL·재시도·희소성 (락 소유권) 정책을 명확히 해두어야 함.</li></ul><h5 id=시스템-유형별-락-적용-권장표>시스템 유형별 락 적용 권장표<a hidden class=anchor aria-hidden=true href=#시스템-유형별-락-적용-권장표>#</a></h5><table><thead><tr><th>시스템 유형</th><th style=text-align:center>적합도 (★5)</th><th>왜 적합/부적합? (핵심 근거)</th><th>권장 Lock Modes / 패턴</th></tr></thead><tbody><tr><td>OLTP (금융/결제)</td><td style=text-align:center>★★★★★</td><td>짧고 빈번한 업데이트, 강한 무결성 필요—전통 락이 안전.</td><td>S, X, U, IS, IX; 짧은 트랜잭션, 인덱스 최적화</td></tr><tr><td>OLAP (분석/리포팅)</td><td style=text-align:center>★★★</td><td>대량 읽기·장시간 쿼리—읽기 블로킹 회피가 우선.</td><td>MVCC 스냅샷, Read-only S / Range Locks 최소 사용</td></tr><tr><td>배치 처리 (대용량)</td><td style=text-align:center>★★</td><td>동시성 낮고 순차적 작업—전체 잠금으로 단순화 가능</td><td>X, BU (bulk update), 전용 배치 창</td></tr><tr><td>실시간 (예측응답)</td><td style=text-align:center>★★★★</td><td>응답 시간 예측 필요—락 지연 최소화</td><td>짧은 S/X, 타임아웃 엄격 적용, 낙관적 전략 병행</td></tr><tr><td>분산 시스템</td><td style=text-align:center>★★</td><td>네트워크 지연·파티셔닝으로 전역 락 비효율</td><td>분산 락 서비스 + 샤딩/MVCC/낙관적 CC 조합.</td></tr></tbody></table><p>워크로드 성격에 따라 &rsquo; 락 중심 (OLTP) ↔ MVCC/스냅샷 (OLAP)&rsquo; 선택이 핵심이다. 분산·대규모 환경에서는 전역 락은 피하고 분산 락·샤딩·낙관적 병행 제어를 조합해 확장성·일관성의 균형을 맞춰야 한다. 운영에서는 락 대기·데드락·에스컬레이션 지표를 지속 모니터링하고, 트랜잭션을 가능한 짧게 유지하는 것이 성능·가용성에 가장 큰 영향을 준다.</p><h3 id=구현-방법-및-분류>구현 방법 및 분류<a hidden class=anchor aria-hidden=true href=#구현-방법-및-분류>#</a></h3><h4 id=락-모드-구현운영-핵심-카탈로그>락 모드 구현·운영 핵심 카탈로그<a hidden class=anchor aria-hidden=true href=#락-모드-구현운영-핵심-카탈로그>#</a></h4><ul><li>트랜잭션은 <strong>읽기용 (S)</strong> 과 <strong>쓰기용 (X)</strong> 잠금을 통해 서로 방해하지 않도록 한다.</li><li><strong>Update(U)</strong> 는 읽기 후 쓰기 가능성 있는 상황에서 데드락을 줄이기 위해 쓰인다.</li><li><strong>의도 락</strong>은 " 내가 곧 행 단위 락을 잡을 거다 " 라고 테이블 수준에 알려줘 검사 비용을 줄여준다.</li><li>범위 (갭) 잠금은 <strong>범위 쿼리의 새로운 행 삽입 (phantom)</strong> 을 막는다.</li><li>락 관리는 <strong>락 매니저 (해시 테이블 + 대기 리스트)</strong> 가 하고, <strong>승격·변환·데드락 탐지·타임아웃</strong> 같은 운영 정책이 성능/정합성에 큰 영향을 준다.</li></ul><h5 id=구현-기법별-정리>구현 기법별 정리<a hidden class=anchor aria-hidden=true href=#구현-기법별-정리>#</a></h5><table><thead><tr><th style=text-align:right>구현 방법</th><th>정의</th><th>특징</th><th>목적</th><th>사용 상황</th><th>예시</th></tr></thead><tbody><tr><td style=text-align:right>Shared (S)</td><td>읽기용 공유잠금</td><td>여러 트랜잭션 동시 보유 가능. 쓰기 차단</td><td>Dirty Read 방지, 일관된 읽기</td><td>SELECT(락을 요구하는 경우), READ_COMMITTED 이상</td><td>SELECT … FOR SHARE / 보통 읽기</td></tr><tr><td style=text-align:right>Exclusive (X)</td><td>쓰기용 배타잠금</td><td>단일 보유, 대부분 비호환</td><td>Lost Update/Dirty Write 방지</td><td>INSERT/UPDATE/DELETE</td><td>UPDATE … (행에 X)</td></tr><tr><td style=text-align:right>Update (U)</td><td>읽기 후 쓰기 가능성 표시</td><td>S 와 호환, U 끼리 상호 제한</td><td>S→X 변환 시 데드락 완화</td><td>UPDATE 의 식별 단계</td><td>SELECT for UPDATE 변형</td></tr><tr><td style=text-align:right>Intent (IS/IX/SIX)</td><td>상위 객체에 하위 잠금 의도 표기</td><td>빠른 호환 검사, 계층적</td><td>락 검사 비용 절감</td><td>행 단위 락 시 테이블 레벨에 설정</td><td>행 업데이트 시 테이블에 IX</td></tr><tr><td style=text-align:right>Range/Gap/Next-Key</td><td>인덱스 키 범위 잠금 (갭)</td><td>행 + 갭/갭만 등 DB 별 차이</td><td>Phantom Read 방지 (범위 삽입 차단)</td><td>범위 쿼리, SERIALIZABLE</td><td>InnoDB next-key lock</td></tr><tr><td style=text-align:right>Schema Lock (Sch-S/Sch-M)</td><td>스키마 변경 제어</td><td>DDL/DML 간 충돌 방지</td><td>DDL 안전성 보장</td><td>ALTER TABLE, 쿼리 실행</td><td>ALTER TABLE → Sch-M</td></tr></tbody></table><h5 id=락-모드-카테고리별-분류>락 모드 카테고리별 분류<a hidden class=anchor aria-hidden=true href=#락-모드-카테고리별-분류>#</a></h5><h6 id=기본-모드-데이터-접근-목적>기본 모드 (데이터 접근 목적)<a hidden class=anchor aria-hidden=true href=#기본-모드-데이터-접근-목적>#</a></h6><ul><li>S (Shared): 읽기 목적, 다중 보유, 쓰기 차단.</li><li>X (Exclusive): 쓰기 목적, 단독 보유.</li><li>U (Update): 읽기→쓰기 가능성 있는 경우, 데드락 완화.</li></ul><table><thead><tr><th style=text-align:right>모드</th><th>정의</th><th style=text-align:right>특징</th><th>사용 예</th></tr></thead><tbody><tr><td style=text-align:right>S</td><td>읽기 잠금</td><td style=text-align:right>다중 동시 보유, X 차단</td><td>SELECT FOR SHARE</td></tr><tr><td style=text-align:right>X</td><td>쓰기 잠금</td><td style=text-align:right>단일 보유, 강한 배타성</td><td>UPDATE, DELETE</td></tr><tr><td style=text-align:right>U</td><td>업데이트 잠금</td><td style=text-align:right>S 와 일부 호환, U 끼리 제한</td><td>UPDATE 전 조건 평가</td></tr></tbody></table><ul><li>기본 모드는 <strong>데이터 접근 (읽기/쓰기)</strong> 목적에 따라 선택되며, S 는 읽기 동시성을 높이고 X 는 무결성을 보장. U 는 S→X 승격에서 생기는 데드락을 줄이는 실무적 보완 모드다.</li></ul><hr><h6 id=계층메타-모드-호환성-최적화>계층/메타 모드 (호환성 최적화)<a hidden class=anchor aria-hidden=true href=#계층메타-모드-호환성-최적화>#</a></h6><ul><li>IS/IX/SIX: 상위 객체에 하위 락 의도를 표시해 전체 검사 비용을 낮춤.</li><li>NL: 잠금 없음 (메타 목적).</li></ul><table><thead><tr><th style=text-align:right>모드</th><th>정의</th><th style=text-align:right>역할</th><th>사용 예</th></tr></thead><tbody><tr><td style=text-align:right>IS</td><td>의도 공유</td><td style=text-align:right>테이블에 읽기 의도 표기</td><td>행 단위 S 획득 시 테이블 IS</td></tr><tr><td style=text-align:right>IX</td><td>의도 배타</td><td style=text-align:right>행에 X 를 잡을 의도 표기</td><td>행 업데이트 시 테이블 IX</td></tr><tr><td style=text-align:right>SIX</td><td>혼합</td><td style=text-align:right>테이블 S + 하위 일부 X 의도</td><td>대량 읽기 + 일부 수정</td></tr></tbody></table><ul><li>의도 락은 <strong>계층적 잠금 검사</strong>의 핵심이며, 하위 락들을 일일이 검사하지 않고 O(1) 수준으로 충돌 여부를 판별하도록 해 퍼포먼스에 도움을 준다.</li></ul><h6 id=범위팬텀-제어>범위/팬텀 제어<a hidden class=anchor aria-hidden=true href=#범위팬텀-제어>#</a></h6><ul><li>Gap / Next-Key / Range Locks: 인덱스 범위나 gap 을 잠궈 범위 삽입/삭제 (팬텀) 를 방지.</li></ul><table><thead><tr><th style=text-align:right>기법</th><th>정의</th><th style=text-align:right>목적</th><th>사용 예</th></tr></thead><tbody><tr><td style=text-align:right>Gap Lock</td><td>키 사이의 gap 잠금</td><td style=text-align:right>삽입 방지 (팬텀)</td><td>범위 쿼리</td></tr><tr><td style=text-align:right>Next-Key</td><td>레코드 + gap 잠금</td><td style=text-align:right>레코드와 갭 동시 보호</td><td>InnoDB next-key</td></tr><tr><td style=text-align:right>Range Lock</td><td>범위 기반 잠금</td><td style=text-align:right>범위 안정성 보장</td><td>SERIALIZABLE 범위 쿼리</td></tr></tbody></table><ul><li>범위 락류는 <strong>팬텀 현상</strong>을 방어하기 위해 사용되며, 구현 차이 (갭만/레코드 + 갭) 는 DBMS 에 따라 결과와 성능에 큰 영향을 준다.</li></ul><h6 id=스키마시스템-레벨>스키마·시스템 레벨<a hidden class=anchor aria-hidden=true href=#스키마시스템-레벨>#</a></h6><ul><li>Schema Locks, Lock Manager 설계 (해시 테이블·파티셔닝), Lock Escalation 등.</li></ul><table><thead><tr><th style=text-align:right>항목</th><th>정의</th><th>운영 영향</th><th>사용 예</th></tr></thead><tbody><tr><td style=text-align:right>Schema Locks</td><td>DDL/DML 충돌 제어</td><td>DDL 시 서비스 영향</td><td>ALTER TABLE</td></tr><tr><td style=text-align:right>Lock Manager</td><td>락 상태 추적 모듈</td><td>성능 병목/파티셔닝 필요</td><td>해시 lock table</td></tr><tr><td style=text-align:right>Lock Escalation</td><td>세부 락→상위 락 전환</td><td>동시성 감소 가능</td><td>대량 행 잠금 시 테이블 락</td></tr></tbody></table><ul><li>시스템 레벨 기법은 <strong>운영성·성능</strong>에 직접 영향. 락 매니저 구조와 승격 규칙을 모르면 대규모 작업에서 큰 병목·블로킹이 발생할 수 있다.</li></ul><h5 id=락-모드기법-통합-요약표>락 모드·기법 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-모드기법-통합-요약표>#</a></h5><table><thead><tr><th style=text-align:right>카테고리</th><th>기법/모드</th><th>정의 (요약)</th><th>목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td style=text-align:right>기본 모드</td><td>S / X / U</td><td>읽기/쓰기/업데이트 잠금</td><td>일관성·동시성 균형</td><td>최소 범위/짧은 유지 권장</td></tr><tr><td style=text-align:right>계층/메타</td><td>IS / IX / SIX</td><td>상위에 의도 표기</td><td>빠른 충돌 검사</td><td>자동 부착/검사 최적화</td></tr><tr><td style=text-align:right>범위 제어</td><td>Gap / Next-Key / Range</td><td>인덱스 범위 잠금</td><td>Phantom 방지</td><td>DB 별 동작 차이 주의</td></tr><tr><td style=text-align:right>시스템 레벨</td><td>Schema / LockMgr / Escalation</td><td>스키마·락관리·승격</td><td>DDL 안전·자원관리</td><td>파티셔닝/모니터링 필요</td></tr></tbody></table><h4 id=sql-표준과-dbms-락-구현-실무-지침>SQL 표준과 DBMS 락 구현 실무 지침<a hidden class=anchor aria-hidden=true href=#sql-표준과-dbms-락-구현-실무-지침>#</a></h4><p>SQL 표준은 <strong>격리 수준</strong>을 정의해 어떤 일관성 문제가 허용되는지 (더티 리드, 반복 불가 리드, 팬텀 등) 를 규정한다. 그러나 <strong>표준은 &rsquo; 어떻게 구현할지 &lsquo;(예: 어떤 종류의 락을 걸어서 팬텀을 막을지) 를 지정하지 않고</strong> 각 DBMS 가 최적화한 방법으로 구현한다.<br>결과적으로 같은 <code>SERIALIZABLE</code> 이라도 DBMS 마다 내부 동작 (범위 락, 버전 기반 검사, 재시도 정책 등) 이 달라서 실무에서는 <strong>표준 요구사항 + 대상 DBMS 문서</strong>를 함께 이해해야 한다.</p><h5 id=sql-표준과-dbms-락-구현-비교>SQL 표준과 DBMS 락 구현 비교<a hidden class=anchor aria-hidden=true href=#sql-표준과-dbms-락-구현-비교>#</a></h5><table><thead><tr><th>항목</th><th>표준 (ANSI/ISO) 내용</th><th>DBMS 구현 (대표적 사례)</th><th>실무 시 확인 포인트</th></tr></thead><tbody><tr><td>격리 수준 정의</td><td>Dirty/Non-repeatable/Phantom 등 현상 기준 (READ UNCOMMITTED → SERIALIZABLE).</td><td>MySQL(InnoDB), PostgreSQL, SQL Server 등 모두 격리 수준 제공하되 구현 방식 상이.</td><td>애플리케이션이 요구하는 ** 무결성 (예: 팬텀 허용 여부)** 을 명확히 하고 DBMS 별 매핑 확인</td></tr><tr><td>팬텀 제어 방식</td><td>표준은 팬텀 방지를 요구 (Serializable)—구현 방법은 미지정.</td><td>InnoDB: next-key/gap locks<br>PostgreSQL: SSI(predicate-like checks)<br>SQL Server: range locks/locking strategies.</td><td>특정 쿼리 (인덱스 유무, 스캔 유형) 에 따라 실제 락 범위가 달라짐—쿼리 플랜과 인덱스 확인</td></tr><tr><td>Predicate/Range Lock</td><td>표준은 현상 정의만, predicate lock 직접 명시 X.</td><td>일부 DBMS 는 범위 락 적용<br>일부는 버전/SSI 로 대응.</td><td>DBMS 문서에서 &lsquo;predicate lock&rsquo;, &lsquo;range/gap lock&rsquo;, &lsquo;serializable 구현 방식 &rsquo; 검색</td></tr><tr><td>락 힌트·관리</td><td>표준은 힌트 규정하지 않음 (구현별 확장).</td><td>SQL Server 등은 힌트 (UPDLOCK, ROWLOCK 등) 제공<br>MySQL 은 힌트 일부 제공.</td><td>힌트 사용 시 DBMS 버전·부작용 (교착, 확장성) 검증</td></tr><tr><td>상호운용성/마이그레이션</td><td>표준은 공통 언어 제공하지만 세부 구현 차이로 완전 호환성 보장하지 않음.</td><td>마이그레이션 시 Lock Mode·격리 매핑·동작 차이로 애플리케이션 레벨 변경 필요.</td><td>마이그레이션 계획에 락 동작 테스트 (테스트 케이스) 를 포함</td></tr></tbody></table><h4 id=46-심화-안티패턴-및-주의사항>4.6 (심화) 안티패턴 및 주의사항<a hidden class=anchor aria-hidden=true href=#46-심화-안티패턴-및-주의사항>#</a></h4><ul><li><p><strong>무엇이 문제인가?</strong>: 잘못된 잠금 사용은 성능 저하·서비스 중단·데드락을 유발.</p></li><li><p><strong>어떤 패턴이 위험한가?</strong>: 광역 락·잠금 순서 불일치·인덱스 없는 범위 스캔·장기 트랜잭션·에스컬레이션 무시는 대표적 위험.</p></li><li><p><strong>간단한 우선순위 해결법</strong>: (1) 트랜잭션을 짧게, (2) 인덱스와 쿼리 최적화, (3) 일관된 락 순서, (4) 배치·파티셔닝·모니터링.</p></li></ul><h5 id=잠금-안티패턴-문제원인해결>잠금 안티패턴: 문제·원인·해결<a hidden class=anchor aria-hidden=true href=#잠금-안티패턴-문제원인해결>#</a></h5><table><thead><tr><th>안티패턴</th><th>문제 (무슨 현상)</th><th style=text-align:right>결과 (운영에 미치는 영향)</th><th>원인</th><th>해결책 (요약)</th><th>예시 (발생)</th><th>해결 적용 예시</th></tr></thead><tbody><tr><td>광역 락 남발</td><td>테이블/DB 전체 잠금 발생</td><td style=text-align:right>전체 서비스 블로킹, 처리량 급감</td><td>범위가 큰 DML(또는 잘못된 힌트)</td><td>세분화 (행잠금), 배치 조정, 파티셔닝</td><td><code>LOCK TABLE</code> 또는 대규모 <code>UPDATE</code></td><td>배치를 작게, 파티셔닝 적용</td></tr><tr><td>잠금 순서 불일치</td><td>교착 (deadlock)</td><td style=text-align:right>트랜잭션 중단·재시도 발생</td><td>서로 다른 순서로 리소스 잠금</td><td>일관된 자원 잠금 순서 적용</td><td>Tx1: UPDATE A then B / Tx2: UPDATE B then A</td><td>모든 트랜잭션에서 ID 오름차순으로 잠금</td></tr><tr><td>Lock Escalation 무시</td><td>수천개 락 → 테이블 락 전환</td><td style=text-align:right>광범위 블로킹</td><td>많은 행락 획득 (임계치 도달)</td><td>배치 크기 제한, ROWLOCK 힌트, 파티셔닝</td><td>대량 UPDATE 가 자동 에스컬레이션</td><td>작은 배치로 나누고 ROWLOCK 사용.</td></tr><tr><td>인덱스 없는 범위 스캔</td><td>넓은 갭/범위 락 발생</td><td style=text-align:right>팬텀·교착·성능 저하</td><td>적절한 인덱스 부재</td><td>적절한 인덱스 생성, 쿼리 리라이팅</td><td><code>SELECT * FROM t WHERE col > X</code> (no index)</td><td>인덱스 추가 또는 범위 축소.</td></tr><tr><td>장기 트랜잭션</td><td>락 장기 보유, 버전 누적</td><td style=text-align:right>GC 지연·디스크 증가·성능 저하</td><td>긴 트랜잭션 (대량 작업을 트랜잭션으로 진행)</td><td>트랜잭션 분할, 타임아웃, 커밋 권장</td><td>대형 배치 트랜잭션이 오랫동안 열려있음</td><td>배치 당 여러 트랜잭션으로 분할·주기적 커밋.</td></tr><tr><td>락 풀/메모리 부족</td><td>락 할당 실패/에스컬레이션</td><td style=text-align:right>서비스 장애·에러</td><td>락 수·메모리 한계 초과</td><td>모니터링, 에스컬레이션 정책 조정, 쿼리 튜닝</td><td>대량 동시 업데이트로 락 급증</td><td>쿼리 개선·메모리 설정·에스컬레이션 튜닝.</td></tr></tbody></table><h5 id=잠금-안티패턴-분류와-대응>잠금 안티패턴 분류와 대응<a hidden class=anchor aria-hidden=true href=#잠금-안티패턴-분류와-대응>#</a></h5><h6 id=운영설정-operational>운영·설정 (Operational)<a hidden class=anchor aria-hidden=true href=#운영설정-operational>#</a></h6><p>운영·설정 문제는 DB 설정 (에스컬레이션 정책, 타임아웃, 락 메모리) 과 운영 관행 (대형 트랜잭션 배치, 모니터링 부재) 에서 기인한다.</p><p><strong>문제 / 결과 / 원인 / 해결책</strong></p><ul><li>문제: 예기치 않은 lock escalation, 오래 걸리는 배치로 전체 서비스 정체.</li><li>결과: 폭넓은 블로킹, 높은 지연, 서비스 장애 가능.</li><li>원인: 기본 에스컬레이션 임계치 초과, 배치 크기·동시성 고려 부족.</li><li>해결책: 배치 분할, 파티셔닝, 에스컬레이션 정책 검토 (예: SQL Server 힌트·옵션), 모니터링·알림 구성.</li></ul><p><strong>예시 (발생)</strong></p><ul><li>대량 UPDATE 한 번에 실행 → 수천 행 락 → 자동 에스컬레이션 → 테이블 락 → 서비스 블록.</li></ul><p><strong>예시 (해결 적용)</strong></p><ul><li>동일 작업을 1000 건 단위 배치로 나누고, 각 배치 후 커밋. 필요 시 파티셔닝을 통해 단일 파티션만 잠기게 설계.</li></ul><table><thead><tr><th>항목</th><th>핵심 조치</th></tr></thead><tbody><tr><td>원인</td><td>큰 배치·임계치 초과</td></tr><tr><td>대응</td><td>배치 분할, 파티셔닝, 에스컬레이션 튜닝</td></tr></tbody></table><ul><li>요약: 운영 설정과 배치 설계가 잘못되면 자동으로 광역 락이 발생하므로 배치·설정·모니터링이 우선이다.</li></ul><h6 id=트랜잭션-설계-transactional>트랜잭션 설계 (Transactional)<a hidden class=anchor aria-hidden=true href=#트랜잭션-설계-transactional>#</a></h6><p>트랜잭션 설계 문제는 트랜잭션 길이·순서·격리 수준 선정에서 비롯된다.</p><p><strong>문제 / 결과 / 원인 / 해결책</strong></p><ul><li>문제: 장기 트랜잭션, 불일치한 락 순서, 과도한 격리 수준 지정.</li><li>결과: 데드락, 긴 락 보유, MVCC 버전 보존 증가.</li><li>원인: 트랜잭션 안에서 대량 처리·유저 상호작용 허용, 개발자가 리소스 획득 순서 통제 안함.</li><li>해결책: 트랜잭션 분할, 일관된 자원 접근 순서 (예: ID 오름차순), 가능한 한 낮은 격리 수준 사용, 타임아웃/재시도 로직 도입.</li></ul><p><strong>예시 (발생)</strong></p><ul><li>Tx1: UPDATE A → UPDATE B; Tx2: UPDATE B → UPDATE A → 둘 다 기다림 → deadlock.</li></ul><p><strong>예시 (해결 적용)</strong></p><ul><li>모든 트랜잭션에서 리소스 접근을 ID 오름차순으로 고정하고, 큰 작업은 여러 트랜잭션으로 쪼갬.</li></ul><table><thead><tr><th>항목</th><th>핵심 조치</th></tr></thead><tbody><tr><td>원인</td><td>긴 트랜잭션·불일치 순서</td></tr><tr><td>대응</td><td>분할·일관된 순서·타임아웃</td></tr></tbody></table><ul><li>트랜잭션을 짧고 예측 가능하게 설계하면 데드락과 GC 부담을 크게 줄일 수 있다.</li></ul><h6 id=쿼리인덱스-queryindex>쿼리·인덱스 (Query/Index)<a hidden class=anchor aria-hidden=true href=#쿼리인덱스-queryindex>#</a></h6><p>쿼리 패턴과 인덱스가 잠금 범위에 직접적 영향을 준다.</p><p><strong>문제 / 결과 / 원인 / 해결책</strong></p><ul><li>문제: 인덱스 없는 범위 스캔 → 넓은 범위/갭 락 → 팬텀·교착·성능 저하.</li><li>결과: 불필요한 락 확장, 응답성 악화.</li><li>원인: WHERE 절에 적절한 인덱스 부재, 비효율 쿼리 작성.</li><li>해결책: 적절한 인덱스 추가, 쿼리 리라이팅 (범위 축소), 필요한 경우 명시적 잠금 (주의).</li></ul><p><strong>예시 (발생)</strong></p><ul><li><code>SELECT * FROM orders WHERE created_at > '2025-01-01'</code> (created_at 에 인덱스 없음) → 전체 인덱스 스캔 → 갭락 확대.</li></ul><p><strong>예시 (해결 적용)</strong></p><ul><li>created_at 에 인덱스 추가 또는 날짜 범위를 더 좁혀서 인덱스 스캔이 가능하도록 쿼리 조정.</li></ul><table><thead><tr><th>항목</th><th>핵심 조치</th></tr></thead><tbody><tr><td>원인</td><td>인덱스 부재·비효율 쿼리</td></tr><tr><td>대응</td><td>인덱스 설계·쿼리 개선</td></tr></tbody></table><ul><li>요약: 인덱스와 쿼리 구조는 잠금 범위를 결정하므로 쿼리 최적화가 근본적 해결책이다.</li></ul><h6 id=시스템자원-resource>시스템·자원 (Resource)<a hidden class=anchor aria-hidden=true href=#시스템자원-resource>#</a></h6><p>락 메모리·락 테이블 등의 시스템 자원 한계와 모니터링 부재에서 오는 문제.</p><p><strong>문제 / 결과 / 원인 / 해결책</strong></p><ul><li>문제: 락 테이블/메모리 한계 초과 → 서비스 에러/에스컬레이션.</li><li>결과: 장애·성능 악화.</li><li>원인: 동시 트랜잭션 급증, 비효율 쿼리.</li><li>해결책: 모니터링 (락 수, 대기 시간), 리소스 한계 조정, 쿼리·배치 튜닝.</li></ul><p><strong>예시 (발생)</strong></p><ul><li>갑작스런 동시 사용자 증가로 락 수 급증 → DB 가 락 메모리 부족 보고.</li></ul><p><strong>예시 (해결 적용)</strong></p><ul><li>모니터링 경보로 원인 쿼리 차단 및 재시도, DB 설정으로 메모리/에스컬레이션 정책 수정.</li></ul><table><thead><tr><th>항목</th><th>핵심 조치</th></tr></thead><tbody><tr><td>원인</td><td>자원 한계·동시성 급증</td></tr><tr><td>대응</td><td>모니터링·리소스 튜닝</td></tr></tbody></table><ul><li>요약: 시스템 레벨 모니터링과 적절한 설정 없이는 작은 문제도 곧 장애로 이어진다.</li></ul><h5 id=잠금-안티패턴-통합-표>잠금 안티패턴 통합 표<a hidden class=anchor aria-hidden=true href=#잠금-안티패턴-통합-표>#</a></h5><table><thead><tr><th>패턴</th><th>근본 원인</th><th style=text-align:right>대표 증상</th><th>즉시조치</th><th>장기적 대책</th></tr></thead><tbody><tr><td>광역 락 남발</td><td>대형 트랜잭션·잘못된 힌트</td><td style=text-align:right>전체 블로킹</td><td>배치 중단/작게 나눔</td><td>파티셔닝·쿼리 재설계</td></tr><tr><td>잠금 순서 불일치</td><td>랜덤한 자원 접근 순서</td><td style=text-align:right>빈번한 deadlock</td><td>트랜잭션 강제 종료 (재시도)</td><td>접근 순서 표준화</td></tr><tr><td>Lock Escalation</td><td>다량 행락 → 임계치 도달</td><td style=text-align:right>갑작스런 테이블 락</td><td>작업 일시중단·배치 재스케줄</td><td>배치 작게·힌트/튜닝</td></tr><tr><td>인덱스 없는 범위 스캔</td><td>인덱스 부재</td><td style=text-align:right>갭 락 확대·팬텀</td><td>쿼리 중단·임시 인덱스</td><td>인덱스 설계·쿼리 최적화</td></tr><tr><td>장기 트랜잭션</td><td>오랜 트랜잭션</td><td style=text-align:right>GC 지연·리소스 축적</td><td>트랜잭션 강제 커밋</td><td>작업 분할·타임아웃 정책</td></tr><tr><td>락 풀 부족</td><td>동시성 폭증</td><td style=text-align:right>락 실패·에러</td><td>일부 트랜잭션 종료</td><td>모니터링·리소스 증설</td></tr></tbody></table><ul><li>즉시 조치는 서비스 복구를 위한 응급처치, 장기적 대책은 설계·운영 관행 개선과 DBMS 설정 최적화로 귀결된다.</li></ul><h4 id=dbms-락-모드-이전업그레이드-전략>DBMS 락 모드 이전·업그레이드 전략<a hidden class=anchor aria-hidden=true href=#dbms-락-모드-이전업그레이드-전략>#</a></h4><p>마이그레이션은 <strong>락의 이름이 같은지 아닌지</strong>보다 <strong>락이 실제로 무엇을 막고 보장하는지</strong>를 맞추는 작업이다.</p><ul><li>먼저 현재 시스템이 어떤 락을 언제 어떻게 얻는지 (실제 트랜잭션 로그·모니터링으로) 확인한다.</li><li>다음으로 대상 DBMS 의 동작과 비교해 &rsquo; 동일한 보호 수준 &rsquo; 을 보장하도록 매핑하고, 단위·부하 테스트로 실제 동작을 확인한다.</li><li>문제가 발견되면 애플리케이션 (트랜잭션 길이 조정, 재시도 로직) 또는 DB 설정 (에스컬레이션 임계값, 타임아웃) 으로 보완한다.</li><li>최종적으로는 단계적 전환 (파일럿→확대) 과 운영 모니터를 통해 안전하게 전환한다.</li></ul><h5 id=마이그레이션-단계별-체크리스트>마이그레이션 단계별 체크리스트<a hidden class=anchor aria-hidden=true href=#마이그레이션-단계별-체크리스트>#</a></h5><table><thead><tr><th>단계</th><th style=text-align:right>주요 작업</th><th>산출물 (Deliverable)</th><th>주요 리스크</th><th>완화책</th></tr></thead><tbody><tr><td>1. 현황 수집 (Discovery)</td><td style=text-align:right>트랜잭션·락 로그 수집, 주요 쿼리 식별</td><td>사용중인 락·격리 목록, 대표 트랜잭션 집합</td><td>누락된 케이스로 인한 미검증</td><td>운영기간 로그 수집, 핵심 트랜잭션 우선순위화</td></tr><tr><td>2. 세멘틱 매핑</td><td style=text-align:right>모드별 의미 문서화 및 대상 DBMS 매핑표 작성</td><td>세멘틱 매핑표 (행동 기준)</td><td>이름 기반 오매핑</td><td>행동 (예: 삽입 방지 여부) 기준 매핑</td></tr><tr><td>3. 단위 테스트</td><td style=text-align:right>데드락·승격·범위 삽입 시나리오 실행</td><td>단위 테스트 결과 리포트</td><td>DB 내부 구현 차이 발견</td><td>테스트 케이스 보강, 애플리케이션 수정안 도출</td></tr><tr><td>4. 부하·호환성 테스트</td><td style=text-align:right>실제 동시성으로 벤치 (스트레스)</td><td>벤치 결과 (처리량·대기·데드락)</td><td>성능 저하·예상외 에스컬레이션</td><td>임계값 튜닝·쿼리/인덱스 최적화</td></tr><tr><td>5. 파일럿/Canary</td><td style=text-align:right>일부 트래픽 전환 (부분 서비스)</td><td>모니터링 대시보드, 문제 리포트</td><td>실서비스 영향</td><td>빠른 롤백 경로·페일오버 정책</td></tr><tr><td>6. 전면 전환</td><td style=text-align:right>전체 트래픽 전환, 모니터링 강화</td><td>전환 완료 리포트</td><td>운영 이슈 확산</td><td>단계별 롤아웃, 긴급 롤백 플랜</td></tr><tr><td>7. 운영·튜닝</td><td style=text-align:right>지속 모니터링, 지표 기반 튜닝</td><td>운영 SOP, 튜닝 파라미터</td><td>장기적 성능 저하</td><td>정기 리뷰, 자동 알람/대응 playbook</td></tr></tbody></table><ul><li><strong>핵심</strong>: 마이그레이션은 " 분석 → 매핑 → 검증 → 파일럿 → 전환 → 모니터링 " 의 순서로 진행해야 실패 확률이 낮다.</li><li><strong>중요 포인트</strong>: 이름 (예: SIX, U) 은 참고용일 뿐이고, 실제로는 <em>그 락이 어떤 동작 (읽기 보호, 삽입 방지, 범위 잠금 등) 을 하는지</em>를 기준으로 대상 DBMS 에서 같은 동작을 보장하도록 매핑해야 한다.</li><li><strong>운영 팁</strong>: 전환 초반엔 락 대기·데드락 빈도를 집중 감시하고, 에스컬레이션 임계값·타임아웃·VACUUM(GC) 같은 DB 고유 파라미터를 조정할 준비를 해 둬야 한다.</li></ul><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-python-과-sqlite-를-활용한-sharedexclusive-lock-체험>실습 예제: Python 과 SQLite 를 활용한 Shared/Exclusive Lock 체험<a hidden class=anchor aria-hidden=true href=#실습-예제-python-과-sqlite-를-활용한-sharedexclusive-lock-체험>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>락 모드의 실시간 동작을 확인하고 병렬 트랜잭션 환경에서 데이터 일관성을 점검</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>Python, sqlite3, threading, time 라이브러리</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>1 단계: 데이터베이스 생성 및 샘플 데이터 삽입</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3>3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4>4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5>5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6>6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sqlite3</span>
</span></span><span class=line><span class=cl><span class=c1># 새로운 메모리 기반 DB 생성</span>
</span></span><span class=line><span class=cl><span class=n>conn</span> <span class=o>=</span> <span class=n>sqlite3</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s1>&#39;:memory:&#39;</span><span class=p>,</span> <span class=n>check_same_thread</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s1>&#39;CREATE TABLE inventory(id INTEGER PRIMARY KEY, stock INTEGER)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s1>&#39;INSERT INTO inventory(id, stock) VALUES(1,100)&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 병렬 트랜잭션 및 Lock 동작 구현</strong></p></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span><span class=lnt id=hl-8-15><a class=lnlinks href=#hl-8-15>15</a>
</span><span class=lnt id=hl-8-16><a class=lnlinks href=#hl-8-16>16</a>
</span><span class=lnt id=hl-8-17><a class=lnlinks href=#hl-8-17>17</a>
</span><span class=lnt id=hl-8-18><a class=lnlinks href=#hl-8-18>18</a>
</span><span class=lnt id=hl-8-19><a class=lnlinks href=#hl-8-19>19</a>
</span><span class=lnt id=hl-8-20><a class=lnlinks href=#hl-8-20>20</a>
</span><span class=lnt id=hl-8-21><a class=lnlinks href=#hl-8-21>21</a>
</span><span class=lnt id=hl-8-22><a class=lnlinks href=#hl-8-22>22</a>
</span><span class=lnt id=hl-8-23><a class=lnlinks href=#hl-8-23>23</a>
</span><span class=lnt id=hl-8-24><a class=lnlinks href=#hl-8-24>24</a>
</span><span class=lnt id=hl-8-25><a class=lnlinks href=#hl-8-25>25</a>
</span><span class=lnt id=hl-8-26><a class=lnlinks href=#hl-8-26>26</a>
</span><span class=lnt id=hl-8-27><a class=lnlinks href=#hl-8-27>27</a>
</span><span class=lnt id=hl-8-28><a class=lnlinks href=#hl-8-28>28</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>shared_read</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>local_conn</span> <span class=o>=</span> <span class=n>sqlite3</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s1>&#39;:memory:&#39;</span><span class=p>,</span> <span class=n>check_same_thread</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=n>local_conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s1>&#39;SELECT stock FROM inventory WHERE id=1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;공유락(Shared Lock): 재고 =&#34;</span><span class=p>,</span> <span class=n>c</span><span class=o>.</span><span class=n>fetchone</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>local_conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>exclusive_write</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>local_conn</span> <span class=o>=</span> <span class=n>sqlite3</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s1>&#39;:memory:&#39;</span><span class=p>,</span> <span class=n>check_same_thread</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=n>local_conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s1>&#39;BEGIN EXCLUSIVE&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s1>&#39;UPDATE inventory SET stock=stock-1 WHERE id=1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;배타락(Exclusive Lock): 재고 차감 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>  <span class=c1># 락 점유 시간 연장</span>
</span></span><span class=line><span class=cl>    <span class=n>local_conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>local_conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>t1</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>exclusive_write</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>t2</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>shared_read</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>t1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 배타락 우선 확보</span>
</span></span><span class=line><span class=cl><span class=n>t2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>t1</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>t2</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>배타 락 (EXCLUSIVE) 동작 시 다른 트랜잭션의 Read(공유락) 대기 발생 여부 확인</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>여러 Thread 에서 동시에 Update, Read 시도 (Deadlock, Dirty Read 탐지)</li></ul><h5 id=실습-예제-lock-mode-호환성-매트릭스-실험>실습 예제: Lock Mode 호환성 매트릭스 실험<a hidden class=anchor aria-hidden=true href=#실습-예제-lock-mode-호환성-매트릭스-실험>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>다양한 Lock Mode 간 호환성 규칙을 실제로 확인</li><li>SIX 락과 같은 고급 모드의 동작 이해</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>1 단계: 호환성 테스트 함수 생성</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>  1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>  2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>  3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>  4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>  5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6>  6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7>  7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8>  8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9>  9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10> 10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11> 11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12> 12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13> 13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14> 14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15> 15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16> 16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17> 17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18> 18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19> 19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20> 20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21> 21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22> 22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23> 23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24> 24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25> 25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26> 26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27> 27</a>
</span><span class=lnt id=hl-9-28><a class=lnlinks href=#hl-9-28> 28</a>
</span><span class=lnt id=hl-9-29><a class=lnlinks href=#hl-9-29> 29</a>
</span><span class=lnt id=hl-9-30><a class=lnlinks href=#hl-9-30> 30</a>
</span><span class=lnt id=hl-9-31><a class=lnlinks href=#hl-9-31> 31</a>
</span><span class=lnt id=hl-9-32><a class=lnlinks href=#hl-9-32> 32</a>
</span><span class=lnt id=hl-9-33><a class=lnlinks href=#hl-9-33> 33</a>
</span><span class=lnt id=hl-9-34><a class=lnlinks href=#hl-9-34> 34</a>
</span><span class=lnt id=hl-9-35><a class=lnlinks href=#hl-9-35> 35</a>
</span><span class=lnt id=hl-9-36><a class=lnlinks href=#hl-9-36> 36</a>
</span><span class=lnt id=hl-9-37><a class=lnlinks href=#hl-9-37> 37</a>
</span><span class=lnt id=hl-9-38><a class=lnlinks href=#hl-9-38> 38</a>
</span><span class=lnt id=hl-9-39><a class=lnlinks href=#hl-9-39> 39</a>
</span><span class=lnt id=hl-9-40><a class=lnlinks href=#hl-9-40> 40</a>
</span><span class=lnt id=hl-9-41><a class=lnlinks href=#hl-9-41> 41</a>
</span><span class=lnt id=hl-9-42><a class=lnlinks href=#hl-9-42> 42</a>
</span><span class=lnt id=hl-9-43><a class=lnlinks href=#hl-9-43> 43</a>
</span><span class=lnt id=hl-9-44><a class=lnlinks href=#hl-9-44> 44</a>
</span><span class=lnt id=hl-9-45><a class=lnlinks href=#hl-9-45> 45</a>
</span><span class=lnt id=hl-9-46><a class=lnlinks href=#hl-9-46> 46</a>
</span><span class=lnt id=hl-9-47><a class=lnlinks href=#hl-9-47> 47</a>
</span><span class=lnt id=hl-9-48><a class=lnlinks href=#hl-9-48> 48</a>
</span><span class=lnt id=hl-9-49><a class=lnlinks href=#hl-9-49> 49</a>
</span><span class=lnt id=hl-9-50><a class=lnlinks href=#hl-9-50> 50</a>
</span><span class=lnt id=hl-9-51><a class=lnlinks href=#hl-9-51> 51</a>
</span><span class=lnt id=hl-9-52><a class=lnlinks href=#hl-9-52> 52</a>
</span><span class=lnt id=hl-9-53><a class=lnlinks href=#hl-9-53> 53</a>
</span><span class=lnt id=hl-9-54><a class=lnlinks href=#hl-9-54> 54</a>
</span><span class=lnt id=hl-9-55><a class=lnlinks href=#hl-9-55> 55</a>
</span><span class=lnt id=hl-9-56><a class=lnlinks href=#hl-9-56> 56</a>
</span><span class=lnt id=hl-9-57><a class=lnlinks href=#hl-9-57> 57</a>
</span><span class=lnt id=hl-9-58><a class=lnlinks href=#hl-9-58> 58</a>
</span><span class=lnt id=hl-9-59><a class=lnlinks href=#hl-9-59> 59</a>
</span><span class=lnt id=hl-9-60><a class=lnlinks href=#hl-9-60> 60</a>
</span><span class=lnt id=hl-9-61><a class=lnlinks href=#hl-9-61> 61</a>
</span><span class=lnt id=hl-9-62><a class=lnlinks href=#hl-9-62> 62</a>
</span><span class=lnt id=hl-9-63><a class=lnlinks href=#hl-9-63> 63</a>
</span><span class=lnt id=hl-9-64><a class=lnlinks href=#hl-9-64> 64</a>
</span><span class=lnt id=hl-9-65><a class=lnlinks href=#hl-9-65> 65</a>
</span><span class=lnt id=hl-9-66><a class=lnlinks href=#hl-9-66> 66</a>
</span><span class=lnt id=hl-9-67><a class=lnlinks href=#hl-9-67> 67</a>
</span><span class=lnt id=hl-9-68><a class=lnlinks href=#hl-9-68> 68</a>
</span><span class=lnt id=hl-9-69><a class=lnlinks href=#hl-9-69> 69</a>
</span><span class=lnt id=hl-9-70><a class=lnlinks href=#hl-9-70> 70</a>
</span><span class=lnt id=hl-9-71><a class=lnlinks href=#hl-9-71> 71</a>
</span><span class=lnt id=hl-9-72><a class=lnlinks href=#hl-9-72> 72</a>
</span><span class=lnt id=hl-9-73><a class=lnlinks href=#hl-9-73> 73</a>
</span><span class=lnt id=hl-9-74><a class=lnlinks href=#hl-9-74> 74</a>
</span><span class=lnt id=hl-9-75><a class=lnlinks href=#hl-9-75> 75</a>
</span><span class=lnt id=hl-9-76><a class=lnlinks href=#hl-9-76> 76</a>
</span><span class=lnt id=hl-9-77><a class=lnlinks href=#hl-9-77> 77</a>
</span><span class=lnt id=hl-9-78><a class=lnlinks href=#hl-9-78> 78</a>
</span><span class=lnt id=hl-9-79><a class=lnlinks href=#hl-9-79> 79</a>
</span><span class=lnt id=hl-9-80><a class=lnlinks href=#hl-9-80> 80</a>
</span><span class=lnt id=hl-9-81><a class=lnlinks href=#hl-9-81> 81</a>
</span><span class=lnt id=hl-9-82><a class=lnlinks href=#hl-9-82> 82</a>
</span><span class=lnt id=hl-9-83><a class=lnlinks href=#hl-9-83> 83</a>
</span><span class=lnt id=hl-9-84><a class=lnlinks href=#hl-9-84> 84</a>
</span><span class=lnt id=hl-9-85><a class=lnlinks href=#hl-9-85> 85</a>
</span><span class=lnt id=hl-9-86><a class=lnlinks href=#hl-9-86> 86</a>
</span><span class=lnt id=hl-9-87><a class=lnlinks href=#hl-9-87> 87</a>
</span><span class=lnt id=hl-9-88><a class=lnlinks href=#hl-9-88> 88</a>
</span><span class=lnt id=hl-9-89><a class=lnlinks href=#hl-9-89> 89</a>
</span><span class=lnt id=hl-9-90><a class=lnlinks href=#hl-9-90> 90</a>
</span><span class=lnt id=hl-9-91><a class=lnlinks href=#hl-9-91> 91</a>
</span><span class=lnt id=hl-9-92><a class=lnlinks href=#hl-9-92> 92</a>
</span><span class=lnt id=hl-9-93><a class=lnlinks href=#hl-9-93> 93</a>
</span><span class=lnt id=hl-9-94><a class=lnlinks href=#hl-9-94> 94</a>
</span><span class=lnt id=hl-9-95><a class=lnlinks href=#hl-9-95> 95</a>
</span><span class=lnt id=hl-9-96><a class=lnlinks href=#hl-9-96> 96</a>
</span><span class=lnt id=hl-9-97><a class=lnlinks href=#hl-9-97> 97</a>
</span><span class=lnt id=hl-9-98><a class=lnlinks href=#hl-9-98> 98</a>
</span><span class=lnt id=hl-9-99><a class=lnlinks href=#hl-9-99> 99</a>
</span><span class=lnt id=hl-9-100><a class=lnlinks href=#hl-9-100>100</a>
</span><span class=lnt id=hl-9-101><a class=lnlinks href=#hl-9-101>101</a>
</span><span class=lnt id=hl-9-102><a class=lnlinks href=#hl-9-102>102</a>
</span><span class=lnt id=hl-9-103><a class=lnlinks href=#hl-9-103>103</a>
</span><span class=lnt id=hl-9-104><a class=lnlinks href=#hl-9-104>104</a>
</span><span class=lnt id=hl-9-105><a class=lnlinks href=#hl-9-105>105</a>
</span><span class=lnt id=hl-9-106><a class=lnlinks href=#hl-9-106>106</a>
</span><span class=lnt id=hl-9-107><a class=lnlinks href=#hl-9-107>107</a>
</span><span class=lnt id=hl-9-108><a class=lnlinks href=#hl-9-108>108</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pyodbc</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>concurrent.futures</span> <span class=kn>import</span> <span class=n>ThreadPoolExecutor</span><span class=p>,</span> <span class=n>as_completed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockCompatibilityTester</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>connection_string</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>connection_string</span> <span class=o>=</span> <span class=n>connection_string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>execute_with_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>sql_command</span><span class=p>,</span> <span class=n>lock_hint</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>,</span> <span class=n>session_name</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;특정 잠금 힌트로 SQL 실행 및 잠금 상태 반환&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span> <span class=o>=</span> <span class=n>pyodbc</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>connection_string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 트랜잭션 시작</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN TRANSACTION&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 잠금이 포함된 SQL 실행</span>
</span></span><span class=line><span class=cl>            <span class=n>full_sql</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;SELECT * FROM LockTestTable WITH (</span><span class=si>{</span><span class=n>lock_hint</span><span class=si>}</span><span class=s2>) WHERE ID = 1&#34;</span>
</span></span><span class=line><span class=cl>            <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>full_sql</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 잠금 정보 조회</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                SELECT request_mode, request_status 
</span></span></span><span class=line><span class=cl><span class=s2>                FROM sys.dm_tran_locks 
</span></span></span><span class=line><span class=cl><span class=s2>                WHERE request_session_id = @@SPID 
</span></span></span><span class=line><span class=cl><span class=s2>                  AND resource_type = &#39;KEY&#39;
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>lock_info</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchall</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>execution_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 5초 대기 (다른 세션과의 상호작용 관찰용)</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;ROLLBACK TRANSACTION&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;session&#39;</span><span class=p>:</span> <span class=n>session_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;lock_hint&#39;</span><span class=p>:</span> <span class=n>lock_hint</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;lock_mode&#39;</span><span class=p>:</span> <span class=n>lock_info</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=k>if</span> <span class=n>lock_info</span> <span class=k>else</span> <span class=s1>&#39;NONE&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;status&#39;</span><span class=p>:</span> <span class=n>lock_info</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>lock_info</span> <span class=k>else</span> <span class=s1>&#39;NONE&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;execution_time&#39;</span><span class=p>:</span> <span class=n>execution_time</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;success&#39;</span><span class=p>:</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;session&#39;</span><span class=p>:</span> <span class=n>session_name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;lock_hint&#39;</span><span class=p>:</span> <span class=n>lock_hint</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;error&#39;</span><span class=p>:</span> <span class=nb>str</span><span class=p>(</span><span class=n>e</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;success&#39;</span><span class=p>:</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_compatibility</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>lock_combinations</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;여러 잠금 조합의 호환성 테스트&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>results</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=n>max_workers</span><span class=o>=</span><span class=nb>len</span><span class=p>(</span><span class=n>lock_combinations</span><span class=p>))</span> <span class=k>as</span> <span class=n>executor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 동시 실행을 위한 Future 객체 생성</span>
</span></span><span class=line><span class=cl>            <span class=n>future_to_lock</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>executor</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>execute_with_lock</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;SELECT&#34;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>lock_combo</span><span class=p>[</span><span class=s1>&#39;hint&#39;</span><span class=p>],</span> 
</span></span><span class=line><span class=cl>                    <span class=n>lock_combo</span><span class=p>[</span><span class=s1>&#39;name&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=p>):</span> <span class=n>lock_combo</span> <span class=k>for</span> <span class=n>lock_combo</span> <span class=ow>in</span> <span class=n>lock_combinations</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 결과 수집</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>future</span> <span class=ow>in</span> <span class=n>as_completed</span><span class=p>(</span><span class=n>future_to_lock</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=n>future</span><span class=o>.</span><span class=n>result</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>results</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>results</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 호환성 테스트 실행</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 연결 문자열 (실제 환경에 맞게 수정)</span>
</span></span><span class=line><span class=cl>    <span class=n>conn_str</span> <span class=o>=</span> <span class=s2>&#34;Driver={SQL Server};Server=localhost;Database=TestDB;Trusted_Connection=yes;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tester</span> <span class=o>=</span> <span class=n>LockCompatibilityTester</span><span class=p>(</span><span class=n>conn_str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 테스트할 잠금 조합</span>
</span></span><span class=line><span class=cl>    <span class=n>test_combinations</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;Session_S&#39;</span><span class=p>,</span> <span class=s1>&#39;hint&#39;</span><span class=p>:</span> <span class=s1>&#39;HOLDLOCK&#39;</span><span class=p>},</span>           <span class=c1># Shared</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;Session_U&#39;</span><span class=p>,</span> <span class=s1>&#39;hint&#39;</span><span class=p>:</span> <span class=s1>&#39;UPDLOCK&#39;</span><span class=p>},</span>           <span class=c1># Update  </span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;Session_X&#39;</span><span class=p>,</span> <span class=s1>&#39;hint&#39;</span><span class=p>:</span> <span class=s1>&#39;XLOCK&#39;</span><span class=p>},</span>             <span class=c1># Exclusive</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span><span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;Session_IS&#39;</span><span class=p>,</span> <span class=s1>&#39;hint&#39;</span><span class=p>:</span> <span class=s1>&#39;HOLDLOCK, TABLOCK&#39;</span><span class=p>}</span> <span class=c1># Intent Shared</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 동시 실행 및 결과 분석</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span> <span class=o>=</span> <span class=n>tester</span><span class=o>.</span><span class=n>test_compatibility</span><span class=p>(</span><span class=n>test_combinations</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 결과 출력</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=== Lock Compatibility Test Results ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>result</span> <span class=ow>in</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>results</span><span class=p>,</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;execution_time&#39;</span><span class=p>,</span> <span class=mi>999</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>result</span><span class=p>[</span><span class=s1>&#39;success&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Session: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;session&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;  Lock Mode: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;lock_mode&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;  Status: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;status&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;  Execution Time: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;execution_time&#39;</span><span class=p>]</span><span class=si>:</span><span class=s2>f</span><span class=si>}</span><span class=s2>s&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Session: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;session&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2> - ERROR: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;error&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 호환성 매트릭스 검증</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 표준 호환성 매트릭스 검증 스크립트
</span></span></span><span class=line><span class=cl><span class=k>WITH</span><span class=w> </span><span class=n>LockCompatibility</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;S&#39;</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Mode1</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;S&#39;</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Mode2</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Compatible&#39;</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=k>Result</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;S&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;X&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Incompatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;S&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;U&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Compatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;X&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;S&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Incompatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;X&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;X&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Incompatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;X&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;U&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Incompatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;U&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;S&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Compatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;U&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;X&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Incompatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UNION</span><span class=w> </span><span class=k>ALL</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=s1>&#39;U&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;U&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Incompatible&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Mode1</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s1>&#39; vs &#39;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Mode2</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Lock_Combination</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>Result</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Expected_Compatibility</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>LockCompatibility</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>Mode1</span><span class=p>,</span><span class=w> </span><span class=n>Mode2</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h5 id=실습-예제-키---레인지-락-관찰-postgresql--mysql>실습 예제: 키 - 레인지 락 관찰 (PostgreSQL & MySQL)<a hidden class=anchor aria-hidden=true href=#실습-예제-키---레인지-락-관찰-postgresql--mysql>#</a></h5><h6 id=목적-2>목적<a hidden class=anchor aria-hidden=true href=#목적-2>#</a></h6><ul><li>격리 수준에 따른 팬텀/블로킹 차이를 체감하고, 인덱스가 Range/GAP 에 미치는 영향을 확인.</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>PostgreSQL 15+ 또는 MySQL 8+</li></ul><h6 id=단계별-구현-2>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-2>#</a></h6><ol><li><p><strong>스키마 준비</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span><span class=lnt id=hl-11-6><a class=lnlinks href=#hl-11-6>6</a>
</span><span class=lnt id=hl-11-7><a class=lnlinks href=#hl-11-7>7</a>
</span><span class=lnt id=hl-11-8><a class=lnlinks href=#hl-11-8>8</a>
</span><span class=lnt id=hl-11-9><a class=lnlinks href=#hl-11-9>9</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>BIGINT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>customer_id</span><span class=w> </span><span class=nb>BIGINT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>amount</span><span class=w> </span><span class=nb>NUMERIC</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>2</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>created_at</span><span class=w> </span><span class=k>TIMESTAMP</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>INDEX</span><span class=w> </span><span class=p>(</span><span class=n>customer_id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>gs</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>gs</span><span class=o>%</span><span class=mi>10</span><span class=p>),</span><span class=w> </span><span class=p>(</span><span class=n>gs</span><span class=o>%</span><span class=mi>100</span><span class=p>)</span><span class=o>+</span><span class=mi>0</span><span class=p>.</span><span class=mi>99</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>FROM</span><span class=w> </span><span class=n>generate_series</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1000</span><span class=p>)</span><span class=w> </span><span class=n>gs</span><span class=p>;</span><span class=w> </span><span class=c1>-- PostgreSQL
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>세션 A (Serializable/Repeatable Read)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- PostgreSQL
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>SERIALIZABLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>customer_id</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w> </span><span class=c1>-- Predicate 잠금
</span></span></span><span class=line><span class=cl><span class=c1>-- 세션 A는 커밋 전까지 유지
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>세션 B (동시 변경 시도)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 범위를 바꾸는 INSERT/UPDATE
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>2001</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>,</span><span class=w> </span><span class=mi>10</span><span class=p>.</span><span class=mi>00</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=p>());</span><span class=w> </span><span class=c1>-- 세션 A에 의해 차단될 수 있음
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>관찰</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- PostgreSQL: predicate lock 확인
</span></span></span><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>pg_locks</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>locktype</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%predicate%&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>-- MySQL: Next-Key/GAP 잠금은 information_schema/performance_schema로 관찰
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><ul><li>Serializable/Repeatable Read 에서 세션 B 가 <strong>대기</strong> 또는 <strong>충돌</strong>.</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>인덱스 제거 후 범위 질의 → Range/GAP 범위 확대 및 대기 증가.</li></ul><h4 id=실제-도입-사례-분석>실제 도입 사례 분석<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-분석>#</a></h4><h5 id=실제-도입-사례-stack-overflow-데이터베이스-최적화>실제 도입 사례: Stack Overflow 데이터베이스 최적화<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-stack-overflow-데이터베이스-최적화>#</a></h5><h6 id=배경-및-도입-이유>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유>#</a></h6><p>Stack Overflow 는 수백만 명의 사용자가 동시 접근하는 Q&amp;A 플랫폼으로, 높은 동시성과 데이터 일관성이 핵심 요구사항이었다.</p><p>기존의 단순한 테이블 수준 잠금으로는 다음 문제가 발생했다:</p><ul><li><strong>동시성 병목</strong>: 답변 작성 시 전체 질문 테이블 잠금</li><li><strong>데드락 빈발</strong>: 투표와 댓글 작성의 순환 대기</li><li><strong>성능 저하</strong>: 대용량 검색 쿼리가 전체 시스템 블로킹</li></ul><p><strong>해결 목표</strong>: 동시 사용자 10 배 증가 대응, 응답 시간 50% 단축</p><h6 id=구현-아키텍처>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처>#</a></h6><pre class=mermaid>graph TB
    subgraph &#34;Before: Table-level Locking&#34;
        A1[Question Table] --&gt; A2[Full Table Lock]
        A3[Answer Insert] --&gt; A2
        A4[Vote Update] --&gt; A2
        A5[Search Query] --&gt; A2
    end
    
    subgraph &#34;After: Hierarchical Lock Modes&#34;
        B1[Question Table] --&gt; B2[IS/IX Intent Locks]
        B3[Row-level S/X Locks] --&gt; B2
        B4[Answer Insert] --&gt; B5[IX → X conversion]
        B6[Vote Update] --&gt; B7[U → X conversion]
        B8[Search Query] --&gt; B9[S locks only]
    end
    
    A1 -.upgrade.-&gt; B1
</pre><p><strong>핵심 설계 결정</strong>:</p><ol><li><strong>Question 테이블</strong>: SIX 락으로 대량 읽기 + 선택적 수정</li><li><strong>Answer 테이블</strong>: 행 단위 IX/X 락으로 최대 동시성</li><li><strong>Vote 테이블</strong>: Update 락으로 데드락 방지</li></ol><h6 id=핵심-구현-코드>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span><span class=lnt id=hl-16-22><a class=lnlinks href=#hl-16-22>22</a>
</span><span class=lnt id=hl-16-23><a class=lnlinks href=#hl-16-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 질문 조회 시 SIX 락 활용 (대량 읽기 + 조회수 증가)
</span></span></span><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>GetQuestionWithViewUpdate</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>@</span><span class=n>QuestionId</span><span class=w> </span><span class=nb>INT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>AS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>BEGIN</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- SIX 락으로 전체 질문 데이터 읽기 보호 + 특정 행 수정 의도 표시
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>q</span><span class=p>.</span><span class=n>Title</span><span class=p>,</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=n>Body</span><span class=p>,</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=n>ViewCount</span><span class=p>,</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=n>Score</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>u</span><span class=p>.</span><span class=n>DisplayName</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>AuthorName</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>Questions</span><span class=w> </span><span class=n>q</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>SIX</span><span class=p>,</span><span class=w> </span><span class=n>HOLDLOCK</span><span class=p>)</span><span class=w>  </span><span class=c1>-- 읽기 성능 + 수정 가능성
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>Users</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>NOLOCK</span><span class=p>)</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=n>UserId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>u</span><span class=p>.</span><span class=n>Id</span><span class=w>  </span><span class=c1>-- 사용자는 읽기만
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>q</span><span class=p>.</span><span class=n>Id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>@</span><span class=n>QuestionId</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 조회수 업데이트 (X 락 자동 변환)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UPDATE</span><span class=w> </span><span class=n>Questions</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SET</span><span class=w> </span><span class=n>ViewCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ViewCount</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>LastActivityDate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GETUTCDATE</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>Id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>@</span><span class=n>QuestionId</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>COMMIT</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>END</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span><span class=lnt id=hl-17-26><a class=lnlinks href=#hl-17-26>26</a>
</span><span class=lnt id=hl-17-27><a class=lnlinks href=#hl-17-27>27</a>
</span><span class=lnt id=hl-17-28><a class=lnlinks href=#hl-17-28>28</a>
</span><span class=lnt id=hl-17-29><a class=lnlinks href=#hl-17-29>29</a>
</span><span class=lnt id=hl-17-30><a class=lnlinks href=#hl-17-30>30</a>
</span><span class=lnt id=hl-17-31><a class=lnlinks href=#hl-17-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 답변 작성 시 계층적 잠금 최적화
</span></span></span><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>CreateAnswer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>@</span><span class=n>QuestionId</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>@</span><span class=n>UserId</span><span class=w> </span><span class=nb>INT</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>@</span><span class=n>Body</span><span class=w> </span><span class=n>NVARCHAR</span><span class=p>(</span><span class=k>MAX</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>AS</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>BEGIN</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 질문 존재 확인 (S 락)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>IF</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>EXISTS</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>SELECT</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>Questions</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>HOLDLOCK</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>WHERE</span><span class=w> </span><span class=n>Id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>@</span><span class=n>QuestionId</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>ClosedDate</span><span class=w> </span><span class=k>IS</span><span class=w> </span><span class=k>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>THROW</span><span class=w> </span><span class=mi>50001</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;Question not found or closed&#39;</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>END</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 답변 삽입 (행 단위 X 락)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>Answers</span><span class=w> </span><span class=p>(</span><span class=n>QuestionId</span><span class=p>,</span><span class=w> </span><span class=n>UserId</span><span class=p>,</span><span class=w> </span><span class=n>Body</span><span class=p>,</span><span class=w> </span><span class=n>CreationDate</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=o>@</span><span class=n>QuestionId</span><span class=p>,</span><span class=w> </span><span class=o>@</span><span class=n>UserId</span><span class=p>,</span><span class=w> </span><span class=o>@</span><span class=n>Body</span><span class=p>,</span><span class=w> </span><span class=n>GETUTCDATE</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 질문 메타데이터 업데이트 (U → X 락 변환으로 데드락 방지)
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>UPDATE</span><span class=w> </span><span class=n>Questions</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=p>(</span><span class=n>UPDLOCK</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SET</span><span class=w> </span><span class=n>AnswerCount</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>AnswerCount</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>LastActivityDate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GETUTCDATE</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>WHERE</span><span class=w> </span><span class=n>Id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>@</span><span class=n>QuestionId</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>COMMIT</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>END</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>  1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>  2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>  3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>  4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>  5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6>  6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7>  7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8>  8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9>  9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10> 10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11> 11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12> 12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13> 13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14> 14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15> 15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16> 16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17> 17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18> 18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19> 19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20> 20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21> 21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22> 22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23> 23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24> 24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25> 25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26> 26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27> 27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28> 28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29> 29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30> 30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31> 31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32> 32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33> 33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34> 34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35> 35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36> 36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37> 37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38> 38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39> 39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40> 40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41> 41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42> 42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43> 43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44> 44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45> 45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46> 46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47> 47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48> 48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49> 49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50> 50</a>
</span><span class=lnt id=hl-18-51><a class=lnlinks href=#hl-18-51> 51</a>
</span><span class=lnt id=hl-18-52><a class=lnlinks href=#hl-18-52> 52</a>
</span><span class=lnt id=hl-18-53><a class=lnlinks href=#hl-18-53> 53</a>
</span><span class=lnt id=hl-18-54><a class=lnlinks href=#hl-18-54> 54</a>
</span><span class=lnt id=hl-18-55><a class=lnlinks href=#hl-18-55> 55</a>
</span><span class=lnt id=hl-18-56><a class=lnlinks href=#hl-18-56> 56</a>
</span><span class=lnt id=hl-18-57><a class=lnlinks href=#hl-18-57> 57</a>
</span><span class=lnt id=hl-18-58><a class=lnlinks href=#hl-18-58> 58</a>
</span><span class=lnt id=hl-18-59><a class=lnlinks href=#hl-18-59> 59</a>
</span><span class=lnt id=hl-18-60><a class=lnlinks href=#hl-18-60> 60</a>
</span><span class=lnt id=hl-18-61><a class=lnlinks href=#hl-18-61> 61</a>
</span><span class=lnt id=hl-18-62><a class=lnlinks href=#hl-18-62> 62</a>
</span><span class=lnt id=hl-18-63><a class=lnlinks href=#hl-18-63> 63</a>
</span><span class=lnt id=hl-18-64><a class=lnlinks href=#hl-18-64> 64</a>
</span><span class=lnt id=hl-18-65><a class=lnlinks href=#hl-18-65> 65</a>
</span><span class=lnt id=hl-18-66><a class=lnlinks href=#hl-18-66> 66</a>
</span><span class=lnt id=hl-18-67><a class=lnlinks href=#hl-18-67> 67</a>
</span><span class=lnt id=hl-18-68><a class=lnlinks href=#hl-18-68> 68</a>
</span><span class=lnt id=hl-18-69><a class=lnlinks href=#hl-18-69> 69</a>
</span><span class=lnt id=hl-18-70><a class=lnlinks href=#hl-18-70> 70</a>
</span><span class=lnt id=hl-18-71><a class=lnlinks href=#hl-18-71> 71</a>
</span><span class=lnt id=hl-18-72><a class=lnlinks href=#hl-18-72> 72</a>
</span><span class=lnt id=hl-18-73><a class=lnlinks href=#hl-18-73> 73</a>
</span><span class=lnt id=hl-18-74><a class=lnlinks href=#hl-18-74> 74</a>
</span><span class=lnt id=hl-18-75><a class=lnlinks href=#hl-18-75> 75</a>
</span><span class=lnt id=hl-18-76><a class=lnlinks href=#hl-18-76> 76</a>
</span><span class=lnt id=hl-18-77><a class=lnlinks href=#hl-18-77> 77</a>
</span><span class=lnt id=hl-18-78><a class=lnlinks href=#hl-18-78> 78</a>
</span><span class=lnt id=hl-18-79><a class=lnlinks href=#hl-18-79> 79</a>
</span><span class=lnt id=hl-18-80><a class=lnlinks href=#hl-18-80> 80</a>
</span><span class=lnt id=hl-18-81><a class=lnlinks href=#hl-18-81> 81</a>
</span><span class=lnt id=hl-18-82><a class=lnlinks href=#hl-18-82> 82</a>
</span><span class=lnt id=hl-18-83><a class=lnlinks href=#hl-18-83> 83</a>
</span><span class=lnt id=hl-18-84><a class=lnlinks href=#hl-18-84> 84</a>
</span><span class=lnt id=hl-18-85><a class=lnlinks href=#hl-18-85> 85</a>
</span><span class=lnt id=hl-18-86><a class=lnlinks href=#hl-18-86> 86</a>
</span><span class=lnt id=hl-18-87><a class=lnlinks href=#hl-18-87> 87</a>
</span><span class=lnt id=hl-18-88><a class=lnlinks href=#hl-18-88> 88</a>
</span><span class=lnt id=hl-18-89><a class=lnlinks href=#hl-18-89> 89</a>
</span><span class=lnt id=hl-18-90><a class=lnlinks href=#hl-18-90> 90</a>
</span><span class=lnt id=hl-18-91><a class=lnlinks href=#hl-18-91> 91</a>
</span><span class=lnt id=hl-18-92><a class=lnlinks href=#hl-18-92> 92</a>
</span><span class=lnt id=hl-18-93><a class=lnlinks href=#hl-18-93> 93</a>
</span><span class=lnt id=hl-18-94><a class=lnlinks href=#hl-18-94> 94</a>
</span><span class=lnt id=hl-18-95><a class=lnlinks href=#hl-18-95> 95</a>
</span><span class=lnt id=hl-18-96><a class=lnlinks href=#hl-18-96> 96</a>
</span><span class=lnt id=hl-18-97><a class=lnlinks href=#hl-18-97> 97</a>
</span><span class=lnt id=hl-18-98><a class=lnlinks href=#hl-18-98> 98</a>
</span><span class=lnt id=hl-18-99><a class=lnlinks href=#hl-18-99> 99</a>
</span><span class=lnt id=hl-18-100><a class=lnlinks href=#hl-18-100>100</a>
</span><span class=lnt id=hl-18-101><a class=lnlinks href=#hl-18-101>101</a>
</span><span class=lnt id=hl-18-102><a class=lnlinks href=#hl-18-102>102</a>
</span><span class=lnt id=hl-18-103><a class=lnlinks href=#hl-18-103>103</a>
</span><span class=lnt id=hl-18-104><a class=lnlinks href=#hl-18-104>104</a>
</span><span class=lnt id=hl-18-105><a class=lnlinks href=#hl-18-105>105</a>
</span><span class=lnt id=hl-18-106><a class=lnlinks href=#hl-18-106>106</a>
</span><span class=lnt id=hl-18-107><a class=lnlinks href=#hl-18-107>107</a>
</span><span class=lnt id=hl-18-108><a class=lnlinks href=#hl-18-108>108</a>
</span><span class=lnt id=hl-18-109><a class=lnlinks href=#hl-18-109>109</a>
</span><span class=lnt id=hl-18-110><a class=lnlinks href=#hl-18-110>110</a>
</span><span class=lnt id=hl-18-111><a class=lnlinks href=#hl-18-111>111</a>
</span><span class=lnt id=hl-18-112><a class=lnlinks href=#hl-18-112>112</a>
</span><span class=lnt id=hl-18-113><a class=lnlinks href=#hl-18-113>113</a>
</span><span class=lnt id=hl-18-114><a class=lnlinks href=#hl-18-114>114</a>
</span><span class=lnt id=hl-18-115><a class=lnlinks href=#hl-18-115>115</a>
</span><span class=lnt id=hl-18-116><a class=lnlinks href=#hl-18-116>116</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 애플리케이션 레벨 잠금 최적화 (Python/SQLAlchemy)</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sqlalchemy</span> <span class=kn>import</span> <span class=n>create_engine</span><span class=p>,</span> <span class=n>text</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sqlalchemy.orm</span> <span class=kn>import</span> <span class=n>sessionmaker</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>logging</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>StackOverflowLockOptimizer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>db_connection_string</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>engine</span> <span class=o>=</span> <span class=n>create_engine</span><span class=p>(</span><span class=n>db_connection_string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>Session</span> <span class=o>=</span> <span class=n>sessionmaker</span><span class=p>(</span><span class=n>bind</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>engine</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>vote_on_post</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>post_id</span><span class=p>,</span> <span class=n>user_id</span><span class=p>,</span> <span class=n>vote_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        투표 처리 with Update Lock을 활용한 데드락 방지
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>session</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>Session</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>begin</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 1. 기존 투표 확인 (U 락으로 데드락 방지)</span>
</span></span><span class=line><span class=cl>            <span class=n>existing_vote</span> <span class=o>=</span> <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                SELECT VoteTypeId FROM Votes WITH (UPDLOCK)
</span></span></span><span class=line><span class=cl><span class=s2>                WHERE PostId = :post_id AND UserId = :user_id
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span><span class=p>),</span> <span class=p>{</span><span class=s2>&#34;post_id&#34;</span><span class=p>:</span> <span class=n>post_id</span><span class=p>,</span> <span class=s2>&#34;user_id&#34;</span><span class=p>:</span> <span class=n>user_id</span><span class=p>})</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 2. 투표 처리 로직</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>existing_vote</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>existing_vote</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>vote_type</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 투표 변경 (U → X 락 자동 변환)</span>
</span></span><span class=line><span class=cl>                    <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                        UPDATE Votes SET VoteTypeId = :vote_type
</span></span></span><span class=line><span class=cl><span class=s2>                        WHERE PostId = :post_id AND UserId = :user_id
</span></span></span><span class=line><span class=cl><span class=s2>                    &#34;&#34;&#34;</span><span class=p>),</span> <span class=p>{</span><span class=s2>&#34;vote_type&#34;</span><span class=p>:</span> <span class=n>vote_type</span><span class=p>,</span> <span class=s2>&#34;post_id&#34;</span><span class=p>:</span> <span class=n>post_id</span><span class=p>,</span> <span class=s2>&#34;user_id&#34;</span><span class=p>:</span> <span class=n>user_id</span><span class=p>})</span>
</span></span><span class=line><span class=cl>                    <span class=n>score_delta</span> <span class=o>=</span> <span class=mi>2</span> <span class=k>if</span> <span class=n>vote_type</span> <span class=o>==</span> <span class=mi>1</span> <span class=k>else</span> <span class=o>-</span><span class=mi>2</span>  <span class=c1># 업보트 ↔ 다운보트</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 투표 취소</span>
</span></span><span class=line><span class=cl>                    <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                        DELETE FROM Votes 
</span></span></span><span class=line><span class=cl><span class=s2>                        WHERE PostId = :post_id AND UserId = :user_id
</span></span></span><span class=line><span class=cl><span class=s2>                    &#34;&#34;&#34;</span><span class=p>),</span> <span class=p>{</span><span class=s2>&#34;post_id&#34;</span><span class=p>:</span> <span class=n>post_id</span><span class=p>,</span> <span class=s2>&#34;user_id&#34;</span><span class=p>:</span> <span class=n>user_id</span><span class=p>})</span>
</span></span><span class=line><span class=cl>                    <span class=n>score_delta</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span> <span class=k>if</span> <span class=n>vote_type</span> <span class=o>==</span> <span class=mi>1</span> <span class=k>else</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 새 투표 생성</span>
</span></span><span class=line><span class=cl>                <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                    INSERT INTO Votes (PostId, UserId, VoteTypeId, CreationDate)
</span></span></span><span class=line><span class=cl><span class=s2>                    VALUES (:post_id, :user_id, :vote_type, GETUTCDATE())
</span></span></span><span class=line><span class=cl><span class=s2>                &#34;&#34;&#34;</span><span class=p>),</span> <span class=p>{</span><span class=s2>&#34;post_id&#34;</span><span class=p>:</span> <span class=n>post_id</span><span class=p>,</span> <span class=s2>&#34;user_id&#34;</span><span class=p>:</span> <span class=n>user_id</span><span class=p>,</span> <span class=s2>&#34;vote_type&#34;</span><span class=p>:</span> <span class=n>vote_type</span><span class=p>})</span>
</span></span><span class=line><span class=cl>                <span class=n>score_delta</span> <span class=o>=</span> <span class=mi>1</span> <span class=k>if</span> <span class=n>vote_type</span> <span class=o>==</span> <span class=mi>1</span> <span class=k>else</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 3. 게시물 점수 업데이트 (별도 리소스로 데드락 회피)</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                UPDATE Posts WITH (ROWLOCK)
</span></span></span><span class=line><span class=cl><span class=s2>                SET Score = Score + :delta,
</span></span></span><span class=line><span class=cl><span class=s2>                    LastActivityDate = GETUTCDATE()
</span></span></span><span class=line><span class=cl><span class=s2>                WHERE Id = :post_id
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span><span class=p>),</span> <span class=p>{</span><span class=s2>&#34;delta&#34;</span><span class=p>:</span> <span class=n>score_delta</span><span class=p>,</span> <span class=s2>&#34;post_id&#34;</span><span class=p>:</span> <span class=n>post_id</span><span class=p>})</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>info</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Vote processed: Post </span><span class=si>{</span><span class=n>post_id</span><span class=si>}</span><span class=s2>, User </span><span class=si>{</span><span class=n>user_id</span><span class=si>}</span><span class=s2>, Type </span><span class=si>{</span><span class=n>vote_type</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>logging</span><span class=o>.</span><span class=n>error</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Vote processing failed: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span>
</span></span><span class=line><span class=cl>        <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bulk_content_update</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tag_id</span><span class=p>,</span> <span class=n>new_description</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        대량 콘텐츠 업데이트 시 Lock Escalation 제어
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>session</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>Session</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Lock Escalation 방지를 위한 배치 처리</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;ALTER TABLE Posts SET (LOCK_ESCALATION = DISABLE)&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>batch_size</span> <span class=o>=</span> <span class=mi>1000</span>
</span></span><span class=line><span class=cl>            <span class=n>offset</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 배치 단위로 처리하여 메모리 부담 감소</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                    UPDATE TOP (:batch_size) Posts WITH (ROWLOCK)
</span></span></span><span class=line><span class=cl><span class=s2>                    SET Body = REPLACE(Body, :old_text, :new_text),
</span></span></span><span class=line><span class=cl><span class=s2>                        LastEditDate = GETUTCDATE()
</span></span></span><span class=line><span class=cl><span class=s2>                    WHERE Id IN (
</span></span></span><span class=line><span class=cl><span class=s2>                        SELECT TOP (:batch_size) p.Id 
</span></span></span><span class=line><span class=cl><span class=s2>                        FROM Posts p
</span></span></span><span class=line><span class=cl><span class=s2>                        INNER JOIN PostTags pt ON p.Id = pt.PostId
</span></span></span><span class=line><span class=cl><span class=s2>                        WHERE pt.TagId = :tag_id 
</span></span></span><span class=line><span class=cl><span class=s2>                          AND p.Body LIKE &#39;%&#39; + :old_text + &#39;%&#39;
</span></span></span><span class=line><span class=cl><span class=s2>                        ORDER BY p.Id
</span></span></span><span class=line><span class=cl><span class=s2>                        OFFSET :offset ROWS
</span></span></span><span class=line><span class=cl><span class=s2>                    )
</span></span></span><span class=line><span class=cl><span class=s2>                &#34;&#34;&#34;</span><span class=p>),</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;batch_size&#34;</span><span class=p>:</span> <span class=n>batch_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;tag_id&#34;</span><span class=p>:</span> <span class=n>tag_id</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;old_text&#34;</span><span class=p>:</span> <span class=s2>&#34;deprecated_syntax&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;new_text&#34;</span><span class=p>:</span> <span class=n>new_description</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;offset&#34;</span><span class=p>:</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>                <span class=p>})</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>result</span><span class=o>.</span><span class=n>rowcount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                <span class=n>offset</span> <span class=o>+=</span> <span class=n>batch_size</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 중간 커밋으로 잠금 해제</span>
</span></span><span class=line><span class=cl>                <span class=n>session</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>text</span><span class=p>(</span><span class=s2>&#34;ALTER TABLE Posts SET (LOCK_ESCALATION = AUTO)&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span>
</span></span><span class=line><span class=cl>        <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>session</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과>#</a></h6><p><strong>정량적 성과</strong>:</p><ul><li><strong>동시 접속 처리량</strong>: 50,000 → 500,000 동시 사용자 (10 배 증가)</li><li><strong>평균 응답 시간</strong>: 850ms → 420ms (51% 단축)</li><li><strong>데드락 발생률</strong>: 일 평균 150 건 → 15 건 (90% 감소)</li><li><strong>Lock 관련 대기 시간</strong>: 전체 쿼리 시간의 15% → 3% (80% 감소)</li></ul><p><strong>정성적 개선</strong>:</p><ul><li><strong>사용자 경험</strong>: 답변 작성 중 다른 사용자의 질문 조회 차단 해소</li><li><strong>운영 안정성</strong>: 피크 시간대 시스템 블로킹 현상 근절</li><li><strong>확장성</strong>: 트래픽 증가에 따른 선형적 성능 확장 가능</li></ul><h6 id=교훈-및-시사점>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점>#</a></h6><p><strong>재현 시 유의점</strong>:</p><ol><li><strong>점진적 적용</strong>: 전체 시스템 한번에 변경하지 말고 핵심 테이블부터 단계적 적용</li><li><strong>모니터링 강화</strong>: <code>sys.dm_tran_locks</code>, <code>sys.dm_os_wait_stats</code> 지속 관찰 필요</li><li><strong>테스트 환경</strong>: 프로덕션과 동일한 부하 조건에서 성능 테스트 필수</li></ol><p><strong>대안 접근법</strong>:</p><ul><li><strong>MVCC 도입</strong>: PostgreSQL 스타일의 다중 버전 동시성 제어</li><li><strong>읽기 전용 복제본</strong>: 조회 트래픽 분산으로 쓰기 잠금 부담 감소</li><li><strong>캐싱 계층</strong>: Redis 를 활용한 자주 조회되는 데이터의 DB 접근 최소화</li></ul><p><strong>확장 아이디어</strong>:</p><ul><li><strong>머신러닝 기반 Lock Mode 선택</strong>: 쿼리 패턴 분석으로 최적 잠금 모드 자동 추천</li><li><strong>분산 잠금</strong>: 마이크로서비스 환경에서 서비스 간 분산 잠금 메커니즘 구현</li></ul><h4 id=동시성-제어-통합-기술-아키텍처>동시성 제어 통합 기술 아키텍처<a hidden class=anchor aria-hidden=true href=#동시성-제어-통합-기술-아키텍처>#</a></h4><ul><li><strong>핵심 아이디어</strong>: 락은 &rsquo; 누가 지금 쓰는가 &rsquo; 를 통제한다. 하지만 락만으로 모든 문제 (성능·확장성) 를 해결하긴 어렵다. 그래서 <strong>버전 (스냅샷), 애플리케이션 레벨 낙관적 검사, 분산 코디네이션, 메시지 기반 분해</strong> 같은 기술을 조합한다.</li><li><strong>결론 비유</strong>: 락은 &rsquo; 문을 잠그는 열쇠 &lsquo;, MVCC 는 &rsquo; 방 안에 과거 사진을 두는 것 &lsquo;, 낙관적 잠금은 &rsquo; 먼저 들어가서 작업하고 퇴실 시 확인 &lsquo;, 분산 락은 &rsquo; 건물 전체의 출입통제 시스템 &rsquo; 이다. 상황에 맞는 조합이 핵심이다.</li></ul><h5 id=왜-통합하는가>왜 통합하는가<a hidden class=anchor aria-hidden=true href=#왜-통합하는가>#</a></h5><ul><li><strong>단일 기법만으로는 트레이드오프를 완전 해소할 수 없음</strong>: 락은 일관성에 강하나 성능·확장성에서 불리, MVCC 는 읽기 성능에 유리하나 일부 직렬화 이상은 검출·해결 필요. 따라서 서로 장단점을 보완하기 위해 통합한다.</li></ul><h5 id=무엇을-통합하는가>무엇을 통합하는가<a hidden class=anchor aria-hidden=true href=#무엇을-통합하는가>#</a></h5><ul><li><strong>MVCC + Lock Modes</strong>: 읽기는 버전으로, 쓰기는 필요 시 락으로 보강.</li><li><strong>Optimistic Locking + DB Lock</strong>: 애플리케이션 레벨 버전 체크로 대부분 케이스를 낙관 처리, 충돌 시 DB 락/재시도.</li><li><strong>Snapshot Isolation (row-versioning)</strong>: 읽기 격리 확보 (READ_COMMITTED_SNAPSHOT), 락 경쟁 감소.</li><li><strong>분산 Lock + Local Lock</strong>: 노드간 글로벌 코디네이션 (ZooKeeper/etcd/Redis) + 노드 내부의 세밀한 DB 락.</li><li><strong>Messaging / Saga / CQRS</strong>: 긴 단위 트랜잭션을 이벤트로 분해해 로컬 ACID + 보상으로 처리.</li></ul><h5 id=어떻게-통합하는가>어떻게 통합하는가<a hidden class=anchor aria-hidden=true href=#어떻게-통합하는가>#</a></h5><ul><li><strong>계층적 결합</strong>: 애플리케이션 (optimistic/versioning) → DB(MVCC + selective locks) → 인프라 (distributed lock/fencing) → 아키텍처 (messaging/saga) 식으로 역할 분담.</li></ul><h5 id=얻는-가치>얻는 가치<a hidden class=anchor aria-hidden=true href=#얻는-가치>#</a></h5><ol><li><strong>성능 극대화</strong>: 읽기 -heavy 워크로드는 MVCC/스냅샷으로 락 경합 감소.</li><li><strong>일관성/무결성 유지</strong>: 필요한 지점에서만 강한 락 또는 분산 코디네이션을 사용해 데이터 무결성 확보.</li><li><strong>확장성/가용성</strong>: 글로벌 락을 최소화하고 로컬 트랜잭션을 우선시하면 노드 수를 늘려도 확장성 확보.</li><li><strong>운영 유연성</strong>: 워크로드 특성에 따라 동적 조합 (예: read-heavy → snapshot on; write-heavy → pessimistic where needed).</li></ol><h5 id=lock-modes-연계-기술-통합-요약>Lock Modes 연계 기술 통합 요약<a hidden class=anchor aria-hidden=true href=#lock-modes-연계-기술-통합-요약>#</a></h5><table><thead><tr><th style=text-align:right>결합 기술</th><th>주된 역할</th><th>통합 방식 (실무)</th><th>기대 효과</th></tr></thead><tbody><tr><td style=text-align:right>MVCC (Postgres 등)</td><td>읽기 경합 완화</td><td>읽기는 스냅샷, 쓰기는 필요 시 락 보강</td><td>읽기 처리량 증가, 읽기→쓰기 충돌 감소.</td></tr><tr><td style=text-align:right>Optimistic Locking</td><td>애플리케이션 수준 충돌 감지</td><td>버전 필드 (CAS) + 실패 시 재시도/보정</td><td>락 오버헤드 감소, 낮은 충돌 워크로드에 유리.</td></tr><tr><td style=text-align:right>Snapshot Isolation</td><td>버전 기반 읽기 일관성</td><td>READ_COMMITTED_SNAPSHOT 등 설정</td><td>읽기 락 경쟁 제거 (옵션기반).</td></tr><tr><td style=text-align:right>Distributed Locking</td><td>노드 간 상호배제</td><td>ZooKeeper/etcd (강일관) or Redis(경량) + fencing</td><td>글로벌 일관성 보장, 장애 시 안전성 확보.</td></tr><tr><td style=text-align:right>Messaging / Saga / CQRS</td><td>장기 트랜잭션 분해</td><td>이벤트·명령 기반 로컬 트랜잭션 + 보상</td><td>장기 락 회피, 복잡한 분산 트랜잭션 처리.</td></tr></tbody></table><p>위 표는 실무에서 흔히 쓰이는 결합 패턴과 기대 효과를 요약한다. 각 결합은 <strong>워크로드 특성</strong>(읽기/쓰기 비율, 트랜잭션 길이, 분산 정도) 에 따라 선택/조정해야 한다.</p><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><ul><li><p><strong>핵심 기능</strong><br>락 모드는 동시 접근을 제어해 일관성을 보장하는 기본 수단이다. S 는 읽기 공유, X 는 배타적 갱신, U 는 읽은 후 갱신할 가능성이 있는 경우 데드락을 줄이기 위한 중간 모드다. Intent 는 계층적 리소스 (테이블→페이지→행) 에서 하위 락 존재를 빠르게 알려주는 시그널 역할을 한다.</p></li><li><p><strong>범위·팬텀 제어</strong><br>인덱스 스캔이나 범위 쿼리에서는 단순 행 락으로 팬텀이 제어되지 않으므로 gap/next-key/predicate 같은 범위 락 또는 SSI(직렬화 스냅샷 검사) 같은 대체 기법이 필요하다. 구현 방식에 따라 성능과 복잡성이 달라진다.</p></li><li><p><strong>대안 및 혼용</strong><br>MVCC 는 읽기와 쓰기 간 충돌을 줄여 고동시성을 제공하지만 버전 관리·GC 비용이 생긴다. 낙관적 (충돌 후 재시도) 과 비관적 (락에 의한 직권) 방식은 워크로드 특성에 따라 선택하거나 혼합해서 쓴다.</p></li><li><p><strong>운영·모니터링</strong><br>실무에서는 데드락 빈도, 평균 락 대기시간, 락 확대 이벤트, lock table 사용률 등을 모니터링한다. 문제 발견 시 트랜잭션 분해, 쿼리·인덱스 개선, 파티셔닝, MVCC 전환 등을 계획한다.</p></li><li><p><strong>표준 vs 구현</strong><br>ANSI/ISO 는 격리 수준의 기대 동작 (예: SERIALIZABLE 은 팬텀 방지) 을 규정하지만 실제로 이를 달성하기 위한 메커니즘은 DBMS 마다 다르므로 <strong>표준 (what) + 엔진 문서 (how) + 실무 테스트</strong>가 필수다.</p></li><li><p><strong>하드웨어·아키텍처 영향</strong><br>락 테이블은 메모리를 사용하고 스핀락·뮤텍스는 CPU 캐시 구조에 민감하다. NUMA 나 캐시라인 경쟁을 고려하지 않으면 락 경쟁이 성능 병목으로 확대된다.</p></li></ul><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th>핵심 액션</th><th>예시 쿼리/도구 (템플릿)</th><th style=text-align:right>성공 기준 (가이드라인)</th><th>주의사항</th></tr></thead><tbody><tr><td style=text-align:right>1. 현황 분석</td><td>동시 사용자·트랜잭션 패턴 파악</td><td>SQL Server: <code>SELECT * FROM sys.dm_exec_requests WHERE blocking_session_id&lt;>0;</code><br>Postgres: <code>pg_locks</code> 기반 블로커 쿼리 (아래 예시)<br>MySQL: <code>SHOW ENGINE INNODB STATUS\G</code></td><td style=text-align:right>블로킹 세션 비율·평균 대기시간 수치화</td><td>수집기간 (최소 24–72 시간) 확보</td></tr><tr><td style=text-align:right>1. 데드락 진단</td><td>최근 데드락 트레이스 수집</td><td>SQL Server: Extended Events / <code>sys.dm_os_ring_buffers</code><br>MySQL: <code>SHOW ENGINE INNODB STATUS</code></td><td style=text-align:right>원인 쿼리 목록 작성 (상위 10)</td><td>데드락 victim 패턴 분석 필요</td></tr><tr><td style=text-align:right>2. 최적화 계획</td><td>격리 수준·인덱스·트랜잭션 설계</td><td>적용 전 A/B 테스트: 스테이징 재현</td><td style=text-align:right>평균 락 대기 20–50% 개선 목표</td><td>Serializable 도입은 신중 (충돌·abort 증가)</td></tr><tr><td style=text-align:right>2. 락 승격/파티셔닝</td><td>승격 임계·파티셔닝 정책 수립</td><td>DBMS 정책 확인·테스트</td><td style=text-align:right>승격으로 인한 테이블 락 빈도 감소</td><td>승격 방지 위해 쿼리 리팩토링</td></tr><tr><td style=text-align:right>3. 모니터링 구축</td><td>실시간 블로킹 감지·알림</td><td>Prometheus + Grafana, 또는 DBMS 내 Performance Schema/DMV</td><td style=text-align:right>알림 응답 (예: 5 분 이내) SLAs 정의</td><td>알림 소음 최소화 (중요도 분류)</td></tr><tr><td style=text-align:right>3. 자동대응</td><td>Head blocker 탐지 스크립트</td><td>예: blocker → 알림 → (검증 후) <code>KILL</code> 스크립트 (인증·로그 남김)</td><td style=text-align:right>수동介入률 감소, 평균 회복시간 단축</td><td>자동 kill 은 권한·검증 필요</td></tr><tr><td style=text-align:right>4. 고도화</td><td>분산락/메시징/Saga 적용 검토</td><td>ZooKeeper/etcd/Redis, 메시지큐 (Kafka/RabbitMQ)</td><td style=text-align:right>긴 트랜잭션 수 감소, 확장성 개선</td><td>아키텍처 복잡성 증가</td></tr><tr><td style=text-align:right>운영 (Timetable)</td><td>일/주/월 점검 루틴</td><td>일별 블로킹 리포트, 주간 승격 분석</td><td style=text-align:right>정량적 KPI 달성 여부</td><td>리포트 자동화 권장</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th style=text-align:right>기간 (권장)</th><th>목표</th><th>주요 주제</th><th>실무 연관성</th><th>권장 실습</th></tr></thead><tbody><tr><td style=text-align:right>기초</td><td style=text-align:right>0–2 개월</td><td>기본 개념 숙지</td><td>ACID, S/X/U, 호환성, 2PL</td><td>트랜잭션 설계의 기초</td><td>블로킹 재현, DMV 조회</td></tr><tr><td style=text-align:right>주요 원리</td><td style=text-align:right>2–6 개월</td><td>내부 동작·트레이드오프 이해</td><td>Intent, Upgrade/Downgrade, Range/Gap</td><td>대규모 수정·동시성 설계</td><td>업그레이드 경쟁 재현, gap 예제</td></tr><tr><td style=text-align:right>실무구현</td><td style=text-align:right>6–12 개월</td><td>DB 별 구현·모니터링 습득</td><td>Postgres/InnoDB/SQLServer 뷰·동작</td><td>운영 진단·대응 능력</td><td>Deadlock 캡처, Grafana 대시보드</td></tr><tr><td style=text-align:right>응용/트렌드</td><td style=text-align:right>12–24 개월</td><td>MVCC/하이브리드 설계</td><td>MVCC vs 2PL/SSI, Snapshot 문제</td><td>리포팅·정산 일관성 설계</td><td>장기 트랜잭션 실험</td></tr><tr><td style=text-align:right>최적화/고급</td><td style=text-align:right>2 년 +</td><td>분산/최신 기법 적용</td><td>분산 락, lock-free, ML 튜닝</td><td>분산 시스템 일관성 전략</td><td>etcd/Redis 레드락 실험</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th>항목</th><th style=text-align:right>중요도</th><th>학습 목표</th><th>실무 연관성</th><th>설명</th></tr></thead><tbody><tr><td style=text-align:right>기초</td><td>S/X/U Lock 개념</td><td style=text-align:right>필수</td><td>기본 잠금 모드 이해</td><td>높음</td><td>공유/배타/업데이트 락의 역할과 호환성</td></tr><tr><td style=text-align:right>기초</td><td>호환성 매트릭스</td><td style=text-align:right>필수</td><td>충돌 예측 능력</td><td>높음</td><td>어떤 모드가 동시에 가능한지 판정</td></tr><tr><td style=text-align:right>기초</td><td>2PL 프로토콜</td><td style=text-align:right>필수</td><td>직렬화 보장 원리</td><td>높음</td><td>락 획득·해제 규칙 (2 단계) 이해</td></tr><tr><td style=text-align:right>주요 원리</td><td>Intent Locks (IS/IX/SIX)</td><td style=text-align:right>필수</td><td>계층적 충돌 감지</td><td>높음</td><td>상위 - 하위 락 협력 메커니즘</td></tr><tr><td style=text-align:right>주요 원리</td><td>Lock Escalation</td><td style=text-align:right>필수</td><td>메모리 vs 동시성 트레이드오프</td><td>높음</td><td>행→테이블 승격 시 영향 이해</td></tr><tr><td style=text-align:right>주요 원리</td><td>Range/Gap Locks</td><td style=text-align:right>권장</td><td>팬텀 방지 메커니즘</td><td>중간</td><td>인덱스 기반 범위 잠금 이해</td></tr><tr><td style=text-align:right>실무구현</td><td>DBMS 별 락 구현</td><td style=text-align:right>필수</td><td>Postgres/InnoDB/SQLServer 차이</td><td>높음</td><td>각 DB 의 구현·관찰 방법 습득</td></tr><tr><td style=text-align:right>실무구현</td><td>모니터링·대시보드</td><td style=text-align:right>필수</td><td>문제 탐지·알림 체계 구성</td><td>높음</td><td>Prometheus/Grafana 연동 실습</td></tr><tr><td style=text-align:right>응용</td><td>MVCC 통합</td><td style=text-align:right>권장</td><td>읽기 성능 vs 정합성 균형</td><td>중간</td><td>MVCC 동작과 한계 파악</td></tr><tr><td style=text-align:right>응용</td><td>장기 트랜잭션 영향</td><td style=text-align:right>권장</td><td>성능·버전 증가 영향 분석</td><td>중간</td><td>Snapshot 오래 유지 시 문제점 분석</td></tr><tr><td style=text-align:right>고급</td><td>분산 잠금</td><td style=text-align:right>권장</td><td>서비스 간 조정 설계</td><td>중간</td><td>ZooKeeper/etcd/Redis 사용법 실습</td></tr><tr><td style=text-align:right>고급</td><td>Lock-free 자료구조</td><td style=text-align:right>선택</td><td>고성능 동시성 기법 이해</td><td>낮음</td><td>연구·특화시스템 적용 가능성 탐색</td></tr><tr><td style=text-align:right>고급</td><td>적응형 튜닝 (ML)</td><td style=text-align:right>선택</td><td>자동 튜닝 기법 탐색</td><td>낮음</td><td>연구·실험 영역</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글 (영어, 약어))</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심</td><td>잠금 모드 (Lock Mode)</td><td>자원에 대한 접근 권한의 분류 (읽기/쓰기/업데이트 등) 으로, 다른 트랜잭션과의 <strong>호환성 규칙</strong>을 포함.</td><td>트랜잭션, 격리 수준, 호환성 매트릭스</td><td>동시성 정책 설계, 쿼리 힌트 해석</td></tr><tr><td>핵심</td><td>공유 잠금 (Shared Lock, S)</td><td>다수의 트랜잭션이 동시에 읽을 수 있게 허용하되 쓰기는 차단하는 잠금.</td><td>읽기 - 읽기 호환성, S/S 허용</td><td>빈번한 읽기 워크로드 처리</td></tr><tr><td>핵심</td><td>배타 잠금 (Exclusive Lock, X)</td><td>해당 자원에 대해 단독 접근을 허용. 다른 모든 잠금과 비호환.</td><td>쓰기보호, Lost Update 방지</td><td>INSERT/UPDATE/DELETE 보호</td></tr><tr><td>핵심</td><td>업데이트 잠금 (Update Lock, U)</td><td>읽기 후 쓰기 가능성이 있는 경우 사용되는 중간형 잠금 (데드락 완화 목적).</td><td>S → X 승격, 데드락 예방</td><td>SELECT … FOR UPDATE, 업데이트 준비</td></tr><tr><td>구조</td><td>의도 잠금 (Intent Lock, IS/IX/SIX)</td><td>상위 (테이블 등) 자원에 하위 (행) 잠금 의도를 표시해 다중그레인 (계층) 충돌 판정 효율화.</td><td>Multiple Granularity, 호환성 매트릭스</td><td>테이블/행 혼합 액세스에서 성능 보장</td></tr><tr><td>구조</td><td>락 그레인 (Granularity)</td><td>잠금 단위 (데이터베이스/테이블/페이지/행/키 등). 단위가 작을수록 동시성↑·오버헤드↑.</td><td>락 에스컬레이션, 성능 트레이드오프</td><td>설계 시 단위 결정 (OLTP vs 배치)</td></tr><tr><td>구조</td><td>범위 락 (Range/Gap/Next-key/Predicate Lock)</td><td>인덱스 키 범위나 조건 범위를 잠궈 <strong>팬텀 (Phantom)</strong> 을 방지하는 잠금 계열.</td><td>Phantom Read, Serializable</td><td>범위 쿼리 동시성 제어, 인덱스 설계 중요</td></tr><tr><td>구조</td><td>스키마 락 (Schema Lock)</td><td>DDL(스키마 변경) 시 구조 안정성을 위해 걸리는 잠금.</td><td>DDL, 스키마 버전</td><td>테이블 변경 시 안전 확보</td></tr><tr><td>응용</td><td>락 호환성 매트릭스 (Lock Compatibility)</td><td>각 잠금 모드 조합의 허용/차단 여부를 표로 정리한 규칙.</td><td>S/X/U/IS/IX 규칙</td><td>동시성 예측·락 충돌 판단</td></tr><tr><td>응용</td><td>락 에스컬레이션 (Lock Escalation / Promotion)</td><td>세부 단위 잠금이 많아지면 상위 단위 (행→테이블) 로 묶는 자동/수동 전환.</td><td>메모리 절약 vs 동시성 손실</td><td>배치 설계·에스컬레이션 튜닝</td></tr><tr><td>응용</td><td>블로킹 (Blocking)</td><td>자원 점유로 인해 다른 트랜잭션이 대기 상태가 되는 현상.</td><td>Head blocker, wait chain</td><td>성능 진단 (대기 시간 감소)</td></tr><tr><td>응용</td><td>데드락 (Deadlock)</td><td>순환적 자원 대기로 인해 트랜잭션이 서로를 기다리는 상태 (자동 희생자 선정해 롤백).</td><td>Deadlock graph, victim selection</td><td>트랜잭션 설계·로그 분석</td></tr><tr><td>응용</td><td>락 타임아웃 (Lock Timeout)</td><td>대기 제한시간 설정으로 장기 대기 시 예외 발생·재시도 유도.</td><td>타임아웃 정책</td><td>사용자 응답성 보장, 재시도 로직</td></tr><tr><td>최적화</td><td>MVCC (Multi-Version Concurrency Control)</td><td>버전 기반 동시성 제어로 읽기와 쓰기를 분리해 읽기 성능을 높이는 방식 (락 최소화).</td><td>Snapshot Isolation, SSI</td><td>읽기 중심 시스템, PostgreSQL/MySQL InnoDB 적용</td></tr><tr><td>최적화</td><td>낙관적 동시성 (Optimistic OCC)</td><td>실행 중 충돌 검증을 커밋 시점에 수행하고 충돌 시 재시도하는 방식.</td><td>재시도 비용, 충돌 확률</td><td>충돌이 드문 쓰기 환경에서 유리</td></tr><tr><td>진단</td><td>락 풀 / 락 테이블 (Lock Pool/Table)</td><td>DBMS 가 관리하는 잠금 레코드 저장 구조; 한계 초과 시 에러/에스컬레이션 유발.</td><td>리소스 한계, 모니터링</td><td>용량 계획·메트릭 경보</td></tr><tr><td>진단</td><td>대기 그래프 / 락 그래프 (Wait-for Graph)</td><td>세션들 간의 대기 관계를 그래프로 표현해 데드락 원인 분석에 사용.</td><td>Deadlock detection</td><td>데드락 원인 추적·디버깅</td></tr><tr><td>진단</td><td>모니터링 이벤트 (Lock Events / XE / Performance Counters)</td><td>락 획득·해제·대기 정보를 수집하는 감사·성능 추적 기능.</td><td>Extended Events, INFORMATION_SCHEMA</td><td>운영 모니터링·사후 분석</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/current/transaction-iso.html>PostgreSQL 문서 — Transaction Isolation</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html>MySQL 8.0 Reference — InnoDB Locking</a></li><li><a href=https://learn.microsoft.com/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide>Microsoft Learn — SQL Server: Transaction locking and row versioning guide</a></li><li><a href=https://www.postgresql.org/docs/current/mvcc.html>PostgreSQL 문서 — MVCC (Concurrency Control)</a></li><li><a href=https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/data-concurrency-and-consistency.html>Oracle — Data Concurrency and Consistency (Oracle Database 19c)</a></li><li><a href=https://stackoverflow.blog/2019/10/11/how-stack-overflow-caches-apps-for-a-multi-tenant-architecture/>How Stack Overflow Caches Apps for a Multi-Tenant Architecture</a></li><li><a href=https://github.com/cockroachdb/cockroach>CockroachDB — GitHub 저장소 (cockroach)</a></li><li><a href=https://github.com/pingcap/tidb>TiDB — GitHub 저장소 (tidb)</a></li><li><a href=https://github.com/postgres/postgres>PostgreSQL — GitHub 저장소 (postgres)</a></li><li><a href=https://www.sentryone.com/plan-explorer>Plan Explorer — SentryOne</a></li><li><a href=https://docs.microsoft.com/en-us/sql/ssms/>SQL Server Management Studio (SSMS) — Microsoft Learn</a></li><li><a href=https://docs.microsoft.com/en-us/sql/relational-databases/extended-events/>Extended Events — SQL Server (Microsoft Learn)</a></li><li><a href=https://www.datadoghq.com/product/database-monitoring/>Datadog — Database Monitoring</a></li><li><a href="https://www.ibm.com/docs/en/db2-for-zos/12.0.0?topic=locks-lock-modes-compatibility">IBM DB2 — Lock modes and compatibility of locks</a></li><li><a href=https://www.geeksforgeeks.org/dbms/implementation-of-locking-in-dbms/>GeeksforGeeks — Implementation of Locking in DBMS</a></li><li><a href=https://www.alooba.com/skills/concepts/relational-databases-8/locks/>Alooba — Locks (개념 정리)</a></li><li><a href=https://mediatum.ub.tum.de/doc/1692912/1692912.pdf>TUM — Scalable concurrency control methods (PDF)</a></li><li><a href=https://aws.amazon.com/blogs/database/improve-postgresql-performance-diagnose-and-mitigate-lock-manager-contention/>AWS Database Blog — Improve PostgreSQL performance: Diagnose and mitigate lock manager contention</a></li></ul><hr></div><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Intent Modes</h2></header><div class=entry-content><p>Intent Modes Intent Modes(의도 잠금) 는 다중 그라뉼러리티 잠금 (MGL) 에서 상위 노드에 " 하위에서 어떤 락을 걸 계획인지 " 를 선행 표명하는 경량 잠금이다.
기본형은 IS(하위에 S 예고), IX(하위에 X 예고), SIX(테이블은 공유 읽기 허용 + 일부 하위는 배타 갱신) 이며, 트랜잭션은 하위 락을 잡기 전에 반드시 대응되는 의도 락을 상위에 먼저 획득한다 (예: 행 X → 테이블 IX, 행 S → 테이블 IS).
이 구조 덕분에 엔진은 상위 수준에서 Lock Compatibility Matrix만 조회해 대규모 작업 (테이블 스캔·DDL) 과 미세 작업 (개별 행 갱신) 의 충돌 여부를 빠르게 판정하고, 불필요한 광역 차단을 피한다.
의도 락은 2PL과 결합해 직렬가능성 달성에 기여하며, 에스컬레이션·파티셔닝 같은 운영 전략과도 잘 맞는다.
MVCC를 쓰는 엔진에서도 DDL/테이블 락, 인덱스 범위 잠금 등에는 의도 락 규칙이 여전히 적용된다.
...</p></div><footer class=entry-footer><span title='2025-09-22 08:35:00 +0000 UTC'>September 22, 2025</span>&nbsp;·&nbsp;64 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Intent Modes" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/intent-modes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock Compatibility Matrix</h2></header><div class=entry-content><p>Lock Compatibility Matrix **락 호환성 매트릭스 (Lock Compatibility Matrix, LCM)**는 트랜잭션이 리소스 (레코드/페이지/테이블) 를 특정 모드로 잠글 때, 다른 트랜잭션의 잠금 요청을 허용·대기·거부로 즉시 판정하는 규칙표다.
기본 모드는 S(공유)·**X(배타)**이며, 다중 그레뉼러리티에서 상·하위 객체를 안전히 함께 잠그기 위해 **IS/IX/SIX(의도 락)**을 사용한다.
일부 DBMS 는 갱신 경합을 줄이려 U(Update) 같은 확장 모드를 둔다.
Lock Compatibility Matrix(LCM) 은 격리 수준 (특히 2PL 기반 RC/RR/Serializable) 구현과 락 에스컬레이션·타임아웃·교착 탐지의 핵심 근거다.
MVCC 환경에서도 쓰기 충돌·직렬가능성 (예: 프레디킷/범위 잠금) 보장을 위해 잠금이 병행 활용된다.
...</p></div><footer class=entry-footer><span title='2025-09-22 08:23:00 +0000 UTC'>September 22, 2025</span>&nbsp;·&nbsp;49 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock Compatibility Matrix" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-modes/lock-compatibility-matrix/></a></article></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>