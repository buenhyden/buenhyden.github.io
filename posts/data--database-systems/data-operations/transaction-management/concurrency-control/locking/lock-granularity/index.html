<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Lock Granularity | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Concurrency-Control,Locking,Lock-Granularity"><meta name=description content="잠금 세분성은 잠금을 적용하는 단위를 정의해 동시성 및 관리 오버헤드의 균형을 결정하는 핵심 설계 요소다. 세분화는 동시성을 높이나 메타데이터·추적 비용을 증가시키며, 의도잠금·계층적 잠금·에스컬레이션과 워크로드 기반 튜닝으로 실무적 트레이드오프를 관리한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Lock Granularity"><meta property="og:description" content="잠금 세분성은 잠금을 적용하는 단위를 정의해 동시성 및 관리 오버헤드의 균형을 결정하는 핵심 설계 요소다. 세분화는 동시성을 높이나 메타데이터·추적 비용을 증가시키며, 의도잠금·계층적 잠금·에스컬레이션과 워크로드 기반 튜닝으로 실무적 트레이드오프를 관리한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Lock Granularity"><meta name=twitter:description content="잠금 세분성은 잠금을 적용하는 단위를 정의해 동시성 및 관리 오버헤드의 균형을 결정하는 핵심 설계 요소다. 세분화는 동시성을 높이나 메타데이터·추적 비용을 증가시키며, 의도잠금·계층적 잠금·에스컬레이션과 워크로드 기반 튜닝으로 실무적 트레이드오프를 관리한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"Lock Granularity","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/lock-granularity/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Lock Granularity</h1><div class=post-description>잠금 세분성은 잠금을 적용하는 단위를 정의해 동시성 및 관리 오버헤드의 균형을 결정하는 핵심 설계 요소다. 세분화는 동시성을 높이나 메타데이터·추적 비용을 증가시키며, 의도잠금·계층적 잠금·에스컬레이션과 워크로드 기반 튜닝으로 실무적 트레이드오프를 관리한다.</div></header><div class=post-content><h2 id=lock-granularity>Lock Granularity<a hidden class=anchor aria-hidden=true href=#lock-granularity>#</a></h2><p>Lock Granularity 는 " 어느 범위에 락을 걸 것인가 " 를 결정하는 설계 레버로, 세밀할수록 동시성은 커지지만 락 관리 오버헤드·데드락 위험도 증가한다.<br>해결책은 다층적 락 (의도락) 사용으로 상위 - 하위 충돌을 줄이고, 인덱스·쿼리로 범위 스캔을 피하며, 파티셔닝·샤딩·MVCC 병행으로 핫스팟을 완화하는 것이다.</p><p>실무 체크리스트:</p><ol><li>읽기/쓰기 비율 측정</li><li>핫스팟 식별</li><li>인덱스·쿼리 튜닝</li><li>에스컬레이션 임계치·락 테이블 메모리 모니터링</li><li>스테이징에서 그레인별 성능 테스트.</li></ol><p>최종 원칙: " 작게 시작해 계측하고, 워크로드에 맞춰 조정 " 이다.</p><h3 id=핵심-개념>핵심 개념<a hidden class=anchor aria-hidden=true href=#핵심-개념>#</a></h3><ul><li><p>데이터에 동시에 접근하는 여러 작업이 있을 때 <strong>어떤 단위로 얼마만큼 잠글지</strong>(세분성) 를 정하면 성능과 일관성이 결정된다.</p></li><li><p><strong>작게 잠그면 (행)</strong> 더 많은 작업이 동시에 돌아가지만 관리비용이 커진다. <strong>크게 잠그면 (테이블)</strong> 관리비용은 작아지지만 경쟁이 늘어난다.</p></li><li><p>그래서 대부분의 DB 는 <strong>계층적 잠금 (MGL)</strong> 과 <strong>의도락</strong>을 써서 상위 구조에서 충돌을 빠르게 판단하고, 필요에 따라 <strong>락 승격</strong>을 한다.</p></li><li><p>실무 포인트: _ 인덱스·파티셔닝·짧은 트랜잭션·타임아웃/재시도 정책 _ 이 성능을 지키는 핵심이다.</p></li></ul><table><thead><tr><th>개념 (한글 / 약어)</th><th>정의 (간단)</th><th style=text-align:right>왜 중요한가 (실무 관점)</th><th>적용 예시</th></tr></thead><tbody><tr><td>잠금 세분화 (Lock Granularity)</td><td>행/페이지/테이블 등 락 단위</td><td style=text-align:right>동시성 ↔ 관리 오버헤드 균형</td><td>OLTP: 행, 배치: 테이블</td></tr><tr><td>잠금 계층 (Lock Hierarchy)</td><td>DB→테이블→페이지→행 계층</td><td style=text-align:right>계층적 검사로 검색 비용 절감</td><td>의도락 기반 검사</td></tr><tr><td>의도 잠금 (Intention Lock, IS/IX)</td><td>상위 레벨에 하위 락 의도 표기</td><td style=text-align:right>빠른 충돌 판단 및 비용 절감</td><td>대형 테이블 동시 액세스</td></tr><tr><td>락 승격 (Lock Escalation)</td><td>다수 세부 락 → 상위 락 전환</td><td style=text-align:right>메모리 절감 vs 동시성 저하</td><td>대량 업데이트시 승격 발생</td></tr><tr><td>키 - 범위 락 (Key-Range / Predicate)</td><td>범위 단위 잠금</td><td style=text-align:right>팬텀 방지 (격리 보장)</td><td>범위 쿼리 많은 트랜잭션</td></tr><tr><td>락 컨버전 (Lock Conversion)</td><td>S→X 등 모드 변경</td><td style=text-align:right>모드 변경 시 데드락 유발 가능</td><td>read→update 전환 시</td></tr><tr><td>경합 / 데드락 (Contention/Deadlock)</td><td>대기/교착 상태</td><td style=text-align:right>서비스 지연·오류 초래</td><td>데드락 탐지·victim abort</td></tr></tbody></table><p>잠금 설계는 <strong>단위 (세분화)</strong> · <strong>계층 (의도락)</strong> · **전환 (컨버전/승격)**이 상호 작용해 성능과 정합성을 만든다. 실무에서는 워크로드 패턴 (읽기/쓰기, 범위 쿼리 등) 을 보고 적절한 단위와 정책을 선택해야 한다.</p><h4 id=잠금-개념-상호관계-표>잠금 개념 상호관계 표<a hidden class=anchor aria-hidden=true href=#잠금-개념-상호관계-표>#</a></h4><table><thead><tr><th>출발 개념</th><th>영향 대상</th><th style=text-align:right>관계 (무엇을 위해)</th><th>방향성 / 비고</th></tr></thead><tbody><tr><td>잠금 세분화</td><td>동시성, 오버헤드</td><td style=text-align:right>동시성↑ / 오버헤드↑</td><td>행→동시성↑, 테이블→관리↓</td></tr><tr><td>의도 잠금</td><td>락 검사 비용</td><td style=text-align:right>상위에서 하위 검사 비용↓</td><td>IS/IX 도입으로 스캔 비용 감소</td></tr><tr><td>락 승격</td><td>메모리 사용, 동시성</td><td style=text-align:right>메모리↓ / 동시성↓</td><td>다수 행락→테이블락</td></tr><tr><td>키 - 범위 락</td><td>팬텀 발생</td><td style=text-align:right>팬텀 방지 목적</td><td>격리 수준과 연동</td></tr><tr><td>락 컨버전</td><td>데드락 위험</td><td style=text-align:right>컨버전 시 데드락↑</td><td>재시도 정책 필요</td></tr><tr><td>파티셔닝</td><td>경합 분산</td><td style=text-align:right>경합↓, 글로벌조정 필요</td><td>샤드 설계 중요</td></tr></tbody></table><p>각 개념은 **목적 (성능, 일관성, 자원관리)**을 위해 서로 영향을 준다. 설계 시는 어느 방향 (동시성↑/관리↓ 등) 을 얻고 싶은지 명확히 한 뒤 개념을 조합해야 한다.</p><h4 id=잠금-개념의-실무-적용-매핑표>잠금 개념의 실무 적용 매핑표<a hidden class=anchor aria-hidden=true href=#잠금-개념의-실무-적용-매핑표>#</a></h4><table><thead><tr><th>핵심 개념</th><th>실무에서 무엇 (What)</th><th style=text-align:right>어떻게 적용 (How)</th><th>왜 필요한가 (Why)</th></tr></thead><tbody><tr><td>잠금 세분화</td><td>트랜잭션 성능 제어</td><td style=text-align:right>행단위/테이블단위 선택, 인덱스 재설계</td><td>동시성 최적화, 경합 최소화</td></tr><tr><td>의도 잠금</td><td>상위 검사 효율화</td><td style=text-align:right>DB 가 자동 설정 (IS/IX)</td><td>락 탐색 비용 절감</td></tr><tr><td>락 승격</td><td>메모리/관리 부담 완화</td><td style=text-align:right>임계값 기반 전환 정책</td><td>메모리 절감, 운영 안정성</td></tr><tr><td>키 - 범위 락</td><td>팬텀 방지</td><td style=text-align:right>인덱스 기반 범위 잠금</td><td>격리 보장 (Serializable)</td></tr><tr><td>락 컨버전</td><td>쓰기 전환 안전성</td><td style=text-align:right>early X 획득 / 재시도 전략</td><td>데드락 예방</td></tr><tr><td>파티셔닝</td><td>병목 분산</td><td style=text-align:right>샤드 키 설계, 리밸런싱</td><td>확장성 확보</td></tr></tbody></table><p>실무에서는 개념별 행동 (무엇/어떻게) 을 명확히 하고, <strong>측정 가능한 지표</strong>(lock wait, hold time, deadlock count) 를 통해 정책의 적절성을 검증하고 조정해야 한다.</p><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=락-입도-lock-granularity-설계운영-지침>락 입도 (Lock Granularity) 설계·운영 지침<a hidden class=anchor aria-hidden=true href=#락-입도-lock-granularity-설계운영-지침>#</a></h4><p>잠금 입도는 " 데이터에 락을 얼마나 세밀하게 걸 것인가?" 를 결정하는 설계 변수다.<br>레코드 단위로 락을 걸면 여러 트랜잭션이 동시에 다른 행을 수정할 수 있어 동시성이 좋아지지만, 시스템은 더 많은 락을 관리해야 하므로 메모리와 처리 비용이 늘어난다.<br>반대로 테이블 단위로 락을 걸면 관리 비용은 작지만 동시성이 크게 떨어져 핫스팟이 생긴다. 따라서 <strong>짧은 트랜잭션, 작은 락 범위 (가능하면 행 단위), 일관된 락 순서</strong>, 그리고 <strong>지표 모니터링</strong>을 기본 원칙으로 삼아 워크로드에 맞춰 입도를 조정해야 한다.</p><h5 id=락-입도-lock-granularity-핵심정리>락 입도 (Lock Granularity) 핵심정리<a hidden class=anchor aria-hidden=true href=#락-입도-lock-granularity-핵심정리>#</a></h5><p>**잠금 입도 (Lock Granularity)**는 &rsquo; 어떤 단위를 락으로 묶을 것인가 &rsquo; 의 문제로, 본질은 **동시성 (처리량·충돌률)**과 <strong>관리 오버헤드 (메타데이터·락 스케줄링 비용)</strong> 사이의 균형을 찾는 것이다. 설계는 워크로드 (읽기/쓰기 비율, 트랜잭션 지속시간, 핫스팟 존재), DB 내부 메커니즘 (의도락, 에스컬레이션), 그리고 분산 요건 (로컬 vs 글로벌 일관성) 을 종합해 결정해야 한다. 실무 원칙은 다음과 같다.</p><ul><li><strong>작은 단위 우선 원칙</strong>: 가능한 한 행 (레코드) 단위 락을 선호하되, 락 수·메모리 비용이 감당 불가면 상위 단위로 조정.</li><li><strong>일관된 락 순서 적용</strong>: 데드락 예방을 위해 접근 순서 표준화.</li><li><strong>에스컬레이션 제어</strong>: 임계치·히스테리시스 설정으로 불필요한 테이블 락 전환 방지.</li><li><strong>모니터링 기반 튜닝</strong>: lock wait time, avg locks/tx, escalation rate 등 지표로 주기적 조정.</li><li><strong>MVCC·분산 고려</strong>: MVCC 는 읽기 성능을 돕지만 쓰기 충돌·버전 GC 비용을 유발하므로 입도 결정과 함께 검토.</li></ul><h5 id=락-입도-원리와-설계-가이드>락 입도: 원리와 설계 가이드<a hidden class=anchor aria-hidden=true href=#락-입도-원리와-설계-가이드>#</a></h5><h6 id=입도-레벨과-영향>입도 레벨과 영향<a hidden class=anchor aria-hidden=true href=#입도-레벨과-영향>#</a></h6><ul><li><p><strong>Row/Record-level</strong></p><ul><li>장점: 최대 동시성, 충돌 범위 최소.</li><li>단점: 락 오브젝트 수↑, 메모리/CPU 오버헤드↑, 관리 복잡도↑.</li><li>권장: 다수의 동시 쓰기 대상이 분산되어 있고 트랜잭션이 짧은 경우.</li></ul></li><li><p><strong>Page/Block-level</strong></p><ul><li>장점: 락 관리 비용 절감 (단위 당 오브젝트 수 감소).</li><li>단점: 같은 페이지 내 여러 행 동시 수정 시 충돌 발생.</li><li>권장: 물리적 저장/캐시 관점에서 성능 최적화 필요할 때.</li></ul></li><li><p><strong>Table-level</strong></p><ul><li>장점: 구현/관리 단순, 메타데이터 최소.</li><li>단점: 동시성 대폭 저하, 핫스팟 취약.</li><li>권장: 단순 관리·트랜잭션이 적은 환경, 또는 DDL 등 명확한 구간.</li></ul></li><li><p><strong>Database-level</strong></p><ul><li>거의 사용되지 않음 (전역 락). 대규모 동시성 환경에서는 부적합.</li></ul></li></ul><h6 id=기술적-메커니즘>기술적 메커니즘<a hidden class=anchor aria-hidden=true href=#기술적-메커니즘>#</a></h6><ul><li><strong>의도 (상위) 락 (Intention locks)</strong>: 테이블 - 행 계층에서 상위 수준이 하위 수준 락 의도를 표기해 호환성 검사 비용을 줄임 (예: IS/IX).</li><li><strong>락 에스컬레이션 (Lock Escalation)</strong>: 많은 세부 락이 생성되면 시스템이 자동으로 상위 단위로 전환 (예: row→table) 하여 메타데이터 과다를 막음. 임계치와 hysteresis 설정이 중요.</li><li><strong>복합 전략</strong>: 일부 시스템은 동적 입도 (워크로드에 따라 행/페이지 선택) 또는 하이브리드 (MVCC + 행락) 사용.</li><li><strong>분산/샤드 전략</strong>: 전역 락 비용이 크므로 가능한 한 로컬 샤드 내에서 처리 (로컬 락) 하고, 전역 일관성이 필요할 때만 합의/조정 사용.</li></ul><h6 id=실무-튜닝-체크리스트>실무 튜닝 체크리스트<a hidden class=anchor aria-hidden=true href=#실무-튜닝-체크리스트>#</a></h6><ol><li><strong>프로파일링</strong>: lock wait time, avg locks per tx, escalation rate, hot-key access 분포 수집.</li><li><strong>트랜잭션 설계</strong>: 트랜잭션은 가능한 짧게, I/O/외부 호출은 트랜잭션 밖으로 이동.</li><li><strong>인덱스/쿼리 최적화</strong>: 풀스캔을 피해 잠금 범위 축소.</li><li><strong>에스컬레이션 파라미터</strong>: 기본 임계치 확인 및 워크로드에 맞게 조정.</li><li><strong>의도락/계층적 락 이해</strong>: DBMS 가 제공하는 락 계층을 확인해 설계에 반영.</li><li><strong>MVCC 와의 조화</strong>: 읽기 성능이 중요하면 MVCC 활용, 쓰기 충돌은 별도 고려.</li><li><strong>분산 설계</strong>: 가능하면 로컬 처리, 전역 동기화는 최소화.</li></ol><h4 id=락-단위의-진화-문제해결트레이드오프>락 단위의 진화: 문제·해결·트레이드오프<a hidden class=anchor aria-hidden=true href=#락-단위의-진화-문제해결트레이드오프>#</a></h4><p>락 단위 (lock granularity) 는 &rsquo; 얼마나 세밀하게 잠그는가 &rsquo; 에 대한 설계 결정이야. 초기에는 테이블 전체를 잠궜는데, 이는 동시성이 낮아 성능이 안 좋았어. 그래서 페이지, 행, 심지어 키 범위 단위로 점점 더 세분화했고, 상위 - 하위 관계를 관리하기 위해 의도 락 같은 계층적 기법 (MGL) 을 도입했지. 락을 세게 걸면 일관성은 높아지지만 성능이 떨어지고, 세밀하게 하면 병렬성은 좋아지지만 관리가 복잡해지는 트레이드오프가 항상 존재해. 최신 시스템은 MVCC 같은 접근으로 읽기를 비차단화하고, 분산 환경에서는 합의·fencing 으로 안전성을 보장하려고 해.</p><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>다중 사용자·다중 트랜잭션 환경에서 데이터 무결성·일관성 보장 필요. 초기 단순 락으로는 동시성 요구를 충족하지 못해 락 단위의 세분화와 계층적 관리 기법이 발전했다. 또한 범위 쿼리의 팬텀 문제와 분산 환경의 일관성 문제는 새로운 락 유형 (갭 락) 과 분산 보완책 (MVCC, consensus, fencing) 을 촉발했다.</p><h5 id=락-단위의-역사와-실무적-진화>락 단위의 역사와 실무적 진화<a hidden class=anchor aria-hidden=true href=#락-단위의-역사와-실무적-진화>#</a></h5><ol><li><p><strong>테이블/페이지 락 (초기)</strong></p><ul><li>왜 등장했나: 단순 구현으로 데이터 무결성 보장 필요.</li><li>무엇이 개선되었나: 기본적인 상호배제로 무결성 확보.</li><li>트레이드오프: 심각한 동시성 부족 (성능 저하).</li></ul></li><li><p><strong>페이지 단위 → 행 단위로 이동 (세분화)</strong></p><ul><li>왜 등장했나: 테이블/페이지 단위의 과도한 경합을 줄여 병렬성 확보 필요.</li><li>무엇이 개선되었나: 더 많은 트랜잭션 동시 실행 가능 (성능 향상).</li><li>트레이드오프: 락 관리 오버헤드 증가 (메모리·CPU), 복잡성 상승.</li></ul></li><li><p><strong>Multiple Granularity Locking (MGL) + 의도 락 도입</strong></p><ul><li>왜 등장했나: 계층적 구조에서 상위/하위 락 간 충돌을 효율적으로 판정하기 위함.</li><li>무엇이 개선되었나: 상위 레벨에서 하위 락 의도를 표시해 충돌 체크 비용 감소 및 병렬성 향상.</li><li>트레이드오프: 구현·디버깅 복잡성, 정책 이해 필요.</li></ul></li><li><p><strong>락 에스컬레이션 (자동 승격) 등장</strong></p><ul><li>왜 등장했나: 너무 많은 저레벨 락으로 락 테이블이 커지는 문제 해결 필요.</li><li>무엇이 개선되었나: 락 관리 오버헤드 감소 (락 테이블·관리 비용 제어).</li><li>트레이드오프: 에스컬레이션 시 병렬성 급감 가능 (성능 저하).</li></ul></li><li><p><strong>키 - 범위/갭 락 (팬텀 방지)</strong></p><ul><li>왜 등장했나: 범위 쿼리에서 삽입되는 레코드로 인해 팬텀 문제가 발생.</li><li>무엇이 개선되었나: 범위 삽입을 차단해 Repeatable Read/Serializable 수준 보장.</li><li>트레이드오프: 범위 락은 경합 증가 및 잠재적 성능 저하.</li></ul></li><li><p><strong>낙관적 동시성 / MVCC 보급</strong></p><ul><li>왜 등장했나: 읽기 - 쓰기 충돌을 줄이고 읽기를 비차단으로 만들어 응답성 개선 필요.</li><li>무엇이 개선되었나: 읽기 성능 대폭 개선, 락 경합 감소.</li><li>트레이드오프: 버전 누적·GC 부담, 일부 격리 이상 (write-skew 등).</li></ul></li><li><p><strong>클라우드·분산 시대의 적용 변화</strong></p><ul><li>왜 등장했나: 분산·멀티리전 환경에서 전역 일관성·락 동기화 필요.</li><li>무엇이 개선되었나: 합의·lease·fencing 등을 통한 안전한 분산 락 운영 가능.</li><li>트레이드오프: 지연·복잡도·운영 비용 증가.</li></ul></li></ol><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>시기 (대략)</th><th>변화된 락 단위 / 기법</th><th>등장 이유 (문제)</th><th>개선 내용 (성과)</th><th>트레이드오프</th></tr></thead><tbody><tr><td style=text-align:right>초기 (1960s–70s)</td><td>테이블/페이지 락</td><td>단순성·무결성 필요</td><td>기본적 무결성 확보</td><td>동시성 저하</td></tr><tr><td style=text-align:right>1980s</td><td>페이지 → 행 단위 세분화</td><td>과도한 경합 해소</td><td>병렬성 증가</td><td>락 관리 비용 증가</td></tr><tr><td style=text-align:right>1980s–1990s</td><td>Multiple Granularity Locking + 의도 락</td><td>계층적 충돌 판정 필요</td><td>상위에서 하위 의도 표현으로 효율화</td><td>구현 복잡성</td></tr><tr><td style=text-align:right>1990s</td><td>락 에스컬레이션</td><td>락 테이블 오버헤드 제어</td><td>관리 부하 감소</td><td>병렬성 감소 위험</td></tr><tr><td style=text-align:right>1990s–2000s</td><td>키 - 범위 / 갭 락</td><td>팬텀 방지 (범위 쿼리)</td><td>범위 정합성 보장</td><td>범위 경합으로 성능 저하</td></tr><tr><td style=text-align:right>2000s</td><td>낙관적 동시성, MVCC</td><td>비차단 읽기 필요</td><td>읽기 성능 향상·락 경합 감소</td><td>버전 누적·GC 부담</td></tr><tr><td style=text-align:right>2010s–현재</td><td>분산 적용 (lease/consensus/fencing)</td><td>글로벌 일관성·가용성 문제</td><td>안전한 분산 락 운영</td><td>지연·운영 복잡성 증가</td></tr></tbody></table><pre class=mermaid>timeline
  title Lock Granularity 발전 타임라인
  1970 : 테이블/페이지 락 (초기)
  1980 : 페이지→행 단위 세분화
  1985 : Multiple Granularity Locking (MGL), 의도 락 도입
  1990 : 락 에스컬레이션 등장
  1995 : 키-범위/갭 락(팬텀 방지)
  2000 : 낙관적 동시성 / MVCC 확산
  2010 : 분산 락 보완(lease, fencing, consensus)
</pre><p>락 단위의 진화는 항상 &rsquo; 동시성 향상 vs 관리 비용·복잡성 &rsquo; 이라는 트레이드오프를 중심으로 전개되었다.<br>세분화 (행/키 범위) 는 동시성을 크게 개선했지만 락 관리 (메모리·CPU·정책) 부담을 늘렸고, 이를 해소하려 의도 락·에스컬레이션 같은 메커니즘이 등장했다.<br>MVCC 는 읽기를 비차단화해 큰 성능 이득을 주었지만 GC 와 버전 관리라는 새로운 운영 변수를 만들었다. 분산 시대에는 전통적 락 모델에 합의·fencing 을 결합해 안전성을 확보하려는 방향으로 진화하고 있다.</p><h4 id=락-그레뉼러리티-문제목적운영-가이드>락 그레뉼러리티: 문제·목적·운영 가이드<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티-문제목적운영-가이드>#</a></h4><p>락 그레뉼러리티는 **&rsquo; 어떤 단위 (행/페이지/테이블 등) 에 락을 걸 것인가 &lsquo;**를 결정하는 설계다.</p><ul><li>작은 단위 (행) 는 많은 사용자가 동시에 같은 테이블을 다뤄도 충돌을 줄여주지만, 관리 오버헤드 (락 테이블 크기·CPU) 가 커진다.</li><li>큰 단위 (테이블) 는 오버헤드는 작지만 동시성은 떨어진다.</li><li>전략적으로는 대부분 <code>행 락 + 특정 상황에서 범위 락(팬텀 차단)</code> 을 쓰고, 핫 로우는 샤딩·버킷화·애플리케이션 큐로 회피한다.</li><li>운영에서는 락 대기·에스컬레이션·데드락 지표를 모니터링해 정책을 조정한다.</li></ul><h5 id=락-그레뉼러리티로-해결하는-문제표>락 그레뉼러리티로 해결하는 문제표<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티로-해결하는-문제표>#</a></h5><table><thead><tr><th>문제</th><th>증상 (간단)</th><th style=text-align:right>그레뉼러리티 대응 방식</th><th>예시 (실무)</th><th>기대 효과</th></tr></thead><tbody><tr><td>Hot row 병목</td><td>특정 행에 대기 집중, P99 상승</td><td style=text-align:right>애플리케이션 샤딩·버킷화, 로컬 캐시 + 비동기 합산</td><td>사용자 계정 잦은 업데이트</td><td>일반 트랜잭션 P99 개선</td></tr><tr><td>팬텀 읽기</td><td>범위 쿼리 결과가 트랜잭션 간 달라짐</td><td style=text-align:right>Predicate/Gap 락 또는 SERIALIZABLE</td><td>잔고 범위 검사 (금융)</td><td>범위 무결성 보장</td></tr><tr><td>데이터 불일치</td><td>동시 쓰기로 결과 왜곡</td><td style=text-align:right>배타 락 (X) 또는 낙관적 버전검사</td><td>재고 동시 감소 처리</td><td>무결성 확보</td></tr><tr><td>더티 리드</td><td>미확정 데이터 사용 사고</td><td style=text-align:right>Strict 2PL / MVCC 스냅샷</td><td>리포팅 데이터 오류</td><td>잘못된 의사결정 방지</td></tr><tr><td>갱신 손실</td><td>동시 업데이트 중 일부 손실</td><td style=text-align:right>행 락 또는 낙관적 재시도</td><td>동시 가격 갱신</td><td>데이터 손실 방지 및 정확성</td></tr></tbody></table><p>락 그레뉼러리티는 각 문제에 대해 <strong>적절한 범위와 유지시간</strong>을 선택해 충돌을 방지한다. 그러나 락 자체가 비용이므로 <strong>핫 로우는 애플리케이션 차원에서 회피</strong>하고, 팬텀 같은 특수 문제는 인덱스·범위 락으로 해결하는 것이 일반적이다.</p><h5 id=락-그레뉼러리티의-핵심-목적표>락 그레뉼러리티의 핵심 목적표<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티의-핵심-목적표>#</a></h5><table><thead><tr><th>목적</th><th>설명</th><th style=text-align:right>왜 중요한가</th><th>그레뉼러리티가 기여하는 바</th></tr></thead><tbody><tr><td>데이터 무결성</td><td>정확한 데이터 상태 보장</td><td style=text-align:right>비즈니스 로직·재무 신뢰성</td><td>충돌 방지로 오류·환불 감소</td></tr><tr><td>트랜잭션 격리성</td><td>트랜잭션 독립성 보장</td><td style=text-align:right>재현성·디버깅 용이</td><td>적절한 수명·범위로 재현성 확보</td></tr><tr><td>성능 최적화</td><td>지연·대기 최소화</td><td style=text-align:right>사용자 경험·서비스 SLA</td><td>세밀한 락으로 동시성 향상</td></tr><tr><td>운영 예측성</td><td>배치·DDL 작업 안정성</td><td style=text-align:right>운영 계획·리소스 예약</td><td>일시적 거친 락으로 예측 가능성 확보</td></tr></tbody></table><p>목적은 상호보완적이다. 설계자는 <strong>무결성 우선인지 성능 우선인지</strong> 우선순위를 정한 뒤 그에 맞는 그레뉼러리티·수명·패턴 (NOWAIT/SKIP_LOCKED 등) 을 조합해야 한다.</p><h5 id=문제와-목적의-연계-매트릭스>문제와 목적의 연계 매트릭스<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연계-매트릭스>#</a></h5><table><thead><tr><th>문제 \ 목적</th><th style=text-align:center>데이터 무결성</th><th style=text-align:center>트랜잭션 격리</th><th style=text-align:center>성능 최적화</th><th style=text-align:center>운영 예측성</th></tr></thead><tbody><tr><td>Hot row 병목</td><td style=text-align:center>△(직접 관련 아님)</td><td style=text-align:center>○</td><td style=text-align:center>●</td><td style=text-align:center>●(유지·예측 위해 회피필요)</td></tr><tr><td>팬텀 읽기</td><td style=text-align:center>●</td><td style=text-align:center>●</td><td style=text-align:center>△(비용 증가 가능)</td><td style=text-align:center>○</td></tr><tr><td>데이터 불일치</td><td style=text-align:center>●</td><td style=text-align:center>●</td><td style=text-align:center>△</td><td style=text-align:center>○</td></tr><tr><td>더티 리드</td><td style=text-align:center>●</td><td style=text-align:center>●</td><td style=text-align:center>△</td><td style=text-align:center>○</td></tr><tr><td>갱신 손실</td><td style=text-align:center>●</td><td style=text-align:center>●</td><td style=text-align:center>△</td><td style=text-align:center>○</td></tr></tbody></table><p>(●: 강한 관련 / ○: 일부 관련 / △: 간접적/트레이드오프 존재)</p><p>대부분 <code>데이터 무결성</code> 과 <code>트랜잭션 격리</code> 는 문제 해결의 주요 목적이며, <code>성능</code> 과 <code>운영 예측성</code> 은 설계 시 트레이드오프로 항상 고려해야 할 교환 변수다.</p><h4 id=락-그레인-lock-granularity-핵심-전제와-운영원칙>락 그레인 (lock granularity) 핵심 전제와 운영원칙<a hidden class=anchor aria-hidden=true href=#락-그레인-lock-granularity-핵심-전제와-운영원칙>#</a></h4><blockquote><p><strong>핵심 메시지</strong>: 락 그레인 (lock granularity) 은 &rsquo; 얼마나 작은 단위 (테이블/페이지/레코드/필드) 로 잠글 것인가 &rsquo; 의 문제다.</p></blockquote><ul><li>작은 단위 → 여러 트랜잭션이 동시에 작업 가능 (동시성↑) → 하지만 각 잠금의 메타데이터·관리 비용이 커진다.</li><li>큰 단위 → 관리 비용 작음 (오버헤드↓) → 동시에 접근하는 트랜잭션이 많으면 대기·성능 저하 발생.</li><li>그래서 <strong>DB 는 계층적 (다중) 그레인 + 의도 락</strong>을 써서 서로 다른 크기 트랜잭션이 충돌 없이 공존하도록 설계한다.</li><li>실무에선 <strong>시스템 자원 (메모리)</strong>, <strong>트랜잭션 패턴 (짧고 많은가, 긴가)</strong>, <strong>에스컬레이션 정책</strong>을 먼저 정의하고, 벤치마크로 목표 수치 (예: 잠금 획득 시간, 메모리 한도) 를 검증한다.</li></ul><h5 id=락-그레인-전제조건과-운영요구>락 그레인 전제조건과 운영요구<a hidden class=anchor aria-hidden=true href=#락-그레인-전제조건과-운영요구>#</a></h5><h6 id=특징에-대한-근거-왜-그런-특성이-나타나는가>특징에 대한 근거 (왜 그런 특성이 나타나는가)<a hidden class=anchor aria-hidden=true href=#특징에-대한-근거-왜-그런-특성이-나타나는가>#</a></h6><ul><li><strong>미세 그레인 → 높은 동시성 / 높은 오버헤드</strong>: 각 미세 락은 메타데이터를 저장·관리해야 하므로 메모리/관리 오버헤드가 증가. 과도 시 DB 는 에스컬레이션을 통해 리소스 회복.</li><li><strong>의도 락의 등장 이유</strong>: 테이블 - 페이지 - 레코드 같은 트리 구조에서 하위 락의 존재를 상위가 미리 알지 못하면 호환성 판정이 어려워져 의도 락으로 해결.</li><li><strong>데드락 탐지 요구</strong>: 분산·동시 작업 증가로 순환 대기 가능성이 커져 실시간 탐지·자동화가 필수.</li></ul><h6 id=등장-이전-관련-기술과의-차별점>등장 이전 관련 기술과의 차별점<a hidden class=anchor aria-hidden=true href=#등장-이전-관련-기술과의-차별점>#</a></h6><ul><li><p><strong>단일 전역 락 / 파일·테이블 수준 락</strong></p><ul><li><em>이전 방식</em>: 전체 자원을 하나의 락으로 보호 (간단하지만 동시성 제한).</li><li><em>차별점</em>: 락 그레인 (계층적) 도입으로 작은 트랜잭션은 더 작은 자원만 잠금 → 동시성 향상.</li></ul></li><li><p><strong>MVCC / 낙관적 제어 (OCC)</strong></p><ul><li><em>차별점</em>: MVCC 는 읽기 동작에서 락을 회피 (버전 기반), 락 그레인은 쓰기 충돌 제어에서 중요—즉 MVCC 는 읽기/쓰기 충돌을 다른 방식으로 해결하므로 락 그레인과는 보완적 관계.</li></ul></li></ul><h5 id=락-그레인-전제요구-요약표>락 그레인 전제·요구 요약표<a hidden class=anchor aria-hidden=true href=#락-그레인-전제요구-요약표>#</a></h5><table><thead><tr><th>구분</th><th>항목</th><th style=text-align:right>설명</th><th>권장값 / 운영노트</th></tr></thead><tbody><tr><td>기술 전제</td><td>트랜잭션·ACID 이해</td><td style=text-align:right>락은 트랜잭션 일관성 도구</td><td>설계 전 필수</td></tr><tr><td>기술 전제</td><td>저장 구조 지식</td><td style=text-align:right>테이블/페이지/레코드 구조 이해</td><td>DB 엔진 문서 숙지</td></tr><tr><td>기술 전제</td><td>동시성·교착 지식</td><td style=text-align:right>2PL·데드락 원리 이해</td><td>교육·리뷰 필요</td></tr><tr><td>시스템 요구</td><td>멀티스레딩 OS</td><td style=text-align:right>병렬 트랜잭션 처리 환경</td><td>상시 지원</td></tr><tr><td>시스템 요구</td><td>메모리 (락 테이블)</td><td style=text-align:right>락 메타데이터 저장용</td><td>전체 메모리의 설계기준 (예: ≤5%)</td></tr><tr><td>시스템 요구</td><td>로그/복구</td><td style=text-align:right>롤백·복구를 위한 로그 시스템</td><td>고가용성 설계</td></tr><tr><td>시스템 요구</td><td>모니터링 도구</td><td style=text-align:right>락/대기/데드락 지표 수집</td><td>알람·대시보드 필수</td></tr><tr><td>성능 목표</td><td>잠금 획득/해제 시간</td><td style=text-align:right>응답성 목표 (메모리 OLTP 기준)</td><td>마이크로초 단위 (환경별 벤치)</td></tr><tr><td>성능 목표</td><td>메모리 오버헤드</td><td style=text-align:right>락 메타데이터 한도</td><td>설계값 (예: ≤5%) 로 시작, 검증 필요</td></tr><tr><td>성능 목표</td><td>데드락 탐지 시간</td><td style=text-align:right>운영 탐지·복구 목표</td><td>초 단위 알림·자동 조치</td></tr></tbody></table><p>락 그레인 설계는 &rsquo; 동시성 (성능) 과 관리 오버헤드 (메모리·운영 복잡도)&rsquo; 사이의 균형 설계 문제다. 엔지니어는 먼저 트랜잭션 패턴 (짧은 OLTP vs 긴 배치), 하드웨어 (메모리), DB 엔진의 에스컬레이션 동작을 정의하고, 모니터링·알람·에스컬레이션 정책을 운영 규정으로 명문화해야 한다. 목표 성능 (예: 잠금 획득 마이크로초, 데드락 탐지 초 단위) 은 반드시 벤치마크를 통해 실측·확정한다.</p><h4 id=잠금-세분성-특징근거실무적-의미>잠금 세분성: 특징·근거·실무적 의미<a hidden class=anchor aria-hidden=true href=#잠금-세분성-특징근거실무적-의미>#</a></h4><p>잠금 세분성은 &rsquo; 어떤 단위 (테이블, 페이지, 행 등) 를 잠글 것인가 &rsquo; 의 결정이다. 작은 단위는 많은 트랜잭션이 동시에 작업할 수 있게 해 동시성을 높이지만, 잠금 개수가 늘어나 메타데이터 관리·탐색·데드락 가능성이 커진다. 이를 해결하기 위해 대부분 DB 는 계층 구조와 의도잠금으로 빠르게 충돌 여부를 판단하고, 저수준 잠금이 급증하면 에스컬레이션으로 메타데이터를 제어한다. 범위 질의가 많으면 키 - 범위 잠금으로 팬텀을 막아야 한다. 실무에서는 워크로드 특성에 따라 그레인을 선택하고, 에스컬레이션 임계값과 모니터링을 반드시 설정한다.</p><h5 id=잠금-세분성-특징-비교표>잠금 세분성 특징 비교표<a hidden class=anchor aria-hidden=true href=#잠금-세분성-특징-비교표>#</a></h5><table><thead><tr><th>특징</th><th>기술적 설명 (요약)</th><th style=text-align:right>기술적 근거</th><th>실무적 차별점</th></tr></thead><tbody><tr><td>계층적 구조</td><td>상위 - 하위 포함 관계로 락 검사 비용 감소</td><td style=text-align:right>상위에서 의도 표시만 확인하면 하위 전수조사 불필요</td><td>플랫 구조 대비 락 검사 비용·지연 절감</td></tr><tr><td>의도 잠금</td><td>IS/IX 등으로 하위 락 의도 표기</td><td style=text-align:right>상위에서 하위 락 존재 여부를 상수 검사 가능</td><td>단일 S/X 모델 대비 동시성 향상</td></tr><tr><td>에스컬레이션</td><td>저수준 락 폭증 시 상위로 전환</td><td style=text-align:right>메타데이터 (락 테이블) 폭증 방지</td><td>메모리 절감 vs 일시적 동시성 저하 트레이드오프</td></tr><tr><td>키 - 범위 잠금</td><td>인덱스 범위/프레디킷 단위로 잠금</td><td style=text-align:right>팬텀 방지 (직렬화 보장)</td><td>단순 행락만의 시스템 대비 팬텀 제어 가능</td></tr><tr><td>호환성 매트릭스</td><td>락 모드 간 허용/불허 규칙 표준화</td><td style=text-align:right>충돌 판단을 수학적 표로 단순화</td><td>복합 모드 지원으로 유연한 동시성 정책 가능</td></tr></tbody></table><p>잠금 세분성의 핵심은 <strong>&rsquo; 동시성 증대 (미세 그레인)&rsquo; 와 &rsquo; 관리 오버헤드 억제 (거친 그레인)&rsquo; 의 균형</strong>을 계층적 설계·의도락·에스컬레이션·범위잠금·호환성 매트릭스로 운영적으로 풀어낸다는 점이다. 실제 적용은 DBMS 구현 방식과 워크로드 특성에 따라 달라지므로, 벤치마크와 모니터링을 통한 정교한 튜닝이 필요하다.</p><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=락-세분성-설계-원칙과-실무철학>락 세분성 설계 원칙과 실무철학<a hidden class=anchor aria-hidden=true href=#락-세분성-설계-원칙과-실무철학>#</a></h4><p>락 세분성 설계는 <strong>어디까지 잠글 것인가</strong>를 결정하는 일이다. 핵심 원칙은 ① <strong>2PL</strong>로 트랜잭션의 직렬성을 보장하고, ② <strong>최소 권한</strong>으로 필요한 데이터만 잠그며, ③ <strong>의도락/계층적 락</strong>으로 상위·하위 그레인의 일관성을 관리하는 것이다. 실무 철학은 " 작게 시작해 (행 단위) 계측하면서 필요하면 크게 올린다 " 와 " 측정→시작→튜닝 " 이다. 즉, 먼저 행·키 단위로 락을 적용해 동시성을 높이고, 모니터링 지표 (대기시간·데드락·핫스팟) 를 보며 에스컬레이션이나 파티셔닝, MVCC 병행 등을 적용하는 방식이 안전하고 효율적이다.</p><h5 id=락-핵심-원칙-요약표>락 핵심 원칙 요약표<a hidden class=anchor aria-hidden=true href=#락-핵심-원칙-요약표>#</a></h5><table><thead><tr><th>원칙</th><th>설명 (요약)</th><th>목적 (무엇을 위한)</th><th>왜 필요한가 (이유/효과)</th><th>운영 포인트</th></tr></thead><tbody><tr><td>2PL (Two-Phase Locking)</td><td>성장·수축 단계로 락 관리</td><td>직렬성 보장</td><td>강한 일관성·무결성 확보</td><td>Strict vs non-strict 선택, 커밋 시 해제 정책</td></tr><tr><td>최소 권한 원칙</td><td>트랜잭션은 최소 범위만 잠금</td><td>동시성 극대화</td><td>불필요 블로킹·데드락 감소</td><td>그레인 (행/범위) 선택, 트랜잭션 경계 단축</td></tr><tr><td>계층 일관성 / 의도락</td><td>상위에 IS/IX 올려 하위 관리</td><td>다중 그레인 일관성</td><td>검사 비용 절감, 불필요 전역 락 회피</td><td>의도락 상태 검사, 에스컬레이션 정책</td></tr></tbody></table><p>이 표는 락 설계에서 반드시 고려해야 할 세 가지 원칙을 한눈에 보여준다. 2PL 은 이론적 직렬성을 제공하고, 최소 권한은 실무적 성능을 지탱하며, 의도락은 계층적 환경에서 락 검사 비용을 줄여준다. 운영에서는 각 원칙의 구현 세부 (Strict 2PL 여부, 그레인 선택, 에스컬레이션 임계치) 를 워크로드 기반으로 결정해야 한다.</p><h5 id=락-설계-철학-요약표>락 설계 철학 요약표<a hidden class=anchor aria-hidden=true href=#락-설계-철학-요약표>#</a></h5><table><thead><tr><th>설계 철학</th><th>설명 (요약)</th><th>목적 (무엇을 위한)</th><th>왜 필요한가 (이유/효과)</th><th>실무 적용 예</th></tr></thead><tbody><tr><td>작게 잠그고 필요시 크게 올린다</td><td>기본은 세밀 그레인 → 필요 시 에스컬레이트</td><td>초기 동시성 확보 + 운영 비용 제어</td><td>대부분 국부적 접근에 최적, 에스컬레이션으로 복구</td><td>행단위 시작 → 핫스팟시 파티셔닝/에스컬레이션</td></tr><tr><td>계측 기반 조정</td><td>측정 → 작은 범위 적용 → 튜닝 반복</td><td>워크로드 변화에 적응</td><td>정적 규칙보다 현실적 성능 보장</td><td>Prometheus 지표 기반 정책 변경</td></tr></tbody></table><p>설계 철학은 구현 규칙이 아니라 _ 행동 원칙 _ 이다. 먼저 세밀하게 잠그고 (동시성 확보), 모니터링해 문제 발생 시 에스컬레이션 또는 아키텍처 변경 (파티셔닝, MVCC 병행) 을 적용한다. 이 과정을 자동화·문서화하면 운영 안정성이 커진다.</p><h4 id=잠금-동작-원리와-운영-메커니즘>잠금 동작 원리와 운영 메커니즘<a hidden class=anchor aria-hidden=true href=#잠금-동작-원리와-운영-메커니즘>#</a></h4><ul><li>데이터베이스는 데이터를 계층 (데이터베이스→테이블→페이지→행) 으로 보고, <strong>하위 항목을 잠그기 전에 상위에 &rsquo; 의도 &rsquo; 를 먼저 표시</strong>한다.</li><li>이것 (의도락) 을 통해 DB 는 " 어떤 트랜잭션이 어떤 수준에서 무엇을 하려는지 " 를 빠르게 파악하고, 불필요한 전체 스캔을 피해 동시성을 높인다.</li><li>만약 많은 세부 잠금이 쌓이면 시스템은 자동으로 <strong>락 승격</strong>을 해 관리비용을 줄이지만, 이로 인해 동시성이 떨어질 수 있다.</li><li>요약: <strong>의도락 → 호환성 검사 → 획득/대기 → (필요 시) 승격/변환 → 해제</strong> 의 반복으로 안전한 동시성이 유지된다.</li></ul><h5 id=잠금-계층메커니즘-원리>잠금 계층·메커니즘 원리<a hidden class=anchor aria-hidden=true href=#잠금-계층메커니즘-원리>#</a></h5><h6 id=계층적-잠금-구조-hierarchy>계층적 잠금 구조 (Hierarchy)<a hidden class=anchor aria-hidden=true href=#계층적-잠금-구조-hierarchy>#</a></h6><ul><li><strong>무엇</strong>: DB → Tablespace → Table → Page → Row 형태의 트리 구조.</li><li><strong>왜</strong>: 상위 단위에서 충돌 여부를 빠르게 판정해 하위 검사 비용 절감.</li><li><strong>어떻게</strong>: 상위 노드에 IS/IX 를 설정하고, 하위에서 실제 S/X 를 요청하면 의도락 호환성 검사 후 진행.</li></ul><h6 id=의도-잠금-intention-locks-isixsix>의도 잠금 (Intention Locks: IS/IX/SIX)<a hidden class=anchor aria-hidden=true href=#의도-잠금-intention-locks-isixsix>#</a></h6><ul><li><strong>무엇</strong>: 하위 락 의도를 상위에 표기하는 락 모드.</li><li><strong>왜</strong>: 전체 스캔·상위 검사 비용 절감, 동시성 유지.</li><li><strong>어떻게</strong>: 예: 행 S-Lock 요구 시 부모 페이지·테이블에 IS 세팅; 행 X-Lock 전에 IS→(필요 시)IX 로 표기.</li></ul><h6 id=호환성-검사-compatibility>호환성 검사 (Compatibility)<a hidden class=anchor aria-hidden=true href=#호환성-검사-compatibility>#</a></h6><ul><li><strong>무엇</strong>: 두 락 모드가 동시에 허용되는지 판정하는 매트릭스.</li><li><strong>왜</strong>: 충돌을 만들지 않기 위해.</li><li><strong>어떻게</strong>: Lock Manager 가 해당 노드의 현재 소유자들과 호환성 표를 비교해 승인/대기 결정.</li></ul><h6 id=락-획득-순서--컨버전-acquisition--conversion>락 획득 순서 & 컨버전 (Acquisition & Conversion)<a hidden class=anchor aria-hidden=true href=#락-획득-순서--컨버전-acquisition--conversion>#</a></h6><ul><li><strong>무엇</strong>: 상위 의도락 → 하위 실제락 순으로 획득; 필요 시 S→X 변환.</li><li><strong>왜</strong>: 안전한 동시성 보장 및 최소한의 탐색 비용.</li><li><strong>어떻게</strong>: 컨버전 시점에 호환성 재검사 및 대기/데드락 가능성 존재.</li></ul><h6 id=락-승격-escalation>락 승격 (Escalation)<a hidden class=anchor aria-hidden=true href=#락-승격-escalation>#</a></h6><ul><li><strong>무엇</strong>: 다수의 세부락을 하나의 상위 (거친) 락으로 전환.</li><li><strong>왜</strong>: 락 테이블 메모리·관리 오버헤드 절감.</li><li><strong>어떻게</strong>: 임계값 (예: 트랜잭션이 보유한 행락 수) 초과 시 자동 승격; 승격 정책·임계값 제어 가능.</li></ul><h6 id=키---범위프레디킷-락-range--predicate-lock>키 - 범위/프레디킷 락 (Range / Predicate Lock)<a hidden class=anchor aria-hidden=true href=#키---범위프레디킷-락-range--predicate-lock>#</a></h6><ul><li><strong>무엇</strong>: 인덱스 범위나 프레디킷 단위 잠금으로 팬텀 방지.</li><li><strong>왜</strong>: 반복 가능한 읽기 이상에서 팬텀 현상 제거 (Serializable 보장).</li><li><strong>어떻게</strong>: 범위잠금 (gap-lock) 또는 predicate-lock 을 사용해 삽입/삭제로 인한 팬텀을 차단.</li></ul><h6 id=데드락-형성-및-처리-deadlock>데드락 형성 및 처리 (Deadlock)<a hidden class=anchor aria-hidden=true href=#데드락-형성-및-처리-deadlock>#</a></h6><ul><li><strong>무엇</strong>: 트랜잭션들이 서로 상대의 락을 기다려 순환 대기 상태.</li><li><strong>왜</strong>: 데드락은 가용성·응답성 저해.</li><li><strong>어떻게</strong>: 탐지 (Wait-for 그래프) → victim 선정 → abort/rollback → 해제; 또는 회피 (타임아웃/정책).</li></ul><h5 id=잠금-기본-동작>잠금 기본 동작<a hidden class=anchor aria-hidden=true href=#잠금-기본-동작>#</a></h5><ol><li><strong>획득 순서</strong>: 트랜잭션이 하위 리소스 (행 등) 를 잠그려면 먼저 모든 상위 노드에 적절한 의도락 (IS/IX) 을 걸어야 함.</li><li><strong>호환성 검사</strong>: Lock Manager 가 현재 소유 락과 요청 락의 호환성 매트릭스를 비교하여 승인 또는 대기.</li><li><strong>동시 접근 처리</strong>: 여러 트랜잭션이 공유 읽기 (S) 를 허용받을 수 있으나, X 가 존재하면 모두 차단.</li><li><strong>컨버전</strong>: 처음 S 로 읽다가 쓰기로 전환하면 S→X 컨버전이 일어나며 이 시점에 대기/데드락 유발 가능.</li><li><strong>승격 정책</strong>: 다수의 세부 락이 누적되면 자동으로 상위 락 (예: 테이블) 으로 승격하여 락 테이블 사용량을 줄임.</li><li><strong>범위 락</strong>: 팬텀 방지를 위해 범위 단위 잠금이 쓰임 (인덱스 설계 영향).</li><li><strong>해제</strong>: 트랜잭션 커밋/롤백 시 모든 락 해제 → 대기 큐 순서대로 다음 승인.</li></ol><table><thead><tr><th>항목</th><th>동작 / 규칙</th><th>핵심 포인트</th></tr></thead><tbody><tr><td>획득 순서</td><td>상위 (IS/IX) → 하위 (S/X)</td><td>상위에 의도 표기 후 실제 락 요청</td></tr><tr><td>호환성</td><td>호환성 매트릭스에 따라 승인/대기</td><td>S 는 S 와 호환, X 는 모두 불허</td></tr><tr><td>컨버전</td><td>S → X 변환 가능</td><td>변환 시 재검사·대기·데드락 가능</td></tr><tr><td>승격</td><td>세부락 다수 → 상위 락 전환</td><td>메모리 절감 vs 동시성 저하</td></tr><tr><td>범위 락</td><td>인덱스 범위 잠금으로 팬텀 방지</td><td>인덱스 설계와 밀접</td></tr><tr><td>데드락 처리</td><td>탐지 (Wait-for) → victim abort</td><td>타임아웃/재시도 정책 필요</td></tr><tr><td>해제</td><td>커밋/롤백 시 전체 해제</td><td>대기 큐 승계 → 성능 지표 관찰 필요</td></tr></tbody></table><p>상위에 의도락을 먼저 걸어 하위 락의 충돌을 사전 판별하고, 호환성 매트릭스에 따라 락을 승인한다. 컨버전·승격·범위락·데드락 처리가 실제 운영에서 주된 복잡도를 만든다.</p><h5 id=잠금-획득대기해제-흐름도>잠금 획득·대기·해제 흐름도<a hidden class=anchor aria-hidden=true href=#잠금-획득대기해제-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  T[트랜잭션 시작] --&gt; R[&#34;리소스 접근 요청(레코드)&#34;]
  R --&gt; A[상위 노드 순회: Table -&gt; Page -&gt; Row]
  A --&gt; B[상위에 IS/IX 설정 요청]
  B --&gt; C[Lock Manager: 호환성 검사]
  C --&gt;|호환| D[&#34;하위 실제락(S/X) 부여&#34;]
  C --&gt;|비호환| E[대기 큐에 추가]
  E --&gt; F{데드락/타임아웃 검사}
  F --&gt;|데드락 탐지| G[Victim 선정 → Abort]
  F --&gt;|타임아웃| H[트랜잭션 중단/재시도]
  D --&gt; I{트랜잭션 동작: 읽기/쓰기}
  I --&gt; J{트랜잭션 완료?}
  J --&gt;|아니오| R
  J --&gt;|예| K[커밋/롤백 → 락 해제]
  K --&gt; L[대기 큐에서 다음 승인]
</pre><p>이 흐름도는 트랜잭션이 특정 리소스 (행) 를 접근하려 할 때의 표준적 절차를 보여준다. 먼저 상위 노드들 (테이블→페이지 등) 에 <strong>의도락</strong>을 요청하고, Lock Manager 가 현재 소유자들과의 <strong>호환성 검사</strong>를 수행한다. 호환하면 하위 실제락 (S/X) 을 부여하고 작업을 실행한다. 비호환이면 대기 큐에 들어가며, 대기 중에는 <strong>데드락 탐지</strong>와 <strong>타임아웃/재시도 정책</strong>이 작동한다. 작업 종료 (커밋/롤백) 시 모든 락을 해제하고 대기 큐에서 다음 트랜잭션을 승계한다. 운영상 MVCC, 컨버전 경로, 승격 트리거, 모니터링 훅을 반드시 반영해야 안전하고 관측 가능한 시스템이 된다.<br>``</p><h4 id=락-입도-lock-granularity-데이터제어-흐름-가이드>락 입도 (lock granularity) 데이터·제어 흐름 가이드<a hidden class=anchor aria-hidden=true href=#락-입도-lock-granularity-데이터제어-흐름-가이드>#</a></h4><p>트랜잭션이 데이터를 건드릴 때는 먼저 <strong>잠금 요청</strong>을 하고, 잠금 관리자가 <strong>다른 잠금과 충돌하는지 검사</strong>한다.<br>충돌이 없으면 작업하고, 있으면 대기열에 들어간다.<br>많은 행을 잠그면 시스템은 자동으로 <strong>상위 단위로 락을 바꿔 (에스컬레이션)</strong> 메타데이터 부담을 줄인다.<br>전체 흐름을 모니터링해 <code>lock wait time</code>, <code>deadlock</code> 등을 관리해야 서비스가 안정적으로 돌아간다.</p><h5 id=락-제어-원리와-운영-포인트>락 제어 원리와 운영 포인트<a hidden class=anchor aria-hidden=true href=#락-제어-원리와-운영-포인트>#</a></h5><h6 id=핵심-엔티티-및-역할>핵심 엔티티 및 역할<a hidden class=anchor aria-hidden=true href=#핵심-엔티티-및-역할>#</a></h6><ul><li><strong>트랜잭션 (T)</strong>: 락 요청자.</li><li><strong>Lock Manager(LM)</strong>: 락 객체 생성/조회/호환성 검사/대기큐 관리/에스컬레이션 결정.</li><li><strong>Lock Object(LO)</strong>: 실제 락 단위 (레코드/페이지/테이블) 와 상태 (소유자, 대기자).</li><li><strong>데이터 관리자 (DM)</strong>: 버퍼 읽기/쓰기, 물리 I/O 연계 (버퍼 플러시와 락 타이밍 고려).</li><li><strong>Deadlock Detector(DD)</strong>: Wait-for Graph 생성, 주기적 또는 이벤트 기반 탐지.</li><li><strong>Transaction Manager(TM)</strong>: 트랜잭션 상태 및 커밋/롤백 처리 (락 해제 트리거).</li></ul><h6 id=흐름-핵심-포인트>흐름 핵심 포인트<a hidden class=anchor aria-hidden=true href=#흐름-핵심-포인트>#</a></h6><ol><li><strong>하향 획득 (Top-down)</strong>: 트랜잭션은 루트 (테이블) 에서 의도락 (IS/IX) 를 표시 → 하위 (페이지/row) 로 내려가 실제 S/X 획득.</li><li><strong>호환성 검사</strong>: LM 은 현재 LO 의 모드와 요청 모드가 충돌하는지 검사 (Compatibility Matrix).</li><li><strong>대기 처리</strong>: 충돌 시 LM 이 대기큐에 넣음; Wait-for Graph 에 엣지 추가.</li><li><strong>데드락 탐지</strong>: DD 가 사이클 발견 시 victim 선정 → TM 에게 강제 롤백 명령.</li><li><strong>에스컬레이션</strong>: LO 수가 임계치를 넘으면 LM 이 비용 계산 후 상위 락으로 전환 (기존 하위 락들 해제 → 상위 락 설정).</li><li><strong>해제 (상향)</strong>: 트랜잭션 커밋/롤백 시 하위 락부터 해제 → 상위 락 해제. 이는 2PL 의 Growing→Shrinking 과 일치.</li></ol><h6 id=운영-권장>운영 권장<a hidden class=anchor aria-hidden=true href=#운영-권장>#</a></h6><ul><li>의도락/호환성 규칙 숙지 (특히 IS/IX 조합).</li><li>에스컬레이션 임계치는 워크로드 (locks/tx, 메모리) 기준으로 튜닝.</li><li>Wait-for Graph 로그를 보존해 반복 패턴 (업데이트 순서 역전 등) 분석.</li><li>모니터링: lock wait time, blocking chain length, escalation events, long-running tx.</li></ul><h5 id=데이터제어-흐름-표락-획득-데이터제어-흐름표>데이터·제어 흐름 표락 획득 데이터·제어 흐름표<a hidden class=anchor aria-hidden=true href=#데이터제어-흐름-표락-획득-데이터제어-흐름표>#</a></h5><table><thead><tr><th>단계</th><th>액터</th><th style=text-align:right>입력/조건</th><th>동작 (제어)</th><th>결과 (데이터)</th><th>운영 지표</th></tr></thead><tbody><tr><td>1. 요청</td><td>트랜잭션</td><td style=text-align:right>리소스 ID, 모드 (S/X)</td><td>LM 에 Lock Request 전송</td><td>LO 조회/생성</td><td>request rate</td></tr><tr><td>2. 호환성 검사</td><td>LM</td><td style=text-align:right>현재 LO 상태</td><td>Compatibility Matrix 검사</td><td>승인 또는 대기 등록</td><td>granted ratio</td></tr><tr><td>3a. 승인 (즉시)</td><td>LM → T</td><td style=text-align:right>호환 가능</td><td>Lock 부여, 의도락 갱신</td><td>트랜잭션이 데이터 접근</td><td>lock hold time</td></tr><tr><td>3b. 대기</td><td>LM</td><td style=text-align:right>충돌</td><td>대기큐에 enqueue, Wait-for Graph 엣지 추가</td><td>blocked state</td><td>wait queue length</td></tr><tr><td>4. 데드락 감지</td><td>DD</td><td style=text-align:right>주기/이벤트</td><td>Wait-for Graph 에서 사이클 탐지</td><td>victim 선정/알림</td><td>deadlock count</td></tr><tr><td>5. 에스컬레이션</td><td>LM</td><td style=text-align:right>locks/LO 수 > threshold</td><td>행락 해제 → 테이블/페이지 락 설정</td><td>락 오브젝트 수 감소</td><td>escalation rate</td></tr><tr><td>6. 해제</td><td>TM</td><td style=text-align:right>커밋/롤백</td><td>하위 락부터 해제 → 상위 락 해제</td><td>LO 상태 갱신, 대기자 승인</td><td>lock release latency</td></tr></tbody></table><ul><li>트랜잭션은 <strong>요청→검사→획득/대기→작업→해제</strong> 순으로 진행되며, 락 호환성 검사와 대기큐 관리는 Lock Manager 의 핵심 기능이다.</li><li>데드락 해결은 Deadlock Detector(Wait-for Graph) 와 victim selection 정책에 의존한다.</li><li>에스컬레이션은 메타데이터 폭주를 막지만 동시성을 악화시킬 수 있어 임계값·히스테리시스 설계가 필수다.</li><li>운영 관점에서 <code>granted ratio</code>, <code>wait queue length</code>, <code>deadlock count</code>, <code>escalation rate</code> 같은 지표를 수집해 자동화/조정 루틴을 만드는 것이 중요하다.</li></ul><h5 id=락-제어-데이터제어-흐름도>락 제어 데이터·제어 흐름도<a hidden class=anchor aria-hidden=true href=#락-제어-데이터제어-흐름도>#</a></h5><pre class=mermaid>graph LR
  T[트랜잭션] --&gt;|1. Lock Request| LM(잠금 관리자)
  LM --&gt;|2. Check Compatibility| LO[Lock Object]
  LO --&gt;|호환 가능| LM
  LM --&gt;|3a. Grant Lock| T
  LM --&gt;|3b. Enqueue| WQ[Wait Queue]
  WQ --&gt;|Wait-for Edge 생성| WFG[Wait-for Graph]
  WFG --&gt;|Deadlock Detect| DD[Deadlock Detector]
  DD --&gt;|Victim Selected| TM[Transaction Manager]
  TM --&gt;|Force Rollback| T
  T --&gt;|4. Data Access| DM[데이터 관리자]
  T --&gt;|5. Commit/Rollback| TM
  TM --&gt;|&#34;6. Release Locks (하위→상위)&#34;| LM
  LM --&gt;|7. Escalation Check| Esc[Escalation]
  Esc --&gt;|If threshold| LM
  LM --&gt;|Notify| M[Monitoring/Alert]
</pre><ul><li>트랜잭션이 Lock Request 를 보내면 Lock Manager 가 <strong>의도락 업데이트 → 하위 Lock 조회/호환성 검사</strong>를 수행한다.</li><li>충돌 시 대기큐에 들어가고 Wait-for Graph 에 엣지가 추가된다. Deadlock Detector 가 사이클을 찾으면 Transaction Manager 에게 희생자 롤백을 요청한다.</li><li>Lock 해제 (커밋/롤백) 는 하위 락부터 상위 락 순으로 이루어지며, Lock Manager 는 주기적으로 에스컬레이션 임계치를 확인하여 필요 시 상위 락으로 변환한다. 모든 주요 이벤트는 모니터링으로 송신되어 운영 알람·지표를 형성한다.</li></ul><h5 id=잠금-획득-생명주기-시퀀스>잠금 획득 생명주기 시퀀스<a hidden class=anchor aria-hidden=true href=#잠금-획득-생명주기-시퀀스>#</a></h5><pre class=mermaid>sequenceDiagram
  participant T as 트랜잭션
  participant LM as Lock Manager
  participant LO as Lock Object
  participant WQ as Wait Queue
  participant DD as Deadlock Detector
  participant TM as Transaction Manager
  participant DM as Data Manager

  T-&gt;&gt;LM: 1. begin + Lock Request(resource, mode)
  LM-&gt;&gt;LM: 2. update Intention Lock (IS/IX)
  LM-&gt;&gt;LO: 3. check compatibility
  alt compatible
    LO--&gt;&gt;LM: ok
    LM--&gt;&gt;T: 4a. grant lock
    T-&gt;&gt;DM: 5a. read/write
    DM--&gt;&gt;T: 6a. data returned
  else not compatible
    LM--&gt;&gt;T: 4b. enqueue in WQ
    WQ--&gt;&gt;DD: 5b. notify (new wait edge)
    DD--&gt;&gt;TM: 6b. (if cycle) request victim
    TM--&gt;&gt;Victim: 7b. rollback
    Victim--&gt;&gt;LM: 8b. locks released
    LM--&gt;&gt;WaitingTx: 9b. grant lock (when available)
  end
  T-&gt;&gt;TM: 10. commit/rollback
  TM-&gt;&gt;LM: 11. release locks (child-&gt;parent)
  LM-&gt;&gt;LM: 12. check escalation thresholds
  alt escalate
    LM-&gt;&gt;LM: 13. convert locks -&gt; higher granularity
  end
</pre><ul><li>시퀀스는 트랜잭션의 시작 (락 요청) 부터 커밋/롤백 (락 해제) 까지의 메시지 흐름을 자세히 보여준다. 데드락 상황에서는 Deadlock Detector → Transaction Manager → Victim rollback 루틴이 개입한다. 에스컬레이션은 마지막 단계에서 메타데이터 부담을 줄이려 할 때 발생한다.</li></ul><h4 id=lock-manager-종합-구조컴포넌트운영-지침>Lock Manager 종합: 구조·컴포넌트·운영 지침<a hidden class=anchor aria-hidden=true href=#lock-manager-종합-구조컴포넌트운영-지침>#</a></h4><p>락 시스템은 중앙의 <strong>Lock Table</strong>을 통해 현재 누가 어떤 자원을 잠그고 있는지 관리한다.<br>트랜잭션이 락을 요청하면 API 가 Lock Table 을 조회하고, 현재 소유자와의 <strong>호환성 매트릭스</strong>로 허가 여부를 결정한다. 허가되지 않으면 <strong>대기 큐</strong>에 들어가고, 장시간 대기는 <strong>데드락 탐지기</strong>가 주기적으로 검사해 해결한다.<br>락이 많아지면 <strong>에스컬레이션</strong>이 발생해 락 단위가 커져 관리 비용은 줄지만 동시성은 떨어질 수 있다. 분산 환경에서는 <strong>lease/fencing 어댑터</strong>가 외부 코디네이터와 협력해 안전하게 락을 관리한다. 모든 이벤트는 <strong>관측 계층</strong>으로 흘러 모니터링·알람·튜닝에 사용된다.</p><h5 id=락-구조-데이터-흐름컴포넌트-관계-지도>락 구조: 데이터 흐름·컴포넌트 관계 지도<a hidden class=anchor aria-hidden=true href=#락-구조-데이터-흐름컴포넌트-관계-지도>#</a></h5><ul><li>Lock Table: 누가 무엇을 잠그는지 기록하는 중앙 레지스터.</li><li>Wait Queue: 락을 못 얻은 트랜잭션이 줄서는 곳.</li><li>Deadlock Detector: 교착이 생기면 누굴 쓰러뜨릴지 판단하는 감시자.</li><li>Escalation Scheduler: 락이 너무 많아지면 상위 단위로 합치는 관리자.</li><li>Fencing Adapter: 분산 상황에서 &rsquo; 이 요청은 유효하다 &rsquo; 고 증명하는 안전장치.</li><li>Metrics: 지표 모아 문제를 빨리 찾게 해주는 도구.</li></ul><h6 id=락-아키텍처-요소별-역할-표>락 아키텍처 요소별 역할 표<a hidden class=anchor aria-hidden=true href=#락-아키텍처-요소별-역할-표>#</a></h6><table><thead><tr><th>구성요소</th><th>설명</th><th style=text-align:right>역할</th><th>주요 기능</th><th>특징 / 상호관계</th></tr></thead><tbody><tr><td>Lock Table</td><td>활성 락 엔트리 저장</td><td style=text-align:right>중앙 상태 레지스터</td><td>엔트리 생성/삭제/조회</td><td>해시/B+-Tree 선택, Wait Queue 와 연결</td></tr><tr><td>Wait Queue</td><td>대기 트랜잭션 목록</td><td style=text-align:right>대기 관리</td><td>등록·우선순위·타임아웃</td><td>각 락 엔트리와 1:1 연결</td></tr><tr><td>Compatibility Matrix</td><td>모드 간 허용 룩업</td><td style=text-align:right>허용 판정</td><td>O(1) 룩업</td><td>Lock Table 의 현재 모드 참조</td></tr><tr><td>Deadlock Detector</td><td>교착 탐지기</td><td style=text-align:right>교착 확인·해결</td><td>그래프 생성·순환 탐지·victim 선정</td><td>Lock Table·Wait Queue 읽음</td></tr><tr><td>Escalation Scheduler</td><td>락 승격 관리자</td><td style=text-align:right>락 수 제어</td><td>모니터링·승격 실행</td><td>Lock Table 상태 변경 → Wait Queue 재계산</td></tr><tr><td>API Layer</td><td>클라이언트 인터페이스</td><td style=text-align:right>락 요청/응답 중개</td><td>acquire/release/status</td><td>트랜잭션 관리자와 연동</td></tr><tr><td>Metrics</td><td>관측 계층</td><td style=text-align:right>모니터링·알람</td><td>지표 수집·대시·알람</td><td>모든 컴포넌트 이벤트 수집</td></tr><tr><td>Fencing Adapter</td><td>분산 연동층</td><td style=text-align:right>분산 안전 보장</td><td>lease/fencing token 관리</td><td>외부 코디네이터와 통신</td></tr></tbody></table><p>Lock Table 이 중심이며, Wait Queue·Compatibility Matrix 가 실시간 허가 결정을 돕는다. Deadlock Detector 와 Escalation Scheduler 는 운영 안정성과 메모리 제어를 담당하고, API Layer 와 Metrics 는 외부와의 인터페이스·관측을 담당한다. Fencing Adapter 는 분산 환경 특수 요구를 처리한다.</p><h6 id=운영실행-관점의-구성요소-속성표>운영·실행 관점의 구성요소 속성표<a hidden class=anchor aria-hidden=true href=#운영실행-관점의-구성요소-속성표>#</a></h6><table><thead><tr><th>구성요소</th><th style=text-align:right>필수/선택</th><th style=text-align:right>구현 난이도</th><th style=text-align:right>성능 민감도</th><th>운영 주의사항</th></tr></thead><tbody><tr><td>Lock Table</td><td style=text-align:right>필수</td><td style=text-align:right>중</td><td style=text-align:right>매우 높음</td><td>샤딩/rehash 주기·GC 정책 필요</td></tr><tr><td>Wait Queue</td><td style=text-align:right>필수</td><td style=text-align:right>중</td><td style=text-align:right>높음</td><td>우선순위 정책·starvation 방지 필요</td></tr><tr><td>Compatibility Matrix</td><td style=text-align:right>필수</td><td style=text-align:right>낮</td><td style=text-align:right>중</td><td>확장 모드 존재 시 동적 업데이트 고려</td></tr><tr><td>Deadlock Detector</td><td style=text-align:right>권장 (필수 수준)</td><td style=text-align:right>중</td><td style=text-align:right>중</td><td>탐지 주기·victim 정책 조정 필요</td></tr><tr><td>Escalation Scheduler</td><td style=text-align:right>권장</td><td style=text-align:right>중</td><td style=text-align:right>중</td><td>임계값 튜닝으로 성능 영향 조절</td></tr><tr><td>API Layer</td><td style=text-align:right>필수</td><td style=text-align:right>낮</td><td style=text-align:right>중</td><td>비동기/동기 API 선택 영향 큼</td></tr><tr><td>Metrics</td><td style=text-align:right>필수</td><td style=text-align:right>낮</td><td style=text-align:right>낮 (수집시 부하 고려)</td><td>샘플링 설계 필요</td></tr><tr><td>Fencing Adapter</td><td style=text-align:right>선택 (분산시 필수)</td><td style=text-align:right>높음</td><td style=text-align:right>높음</td><td>외부 코디네이터 의존성·보안 고려</td></tr></tbody></table><p>Lock Table·Wait Queue·API Layer·Compatibility Matrix·Metrics 는 거의 모든 시스템에서 필수적이다. Deadlock Detector·Escalation 은 운영 규모·정책에 따라 권장된다. Fencing Adapter 는 분산 환경에서 필수 요소로서 구현 난이도·외부 의존성을 고려해 신중 도입해야 한다.</p><h6 id=락-매니저-구조-및-데이터-흐름도>락 매니저 구조 및 데이터 흐름도<a hidden class=anchor aria-hidden=true href=#락-매니저-구조-및-데이터-흐름도>#</a></h6><pre class=mermaid>flowchart TB
  subgraph ClientSide
    TX[Transaction / Session]
  end

  subgraph API
    API_Layer[&#34;API Layer&lt;br/&gt;(acquire/release/status)&#34;]
  end

  subgraph LockManager
    LT[Lock Table]
    CM[Compatibility Matrix]
    WQ[Wait Queue]
    DD[Deadlock Detector]
    ES[Escalation Scheduler]
    FA[Fencing / Lease Adapter]
    MT[Metrics &amp; Observability]
  end

  TX --&gt;|&#34;lock_acquire()&#34;| API_Layer
  API_Layer --&gt;|lookup/insert| LT
  API_Layer --&gt; CM
  LT --&gt; WQ
  WQ --&gt; DD
  LT --&gt; ES
  LT --&gt; MT
  WQ --&gt; MT
  DD --&gt;|abort| API_Layer
  FA --- LT
  FA --- API_Layer
  MT --&gt;|alerts| Ops[Operations / Alerting]
</pre><p>다이어그램 요약: 트랜잭션이 API 를 통해 락을 요청하면 API 가 Compatibility Matrix·Lock Table 을 확인한다. 현재 소유자와 충돌하면 Lock Table 의 관련 엔트리의 Wait Queue 에 추가되고, Deadlock Detector 가 주기적으로 Wait Queue/Lock Table 을 살펴 교착을 탐지해 victim(롤백) 결정을 내린다. Escalation Scheduler 는 Lock Table 상태를 모니터링해 필요 시 락을 상위 단위로 승격한다. 분산 환경에서는 Fencing Adapter 가 lease/fencing 토큰으로 외부 코디네이터와 연동해 안전성을 보강한다. Metrics 는 모든 이벤트를 수집해 운영자에게 알림을 준다.</p><h5 id=락-구성요소-역할운영보안-속성>락 구성요소: 역할·운영·보안 속성<a hidden class=anchor aria-hidden=true href=#락-구성요소-역할운영보안-속성>#</a></h5><ul><li><strong>Lock Table</strong>: " 누가 무엇을 잠그는가 " 를 기록하는 핵심 목록.</li><li><strong>Wait Queue</strong>: 잠금 실패한 트랜잭션이 줄 서는 곳 (우선순위 규칙 적용 가능).</li><li><strong>Compatibility Matrix</strong>: 요청한 락이 현재 락들과 충돌하는지 빠르게 결정하는 표.</li><li><strong>Deadlock Detector</strong>: 서로 대기하는 순환이 생기면 해결하도록 모니터링.</li><li><strong>Escalation Scheduler</strong>: 락이 너무 많으면 합쳐서 관리 비용 줄이는 관리자.</li><li><strong>API Layer</strong>: 트랜잭션이 락을 요청/해제하는 인터페이스.</li><li><strong>Metrics</strong>: 문제 감지·튜닝을 위한 데이터 수집기.</li><li><strong>Fencing Adapter</strong>: 분산 환경 안전 보장 모듈.</li></ul><h6 id=구성요소-상세-역할상호관계필수성>구성요소 상세: 역할·상호관계·필수성<a hidden class=anchor aria-hidden=true href=#구성요소-상세-역할상호관계필수성>#</a></h6><table><thead><tr><th>구성요소</th><th>역할</th><th>기능</th><th>특징</th><th>상호관계</th><th style=text-align:right>필수/선택</th><th>속한 구조</th></tr></thead><tbody><tr><td>Lock Table</td><td>중앙 상태 레지스터</td><td>엔트리 관리, lookup</td><td>해시/B+-Tree, 샤딩 가능</td><td>API, WQ, ES, DD 연계</td><td style=text-align:right>필수</td><td>Core</td></tr><tr><td>Wait Queue</td><td>대기 관리</td><td>등록·우선순위·타임아웃</td><td>linked list / priority queue</td><td>LT 엔트리와 1:1</td><td style=text-align:right>필수</td><td>Core</td></tr><tr><td>Compatibility Matrix</td><td>허용 판정</td><td>모드 룩업</td><td>O(1) 테이블</td><td>API→LT 판단</td><td style=text-align:right>필수</td><td>Core</td></tr><tr><td>Deadlock Detector</td><td>교착 탐지/해결</td><td>그래프 생성, victim 선정</td><td>주기/증분 탐지</td><td>LT/WQ 읽음, API 로 abort</td><td style=text-align:right>권장</td><td>Core</td></tr><tr><td>Escalation Scheduler</td><td>락 수 제어</td><td>임계 감지·승격 실행</td><td>자동/수동 모드</td><td>LT 변경 → WQ 재정렬</td><td style=text-align:right>권장</td><td>Core</td></tr><tr><td>API Layer</td><td>인터페이스</td><td>acquire/release/status</td><td>동기/비동기 지원</td><td>TX/LockManager 중개</td><td style=text-align:right>필수</td><td>Interface</td></tr><tr><td>Metrics</td><td>모니터링</td><td>수집·집계·알람</td><td>샘플링 필요</td><td>모든 컴포넌트 feed</td><td style=text-align:right>필수</td><td>Observability</td></tr><tr><td>Fencing Adapter</td><td>분산 안전</td><td>lease, fencing token</td><td>외부 코디네이터 연동</td><td>API↔LT↔Coord 연결</td><td style=text-align:right>선택 (분산시 필수)</td><td>Distributed</td></tr></tbody></table><p>표 요약: Core(핵심) 는 Lock Table·Wait Queue·Compatibility Matrix. Deadlock Detector·Escalation 은 운영 규모에 따라 권장. API·Metrics 는 필수적이며, Fencing Adapter 는 분산 배치 시 필수요소로 취급해야 한다.</p><h6 id=구성요소-운영보안복구-속성표>구성요소 운영·보안·복구 속성표<a hidden class=anchor aria-hidden=true href=#구성요소-운영보안복구-속성표>#</a></h6><table><thead><tr><th>구성요소</th><th style=text-align:right>성능 민감도</th><th>운영 이슈</th><th>보안/권한</th><th>재해복구 (복제)</th></tr></thead><tbody><tr><td>Lock Table</td><td style=text-align:right>매우 높음</td><td>rehash/GC 주기</td><td>접근 제어 필요</td><td>복제·쓰기 순서 보장 필요</td></tr><tr><td>Wait Queue</td><td style=text-align:right>높음</td><td>starvation 모니터링</td><td>트랜잭션 인증</td><td>대기 상태 복원 필요</td></tr><tr><td>Compatibility Matrix</td><td style=text-align:right>중</td><td>모드 변경 시 검증</td><td>모드 정의 권한</td><td>구문/정책 복제</td></tr><tr><td>Deadlock Detector</td><td style=text-align:right>중</td><td>주기 조정 (비용)</td><td>abort 권한 관리</td><td>탐지 상태 복구</td></tr><tr><td>Escalation Scheduler</td><td style=text-align:right>중</td><td>임계값 튜닝</td><td>자동화 권한</td><td>정책 동기화 필요</td></tr><tr><td>API Layer</td><td style=text-align:right>중</td><td>API 안정성·rate limit</td><td>인증·권한·auditing</td><td>endpoint 복제</td></tr><tr><td>Metrics</td><td style=text-align:right>낮</td><td>샘플링 설계</td><td>민감 데이터 마스킹</td><td>중앙화된 스토리지</td></tr><tr><td>Fencing Adapter</td><td style=text-align:right>매우 높음</td><td>외부 코디네이터 의존</td><td>토큰 검증·권한</td><td>코디네이터 복제 필요</td></tr></tbody></table><p>표 요약: Lock Table 과 Fencing Adapter 는 성능·보안·복구 면에서 특별한 주의가 필요하다. 운영적으로는 재해복구 (단일 실패 지점 방지) 와 권한 관리를 반드시 설계해야 한다.</p><h6 id=락-구성요소-상호관계도>락 구성요소 상호관계도<a hidden class=anchor aria-hidden=true href=#락-구성요소-상호관계도>#</a></h6><pre class=mermaid>graph LR
  TX[Transaction] --&gt;|acquire/release| API[API Layer]
  API --&gt; LT[Lock Table]
  LT --&gt; WQ[Wait Queue]
  LT --&gt; CM[Compatibility Matrix]
  WQ --&gt; DD[Deadlock Detector]
  LT --&gt; ES[Escalation Scheduler]
  LT --&gt; MT[Metrics]
  API --&gt; FA[Fencing Adapter]
  FA --&gt; CO[Coord/etcd/ZK]
  MT --&gt; Ops[Operations]
  DD --&gt;|abort/victim| API
  ES --&gt;|escalate| LT
</pre><p>구성 요소 다이어그램은 실제 구현 흐름을 단순화해 보여준다. 트랜잭션이 API 를 호출하면 Lock Table 을 통해 결정되고 대기 시 Wait Queue 에 들어간다. Deadlock Detector 는 Wait Queue 를 스캔해 교착을 해결하고, Escalation Scheduler 는 필요시 락을 합쳐 관리 부담을 줄인다. 분산 환경에서는 Fencing Adapter 가 외부 코디네이터와 연동해 안전한 락 소유권을 보장한다. Metrics 는 중앙 모니터링으로 운영팀에 알림을 제공한다.</p><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=락-그레뉼러리티-장점운영적-가치>락 그레뉼러리티: 장점·운영적 가치<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티-장점운영적-가치>#</a></h4><p>락 그레뉼러리티는 &rsquo; 어떤 단위 (행/페이지/테이블 등) 에 락을 걸어야 효율적인가 &rsquo; 를 결정하는 설계이다.<br>작은 단위는 동시성을 크게 높여 TPS 와 응답성을 개선하지만 락 관리 오버헤드 (메모리·CPU) 가 늘어난다. 큰 단위는 관리와 배치 예측성에 유리하다. 실무에서는 인텐션 락이나 자동 에스컬레이션 같은 계층적 기법으로 두 극단의 장단점을 절충하고, 핫 로우는 샤딩·버켓화로 회피한다.</p><h5 id=락-그레뉼러리티-장점실무-이점표>락 그레뉼러리티 장점·실무 이점표<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티-장점실무-이점표>#</a></h5><table><thead><tr><th>장점</th><th>상세 설명</th><th style=text-align:right>기술 근거</th><th>적용 상황</th><th>실무적 가치</th></tr></thead><tbody><tr><td>병행성 극대화</td><td>충돌 범위를 최소화해 동시 쓰기/읽기 가능</td><td style=text-align:right>행/키 단위 락, Intention Lock</td><td>OLTP, 높은 동시성 워크로드</td><td>TPS↑, 평균·P99 지연↓</td></tr><tr><td>예측 가능한 스키마 작업</td><td>상위 락으로 DDL/배치 보호</td><td style=text-align:right>테이블/DB 수준 락</td><td>메이저 배치·DDL 창</td><td>배치 실패·충돌↓, 일정 예측</td></tr><tr><td>팬텀 제어</td><td>범위 삽입/삭제 차단</td><td style=text-align:right>Predicate / Gap 락, SERIALIZABLE</td><td>범위 무결성 필수 (금융)</td><td>논리적 일관성 보장</td></tr><tr><td>운영 탄력성 (에스컬레이션)</td><td>락 폭증 시 상향으로 자원 제어</td><td style=text-align:right>MGL/에스컬레이션 정책</td><td>락 수 급증·메모리 한계</td><td>메모리 안정성·관리 단순화</td></tr><tr><td>데이터 무결성</td><td>동시성 제어로 무결성 보장</td><td style=text-align:right>2PL, 트랜잭션 수명 제어</td><td>전 산업 (금융·의료 등)</td><td>오류·환불·리스크 감소</td></tr></tbody></table><p>락 그레뉼러리티는 <strong>동시성·무결성·운영 예측성</strong> 사이에서 균형을 만드는 도구다. 실무적 가치는 워크로드 특성에 따라 달라지므로, <strong>핫 로우 식별 → 그레뉼러리티 결정 → 운영 모니터링 및 에스컬레이션 규칙</strong>의 순으로 설계해야 최대 효과를 얻는다.</p><h4 id=락-그레인-한계와-운영-대응-전략>락 그레인 한계와 운영 대응 전략<a hidden class=anchor aria-hidden=true href=#락-그레인-한계와-운영-대응-전략>#</a></h4><p>락 그레인은 &rsquo; 얼마나 작은 단위로 잠글지 &rsquo; 의 결정이다.<br>미세 그레인은 동시에 많은 작업을 허용하지만 각 잠금에 비용 (메모리·CPU) 이 들고, 락 간 상호작용이 복잡해져 데드락·튜닝 난이도가 올라간다. 반대로 거친 그레인은 관리 비용은 적지만 동시성이 나빠져 대기 시간이 길어진다.</p><p>운영에서는 <strong>(1) 데드락 탐지·타임아웃</strong>, <strong>(2) 락 에스컬레이션 정책</strong>, <strong>(3) 인덱스·쿼리 최적화</strong>, <strong>(4) 샤딩/파티셔닝</strong>을 조합해 균형을 잡는다.<br>주요 수치 (예: 락당 메모리, 데드락 탐지 주기) 는 사용 DB 와 하드웨어에 맞춰 벤치마크로 확정해야 한다.</p><h5 id=락-그레인-단점-상세표>락 그레인 단점 상세표<a hidden class=anchor aria-hidden=true href=#락-그레인-단점-상세표>#</a></h5><table><thead><tr><th>단점</th><th>설명</th><th>원인</th><th>실무 문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>데드락 위험</td><td>트랜잭션 상호 대기 (순환)</td><td>리소스 획득 순서 불일치</td><td>롤백·서비스 중단</td><td>리소스 오더링, 2PL, 탐지 + 자동 롤백, 타임아웃</td><td>OCC, MVCC, 락 - 프리</td></tr><tr><td>성능 오버헤드</td><td>락 메타데이터·관리 비용</td><td>락당 메모리·해시 테이블 접근</td><td>메모리/CPU 사용 증가, 에스컬레이션</td><td>락 압축·임계값·샤딩, 트랜잭션 단축</td><td>MVCC, In-memory DB</td></tr><tr><td>복잡성 증가</td><td>설계·튜닝 난도 상승</td><td>의도락·호환성 매트릭스 등</td><td>개발 버그·튜닝 시간 증가</td><td>추상화·자동화 도구·교육</td><td>단순 모델 (NoSQL), 낙관적 제어</td></tr></tbody></table><p>단점은 주로 <strong>동시성 향상 대가로 발생하는 비용과 리스크</strong>다. 데드락은 설계·순서 통제로 상당 부분 완화할 수 있지만 완전히 제거되지는 않으며, 메모리 오버헤드는 시스템 한계에 직접 영향을 미치므로 락 수·크기 관리를 설계 초기부터 반영해야 한다. 복잡성은 자동화·추상화로 관리 가능하나 초기 투자와 운영 숙련도가 필요하다.</p><h5 id=락-그레인-제약사항-요약표>락 그레인 제약사항 요약표<a hidden class=anchor aria-hidden=true href=#락-그레인-제약사항-요약표>#</a></h5><table><thead><tr><th>제약사항</th><th>설명</th><th>원인</th><th>영향</th><th>해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>메모리 요구</td><td>락 메타데이터 저장 필요</td><td>동시 락 수 증가</td><td>메모리 부족·에스컬레이션</td><td>메모리 예산·락 제한·샤딩</td><td>In-memory DB, MVCC</td></tr><tr><td>확장성 한계</td><td>중앙 락관리 병목</td><td>단일 락 테이블/해시 충돌</td><td>대규모 처리 제한</td><td>파티셔닝·분산 락·비동기화</td><td>분산 DB, 이벤트 기반 아키텍처</td></tr><tr><td>실시간 제약</td><td>응답 시간 불확실성</td><td>락 경합의 비결정성</td><td>SLA 위반 위험</td><td>우선순위 스케줄링, NOWAIT/SKIP LOCKED</td><td>락 - 프리, HTM(짧은 TX)</td></tr></tbody></table><p>제약사항은 하드웨어·엔진·요구조건 때문에 발생하는 한계다.<br>메모리·확장성·실시간 요구는 설계 초기부터 아키텍처 (샤딩, 파티셔닝, 비동기화) 와 기술 선택 (MVCC, 분산 DB, 락 - 프리) 을 통해 처리계획을 세워야 한다.<br>실시간 시스템은 락 기반 접근을 최소화하거나 대체 기술을 적극 고려해야 한다.</p><h4 id=세분성-트레이드오프혼합-전략-총괄>세분성 트레이드오프·혼합 전략 총괄<a hidden class=anchor aria-hidden=true href=#세분성-트레이드오프혼합-전략-총괄>#</a></h4><p>잠금 세분성의 핵심은 " 어떤 단위를 잠글 것인가 " 다. 작은 단위 (행) 는 여러 트랜잭션이 동시에 작업할 수 있게 해 동시성을 높이지만, 잠금 개수·메타데이터가 증가해 관리 비용·데드락 위험이 커진다.<br>반대로 큰 단위 (테이블) 는 관리가 쉬우나 많은 트랜잭션을 한꺼번에 막아 성능을 떨어뜨린다.<br>실무에서는 <strong>작업 패턴을 계측</strong>해 적절한 기본 그레인을 선택하고, 핫스팟이나 범위 질의에는 적응형 그레인·샤딩·MVCC 혼용 같은 하이브리드 기법으로 균형을 맞춘다.</p><h5 id=트레이드오프>트레이드오프<a hidden class=anchor aria-hidden=true href=#트레이드오프>#</a></h5><h6 id=선택-a-미세-세분성-행-단위-등>선택 A: 미세 세분성 (행 단위 등)<a hidden class=anchor aria-hidden=true href=#선택-a-미세-세분성-행-단위-등>#</a></h6><ul><li>장점: 높은 동시성, 소규모 충돌 격리, 세밀한 병렬 처리 가능.</li><li>단점: 락 테이블/대기큐 증가, 더 많은 데드락 가능성, 메타데이터·추적 비용 상승.</li><li>고려 기준: 읽기·단건 쓰기 많은 OLTP, 인덱스 설계로 핫스팟 완화 가능하면 선택.</li></ul><h6 id=선택-b-거친-세분성-테이블파티션-단위>선택 B: 거친 세분성 (테이블/파티션 단위)<a hidden class=anchor aria-hidden=true href=#선택-b-거친-세분성-테이블파티션-단위>#</a></h6><ul><li>장점: 관리 오버헤드 작음, 락 처리 비용·메모리 절감, 단순 운영.</li><li>단점: 동시성 저하, 대량 트랜잭션이 동시에 블록될 가능성, 응답성 저하.</li><li>고려 기준: 배치 작업·OLAP·단순 대량 업데이트가 주류이면 선택.</li></ul><h6 id=선택-c-중간적응형-페이지파티션동적-전환>선택 C: 중간/적응형 (페이지·파티션·동적 전환)<a hidden class=anchor aria-hidden=true href=#선택-c-중간적응형-페이지파티션동적-전환>#</a></h6><ul><li>장점: 상황에 맞춰 성능과 오버헤드 균형 유지.</li><li>단점: 구현·운영 복잡성 증가 (정책·모니터링 필요).</li><li>고려 기준: 혼합 워크로드, 운영 자동화 수준이 높을 때 권장.</li></ul><h5 id=선택-상황과-관련-트레이드오프>선택 상황과 관련 트레이드오프<a hidden class=anchor aria-hidden=true href=#선택-상황과-관련-트레이드오프>#</a></h5><ul><li><strong>OLTP(다수 단건 트랜잭션)</strong> → 미세 세분성이 유리 (동시성 우선).</li><li><strong>OLAP/배치</strong> → 거친 세분성이 유리 (관리 오버헤드 우선).</li><li><strong>혼합 (하이브리드)</strong> → 적응형/파티셔닝 + MVCC 혼용 권장.</li></ul><h5 id=세분성-선택-비교표>세분성 선택 비교표<a hidden class=anchor aria-hidden=true href=#세분성-선택-비교표>#</a></h5><table><thead><tr><th>선택</th><th>장점</th><th>단점</th><th>적합 워크로드</th><th>고려 기준</th></tr></thead><tbody><tr><td>미세 (행)</td><td>높은 동시성, 세밀 제어</td><td>메타데이터↑, 데드락↑</td><td>OLTP, 단건 트랜잭션</td><td>인덱스 설계·메모리 보유</td></tr><tr><td>거친 (테이블/파티션)</td><td>관리·메모리 오버헤드↓</td><td>동시성↓, 응답성 저하</td><td>OLAP, 대량 배치</td><td>단순 대량 작업, 낮은 동시성 요구</td></tr><tr><td>적응형/중간</td><td>상황 따라 균형 유지</td><td>정책·운영 복잡성↑</td><td>혼합 워크로드</td><td>모니터링·자동화 역량 필요</td></tr></tbody></table><p>요약: 선택은 워크로드 성격에 직결된다. OLTP 면 미세, OLAP 면 거친, 혼합이면 적응형을 고려하되 각 선택은 인덱스·파티셔닝·모니터링 역량과 맞물려야 한다.</p><h5 id=부분적-교차-하이브리드-방법>부분적 교차 (하이브리드) 방법<a hidden class=anchor aria-hidden=true href=#부분적-교차-하이브리드-방법>#</a></h5><h6 id=적응형-그레인-adaptive-granularity>적응형 그레인 (Adaptive Granularity)<a hidden class=anchor aria-hidden=true href=#적응형-그레인-adaptive-granularity>#</a></h6><ul><li><strong>대상 트레이드오프</strong>: 동시성 vs 오버헤드</li><li><strong>구성 요소</strong>: 모니터 (대기시간·빈도), 정책 엔진 (전환 규칙), 실행기 (락 변환)</li><li><strong>적용 목적</strong>: 핫스팟 자동 완화·일반 영역은 미세 유지</li><li><strong>장점</strong>: 런타임 최적화, 자동화된 균형</li><li><strong>고려사항</strong>: 정책 오류 시 성능 불안정, 구현 난이도</li></ul><h6 id=mvcc--제한적-락-혼용>MVCC + 제한적 락 혼용<a hidden class=anchor aria-hidden=true href=#mvcc--제한적-락-혼용>#</a></h6><ul><li><strong>대상 트레이드오프</strong>: 읽기 지연 vs 쓰기 일관성</li><li><strong>구성 요소</strong>: MVCC 읽기 (스냅샷), 명시적 쓰기 락, 충돌 재시도 로직</li><li><strong>적용 목적</strong>: 읽기 대량 시스템에서 쓰기 일관성 확보</li><li><strong>장점</strong>: 읽기 성능 극대화, 낮은 읽기 락 오버헤드</li><li><strong>고려사항</strong>: 쓰기 충돌·재시도 비용, 복잡한 에러 처리</li></ul><h6 id=락-샤딩--파티셔닝>락 샤딩 / 파티셔닝<a hidden class=anchor aria-hidden=true href=#락-샤딩--파티셔닝>#</a></h6><ul><li><strong>대상 트레이드오프</strong>: 락 메타데이터 컨텐션 vs 데이터 분산성</li><li><strong>구성 요소</strong>: 샤드 키 설계, 분산 락 테이블, 라우팅 레이어</li><li><strong>적용 목적</strong>: 대규모 동시성 환경에서 락 스케일아웃</li><li><strong>장점</strong>: 수평 확장, 락 테이블 병렬화</li><li><strong>고려사항</strong>: 샤딩 불균형 (핫샤드) 주의</li></ul><h6 id=d-선택적-범위잠금-predicate-locking-on-demand>(d) 선택적 범위잠금 (Predicate Locking on-demand)<a hidden class=anchor aria-hidden=true href=#d-선택적-범위잠금-predicate-locking-on-demand>#</a></h6><ul><li><strong>대상 트레이드오프</strong>: 팬텀 제어 vs 인덱스 스캔 비용</li><li><strong>구성 요소</strong>: 쿼리 분류기, 범위잠금 적용기, 인덱스 튜닝</li><li><strong>적용 목적</strong>: 팬텀 위험이 높은 쿼리만 비용 지불</li><li><strong>장점</strong>: 전체 비용 절감, 정확한 일관성 유지</li><li><strong>고려사항</strong>: 쿼리 분류 정확도 필요</li></ul><h6 id=지능형-에스컬레이션-adaptive-escalation>지능형 에스컬레이션 (Adaptive Escalation)<a hidden class=anchor aria-hidden=true href=#지능형-에스컬레이션-adaptive-escalation>#</a></h6><ul><li><strong>대상 트레이드오프</strong>: 메타데이터 비용 vs 중요 트랜잭션 동시성</li><li><strong>구성 요소</strong>: 트랜잭션 중요도 태깅, 예상 지속시간 모델, 에스컬레이션 정책</li><li><strong>적용 목적</strong>: 핵심 서비스의 응답성 보장하면서 메타데이터 제어</li><li><strong>장점</strong>: SLA 기반 유연한 운영</li><li><strong>고려사항</strong>: 트랜잭션 메타데이터 수집 필요</li></ul><h5 id=세분성-하이브리드-기법-비교표>세분성 하이브리드 기법 비교표<a hidden class=anchor aria-hidden=true href=#세분성-하이브리드-기법-비교표>#</a></h5><table><thead><tr><th>기법</th><th>목표 트레이드오프</th><th>구성 요소</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>적응형 그레인</td><td>동시성 ↔ 오버헤드</td><td>모니터 + 정책 엔진 + 변환기</td><td>자동 균형, 유연성</td><td>구현·테스트 복잡</td></tr><tr><td>MVCC+ 락 혼용</td><td>읽기 성능 ↔ 쓰기 일관성</td><td>MVCC + 명시적 쓰기락</td><td>읽기 비차단성 확보</td><td>쓰기 재시도 비용</td></tr><tr><td>락 샤딩</td><td>메타데이터 컨텐션 ↔ 확장성</td><td>샤드 키, 분산 락 테이블</td><td>수평 확장성</td><td>샤드 불균형 위험</td></tr><tr><td>선택적 범위잠금</td><td>팬텀 제어 ↔ 스캔 비용</td><td>쿼리 분류기, 범위락</td><td>비용 절감, 정확성</td><td>분류 정확도 필요</td></tr><tr><td>지능형 에스컬레이션</td><td>메타데이터 비용 ↔ SLA 보장</td><td>우선순위·예측 모델</td><td>SLA 기반 최적화</td><td>메타정보 수집 필요</td></tr></tbody></table><p>요약: 하이브리드 기법은 각각 특정 트레이드오프를 대상화하여 부분적으로 문제를 해소한다. 실무에서는 한 가지 기법만 쓰지 않고, <strong>모니터링 기반으로 정책을 조합</strong>해 적용하는 것이 효과적이다.</p><h4 id=락-그레인-적용성-평가와-권장방향>락 그레인 적용성 평가와 권장방향<a hidden class=anchor aria-hidden=true href=#락-그레인-적용성-평가와-권장방향>#</a></h4><p>락 그레인 (Granularity) 선택은 <strong>어떤 범위를 잠글지</strong> 결정하는 것이다. 행 단위는 동시성을 높이고 데드락의 표면적을 줄이지만 락 수와 메타데이터 비용이 늘어난다. 반대로 테이블 단위는 구현·관리 비용이 적지만 동시성이 크게 떨어진다. 따라서 OLTP 나 은행 같은 트랜잭션 중심 시스템, 경합이 자주 발생하는 대규모 서비스에서는 <strong>다중 그레인 (MGL)</strong> 을 적용해 행→페이지→테이블을 계층적으로 관리하는 것이 적합하다. 반면, 초저지연 실시간 시스템이나 읽기 위주의 분석 시스템에서는 MVCC 나 읽기 리플리카, 혹은 단순 락 전략이 더 적절할 수 있다. 최종 결정은 <strong>읽기/쓰기 비율, 트랜잭션 길이, 핫스팟 존재 여부, DB 엔진 특성</strong>을 측정한 뒤 스테이징 테스트로 검증해야 한다.</p><h5 id=락-세분성-적용-적합성-평가>락 세분성 적용 적합성 평가<a hidden class=anchor aria-hidden=true href=#락-세분성-적용-적합성-평가>#</a></h5><h6 id=설계-관점>설계 관점<a hidden class=anchor aria-hidden=true href=#설계-관점>#</a></h6><ul><li><strong>설명</strong>: 데이터 모델·쿼리 패턴에 따라 초기 락 그레인을 설계 (행/범위/테이블).</li><li><strong>적합성 판단</strong>:<ul><li>적합: 계층화된 데이터 모델, 많은 동시 트랜잭션, 복잡한 업데이트 패스.</li><li>부적합: 단순 단건 트랜잭션, 엄격 초저지연 시스템.</li></ul></li><li><strong>권장 조치</strong>: 시작은 행/키 단위; 핫스팟 발견 시 파티셔닝·샤딩·업데이트 경합 분리 적용.</li></ul><h6 id=분석-아키텍처성능-관점>분석 (아키텍처·성능) 관점<a hidden class=anchor aria-hidden=true href=#분석-아키텍처성능-관점>#</a></h6><ul><li><strong>설명</strong>: 적용 전후 성능 (응답시간, TPS, 데드락율) 영향 분석이 필수.</li><li><strong>적합성 판단</strong>:<ul><li>적합: 예측 가능한 워크로드, 테스트 가능한 환경.</li><li>부적합: 워크로드 변동성이 극심한 시스템 (사전 보정 어려움).</li></ul></li><li><strong>권장 조치</strong>: 읽기/쓰기 비율·트랜잭션 길이·락 대기 시간 측정 후 기준 (예: 읽기>80% 는 MVCC 우선) 수립.</li></ul><h6 id=운영-관점>운영 관점<a hidden class=anchor aria-hidden=true href=#운영-관점>#</a></h6><ul><li><strong>설명</strong>: 모니터링·알람·자동화 (에스컬레이션 임계치, deadlock 탐지) 및 운영 비용 (메모리) 고려.</li><li><strong>적합성 판단</strong>:<ul><li>적합: 충분한 자원·운영 역량 (모니터링·튜닝 가능).</li><li>부적합: 자원 제약·운영 자원 부족 (로그·모니터링 미흡).</li></ul></li><li><strong>권장 조치</strong>: lock_wait_time, deadlock_count, escalation_events 등 지표 수집·알람, 스테이징에서 임계치 테스트.</li></ul><h5 id=락-그레인-적용-적합성-가이드>락 그레인 적용 적합성 가이드<a hidden class=anchor aria-hidden=true href=#락-그레인-적용-적합성-가이드>#</a></h5><table><thead><tr><th>환경 유형</th><th style=text-align:right>적용 적합성</th><th>근거 (이유)</th><th>설계 권장</th><th>운영 권장</th></tr></thead><tbody><tr><td>OLTP(은행·e- 커머스)</td><td style=text-align:right>적합</td><td>높은 일관성·동시성 요구, 국부적 업데이트 패턴</td><td>행/키 - 범위 그레인, MGL 적용</td><td>모니터링 (대기·deadlock), 에스컬레이션 임계치 튜닝</td></tr><tr><td>읽기 중심 분석 (OLAP)</td><td style=text-align:right>부적합</td><td>대규모 스캔·보고서로 락 비용 비효율</td><td>읽기 리플리카 · MVCC 우선</td><td>리플리카 분리, 배치 시간 스케줄링</td></tr><tr><td>초저지연 실시간</td><td style=text-align:right>부적합</td><td>락 획득 오버헤드로 지연 발생</td><td>Lock-free/최소 락 또는 in-memory 구조</td><td>경량 모니터링, 지연 SLA 우선</td></tr><tr><td>소규모 단일 트랜잭션</td><td style=text-align:right>보통</td><td>경합 적음 → 단순 설계가 경제적</td><td>간단한 락 메커니즘 (테이블/행 단순)</td><td>과도한 튜닝 불필요</td></tr><tr><td>배치·리포트 작업</td><td style=text-align:right>적합 (거친 그레인)</td><td>전체 스캔·대량 업데이트에 유리</td><td>파티션/테이블 락 또는 배치 전용 윈도우</td><td>작업 윈도우 확보, 리소스 격리</td></tr><tr><td>자원 제약 (임베디드)</td><td style=text-align:right>부적합</td><td>메타데이터·메모리 여유 부족</td><td>단순 락·애플리케이션 레벨 제어</td><td>경량화, 트랜잭션 단순화</td></tr></tbody></table><p>핵심은 워크로드 성격에 맞춘 선택이다. 트랜잭션이 빈번하고 업데이트가 국부적인 OLTP 는 MGL(행 우선) 이득이 크다. 읽기 중심·초저지연·자원 제약 환경에서는 MVCC·리플리카·락 - 프리 설계 등 다른 패턴이 더 적절하다. 반드시 측정 (비율·지연·핫스팟) 과 스테이징 실험을 거쳐 결정하라.</p><h3 id=구현-방법-및-분류>구현 방법 및 분류<a hidden class=anchor aria-hidden=true href=#구현-방법-및-분류>#</a></h3><h4 id=lock-granularity잠금-세분화-단위-정리>Lock Granularity(잠금 세분화 단위) 정리<a hidden class=anchor aria-hidden=true href=#lock-granularity잠금-세분화-단위-정리>#</a></h4><blockquote><p>질문: <em>Row/Key, Page, Index, Table, Schema, Key-Range 는 Lock Granularity 에 포함되는가?</em> → <strong>포함된다.</strong> 단, <strong>Key-Range</strong>는 특정 엔진에서 <strong>정렬된 인덱스 상의 논리적 범위</strong>를 자원으로 취급하는 <strong>파생적 (granularity+strategy 교차)</strong> 단위라는 점을 명확히 하자.</p></blockquote><h5 id=공통-계층-개념적>공통 계층 (개념적)<a hidden class=anchor aria-hidden=true href=#공통-계층-개념적>#</a></h5><pre class=mermaid>graph TD
  Schema --&gt; Table
  Table --&gt;|may contain| Index
  Table --&gt; Page
  Page --&gt; Row[&#34;Row (or Key/Record)&#34;]
  Index --&gt; IndexPage[Index Page]
  IndexPage --&gt; Key[Index Key]
  subgraph Logical Range
    KeyRange[&#34;Key-Range (ordered key interval)&#34;]
  end
</pre><h5 id=자원별-분류-테이블>자원별 분류 테이블<a hidden class=anchor aria-hidden=true href=#자원별-분류-테이블>#</a></h5><table><thead><tr><th>자원 (한글/영문)</th><th>Granularity 해당?</th><th>의미/용도</th><th>대표 DBMS 동작</th><th>대표 모드/의도</th><th>비고</th></tr></thead><tbody><tr><td>행/키 (Row/Key)</td><td>예</td><td>단일 레코드 (클러스터/보조 인덱스 키)</td><td>InnoDB 레코드 락, PG tuple-level, SQL Server RID</td><td>S/U/X (+ROWLOCK 힌트), IS/IX 상위</td><td>InnoDB 는 보조 인덱스 키 기준으로 Next-Key 와 결합</td></tr><tr><td>페이지 (Page)</td><td>예 (엔진별)</td><td>저장 페이지 (데이터/인덱스)</td><td>SQL Server PAGE 락, 일부 엔진 옵션</td><td>S/X/U, IS/IX</td><td>PostgreSQL 은 <strong>트랜잭션 락</strong> 대신 <strong>래치</strong> 중심</td></tr><tr><td>인덱스 (Index)</td><td>예</td><td>인덱스 객체 또는 노드/페이지</td><td>SQL Server 인덱스 대상 의도/범위, PG 인덱스 스캔 중 래치</td><td>IS/IX/SIX, Range*</td><td>인덱스 유지/스플릿 시 래치와 구분</td></tr><tr><td>테이블 (Table)</td><td>예</td><td>테이블 단위 보호/에스컬레이션</td><td>대부분 지원</td><td>S/X, IS/IX/SIX</td><td>락 에스컬레이션 대상</td></tr><tr><td>스키마 (Schema)</td><td>예</td><td>메타데이터/DDL 보호</td><td>SQL Server Sch-S/Sch-M</td><td>Sch-S/Sch-M</td><td>데이터 락과 별 개념이나 <strong>granularity</strong> 관점 포함</td></tr><tr><td>키 - 범위 (Key-Range)</td><td>예 (엔진별)</td><td><strong>정렬 키 구간</strong>을 자원으로 간주</td><td>SQL Server RangeS/U/I, InnoDB Next-Key/GAP, PG Predicate</td><td>RangeS-S, RangeS-U 등 + IS/IX</td><td>** 전략 (팬텀 방지)** 과 <strong>자원 단위</strong>가 교차하는 특수 케이스</td></tr></tbody></table><h4 id=lock-granularity-구현-종합-가이드>Lock Granularity 구현 종합 가이드<a hidden class=anchor aria-hidden=true href=#lock-granularity-구현-종합-가이드>#</a></h4><h5 id=구현-방법-및-기법>구현 방법 및 기법<a hidden class=anchor aria-hidden=true href=#구현-방법-및-기법>#</a></h5><h6 id=계층적-잠금-프로토콜-구현-hierarchical-locking--mgl>계층적 잠금 프로토콜 구현 (Hierarchical Locking / MGL)<a hidden class=anchor aria-hidden=true href=#계층적-잠금-프로토콜-구현-hierarchical-locking--mgl>#</a></h6><ul><li><strong>정의</strong>: 데이터 자원을 계층 (데이터베이스→테이블→페이지→행) 으로 보고, 하위 자원 잠그기 전에 상위에 의도락 (IS/IX/SIX) 을 먼저 획득하는 프로토콜.</li><li><strong>특징</strong>: 의도락으로 상위에서 하위 충돌 여부를 빠르게 판정, 상향식 해제 (consistent release).</li><li><strong>목적</strong>: 대규모 데이터 구조에서 락 검사 비용을 낮추고 동시성 유지.</li><li>기본 메커니즘<ul><li>트랜잭션이 어떤 행을 읽거나 쓰려면 먼저 그 행의 부모 노드들 (테이블, 페이지 등) 에 적절한 의도락 (IS/IX) 을 획득한다.</li><li>의도락 획득이 가능하면 하위 리소스에 실제 락 (S/X) 을 부여한다.</li><li>다수의 세부 락이 쌓이면 시스템은 락 승격 (Lock Escalation) 을 통해 관리 오버헤드를 줄일 수 있다.</li></ul></li><li><strong>사용 상황</strong>: 대형 테이블, 파티셔닝, 복잡한 트랜잭션 경로가 있는 OLTP 환경.</li><li><strong>예시</strong>: 레코드 읽기 → 부모 페이지·테이블에 <code>IS</code> 세팅 → 레코드에 <code>S</code> 획득.</li></ul><p><strong>운영 주의</strong>: Lock Manager 구현은 원자성 (동시에 여러 트랜잭션이 상위 락 갱신 시 race)·deadlock 탐지 로직 필요.</p><p><strong>구현 예시</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span><span class=lnt id=hl-7-15><a class=lnlinks href=#hl-7-15>15</a>
</span><span class=lnt id=hl-7-16><a class=lnlinks href=#hl-7-16>16</a>
</span><span class=lnt id=hl-7-17><a class=lnlinks href=#hl-7-17>17</a>
</span><span class=lnt id=hl-7-18><a class=lnlinks href=#hl-7-18>18</a>
</span><span class=lnt id=hl-7-19><a class=lnlinks href=#hl-7-19>19</a>
</span><span class=lnt id=hl-7-20><a class=lnlinks href=#hl-7-20>20</a>
</span><span class=lnt id=hl-7-21><a class=lnlinks href=#hl-7-21>21</a>
</span><span class=lnt id=hl-7-22><a class=lnlinks href=#hl-7-22>22</a>
</span><span class=lnt id=hl-7-23><a class=lnlinks href=#hl-7-23>23</a>
</span><span class=lnt id=hl-7-24><a class=lnlinks href=#hl-7-24>24</a>
</span><span class=lnt id=hl-7-25><a class=lnlinks href=#hl-7-25>25</a>
</span><span class=lnt id=hl-7-26><a class=lnlinks href=#hl-7-26>26</a>
</span><span class=lnt id=hl-7-27><a class=lnlinks href=#hl-7-27>27</a>
</span><span class=lnt id=hl-7-28><a class=lnlinks href=#hl-7-28>28</a>
</span><span class=lnt id=hl-7-29><a class=lnlinks href=#hl-7-29>29</a>
</span><span class=lnt id=hl-7-30><a class=lnlinks href=#hl-7-30>30</a>
</span><span class=lnt id=hl-7-31><a class=lnlinks href=#hl-7-31>31</a>
</span><span class=lnt id=hl-7-32><a class=lnlinks href=#hl-7-32>32</a>
</span><span class=lnt id=hl-7-33><a class=lnlinks href=#hl-7-33>33</a>
</span><span class=lnt id=hl-7-34><a class=lnlinks href=#hl-7-34>34</a>
</span><span class=lnt id=hl-7-35><a class=lnlinks href=#hl-7-35>35</a>
</span><span class=lnt id=hl-7-36><a class=lnlinks href=#hl-7-36>36</a>
</span><span class=lnt id=hl-7-37><a class=lnlinks href=#hl-7-37>37</a>
</span><span class=lnt id=hl-7-38><a class=lnlinks href=#hl-7-38>38</a>
</span><span class=lnt id=hl-7-39><a class=lnlinks href=#hl-7-39>39</a>
</span><span class=lnt id=hl-7-40><a class=lnlinks href=#hl-7-40>40</a>
</span><span class=lnt id=hl-7-41><a class=lnlinks href=#hl-7-41>41</a>
</span><span class=lnt id=hl-7-42><a class=lnlinks href=#hl-7-42>42</a>
</span><span class=lnt id=hl-7-43><a class=lnlinks href=#hl-7-43>43</a>
</span><span class=lnt id=hl-7-44><a class=lnlinks href=#hl-7-44>44</a>
</span><span class=lnt id=hl-7-45><a class=lnlinks href=#hl-7-45>45</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>HierarchicalLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_table</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 잠금 테이블</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>compatibility_matrix</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1># IS, IX, S, X 호환성 매트릭스</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;IS&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;IS&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;IX&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;IS&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;IS&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=kc>True</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;IS&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>,</span> <span class=n>resource_path</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        계층적 잠금 획득
</span></span></span><span class=line><span class=cl><span class=s2>        resource_path: [&#39;database&#39;, &#39;table1&#39;, &#39;page5&#39;, &#39;row10&#39;]
</span></span></span><span class=line><span class=cl><span class=s2>        mode: &#39;IS&#39;, &#39;IX&#39;, &#39;S&#39;, &#39;X&#39;
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 상위 계층부터 의도 잠금 획득</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>resource_path</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>parent_path</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>resource_path</span><span class=p>[:</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>intent_mode</span> <span class=o>=</span> <span class=s1>&#39;IS&#39;</span> <span class=k>if</span> <span class=n>mode</span> <span class=ow>in</span> <span class=p>[</span><span class=s1>&#39;IS&#39;</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>]</span> <span class=k>else</span> <span class=s1>&#39;IX&#39;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>_check_compatibility</span><span class=p>(</span><span class=n>parent_path</span><span class=p>,</span> <span class=n>intent_mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>  <span class=c1># 대기 상태로 전환</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_grant_lock</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>parent_path</span><span class=p>,</span> <span class=n>intent_mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 목표 자원에 실제 잠금 설정</span>
</span></span><span class=line><span class=cl>        <span class=n>target_path</span> <span class=o>=</span> <span class=nb>tuple</span><span class=p>(</span><span class=n>resource_path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_check_compatibility</span><span class=p>(</span><span class=n>target_path</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_grant_lock</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>target_path</span><span class=p>,</span> <span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_check_compatibility</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;잠금 호환성 검사&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>resource</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock_table</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>existing_locks</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock_table</span><span class=p>[</span><span class=n>resource</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>existing_mode</span> <span class=ow>in</span> <span class=n>existing_locks</span><span class=o>.</span><span class=n>values</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>compatibility_matrix</span><span class=p>[</span><span class=n>mode</span><span class=p>][</span><span class=n>existing_mode</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>True</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>MGL 상세 흐름도</strong></p><pre class=mermaid>flowchart TD
  subgraph START[&#34;트랜잭션 시작&#34;]
    T[트랜잭션 시작]
  end

  T --&gt; OP{작업 종류}
  OP --&gt; |&#34;읽기 (read)&#34;| READ
  OP --&gt; |&#34;읽기-for-update / 쓰기 (write)&#34;| WRITE

  %% MVCC 분기
  READ --&gt; MVCC?{MVCC 사용중인가?}
  MVCC? --&gt; |예 - 스냅샷 읽기| MVCC_PATH[&#34;MVCC 스냅샷 경로\n(의도락 불필요)&#34;]
  MVCC? --&gt; |아니오 또는 FOR UPDATE| ACQUIRE_READ

  %% 읽기-락 획득 경로
  ACQUIRE_READ[&#34;상위 의도락(IS) 획득 시도\n(테이블-&gt;페이지-&gt;…)&#34;] --&gt; CMP1{상위 호환성 검사}
  CMP1 --&gt; |호환| GRANT_IS1[&#34;IS 부여(부모들)&#34;]
  CMP1 --&gt; |비호환| WAIT_PARENT1[대기 큐에 추가 -&gt; 대기]
  GRANT_IS1 --&gt; REQ_S[행에 S요청]
  REQ_S --&gt; CMP_R{행 호환성 검사}
  CMP_R --&gt; |호환| GRANT_S[행 S 부여 -&gt; 읽기 수행]
  CMP_R --&gt; |비호환| WAIT_ROW1[대기 큐에 추가 -&gt; 대기]

  %% 쓰기-락 획득 경로
  WRITE --&gt; ACQUIRE_WRITE[&#34;상위 의도락(IX) 획득 시도\n(테이블-&gt;페이지-&gt;…)&#34;]
  ACQUIRE_WRITE --&gt; CMP2{상위 호환성 검사}
  CMP2 --&gt; |호환| GRANT_IX[&#34;IX 부여(부모들)&#34;]
  CMP2 --&gt; |비호환| WAIT_PARENT2[대기 큐에 추가 -&gt; 대기]
  GRANT_IX --&gt; REQ_X[행에 X요청]
  REQ_X --&gt; CMP_W{행 호환성 검사}
  CMP_W --&gt; |호환| GRANT_X[행 X 부여 -&gt; 쓰기 수행]
  CMP_W --&gt; |비호환| WAIT_ROW2[대기 큐에 추가 -&gt; 대기]

  %% 동일 페이지 다른 행 동시 허용 표시
  subgraph CONC[&#34;동시성 예: 동일 페이지, 다른 행&#34;]
    GRANT_S --&gt;|다른 행| GRANT_S2[&#34;다른 행 S 부여(동시 허용)&#34;]
    GRANT_S2 --&gt; NOTE1[상위에 IS만 있으므로 동시성 허용]
  end

  %% 컨버전 (S -&gt; X)
  GRANT_S --&gt; CONV{이후 쓰기로 전환?}
  CONV --&gt; |예| S2X[S -&gt; X 컨버전 요청]
  S2X --&gt; CMP_CONV{호환성 재검사}
  CMP_CONV --&gt; |호환| GRANT_X2[컨버전 성공 -&gt; X 부여]
  CMP_CONV --&gt; |비호환| WAIT_CONV[대기 큐에 추가 -&gt; 대기]

  %% 대기 처리 / 데드락
  WAIT_PARENT1 --&gt; DEADCHK1[데드락 탐지 / 타임아웃 체크]
  WAIT_PARENT2 --&gt; DEADCHK2[데드락 탐지 / 타임아웃 체크]
  WAIT_ROW1 --&gt; DEADCHK1
  WAIT_ROW2 --&gt; DEADCHK2
  WAIT_CONV --&gt; DEADCHK2

  DEADCHK1 --&gt; |데드락 발견| VICTIM[Victim 선정 → Abort/롤백]
  DEADCHK1 --&gt; |타임아웃| TIMEOUT1[타임아웃 처리 → 재시도/Abort]
  DEADCHK2 --&gt; |데드락 발견| VICTIM
  DEADCHK2 --&gt; |타임아웃| TIMEOUT2[타임아웃 처리 → 재시도/Abort]

  VICTIM --&gt; RELEASE_V[해당 트랜잭션 락 해제]
  RELEASE_V --&gt; QUEUE_PROC[대기 큐 재검사 후 승인]

  %% 승격(Esclation) 경로
  GRANT_X --&gt; LOCK_COUNT_CHECK{테이블 내 보유 행락 수 &gt; threshold?}
  GRANT_S --&gt; LOCK_COUNT_CHECK
  LOCK_COUNT_CHECK --&gt; |초과| ESCALATE[락 승격 트리거]
  ESCALATE --&gt; RELEASE_ROWS[&#34;행 락 해제(해당 Txn)&#34;]
  RELEASE_ROWS --&gt; ACQUIRE_TABLE[X 테이블 락 획득]
  ACQUIRE_TABLE --&gt; NOTE_ESC[승격: 메모리↓, 동시성↓]

  %% 완료 경로
  GRANT_X --&gt; TX_DONE{트랜잭션 완료?}
  GRANT_S --&gt; TX_DONE
  ACQUIRE_TABLE --&gt; TX_DONE
  MVCC_PATH --&gt; TX_DONE

  TX_DONE --&gt; |예| COMMIT[COMMIT/ROLLBACK -&gt; 모든 락 해제]
  COMMIT --&gt; QUEUE_PROC

  %% 모니터링 훅(지점표시)
  classDef hook fill:#fff7c4,stroke:#ff9900;
  CMP1:::hook
  CMP2:::hook
  CMP_R:::hook
  CMP_W:::hook
  DEADCHK1:::hook
  LOCK_COUNT_CHECK:::hook
  QUEUE_PROC:::hook
  MVCC_PATH:::hook
</pre><h6 id=잠금-상승-lock-escalation>잠금 상승 (Lock Escalation)<a hidden class=anchor aria-hidden=true href=#잠금-상승-lock-escalation>#</a></h6><ul><li><strong>정의</strong>: 다수의 세부 락 (예: 행 락) 을 하나의 상위 락 (예: 테이블 락) 으로 전환하는 최적화.</li><li><strong>특징</strong>: 임계값 (락 수) 기반 자동 작동, 메모리·관리 오버헤드 절감, 그러나 동시성 저하 위험.</li><li><strong>목적</strong>: 락 테이블/메모리 부담을 제어해 시스템 안정성 확보.</li><li><strong>사용 상황</strong>: 대량 업데이트가 빈번한 트랜잭션, 메모리 제한 상황, 장기 트랜잭션 누적 시.</li><li><strong>예시</strong>: <code>LockEscalationManager</code> 에서 행락 수가 threshold 초과하면 테이블 X 락으로 전환.</li></ul><p><strong>운영 주의</strong>: 임계값은 워크로드별로 튜닝, 자동 승격 시 모니터링·알람 설정 필수.</p><p><strong>구현 방법</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23>23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24>24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25>25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26>26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockEscalationManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>escalation_threshold</span><span class=o>=</span><span class=mi>1000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>threshold</span> <span class=o>=</span> <span class=n>escalation_threshold</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_counts</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 트랜잭션별 잠금 수 추적</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>check_escalation</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;잠금 상승 조건 확인 및 실행&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>row_lock_count</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_count_row_locks</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>row_lock_count</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>threshold</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 비용-효익 분석</span>
</span></span><span class=line><span class=cl>            <span class=n>current_cost</span> <span class=o>=</span> <span class=n>row_lock_count</span> <span class=o>*</span> <span class=mi>10</span>  <span class=c1># 행 잠금 관리 비용</span>
</span></span><span class=line><span class=cl>            <span class=n>escalated_cost</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>*</span> <span class=mi>100</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>_calculate_blocking_cost</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>escalated_cost</span> <span class=o>&lt;</span> <span class=n>current_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_escalate_to_table_lock</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_escalate_to_table_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;테이블 수준 잠금으로 상승&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 1. 기존 행 잠금들 해제</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_release_row_locks</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 2. 테이블 잠금 설정</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_acquire_table_lock</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 3. 잠금 테이블 업데이트</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_update_lock_tracking</span><span class=p>(</span><span class=n>transaction_id</span><span class=p>,</span> <span class=n>table_id</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=적응적-잠금-선택-adaptive-lock-selection>적응적 잠금 선택 (Adaptive Lock Selection)<a hidden class=anchor aria-hidden=true href=#적응적-잠금-선택-adaptive-lock-selection>#</a></h6><ul><li><strong>정의</strong>: 쿼리 특성 (선택도, 접근 패턴, 동시 트랜잭션 수 등) 을 바탕으로 최적의 락 입도 (row/page/table) 를 동적으로 선택.</li><li><strong>특징</strong>: 과거 성능 데이터 기반 예측, 온라인 학습 가능, 안전장치 필요.</li><li><strong>목적</strong>: 워크로드 변화에 따라 최적의 동시성/성능 균형 자동 확보.</li><li><strong>사용 상황</strong>: 다양한 쿼리 패턴이 섞인 시스템, 자주 변하는 워크로드.</li><li><strong>예시</strong>: <code>AdaptiveLockSelector</code> 가 유사 과거 패턴의 평균 성능을 보고 <code>row</code>/<code>page</code>/<code>table</code> 중 선택.</li></ul><p><strong>운영 주의</strong>: 초기에는 보수적 정책 (가드레일), 모델 실패 시 fallback 경로 필요.</p><p><strong>구현 알고리즘</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1> 1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2> 2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3> 3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4> 4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5> 5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6> 6</a>
</span><span class=lnt id=hl-10-7><a class=lnlinks href=#hl-10-7> 7</a>
</span><span class=lnt id=hl-10-8><a class=lnlinks href=#hl-10-8> 8</a>
</span><span class=lnt id=hl-10-9><a class=lnlinks href=#hl-10-9> 9</a>
</span><span class=lnt id=hl-10-10><a class=lnlinks href=#hl-10-10>10</a>
</span><span class=lnt id=hl-10-11><a class=lnlinks href=#hl-10-11>11</a>
</span><span class=lnt id=hl-10-12><a class=lnlinks href=#hl-10-12>12</a>
</span><span class=lnt id=hl-10-13><a class=lnlinks href=#hl-10-13>13</a>
</span><span class=lnt id=hl-10-14><a class=lnlinks href=#hl-10-14>14</a>
</span><span class=lnt id=hl-10-15><a class=lnlinks href=#hl-10-15>15</a>
</span><span class=lnt id=hl-10-16><a class=lnlinks href=#hl-10-16>16</a>
</span><span class=lnt id=hl-10-17><a class=lnlinks href=#hl-10-17>17</a>
</span><span class=lnt id=hl-10-18><a class=lnlinks href=#hl-10-18>18</a>
</span><span class=lnt id=hl-10-19><a class=lnlinks href=#hl-10-19>19</a>
</span><span class=lnt id=hl-10-20><a class=lnlinks href=#hl-10-20>20</a>
</span><span class=lnt id=hl-10-21><a class=lnlinks href=#hl-10-21>21</a>
</span><span class=lnt id=hl-10-22><a class=lnlinks href=#hl-10-22>22</a>
</span><span class=lnt id=hl-10-23><a class=lnlinks href=#hl-10-23>23</a>
</span><span class=lnt id=hl-10-24><a class=lnlinks href=#hl-10-24>24</a>
</span><span class=lnt id=hl-10-25><a class=lnlinks href=#hl-10-25>25</a>
</span><span class=lnt id=hl-10-26><a class=lnlinks href=#hl-10-26>26</a>
</span><span class=lnt id=hl-10-27><a class=lnlinks href=#hl-10-27>27</a>
</span><span class=lnt id=hl-10-28><a class=lnlinks href=#hl-10-28>28</a>
</span><span class=lnt id=hl-10-29><a class=lnlinks href=#hl-10-29>29</a>
</span><span class=lnt id=hl-10-30><a class=lnlinks href=#hl-10-30>30</a>
</span><span class=lnt id=hl-10-31><a class=lnlinks href=#hl-10-31>31</a>
</span><span class=lnt id=hl-10-32><a class=lnlinks href=#hl-10-32>32</a>
</span><span class=lnt id=hl-10-33><a class=lnlinks href=#hl-10-33>33</a>
</span><span class=lnt id=hl-10-34><a class=lnlinks href=#hl-10-34>34</a>
</span><span class=lnt id=hl-10-35><a class=lnlinks href=#hl-10-35>35</a>
</span><span class=lnt id=hl-10-36><a class=lnlinks href=#hl-10-36>36</a>
</span><span class=lnt id=hl-10-37><a class=lnlinks href=#hl-10-37>37</a>
</span><span class=lnt id=hl-10-38><a class=lnlinks href=#hl-10-38>38</a>
</span><span class=lnt id=hl-10-39><a class=lnlinks href=#hl-10-39>39</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AdaptiveLockSelector</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>history_size</span><span class=o>=</span><span class=mi>1000</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>access_patterns</span> <span class=o>=</span> <span class=n>deque</span><span class=p>(</span><span class=n>maxlen</span><span class=o>=</span><span class=n>history_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>performance_metrics</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>predict_optimal_granularity</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>query_characteristics</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        쿼리 특성을 바탕으로 최적 잠금 입도 예측
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 특성 벡터 추출</span>
</span></span><span class=line><span class=cl>        <span class=n>features</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_extract_features</span><span class=p>(</span><span class=n>query_characteristics</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 과거 성능 데이터 기반 예측</span>
</span></span><span class=line><span class=cl>        <span class=n>predicted_performance</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>granularity</span> <span class=ow>in</span> <span class=p>[</span><span class=s1>&#39;row&#39;</span><span class=p>,</span> <span class=s1>&#39;page&#39;</span><span class=p>,</span> <span class=s1>&#39;table&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 유사한 패턴의 과거 성능 데이터 조회</span>
</span></span><span class=line><span class=cl>            <span class=n>similar_patterns</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_find_similar_patterns</span><span class=p>(</span><span class=n>features</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>performance</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>mean</span><span class=p>([</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=p>[</span><span class=s1>&#39;performance&#39;</span><span class=p>][</span><span class=n>granularity</span><span class=p>]</span> 
</span></span><span class=line><span class=cl>                <span class=k>for</span> <span class=n>p</span> <span class=ow>in</span> <span class=n>similar_patterns</span>
</span></span><span class=line><span class=cl>            <span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>predicted_performance</span><span class=p>[</span><span class=n>granularity</span><span class=p>]</span> <span class=o>=</span> <span class=n>performance</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 최적 입도 선택</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>predicted_performance</span><span class=o>.</span><span class=n>items</span><span class=p>(),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>])[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_extract_features</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>query_chars</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;쿼리 특성 벡터 추출&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;selectivity&#39;</span><span class=p>:</span> <span class=n>query_chars</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;selectivity&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>  <span class=c1># 선택도</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;table_size&#39;</span><span class=p>:</span> <span class=n>query_chars</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;table_size&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>    <span class=c1># 테이블 크기</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;concurrent_txns&#39;</span><span class=p>:</span> <span class=n>query_chars</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;concurrent_txns&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>  <span class=c1># 동시 트랜잭션 수</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;operation_type&#39;</span><span class=p>:</span> <span class=n>query_chars</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;op_type&#39;</span><span class=p>,</span> <span class=s1>&#39;read&#39;</span><span class=p>),</span>  <span class=c1># 연산 유형</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;access_pattern&#39;</span><span class=p>:</span> <span class=n>query_chars</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;pattern&#39;</span><span class=p>,</span> <span class=s1>&#39;random&#39;</span><span class=p>)</span>  <span class=c1># 접근 패턴</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=해시-기반-락-테이블--알고리즘적-최적화>해시 기반 락 테이블 / 알고리즘적 최적화<a hidden class=anchor aria-hidden=true href=#해시-기반-락-테이블--알고리즘적-최적화>#</a></h6><ul><li><strong>정의</strong>: 락 테이블을 해시 버킷으로 관리해 락 검색·갱신을 O(1) 평균으로 구현.</li><li><strong>특징</strong>: 빠른 검색, 부분 락 (bucket-level) 로 경쟁 완화, 리사이징 비용 고려.</li><li><strong>목적</strong>: 락 획득/해제 지연 최소화.</li><li><strong>사용 상황</strong>: 고요청·저지연 시스템, 많은 동시 트랜잭션.</li><li><strong>예시</strong>: 버킷별 락 (시분할) + 부분 리사이징 전략.</li></ul><p><strong>운영 주의</strong>: 리사이징 동기화가 병목이 될 수 있으니 점진적 리사이징 설계 필요.</p><h6 id=키---범위--프레디킷-락-range--predicate-locks>키 - 범위 / 프레디킷 락 (Range / Predicate Locks)<a hidden class=anchor aria-hidden=true href=#키---범위--프레디킷-락-range--predicate-locks>#</a></h6><ul><li><strong>정의</strong>: 인덱스 범위나 프레디킷 단위로 잠금하여 신규 레코드 삽입으로 인한 팬텀을 방지하는 락.</li><li><strong>특징</strong>: 팬텀 차단 (Serializable 보장), 구현 방식은 DB 마다 상이 (gap-lock 등).</li><li><strong>목적</strong>: 특정 격리 수준에서 일관성 보증.</li><li><strong>사용 상황</strong>: 반복 가능한 읽기/직렬화가 필요한 트랜잭션, 범위 쿼리 빈번 환경.</li><li><strong>예시</strong>: <code>SELECT … WHERE id BETWEEN a AND b FOR UPDATE</code> 시 범위 락.</li></ul><p><strong>운영 주의</strong>: 범위 락은 쓰기 지연을 유발할 수 있으므로 인덱스·쿼리 설계로 빈도 줄이기.</p><h6 id=분산-전환--어드바이저리--합의-펜싱-전략>분산 전환 / 어드바이저리 → 합의 (펜싱) 전략<a hidden class=anchor aria-hidden=true href=#분산-전환--어드바이저리--합의-펜싱-전략>#</a></h6><ul><li><strong>정의</strong>: 애플리케이션 레벨 advisory 락에서 분산 환경으로 확장 시 etcd/zk/Redis 기반 분산락과 펜싱 토큰으로 전환하는 전략.</li><li><strong>특징</strong>: 네트워크 분할·스플릿브레인 대비, 펜싱으로 stale leader 방지.</li><li><strong>목적</strong>: 분산 환경에서의 안전한 락 소유 보장.</li><li><strong>사용 상황</strong>: 서비스가 멀티노드·멀티리전으로 확장될 때.</li><li><strong>예시</strong>: Redis <code>SET key val NX PX</code> + fencing token, or etcd lease 기반 락.</li></ul><p><strong>운영 주의</strong>: 분산락은 네트워크 지연·가용성 트레이드오프가 있으므로 필수적 작업만 글로벌 락으로 처리.</p><h6 id=보조-기법-타임아웃-백오프-우선순위-스케줄링>보조 기법: 타임아웃, 백오프, 우선순위 스케줄링<a hidden class=anchor aria-hidden=true href=#보조-기법-타임아웃-백오프-우선순위-스케줄링>#</a></h6><ul><li><strong>정의/목적</strong>: 블로킹을 완화하고 기아를 방지하기 위한 운영 기법들 (타임아웃, exponential backoff, priority/aging).</li><li><strong>사용 상황</strong>: 대기 시간이 부담되거나 SLA 가 민감한 트랜잭션이 있는 경우.</li></ul><h5 id=잠금-구현-기법-요약표>잠금 구현 기법 요약표<a hidden class=anchor aria-hidden=true href=#잠금-구현-기법-요약표>#</a></h5><table><thead><tr><th>기법</th><th>정의</th><th>특징</th><th>목적</th><th>사용 상황</th><th>예시</th></tr></thead><tbody><tr><td>계층적 잠금 (MGL)</td><td>상위→하위 의도락 후 실제락</td><td>IS/IX/SIX, 상향식 해제</td><td>락 검사 비용 절감</td><td>대형 테이블/파티션</td><td>상위 IS → 행 S</td></tr><tr><td>락 승격</td><td>세부락 → 상위락 자동 전환</td><td>임계값 기반, 메모리 절감</td><td>관리 오버헤드 감소</td><td>대량 업데이트</td><td>행락 수 초과 → 테이블 X</td></tr><tr><td>적응형 선택</td><td>과거 패턴 기반 입도 예측</td><td>학습 기반, 온라인 적용</td><td>워크로드 적응 최적화</td><td>혼합 워크로드</td><td>row/page/table 선택</td></tr><tr><td>해시 락테이블</td><td>해시 버킷 기반 락 관리</td><td>O(1) 평균, 부분락</td><td>락 획득 지연 최소화</td><td>고동시성 시스템</td><td>bucketed lock table</td></tr><tr><td>키 - 범위 락</td><td>인덱스 범위 단위 잠금</td><td>팬텀 방지, DB 별 구현 차이</td><td>격리 보장 (Serializable)</td><td>범위쿼리多</td><td>gap-lock / predicate-lock</td></tr><tr><td>분산 락 (펜싱)</td><td>etcd/zk/Redis 기반 분산락</td><td>펜싱 토큰, lease</td><td>분산 환경 안전성</td><td>멀티노드·멀티리전</td><td>Redis SET NX PX + token</td></tr><tr><td>운영 기법</td><td>타임아웃/백오프/우선순위</td><td>기아 방지·혼잡 완화</td><td>응답성 보장</td><td>SLA 민감 시스템</td><td>exponential backoff</td></tr></tbody></table><ul><li><p><strong>무엇을 하는가?</strong>: " 어떤 크기 (unit) 로 데이터를 잠글지 " 를 결정하고, 그 결정을 실행하는 여러 기법을 구현하는 일.</p></li><li><p><strong>왜 중요한가?</strong>: 세밀하게 잠그면 동시에 더 많은 작업이 가능하지만 관리비용이 커지고, 거칠게 잠그면 간단하지만 동시성이 떨어져 서비스 응답성이 저하된다.</p></li><li><p><strong>핵심 아이디어</strong>: 상위에 <strong>의도락</strong>을 찍어 하위 락 충돌을 미리 판단하고, 많은 세부 락은 <strong>승격</strong>으로 관리 부담을 낮추며, 워크로드에 따라 <strong>적응형</strong>으로 입도를 바꿀 수 있다.</p></li><li><p><strong>실무 팁</strong>: 먼저 워크로드 (읽기/쓰기 비율, 범위 쿼리 비중) 를 측정 → 보수적 기본 정책 적용 → 모니터링·벤치마크로 튜닝.</p></li></ul><h5 id=잠금-구현-카테고리별-정리>잠금 구현 카테고리별 정리<a hidden class=anchor aria-hidden=true href=#잠금-구현-카테고리별-정리>#</a></h5><h6 id=락-관리운영-기법>락 관리/운영 기법<a hidden class=anchor aria-hidden=true href=#락-관리운영-기법>#</a></h6><p>계층적 잠금 (MGL), 락 승격, 타임아웃/백오프, 우선순위 스케줄링 등을 포함.</p><ul><li>핵심 아이디어: 상위 의도락으로 충돌을 조기에 판정하고, 세부락 과다시 승격으로 관리부하를 줄이며, 대기 정책 (타임아웃/백오프) 으로 혼잡을 완화한다.</li><li>운영 포인트: 승격 임계값, 대기 타임아웃, 데드락 탐지 주기 설정, 모니터링 (esc_count, deadlock_count) 필요.</li></ul><table><thead><tr><th>기법</th><th>핵심 동작</th><th>운영 지표</th></tr></thead><tbody><tr><td>계층적 잠금 (MGL)</td><td>상위 IS/IX → 하위 S/X</td><td>IS/IX 획득률, lock wait</td></tr><tr><td>락 승격</td><td>임계치 초과 시 테이블락</td><td>escalation_count, lock table size</td></tr><tr><td>타임아웃/백오프</td><td>대기 중 타임아웃 후 재시도</td><td>timeout_rate, retry_rate</td></tr></tbody></table><ul><li>핵심 요약: 락 관리 기법은 시스템 안정성·운영 비용에 직접적 영향을 준다. 임계값·타임아웃 설계와 모니터링이 핵심이다.</li></ul><h6 id=알고리즘자료구조-기법>알고리즘·자료구조 기법<a hidden class=anchor aria-hidden=true href=#알고리즘자료구조-기법>#</a></h6><p>해시 락테이블, 부분락 (bucketed locks), 효율적 호환성 검사 등.</p><ul><li>핵심 아이디어: 락 획득/해제의 평균 지연을 줄이기 위해 자료구조 (해시·버킷) 를 사용하고, 리사이징/슬로우 경로를 안전하게 설계한다.</li><li>운영 포인트: 버킷 충돌률, lookup latency, 리사이징 시간 및 영향 측정.</li></ul><table><thead><tr><th>기법</th><th>핵심 동작</th><th>운영 지표</th></tr></thead><tbody><tr><td>해시 락테이블</td><td>버킷화로 O(1) 평균 접근</td><td>lookup latency, collision rate</td></tr><tr><td>부분 락</td><td>버킷 단위 경쟁 완화</td><td>bucket hotness, contention</td></tr></tbody></table><ul><li>핵심 요약: 올바른 자료구조는 동시성 병목을 크게 낮춘다. 리사이징·동기화 비용을 반드시 고려하라.</li></ul><h6 id=적응분산-기법>적응·분산 기법<a hidden class=anchor aria-hidden=true href=#적응분산-기법>#</a></h6><p>적응형 잠금 선택, 키 - 범위 락, 분산락 (펜싱, lease) 포함.</p><ul><li>핵심 아이디어: 워크로드 변화에 동적으로 대응하거나 분산 환경에서 안전한 락 소유를 보장한다.</li><li>운영 포인트: 학습 모델 안정성, 펜싱 실패 비율, replica lag 와 락 일관성 관계 확인.</li></ul><table><thead><tr><th>기법</th><th>핵심 동작</th><th>운영 지표</th></tr></thead><tbody><tr><td>적응형 선택</td><td>과거 패턴으로 최적 입도 선택</td><td>model accuracy, regression in perf</td></tr><tr><td>키 - 범위 락</td><td>인덱스 범위로 팬텀 방지</td><td>range lock count, write latency</td></tr><tr><td>분산 락 (펜싱)</td><td>lease+token 으로 소유 보장</td><td>fencing failure, network latency</td></tr></tbody></table><ul><li>핵심 요약: 적응형/분산 기법은 고난도지만 효과가 크다. 작은 범위에서 파일럿 후 점진 적용하라.</li></ul><h5 id=잠금-기법-카테고리-요약표>잠금 기법 카테고리 요약표<a hidden class=anchor aria-hidden=true href=#잠금-기법-카테고리-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>기법</th><th>목적</th><th>장점</th><th>주의사항 (운영)</th></tr></thead><tbody><tr><td>A 락 관리</td><td>MGL, 승격, 타임아웃</td><td>충돌 판정·운영 안정</td><td>비용 절감·충돌 조기 감지</td><td>임계값·데드락 처리</td></tr><tr><td>B 알고리즘</td><td>해시 테이블, 부분락</td><td>획득 지연 최소화</td><td>낮은 latency</td><td>리사이징 동기화 비용</td></tr><tr><td>C 적응·분산</td><td>적응형 선택, range lock, 분산락</td><td>워크로드 적응·분산 안전</td><td>높은 효율·안전성</td><td>모델 실패·네트워크 영향</td></tr></tbody></table><h4 id=락-분류-및-적용-전략>락 분류 및 적용 전략<a hidden class=anchor aria-hidden=true href=#락-분류-및-적용-전략>#</a></h4><ul><li><p><strong>무엇인가?</strong> 락 입도는 &rsquo; 어떤 단위로 락을 걸 것인가 &rsquo; 이다.</p></li><li><p><strong>왜 중요한가?</strong> 단위가 작으면 동시에 더 많은 작업을 처리할 수 있지만 시스템은 더 많은 락을 관리해야 한다.</p></li><li><p><strong>어떻게 선택하나?</strong> 워크로드 (읽기/쓰기 비율, 핫스팟, 트랜잭션 길이), DBMS 특성 (MVCC/비 MVCC), 분산 요건을 고려해 결정한다.</p></li><li><p><strong>현장에서의 기본 규칙</strong>: 가능한 한 행 단위로 (작게) → 모니터링으로 오버헤드 관찰 → 필요 시 파티셔닝/에스컬레이션 정책 적용.</p></li></ul><h5 id=락-유형별-핵심-비교표>락 유형별 핵심 비교표<a hidden class=anchor aria-hidden=true href=#락-유형별-핵심-비교표>#</a></h5><table><thead><tr><th>유형</th><th>입도 (예)</th><th style=text-align:right>충돌 범위</th><th style=text-align:right>동시성</th><th style=text-align:right>오버헤드</th><th>주 사용 사례</th><th>구현/운영 고려사항</th></tr></thead><tbody><tr><td>Row (레코드)</td><td>행 단위</td><td style=text-align:right>최소</td><td style=text-align:right>최고</td><td style=text-align:right>매우 높음</td><td>OLTP, 계좌·주문</td><td>많은 락 오브젝트·메모리, 데드락 주의</td></tr><tr><td>Key-range (키 - 범위)</td><td>인덱스 범위</td><td style=text-align:right>작음 (범위)</td><td style=text-align:right>높음</td><td style=text-align:right>높음</td><td>Serializable, 범위 잠금</td><td>인덱스 설계 필수, phantom 방지</td></tr><tr><td>Page/Block (페이지)</td><td>페이지·블록</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td><td>스토리지 최적화</td><td>물리 레이아웃 영향, 엔진 종속</td></tr><tr><td>Partition (파티션)</td><td>샤드·파티션</td><td style=text-align:right>중간~큼</td><td style=text-align:right>중간</td><td style=text-align:right>낮음</td><td>배치·샤드 처리</td><td>샤딩 키 설계와 결합 필요</td></tr><tr><td>Table (테이블)</td><td>테이블 전체</td><td style=text-align:right>큼</td><td style=text-align:right>낮음</td><td style=text-align:right>낮음</td><td>DDL, 대량 변경</td><td>단순·안전하지만 동시성 저하</td></tr><tr><td>DB (데이터베이스)</td><td>전체 DB</td><td style=text-align:right>최대</td><td style=text-align:right>매우 낮음</td><td style=text-align:right>매우 낮음</td><td>마이그레이션/유지보수</td><td>넓은 유지보수 창 필요</td></tr><tr><td>Hierarchical (계층)</td><td>혼합 (의도락)</td><td style=text-align:right>유연</td><td style=text-align:right>유연</td><td style=text-align:right>유연</td><td>일반 DBMS 기본</td><td>IS/IX 등 호환성 규칙 필요</td></tr></tbody></table><h5 id=락-분류-기준-카테고리>락 분류 기준 카테고리<a hidden class=anchor aria-hidden=true href=#락-분류-기준-카테고리>#</a></h5><h6 id=입도-레벨-크기-기준>입도 레벨 (크기 기준)<a hidden class=anchor aria-hidden=true href=#입도-레벨-크기-기준>#</a></h6><p>Row, Key-range, Page, Partition, Table, DB 등 실제 적용 단위를 기준으로 분류.</p><table><thead><tr><th>입도</th><th style=text-align:right>충돌 범위</th><th style=text-align:right>동시성</th><th style=text-align:right>오버헤드</th><th>대표 사용 예</th><th>운영 포인트</th></tr></thead><tbody><tr><td>Row</td><td style=text-align:right>최소</td><td style=text-align:right>최고</td><td style=text-align:right>매우 높음</td><td>OLTP(계좌,주문)</td><td>데드락·메모리 관찰</td></tr><tr><td>Key-range</td><td style=text-align:right>작음 (범위)</td><td style=text-align:right>높음</td><td style=text-align:right>높음</td><td>Serializable 격리, 범위 잠금</td><td>인덱스 설계 중요</td></tr><tr><td>Page</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td><td>스토리지/엔진 최적화</td><td>페이지 레이아웃 영향</td></tr><tr><td>Partition</td><td style=text-align:right>중~큼</td><td style=text-align:right>중간</td><td style=text-align:right>낮음</td><td>파티셔닝·샤딩</td><td>샤드 키 설계</td></tr><tr><td>Table</td><td style=text-align:right>큼</td><td style=text-align:right>낮음</td><td style=text-align:right>낮음</td><td>DDL, 일괄 작업</td><td>동시성 저하 주의</td></tr><tr><td>DB</td><td style=text-align:right>최대</td><td style=text-align:right>매우 낮음</td><td style=text-align:right>매우 낮음</td><td>마이그레이션</td><td>전역 유지보수 창</td></tr></tbody></table><p>입도 레벨은 동시성과 오버헤드의 전형적 트레이드오프로 요약된다. OLTP 는 Row, 대량 배치는 Partition/Table 을 선호.</p><h6 id=동작-모드-조정-방식>동작 모드 (조정 방식)<a hidden class=anchor aria-hidden=true href=#동작-모드-조정-방식>#</a></h6><p>락 적용이 어떻게 조정되는지 (정적 vs 동적 vs 적응적).</p><table><thead><tr><th>모드</th><th>설명</th><th style=text-align:right>복잡도</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>Static</td><td>설정 파일/설계 시 고정</td><td style=text-align:right>낮음</td><td>예측 가능</td><td>워크로드 변화에 취약</td></tr><tr><td>Dynamic</td><td>운영자가 런타임 조정 가능</td><td style=text-align:right>중간</td><td>상황 대응 가능</td><td>운영 관리 비용</td></tr><tr><td>Adaptive</td><td>시스템이 런타임 자동 조정</td><td style=text-align:right>높음</td><td>자동 최적화</td><td>구현 복잡, 안정성 검증 필요</td></tr></tbody></table><p>초기에는 Static 으로 시작해 모니터링 기반으로 Dynamic/Adaptive 로 옮기는 전략이 현실적이다.</p><h6 id=범위-분산-관점>범위 (분산 관점)<a hidden class=anchor aria-hidden=true href=#범위-분산-관점>#</a></h6><p>로컬 샤드 내 처리인지, 전역 일관성이 필요한지에 따른 분류.</p><table><thead><tr><th>범위</th><th>설명</th><th>장점</th><th>단점</th><th>적용 팁</th></tr></thead><tbody><tr><td>Local</td><td>샤드/파티션 내부 락</td><td>낮은 레이턴시, 확장성</td><td>전역 일관성 부족</td><td>가능하면 로컬로 처리</td></tr><tr><td>Global</td><td>전역 락 (합의 필요)</td><td>일관성 보장</td><td>네트워크 비용·지연</td><td>펜싱·lease 사용 권장</td></tr></tbody></table><p>분산 시스템에서는 가능한 한 로컬 락 설계를 우선하고, 전역 락은 최소화하라.</p><h5 id=락-분류-통합-요약표>락 분류 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-분류-통합-요약표>#</a></h5><table><thead><tr><th>축</th><th>카테고리</th><th>예시</th><th>장점</th><th>단점</th><th>주의점</th></tr></thead><tbody><tr><td>입도</td><td>Row / Key-range / Page / Partition / Table / DB</td><td>Row: 행, Table: 전체</td><td>동시성 (입도 작을수록↑)</td><td>오버헤드 (입도 작을수록↑)</td><td>인덱스·트랜잭션 길이 고려</td></tr><tr><td>동작모드</td><td>Static / Dynamic / Adaptive</td><td>Static: config</td><td>관리 간단</td><td>워크로드 변화 취약</td><td>단계적 전환 권장</td></tr><tr><td>분산범위</td><td>Local / Global</td><td>Local: 샤드 내부</td><td>확장성·저지연</td><td>전역 일관성 부족</td><td>전역 락은 최소화</td></tr></tbody></table><h4 id=lock-granularity-도구프레임워크-지도>Lock Granularity 도구·프레임워크 지도<a hidden class=anchor aria-hidden=true href=#lock-granularity-도구프레임워크-지도>#</a></h4><p>데이터베이스 락 생태계는 크게</p><ol><li><strong>DB 엔진의 내장 락 구현</strong>(행/범위/의도 락·에스컬레이션 등)</li><li><strong>분산 락 라이브러리</strong>(Redis/ZK/etcd 로 구현한 외부 락)</li><li><strong>운영·모니터링 툴</strong>(PMM/DPA 등)</li><li><strong>애플리케이션/ORM 계층의 락 추상화</strong></li><li><strong>운영 보조 도구</strong><br>로 나눌 수 있다.<br>각 계층은 역할과 보증 수준이 다르니, <strong>일관성 보장 (ACID)</strong> 이 중요한 경우 DB 내부 락을 선호하고, <strong>서비스 간 조정</strong>은 분산 락을, <strong>운영 문제 추적</strong>은 모니터링 툴을 조합해 사용해야 한다.</li></ol><h5 id=기능별-lock-생태계-분류>기능별 Lock 생태계 분류<a hidden class=anchor aria-hidden=true href=#기능별-lock-생태계-분류>#</a></h5><h6 id=engine-level-locking-상용오픈-db>Engine-level Locking (상용/오픈 DB)<a hidden class=anchor aria-hidden=true href=#engine-level-locking-상용오픈-db>#</a></h6><p>내부 트랜잭션 엔진이 제공하는 락 모델로, 행/페이지/테이블 수준 락, 의도락, 갭/next-key 락, MVCC 등을 포함. 일관성 (ACID) 을 보장하기 위한 핵심 수단.</p><table><thead><tr><th>제품/기능</th><th>정확한 기능</th><th style=text-align:right>장점</th><th>단점</th><th>주의점 / 연관성</th></tr></thead><tbody><tr><td>MySQL InnoDB</td><td>row locks, next-key/gap lock, intention locks</td><td style=text-align:right>팬텀 방지·강한 일관성 (레거시)</td><td>gap lock 으로 인한 의도치 않은 경합</td><td>애플리케이션 쿼리 패턴 고려 필요.</td></tr><tr><td>PostgreSQL</td><td>MVCC, row/page locks, advisory locks</td><td style=text-align:right>읽기 비차단·높은 동시성</td><td>VACUUM/GC 관리 필요</td><td>advisory lock 은 앱 레벨 협조용.</td></tr><tr><td>Oracle / SQL Server</td><td>행/블록/테이블, intention locks, escalation</td><td style=text-align:right>세밀한 제어·상업적 지원</td><td>복잡한 튜닝·라이센스 비용</td><td>엔터프라이즈 환경 적합.</td></tr></tbody></table><p>엔진 수준 락은 정합성 보장에 최적화되어 있으며, 각 제품은 범위 락·에스컬레이션·MVCC 등 구현 차이를 가진다. 운영 시 제품 문서를 기준으로 쿼리·인덱스 설계와 함께 튜닝해야 한다.</p><h6 id=distributed-coordination-외부-락리더-선출>Distributed Coordination (외부 락/리더 선출)<a hidden class=anchor aria-hidden=true href=#distributed-coordination-외부-락리더-선출>#</a></h6><p>Redis, Zookeeper, etcd 같은 코디네이터를 사용해 노드 간 상호배제·leader election·lease 관리를 수행한다. 편의성과 성능은 좋지만 안전성 전제 조건을 검증해야 한다.</p><table><thead><tr><th>라이브러리/도구</th><th>정확한 기능</th><th style=text-align:right>장점</th><th>약점 / 주의</th><th>연관성·실무 팁</th></tr></thead><tbody><tr><td>Redis (Redlock)</td><td>분산 락 알고리즘 (여러 인스턴스에 키 분산)</td><td style=text-align:right>간단·빠름</td><td>타이밍 가정에 민감 (안전성 논쟁)</td><td>fencing/lease 보완 권장.</td></tr><tr><td>Zookeeper</td><td>ephemeral node 기반 락·leader election</td><td style=text-align:right>강한 일관성 (분산 코디네이터)</td><td>운영 복잡성·연결 관리</td><td>분산 시스템에서 안전한 선택지</td></tr><tr><td>etcd / Consul</td><td>lease 기반 락·KV</td><td style=text-align:right>클라우드 네이티브 통합</td><td>운영 오버헤드</td><td>Kubernetes 환경과 친화적</td></tr></tbody></table><p>외부 코디네이터는 서비스 간 조정에 유용하나, 분산 특유의 타이밍·클럭 문제를 설계로 보완해야 한다.</p><h6 id=monitoring--diagnostics>Monitoring & Diagnostics<a hidden class=anchor aria-hidden=true href=#monitoring--diagnostics>#</a></h6><p>DB 내부 뷰와 외부 DPA/PMM 등은 락·대기·데드락의 실시간 가시성을 제공한다. 운영 문제 진단·알람의 핵심.</p><table><thead><tr><th>도구</th><th>정확한 기능</th><th style=text-align:right>장점</th><th>단점</th><th>활용 팁</th></tr></thead><tbody><tr><td>Percona PMM</td><td>InnoDB row lock activity, query analytics</td><td style=text-align:right>오픈소스·DB 유형 다양 지원</td><td>설정·에이전트 필요</td><td>InnoDB undo/locks 대시 권장.</td></tr><tr><td>SolarWinds DPA</td><td>wait-time anomaly, blocker aggregation</td><td style=text-align:right>상용 지원·권고 기능</td><td>비용·에이전트</td><td>블로커 탐지 기능 활용.</td></tr><tr><td>DB 내장 뷰</td><td><code>pg_locks</code>, <code>performance_schema</code>, DMVs</td><td style=text-align:right>낮은 오버헤드·정확한 상태</td><td>분석 도구 부족</td><td>정기 스냅샷 + 외부 대시 결합 권장.</td></tr></tbody></table><p>모니터링은 문제 탐지의 첫 단계다. DB 뷰와 외부 툴을 조합해 알람·장기 트렌드 관리를 설계하자.</p><h6 id=개발-프레임워크orm-레이어-응용-측-협조-advisory편의-기능->개발 프레임워크·ORM 레이어—" 응용 측 협조 (Advisory)·편의 기능 "<a hidden class=anchor aria-hidden=true href=#개발-프레임워크orm-레이어-응용-측-협조-advisory편의-기능->#</a></h6><ul><li><strong>정확한 기능 / 역할</strong>: 트랜잭션 API·락 힌트 제공, (일부) advisory lock/optimistic locking 추상화.</li><li><strong>용도</strong>: 애플리케이션 레벨 협조 락, 낙관적 락 (버전 칼럼) 사용.</li><li><strong>강점</strong>: 개발자 친화적 (추상화)·빠른 적용.</li><li><strong>약점</strong>: DB 내부 특성을 완전히 숨기는 경우 최적화·디버깅 난이도 증가.</li><li><strong>예시</strong>: Hibernate/JPA, Sequelize, TypeORM 등; PostgreSQL advisory locks 사용 예</li></ul><h6 id=보조-유틸스크립트-진단운영-보조->보조 유틸/스크립트—" 진단·운영 보조 "<a hidden class=anchor aria-hidden=true href=#보조-유틸스크립트-진단운영-보조->#</a></h6><ul><li><strong>정확한 기능 / 역할</strong>: 데드락 로그 수집, 상태 스냅샷, 포렌식 분석.</li><li><strong>용도</strong>: 사고 발생 시 원인 분석·피드백 루프.</li><li><strong>강점</strong>: 경량·실무 친화적.</li><li><strong>약점</strong>: 자동화 미비 시 반복 대응 비용 발생.</li><li><strong>예시</strong>: Percona Toolkit <code>pt-deadlock-logger</code>, <code>SHOW ENGINE INNODB STATUS</code> scripts</li></ul><h5 id=lock-생태계-통합-요약표>Lock 생태계 통합 요약표<a hidden class=anchor aria-hidden=true href=#lock-생태계-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 도구/제품</th><th style=text-align:right>핵심 역할</th><th>운영상 유의점</th></tr></thead><tbody><tr><td>Engine-level</td><td>MySQL InnoDB, PostgreSQL, Oracle</td><td style=text-align:right>트랜잭션 내 정합성·격리 보장</td><td>gap/next-key, VACUUM, 에스컬레이션 튜닝 필요. ([MySQL][2])</td></tr><tr><td>Distributed</td><td>Redis(Redlock), ZK, etcd</td><td style=text-align:right>서비스 간 상호배제·leader election</td><td>타이밍 가정·fencing 필요 (Redlock 논쟁). ([Redis][4])</td></tr><tr><td>Monitoring</td><td>Percona PMM, SolarWinds DPA</td><td style=text-align:right>wait/lock 진단·알람</td><td>수집·샘플링 설계 필요. ([Percona Docs][5])</td></tr><tr><td>ORM / App</td><td>Hibernate/JPA, Sequelize</td><td style=text-align:right>앱 레벨 협조 락·버전 검증</td><td>DB 특성 숨김 주의</td></tr><tr><td>Utilities</td><td>pt-deadlock-logger, SHOW ENGINE INNODB STATUS</td><td style=text-align:right>사고 포렌식</td><td>자동화 스크립트 권장. ([Percona Docs][9])</td></tr></tbody></table><h4 id=락-표준제품운영-규격-종합안>락 표준·제품·운영 규격 종합안<a hidden class=anchor aria-hidden=true href=#락-표준제품운영-규격-종합안>#</a></h4><p>표준 및 규격은 데이터베이스의 <strong>동시성·무결성 보장 틀</strong>을 제공한다. SQL 표준은 다양한 격리 수준을 정의해 어떤 이상 현상을 허용할지 규정하고, ACID 는 트랜잭션의 신뢰성을 보장한다. 분산 트랜잭션 (XA/2PC) 은 여러 시스템에 걸친 일관성을 조정하는 규격이다. 다만 실제 시스템에서는 각 DBMS 가 표준을 해석·확장하므로, 설계자는 <strong>표준 이해 + 특정 DB 구현·운영 규칙</strong>을 함께 숙지해야 한다.</p><h5 id=granularity-표준규격>Granularity 표준·규격<a hidden class=anchor aria-hidden=true href=#granularity-표준규격>#</a></h5><table><thead><tr><th>표준/규격</th><th>핵심 내용</th><th style=text-align:right>런타임 요구사항</th><th>실무적 주의점</th></tr></thead><tbody><tr><td>ISO/ANSI SQL 격리수준</td><td>격리 단계 (READ UNCOMMITTED → SERIALIZABLE) 정의</td><td style=text-align:right>트랜잭션 엔진은 각 레벨 동작 보장</td><td>DB 별 동작 차이 (예: RR 구현 방식) 검증 필요</td></tr><tr><td>ACID</td><td>원자성·일관성·격리성·지속성 보장</td><td style=text-align:right>로그·복구·커밋 프로토콜 필요</td><td>성능·동시성과 트레이드오프 존재</td></tr><tr><td>X/Open XA (2PC)</td><td>분산 트랜잭션 조정 (Prepare/Commit)</td><td style=text-align:right>글로벌 TX ID, 회복 매커니즘 필요</td><td>Heuristic 결정/타임아웃 정책 명문화 필요</td></tr><tr><td>락 호환성 모드</td><td>S/X/IS/IX/SIX 등 표준 모드</td><td style=text-align:right>락 매니저가 호환성 매트릭스 구현</td><td>의도락 사용 규칙·해석 통일 필요</td></tr><tr><td>DBMS 확장·세부</td><td>gap lock, SSI 등 구현 차이</td><td style=text-align:right>제품 문서 기준 동작 확인 필수</td><td>운영 가이드 (예: autovacuum, purge) 필요</td></tr></tbody></table><h5 id=락-규격-분류-표준분산운영>락 규격 분류: 표준·분산·운영<a hidden class=anchor aria-hidden=true href=#락-규격-분류-표준분산운영>#</a></h5><h6 id=sql--트랜잭션-표준-isoansi-acid>SQL / 트랜잭션 표준 (ISO/ANSI, ACID)<a hidden class=anchor aria-hidden=true href=#sql--트랜잭션-표준-isoansi-acid>#</a></h6><p>SQL 표준은 트랜잭션 격리수준 (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE) 을 정의하고, ACID 는 트랜잭션의 기본 보장 요구를 규정한다. 설계 시 <strong>어떤 격리 수준이 요구되는지</strong>(예: 금융→SERIALIZABLE) 와 그에 따른 성능 영향 (락 범위·수명) 을 명시해야 한다.</p><table><thead><tr><th>표준</th><th>핵심 요구</th><th style=text-align:right>런타임 영향</th><th>적용 포인트</th></tr></thead><tbody><tr><td>ANSI/ISO SQL 격리수준</td><td>격리 레벨별 허용 이상 현상 정의</td><td style=text-align:right>격리↑ → 동시성↓, 오버헤드↑</td><td>서비스 중요도에 따라 레벨 선택</td></tr><tr><td>ACID</td><td>트랜잭션 원자성·일관성·격리성·지속성</td><td style=text-align:right>로그·복구·WAL 필요</td><td>복구 절차·백업 정책 필수</td></tr></tbody></table><p><strong>SQL 격리수준과 ACID 는 설계의 근간</strong>이며, 표준 선택이 곧 락 정책·운영 규칙을 좌우한다.</p><h6 id=분산-트랜잭션-표준-xopen-xa-2pc>분산 트랜잭션 표준 (X/Open XA, 2PC)<a hidden class=anchor aria-hidden=true href=#분산-트랜잭션-표준-xopen-xa-2pc>#</a></h6><p>분산 트랜잭션은 여러 리소스 매니저 간 일관성을 맞춰야 하므로 2PC 프로토콜 (XA) 을 사용한다. 2PC 는 Prepare→Commit 단계로 구성되며, 실패 시 복구·heuristic 처리 규칙을 마련해야 한다. 타임아웃·재시도·진행중 복구 (rollback/commit) 정책을 문서화해야 한다.</p><table><thead><tr><th>표준</th><th>핵심 절차</th><th style=text-align:right>운영 요구</th><th>주의점</th></tr></thead><tbody><tr><td>X/Open XA (2PC)</td><td>Prepare → Commit/Abort</td><td style=text-align:right>글로벌 TX ID, 복구 매커니즘</td><td>네트워크/코디네이터 실패 시 휴리스틱 가능성</td></tr><tr><td>2PC 운영 가이드</td><td>타임아웃·재시도 정책 정의</td><td style=text-align:right>로그·재시작 메커니즘</td><td>운영 자동화·감시 필요</td></tr></tbody></table><p><strong>분산 트랜잭션은 복구 시나리오가 핵심</strong>이며, 운영 규칙을 명확히 해두지 않으면 서비스 장애가 장기화될 수 있다.</p><h6 id=락-모드-및-호환성-규약-sxisixsix>락 모드 및 호환성 규약 (S/X/IS/IX/SIX)<a hidden class=anchor aria-hidden=true href=#락-모드-및-호환성-규약-sxisixsix>#</a></h6><p>락 모드는 데이터 접근 권한을 규정한다 (공유·배타·의도락 등). 락 매니저는 모드 간 호환성 매트릭스를 구현해야 하며, 의도락은 멀티레벨 락 (테이블→행) 에서 탐색 비용을 줄인다. 표준화된 매트릭스와 DB 별 해석 차이를 문서화해야 한다.</p><table><thead><tr><th>모드</th><th>의미</th><th style=text-align:right>동시 허용 예</th><th>비고</th></tr></thead><tbody><tr><td>S(Shared)</td><td>읽기 허용</td><td style=text-align:right>다른 S 허용</td><td>읽기 중심 워크로드 유리</td></tr><tr><td>X(Exclusive)</td><td>읽기/쓰기 독점</td><td style=text-align:right>다른 락 불허</td><td>갱신시 사용</td></tr><tr><td>IS/IX</td><td>의도락</td><td style=text-align:right>상위에서 하위 락 의도 표기</td><td>계층적 락 성능 보조</td></tr></tbody></table><p><strong>락 모드 표준은 DB 내부 락 충돌 규칙의 기본</strong>이며, 구현 규칙을 운영 정책에 반영해야 한다.</p><h6 id=dbms-별-구현확장-규칙-제품-특화-동작>DBMS 별 구현·확장 규칙 (제품 특화 동작)<a hidden class=anchor aria-hidden=true href=#dbms-별-구현확장-규칙-제품-특화-동작>#</a></h6><p>표준은 원칙을 제시하지만, 실제 동작은 DBMS 별로 달라진다. 예: InnoDB 의 gap lock, PostgreSQL 의 SSI, Oracle 의 행 버전 관리 등. 각 제품의 문서를 기준으로 &rsquo; 제품별 예외·권장 설정 &rsquo; 을 운영 카탈로그로 관리해야 한다.</p><table><thead><tr><th>제품</th><th>대표 확장/특징</th><th style=text-align:right>운영 영향</th><th>권장 문서화</th></tr></thead><tbody><tr><td>MySQL (InnoDB)</td><td>Gap lock, autovacuum 유사 제어</td><td style=text-align:right>범위 락·팬텀 영향</td><td>갭락 동작·회피법 문서화</td></tr><tr><td>Postgres</td><td>MVCC, Serializable via SSI</td><td style=text-align:right>스냅샷 격리 특성</td><td>vacuum/oldest XID 관리</td></tr><tr><td>Oracle</td><td>멀티 버전·잠금 정책</td><td style=text-align:right>undo/redo 관리</td><td>undo retention·GC 운영</td></tr></tbody></table><p><strong>제품별 차이를 모르고 표준만 따르려하면 사고 난다.</strong> 제품 문서 기반 운영 매뉴얼 필수.</p><h6 id=운영감사보안-규격-모니터링과-컴플라이언스>운영·감사·보안 규격 (모니터링과 컴플라이언스)<a hidden class=anchor aria-hidden=true href=#운영감사보안-규격-모니터링과-컴플라이언스>#</a></h6><p>표준 준수는 기능뿐 아니라 운영·감사 측면에서도 요구된다. 락 관련 로그 (데드락 이벤트, 장시간 대기), SLA 준수 지표, 감사 로그 보존 정책을 규격화해야 한다. 모니터링 지표와 알람 임계값도 표준 운영 문서에 포함될 것.</p><table><thead><tr><th>항목</th><th>권장 지표</th><th style=text-align:right>보존/알람 정책</th><th>적용 예</th></tr></thead><tbody><tr><td>데드락</td><td>deadlock_rate, deadlock_events</td><td style=text-align:right>즉시 알람·30 일 로그 보관</td><td>금융 트랜잭션 모니터링</td></tr><tr><td>대기</td><td>avg_lock_wait, p99_lock_wait</td><td style=text-align:right>임계 초과 알람</td><td>API SLA 연동</td></tr><tr><td>감사</td><td>lock_acquire/release 로그</td><td style=text-align:right>보관 기간·무결성 서명</td><td>규제 준수 감사용</td></tr></tbody></table><p>**운영 규격은 표준 준수의 &rsquo; 실제 증거 &lsquo;**이며, 규정된 지표·보존 정책이 없으면 규격 준수가 불완전하다.</p><h5 id=락-표준구현운영-종합표>락 표준·구현·운영 종합표<a hidden class=anchor aria-hidden=true href=#락-표준구현운영-종합표>#</a></h5><table><thead><tr><th>분류</th><th>표준/규격</th><th style=text-align:right>핵심 요구</th><th>운영 체크포인트</th></tr></thead><tbody><tr><td>A SQL/트랜잭션</td><td>ISO/ANSI SQL, ACID</td><td style=text-align:right>격리수준·무결성 보장</td><td>적용 레벨 문서화, 성능 영향 검증</td></tr><tr><td>B 분산 TX</td><td>X/Open XA, 2PC</td><td style=text-align:right>글로벌 커밋/복구 절차</td><td>타임아웃·heuristic 정책 명기</td></tr><tr><td>C 락 모드</td><td>S/X/IS/IX/SIX</td><td style=text-align:right>호환성 매트릭스 구현</td><td>의도락 사용 규칙 문서화</td></tr><tr><td>D 제품 확장</td><td>InnoDB gap lock, Postgres SSI</td><td style=text-align:right>제품별 예외·설정</td><td>제품별 운영 매뉴얼 보관</td></tr><tr><td>E 운영·감사</td><td>모니터링·감사 규격</td><td style=text-align:right>로그·지표·알람</td><td>임계값·보존정책·감사 절차</td></tr></tbody></table><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-행-락-vs-테이블-락의-처리량-차이-postgresql>실습 예제: 행 락 Vs 테이블 락의 처리량 차이 (PostgreSQL)<a hidden class=anchor aria-hidden=true href=#실습-예제-행-락-vs-테이블-락의-처리량-차이-postgresql>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>세분화에 따른 처리량/대기시간 차이를 체감</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>PostgreSQL 14+, <code>psycopg</code> 또는 <code>psycopg2</code>, 샘플 테이블 <code>accounts(id PK, balance int)</code></li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>두 세션에서 경쟁 시나리오 구성</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 행 락
</span></span></span><span class=line><span class=cl><span class=c1>-- 10초 유지 후 COMMIT
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1>1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2>2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3>3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션2 (동일 행)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- 세션1이 커밋할 때까지 대기
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>테이블 락으로 변경</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1>1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2>2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3>3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>LOCK</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=k>EXCLUSIVE</span><span class=w> </span><span class=k>MODE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 테이블 락
</span></span></span><span class=line><span class=cl><span class=c1>-- 임의 작업 후 COMMIT
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1>1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2>2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3>3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션2 (다른 행)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=w> </span><span class=c1>-- 즉시 대기로 전환
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>행 락: id=1 만 대기, id=2 갱신은 병행 가능</li><li>테이블 락: 모든 행 작업이 대기 → 처리량 저하</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li><code>SELECT … FOR UPDATE SKIP LOCKED</code> 사용 시 대기 회피</li></ul><h5 id=실습-예제-키---범위-락과-팬텀-방지-개념>실습 예제: 키 - 범위 락과 팬텀 방지 (개념)<a hidden class=anchor aria-hidden=true href=#실습-예제-키---범위-락과-팬텀-방지-개념>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>범위 삽입 차단 효과 이해</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1>1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2>2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3>3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션1 (Serializable)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>BEGIN</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>SERIALIZABLE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>orders</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>amount</span><span class=w> </span><span class=k>BETWEEN</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=mi>200</span><span class=p>;</span><span class=w> </span><span class=c1>-- 범위 읽기
</span></span></span><span class=line><span class=cl><span class=c1>-- 세션1이 끝날 때까지 100~200 사이로의 INSERT가 차단(엔진별 구현 차)
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1>1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 세션2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>orders</span><span class=p>(</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>amount</span><span class=p>)</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=mi>999</span><span class=p>,</span><span class=w> </span><span class=mi>150</span><span class=p>);</span><span class=w> </span><span class=c1>-- 범위 잠금으로 대기/충돌 가능
</span></span></span></code></pre></td></tr></table></div></div><h5 id=python-예제-경합대기-측정-psycopg>Python 예제: 경합/대기 측정 (Psycopg)<a hidden class=anchor aria-hidden=true href=#python-예제-경합대기-측정-psycopg>#</a></h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span><span class=lnt id=hl-17-26><a class=lnlinks href=#hl-17-26>26</a>
</span><span class=lnt id=hl-17-27><a class=lnlinks href=#hl-17-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># pip install psycopg[binary]</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span><span class=o>,</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>psycopg</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DSN</span> <span class=o>=</span> <span class=s2>&#34;postgres://user:pass@localhost:5432/app&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>lock_row</span><span class=p>(</span><span class=nb>id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>psycopg</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DSN</span><span class=p>,</span> <span class=n>autocommit</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span> <span class=k>as</span> <span class=n>cur</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;SELECT * FROM accounts WHERE id=</span><span class=si>%s</span><span class=s2> FOR UPDATE&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nb>id</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span>  <span class=c1># 락 유지</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UPDATE accounts SET balance = balance + 1 WHERE id=</span><span class=si>%s</span><span class=s2>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nb>id</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>update_row</span><span class=p>(</span><span class=nb>id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>t0</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>psycopg</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=n>DSN</span><span class=p>,</span> <span class=n>autocommit</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span> <span class=k>as</span> <span class=n>cur</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UPDATE accounts SET balance = balance + 1 WHERE id=</span><span class=si>%s</span><span class=s2>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nb>id</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;id=</span><span class=si>{</span><span class=nb>id</span><span class=si>}</span><span class=s2> waited=</span><span class=si>{</span><span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span><span class=o>-</span><span class=n>t0</span><span class=si>:</span><span class=s2>f</span><span class=si>}</span><span class=s2>s&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 서로 다른 행은 병행, 동일 행은 대기</span>
</span></span><span class=line><span class=cl><span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>lock_row</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=mi>1</span><span class=p>,))</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>update_row</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=mi>2</span><span class=p>,))</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>update_row</span><span class=p>,</span> <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=mi>1</span><span class=p>,))</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=실습-예제-python-으로-인텐션-락-기반-계층적-mgl-시뮬레이션>실습 예제: Python 으로 인텐션 락 기반 계층적 MGL 시뮬레이션<a hidden class=anchor aria-hidden=true href=#실습-예제-python-으로-인텐션-락-기반-계층적-mgl-시뮬레이션>#</a></h5><h6 id=목적-2>목적<a hidden class=anchor aria-hidden=true href=#목적-2>#</a></h6><ul><li>계층별 데이터 (데이터베이스 - 테이블 - 레코드) 에 트랜잭션이 올바른 락을 순차적으로 신청/해제할 수 있는 구조와 호환성 검증을 직접 실습한다.</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>Python 3.x 환경</li><li>트리 구조 데이터 지원 라이브러리 (optional, 기본은 dict 로 처리)</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>1 단계: 계층 데이터 및 락 구조 정의</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1>1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2>2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3>3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4>4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5>5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6>6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7>7</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 데이터 계층, 락 테이블 및 호환성 정의</span>
</span></span><span class=line><span class=cl><span class=n>database</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;table1&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;record1&#39;</span><span class=p>:</span> <span class=p>{},</span> <span class=s1>&#39;record2&#39;</span><span class=p>:</span> <span class=p>{}},</span> <span class=s1>&#39;table2&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;record3&#39;</span><span class=p>:</span> <span class=p>{}}}</span>
</span></span><span class=line><span class=cl><span class=n>lock_table</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># {&#39;node_path&#39;: {&#39;transaction&#39;: &#39;LOCK_MODE&#39;}}</span>
</span></span><span class=line><span class=cl><span class=n>compatibility</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=s1>&#39;IS&#39;</span><span class=p>],</span> <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=p>[],</span> <span class=s1>&#39;IS&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=s1>&#39;IS&#39;</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>,</span> <span class=s1>&#39;SIX&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;IX&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;IS&#39;</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>,</span> <span class=s1>&#39;SIX&#39;</span><span class=p>],</span> <span class=s1>&#39;SIX&#39;</span><span class=p>:</span> <span class=p>[</span><span class=s1>&#39;IS&#39;</span><span class=p>,</span> <span class=s1>&#39;IX&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 락 신청 알고리즘 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1>1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2>2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3>3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4>4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5>5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6>6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7>7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>request_lock</span><span class=p>(</span><span class=n>transaction</span><span class=p>,</span> <span class=n>node_path</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 호환성 체크 · 상위노드 Intention Lock 동시 처리</span>
</span></span><span class=line><span class=cl>    <span class=c1># 실무에서는 lock_table 및 compatibility 매트릭스를 참조해 충돌 확인</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[</span><span class=si>{</span><span class=n>transaction</span><span class=si>}</span><span class=s2>] </span><span class=si>{</span><span class=n>node_path</span><span class=si>}</span><span class=s2>에 &#39;</span><span class=si>{</span><span class=n>mode</span><span class=si>}</span><span class=s2>&#39; 락 신청&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 실제 구현에서는 상위노드 및 하위노드에 해당 모드의 락을 걸어야 함</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>request_lock</span><span class=p>(</span><span class=s1>&#39;T1&#39;</span><span class=p>,</span> <span class=s1>&#39;database/table1/record1&#39;</span><span class=p>,</span> <span class=s1>&#39;S&#39;</span><span class=p>)</span>  <span class=c1># 예시: T1이 레코드 하나 읽기</span>
</span></span><span class=line><span class=cl><span class=n>request_lock</span><span class=p>(</span><span class=s1>&#39;T2&#39;</span><span class=p>,</span> <span class=s1>&#39;database/table1&#39;</span><span class=p>,</span> <span class=s1>&#39;X&#39;</span><span class=p>)</span>         <span class=c1># 예시: T2가 테이블 전체 수정</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><ul><li>각 트랜잭션이 신청한 락과, 해당 계층에 필요한 상위 노드 락 (IS/IX) 이 함께 출력된다</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>여러 트랜잭션이 동시 신청할 때 호환성 매트릭스 기반 충돌 체크, Deadlock 감지 및 시간 제한 적용 등 확장.</li></ul><h5 id=실습-예제-mysql-innodb-잠금-입도-실험>실습 예제: MySQL InnoDB 잠금 입도 실험<a hidden class=anchor aria-hidden=true href=#실습-예제-mysql-innodb-잠금-입도-실험>#</a></h5><h6 id=목적-3>목적<a hidden class=anchor aria-hidden=true href=#목적-3>#</a></h6><ul><li>다양한 잠금 입도가 동시성과 성능에 미치는 영향 체험</li><li>실제 데이터베이스에서 잠금 상승 메커니즘 관찰</li><li>격리 수준별 잠금 동작 차이점 확인</li></ul><h6 id=사전-요구사항-2>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-2>#</a></h6><ul><li>MySQL 8.0 이상 (InnoDB 스토리지 엔진)</li><li>Python 3.8+ with mysql-connector-python</li><li>동시 접속 테스트를 위한 멀티스레딩 지원</li><li>성능 모니터링을 위한 sys 스키마 접근 권한</li></ul><h6 id=단계별-구현-2>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-2>#</a></h6><ol><li><p><strong>1 단계: 테스트 환경 설정</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span><span class=lnt id=hl-20-11><a class=lnlinks href=#hl-20-11>11</a>
</span><span class=lnt id=hl-20-12><a class=lnlinks href=#hl-20-12>12</a>
</span><span class=lnt id=hl-20-13><a class=lnlinks href=#hl-20-13>13</a>
</span><span class=lnt id=hl-20-14><a class=lnlinks href=#hl-20-14>14</a>
</span><span class=lnt id=hl-20-15><a class=lnlinks href=#hl-20-15>15</a>
</span><span class=lnt id=hl-20-16><a class=lnlinks href=#hl-20-16>16</a>
</span><span class=lnt id=hl-20-17><a class=lnlinks href=#hl-20-17>17</a>
</span><span class=lnt id=hl-20-18><a class=lnlinks href=#hl-20-18>18</a>
</span><span class=lnt id=hl-20-19><a class=lnlinks href=#hl-20-19>19</a>
</span><span class=lnt id=hl-20-20><a class=lnlinks href=#hl-20-20>20</a>
</span><span class=lnt id=hl-20-21><a class=lnlinks href=#hl-20-21>21</a>
</span><span class=lnt id=hl-20-22><a class=lnlinks href=#hl-20-22>22</a>
</span><span class=lnt id=hl-20-23><a class=lnlinks href=#hl-20-23>23</a>
</span><span class=lnt id=hl-20-24><a class=lnlinks href=#hl-20-24>24</a>
</span><span class=lnt id=hl-20-25><a class=lnlinks href=#hl-20-25>25</a>
</span><span class=lnt id=hl-20-26><a class=lnlinks href=#hl-20-26>26</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 테스트 데이터베이스 생성
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>DATABASE</span><span class=w> </span><span class=n>lock_granularity_test</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>USE</span><span class=w> </span><span class=n>lock_granularity_test</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 테스트 테이블 생성 (행 수준 잠금 테스트용)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>account</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>balance</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>2</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>account_type</span><span class=w> </span><span class=nb>VARCHAR</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_type</span><span class=w> </span><span class=p>(</span><span class=n>account_type</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 테스트 데이터 삽입 (100만 행)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>account</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>seq</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ROUND</span><span class=p>(</span><span class=n>RAND</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>10000</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>CASE</span><span class=w> </span><span class=k>WHEN</span><span class=w> </span><span class=n>seq</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=k>THEN</span><span class=w> </span><span class=s1>&#39;savings&#39;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>WHEN</span><span class=w> </span><span class=n>seq</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>THEN</span><span class=w> </span><span class=s1>&#39;checking&#39;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>ELSE</span><span class=w> </span><span class=s1>&#39;investment&#39;</span><span class=w> </span><span class=k>END</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>ROW_NUMBER</span><span class=p>()</span><span class=w> </span><span class=n>OVER</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>seq</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>columns</span><span class=w> </span><span class=n>a</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>CROSS</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>columns</span><span class=w> </span><span class=n>b</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>LIMIT</span><span class=w> </span><span class=mi>1000000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 잠금 모니터링 시스템 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-21-1><a class=lnlinks href=#hl-21-1> 1</a>
</span><span class=lnt id=hl-21-2><a class=lnlinks href=#hl-21-2> 2</a>
</span><span class=lnt id=hl-21-3><a class=lnlinks href=#hl-21-3> 3</a>
</span><span class=lnt id=hl-21-4><a class=lnlinks href=#hl-21-4> 4</a>
</span><span class=lnt id=hl-21-5><a class=lnlinks href=#hl-21-5> 5</a>
</span><span class=lnt id=hl-21-6><a class=lnlinks href=#hl-21-6> 6</a>
</span><span class=lnt id=hl-21-7><a class=lnlinks href=#hl-21-7> 7</a>
</span><span class=lnt id=hl-21-8><a class=lnlinks href=#hl-21-8> 8</a>
</span><span class=lnt id=hl-21-9><a class=lnlinks href=#hl-21-9> 9</a>
</span><span class=lnt id=hl-21-10><a class=lnlinks href=#hl-21-10>10</a>
</span><span class=lnt id=hl-21-11><a class=lnlinks href=#hl-21-11>11</a>
</span><span class=lnt id=hl-21-12><a class=lnlinks href=#hl-21-12>12</a>
</span><span class=lnt id=hl-21-13><a class=lnlinks href=#hl-21-13>13</a>
</span><span class=lnt id=hl-21-14><a class=lnlinks href=#hl-21-14>14</a>
</span><span class=lnt id=hl-21-15><a class=lnlinks href=#hl-21-15>15</a>
</span><span class=lnt id=hl-21-16><a class=lnlinks href=#hl-21-16>16</a>
</span><span class=lnt id=hl-21-17><a class=lnlinks href=#hl-21-17>17</a>
</span><span class=lnt id=hl-21-18><a class=lnlinks href=#hl-21-18>18</a>
</span><span class=lnt id=hl-21-19><a class=lnlinks href=#hl-21-19>19</a>
</span><span class=lnt id=hl-21-20><a class=lnlinks href=#hl-21-20>20</a>
</span><span class=lnt id=hl-21-21><a class=lnlinks href=#hl-21-21>21</a>
</span><span class=lnt id=hl-21-22><a class=lnlinks href=#hl-21-22>22</a>
</span><span class=lnt id=hl-21-23><a class=lnlinks href=#hl-21-23>23</a>
</span><span class=lnt id=hl-21-24><a class=lnlinks href=#hl-21-24>24</a>
</span><span class=lnt id=hl-21-25><a class=lnlinks href=#hl-21-25>25</a>
</span><span class=lnt id=hl-21-26><a class=lnlinks href=#hl-21-26>26</a>
</span><span class=lnt id=hl-21-27><a class=lnlinks href=#hl-21-27>27</a>
</span><span class=lnt id=hl-21-28><a class=lnlinks href=#hl-21-28>28</a>
</span><span class=lnt id=hl-21-29><a class=lnlinks href=#hl-21-29>29</a>
</span><span class=lnt id=hl-21-30><a class=lnlinks href=#hl-21-30>30</a>
</span><span class=lnt id=hl-21-31><a class=lnlinks href=#hl-21-31>31</a>
</span><span class=lnt id=hl-21-32><a class=lnlinks href=#hl-21-32>32</a>
</span><span class=lnt id=hl-21-33><a class=lnlinks href=#hl-21-33>33</a>
</span><span class=lnt id=hl-21-34><a class=lnlinks href=#hl-21-34>34</a>
</span><span class=lnt id=hl-21-35><a class=lnlinks href=#hl-21-35>35</a>
</span><span class=lnt id=hl-21-36><a class=lnlinks href=#hl-21-36>36</a>
</span><span class=lnt id=hl-21-37><a class=lnlinks href=#hl-21-37>37</a>
</span><span class=lnt id=hl-21-38><a class=lnlinks href=#hl-21-38>38</a>
</span><span class=lnt id=hl-21-39><a class=lnlinks href=#hl-21-39>39</a>
</span><span class=lnt id=hl-21-40><a class=lnlinks href=#hl-21-40>40</a>
</span><span class=lnt id=hl-21-41><a class=lnlinks href=#hl-21-41>41</a>
</span><span class=lnt id=hl-21-42><a class=lnlinks href=#hl-21-42>42</a>
</span><span class=lnt id=hl-21-43><a class=lnlinks href=#hl-21-43>43</a>
</span><span class=lnt id=hl-21-44><a class=lnlinks href=#hl-21-44>44</a>
</span><span class=lnt id=hl-21-45><a class=lnlinks href=#hl-21-45>45</a>
</span><span class=lnt id=hl-21-46><a class=lnlinks href=#hl-21-46>46</a>
</span><span class=lnt id=hl-21-47><a class=lnlinks href=#hl-21-47>47</a>
</span><span class=lnt id=hl-21-48><a class=lnlinks href=#hl-21-48>48</a>
</span><span class=lnt id=hl-21-49><a class=lnlinks href=#hl-21-49>49</a>
</span><span class=lnt id=hl-21-50><a class=lnlinks href=#hl-21-50>50</a>
</span><span class=lnt id=hl-21-51><a class=lnlinks href=#hl-21-51>51</a>
</span><span class=lnt id=hl-21-52><a class=lnlinks href=#hl-21-52>52</a>
</span><span class=lnt id=hl-21-53><a class=lnlinks href=#hl-21-53>53</a>
</span><span class=lnt id=hl-21-54><a class=lnlinks href=#hl-21-54>54</a>
</span><span class=lnt id=hl-21-55><a class=lnlinks href=#hl-21-55>55</a>
</span><span class=lnt id=hl-21-56><a class=lnlinks href=#hl-21-56>56</a>
</span><span class=lnt id=hl-21-57><a class=lnlinks href=#hl-21-57>57</a>
</span><span class=lnt id=hl-21-58><a class=lnlinks href=#hl-21-58>58</a>
</span><span class=lnt id=hl-21-59><a class=lnlinks href=#hl-21-59>59</a>
</span><span class=lnt id=hl-21-60><a class=lnlinks href=#hl-21-60>60</a>
</span><span class=lnt id=hl-21-61><a class=lnlinks href=#hl-21-61>61</a>
</span><span class=lnt id=hl-21-62><a class=lnlinks href=#hl-21-62>62</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>mysql.connector</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>datetime</span> <span class=kn>import</span> <span class=n>datetime</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=k>as</span> <span class=nn>plt</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockMonitor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>connection_config</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>config</span> <span class=o>=</span> <span class=n>connection_config</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>monitoring</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_data</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>start_monitoring</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;실시간 잠금 상태 모니터링 시작&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>monitoring</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>monitor_thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_monitor_locks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>monitor_thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>monitor_thread</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_monitor_locks</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;잠금 정보를 주기적으로 수집&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span> <span class=o>=</span> <span class=n>mysql</span><span class=o>.</span><span class=n>connector</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>(</span><span class=n>dictionary</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>monitoring</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 현재 잠금 상태 조회 - InnoDB 잠금 정보 수집</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                    SELECT 
</span></span></span><span class=line><span class=cl><span class=s2>                        NOW() as timestamp,
</span></span></span><span class=line><span class=cl><span class=s2>                        COUNT(*) as total_locks,
</span></span></span><span class=line><span class=cl><span class=s2>                        SUM(CASE WHEN LOCK_TYPE = &#39;RECORD&#39; THEN 1 ELSE 0 END) as row_locks,
</span></span></span><span class=line><span class=cl><span class=s2>                        SUM(CASE WHEN LOCK_TYPE = &#39;TABLE&#39; THEN 1 ELSE 0 END) as table_locks,
</span></span></span><span class=line><span class=cl><span class=s2>                        COUNT(DISTINCT REQUESTING_TRX_ID) as waiting_transactions
</span></span></span><span class=line><span class=cl><span class=s2>                    FROM performance_schema.data_locks
</span></span></span><span class=line><span class=cl><span class=s2>                &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchone</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>result</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>lock_data</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[</span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;timestamp&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>] 잠금 상태 - &#34;</span>
</span></span><span class=line><span class=cl>                          <span class=sa>f</span><span class=s2>&#34;총: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;total_locks&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>, &#34;</span>
</span></span><span class=line><span class=cl>                          <span class=sa>f</span><span class=s2>&#34;행: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;row_locks&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>, &#34;</span>
</span></span><span class=line><span class=cl>                          <span class=sa>f</span><span class=s2>&#34;테이블: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;table_locks&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>, &#34;</span>
</span></span><span class=line><span class=cl>                          <span class=sa>f</span><span class=s2>&#34;대기: </span><span class=si>{</span><span class=n>result</span><span class=p>[</span><span class=s1>&#39;waiting_transactions&#39;</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 1초마다 모니터링</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;모니터링 오류: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 잠금 모니터 인스턴스 생성</span>
</span></span><span class=line><span class=cl><span class=n>monitor</span> <span class=o>=</span> <span class=n>LockMonitor</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;host&#39;</span><span class=p>:</span> <span class=s1>&#39;localhost&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;user&#39;</span><span class=p>:</span> <span class=s1>&#39;root&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;password&#39;</span><span class=p>:</span> <span class=s1>&#39;password&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;database&#39;</span><span class=p>:</span> <span class=s1>&#39;lock_granularity_test&#39;</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>3 단계: 동시성 테스트 시나리오 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1>  1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2>  2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3>  3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4>  4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5>  5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6>  6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7>  7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8>  8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9>  9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10> 10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11> 11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12> 12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13> 13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14> 14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15> 15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16> 16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17> 17</a>
</span><span class=lnt id=hl-22-18><a class=lnlinks href=#hl-22-18> 18</a>
</span><span class=lnt id=hl-22-19><a class=lnlinks href=#hl-22-19> 19</a>
</span><span class=lnt id=hl-22-20><a class=lnlinks href=#hl-22-20> 20</a>
</span><span class=lnt id=hl-22-21><a class=lnlinks href=#hl-22-21> 21</a>
</span><span class=lnt id=hl-22-22><a class=lnlinks href=#hl-22-22> 22</a>
</span><span class=lnt id=hl-22-23><a class=lnlinks href=#hl-22-23> 23</a>
</span><span class=lnt id=hl-22-24><a class=lnlinks href=#hl-22-24> 24</a>
</span><span class=lnt id=hl-22-25><a class=lnlinks href=#hl-22-25> 25</a>
</span><span class=lnt id=hl-22-26><a class=lnlinks href=#hl-22-26> 26</a>
</span><span class=lnt id=hl-22-27><a class=lnlinks href=#hl-22-27> 27</a>
</span><span class=lnt id=hl-22-28><a class=lnlinks href=#hl-22-28> 28</a>
</span><span class=lnt id=hl-22-29><a class=lnlinks href=#hl-22-29> 29</a>
</span><span class=lnt id=hl-22-30><a class=lnlinks href=#hl-22-30> 30</a>
</span><span class=lnt id=hl-22-31><a class=lnlinks href=#hl-22-31> 31</a>
</span><span class=lnt id=hl-22-32><a class=lnlinks href=#hl-22-32> 32</a>
</span><span class=lnt id=hl-22-33><a class=lnlinks href=#hl-22-33> 33</a>
</span><span class=lnt id=hl-22-34><a class=lnlinks href=#hl-22-34> 34</a>
</span><span class=lnt id=hl-22-35><a class=lnlinks href=#hl-22-35> 35</a>
</span><span class=lnt id=hl-22-36><a class=lnlinks href=#hl-22-36> 36</a>
</span><span class=lnt id=hl-22-37><a class=lnlinks href=#hl-22-37> 37</a>
</span><span class=lnt id=hl-22-38><a class=lnlinks href=#hl-22-38> 38</a>
</span><span class=lnt id=hl-22-39><a class=lnlinks href=#hl-22-39> 39</a>
</span><span class=lnt id=hl-22-40><a class=lnlinks href=#hl-22-40> 40</a>
</span><span class=lnt id=hl-22-41><a class=lnlinks href=#hl-22-41> 41</a>
</span><span class=lnt id=hl-22-42><a class=lnlinks href=#hl-22-42> 42</a>
</span><span class=lnt id=hl-22-43><a class=lnlinks href=#hl-22-43> 43</a>
</span><span class=lnt id=hl-22-44><a class=lnlinks href=#hl-22-44> 44</a>
</span><span class=lnt id=hl-22-45><a class=lnlinks href=#hl-22-45> 45</a>
</span><span class=lnt id=hl-22-46><a class=lnlinks href=#hl-22-46> 46</a>
</span><span class=lnt id=hl-22-47><a class=lnlinks href=#hl-22-47> 47</a>
</span><span class=lnt id=hl-22-48><a class=lnlinks href=#hl-22-48> 48</a>
</span><span class=lnt id=hl-22-49><a class=lnlinks href=#hl-22-49> 49</a>
</span><span class=lnt id=hl-22-50><a class=lnlinks href=#hl-22-50> 50</a>
</span><span class=lnt id=hl-22-51><a class=lnlinks href=#hl-22-51> 51</a>
</span><span class=lnt id=hl-22-52><a class=lnlinks href=#hl-22-52> 52</a>
</span><span class=lnt id=hl-22-53><a class=lnlinks href=#hl-22-53> 53</a>
</span><span class=lnt id=hl-22-54><a class=lnlinks href=#hl-22-54> 54</a>
</span><span class=lnt id=hl-22-55><a class=lnlinks href=#hl-22-55> 55</a>
</span><span class=lnt id=hl-22-56><a class=lnlinks href=#hl-22-56> 56</a>
</span><span class=lnt id=hl-22-57><a class=lnlinks href=#hl-22-57> 57</a>
</span><span class=lnt id=hl-22-58><a class=lnlinks href=#hl-22-58> 58</a>
</span><span class=lnt id=hl-22-59><a class=lnlinks href=#hl-22-59> 59</a>
</span><span class=lnt id=hl-22-60><a class=lnlinks href=#hl-22-60> 60</a>
</span><span class=lnt id=hl-22-61><a class=lnlinks href=#hl-22-61> 61</a>
</span><span class=lnt id=hl-22-62><a class=lnlinks href=#hl-22-62> 62</a>
</span><span class=lnt id=hl-22-63><a class=lnlinks href=#hl-22-63> 63</a>
</span><span class=lnt id=hl-22-64><a class=lnlinks href=#hl-22-64> 64</a>
</span><span class=lnt id=hl-22-65><a class=lnlinks href=#hl-22-65> 65</a>
</span><span class=lnt id=hl-22-66><a class=lnlinks href=#hl-22-66> 66</a>
</span><span class=lnt id=hl-22-67><a class=lnlinks href=#hl-22-67> 67</a>
</span><span class=lnt id=hl-22-68><a class=lnlinks href=#hl-22-68> 68</a>
</span><span class=lnt id=hl-22-69><a class=lnlinks href=#hl-22-69> 69</a>
</span><span class=lnt id=hl-22-70><a class=lnlinks href=#hl-22-70> 70</a>
</span><span class=lnt id=hl-22-71><a class=lnlinks href=#hl-22-71> 71</a>
</span><span class=lnt id=hl-22-72><a class=lnlinks href=#hl-22-72> 72</a>
</span><span class=lnt id=hl-22-73><a class=lnlinks href=#hl-22-73> 73</a>
</span><span class=lnt id=hl-22-74><a class=lnlinks href=#hl-22-74> 74</a>
</span><span class=lnt id=hl-22-75><a class=lnlinks href=#hl-22-75> 75</a>
</span><span class=lnt id=hl-22-76><a class=lnlinks href=#hl-22-76> 76</a>
</span><span class=lnt id=hl-22-77><a class=lnlinks href=#hl-22-77> 77</a>
</span><span class=lnt id=hl-22-78><a class=lnlinks href=#hl-22-78> 78</a>
</span><span class=lnt id=hl-22-79><a class=lnlinks href=#hl-22-79> 79</a>
</span><span class=lnt id=hl-22-80><a class=lnlinks href=#hl-22-80> 80</a>
</span><span class=lnt id=hl-22-81><a class=lnlinks href=#hl-22-81> 81</a>
</span><span class=lnt id=hl-22-82><a class=lnlinks href=#hl-22-82> 82</a>
</span><span class=lnt id=hl-22-83><a class=lnlinks href=#hl-22-83> 83</a>
</span><span class=lnt id=hl-22-84><a class=lnlinks href=#hl-22-84> 84</a>
</span><span class=lnt id=hl-22-85><a class=lnlinks href=#hl-22-85> 85</a>
</span><span class=lnt id=hl-22-86><a class=lnlinks href=#hl-22-86> 86</a>
</span><span class=lnt id=hl-22-87><a class=lnlinks href=#hl-22-87> 87</a>
</span><span class=lnt id=hl-22-88><a class=lnlinks href=#hl-22-88> 88</a>
</span><span class=lnt id=hl-22-89><a class=lnlinks href=#hl-22-89> 89</a>
</span><span class=lnt id=hl-22-90><a class=lnlinks href=#hl-22-90> 90</a>
</span><span class=lnt id=hl-22-91><a class=lnlinks href=#hl-22-91> 91</a>
</span><span class=lnt id=hl-22-92><a class=lnlinks href=#hl-22-92> 92</a>
</span><span class=lnt id=hl-22-93><a class=lnlinks href=#hl-22-93> 93</a>
</span><span class=lnt id=hl-22-94><a class=lnlinks href=#hl-22-94> 94</a>
</span><span class=lnt id=hl-22-95><a class=lnlinks href=#hl-22-95> 95</a>
</span><span class=lnt id=hl-22-96><a class=lnlinks href=#hl-22-96> 96</a>
</span><span class=lnt id=hl-22-97><a class=lnlinks href=#hl-22-97> 97</a>
</span><span class=lnt id=hl-22-98><a class=lnlinks href=#hl-22-98> 98</a>
</span><span class=lnt id=hl-22-99><a class=lnlinks href=#hl-22-99> 99</a>
</span><span class=lnt id=hl-22-100><a class=lnlinks href=#hl-22-100>100</a>
</span><span class=lnt id=hl-22-101><a class=lnlinks href=#hl-22-101>101</a>
</span><span class=lnt id=hl-22-102><a class=lnlinks href=#hl-22-102>102</a>
</span><span class=lnt id=hl-22-103><a class=lnlinks href=#hl-22-103>103</a>
</span><span class=lnt id=hl-22-104><a class=lnlinks href=#hl-22-104>104</a>
</span><span class=lnt id=hl-22-105><a class=lnlinks href=#hl-22-105>105</a>
</span><span class=lnt id=hl-22-106><a class=lnlinks href=#hl-22-106>106</a>
</span><span class=lnt id=hl-22-107><a class=lnlinks href=#hl-22-107>107</a>
</span><span class=lnt id=hl-22-108><a class=lnlinks href=#hl-22-108>108</a>
</span><span class=lnt id=hl-22-109><a class=lnlinks href=#hl-22-109>109</a>
</span><span class=lnt id=hl-22-110><a class=lnlinks href=#hl-22-110>110</a>
</span><span class=lnt id=hl-22-111><a class=lnlinks href=#hl-22-111>111</a>
</span><span class=lnt id=hl-22-112><a class=lnlinks href=#hl-22-112>112</a>
</span><span class=lnt id=hl-22-113><a class=lnlinks href=#hl-22-113>113</a>
</span><span class=lnt id=hl-22-114><a class=lnlinks href=#hl-22-114>114</a>
</span><span class=lnt id=hl-22-115><a class=lnlinks href=#hl-22-115>115</a>
</span><span class=lnt id=hl-22-116><a class=lnlinks href=#hl-22-116>116</a>
</span><span class=lnt id=hl-22-117><a class=lnlinks href=#hl-22-117>117</a>
</span><span class=lnt id=hl-22-118><a class=lnlinks href=#hl-22-118>118</a>
</span><span class=lnt id=hl-22-119><a class=lnlinks href=#hl-22-119>119</a>
</span><span class=lnt id=hl-22-120><a class=lnlinks href=#hl-22-120>120</a>
</span><span class=lnt id=hl-22-121><a class=lnlinks href=#hl-22-121>121</a>
</span><span class=lnt id=hl-22-122><a class=lnlinks href=#hl-22-122>122</a>
</span><span class=lnt id=hl-22-123><a class=lnlinks href=#hl-22-123>123</a>
</span><span class=lnt id=hl-22-124><a class=lnlinks href=#hl-22-124>124</a>
</span><span class=lnt id=hl-22-125><a class=lnlinks href=#hl-22-125>125</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConcurrencyTester</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>connection_config</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>config</span> <span class=o>=</span> <span class=n>connection_config</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>results</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_row_level_locks</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>num_threads</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> <span class=n>duration</span><span class=o>=</span><span class=mi>30</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;행 수준 잠금에서의 동시성 테스트&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=== 행 수준 잠금 테스트 시작 ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>threads</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 각 스레드는 서로 다른 행에 접근 (최대 동시성)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_threads</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>target</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_worker_different_rows</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>start_time</span> <span class=o>+</span> <span class=n>duration</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>threads</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>thread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 모든 스레드 완료 대기</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>thread</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_calculate_performance_metrics</span><span class=p>(</span><span class=s1>&#39;row_level&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>test_table_level_locks</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>num_threads</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> <span class=n>duration</span><span class=o>=</span><span class=mi>30</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;테이블 수준 잠금에서의 동시성 테스트&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=== 테이블 수준 잠금 테스트 시작 ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>threads</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 각 스레드가 테이블 전체에 잠금 (순차 실행)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_threads</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>thread</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>target</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>_worker_table_lock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>start_time</span> <span class=o>+</span> <span class=n>duration</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>threads</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>thread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>thread</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>thread</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>thread</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>_calculate_performance_metrics</span><span class=p>(</span><span class=s1>&#39;table_level&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_worker_different_rows</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>worker_id</span><span class=p>,</span> <span class=n>end_time</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;서로 다른 행에 접근하는 워커 (행 수준 잠금)&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span> <span class=o>=</span> <span class=n>mysql</span><span class=o>.</span><span class=n>connector</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>  <span class=c1># 트랜잭션 모드 활성화</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>transaction_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>base_account_id</span> <span class=o>=</span> <span class=n>worker_id</span> <span class=o>*</span> <span class=mi>10000</span>  <span class=c1># 각 워커는 다른 계정 ID 범위 사용</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>end_time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN&#34;</span><span class=p>)</span>  <span class=c1># 명시적 트랜잭션 시작</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 특정 계정 잔액 업데이트 (행 수준 잠금)</span>
</span></span><span class=line><span class=cl>                <span class=n>account_id</span> <span class=o>=</span> <span class=n>base_account_id</span> <span class=o>+</span> <span class=p>(</span><span class=n>transaction_count</span> <span class=o>%</span> <span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;UPDATE account SET balance = balance + </span><span class=si>%s</span><span class=s2> WHERE id = </span><span class=si>%s</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=mf>10.0</span><span class=p>,</span> <span class=n>account_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 소액의 지연 시뮬레이션 (실제 비즈니스 로직)</span>
</span></span><span class=line><span class=cl>                <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.01</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT&#34;</span><span class=p>)</span>  <span class=c1># 트랜잭션 커밋</span>
</span></span><span class=line><span class=cl>                <span class=n>transaction_count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;ROLLBACK&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;워커 </span><span class=si>{</span><span class=n>worker_id</span><span class=si>}</span><span class=s2> 오류: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 성능 결과 저장</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>results</span><span class=p>[</span><span class=sa>f</span><span class=s1>&#39;worker_</span><span class=si>{</span><span class=n>worker_id</span><span class=si>}</span><span class=s1>_row&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>transaction_count</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_worker_table_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>worker_id</span><span class=p>,</span> <span class=n>end_time</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;테이블 전체에 잠금하는 워커 (테이블 수준 잠금)&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span> <span class=o>=</span> <span class=n>mysql</span><span class=o>.</span><span class=n>connector</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>transaction_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>end_time</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 테이블 수준 잠금 (전체 테이블 스캔 강제)</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;LOCK TABLES account WRITE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 전체 계정의 잔액 업데이트</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=s2>&#34;UPDATE account SET balance = balance + 1.0 WHERE account_type = &#39;savings&#39;&#34;</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>  <span class=c1># 긴 작업 시뮬레이션</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UNLOCK TABLES&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>transaction_count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UNLOCK TABLES&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;ROLLBACK&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;워커 </span><span class=si>{</span><span class=n>worker_id</span><span class=si>}</span><span class=s2> 오류: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>results</span><span class=p>[</span><span class=sa>f</span><span class=s1>&#39;worker_</span><span class=si>{</span><span class=n>worker_id</span><span class=si>}</span><span class=s1>_table&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>transaction_count</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 동시성 테스터 실행</span>
</span></span><span class=line><span class=cl><span class=n>tester</span> <span class=o>=</span> <span class=n>ConcurrencyTester</span><span class=p>({</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;host&#39;</span><span class=p>:</span> <span class=s1>&#39;localhost&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;user&#39;</span><span class=p>:</span> <span class=s1>&#39;root&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;password&#39;</span><span class=p>:</span> <span class=s1>&#39;password&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;database&#39;</span><span class=p>:</span> <span class=s1>&#39;lock_granularity_test&#39;</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>4 단계: 잠금 상승 실험</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-23-1><a class=lnlinks href=#hl-23-1> 1</a>
</span><span class=lnt id=hl-23-2><a class=lnlinks href=#hl-23-2> 2</a>
</span><span class=lnt id=hl-23-3><a class=lnlinks href=#hl-23-3> 3</a>
</span><span class=lnt id=hl-23-4><a class=lnlinks href=#hl-23-4> 4</a>
</span><span class=lnt id=hl-23-5><a class=lnlinks href=#hl-23-5> 5</a>
</span><span class=lnt id=hl-23-6><a class=lnlinks href=#hl-23-6> 6</a>
</span><span class=lnt id=hl-23-7><a class=lnlinks href=#hl-23-7> 7</a>
</span><span class=lnt id=hl-23-8><a class=lnlinks href=#hl-23-8> 8</a>
</span><span class=lnt id=hl-23-9><a class=lnlinks href=#hl-23-9> 9</a>
</span><span class=lnt id=hl-23-10><a class=lnlinks href=#hl-23-10>10</a>
</span><span class=lnt id=hl-23-11><a class=lnlinks href=#hl-23-11>11</a>
</span><span class=lnt id=hl-23-12><a class=lnlinks href=#hl-23-12>12</a>
</span><span class=lnt id=hl-23-13><a class=lnlinks href=#hl-23-13>13</a>
</span><span class=lnt id=hl-23-14><a class=lnlinks href=#hl-23-14>14</a>
</span><span class=lnt id=hl-23-15><a class=lnlinks href=#hl-23-15>15</a>
</span><span class=lnt id=hl-23-16><a class=lnlinks href=#hl-23-16>16</a>
</span><span class=lnt id=hl-23-17><a class=lnlinks href=#hl-23-17>17</a>
</span><span class=lnt id=hl-23-18><a class=lnlinks href=#hl-23-18>18</a>
</span><span class=lnt id=hl-23-19><a class=lnlinks href=#hl-23-19>19</a>
</span><span class=lnt id=hl-23-20><a class=lnlinks href=#hl-23-20>20</a>
</span><span class=lnt id=hl-23-21><a class=lnlinks href=#hl-23-21>21</a>
</span><span class=lnt id=hl-23-22><a class=lnlinks href=#hl-23-22>22</a>
</span><span class=lnt id=hl-23-23><a class=lnlinks href=#hl-23-23>23</a>
</span><span class=lnt id=hl-23-24><a class=lnlinks href=#hl-23-24>24</a>
</span><span class=lnt id=hl-23-25><a class=lnlinks href=#hl-23-25>25</a>
</span><span class=lnt id=hl-23-26><a class=lnlinks href=#hl-23-26>26</a>
</span><span class=lnt id=hl-23-27><a class=lnlinks href=#hl-23-27>27</a>
</span><span class=lnt id=hl-23-28><a class=lnlinks href=#hl-23-28>28</a>
</span><span class=lnt id=hl-23-29><a class=lnlinks href=#hl-23-29>29</a>
</span><span class=lnt id=hl-23-30><a class=lnlinks href=#hl-23-30>30</a>
</span><span class=lnt id=hl-23-31><a class=lnlinks href=#hl-23-31>31</a>
</span><span class=lnt id=hl-23-32><a class=lnlinks href=#hl-23-32>32</a>
</span><span class=lnt id=hl-23-33><a class=lnlinks href=#hl-23-33>33</a>
</span><span class=lnt id=hl-23-34><a class=lnlinks href=#hl-23-34>34</a>
</span><span class=lnt id=hl-23-35><a class=lnlinks href=#hl-23-35>35</a>
</span><span class=lnt id=hl-23-36><a class=lnlinks href=#hl-23-36>36</a>
</span><span class=lnt id=hl-23-37><a class=lnlinks href=#hl-23-37>37</a>
</span><span class=lnt id=hl-23-38><a class=lnlinks href=#hl-23-38>38</a>
</span><span class=lnt id=hl-23-39><a class=lnlinks href=#hl-23-39>39</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>test_lock_escalation</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;잠금 상승 임계값 테스트&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>conn</span> <span class=o>=</span> <span class=n>mysql</span><span class=o>.</span><span class=n>connector</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=o>**</span><span class=n>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;BEGIN&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 대량의 행 잠금 생성 (InnoDB는 자동으로 상승 판단)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;대량 행 잠금 생성 중…&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1000</span><span class=p>,</span> <span class=mi>2000</span><span class=p>):</span>  <span class=c1># 1000개 행 잠금</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;SELECT * FROM account WHERE id = </span><span class=si>%s</span><span class=s2> FOR UPDATE&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=p>(</span><span class=n>i</span><span class=p>,)</span>
</span></span><span class=line><span class=cl>            <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 매 100개마다 현재 잠금 상태 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>%</span> <span class=mi>100</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                    SELECT LOCK_TYPE, COUNT(*) as count 
</span></span></span><span class=line><span class=cl><span class=s2>                    FROM performance_schema.data_locks 
</span></span></span><span class=line><span class=cl><span class=s2>                    WHERE OBJECT_NAME = &#39;account&#39; 
</span></span></span><span class=line><span class=cl><span class=s2>                    GROUP BY LOCK_TYPE
</span></span></span><span class=line><span class=cl><span class=s2>                &#34;&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>locks</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchall</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;행 </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>locks</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;COMMIT&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;잠금 상승 테스트 오류: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;ROLLBACK&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cursor</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>conn</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 잠금 상승 실험 실행</span>
</span></span><span class=line><span class=cl><span class=n>test_lock_escalation</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-2>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-2>#</a></h6><p>테스트 실행 후 다음과 같은 결과를 확인할 수 있다:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span><span class=lnt id=hl-24-5><a class=lnlinks href=#hl-24-5>5</a>
</span><span class=lnt id=hl-24-6><a class=lnlinks href=#hl-24-6>6</a>
</span><span class=lnt id=hl-24-7><a class=lnlinks href=#hl-24-7>7</a>
</span><span class=lnt id=hl-24-8><a class=lnlinks href=#hl-24-8>8</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>=== 잠금 입도별 성능 비교 ===
</span></span><span class=line><span class=cl>행 수준 잠금: 평균 1,250 TPS (Transaction Per Second)
</span></span><span class=line><span class=cl>테이블 수준 잠금: 평균 45 TPS
</span></span><span class=line><span class=cl>성능 차이: 약 28배
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>=== 리소스 사용량 ===
</span></span><span class=line><span class=cl>행 수준 잠금: 메모리 사용량 15% 증가
</span></span><span class=line><span class=cl>테이블 수준 잠금: CPU 사용률 85% (대기 시간)
</span></span></code></pre></td></tr></table></div></div><h6 id=추가-실험-2>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-2>#</a></h6><ol><li><strong>격리 수준별 성능 차이</strong>: READ COMMITTED vs SERIALIZABLE</li><li><strong>인덱스 유무에 따른 잠금 범위 변화</strong>: 클러스터드 vs 논클러스터드 인덱스</li><li><strong>데드락 발생 시나리오</strong>: 순환 의존성 생성 및 탐지</li></ol><h4 id=실제-도입-사례-분석>실제 도입 사례 분석<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-분석>#</a></h4><h5 id=실제-도입-사례-온라인-뱅킹-시스템-국내-a-은행>실제 도입 사례: 온라인 뱅킹 시스템 (국내 A 은행)<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-온라인-뱅킹-시스템-국내-a-은행>#</a></h5><h6 id=배경-및-도입-이유>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유>#</a></h6><p><strong>비즈니스 요구사항</strong>:</p><ul><li>일일 거래량: 1,000 만 건 이상</li><li>동시 접속자: 피크 시간 50 만 명</li><li>응답 시간: 평균 200ms 이하 보장</li><li>데이터 무결성: 100% 보장 (금융 규제 준수)</li></ul><p><strong>기술적 제약사항</strong>:</p><ul><li>기존 레거시 시스템과 호환성 유지</li><li>24 시간 무중단 서비스 요구</li><li>감사 추적 및 규제 보고 의무</li></ul><p><strong>잠금 입도 선택 배경</strong>:</p><ul><li>계좌별 독립적 거래를 위한 행 수준 잠금 필요</li><li>대용량 배치 처리를 위한 테이블 수준 잠금 지원</li><li>실시간 사기 탐지를 위한 동적 입도 조절</li></ul><h6 id=구현-아키텍처>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처>#</a></h6><pre class=mermaid>graph TB
    subgraph &#34;Client Layer&#34;
        WEB[웹 애플리케이션]
        MOBILE[모바일 앱]
        ATM[ATM/키오스크]
    end
    
    subgraph &#34;Application Layer&#34;
        LB[로드 밸런서]
        APP1[앱 서버 1]
        APP2[앱 서버 2]
        APP3[앱 서버 N]
    end
    
    subgraph &#34;Database Layer&#34;
        PROXY[DB 프록시]
        MASTER[마스터 DB]
        SLAVE1[슬레이브 1]
        SLAVE2[슬레이브 2]
        
        subgraph &#34;Lock Management&#34;
            LM[잠금 관리자]
            DE[데드락 탐지기]
            ES[상승 스케줄러]
        end
    end
    
    WEB --&gt; LB
    MOBILE --&gt; LB
    ATM --&gt; LB
    
    LB --&gt; APP1
    LB --&gt; APP2
    LB --&gt; APP3
    
    APP1 --&gt; PROXY
    APP2 --&gt; PROXY
    APP3 --&gt; PROXY
    
    PROXY --&gt; MASTER
    PROXY --&gt; SLAVE1
    PROXY --&gt; SLAVE2
    
    MASTER --&gt; LM
    LM --&gt; DE
    LM --&gt; ES
</pre><h6 id=핵심-구현-코드>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-26-1><a class=lnlinks href=#hl-26-1>  1</a>
</span><span class=lnt id=hl-26-2><a class=lnlinks href=#hl-26-2>  2</a>
</span><span class=lnt id=hl-26-3><a class=lnlinks href=#hl-26-3>  3</a>
</span><span class=lnt id=hl-26-4><a class=lnlinks href=#hl-26-4>  4</a>
</span><span class=lnt id=hl-26-5><a class=lnlinks href=#hl-26-5>  5</a>
</span><span class=lnt id=hl-26-6><a class=lnlinks href=#hl-26-6>  6</a>
</span><span class=lnt id=hl-26-7><a class=lnlinks href=#hl-26-7>  7</a>
</span><span class=lnt id=hl-26-8><a class=lnlinks href=#hl-26-8>  8</a>
</span><span class=lnt id=hl-26-9><a class=lnlinks href=#hl-26-9>  9</a>
</span><span class=lnt id=hl-26-10><a class=lnlinks href=#hl-26-10> 10</a>
</span><span class=lnt id=hl-26-11><a class=lnlinks href=#hl-26-11> 11</a>
</span><span class=lnt id=hl-26-12><a class=lnlinks href=#hl-26-12> 12</a>
</span><span class=lnt id=hl-26-13><a class=lnlinks href=#hl-26-13> 13</a>
</span><span class=lnt id=hl-26-14><a class=lnlinks href=#hl-26-14> 14</a>
</span><span class=lnt id=hl-26-15><a class=lnlinks href=#hl-26-15> 15</a>
</span><span class=lnt id=hl-26-16><a class=lnlinks href=#hl-26-16> 16</a>
</span><span class=lnt id=hl-26-17><a class=lnlinks href=#hl-26-17> 17</a>
</span><span class=lnt id=hl-26-18><a class=lnlinks href=#hl-26-18> 18</a>
</span><span class=lnt id=hl-26-19><a class=lnlinks href=#hl-26-19> 19</a>
</span><span class=lnt id=hl-26-20><a class=lnlinks href=#hl-26-20> 20</a>
</span><span class=lnt id=hl-26-21><a class=lnlinks href=#hl-26-21> 21</a>
</span><span class=lnt id=hl-26-22><a class=lnlinks href=#hl-26-22> 22</a>
</span><span class=lnt id=hl-26-23><a class=lnlinks href=#hl-26-23> 23</a>
</span><span class=lnt id=hl-26-24><a class=lnlinks href=#hl-26-24> 24</a>
</span><span class=lnt id=hl-26-25><a class=lnlinks href=#hl-26-25> 25</a>
</span><span class=lnt id=hl-26-26><a class=lnlinks href=#hl-26-26> 26</a>
</span><span class=lnt id=hl-26-27><a class=lnlinks href=#hl-26-27> 27</a>
</span><span class=lnt id=hl-26-28><a class=lnlinks href=#hl-26-28> 28</a>
</span><span class=lnt id=hl-26-29><a class=lnlinks href=#hl-26-29> 29</a>
</span><span class=lnt id=hl-26-30><a class=lnlinks href=#hl-26-30> 30</a>
</span><span class=lnt id=hl-26-31><a class=lnlinks href=#hl-26-31> 31</a>
</span><span class=lnt id=hl-26-32><a class=lnlinks href=#hl-26-32> 32</a>
</span><span class=lnt id=hl-26-33><a class=lnlinks href=#hl-26-33> 33</a>
</span><span class=lnt id=hl-26-34><a class=lnlinks href=#hl-26-34> 34</a>
</span><span class=lnt id=hl-26-35><a class=lnlinks href=#hl-26-35> 35</a>
</span><span class=lnt id=hl-26-36><a class=lnlinks href=#hl-26-36> 36</a>
</span><span class=lnt id=hl-26-37><a class=lnlinks href=#hl-26-37> 37</a>
</span><span class=lnt id=hl-26-38><a class=lnlinks href=#hl-26-38> 38</a>
</span><span class=lnt id=hl-26-39><a class=lnlinks href=#hl-26-39> 39</a>
</span><span class=lnt id=hl-26-40><a class=lnlinks href=#hl-26-40> 40</a>
</span><span class=lnt id=hl-26-41><a class=lnlinks href=#hl-26-41> 41</a>
</span><span class=lnt id=hl-26-42><a class=lnlinks href=#hl-26-42> 42</a>
</span><span class=lnt id=hl-26-43><a class=lnlinks href=#hl-26-43> 43</a>
</span><span class=lnt id=hl-26-44><a class=lnlinks href=#hl-26-44> 44</a>
</span><span class=lnt id=hl-26-45><a class=lnlinks href=#hl-26-45> 45</a>
</span><span class=lnt id=hl-26-46><a class=lnlinks href=#hl-26-46> 46</a>
</span><span class=lnt id=hl-26-47><a class=lnlinks href=#hl-26-47> 47</a>
</span><span class=lnt id=hl-26-48><a class=lnlinks href=#hl-26-48> 48</a>
</span><span class=lnt id=hl-26-49><a class=lnlinks href=#hl-26-49> 49</a>
</span><span class=lnt id=hl-26-50><a class=lnlinks href=#hl-26-50> 50</a>
</span><span class=lnt id=hl-26-51><a class=lnlinks href=#hl-26-51> 51</a>
</span><span class=lnt id=hl-26-52><a class=lnlinks href=#hl-26-52> 52</a>
</span><span class=lnt id=hl-26-53><a class=lnlinks href=#hl-26-53> 53</a>
</span><span class=lnt id=hl-26-54><a class=lnlinks href=#hl-26-54> 54</a>
</span><span class=lnt id=hl-26-55><a class=lnlinks href=#hl-26-55> 55</a>
</span><span class=lnt id=hl-26-56><a class=lnlinks href=#hl-26-56> 56</a>
</span><span class=lnt id=hl-26-57><a class=lnlinks href=#hl-26-57> 57</a>
</span><span class=lnt id=hl-26-58><a class=lnlinks href=#hl-26-58> 58</a>
</span><span class=lnt id=hl-26-59><a class=lnlinks href=#hl-26-59> 59</a>
</span><span class=lnt id=hl-26-60><a class=lnlinks href=#hl-26-60> 60</a>
</span><span class=lnt id=hl-26-61><a class=lnlinks href=#hl-26-61> 61</a>
</span><span class=lnt id=hl-26-62><a class=lnlinks href=#hl-26-62> 62</a>
</span><span class=lnt id=hl-26-63><a class=lnlinks href=#hl-26-63> 63</a>
</span><span class=lnt id=hl-26-64><a class=lnlinks href=#hl-26-64> 64</a>
</span><span class=lnt id=hl-26-65><a class=lnlinks href=#hl-26-65> 65</a>
</span><span class=lnt id=hl-26-66><a class=lnlinks href=#hl-26-66> 66</a>
</span><span class=lnt id=hl-26-67><a class=lnlinks href=#hl-26-67> 67</a>
</span><span class=lnt id=hl-26-68><a class=lnlinks href=#hl-26-68> 68</a>
</span><span class=lnt id=hl-26-69><a class=lnlinks href=#hl-26-69> 69</a>
</span><span class=lnt id=hl-26-70><a class=lnlinks href=#hl-26-70> 70</a>
</span><span class=lnt id=hl-26-71><a class=lnlinks href=#hl-26-71> 71</a>
</span><span class=lnt id=hl-26-72><a class=lnlinks href=#hl-26-72> 72</a>
</span><span class=lnt id=hl-26-73><a class=lnlinks href=#hl-26-73> 73</a>
</span><span class=lnt id=hl-26-74><a class=lnlinks href=#hl-26-74> 74</a>
</span><span class=lnt id=hl-26-75><a class=lnlinks href=#hl-26-75> 75</a>
</span><span class=lnt id=hl-26-76><a class=lnlinks href=#hl-26-76> 76</a>
</span><span class=lnt id=hl-26-77><a class=lnlinks href=#hl-26-77> 77</a>
</span><span class=lnt id=hl-26-78><a class=lnlinks href=#hl-26-78> 78</a>
</span><span class=lnt id=hl-26-79><a class=lnlinks href=#hl-26-79> 79</a>
</span><span class=lnt id=hl-26-80><a class=lnlinks href=#hl-26-80> 80</a>
</span><span class=lnt id=hl-26-81><a class=lnlinks href=#hl-26-81> 81</a>
</span><span class=lnt id=hl-26-82><a class=lnlinks href=#hl-26-82> 82</a>
</span><span class=lnt id=hl-26-83><a class=lnlinks href=#hl-26-83> 83</a>
</span><span class=lnt id=hl-26-84><a class=lnlinks href=#hl-26-84> 84</a>
</span><span class=lnt id=hl-26-85><a class=lnlinks href=#hl-26-85> 85</a>
</span><span class=lnt id=hl-26-86><a class=lnlinks href=#hl-26-86> 86</a>
</span><span class=lnt id=hl-26-87><a class=lnlinks href=#hl-26-87> 87</a>
</span><span class=lnt id=hl-26-88><a class=lnlinks href=#hl-26-88> 88</a>
</span><span class=lnt id=hl-26-89><a class=lnlinks href=#hl-26-89> 89</a>
</span><span class=lnt id=hl-26-90><a class=lnlinks href=#hl-26-90> 90</a>
</span><span class=lnt id=hl-26-91><a class=lnlinks href=#hl-26-91> 91</a>
</span><span class=lnt id=hl-26-92><a class=lnlinks href=#hl-26-92> 92</a>
</span><span class=lnt id=hl-26-93><a class=lnlinks href=#hl-26-93> 93</a>
</span><span class=lnt id=hl-26-94><a class=lnlinks href=#hl-26-94> 94</a>
</span><span class=lnt id=hl-26-95><a class=lnlinks href=#hl-26-95> 95</a>
</span><span class=lnt id=hl-26-96><a class=lnlinks href=#hl-26-96> 96</a>
</span><span class=lnt id=hl-26-97><a class=lnlinks href=#hl-26-97> 97</a>
</span><span class=lnt id=hl-26-98><a class=lnlinks href=#hl-26-98> 98</a>
</span><span class=lnt id=hl-26-99><a class=lnlinks href=#hl-26-99> 99</a>
</span><span class=lnt id=hl-26-100><a class=lnlinks href=#hl-26-100>100</a>
</span><span class=lnt id=hl-26-101><a class=lnlinks href=#hl-26-101>101</a>
</span><span class=lnt id=hl-26-102><a class=lnlinks href=#hl-26-102>102</a>
</span><span class=lnt id=hl-26-103><a class=lnlinks href=#hl-26-103>103</a>
</span><span class=lnt id=hl-26-104><a class=lnlinks href=#hl-26-104>104</a>
</span><span class=lnt id=hl-26-105><a class=lnlinks href=#hl-26-105>105</a>
</span><span class=lnt id=hl-26-106><a class=lnlinks href=#hl-26-106>106</a>
</span><span class=lnt id=hl-26-107><a class=lnlinks href=#hl-26-107>107</a>
</span><span class=lnt id=hl-26-108><a class=lnlinks href=#hl-26-108>108</a>
</span><span class=lnt id=hl-26-109><a class=lnlinks href=#hl-26-109>109</a>
</span><span class=lnt id=hl-26-110><a class=lnlinks href=#hl-26-110>110</a>
</span><span class=lnt id=hl-26-111><a class=lnlinks href=#hl-26-111>111</a>
</span><span class=lnt id=hl-26-112><a class=lnlinks href=#hl-26-112>112</a>
</span><span class=lnt id=hl-26-113><a class=lnlinks href=#hl-26-113>113</a>
</span><span class=lnt id=hl-26-114><a class=lnlinks href=#hl-26-114>114</a>
</span><span class=lnt id=hl-26-115><a class=lnlinks href=#hl-26-115>115</a>
</span><span class=lnt id=hl-26-116><a class=lnlinks href=#hl-26-116>116</a>
</span><span class=lnt id=hl-26-117><a class=lnlinks href=#hl-26-117>117</a>
</span><span class=lnt id=hl-26-118><a class=lnlinks href=#hl-26-118>118</a>
</span><span class=lnt id=hl-26-119><a class=lnlinks href=#hl-26-119>119</a>
</span><span class=lnt id=hl-26-120><a class=lnlinks href=#hl-26-120>120</a>
</span><span class=lnt id=hl-26-121><a class=lnlinks href=#hl-26-121>121</a>
</span><span class=lnt id=hl-26-122><a class=lnlinks href=#hl-26-122>122</a>
</span><span class=lnt id=hl-26-123><a class=lnlinks href=#hl-26-123>123</a>
</span><span class=lnt id=hl-26-124><a class=lnlinks href=#hl-26-124>124</a>
</span><span class=lnt id=hl-26-125><a class=lnlinks href=#hl-26-125>125</a>
</span><span class=lnt id=hl-26-126><a class=lnlinks href=#hl-26-126>126</a>
</span><span class=lnt id=hl-26-127><a class=lnlinks href=#hl-26-127>127</a>
</span><span class=lnt id=hl-26-128><a class=lnlinks href=#hl-26-128>128</a>
</span><span class=lnt id=hl-26-129><a class=lnlinks href=#hl-26-129>129</a>
</span><span class=lnt id=hl-26-130><a class=lnlinks href=#hl-26-130>130</a>
</span><span class=lnt id=hl-26-131><a class=lnlinks href=#hl-26-131>131</a>
</span><span class=lnt id=hl-26-132><a class=lnlinks href=#hl-26-132>132</a>
</span><span class=lnt id=hl-26-133><a class=lnlinks href=#hl-26-133>133</a>
</span><span class=lnt id=hl-26-134><a class=lnlinks href=#hl-26-134>134</a>
</span><span class=lnt id=hl-26-135><a class=lnlinks href=#hl-26-135>135</a>
</span><span class=lnt id=hl-26-136><a class=lnlinks href=#hl-26-136>136</a>
</span><span class=lnt id=hl-26-137><a class=lnlinks href=#hl-26-137>137</a>
</span><span class=lnt id=hl-26-138><a class=lnlinks href=#hl-26-138>138</a>
</span><span class=lnt id=hl-26-139><a class=lnlinks href=#hl-26-139>139</a>
</span><span class=lnt id=hl-26-140><a class=lnlinks href=#hl-26-140>140</a>
</span><span class=lnt id=hl-26-141><a class=lnlinks href=#hl-26-141>141</a>
</span><span class=lnt id=hl-26-142><a class=lnlinks href=#hl-26-142>142</a>
</span><span class=lnt id=hl-26-143><a class=lnlinks href=#hl-26-143>143</a>
</span><span class=lnt id=hl-26-144><a class=lnlinks href=#hl-26-144>144</a>
</span><span class=lnt id=hl-26-145><a class=lnlinks href=#hl-26-145>145</a>
</span><span class=lnt id=hl-26-146><a class=lnlinks href=#hl-26-146>146</a>
</span><span class=lnt id=hl-26-147><a class=lnlinks href=#hl-26-147>147</a>
</span><span class=lnt id=hl-26-148><a class=lnlinks href=#hl-26-148>148</a>
</span><span class=lnt id=hl-26-149><a class=lnlinks href=#hl-26-149>149</a>
</span><span class=lnt id=hl-26-150><a class=lnlinks href=#hl-26-150>150</a>
</span><span class=lnt id=hl-26-151><a class=lnlinks href=#hl-26-151>151</a>
</span><span class=lnt id=hl-26-152><a class=lnlinks href=#hl-26-152>152</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BankingLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>db_config</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>db_pool</span> <span class=o>=</span> <span class=n>create_connection_pool</span><span class=p>(</span><span class=o>**</span><span class=n>db_config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_escalation_threshold</span> <span class=o>=</span> <span class=mi>500</span>  <span class=c1># 계좌당 최대 행 잠금 수</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>deadlock_retry_count</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>performance_monitor</span> <span class=o>=</span> <span class=n>PerformanceMonitor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>transfer_money</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        계좌 이체 - 데드락 방지를 위한 정렬된 잠금 순서
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 데드락 방지: 계좌 ID 순으로 정렬하여 잠금</span>
</span></span><span class=line><span class=cl>        <span class=n>accounts</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>([</span><span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>retry_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>retry_count</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>deadlock_retry_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>db_pool</span><span class=o>.</span><span class=n>get_connection</span><span class=p>()</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>conn</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>                    <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 정렬된 순서로 계좌 잠금</span>
</span></span><span class=line><span class=cl>                    <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                        SELECT account_id, balance 
</span></span></span><span class=line><span class=cl><span class=s2>                        FROM accounts 
</span></span></span><span class=line><span class=cl><span class=s2>                        WHERE account_id IN (</span><span class=si>%s</span><span class=s2>, </span><span class=si>%s</span><span class=s2>)
</span></span></span><span class=line><span class=cl><span class=s2>                        ORDER BY account_id
</span></span></span><span class=line><span class=cl><span class=s2>                        FOR UPDATE
</span></span></span><span class=line><span class=cl><span class=s2>                    &#34;&#34;&#34;</span><span class=p>,</span> <span class=n>accounts</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=n>account_data</span> <span class=o>=</span> <span class=p>{</span><span class=n>row</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span> <span class=n>row</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchall</span><span class=p>()}</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 잔액 검증</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=n>account_data</span><span class=p>[</span><span class=n>from_account</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>amount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=k>raise</span> <span class=n>InsufficientFundsError</span><span class=p>(</span><span class=s2>&#34;잔액 부족&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 이체 실행</span>
</span></span><span class=line><span class=cl>                    <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                        UPDATE accounts 
</span></span></span><span class=line><span class=cl><span class=s2>                        SET balance = balance - </span><span class=si>%s</span><span class=s2>,
</span></span></span><span class=line><span class=cl><span class=s2>                            last_modified = NOW()
</span></span></span><span class=line><span class=cl><span class=s2>                        WHERE account_id = </span><span class=si>%s</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>                    &#34;&#34;&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>from_account</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                        UPDATE accounts 
</span></span></span><span class=line><span class=cl><span class=s2>                        SET balance = balance + </span><span class=si>%s</span><span class=s2>,
</span></span></span><span class=line><span class=cl><span class=s2>                            last_modified = NOW()
</span></span></span><span class=line><span class=cl><span class=s2>                        WHERE account_id = </span><span class=si>%s</span><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>                    &#34;&#34;&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>to_account</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 거래 이력 기록</span>
</span></span><span class=line><span class=cl>                    <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                        INSERT INTO transaction_log 
</span></span></span><span class=line><span class=cl><span class=s2>                        (from_account, to_account, amount, transaction_time)
</span></span></span><span class=line><span class=cl><span class=s2>                        VALUES (</span><span class=si>%s</span><span class=s2>, </span><span class=si>%s</span><span class=s2>, </span><span class=si>%s</span><span class=s2>, NOW())
</span></span></span><span class=line><span class=cl><span class=s2>                    &#34;&#34;&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>,</span> <span class=n>amount</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=n>conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=c1># 성능 메트릭 기록</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>performance_monitor</span><span class=o>.</span><span class=n>record_successful_transaction</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                        <span class=s1>&#39;transfer&#39;</span><span class=p>,</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>                    <span class=p>)</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>                    
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=n>DeadlockError</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>retry_count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>performance_monitor</span><span class=o>.</span><span class=n>record_deadlock</span><span class=p>(</span><span class=s1>&#39;transfer&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>retry_count</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>deadlock_retry_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 지수 백오프로 재시도</span>
</span></span><span class=line><span class=cl>                    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span> <span class=o>*</span> <span class=p>(</span><span class=mi>2</span> <span class=o>**</span> <span class=n>retry_count</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>raise</span> <span class=n>TransactionFailedError</span><span class=p>(</span><span class=s2>&#34;데드락으로 인한 거래 실패&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>conn</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>raise</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>batch_interest_calculation</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>account_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        대용량 배치 처리 - 테이블 수준 잠금 사용
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>db_pool</span><span class=o>.</span><span class=n>get_connection</span><span class=p>()</span> <span class=k>as</span> <span class=n>conn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>conn</span><span class=o>.</span><span class=n>autocommit</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 테이블 수준 잠금으로 일관성 보장</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;LOCK TABLES accounts WRITE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 해당 유형 계좌의 이자 계산</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                    UPDATE accounts 
</span></span></span><span class=line><span class=cl><span class=s2>                    SET balance = balance * 1.02,  -- 2% 이자
</span></span></span><span class=line><span class=cl><span class=s2>                        last_interest_date = CURDATE()
</span></span></span><span class=line><span class=cl><span class=s2>                    WHERE account_type = </span><span class=si>%s</span><span class=s2> 
</span></span></span><span class=line><span class=cl><span class=s2>                    AND last_interest_date &lt; CURDATE()
</span></span></span><span class=line><span class=cl><span class=s2>                &#34;&#34;&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>account_type</span><span class=p>,))</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=n>affected_rows</span> <span class=o>=</span> <span class=n>cursor</span><span class=o>.</span><span class=n>rowcount</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 배치 로그 기록</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                    INSERT INTO batch_log 
</span></span></span><span class=line><span class=cl><span class=s2>                    (operation, account_type, affected_rows, execution_time)
</span></span></span><span class=line><span class=cl><span class=s2>                    VALUES (&#39;interest_calculation&#39;, </span><span class=si>%s</span><span class=s2>, </span><span class=si>%s</span><span class=s2>, NOW())
</span></span></span><span class=line><span class=cl><span class=s2>                &#34;&#34;&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>account_type</span><span class=p>,</span> <span class=n>affected_rows</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=n>conn</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UNLOCK TABLES&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>affected_rows</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=s2>&#34;UNLOCK TABLES&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>conn</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>raise</span> <span class=n>BatchProcessingError</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;배치 처리 실패: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 적응적 잠금 입도 선택기</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AdaptiveLockStrategy</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transaction_patterns</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>performance_history</span> <span class=o>=</span> <span class=n>deque</span><span class=p>(</span><span class=n>maxlen</span><span class=o>=</span><span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>choose_lock_strategy</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>transaction_type</span><span class=p>,</span> <span class=n>params</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        트랜잭션 유형과 파라미터를 바탕으로 최적 잠금 전략 선택
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>transaction_type</span> <span class=o>==</span> <span class=s1>&#39;transfer&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 소액 이체는 행 수준, 대액 이체는 추가 검증</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>params</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;amount&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1000000</span><span class=p>:</span>  <span class=c1># 100만원 초과</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=s1>&#39;row_with_validation&#39;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;row_optimized&#39;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>transaction_type</span> <span class=o>==</span> <span class=s1>&#39;batch&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 배치 크기에 따른 입도 선택</span>
</span></span><span class=line><span class=cl>            <span class=n>estimated_rows</span> <span class=o>=</span> <span class=n>params</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;estimated_rows&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>estimated_rows</span> <span class=o>&gt;</span> <span class=mi>10000</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=s1>&#39;table_lock&#39;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;page_lock&#39;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>transaction_type</span> <span class=o>==</span> <span class=s1>&#39;inquiry&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 조회 전용 트랜잭션</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;read_committed&#39;</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s1>&#39;default&#39;</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과>#</a></h6><p><strong>정량적 성과</strong>:</p><ul><li><strong>처리량 개선</strong>: 기존 대비 300% 향상 (3,000 TPS → 12,000 TPS)</li><li><strong>응답 시간</strong>: 평균 180ms 달성 (목표 200ms 대비 20ms 단축)</li><li><strong>데드락 감소</strong>: 99.8% 감소 (월 1,000 건 → 월 2 건)</li><li><strong>시스템 안정성</strong>: 99.99% 가용성 달성</li></ul><p><strong>정성적 개선</strong>:</p><ul><li><strong>고객 경험</strong>: 거래 대기 시간 단축으로 고객 만족도 15% 향상</li><li><strong>운영 효율</strong>: 장애 대응 시간 80% 단축</li><li><strong>개발자 경험</strong>: 디버깅 시간 60% 감소</li></ul><p><strong>비용 효과</strong>:</p><ul><li><strong>하드웨어 비용</strong>: 서버 수 30% 감소 (효율성 개선)</li><li><strong>운영 비용</strong>: 모니터링 인력 50% 절감</li><li><strong>규제 대응</strong>: 감사 준비 시간 70% 단축</li></ul><h6 id=교훈-및-시사점>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점>#</a></h6><p><strong>성공 요인</strong>:</p><ol><li><strong>단계적 도입</strong>: 점진적 마이그레이션으로 위험 최소화</li><li><strong>철저한 테스트</strong>: 실제 트래픽 시뮬레이션 기반 검증</li><li><strong>모니터링 체계</strong>: 실시간 성능 추적 및 알림 시스템</li><li><strong>팀 교육</strong>: 개발팀의 잠금 메커니즘 이해도 향상</li></ol><p><strong>주요 도전과제</strong>:</p><ol><li><strong>레거시 연동</strong>: 기존 시스템과의 트랜잭션 일관성 보장</li><li><strong>성능 튜닝</strong>: 최적 임계값 찾기 위한 지속적 실험</li><li><strong>장애 대응</strong>: 복잡한 잠금 구조로 인한 디버깅 어려움</li></ol><p><strong>재현 시 유의점</strong>:</p><ul><li>충분한 테스트 환경에서 부하 테스트 필수</li><li>데드락 탐지/해결 메커니즘 사전 구축</li><li>모니터링 지표 정의 및 임계값 설정</li><li>팀 교육 및 운영 절차 수립</li></ul><p><strong>확장 아이디어</strong>:</p><ul><li>기계학습 기반 예측적 잠금 상승</li><li>블록체인 기반 분산 잠금 메커니즘</li><li>실시간 사기 탐지와 연계한 적응적 잠금</li></ul><h5 id=사례-주문-처리-시스템의-핫-파티션-완화>사례: 주문 처리 시스템의 핫 파티션 완화<a hidden class=anchor aria-hidden=true href=#사례-주문-처리-시스템의-핫-파티션-완화>#</a></h5><h6 id=배경목표>배경/목표<a hidden class=anchor aria-hidden=true href=#배경목표>#</a></h6><ul><li>특정 지역 파티션에 트래픽 집중, 데드락 증가</li></ul><h6 id=구현-아키텍처-1>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처-1>#</a></h6><ul><li>파티셔닝 + 파티션 락 기반 배치, OLTP 는 행/키 - 범위 유지</li></ul><pre class=mermaid>flowchart LR
  C[Client] --&gt; API
  API --&gt; DB[(RDBMS)]
  DB --&gt; P1[Partition A]
  DB --&gt; P2[Partition B]
  subgraph Batch
    B1[&#34;ETL Job]\n(Table Lock on Partition)&#34;]
  end
  B1 --&gt; P2
</pre><h6 id=핵심-코드-개념>핵심 코드 (개념)<a hidden class=anchor aria-hidden=true href=#핵심-코드-개념>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-28-1><a class=lnlinks href=#hl-28-1>1</a>
</span><span class=lnt id=hl-28-2><a class=lnlinks href=#hl-28-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 배치 창구에서만 파티션 테이블 락 허용
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>LOCK</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>orders_2025q3</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=k>SHARE</span><span class=w> </span><span class=k>ROW</span><span class=w> </span><span class=k>EXCLUSIVE</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h6 id=성과>성과<a hidden class=anchor aria-hidden=true href=#성과>#</a></h6><ul><li>데드락 80% 감소, 배치 시간 30% 단축</li></ul><h6 id=교훈>교훈<a hidden class=anchor aria-hidden=true href=#교훈>#</a></h6><ul><li>핫스팟은 파티셔닝과 세분화 전략의 경계면에서 해결된다</li></ul><h4 id=락-그레인-통합연계-기술-통찰>락 그레인 통합·연계 기술 통찰<a hidden class=anchor aria-hidden=true href=#락-그레인-통합연계-기술-통찰>#</a></h4><ul><li><p><strong>문제</strong>: 분산 환경에서 동시에 같은 데이터에 접근하면 충돌이 나고, 잠그면 성능이 떨어진다.</p></li><li><p><strong>해결 아이디어</strong>: &rsquo; 글로벌 락으로 충돌을 막고 (정합성), 로컬 락과 캐시로 성능을 확보하며 (응답성), 메시지로 대기자에게 알림을 준다 (효율)&rsquo;—이 세 가지를 연결하면 균형을 맞출 수 있다.</p></li><li><p><strong>운영 포인트</strong>: 글로벌 락은 성능·안전성 트레이드오프가 있으므로 _ 정합성 수준 _ 에 따라 Redis 계열 (경량) 또는 합의 기반 (강한 안전) 중 선택해야 한다. 캐시는 커밋 이후 무효화, 메시지 큐는 idempotent 재시도/ack 설계가 필수다.</p></li></ul><h5 id=락-그레인-통합연계-기술-개요>락 그레인 통합·연계 기술 개요<a hidden class=anchor aria-hidden=true href=#락-그레인-통합연계-기술-개요>#</a></h5><h6 id=왜-통합하는가-why>왜 통합하는가 (Why)<a hidden class=anchor aria-hidden=true href=#왜-통합하는가-why>#</a></h6><ul><li><strong>목표</strong>: 락으로 인한 블로킹·자원 낭비를 줄이고, 데이터 일관성과 시스템 성능을 둘 다 확보하는 것.</li><li><strong>문제 맥락</strong>: 로컬 DB 락만 있으면 멀티노드 환경에서 경쟁·중복작업이 발생하고, 캐시·비동기 패스가 없으면 응답성 저하.</li></ul><h6 id=무엇을-통합하는가-what>무엇을 통합하는가 (What)<a hidden class=anchor aria-hidden=true href=#무엇을-통합하는가-what>#</a></h6><ul><li><strong>글로벌 분산 락</strong>(Redis/Redlock 또는 합의 기반)</li><li><strong>로컬 DB 락</strong>(FOR UPDATE 등)—성능 확보용</li><li><strong>캐시 계층 연계</strong>(무효화/이벤트)—읽기 성능 향상</li><li><strong>메시지 큐/이벤트</strong>(대기 알림·비동기 후처리)—폴링 제거·지연 오프로드</li><li><strong>모니터링·알림</strong>(Prometheus/Grafana)—운영 가시성 확보</li></ul><h6 id=어떻게-통합하는가-how>어떻게 통합하는가 (How)<a hidden class=anchor aria-hidden=true href=#어떻게-통합하는가-how>#</a></h6><ul><li><strong>조합 패턴</strong>: 글로벌 락 (분산) 획득 → 로컬 DB 트랜잭션 (필요 시 FOR UPDATE) → 트랜잭션 커밋 → 캐시 무효화 이벤트 발행 (비동기) → 글로벌 락 해제. (원자성/정합성 보장을 위해 release 스크립트/펜싱 사용 권장).</li><li><strong>이벤트 알림 패턴</strong>: 잠금 해제 시 메시지 큐로 &rsquo;lock_released&rsquo; 발행 → 대기자 (구독자) 는 수신 즉시 재시도. 재시도/중복방지 (아이디엠포턴시) 필수.</li><li><strong>모니터링 루프</strong>: lock_wait_time, active_locks, deadlocks_total 같은 메트릭을 수집해 경보 룰 (예: wait > 5s, deadlock rate spike) 로 운영자/자동대응 트리거 설정.</li></ul><h6 id=통합으로-얻는-가치-value>통합으로 얻는 가치 (Value)<a hidden class=anchor aria-hidden=true href=#통합으로-얻는-가치-value>#</a></h6><ul><li><strong>성능</strong>: 캐시 + 로컬 락으로 읽기 처리량 대폭 향상 (실무 사례: 캐시 활용으로 응답성·처리량 향상).</li><li><strong>효율</strong>: 메시지 기반 알림으로 폴링 제거→자원 절약·대기시간 감소.</li><li><strong>신뢰성 (조건부)</strong>: 합의 기반 락 사용 시 강한 정합성 확보 (대신 비용 증가).</li></ul><h5 id=42-통합-내용-표>4.2 통합 내용 표<a hidden class=anchor aria-hidden=true href=#42-통합-내용-표>#</a></h5><table><thead><tr><th>통합 요소</th><th>어떻게 통합하는가</th><th>운영상 주의점</th><th>얻는 가치</th></tr></thead><tbody><tr><td>분산 락 + 로컬 락</td><td>글로벌 락 획득 → 로컬 DB 트랜잭션 → 커밋 → 글로벌 해제</td><td>펜싱·락만료·타임아웃 설계 필요</td><td>글로벌 일관성 + 로컬 성능</td></tr><tr><td>캐시 연계</td><td>트랜잭션 커밋 후 비동기 캐시 무효화 (또는 로그 기반)</td><td>무효화 지연·중복 처리 설계 필요</td><td>읽기 성능 향상, 캐시 일관성 유지</td></tr><tr><td>메시지 큐 연동</td><td>잠금 해제 이벤트 발행 → 대기자 재시도</td><td>idempotency·ack·재시도 정책 필요</td><td>폴링 제거·대기시간 감소</td></tr><tr><td>모니터링 통합</td><td>Prometheus 메트릭 + Grafana 알림 룰</td><td>적정 임계값·알람 튜닝 필요</td><td>가시성 확보·자동화 트리거</td></tr></tbody></table><h5 id=락-통합-기술의-4-대-카테고리>락 통합 기술의 4 대 카테고리<a hidden class=anchor aria-hidden=true href=#락-통합-기술의-4-대-카테고리>#</a></h5><h6 id=동기화-계층-통합>동기화 계층 통합<a hidden class=anchor aria-hidden=true href=#동기화-계층-통합>#</a></h6><p>글로벌 분산 락 (예: Redis) 과 로컬 DB 락을 조합하면 &rsquo; 노드간 정합성 &rsquo; 과 &rsquo; 로컬 성능 &rsquo; 을 동시에 잡을 수 있다.</p><ul><li>어떻게: 글로벌 락 획득 → 로컬 트랜잭션 (필요 시 FOR UPDATE) → 커밋 → 캐시 무효화 이벤트 → 글로벌 락 해제.</li><li>왜 중요한가: 글로벌 충돌을 막으면서 로컬 DB 의 원자성/성능을 유지할 수 있음.</li><li>운영 유의사항: Redis 락의 타임아웃·락 갱신·펜싱 고려, 합의 기반 대체 (Etcd/ZK) 검토.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>권장 패턴</th><th>운영 핵심</th></tr></thead><tbody><tr><td>글로벌 + 로컬</td><td style=text-align:right>선획득 → 로컬 트랜잭션 → 해제</td><td>펜싱·타임아웃·락 갱신</td></tr></tbody></table><p>글로벌 + 로컬 조합은 분산 환경에서 현실적인 타협이다. 성능과 정합성 요구 수준에 따라 Redis 형 (경량) 또는 Raft/Paxos 계열 (강한 안전) 으로 결정하라.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-29-1><a class=lnlinks href=#hl-29-1> 1</a>
</span><span class=lnt id=hl-29-2><a class=lnlinks href=#hl-29-2> 2</a>
</span><span class=lnt id=hl-29-3><a class=lnlinks href=#hl-29-3> 3</a>
</span><span class=lnt id=hl-29-4><a class=lnlinks href=#hl-29-4> 4</a>
</span><span class=lnt id=hl-29-5><a class=lnlinks href=#hl-29-5> 5</a>
</span><span class=lnt id=hl-29-6><a class=lnlinks href=#hl-29-6> 6</a>
</span><span class=lnt id=hl-29-7><a class=lnlinks href=#hl-29-7> 7</a>
</span><span class=lnt id=hl-29-8><a class=lnlinks href=#hl-29-8> 8</a>
</span><span class=lnt id=hl-29-9><a class=lnlinks href=#hl-29-9> 9</a>
</span><span class=lnt id=hl-29-10><a class=lnlinks href=#hl-29-10>10</a>
</span><span class=lnt id=hl-29-11><a class=lnlinks href=#hl-29-11>11</a>
</span><span class=lnt id=hl-29-12><a class=lnlinks href=#hl-29-12>12</a>
</span><span class=lnt id=hl-29-13><a class=lnlinks href=#hl-29-13>13</a>
</span><span class=lnt id=hl-29-14><a class=lnlinks href=#hl-29-14>14</a>
</span><span class=lnt id=hl-29-15><a class=lnlinks href=#hl-29-15>15</a>
</span><span class=lnt id=hl-29-16><a class=lnlinks href=#hl-29-16>16</a>
</span><span class=lnt id=hl-29-17><a class=lnlinks href=#hl-29-17>17</a>
</span><span class=lnt id=hl-29-18><a class=lnlinks href=#hl-29-18>18</a>
</span><span class=lnt id=hl-29-19><a class=lnlinks href=#hl-29-19>19</a>
</span><span class=lnt id=hl-29-20><a class=lnlinks href=#hl-29-20>20</a>
</span><span class=lnt id=hl-29-21><a class=lnlinks href=#hl-29-21>21</a>
</span><span class=lnt id=hl-29-22><a class=lnlinks href=#hl-29-22>22</a>
</span><span class=lnt id=hl-29-23><a class=lnlinks href=#hl-29-23>23</a>
</span><span class=lnt id=hl-29-24><a class=lnlinks href=#hl-29-24>24</a>
</span><span class=lnt id=hl-29-25><a class=lnlinks href=#hl-29-25>25</a>
</span><span class=lnt id=hl-29-26><a class=lnlinks href=#hl-29-26>26</a>
</span><span class=lnt id=hl-29-27><a class=lnlinks href=#hl-29-27>27</a>
</span><span class=lnt id=hl-29-28><a class=lnlinks href=#hl-29-28>28</a>
</span><span class=lnt id=hl-29-29><a class=lnlinks href=#hl-29-29>29</a>
</span><span class=lnt id=hl-29-30><a class=lnlinks href=#hl-29-30>30</a>
</span><span class=lnt id=hl-29-31><a class=lnlinks href=#hl-29-31>31</a>
</span><span class=lnt id=hl-29-32><a class=lnlinks href=#hl-29-32>32</a>
</span><span class=lnt id=hl-29-33><a class=lnlinks href=#hl-29-33>33</a>
</span><span class=lnt id=hl-29-34><a class=lnlinks href=#hl-29-34>34</a>
</span><span class=lnt id=hl-29-35><a class=lnlinks href=#hl-29-35>35</a>
</span><span class=lnt id=hl-29-36><a class=lnlinks href=#hl-29-36>36</a>
</span><span class=lnt id=hl-29-37><a class=lnlinks href=#hl-29-37>37</a>
</span><span class=lnt id=hl-29-38><a class=lnlinks href=#hl-29-38>38</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>redis</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>uuid</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>contextlib</span> <span class=kn>import</span> <span class=n>contextmanager</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DistributedLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>redis_client</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>redis</span> <span class=o>=</span> <span class=n>redis_client</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>local_locks</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=nd>@contextmanager</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>distributed_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>local_granularity</span><span class=o>=</span><span class=s1>&#39;row&#39;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        분산 환경에서 로컬 잠금과 글로벌 잠금 조합
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_key</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;global_lock:</span><span class=si>{</span><span class=n>resource_id</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_value</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>uuid</span><span class=o>.</span><span class=n>uuid4</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>timeout</span> <span class=o>=</span> <span class=mi>30</span>  <span class=c1># 30초 타임아웃</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 1. 글로벌 분산 잠금 획득</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>redis</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>lock_key</span><span class=p>,</span> <span class=n>lock_value</span><span class=p>,</span> <span class=n>nx</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>ex</span><span class=o>=</span><span class=n>timeout</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1># 2. 로컬 데이터베이스 잠금 획득</span>
</span></span><span class=line><span class=cl>                <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>_local_lock</span><span class=p>(</span><span class=n>resource_id</span><span class=p>,</span> <span class=n>local_granularity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>yield</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>raise</span> <span class=n>DistributedLockError</span><span class=p>(</span><span class=s2>&#34;글로벌 잠금 획득 실패&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>        <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 3. 글로벌 잠금 해제 (원자적 해제 보장)</span>
</span></span><span class=line><span class=cl>            <span class=n>lua_script</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>                if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then
</span></span></span><span class=line><span class=cl><span class=s2>                    return redis.call(&#39;del&#39;, KEYS[1])
</span></span></span><span class=line><span class=cl><span class=s2>                else
</span></span></span><span class=line><span class=cl><span class=s2>                    return 0
</span></span></span><span class=line><span class=cl><span class=s2>                end
</span></span></span><span class=line><span class=cl><span class=s2>            &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>redis</span><span class=o>.</span><span class=n>eval</span><span class=p>(</span><span class=n>lua_script</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>lock_key</span><span class=p>,</span> <span class=n>lock_value</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성능-보강-통합-캐시-연계>성능 보강 통합 (캐시 연계)<a hidden class=anchor aria-hidden=true href=#성능-보강-통합-캐시-연계>#</a></h6><p>캐시를 트랜잭션 경로에 연계하면 읽기 성능을 대폭 높일 수 있으나 무효화의 타이밍·정합성 처리가 핵심이다.</p><ul><li>어떻게: 트랜잭션 커밋 후 무효화 메시지 발행 (비동기), 또는 트랜잭션 로그 기반 일괄 무효화.</li><li>왜 중요한가: 읽기 부하가 큰 서비스에서 응답성·처리량을 확보하기 위해 필수.</li><li>운영 유의사항: 무효화 지연/중복에 대비한 idempotency, 스케줄러/큐 크기 모니터링.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>권장 패턴</th><th>운영 핵심</th></tr></thead><tbody><tr><td>캐시 무효화</td><td style=text-align:right>트랜잭션 → 이벤트 무효화 (비동기)</td><td>무효화 지연·중복 처리</td></tr></tbody></table><p>캐시 연계는 &rsquo; 읽기 성능 &rsquo; 을 극대화하지만 일관성 경계를 명확히 정의해야 한다. 트랜잭션 로그 기반 방법은 안전성을 높인다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-30-1><a class=lnlinks href=#hl-30-1> 1</a>
</span><span class=lnt id=hl-30-2><a class=lnlinks href=#hl-30-2> 2</a>
</span><span class=lnt id=hl-30-3><a class=lnlinks href=#hl-30-3> 3</a>
</span><span class=lnt id=hl-30-4><a class=lnlinks href=#hl-30-4> 4</a>
</span><span class=lnt id=hl-30-5><a class=lnlinks href=#hl-30-5> 5</a>
</span><span class=lnt id=hl-30-6><a class=lnlinks href=#hl-30-6> 6</a>
</span><span class=lnt id=hl-30-7><a class=lnlinks href=#hl-30-7> 7</a>
</span><span class=lnt id=hl-30-8><a class=lnlinks href=#hl-30-8> 8</a>
</span><span class=lnt id=hl-30-9><a class=lnlinks href=#hl-30-9> 9</a>
</span><span class=lnt id=hl-30-10><a class=lnlinks href=#hl-30-10>10</a>
</span><span class=lnt id=hl-30-11><a class=lnlinks href=#hl-30-11>11</a>
</span><span class=lnt id=hl-30-12><a class=lnlinks href=#hl-30-12>12</a>
</span><span class=lnt id=hl-30-13><a class=lnlinks href=#hl-30-13>13</a>
</span><span class=lnt id=hl-30-14><a class=lnlinks href=#hl-30-14>14</a>
</span><span class=lnt id=hl-30-15><a class=lnlinks href=#hl-30-15>15</a>
</span><span class=lnt id=hl-30-16><a class=lnlinks href=#hl-30-16>16</a>
</span><span class=lnt id=hl-30-17><a class=lnlinks href=#hl-30-17>17</a>
</span><span class=lnt id=hl-30-18><a class=lnlinks href=#hl-30-18>18</a>
</span><span class=lnt id=hl-30-19><a class=lnlinks href=#hl-30-19>19</a>
</span><span class=lnt id=hl-30-20><a class=lnlinks href=#hl-30-20>20</a>
</span><span class=lnt id=hl-30-21><a class=lnlinks href=#hl-30-21>21</a>
</span><span class=lnt id=hl-30-22><a class=lnlinks href=#hl-30-22>22</a>
</span><span class=lnt id=hl-30-23><a class=lnlinks href=#hl-30-23>23</a>
</span><span class=lnt id=hl-30-24><a class=lnlinks href=#hl-30-24>24</a>
</span><span class=lnt id=hl-30-25><a class=lnlinks href=#hl-30-25>25</a>
</span><span class=lnt id=hl-30-26><a class=lnlinks href=#hl-30-26>26</a>
</span><span class=lnt id=hl-30-27><a class=lnlinks href=#hl-30-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>CacheAwareLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>db_connection</span><span class=p>,</span> <span class=n>cache_client</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>db</span> <span class=o>=</span> <span class=n>db_connection</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache</span> <span class=o>=</span> <span class=n>cache_client</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache_invalidation_queue</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>update_with_cache_invalidation</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>table</span><span class=p>,</span> <span class=n>conditions</span><span class=p>,</span> <span class=n>updates</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        데이터 업데이트와 캐시 무효화를 원자적으로 처리
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 1. 영향받는 캐시 키 미리 계산</span>
</span></span><span class=line><span class=cl>        <span class=n>affected_keys</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_calculate_cache_keys</span><span class=p>(</span><span class=n>table</span><span class=p>,</span> <span class=n>conditions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>transaction</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=c1># 2. 데이터베이스 잠금 및 업데이트</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>cursor</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;SELECT * FROM </span><span class=si>{</span><span class=n>table</span><span class=si>}</span><span class=s2> WHERE </span><span class=si>{</span><span class=n>conditions</span><span class=si>}</span><span class=s2> FOR UPDATE&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 실제 업데이트 실행</span>
</span></span><span class=line><span class=cl>            <span class=n>cursor</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;UPDATE </span><span class=si>{</span><span class=n>table</span><span class=si>}</span><span class=s2> SET </span><span class=si>{</span><span class=n>updates</span><span class=si>}</span><span class=s2> WHERE </span><span class=si>{</span><span class=n>conditions</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 3. 트랜잭션 커밋 후 캐시 무효화 스케줄링</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>db</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=c1># 4. 비동기 캐시 무효화 (성능 최적화)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>affected_keys</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>cache_invalidation_queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=대기알림-통합-메시지-큐>대기/알림 통합 (메시지 큐)<a hidden class=anchor aria-hidden=true href=#대기알림-통합-메시지-큐>#</a></h6><p>메시지 큐로 잠금 해제 이벤트를 발행하면 폴링을 제거하고 대기자에게 능동적 재시도 기회를 줄 수 있다.</p><ul><li>어떻게: 잠금 해제 시 &rsquo;lock_released&rsquo; 이벤트 발행 → 대기자는 수신 즉시 재시도 (ack/재시도 설계).</li><li>왜 중요한가: 폴링 오버헤드를 제거하고 대기 시간을 줄인다.</li><li>운영 유의사항: 재시도 - 중복 방지 (idempotency), 소비자 장애 처리, 메시지 지연 모니터링.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>권장 패턴</th><th>운영 핵심</th></tr></thead><tbody><tr><td>이벤트 알림</td><td style=text-align:right>lock_released 이벤트 발행</td><td>ack·idempotency·재시도</td></tr></tbody></table><p>메시지 기반 알림은 효율적이나, 신뢰성 (배달 보장) 과 중복 처리 설계가 필수다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-31-1><a class=lnlinks href=#hl-31-1> 1</a>
</span><span class=lnt id=hl-31-2><a class=lnlinks href=#hl-31-2> 2</a>
</span><span class=lnt id=hl-31-3><a class=lnlinks href=#hl-31-3> 3</a>
</span><span class=lnt id=hl-31-4><a class=lnlinks href=#hl-31-4> 4</a>
</span><span class=lnt id=hl-31-5><a class=lnlinks href=#hl-31-5> 5</a>
</span><span class=lnt id=hl-31-6><a class=lnlinks href=#hl-31-6> 6</a>
</span><span class=lnt id=hl-31-7><a class=lnlinks href=#hl-31-7> 7</a>
</span><span class=lnt id=hl-31-8><a class=lnlinks href=#hl-31-8> 8</a>
</span><span class=lnt id=hl-31-9><a class=lnlinks href=#hl-31-9> 9</a>
</span><span class=lnt id=hl-31-10><a class=lnlinks href=#hl-31-10>10</a>
</span><span class=lnt id=hl-31-11><a class=lnlinks href=#hl-31-11>11</a>
</span><span class=lnt id=hl-31-12><a class=lnlinks href=#hl-31-12>12</a>
</span><span class=lnt id=hl-31-13><a class=lnlinks href=#hl-31-13>13</a>
</span><span class=lnt id=hl-31-14><a class=lnlinks href=#hl-31-14>14</a>
</span><span class=lnt id=hl-31-15><a class=lnlinks href=#hl-31-15>15</a>
</span><span class=lnt id=hl-31-16><a class=lnlinks href=#hl-31-16>16</a>
</span><span class=lnt id=hl-31-17><a class=lnlinks href=#hl-31-17>17</a>
</span><span class=lnt id=hl-31-18><a class=lnlinks href=#hl-31-18>18</a>
</span><span class=lnt id=hl-31-19><a class=lnlinks href=#hl-31-19>19</a>
</span><span class=lnt id=hl-31-20><a class=lnlinks href=#hl-31-20>20</a>
</span><span class=lnt id=hl-31-21><a class=lnlinks href=#hl-31-21>21</a>
</span><span class=lnt id=hl-31-22><a class=lnlinks href=#hl-31-22>22</a>
</span><span class=lnt id=hl-31-23><a class=lnlinks href=#hl-31-23>23</a>
</span><span class=lnt id=hl-31-24><a class=lnlinks href=#hl-31-24>24</a>
</span><span class=lnt id=hl-31-25><a class=lnlinks href=#hl-31-25>25</a>
</span><span class=lnt id=hl-31-26><a class=lnlinks href=#hl-31-26>26</a>
</span><span class=lnt id=hl-31-27><a class=lnlinks href=#hl-31-27>27</a>
</span><span class=lnt id=hl-31-28><a class=lnlinks href=#hl-31-28>28</a>
</span><span class=lnt id=hl-31-29><a class=lnlinks href=#hl-31-29>29</a>
</span><span class=lnt id=hl-31-30><a class=lnlinks href=#hl-31-30>30</a>
</span><span class=lnt id=hl-31-31><a class=lnlinks href=#hl-31-31>31</a>
</span><span class=lnt id=hl-31-32><a class=lnlinks href=#hl-31-32>32</a>
</span><span class=lnt id=hl-31-33><a class=lnlinks href=#hl-31-33>33</a>
</span><span class=lnt id=hl-31-34><a class=lnlinks href=#hl-31-34>34</a>
</span><span class=lnt id=hl-31-35><a class=lnlinks href=#hl-31-35>35</a>
</span><span class=lnt id=hl-31-36><a class=lnlinks href=#hl-31-36>36</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>kafka</span> <span class=kn>import</span> <span class=n>KafkaProducer</span><span class=p>,</span> <span class=n>KafkaConsumer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>EventDrivenLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>kafka_config</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>producer</span> <span class=o>=</span> <span class=n>KafkaProducer</span><span class=p>(</span><span class=o>**</span><span class=n>kafka_config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>consumer</span> <span class=o>=</span> <span class=n>KafkaConsumer</span><span class=p>(</span><span class=s1>&#39;lock_events&#39;</span><span class=p>,</span> <span class=o>**</span><span class=n>kafka_config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>waiting_transactions</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire_lock_with_notification</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        이벤트 기반 잠금 획득 - 대기 시 알림 구독
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_try_immediate_lock</span><span class=p>(</span><span class=n>resource_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 대기 상태 등록 및 이벤트 구독</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>_register_waiting_transaction</span><span class=p>(</span><span class=n>resource_id</span><span class=p>,</span> <span class=n>transaction_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 잠금 해제 이벤트 대기</span>
</span></span><span class=line><span class=cl>        <span class=k>async</span> <span class=k>for</span> <span class=n>message</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>consumer</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>message</span><span class=o>.</span><span class=n>key</span><span class=o>.</span><span class=n>decode</span><span class=p>()</span> <span class=o>==</span> <span class=n>resource_id</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 잠금 재시도</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_try_immediate_lock</span><span class=p>(</span><span class=n>resource_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>release_lock_with_notification</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        잠금 해제 시 대기자들에게 이벤트 발송
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_release_local_lock</span><span class=p>(</span><span class=n>resource_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 대기 중인 트랜잭션들에게 알림</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>producer</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=s1>&#39;lock_events&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                          <span class=n>key</span><span class=o>=</span><span class=n>resource_id</span><span class=o>.</span><span class=n>encode</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                          <span class=n>value</span><span class=o>=</span><span class=sa>b</span><span class=s1>&#39;lock_released&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=관측운영-통합-모니터링>관측·운영 통합 (모니터링)<a hidden class=anchor aria-hidden=true href=#관측운영-통합-모니터링>#</a></h6><p>Prometheus/Grafana 등의 메트릭·알림 체계를 잠금 시스템에 통합해 실시간 이상 감지와 자동화 트리거를 구성한다.</p><ul><li>어떻게: lock_wait_seconds, active_locks, deadlocks_total 등 메트릭 수집 → Grafana 알림 규칙 설정 → 자동화 루프 (예: 샘플링/알림/오퍼레이터 개입).</li><li>왜 중요한가: 잠금 병목·데드락의 조기 탐지와 원인 분석을 가능하게 함.</li><li>운영 유의사항: 적정 임계값 설정, 노이즈 필터링, 알림 피로 방지.</li></ul><table><thead><tr><th>항목</th><th style=text-align:right>권장 패턴</th><th>운영 핵심</th></tr></thead><tbody><tr><td>모니터링</td><td style=text-align:right>Prometheus 메트릭 + Grafana 알림</td><td>임계값 튜닝·알림 정책</td></tr></tbody></table><p>모니터링은 문제발생 이전의 예방과 빠른 대응을 가능하게 한다. 자동화 루프를 설계하면 운영 부담을 크게 줄일 수 있다.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-32-1><a class=lnlinks href=#hl-32-1> 1</a>
</span><span class=lnt id=hl-32-2><a class=lnlinks href=#hl-32-2> 2</a>
</span><span class=lnt id=hl-32-3><a class=lnlinks href=#hl-32-3> 3</a>
</span><span class=lnt id=hl-32-4><a class=lnlinks href=#hl-32-4> 4</a>
</span><span class=lnt id=hl-32-5><a class=lnlinks href=#hl-32-5> 5</a>
</span><span class=lnt id=hl-32-6><a class=lnlinks href=#hl-32-6> 6</a>
</span><span class=lnt id=hl-32-7><a class=lnlinks href=#hl-32-7> 7</a>
</span><span class=lnt id=hl-32-8><a class=lnlinks href=#hl-32-8> 8</a>
</span><span class=lnt id=hl-32-9><a class=lnlinks href=#hl-32-9> 9</a>
</span><span class=lnt id=hl-32-10><a class=lnlinks href=#hl-32-10>10</a>
</span><span class=lnt id=hl-32-11><a class=lnlinks href=#hl-32-11>11</a>
</span><span class=lnt id=hl-32-12><a class=lnlinks href=#hl-32-12>12</a>
</span><span class=lnt id=hl-32-13><a class=lnlinks href=#hl-32-13>13</a>
</span><span class=lnt id=hl-32-14><a class=lnlinks href=#hl-32-14>14</a>
</span><span class=lnt id=hl-32-15><a class=lnlinks href=#hl-32-15>15</a>
</span><span class=lnt id=hl-32-16><a class=lnlinks href=#hl-32-16>16</a>
</span><span class=lnt id=hl-32-17><a class=lnlinks href=#hl-32-17>17</a>
</span><span class=lnt id=hl-32-18><a class=lnlinks href=#hl-32-18>18</a>
</span><span class=lnt id=hl-32-19><a class=lnlinks href=#hl-32-19>19</a>
</span><span class=lnt id=hl-32-20><a class=lnlinks href=#hl-32-20>20</a>
</span><span class=lnt id=hl-32-21><a class=lnlinks href=#hl-32-21>21</a>
</span><span class=lnt id=hl-32-22><a class=lnlinks href=#hl-32-22>22</a>
</span><span class=lnt id=hl-32-23><a class=lnlinks href=#hl-32-23>23</a>
</span><span class=lnt id=hl-32-24><a class=lnlinks href=#hl-32-24>24</a>
</span><span class=lnt id=hl-32-25><a class=lnlinks href=#hl-32-25>25</a>
</span><span class=lnt id=hl-32-26><a class=lnlinks href=#hl-32-26>26</a>
</span><span class=lnt id=hl-32-27><a class=lnlinks href=#hl-32-27>27</a>
</span><span class=lnt id=hl-32-28><a class=lnlinks href=#hl-32-28>28</a>
</span><span class=lnt id=hl-32-29><a class=lnlinks href=#hl-32-29>29</a>
</span><span class=lnt id=hl-32-30><a class=lnlinks href=#hl-32-30>30</a>
</span><span class=lnt id=hl-32-31><a class=lnlinks href=#hl-32-31>31</a>
</span><span class=lnt id=hl-32-32><a class=lnlinks href=#hl-32-32>32</a>
</span><span class=lnt id=hl-32-33><a class=lnlinks href=#hl-32-33>33</a>
</span><span class=lnt id=hl-32-34><a class=lnlinks href=#hl-32-34>34</a>
</span><span class=lnt id=hl-32-35><a class=lnlinks href=#hl-32-35>35</a>
</span><span class=lnt id=hl-32-36><a class=lnlinks href=#hl-32-36>36</a>
</span><span class=lnt id=hl-32-37><a class=lnlinks href=#hl-32-37>37</a>
</span><span class=lnt id=hl-32-38><a class=lnlinks href=#hl-32-38>38</a>
</span><span class=lnt id=hl-32-39><a class=lnlinks href=#hl-32-39>39</a>
</span><span class=lnt id=hl-32-40><a class=lnlinks href=#hl-32-40>40</a>
</span><span class=lnt id=hl-32-41><a class=lnlinks href=#hl-32-41>41</a>
</span><span class=lnt id=hl-32-42><a class=lnlinks href=#hl-32-42>42</a>
</span><span class=lnt id=hl-32-43><a class=lnlinks href=#hl-32-43>43</a>
</span><span class=lnt id=hl-32-44><a class=lnlinks href=#hl-32-44>44</a>
</span><span class=lnt id=hl-32-45><a class=lnlinks href=#hl-32-45>45</a>
</span><span class=lnt id=hl-32-46><a class=lnlinks href=#hl-32-46>46</a>
</span><span class=lnt id=hl-32-47><a class=lnlinks href=#hl-32-47>47</a>
</span><span class=lnt id=hl-32-48><a class=lnlinks href=#hl-32-48>48</a>
</span><span class=lnt id=hl-32-49><a class=lnlinks href=#hl-32-49>49</a>
</span><span class=lnt id=hl-32-50><a class=lnlinks href=#hl-32-50>50</a>
</span><span class=lnt id=hl-32-51><a class=lnlinks href=#hl-32-51>51</a>
</span><span class=lnt id=hl-32-52><a class=lnlinks href=#hl-32-52>52</a>
</span><span class=lnt id=hl-32-53><a class=lnlinks href=#hl-32-53>53</a>
</span><span class=lnt id=hl-32-54><a class=lnlinks href=#hl-32-54>54</a>
</span><span class=lnt id=hl-32-55><a class=lnlinks href=#hl-32-55>55</a>
</span><span class=lnt id=hl-32-56><a class=lnlinks href=#hl-32-56>56</a>
</span><span class=lnt id=hl-32-57><a class=lnlinks href=#hl-32-57>57</a>
</span><span class=lnt id=hl-32-58><a class=lnlinks href=#hl-32-58>58</a>
</span><span class=lnt id=hl-32-59><a class=lnlinks href=#hl-32-59>59</a>
</span><span class=lnt id=hl-32-60><a class=lnlinks href=#hl-32-60>60</a>
</span><span class=lnt id=hl-32-61><a class=lnlinks href=#hl-32-61>61</a>
</span><span class=lnt id=hl-32-62><a class=lnlinks href=#hl-32-62>62</a>
</span><span class=lnt id=hl-32-63><a class=lnlinks href=#hl-32-63>63</a>
</span><span class=lnt id=hl-32-64><a class=lnlinks href=#hl-32-64>64</a>
</span><span class=lnt id=hl-32-65><a class=lnlinks href=#hl-32-65>65</a>
</span><span class=lnt id=hl-32-66><a class=lnlinks href=#hl-32-66>66</a>
</span><span class=lnt id=hl-32-67><a class=lnlinks href=#hl-32-67>67</a>
</span><span class=lnt id=hl-32-68><a class=lnlinks href=#hl-32-68>68</a>
</span><span class=lnt id=hl-32-69><a class=lnlinks href=#hl-32-69>69</a>
</span><span class=lnt id=hl-32-70><a class=lnlinks href=#hl-32-70>70</a>
</span><span class=lnt id=hl-32-71><a class=lnlinks href=#hl-32-71>71</a>
</span><span class=lnt id=hl-32-72><a class=lnlinks href=#hl-32-72>72</a>
</span><span class=lnt id=hl-32-73><a class=lnlinks href=#hl-32-73>73</a>
</span><span class=lnt id=hl-32-74><a class=lnlinks href=#hl-32-74>74</a>
</span><span class=lnt id=hl-32-75><a class=lnlinks href=#hl-32-75>75</a>
</span><span class=lnt id=hl-32-76><a class=lnlinks href=#hl-32-76>76</a>
</span><span class=lnt id=hl-32-77><a class=lnlinks href=#hl-32-77>77</a>
</span><span class=lnt id=hl-32-78><a class=lnlinks href=#hl-32-78>78</a>
</span><span class=lnt id=hl-32-79><a class=lnlinks href=#hl-32-79>79</a>
</span><span class=lnt id=hl-32-80><a class=lnlinks href=#hl-32-80>80</a>
</span><span class=lnt id=hl-32-81><a class=lnlinks href=#hl-32-81>81</a>
</span><span class=lnt id=hl-32-82><a class=lnlinks href=#hl-32-82>82</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>prometheus_client</span> <span class=kn>import</span> <span class=n>Counter</span><span class=p>,</span> <span class=n>Histogram</span><span class=p>,</span> <span class=n>Gauge</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>grafana_api</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MonitoringIntegratedLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Prometheus 메트릭 정의</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_acquisitions</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=s1>&#39;lock_acquisitions_total&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                        <span class=s1>&#39;Total lock acquisitions&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                        <span class=p>[</span><span class=s1>&#39;granularity&#39;</span><span class=p>,</span> <span class=s1>&#39;table&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_wait_time</span> <span class=o>=</span> <span class=n>Histogram</span><span class=p>(</span><span class=s1>&#39;lock_wait_seconds&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                      <span class=s1>&#39;Lock waiting time&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                      <span class=p>[</span><span class=s1>&#39;resource_type&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>active_locks</span> <span class=o>=</span> <span class=n>Gauge</span><span class=p>(</span><span class=s1>&#39;active_locks_current&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                <span class=s1>&#39;Current number of active locks&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=p>[</span><span class=s1>&#39;lock_type&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>deadlock_count</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=s1>&#39;deadlocks_total&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                                    <span class=s1>&#39;Total deadlock occurrences&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># Grafana 대시보드 연동</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>grafana</span> <span class=o>=</span> <span class=n>grafana_api</span><span class=o>.</span><span class=n>GrafanaApi</span><span class=o>.</span><span class=n>from_url</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire_monitored_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource</span><span class=p>,</span> <span class=n>granularity</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        모니터링 메트릭과 함께 잠금 획득
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 실제 잠금 획득</span>
</span></span><span class=line><span class=cl>            <span class=n>success</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_acquire_lock_internal</span><span class=p>(</span><span class=n>resource</span><span class=p>,</span> <span class=n>granularity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>success</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 성공 메트릭 기록</span>
</span></span><span class=line><span class=cl>                <span class=n>wait_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>lock_acquisitions</span><span class=o>.</span><span class=n>labels</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=n>granularity</span><span class=o>=</span><span class=n>granularity</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                    <span class=n>table</span><span class=o>=</span><span class=n>resource</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;.&#39;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>lock_wait_time</span><span class=o>.</span><span class=n>labels</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                    <span class=n>resource_type</span><span class=o>=</span><span class=n>granularity</span>
</span></span><span class=line><span class=cl>                <span class=p>)</span><span class=o>.</span><span class=n>observe</span><span class=p>(</span><span class=n>wait_time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>active_locks</span><span class=o>.</span><span class=n>labels</span><span class=p>(</span><span class=n>lock_type</span><span class=o>=</span><span class=n>granularity</span><span class=p>)</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>success</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=n>DeadlockDetected</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 데드락 메트릭 기록</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>deadlock_count</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>setup_alerting_rules</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        알림 규칙 설정 - 잠금 관련 임계값 모니터링
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>alert_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;HighLockWaitTime&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;condition&#39;</span><span class=p>:</span> <span class=s1>&#39;lock_wait_seconds &gt; 5&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;severity&#39;</span><span class=p>:</span> <span class=s1>&#39;warning&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;message&#39;</span><span class=p>:</span> <span class=s1>&#39;잠금 대기 시간이 5초를 초과했습니다&#39;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;DeadlockSpike&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;condition&#39;</span><span class=p>:</span> <span class=s1>&#39;rate(deadlocks_total[5m]) &gt; 10&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;severity&#39;</span><span class=p>:</span> <span class=s1>&#39;critical&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>                <span class=s1>&#39;message&#39;</span><span class=p>:</span> <span class=s1>&#39;데드락 발생률이 급증했습니다&#39;</span>
</span></span><span class=line><span class=cl>            <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;name&#39;</span><span class=p>:</span> <span class=s1>&#39;LockEscalationFrequent&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;condition&#39;</span><span class=p>:</span> <span class=s1>&#39;rate(lock_escalations_total[5m]) &gt; 50&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;severity&#39;</span><span class=p>:</span> <span class=s1>&#39;warning&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;message&#39;</span><span class=p>:</span> <span class=s1>&#39;잠금 상승이 빈번하게 발생하고 있습니다&#39;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>rule</span> <span class=ow>in</span> <span class=n>alert_rules</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>grafana</span><span class=o>.</span><span class=n>create_alert_rule</span><span class=p>(</span><span class=n>rule</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=락-통합-기술-요약표>락 통합 기술 요약표<a hidden class=anchor aria-hidden=true href=#락-통합-기술-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 패턴</th><th style=text-align:right>주요 이슈</th><th>운영 포인트</th><th>핵심 가치</th></tr></thead><tbody><tr><td>동기화 계층</td><td>글로벌 분산 락 + 로컬 트랜잭션</td><td style=text-align:right>펜싱·락 만료·정합성</td><td>펜싱·타임아웃 설계, 합의대안 검토</td><td>정합성 유지 + 로컬 성능</td></tr><tr><td>성능 보강</td><td>트랜잭션→비동기 캐시 무효화</td><td style=text-align:right>무효화 지연·중복</td><td>idempotency·무효화 모니터링</td><td>읽기 성능 대폭 향상</td></tr><tr><td>대기/알림</td><td>메시지 큐로 lock_released 알림</td><td style=text-align:right>배달 지연·중복·소비자 장애</td><td>ack·재시도 정책·모니터링</td><td>폴링 제거·대기시간 감소</td></tr><tr><td>관측·운영</td><td>Prometheus/Grafana 메트릭</td><td style=text-align:right>임계값·알림 노이즈</td><td>임계값 튜닝·알람 라우팅</td><td>조기 탐지·자동화 트리거</td></tr></tbody></table><h3 id=운영-및-최적화>운영 및 최적화<a hidden class=anchor aria-hidden=true href=#운영-및-최적화>#</a></h3><h4 id=락-관측성-지표분류운영-실무>락 관측성: 지표·분류·운영 실무<a hidden class=anchor aria-hidden=true href=#락-관측성-지표분류운영-실무>#</a></h4><p>락 관측성은 시스템의 &rsquo; 락 상태 &rsquo; 를 지속적으로 파악해 성능 저하와 무결성 위험을 조기에 발견하는 활동이다.<br>핵심은</p><ol><li><strong>무엇을 측정할지 (P95/P99 대기, 데드락, 에스컬레이션 등)</strong></li><li><strong>어떻게 수집하고 시각화할지 (exporter → 시계열 DB → 대시보드)</strong></li><li><strong>언제 상세 추적을 활성화할지 (임계값·샘플링 정책)</strong><br>를 설계하는 것이다.<br>운영에서는 임계값 기반 알람과 트렌드 예측을 결합해 사전 대응 체계를 만드는 것이 중요하다.</li></ol><h5 id=락-관측성-무엇왜어떻게>락 관측성: 무엇·왜·어떻게<a hidden class=anchor aria-hidden=true href=#락-관측성-무엇왜어떻게>#</a></h5><table><thead><tr><th>항목</th><th>무엇 (관측 대상)</th><th>왜 (목적)</th><th>어떻게 (수집·모니터링 방법)</th></tr></thead><tbody><tr><td>락 대기 시간</td><td>P50/P95/P99 락 대기 (ms)</td><td>사용자 체감 지연·병목 탐지</td><td>DB 뷰 (예: MySQL <code>INNODB_ROW_LOCK_TIME</code>), exporter → histogram → Grafana 패널</td></tr><tr><td>락 경합률</td><td>락 요청 대비 대기 비율</td><td>동시성 저하 전조</td><td>(wait_events / total_lock_requests) 집계, 시계열 경보</td></tr><tr><td>데드락 수/해결시간</td><td>데드락 발생 건수 및 탐지→해결 소요</td><td>무결성/가용성 영향 평가</td><td>DB deadlock log 수집, 트랜잭션 스택 저장</td></tr><tr><td>활성 락 분포</td><td>락 타입별/테이블별 활성 락 수</td><td>핫스팟·핵심 테이블 식별</td><td><code>pg_locks</code>/Performance Schema 쿼리 → 태그화하여 시계열 저장</td></tr><tr><td>락 에스컬레이션</td><td>에스컬레이션 이벤트 카운트</td><td>메타데이터 폭증·성능 저하 감시</td><td>DB 이벤트 로그 수집 · 알람</td></tr><tr><td>락 테이블 메모리</td><td>락 메타데이터 메모리 사용량</td><td>용량계획·GC 필요성 판단</td><td>OS/DB 메모리 메트릭과 연동</td></tr><tr><td>트랜잭션별 락 생애</td><td>트랜잭션이 획득·대기·해제한 락 타임라인</td><td>근본원인 분석 (RCA)</td><td>샘플링 기반 분산 트레이싱 연계 (예: Jaeger)</td></tr></tbody></table><h5 id=락-관측성-카테고리별-지표>락 관측성 카테고리별 지표<a hidden class=anchor aria-hidden=true href=#락-관측성-카테고리별-지표>#</a></h5><h6 id=실시간-운영-kpi-빠른-경보용>실시간 운영 KPI (빠른 경보용)<a hidden class=anchor aria-hidden=true href=#실시간-운영-kpi-빠른-경보용>#</a></h6><p>실시간으로 즉시 대응이 필요한 지표들을 모아 운영 알람과 연동한다.<br>무엇을: P95/P99 Lock Wait Time, Lock Contention Rate, Blocked Sessions<br>왜: 사용자 체감 성능 저하와 직결되므로 즉시 경고·조치 필요<br>어떻게: DB 뷰 → exporter → histogram/summary → Grafana 패널 + Alertmanager</p><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>즉시 대응</th></tr></thead><tbody><tr><td>P95/P99 Lock Wait</td><td style=text-align:right>DB view → exporter → histogram</td><td>경고 → 쿼리 캡처/우선 조사</td></tr><tr><td>Lock Contention Rate</td><td style=text-align:right>집계 (metric)</td><td>경합 구간 스케일/쿼리 튜닝</td></tr><tr><td>Blocked Sessions</td><td style=text-align:right><code>pg_locks</code>/INNODB_LOCK_WAITS</td><td>블로킹 쿼리 확인/kill 후보</td></tr></tbody></table><p>실사용자 영향이 큰 지표에 집중해 단기 SLA 위반을 막는 것이 목적이다. 임계값은 서비스 특성에 맞춰 실험적으로 설정하라.</p><h6 id=안정성무결성-지표-상태-추적용>안정성·무결성 지표 (상태 추적용)<a hidden class=anchor aria-hidden=true href=#안정성무결성-지표-상태-추적용>#</a></h6><p>시스템 신뢰성·무결성과 관련된 지표로 장기 분석과 개선 작업의 근거가 된다.<br>무엇을: Deadlock Count, Deadlock Resolution Time, Lock Escalation Events<br>왜: 데이터 무결성·서비스 연속성에 직접적 영향이 있어 근본 원인 (RCA) 이 필요<br>어떻게: DB deadlock 로그 보존, 상세 트레이스 샘플링, 일별/주별 집계 리포트</p><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>운영 대응</th></tr></thead><tbody><tr><td>Deadlock Count</td><td style=text-align:right>DB deadlock log</td><td>RCA → 쿼리/순서/인덱스 수정</td></tr><tr><td>Deadlock Resolution Time</td><td style=text-align:right>로그 타임스탬프</td><td>SLA 영향 평가</td></tr><tr><td>Lock Escalation</td><td style=text-align:right>DB 이벤트</td><td>에스컬레이션 정책 재검토</td></tr></tbody></table><p>빈번한 데드락/에스컬레이션은 설계·쿼리·스키마 수준의 수정 신호다. 자동 알람과 함께 근본원인 분석 프로세스를 마련하라.</p><h6 id=자원용량-지표-용량-계획용>자원·용량 지표 (용량 계획용)<a hidden class=anchor aria-hidden=true href=#자원용량-지표-용량-계획용>#</a></h6><p>락 관리가 시스템 자원을 얼마나 소모하는지 파악해 용량 계획에 반영한다.<br>무엇을: Lock Table Memory Usage, Lock Queue Length, Lock Throughput<br>왜: 메타데이터·메모리 포화로 서비스 영향을 받기 전에 확장·튜닝 필요<br>어떻게: OS/DB 메모리 + DB 이벤트 스냅샷 (5 분 간격) → 장기 추세 분석</p><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>권장 조치</th></tr></thead><tbody><tr><td>Lock Table Memory</td><td style=text-align:right>OS/DB metrics</td><td>메모리 증설 또는 샤딩</td></tr><tr><td>Queue Length</td><td style=text-align:right>DB view 집계</td><td>트랜잭션 분할/재조정</td></tr><tr><td>Lock Throughput</td><td style=text-align:right>metric rate</td><td>처리량 한계 파악</td></tr></tbody></table><p>락 관련 메타데이터는 장기적으로 용량 이슈를 야기한다. 정기적인 추세 모니터링으로 미리 증설·재설계 계획을 세우자.</p><h6 id=진단추적-지표-원인-분석용>진단·추적 지표 (원인 분석용)<a hidden class=anchor aria-hidden=true href=#진단추적-지표-원인-분석용>#</a></h6><p>문제 재현이 어렵거나 간헐적 이슈의 근본 원인을 찾기 위한 포렌식 데이터 수집에 집중한다.<br>무엇을: Transaction Lock Lifecycle, Slow-lock traces, Query/Plan 샘플<br>왜: 근본원인 분석 (RCA) 에 필수, 단순 메트릭으로는 원인 규명이 불가능한 경우가 많음<br>어떻게: 샘플링 기반 분산 트레이싱 연계 (Jaeger), on-demand 상세 캡처</p><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>활용</th></tr></thead><tbody><tr><td>Lock lifecycle trace</td><td style=text-align:right>샘플링 trace</td><td>RCA(근본원인분석)</td></tr><tr><td>Slow-lock traces</td><td style=text-align:right>on-demand 캡처</td><td>QOE 개선</td></tr></tbody></table><p>평상시에는 샘플링, 이상 징후 발생 시에만 상세 캡처를 켜서 비용을 제어하라. 트레이스는 쿼리·트랜잭션과 연계해 저장하라.</p><h6 id=예측보고-지표-전략용량-예측>예측·보고 지표 (전략/용량 예측)<a hidden class=anchor aria-hidden=true href=#예측보고-지표-전략용량-예측>#</a></h6><p>중장기 의사결정 (용량, 배포 일정, 아키텍처 개선) 에 쓰이는 지표들이다.<br>무엇을: Trend, Seasonality, Forecasted breach time<br>왜: 사전 용량 증설·배포 일정·비즈니스 이벤트 대비를 위해 필요<br>어떻게: 시계열 분석 모델 (rolling avg, EWMA), BI 리포트</p><table><thead><tr><th>지표</th><th style=text-align:right>수집 방법</th><th>활용</th></tr></thead><tbody><tr><td>Trend / Seasonality</td><td style=text-align:right>시계열 집계</td><td>용량 계획</td></tr><tr><td>Forecasted breach time</td><td style=text-align:right>모델 기반 예측</td><td>사전 스케일 아웃</td></tr></tbody></table><p>운영 알람은 단기 대응, 예측 지표는 장기 전략을 지원한다. 비즈니스 캘린더 (프로모션 등) 를 메타데이터로 연계하라.</p><h5 id=락-관측성-종합-지표표>락 관측성 종합 지표표<a hidden class=anchor aria-hidden=true href=#락-관측성-종합-지표표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 지표 예시</th><th style=text-align:right>수집 수단</th><th>즉시 활용/목적</th></tr></thead><tbody><tr><td>운영 KPI</td><td>P95/P99 Wait, Contention Rate</td><td style=text-align:right>DB view → exporter → Prometheus</td><td>단기 알람·SLA 보호</td></tr><tr><td>안정성</td><td>Deadlock count, Escalation</td><td style=text-align:right>DB deadlock log, 이벤트</td><td>RCA·설계 개선</td></tr><tr><td>자원/용량</td><td>Lock table memory, Queue length</td><td style=text-align:right>OS/DB metrics, snapshots</td><td>용량 계획·샤딩 판단</td></tr><tr><td>진단/추적</td><td>Lock lifecycle trace, Slow-lock</td><td style=text-align:right>샘플링 trace, on-demand capture</td><td>근본원인 분석</td></tr><tr><td>예측/보고</td><td>Trend, Forecasted breach</td><td style=text-align:right>시계열 분석, BI 리포트</td><td>장기 전략·용량 예측</td></tr></tbody></table><p>통합 관측성 체계는 단기 운영 (즉시 대응) 과 장기 전략 (용량·아키텍처 개선) 을 결합해야 효과적이다. 각 카테고리에 맞는 수집 빈도 (실시간 vs 스냅샷 vs 샘플링) 와 보존 정책을 설계하라.</p><h4 id=락-보안컴플라이언스-구현-가이드>락 보안·컴플라이언스 구현 가이드<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-구현-가이드>#</a></h4><p>락 보안·컴플라이언스는 <strong>누가 언제 어떤 자원에 락을 걸었는지</strong>를 증명 가능하게 만들고, 락 행위 자체로 인한 보안 리스크를 줄이는 작업이다.<br>이를 위해 락 요청 전에 강한 인증·권한검사를 수행하고 (예: RBAC, mTLS), 락 획득·해제·에스컬레이션을 전수 기록해 로그의 무결성 (서명·WORM) 과 접근 통제를 보장한다.<br>분산 환경에서는 펜싱 토큰과 lease 기반의 안전 장치를 도입하고, 모든 락 이벤트를 SIEM 으로 연동해 이상패턴을 실시간으로 탐지·자동 대응하는 운영 체계를 갖추면 규제·보안 요구를 충족할 수 있다.</p><h5 id=락-보안컴플라이언스-설계-요약>락 보안·컴플라이언스 설계 요약<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-설계-요약>#</a></h5><table><thead><tr><th>보안·컴플라이언스 항목</th><th>무엇을 (조치)</th><th>왜 (목적)</th><th>어떻게 (구현 방식)</th></tr></thead><tbody><tr><td>인증·권한관리</td><td>락 요청 전 신원·권한 검증</td><td>무권한/권한 남용 차단</td><td>RBAC/ABAC, 서비스 토큰·mTLS, 관리자 워크플로우</td></tr><tr><td>감사 로깅</td><td>락 생명주기 전수 기록</td><td>포렌식·규제 증빙</td><td>이벤트 (ACQUIRE/RELEASE/ESCALATE/DEADLOCK) 저장, query_hash 포함</td></tr><tr><td>로그 무결성</td><td>로그 변조 방지</td><td>증거성·신뢰성 확보</td><td>HMAC/디지털 서명, 해시체인, WORM 보관</td></tr><tr><td>민감데이터 처리</td><td>로그·메타데이터 PII 마스킹</td><td>개인정보 유출 방지 & 규정 준수</td><td>마스킹/토큰화, 접근권한 분리</td></tr><tr><td>분산 락 안전성</td><td>펜싱 토큰·lease, quorum 사용</td><td>리더 교체 시 중복 실행/장기 락 방지</td><td>etcd/ZK, lease+token 검증, 멱등 처리</td></tr><tr><td>운영 탐지·대응</td><td>실시간 알람·자동 플레이북</td><td>장애/보안사고 조기 대응</td><td>Prometheus→SIEM→알람→자동 롤백 스크립트</td></tr><tr><td>규제 매핑</td><td>표준별 보존·접근 정책 반영</td><td>법적·계약적 요구 충족</td><td>보존 파이프라인, 컴플라이언스 리포트 자동화</td></tr></tbody></table><h5 id=락-보안컴플라이언스-카테고리>락 보안·컴플라이언스 카테고리<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-카테고리>#</a></h5><h6 id=인증권한관리-authentication--authorization>인증·권한관리 (Authentication & Authorization)<a hidden class=anchor aria-hidden=true href=#인증권한관리-authentication--authorization>#</a></h6><p>설명: 락 요청 주체 (사용자/서비스) 의 신원과 권한을 검증해 무단 락을 방지.<br>무엇을: RBAC/ABAC, 서비스별 계정, short-lived tokens, mTLS, 관리자 워크플로우.<br>왜: 권한 남용·내부자 위협을 예방하고 감사 추적을 가능하게 하기 위해.<br>어떻게: 서비스용 인증서 (mTLS), OAuth/JWT 토큰 만료 정책, 관리자 작업은 이중 승인 로그.</p><table><thead><tr><th>항목</th><th style=text-align:right>악례 (간단)</th><th>권장 (간단)</th></tr></thead><tbody><tr><td>인증</td><td style=text-align:right>공용 DB 계정 사용</td><td>서비스별 계정 + mTLS</td></tr><tr><td>권한</td><td style=text-align:right>포괄적 관리자 권한</td><td>객체 단위 RBAC</td></tr><tr><td>관리자 작업</td><td style=text-align:right>즉시 실행</td><td>이중 승인·감사 로그</td></tr></tbody></table><ul><li>요약: 모든 락 요청은 인증·권한 검사를 통과해야 하며, 관리자 행위는 특별 취급해야 한다.</li></ul><h6 id=감사로그-무결성-audit--integrity>감사·로그 무결성 (Audit & Integrity)<a hidden class=anchor aria-hidden=true href=#감사로그-무결성-audit--integrity>#</a></h6><p>설명: 락 생명주기와 메타데이터를 변경 불가능하게 기록해 포렌식·규정 준수 근거를 확보.<br>무엇을: ACQUIRE/RELEASE/ESCALATE/DEADLOCK 이벤트, query_hash, client_ip 등.<br>왜: 사고 시 원인 분석·규제 보고를 위해 신뢰성 있는 증거가 필요.<br>어떻게: 이벤트 서명 (HMAC or digital signature), 해시체인 저장, WORM 스토리지, 접근 통제.</p><table><thead><tr><th>항목</th><th>악례</th><th>권장</th></tr></thead><tbody><tr><td>저장</td><td>일반 파일 (편집 가능)</td><td>WORM / 버전링 보관</td></tr><tr><td>무결성</td><td>무서명 로그</td><td>HMAC/디지털 서명 + 정기검증</td></tr><tr><td>접근</td><td>운영자 전권</td><td>읽기 전용 + 감사 추적</td></tr></tbody></table><ul><li>요약: 로그는 증거이므로 변조 불가능·접근 통제가 필요하다.</li></ul><h6 id=민감데이터-보호-data-protection--masking>민감데이터 보호 (Data Protection & Masking)<a hidden class=anchor aria-hidden=true href=#민감데이터-보호-data-protection--masking>#</a></h6><p>설명: 감사 로그·메타데이터에 PII/민감정보가 포함될 경우 유출 위험 및 규제 문제가 발생.<br>무엇을: 마스킹, 토큰화, 암호화 (at-rest & in-transit).<br>왜: 규제 (PCI/GDPR/HIPAA) 준수 및 내부 유출 방지.<br>어떻게: 로그 필드 레벨 마스킹, KMS 기반 암호화, 최소 로그 수준.</p><table><thead><tr><th>항목</th><th>악례</th><th>권장</th></tr></thead><tbody><tr><td>로그 민감성</td><td>PAN 원문 저장</td><td>PAN 마스킹/토큰화</td></tr><tr><td>전송</td><td>평문 전송</td><td>TLS/mTLS</td></tr><tr><td>저장</td><td>평문 at-rest</td><td>KMS 암호화</td></tr></tbody></table><ul><li>요약: 로그도 데이터다—민감정보는 마스킹·암호화해야 규제 요건을 충족한다.</li></ul><h6 id=분산-락-안전성-distributed-lock-hardening>분산 락 안전성 (Distributed Lock Hardening)<a hidden class=anchor aria-hidden=true href=#분산-락-안전성-distributed-lock-hardening>#</a></h6><p>설명: 노드 장애·파티션 상황에서 락이 안전하게 관리되도록 설계.<br>무엇을: lease+token(펜싱), quorum 기반 코디네이터 (etcd/ZK), 멱등 처리.<br>왜: 리더 교체·네트워크 분할 시 중복 수행이나 장기 락을 방지하기 위해.<br>어떻게: ttl 기반 lease 발급, 작업 시 token 체크, quorum 으로 리더 선출.</p><table><thead><tr><th>항목</th><th>악례</th><th>권장</th></tr></thead><tbody><tr><td>코디네이터</td><td>단일 Redis 인스턴스</td><td>etcd/ZK quorum</td></tr><tr><td>안전성</td><td>TTL 미검증</td><td>lease+token+ 검증</td></tr><tr><td>중복방지</td><td>비멱등 작업</td><td>멱등 설계 (아이디 empotency)</td></tr></tbody></table><ul><li>요약: 분산 락은 합의와 펜싱, 멱등성을 함께 설계해야 안전하다.</li></ul><h6 id=운영-탐지대응-monitoring-siem--playbooks>운영 탐지·대응 (Monitoring, SIEM & Playbooks)<a hidden class=anchor aria-hidden=true href=#운영-탐지대응-monitoring-siem--playbooks>#</a></h6><p>설명: 락 이상징후를 실시간 감시하고 자동화된 대응을 준비.<br>무엇을: lock_wait_time, long_lock_sessions, deadlock_count, escalation_events.<br>왜: 문제 조기탐지·신속 대응으로 가용성 유지.<br>어떻게: Prometheus→Grafana 알람, SIEM 연동, 자동 희생자 롤백 및 팀 알림 플레이북.</p><table><thead><tr><th>항목</th><th>악례</th><th>권장</th></tr></thead><tbody><tr><td>지표</td><td>수동 로그 확인</td><td>Prometheus 지표 수집</td></tr><tr><td>상관분석</td><td>로그 단편</td><td>SIEM 연계 상관분석</td></tr><tr><td>대응</td><td>수동 복구</td><td>자동 플레이북 + Runbook</td></tr></tbody></table><ul><li>요약: 관찰성·자동화는 장애 복구 시간 (RTO) 을 단축시킨다.</li></ul><h6 id=규제-매핑보존-regulatory-mapping--retention>규제 매핑·보존 (Regulatory Mapping & Retention)<a hidden class=anchor aria-hidden=true href=#규제-매핑보존-regulatory-mapping--retention>#</a></h6><p>설명: 규제별 보존·보안·접근 요구를 락 정책과 감사 파이프라인에 반영.<br>무엇을: 보존기간·접근제어·보고서 자동화 (예: SOX, GDPR, PCI).<br>왜: 법적·계약적 책임·감사 대비.<br>어떻게: 규제별 정책 문서화→자동 보존·삭제 파이프라인→정기 리포트 생성.</p><table><thead><tr><th>규제</th><th>핵심 요구</th><th>구현 포인트</th></tr></thead><tbody><tr><td>PCI</td><td>PAN 보호·접근로그</td><td>마스킹, 상세 접근로그</td></tr><tr><td>GDPR</td><td>삭제권·접근권</td><td>PII 최소화·삭제 로그</td></tr><tr><td>SOX</td><td>재무 증빙</td><td>장기 보관·무결성 보장</td></tr></tbody></table><ul><li>요약: 규제 요구는 명확히 문서화하고 자동화 파이프라인으로 이행·증빙하라.</li></ul><h5 id=락-보안컴플라이언스-통합표>락 보안·컴플라이언스 통합표<a hidden class=anchor aria-hidden=true href=#락-보안컴플라이언스-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 조치</th><th>목적</th><th>대표 기술/방식</th></tr></thead><tbody><tr><td>인증·권한관리</td><td>RBAC, mTLS, short-lived tokens</td><td>무권한 접근 차단</td><td>OAuth2/JWT, mTLS</td></tr><tr><td>감사·무결성</td><td>이벤트 서명, WORM 보관</td><td>증거성 확보</td><td>HMAC/디지털 서명, S3 Object Lock</td></tr><tr><td>민감데이터 보호</td><td>마스킹·토큰화, 암호화</td><td>PII 노출 방지</td><td>KMS, 필드 마스킹</td></tr><tr><td>분산 락 안전성</td><td>lease+token, quorum</td><td>중복 실행·장기 락 방지</td><td>etcd/ZK, Redlock(주의)</td></tr><tr><td>운영 탐지·대응</td><td>지표·SIEM·플레이북</td><td>조기 탐지·자동복구</td><td>Prometheus, SIEM, Runbook</td></tr><tr><td>규제 매핑</td><td>보존·보고 자동화</td><td>법적 요구 충족</td><td>보존 파이프라인, 리포트 엔진</td></tr></tbody></table><h4 id=락-입도-기반-성능확장성-전략>락 입도 기반 성능·확장성 전략<a hidden class=anchor aria-hidden=true href=#락-입도-기반-성능확장성-전략>#</a></h4><ul><li><strong>문제</strong>: 많은 트랜잭션이 동시에 같은 데이터에 접근하면 락 경합으로 지연·스루풋 저하가 생긴다.</li><li><strong>핵심 아이디어</strong>: 락을 &rsquo; 어떤 단위 &rsquo; 로 잡을지 (행/페이지/테이블) 와 락을 &rsquo; 어떻게 관리 &rsquo; 할지를 조합해서 성능과 일관성의 균형을 맞춘다.</li><li><strong>주요 수단</strong>:<ul><li><em>계층적 잠금 (MGL)</em>—상위에 의도락을 찍어 검사 비용을 줄임.</li><li><em>락 승격</em>—세부 락 과다 시 한 번에 상위 락으로 바꿔 관리비용을 낮춤.</li><li><em>적응형/자동 튜닝</em>—워크로드를 보고 최적 파라미터를 찾음 (ML 보조).</li><li><em>파티션/샤드 분할</em>—데이터 분산으로 경합을 줄여 확장성을 얻음.</li></ul></li><li><strong>운영 핵심</strong>: 모니터링 (대기시간·승격·데드락), 점진 적용 (Canary), 재현 가능한 테스트 케이스.</li></ul><h5 id=성능확장성-최적화-핵심표>성능·확장성 최적화 핵심표<a hidden class=anchor aria-hidden=true href=#성능확장성-최적화-핵심표>#</a></h5><table><thead><tr><th>측면</th><th style=text-align:right>무엇 (기법)</th><th>왜 (효과)</th><th>어떻게 (구현·운영 포인트)</th></tr></thead><tbody><tr><td>성능</td><td style=text-align:right>해시 락테이블 / 부분락</td><td>락 획득 지연 저감 → 응답성 향상</td><td>버킷화, 점진 리사이징, bucket hotness 모니터링</td></tr><tr><td>성능</td><td style=text-align:right>적응형 입도 선택 (ML)</td><td>워크로드별 최적 입도로 처리량 개선</td><td>피처선정, 보수적 초기 정책, A/B·Canary 적용</td></tr><tr><td>성능</td><td style=text-align:right>락 승격</td><td>락 테이블 메모리 절감, GC 부담 완화</td><td>임계값·비용 - 효익 분석, 승격 알람·롤백 경로</td></tr><tr><td>성능</td><td style=text-align:right>운영 기법 (타임아웃/백오프)</td><td>기아·장시간 대기 완화 → SLA 보호</td><td>exponential backoff, retry limit, SLA 기반 timeout</td></tr><tr><td>확장성</td><td style=text-align:right>파티셔닝 기반 로컬락</td><td>로컬성 증가 → 병렬 처리 향상</td><td>파티션 라우팅, 로컬 매니저, cross-partition 분석</td></tr><tr><td>확장성</td><td style=text-align:right>분산 락 (2PC/펜싱)</td><td>크로스샤드 일관성 보장</td><td>정렬된 획득, 펜싱 토큰, 실패시 Abort/복구 절차</td></tr><tr><td>확장성</td><td style=text-align:right>샤딩 글로벌 코디네이터</td><td>글로벌 트랜잭션 관리 및 deadlock 방지</td><td>샤드 정렬 획득, 역순 해제, 글로벌 txn id 관리</td></tr></tbody></table><h5 id=락-성능확장-카테고리-분류>락 성능·확장 카테고리 분류<a hidden class=anchor aria-hidden=true href=#락-성능확장-카테고리-분류>#</a></h5><h6 id=자료구조알고리즘-최적화>자료구조·알고리즘 최적화<a hidden class=anchor aria-hidden=true href=#자료구조알고리즘-최적화>#</a></h6><p>해시 락테이블, 부분락, 효율적 호환성 검사 등</p><ul><li>핵심 내용:<ul><li>해시 버킷으로 락 테이블을 관리해 평균 O(1) 획득을 목표로 한다.</li><li>부분락 (bucketed locks) 은 버킷 단위 경쟁을 완화해 스케일아웃 전까지 병목을 늦춘다.</li><li>락 리사이징은 점진적 (online) 으로 설계하여 리사이징 시 동기화 비용을 줄인다.</li></ul></li><li>운영 포인트:<ul><li>버킷 수/로드 팩터 튜닝, bucket hotness 모니터링, 리사이징 지연 측정.</li></ul></li></ul><table><thead><tr><th>기법</th><th>핵심 동작</th><th>운영 지표</th></tr></thead><tbody><tr><td>해시 락테이블</td><td>버킷화로 O(1) 평균 접근</td><td>lookup_latency, collision_rate</td></tr><tr><td>부분락</td><td>버킷 단위 경쟁 완화</td><td>bucket_hotness, contention_pct</td></tr></tbody></table><p>자료구조 최적화는 락 획득/해제 지연을 근본적으로 낮춰 응답성과 처리량을 개선한다. 리사이징·동기화 비용을 항상 고려해야 한다.</p><h6 id=운영정책-최적화>운영·정책 최적화<a hidden class=anchor aria-hidden=true href=#운영정책-최적화>#</a></h6><p>락 승격, 타임아웃/백오프, 적응형 튜닝 (ML), 모니터링/알람</p><ul><li>핵심 내용:<ul><li>락 승격은 메모리·GC 제약을 해결하나 동시성 저하 위험이 있으므로 임계값과 비용 - 효익 분석 기준 필요.</li><li>타임아웃·백오프·우선순위 스케줄링은 대기 시간을 관리하고 기아를 방지.</li><li>자동 튜닝은 데이터 기반으로 파라미터를 찾지만, 모델 실패 대비 safety fallback·카나리 적용 필수.</li><li>모니터링 지표 (예: lock_wait_p99, escalation_count, deadlock_rate) 를 SLO 로 설정.</li></ul></li><li>운영 포인트:<ul><li>Canary(10%→50%→100%) 적용, 성능리그레션 방지 테스트, 알람·대시보드 구성.</li></ul></li></ul><table><thead><tr><th>기법</th><th>핵심 동작</th><th>운영 지표</th></tr></thead><tbody><tr><td>락 승격</td><td>임계값 초과 시 상위락 전환</td><td>escalation_count, avg_row_locks</td></tr><tr><td>타임아웃/백오프</td><td>대기중 timeout → retry/backoff</td><td>timeout_rate, retry_success</td></tr><tr><td>적응형 튜닝</td><td>모델 기반 설정 제안 + Canary</td><td>model_accuracy, perf_delta_canary</td></tr></tbody></table><p>운영 정책은 시스템 안정성의 핵심이다. 자동화는 유리하나 반드시 점진·관측·롤백 루프와 함께 운영해야 한다.</p><h6 id=분할분산-확장-전략>분할·분산 확장 전략<a hidden class=anchor aria-hidden=true href=#분할분산-확장-전략>#</a></h6><p>파티셔닝 로컬락, 분산 잠금 (2PC/펜싱), 샤딩 글로벌 코디네이터</p><ul><li>핵심 내용:<ul><li>파티셔닝으로 로컬성 확보 → 로컬 잠금만으로 처리 가능한 케이스를 늘려 경합을 줄인다.</li><li>크로스 파티션 트랜잭션은 분산락 (2PC) 로 처리하되, 네트워크 실패·분할 고려해 펜싱/lease 설계.</li><li>샤드간 락은 글로벌 순서 (정렬된 획득) 로 데드락을 예방하고, 실패 시 역순 해제 규약을 둔다.</li></ul></li><li>운영 포인트:<ul><li>파티션 핫스팟 모니터링, 글로벌 coordinator 성능, 네트워크 지연에 따른 타임아웃 튜닝.</li></ul></li></ul><table><thead><tr><th>기법</th><th>핵심 동작</th><th>운영 지표</th></tr></thead><tbody><tr><td>파티셔닝 로컬락</td><td>리소스 파티션 별 로컬 락</td><td>partition_hotness, local_lock_latency</td></tr><tr><td>분산 락 (2PC/펜싱)</td><td>정렬된 prepare/commit, fencing token</td><td>prepare_latency, fencing_failures</td></tr><tr><td>샤딩 글로벌 코디네이터</td><td>샤드 정렬 획득 → 글로벌 txn id</td><td>cross_shard_latency, rollback_rate</td></tr></tbody></table><p>분할·분산 전략은 확장성의 실무적 해법이다. 그러나 네트워크·분산 실패 시나리오를 반드시 설계에 포함해야 한다.</p><h5 id=락-성능확장성-통합-요약표>락 성능·확장성 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-성능확장성-통합-요약표>#</a></h5><p>``</p><table><thead><tr><th>카테고리</th><th>핵심 기법</th><th>주요 목표</th><th>핵심 운영지표</th></tr></thead><tbody><tr><td>자료구조</td><td>해시 락테이블, 부분락</td><td>락 획득 지연 최소화</td><td>lookup_latency, collision_rate</td></tr><tr><td>운영·정책</td><td>승격, 타임아웃, 적응형 튜닝</td><td>안정성·SLA 보장</td><td>escalation_count, deadlock_rate</td></tr><tr><td>분할·분산</td><td>파티셔닝, 2PC, 펜싱</td><td>스케일아웃·일관성 보장</td><td>cross_shard_latency, fencing_failures</td></tr></tbody></table><h4 id=락-트러블슈팅-완전-분류표>락 트러블슈팅 완전 분류표<a hidden class=anchor aria-hidden=true href=#락-트러블슈팅-완전-분류표>#</a></h4><p>락 문제는 " 누가 언제 무엇을 잠그고 있는가 " 를 빨리 파악하는 것이 핵심이다.<br>먼저 모니터링 알람이 울리면 <code>pg_locks</code>/<code>INNODB_TRX</code> 등으로 누가 블로킹 중인지 확인하라.<br>임시로는 해당 트랜잭션을 강제 종료하거나 SKIP_LOCKED/NOWAIT 로 우회하고, 근본적으로는 락 순서 표준화·짧은 트랜잭션·인덱스 개선·파티셔닝으로 재발을 막아라.<br>자동화 (탐지→알람→주의적 자동 복구) 와 사후 포스트모템을 반드시 운영하라.</p><p><strong>왜 발생하는가 (근본 원인)</strong></p><ul><li><strong>순서 역전</strong>: 트랜잭션들이 서로 다른 순서로 리소스 잠금 → 순환 대기 (데드락).</li><li><strong>긴 트랜잭션</strong>: 락 장시간 보유로 대기 누적 → 경합 심화.</li><li><strong>풀스캔/범위 업데이트</strong>: 인덱스 결여로 많은 행을 잠궈 광범위 블로킹.</li><li><strong>에스컬레이션 임계초과</strong>: 다수의 하위 락으로 인해 상위 락으로 전환되어 동시성 급감.</li><li><strong>핫스팟 (핫키)</strong>: 특정 키/테이블로 집중된 업데이트.</li></ul><p><strong>무엇으로 해결하는가 (대응 수단)</strong></p><ul><li><strong>탐지·진단</strong>: wait-for 그래프, <code>pg_locks</code>/<code>pg_stat_activity</code>, <code>INNODB_TRX</code>/<code>performance_schema</code> 등 분석.</li><li><strong>즉시 완화</strong>: victim 롤백/kill, 타임아웃·NOWAIT, SKIP_LOCKED, 트래픽 셰이핑.</li><li><strong>근본 해결</strong>: 락 순서 표준화, 트랜잭션 분해 (짧게), 인덱스 추가·쿼리 최적화, 파티셔닝·샤딩, 낙관적 제어 도입.</li><li><strong>운영 정책</strong>: 자동 복구 (장기 tx 킬 기준), 에스컬레이션 임계치 설정, 재시도 백오프 전략.</li><li><strong>검증</strong>: 부하/회귀 테스트, 모니터링 지표 비교 (TPS/latency/lock wait).</li></ul><p><strong>어떻게 적용 (절차)</strong></p><ol><li>증상 포착 (알람)</li><li>상태 캡처 (pg_locks 등)</li><li>분류 (데드락/핫스팟/긴 tx)</li><li>즉시 완화 (권한자 결정)</li><li>근본 조치 (코드/설계)</li><li>검증 (부하 테스트)</li><li>문서화·자동화 규칙 반영.</li></ol><h5 id=락-문제-원인해결-요약표>락 문제 원인·해결 요약표<a hidden class=anchor aria-hidden=true href=#락-문제-원인해결-요약표>#</a></h5><table><thead><tr><th>증상</th><th>주요 원인</th><th>즉시 조치</th><th>근본 해결</th><th>검증 지표</th></tr></thead><tbody><tr><td>데드락 빈발</td><td>락 접근 순서 역전</td><td>자동 deadlock killer 또는 수동 롤백 (피해 적은 트랜잭션)</td><td>일관된 락 순서 적용, 트랜잭션 분해</td><td>deadlock count, MTTR</td></tr><tr><td>TPS 급락·대기↑</td><td>풀스캔·범위 업데이트</td><td>SKIP_LOCKED, NOWAIT, 트래픽 셰이핑</td><td>인덱스 추가, 쿼리 리팩토링, 파티셔닝</td><td>TPS, avg lock wait</td></tr><tr><td>장기 대기/긴 tx</td><td>배치·외부 호출로 트랜잭션 지연</td><td>강제 종료 (관리자) 또는 타임아웃</td><td>트랜잭션 짧게 유지, 비동기 처리</td><td>long-running tx 수</td></tr><tr><td>에스컬레이션 빈번</td><td>많은 row 락 → 임계치 초과</td><td>임계치 조정, 메모리 증설</td><td>트랜잭션 크기 축소, 임계치 재설계</td><td>escalation rate</td></tr><tr><td>핫스팟</td><td>특정 키 집중</td><td>캐시, 레디스 분산락, 읽기 복제본 활용</td><td>샤딩·핫키 분산, CQRS</td><td>hot-key access distribution</td></tr></tbody></table><h5 id=락-트러블슈팅-분류>락 트러블슈팅 분류<a hidden class=anchor aria-hidden=true href=#락-트러블슈팅-분류>#</a></h5><h6 id=탐지진단-detect>탐지·진단 (Detect)<a hidden class=anchor aria-hidden=true href=#탐지진단-detect>#</a></h6><ul><li><strong>목적</strong>: 문제 조기 포착 및 원인 후보 수집.</li><li><strong>핵심 작업</strong>: 샘플 캡처 (<code>pg_stat_activity</code>, <code>pg_locks</code>, <code>INNODB_TRX</code>, <code>performance_schema</code>), wait-for 그래프 생성, deadlock 로그 파싱.</li><li><strong>사용 도구/쿼리</strong>: <code>SELECT * FROM pg_locks WHERE NOT granted;</code>, <code>SHOW ENGINE INNODB STATUS;</code>, deadlock_parser.</li><li><strong>운영 팁</strong>: 자동 스냅샷 (30s) 저장, 알람 기준 (예: avg lock wait >200ms).</li></ul><table><thead><tr><th>항목</th><th>쿼리/도구</th><th>임계값 예시</th></tr></thead><tbody><tr><td>lock wait time</td><td>pg_locks + pg_stat_activity</td><td>>200ms 경고</td></tr><tr><td>deadlock rate</td><td>로그 파싱</td><td>>1/hr 경고</td></tr><tr><td>long-running tx</td><td>pg_stat_activity</td><td>>30s 경고</td></tr></tbody></table><ul><li>탐지는 처리 속도와 우선순위 결정을 좌우한다. 빠른 스냅샷과 적절한 임계값이 중요하다.</li></ul><h6 id=즉시-완화-mitigate>즉시 완화 (Mitigate)<a hidden class=anchor aria-hidden=true href=#즉시-완화-mitigate>#</a></h6><ul><li><strong>목적</strong>: 서비스 영향 최소화 (복구 우선).</li><li><strong>방법</strong>: victim 강제 롤백/pg_terminate_backend, 타임아웃 설정, SKIP_LOCKED/NOWAIT 사용, 트래픽 셰이핑.</li><li><strong>운영 팁</strong>: 자동 킬은 제한적으로 (테스트된 정책만), 강제 조치는 영향 범위 (트랜잭션 작업량) 고려.</li></ul><table><thead><tr><th>조치</th><th>상황</th><th>주의점</th></tr></thead><tbody><tr><td>pg_terminate_backend(pid)</td><td>데드락/장기 tx</td><td>데이터 무결성 영향 점검</td></tr><tr><td>SKIP_LOCKED</td><td>워커 큐 중복 방지</td><td>건너뛴 항목 처리 보장 필요</td></tr><tr><td>타임아웃 설정</td><td>대기 누적 방지</td><td>재시도 로직 필요</td></tr></tbody></table><ul><li>즉시 완화는 고객 영향 완화용이며, 이후 근본 원인 분석을 꼭 수행해야 한다.</li></ul><h6 id=근본-개선-root-fix>근본 개선 (Root Fix)<a hidden class=anchor aria-hidden=true href=#근본-개선-root-fix>#</a></h6><ul><li><strong>목적</strong>: 재발 방지 및 시스템 구조 개선.</li><li><strong>방법</strong>: 락 순서 표준화, 트랜잭션 분해, 인덱스 추가, 파티셔닝·샤딩, 낙관적 제어 도입, 작업 재설계 (CQRS/Saga).</li><li><strong>운영 팁</strong>: 변경 전 스테이징 부하 테스트 필요.</li></ul><table><thead><tr><th>문제</th><th>근본 조치</th><th>기대효과</th></tr></thead><tbody><tr><td>풀스캔</td><td>인덱스 추가/쿼리 리팩터링</td><td>lock 범위 축소</td></tr><tr><td>순서 역전</td><td>접근 순서 표준화</td><td>deadlock 감소</td></tr><tr><td>핫스팟</td><td>샤딩/캐시 적용</td><td>경쟁 완화</td></tr></tbody></table><ul><li>근본 개선은 비용·리스크가 있기에 단계적 배포와 검증이 필수다.</li></ul><h6 id=자동화정책-policy--auto>자동화·정책 (Policy & Auto)<a hidden class=anchor aria-hidden=true href=#자동화정책-policy--auto>#</a></h6><ul><li><strong>목적</strong>: 사람 의존도 감소, 평균 복구 시간 (MTTR) 단축.</li><li><strong>구성요소</strong>: 자동 탐지 스케줄, 복구 액션 (장기 tx 킬, 타임아웃 조정, 리플리카 스케일), 알림·티켓 자동화, 희생자 정책.</li><li><strong>안전망</strong>: 자동화는 퍼미션·화이트리스트·휴리스틱 (최소 작업량) 으로 제한.</li></ul><table><thead><tr><th>자동화 액션</th><th>조건</th><th>안전장치</th></tr></thead><tbody><tr><td>장기 tx 자동 킬</td><td>tx > 10min & blocking</td><td>whitelist/비용평가</td></tr><tr><td>escalation adjust</td><td>memory pressure</td><td>임계값 step change</td></tr><tr><td>auto-scale read replicas</td><td>read lag ↑</td><td>rate limit</td></tr></tbody></table><ul><li>자동화는 MTTR 을 줄이지만 오작동 위험을 낮추는 안전장치가 핵심이다.</li></ul><h6 id=검증사후조치-validate--postmortem>검증·사후조치 (Validate & Postmortem)<a hidden class=anchor aria-hidden=true href=#검증사후조치-validate--postmortem>#</a></h6><ul><li><strong>목적</strong>: 수정 효과 검증 및 지식 축적.</li><li><strong>작업</strong>: 부하 테스트, 회귀 테스트, 포스트모템 문서화 (원인·조치·책임·마감).</li><li><strong>지표</strong>: MTTR, deadlock rate, TPS, lock wait time 개선률.</li></ul><table><thead><tr><th>단계</th><th>활동</th><th>산출물</th></tr></thead><tbody><tr><td>검증</td><td>부하/회귀 테스트</td><td>테스트 리포트</td></tr><tr><td>사후분석</td><td>로그·trace 분석</td><td>포스트모템 문서</td></tr><tr><td>학습</td><td>팀 교육</td><td>룩백 미팅</td></tr></tbody></table><ul><li>검증은 변경의 신뢰성을 높이며, 사후분석은 같은 사고 재발을 막는 핵심이다.</li></ul><h5 id=락-문제-대응-통합표>락 문제 대응 통합표<a hidden class=anchor aria-hidden=true href=#락-문제-대응-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>목적</th><th>핵심 도구/쿼리</th><th>즉시 액션</th><th>근본 액션</th><th>지표</th></tr></thead><tbody><tr><td>탐지·진단</td><td>원인 식별</td><td>pg_locks, INNODB_TRX, deadlock log</td><td>스냅샷 저장</td><td>—</td><td>lock wait, deadlock count</td></tr><tr><td>즉시 완화</td><td>서비스 회복</td><td>pg_terminate_backend, SKIP_LOCKED</td><td>kill/timeout/SKIP</td><td>—</td><td>TPS 복구 시간</td></tr><tr><td>근본 개선</td><td>재발 방지</td><td>EXPLAIN, 인덱스 분석</td><td>—</td><td>쿼리/스키마/샤딩 수정</td><td>hot-key 감소</td></tr><tr><td>자동화·정책</td><td>MTTR 단축</td><td>모니터링 스크립트, 오케스트레이터</td><td>자동 복구 (제한적)</td><td>정책 업데이트</td><td>자동화 성공률</td></tr><tr><td>검증·사후조치</td><td>신뢰성 확보</td><td>부하 툴, 로그 분석</td><td>테스트 실행</td><td>포스트모템 반영</td><td>MTTR, 회귀율</td></tr></tbody></table><h3 id=phase-7-고급-주제-및-미래-전망>Phase 7: 고급 주제 및 미래 전망<a hidden class=anchor aria-hidden=true href=#phase-7-고급-주제-및-미래-전망>#</a></h3><h4 id=락-단위의-기술적-도전과-실무-대응>락 단위의 기술적 도전과 실무 대응<a hidden class=anchor aria-hidden=true href=#락-단위의-기술적-도전과-실무-대응>#</a></h4><p>락 단위 설계의 현재 도전은 크게 세 가지다.</p><ol><li><strong>규모 (확장성)</strong>: 중앙에서 모든 잠금을 관리하면 동시 사용자가 많아질수록 병목이 된다.</li><li><strong>자원 (메모리/관리 오버헤드)</strong>: 세밀한 락을 많이 쓰면 락 정보를 저장·관리하는 비용이 급증한다.</li><li><strong>분산·실시간의 한계</strong>: 네트워크 분할이나 노드 간 시계 차이 때문에 전역 락을 안전하게 보장하기 어렵고, 락 대기시간이 불확실해 실시간 응답을 보장할 수 없다.<br>이 문제들 각각은 서로 연결되어 있으며, 샤딩·합의 알고리즘·락 - 프리 자료구조 등으로 일부 완화는 가능하지만 새로운 복잡성과 운영 비용을 만든다.</li></ol><h5 id=락-단위의-현재-도전과-한계>락 단위의 현재 도전과 한계<a hidden class=anchor aria-hidden=true href=#락-단위의-현재-도전과-한계>#</a></h5><table><thead><tr><th>도전 과제</th><th>문제 (무엇)</th><th style=text-align:right>원인 (왜 발생)</th><th>영향 (무슨 문제)</th><th>핵심 난점 (왜 어려운가)</th></tr></thead><tbody><tr><td>확장성 한계</td><td>중앙 잠금 관리자 병목</td><td style=text-align:right>모든 요청이 중앙 상태를 통과</td><td>처리량/지연 한계, 스케일 제한</td><td>분산화 시 일관성/가용성 트레이드오프 (CAP)</td></tr><tr><td>메모리 증가</td><td>락 테이블·호환성 정보 폭증</td><td style=text-align:right>동시 트랜잭션·세분화된 락 수</td><td>메모리 부족·GC/캐시 악화</td><td>정확성 유지하면서 표현·압축하기 어려움</td></tr><tr><td>실시간 비호환성</td><td>대기시간 비결정성 (지연 변동)</td><td style=text-align:right>다른 트랜잭션 실행시간 영향</td><td>실시간 응답성 보장 불가</td><td>외부 영향 (네트워크·스케줄링) 으로 예측 불가</td></tr><tr><td>분산 이론 한계</td><td>글로벌 순서 부재·CAP 제약</td><td style=text-align:right>전역 시계 없음·파티션 가능성</td><td>전역 락 보장 어려움·복잡한 복구</td><td>분산에서 동시에 성능·일관성 보장 불가능</td></tr><tr><td>데드락·기아</td><td>순환 대기·특정 트랜잭션 기아</td><td style=text-align:right>MGL·2PL 의 상호작용</td><td>일부 트랜잭션 무한 대기·성능 편중</td><td>탐지·해결 정책이 성능과 공정성 간 트레이드오프</td></tr><tr><td>MVCC/Garbage</td><td>버전 누적·GC 부담</td><td style=text-align:right>읽기 비차단으로 버전 증가</td><td>저장소 증가·GC 로 인한 지연</td><td>GC 타이밍과 장기 트랜잭션 조정의 어려움</td></tr></tbody></table><h5 id=락-단위-도전의-분류>락 단위 도전의 분류<a hidden class=anchor aria-hidden=true href=#락-단위-도전의-분류>#</a></h5><h6 id=아키텍처확장성-문제>아키텍처·확장성 문제<a hidden class=anchor aria-hidden=true href=#아키텍처확장성-문제>#</a></h6><p>중앙 집중식 Lock Manager 는 설계상 단일 처리 경로가 되어 병목을 유발한다. 샤딩 (락 파티셔닝) 으로 분산하면 일부 해결되나, 샤딩 키 불균형·교차 샤드 트랜잭션이 새 문제를 낳는다. 분산 합의 (Raft/Paxos) 는 일관성은 제공하나 지연과 운영 복잡도를 증가시키며, 높은 처리량 요구에 항상 적합하지 않다. 락 - 프리 구조는 중앙 병목을 제거하지만 구현 난이도 (ABA, 메모리 reclamation) 와 디버깅 비용이 크다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>중앙 병목</td><td style=text-align:right>단일 상태 허브</td><td>처리량 한계·고지연</td><td>샤딩·분산 코디네이터</td></tr><tr><td>샤딩 불균형</td><td style=text-align:right>키 분포 편중</td><td>일부 파티션 과부하</td><td>해시 균형화·재배치 전략</td></tr><tr><td>합의 지연</td><td style=text-align:right>메시지 왕복</td><td>응답성 저하</td><td>라이트 경로 최적화, 지역 우선 정책</td></tr></tbody></table><ul><li>요약: 확장성 문제는 아키텍처 선택 (중앙화 vs 분산) 과 데이터 분포 설계에 크게 의존한다. 실험 기반 튜닝이 필수다.</li></ul><h6 id=자원연산-오버헤드-문제-메모리cpugc>자원·연산 오버헤드 문제 (메모리·CPU·GC)<a hidden class=anchor aria-hidden=true href=#자원연산-오버헤드-문제-메모리cpugc>#</a></h6><p>세밀한 락 (레코드/키 범위) 은 락 엔트리 수를 폭증시켜 락 테이블 메모리·캐시 부하를 키운다. 호환성 매트릭스·대기 큐 관리도 메모리를 소모한다. MVCC 는 읽기 성능을 높이지만 버전 누적으로 GC 부담이 증가한다. 해결법으로는 락 표현 압축 (예: 집합 표현, Bloom 필터 전선 판정), 확률적/approximate 관리, adaptive GC 정책 등이 연구·도입되고 있다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>락 엔트리 폭증</td><td style=text-align:right>동시 트랜잭션·세분화</td><td>메모리 부족·캐시 미스</td><td>샤딩·압축·eviction 정책</td></tr><tr><td>GC 부담 (MVCC)</td><td style=text-align:right>버전 누적·장기 txn</td><td>GC 지연·지연 스파이크</td><td>adaptive GC·장기 txn 제한</td></tr><tr><td>CPU 병목</td><td style=text-align:right>순차 경로·락 관리 오버헤드</td><td>멀티코어 비선형 확장</td><td>NUMA-aware 설계·lock-free 일부 도입</td></tr></tbody></table><ul><li>요약: 자원 문제는 단순히 더 많은 메모리로 해결되지 않는다. 표현 방식·GC 정책·데이터 배치가 핵심이다.</li></ul><h6 id=실시간성예측성-문제>실시간성·예측성 문제<a hidden class=anchor aria-hidden=true href=#실시간성예측성-문제>#</a></h6><p>락 대기는 다른 트랜잭션의 실행 시간에 따라 비결정적으로 변한다. 실시간 시스템 (예: 제어기, 실시간 금융 마이크로서비스) 은 이런 변동성을 허용하지 못한다. 대응으로 우선순위 락, 시간 제한 트랜잭션, 사전 예약 (예약 락) 같은 기법이 연구된다. 그러나 우선순위는 역전 문제를 만들 수 있고, 시간 제한은 일관성/성능 트레이드오프를 유발한다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>비결정적 대기</td><td style=text-align:right>경쟁 트랜잭션 실행시간 변동</td><td>실시간 SLA 미충족</td><td>우선순위/예약·시간 제한 트랜잭션</td></tr><tr><td>우선순위 역전</td><td style=text-align:right>낮은 우선순위 보유자가 리소스 점유</td><td>중요 트랜잭션 지연</td><td>우선순위 상속·보장 메커니즘</td></tr></tbody></table><ul><li>요약: 실시간 요구를 만족하려면 락 설계 자체를 재검토 (비차단 설계 또는 예약제) 해야 하며, 부작용을 함께 고려해야 한다.</li></ul><h6 id=분산이론적-한계-cap전역-순서>분산·이론적 한계 (CAP·전역 순서)<a hidden class=anchor aria-hidden=true href=#분산이론적-한계-cap전역-순서>#</a></h6><p>CAP 정리는 분산 시스템에서 파티션 상황에서는 일관성 (C) 과 가용성 (A) 을 동시에 만족할 수 없음을 말한다. 전역 시계 부재로 인해 전역 락의 존재와 정확한 순서 보장이 어려우며, 분산 데드락 탐지도 O(n²) 메시지 복잡도를 초래할 수 있다. 해결 접근으로는 지역 우선 설계, 최종 일관성 모델 사용, 외부 합의 (라프트) 로 지급 정합성 확보 등이 있으나 각 방법은 지연·운영 복잡성을 동반한다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>CAP 제약</td><td style=text-align:right>네트워크 파티션 가능성</td><td>일관성 vs 가용성 선택 필요</td><td>요구사항 기반 설계 (CP vs AP)</td></tr><tr><td>글로벌 순서 부재</td><td style=text-align:right>전역 시계 없음</td><td>전역 락·데드락 복잡</td><td>TrueTime(외부 시계)·logical clocks 활용</td></tr></tbody></table><ul><li>요약: 분산 환경에서는 목표 (일관성·가용성·지연) 중 우선순위를 명확히 하고 설계를 선택해야 한다.</li></ul><h6 id=데드락기아-및-mgl-복잡성>데드락·기아 및 MGL 복잡성<a hidden class=anchor aria-hidden=true href=#데드락기아-및-mgl-복잡성>#</a></h6><p>MGL(다중 세분성 락) 과 2PL 은 강력한 정합성을 제공하지만, 락 관계의 계층화로 인해 데드락/기아 시나리오가 더 다양해진다. 데드락 탐지는 비용과 빈도 간 절충이며, 피해자 선정 (victim selection) 은 성능·공정성 문제를 함께 고려해야 한다. 예방책 (타임아웃), 탐지 (주기 스캔), 회복 (rollback/abort) 중에 적절한 혼합 정책이 필요하다.</p><table><thead><tr><th>항목</th><th style=text-align:right>원인</th><th>영향</th><th>권장 대응</th></tr></thead><tbody><tr><td>데드락 빈발</td><td style=text-align:right>복잡한 락 의존성</td><td>트랜잭션 롤백·성능 저하</td><td>주기 탐지 + 타임아웃 혼합</td></tr><tr><td>기아 (Starvation)</td><td style=text-align:right>우선순위·에스컬레이션</td><td>특정 트랜잭션 장기 대기</td><td>공정성 정책·aging(우선순위 상승)</td></tr></tbody></table><ul><li>요약: 데드락/기아 관리는 단일 정책으로 해결되지 않으며, 시스템 특성별 혼합 전략과 모니터링이 필요하다.</li></ul><h5 id=락-단위-도전-통합-요약표>락 단위 도전: 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-단위-도전-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 도전</th><th style=text-align:right>주요 원인</th><th>즉각적 권장 대응</th></tr></thead><tbody><tr><td>아키텍처·확장성</td><td>중앙 병목, 샤딩 불균형</td><td style=text-align:right>중앙화 설계, 키 분포</td><td>샤딩·분산 코디네이터·lock-free 일부 도입</td></tr><tr><td>자원·오버헤드</td><td>락 엔트리 폭증·GC</td><td style=text-align:right>세분화·동시성</td><td>압축·샤딩·adaptive GC</td></tr><tr><td>실시간성</td><td>비결정적 대기</td><td style=text-align:right>경쟁 트랜잭션 변동</td><td>우선순위/예약/시간제한 설계</td></tr><tr><td>분산·이론</td><td>CAP·전역 순서 부재</td><td style=text-align:right>파티션·시계 문제</td><td>요구기반 (CP/AP) 선택·fencing·logical clocks</td></tr><tr><td>동시성 특수</td><td>데드락·기아</td><td style=text-align:right>MGL·2PL 복잡성</td><td>탐지 + 타임아웃 혼합·aging</td></tr></tbody></table><h4 id=락-그레뉼러리티-최신-트렌드-2025-검증>락 그레뉼러리티 최신 트렌드 (2025 검증)<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티-최신-트렌드-2025-검증>#</a></h4><p>2025 년 기준으로 <strong>락 그레뉼러리티</strong>의 최신 흐름은 &rsquo; 락 자체를 가볍게 하거나 (경량 락), 락을 쓰지 않는 방향 (락 - 프리), 그리고 운영을 지능화 (ML/자동화) 하거나 하드웨어로 일부 오프로드 &rsquo; 하는 세 갈래로 요약된다.<br>각 접근은 <strong>워크로드 특성 (읽기/쓰기 비율, 핫스팟 유무, 분산 여부)</strong> 에 따라 장단점이 확연히 달라지며, 실무에서는 혼합 (Hybrid) 전략과 단계적 PoC 로 도입하는 게 안전하다.</p><h5 id=락-그레뉼러리티-최신-트렌드-검증표>락 그레뉼러리티 최신 트렌드 검증표<a hidden class=anchor aria-hidden=true href=#락-그레뉼러리티-최신-트렌드-검증표>#</a></h5><table><thead><tr><th>트렌드</th><th>2025 상태 (요약)</th><th style=text-align:right>실무 적용성</th></tr></thead><tbody><tr><td>VLL (경량 락)</td><td>연구·벤치마크로 유의미한 성능 보고</td><td style=text-align:right>메모리 DB·임베디드에 유망</td></tr><tr><td>락 - 프리 / 비차단</td><td>이론·라이브러리 영역 활발, 범용화는 제한</td><td style=text-align:right>특정 데이터구조/핫경로에 적용 권장</td></tr><tr><td>ML 기반 스마트 락</td><td>PoC·연구 단계, 데이터·안전성 이슈 존재</td><td style=text-align:right>운영 보조 (충돌 예측) 로 우선 도입 권장</td></tr><tr><td>블록체인 락</td><td>연구·소규모 프로토타입 존재, 비용·지연 문제</td><td style=text-align:right>특수 보안·감사가 요구되는 영역에서 고려</td></tr><tr><td>HW 오프로딩</td><td>레플리케이션/네트워크 오프로딩 성과 보고</td><td style=text-align:right>저지연·대규모 환경에서 가치 (통합 비용 고려)</td></tr></tbody></table><h5 id=경량지능화하드웨어-기반-트렌드>경량·지능화·하드웨어 기반 트렌드<a hidden class=anchor aria-hidden=true href=#경량지능화하드웨어-기반-트렌드>#</a></h5><h6 id=경량비차단-기법>경량·비차단 기법<a hidden class=anchor aria-hidden=true href=#경량비차단-기법>#</a></h6><ul><li><p><strong>VLL(Very Lightweight Locking)</strong>: 각 튜플 수준의 메타데이터로 중앙 락매니저 오버헤드를 줄여 고성능 메모리 DB 에 적합. 워크로드가 높은 contention 일 때도 selective contention analysis 같은 보완이 필요.</p></li><li><p><strong>락 - 프리/Non-blocking</strong>: CAS 기반 자료구조, lock-free 큐/트리 등은 대기·교착 문제를 제거하지만 설계·검증 난이도가 높음. 트랜잭션 메모리는 특정 패턴에서 유망.</p></li></ul><table><thead><tr><th>기법</th><th>장점</th><th style=text-align:right>단점</th><th>적용 권장</th></tr></thead><tbody><tr><td>VLL</td><td>락 오버헤드 극감, high throughput</td><td style=text-align:right>구현 복잡·특정 시나리오 한정</td><td>메모리 DB, 임베디드</td></tr><tr><td>락 - 프리</td><td>비교착·낮은 레이턴시</td><td style=text-align:right>디버깅·증명 어려움</td><td>핫경로·저수준 라이브러리</td></tr></tbody></table><ul><li>요약: 경량·비차단 기법은 <strong>핫경로 최적화</strong>에 탁월하지만 보편적 대체는 아니며, 검증·테스트 비용을 반드시 고려해야 한다.</li></ul><h6 id=운영-지능화자동화>운영 지능화·자동화<a hidden class=anchor aria-hidden=true href=#운영-지능화자동화>#</a></h6><ul><li><p><strong>ML 기반 충돌 예측 / 입도 예측</strong>: 트랜잭션 로그·피처로 충돌 확률을 예측해 사전 대기·스케줄링·입도 변경을 제안. 실전 적용 시 라벨링·추론 레이턴시·오탐 비용을 평가해야 함.</p></li><li><p><strong>확률적/베이지안 에스컬레이션</strong>: 과거 성공률을 바탕으로 에스컬레이션 의사결정을 확률적으로 수행해 운영 안정성·성능 균형을 맞춤 (제공 예시는 초안 코드 수준).</p></li></ul><table><thead><tr><th>항목</th><th>기대효과</th><th style=text-align:right>리스크</th><th>권장 도입 단계</th></tr></thead><tbody><tr><td>ML 충돌 예측</td><td>대기시간·재시도 감소</td><td style=text-align:right>데이터·신뢰도 이슈</td><td>PoC → A/B 테스트</td></tr><tr><td>확률적 에스컬레이션</td><td>불필요한 에스컬레이션 감소</td><td style=text-align:right>오결정 시 성능 저하</td><td>시뮬레이션 기반 튜닝</td></tr></tbody></table><ul><li>요약: 자동화는 운영 효율을 올리지만 <strong>안전장치 (롤백·휴리스틱)</strong> 를 반드시 설계해야 한다.</li></ul><h6 id=분산하드웨어-보조-기법>분산·하드웨어 보조 기법<a hidden class=anchor aria-hidden=true href=#분산하드웨어-보조-기법>#</a></h6><ul><li><p><strong>블록체인 기반 락</strong>: 스마트컨트랙트로 락을 관리하는 아이디어는 투명성·불변성을 제공하나, 합의 지연·가스 (비용)·복구 모델 문제로 범용 락 서비스 대체는 아직 제한적.</p></li><li><p><strong>SmartNIC/FPGA 오프로딩</strong>: 레플리케이션·네트워크 연산 오프로딩 PoC 는 호스트 CPU 부담을 줄여 전체 지연을 낮춤. 락 관련 연산 (예: 토큰 검증, 경합 조정) 도 오프로딩 후보. 통합·운영 비용과 프로그래머빌리티 비용이 관건.</p></li></ul><table><thead><tr><th>접근</th><th>장점</th><th style=text-align:right>제약</th><th>적용 권장</th></tr></thead><tbody><tr><td>블록체인 락</td><td>투명성·변조 방지</td><td style=text-align:right>지연·비용·회복성</td><td>규제·감사 요구 특수 영역</td></tr><tr><td>HW 오프로딩</td><td>CPU 절감·저지연</td><td style=text-align:right>통합·비용·개발 난도</td><td>대규모·저지연 시스템</td></tr></tbody></table><ul><li>요약: 분산·HW 접근은 특정 도메인 (금융·네트워크·대규모 레플리케이션) 에 가치가 크며, 일반 서비스는 비용·운영 부담을 따져야 한다.</li></ul><h5 id=경량지능화하드웨어-트렌드-종합표>경량·지능화·하드웨어 트렌드 종합표<a hidden class=anchor aria-hidden=true href=#경량지능화하드웨어-트렌드-종합표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 패턴</th><th style=text-align:right>실무 가치</th><th>위험/주의</th></tr></thead><tbody><tr><td>경량·비차단</td><td>VLL, Lock-free, TM</td><td style=text-align:right>핫경로 성능 개선</td><td>검증·디버깅 비용</td></tr><tr><td>운영 지능화</td><td>ML 예측, 확률적 에스컬레이션</td><td style=text-align:right>운영 효율·자동화</td><td>데이터·안전성 리스크</td></tr><tr><td>분산·HW</td><td>블록체인 락, SmartNIC 오프로딩</td><td style=text-align:right>투명성·저지연 가속</td><td>비용·통합 복잡성</td></tr></tbody></table><h4 id=동시성-대안-기술-종합분석>동시성 대안 기술 종합분석<a hidden class=anchor aria-hidden=true href=#동시성-대안-기술-종합분석>#</a></h4><p>동시성 문제를 푸는 방법은 크게 세 갈래다:</p><ol><li><strong>락을 더 잘 쓰는 방법</strong>(그레인 조절, 의도락 등)—쉽지만 경합·데드락 문제 존재.</li><li><strong>락을 아예 피하는 방법</strong>(락 - 프리/웨이트프리, RCU)—매우 빠르지만 구현·증명·메모리 관리가 어렵다.</li><li><strong>설계 레벨 회피</strong>(MVCC/OCC, 이벤트 소싱, CRDT)—충돌을 다른 방식 (버전·이벤트·수학적 병합) 으로 해결.</li></ol><p>선택 기준은 항상: <strong>일관성 요구 수준, 동시성 목표 (처리량/레이턴시), 팀의 구현·운영 역량</strong>이다. 작은 팀이나 엄격한 일관성이 필요하면 단순하고 검증된 방식 (강한 트랜잭션 + 합의) 을 택하고, 고처리량·분산성이 필요하면 CRDT·락 - 프리·이벤트 소싱 같은 기법을 단계적으로 도입하라.</p><h5 id=대안-동시성-기술-비교>대안 동시성 기술 비교<a hidden class=anchor aria-hidden=true href=#대안-동시성-기술-비교>#</a></h5><table><thead><tr><th>기술</th><th style=text-align:right>핵심 아이디어</th><th>장점</th><th>단점</th><th style=text-align:right>구현 난도</th><th>적합 작업영역</th></tr></thead><tbody><tr><td>락 - 프리 (CAS 기반)</td><td style=text-align:right>원자 연산으로 동시성 보장</td><td>높은 동시성, 낮은 대기</td><td>ABA·메모리 재사용 문제, 디버깅 어려움</td><td style=text-align:right>매우 높음</td><td>고성능 인메모리 큐/스택</td></tr><tr><td>웨이트프리</td><td style=text-align:right>모든 스레드에 응답 보장</td><td>예측 가능한 지연 상한</td><td>구현 극히 복잡</td><td style=text-align:right>극히 높음</td><td>실시간/하드 리얼타임</td></tr><tr><td>MVCC (DB)</td><td style=text-align:right>버전 스냅샷으로 읽기 비차단</td><td>읽기 동시성 우수</td><td>스토리지·GC 오버헤드</td><td style=text-align:right>중간</td><td>읽기 중심 DB/분석</td></tr><tr><td>OCC / Timestamp</td><td style=text-align:right>커밋 시 충돌 검사</td><td>간단·락 오버헤드 없음</td><td>충돌·재시도 비용</td><td style=text-align:right>중간</td><td>저경합 서비스</td></tr><tr><td>Event Sourcing</td><td style=text-align:right>이벤트 시퀀스로 상태 관리</td><td>감사·복원성 우수</td><td>쿼리 복잡·스토리지 증가</td><td style=text-align:right>높음</td><td>도메인 이벤트 중심 시스템</td></tr><tr><td>CRDT</td><td style=text-align:right>수학적 병합 규칙으로 충돌 해결</td><td>분산에서 충돌 無</td><td>결국일관성 (지연 허용), 복잡성</td><td style=text-align:right>높음</td><td>오프라인/글로벌 카운터, 협업 앱</td></tr><tr><td>HTM / STM</td><td style=text-align:right>CPU/소프트웨어 트랜잭션</td><td>잠금 코드 제거 (HTM 가능)</td><td>HTM 용량/폴백, STM 오버헤드</td><td style=text-align:right>중간~높음</td><td>짧은 메모리 트랜잭션</td></tr></tbody></table><h5 id=동시성-대안-기술-분류체계>동시성 대안 기술 분류체계<a hidden class=anchor aria-hidden=true href=#동시성-대안-기술-분류체계>#</a></h5><h6 id=메모리자료구조-레벨-락---프리--웨이트프리--rcu--htm>메모리·자료구조 레벨 (락 - 프리 / 웨이트프리 / RCU / HTM)<a hidden class=anchor aria-hidden=true href=#메모리자료구조-레벨-락---프리--웨이트프리--rcu--htm>#</a></h6><p>락 - 프리와 웨이트프리는 뮤텍스 없이 원자 연산 (CAS 등) 으로 동시성을 구현한다. RCU 는 읽기 경로를 매우 빠르게 하고 업데이트는 복사 - 갱신 방식으로 처리한다. HTM 은 CPU 가 트랜잭션을 원자적으로 처리하지만 용량 (캐시) 제한과 폴백 경로가 필요하다.</p><ul><li>적용 포인트: 짧고 빈번한 인메모리 연산 (큐, 스택, 해시맵) 에 최적.</li><li>운영 포인트: ABA 문제·메모리 재활용 (Hazard pointers, epoch reclamation), GC 영향, 디버깅·검증 비용.</li></ul><table><thead><tr><th>기술</th><th style=text-align:right>핵심</th><th>장점</th><th>단점</th><th>적합 영역</th></tr></thead><tbody><tr><td>락 - 프리</td><td style=text-align:right>CAS 기반 원자연산</td><td>높은 동시성</td><td>ABA·메모리관리 난제</td><td>인메모리 자료구조</td></tr><tr><td>웨이트프리</td><td style=text-align:right>모든 스레드 응답 보장</td><td>예측 가능 지연</td><td>구현 복잡</td><td>하드리얼타임</td></tr><tr><td>RCU</td><td style=text-align:right>읽기 경로 잠금 없음</td><td>매우 빠른 읽기</td><td>업데이트 지연·메모리 증가</td><td>커널·읽기중심 구조</td></tr><tr><td>HTM/STM</td><td style=text-align:right>CPU/소프트웨어 트랜잭션</td><td>잠금 코드 제거 가능</td><td>용량 abort·오버헤드</td><td>짧은 메모리 트랜잭션</td></tr></tbody></table><p>메모리 수준 기법은 <strong>초고성능</strong>을 가능하게 하나, 구현·운영 비용이 크다. 프로파일링과 형식검증 없이는 위험하므로 제한 영역에서 점진 도입하라.</p><h6 id=데이터베이스트랜잭션-레벨-mvcc--occ--timestamp>데이터베이스·트랜잭션 레벨 (MVCC / OCC / Timestamp)<a hidden class=anchor aria-hidden=true href=#데이터베이스트랜잭션-레벨-mvcc--occ--timestamp>#</a></h6><p>MVCC 는 읽기 트랜잭션에 스냅샷을 제공해 읽기 - 쓰기 충돌을 줄인다. OCC 는 커밋 시 충돌을 검증해 롤백/재시도를 사용한다. Timestamp Ordering 은 트랜잭션에 타임스탬프를 부여해 순서를 강제한다.</p><ul><li>적용 포인트: 데이터 정합성 요구와 읽기/쓰기 비율에 따라 선택.</li><li>운영 포인트: MVCC 는 GC(VACUUM) 관리 필요, OCC 는 충돌률 모니터링·재시도 정책 필요.</li></ul><table><thead><tr><th>기술</th><th style=text-align:right>핵심</th><th>장점</th><th>단점</th><th>적합 영역</th></tr></thead><tbody><tr><td>MVCC</td><td style=text-align:right>버전 스냅샷</td><td>읽기 비차단</td><td>버전·GC 오버헤드</td><td>읽기중심 DB</td></tr><tr><td>OCC</td><td style=text-align:right>커밋시 충돌검증</td><td>락 오버헤드 없음</td><td>충돌시 비용</td><td>저경합 서비스</td></tr><tr><td>Timestamp</td><td style=text-align:right>시간순 보장</td><td>직렬성 보장 가능</td><td>타임스탬프 관리</td><td>특정 분산 DB 설계</td></tr></tbody></table><p>DB 레벨 기법은 <strong>일관성 요구</strong>와 <strong>워크로드 특성</strong>에 맞춰 선택하라. 운영 (예: VACUUM, 재시도 정책) 이 핵심 관리 포인트다.</p><h6 id=분산스케일-아키텍처-레벨-crdt--합의-기반-락>분산·스케일 아키텍처 레벨 (CRDT / 합의 기반 락)<a hidden class=anchor aria-hidden=true href=#분산스케일-아키텍처-레벨-crdt--합의-기반-락>#</a></h6><p>CRDT 는 로컬 업데이트를 병합해 최종적으로 동일한 상태로 수렴하게 설계된다. 합의 기반 락 (Etcd/ZK) 은 강한 일관성이 필요할 때 사용한다.</p><ul><li>적용 포인트: 글로벌 분산, 오프라인 동기화, 협업 툴, 소수의 강한 - 정합성 리더가 필요한 서비스.</li><li>운영 포인트: CRDT 는 데이터 모델링이 핵심 (연산의 합성 규칙), 합의 기반 시스템은 운영 복잡·레이턴시 고려.</li></ul><table><thead><tr><th>기술</th><th style=text-align:right>핵심</th><th>장점</th><th>단점</th><th>적합 영역</th></tr></thead><tbody><tr><td>CRDT</td><td style=text-align:right>수학적 병합 규칙</td><td>분산 충돌 無</td><td>결국일관성 (지연)</td><td>글로벌 카운터, 협업</td></tr><tr><td>합의 (Etcd/ZK)</td><td style=text-align:right>Paxos/Raft 기반</td><td>강한 일관성</td><td>운영·레이턴시 비용</td><td>리더선출, 메타데이터 서비스</td></tr></tbody></table><p>분산 레벨 기법은 <strong>정합성 요구 수준</strong>과 <strong>지연 허용치</strong>를 기준으로 선택하라. CRDT 는 가용성·오프라인 우수, 합의 기반은 강한 일관성 보장.</p><h6 id=아키텍처패턴-레벨-event-sourcing--cqrs--outbox>아키텍처/패턴 레벨 (Event Sourcing / CQRS / Outbox)<a hidden class=anchor aria-hidden=true href=#아키텍처패턴-레벨-event-sourcing--cqrs--outbox>#</a></h6><p>이벤트 소싱은 상태를 이벤트로 저장하고 필요 시 재구성한다. CQRS 는 읽기와 쓰기를 분리해 각각에 최적화한다. Transactional Outbox 는 트랜잭션 내 이벤트 저장 후 별도 워커로 안전하게 발행한다.</p><ul><li>적용 포인트: 감사·이력 보존, 복잡한 도메인, 비동기 통합 시 유리.</li><li>운영 포인트: 이벤트 스토어 설계, 스냅샷 전략, 이벤트 스키마 진화 관리를 반드시 계획.</li></ul><table><thead><tr><th>기술</th><th style=text-align:right>핵심</th><th>장점</th><th>단점</th><th>적합 영역</th></tr></thead><tbody><tr><td>Event Sourcing</td><td style=text-align:right>이벤트 시퀀스 보관</td><td>감사·복원성</td><td>쿼리·스토리지 비용</td><td>도메인 이벤트 중심 시스템</td></tr><tr><td>CQRS</td><td style=text-align:right>읽기/쓰기 분리</td><td>각 사이드 최적화</td><td>복잡성 증가</td><td>복잡 조회/쓰기 분리 필요</td></tr><tr><td>Outbox</td><td style=text-align:right>트랜잭션 + 이벤트 영속화</td><td>안전한 이벤트 발행</td><td>워커·지연 필요</td><td>분산 캐시 무효화 등</td></tr></tbody></table><p>패턴 레벨 선택은 <strong>운영·개발 복잡도 증가</strong>를 수반한다. 장점 (감사·확장성) 을 얻으려면 스냅샷·이벤트 버전 관리·모니터링을 설계에 포함해야 한다.</p><h5 id=대안-동시성-기술-통합표>대안 동시성 기술 통합표<a hidden class=anchor aria-hidden=true href=#대안-동시성-기술-통합표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 기술</th><th>핵심 강점</th><th>주요 리스크</th><th>적용 권장 상황</th></tr></thead><tbody><tr><td>메모리·자료구조</td><td>락 - 프리, 웨이트프리, RCU, HTM</td><td>초저지연·고처리량</td><td>구현·검증·메모리재활용</td><td>인메모리 핵심 자료구조</td></tr><tr><td>DB·트랜잭션</td><td>MVCC, OCC, Timestamp</td><td>읽기성능·간단성</td><td>GC·충돌·재시도 비용</td><td>OLTP/읽기중심 시스템</td></tr><tr><td>분산·스케일</td><td>CRDT, Etcd/ZK(합의)</td><td>가용성/분산 합의</td><td>결국일관성·레이턴시·운영복잡</td><td>글로벌 분산/메타데이터</td></tr><tr><td>아키텍처 패턴</td><td>Event Sourcing, CQRS, Outbox</td><td>감사·비동기 통합</td><td>쿼리복잡·스토리지증가</td><td>복잡 도메인·통합필요</td></tr></tbody></table><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>잠금 세분성은 데이터베이스 동시성 제어의 핵심 설계축으로, " 얼마나 세밀하게 잠글 것인가 " 의 선택이 시스템 성능과 관리 오버헤드 사이의 균형을 결정한다.<br>이를 위해 대부분의 DB 는 계층적 그레인 (데이터베이스→테이블→페이지→행) 을 제공하고, 하위 레벨의 잠금 의도를 상위 레벨에 표시하는 의도락 (IS/IX/SIX) 으로 락 검사 비용을 낮춘다.<br>저수준 잠금이 폭증하면 에스컬레이션으로 메타데이터 부담을 제어하지만 일시적으로 동시성이 떨어진다.<br>범위 질의나 삽입으로 발생하는 팬텀 문제는 키 - 범위 (프레디킷) 잠금으로 제어한다.<br>MVCC 환경에서는 읽기는 비차단으로 처리되지만 쓰기 경로와 인덱스 변경은 여전히 세분성 결정의 영향을 받는다.<br>따라서 실무에서는 파티셔닝·인덱스 설계·모니터링 (락 대기 P95/P99, 에스컬레이션 빈도, 데드락)·워크로드 기반 벤치마킹을 결합한 반복적 튜닝 루프가 필요하다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>항목 (체크)</th><th>설명</th><th style=text-align:right>권장 우선순위</th><th>실행 방법/예시</th><th>모니터링 지표</th><th>관련 도구/메모</th></tr></thead><tbody><tr><td>현재 시스템 분석 ✓</td><td>워크로드 (읽기/쓰기), TX 길이, 핫스팟 파악</td><td style=text-align:right>High</td><td>샘플 트래픽 수집·분석 (24~72h)</td><td>read/write ratio, TX duration histogram, hot-key %</td><td>pg_stat_statements, APM</td></tr><tr><td>잠금 전략 수립 ✓</td><td>OLTP: 행/범위, OLAP: MVCC/리플리카 등</td><td style=text-align:right>High</td><td>설계 문서·정책 (에스컬레이션/타임아웃 포함)</td><td>-</td><td>설계 회의, ADR</td></tr><tr><td>단계적 적용 (카나리) ✓</td><td>소규모→증가 적용, 리스크 감시</td><td style=text-align:right>High</td><td>카나리 비율 5→25→100%</td><td>error rate, latency change</td><td>CI/CD, Feature flag</td></tr><tr><td>모니터링 체계 구축 ✓</td><td>실시간 대시보드·알람</td><td style=text-align:right>High</td><td>Prometheus→Grafana, 알람 룰</td><td>lock_wait_time, long_lock_sessions, deadlock_count</td><td>Prometheus, Grafana, Alertmanager</td></tr><tr><td>성능 기준선 설정 ✓</td><td>목표 TPS/응답시간/데드락률 정의</td><td style=text-align:right>High</td><td>SLA 문서화, SLO 설정</td><td>p95 latency, TPS, deadlock_rate</td><td>SLO 플랫폼</td></tr><tr><td>트랜잭션 타임아웃 설정 ✓</td><td>장수 TX 로 인한 bloat/락 방지</td><td style=text-align:right>High</td><td>예: TX timeout 30s(업무에 따라 조정)</td><td>long_tx_count</td><td>DB 설정, app timeout</td></tr><tr><td>긴 트랜잭션 분할 ✓</td><td>큰 배치/트랜잭션 분할 권고</td><td style=text-align:right>Medium</td><td>배치 쪼개기, chunk size 조정</td><td>avg tx work size</td><td>ETL 설계</td></tr><tr><td>인덱스·쿼리 최적화 ✓</td><td>범위 쿼리 커버 인덱스 필수</td><td style=text-align:right>High</td><td>커버링 인덱스, avoid full table scan</td><td>table scan rate, index hit ratio</td><td>EXPLAIN, slow query log</td></tr><tr><td>에스컬레이션 정책 명시 ✓</td><td>임계값·승격 정책 문서화</td><td style=text-align:right>Medium</td><td>행→페이지→테이블 임계치 정의</td><td>escalation_events</td><td>DB config</td></tr><tr><td>배치/DDL 윈도우 운영 ✓</td><td>배치·스키마 변경 시 락 영향 최소화</td><td style=text-align:right>Medium</td><td>야간/창구 시간 운영, maintenance window</td><td>job success, window conflicts</td><td>Scheduler</td></tr><tr><td>자동 희생자/복구 플레이북 ✓</td><td>임계치 초과 시 자동화 조치</td><td style=text-align:right>High</td><td>오래된 TX 강제 종료 스크립트</td><td>auto_kill_count</td><td>Runbook, automation scripts</td></tr><tr><td>모의 재해·리허설 ✓</td><td>장애 대응 절차 검증</td><td style=text-align:right>Medium</td><td>분기별 테이블탑·DR 연습</td><td>RTO, RPO</td><td>Chaos testing</td></tr><tr><td>장비·용량 계획 ✓</td><td>메타데이터 메모리·IO 여유 확보</td><td style=text-align:right>Medium</td><td>메모리 버퍼 여유 (예: 20%)</td><td>memory for lock table, IO wait</td><td>Capacity planning</td></tr><tr><td>보안·감사 연계 ✓</td><td>락 이벤트 감사·무결성 보관</td><td style=text-align:right>High</td><td>이벤트 서명·WORM, SIEM 연계</td><td>audit_events, integrity checks</td><td>SIEM, KMS, S3 Object Lock</td></tr><tr><td>확장성 검토 (샤딩·분산) ✓</td><td>샤딩/분산 락 전략 수립</td><td style=text-align:right>Medium</td><td>shard key 설계, distributed lock infra</td><td>cross-shard tx failures</td><td>etcd/zk, sharding plan</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th style=text-align:center>권장 기간</th><th>핵심 주제 (요약)</th><th>학습 목표</th><th>권장 활동 (실습·평가)</th></tr></thead><tbody><tr><td style=text-align:right>Phase 1—기초</td><td style=text-align:center>1–2 주</td><td>트랜잭션·ACID·격리수준, 공유/배타 락</td><td>트랜잭션 의미 이해, 기본 락 동작 재현</td><td>SQL 실습: <code>SELECT … FOR UPDATE</code>, 단순 데드락 재현 스크립트</td></tr><tr><td style=text-align:right>Phase 2—구조·원리</td><td style=text-align:center>2–3 주</td><td>MGL(의도락 IS/IX/SIX), 잠금 입도, 호환성 매트릭스</td><td>계층적 락 획득/해제, 의도락 역할 이해</td><td>시뮬레이터 실행 (MGL 다이어그램 따라 재현), 실습 과제: 상위/하위 락 흐름 증명</td></tr><tr><td style=text-align:right>Phase 3—충돌·격리·트레이드오프</td><td style=text-align:center>2 주</td><td>데드락, 락 컨버전, 키 - 범위/팬텀, 격리수준 트레이드오프</td><td>교착 원인 분석·회피, 격리 선택 근거 숙지</td><td>데드락 탐지 도구 사용, 트레이드오프 사례 토의</td></tr><tr><td style=text-align:right>Phase 4—구현·운영 기초</td><td style=text-align:center>2–3 주</td><td>락 승격, 락 테이블 구조, 모니터링 기초</td><td>임계값·승격 동작 이해, 기본 운영 지표 수집</td><td>승격 실험 (스테이징), Prometheus 지표 대시보드 구성</td></tr><tr><td style=text-align:right>Phase 5—성능 튜닝·트러블슈팅</td><td style=text-align:center>3–4 주</td><td>성능 지표, 타임아웃/백오프, 인덱스·쿼리 튜닝</td><td>병목 식별·완화, 운영 대응 프로세스 습득</td><td>부하 테스트 (벤치마크), 튜닝 전/후 비교 리포트</td></tr><tr><td style=text-align:right>Phase 6—분산·샤딩 응용</td><td style=text-align:center>3–6 주</td><td>파티셔닝, 샤딩, 분산락 (2PC, 펜싱)</td><td>크로스샤드 트랜잭션 설계·오류 처리</td><td>etcd/Redis 분산락 실습, 크로스샤드 트랜잭션 시뮬레이션</td></tr><tr><td style=text-align:right>Phase 7—고급·자동화</td><td style=text-align:center>4–8 주</td><td>MVCC·락프리·자동튜닝 (ML)·Hybrid CC</td><td>대규모·분산 환경 설계, 자동화 안전성 검증</td><td>ML PoC(적응형 임계값), 연구논문 리뷰, 프로토타입 평가</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>Phase</th><th>세부 항목</th><th style=text-align:right>중요도</th><th>학습 목표 (구체)</th><th>실무 연관성</th><th>설명 (세부 구성)</th><th>권장 실습/평가</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td>트랜잭션·ACID</td><td style=text-align:right>필수</td><td>원자성·일관성·격리성 이해</td><td>매우 높음</td><td>ACID 정의, 커밋/롤백 흐름, 간단 SQL 예제</td><td>단일 DB 에서 COMMIT/ROLLBACK 실습</td></tr><tr><td style=text-align:right>1</td><td>공유 (S)/배타 (X) 락</td><td style=text-align:right>필수</td><td>락 모드·호환성 인식</td><td>매우 높음</td><td>S vs X, 블로킹 예제</td><td><code>SELECT FOR UPDATE</code> vs <code>SELECT</code> 비교</td></tr><tr><td style=text-align:right>2</td><td>MGL / Intention Locks</td><td style=text-align:right>필수</td><td>IS/IX/SIX 획득순서와 이유 이해</td><td>높음</td><td>트리 계층 (테이블→페이지→행) 과 의도락 동작</td><td>MGL 시뮬레이터로 단계별 재현</td></tr><tr><td style=text-align:right>2</td><td>Lock Granularity</td><td style=text-align:right>필수</td><td>입도 선택 기준 이해</td><td>높음</td><td>Row/Page/Table trade-off</td><td>실험: row vs table 락 성능 비교</td></tr><tr><td style=text-align:right>3</td><td>키 - 범위/프레디킷 락</td><td style=text-align:right>필수</td><td>팬텀 방지와 격리 구현 이해</td><td>높음</td><td>gap-lock, predicate-lock 동작 차이</td><td>범위 쿼리로 팬텀 재현</td></tr><tr><td style=text-align:right>3</td><td>데드락 탐지/해결</td><td style=text-align:right>필수</td><td>wait-for 그래프·victim 선정 원리</td><td>매우 높음</td><td>데드락 재현, 자동탐지 vs 예방 전략</td><td>데드락 스크립트 + 탐지 로그 분석</td></tr><tr><td style=text-align:right>4</td><td>Lock Escalation</td><td style=text-align:right>권장</td><td>임계값·비용 - 효익 판단 이해</td><td>높음</td><td>행락→테이블락 전환 프로세스</td><td>임계값 바꿔가며 성능 측정</td></tr><tr><td style=text-align:right>4</td><td>락 테이블 자료구조</td><td style=text-align:right>권장</td><td>해시 버킷·리사이징 이해</td><td>중간</td><td>bucketed lock, 동기화 비용</td><td>해시 락테이블 간단 구현 실습</td></tr><tr><td style=text-align:right>4</td><td>모니터링 지표</td><td style=text-align:right>필수</td><td>lock_wait, deadlock_rate 등 정의</td><td>매우 높음</td><td>메트릭 수집/대시보드/알람 설정</td><td>Prometheus 대시보드 작성</td></tr><tr><td style=text-align:right>5</td><td>성능 튜닝</td><td style=text-align:right>필수</td><td>병목 식별·튜닝 기법 습득</td><td>매우 높음</td><td>인덱스·쿼리·타임아웃 조정</td><td>부하 테스트 + 튜닝 리포트</td></tr><tr><td style=text-align:right>5</td><td>트러블슈팅 워크플로</td><td style=text-align:right>필수</td><td>원인분석→임시완화→근본대응</td><td>매우 높음</td><td>로그·대기큐·스택·재현 절차</td><td>케이스 스터디 기반 문제해결</td></tr><tr><td style=text-align:right>6</td><td>파티셔닝/샤딩</td><td style=text-align:right>권장</td><td>분할 전략과 라우팅 설계</td><td>높음</td><td>범위·해시 샤딩, 핫스팟 관리</td><td>샤드 라우터 시뮬레이션</td></tr><tr><td style=text-align:right>6</td><td>분산락 (2PC/펜싱)</td><td style=text-align:right>권장</td><td>글로벌 일관성과 장애복구</td><td>높음</td><td>prepare/commit, fencing token</td><td>etcd/Redis 기반 분산락 실습</td></tr><tr><td style=text-align:right>7</td><td>MVCC / Lock-free</td><td style=text-align:right>선택</td><td>판독전용 성능·GC 비용 이해</td><td>중간</td><td>스냅샷, 버전체인, vacuum/GC</td><td>MVCC 동작 시뮬레이션</td></tr><tr><td style=text-align:right>7</td><td>자동튜닝 (ML)</td><td style=text-align:right>선택</td><td>데이터 기반 파라미터 최적화</td><td>중간</td><td>피처 설계, Canary 배포</td><td>ML PoC: 성능모델→카나리 테스트</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th style=text-align:right>카테고리</th><th>용어 (한글)</th><th>(영어 풀네임, 약어)</th><th>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td style=text-align:right>핵심</td><td>락 세분성</td><td>Lock Granularity</td><td>잠금을 적용하는 데이터 단위의 크기 (예: 레코드·페이지·테이블·DB).</td><td>MGL, 2PL, 동시성/오버헤드</td><td>입도 결정 (OLTP→행, 배치→파티션 등), 성능 튜닝</td></tr><tr><td style=text-align:right>핵심</td><td>2 단계 잠금 (2PL)</td><td>Two-Phase Locking (2PL)</td><td>획득 단계 (Growing) 와 해제 단계 (Shrinking) 로 트랜잭션 락을 관리하는 프로토콜.</td><td>직렬화, ACID</td><td>트랜잭션 설계·직렬화 보장</td></tr><tr><td style=text-align:right>구현</td><td>다중 세분성 락</td><td>Multiple Granularity Locking (MGL)</td><td>계층적 데이터 트리에서 적합한 단위에 락을 적용하는 기법.</td><td>Intention Lock, 호환성 매트릭스</td><td>대형 DBMS 기본 락 전략</td></tr><tr><td style=text-align:right>구현</td><td>인텐션 락</td><td>Intention Lock (IS/IX/SIX)</td><td>하위 노드에 락을 걸 의도를 상위 노드에 표시하는 락 모드.</td><td>호환성 매트릭스, 계층 락</td><td>락 검사 비용 절감, 계층적 호환성 보장</td></tr><tr><td style=text-align:right>구현</td><td>키 - 범위 잠금</td><td>Key-Range Lock / Gap Lock</td><td>인덱스의 범위를 잠궈 팬텀 현상을 제어하는 잠금.</td><td>Serializable, 인덱스 설계</td><td>범위 업데이트·직렬화 격리에 중요</td></tr><tr><td style=text-align:right>구현</td><td>락 에스컬레이션</td><td>Lock Escalation</td><td>다수의 세부 락이 일정 임계치를 넘을 때 상위 단위로 승격하는 과정.</td><td>메모리 임계치, 히스테리시스</td><td>메타데이터 관리, 임계값 튜닝</td></tr><tr><td style=text-align:right>구현</td><td>호환성 매트릭스</td><td>Lock Compatibility Matrix</td><td>다양한 락 모드 간의 동시 허용성 규칙 표.</td><td>S/X/IS/IX/SIX</td><td>락 검사 로직/호환성 판단</td></tr><tr><td style=text-align:right>구현</td><td>락 관리자</td><td>Lock Manager</td><td>락 요청 처리, 락 테이블 관리, 대기 큐·에스컬레이션 결정 주체.</td><td>Lock Table, Wait Queue</td><td>운영·진단 포인트</td></tr><tr><td style=text-align:right>운영</td><td>교착상태 (데드락)</td><td>Deadlock</td><td>트랜잭션 간 순환 대기로 진행이 멈추는 현상.</td><td>Wait-for Graph, victim selection</td><td>탐지·롤백·운영 알림</td></tr><tr><td style=text-align:right>운영</td><td>잠금 경합</td><td>Lock Contention</td><td>동일 자원에 대한 동시 잠금 요청으로 인한 성능 저하.</td><td>핫스팟, TPS 저하</td><td>핫키 분석·파티셔닝·캐싱</td></tr><tr><td style=text-align:right>운영</td><td>NOWAIT / SKIP_LOCKED</td><td>NOWAIT / SKIP LOCKED</td><td>즉시 실패 (NOWAIT) 또는 잠긴 행 건너뛰기 (SKIP LOCKED) 옵션.</td><td>대기 정책, 워커 큐</td><td>멀티 - 컨슈머 큐·응답성 설계</td></tr><tr><td style=text-align:right>운영</td><td>모니터링 지표</td><td>Monitoring Metrics</td><td>avg lock wait, locks/tx, escalation rate 등 운영 지표.</td><td>Grafana, 알람 정책</td><td>임계값 기반 알람·자동화</td></tr><tr><td style=text-align:right>고급</td><td>낙관적 동시성 제어</td><td>Optimistic Concurrency Control (OCC)</td><td>변경 시점에 충돌을 검사하고 충돌 시 재시도하는 방식 (락 최소화).</td><td>버전관리, 충돌 재시도</td><td>충돌 드문 쓰기 중심 시스템</td></tr><tr><td style=text-align:right>고급</td><td>MVCC</td><td>Multi-Version Concurrency Control (MVCC)</td><td>버전별로 읽기 뷰를 제공해 읽기에서 락을 최소화하는 기법.</td><td>스냅샷 격리, VACUUM</td><td>읽기 우선 워크로드에 유리</td></tr><tr><td style=text-align:right>고급</td><td>분산락 (펜싱/리스)</td><td>Distributed Locks (Fencing / Leases)</td><td>분산환경에서 전역 자원 접근을 조정하는 락 메커니즘.</td><td>Redis, Zookeeper, 펜싱 토큰</td><td>분산 크루싱·리더십 제어</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.postgresql.org/docs/current/mvcc.html>PostgreSQL Documentation — Concurrency Control</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html>MySQL InnoDB Locks — Concepts</a></li><li><a href=https://learn.microsoft.com/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide>SQL Server — Locking, Blocking, and Row Versioning Guide</a></li><li><a href=https://highered.mheducation.com/sites/0073523321/>Database System Concepts (Silberschatz, Korth, Sudarshan)</a></li><li><a href=https://www.postgresql.org/docs/current/explicit-locking.html>PostgreSQL Documentation - Explicit Locking</a></li><li><a href=https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/data-concurrency-and-consistency.html>Oracle Database Concepts - Data Concurrency and Consistency</a></li><li><a href=https://www.elsevier.com/books/transactional-information-systems/weikum/978-1-55860-508-4>Transactional Information Systems (Weikum & Vossen) — Elsevier</a></li><li><a href=https://www.mongodb.com/ko-kr/docs/manual/faq/concurrency/>MongoDB 공식 매뉴얼 - Concurrency</a></li><li><a href=https://bako94.tistory.com/157>Multiple Granularity Locking 논의 및 사례</a></li><li><a href=https://jaeseo0519.tistory.com/347>트랜잭션 동시성 제어 및 Deadlock 실습</a></li><li><a href=https://hanpy-blog.com/backend/ko/database/mongodb-concurrency-control-2-Lock-Granularity>DB Lock 실전 구조 설명</a></li><li><a href=https://m.earticle.net/Article/A346093>경량 락킹 기법 (SQLite 사례) — earticle</a></li><li><a href="https://translate.google.com/translate?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FLock_%28computer_science%29&amp;hl=ko&amp;sl=en&amp;tl=ko&amp;client=srp">Lock (computer science) - Wikipedia (번역)</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>