<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Locking Protocols | hyunyoun's Blog</title><meta name=keywords content="Data-and-Database-Systems,Data-Operations,Transaction-Management,Concurrency-Control,Locking,Locking-Protocols"><meta name=description content="락 프로토콜은 트랜잭션의 동시 접근을 제어해 일관성과 직렬성을 보장하는 규칙 집합이다. 대표적으로 Two-Phase Locking(공유·배타·업데이트·의도 락)과 범위 락이 있으며, MVCC·낙관적 기법과의 혼용으로 성능·무결성 간 트레이드오프를 관리한다."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Locking Protocols"><meta property="og:description" content="락 프로토콜은 트랜잭션의 동시 접근을 제어해 일관성과 직렬성을 보장하는 규칙 집합이다. 대표적으로 Two-Phase Locking(공유·배타·업데이트·의도 락)과 범위 락이 있으며, MVCC·낙관적 기법과의 혼용으로 성능·무결성 간 트레이드오프를 관리한다."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Locking Protocols"><meta name=twitter:description content="락 프로토콜은 트랜잭션의 동시 접근을 제어해 일관성과 직렬성을 보장하는 규칙 집합이다. 대표적으로 Two-Phase Locking(공유·배타·업데이트·의도 락)과 범위 락이 있으며, MVCC·낙관적 기법과의 혼용으로 성능·무결성 간 트레이드오프를 관리한다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"HY's Blog","item":"https://buenhyden.github.io/posts/"},{"@type":"ListItem","position":7,"name":"Locking Protocols","item":"https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-protocols/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://buenhyden.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://buenhyden.github.io/posts/>HY's Blog</a></div><h1>Locking Protocols</h1><div class=post-description>락 프로토콜은 트랜잭션의 동시 접근을 제어해 일관성과 직렬성을 보장하는 규칙 집합이다. 대표적으로 Two-Phase Locking(공유·배타·업데이트·의도 락)과 범위 락이 있으며, MVCC·낙관적 기법과의 혼용으로 성능·무결성 간 트레이드오프를 관리한다.</div></header><div class=post-content><h2 id=locking-protocols>Locking Protocols<a hidden class=anchor aria-hidden=true href=#locking-protocols>#</a></h2><p>잠금 프로토콜은 다중 트랜잭션 환경에서 데이터 일관성과 격리성을 보장하기 위해 자원 접근 (획득·해제) 규칙을 정의한 기술이다.<br>핵심 개념은 공유 (S)/배타 (X) 같은 락 모드와 락 획득·해제 시점 (예: Two-Phase Locking, 2PL) 이며, Strict 2PL 은 쓰기 락을 커밋까지 유지해 복구를 단순화한다.<br>현대 시스템에서는 MVCC(스냅샷 읽기) 를 통해 읽기 성능을 높이고, 낙관적 동시성 (버전 비교) 을 충돌이 적은 워크로드에 적용한다.<br>구현 관점에서는 락 매니저·락 테이블, 의도락 (IS/IX)·갭/넥스트키 락 등 계층·범위 제어가 중요하다.<br>운영상 데드락은 Wait-for 그래프 탐지·타임아웃·victim 선정으로 처리하고, 락 승격은 대량 락 상황에서 성능 저하를 유발하므로 주의해야 한다.<br>분산 환경에서는 ZooKeeper/etcd/Redis 기반 분산 락 (리스/펜싱 토큰) 과 메시지 기반 (Saga/CQRS) 아키텍처를 조합해 장기 트랜잭션과 글로벌 일관성을 관리한다.<br>설계 시에는 격리 수준, 인덱스·쿼리 범위, 트랜잭션 길이, DBMS 별 구현 차이를 고려해 성능과 정합성 사이의 적절한 균형을 맞추는 것이 관건이다.</p><h3 id=락-프로토콜-이론실무-종합정리>락 프로토콜: 이론↔실무 종합정리<a hidden class=anchor aria-hidden=true href=#락-프로토콜-이론실무-종합정리>#</a></h3><p>락은 동시에 여러 트랜잭션이 데이터에 접근할 때 <strong>누가 어떤 권한 (읽기/쓰기) 을 가질지 정하는 규칙</strong>이다.<br>기본 모드는 공유 (S) 와 배타 (X) 이며, 획득 순서와 해제 시점 (2PL) 이 시스템의 직렬성 보장을 좌우한다.<br>트랜잭션을 오래 열어두면 락을 오래 유지해 다른 세션을 막으니 <strong>짧게</strong> 설계하고 인덱스로 범위를 좁히는 것이 실무 핵심이다.<br>데드락 (서로 기다리는 상태) 은 자동 탐지·희생자 선정 또는 예방 기법으로 해결한다.<br>MVCC 는 읽기 성능을 높여 주지만 삽입 (팬텀) 은 별도 제어가 필요하다.</p><h4 id=핵심-개념-요약표>핵심 개념 요약표<a hidden class=anchor aria-hidden=true href=#핵심-개념-요약표>#</a></h4><table><thead><tr><th>핵심 개념 (한글, 약어)</th><th>정의</th><th>왜 중요한가</th></tr></thead><tbody><tr><td>공유 잠금 (Shared Lock, S)</td><td>여러 트랜잭션이 읽기 가능하도록 허용하는 락</td><td>읽기 동시성 허용</td></tr><tr><td>전용 잠금 (Exclusive Lock, X)</td><td>단일 트랜잭션만 읽기/쓰기 가능</td><td>쓰기 충돌 방지</td></tr><tr><td>의도 잠금 (Intention Lock, IS/IX/SIX)</td><td>상위 오브젝트가 하위 락 의도를 표시</td><td>계층적 충돌 검사 비용 절감</td></tr><tr><td>락 그레뉼러리티 (Granularity)</td><td>락 대상 단위 (테이블/페이지/행/키)</td><td>충돌 표면과 관리 비용 결정</td></tr><tr><td>2 단계 락 (Two-Phase Locking, 2PL)</td><td>획득 (확장)→해제 (수축) 규칙</td><td>충돌 직렬성 보장</td></tr><tr><td>엄격 2PL (Strict 2PL, S2PL)</td><td>X 락을 커밋까지 유지</td><td>카스케이딩 방지·복구 용이</td></tr><tr><td>데드락 (Deadlock)</td><td>상호 대기 상태</td><td>가용성 저하; 탐지/회복 필요</td></tr><tr><td>락 에스컬레이션 (Lock Escalation)</td><td>세분 락 통합 → 상위 락</td><td>메모리 절감 vs 동시성 저하</td></tr><tr><td>분산 잠금 (Distributed Lock)</td><td>외부 coord.로 서비스간 락 제공</td><td>분산 시스템 조정·리더 선출</td></tr><tr><td>MVCC (다중버전동시성제어)</td><td>버전으로 읽기 충돌 회피</td><td>읽기 성능 향상, 삽입 관련 문제 존재</td></tr><tr><td>낙관적 동시성 (Optimistic Concurrency Control, OCC)</td><td>충돌 시 검증 후 재시도</td><td>쓰기 충돌이 적은 경우 성능 유리</td></tr></tbody></table><ul><li>위 개념들은 트랜잭션의 일관성·성능을 설계·운영할 때 반드시 이해해야 할 핵심 구성요소다.</li><li>한 개념만으로 완전한 해법은 없고, 워크로드·서비스 요구 (SLA) 에 따라 적절한 조합이 필요하다.</li></ul><h4 id=개념-관계-목적메커니즘-중심>개념 관계: 목적·메커니즘 중심<a hidden class=anchor aria-hidden=true href=#개념-관계-목적메커니즘-중심>#</a></h4><table><thead><tr><th>출발 개념</th><th style=text-align:right>방향성</th><th>대상 개념</th><th>무엇을 위해 / 어떻게 연결되는가</th></tr></thead><tbody><tr><td>트랜잭션</td><td style=text-align:right>→</td><td>락</td><td>일관성 (직렬성) 확보를 위해 항목 접근 제어</td></tr><tr><td>락</td><td style=text-align:right>→</td><td>2PL</td><td>락 획득/해제 규칙으로 직렬성 보장</td></tr><tr><td>2PL</td><td style=text-align:right>→</td><td>S2PL</td><td>X 락 유지로 복구·카스케이딩 방지 강화</td></tr><tr><td>락 그레뉼러리티</td><td style=text-align:right>→</td><td>동시성/관리비용</td><td>단위 작아지면 동시성↑ / 락 메타데이터↑</td></tr><tr><td>의도락</td><td style=text-align:right>→</td><td>그레뉼러리티 연산</td><td>상위에서 하위 충돌 여부를 빠르게 판단</td></tr><tr><td>락 매니저</td><td style=text-align:right>→</td><td>데드락 탐지</td><td>wait-for 그래프를 통해 사이클 탐지</td></tr><tr><td>데드락 탐지</td><td style=text-align:right>→</td><td>회복 (선택적 희생자)</td><td>희생자 롤백으로 교착 해소</td></tr><tr><td>MVCC</td><td style=text-align:right>⇄</td><td>락</td><td>읽기 성능↑, 하지만 삽입/팬텀은 락 보완 필요</td></tr><tr><td>락 에스컬레이션</td><td style=text-align:right>→</td><td>그레뉼러리티 변화</td><td>다수 세분 락 → 상위 락으로 통합 (성능 영향)</td></tr><tr><td>분산 락</td><td style=text-align:right>→</td><td>트랜잭션 조정</td><td>서비스 간 조정·리더 선출 위해 외부 합의 사용</td></tr></tbody></table><ul><li>방향은 " 무엇을 위해 &ldquo;(목적) 과 " 어떻게 &ldquo;(메커니즘) 를 함께 보여준다.<br>예: MVCC 는 읽기 충돌을 줄이려 도입되지만 특정 케이스 (팬텀) 는 락으로 보완한다.</li></ul><h4 id=실무-적용-매핑표>실무 적용 매핑표<a hidden class=anchor aria-hidden=true href=#실무-적용-매핑표>#</a></h4><table><thead><tr><th>핵심 개념</th><th>무엇이 (What)</th><th>어떻게 (How)</th><th>왜 (Why)</th></tr></thead><tbody><tr><td>트랜잭션 경계</td><td>트랜잭션의 범위 (업무 단위)</td><td>커밋 시점/범위 명확화, 외부 I/O 제외</td><td>락 보유 시간 단축 → 동시성 개선</td></tr><tr><td>S/X 락</td><td>읽기/쓰기 충돌 제어</td><td>DB 가 호환성 매트릭스로 grant/wait</td><td>데이터 무결성 보장</td></tr><tr><td>의도 락</td><td>상위 - 하위 충돌 사전표시</td><td>테이블에 IS/IX 로 하위 락 의도 표기</td><td>하위 스캔 없이 충돌 판단 비용 절감</td></tr><tr><td>Range/Gap 락</td><td>팬텀 방지</td><td>인덱스 기반 범위 잠금</td><td>SERIALIZABLE 수준 보장</td></tr><tr><td>Lock Escalation</td><td>락 관리 비용 절감</td><td>세분 락 누적시 상위로 합침</td><td>메모리 보호지만 동시성 저하 위험</td></tr><tr><td>데드락 정책</td><td>교착 자동 해소·예방</td><td>탐지 (그래프)/예방 (순서)/회피 (우선순위)</td><td>가용성 유지, MTTR 단축</td></tr><tr><td>MVCC</td><td>읽기 성능 개선</td><td>버전 스냅샷으로 읽기 제공</td><td>읽기 많은 워크로드에 유리</td></tr><tr><td>분산 락</td><td>서비스 간 조정</td><td>외부 coord(zk/etcd) 로 락 관리</td><td>분산 리더 선출·자원 조율</td></tr><tr><td>낙관적 동시성</td><td>충돌이 적은 쓰기</td><td>버전 검증 후 커밋, 실패시 재시도</td><td>충돌 낮은 환경에서 성능 유리</td></tr></tbody></table><ul><li>실무 적용은 " 무엇을 해결하려는가 " 와 " 어떤 메커니즘으로 " 를 명확히 매핑해야 한다.</li><li>동일 문제 (예: 팬텀) 는 DB 별로 다른 도구 (range/gap/predicate) 로 해결되므로 DB 특성 반영 필수.</li></ul><h3 id=기초-조사-및-개념-정립>기초 조사 및 개념 정립<a hidden class=anchor aria-hidden=true href=#기초-조사-및-개념-정립>#</a></h3><h4 id=락킹-프로토콜의-정의와-본질>락킹 프로토콜의 정의와 본질<a hidden class=anchor aria-hidden=true href=#락킹-프로토콜의-정의와-본질>#</a></h4><ol><li><p><strong>왜 필요한가?</strong><br>여러 사용자가 동시에 데이터에 접근하면 결과가 엉킬 수 있다 → 락으로 순서를 만들고 충돌을 막는다.</p></li><li><p><strong>무엇을 하는가?</strong><br>트랜잭션이 읽거나 쓰기 전에 적절한 락을 걸고, 작업 끝나면 락을 풀어 다른 트랜잭션이 접근할 수 있게 한다.</p></li><li><p><strong>중요한 개념 세 개</strong></p><ul><li><strong>공유 (S)</strong>: 여러 트랜잭션이 동시에 읽을 수 있음.</li><li><strong>배타 (X)</strong>: 단독으로 쓰기 (또는 읽기 제외) 허용.</li><li><strong>2PL</strong>: 락을 얻는 단계와 푸는 단계를 분리해 직렬성 보장.</li></ul></li><li><p><strong>현실적 문제와 대책</strong></p><ul><li>데드락 → 일관된 잠금 순서/타임아웃/재시도</li><li>성능 저하 → 작은 그레인·MVCC·쿼리/인덱스 튜닝</li><li>분산 리소스 → 합의 기반 분산락 도입</li></ul></li></ol><p>락킹 프로토콜은 트랜잭션이 데이터 항목에 접근하기 위해 따르는 규칙 모음으로, 어떤 락을 언제 획득하고 언제 해제할지, 그리고 서로 다른 락 모드 간 호환성 규칙을 정의한다. 이 규칙을 통해 DB 는 트랜잭션 간 상호작용이 마치 순차적으로 실행된 것처럼 보이게 하여 데이터 일관성과 무결성을 유지한다.</p><p><strong>본질적 이해 (요점)</strong></p><ul><li><strong>목표</strong>: 직렬성 (Serializability) 과 복구 가능성 (Recoverability) 을 확보하면서 가능한 한 많은 동시성을 허용해 시스템 처리량을 높이는 것.</li><li><strong>수단</strong>: 락 모드·그레인·획득/해제 타이밍 (예: 2PL), 그리고 필요시 버전 (MVCC) 이나 분산 합의로 보완.</li><li><strong>트레이드오프</strong>: 강한 일관성은 동시성 손실을, 높은 동시성은 일관성 위험 (또는 추가 복잡도) 을 초래한다.</li></ul><h4 id=락-프로토콜의-등장과-진화사>락 프로토콜의 등장과 진화사<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-등장과-진화사>#</a></h4><p>데이터베이스에서 여러 트랜잭션이 동시에 같은 데이터를 다루면 충돌과 불일성이 생긴다.<br>처음엔 공유 (S) 와 전용 (X) 같은 단순한 락으로 문제를 막았고, 이걸 규칙 (2PL) 으로 묶어 직렬성을 보장했다.<br>이후엔 성능을 위해 락의 크기를 세분화 (테이블→레코드) 하고, 의도 락으로 검사 비용을 줄였다.<br>팬텀 문제는 범위 잠금으로 대응했고, 읽기 성능을 극대화하려 MVCC(스냅샷) 같은 비락 기법이 나왔다.<br>마지막에는 분산 환경에 맞춘 분산 락·샤딩 방식으로 확장성을 확보하게 되었다.</p><h5 id=등장-배경>등장 배경<a hidden class=anchor aria-hidden=true href=#등장-배경>#</a></h5><p>초기 다중 사용자 데이터베이스에서는 여러 트랜잭션이 동일 데이터에 동시 접근하면서 <strong>경쟁 조건, 갱신 손실 (Lost Update), 더티 리드 (Dirty Read), 반복 불가능한 읽기 (Non-repeatable Read), 팬텀 (Phantom Read)</strong> 같은 문제가 빈번히 발생했다.<br>이러한 문제를 해결하고 데이터 무결성과 직렬가능성 (Serializability) 을 보장하기 위해 <strong>락 프로토콜 (lock protocols)</strong> 이 도입되었다.<br>초기에는 단순한 공유/전용 락 모델로 시작했지만, 실무적 성능·동시성 요구가 커지면서 락의 형태와 제어 기법이 점진적으로 발전해 왔다.</p><h5 id=발전-과정>발전 과정<a hidden class=anchor aria-hidden=true href=#발전-과정>#</a></h5><table><thead><tr><th style=text-align:right>시기</th><th>주요 기법/개념</th><th>등장 이유 (문제)</th><th>개선 포인트 (무엇이 좋아졌나)</th></tr></thead><tbody><tr><td style=text-align:right>1970 년대</td><td>S/X 락, 2PL 기초</td><td>동시성으로 인한 데이터 불일치 방지</td><td>기본적 직렬성 보장</td></tr><tr><td style=text-align:right>1976 전후</td><td>Predicate locks (팬텀 이슈 제기)</td><td>팬텀 (쿼리 범위에 신규 레코드 삽입) 해결 필요</td><td>범위 보호로 팬텀 방지 (이론적 근거)</td></tr><tr><td style=text-align:right>1980s</td><td>Intent locks, 다중 그레뉼러리티</td><td>상위/하위 락 혼용 시 검사 비용·대기 문제</td><td>상위 - 하위 통합 검사로 불필요 대기 감소</td></tr><tr><td style=text-align:right>1990s</td><td>Key-range / Next-key, 인덱스 락 최적화</td><td>인덱스·트리 탐색 중 동시성·구조 변경 문제</td><td>트리 기반 처리중 동시성 향상</td></tr><tr><td style=text-align:right>1980s~2000s</td><td>MVCC(스냅샷) 상용화</td><td>읽기 - 쓰기 블로킹 완화 필요</td><td>읽기 비차단으로 읽기 성능 대폭 향상</td></tr><tr><td style=text-align:right>2000s~</td><td>하이브리드·분산 락</td><td>클라우드·분산 환경의 일관성·확장성 요구</td><td>샤딩·분산 합의로 확장성 확보 (대가 존재)</td></tr></tbody></table><pre class=mermaid>timeline
    title 락 프로토콜 발전 타임라인
    1970s : 관계형 DB 등장 및 S/X, 2PL 개념 정립
    1976 : Predicate locks(팬텀 문제 이론화)
    1980s : 그레뉼러리티·Intent locks 연구·도입
    1990s : Key-range / Next-key 락, 인덱스 동시성 최적화
    1980s-2000s : MVCC 실무 적용 및 상용화(스냅샷)
    2000s~ : 하이브리드·분산 락/샤딩 설계 확산
</pre><p>1970 년대에는 관계형 모델과 함께 S/X 락과 2PL 같은 기초 기법이 도입되어 직렬성의 이론적 기반을 마련했다.<br>1976 년 전후에는 팬텀 문제를 지적하는 연구들이 등장했고, 이후로는 실제 시스템에서 이를 해결하기 위한 key-range·next-key 락과 같은 인덱스 기반 기법이 개발되었다.<br>1980 년대<del>1990 년대에는 락 그레뉼러리티 문제 해결을 위해 의도 락과 계층적 잠금이 도입되어 상위·하위 락의 상호작용을 효율화했다.<br>1980s 후반</del>2000 년대에는 MVCC(스냅샷) 기법이 실무에 정착되어 읽기 블로킹 문제를 크게 완화했으며, 2000 년대 이후에는 분산·클라우드 환경을 고려한 하이브리드 및 분산 락 설계가 확산되었다.<br>각 단계는 &rsquo; 어떤 문제를 해결하려고 했는가 &rsquo; 와 &rsquo; 그 해결책이 어떤 성능·정합성 트레이드오프를 가져왔는가 &rsquo; 를 기준으로 이해해야 실무 적용 시 혼선을 줄일 수 있다.</p><h4 id=락-프로토콜의-문제목적해결-매핑>락 프로토콜의 문제·목적·해결 매핑<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-문제목적해결-매핑>#</a></h4><p>락 프로토콜은 여러 트랜잭션이 동시에 데이터에 접근할 때 **일관성 (같은 결과가 나오도록)**과 **안전한 복구 (롤백 시 피해 최소화)**를 보장하기 위해 도입한다.<br>기본 아이디어는 &rsquo; 누군가 쓰기를 할 때는 다른 사람이 못 보게 한다 &rsquo; 는 것인데, 이것을 시스템적으로 관리하는 규칙이 2PL·Strict 2PL 등 락 프로토콜이다.<br>팬텀 (범위 삽입) 문제는 범위 단위 락으로 막고, 데드락은 탐지하거나 예방하는 정책으로 처리한다.<br>성능을 위해서는 락의 세분성, 의도 락, 또는 MVCC 같은 대안기법을 적절히 조합한다.</p><h5 id=락-프로토콜이-해결하는-문제>락 프로토콜이 해결하는 문제<a hidden class=anchor aria-hidden=true href=#락-프로토콜이-해결하는-문제>#</a></h5><table><thead><tr><th>문제</th><th>원인 (요약)</th><th>대표 프로토콜/기법</th><th>기대 효과</th></tr></thead><tbody><tr><td>읽기 - 쓰기 충돌</td><td>동시 읽기·수정 시 비일관성</td><td>2PL (S/X 락)</td><td>직렬가능성 확보</td></tr><tr><td>쓰기 - 쓰기 충돌</td><td>동시 쓰기 시 덮어쓰기</td><td>2PL, Exclusive lock</td><td>데이터 무결성 보장</td></tr><tr><td>쓰기 - 읽기 (비가시성)</td><td>커밋 전 변경 노출</td><td>Strict 2PL</td><td>cascading rollback 방지</td></tr><tr><td>팬텀 (범위 삽입)</td><td>범위 조회 후 삽입 발생</td><td>Next-key / predicate lock</td><td>팬텀 제거 → Serializable 보장</td></tr><tr><td>데드락</td><td>리소스 순서 불일치</td><td>Deadlock detection/prevention</td><td>블로킹 복구 → 가용성 개선</td></tr><tr><td>에스컬레이션</td><td>과다 락 보유 → 상위 락</td><td>에스컬레이션 정책·파티셔닝</td><td>관리 오버헤드 감소 but 동시성 저하</td></tr></tbody></table><p>락 프로토콜은 충돌 유형별로 적절한 락/전략을 매핑해 직렬가능성과 무결성을 보장한다. 각 기법은 보장성 (안전) 과 성능 (동시성) 사이의 균형점을 다르게 설정한다.</p><h5 id=락-프로토콜의-핵심-목적>락 프로토콜의 핵심 목적<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-핵심-목적>#</a></h5><table><thead><tr><th>목적</th><th>설명</th><th>주된 수단</th><th>시스템적 효과</th></tr></thead><tbody><tr><td>일관성 유지</td><td>제약·무결성 위반 방지</td><td>S/X 락, 강한 격리</td><td>무결성 보장</td></tr><tr><td>직렬가능성</td><td>병행 실행 결과의 동등성</td><td>2PL 계열, 범위 락</td><td>예측 가능한 결과</td></tr><tr><td>회복성</td><td>롤백 시 파급 방지</td><td>Strict/Rigorous 2PL</td><td>복구 단순화</td></tr><tr><td>처리량 최적화</td><td>대기 최소화·동시성 확보</td><td>세분화 락, Intent, MVCC</td><td>높은 처리량 유지</td></tr></tbody></table><p>각 목적은 상호 보완적이지만 때로 상충한다 (예: 직렬성 강화는 처리량 저하). 설계는 목적 우선순위에 따라 프로토콜과 정책을 선택하는 과정이다.</p><h5 id=문제와-목적의-연계-매핑>문제와 목적의 연계 매핑<a hidden class=anchor aria-hidden=true href=#문제와-목적의-연계-매핑>#</a></h5><table><thead><tr><th>문제</th><th>대응 목적 (우선순위)</th><th>핵심 메커니즘</th></tr></thead><tbody><tr><td>읽기 - 쓰기 충돌</td><td>직렬가능성, 일관성</td><td>S/X 락, 2PL</td></tr><tr><td>쓰기 - 쓰기 충돌</td><td>일관성, 회복성</td><td>Exclusive lock, Strict 2PL</td></tr><tr><td>팬텀</td><td>직렬가능성</td><td>Predicate/Next-key lock</td></tr><tr><td>데드락</td><td>가용성 (회복성 보조)</td><td>탐지/예방 알고리즘</td></tr><tr><td>에스컬레이션</td><td>처리량 유지</td><td>파티셔닝·임계치 조정, 락 세분화</td></tr></tbody></table><p>문제별 우선 해결 목적이 명확하면 어떤 락 프로토콜·운영정책을 선택할지 결정할 수 있다. 예컨대 팬텀이 핵심이라면 범위 락과 높은 격리 수준을 채택해야 한다.</p><h4 id=락-프로토콜-운영을-위한-필수-조건>락 프로토콜 운영을 위한 필수 조건<a hidden class=anchor aria-hidden=true href=#락-프로토콜-운영을-위한-필수-조건>#</a></h4><p>락 프로토콜을 안정적으로 적용하려면 먼저 트랜잭션의 시작과 끝을 분명히 정의해야 한다.<br>어떤 단위로 락을 걸 것인지 (행, 블록, 테이블) 를 정책으로 정하고, 락 모드 간 허용 규칙 (호환성 매트릭스) 을 문서로 만들어야 운영 중 예측 가능한 블로킹·데드락 대응이 가능하다.<br>또한 로그 (WAL) 와 커밋 타이밍의 규칙을 정해 데이터 내구성과 락 보유 시간 간 균형을 잡고, 데드락 감지·자동 해결·모니터링 체계를 갖춰야 실서비스에서 안정적으로 동작한다.</p><h5 id=전제조건-및-시스템-요구사항-체크리스트>전제조건 및 시스템 요구사항 체크리스트<a hidden class=anchor aria-hidden=true href=#전제조건-및-시스템-요구사항-체크리스트>#</a></h5><table><thead><tr><th>항목</th><th>요구사항 (무엇을)</th><th>이유 (근거)</th><th>미준수 시 영향</th><th>권장 조치 (실무 적용)</th></tr></thead><tbody><tr><td>트랜잭션 경계</td><td>트랜잭션 단위·길이 규정</td><td>락 보유 시간·원자성 보장</td><td>장기 락, 기아, 성능 저하</td><td>트랜잭션 가이드·타임아웃 설정</td></tr><tr><td>락 그라뉼러리</td><td>기본/예외 세분성 정의</td><td>동시성 vs 오버헤드 균형</td><td>과도한 블로킹 또는 메모리 폭증</td><td>행 우선, 배치시 테이블 락 정책</td></tr><tr><td>호환성 매트릭스</td><td>모드 간 허용 표준화</td><td>블로킹 예측·검증 용이</td><td>예측 불가한 충돌·데드락</td><td>문서화 + 테스트 케이스 제공</td></tr><tr><td>로그·복구 (WAL)</td><td>커밋 - 로그 - 락 상호 규칙</td><td>내구성·락 기간 연계</td><td>커밋 지연·락 장기화</td><td>WAL 정책·fsync 전략 명시</td></tr><tr><td>락 관리자</td><td>락 상태 추적·큐잉</td><td>충돌 판단·권한 부여 필요</td><td>락 누락·불일치 발생</td><td>중앙/분산 Lock Manager 설계</td></tr><tr><td>데드락 감지기</td><td>WFG·감지 주기·해결 규칙</td><td>순환대기 자동 탐지·회복</td><td>트랜잭션 롤백·SLA 위반</td><td>탐지 주기·우선순위·자동 롤백</td></tr><tr><td>모니터링</td><td>locks/sec, wait-time 등 지표</td><td>이상 조기 탐지·SLA 관리</td><td>문제 장기화·원인 미추적</td><td>대시보드·알림·정기 리포트</td></tr><tr><td>개발·운영 절차</td><td>힌트/격리 변경 절차</td><td>변경 시 동작 검증 필요</td><td>마이그레이션 중 동작 불일치</td><td>변경 승인·동시성 테스트 포함</td></tr></tbody></table><p>핵심은 정책 (문서화)→검증 (테스트)→운영 (모니터링) 삼단계의 일관된 프로세스를 만드는 것이다. 트랜잭션 규칙·락 세분성·호환성 매트릭스·WAL 정책을 먼저 정의하고, 구현 대상 (DBMS) 별 특성에 맞춰 테스트한 뒤 운영 지표로 지속 관찰하라.</p><h4 id=잠금-프로토콜의-기술적-특징>잠금 프로토콜의 기술적 특징<a hidden class=anchor aria-hidden=true href=#잠금-프로토콜의-기술적-특징>#</a></h4><p>잠금 프로토콜은 여러 사용자 (트랜잭션) 가 동시에 데이터를 건드릴 때 <strong>충돌을 막고 결과를 예측 가능</strong>하게 만드는 규칙이다.<br>읽을 때는 여러 사람이 함께 보도록 <code>공유(S)</code> 를 걸고, 쓸 때는 다른 사람이 못 보게 <code>배타(X)</code> 를 건다.<br>언제 락을 얻고 언제 푸는지 (예: 2PL) 는 데이터 정합성의 핵심이다.<br>읽기 성능을 높이려면 MVCC 처럼 과거 버전을 보는 기술을 쓰고, 분산 시스템에서는 글로벌 락 (예: ZooKeeper) 이나 메시지 기반 패턴 (Saga) 을 섞어 장기 락을 피한다.</p><h5 id=잠금-프로토콜-핵심-특성-정리>잠금 프로토콜 핵심 특성 정리`<a hidden class=anchor aria-hidden=true href=#잠금-프로토콜-핵심-특성-정리>#</a></h5><ol><li><p><strong>락 타입 (모드)—정확한 권한 분리</strong></p><ul><li>근거: 호환성 매트릭스로 수학적 충돌 판정 가능 → 시스템이 결정적 행위 보장.</li><li>차별점: MVCC 는 읽기 락 불필요, 하지만 쓰기 충돌은 여전히 락이나 검증 필요.</li></ul></li><li><p><strong>세분성 (그레뉼러리티)—성능 vs 오버헤드 균형</strong></p><ul><li>근거: 락 개수증가 → 락 테이블·관리 오버헤드 증가 → 병목 (메모리·CPU).</li><li>차별점: coarse-grain 은 적은 관리비용·낮은 동시성, fine-grain 은 높은 동시성·관리비용.</li></ul></li><li><p><strong>획득/해제 규칙 (2PL 계열)—이론적 직렬성 보장</strong></p><ul><li>근거: 2PL 이론으로 직렬성 보장 가능 (증명 존재). Strict 2PL 은 복구 성질 강화.</li><li>차별점: 낙관적/타임스탬프 방식은 직렬성/포함보장 방식이 다르고 비용 (재시도 vs 블로킹) 이 교환점.</li></ul></li><li><p><strong>범위·갭 락—Phantom 문제 해결</strong></p><ul><li>근거: 범위 삽입에 의한 결과변화를 물리적으로 차단하여 쿼리 일관성 유지.</li><li>차별점: SSI(스냅샷 직렬화) 등은 블로킹 대신 충돌 검출로 대응 (결과: abort 가능).</li></ul></li><li><p><strong>운영 메커니즘 (데드락/에스컬레이션)</strong></p><ul><li>근거: 교착은 피할 수 없으므로 Wait-for 그래프 탐지·victim 선정이 필요.</li><li>차별점: 낙관적 접근은 데드락 대신 충돌 발생 시 rollback/retry 전략을 취함.</li></ul></li></ol><h5 id=잠금-프로토콜-핵심-특성-요약표>잠금 프로토콜 핵심 특성 요약표<a hidden class=anchor aria-hidden=true href=#잠금-프로토콜-핵심-특성-요약표>#</a></h5><table><thead><tr><th style=text-align:right>핵심 특징</th><th>기술적 근거</th><th>다른 기술과의 차별점</th></tr></thead><tbody><tr><td style=text-align:right>락 타입 다양성 (S/X/U/IS/IX/Gap)</td><td>호환성 매트릭스 (충돌을 행렬로 정의)</td><td>MVCC 는 읽기 락 회피, 락은 결정적 쓰기 차단</td></tr><tr><td style=text-align:right>그레뉼러리티 제어</td><td>락 개수·관리 오버헤드 vs 동시성의 수학적 트레이드오프</td><td>coarse vs fine tradeoff (동시성↔오버헤드)</td></tr><tr><td style=text-align:right>획득·해제 규칙 (2PL, Strict)</td><td>2PL 이론 → 직렬성 보장 (증명)</td><td>낙관적은 커밋 시 검증·재시도, 2PL 은 블로킹 기반</td></tr><tr><td style=text-align:right>범위/갭 락 (Phantom 제어)</td><td>범위 삽입을 물리적으로 차단해 결과 일관성 확보</td><td>SSI 등은 검출·abort 로 차별화</td></tr><tr><td style=text-align:right>락 변환·의도락·대기 정책</td><td>의도락으로 상위 검사 O(1) 성능·변환은 재검사 필요</td><td>변환은 교착 위험, 의도락은 검사 비용 절감</td></tr><tr><td style=text-align:right>운영 이슈 (데드락/승격)</td><td>Wait-for 그래프·타임아웃·승격 기준으로 운영 제어</td><td>낙관적 모델은 블로킹 대신 재시도 비용 발생</td></tr></tbody></table><p>이 표는 잠금 프로토콜의 핵심 특성들과 그 근거, 그리고 MVCC·낙관적 동시성 등 대안과의 핵심 차이를 한눈에 보여준다. 설계에서는 <strong>어떤 성능·정합성 트레이드오프를 허용할지</strong>가 선택의 핵심이다.</p><h3 id=핵심-원리-및-이론적-기반>핵심 원리 및 이론적 기반<a hidden class=anchor aria-hidden=true href=#핵심-원리-및-이론적-기반>#</a></h3><h4 id=락-설계-원칙과-철학의-실무적용>락 설계 원칙과 철학의 실무적용<a hidden class=anchor aria-hidden=true href=#락-설계-원칙과-철학의-실무적용>#</a></h4><p>락 프로토콜 설계는 **안전성 (정확성)**과 <strong>성능 (동시성)</strong> 사이를 균형 있게 맞추는 작업이다.</p><p>세 가지 핵심 원칙은</p><ol><li><strong>보수성</strong>—의심스러우면 차단해 데이터 일관성을 지키고,</li><li><strong>최소 권한</strong>—필요한 대상·시간만 잠가 동시성을 살리며,</li><li><strong>공정성</strong>—특정 트랜잭션이 계속 밀리지 않도록 한다.</li></ol><p>설계 철학으로는 <strong>안전성 우선</strong>, <strong>단순성 추구</strong>, <strong>확장성 고려</strong>를 따르며, 실제로는 워크로드와 SLA 에 따라 이 원칙들을 적절히 조합하고 계량화된 지표 (P99 대기·데드락율 등) 로 운영해야 한다.</p><h5 id=핵심-원칙>핵심 원칙<a hidden class=anchor aria-hidden=true href=#핵심-원칙>#</a></h5><ol><li><p>보수성 원칙 (Conservatism Principle)</p><ul><li><strong>설명</strong>: 잠재적 충돌 가능성이 있으면 우선 차단 (대기 또는 거부) 함으로써 데이터 일관성을 우선시한다.</li><li><strong>목적 (무엇을 위한 것)</strong>: 무결성 손상·비일관 상태의 사전 예방.</li><li><strong>왜 필요한가</strong>: 분산·동시성 환경에서 작은 타이밍 차이로도 데이터 불일치가 발생하므로, 안전 쪽으로 기울여 사고 리스크를 줄여야 함.</li><li><strong>실무적 적용 예/영향</strong>: SERIALIZABLE 격리 수준, 엄격 2PL 등. 단점은 처리량 저하 → 서비스별 SLA 에 따라 완화 전략 필요.</li></ul></li><li><p>최소 권한 원칙 (Principle of Least Privilege)</p><ul><li><strong>설명</strong>: 트랜잭션은 필요한 최소한의 락만 (대상·기간 둘 다) 획득한다.</li><li><strong>목적</strong>: 락 보유 시간과 충돌 표면 최소화로 동시성 향상.</li><li><strong>왜 필요한가</strong>: 불필요한 락은 블로킹·데드락·스루풋 저하의 직접 원인.</li><li><strong>실무적 적용 예/영향</strong>: <code>SELECT … FOR UPDATE</code> 를 쓰기 시점에만 사용, 트랜잭션 경계 짧게 설계, 인덱스 최적화. 자동화로 잠금 분석·리팩터링 권장.</li></ul></li><li><p>공정성 원칙 (Fairness Principle)</p><ul><li><strong>설명</strong>: 락 획득/대기에서 기아 (starvation) 를 방지하고 가능한 한 공평한 서비스 제공을 보장한다.</li><li><strong>목적</strong>: 특정 트랜잭션의 지속적 차단 방지 → 가용성·응답성 유지.</li><li><strong>왜 필요한가</strong>: 우선순위 편향 · 반복 재시도로 인한 서비스 불균형과 SLA 위반을 막기 위함.</li><li><strong>실무적 적용 예/영향</strong>: aging(대기시간에 따른 우선순위 상승), 제한적 우선순위 정책 (비즈니스 우선 작업은 우선 처리). 공정성 강조 시 전체 처리율에 미세한 영향 존재.</li></ul></li></ol><h6 id=락-설계-핵심-원칙-요약표>락 설계 핵심 원칙 요약표<a hidden class=anchor aria-hidden=true href=#락-설계-핵심-원칙-요약표>#</a></h6><table><thead><tr><th>핵심 원칙</th><th>설명</th><th>목적 (무엇을 위한)</th><th>왜 필요한가 (근거)</th><th>실무 적용 예</th></tr></thead><tbody><tr><td>보수성 (Conservatism)</td><td>잠재 충돌시 우선 차단</td><td>무결성·정합성 보장</td><td>작은 불일치도 치명적 결과 초래 가능</td><td>엄격 격리 (SERIALIZABLE), S2PL</td></tr><tr><td>최소 권한 (Least Privilege)</td><td>필요한 최소 락만 획득</td><td>락 보유 시간/충돌 면적 최소화</td><td>불필요 락이 블로킹·데드락 유발</td><td><code>SELECT FOR UPDATE</code> 시점 국한</td></tr><tr><td>공정성 (Fairness)</td><td>기아 방지·평등한 기회 보장</td><td>서비스 안정성·응답성 확보</td><td>편향된 우선순위가 SLA 위반 유발</td><td>aging, 우선순위 제한 정책</td></tr></tbody></table><ul><li>세 원칙은 트레이드오프 관계: 보수성↑ → 동시성↓; 최소권한으로 완화 가능.</li><li>실무에서는 서비스 중요도 (예: 금융 vs 로그수집) 에 따라 우선순위를 정해 적용해야 한다.</li></ul><h5 id=설계-철학>설계 철학<a hidden class=anchor aria-hidden=true href=#설계-철학>#</a></h5><ol><li><p>안전성 우선 (Safety First)</p><ul><li><strong>설명</strong>: 데이터 정확성·무결성을 가장 우선시해 시스템을 설계한다.</li><li><strong>목적</strong>: 고객 신뢰·비즈니스 규칙 준수, 규제 요건 충족.</li><li><strong>왜 필요한가</strong>: 금융·의료 등에서 잘못된 데이터 한 건이 큰 피해로 이어지므로 일관성 확보가 최우선.</li><li><strong>실무적 적용</strong>: 강한 격리·트랜잭션 로그·엄격 복구 정책 채택. 단점: 성능 희생 → 필요시 부분 완화 전략 사용.</li></ul></li><li><p>단순성 추구 (Simplicity)</p><ul><li><strong>설명</strong>: 복잡한 잠금 로직보다 이해·운영·디버깅이 쉬운 설계를 선호한다.</li><li><strong>목적</strong>: 운영·유지보수 비용 절감, 문제 재현·해결 용이.</li><li><strong>왜 필요한가</strong>: 복잡한 정책은 버그·오해·운영사고를 유발하므로 실무에서 위험요인임.</li><li><strong>실무적 적용</strong>: 표준화된 트랜잭션 패턴·명확한 문서·자동화된 검사 도구.</li></ul></li><li><p>확장성 고려 (Scalability)</p><ul><li><strong>설명</strong>: 대량 트래픽·데이터 규모에서도 성능을 유지하거나 선형적으로 확장 가능한 설계 지향.</li><li><strong>목적</strong>: 성장하는 서비스에서 병목으로 인한 서비스 실패 방지.</li><li><strong>왜 필요한가</strong>: 초기에는 맞아도 규모가 커지면 락 경합이 전체 시스템을 죽일 수 있으므로 설계 초기부터 확장성 고려 필요.</li><li><strong>실무적 적용</strong>: 파티셔닝·샤딩·비관적·낙관적 혼용 등 아키텍처적 선택. 상충점: 확장성 강화는 설계 복잡성 증가 가능.</li></ul></li></ol><h6 id=락-설계-철학-요약표>락 설계 철학 요약표<a hidden class=anchor aria-hidden=true href=#락-설계-철학-요약표>#</a></h6><table><thead><tr><th>설계 철학</th><th>설명</th><th>목적 (무엇을 위한)</th><th>왜 필요한가 (근거)</th><th>실무 적용 예</th></tr></thead><tbody><tr><td>안전성 우선 (Safety First)</td><td>데이터 정확성·무결성 최우선</td><td>규제·신뢰성 확보</td><td>잘못된 데이터는 큰 리스크</td><td>엄격 격리·로그·검증 파이프라인</td></tr><tr><td>단순성 추구 (Simplicity)</td><td>이해·운영 쉬운 구조 선호</td><td>운영 오류·디버깅 최소화</td><td>복잡성은 사고 발생 원인</td><td>표준 트랜잭션 패턴, 문서화</td></tr><tr><td>확장성 고려 (Scalability)</td><td>규모 변화에 대응 가능한 설계</td><td>성장 시 병목 예방</td><td>락 경합은 시스템 전체 성능 저하</td><td>파티셔닝·샤딩·비동기화 설계</td></tr></tbody></table><ul><li>철학은 설계 <em>방향성</em>을 제공: 어떤 상황에서 안전을 택할지, 언제 단순성을 희생할지, 확장성을 어느 시점에 확보할지 결정하는 기준이 된다.</li><li>실제 설계는 철학 간 균형을 맞추는 작업이며, 이를 위해 계량화된 목표 (SLA·임계값) 를 사전에 정의해야 한다.</li></ul><h4 id=락-기본-동작과-운영-메커니즘>락 기본 동작과 운영 메커니즘<a hidden class=anchor aria-hidden=true href=#락-기본-동작과-운영-메커니즘>#</a></h4><ul><li>트랜잭션이 데이터를 읽거나 쓰려면 <strong>락을 먼저 요청</strong>한다. 락 매니저는 현재 보유 락과의 <strong>호환성</strong>을 검사해 즉시 허용하거나 대기시킨다.</li><li>2PL 규칙을 따르면 트랜잭션은 먼저 필요한 락을 모으고 (획득 단계), 모든 연산이 끝난 뒤 락을 푼다 (해제 단계).</li><li><strong>문제 상황</strong>: 동시에 여러 트랜잭션이 충돌하면 대기·데드락이 발생한다. 이를 잡기 위해 <strong>대기 큐 정책, 데드락 탐지 (그래프), 타임아웃/재시도</strong> 같은 운영 장치가 필요하다.</li><li>요약: 기본은 " 요청 → 검사 → 부여/대기 → 해제 " 의 단순 루프지만, 실제는 승격/에스컬레이션·범위락·분산 이슈로 복잡해진다.</li></ul><h5 id=락-기본-메커니즘>락 기본 메커니즘<a hidden class=anchor aria-hidden=true href=#락-기본-메커니즘>#</a></h5><ol><li><p><strong>락 라이프사이클</strong></p><ul><li>요청 (Request) → 호환성 검사 (Check) → Granted/Blocked → (대기 중) Wakeup → 사용 (Access) → 해제 (Release).</li><li>락은 단일 자원 (행) 뿐 아니라 계층 (테이블/페이지/행) 에서 관리된다. Intent 락은 계층적 충돌 판단을 돕는다.</li></ul></li><li><p><strong>2 단계 락킹 (2PL) 이 제공하는 보장</strong></p><ul><li>모든 트랜잭션이 2PL 을 따를 때 스케줄은 직렬화 가능. Strict 2PL 은 회복성을 보강 (쓰기 락을 커밋까지 유지).</li></ul></li><li><p><strong>락 모드 전환 (U → X 등)</strong></p><ul><li>읽기 후 쓰기 상황에서 U(업데이트) 락을 먼저 잡아 데드락 가능성 감소. 승격 시 호환성 재평가 필요.</li></ul></li><li><p><strong>데드락 탐지 vs 예방</strong></p><ul><li>탐지: wait-for 그래프에서 사이클 찾고 희생자 선정.</li><li>예방: 자원 획득 순서 강제, 타임아웃, 또는 낙관적 동시성 사용.</li></ul></li><li><p><strong>운영 고려사항</strong></p><ul><li>배치·대량 작업은 에스컬레이션을 유발하므로 분할·파티셔닝 권장.</li><li>모니터링 (락 대기시간, wait chains) 과 알림은 운영 안정성 핵심.</li></ul></li></ol><h6 id=락-기본-메커니즘-요약표>락 기본 메커니즘 요약표<a hidden class=anchor aria-hidden=true href=#락-기본-메커니즘-요약표>#</a></h6><table><thead><tr><th>메커니즘</th><th style=text-align:right>목적</th><th>핵심 동작</th><th>운영 고려사항</th><th>예시</th></tr></thead><tbody><tr><td>락 요청 & 호환성 검사</td><td style=text-align:right>안전한 동시 접근 허용/차단</td><td>매니저가 호환성 매트릭스 검사 후 즉시 부여/대기</td><td>경쟁 심하면 대기 큐 성장 → 타임아웃 필요</td><td>T1:X lock → T2:S lock 요청 시 대기</td></tr><tr><td>대기 큐 관리</td><td style=text-align:right>공정성/성능 제어</td><td>FIFO/우선순위 등 정책 적용</td><td>잘못된 정책은 starvation 초래</td><td>우선순위 높은 txn 먼저 처리</td></tr><tr><td>데드락 탐지</td><td style=text-align:right>순환 대기 복구</td><td>wait-for 그래프 사이클 탐지 → 희생자 롤백</td><td>탐지 주기·희생자 기준 튜닝 필요</td><td>2 txn 상호 대기 → one rolled back</td></tr><tr><td>락 승격/에스컬레이션</td><td style=text-align:right>메모리 절약/쓰기 준비</td><td>다수 행락 → 페이지/테이블 락으로 묶음</td><td>동시성 저하 위험 → 배치 분할 권장</td><td>대량 업데이트 시 테이블 락 발생</td></tr><tr><td>2PL (Growing/Shrinking)</td><td style=text-align:right>직렬성 보장</td><td>Growing: 획득만, Shrinking: 해제만</td><td>Strict 2PL → 커밋까지 락 유지 (복구성↑)</td><td>표준 트랜잭션 흐름</td></tr><tr><td>범위/갭 락</td><td style=text-align:right>팬텀 방지</td><td>인덱스 범위를 잠가 삽입 차단</td><td>인덱스 부재 시 범위 확대로 성능 저하</td><td>범위 쿼리에서 삽입 차단</td></tr><tr><td>타임아웃·재시도</td><td style=text-align:right>무한 대기 방지</td><td>일정시간 초과 시 실패/재시도</td><td>재시도는 전체 부하 증가 유발</td><td>타임아웃 후 exponential backoff</td></tr></tbody></table><p>기본 동작은 단순하지만, 운영 환경에서는 락 승격·범위 락·데드락 탐지·대기 정책 등 다양한 메커니즘이 서로 얽혀 시스템 거동을 결정한다. 각 항목은 성능·안정성 사이 트레이드오프를 내포하므로 정책·파라미터 튜닝이 핵심이다.</p><h5 id=락-획득---대기---해제-흐름도>락 획득 - 대기 - 해제 흐름도<a hidden class=anchor aria-hidden=true href=#락-획득---대기---해제-흐름도>#</a></h5><pre class=mermaid>sequenceDiagram
    participant T as Transaction
    participant LM as LockManager
    participant DB as Database
    participant NET as Consensus (optional)
    T-&gt;&gt;LM: Request Lock(mode, resource)
    LM-&gt;&gt;LM: Check compatibility
    alt Compatible
        LM--&gt;&gt;T: Grant Lock
        T-&gt;&gt;DB: Operation
        T-&gt;&gt;LM: Release or Commit
        LM--&gt;&gt;LM: Wakeup waiting
        opt Lock Escalation condition met
            LM-&gt;&gt;LM: Escalate locks (row-&gt;table)
            LM--&gt;&gt;All: Adjust grants
        end
    else Conflict
        LM--&gt;&gt;T: Enqueue in WaitQueue
        LM-&gt;&gt;LM: Start deadlock detector / timeout timer
        alt Deadlock found
            LM-&gt;&gt;Victim: Abort victim
            LM--&gt;&gt;Waiting: Grant next
        else Timeout expired
            LM--&gt;&gt;T: Return timeout error or retry
        end
    end
    opt Distributed LM
        LM-&gt;&gt;NET: Request consensus for grant/lease
        NET--&gt;&gt;LM: Grant/Reject based on quorum
    end
</pre><ul><li>트랜잭션은 락 매니저에 모드와 자원 (행/테이블/키) 을 요청한다.</li><li>락 매니저는 <strong>호환성 검사</strong>를 먼저 수행한다. 호환되면 즉시 부여, 충돌이면 대기 큐에 넣는다.</li><li>대기 큐에 들어가면 <strong>데드락 탐지</strong>(wait-for 그래프) 와 <strong>타임아웃 타이머</strong>가 병행으로 동작한다. 데드락이 발견되면 희생자를 골라 롤백하고 락을 재분배한다. 타임아웃이 만료되면 트랜잭션은 오류 또는 재시도 정책에 따라 동작.</li><li>락 승격 (U→X) 이나 <strong>락 에스컬레이션</strong>(행→테이블) 은 별도 조건에서 발생하며, 에스컬레이션 시 동시성에 큰 영향을 준다.</li><li>분산 환경이면 락 부여 시 <strong>합의 (Consensus)</strong> 절차 (leader, quorum 호출) 가 추가되어 네트워크 레이턴시 영향이 중요해진다.</li></ul><h4 id=트랜잭션락의-데이터제어-흐름-총괄>트랜잭션·락의 데이터·제어 흐름 총괄<a hidden class=anchor aria-hidden=true href=#트랜잭션락의-데이터제어-흐름-총괄>#</a></h4><p>트랜잭션은 데이터에 접근하기 전에 락을 요청하고, 락 관리자는 현재 이미 걸린 락들과의 <strong>호환성</strong>을 검사해 즉시 허용하거나 대기시킨다.<br>트랜잭션이 길게 유지되면 다른 트랜잭션이 기다리게 되고, 서로 기다리는 상황이 원형으로 이어지면 데드락이 발생한다.<br>데드락은 그래프 기반으로 탐지하여 한 트랜잭션을 희생자로 선택해 롤백함으로써 풀린다.<br>읽기는 보통 Shared 락을, 쓰기는 Exclusive 락을 요구하며, 많은 행을 잠그면 시스템이 자동으로 <strong>락 에스컬레이션</strong>(행→페이지→테이블) 을 해 성능에 영향을 미친다.<br>MVCC 를 사용하는 DB 는 읽기 작업을 스냅샷으로 처리해 읽기 - 쓰기 충돌을 피하기도 한다.</p><h5 id=데이터제어-흐름-트랜잭션과-락>데이터·제어 흐름: 트랜잭션과 락<a hidden class=anchor aria-hidden=true href=#데이터제어-흐름-트랜잭션과-락>#</a></h5><ul><li><strong>요청 단계</strong>: 트랜잭션이 리소스 접근 시 <code>LOCK_REQ(mode, resource)</code> 를 락 관리자에 보냄.</li><li><strong>검사 단계</strong>: 락 관리자는 Lock Table 에서 해당 리소스의 현재 보유 목록을 조회하고 Compatibility Matrix(요청모드 × 보유모드) 를 참조.</li><li><strong>결정 단계</strong>:<ul><li><strong>허용 (GRANT)</strong>: 락 테이블에 요청 트랜잭션을 추가 (보유 목록 갱신) → 트랜잭션 진행.</li><li><strong>대기 (QUEUE)</strong>: 대기 큐에 삽입 → wait-for 그래프에 에지 추가 → 데드락 탐지 대상.</li></ul></li><li><strong>실행 단계</strong>: 트랜잭션은 읽기/쓰기 작업 수행. 쓰기 로그 (undo/redo) 관리와 함께 변경을 준비.</li><li><strong>완료 단계</strong>: COMMIT 시 쓰기 변경을 확정 (로그 flush 등) → 락 해제 (Strict 2PL 이면 커밋 시점까지 유지) → 해제된 리소스에 대해 대기 큐 재검사 및 다음 후보 GRANT. ROLLBACK 시 undo 처리 후 락 해제.</li><li><strong>운영 요소</strong>: lock escalation, lock conversion, timeout 정책, deadlock detector(주기적/이벤트), 모니터링 (대기 통계, deadlock graphs), MVCC 분기 (읽기는 스냅샷 경로로 처리).</li></ul><h6 id=트랜잭션---락-단계별-제어-표>트랜잭션 - 락 단계별 제어 표<a hidden class=anchor aria-hidden=true href=#트랜잭션---락-단계별-제어-표>#</a></h6><table><thead><tr><th style=text-align:right>단계</th><th>트랜잭션 행동</th><th>락 관리자 (동작)</th><th>주사용 자료구조</th><th>주의/운영 포인트</th></tr></thead><tbody><tr><td style=text-align:right>요청 (Request)</td><td>LOCK_REQ(mode, resource)</td><td>Lock Table 조회 → Compatibility 검사</td><td>Lock Table, Compatibility Matrix</td><td>mode 선택 (격리수준) 정확도</td></tr><tr><td style=text-align:right>결정 (Grant/Queue)</td><td>즉시 진행 또는 대기</td><td>GRANT → 보유목록 갱신 / QUEUE → 대기큐 삽입</td><td>보유 목록, 대기 큐</td><td>우선순위·타임아웃 정책</td></tr><tr><td style=text-align:right>실행 (Execute)</td><td>Read/Write 수행</td><td>(보조) lock conversion, version 관리 (MVCC)</td><td>Undo/Redo, 버전 스토어</td><td>긴 트랜잭션 금지</td></tr><tr><td style=text-align:right>완료 (Commit)</td><td>COMMIT/ROLLBACK</td><td>COMMIT → 락 해제 / ROLLBACK → undo 후 해제</td><td>로그, Lock Table 업데이트</td><td>Strict 2PL 여부 (해제 시점)</td></tr><tr><td style=text-align:right>데드락 탐지</td><td>—</td><td>Wait-for Graph 분석 → 사이클 탐지 → 희생자 선정</td><td>Wait-for Graph, Deadlock Log</td><td>탐지 주기와 비용 조절</td></tr><tr><td style=text-align:right>확장 (에스컬레이션)</td><td>다수 행 잠금 발생</td><td>자동으로 에스컬레이션 (Row→Page→Table)</td><td>에스컬레이션 카운터</td><td>파티셔닝·배치로 제어 필요</td></tr></tbody></table><ul><li>트랜잭션은 락 요청 → 락 관리자의 호환성 판단 → (GRANT/QUEUE) → 실행 → 커밋/롤백 시 락 해제의 순으로 흐른다. 운영에서는 대기 시간, 데드락 빈도, 에스컬레이션 발생 빈도를 핵심 지표로 삼아 튜닝한다.</li></ul><h5 id=락-요청결정해제-전체-흐름도>락 요청·결정·해제 전체 흐름도<a hidden class=anchor aria-hidden=true href=#락-요청결정해제-전체-흐름도>#</a></h5><pre class=mermaid>flowchart TD
  subgraph TX [트랜잭션 측]
    T1[BEGIN TRANSACTION] --&gt; Req[&#34;LOCK_REQ(mode, resource)&#34;]
    Req --&gt; WaitCheck
    Exec[Execute Read/Write] --&gt; Commit[COMMIT/ROLLBACK]
  end

  subgraph LM [Lock Manager]
    WaitCheck{호환성 검사} --&gt;|허용| Grant[GRANT -&gt; 보유목록 갱신]
    WaitCheck --&gt;|불허| Queue[대기큐 삽입 -&gt; wait-for 그래프 업데이트]
    Queue --&gt; DeadDetect[데드락 탐지기]
    DeadDetect --&gt;|사이클| Victim[희생자 선정 -&gt; ROLLBACK 신호]
    Grant --&gt; Signal[락 해제 시 신호 -&gt; 대기큐 재검사]
    Signal --&gt; WaitCheck
    Grant --&gt; Exec
  end

  Commit --&gt;|락 해제| Signal
  Victim --&gt;|롤백 신호| Rollback[트랜잭션 롤백]
  Rollback --&gt; Signal

  subgraph Ops [운영 요소]
    Metrics[대기 통계/Deadlock 로그] --&gt; LM
    Escalation[Lock Escalation 임계치] --&gt; LM
    Timeout[Lock Timeout 정책] --&gt; LM
  end
</pre><ul><li>트랜잭션은 락 요청을 보내고 락 관리자는 <strong>호환성 검사</strong>로 즉시 허용 또는 대기시킨다. 대기된 트랜잭션은 wait-for 그래프에 반영되어 데드락 탐지기의 주기 검사 대상이 된다. 데드락 시 희생자가 선정되어 롤백 신호가 전달되고, 롤백 후 락이 해제되어 대기 큐의 다음 후보가 재검사된다. 운영 요소 (메트릭, 에스컬레이션 임계치, 타임아웃) 는 Lock Manager 의 정책에 직접 영향을 미친다. MVCC 환경에서는 읽기 경로가 스냅샷으로 분기되어 읽기 락을 회피한다.</li></ul><h5 id=트랜잭션-생명주기와-락-상태-전이>트랜잭션 생명주기와 락 상태 전이<a hidden class=anchor aria-hidden=true href=#트랜잭션-생명주기와-락-상태-전이>#</a></h5><pre class=mermaid>stateDiagram-v2
  [*] --&gt; Active: BEGIN TRANSACTION
  Active --&gt; Waiting: LOCK_REQ -&gt; QUEUE (대기중)
  Active --&gt; Executing: LOCK_GRANTED -&gt; Execute
  Executing --&gt; PartiallyCommitted: COMMIT (로그 flush)
  PartiallyCommitted --&gt; Committed: 락 해제 완료
  Active --&gt; Failed: 오류 발생
  Failed --&gt; Aborted: ROLLBACK (undo)
  Aborted --&gt; [*]: 정리 완료
  Committed --&gt; [*]: 정리 완료
</pre><ul><li>Active 상태에서 락이 즉시 허용되면 Executing 으로 가서 실제 작업을 수행한다. 락이 허용되지 않으면 Waiting 상태로 들어가며, 이때 타임아웃 또는 데드락 탐지로 롤백될 수 있다. COMMIT 시 필요한 작업 (로그 flush) 이 수행되고 락이 해제되면서 PartiallyCommitted→Committed 로 전이된다. MVCC 가 적용된 읽기 트랜잭션은 Waiting 을 거치지 않고 스냅샷을 사용해 바로 Executing 으로 진입하는 점이 핵심 차이이다.</li></ul><h4 id=운영성능을-고려한-락-시스템-아키텍처>운영·성능을 고려한 락 시스템 아키텍처<a hidden class=anchor aria-hidden=true href=#운영성능을-고려한-락-시스템-아키텍처>#</a></h4><p>락 시스템은 트랜잭션이 데이터에 접근하려 할 때 " 누가, 어떤 권한으로, 얼마나 오래 " 그 자원을 점유하는지를 중앙에서 관리한다. Lock Manager 가 요청을 받고 Compatibility Matrix 로 판단한 뒤 허용되면 Lock Table(LCB) 에 기록, 거부되면 Wait Queue 에 넣는다. 대기 중인 트랜잭션들이 서로 순환하면 Waits-For Graph 를 통해 Deadlock Detector 가 이를 찾아 희생자를 고른다. 에스컬레이션은 많은 작은 락을 하나로 합쳐 메모리·관리부담을 줄이지만 동시성은 떨어뜨린다. 운영자는 Monitoring 을 통해 대기·데드락·에스컬레이션 지표를 상시 관찰해야 한다.</p><h5 id=안정적-락-구조-설계-원칙>안정적 락 구조 설계 원칙<a hidden class=anchor aria-hidden=true href=#안정적-락-구조-설계-원칙>#</a></h5><ul><li>트랜잭션 → Lock 요청 → Lock Manager → Lock Table(허용/거부) → Wait Queue(대기) → Deadlock Detector(사이클 탐지) → Transaction Manager(롤백/복구). Monitoring 은 전체를 관찰한다.</li></ul><h6 id=락-구조별-역할기능-요약>락 구조별 역할·기능 요약<a hidden class=anchor aria-hidden=true href=#락-구조별-역할기능-요약>#</a></h6><table><thead><tr><th>구조 요소</th><th>역할</th><th style=text-align:right>주요 기능</th><th>특징</th><th>상호관계</th></tr></thead><tbody><tr><td>Lock Manager</td><td>중앙 통제</td><td style=text-align:right>request/release/escalate</td><td>고동시성 경로</td><td>Lock Table, Compatibility Matrix, Deadlock Detector</td></tr><tr><td>Lock Table</td><td>상태 저장</td><td style=text-align:right>레코드 CRUD, owners list</td><td>메모리 중심, GC 필요</td><td>LCB, Resource Hash, Wait Queue</td></tr><tr><td>Lock Control Block</td><td>엔트리 메타</td><td style=text-align:right>owners, wait_queue_ptr</td><td>캐시 친화적 설계 필요</td><td>Lock Table 내부</td></tr><tr><td>Wait Queue</td><td>대기 관리</td><td style=text-align:right>enqueue/dequeue, priority</td><td>정책이 성능 좌우</td><td>LCB, Deadlock Detector</td></tr><tr><td>Waits-For Graph</td><td>의존성 모델</td><td style=text-align:right>edge add/remove, cycle detect</td><td>실시간 비용 트레이드오프</td><td>Wait Queue 업데이트 시 변경</td></tr><tr><td>Deadlock Detector</td><td>탐지·복구</td><td style=text-align:right>cycle detection, victim select</td><td>탐지 빈도·정책 중요</td><td>Transaction Manager(rollback)</td></tr><tr><td>Escalation Controller</td><td>에스컬레이션 제어</td><td style=text-align:right>threshold check, escalate</td><td>동시성 vs 관리 비용 트레이드오프</td><td>Lock Table, Monitoring</td></tr><tr><td>Compatibility Matrix</td><td>허용 판정</td><td style=text-align:right>mode x mode lookup</td><td>Intent/Range 통합 필요</td><td>Lock Manager 핵심 입력</td></tr><tr><td>Monitoring</td><td>운영 관측</td><td style=text-align:right>expose metrics, alerts</td><td>낮은 오버헤드 필수</td><td>전 컴포넌트 데이터 수집</td></tr></tbody></table><p>각 구조 요소는 역할이 분명하며 상호작용을 통해 락 획득·대기·복구 흐름을 만든다. 설계 시 내부 동시성·메모리·탐지 정책 세부 튜닝이 전체 성능을 좌우한다.</p><h6 id=구조별-설계운영-고려사항>구조별 설계·운영 고려사항<a hidden class=anchor aria-hidden=true href=#구조별-설계운영-고려사항>#</a></h6><table><thead><tr><th>구조 요소</th><th>설계 고려사항</th><th style=text-align:right>운영 지표</th><th>실패 시 영향</th></tr></thead><tbody><tr><td>Lock Manager</td><td>버킷 락/락 - 프리, 경합 최소화</td><td style=text-align:right>avg request latency</td><td>전체 TPS 저하</td></tr><tr><td>Lock Table</td><td>해시 크기·리샤딩, GC 정책</td><td style=text-align:right>LCB count, mem usage</td><td>OOM, 탐색 지연</td></tr><tr><td>LCB</td><td>compact layout, reference count</td><td style=text-align:right>avg owners per resource</td><td>메모리·캐시 비효율</td></tr><tr><td>Wait Queue</td><td>priority vs FIFO, spin/block</td><td style=text-align:right>queue length, wait time</td><td>긴 블로킹</td></tr><tr><td>Deadlock Detector</td><td>detection frequency, victim policy</td><td style=text-align:right>deadlock_rate, detect_time</td><td>장기 블로킹</td></tr><tr><td>Escalation Ctrl</td><td>threshold, exception rules</td><td style=text-align:right>escalation_count</td><td>동시성 급락</td></tr><tr><td>Compatibility Matrix</td><td>static vs dynamic rules</td><td style=text-align:right>lookup latency</td><td>잘못된 허용/거부</td></tr><tr><td>Monitoring</td><td>수집 주기, 노출 포맷</td><td style=text-align:right>metric freshness</td><td>진단 불가</td></tr></tbody></table><p>설계 단계에서 각 구조 요소의 내부 구현 방식과 운영 지표를 미리 정하면 장애 대응·튜닝 속도가 빨라진다.</p><h6 id=락-시스템-상호작용-구조도>락 시스템 상호작용 구조도<a hidden class=anchor aria-hidden=true href=#락-시스템-상호작용-구조도>#</a></h6><pre class=mermaid>flowchart TB
  subgraph AppLayer
    TM[Transaction Manager]
    QP[Query Processor]
  end

  subgraph ConcurrencyLayer
    LM[Lock Manager]
    CM[Compatibility Matrix]
    IH[Intent Handler]
    LT[Lock Table]
    LCB[Lock Control Block]
    WQ[Wait Queue]
    WFG[Waits-For Graph]
    DD[Deadlock Detector]
    EC[Escalation Controller]
  end

  subgraph StorageLayer
    BM[Buffer Manager]
    LG[Log Manager]
    SE[Storage Engine]
  end

  subgraph Monitoring
    MET[Metrics Collector]
    DASH[Dashboard/Alerts]
  end

  TM --&gt;|lock request| LM
  QP --&gt;|lock request| LM
  LM --&gt; CM
  LM --&gt; IH
  LM --&gt; LT
  LT --&gt; LCB
  LCB --&gt; WQ
  WQ --&gt; WFG
  WFG --&gt; DD
  LM --&gt; EC
  LM --&gt; BM
  BM --&gt; SE
  LG --&gt; SE
  LT --&gt; MET
  WQ --&gt; MET
  DD --&gt; MET
  MET --&gt; DASH
</pre><ul><li>트랜잭션/쿼리 계층이 Lock Manager 에 요청을 보낸다.</li><li>Lock Manager 는 Compatibility Matrix 와 Intent Handler 로 판정 후 Lock Table(LCB) 에 기록하거나 Wait Queue 에 등록한다. Wait Queue 변경은 Waits-For Graph 를 갱신하며 Deadlock Detector 가 이를 검사한다. Escalation Controller 는 필요 시 Lock Table 의 여러 LCB 를 합쳐 상위 락으로 전환한다. Monitoring 계층은 Lock Table/Wait Queue/Deadlock 이벤트를 수집해 Dashboard 로 노출한다.</li></ul><h5 id=운영-중심-락-구성요소-속성>운영 중심 락 구성요소 속성<a hidden class=anchor aria-hidden=true href=#운영-중심-락-구성요소-속성>#</a></h5><ul><li><strong>Lock Table</strong>: " 누가 어떤 자원을 점유 중인지 " 를 기록하는 테이블.</li><li><strong>LCB</strong>: 각 자원 한 줄 (레코드) 의 메타데이터 (소유자·대기자 등).</li><li><strong>Wait Queue</strong>: 권한을 못 받은 요청들이 줄 서는 곳.</li><li><strong>Deadlock Detector</strong>: 서로 기다리는 순환을 찾아 해결사 (희생자) 를 고른다.</li><li><strong>Escalation Controller</strong>: 많은 작은 락을 합쳐 관리 부담 줄이는 역할.</li><li><strong>Compatibility Matrix</strong>: 어떤 모드끼리 공존 가능한지 적힌 표.</li><li><strong>Monitoring</strong>: 운영자가 상황을 보는 창.</li></ul><h6 id=구성요소-상세-속성표>구성요소 상세 속성표<a hidden class=anchor aria-hidden=true href=#구성요소-상세-속성표>#</a></h6><table><thead><tr><th>구성 요소</th><th>설명</th><th>역할</th><th style=text-align:right>기능</th><th>특징</th><th>상호관계</th><th style=text-align:right>필수/선택</th><th>속한 구조</th></tr></thead><tbody><tr><td>Lock Table</td><td>상태 저장소</td><td>리소스 상태 관리</td><td style=text-align:right>entry CRUD, stats</td><td>메모리 중심</td><td>Lock Manager, LCB</td><td style=text-align:right>필수</td><td>ConcurrencyLayer</td></tr><tr><td>LCB</td><td>엔트리 메타</td><td>owners·wait ptr 관리</td><td style=text-align:right>owners list, counters</td><td>compact 필요</td><td>Lock Table, Wait Queue</td><td style=text-align:right>필수</td><td>ConcurrencyLayer</td></tr><tr><td>Wait Queue</td><td>대기 목록</td><td>요청 순서 관리</td><td style=text-align:right>enqueue/dequeue</td><td>우선정책 영향</td><td>LCB, Deadlock Detector</td><td style=text-align:right>필수</td><td>ConcurrencyLayer</td></tr><tr><td>Deadlock Detector</td><td>탐지·복구</td><td>사이클 탐지·victim select</td><td style=text-align:right>DFS/algos</td><td>탐지 비용 존재</td><td>Waits-For Graph, TM</td><td style=text-align:right>필수</td><td>ConcurrencyLayer</td></tr><tr><td>Escalation Ctrl</td><td>에스컬레이션</td><td>threshold 기반 변환</td><td style=text-align:right>escalate, events</td><td>동시성 영향</td><td>Lock Table, Monitoring</td><td style=text-align:right>권장</td><td>ConcurrencyLayer</td></tr><tr><td>Compatibility Matrix</td><td>모드 표</td><td>허용 판단</td><td style=text-align:right>lookup</td><td>Intent 포함 필요</td><td>Lock Manager</td><td style=text-align:right>필수</td><td>ConcurrencyLayer</td></tr><tr><td>Intent Handler</td><td>의도 락 처리</td><td>계층 판정 최적화</td><td style=text-align:right>intent set/clear</td><td>계층 락 전용</td><td>Lock Manager, LT</td><td style=text-align:right>필수 (계층사용)</td><td>ConcurrencyLayer</td></tr><tr><td>Monitoring API</td><td>계측/노출</td><td>지표 제공</td><td style=text-align:right>metrics, alerts</td><td>저오버헤드 요구</td><td>전 컴포넌트</td><td style=text-align:right>필수</td><td>Monitoring</td></tr></tbody></table><p>구성 요소들은 필수적 요소와 권장 요소로 구분되며, Lock Manager 와 Lock Table 을 중심으로 Wait Queue·Deadlock Detector 가 문제 감지/해결 루프를 형성한다. Escalation Controller 와 Monitoring 은 운영 안정성·가시성에 필수적이다.</p><h6 id=구성요소-운영보안-고려표>구성요소 운영·보안 고려표<a hidden class=anchor aria-hidden=true href=#구성요소-운영보안-고려표>#</a></h6><table><thead><tr><th>구성 요소</th><th>구현 고려사항</th><th style=text-align:right>운영 지표</th><th>확장성 이슈</th><th>보안/권한</th></tr></thead><tbody><tr><td>Lock Table</td><td>리샤딩, persistence</td><td style=text-align:right>LCB 수, mem usage</td><td>노드 분산 시 동기화</td><td>조회 권한 통제</td></tr><tr><td>LCB</td><td>compact layout</td><td style=text-align:right>avg owners</td><td>캐시 미스</td><td>내부 정보 보호</td></tr><tr><td>Wait Queue</td><td>priority policy</td><td style=text-align:right>queue length</td><td>분할 운영</td><td>DoS 방지</td></tr><tr><td>Deadlock Detector</td><td>detect freq</td><td style=text-align:right>detect_time</td><td>분산 그래프 합병</td><td>로그 접근 제어</td></tr><tr><td>Escalation Ctrl</td><td>threshold tuning</td><td style=text-align:right>escalation_count</td><td>정책 불일치</td><td>임계치 변경 권한</td></tr><tr><td>Monitoring</td><td>collection cost</td><td style=text-align:right>metric freshness</td><td>중앙 vs 샤드</td><td>민감정보 마스킹</td></tr></tbody></table><p>운영/보안/확장성 요소는 설계 초기부터 고려해야 하며, 특히 분산 환경에서는 Lock Table/Deadlock Detector 의 분산 합의·합병 전략이 중요하다.</p><h6 id=구성요소-상호작용-구성도>구성요소 상호작용 구성도<a hidden class=anchor aria-hidden=true href=#구성요소-상호작용-구성도>#</a></h6><pre class=mermaid>graph LR
  TM[Transaction Manager]
  LM[Lock Manager]
  LT[Lock Table]
  LCB[&#34;LCB (entries)&#34;]
  WQ[Wait Queue]
  WFG[Waits-For Graph]
  DD[Deadlock Detector]
  EC[Escalation Controller]
  CM[Compatibility Matrix]
  IH[Intent Handler]
  MET[Metrics Collector]

  TM --&gt;|request/release| LM
  LM --&gt; CM
  LM --&gt; IH
  LM --&gt; LT
  LT --&gt; LCB
  LCB --&gt; WQ
  WQ --&gt; WFG
  WFG --&gt; DD
  LM --&gt; EC
  LT --&gt; MET
  WQ --&gt; MET
  DD --&gt; MET
  EC --&gt; MET
</pre><ul><li>트랜잭션은 Lock Manager 에 요청/해제를 전달한다. Lock Manager 는 Compatibility Matrix 와 Intent Handler 로 판정하여 Lock Table(LCB) 을 업데이트하거나 Wait Queue 로 보낸다. Wait Queue 는 Waits-For Graph 의 간선 정보를 생성하고 Deadlock Detector 가 이를 검사한다. Escalation Controller 는 Lock Table 의 상태를 모니터링해 에스컬레이션 수행 여부를 결정한다. 모든 핵심 이벤트는 Metrics Collector 에 집계된다.</li></ul><h3 id=특성-분석-및-평가>특성 분석 및 평가<a hidden class=anchor aria-hidden=true href=#특성-분석-및-평가>#</a></h3><h4 id=락-프로토콜의-실무적-장점-분석>락 프로토콜의 실무적 장점 분석<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-실무적-장점-분석>#</a></h4><p>락 기반 프로토콜은 트랜잭션 간 충돌을 제어해 데이터의 **정확성 (직렬성)**과 <strong>무결성</strong>을 보장하는 전통적 수단이다.<br>2PL 계열은 충돌을 이론적으로 막아주고, S2PL 은 복구를 단순화한다.<br>실무에서는 이점 (무결성·예측성·운영 가시성) 을 얻는 대신 동시성·응답성 저하라는 비용을 지불한다. 따라서 중요한 경로에는 락 기반 엄격성을 적용하고, 처리량이 민감한 경로에는 인덱스·샤딩·낙관적 기법으로 보완하는 하이브리드 전략이 일반적이다.</p><h5 id=락-프로토콜-장점근거실무효과표>락 프로토콜 장점·근거·실무효과표<a hidden class=anchor aria-hidden=true href=#락-프로토콜-장점근거실무효과표>#</a></h5><table><thead><tr><th>장점</th><th>기술적 근거</th><th>실무 효과 / 예시</th><th>적용 상황</th><th>주의 및 완화책</th></tr></thead><tbody><tr><td>직렬성 보장</td><td>Two-Phase Locking(2PL) 이론</td><td>금융 이체: 동시성 있어도 정합성 유지</td><td>강한 무결성 요구 시스템</td><td>처리량 저하 → 파티셔닝/낙관적 보완</td></tr><tr><td>데이터 무결성 확보</td><td>호환성 매트릭스 (Grant/Wait)</td><td>재고 감소·결제 로직의 정확성 확보</td><td>OLTP, 회계·정산</td><td>인덱스 없으면 범위락 확대 → 인덱스 최적화</td></tr><tr><td>구현 단순성</td><td>공유/전용 락 + 대기 큐 모델</td><td>문제 재현·디버깅 쉬움 → 운영 MTTR 단축</td><td>전통 RDBMS 중심 환경</td><td>분산·대규모 한계 → 하이브리드 필요</td></tr><tr><td>연쇄 롤백 방지</td><td>Strict 2PL (X 락 커밋까지 유지)</td><td>장애 시 롤백 전파 차단, 복구 단순화</td><td>복구 중요 시스템</td><td>동시성 저하 → 부분 적용 권장</td></tr><tr><td>운영 정책 유연성</td><td>MGL·에스컬레이션·타임아웃 기능</td><td>배치/OLTP 혼재에서 튜닝 유연성</td><td>엔터프라이즈 환경</td><td>정책 실패 시 경합 증가 → 시뮬레이션 필요</td></tr><tr><td>데드락 감지·회복</td><td>wait-for 그래프, 희생자 선택</td><td>자동 회복 → 서비스 가용성 유지</td><td>고동시성 OLTP</td><td>잦은 데드락은 비용↑ → 구조적 개선 필요</td></tr><tr><td>운영 가시성</td><td>Lock Manager·DMV 제공</td><td>블로킹/Top-blocker 식별로 빠른 대응</td><td>운영 모니터링 중요 환경</td><td>모니터링 오버헤드 관리 필요</td></tr><tr><td>분산 적용 가능성</td><td>분산 2PL + 2PC 조합</td><td>샤드 간 트랜잭션 일관성 확보</td><td>분산 DB, 마이크로서비스</td><td>높은 지연·가용성 비용 → 대안 검토</td></tr></tbody></table><ul><li>락 프로토콜은 <strong>데이터 정합성·운영 예측성</strong>을 확실히 보장해 중요한 비즈니스 로직에 필수적이다.</li><li>반면 <strong>동시성·성능 비용</strong>이 수반되므로 적용 범위를 엄밀히 정하고, 인덱스·파티셔닝·낙관적 기법 등으로 보완해 하이브리드 전략을 취하는 것이 실무 핵심이다.</li></ul><h4 id=락-프로토콜-단점운영-제약>락 프로토콜 단점·운영 제약<a hidden class=anchor aria-hidden=true href=#락-프로토콜-단점운영-제약>#</a></h4><p>락은 데이터 무결성·직렬성을 보장하지만 비용이 든다. 락을 관리하려면 메모리·CPU·대기 시간이 늘어나고, 잘못 설계하면 데드락·성능 병목이 생긴다.<br>실무에서는<br><strong>(1) 락 범위 줄이기 (인덱스·쿼리 최적화)</strong><br><strong>(2) 트랜잭션 짧게 유지 (중간 커밋/배치)</strong><br><strong>(3) 데드락 예방·탐지 정책 (자원 정렬·타임아웃·탐지)</strong><br><strong>(4) 필요 시 MVCC/낙관적 제어 또는 샤딩으로 아키텍처 전환</strong><br>을 통해 문제를 완화한다.</p><h5 id=락-프로토콜의-주요-단점-표>락 프로토콜의 주요 단점 표<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-주요-단점-표>#</a></h5><table><thead><tr><th>단점</th><th>상세 설명</th><th>원인</th><th>실무 문제</th><th>완화/해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>성능 오버헤드</td><td>락 획득·해제·관리 비용으로 응답 지연 발생</td><td>락 테이블·동기화 비용, 컨텐션</td><td>TPS 감소, 응답 시간 증가</td><td>인덱스 최적화, 락 그레뉼러리티 축소, 배치</td><td>MVCC, OCC, Lock-free</td></tr><tr><td>데드락 가능성</td><td>상호 대기 (원형) 로 트랜잭션 정지</td><td>자원 획득 순서 불일치</td><td>트랜잭션 롤백·재시도, 작업 손실</td><td>자원 정렬, Wait-for 탐지, 타임아웃, Wound-Wait</td><td>타임스탬프 기법, MVCC</td></tr><tr><td>확장성 한계</td><td>중앙 락 관리로 병목 발생</td><td>전역 동기화, 단일 관리 구조</td><td>대규모 동시성시 처리량 급감</td><td>파티셔닝/샤딩, 로컬 결합 확대</td><td>NoSQL, 이벤트 소싱 (CQRS)</td></tr><tr><td>팬텀 방지 비용</td><td>범위 락으로 넓은 영역 잠금, 오버헤드</td><td>쿼리 조건에 의한 삽입/삭제 변화</td><td>반복가능한 읽기 시 성능 저하</td><td>key-range/next-key 최적화, MVCC(SSI)</td><td>SSI, MVCC 기반 직렬화</td></tr></tbody></table><p>락은 일관성을 보장하지만 성능·확장성·가용성 측면에서 본질적 트레이드오프가 존재한다. 실무에선 인덱스·쿼리 개선, 트랜잭션 짧게 유지, 데드락 예방·탐지 정책을 우선 적용하고, 워크로드 특성에 따라 MVCC·OCC·샤딩 같은 대안으로 전환하는 것이 일반적 패턴이다.</p><h5 id=운영-환경별-제약사항-표>운영 환경별 제약사항 표<a hidden class=anchor aria-hidden=true href=#운영-환경별-제약사항-표>#</a></h5><table><thead><tr><th>제약사항</th><th>상세 설명</th><th>원인</th><th>영향</th><th>해결 방안</th><th>대안 기술</th></tr></thead><tbody><tr><td>메모리/리소스 요구</td><td>Lock Table·대기 큐·버전 저장소 소모</td><td>객체별 메타데이터·MVCC 버전 유지</td><td>메모리 증가·IO/Garbage 수반</td><td>에스컬레이션, 메모리 풀 관리, GC 튜닝</td><td>디스크 기반 관리, 경량 버전 전략</td></tr><tr><td>실시간 처리 제약</td><td>락 대기로 예측 불가 지연</td><td>동기화 기반 제어의 본질</td><td>실시간 SLA 충족 어려움</td><td>우선순위 스케줄링, 타임아웃, 비동기 설계</td><td>Lock-free 알고리즘, 스트리밍 아키텍처</td></tr><tr><td>분산 환경 복잡성</td><td>네트워크 지연·분할로 락 유지 어려움</td><td>CAP 트레이드오프 (일관성 vs 가용성)</td><td>가용성 저하·복구 복잡성</td><td>lease 기반 락, 샤딩, 제한적 분산 락</td><td>SAGA, BASE 모델, Consensus(RAFT)</td></tr></tbody></table><p>환경적 제약 (메모리·실시간·분산) 은 설계 원칙을 바꿀 만큼 중요하다. 규모가 커지면 중앙 락만으로는 한계가 분명하므로, 아키텍처 단계에서 샤딩·비동기·최종합의 모델을 고려해야 한다.</p><h4 id=33-트레이드오프-관계-분석>3.3 트레이드오프 관계 분석<a hidden class=anchor aria-hidden=true href=#33-트레이드오프-관계-분석>#</a></h4><ul><li>데이터베이스 동시성 설계는 항상 **일관성 (정확성)**과 <strong>동시성 (처리량)</strong> 사이에서 균형을 잡는 일이다.</li><li>강하게 잠그면 (Strict 2PL 등) 데이터는 안전하지만 동시성이 떨어지고 데드락 리스크가 커진다.</li><li>느슨하게 하면 (낙관적·MVCC 등) 동시성은 좋아지지만 충돌 시 재시도·버전관리 비용이 든다.</li><li>실무에서는 워크로드 특성에 따라 <strong>상황별/대상별 하이브리드</strong>(예: MVCC 읽기 + 특정 업데이트에만 강제 락) 를 적용해 균형을 맞춘다.</li></ul><h5 id=핵심-선택지별-트레이드오프-요약>핵심 선택지별 트레이드오프 요약<a hidden class=anchor aria-hidden=true href=#핵심-선택지별-트레이드오프-요약>#</a></h5><table><thead><tr><th>선택 쌍 (A vs B)</th><th>A(특징)</th><th style=text-align:right>장점</th><th>단점</th><th>선택 기준 (언제 A?)</th></tr></thead><tbody><tr><td><strong>Strict 2PL vs Loose/Optimistic</strong></td><td>Strict 2PL: 쓰기 락을 커밋까지 유지</td><td style=text-align:right>복구 단순·무결성 안전</td><td>동시성·성능 저하, 데드락 ↑</td><td>금융·회계·의료 등 강한 일관성 필요</td></tr><tr><td>Loose/Optimistic: 낙관적 충돌 처리</td><td>성능·동시성 우수, 충돌 시 재시도</td><td style=text-align:right>재시도 비용·복잡성 ↑</td><td>충돌 빈도 낮은 OLTP 쓰기 적은 환경</td><td></td></tr><tr><td><strong>Row-level vs Table-level</strong></td><td>Row-level: 세분성 높음</td><td style=text-align:right>최대 동시성</td><td>락 오버헤드↑, 메모리↑</td><td>고동시성 OLTP</td></tr><tr><td>Table-level: 단순/오버헤드 낮음</td><td>관리 단순·오버헤드 최소</td><td style=text-align:right>동시성 낮음</td><td>배치·DDL 등 대량 작업</td><td></td></tr><tr><td><strong>Prevention vs Detection (Deadlock)</strong></td><td>Prevention (Wound-Wait/Wait-Die)</td><td style=text-align:right>데드락 발생 자체 억제</td><td>공정성/성능 저하 가능</td><td>데드락 발생 비용 매우 큰 시스템</td></tr><tr><td>Detection (Wait-for graph + victim)</td><td>공정성·성능 유리</td><td style=text-align:right>탐지 비용·복구 필요</td><td>탐지/회복 시점 결정 필요</td><td></td></tr><tr><td><strong>Centralized LM vs Partitioned/Distributed</strong></td><td>Centralized: 설계 단순</td><td style=text-align:right>구현·운영 단순</td><td>확장성·단일고장점</td><td>소규모/단일노드 DB</td></tr><tr><td>Distributed: 샤드별 LM + 글로벌 합의</td><td>확장성 우수</td><td style=text-align:right>구현 복잡·동기화 비용</td><td>대규모·분산 환경</td><td></td></tr></tbody></table><ul><li>강한 일관성이 필수면 Strict 2PL/행동 규칙을 채택하라.</li><li>높은 처리량과 읽기 우선 환경이면 MVCC/낙관적 기법 우선 고려.</li><li>데드락 정책은 비용·공정성·운영 편의성의 균형으로 결정.</li><li>분산환경이면 로컬 빠름 + 글로벌 합의 패턴을 권장.</li></ul><h5 id=락-프로토콜의-트레이드오프와-하이브리드-해법>락 프로토콜의 트레이드오프와 하이브리드 해법<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-트레이드오프와-하이브리드-해법>#</a></h5><table><thead><tr><th>하이브리드 기법</th><th>해결하려는 트레이드오프</th><th>구성 요소 (주요)</th><th>적용 목적</th><th>장점</th><th>주의사항</th></tr></thead><tbody><tr><td>MVCC + Selective Pessimistic Locks</td><td>읽기 성능 ↑ vs 특정 쓰기 일관성 유지</td><td>버전 스토어 + Lock Manager(선택적 FOR UPDATE)</td><td>읽기우선 환경에서 특정 레코드 강제 보호</td><td>대부분 읽기엔 낮은 오버헤드, 특정 쓰기 안전</td><td>정책 엔진 필요, 복잡도↑</td></tr><tr><td>Adaptive Granularity / Dynamic Escalation</td><td>세분성↑(동시성) vs 오버헤드 관리</td><td>Escalation Controller + Lock Table 통계</td><td>워크로드 변동시 자동 조정</td><td>운영 유연성↑, 오버헤드 관리</td><td>임계치 튜닝 필요, 잘못 설정시 악화</td></tr><tr><td>Partitioned Local LM + Global Coordinator</td><td>중앙 단일화 vs 분산확장성</td><td>샤드별 LM + consensus(leader)</td><td>샤드화된 데이터로 로컬 처리 최적화</td><td>로컬속도 우수·글로벌 안전</td><td>크로스샤드 비용·합의 복잡</td></tr><tr><td>Optimistic Execution + Pessimistic Fallback</td><td>성능 우선 vs 일관성 보장</td><td>OCC/MVCC + fallback lock path</td><td>충돌 적은 트랜잭션에 최적</td><td>높은 동시성, 낮은 평균 레이턴시</td><td>재시도 비용 고려</td></tr><tr><td>Prevention (Wound-Wait) + Periodic Detection</td><td>예방 비용 vs 탐지 비용 균형</td><td>Timestamp manager + Deadlock Detector</td><td>긴 대기/긴 트랜잭션 환경</td><td>데드락 빈도 감소</td><td>우선순위 문제/공정성 영향</td></tr></tbody></table><p>하이브리드 기법은 단일 전략의 한계를 보완한다. 적용 전 핵심은 (1) 워크로드 프로파일링, (2) 운영·모니터링 준비, (3) 임계치·전환 규칙에 대한 실험적 검증이다.</p><h4 id=잠금-프로토콜-적용성-판단-지침>잠금 프로토콜 적용성 판단 지침<a hidden class=anchor aria-hidden=true href=#잠금-프로토콜-적용성-판단-지침>#</a></h4><p>잠금 프로토콜은 동시에 여러 사용자가 데이터를 다룰 때 ** 정확성 (무결성)** 을 보장하기 위한 도구다. 실시간 거래처럼 정확성이 최우선이면 락 기반 (2PL, Strict 2PL) 이 적합하다.<br>반면 순수 분석·읽기 집약 환경이나 초대형 수평 확장이 필요한 웹스케일 서비스에서는 락이 성능 병목을 만들기 쉬우니 MVCC, 이벤트 기반 아키텍처, 또는 NoSQL 같은 대안이 더 적절하다. 실제 도입은 워크로드 (읽기/쓰기 비율·트랜잭션 길이) 와 DBMS 특성, 운영 능력을 함께 고려해 결정한다.</p><h5 id=잠금-프로토콜-적용-적합성-분석>잠금 프로토콜 적용 적합성 분석<a hidden class=anchor aria-hidden=true href=#잠금-프로토콜-적용-적합성-분석>#</a></h5><h6 id=설계-관점>설계 관점<a hidden class=anchor aria-hidden=true href=#설계-관점>#</a></h6><ul><li><strong>언제 채택할 것인가</strong>: 데이터 정확성이 최우선 (금융 결제, 재고 최종성) 일 때 기본 선택지.</li><li><strong>설계 권장</strong>: 핵심 데이터 범주 (예: 잔액, 결제 상태) 에만 강한 락/Strict 2PL 적용, 부가적 읽기 테이블은 MVCC/리플리카 사용으로 분리.</li><li><strong>디자인 리스크</strong>: 과도한 범위 락 → 전체 서비스 지연 가능. 인덱스·쿼리로 락 대상 축소 필수.</li></ul><h6 id=분석-성능정합성-관점>분석 (성능·정합성) 관점<a hidden class=anchor aria-hidden=true href=#분석-성능정합성-관점>#</a></h6><ul><li><strong>평가 지표</strong>: 평균 락 대기시간 (ms), 블로커 비율 (%), 데드락/주당 발생 건수, P99 응답시간 변화.</li><li><strong>분석 방법</strong>: A/B 로 격리 수준 (READ COMMITTED vs REPEATABLE vs SERIALIZABLE) 변경 후 지표 비교. DBMS 별 갭락/SSI 차이를 관찰해 최적 지점 도출.</li><li><strong>성능 트레이드오프</strong>: 강한 일관성 확보 시 블로킹·abort·재시도 증가—SLA 와 비용 (재시도·지연) 을 비교해 결정.</li></ul><h6 id=운영-관점>운영 관점<a hidden class=anchor aria-hidden=true href=#운영-관점>#</a></h6><ul><li><strong>운영 준비사항</strong>: 실시간 블로킹 탐지·알림, 자동화된 Head-blocker 식별 스크립트 (검증 단계 포함), 데드락 로그 수집·분석 파이프라인.</li><li><strong>운영 정책</strong>: 임계값 (예: 평균 락 대기 > 300ms 알림), 승격 정책 (에스컬레이션 임계치) 과 자동 대응 (알람→수동/반자동 개입) 정의.</li><li><strong>장애 대응</strong>: 데드락 victim 선정 기준 (비용·작업 소유자 등) 과 롤백·재시도 절차 문서화.</li></ul><h5 id=환경별-잠금-프로토콜-적합성>환경별 잠금 프로토콜 적합성<a hidden class=anchor aria-hidden=true href=#환경별-잠금-프로토콜-적합성>#</a></h5><table><thead><tr><th style=text-align:right>환경 유형</th><th style=text-align:right>적합성 (권장 수준)</th><th>이유 (요약)</th><th>대안/권장 조합</th></tr></thead><tbody><tr><td style=text-align:right>OLTP(금융·전자상거래)</td><td style=text-align:right>매우 적합</td><td>짧은 트랜잭션·정합성 우선 → 즉시 일관성 필요</td><td>Strict 2PL + 모니터링, 일부 읽기 MVCC 활용</td></tr><tr><td style=text-align:right>전통 RDBMS(정규화)</td><td style=text-align:right>적합</td><td>SQL·ACID 요구 충족, 기존 앱 호환성</td><td>필요한 테이블에만 강 락 적용</td></tr><tr><td style=text-align:right>규제 민감 산업 (의료·금융)</td><td style=text-align:right>매우 적합</td><td>감사·무결성·규정 준수 요구</td><td>강한 락 정책 + 감사 로그</td></tr><tr><td style=text-align:right>빅데이터 분석</td><td style=text-align:right>부적합</td><td>읽기 최우선·처리량 중요 → 락 오버헤드 불리</td><td>파티셔닝·샘플링·배치 처리</td></tr><tr><td style=text-align:right>IoT / 실시간 스트리밍</td><td style=text-align:right>부적합</td><td>지연 민감·대량 삽입</td><td>이벤트 스트리밍, 시계열 DB</td></tr><tr><td style=text-align:right>웹스케일 서비스</td><td style=text-align:right>부분적 부적합</td><td>수평 확장·가용성 우선</td><td>NoSQL, 최종적 일관성, CQRS/Saga</td></tr></tbody></table><p>잠금 프로토콜은 <strong>정합성 우선</strong> 환경에 강력히 적합하며, <strong>처리량·지연·수평확장</strong>을 우선하는 환경에서는 대안 (스냅샷/MVCC, 메시지 기반 분해, 분산락 또는 NoSQL) 을 검토하라. 혼합 워크로드라면 핵심 데이터에만 락을 적용하고 나머지는 경량 기법으로 분리하는 하이브리드 전략이 실무적이다.</p><h3 id=구현-방법-및-분류>구현 방법 및 분류<a hidden class=anchor aria-hidden=true href=#구현-방법-및-분류>#</a></h3><h4 id=락-프로토콜-구현-기법-정리>락 프로토콜 구현 기법 정리<a hidden class=anchor aria-hidden=true href=#락-프로토콜-구현-기법-정리>#</a></h4><h2 id=4-구현-기법-상세-정리>4) 구현 기법 상세 정리<a hidden class=anchor aria-hidden=true href=#4-구현-기법-상세-정리>#</a></h2><p>각 기법에 대해 정의·특징·목적·사용 상황·간단한 예시 (필요시 코드) 를 포함한다.</p><h3 id=41-basic-two-phase-locking-기본-2pl>4.1 Basic Two-Phase Locking (기본 2PL)<a hidden class=anchor aria-hidden=true href=#41-basic-two-phase-locking-기본-2pl>#</a></h3><ul><li>정의: 트랜잭션이 Growing(획득) 단계에서만 락을 얻고, Shrinking(해제) 단계에서만 락을 푼다.</li><li>특징: 직렬성 보장, 중간에 락 재획득 불가 → 데드락 가능성 존재.</li><li>목적: 간단한 직렬성 보장 메커니즘.</li><li>사용 상황: 학습·소형 시스템·프로토타입.</li><li>예시 (의사코드): (아래 간단 Python 예시 포함)</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span><span class=lnt id=hl-6-15><a class=lnlinks href=#hl-6-15>15</a>
</span><span class=lnt id=hl-6-16><a class=lnlinks href=#hl-6-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Basic 2PL 의사 구현 (교육용)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TwoPhaseLockingTx</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>growing</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>  <span class=c1># (item, mode)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>growing</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>RuntimeError</span><span class=p>(</span><span class=s2>&#34;이미 축소 단계: 락 획득 불가&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 실제에는 호환성 검사와 Lock Table 상의 대기 로직 필요</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held</span><span class=o>.</span><span class=n>add</span><span class=p>((</span><span class=n>item</span><span class=p>,</span> <span class=n>mode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>release</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>item</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 첫 해제 시 축소 단계로 전환</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>growing</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held</span> <span class=o>=</span> <span class=p>{</span><span class=n>h</span> <span class=k>for</span> <span class=n>h</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>held</span> <span class=k>if</span> <span class=n>h</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>item</span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>락 구현은 크게 <strong>프로토콜 (2PL 변형 등)</strong> 과 <strong>아키텍처 (중앙화 vs 분산)</strong> 로 나뉜다. 2PL 계열은 트랜잭션이 락을 언제 획득·해제할지 규칙화해 직렬성을 보장하고, MGL 은 계층적 자원에서 효율을 더한다. 데드락은 예방·탐지·타임아웃 중 정책을 정해 대응하고, 분산 환경에서는 lease 나 consensus 기반 분산 락 서비스를 사용한다. 워크로드 특성에 따라 낙관적 (MVCC/OCC) 혹은 비관적 (락) 방식을 선택한다.</p><h4 id=락-구현-기법-요약표>락 구현 기법 요약표<a hidden class=anchor aria-hidden=true href=#락-구현-기법-요약표>#</a></h4><table><thead><tr><th style=text-align:right>기법</th><th>정의</th><th>특징</th><th>목적/사용 상황</th><th>예시/비고</th></tr></thead><tbody><tr><td style=text-align:right>Basic 2PL</td><td>Growing/Shrinking 분리</td><td>간단·직렬성 보장</td><td>학습·소형 시스템</td><td>교육용 의사코드</td></tr><tr><td style=text-align:right>Strict/Rigorous 2PL</td><td>커밋까지 락 유지</td><td>연쇄 롤백 방지</td><td>상용 DB 기본</td><td>복구 유리</td></tr><tr><td style=text-align:right>Conservative 2PL</td><td>선획득 (Pre-claim)</td><td>데드락 없음·동시성 저하</td><td>실시간/위험 회피</td><td>사전 자원 요구</td></tr><tr><td style=text-align:right>MGL + Intent</td><td>계층적 락 (IS/IX/SIX)</td><td>효율적 충돌검사</td><td>대규모 DB</td><td>테이블→행 최적화</td></tr><tr><td style=text-align:right>Lock Escalation</td><td>미세→상위 승격</td><td>메모리 절약·동시성 악화 가능</td><td>배치·큰 트랜잭션 주의</td><td>임계치 필요</td></tr><tr><td style=text-align:right>Deadlock 처리</td><td>Wait-Die/Wound-Wait/WFG</td><td>예방/탐지/타임아웃 방식</td><td>운영 정책에 따라 선택</td><td>혼합 적용 권장</td></tr><tr><td style=text-align:right>Central LD / Distributed</td><td>중앙화 vs 분산 서비스</td><td>SPOF vs 복잡도/지연</td><td>단일 노드 vs 분산 시스템</td><td>etcd/zk/consul</td></tr><tr><td style=text-align:right>Optimistic vs Pessimistic</td><td>충돌시 재시도 vs 락</td><td>충돌률에 따른 선택</td><td>읽기 많은 경우 낙관적 유리</td><td>MVCC/OCC 등</td></tr></tbody></table><h4 id=구현-기법-분류-프로토콜계층아키텍처>구현 기법 분류 (프로토콜·계층·아키텍처)<a hidden class=anchor aria-hidden=true href=#구현-기법-분류-프로토콜계층아키텍처>#</a></h4><h5 id=프로토콜-protocol-계열>프로토콜 (Protocol) 계열<a hidden class=anchor aria-hidden=true href=#프로토콜-protocol-계열>#</a></h5><p>기법: Basic 2PL, Strict 2PL, Rigorous 2PL, Conservative 2PL</p><p>설명: 트랜잭션의 락 획득·해제 규칙을 정의하는 클래스. Basic 은 확장/축소 단계로 직렬성 보장, Strict/Rigorous 는 커밋까지 락 보유로 복구에 유리, Conservative 는 선획득으로 데드락을 원천 차단하지만 동시성 제약이 크다.</p><table><thead><tr><th>기법</th><th>정의</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>Basic 2PL</td><td>Growing/Shrinking 분리</td><td>단순·직렬성 보장</td><td>데드락 가능</td></tr><tr><td>Strict 2PL</td><td>X 락을 커밋까지 유지</td><td>연쇄 롤백 방지</td><td>락 장기화</td></tr><tr><td>Rigorous 2PL</td><td>S/X 모두 커밋까지 유지</td><td>복구 안정성</td><td>동시성 제한</td></tr><tr><td>Conservative 2PL</td><td>시작 시 모든 락 선점</td><td>데드락 없음</td><td>낮은 동시성</td></tr></tbody></table><ul><li>프로토콜 선택은 데이터 무결성 요구 (복구/직렬성) 와 동시성 (성능) 요구 사이의 트레이드오프를 의미한다.</li></ul><p><strong>구현 예시</strong>:<br>(Basic 2PL)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1> 1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2> 2</a>
</span><span class=lnt id=hl-7-3><a class=lnlinks href=#hl-7-3> 3</a>
</span><span class=lnt id=hl-7-4><a class=lnlinks href=#hl-7-4> 4</a>
</span><span class=lnt id=hl-7-5><a class=lnlinks href=#hl-7-5> 5</a>
</span><span class=lnt id=hl-7-6><a class=lnlinks href=#hl-7-6> 6</a>
</span><span class=lnt id=hl-7-7><a class=lnlinks href=#hl-7-7> 7</a>
</span><span class=lnt id=hl-7-8><a class=lnlinks href=#hl-7-8> 8</a>
</span><span class=lnt id=hl-7-9><a class=lnlinks href=#hl-7-9> 9</a>
</span><span class=lnt id=hl-7-10><a class=lnlinks href=#hl-7-10>10</a>
</span><span class=lnt id=hl-7-11><a class=lnlinks href=#hl-7-11>11</a>
</span><span class=lnt id=hl-7-12><a class=lnlinks href=#hl-7-12>12</a>
</span><span class=lnt id=hl-7-13><a class=lnlinks href=#hl-7-13>13</a>
</span><span class=lnt id=hl-7-14><a class=lnlinks href=#hl-7-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BasicTwoPhaseLocking</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>growing_phase</span> <span class=o>=</span> <span class=kc>True</span>  <span class=c1># True: Growing, False: Shrinking</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data_item</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>growing_phase</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Cannot acquire lock in shrinking phase&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 락 획득 로직</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>add</span><span class=p>((</span><span class=n>data_item</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>release_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data_item</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>growing_phase</span> <span class=o>=</span> <span class=kc>False</span>  <span class=c1># 첫 락 해제 시 축소 단계 시작</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>remove</span><span class=p>((</span><span class=n>data_item</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>))</span>
</span></span></code></pre></td></tr></table></div></div><p>(Strict 2PL)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1> 1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2> 2</a>
</span><span class=lnt id=hl-8-3><a class=lnlinks href=#hl-8-3> 3</a>
</span><span class=lnt id=hl-8-4><a class=lnlinks href=#hl-8-4> 4</a>
</span><span class=lnt id=hl-8-5><a class=lnlinks href=#hl-8-5> 5</a>
</span><span class=lnt id=hl-8-6><a class=lnlinks href=#hl-8-6> 6</a>
</span><span class=lnt id=hl-8-7><a class=lnlinks href=#hl-8-7> 7</a>
</span><span class=lnt id=hl-8-8><a class=lnlinks href=#hl-8-8> 8</a>
</span><span class=lnt id=hl-8-9><a class=lnlinks href=#hl-8-9> 9</a>
</span><span class=lnt id=hl-8-10><a class=lnlinks href=#hl-8-10>10</a>
</span><span class=lnt id=hl-8-11><a class=lnlinks href=#hl-8-11>11</a>
</span><span class=lnt id=hl-8-12><a class=lnlinks href=#hl-8-12>12</a>
</span><span class=lnt id=hl-8-13><a class=lnlinks href=#hl-8-13>13</a>
</span><span class=lnt id=hl-8-14><a class=lnlinks href=#hl-8-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>StrictTwoPhaseLocking</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transaction_active</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data_item</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>transaction_active</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=s2>&#34;Transaction not active&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>add</span><span class=p>((</span><span class=n>data_item</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>commit_transaction</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 커밋 시점에서 모든 락 해제</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transaction_active</span> <span class=o>=</span> <span class=kc>False</span>
</span></span></code></pre></td></tr></table></div></div><h5 id=세분성계층화-기법>세분성·계층화 기법<a hidden class=anchor aria-hidden=true href=#세분성계층화-기법>#</a></h5><p>기법: Multi-Granularity Locking, Intention Locks, Lock Escalation</p><p>설명: 리소스 계층 (DB/Table/Page/Row) 에 맞춘 락으로 작은 그레인과 큰 그레인을 조화시킨다. Intention Locks(IS/IX/SIX) 는 상위 레벨에서 하위 락 존재를 알리는 신호이고, Escalation 은 많은 소규모 락을 상위 락으로 합쳐 관리 비용을 줄인다.</p><table><thead><tr><th>기법</th><th>목적</th><th>영향/주의점</th></tr></thead><tbody><tr><td>MGL + Intention</td><td>계층적 락 효율화</td><td>복잡한 정책 필요</td></tr><tr><td>Lock Escalation</td><td>메모리 절약</td><td>동시성 악화 가능</td></tr></tbody></table><ul><li>세분성 설계는 동시성 확보와 관리 오버헤드 절감을 균형 있게 맞춰야 한다.</li></ul><h5 id=데드락충돌-처리-기법>데드락·충돌 처리 기법<a hidden class=anchor aria-hidden=true href=#데드락충돌-처리-기법>#</a></h5><p>기법: Wait-Die, Wound-Wait, WFG 탐지, Timeout</p><p>설명: 데드락을 예방하거나 탐지해 회복하는 기법들로, 시스템 요구 (응답성·재시도 비용) 에 따라 적절한 전략을 선택하거나 혼합 적용한다.</p><table><thead><tr><th>기법</th><th>방식</th><th>장단점</th></tr></thead><tbody><tr><td>Wait-Die</td><td>연령 기반 대기/포기</td><td>공정성 보장, 젊은 트랜잭션 희생</td></tr><tr><td>Wound-Wait</td><td>오래된 트랜잭션 우선</td><td>오래된 작업 우선, 재시도 비용 상승</td></tr><tr><td>WFG 탐지</td><td>사이클 검사→롤백</td><td>탐지 주기 필요, 복구 비용 있음</td></tr><tr><td>Timeout</td><td>일정시간후 abort</td><td>구현 간단, false positive 가능</td></tr></tbody></table><ul><li>운영 환경에 따라 응답성 (타임아웃) 과 재시도 비용 (탐지·롤백) 을 저울질해 정책을 정해야 한다.</li></ul><h5 id=아키텍처배치-방식>아키텍처/배치 방식<a hidden class=anchor aria-hidden=true href=#아키텍처배치-방식>#</a></h5><p>기법: Central Lock Manager, Distributed Lock Service(etcd/zk), Lease 기반 락</p><p>설명: 락의 소유·관리 위치 (중앙 vs 분산) 에 따른 설계. 중앙화는 단순하지만 SPOF·병목 우려, 분산은 가용성·복잡성·지연이 고려사항. Lease 는 TTL 로 자동 해제해 분산 파티션 상황에서 복구를 돕는다.</p><table><thead><tr><th>방식</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>Central LM</td><td>설계 단순</td><td>SPOF·확장성 한계</td></tr><tr><td>Distributed (consensus)</td><td>가용성·분산 지원</td><td>복잡성·지연</td></tr><tr><td>Lease 기반</td><td>파티션 복구 용이</td><td>TTL 설정 민감</td></tr></tbody></table><ul><li>분산 환경에서는 지역성 (locality) 설계와 lease/consensus 전략 조합이 핵심이다.</li></ul><h5 id=대체혼합-기법>대체·혼합 기법<a hidden class=anchor aria-hidden=true href=#대체혼합-기법>#</a></h5><p>기법: MVCC, Optimistic Concurrency(OCC), Lock-free 자료구조, Hybrid</p><p>설명: 충돌을 허용하고 후속 검사로 해결하거나 (낙관적), 락을 피하는 구조로 성능을 얻는다. MVCC 는 읽기 성능에 강점, OCC 는 낮은 충돌률에서 효율적. Hybrid 는 충돌 빈도에 따라 동적 선택.</p><table><thead><tr><th>기법</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>MVCC</td><td>읽기 비차단, 고동시성</td><td>버전 관리·GC 필요</td></tr><tr><td>OCC</td><td>락 오버헤드 없음 (저충돌)</td><td>충돌시 재시도 비용</td></tr><tr><td>Lock-free</td><td>지연 보장 가능</td><td>설계 난도 높음</td></tr></tbody></table><ul><li>대체기법은 워크로드 특성 (충돌률, 읽기/쓰기 비율) 에 기반해 선택해야 한다.</li></ul><h4 id=구현-기법-통합-비교표>구현 기법 통합 비교표<a hidden class=anchor aria-hidden=true href=#구현-기법-통합-비교표>#</a></h4><table><thead><tr><th>카테고리</th><th>주요 기법</th><th>핵심 장점</th><th>핵심 단점</th><th>권장 적용 상황</th></tr></thead><tbody><tr><td>Protocol</td><td>Basic/Strict/Rigorous/Conservative 2PL</td><td>직렬성·회복성 제어 용이</td><td>동시성/성능 트레이드오프</td><td>무결성 최우선 시스템</td></tr><tr><td>Granularity</td><td>MGL, Intention, Escalation</td><td>효율적 자원 관리</td><td>구현·운영 복잡</td><td>혼합 워크로드 대형 DB</td></tr><tr><td>Deadlock</td><td>Wait-Die, Wound-Wait, WFG, Timeout</td><td>다양한 운영 정책 지원</td><td>재시도/탐지 비용</td><td>운영 정책 기반 선택</td></tr><tr><td>Architecture</td><td>Central LM, Distributed, Lease</td><td>단순성 vs 분산 가용성</td><td>SPOF vs 복잡성·지연</td><td>단일 노드 vs 분산 시스템</td></tr><tr><td>Alternatives</td><td>MVCC, OCC, Lock-free, Hybrid</td><td>높은 동시성/읽기 성능</td><td>GC·재시도·설계 난도</td><td>읽기 우세 또는 저충돌 환경</td></tr></tbody></table><h4 id=락-프로토콜-분류와-실무-적용-체계>락 프로토콜 분류와 실무 적용 체계<a hidden class=anchor aria-hidden=true href=#락-프로토콜-분류와-실무-적용-체계>#</a></h4><ul><li>락 프로토콜은 <strong>언제 락을 걸고 풀 것인가</strong>를 규정하는 규칙 모음이다.</li><li>분류는 크게 <strong>(1) 락을 언제 해제하느냐, (2) 어느 단위로 잠그느냐, (3) 데드락을 어떻게 처리하느냐, (4) 어느 방식으로 동시성을 제어하느냐, (5) 로컬인지 분산인지</strong>로 나눌 수 있다.</li><li>설계자는 워크로드 (읽기/쓰기 비율), 일관성 요구, 운영 환경 (단일 vs 분산) 과 하드웨어를 고려해 위 유형들을 조합한다.</li></ul><h5 id=락-프로토콜-유형-분류표>락 프로토콜 유형 분류표<a hidden class=anchor aria-hidden=true href=#락-프로토콜-유형-분류표>#</a></h5><table><thead><tr><th>분류 기준</th><th>유형</th><th>핵심 규칙</th><th>장점</th><th>단점</th><th>대표 적용 사례</th></tr></thead><tbody><tr><td>해제 시점 (2PL 변형)</td><td>기본 2PL</td><td>Growing/Shrinking 단계로 락 획득/해제</td><td>직렬성 보장, 유연</td><td>데드락 발생 가능</td><td>교육·연구용, 단순 시스템</td></tr><tr><td></td><td>Strict 2PL</td><td>쓰기 락을 커밋 전까지 유지</td><td>복구 용이성↑</td><td>동시성↓</td><td>상업 DB, 금융 일부</td></tr><tr><td></td><td>Rigorous/Conservative 2PL</td><td>모든 락을 트랜잭션 종료까지 보유 또는 시작 시 선획득</td><td>데드락 회피 (Conservative)·복구 강함</td><td>매우 낮은 동시성</td><td>배치·일괄 처리</td></tr><tr><td>세분성 (Granularity)</td><td>DB / Table / Page / Row / Column</td><td>잠금 단위 (크기) 로 동시성·오버헤드 결정</td><td>세분화 시 동시성↑</td><td>세분화 시 관리·메모리 오버헤드↑</td><td>OLTP: Row, 배치: Table</td></tr><tr><td>데드락 처리</td><td>Prevention</td><td>자원획득 순서 고정 등</td><td>데드락 근본 차단</td><td>동시성 제한</td><td>안전 우선 시스템</td></tr><tr><td></td><td>Avoidance</td><td>안전 상태 보장 알고리즘</td><td>데드락 낮춤</td><td>구현 복잡</td><td>예측 가능한 워크로드</td></tr><tr><td></td><td>Detection</td><td>Wait-for 그래프, victim rollback</td><td>성능 유지, 현실적</td><td>탐지 오버헤드·롤백 비용</td><td>대부분 RDBMS</td></tr><tr><td></td><td>Timeout (Ignore)</td><td>일정 시간 후 실패 처리</td><td>구현 단순</td><td>false abort 가능</td><td>단순/저비용 시스템</td></tr><tr><td>동작 방식</td><td>Pessimistic Locking</td><td>즉시 락 획득으로 충돌 차단</td><td>일관성 확실</td><td>동시성 저하</td><td>금융, 높은 충돌</td></tr><tr><td></td><td>Optimistic (OCC)</td><td>커밋 직전 충돌검증·재시도</td><td>높은 처리량 (충돌 적을 때)</td><td>재시도 비용</td><td>읽기중심·분산 환경</td></tr><tr><td></td><td>MVCC</td><td>버전으로 읽기 분리 (스냅샷)</td><td>읽기 성능 우수</td><td>쓰기 충돌·GC 필요</td><td>PostgreSQL, InnoDB</td></tr><tr><td>배포 경계</td><td>Local Locking</td><td>단일 인스턴스 LM</td><td>단순·오버헤드 낮음</td><td>단일 장애점</td><td>단일 DB 인스턴스</td></tr><tr><td></td><td>Distributed Locking</td><td>Consensus 기반 락 관리</td><td>글로벌 일관성 가능</td><td>네트워크·합의 오버헤드</td><td>분산 시스템, 마이크로서비스</td></tr></tbody></table><h5 id=락-분류-시점그레인정책모델영역>락 분류: 시점·그레인·정책·모델·영역<a hidden class=anchor aria-hidden=true href=#락-분류-시점그레인정책모델영역>#</a></h5><h6 id=해제-시점정책-2pl-변형>해제 시점·정책 (2PL 변형)<a hidden class=anchor aria-hidden=true href=#해제-시점정책-2pl-변형>#</a></h6><ul><li>설명<ul><li>트랜잭션이 락을 언제 해제하는지 (혹은 언제 획득을 모두 마치는지) 에 따라 분류. 기본 2PL·Strict·Rigorous(또는 Conservative) 등으로 나뉜다.</li></ul></li><li>문제·결과·원인·해결책<ul><li>문제: Strict/Rigorous 는 동시성 저하 → 처리량 감소.</li><li>결과: 응답 지연·대기 증가.</li><li>원인: 락을 오래 보유함 (복구·안전 우선 설계).</li><li>해결: 필요한 경우 트랜잭션 분할, 낮은 격리 수준 사용, 동시성 높은 경로는 MVCC 적용.</li></ul></li><li>예시 (발생)<ul><li>금융 정산에서 Strict 2PL 사용 → 동시 트랜잭션이 적절히 직렬화되어 오류 방지.</li></ul></li><li>예시 (해결 적용)<ul><li>비핵심 집계 작업은 Rigorous 대신 기본 2PL 로 전환해 처리량 확보.</li></ul></li></ul><table><thead><tr><th>항목</th><th>Basic 2PL (Plain / Classic)</th><th style=text-align:right>Strict 2PL</th><th>Rigorous 2PL</th></tr></thead><tbody><tr><td><strong>정의 (요지)</strong></td><td>Two-Phase Locking 의 원형. 트랜잭션은 Growing(락 획득) → Shrinking(락 해제) 두 단계로 동작하면 직렬성 보장.</td><td style=text-align:right>기본 2PL 에 <strong>쓰기 (X) 락은 커밋 (or 롤백) 까지 해제하지 않음</strong>. 읽기 (S) 락은 상황에 따라 일찍 해제 가능.</td><td>** 모든 락 (S, X 모두)** 을 트랜잭션의 종료 (커밋/롤백) 시까지 보유. 즉 S·X 락 전부 지연 해제.</td></tr><tr><td><strong>락 획득 규칙</strong></td><td>필요시 락을 획득 (성장 단계).</td><td style=text-align:right>필요시 락 획득 (성장).</td><td>필요시 락 획득 (성장).</td></tr><tr><td><strong>락 해제 시점</strong></td><td>Shrinking 단계에서 자유롭게 해제 가능 (커밋 전에도 일부 해제 가능).</td><td style=text-align:right>X 락은 커밋까지 유지. S 락은 Shrinking 단계에서 해제 가능 (구현에 따라 차이).</td><td>모든 락은 커밋/롤백 시점까지 유지 (해제는 트랜잭션 종료 후).</td></tr><tr><td><strong>보장되는 형식적 속성</strong></td><td><strong>직렬성 (Serializability)</strong> 보장. 하지만 **recoverability(회복성)** 는 보장되지 않을 수 있음 (다른 트랜잭션이 uncommitted 데이터를 읽을 경우).</td><td style=text-align:right>직렬성 + <strong>Recoverability / Cascadelessness</strong> 보장 (다른 트랜잭션이 uncommitted 쓰기 읽지 못함 → cascading abort 방지).</td><td>Strict 2PL 보다 강력한 동작. 직렬성 + recoverability 보장, <strong>읽기조차 커밋 전 노출 없음</strong>(완전한 락 지연 해제).</td></tr><tr><td><strong>데드락 위험</strong></td><td>존재 (락을 일찍 해제하면 감소 가능하지만 쉐이킹 단계에서 데드락 발생 가능).</td><td style=text-align:right>존재 (쓰기 락 장기 보유로 데드락 가능성 ↑).</td><td>존재하지만 <strong>데드락 회피 목적으로 Conservative(선획득) 와 조합하면 감소</strong>. 일반적으론 장기 보유로 데드락 위험↑.</td></tr><tr><td><strong>성능 (동시성)</strong></td><td>가장 유연하여 <strong>동시성 높음</strong>(락을 빨리 해제 가능).</td><td style=text-align:right>쓰기 동시성 감소 (쓰기 락 장기 보유) → 동시성 중간.</td><td>동시성 <strong>가장 낮음</strong>(S 도 유지하므로 읽기 간의 동시성 제한).</td></tr><tr><td><strong>복구/롤백 비용</strong></td><td>다른 트랜잭션이 uncommitted 데이터를 읽으면 cascading rollback 발생 가능 → 복구 비용 증가.</td><td style=text-align:right>cascading abort 방지 → 복구 단순·비용 절감.</td><td>복구가 가장 단순 (테이프처럼 트랜잭션 단위로 처리).</td></tr><tr><td><strong>구현 복잡도</strong></td><td>상대적 단순.</td><td style=text-align:right>중간 (쓰기 락 유지 로직 필요).</td><td>간단 로직이지만 운영 트레이드오프로 복잡한 튜닝 요구 (동시성 저하 조정).</td></tr><tr><td><strong>대표 DB/사용 사례</strong></td><td>교육/이론 실험, 일부 고동시성 시스템 (특정 튜닝 하에).</td><td style=text-align:right>대부분 상용 RDBMS 의 기본 운용 모드 (복구·안전성 우선 시스템).</td><td>금융/회계의 배치/결산, 아주 높은 데이터 무결성 요구 처리 (또는 실험적 환경).</td></tr><tr><td><strong>실무 예시 (의사 SQL 흐름)</strong></td><td>T1: S(A) → read; release S(A); T1: X(B) → write; commit (일부 락은 커밋前 해제 가능)</td><td style=text-align:right>T1: X(A) → write (X 보유 until COMMIT); 다른 T2 는 A 접근 불가 until T1 COMMIT</td><td>T1: S(A), X(B) 획득 → 모든 락 COMMIT 까지 유지; T2 아무것도 못함 until COMMIT</td></tr><tr><td><strong>장점 (핵심)</strong></td><td>동시성 높음, 처리량 유리.</td><td style=text-align:right>안정적 복구, cascading abort 방지, 데이터 무결성 향상.</td><td>가장 높은 일관성·회복 단순성 (예측 가능성).</td></tr><tr><td><strong>단점 (핵심)</strong></td><td>복구 -> cascading abort 위험, 데이터 노출 가능성 (정책상 문제).</td><td style=text-align:right>쓰기 충돌/대기 증가, 처리량 저하.</td><td>동시성 매우 낮음, 응답성·처리량 큰 감소.</td></tr><tr><td><strong>운영·튜닝 포인트</strong></td><td>데드락 탐지·타임아웃·트랜잭션 분할 권장.</td><td style=text-align:right>모니터링 (긴 X 락), 배치 시간 분산, 트랜잭션 짧게 유지 권장.</td><td>예약 작업·일괄 처리에 적합, 긴 트랜잭션 회피, 파티셔닝 활용 권장.</td></tr><tr><td><strong>권장 결정 기준</strong></td><td>읽기/쓰기 비율이 높고 재시도 (재시행) 비용이 낮은 시스템.</td><td style=text-align:right>표준 OLTP 시스템 (데이터 무결성·회복성 우선).</td><td>미션 크리티컬한 무결성 요구 (금융 결산, 규제 리포트 등).</td></tr></tbody></table><ul><li><p><strong>Basic 2PL</strong>은 가장 유연하고 동시성이 높지만, 다른 트랜잭션이 <em>아직 커밋되지 않은</em> 값을 읽거나 의존하면 <strong>cascading rollback</strong> 발생 가능. 이 때문에 단독으로 운영하면 회복성이 약해질 수 있다.</p></li><li><p><strong>Strict 2PL</strong>은 실무에서 가장 현실적인 절충안. <strong>쓰기 락 (X) 을 커밋까지 유지</strong>함으로써 다른 트랜잭션이 미확정 쓰기를 읽는 것을 차단하고 cascading abort 를 방지한다. 많은 RDBMS 가 기본적으로 이 동작 (또는 유사) 을 채택한다.</p></li><li><p><strong>Rigorous 2PL</strong>은 가장 엄격해 모든 락을 트랜잭션 종료까지 유지한다. 무결성·회복성 면에서는 최고지만 읽기조차 지연되어 처리량이 크게 떨어질 수 있다. 배치·정산 같은 곳에서 채택될 수 있다.</p></li><li><p><strong>안전성 vs 동시성</strong>의 전형적 트레이드오프. 금융 같은 도메인은 안전성을 택하고, 고동시성 서비스는 타협을 고려.</p></li></ul><p><strong>예시 시나리오 (작동 차이 시연—의사 코드)</strong></p><ul><li><p><strong>Strict 2PL (의사)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1>1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2>2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3>3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4>4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- T1 acquires X on row A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>100</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=c1>-- X(A) 획득, 유지 until COMMIT
</span></span></span><span class=line><span class=cl><span class=c1>-- other transactions cannot read/write A until COMMIT
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- 여기서 X(A) 해제
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Basic 2PL (의사—락 해제 허용)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-10-1><a class=lnlinks href=#hl-10-1>1</a>
</span><span class=lnt id=hl-10-2><a class=lnlinks href=#hl-10-2>2</a>
</span><span class=lnt id=hl-10-3><a class=lnlinks href=#hl-10-3>3</a>
</span><span class=lnt id=hl-10-4><a class=lnlinks href=#hl-10-4>4</a>
</span><span class=lnt id=hl-10-5><a class=lnlinks href=#hl-10-5>5</a>
</span><span class=lnt id=hl-10-6><a class=lnlinks href=#hl-10-6>6</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>items</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>SHARE</span><span class=p>;</span><span class=w> </span><span class=c1>-- S(10) 획득
</span></span></span><span class=line><span class=cl><span class=c1>-- read done
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>RELEASE</span><span class=w> </span><span class=k>LOCK</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>items</span><span class=p>(</span><span class=n>id</span><span class=o>=</span><span class=mi>10</span><span class=p>);</span><span class=w> </span><span class=c1>-- Shrinking 단계에서 S 해제 (커밋前 가능)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>items</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>qty</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>qty</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>11</span><span class=p>;</span><span class=w> </span><span class=c1>-- X(11) 획득
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Rigorous 2PL (의사)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-11-1><a class=lnlinks href=#hl-11-1>1</a>
</span><span class=lnt id=hl-11-2><a class=lnlinks href=#hl-11-2>2</a>
</span><span class=lnt id=hl-11-3><a class=lnlinks href=#hl-11-3>3</a>
</span><span class=lnt id=hl-11-4><a class=lnlinks href=#hl-11-4>4</a>
</span><span class=lnt id=hl-11-5><a class=lnlinks href=#hl-11-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>SHARE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>many</span><span class=w> </span><span class=k>rows</span><span class=p>;</span><span class=w> </span><span class=c1>-- S on many rows
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=err>…</span><span class=w> </span><span class=c1>-- X on few rows
</span></span></span><span class=line><span class=cl><span class=c1>-- 모든 S/X는 COMMIT까지 유지
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w> </span><span class=c1>-- 비로소 모든 락 해제
</span></span></span></code></pre></td></tr></table></div></div></li></ul><h6 id=세분성-granularity>세분성 (Granularity)<a hidden class=anchor aria-hidden=true href=#세분성-granularity>#</a></h6><ul><li>설명<ul><li>어떤 단위를 잠그는지가 핵심 (테이블→페이지→행→컬럼). 단위가 작을수록 동시성은 좋아지지만 락 수·관리 비용 증가.</li></ul></li><li>문제·결과·원인·해결책<ul><li>문제: 행 단위는 락 수 과다·메모리 부담, 테이블 단위는 병목.</li><li>결과: 메모리 압박 또는 성능 병목.</li><li>원인: 워크로드 특성 (동시 업데이트 수, 조회 패턴).</li><li>해결: 파티셔닝·인덱스 재설계·에스컬레이션 임계 조정.</li></ul></li><li>예시 (발생)<ul><li>OLTP 에서 행 단위로 처리 → 높은 동시성 유지.</li></ul></li><li>예시 (해결 적용)<ul><li>배치 작업은 파티셔닝 + 테이블 잠금으로 단순화.</li></ul></li></ul><table><thead><tr><th>그레인</th><th style=text-align:right>메모리 오버헤드</th><th style=text-align:right>동시성</th></tr></thead><tbody><tr><td>테이블</td><td style=text-align:right>낮음</td><td style=text-align:right>낮음</td></tr><tr><td>페이지</td><td style=text-align:right>중간</td><td style=text-align:right>중간</td></tr><tr><td>행</td><td style=text-align:right>높음</td><td style=text-align:right>높음</td></tr><tr><td>컬럼</td><td style=text-align:right>매우 높음</td><td style=text-align:right>매우 높음</td></tr></tbody></table><ul><li>그레인 결정은 워크로드 (읽기/쓰기 비율) 와 시스템 자원 (메모리) 을 함께 고려해야 한다.</li></ul><h6 id=데드락-처리-정책>데드락 처리 정책<a hidden class=anchor aria-hidden=true href=#데드락-처리-정책>#</a></h6><ul><li>설명<ul><li>데드락 접근법은 Prevention, Avoidance, Detection, Timeout(무시) 로 나뉜다.</li></ul></li><li>문제·결과·원인·해결책<ul><li>문제: Prevention 은 동시성 제약, Detection 은 롤백 비용.</li><li>결과: 과도한 롤백·지연 또는 낮은 동시성.</li><li>원인: 자원 획득 전략·트랜잭션 설계 미흡.</li><li>해결: 혼합 전략 (예: Detection + 재시도 정책, 자원 정렬 규칙).</li></ul></li><li>예시 (발생)<ul><li>다중 테이블 업데이트 순서 불일치로 빈번한 deadlock 발생.</li></ul></li><li>예시 (해결 적용)<ul><li>모든 트랜잭션에서 리소스 접근을 ID 오름차순으로 고정 (Prevention 성격) + 탐지 로직 유지.</li></ul></li></ul><table><thead><tr><th>방식</th><th style=text-align:right>구현 복잡도</th><th style=text-align:right>성능 영향</th></tr></thead><tbody><tr><td>Prevention</td><td style=text-align:right>낮음</td><td style=text-align:right>동시성 제한</td></tr><tr><td>Avoidance</td><td style=text-align:right>높음</td><td style=text-align:right>중간</td></tr><tr><td>Detection</td><td style=text-align:right>중간</td><td style=text-align:right>높음 (현실적)</td></tr><tr><td>Timeout</td><td style=text-align:right>낮음</td><td style=text-align:right>낮음 (오탐 위험)</td></tr></tbody></table><ul><li>실무는 보통 <strong>Detection + 재시도/타임아웃</strong> 혼합을 사용.</li></ul><h6 id=동작-방식-락-모델>동작 방식 (락 모델)<a hidden class=anchor aria-hidden=true href=#동작-방식-락-모델>#</a></h6><ul><li>설명<ul><li>동시성 제어 방식으로 Pessimistic(락 즉시획득), Optimistic(OCC), MVCC(버전) 의 세 계열이 있다.</li></ul></li><li>문제·결과·원인·해결책<ul><li>문제: Pessimistic 은 충돌 빈도 낮은 환경에서 오버헤드, OCC/MVCC 는 쓰기 충돌 시 재시도·GC 부담.</li><li>결과: 워크로드에 따라 성능 천차만별.</li><li>원인: 읽기/쓰기 패턴, 충돌 확률.</li><li>해결: 워크로드 기반 혼용 (읽기많음→MVCC, 충돌많음→Pessimistic).</li></ul></li><li>예시 (발생)<ul><li>읽기 중심 서비스는 MVCC 로 높은 처리량 확보.</li></ul></li><li>예시 (해결 적용)<ul><li>결제/회계 같은 경우 Pessimistic 으로 일관성 보장.</li></ul></li></ul><table><thead><tr><th>모델</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>Pessimistic</td><td>일관성 확실</td><td>동시성 저하</td></tr><tr><td>OCC</td><td>높은 처리량 (충돌 적을 때)</td><td>재시도 비용</td></tr><tr><td>MVCC</td><td>읽기 동시성 우수</td><td>GC·쓰기 충돌</td></tr></tbody></table><ul><li>적절한 모델 선택은 워크로드 특성 (충돌 확률, 읽기/쓰기 비율) 에 달려있다.</li></ul><h6 id=배포-경계-local-vs-distributed>배포 경계 (Local Vs Distributed)<a hidden class=anchor aria-hidden=true href=#배포-경계-local-vs-distributed>#</a></h6><ul><li>설명<ul><li>락 관리가 단일 인스턴스 내에서 끝나는지, 분산된 여러 노드에 걸쳐야 하는지에 따른 분류.</li></ul></li><li>문제·결과·원인·해결책<ul><li>문제: 분산 락은 네트워크 지연·파티션·합의 비용 발생.</li><li>결과: 응답성 저하·복잡성 증가.</li><li>원인: 글로벌 자원 동기화 요구.</li><li>해결: Consensus 기반 솔루션, fencing token, lease/timestamp 기반 설계.</li></ul></li><li>예시 (발생)<ul><li>마이크로서비스에서 글로벌 리더 선출 필요 → etcd 사용.</li></ul></li><li>예시 (해결 적용)<ul><li>간단한 락은 Redis 로, 강한 안전성 필요하면 etcd/zookeeper 로 전환.</li></ul></li></ul><table><thead><tr><th>경계</th><th>장점</th><th>단점</th></tr></thead><tbody><tr><td>Local</td><td>단순·저오버헤드</td><td>확장성/가용성 한계</td></tr><tr><td>Distributed</td><td>글로벌 일관성 가능</td><td>네트워크·합의 오버헤드</td></tr></tbody></table><ul><li>분산 락은 안전성 요구 수준에 따라 Redis(경량) vs etcd(강력) 등 선택.</li></ul><h5 id=락-유형-통합-비교표>락 유형 통합 비교표<a hidden class=anchor aria-hidden=true href=#락-유형-통합-비교표>#</a></h5><table><thead><tr><th>카테고리</th><th>유형 (예)</th><th>핵심 규칙</th><th>장점</th><th>단점</th><th>권장 상황</th></tr></thead><tbody><tr><td>해제 시점</td><td>기본/Strict/Rigorous</td><td>락 해제 타이밍 규정</td><td>직렬성·복구</td><td>동시성·복잡도</td><td>금융·배치 등</td></tr><tr><td>그레인</td><td>Table/Page/Row</td><td>잠금 단위 결정</td><td>세분화→동시성↑</td><td>오버헤드↑</td><td>OLTP vs 배치</td></tr><tr><td>데드락</td><td>Prevention/Avoidance/Detection/Timeout</td><td>데드락 정책</td><td>안전/현실적 조합</td><td>각기 단점 존재</td><td>운영환경에 따라</td></tr><tr><td>모델</td><td>Pessimistic/OCC/MVCC</td><td>충돌 제어 방식</td><td>모델별 장단 상이</td><td>워크로드 의존</td><td>워크로드 기반 선택</td></tr><tr><td>배포</td><td>Local/Distributed</td><td>LM 위치·합의 여부</td><td>단순 vs 확장성</td><td>네트워크/합의 비용</td><td>마이크로서비스·분산 DB</td></tr></tbody></table><h3 id=실무-적용-및-사례>실무 적용 및 사례<a hidden class=anchor aria-hidden=true href=#실무-적용-및-사례>#</a></h3><h4 id=실습-예제-및-코드-구현>실습 예제 및 코드 구현<a hidden class=anchor aria-hidden=true href=#실습-예제-및-코드-구현>#</a></h4><h5 id=실습-예제-python-으로-구현하는-lock-관리-예시>실습 예제: Python 으로 구현하는 Lock 관리 예시<a hidden class=anchor aria-hidden=true href=#실습-예제-python-으로-구현하는-lock-관리-예시>#</a></h5><h6 id=목적>목적<a hidden class=anchor aria-hidden=true href=#목적>#</a></h6><ul><li>트랜잭션 환경에서 Lock 획득과 해제, 충돌 방지의 원리 체득</li></ul><h6 id=사전-요구사항>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항>#</a></h6><ul><li>파이썬 3.x</li><li><code>threading</code> 라이브러리 (표준)</li><li>멀티스레드 코드 이해</li></ul><h6 id=단계별-구현>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현>#</a></h6><ol><li><p><strong>1 단계: Lock 도입 및 트랜잭션 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-12-1><a class=lnlinks href=#hl-12-1> 1</a>
</span><span class=lnt id=hl-12-2><a class=lnlinks href=#hl-12-2> 2</a>
</span><span class=lnt id=hl-12-3><a class=lnlinks href=#hl-12-3> 3</a>
</span><span class=lnt id=hl-12-4><a class=lnlinks href=#hl-12-4> 4</a>
</span><span class=lnt id=hl-12-5><a class=lnlinks href=#hl-12-5> 5</a>
</span><span class=lnt id=hl-12-6><a class=lnlinks href=#hl-12-6> 6</a>
</span><span class=lnt id=hl-12-7><a class=lnlinks href=#hl-12-7> 7</a>
</span><span class=lnt id=hl-12-8><a class=lnlinks href=#hl-12-8> 8</a>
</span><span class=lnt id=hl-12-9><a class=lnlinks href=#hl-12-9> 9</a>
</span><span class=lnt id=hl-12-10><a class=lnlinks href=#hl-12-10>10</a>
</span><span class=lnt id=hl-12-11><a class=lnlinks href=#hl-12-11>11</a>
</span><span class=lnt id=hl-12-12><a class=lnlinks href=#hl-12-12>12</a>
</span><span class=lnt id=hl-12-13><a class=lnlinks href=#hl-12-13>13</a>
</span><span class=lnt id=hl-12-14><a class=lnlinks href=#hl-12-14>14</a>
</span><span class=lnt id=hl-12-15><a class=lnlinks href=#hl-12-15>15</a>
</span><span class=lnt id=hl-12-16><a class=lnlinks href=#hl-12-16>16</a>
</span><span class=lnt id=hl-12-17><a class=lnlinks href=#hl-12-17>17</a>
</span><span class=lnt id=hl-12-18><a class=lnlinks href=#hl-12-18>18</a>
</span><span class=lnt id=hl-12-19><a class=lnlinks href=#hl-12-19>19</a>
</span><span class=lnt id=hl-12-20><a class=lnlinks href=#hl-12-20>20</a>
</span><span class=lnt id=hl-12-21><a class=lnlinks href=#hl-12-21>21</a>
</span><span class=lnt id=hl-12-22><a class=lnlinks href=#hl-12-22>22</a>
</span><span class=lnt id=hl-12-23><a class=lnlinks href=#hl-12-23>23</a>
</span><span class=lnt id=hl-12-24><a class=lnlinks href=#hl-12-24>24</a>
</span><span class=lnt id=hl-12-25><a class=lnlinks href=#hl-12-25>25</a>
</span><span class=lnt id=hl-12-26><a class=lnlinks href=#hl-12-26>26</a>
</span><span class=lnt id=hl-12-27><a class=lnlinks href=#hl-12-27>27</a>
</span><span class=lnt id=hl-12-28><a class=lnlinks href=#hl-12-28>28</a>
</span><span class=lnt id=hl-12-29><a class=lnlinks href=#hl-12-29>29</a>
</span><span class=lnt id=hl-12-30><a class=lnlinks href=#hl-12-30>30</a>
</span><span class=lnt id=hl-12-31><a class=lnlinks href=#hl-12-31>31</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 공유 자원(데이터베이스 테이블 컬럼 가정)</span>
</span></span><span class=line><span class=cl><span class=n>shared_data</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;balance&#39;</span><span class=p>:</span> <span class=mi>100</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1># 락 오브젝트 생성</span>
</span></span><span class=line><span class=cl><span class=n>lock</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>transaction1</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>lock</span><span class=p>:</span>  <span class=c1># lock 획득(배타적)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;트랜잭션1: 시작. 락 획득!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>original</span> <span class=o>=</span> <span class=n>shared_data</span><span class=p>[</span><span class=s1>&#39;balance&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 실제 처리 대기(데이터 충돌 가능성 표현)</span>
</span></span><span class=line><span class=cl>        <span class=n>shared_data</span><span class=p>[</span><span class=s1>&#39;balance&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>original</span> <span class=o>+</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;트랜잭션1: 완료. balance =&#34;</span><span class=p>,</span> <span class=n>shared_data</span><span class=p>[</span><span class=s1>&#39;balance&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>transaction2</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>lock</span><span class=p>:</span>  <span class=c1># lock 획득(배타적)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;트랜잭션2: 시작. 락 획득!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>original</span> <span class=o>=</span> <span class=n>shared_data</span><span class=p>[</span><span class=s1>&#39;balance&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>shared_data</span><span class=p>[</span><span class=s1>&#39;balance&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>original</span> <span class=o>-</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;트랜잭션2: 완료. balance =&#34;</span><span class=p>,</span> <span class=n>shared_data</span><span class=p>[</span><span class=s1>&#39;balance&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>t1</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>transaction1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>t2</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>transaction2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>t1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>t2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>t1</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>t2</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과>#</a></h6><ul><li>트랜잭션 1 이 먼저 락을 잡고 작업 완료까지 트랜잭션 2 는 대기</li><li>두 트랜잭션이 동시에 balance 값을 갱신하려 해도 데이터 불일치 발생 X</li></ul><h6 id=추가-실험>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험>#</a></h6><ul><li>여러 스레드 동시 실행 시 락이 없을 때와 비교</li><li>Shared Lock, Exclusive Lock 시나리오로 확장</li><li>데드락 상황 (서로 다른 락 획득 후 교차 대기) 코드 변형 실습</li></ul><h5 id=실습-예제-간단한-lock-manager-시뮬레이션-python>실습 예제: 간단한 Lock Manager 시뮬레이션 (Python)<a hidden class=anchor aria-hidden=true href=#실습-예제-간단한-lock-manager-시뮬레이션-python>#</a></h5><h6 id=목적-1>목적<a hidden class=anchor aria-hidden=true href=#목적-1>#</a></h6><ul><li>2PL 개념 (Shared/Exclusive 락, 락 획득/해제, 간단한 deadlock 시연) 을 이해</li></ul><h6 id=사전-요구사항-1>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-1>#</a></h6><ul><li>Python 3.8+</li></ul><h6 id=단계별-구현-1>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-1>#</a></h6><ol><li><p><strong>Lock Manager 클래스 작성</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-13-1><a class=lnlinks href=#hl-13-1> 1</a>
</span><span class=lnt id=hl-13-2><a class=lnlinks href=#hl-13-2> 2</a>
</span><span class=lnt id=hl-13-3><a class=lnlinks href=#hl-13-3> 3</a>
</span><span class=lnt id=hl-13-4><a class=lnlinks href=#hl-13-4> 4</a>
</span><span class=lnt id=hl-13-5><a class=lnlinks href=#hl-13-5> 5</a>
</span><span class=lnt id=hl-13-6><a class=lnlinks href=#hl-13-6> 6</a>
</span><span class=lnt id=hl-13-7><a class=lnlinks href=#hl-13-7> 7</a>
</span><span class=lnt id=hl-13-8><a class=lnlinks href=#hl-13-8> 8</a>
</span><span class=lnt id=hl-13-9><a class=lnlinks href=#hl-13-9> 9</a>
</span><span class=lnt id=hl-13-10><a class=lnlinks href=#hl-13-10>10</a>
</span><span class=lnt id=hl-13-11><a class=lnlinks href=#hl-13-11>11</a>
</span><span class=lnt id=hl-13-12><a class=lnlinks href=#hl-13-12>12</a>
</span><span class=lnt id=hl-13-13><a class=lnlinks href=#hl-13-13>13</a>
</span><span class=lnt id=hl-13-14><a class=lnlinks href=#hl-13-14>14</a>
</span><span class=lnt id=hl-13-15><a class=lnlinks href=#hl-13-15>15</a>
</span><span class=lnt id=hl-13-16><a class=lnlinks href=#hl-13-16>16</a>
</span><span class=lnt id=hl-13-17><a class=lnlinks href=#hl-13-17>17</a>
</span><span class=lnt id=hl-13-18><a class=lnlinks href=#hl-13-18>18</a>
</span><span class=lnt id=hl-13-19><a class=lnlinks href=#hl-13-19>19</a>
</span><span class=lnt id=hl-13-20><a class=lnlinks href=#hl-13-20>20</a>
</span><span class=lnt id=hl-13-21><a class=lnlinks href=#hl-13-21>21</a>
</span><span class=lnt id=hl-13-22><a class=lnlinks href=#hl-13-22>22</a>
</span><span class=lnt id=hl-13-23><a class=lnlinks href=#hl-13-23>23</a>
</span><span class=lnt id=hl-13-24><a class=lnlinks href=#hl-13-24>24</a>
</span><span class=lnt id=hl-13-25><a class=lnlinks href=#hl-13-25>25</a>
</span><span class=lnt id=hl-13-26><a class=lnlinks href=#hl-13-26>26</a>
</span><span class=lnt id=hl-13-27><a class=lnlinks href=#hl-13-27>27</a>
</span><span class=lnt id=hl-13-28><a class=lnlinks href=#hl-13-28>28</a>
</span><span class=lnt id=hl-13-29><a class=lnlinks href=#hl-13-29>29</a>
</span><span class=lnt id=hl-13-30><a class=lnlinks href=#hl-13-30>30</a>
</span><span class=lnt id=hl-13-31><a class=lnlinks href=#hl-13-31>31</a>
</span><span class=lnt id=hl-13-32><a class=lnlinks href=#hl-13-32>32</a>
</span><span class=lnt id=hl-13-33><a class=lnlinks href=#hl-13-33>33</a>
</span><span class=lnt id=hl-13-34><a class=lnlinks href=#hl-13-34>34</a>
</span><span class=lnt id=hl-13-35><a class=lnlinks href=#hl-13-35>35</a>
</span><span class=lnt id=hl-13-36><a class=lnlinks href=#hl-13-36>36</a>
</span><span class=lnt id=hl-13-37><a class=lnlinks href=#hl-13-37>37</a>
</span><span class=lnt id=hl-13-38><a class=lnlinks href=#hl-13-38>38</a>
</span><span class=lnt id=hl-13-39><a class=lnlinks href=#hl-13-39>39</a>
</span><span class=lnt id=hl-13-40><a class=lnlinks href=#hl-13-40>40</a>
</span><span class=lnt id=hl-13-41><a class=lnlinks href=#hl-13-41>41</a>
</span><span class=lnt id=hl-13-42><a class=lnlinks href=#hl-13-42>42</a>
</span><span class=lnt id=hl-13-43><a class=lnlinks href=#hl-13-43>43</a>
</span><span class=lnt id=hl-13-44><a class=lnlinks href=#hl-13-44>44</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 간단한 락 매니저 시뮬레이션 (교육용)</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>enum</span> <span class=kn>import</span> <span class=n>Enum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockType</span><span class=p>(</span><span class=n>Enum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>S</span> <span class=o>=</span> <span class=s1>&#39;S&#39;</span>  <span class=c1># Shared</span>
</span></span><span class=line><span class=cl>    <span class=n>X</span> <span class=o>=</span> <span class=s1>&#39;X&#39;</span>  <span class=c1># Exclusive</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># resource -&gt; list of (txn_id, lock_type)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>can_grant</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource</span><span class=p>,</span> <span class=n>txn_id</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>holders</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>resource</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># if no holders =&gt; grant</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=n>holders</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=c1># shared lock requested: allow if all holders are shared</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>lock_type</span> <span class=o>==</span> <span class=n>LockType</span><span class=o>.</span><span class=n>S</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>all</span><span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>LockType</span><span class=o>.</span><span class=n>S</span> <span class=k>for</span> <span class=n>h</span> <span class=ow>in</span> <span class=n>holders</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># exclusive lock requested: only allow if single holder and it&#39;s the same txn</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>holders</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>holders</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=ow>and</span> <span class=n>holders</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=n>txn_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource</span><span class=p>,</span> <span class=n>txn_id</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>can_grant</span><span class=p>(</span><span class=n>resource</span><span class=p>,</span> <span class=n>txn_id</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>resource</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>txn_id</span><span class=p>,</span> <span class=n>lock_type</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>release_all</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>txn_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>list</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=o>.</span><span class=n>keys</span><span class=p>()):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>r</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=n>h</span> <span class=k>for</span> <span class=n>h</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>r</span><span class=p>]</span> <span class=k>if</span> <span class=n>h</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>txn_id</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>r</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>del</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>r</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>lm</span> <span class=o>=</span> <span class=n>LockManager</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=s1>&#39;row:1&#39;</span><span class=p>,</span> <span class=s1>&#39;T1&#39;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>S</span><span class=p>))</span>  <span class=c1># True</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=s1>&#39;row:1&#39;</span><span class=p>,</span> <span class=s1>&#39;T2&#39;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>S</span><span class=p>))</span>  <span class=c1># True (shared ok)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=s1>&#39;row:1&#39;</span><span class=p>,</span> <span class=s1>&#39;T3&#39;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>X</span><span class=p>))</span>  <span class=c1># False (exclusive blocked)</span>
</span></span><span class=line><span class=cl><span class=n>lm</span><span class=o>.</span><span class=n>release_all</span><span class=p>(</span><span class=s1>&#39;T1&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>lm</span><span class=o>.</span><span class=n>release_all</span><span class=p>(</span><span class=s1>&#39;T2&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=s1>&#39;row:1&#39;</span><span class=p>,</span> <span class=s1>&#39;T3&#39;</span><span class=p>,</span> <span class=n>LockType</span><span class=o>.</span><span class=n>X</span><span class=p>))</span>  <span class=c1># True now</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-1>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-1>#</a></h6><ul><li>공유 락 동시 허용, 전용 락은 충돌로 인해 블록되는 것을 관찰 가능</li></ul><h6 id=추가-실험-1>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-1>#</a></h6><ul><li>데드락 시나리오 추가 (두 트랜잭션이 서로 다른 리소스를 X 로 점유하고 상대 리소스를 요청)</li><li>타임아웃/우선순위 정책 도입</li></ul><h5 id=실습-예제-미니-락-매니저-2pl--deadlock-탐지>실습 예제: 미니 락 매니저 (2PL + Deadlock 탐지)<a hidden class=anchor aria-hidden=true href=#실습-예제-미니-락-매니저-2pl--deadlock-탐지>#</a></h5><h6 id=목적-2>목적<a hidden class=anchor aria-hidden=true href=#목적-2>#</a></h6><ul><li>S/X 락, 의존 대기, Waits-For 그래프 기반 데드락 탐지를 이해하고 2PL 동작을 실습한다.</li></ul><h6 id=사전-요구사항-2>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-2>#</a></h6><ul><li>Python 3.10+, <code>networkx</code>(선택: 사이클 검증). 여기서는 표준 라이브러리만 사용.</li></ul><h6 id=단계별-구현-2>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-2>#</a></h6><ol><li><p><strong>락 자료구조와 호환성 매트릭스 정의</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-14-1><a class=lnlinks href=#hl-14-1> 1</a>
</span><span class=lnt id=hl-14-2><a class=lnlinks href=#hl-14-2> 2</a>
</span><span class=lnt id=hl-14-3><a class=lnlinks href=#hl-14-3> 3</a>
</span><span class=lnt id=hl-14-4><a class=lnlinks href=#hl-14-4> 4</a>
</span><span class=lnt id=hl-14-5><a class=lnlinks href=#hl-14-5> 5</a>
</span><span class=lnt id=hl-14-6><a class=lnlinks href=#hl-14-6> 6</a>
</span><span class=lnt id=hl-14-7><a class=lnlinks href=#hl-14-7> 7</a>
</span><span class=lnt id=hl-14-8><a class=lnlinks href=#hl-14-8> 8</a>
</span><span class=lnt id=hl-14-9><a class=lnlinks href=#hl-14-9> 9</a>
</span><span class=lnt id=hl-14-10><a class=lnlinks href=#hl-14-10>10</a>
</span><span class=lnt id=hl-14-11><a class=lnlinks href=#hl-14-11>11</a>
</span><span class=lnt id=hl-14-12><a class=lnlinks href=#hl-14-12>12</a>
</span><span class=lnt id=hl-14-13><a class=lnlinks href=#hl-14-13>13</a>
</span><span class=lnt id=hl-14-14><a class=lnlinks href=#hl-14-14>14</a>
</span><span class=lnt id=hl-14-15><a class=lnlinks href=#hl-14-15>15</a>
</span><span class=lnt id=hl-14-16><a class=lnlinks href=#hl-14-16>16</a>
</span><span class=lnt id=hl-14-17><a class=lnlinks href=#hl-14-17>17</a>
</span><span class=lnt id=hl-14-18><a class=lnlinks href=#hl-14-18>18</a>
</span><span class=lnt id=hl-14-19><a class=lnlinks href=#hl-14-19>19</a>
</span><span class=lnt id=hl-14-20><a class=lnlinks href=#hl-14-20>20</a>
</span><span class=lnt id=hl-14-21><a class=lnlinks href=#hl-14-21>21</a>
</span><span class=lnt id=hl-14-22><a class=lnlinks href=#hl-14-22>22</a>
</span><span class=lnt id=hl-14-23><a class=lnlinks href=#hl-14-23>23</a>
</span><span class=lnt id=hl-14-24><a class=lnlinks href=#hl-14-24>24</a>
</span><span class=lnt id=hl-14-25><a class=lnlinks href=#hl-14-25>25</a>
</span><span class=lnt id=hl-14-26><a class=lnlinks href=#hl-14-26>26</a>
</span><span class=lnt id=hl-14-27><a class=lnlinks href=#hl-14-27>27</a>
</span><span class=lnt id=hl-14-28><a class=lnlinks href=#hl-14-28>28</a>
</span><span class=lnt id=hl-14-29><a class=lnlinks href=#hl-14-29>29</a>
</span><span class=lnt id=hl-14-30><a class=lnlinks href=#hl-14-30>30</a>
</span><span class=lnt id=hl-14-31><a class=lnlinks href=#hl-14-31>31</a>
</span><span class=lnt id=hl-14-32><a class=lnlinks href=#hl-14-32>32</a>
</span><span class=lnt id=hl-14-33><a class=lnlinks href=#hl-14-33>33</a>
</span><span class=lnt id=hl-14-34><a class=lnlinks href=#hl-14-34>34</a>
</span><span class=lnt id=hl-14-35><a class=lnlinks href=#hl-14-35>35</a>
</span><span class=lnt id=hl-14-36><a class=lnlinks href=#hl-14-36>36</a>
</span><span class=lnt id=hl-14-37><a class=lnlinks href=#hl-14-37>37</a>
</span><span class=lnt id=hl-14-38><a class=lnlinks href=#hl-14-38>38</a>
</span><span class=lnt id=hl-14-39><a class=lnlinks href=#hl-14-39>39</a>
</span><span class=lnt id=hl-14-40><a class=lnlinks href=#hl-14-40>40</a>
</span><span class=lnt id=hl-14-41><a class=lnlinks href=#hl-14-41>41</a>
</span><span class=lnt id=hl-14-42><a class=lnlinks href=#hl-14-42>42</a>
</span><span class=lnt id=hl-14-43><a class=lnlinks href=#hl-14-43>43</a>
</span><span class=lnt id=hl-14-44><a class=lnlinks href=#hl-14-44>44</a>
</span><span class=lnt id=hl-14-45><a class=lnlinks href=#hl-14-45>45</a>
</span><span class=lnt id=hl-14-46><a class=lnlinks href=#hl-14-46>46</a>
</span><span class=lnt id=hl-14-47><a class=lnlinks href=#hl-14-47>47</a>
</span><span class=lnt id=hl-14-48><a class=lnlinks href=#hl-14-48>48</a>
</span><span class=lnt id=hl-14-49><a class=lnlinks href=#hl-14-49>49</a>
</span><span class=lnt id=hl-14-50><a class=lnlinks href=#hl-14-50>50</a>
</span><span class=lnt id=hl-14-51><a class=lnlinks href=#hl-14-51>51</a>
</span><span class=lnt id=hl-14-52><a class=lnlinks href=#hl-14-52>52</a>
</span><span class=lnt id=hl-14-53><a class=lnlinks href=#hl-14-53>53</a>
</span><span class=lnt id=hl-14-54><a class=lnlinks href=#hl-14-54>54</a>
</span><span class=lnt id=hl-14-55><a class=lnlinks href=#hl-14-55>55</a>
</span><span class=lnt id=hl-14-56><a class=lnlinks href=#hl-14-56>56</a>
</span><span class=lnt id=hl-14-57><a class=lnlinks href=#hl-14-57>57</a>
</span><span class=lnt id=hl-14-58><a class=lnlinks href=#hl-14-58>58</a>
</span><span class=lnt id=hl-14-59><a class=lnlinks href=#hl-14-59>59</a>
</span><span class=lnt id=hl-14-60><a class=lnlinks href=#hl-14-60>60</a>
</span><span class=lnt id=hl-14-61><a class=lnlinks href=#hl-14-61>61</a>
</span><span class=lnt id=hl-14-62><a class=lnlinks href=#hl-14-62>62</a>
</span><span class=lnt id=hl-14-63><a class=lnlinks href=#hl-14-63>63</a>
</span><span class=lnt id=hl-14-64><a class=lnlinks href=#hl-14-64>64</a>
</span><span class=lnt id=hl-14-65><a class=lnlinks href=#hl-14-65>65</a>
</span><span class=lnt id=hl-14-66><a class=lnlinks href=#hl-14-66>66</a>
</span><span class=lnt id=hl-14-67><a class=lnlinks href=#hl-14-67>67</a>
</span><span class=lnt id=hl-14-68><a class=lnlinks href=#hl-14-68>68</a>
</span><span class=lnt id=hl-14-69><a class=lnlinks href=#hl-14-69>69</a>
</span><span class=lnt id=hl-14-70><a class=lnlinks href=#hl-14-70>70</a>
</span><span class=lnt id=hl-14-71><a class=lnlinks href=#hl-14-71>71</a>
</span><span class=lnt id=hl-14-72><a class=lnlinks href=#hl-14-72>72</a>
</span><span class=lnt id=hl-14-73><a class=lnlinks href=#hl-14-73>73</a>
</span><span class=lnt id=hl-14-74><a class=lnlinks href=#hl-14-74>74</a>
</span><span class=lnt id=hl-14-75><a class=lnlinks href=#hl-14-75>75</a>
</span><span class=lnt id=hl-14-76><a class=lnlinks href=#hl-14-76>76</a>
</span><span class=lnt id=hl-14-77><a class=lnlinks href=#hl-14-77>77</a>
</span><span class=lnt id=hl-14-78><a class=lnlinks href=#hl-14-78>78</a>
</span><span class=lnt id=hl-14-79><a class=lnlinks href=#hl-14-79>79</a>
</span><span class=lnt id=hl-14-80><a class=lnlinks href=#hl-14-80>80</a>
</span><span class=lnt id=hl-14-81><a class=lnlinks href=#hl-14-81>81</a>
</span><span class=lnt id=hl-14-82><a class=lnlinks href=#hl-14-82>82</a>
</span><span class=lnt id=hl-14-83><a class=lnlinks href=#hl-14-83>83</a>
</span><span class=lnt id=hl-14-84><a class=lnlinks href=#hl-14-84>84</a>
</span><span class=lnt id=hl-14-85><a class=lnlinks href=#hl-14-85>85</a>
</span><span class=lnt id=hl-14-86><a class=lnlinks href=#hl-14-86>86</a>
</span><span class=lnt id=hl-14-87><a class=lnlinks href=#hl-14-87>87</a>
</span><span class=lnt id=hl-14-88><a class=lnlinks href=#hl-14-88>88</a>
</span><span class=lnt id=hl-14-89><a class=lnlinks href=#hl-14-89>89</a>
</span><span class=lnt id=hl-14-90><a class=lnlinks href=#hl-14-90>90</a>
</span><span class=lnt id=hl-14-91><a class=lnlinks href=#hl-14-91>91</a>
</span><span class=lnt id=hl-14-92><a class=lnlinks href=#hl-14-92>92</a>
</span><span class=lnt id=hl-14-93><a class=lnlinks href=#hl-14-93>93</a>
</span><span class=lnt id=hl-14-94><a class=lnlinks href=#hl-14-94>94</a>
</span><span class=lnt id=hl-14-95><a class=lnlinks href=#hl-14-95>95</a>
</span><span class=lnt id=hl-14-96><a class=lnlinks href=#hl-14-96>96</a>
</span><span class=lnt id=hl-14-97><a class=lnlinks href=#hl-14-97>97</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span><span class=p>,</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>dataclasses</span> <span class=kn>import</span> <span class=n>dataclass</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Dict</span><span class=p>,</span> <span class=n>Set</span><span class=p>,</span> <span class=n>Deque</span><span class=p>,</span> <span class=n>Optional</span><span class=p>,</span> <span class=n>Tuple</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 호환성: S는 S와만, X는 누구와도 호환 안 됨</span>
</span></span><span class=line><span class=cl><span class=n>COMPAT</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;S&#39;</span><span class=p>:</span> <span class=p>{</span><span class=s1>&#39;S&#39;</span><span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;X&#39;</span><span class=p>:</span> <span class=nb>set</span><span class=p>(),</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockRequest</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>txn</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>mode</span><span class=p>:</span> <span class=nb>str</span>  <span class=c1># &#39;S&#39; or &#39;X&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockState</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>owners</span><span class=p>:</span> <span class=n>Set</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>mode</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=nb>str</span><span class=p>]</span>  <span class=c1># None, &#39;S&#39;, or &#39;X&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=p>:</span> <span class=n>Deque</span><span class=p>[</span><span class=n>LockRequest</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span> <span class=n>LockState</span><span class=p>]</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=k>lambda</span><span class=p>:</span> <span class=n>LockState</span><span class=p>(</span><span class=nb>set</span><span class=p>(),</span> <span class=kc>None</span><span class=p>,</span> <span class=n>deque</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>waits_for</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Set</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>  <span class=c1># Waits-For Graph</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_compatible</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>:</span> <span class=n>LockState</span><span class=p>,</span> <span class=n>mode</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>requester</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=c1># Shared: multiple S 허용, 단 요청자가 기존 X 요청 충돌 여부 고려</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span> <span class=ow>and</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 이미 X 소유자가 없으므로 S와 호환</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=c1># 동일 트랜잭션의 승격: S -&gt; X</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;X&#39;</span> <span class=ow>and</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span> <span class=ow>and</span> <span class=n>state</span><span class=o>.</span><span class=n>owners</span> <span class=o>==</span> <span class=p>{</span><span class=n>requester</span><span class=p>}:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>acquire</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>res</span><span class=p>:</span> <span class=n>Tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>],</span> <span class=n>txn</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>mode</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>res</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_compatible</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>txn</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 락 부여</span>
</span></span><span class=line><span class=cl>            <span class=n>state</span><span class=o>.</span><span class=n>owners</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>txn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=n>mode</span> <span class=k>if</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span> <span class=k>else</span> <span class=p>(</span><span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=k>if</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span> <span class=ow>and</span> <span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span> <span class=k>else</span> <span class=s1>&#39;X&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=c1># 대기열로 이동</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>LockRequest</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=n>mode</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1># 대기 관계: 현재 소유자들에 대해 waits-for 간선 추가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>owner</span> <span class=ow>in</span> <span class=n>state</span><span class=o>.</span><span class=n>owners</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>owner</span> <span class=o>!=</span> <span class=n>txn</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>waits_for</span><span class=p>[</span><span class=n>txn</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>owner</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>release_all</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>txn</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 트랜잭션의 모든 락 해제 및 대기열 재평가</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>res</span><span class=p>,</span> <span class=n>state</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>txn</span> <span class=ow>in</span> <span class=n>state</span><span class=o>.</span><span class=n>owners</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>state</span><span class=o>.</span><span class=n>owners</span><span class=o>.</span><span class=n>discard</span><span class=p>(</span><span class=n>txn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=n>state</span><span class=o>.</span><span class=n>owners</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>                <span class=c1># 대기 간선 정리</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>waits_for</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>txn</span><span class=p>,</span> <span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>_grant_waiters</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_grant_waiters</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>changed</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>changed</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>changed</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>res</span><span class=p>,</span> <span class=n>state</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>table</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=n>state</span><span class=o>.</span><span class=n>queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>state</span><span class=o>.</span><span class=n>queue</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_compatible</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>head</span><span class=o>.</span><span class=n>mode</span><span class=p>,</span> <span class=n>head</span><span class=o>.</span><span class=n>txn</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=n>state</span><span class=o>.</span><span class=n>queue</span><span class=o>.</span><span class=n>popleft</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=n>state</span><span class=o>.</span><span class=n>owners</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>head</span><span class=o>.</span><span class=n>txn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=n>mode</span> <span class=k>if</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=ow>is</span> <span class=kc>None</span> <span class=k>else</span> <span class=p>(</span><span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=k>if</span> <span class=n>state</span><span class=o>.</span><span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span> <span class=ow>and</span> <span class=n>head</span><span class=o>.</span><span class=n>mode</span> <span class=o>==</span> <span class=s1>&#39;S&#39;</span> <span class=k>else</span> <span class=s1>&#39;X&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=c1># 대기 간선 제거</span>
</span></span><span class=line><span class=cl>                    <span class=bp>self</span><span class=o>.</span><span class=n>waits_for</span><span class=p>[</span><span class=n>head</span><span class=o>.</span><span class=n>txn</span><span class=p>]</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=n>changed</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>detect_deadlock</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Optional</span><span class=p>[</span><span class=n>Tuple</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>str</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 간단한 사이클 검사(2노드 사이클만 예시). 실무는 DFS/Strongly Connected Components 사용</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>u</span><span class=p>,</span> <span class=n>deps</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>waits_for</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>v</span> <span class=ow>in</span> <span class=n>deps</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>u</span> <span class=o>!=</span> <span class=n>v</span> <span class=ow>and</span> <span class=n>u</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>waits_for</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=nb>set</span><span class=p>()):</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=p>(</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 사용 예시</span>
</span></span><span class=line><span class=cl><span class=n>lm</span> <span class=o>=</span> <span class=n>LockManager</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>R</span> <span class=o>=</span> <span class=p>(</span><span class=s2>&#34;table&#34;</span><span class=p>,</span> <span class=s2>&#34;orders:42&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=n>R</span><span class=p>,</span> <span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;X&#34;</span><span class=p>)</span> <span class=ow>is</span> <span class=kc>True</span>  <span class=c1># T1이 X락 획득</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=n>R</span><span class=p>,</span> <span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;S&#34;</span><span class=p>)</span> <span class=ow>is</span> <span class=kc>False</span> <span class=c1># T2는 대기</span>
</span></span><span class=line><span class=cl><span class=n>cycle</span> <span class=o>=</span> <span class=n>lm</span><span class=o>.</span><span class=n>detect_deadlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;deadlock?&#34;</span><span class=p>,</span> <span class=n>cycle</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>lm</span><span class=o>.</span><span class=n>release_all</span><span class=p>(</span><span class=s2>&#34;T1&#34;</span><span class=p>)</span>                 <span class=c1># T1 커밋 → T2로 부여</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;T2 granted after T1 release:&#34;</span><span class=p>,</span> <span class=n>lm</span><span class=o>.</span><span class=n>table</span><span class=p>[</span><span class=n>R</span><span class=p>]</span><span class=o>.</span><span class=n>owners</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>데드락 유도 및 회복 (희생자 선택)</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-15-1><a class=lnlinks href=#hl-15-1> 1</a>
</span><span class=lnt id=hl-15-2><a class=lnlinks href=#hl-15-2> 2</a>
</span><span class=lnt id=hl-15-3><a class=lnlinks href=#hl-15-3> 3</a>
</span><span class=lnt id=hl-15-4><a class=lnlinks href=#hl-15-4> 4</a>
</span><span class=lnt id=hl-15-5><a class=lnlinks href=#hl-15-5> 5</a>
</span><span class=lnt id=hl-15-6><a class=lnlinks href=#hl-15-6> 6</a>
</span><span class=lnt id=hl-15-7><a class=lnlinks href=#hl-15-7> 7</a>
</span><span class=lnt id=hl-15-8><a class=lnlinks href=#hl-15-8> 8</a>
</span><span class=lnt id=hl-15-9><a class=lnlinks href=#hl-15-9> 9</a>
</span><span class=lnt id=hl-15-10><a class=lnlinks href=#hl-15-10>10</a>
</span><span class=lnt id=hl-15-11><a class=lnlinks href=#hl-15-11>11</a>
</span><span class=lnt id=hl-15-12><a class=lnlinks href=#hl-15-12>12</a>
</span><span class=lnt id=hl-15-13><a class=lnlinks href=#hl-15-13>13</a>
</span><span class=lnt id=hl-15-14><a class=lnlinks href=#hl-15-14>14</a>
</span><span class=lnt id=hl-15-15><a class=lnlinks href=#hl-15-15>15</a>
</span><span class=lnt id=hl-15-16><a class=lnlinks href=#hl-15-16>16</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 두 자원 R1, R2에 대해 서로가 상대가 가진 자원을 기다리는 상황</span>
</span></span><span class=line><span class=cl><span class=n>lm</span> <span class=o>=</span> <span class=n>LockManager</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>R1</span> <span class=o>=</span> <span class=p>(</span><span class=s2>&#34;row&#34;</span><span class=p>,</span> <span class=s2>&#34;A&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>R2</span> <span class=o>=</span> <span class=p>(</span><span class=s2>&#34;row&#34;</span><span class=p>,</span> <span class=s2>&#34;B&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;X&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>assert</span> <span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;X&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>_</span> <span class=o>=</span> <span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=n>R2</span><span class=p>,</span> <span class=s2>&#34;T1&#34;</span><span class=p>,</span> <span class=s2>&#34;S&#34;</span><span class=p>)</span>  <span class=c1># 대기</span>
</span></span><span class=line><span class=cl><span class=n>_</span> <span class=o>=</span> <span class=n>lm</span><span class=o>.</span><span class=n>acquire</span><span class=p>(</span><span class=n>R1</span><span class=p>,</span> <span class=s2>&#34;T2&#34;</span><span class=p>,</span> <span class=s2>&#34;S&#34;</span><span class=p>)</span>  <span class=c1># 대기 → 2노드 사이클 발생</span>
</span></span><span class=line><span class=cl><span class=n>cycle</span> <span class=o>=</span> <span class=n>lm</span><span class=o>.</span><span class=n>detect_deadlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;deadlock?&#34;</span><span class=p>,</span> <span class=n>cycle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 간단 희생자 정책: 사전식으로 큰 ID를 롤백</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>cycle</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>victim</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>cycle</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>lm</span><span class=o>.</span><span class=n>release_all</span><span class=p>(</span><span class=n>victim</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;victim aborted:&#34;</span><span class=p>,</span> <span class=n>victim</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-2>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-2>#</a></h6><ul><li>첫 스니펫: T1 커밋 후 T2 에 락 부여 → 대기 해소</li><li>둘째 스니펫: (T1,T2) 사이클 감지 → 피해자 선택/해제 후 진행</li></ul><h6 id=추가-실험-2>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-2>#</a></h6><ul><li>승격 (S→X) 경로, 다중 그레뉼러리티 (테이블/페이지/레코드 키 구성) 확장, 타임아웃 기반 회복.</li></ul><h5 id=실습-예제-파이썬-동시-트랜잭션-lock-시뮬레이션>실습 예제: 파이썬 동시 트랜잭션 Lock 시뮬레이션<a hidden class=anchor aria-hidden=true href=#실습-예제-파이썬-동시-트랜잭션-lock-시뮬레이션>#</a></h5><h6 id=목적-3>목적<a hidden class=anchor aria-hidden=true href=#목적-3>#</a></h6><ul><li>Lock 획득과 해제 과정을 코드로 체험하며 데이터 무결성 확보 원리를 이해</li></ul><h6 id=사전-요구사항-3>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-3>#</a></h6><ul><li>Python 3.x</li><li>threading 모듈 사용</li></ul><h6 id=단계별-구현-3>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-3>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-16-1><a class=lnlinks href=#hl-16-1> 1</a>
</span><span class=lnt id=hl-16-2><a class=lnlinks href=#hl-16-2> 2</a>
</span><span class=lnt id=hl-16-3><a class=lnlinks href=#hl-16-3> 3</a>
</span><span class=lnt id=hl-16-4><a class=lnlinks href=#hl-16-4> 4</a>
</span><span class=lnt id=hl-16-5><a class=lnlinks href=#hl-16-5> 5</a>
</span><span class=lnt id=hl-16-6><a class=lnlinks href=#hl-16-6> 6</a>
</span><span class=lnt id=hl-16-7><a class=lnlinks href=#hl-16-7> 7</a>
</span><span class=lnt id=hl-16-8><a class=lnlinks href=#hl-16-8> 8</a>
</span><span class=lnt id=hl-16-9><a class=lnlinks href=#hl-16-9> 9</a>
</span><span class=lnt id=hl-16-10><a class=lnlinks href=#hl-16-10>10</a>
</span><span class=lnt id=hl-16-11><a class=lnlinks href=#hl-16-11>11</a>
</span><span class=lnt id=hl-16-12><a class=lnlinks href=#hl-16-12>12</a>
</span><span class=lnt id=hl-16-13><a class=lnlinks href=#hl-16-13>13</a>
</span><span class=lnt id=hl-16-14><a class=lnlinks href=#hl-16-14>14</a>
</span><span class=lnt id=hl-16-15><a class=lnlinks href=#hl-16-15>15</a>
</span><span class=lnt id=hl-16-16><a class=lnlinks href=#hl-16-16>16</a>
</span><span class=lnt id=hl-16-17><a class=lnlinks href=#hl-16-17>17</a>
</span><span class=lnt id=hl-16-18><a class=lnlinks href=#hl-16-18>18</a>
</span><span class=lnt id=hl-16-19><a class=lnlinks href=#hl-16-19>19</a>
</span><span class=lnt id=hl-16-20><a class=lnlinks href=#hl-16-20>20</a>
</span><span class=lnt id=hl-16-21><a class=lnlinks href=#hl-16-21>21</a>
</span><span class=lnt id=hl-16-22><a class=lnlinks href=#hl-16-22>22</a>
</span><span class=lnt id=hl-16-23><a class=lnlinks href=#hl-16-23>23</a>
</span><span class=lnt id=hl-16-24><a class=lnlinks href=#hl-16-24>24</a>
</span><span class=lnt id=hl-16-25><a class=lnlinks href=#hl-16-25>25</a>
</span><span class=lnt id=hl-16-26><a class=lnlinks href=#hl-16-26>26</a>
</span><span class=lnt id=hl-16-27><a class=lnlinks href=#hl-16-27>27</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 공유 데이터(예: 은행 계좌)</span>
</span></span><span class=line><span class=cl><span class=n>database</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;balance&#34;</span><span class=p>:</span> <span class=mi>100</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>lock</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>deposit</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>orig</span> <span class=o>=</span> <span class=n>database</span><span class=p>[</span><span class=s2>&#34;balance&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>database</span><span class=p>[</span><span class=s2>&#34;balance&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>orig</span> <span class=o>+</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;입금: 잔액 =&#34;</span><span class=p>,</span> <span class=n>database</span><span class=p>[</span><span class=s2>&#34;balance&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>withdraw</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>orig</span> <span class=o>=</span> <span class=n>database</span><span class=p>[</span><span class=s2>&#34;balance&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>database</span><span class=p>[</span><span class=s2>&#34;balance&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>orig</span> <span class=o>-</span> <span class=mi>30</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;출금: 잔액 =&#34;</span><span class=p>,</span> <span class=n>database</span><span class=p>[</span><span class=s2>&#34;balance&#34;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>thread1</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>deposit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>thread2</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span><span class=o>=</span><span class=n>withdraw</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>thread1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread1</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>thread2</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=실행-결과-3>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-3>#</a></h6><ul><li>입금/출금 스레드가 Lock 을 통해 한 번에 하나씩만 데이터 갱신</li><li>데이터 불일치/경합 방지 확인</li></ul><h6 id=추가-실험-3>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-3>#</a></h6><ul><li>Lock 구문 제거 후, 값이 비정상적으로 변하는 사례 확인</li><li>데드락 시나리오로 응용 (서로 다른 락 띄고 교차 대기)</li></ul><h5 id=실습-예제-은행-계좌-이체-시스템에서의-락킹-프로토콜>실습 예제: 은행 계좌 이체 시스템에서의 락킹 프로토콜<a hidden class=anchor aria-hidden=true href=#실습-예제-은행-계좌-이체-시스템에서의-락킹-프로토콜>#</a></h5><h6 id=목적-4>목적<a hidden class=anchor aria-hidden=true href=#목적-4>#</a></h6><ul><li>다중 트랜잭션 환경에서 계좌 잔액의 일관성 보장</li><li>데드락 상황 처리 및 해결 방법 학습</li><li>Strict 2PL 프로토콜의 실제 구현 이해</li></ul><h6 id=사전-요구사항-4>사전 요구사항<a hidden class=anchor aria-hidden=true href=#사전-요구사항-4>#</a></h6><ul><li>Python 3.8+</li><li>threading 모듈 (표준 라이브러리)</li><li>기본적인 동시성 개념 이해</li></ul><h6 id=단계별-구현-4>단계별 구현<a hidden class=anchor aria-hidden=true href=#단계별-구현-4>#</a></h6><ol><li><p><strong>1 단계: 기본 락 매니저 구현</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-17-1><a class=lnlinks href=#hl-17-1> 1</a>
</span><span class=lnt id=hl-17-2><a class=lnlinks href=#hl-17-2> 2</a>
</span><span class=lnt id=hl-17-3><a class=lnlinks href=#hl-17-3> 3</a>
</span><span class=lnt id=hl-17-4><a class=lnlinks href=#hl-17-4> 4</a>
</span><span class=lnt id=hl-17-5><a class=lnlinks href=#hl-17-5> 5</a>
</span><span class=lnt id=hl-17-6><a class=lnlinks href=#hl-17-6> 6</a>
</span><span class=lnt id=hl-17-7><a class=lnlinks href=#hl-17-7> 7</a>
</span><span class=lnt id=hl-17-8><a class=lnlinks href=#hl-17-8> 8</a>
</span><span class=lnt id=hl-17-9><a class=lnlinks href=#hl-17-9> 9</a>
</span><span class=lnt id=hl-17-10><a class=lnlinks href=#hl-17-10>10</a>
</span><span class=lnt id=hl-17-11><a class=lnlinks href=#hl-17-11>11</a>
</span><span class=lnt id=hl-17-12><a class=lnlinks href=#hl-17-12>12</a>
</span><span class=lnt id=hl-17-13><a class=lnlinks href=#hl-17-13>13</a>
</span><span class=lnt id=hl-17-14><a class=lnlinks href=#hl-17-14>14</a>
</span><span class=lnt id=hl-17-15><a class=lnlinks href=#hl-17-15>15</a>
</span><span class=lnt id=hl-17-16><a class=lnlinks href=#hl-17-16>16</a>
</span><span class=lnt id=hl-17-17><a class=lnlinks href=#hl-17-17>17</a>
</span><span class=lnt id=hl-17-18><a class=lnlinks href=#hl-17-18>18</a>
</span><span class=lnt id=hl-17-19><a class=lnlinks href=#hl-17-19>19</a>
</span><span class=lnt id=hl-17-20><a class=lnlinks href=#hl-17-20>20</a>
</span><span class=lnt id=hl-17-21><a class=lnlinks href=#hl-17-21>21</a>
</span><span class=lnt id=hl-17-22><a class=lnlinks href=#hl-17-22>22</a>
</span><span class=lnt id=hl-17-23><a class=lnlinks href=#hl-17-23>23</a>
</span><span class=lnt id=hl-17-24><a class=lnlinks href=#hl-17-24>24</a>
</span><span class=lnt id=hl-17-25><a class=lnlinks href=#hl-17-25>25</a>
</span><span class=lnt id=hl-17-26><a class=lnlinks href=#hl-17-26>26</a>
</span><span class=lnt id=hl-17-27><a class=lnlinks href=#hl-17-27>27</a>
</span><span class=lnt id=hl-17-28><a class=lnlinks href=#hl-17-28>28</a>
</span><span class=lnt id=hl-17-29><a class=lnlinks href=#hl-17-29>29</a>
</span><span class=lnt id=hl-17-30><a class=lnlinks href=#hl-17-30>30</a>
</span><span class=lnt id=hl-17-31><a class=lnlinks href=#hl-17-31>31</a>
</span><span class=lnt id=hl-17-32><a class=lnlinks href=#hl-17-32>32</a>
</span><span class=lnt id=hl-17-33><a class=lnlinks href=#hl-17-33>33</a>
</span><span class=lnt id=hl-17-34><a class=lnlinks href=#hl-17-34>34</a>
</span><span class=lnt id=hl-17-35><a class=lnlinks href=#hl-17-35>35</a>
</span><span class=lnt id=hl-17-36><a class=lnlinks href=#hl-17-36>36</a>
</span><span class=lnt id=hl-17-37><a class=lnlinks href=#hl-17-37>37</a>
</span><span class=lnt id=hl-17-38><a class=lnlinks href=#hl-17-38>38</a>
</span><span class=lnt id=hl-17-39><a class=lnlinks href=#hl-17-39>39</a>
</span><span class=lnt id=hl-17-40><a class=lnlinks href=#hl-17-40>40</a>
</span><span class=lnt id=hl-17-41><a class=lnlinks href=#hl-17-41>41</a>
</span><span class=lnt id=hl-17-42><a class=lnlinks href=#hl-17-42>42</a>
</span><span class=lnt id=hl-17-43><a class=lnlinks href=#hl-17-43>43</a>
</span><span class=lnt id=hl-17-44><a class=lnlinks href=#hl-17-44>44</a>
</span><span class=lnt id=hl-17-45><a class=lnlinks href=#hl-17-45>45</a>
</span><span class=lnt id=hl-17-46><a class=lnlinks href=#hl-17-46>46</a>
</span><span class=lnt id=hl-17-47><a class=lnlinks href=#hl-17-47>47</a>
</span><span class=lnt id=hl-17-48><a class=lnlinks href=#hl-17-48>48</a>
</span><span class=lnt id=hl-17-49><a class=lnlinks href=#hl-17-49>49</a>
</span><span class=lnt id=hl-17-50><a class=lnlinks href=#hl-17-50>50</a>
</span><span class=lnt id=hl-17-51><a class=lnlinks href=#hl-17-51>51</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span><span class=p>,</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>enum</span> <span class=kn>import</span> <span class=n>Enum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockMode</span><span class=p>(</span><span class=n>Enum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>SHARED</span> <span class=o>=</span> <span class=s2>&#34;S&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>EXCLUSIVE</span> <span class=o>=</span> <span class=s2>&#34;X&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;락킹 프로토콜을 구현한 락 매니저&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>locks</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># resource_id -&gt; {&#39;mode&#39;: mode, &#39;holders&#39;: set, &#39;waiters&#39;: deque}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>transactions</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># tx_id -&gt; {&#39;locks&#39;: set, &#39;state&#39;: state}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>wait_graph</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>  <span class=c1># 데드락 감지용 대기 그래프</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>RLock</span><span class=p>()</span>  <span class=c1># 락 매니저 자체의 동시성 제어</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>request_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;트랜잭션이 리소스에 대한 락을 요청&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 이미 가지고 있는 락인지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>resource_id</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>transactions</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>tx_id</span><span class=p>,</span> <span class=p>{})</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;locks&#39;</span><span class=p>,</span> <span class=nb>set</span><span class=p>()):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 호환 가능한지 확인</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_is_compatible</span><span class=p>(</span><span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_grant_lock</span><span class=p>(</span><span class=n>tx_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>_add_to_wait_queue</span><span class=p>(</span><span class=n>tx_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_is_compatible</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;락 호환성 검사 - 락킹 프로토콜의 핵심 로직&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>resource_id</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>locks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>current_lock</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>locks</span><span class=p>[</span><span class=n>resource_id</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>current_mode</span> <span class=o>=</span> <span class=n>current_lock</span><span class=p>[</span><span class=s1>&#39;mode&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>holders</span> <span class=o>=</span> <span class=n>current_lock</span><span class=p>[</span><span class=s1>&#39;holders&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 이미 해당 트랜잭션이 락을 보유중인 경우</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>tx_id</span> <span class=ow>in</span> <span class=n>holders</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 공유락끼리는 호환 가능</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_mode</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>.</span><span class=n>SHARED</span> <span class=ow>and</span> <span class=n>mode</span> <span class=o>==</span> <span class=n>LockMode</span><span class=o>.</span><span class=n>SHARED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 그 외의 경우는 모두 비호환</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>holders</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>2 단계: 트랜잭션 및 데드락 관리</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-18-1><a class=lnlinks href=#hl-18-1> 1</a>
</span><span class=lnt id=hl-18-2><a class=lnlinks href=#hl-18-2> 2</a>
</span><span class=lnt id=hl-18-3><a class=lnlinks href=#hl-18-3> 3</a>
</span><span class=lnt id=hl-18-4><a class=lnlinks href=#hl-18-4> 4</a>
</span><span class=lnt id=hl-18-5><a class=lnlinks href=#hl-18-5> 5</a>
</span><span class=lnt id=hl-18-6><a class=lnlinks href=#hl-18-6> 6</a>
</span><span class=lnt id=hl-18-7><a class=lnlinks href=#hl-18-7> 7</a>
</span><span class=lnt id=hl-18-8><a class=lnlinks href=#hl-18-8> 8</a>
</span><span class=lnt id=hl-18-9><a class=lnlinks href=#hl-18-9> 9</a>
</span><span class=lnt id=hl-18-10><a class=lnlinks href=#hl-18-10>10</a>
</span><span class=lnt id=hl-18-11><a class=lnlinks href=#hl-18-11>11</a>
</span><span class=lnt id=hl-18-12><a class=lnlinks href=#hl-18-12>12</a>
</span><span class=lnt id=hl-18-13><a class=lnlinks href=#hl-18-13>13</a>
</span><span class=lnt id=hl-18-14><a class=lnlinks href=#hl-18-14>14</a>
</span><span class=lnt id=hl-18-15><a class=lnlinks href=#hl-18-15>15</a>
</span><span class=lnt id=hl-18-16><a class=lnlinks href=#hl-18-16>16</a>
</span><span class=lnt id=hl-18-17><a class=lnlinks href=#hl-18-17>17</a>
</span><span class=lnt id=hl-18-18><a class=lnlinks href=#hl-18-18>18</a>
</span><span class=lnt id=hl-18-19><a class=lnlinks href=#hl-18-19>19</a>
</span><span class=lnt id=hl-18-20><a class=lnlinks href=#hl-18-20>20</a>
</span><span class=lnt id=hl-18-21><a class=lnlinks href=#hl-18-21>21</a>
</span><span class=lnt id=hl-18-22><a class=lnlinks href=#hl-18-22>22</a>
</span><span class=lnt id=hl-18-23><a class=lnlinks href=#hl-18-23>23</a>
</span><span class=lnt id=hl-18-24><a class=lnlinks href=#hl-18-24>24</a>
</span><span class=lnt id=hl-18-25><a class=lnlinks href=#hl-18-25>25</a>
</span><span class=lnt id=hl-18-26><a class=lnlinks href=#hl-18-26>26</a>
</span><span class=lnt id=hl-18-27><a class=lnlinks href=#hl-18-27>27</a>
</span><span class=lnt id=hl-18-28><a class=lnlinks href=#hl-18-28>28</a>
</span><span class=lnt id=hl-18-29><a class=lnlinks href=#hl-18-29>29</a>
</span><span class=lnt id=hl-18-30><a class=lnlinks href=#hl-18-30>30</a>
</span><span class=lnt id=hl-18-31><a class=lnlinks href=#hl-18-31>31</a>
</span><span class=lnt id=hl-18-32><a class=lnlinks href=#hl-18-32>32</a>
</span><span class=lnt id=hl-18-33><a class=lnlinks href=#hl-18-33>33</a>
</span><span class=lnt id=hl-18-34><a class=lnlinks href=#hl-18-34>34</a>
</span><span class=lnt id=hl-18-35><a class=lnlinks href=#hl-18-35>35</a>
</span><span class=lnt id=hl-18-36><a class=lnlinks href=#hl-18-36>36</a>
</span><span class=lnt id=hl-18-37><a class=lnlinks href=#hl-18-37>37</a>
</span><span class=lnt id=hl-18-38><a class=lnlinks href=#hl-18-38>38</a>
</span><span class=lnt id=hl-18-39><a class=lnlinks href=#hl-18-39>39</a>
</span><span class=lnt id=hl-18-40><a class=lnlinks href=#hl-18-40>40</a>
</span><span class=lnt id=hl-18-41><a class=lnlinks href=#hl-18-41>41</a>
</span><span class=lnt id=hl-18-42><a class=lnlinks href=#hl-18-42>42</a>
</span><span class=lnt id=hl-18-43><a class=lnlinks href=#hl-18-43>43</a>
</span><span class=lnt id=hl-18-44><a class=lnlinks href=#hl-18-44>44</a>
</span><span class=lnt id=hl-18-45><a class=lnlinks href=#hl-18-45>45</a>
</span><span class=lnt id=hl-18-46><a class=lnlinks href=#hl-18-46>46</a>
</span><span class=lnt id=hl-18-47><a class=lnlinks href=#hl-18-47>47</a>
</span><span class=lnt id=hl-18-48><a class=lnlinks href=#hl-18-48>48</a>
</span><span class=lnt id=hl-18-49><a class=lnlinks href=#hl-18-49>49</a>
</span><span class=lnt id=hl-18-50><a class=lnlinks href=#hl-18-50>50</a>
</span><span class=lnt id=hl-18-51><a class=lnlinks href=#hl-18-51>51</a>
</span><span class=lnt id=hl-18-52><a class=lnlinks href=#hl-18-52>52</a>
</span><span class=lnt id=hl-18-53><a class=lnlinks href=#hl-18-53>53</a>
</span><span class=lnt id=hl-18-54><a class=lnlinks href=#hl-18-54>54</a>
</span><span class=lnt id=hl-18-55><a class=lnlinks href=#hl-18-55>55</a>
</span><span class=lnt id=hl-18-56><a class=lnlinks href=#hl-18-56>56</a>
</span><span class=lnt id=hl-18-57><a class=lnlinks href=#hl-18-57>57</a>
</span><span class=lnt id=hl-18-58><a class=lnlinks href=#hl-18-58>58</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Transaction</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Strict 2PL을 구현한 트랜잭션 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>,</span> <span class=n>lock_manager</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tx_id</span> <span class=o>=</span> <span class=n>tx_id</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span> <span class=o>=</span> <span class=n>lock_manager</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>  <span class=c1># 보유중인 락들</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=s2>&#34;ACTIVE&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rollback_flag</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>read</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;데이터 읽기 - 공유락 필요&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_acquire_lock</span><span class=p>(</span><span class=n>resource_id</span><span class=p>,</span> <span class=n>LockMode</span><span class=o>.</span><span class=n>SHARED</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 실제 데이터 읽기 시뮬레이션</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.01</span><span class=p>)</span>  <span class=c1># I/O 시뮬레이션</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Data from </span><span class=si>{</span><span class=n>resource_id</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Cannot acquire shared lock on </span><span class=si>{</span><span class=n>resource_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>write</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>value</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;데이터 쓰기 - 배타락 필요&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_acquire_lock</span><span class=p>(</span><span class=n>resource_id</span><span class=p>,</span> <span class=n>LockMode</span><span class=o>.</span><span class=n>EXCLUSIVE</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 실제 데이터 쓰기 시뮬레이션</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.02</span><span class=p>)</span>  <span class=c1># I/O 시뮬레이션</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=sa>f</span><span class=s2>&#34;Written </span><span class=si>{</span><span class=n>value</span><span class=si>}</span><span class=s2> to </span><span class=si>{</span><span class=n>resource_id</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span> <span class=ne>Exception</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Cannot acquire exclusive lock on </span><span class=si>{</span><span class=n>resource_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_acquire_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;락 획득 시도 - 데드락 방지를 위한 타임아웃 포함&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span> <span class=o>&lt;</span> <span class=n>timeout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span><span class=o>.</span><span class=n>request_lock</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tx_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>mode</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>resource_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>  <span class=c1># 잠시 대기 후 재시도</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 타임아웃 발생 시 데드락 가능성 있음</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rollback_flag</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>commit</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;트랜잭션 커밋 - Strict 2PL에 따라 모든 락을 유지했다가 한번에 해제&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>rollback_flag</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=s2>&#34;COMMITTED&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 커밋 시점에서 모든 락 해제 (Strict 2PL의 특징)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>resource_id</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span><span class=o>.</span><span class=n>release_lock</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tx_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>rollback</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;트랜잭션 롤백&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state</span> <span class=o>=</span> <span class=s2>&#34;ABORTED&#34;</span> 
</span></span><span class=line><span class=cl>        <span class=c1># 롤백 시점에서 모든 락 해제</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>resource_id</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>lock_manager</span><span class=o>.</span><span class=n>release_lock</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tx_id</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>held_locks</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>3 단계: 은행 이체 시나리오 시뮬레이션</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-19-1><a class=lnlinks href=#hl-19-1> 1</a>
</span><span class=lnt id=hl-19-2><a class=lnlinks href=#hl-19-2> 2</a>
</span><span class=lnt id=hl-19-3><a class=lnlinks href=#hl-19-3> 3</a>
</span><span class=lnt id=hl-19-4><a class=lnlinks href=#hl-19-4> 4</a>
</span><span class=lnt id=hl-19-5><a class=lnlinks href=#hl-19-5> 5</a>
</span><span class=lnt id=hl-19-6><a class=lnlinks href=#hl-19-6> 6</a>
</span><span class=lnt id=hl-19-7><a class=lnlinks href=#hl-19-7> 7</a>
</span><span class=lnt id=hl-19-8><a class=lnlinks href=#hl-19-8> 8</a>
</span><span class=lnt id=hl-19-9><a class=lnlinks href=#hl-19-9> 9</a>
</span><span class=lnt id=hl-19-10><a class=lnlinks href=#hl-19-10>10</a>
</span><span class=lnt id=hl-19-11><a class=lnlinks href=#hl-19-11>11</a>
</span><span class=lnt id=hl-19-12><a class=lnlinks href=#hl-19-12>12</a>
</span><span class=lnt id=hl-19-13><a class=lnlinks href=#hl-19-13>13</a>
</span><span class=lnt id=hl-19-14><a class=lnlinks href=#hl-19-14>14</a>
</span><span class=lnt id=hl-19-15><a class=lnlinks href=#hl-19-15>15</a>
</span><span class=lnt id=hl-19-16><a class=lnlinks href=#hl-19-16>16</a>
</span><span class=lnt id=hl-19-17><a class=lnlinks href=#hl-19-17>17</a>
</span><span class=lnt id=hl-19-18><a class=lnlinks href=#hl-19-18>18</a>
</span><span class=lnt id=hl-19-19><a class=lnlinks href=#hl-19-19>19</a>
</span><span class=lnt id=hl-19-20><a class=lnlinks href=#hl-19-20>20</a>
</span><span class=lnt id=hl-19-21><a class=lnlinks href=#hl-19-21>21</a>
</span><span class=lnt id=hl-19-22><a class=lnlinks href=#hl-19-22>22</a>
</span><span class=lnt id=hl-19-23><a class=lnlinks href=#hl-19-23>23</a>
</span><span class=lnt id=hl-19-24><a class=lnlinks href=#hl-19-24>24</a>
</span><span class=lnt id=hl-19-25><a class=lnlinks href=#hl-19-25>25</a>
</span><span class=lnt id=hl-19-26><a class=lnlinks href=#hl-19-26>26</a>
</span><span class=lnt id=hl-19-27><a class=lnlinks href=#hl-19-27>27</a>
</span><span class=lnt id=hl-19-28><a class=lnlinks href=#hl-19-28>28</a>
</span><span class=lnt id=hl-19-29><a class=lnlinks href=#hl-19-29>29</a>
</span><span class=lnt id=hl-19-30><a class=lnlinks href=#hl-19-30>30</a>
</span><span class=lnt id=hl-19-31><a class=lnlinks href=#hl-19-31>31</a>
</span><span class=lnt id=hl-19-32><a class=lnlinks href=#hl-19-32>32</a>
</span><span class=lnt id=hl-19-33><a class=lnlinks href=#hl-19-33>33</a>
</span><span class=lnt id=hl-19-34><a class=lnlinks href=#hl-19-34>34</a>
</span><span class=lnt id=hl-19-35><a class=lnlinks href=#hl-19-35>35</a>
</span><span class=lnt id=hl-19-36><a class=lnlinks href=#hl-19-36>36</a>
</span><span class=lnt id=hl-19-37><a class=lnlinks href=#hl-19-37>37</a>
</span><span class=lnt id=hl-19-38><a class=lnlinks href=#hl-19-38>38</a>
</span><span class=lnt id=hl-19-39><a class=lnlinks href=#hl-19-39>39</a>
</span><span class=lnt id=hl-19-40><a class=lnlinks href=#hl-19-40>40</a>
</span><span class=lnt id=hl-19-41><a class=lnlinks href=#hl-19-41>41</a>
</span><span class=lnt id=hl-19-42><a class=lnlinks href=#hl-19-42>42</a>
</span><span class=lnt id=hl-19-43><a class=lnlinks href=#hl-19-43>43</a>
</span><span class=lnt id=hl-19-44><a class=lnlinks href=#hl-19-44>44</a>
</span><span class=lnt id=hl-19-45><a class=lnlinks href=#hl-19-45>45</a>
</span><span class=lnt id=hl-19-46><a class=lnlinks href=#hl-19-46>46</a>
</span><span class=lnt id=hl-19-47><a class=lnlinks href=#hl-19-47>47</a>
</span><span class=lnt id=hl-19-48><a class=lnlinks href=#hl-19-48>48</a>
</span><span class=lnt id=hl-19-49><a class=lnlinks href=#hl-19-49>49</a>
</span><span class=lnt id=hl-19-50><a class=lnlinks href=#hl-19-50>50</a>
</span><span class=lnt id=hl-19-51><a class=lnlinks href=#hl-19-51>51</a>
</span><span class=lnt id=hl-19-52><a class=lnlinks href=#hl-19-52>52</a>
</span><span class=lnt id=hl-19-53><a class=lnlinks href=#hl-19-53>53</a>
</span><span class=lnt id=hl-19-54><a class=lnlinks href=#hl-19-54>54</a>
</span><span class=lnt id=hl-19-55><a class=lnlinks href=#hl-19-55>55</a>
</span><span class=lnt id=hl-19-56><a class=lnlinks href=#hl-19-56>56</a>
</span><span class=lnt id=hl-19-57><a class=lnlinks href=#hl-19-57>57</a>
</span><span class=lnt id=hl-19-58><a class=lnlinks href=#hl-19-58>58</a>
</span><span class=lnt id=hl-19-59><a class=lnlinks href=#hl-19-59>59</a>
</span><span class=lnt id=hl-19-60><a class=lnlinks href=#hl-19-60>60</a>
</span><span class=lnt id=hl-19-61><a class=lnlinks href=#hl-19-61>61</a>
</span><span class=lnt id=hl-19-62><a class=lnlinks href=#hl-19-62>62</a>
</span><span class=lnt id=hl-19-63><a class=lnlinks href=#hl-19-63>63</a>
</span><span class=lnt id=hl-19-64><a class=lnlinks href=#hl-19-64>64</a>
</span><span class=lnt id=hl-19-65><a class=lnlinks href=#hl-19-65>65</a>
</span><span class=lnt id=hl-19-66><a class=lnlinks href=#hl-19-66>66</a>
</span><span class=lnt id=hl-19-67><a class=lnlinks href=#hl-19-67>67</a>
</span><span class=lnt id=hl-19-68><a class=lnlinks href=#hl-19-68>68</a>
</span><span class=lnt id=hl-19-69><a class=lnlinks href=#hl-19-69>69</a>
</span><span class=lnt id=hl-19-70><a class=lnlinks href=#hl-19-70>70</a>
</span><span class=lnt id=hl-19-71><a class=lnlinks href=#hl-19-71>71</a>
</span><span class=lnt id=hl-19-72><a class=lnlinks href=#hl-19-72>72</a>
</span><span class=lnt id=hl-19-73><a class=lnlinks href=#hl-19-73>73</a>
</span><span class=lnt id=hl-19-74><a class=lnlinks href=#hl-19-74>74</a>
</span><span class=lnt id=hl-19-75><a class=lnlinks href=#hl-19-75>75</a>
</span><span class=lnt id=hl-19-76><a class=lnlinks href=#hl-19-76>76</a>
</span><span class=lnt id=hl-19-77><a class=lnlinks href=#hl-19-77>77</a>
</span><span class=lnt id=hl-19-78><a class=lnlinks href=#hl-19-78>78</a>
</span><span class=lnt id=hl-19-79><a class=lnlinks href=#hl-19-79>79</a>
</span><span class=lnt id=hl-19-80><a class=lnlinks href=#hl-19-80>80</a>
</span><span class=lnt id=hl-19-81><a class=lnlinks href=#hl-19-81>81</a>
</span><span class=lnt id=hl-19-82><a class=lnlinks href=#hl-19-82>82</a>
</span><span class=lnt id=hl-19-83><a class=lnlinks href=#hl-19-83>83</a>
</span><span class=lnt id=hl-19-84><a class=lnlinks href=#hl-19-84>84</a>
</span><span class=lnt id=hl-19-85><a class=lnlinks href=#hl-19-85>85</a>
</span><span class=lnt id=hl-19-86><a class=lnlinks href=#hl-19-86>86</a>
</span><span class=lnt id=hl-19-87><a class=lnlinks href=#hl-19-87>87</a>
</span><span class=lnt id=hl-19-88><a class=lnlinks href=#hl-19-88>88</a>
</span><span class=lnt id=hl-19-89><a class=lnlinks href=#hl-19-89>89</a>
</span><span class=lnt id=hl-19-90><a class=lnlinks href=#hl-19-90>90</a>
</span><span class=lnt id=hl-19-91><a class=lnlinks href=#hl-19-91>91</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>BankAccount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;은행 계좌 클래스&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>account_id</span><span class=p>,</span> <span class=n>initial_balance</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>account_id</span> <span class=o>=</span> <span class=n>account_id</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>=</span> <span class=n>initial_balance</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>lock</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_balance</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>balance</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>update_balance</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>balance</span> <span class=o>+=</span> <span class=n>amount</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>bank_transfer_simulation</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;은행 이체 시뮬레이션 - 락킹 프로토콜 적용&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 시스템 초기화</span>
</span></span><span class=line><span class=cl>    <span class=n>lock_manager</span> <span class=o>=</span> <span class=n>LockManager</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>accounts</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;A&#39;</span><span class=p>:</span> <span class=n>BankAccount</span><span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=mi>1000</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;B&#39;</span><span class=p>:</span> <span class=n>BankAccount</span><span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=mi>500</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;C&#39;</span><span class=p>:</span> <span class=n>BankAccount</span><span class=p>(</span><span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=mi>750</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>transfer</span><span class=p>(</span><span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>,</span> <span class=n>amount</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;계좌 이체 함수 - 락킹 프로토콜을 사용한 안전한 이체&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>tx</span> <span class=o>=</span> <span class=n>Transaction</span><span class=p>(</span><span class=n>tx_id</span><span class=p>,</span> <span class=n>lock_manager</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 출금 계좌에서 배타락 획득 (읽기 + 쓰기)</span>
</span></span><span class=line><span class=cl>            <span class=n>current_balance</span> <span class=o>=</span> <span class=n>accounts</span><span class=p>[</span><span class=n>from_account</span><span class=p>]</span><span class=o>.</span><span class=n>get_balance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>current_balance</span> <span class=o>&lt;</span> <span class=n>amount</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;TX</span><span class=si>{</span><span class=n>tx_id</span><span class=si>}</span><span class=s2>: 잔액 부족 - </span><span class=si>{</span><span class=n>from_account</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>current_balance</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>tx</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 양쪽 계좌 모두에 배타락 필요 (데드락 방지를 위해 알파벳 순서로 획득)</span>
</span></span><span class=line><span class=cl>            <span class=n>accounts_to_lock</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>([</span><span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>account</span> <span class=ow>in</span> <span class=n>accounts_to_lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>tx</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>account</span><span class=p>,</span> <span class=sa>f</span><span class=s2>&#34;lock_acquired&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 실제 이체 수행</span>
</span></span><span class=line><span class=cl>            <span class=n>accounts</span><span class=p>[</span><span class=n>from_account</span><span class=p>]</span><span class=o>.</span><span class=n>update_balance</span><span class=p>(</span><span class=o>-</span><span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>0.05</span><span class=p>)</span>  <span class=c1># 네트워크 지연 시뮬레이션</span>
</span></span><span class=line><span class=cl>            <span class=n>accounts</span><span class=p>[</span><span class=n>to_account</span><span class=p>]</span><span class=o>.</span><span class=n>update_balance</span><span class=p>(</span><span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;TX</span><span class=si>{</span><span class=n>tx_id</span><span class=si>}</span><span class=s2>: 이체 완료 </span><span class=si>{</span><span class=n>from_account</span><span class=si>}</span><span class=s2> -&gt; </span><span class=si>{</span><span class=n>to_account</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>amount</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>tx</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;TX</span><span class=si>{</span><span class=n>tx_id</span><span class=si>}</span><span class=s2>: 이체 실패 - </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>tx</span><span class=o>.</span><span class=n>rollback</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 동시 이체 시나리오 실행</span>
</span></span><span class=line><span class=cl>    <span class=n>threads</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>scenarios</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=s1>&#39;B&#39;</span><span class=p>,</span> <span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=mi>200</span><span class=p>,</span> <span class=mi>2</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=mi>150</span><span class=p>,</span> <span class=mi>3</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=s1>&#39;A&#39;</span><span class=p>,</span> <span class=s1>&#39;C&#39;</span><span class=p>,</span> <span class=mi>300</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>from_acc</span><span class=p>,</span> <span class=n>to_acc</span><span class=p>,</span> <span class=n>amount</span><span class=p>,</span> <span class=n>tx_id</span> <span class=ow>in</span> <span class=n>scenarios</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>target</span><span class=o>=</span><span class=n>transfer</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=n>args</span><span class=o>=</span><span class=p>(</span><span class=n>from_acc</span><span class=p>,</span> <span class=n>to_acc</span><span class=p>,</span> <span class=n>amount</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>threads</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 모든 트랜잭션 완료 대기</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>threads</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 최종 잔액 확인</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>=== 최종 잔액 ===&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>total_before</span> <span class=o>=</span> <span class=mi>1000</span> <span class=o>+</span> <span class=mi>500</span> <span class=o>+</span> <span class=mi>750</span>  <span class=c1># 초기 총 잔액</span>
</span></span><span class=line><span class=cl>    <span class=n>total_after</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>acc</span><span class=o>.</span><span class=n>get_balance</span><span class=p>()</span> <span class=k>for</span> <span class=n>acc</span> <span class=ow>in</span> <span class=n>accounts</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>acc_id</span><span class=p>,</span> <span class=n>account</span> <span class=ow>in</span> <span class=n>accounts</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;계좌 </span><span class=si>{</span><span class=n>acc_id</span><span class=si>}</span><span class=s2>: </span><span class=si>{</span><span class=n>account</span><span class=o>.</span><span class=n>get_balance</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;잔액 보존 검증: </span><span class=si>{</span><span class=n>total_before</span><span class=si>}</span><span class=s2> -&gt; </span><span class=si>{</span><span class=n>total_after</span><span class=si>}</span><span class=s2> (</span><span class=si>{</span><span class=s1>&#39;성공&#39;</span> <span class=k>if</span> <span class=n>total_before</span> <span class=o>==</span> <span class=n>total_after</span> <span class=k>else</span> <span class=s1>&#39;실패&#39;</span><span class=si>}</span><span class=s2>)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 실행</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>bank_transfer_simulation</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><h6 id=실행-결과-4>실행 결과<a hidden class=anchor aria-hidden=true href=#실행-결과-4>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-20-1><a class=lnlinks href=#hl-20-1> 1</a>
</span><span class=lnt id=hl-20-2><a class=lnlinks href=#hl-20-2> 2</a>
</span><span class=lnt id=hl-20-3><a class=lnlinks href=#hl-20-3> 3</a>
</span><span class=lnt id=hl-20-4><a class=lnlinks href=#hl-20-4> 4</a>
</span><span class=lnt id=hl-20-5><a class=lnlinks href=#hl-20-5> 5</a>
</span><span class=lnt id=hl-20-6><a class=lnlinks href=#hl-20-6> 6</a>
</span><span class=lnt id=hl-20-7><a class=lnlinks href=#hl-20-7> 7</a>
</span><span class=lnt id=hl-20-8><a class=lnlinks href=#hl-20-8> 8</a>
</span><span class=lnt id=hl-20-9><a class=lnlinks href=#hl-20-9> 9</a>
</span><span class=lnt id=hl-20-10><a class=lnlinks href=#hl-20-10>10</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>TX1: 이체 완료 A -&gt; B: 100
</span></span><span class=line><span class=cl>TX3: 이체 완료 C -&gt; A: 150  
</span></span><span class=line><span class=cl>TX2: 이체 완료 B -&gt; C: 200
</span></span><span class=line><span class=cl>TX4: 이체 완료 A -&gt; C: 300
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>=== 최종 잔액 ===
</span></span><span class=line><span class=cl>계좌 A: 750   # 1000 - 100 + 150 - 300
</span></span><span class=line><span class=cl>계좌 B: 400   # 500 + 100 - 200  
</span></span><span class=line><span class=cl>계좌 C: 1100  # 750 - 150 + 200 + 300
</span></span><span class=line><span class=cl>잔액 보존 검증: 2250 -&gt; 2250 성공
</span></span></code></pre></td></tr></table></div></div><h6 id=추가-실험-4>추가 실험<a hidden class=anchor aria-hidden=true href=#추가-실험-4>#</a></h6><ol><li><strong>데드락 상황 유발</strong>: 트랜잭션들이 서로 다른 순서로 락을 요청하도록 수정</li><li><strong>성능 비교</strong>: 락킹 vs 낙관적 동시성 제어 성능 측정</li><li><strong>확장성 테스트</strong>: 트랜잭션 수를 늘려가며 처리량 변화 관찰</li></ol><h4 id=실제-도입-사례-분석>실제 도입 사례 분석<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-분석>#</a></h4><h5 id=실제-도입-사례-네이버-클라우드-플랫폼의-분산-락킹-시스템>실제 도입 사례: 네이버 클라우드 플랫폼의 분산 락킹 시스템<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-네이버-클라우드-플랫폼의-분산-락킹-시스템>#</a></h5><h6 id=배경-및-도입-이유>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유>#</a></h6><p><strong>비즈니스 목표</strong>: 마이크로서비스 아키텍처에서 분산 트랜잭션의 일관성 보장<br><strong>기술적 도전</strong>:</p><ul><li>서비스 간 데이터 일관성 유지</li><li>분산 환경에서 데드락 방지</li><li>높은 가용성과 확장성 요구</li></ul><p><strong>제약사항</strong>:</p><ul><li>네트워크 지연 및 분할 내성 필요</li><li>초당 10 만 TPS 이상 처리</li><li>99.99% 가용성 요구</li></ul><h6 id=구현-아키텍처>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처>#</a></h6><pre class=mermaid>graph TB
    subgraph &#34;Client Services&#34;
        A[Payment Service]
        B[Inventory Service] 
        C[Order Service]
    end
    
    subgraph &#34;Distributed Lock Manager&#34;
        D[Lock Coordinator]
        E[Consensus Module&lt;br/&gt;Raft Algorithm]
        F[Lock Registry]
    end
    
    subgraph &#34;Storage Layer&#34;
        G[(Primary DB)]
        H[(Replica DB)]
        I[Redis Cache]
    end
    
    A --&gt; D
    B --&gt; D
    C --&gt; D
    D --&gt; E
    E --&gt; F
    D --&gt; I
    F --&gt; G
    G --&gt; H
</pre><h6 id=핵심-구현-코드>핵심 구현 코드<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-22-1><a class=lnlinks href=#hl-22-1> 1</a>
</span><span class=lnt id=hl-22-2><a class=lnlinks href=#hl-22-2> 2</a>
</span><span class=lnt id=hl-22-3><a class=lnlinks href=#hl-22-3> 3</a>
</span><span class=lnt id=hl-22-4><a class=lnlinks href=#hl-22-4> 4</a>
</span><span class=lnt id=hl-22-5><a class=lnlinks href=#hl-22-5> 5</a>
</span><span class=lnt id=hl-22-6><a class=lnlinks href=#hl-22-6> 6</a>
</span><span class=lnt id=hl-22-7><a class=lnlinks href=#hl-22-7> 7</a>
</span><span class=lnt id=hl-22-8><a class=lnlinks href=#hl-22-8> 8</a>
</span><span class=lnt id=hl-22-9><a class=lnlinks href=#hl-22-9> 9</a>
</span><span class=lnt id=hl-22-10><a class=lnlinks href=#hl-22-10>10</a>
</span><span class=lnt id=hl-22-11><a class=lnlinks href=#hl-22-11>11</a>
</span><span class=lnt id=hl-22-12><a class=lnlinks href=#hl-22-12>12</a>
</span><span class=lnt id=hl-22-13><a class=lnlinks href=#hl-22-13>13</a>
</span><span class=lnt id=hl-22-14><a class=lnlinks href=#hl-22-14>14</a>
</span><span class=lnt id=hl-22-15><a class=lnlinks href=#hl-22-15>15</a>
</span><span class=lnt id=hl-22-16><a class=lnlinks href=#hl-22-16>16</a>
</span><span class=lnt id=hl-22-17><a class=lnlinks href=#hl-22-17>17</a>
</span><span class=lnt id=hl-22-18><a class=lnlinks href=#hl-22-18>18</a>
</span><span class=lnt id=hl-22-19><a class=lnlinks href=#hl-22-19>19</a>
</span><span class=lnt id=hl-22-20><a class=lnlinks href=#hl-22-20>20</a>
</span><span class=lnt id=hl-22-21><a class=lnlinks href=#hl-22-21>21</a>
</span><span class=lnt id=hl-22-22><a class=lnlinks href=#hl-22-22>22</a>
</span><span class=lnt id=hl-22-23><a class=lnlinks href=#hl-22-23>23</a>
</span><span class=lnt id=hl-22-24><a class=lnlinks href=#hl-22-24>24</a>
</span><span class=lnt id=hl-22-25><a class=lnlinks href=#hl-22-25>25</a>
</span><span class=lnt id=hl-22-26><a class=lnlinks href=#hl-22-26>26</a>
</span><span class=lnt id=hl-22-27><a class=lnlinks href=#hl-22-27>27</a>
</span><span class=lnt id=hl-22-28><a class=lnlinks href=#hl-22-28>28</a>
</span><span class=lnt id=hl-22-29><a class=lnlinks href=#hl-22-29>29</a>
</span><span class=lnt id=hl-22-30><a class=lnlinks href=#hl-22-30>30</a>
</span><span class=lnt id=hl-22-31><a class=lnlinks href=#hl-22-31>31</a>
</span><span class=lnt id=hl-22-32><a class=lnlinks href=#hl-22-32>32</a>
</span><span class=lnt id=hl-22-33><a class=lnlinks href=#hl-22-33>33</a>
</span><span class=lnt id=hl-22-34><a class=lnlinks href=#hl-22-34>34</a>
</span><span class=lnt id=hl-22-35><a class=lnlinks href=#hl-22-35>35</a>
</span><span class=lnt id=hl-22-36><a class=lnlinks href=#hl-22-36>36</a>
</span><span class=lnt id=hl-22-37><a class=lnlinks href=#hl-22-37>37</a>
</span><span class=lnt id=hl-22-38><a class=lnlinks href=#hl-22-38>38</a>
</span><span class=lnt id=hl-22-39><a class=lnlinks href=#hl-22-39>39</a>
</span><span class=lnt id=hl-22-40><a class=lnlinks href=#hl-22-40>40</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>DistributedLockManager</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;분산 락킹 프로토콜 구현 - 실제 시스템 단순화 버전&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node_id</span><span class=p>,</span> <span class=n>cluster_nodes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>node_id</span> <span class=o>=</span> <span class=n>node_id</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cluster_nodes</span> <span class=o>=</span> <span class=n>cluster_nodes</span>  <span class=c1># 다른 노드들의 주소</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>local_locks</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 로컬 락 저장소</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>global_view</span> <span class=o>=</span> <span class=p>{}</span>  <span class=c1># 글로벌 락 상태 뷰</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>leader</span> <span class=o>=</span> <span class=kc>None</span>  <span class=c1># 리더 노드 정보</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>acquire_distributed_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>30</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;분산 락 획득 - 2PC (Two-Phase Commit) 기반&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># Phase 1: 모든 노드에 락 요청 준비</span>
</span></span><span class=line><span class=cl>        <span class=n>prepare_votes</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cluster_nodes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>vote</span> <span class=o>=</span> <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>send_prepare_request</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>prepare_votes</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vote</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=c1># 모든 노드가 동의해야 진행</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>all</span><span class=p>(</span><span class=n>vote</span> <span class=o>==</span> <span class=s1>&#39;YES&#39;</span> <span class=k>for</span> <span class=n>vote</span> <span class=ow>in</span> <span class=n>prepare_votes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># Phase 2: 커밋 - 모든 노드에 락 부여 확정</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cluster_nodes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>send_commit_request</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Phase 2: 중단 - 모든 노드에 취소 통보</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cluster_nodes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>send_abort_request</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>release_distributed_lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;분산 락 해제&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>release_tasks</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cluster_nodes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>send_release_request</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>resource_id</span><span class=p>,</span> <span class=n>tx_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>release_tasks</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># 비동기적으로 모든 노드에 해제 요청</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=o>*</span><span class=n>release_tasks</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과>#</a></h6><p><strong>정량 지표:</strong></p><ul><li><strong>처리량</strong>: 95,000 TPS → 120,000 TPS (26% 향상)</li><li><strong>응답 시간</strong>: P99 기준 200ms → 150ms (25% 개선)</li><li><strong>가용성</strong>: 99.95% → 99.99% (장애 시간 연간 4 시간 → 1 시간)</li></ul><p><strong>정성 개선:</strong></p><ul><li>데드락으로 인한 서비스 중단 완전 제거</li><li>마이크로서비스 간 데이터 일관성 100% 보장</li><li>운영팀의 장애 대응 시간 70% 단축</li></ul><h6 id=교훈-및-시사점>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점>#</a></h6><p><strong>재현 시 유의점:</strong></p><ol><li><strong>네트워크 분할 대비</strong>: Byzantine Fault Tolerance 고려 필요</li><li><strong>백프레셔 제어</strong>: 락 대기 큐가 무한정 증가하지 않도록 제한</li><li><strong>관측성</strong>: 락 경합 상황을 실시간으로 모니터링할 수 있는 대시보드 필수</li></ol><p><strong>확장 아이디어:</strong></p><ul><li>머신러닝 기반 데드락 예측 시스템 도입</li><li>지리적 분산을 고려한 글로벌 락킹 최적화</li></ul><h5 id=실제-도입-사례-금융권-실시간-계좌-트랜잭션>실제 도입 사례: 금융권 실시간 계좌 트랜잭션<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-금융권-실시간-계좌-트랜잭션>#</a></h5><h6 id=배경-및-도입-이유-1>배경 및 도입 이유<a hidden class=anchor aria-hidden=true href=#배경-및-도입-이유-1>#</a></h6><ul><li>실시간 동시 요청 과다 (예: 급여 이체, 이중 인출 등)</li><li>데이터 일관성, 오류·중복 방지 요구 부각</li></ul><h6 id=구현-아키텍처-1>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처-1>#</a></h6><ul><li>계좌정보 단위 Exclusive Lock</li><li>커밋 시 동시성 체크·일괄 갱신</li></ul><pre class=mermaid>graph TB
    USER[사용자] --&gt; API[API 게이트웨이]
    API --&gt; DB[DBMS Lock Manager]
    DB --&gt; MON[Lock 모니터링/데드락 탐지]
</pre><h6 id=핵심-구현-코드-예시>핵심 구현 코드 (예시)<a hidden class=anchor aria-hidden=true href=#핵심-구현-코드-예시>#</a></h6><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-24-1><a class=lnlinks href=#hl-24-1>1</a>
</span><span class=lnt id=hl-24-2><a class=lnlinks href=#hl-24-2>2</a>
</span><span class=lnt id=hl-24-3><a class=lnlinks href=#hl-24-3>3</a>
</span><span class=lnt id=hl-24-4><a class=lnlinks href=#hl-24-4>4</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>transfer</span><span class=p>(</span><span class=n>from_account</span><span class=p>,</span> <span class=n>to_account</span><span class=p>,</span> <span class=n>amount</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=n>lock</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># A와 B 모두 락 후 금액 이체 원자성 보장</span>
</span></span><span class=line><span class=cl>        <span class=err>…</span>
</span></span></code></pre></td></tr></table></div></div><h6 id=성과-및-결과-1>성과 및 결과<a hidden class=anchor aria-hidden=true href=#성과-및-결과-1>#</a></h6><ul><li>동시 실행 환경에서도 불일치/이중처리 없음</li><li>장애 발생 시 연쇄 롤백 없이 복구 용이</li></ul><h6 id=교훈-및-시사점-1>교훈 및 시사점<a hidden class=anchor aria-hidden=true href=#교훈-및-시사점-1>#</a></h6><ul><li>대량 쓰기 상황에서 Lock Granularity(세분화 - 통합) 조정, 데드락 자동 관리가 실무 성패 좌우</li></ul><h5 id=실제-도입-사례-전자상거래-주문재고-시스템의-strict-2pl-적용>실제 도입 사례: 전자상거래 주문/재고 시스템의 Strict 2PL 적용<a hidden class=anchor aria-hidden=true href=#실제-도입-사례-전자상거래-주문재고-시스템의-strict-2pl-적용>#</a></h5><h6 id=배경이유>배경/이유<a hidden class=anchor aria-hidden=true href=#배경이유>#</a></h6><ul><li>재고 감소/결제 동시성에서 <strong>잃어버린 업데이트</strong>와 <strong>더티 리드</strong> 방지 필요.</li></ul><h6 id=구현-아키텍처-2>구현 아키텍처<a hidden class=anchor aria-hidden=true href=#구현-아키텍처-2>#</a></h6><ul><li>서비스 계층에서 <strong>짧은 트랜잭션 경계</strong> 유지, DB 는 <strong>Strict 2PL + 인덱스 기반 범위 락</strong>.</li></ul><pre class=mermaid>graph TB
  API[Order API] --&gt; SVC[Order Service]
  SVC --&gt; DB[(DB: Strict 2PL)]
  SVC --&gt; INV[(Inventory)]
  DB --&gt;|Next-Key Locks| IDX[(B+Tree Index)]
</pre><h6 id=핵심-구현-포인트>핵심 구현 포인트<a hidden class=anchor aria-hidden=true href=#핵심-구현-포인트>#</a></h6><ul><li><code>SELECT … FOR UPDATE</code> 는 꼭 필요한 키 범위에 한정.</li><li>장기 보류 작업 (결제 게이트웨이 호출) 은 트랜잭션 밖에서 <strong>사가 (Saga) 패턴</strong>으로 처리.</li></ul><h6 id=성과>성과<a hidden class=anchor aria-hidden=true href=#성과>#</a></h6><ul><li>더티 리드/잃어버린 업데이트 제거, 롤백 단순화. P95 지연은 약간 증가했으나 재시도/사가로 흡수.</li></ul><h6 id=교훈>교훈<a hidden class=anchor aria-hidden=true href=#교훈>#</a></h6><ul><li>트랜잭션을 <strong>짧게</strong>, 인덱스 <strong>선행 설계</strong>, 핫키 <strong>분산</strong>.</li></ul><h4 id=락-프로토콜-통합연계-기술-지도>락 프로토콜 통합·연계 기술 지도<a hidden class=anchor aria-hidden=true href=#락-프로토콜-통합연계-기술-지도>#</a></h4><ul><li>락 프로토콜은 단지 " 누가 언제 잠그느냐 " 규칙만이 아니다. 실제로는 <strong>트랜잭션 매니저, 로그 (복구), 복제, 인덱스, 샤딩, 캐시, 메시징 등 여러 시스템과 함께 작동</strong>해야 안전하고 빠르다.</li><li>예: 쓰기 변경을 WAL 에 기록하고 안전히 플러시한 뒤에 락을 해제하면 복구가 안전하다. 분산 환경에선 로컬 락으로 빠르게 처리하고 교차 파티션 작업만 글로벌 합의를 거친다.</li><li>운영에서는 락 대기시간, 데드락 빈도 같은 메트릭을 관찰해 자동 경고/조치를 연결해야 한다.</li></ul><h5 id=락-통합-기술-요약표>락 통합 기술 요약표<a hidden class=anchor aria-hidden=true href=#락-통합-기술-요약표>#</a></h5><table><thead><tr><th>통합 대상</th><th>왜 통합하는가 (문제)</th><th style=text-align:right>무엇을 통합 (기능)</th><th>어떻게 통합 (기술/패턴)</th><th>획득 가치</th></tr></thead><tbody><tr><td>TX Manager ↔ Lock Protocol</td><td>커밋/롤백 타이밍과 락 해제 정합성 필요</td><td style=text-align:right>커밋 시점과 락 해제 동기화</td><td>Strict 2PL 시 쓰기락은 커밋까지 유지, WAL 과 커밋 동기화</td><td>복구·회복성 보장, cascading rollback 방지</td></tr><tr><td>WAL ↔ Locking</td><td>장애 시 일관성 확보 필요</td><td style=text-align:right>로그 기반 복구와 미확정 변경 숨김</td><td>WAL 먼저, commit 후 flush → 락 해제 규칙 연계</td><td>안전한 복구, 데이터 무결성</td></tr><tr><td>Replication ↔ Locking</td><td>복제 지연이 일관성에 영향</td><td style=text-align:right>동기/비동기 복제 정책과 락 해제 시점 연계</td><td>동기 복제: commit 블로킹, 비동기: 로컬 커밋 우선</td><td>다중 리전 정책·일관성 - 지연 선택 가능</td></tr><tr><td>MVCC ↔ Locking</td><td>읽기 성능과 쓰기 일관성 동시 확보</td><td style=text-align:right>읽기는 버전, 쓰기는 선택적 락</td><td>MVCC + SELECT FOR UPDATE(선택적 락)</td><td>읽기 처리량 증대 + 필요한 쓰기 안전성 확보</td></tr><tr><td>Sharding/Partition ↔ Locking</td><td>스케일 아웃 시 글로벌 락 비용</td><td style=text-align:right>로컬 락 우선, 크로스샤드 조정</td><td>샤드별 LM + 글로벌 coord(또는 2PC)</td><td>로컬 성능 극대화, 글로벌 조정으로 일관성 확보</td></tr><tr><td>Distributed Coordinator ↔ Locking</td><td>분산 환경에서 일관적 락 필요</td><td style=text-align:right>etcd/ZK/Redis 기반 분산 락</td><td>Raft/Consensus 기반 리더 선출 + TTL, lease 사용</td><td>분산 환경에서 안전한 상호배제 제공</td></tr><tr><td>Saga/Outbox ↔ Locking</td><td>긴 트랜잭션·분산 작업의 일관성</td><td style=text-align:right>DB 트랜잭션 + 이벤트 발행의 원자성</td><td>Outbox 테이블에 로그 저장 → 별도 프로세스에서 전송</td><td>장기 트랜잭션 문제 회피, 가용성 향상</td></tr><tr><td>Cache ↔ Locking</td><td>캐시 일관성 문제</td><td style=text-align:right>캐시 무효화/업데이트 연계</td><td>Write-through/Invalidate + DB 트랜잭션과 결합</td><td>캐시 효율 유지 + 일관성 확보</td></tr><tr><td>Observability ↔ Locking</td><td>운영·디버깅 불가시 문제</td><td style=text-align:right>락 메트릭/데드락 로그/에스컬레이션 지표</td><td>Metrics/Tracing/Alerts(예: lock_wait_P95)</td><td>빠른 진단·자동화 트리거로 안정성 향상</td></tr></tbody></table><h5 id=락-통합-기술-카테고리>락 통합 기술 카테고리<a hidden class=anchor aria-hidden=true href=#락-통합-기술-카테고리>#</a></h5><h6 id=핵심-트랜잭션복구-통합>핵심 트랜잭션·복구 통합<a hidden class=anchor aria-hidden=true href=#핵심-트랜잭션복구-통합>#</a></h6><p><strong>내용</strong></p><ul><li><strong>왜:</strong> 커밋/롤백 정책과 락 해제는 데이터 무결성·복구에 직접 영향. WAL 이 디스크에 안전히 기록되기 전 상태를 다른 트랜잭션에 노출하면 복구 시 일관성 깨짐.</li><li><strong>무엇을 통합:</strong> TX Manager(트랜잭션 상태), WAL(쓰기 로그), 복제 모듈 (동기/비동기 정책).</li><li><strong>어떻게:</strong> Strict 2PL 규칙과 &ldquo;WAL flush → commit → 락 해제 " 의 순서 보장. 동기 복제 시엔 remote ack 를 commit 전 대기하도록 선택 가능. 운영적으로는 commit-latency, fsync 주기, replication lag 모니터링 필요.</li><li><strong>가치:</strong> 회복성 강화, cascading rollback 방지, 복제 일관성 선택 가능.</li></ul><table><thead><tr><th>기술</th><th>통합 방식</th><th style=text-align:right>목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>TX Manager + WAL</td><td>commit 순서 연계 (WAL flush → commit → 락 해제)</td><td style=text-align:right>복구·일관성 보장</td><td>안전한 복구</td><td>fsync 비용, commit latency</td></tr><tr><td>Replication</td><td>동기/비동기 정책에 따른 commit 처리</td><td style=text-align:right>복제 일관성/지연 조절</td><td>글로벌 일관성 제어</td><td>동기 시 지연 증가</td></tr></tbody></table><ul><li>요약: 트랜잭션·로그·복제는 락 정책과 함께 설계해야 데이터 일관성과 복구가 보장된다.</li></ul><h6 id=데이터-레이어-통합-인덱스파티셔닝샤딩>데이터 레이어 통합 (인덱스·파티셔닝·샤딩)<a hidden class=anchor aria-hidden=true href=#데이터-레이어-통합-인덱스파티셔닝샤딩>#</a></h6><p><strong>내용</strong></p><ul><li><strong>왜:</strong> 잘못된 인덱스나 비효율적인 파티셔닝은 범위 스캔을 유발해 락 충돌을 키운다. 샤딩은 락 범위를 줄여 로컬 작업 성능을 높일 수 있다.</li><li><strong>무엇을 통합:</strong> B+ 트리 인덱스, 파티셔닝 키, 샤드 라우팅, 에스컬레이션 정책.</li><li><strong>어떻게:</strong> 인덱스 설계로 범위 락을 최소화 (복합 인덱스, 커버링), 파티셔닝으로 데이터 지역성 확보, 샤드별 로컬 락 관리 후 교차샤드 작업은 조정 (2PC 또는 compensation).</li><li><strong>가치:</strong> 락 경합 감소→처리량 향상, 에스컬레이션 빈도 축소.</li></ul><table><thead><tr><th>기술</th><th>통합 방식</th><th style=text-align:right>목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>B+ 트리 인덱스</td><td>적절한 인덱스 설계로 범위 스캔 축소</td><td style=text-align:right>범위 락 최소화</td><td>락 획득 수 감소</td><td>인덱스 추가 비용</td></tr><tr><td>파티셔닝/샤딩</td><td>로컬 락 우선 + 글로벌 조정</td><td style=text-align:right>스케일 아웃·로컬 충돌 감소</td><td>로컬 TPS 증가</td><td>크로스샤드 트랜잭션 비용</td></tr></tbody></table><ul><li>요약: 데이터 구조와 파티셔닝은 락 빈도·범위를 근본적으로 바꿔 성능에 큰 영향을 준다.</li></ul><h6 id=분산-조정락-코디네이터>분산 조정·락 코디네이터<a hidden class=anchor aria-hidden=true href=#분산-조정락-코디네이터>#</a></h6><p><strong>내용</strong></p><ul><li><strong>왜:</strong> 분산 환경에서 단일 노드 락만으로는 일관성 보장이 불가하거나 비효율적이다.</li><li><strong>무엇을 통합:</strong> etcd/ZooKeeper/Redis(lease/TTL) 또는 전용 분산락 서비스, Consensus(Raft/Paxos) 기반 coord.</li><li><strong>어떻게:</strong> 샤드간 교차락이나 글로벌 자원에 대해 분산 코디네이터를 사용해 lease/TTL 로 락 보장. 로컬 작업은 로컬 LM 에서 처리해 성능 확보.</li><li><strong>가치:</strong> 분산 시스템에서 안전한 상호배제와 장애 복원성 제공.</li></ul><table><thead><tr><th>기술</th><th>통합 방식</th><th style=text-align:right>목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>etcd / ZK</td><td>Consensus 기반 lease/seq lock</td><td style=text-align:right>글로벌 락 조정</td><td>고신뢰성 락</td><td>네트워크 비용, 복잡성</td></tr><tr><td>Redis (Redlock)</td><td>분산 락 알고리즘</td><td style=text-align:right>빠른 분산 락 제공</td><td>낮은 지연</td><td>안전성 논쟁, TTL 주의</td></tr></tbody></table><ul><li>요약: 분산 락은 로컬 성능을 해치지 않으면서 글로벌 일관성을 어느 정도 확보하는 수단이지만, 구현·운영 복잡성이 커진다.</li></ul><h6 id=분산-트랜잭션패턴-saga--outbox>분산 트랜잭션·패턴 (Saga / Outbox)<a hidden class=anchor aria-hidden=true href=#분산-트랜잭션패턴-saga--outbox>#</a></h6><p><strong>내용</strong></p><ul><li><strong>왜:</strong> 분산·장기 트랜잭션은 전통적 락으로는 가용성·성능을 보장하기 어렵다.</li><li><strong>무엇을 통합:</strong> Saga 패턴 (비동기 보상), Outbox(트랜잭션 내 이벤트 저장 → 비동기 전달).</li><li><strong>어떻게:</strong> 트랜잭션 내부에서 Outbox 테이블에 이벤트를 기록 (동일 트랜잭션으로 원자성 보장), 별도 배치/worker 가 메시지를 발송. Saga 는 각 스텝의 보상 (Compensation) 을 설계.</li><li><strong>가치:</strong> 분산 작업의 가용성 증가, 긴 트랜잭션에 따른 락 유지 시간 최소화.</li></ul><table><thead><tr><th>기술</th><th>통합 방식</th><th style=text-align:right>목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>Outbox</td><td>DB 트랜잭션 내부에 이벤트 기록 → 별도 전송</td><td style=text-align:right>원자성 있는 이벤트 배포</td><td>exactly-once 보장 (구현 시)</td><td>배포 지연, 모니터링 필요</td></tr><tr><td>Saga</td><td>비동기 단계 + 보상 트랜잭션</td><td style=text-align:right>장기 분산 트랜잭션 처리</td><td>높은 가용성</td><td>보상 로직 설계 복잡</td></tr></tbody></table><ul><li>요약: 분산 트랜잭션 문제는 메시지 기반 패턴으로 우회하는 것이 실무에서 효과적이다.</li></ul><h6 id=캐시관찰운영-자동화>캐시·관찰·운영 자동화<a hidden class=anchor aria-hidden=true href=#캐시관찰운영-자동화>#</a></h6><p><strong>내용</strong></p><ul><li><strong>왜:</strong> 캐시와 락이 잘못 연동되면 일관성 문제가 발생하고, 운영 가시성이 없으면 문제 파악이 늦어진다.</li><li><strong>무엇을 통합:</strong> 캐시 동기화 전략, 메트릭 (lock_wait_p95, deadlock_rate, escalation_count), 알람 및 자동화 (예: 자동 재시도, 제한 초과 시 권고/자동 KILL).</li><li><strong>어떻게:</strong> 트랜잭션에서 DB 변경 후 캐시 무효화 (Invalidate) 나 write-through 를 실행. 운영측은 Prometheus/Grafana 에 락 지표를 내보내고, 경계치 기반 알람·자동화 룰을 적용.</li><li><strong>가치:</strong> 캐시 일관성 유지, 빠른 문제탐지·자동 대응, 운영 비용 절감.</li></ul><table><thead><tr><th>기술</th><th>통합 방식</th><th style=text-align:right>목적</th><th>장점</th><th>고려사항</th></tr></thead><tbody><tr><td>Cache (Invalidate/Write-through)</td><td>트랜잭션 후 invalidate or write-through</td><td style=text-align:right>캐시·DB 일관성</td><td>낮은 읽기 지연</td><td>실패 시 복구 전략</td></tr><tr><td>Observability</td><td>metrics/tracing/alerts</td><td style=text-align:right>운영가시성</td><td>빠른 문제탐지</td><td>수집 오버헤드</td></tr></tbody></table><ul><li>요약: 캐시와 관찰/자동화는 운영 안정성과 성능 최적화의 핵심 축이다.</li></ul><h5 id=락-연계-기술-통합-요약표>락 연계 기술 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-연계-기술-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 연계 대상</th><th>통합 방식 요약</th><th>기대 효과</th></tr></thead><tbody><tr><td>A. 트랜잭션·복구</td><td>TX Manager, WAL, Replication</td><td>커밋·로그·복제 정책과 락 해제 동기화</td><td>복구 안전성, 일관성</td></tr><tr><td>B. 데이터 레이어</td><td>인덱스, 파티셔닝, 샤딩</td><td>인덱스 최적화, 로컬 락, 샤드 라우팅</td><td>락 충돌 감소, 스케일 아웃</td></tr><tr><td>C. 분산 코디네이터</td><td>etcd/ZK/Redis, Consensus</td><td>글로벌 락은 coord, 로컬은 로컬 LM</td><td>분산 환경 일관성</td></tr><tr><td>D. 메시지 패턴</td><td>Outbox, Saga, MQ</td><td>트랜잭션 내 이벤트 기록 → 비동기 전송</td><td>긴 트랜잭션 회피, 가용성</td></tr><tr><td>E. 캐시·운영</td><td>Cache, Metrics, Automation</td><td>트랜잭션 - 캐시 동기화 + 모니터링</td><td>빠른 진단·운영 안정성</td></tr></tbody></table><h3 id=운영-및-최적화>운영 및 최적화<a hidden class=anchor aria-hidden=true href=#운영-및-최적화>#</a></h3><h4 id=락-성능확장성>락 성능·확장성<a hidden class=anchor aria-hidden=true href=#락-성능확장성>#</a></h4><p>락 시스템 성능 최적화와 확장성은 **&rdquo; 언제/어떤 수준으로 락을 걸지 " + " 락 정보를 어떻게 저장·조회·분산할지 &ldquo;**의 문제다.</p><ul><li>작은 단위 (행) 락은 동시성을 높지만 메타데이터가 커진다 → <strong>Adaptive Escalation</strong>으로 균형 맞춤.</li><li>락 조회를 빠르게 하기 위해 Bloom 필터 (없음 빠르게 판별) + 해시 (BY-ID 고속) + B+-Tree(범위) 조합을 쓴다.</li><li>분산환경에서는 <strong>정합성 요구</strong>에 따라 ZooKeeper/etcd(강정합) 또는 Redis(경량) 를 선택하고, 항상 장애·펜싱을 고려해야 한다.</li></ul><h5 id=락-성능확장성-최적화-요약표>락 성능·확장성 최적화 요약표<a hidden class=anchor aria-hidden=true href=#락-성능확장성-최적화-요약표>#</a></h5><table><thead><tr><th style=text-align:right>분류</th><th>기법 (무엇)</th><th>왜 (근거)</th><th>실행 (어떻게)</th><th style=text-align:right>핵심 KPI</th></tr></thead><tbody><tr><td style=text-align:right>에스컬레이션</td><td>Adaptive Escalation</td><td>락 메타 오버헤드↓, 자원 절약. 연구·실무 근거 있음.</td><td>동적 임계값·메모리 기반 보정·성공률 반영</td><td style=text-align:right>락 테이블 메모리, 락 수</td></tr><tr><td style=text-align:right>그레뉼러리티</td><td>세분화 (행)/쿼리 리팩터</td><td>범위 락·블로킹 감소</td><td>인덱스 최적화·쿼리 리라이팅</td><td style=text-align:right>평균 락 대기 (ms)</td></tr><tr><td style=text-align:right>데이터구조</td><td>Bloom + Hash + B+Tree</td><td>빠른 존재 체크·범위 검색 효율화.</td><td>Bloom Filter→해시→B+-Tree 순 검사</td><td style=text-align:right>락 조회 레이턴시</td></tr><tr><td style=text-align:right>분산 라우팅</td><td>Consistent Hashing/샤딩</td><td>노드 리밸런싱 비용 최소화</td><td>해시링 + 복제 + 헬스 체크</td><td style=text-align:right>리밸런싱 오프라인 시간</td></tr><tr><td style=text-align:right>분산락 선택</td><td>ZooKeeper/etcd vs Redis</td><td>정합성 대비 속도/운영 복잡성 균형.</td><td>컨센서스 (정합성) / Redis(경량) 선택 + 펜싱</td><td style=text-align:right>장애 시 오버슈트</td></tr><tr><td style=text-align:right>예측·적응</td><td>ML 기반 예측·스케줄링</td><td>사전 완화로 블로킹·데드락 감소 (연구중)</td><td>로그 수집→모델 학습→스케줄러 통합</td><td style=text-align:right>블로킹 이벤트 감지율</td></tr></tbody></table><h5 id=락-성능확장성-카테고리>락 성능·확장성 카테고리<a hidden class=anchor aria-hidden=true href=#락-성능확장성-카테고리>#</a></h5><h6 id=에스컬레이션그레뉼러리티-제어>에스컬레이션·그레뉼러리티 제어<a hidden class=anchor aria-hidden=true href=#에스컬레이션그레뉼러리티-제어>#</a></h6><ul><li>내용: 동적 임계값 기반 에스컬레이션 (행→테이블) 과, 쿼리/인덱스 리팩터링으로 락 대상 축소. 임계값은 메모리 압박·과거 성공률·현재 락 수로 보정.</li></ul><table><thead><tr><th style=text-align:right>항목</th><th>설명</th><th>실행 포인트</th></tr></thead><tbody><tr><td style=text-align:right>Adaptive Escalation</td><td>임계값·메모리·성공률 기반 승격 판단</td><td>트랜잭션별 락 카운터·메모리 모니터링</td></tr><tr><td style=text-align:right>세분화 설계</td><td>핫스폿 회피·파티셔닝</td><td>키 설계 (해시/증분 접미)</td></tr></tbody></table><ul><li>요약: 에스컬레이션은 관리 오버헤드·메모리 절감을 위해 필수이며, 임계값을 고정하지 말고 운영 지표에 맞춰 동적으로 조정하라.</li></ul><h6 id=데이터구조락-테이블-최적화>데이터구조·락 테이블 최적화<a hidden class=anchor aria-hidden=true href=#데이터구조락-테이블-최적화>#</a></h6><ul><li>내용: Bloom filter 로 " 존재여부 " 1 차 스크리닝, 해시로 포인트락 접근, B+-Tree 로 범위쿼리 처리. 락 테이블 파티셔닝과 메모리 압축 (레코드 압축) 권장.</li></ul><table><thead><tr><th style=text-align:right>항목</th><th>설명</th><th>실행 포인트</th></tr></thead><tbody><tr><td style=text-align:right>Bloom Filter</td><td>비존재 빠르게 판별</td><td>주기적 재빌드·용량관리</td></tr><tr><td style=text-align:right>Hash Index</td><td>포인트락 O(1) 접근</td><td>해시 충돌·리사이즈 정책</td></tr><tr><td style=text-align:right>B+-Tree</td><td>범위 락 쿼리</td><td>페이지 레벨 잠금 연동</td></tr></tbody></table><ul><li>요약: 락 조회 루틴을 계층화하면 불필요한 잠금 연산을 피할 수 있다.</li></ul><h6 id=분산-라우팅락-서비스-아키텍처>분산 라우팅·락 서비스 아키텍처<a hidden class=anchor aria-hidden=true href=#분산-라우팅락-서비스-아키텍처>#</a></h6><ul><li>내용: 리소스별 일관된 해싱으로 락을 샤드화하고, 복제·헬스 체크로 가용성 확보. 락 타입에 따라 ZooKeeper/etcd(정합성) 또는 Redis(경량) 선택. 펜싱 토큰·TTL 필수.</li></ul><table><thead><tr><th style=text-align:right>항목</th><th>설명</th><th>실행 포인트</th></tr></thead><tbody><tr><td style=text-align:right>Consistent Hashing</td><td>리밸런싱 비용 최소화</td><td>복제 인자·노드 헬스 반영</td></tr><tr><td style=text-align:right>Lock Service 선택</td><td>ZooKeeper vs Redis</td><td>정합성 요구 기반 선택</td></tr></tbody></table><ul><li>요약: 정합성이 중요하면 컨센서스 시스템, 단순 글로벌 뮤텍스면 Redis(단, 펜싱 설계 필수).</li></ul><h6 id=예측적응형-제어-ml정책엔진>예측·적응형 제어 (ML/정책엔진)<a hidden class=anchor aria-hidden=true href=#예측적응형-제어-ml정책엔진>#</a></h6><ul><li>내용: 로그 기반 모델 (Transformer/LSTM 등) 로 lock 요청·경합 예측 → 스케줄러/정책엔진에 반영 (우선순위 조정·선행 리소스 할당). 연구·PoC 단계지만 효과 기대.</li></ul><table><thead><tr><th style=text-align:right>항목</th><th>설명</th><th>실행 포인트</th></tr></thead><tbody><tr><td style=text-align:right>Lock Prediction</td><td>과거 로그로 경합 사전예측</td><td>로그 수집·피쳐 엔지니어링</td></tr><tr><td style=text-align:right>Policy Engine</td><td>예측에 따른 스케줄 변경</td><td>안전 (검증) 루틴 포함</td></tr></tbody></table><ul><li>요약: 예측 모델은 보조수단—우선은 규칙 기반 안전장치 (타임아웃·검증) 를 둬야 함.</li></ul><h6 id=운영모니터링kpi>운영·모니터링·KPI<a hidden class=anchor aria-hidden=true href=#운영모니터링kpi>#</a></h6><ul><li>내용: 핵심 지표 (평균 락 대기 (ms), 블로커 비율, 데드락 빈도, 에스컬레이션 빈도) 를 정의하고 대시보드·알람·자동화 (Head-blocker 탐지→검증→조치) 를 구축.</li></ul><table><thead><tr><th style=text-align:right>항목</th><th>설명</th><th>실행 포인트</th></tr></thead><tbody><tr><td style=text-align:right>KPI</td><td>avg wait / p99 / blocker %</td><td>알람 임계값 설정</td></tr><tr><td style=text-align:right>자동화</td><td>Head-blocker 탐지·대응</td><td>로그·권한·검증 루틴 포함</td></tr></tbody></table><ul><li>요약: 자동화는 운영 부담을 낮추지만, 자동 조치 전 검증 스텝을 반드시 둬라.</li></ul><h5 id=락-최적화확장성-기법-통합표>락 최적화·확장성 기법 통합표<a hidden class=anchor aria-hidden=true href=#락-최적화확장성-기법-통합표>#</a></h5><table><thead><tr><th style=text-align:right>카테고리</th><th>핵심 기법</th><th>목적</th><th>운영 포인트</th></tr></thead><tbody><tr><td style=text-align:right>에스컬레이션·그레인</td><td>Adaptive Escalation, 파티셔닝</td><td>메모리·메타 오버헤드↓, 블로킹↓</td><td>동적 임계값, 모니터링</td></tr><tr><td style=text-align:right>데이터구조</td><td>Bloom / Hash / B+-Tree</td><td>락 조회·범위 검색 최적화</td><td>재빌드·리사이즈 정책</td></tr><tr><td style=text-align:right>분산 아키텍처</td><td>Consistent Hashing, ZooKeeper/Redis</td><td>샤딩·정합성·가용성 확보</td><td>펜싱/TTL·마이그레이션</td></tr><tr><td style=text-align:right>예측·제어</td><td>ML 예측, 정책엔진</td><td>사전 완화로 블로킹/데드락 감소</td><td>로그·모델 검증·피드백</td></tr><tr><td style=text-align:right>운영</td><td>KPI, 자동대응, 알람</td><td>안정성·감시·복구 시간 단축</td><td>알람 임계·검증 스텝</td></tr></tbody></table><h4 id=락-시스템-트러블슈팅-체크리스트>락 시스템 트러블슈팅 체크리스트<a hidden class=anchor aria-hidden=true href=#락-시스템-트러블슈팅-체크리스트>#</a></h4><p>트러블슈팅은 언제나 <strong>탐지 → 진단 → 임시조치 → 근본대책</strong> 순서로 진행한다. 데드락·장기 락·핫스팟·분산락 문제는 각기 다른 원인을 가지므로 로그 (데드락 리포트), 메트릭 (locks/sec, wait time), 트랜잭션 스냅샷을 종합해 원인을 좁혀야 한다. 단기적으로는 자동 희생자 선정·타임아웃·임시 백오프를 사용하고, 장기적으로는 인덱스·쿼리·데이터 파티셔닝·아키텍처 변경으로 근본 해결한다.</p><h5 id=락-시스템-트러블슈팅-요약표>락 시스템 트러블슈팅 요약표<a hidden class=anchor aria-hidden=true href=#락-시스템-트러블슈팅-요약표>#</a></h5><table><thead><tr><th>문제</th><th style=text-align:right>주요 원인</th><th>탐지 지표/방법</th><th>즉시 조치</th><th>근본 해결</th></tr></thead><tbody><tr><td>데드락</td><td style=text-align:right>리소스 획득 순서 불일치, 복잡 TX</td><td>Deadlock logs, WFG 사이클</td><td>희생자 롤백 자동화</td><td>획득 순서 표준화, TX 단축</td></tr><tr><td>장기 보유 락</td><td style=text-align:right>긴 TX, 커밋 누락, 네트워크 이슈</td><td>오래된 lock holders, TX 활동 로그</td><td>강제 롤백·고아 락 정리</td><td>타임아웃, 트랜잭션 경계 명확화</td></tr><tr><td>핫스팟 경합</td><td style=text-align:right>특정 키 집중 업데이트</td><td>top locking resources, wait-time</td><td>트래픽 스로틀, 캐시</td><td>파티셔닝/샤딩, 데이터 모델 변경</td></tr><tr><td>팬텀 (범위 락)</td><td style=text-align:right>범위 스캔, 인덱스 부재</td><td>범위 락 빈도, 인덱스 사용률</td><td>쿼리 리팩토링, 인덱스 추가</td><td>인덱스 설계, SSI 고려</td></tr><tr><td>분산 락 오류</td><td style=text-align:right>네트워크 파티션, lease 문제</td><td>lease age, leader change 이벤트</td><td>leader 확인·재선출, 강제 만료</td><td>TTL/lease 튜닝, 지역성 설계</td></tr></tbody></table><h5 id=락-문제-유형별-트러블슈팅-카테고리>락 문제 유형별 트러블슈팅 카테고리<a hidden class=anchor aria-hidden=true href=#락-문제-유형별-트러블슈팅-카테고리>#</a></h5><h6 id=데드락-탐지해결>데드락 탐지·해결<a hidden class=anchor aria-hidden=true href=#데드락-탐지해결>#</a></h6><p>데드락은 순환 대기로 인해 트랜잭션들이 서로를 무한정 기다릴 때 발생한다. 탐지 (Wait-For 그래프), 자동 희생자 선택 (정책 기반), 로그 분석 (싸이클 구성원과 자원) → 즉시 희생자 롤백 → 원인 (락 획득 순서·긴 트랜잭션) 분석 → 획득 순서 표준화·TX 경량화로 예방한다.</p><table><thead><tr><th>항목</th><th>방법</th></tr></thead><tbody><tr><td>탐지</td><td>WFG 사이클 탐지, DB 데드락 로그</td></tr><tr><td>즉시조치</td><td>희생자 자동 롤백, 운영자 알림</td></tr><tr><td>근본해결</td><td>락 순서 표준화, 트랜잭션 단축</td></tr></tbody></table><ul><li>데드락은 자동탐지 + 자동회복을 기본으로 하고, 근본적으로는 애플리케이션의 자원 접근 순서와 트랜잭션 설계로 예방해야 한다.</li></ul><h6 id=장기-보유-락고아-락-처리>장기 보유 락·고아 락 처리<a hidden class=anchor aria-hidden=true href=#장기-보유-락고아-락-처리>#</a></h6><p>장기 보유 락은 트랜잭션이 비정상적으로 오래 락을 보유할 때 발생한다. 탐지 (오래된 락 보유자), 즉시 강제 롤백 또는 고아 락 강제 정리, 이후 타임아웃 정책·트랜잭션 가이드 발행으로 재발 방지한다.</p><table><thead><tr><th>항목</th><th>방법</th></tr></thead><tbody><tr><td>탐지</td><td>lock age, inactive TX 체크</td></tr><tr><td>즉시조치</td><td>강제 roll back, orphan lock cleanup</td></tr><tr><td>근본해결</td><td>TX timeout, commit/rollback 절차 강화</td></tr></tbody></table><ul><li>장기 락은 운영 장애를 직접 초래하므로 자동 알람과 강제 정리 루틴을 마련하고 트랜잭션 길이를 관리해야 한다.</li></ul><h6 id=락-경합-핫스팟-성능문제>락 경합 (핫스팟) 성능문제<a hidden class=anchor aria-hidden=true href=#락-경합-핫스팟-성능문제>#</a></h6><p>핫스팟은 특정 리소스에 동시 접근이 집중돼 성능이 급격히 떨어지는 현상이다. 탐지 (top locking resources, wait-time) → 임시 백오프/스로틀 → 근본적으로는 데이터 모델 변경·파티셔닝·인덱스·캐싱으로 해결한다.</p><table><thead><tr><th>항목</th><th>방법</th></tr></thead><tbody><tr><td>탐지</td><td>top locking resources, wait-time histogram</td></tr><tr><td>즉시조치</td><td>스로틀, 캐시, 우선순위 조정</td></tr><tr><td>근본해결</td><td>파티셔닝/샤딩, 인덱스·모델 변경</td></tr></tbody></table><ul><li>핫스팟 해결은 설계 변경을 필요로 하는 경우가 많으므로 성능 지표를 통해 조기에 탐지하고 단계적으로 완화한다.</li></ul><h6 id=범위-락팬텀-관련-문제>범위 락/팬텀 관련 문제<a hidden class=anchor aria-hidden=true href=#범위-락팬텀-관련-문제>#</a></h6><p>범위 락으로 인한 대기 확산은 주로 범위 스캔·인덱스 부재에서 발생한다. 탐지 (범위 락 빈도·긴 range scans) → 쿼리 리팩토링 또는 인덱스 추가 · 격리 수준 조정 (비용·리스크 평가) → 장기적으로는 인덱스 설계·SSI 고려.</p><table><thead><tr><th>항목</th><th>방법</th></tr></thead><tbody><tr><td>탐지</td><td>range-lock freq, index usage</td></tr><tr><td>즉시조치</td><td>쿼리 리팩토링, 인덱스 추가</td></tr><tr><td>근본해결</td><td>인덱스 재설계, 대체 직렬화 기법</td></tr></tbody></table><ul><li>팬텀 문제는 주로 쿼리/인덱스 설계에서 기인하므로, 쿼리 구조를 바꾸는 것이 가장 효과적이다.</li></ul><h6 id=분산-락-운영-이슈>분산 락 운영 이슈<a hidden class=anchor aria-hidden=true href=#분산-락-운영-이슈>#</a></h6><p>분산 락은 네트워크·리더·lease 이슈에 민감하다. 탐지 (lease 만료, leader changes, client retries) → 즉시 리더 상태 확인·재선출, 알맞은 TTL 설정 → 근본적으로는 지역성 설계 (local affinity), idempotent 작업 구현, 분산 합의 튜닝 필요.</p><table><thead><tr><th>항목</th><th>방법</th></tr></thead><tbody><tr><td>탐지</td><td>lease age, leader change 로그</td></tr><tr><td>즉시조치</td><td>leader 확인·강제 재선출</td></tr><tr><td>근본해결</td><td>TTL/lease 튜닝, 지역성 설계</td></tr></tbody></table><ul><li>분산 락 문제는 장애 시 복구 시나리오와 TTL 파라미터에 따라 결과가 크게 달라지므로 사전 시뮬레이션이 필수다.</li></ul><h5 id=트러블슈팅-통합-요약표>트러블슈팅 통합 요약표<a hidden class=anchor aria-hidden=true href=#트러블슈팅-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>탐지 지표</th><th>즉시 조치</th><th>근본 해결</th><th>운영 권장</th></tr></thead><tbody><tr><td>데드락</td><td>Deadlock logs, WFG</td><td>희생자 롤백</td><td>획득 순서 표준화, TX 단축</td><td>자동 탐지 + 알림</td></tr><tr><td>장기 락</td><td>lock age, inactive TX</td><td>강제 롤백, 정리</td><td>타임아웃, TX 경계 명확화</td><td>고아 락 정리 스케줄</td></tr><tr><td>핫스팟</td><td>top resources, wait-time</td><td>스로틀, 캐시</td><td>파티셔닝·모델 변경</td><td>핫스팟 모니터링 자동화</td></tr><tr><td>팬텀/범위</td><td>range-lock freq, index usage</td><td>쿼리 리팩토링</td><td>인덱스 설계, SSI 검토</td><td>범위 스캔 경보</td></tr><tr><td>분산 락</td><td>lease age, leader events</td><td>leader 재선출, 강제 만료</td><td>TTL/lease 튜닝, 지역성</td><td>분산락 모니터·시나리오 문서화</td></tr></tbody></table><h3 id=고급-주제-및-미래-전망>고급 주제 및 미래 전망<a hidden class=anchor aria-hidden=true href=#고급-주제-및-미래-전망>#</a></h3><h4 id=락-프로토콜의-한계와-실무적-대응>락 프로토콜의 한계와 실무적 대응<a hidden class=anchor aria-hidden=true href=#락-프로토콜의-한계와-실무적-대응>#</a></h4><p>락 프로토콜의 한계는 <strong>&rdquo; 어떤 상황에서 여러 트랜잭션이 동시에 같은 자원 (데이터, 인덱스, 테이블 등) 을 건드릴 때 &ldquo;</strong> 생기는 현실적 문제들이다.<br>핵심적으로는 (1) <strong>경합</strong>이 많으면 처리량이 떨어지고, (2) <strong>데드락</strong>이 발생하면 트랜잭션을 강제로 되돌려야 하며, (3) <strong>분산 환경</strong>에서는 네트워크 문제 때문에 락을 안전하게 유지하기 어렵다.<br>따라서 해법은 ** 문제를 줄이는 설계 (파티셔닝, 인덱스, 트랜잭션 짧게)** 와 ** 문제 발생 시 빠르게 감지·완화하는 운영 (모니터링·자동 롤백·재시도)** 의 조합이다.</p><h5 id=락의-현재-도전-과제와-대응>락의 현재 도전 과제와 대응<a hidden class=anchor aria-hidden=true href=#락의-현재-도전-과제와-대응>#</a></h5><table><thead><tr><th>도전 과제</th><th>무엇 (문제)</th><th>왜 문제인가 (원인)</th><th>실무 영향 (결과)</th><th>대표적 대응 (요약)</th></tr></thead><tbody><tr><td>락 경합 (Hotspots)</td><td>특정 레코드/파티션에 동시 접근 집중</td><td>단일 리소스에 많은 업데이트/읽기</td><td>처리량 급감, 응답 지연, 에스컬레이션</td><td>파티셔닝/샤딩, 레코드 분산, 큐잉</td></tr><tr><td>데드락 / Priority Inversion</td><td>트랜잭션 상호 대기, 우선순위 낮은 작업이 고우선 작업 차단</td><td>상호 자원 획득 순서 불일치, 우선순위 무시</td><td>응답성 저하, 기아, 재시도 폭증</td><td>자원 획득 순서 고정, priority inheritance, 타임아웃</td></tr><tr><td>Lock Manager 병목</td><td>중앙 LM 가 동시 요청 처리 한계</td><td>단일 공유 구조, 락 테이블 동기화 비용</td><td>전체 시스템 병목, 스케일 한계</td><td>분산 LM, 파티셔닝 LM, lock caching</td></tr><tr><td>분산 환경의 불확실성</td><td>네트워크 지연·파티션으로 락 정합성 붕괴 위험</td><td>CAP 제약·합의 비용·시계 불일치</td><td>가용성 감소, 복잡한 복구</td><td>Consensus(etcd/zk), fencing, lease 기반 락</td></tr><tr><td>MVCC/락 혼용 비용</td><td>MVCC 로 읽기 분리하나 쓰기 충돌·GC 발생</td><td>버전 관리·undo/GC 비용, snapshot 격리 이상</td><td>쓰기 처리량 저하, 스토리지 부담</td><td>GC 튜닝, SSI, 쓰기 분리 패턴</td></tr><tr><td>고성능·실시간 요구</td><td>μs 단위 응답 요구에서 락 오버헤드</td><td>컨텍스트 스위칭, 캐시라인 경합, I/O 지연</td><td>SLA 위반, 처리량 한계</td><td>lock-free 구조, HW atomics, RDMA, batching</td></tr><tr><td>운영·관측 한계</td><td>데드락/에스컬레이션 원인 추적 어려움</td><td>이벤트·로그 부족, 분산 로그 동기화 난이도</td><td>문제 대응 늦음, SLA 위협</td><td>실시간 모니터링, tracing, 샘플링 로그</td></tr></tbody></table><h5 id=락의-한계-설계운영분산-과제>락의 한계: 설계·운영·분산 과제<a hidden class=anchor aria-hidden=true href=#락의-한계-설계운영분산-과제>#</a></h5><h6 id=확장성성능-scalability--performance>확장성·성능 (Scalability & Performance)<a hidden class=anchor aria-hidden=true href=#확장성성능-scalability--performance>#</a></h6><ul><li><strong>설명</strong><br>고동시성·대규모 쓰기 워크로드에서 락 획득/관리 자체가 병목이 되어 처리량과 응답성을 제한한다. 중앙화 LM, 락 레코드 메모리, 락 에스컬레이션이 주요 원인이다.</li><li><strong>문제·결과·원인·해결책</strong><ul><li>문제: 핫스팟 (특정 PK/파티션) 에 작업 집중 → 긴 대기열</li><li>결과: 처리량 저하, 응답 지연, 전체 서비스 품질 하락</li><li>원인: 단일 자원에 집중되는 접근 패턴, 부적절한 파티셔닝/인덱스</li><li>해결책: 파티셔닝·샤딩으로 접근 분산, 지연 허용 가능한 작업은 배치화, contention-aware backoff, optimistic concurrency 또는 MVCC 적용</li></ul></li><li><strong>구체 예시 (실무)</strong><ul><li>주문 테이블의 특정 계정이 집중적으로 업데이트 → 파티션 키 재설계로 해결</li></ul></li></ul><table><thead><tr><th>항목</th><th>영향</th><th>대표 원인</th><th>권장 대응</th></tr></thead><tbody><tr><td>핫스팟</td><td>처리량/응답성 저하</td><td>단일 키 집중</td><td>파티셔닝, 키 재설계</td></tr><tr><td>LM 병목</td><td>전체 시스템 병목</td><td>중앙화 LM</td><td>분산 LM, LM 파티셔닝</td></tr><tr><td>락 에스컬레이션</td><td>광역 블로킹</td><td>행락 대량 발생</td><td>배치 분할, 에스컬레이션 임계치 조정</td></tr></tbody></table><ul><li>요약: 성능 문제는 **데이터 모델 (파티셔닝/키)**과 **락 정책 (MVCC vs Pessimistic)**으로 근본 완화 가능.</li></ul><h6 id=분산네트워크-distributed-consistency--faults>분산·네트워크 (Distributed Consistency & Faults)<a hidden class=anchor aria-hidden=true href=#분산네트워크-distributed-consistency--faults>#</a></h6><ul><li><strong>설명</strong><br>노드 간 네트워크 불안정, 레이턴시, 파티션으로 인해 분산 락의 안전성·가용성 확보가 어렵다. CAP 제약과 합의 알고리즘의 비용이 주요 이슈다.</li><li><strong>문제·결과·원인·해결책</strong><ul><li>문제: 락 소유권이 네트워크 장애로 불명확해짐 → 이중 획득 또는 영구 블로킹 가능</li><li>결과: 서비스 가용성 저하, 복구 복잡성 증가</li><li>원인: 분산 시스템의 불확실성 (CAP), 시계 (클록) 불일치</li><li>해결책: Consensus 기반 락 (etcd/zookeeper), lease + fencing token 설계, idempotent 연산 권장</li></ul></li><li><strong>구체 예시 (실무)</strong><ul><li>Redis 단순 락 (비영구) 사용 중 네트워크 분할 → 두 노드에서 동시에 락 소유 발생 → 데이터 손상 위험</li></ul></li></ul><table><thead><tr><th>항목</th><th>영향</th><th>대표 원인</th><th>권장 대응</th></tr></thead><tbody><tr><td>이중 락 소유</td><td>데이터 정합성 위험</td><td>네트워크 파티션</td><td>consensus 기반 락, fencing</td></tr><tr><td>높은 합의 비용</td><td>응답성 저하</td><td>raft/zk leader 선출</td><td>지역화된 락, 약한 일관성 설계</td></tr><tr><td>시계 불일치</td><td>lease 실패/중복</td><td>NTP 불안정</td><td>시간 동기화, logical clocks</td></tr></tbody></table><ul><li>분산 환경에선 <strong>합의 · 타임아웃 · 펜싱</strong> 패턴을 조합해 안전성을 확보하되 비용을 감수해야 한다.</li></ul><h6 id=동시성정확성-concurrency-correctness>동시성·정확성 (Concurrency Correctness)<a hidden class=anchor aria-hidden=true href=#동시성정확성-concurrency-correctness>#</a></h6><ul><li><strong>설명</strong><br>데드락, 팬텀, 불일치, priority inversion 등 동시성 오류가 트랜잭션의 정확성과 성능을 위협한다.</li><li><strong>문제·결과·원인·해결책</strong><ul><li>문제: 트랜잭션 간 상호 대기·불명확한 자원요구가 오류·기아 발생</li><li>결과: 재시도·롤백 증가, 서비스 불안정</li><li>원인: 자원획득 순서 미준수, 부적절한 격리 수준 선택</li><li>해결책: 자원 접근 순서 고정, 적절한 격리수준 (비즈니스에 맞춰), wait-die/wound-wait, detection+retry 패턴</li></ul></li><li><strong>구체 예시 (실무)</strong><ul><li>다중 테이블 업데이트에서 테이블 접근 순서 불일치로 deadlock 빈발 → 코드 규칙으로 해결</li></ul></li></ul><table><thead><tr><th>항목</th><th>영향</th><th>대표 원인</th><th>권장 대응</th></tr></thead><tbody><tr><td>데드락</td><td>트랜잭션 롤백·대기</td><td>무질서한 자원 획득</td><td>자원 순서 고정, deadlock detection</td></tr><tr><td>팬텀</td><td>일관성 위배</td><td>범위 락/인덱스 미비</td><td>적절한 격리 수준, 인덱스 보완</td></tr><tr><td>우선순위 반전</td><td>SLA 위반</td><td>낮은 우선작업이 높은 우선작업 차단</td><td>priority inheritance, QoS 설계</td></tr></tbody></table><ul><li>동시성 정확성 문제는 **설계 규칙 (순서·격리수준)**과 <strong>실시간 모니터링</strong>으로 실무적 제어가 가능하다.</li></ul><h6 id=운영관측-operability--observability>운영·관측 (Operability & Observability)<a hidden class=anchor aria-hidden=true href=#운영관측-operability--observability>#</a></h6><ul><li><strong>설명</strong><br>데드락 원인·에스컬레이션 시점·락 테이블 확장 등 운영 문제를 실시간으로 파악하고 대응하는 능력이 부족하다.</li><li><strong>문제·결과·원인·해결책</strong><ul><li>문제: 원인 미상 장애 발생 시 수동 복구 지연</li><li>결과: SLA 위반·운영 비용 증가</li><li>원인: 로그·메트릭 불충분, 분산 로그 정합성 문제</li><li>해결책: 중앙집중 모니터링 (Trace/Span, Lock metrics), 알람·자동화 (예: 장시간 X 락 알람), 샘플링 기반 Deadlock trace 저장</li></ul></li><li><strong>구체 예시 (실무)</strong><ul><li>deadlock 이 간헐적으로 발생해 원인 추적에 하루 소요 → tracing 도입으로 근원 코드 변경 후 해결</li></ul></li></ul><table><thead><tr><th>항목</th><th>영향</th><th>대표 원인</th><th>권장 대응</th></tr></thead><tbody><tr><td>원인 불명 장애</td><td>긴 MTTR</td><td>로그 부족</td><td>트레이싱·샘플링, Deadlock trace</td></tr><tr><td>예측 불가 에스컬레이션</td><td>운영 중단 위험</td><td>모니터링 미흡</td><td>에스컬레이션 알람, auto-split 배치</td></tr><tr><td>복구 자동화 부족</td><td>수동 대응 비용</td><td>매뉴얼 SOP</td><td>자동 롤백·재시도 플레이북</td></tr></tbody></table><ul><li>요약: 관측·자동화에 투자하면 발생 빈도·복구 시간이 크게 단축된다.</li></ul><h6 id=미래-기술연구-과제-future--hw--security>미래 기술·연구 과제 (Future / HW / Security)<a hidden class=anchor aria-hidden=true href=#미래-기술연구-과제-future--hw--security>#</a></h6><ul><li><strong>설명</strong><br>락 아키텍처는 하드웨어 진화 (예: RDMA, NVRAM), 새로운 알고리즘 (lock-free/wait-free), 보안 (포스트 - 양자) 측면에서 연구·개발이 필요하다.</li><li><strong>문제·결과·원인·해결책</strong><ul><li>문제: 기존 SW 락 패러다임은 μs/으로 동작하는 최신 HW 에서 한계 | 결과: HW 활용 미흡, 성능 한계</li><li>원인: 소프트웨어 동기화의 오버헤드, 전통적 프로토콜 설계</li><li>해결책: RDMA/one-sided 통신 활용한 분산 락, HW atomics, lock-free 자료구조, 양자저항 암호 적용 (보안)</li></ul></li><li><strong>구체 예시 (연구·실무 전환)</strong><ul><li>RDMA 기반 분산 락으로 레이턴시 대폭 저감 (연구 사례)</li></ul></li></ul><table><thead><tr><th>항목</th><th>영향</th><th>대표 원인</th><th>권장 접근</th></tr></thead><tbody><tr><td>HW 가속 미활용</td><td>μs 성능 한계</td><td>SW 동기화 오버헤드</td><td>RDMA, HW atomics</td></tr><tr><td>Lock-free 전환 난이도</td><td>설계 복잡</td><td>증명·검증 비용</td><td>점진적 마이그레이션, 테스트</td></tr><tr><td>보안 위협 (장기)</td><td>암호 기반 취약</td><td>양자컴퓨팅</td><td>PQC 도입 계획</td></tr></tbody></table><ul><li>미래 기술 도입은 비용과 복잡도를 수반하지만 성능·확장성의 획기적 개선을 약속한다.</li></ul><h5 id=락-도전-과제-통합-요약표>락 도전 과제 통합 요약표<a hidden class=anchor aria-hidden=true href=#락-도전-과제-통합-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>주요 문제</th><th>핵심 원인</th><th>단기 대응</th><th>중장기 대응</th></tr></thead><tbody><tr><td>확장성·성능</td><td>핫스팟, LM 병목, 에스컬레이션</td><td>단일 리소스 집중, 중앙 LM</td><td>파티셔닝, 배치 분할, backoff</td><td>분산 LM, lock-free 구조</td></tr><tr><td>분산·네트워크</td><td>이중 소유, 높은 합의 비용</td><td>네트워크 파티션·지연</td><td>lease+fencing, quorum 조정</td><td>Consensus 최적화, 지역화 설계</td></tr><tr><td>동시성·정확성</td><td>데드락, 우선순위 반전</td><td>자원 획득 불일치</td><td>자원 순서 고정, deadlock detection</td><td>priority inheritance, adaptive locking</td></tr><tr><td>운영·관측</td><td>원인 불명 장애, 예측 불가</td><td>로그/메트릭 부족</td><td>tracing, 알람, auto-retry</td><td>AI 기반 예측·자동화</td></tr><tr><td>미래·HW·보안</td><td>HW 미활용, 양자 보안</td><td>SW 병목, 장기 보안 취약</td><td>RDMA PoC, PQC 검토</td><td>HW+SW co-design, lock-free 전환</td></tr></tbody></table><h4 id=적응형-락-트렌드와-실무-적용>적응형 락 트렌드와 실무 적용<a hidden class=anchor aria-hidden=true href=#적응형-락-트렌드와-실무-적용>#</a></h4><p>2025 년의 락 설계 트렌드는 **&rdquo; 혼합·적응·지능화 &ldquo;**이다.<br>즉, DB 는 단 하나의 동시성 기법만 고집하지 않고 MVCC·2PL·OCC 를 워크로드별로 섞어 쓰는 하이브리드 방식이 보편화되고 있고 (성능 연구 보고서), SSI 같은 스냅샷 기반 직렬성은 실무에서 점점 안정적으로 쓰인다.<br>동시에 AI/ML 로 락 경쟁을 예측해 선제적 조치하는 연구가 PoC 수준을 넘어가고 있으며, 분산 환경에서는 consensus 기반 lease 패턴을 신뢰성 있게 운영하는 것이 표준으로 자리잡고 있다.</p><h4 id=락-프로토콜-최신-동향-2025-기준>락 프로토콜 최신 동향 (2025 기준)<a hidden class=anchor aria-hidden=true href=#락-프로토콜-최신-동향-2025-기준>#</a></h4><table><thead><tr><th>트렌드</th><th>요약</th><th style=text-align:right>대표 연구·도구 예시</th><th>실무 의미</th><th>리스크/주의</th></tr></thead><tbody><tr><td>하이브리드 동시성 제어 (HDCC)</td><td>워크로드에 따라 MVCC/OCC/2PL 등 프로토콜을 동적으로 조합·전환</td><td style=text-align:right>PVLDB HDCC 2025 연구, IBM/학계 PoC. ([vldb.org][1])</td><td>읽기·쓰기 특성에 맞게 성능·정합성 균형 최적화</td><td>구현 복잡성, 자동 전환의 안정성 검증 필요</td></tr><tr><td>SSI 확산</td><td>Snapshot 기반으로 직렬성 보장 (Commit 시 충돌 검사·Abort)</td><td style=text-align:right>PostgreSQL SSI 문서/블로그, 도입 사례. ([Medium][2])</td><td>읽기 성능 유지하면서 강한 직렬성 확보 가능</td><td>Commit-time abort 증가 → 재시도 정책 필요</td></tr><tr><td>AI/ML 기반 락 최적화</td><td>트랜잭션 패턴 예측·데드락 위험 예측·동적 그레인 조정</td><td style=text-align:right>arXiv/2025 락 예측 연구, 자동 튜닝 리포트. ([arXiv][3])</td><td>선제적 락 획득/조정으로 대기 감소 가능</td><td>학습 신뢰성·데이터 편향·지속적 재학습 비용</td></tr><tr><td>분산 락과 Lease 통합</td><td>Consensus 기반 (raft/etcd) + lease 패턴이 실무 표준</td><td style=text-align:right>etcd/ZK/Consul, Redis Redlock 논쟁. ([Hacker News][4])</td><td>서비스 간 조정·리더 선출에 안정적 사용 가능</td><td>네트워크 파티션·운영복잡성·Redis 단일한계</td></tr><tr><td>락 - 프리·RDMA·엣지 계층화</td><td>락 프리 자료구조, RDMA 로 저지연 분산 락, 엣지 - 지역 - 글로벌 계층 락</td><td style=text-align:right>HTAP·RDMA 연구·엣지 설계 문헌. ([arXiv][5])</td><td>초저지연·확장성 향상 가능 (IoT/엣지)</td><td>복잡한 분산 설계·일관성 정책 수립 필요</td></tr></tbody></table><ul><li><strong>핵심:</strong> 단일 방식 (전통 2PL) 에서 벗어나 <em>워크로드·환경에 맞춰 혼합·적응</em>하는 흐름이 중심이며, AI·분산 합의·하드웨어 (RDMA) 같은 외부 기술이 동시성 제어 설계에 빠르게 통합되고 있음. 위 내용은 2024–2025 논문·기술 문서로 뒷받침됨.</li></ul><h5 id=적응형-락-트렌드-카테고리>적응형 락 트렌드 카테고리<a hidden class=anchor aria-hidden=true href=#적응형-락-트렌드-카테고리>#</a></h5><h6 id=프로토콜-레벨-혁신>프로토콜 레벨 혁신<a hidden class=anchor aria-hidden=true href=#프로토콜-레벨-혁신>#</a></h6><p>하이브리드 CC 와 SSI 는 &rsquo; 무엇을 보장 &rsquo; 하고 &rsquo; 언제 선택 &rsquo; 할지에 대한 프로토콜 설계 혁신이다.</p><table><thead><tr><th>항목</th><th>설명</th><th style=text-align:right>예시·근거</th><th>실무 효과</th><th>주의</th></tr></thead><tbody><tr><td>하이브리드 CC</td><td>워크로드 분석으로 MVCC/OCC/2PL 전환·조합</td><td style=text-align:right>PVLDB 2025 HDCC 연구.</td><td>특정 워크로드에서 최대 성능·정합성 절충 가능</td><td>구현·운영 복잡성</td></tr><tr><td>SSI</td><td>스냅샷 기반 직렬성 (Commit 시 충돌 검사)</td><td style=text-align:right>PostgreSQL SSI 구현/도입 사례.</td><td>읽기 성능 유지하면서 직렬성 보장</td><td>Commit-time abort↑ → 재시도 필요</td></tr></tbody></table><ul><li>요약: 프로토콜 레벨에서 &rsquo; 적응 &rsquo; 이 핵심. 실무는 테스트로 전환 규칙 (tuning) 을 검증해야 함.</li></ul><h6 id=지능화자동화>지능화·자동화<a hidden class=anchor aria-hidden=true href=#지능화자동화>#</a></h6><p>AI/ML 을 락·데드락 예측·그레인 최적화 등에 적용하려는 시도가 활발.</p><table><thead><tr><th>항목</th><th>설명</th><th style=text-align:right>예시·근거</th><th>실무 효과</th><th>주의</th></tr></thead><tbody><tr><td>예측적 락 관리</td><td>트랜잭션 패턴 예측으로 선제 락 획득/순서 제어</td><td style=text-align:right>arXiv/2025 락 예측 논문.</td><td>블로킹 감소·대기 시간 개선 가능</td><td>학습 신뢰성·데이터 편향·운영 비용</td></tr><tr><td>데드락 리스크 ML</td><td>그래프 기반 예측으로 위험 트랜잭션 식별</td><td style=text-align:right>연구·PoC 들.</td><td>예방적 조치로 데드락 감소</td><td>오탐/추가 오버헤드</td></tr></tbody></table><ul><li>요약: AI 는 보조수단으로 유용하지만, 지속 학습·검증·거버넌스가 필수.</li></ul><h6 id=분산인프라-레벨>분산·인프라 레벨<a hidden class=anchor aria-hidden=true href=#분산인프라-레벨>#</a></h6><p>분산 합의·lease 기반 락, Redis Redlock 논쟁 등 운영 선택에서 핵심.</p><table><thead><tr><th>항목</th><th>설명</th><th style=text-align:right>예시·근거</th><th>실무 효과</th><th>주의</th></tr></thead><tbody><tr><td>Consensus+Lease</td><td>etcd/ZK 기반으로 강한 일관성·세션 관리</td><td style=text-align:right>etcd/ZK/Consul 실무 활용</td><td>안정적 리더선출·조정 가능</td><td>네트워크 파티션·운영 복잡성</td></tr><tr><td>Redis Redlock</td><td>Redis 기반 분산 락 패턴</td><td style=text-align:right>Redlock 안전성 논쟁 자료.</td><td>단순·저지연 락 구현 용이</td><td>완전한 안전성 보장 논란 → advisory lock 권장</td></tr></tbody></table><ul><li>요약: 분산 락은 설계·운영 상단위 결정 (신뢰성 vs 대기지연) 문제.</li></ul><h6 id=하드웨어아키텍처>하드웨어·아키텍처<a hidden class=anchor aria-hidden=true href=#하드웨어아키텍처>#</a></h6><p>RDMA·엣지 계층화·락 - 프리 자료구조로 저지연·확장성 추구.</p><table><thead><tr><th>항목</th><th>설명</th><th style=text-align:right>예시·근거</th><th>실무 효과</th><th>주의</th></tr></thead><tbody><tr><td>RDMA 기반 락</td><td>RDMA 로 원격 메모리 접근·락 간소화</td><td style=text-align:right>HTAP/RDMA 연구.</td><td>저지연 분산 동시성 가능</td><td>HW 의존성·복잡성</td></tr><tr><td>엣지 계층 락</td><td>로컬·지역·글로벌 계층 락 설계</td><td style=text-align:right>엣지 컴퓨팅 설계 논의</td><td>로컬응답성 보장·글로벌 일관성 계층화</td><td>설계 복잡성, 데이터 동기화 비용</td></tr><tr><td>락 - 프리 구조</td><td>CAS 기반 자료구조 등</td><td style=text-align:right>연구·라이브러리</td><td>병렬성 극대화</td><td>구현 난이도·적용 한계</td></tr></tbody></table><ul><li>요약: 하드웨어·아키텍처 변화를 적극 활용하면 성능 한계를 극복 가능하지만 비용·복잡성 관리가 관건.</li></ul><h5 id=2025-락-트렌드-요약표>2025 락 트렌드 요약표<a hidden class=anchor aria-hidden=true href=#2025-락-트렌드-요약표>#</a></h5><table><thead><tr><th>카테고리</th><th>핵심 포인트</th><th>실무에의 시사점</th></tr></thead><tbody><tr><td>프로토콜 레벨</td><td>HDCC·SSI 확산 (워크로드별 적응)</td><td>테스트 기반 전환 규칙 필요</td></tr><tr><td>지능화·자동화</td><td>AI 예측으로 선제 제어·데드락 예측</td><td>PoC→점진적 운영 전환, 거버넌스 필요</td></tr><tr><td>분산·인프라</td><td>consensus+lease 표준, Redis 한계 주의</td><td>운영·네트워크 대비 필수</td></tr><tr><td>HW·아키텍처</td><td>RDMA·엣지·락 - 프리 연구</td><td>고성능·저지연 요구시 검토 대상</td></tr></tbody></table><h4 id=락-대체-기술-분류와-실무-가이드>락 대체 기술: 분류와 실무 가이드<a hidden class=anchor aria-hidden=true href=#락-대체-기술-분류와-실무-가이드>#</a></h4><p>락 프로토콜 대신 (또는 보완하여) 사용할 수 있는 여러 대안 기술은 **&rdquo; 충돌을 예방/감지·해결 &ldquo;** 하는 방식에서 차이가 난다.</p><ul><li><strong>MVCC</strong>는 읽기를 버전으로 분리해 읽기 충돌을 없애고,</li><li><strong>OCC</strong>는 충돌 검사를 커밋 시점으로 미뤄 락 오버헤드를 피하며,</li><li><strong>타임스탬프 기반</strong>은 시간 순서를 이용해 직렬성을 보장한다.<br>분산 환경에서는 <strong>CRDT</strong>(자동 수렴) 나 <strong>Event Sourcing+SAGA</strong>(보상으로 분산 일관성 처리) 가 자주 선택된다. 각 기술은 워크로드 (읽기/쓰기 비율), 충돌 빈도, 실시간성 요구, 운영 복잡도에 따라 적절성이 완전히 달라진다.</li></ul><h5 id=락-대체-기술-비교표>락 대체 기술 비교표<a hidden class=anchor aria-hidden=true href=#락-대체-기술-비교표>#</a></h5><table><thead><tr><th>대안 기술</th><th style=text-align:right>핵심 원리</th><th>장점</th><th>단점/제약</th><th>권장 적용 시나리오</th></tr></thead><tbody><tr><td>MVCC</td><td style=text-align:right>데이터의 여러 버전 유지, 읽기는 스냅샷으로 처리</td><td>읽기 비차단, OLAP/읽기 -heavy 에 유리</td><td>버전 저장·GC 비용, 쓰기 충돌 시 재시도</td><td>읽기 - 쓰기 혼합 (읽기 우세) OLTP/OLAP 혼합</td></tr><tr><td>OCC (낙관적)</td><td style=text-align:right>충돌은 커밋 시점에 검사</td><td>락 오버헤드 없음, 단순 구현</td><td>충돌 시 롤백 비용, 쓰기 집중 시 성능 저하</td><td>읽기 중심 웹앱, 충돌 적은 환경</td></tr><tr><td>Timestamp Ordering (TO)</td><td style=text-align:right>타임스탬프로 연산 순서 보장</td><td>락 불필요, 직렬성 보장</td><td>타임스탬프 관리 복잡, 재정렬 비용</td><td>단일 리더/오프라인 처리 등 특수환경</td></tr><tr><td>Calvin (Deterministic)</td><td style=text-align:right>트랜잭션 스케줄 사전 결정</td><td>동시성 제어 비용 제거, 분산에 강함</td><td>요청 라우팅/오프라인 스케줄 필요</td><td>분산 트랜잭션이 많고 예측 가능한 워크로드</td></tr><tr><td>CRDT</td><td style=text-align:right>수학적 수렴 보장 복제 자료구조</td><td>분산·오프라인 동시 업데이트 허용</td><td>모든 연산에 적용 불가, 설계 복잡</td><td>글로벌 복제·오프라인 우선 애플리케이션</td></tr><tr><td>Event Sourcing + CQRS / SAGA</td><td style=text-align:right>이벤트 기록으로 상태 재구성, 보상 트랜잭션</td><td>분산 트랜잭션 회피, 확장성</td><td>보상 로직 설계 난도, 일관성 모델 제한</td><td>분산 업무 흐름·마이크로서비스 아키텍처</td></tr><tr><td>Lock-free / Wait-free</td><td style=text-align:right>원자 연산으로 동기화 회피</td><td>저지연·실시간에 유리</td><td>고난도 구현, 디버깅 어려움</td><td>실시간/임베디드/저지연 시스템</td></tr></tbody></table><h5 id=동작-기반-대안-기술-분류>동작 기반 대안 기술 분류<a hidden class=anchor aria-hidden=true href=#동작-기반-대안-기술-분류>#</a></h5><h6 id=버전스냅샷-기반-mvcc-ssi>버전/스냅샷 기반 (MVCC, SSI)<a hidden class=anchor aria-hidden=true href=#버전스냅샷-기반-mvcc-ssi>#</a></h6><p>MVCC 는 읽기를 스냅샷으로 처리해 읽기와 쓰기의 직접 충돌을 피한다. Serializable 수준을 요구하면 SSI(Serializable Snapshot Isolation) 처럼 추가 검사가 필요하다. 장점은 읽기 비차단과 잘 알려진 실무 안정성, 단점은 버전 관리와 GC(예: autovacuum) 부담 및 쓰기 충돌 처리다.</p><table><thead><tr><th>항목</th><th style=text-align:right>핵심 효과</th><th>운영 주의사항</th></tr></thead><tbody><tr><td>장점</td><td style=text-align:right>읽기 비차단, 높은 읽기 동시성</td><td>버전스토어 모니터링 (디스크/메모리)</td></tr><tr><td>단점</td><td style=text-align:right>버전 GC 비용, 쓰기 충돌 재시도</td><td>VACUUM/GC 정책 튜닝 필요</td></tr></tbody></table><ul><li>요약: 읽기 - 우선 환경에 첫 선택지. 버전 수집·정리 비용을 반드시 감안해야 한다.</li></ul><h6 id=낙관적검사-기반-occ-to>낙관적·검사 기반 (OCC, TO)<a hidden class=anchor aria-hidden=true href=#낙관적검사-기반-occ-to>#</a></h6><p>낙관적 방식은 트랜잭션 대부분 충돌하지 않는다는 가정 하에 락을 쓰지 않고 커밋 시점에 충돌검사를 한다. 타임스탬프 기반은 읽기·쓰기의 타임스탬프 규칙으로 직렬성을 보장한다. 장점은 락 오버헤드 제거, 단점은 충돌 빈도 높을 때 재시도 비용이 큼.</p><table><thead><tr><th>항목</th><th style=text-align:right>핵심 효과</th><th>운영 주의사항</th></tr></thead><tbody><tr><td>장점</td><td style=text-align:right>락 비용 제거, 간단한 구현 (기본형)</td><td>충돌률 모니터링, 재시도 로직 설계</td></tr><tr><td>단점</td><td style=text-align:right>충돌 시 롤백 비용, 기아 가능성</td><td>충돌률 높으면 성능 급감</td></tr></tbody></table><ul><li>요약: 읽기 중심·충돌 적은 환경에서 성능 이득. 쓰기 집중 워크로드엔 부적합.</li></ul><h6 id=결정적-스케줄링-calvin-류>결정적 스케줄링 (Calvin 류)<a hidden class=anchor aria-hidden=true href=#결정적-스케줄링-calvin-류>#</a></h6><p>Calvin 계열은 트랜잭션을 사전에 수집해 전역 순서를 미리 정함으로써 런타임의 동시성 제어 비용을 제거한다. 분산 트랜잭션 처리에 강점이 있으나 요청 라우팅·사전 수집 과정이 필요하다.</p><table><thead><tr><th>항목</th><th style=text-align:right>핵심 효과</th><th>운영 주의사항</th></tr></thead><tbody><tr><td>장점</td><td style=text-align:right>런타임 락 비용 제거, 분산 확장성</td><td>요청 수집·스케줄 비용, 지연 허용 범위</td></tr><tr><td>단점</td><td style=text-align:right>사전수집 실패·동적 워크로드에 취약</td><td>트래픽 패턴 분석 필요</td></tr></tbody></table><ul><li>요약: 분산 고성능 트랜잭션에 강하지만 설계·운영 복잡도가 동봉된다.</li></ul><h6 id=분산복제-특화-crdt-event-sourcingcqrssaga>분산·복제 특화 (CRDT, Event Sourcing/CQRS/SAGA)<a hidden class=anchor aria-hidden=true href=#분산복제-특화-crdt-event-sourcingcqrssaga>#</a></h6><p>CRDT 는 동시 업데이트를 자동으로 수렴시키며, Event Sourcing 과 CQRS/SAGA 는 분산 트랜잭션 대신 이벤트와 보상으로 일관성을 관리한다. 장점은 높은 가용성·부분적 오프라인 처리가능, 단점은 모델 설계 복잡과 모든 도메인에 적용 불가.</p><table><thead><tr><th>항목</th><th style=text-align:right>핵심 효과</th><th>운영 주의사항</th></tr></thead><tbody><tr><td>장점</td><td style=text-align:right>고가용·오프라인·충돌수렴</td><td>자료형 설계·보상 로직 복잡</td></tr><tr><td>단점</td><td style=text-align:right>복잡한 도메인에는 부적합</td><td>이벤트 버전관리·리플레이 고려</td></tr></tbody></table><ul><li>요약: 글로벌 복제·오프라인 우선 서비스에서 강력. 도메인 적합성 검증이 필수.</li></ul><h6 id=저지연-동시성-lock-free--wait-free>저지연 동시성 (Lock-free / Wait-free)<a hidden class=anchor aria-hidden=true href=#저지연-동시성-lock-free--wait-free>#</a></h6><p>원자 연산 (CAS 등) 기반으로 동기화를 회피해 지연을 극소화한다. 주로 실시간 시스템·임베디드 환경에 쓰인다. 하지만 구현·검증이 매우 어렵다.</p><table><thead><tr><th>항목</th><th style=text-align:right>핵심 효과</th><th>운영 주의사항</th></tr></thead><tbody><tr><td>장점</td><td style=text-align:right>극저지연, 예측 가능한 응답</td><td>구현 복잡·디버깅 난이도</td></tr><tr><td>단점</td><td style=text-align:right>구조적 제약 많음</td><td>고도로 검증된 코드 필요</td></tr></tbody></table><ul><li>요약: 실시간성 최우선이면 고려. 일반 비즈니스 시스템에는 비용 대비 이득 작을 수 있음.</li></ul><h5 id=대안-기술-통합-비교표>대안 기술 통합 비교표<a hidden class=anchor aria-hidden=true href=#대안-기술-통합-비교표>#</a></h5><table><thead><tr><th>카테고리</th><th>대표 기술</th><th>강점</th><th>단점</th><th>권장 적용</th></tr></thead><tbody><tr><td>버전/스냅샷</td><td>MVCC, SSI</td><td>읽기 비차단, 안정적</td><td>버전 GC·쓰기 재시도</td><td>읽기 우세 혼합 워크로드</td></tr><tr><td>낙관적·타임스탬프</td><td>OCC, TO</td><td>락 오버헤드 없음</td><td>충돌 시 롤백 비용</td><td>충돌 적은 웹앱</td></tr><tr><td>결정적 스케줄링</td><td>Calvin</td><td>분산 고성능</td><td>요청 수집 복잡</td><td>분산 트랜잭션 많은 서비스</td></tr><tr><td>분산·복제 특화</td><td>CRDT, SAGA</td><td>가용성·오프라인 강함</td><td>설계 복잡</td><td>글로벌 복제·마이크로서비스</td></tr><tr><td>저지연</td><td>Lock-free/Wait-free</td><td>극저지연</td><td>구현 난도</td><td>실시간/임베디드 시스템</td></tr></tbody></table><hr><h2 id=최종-정리-및-학습-가이드>최종 정리 및 학습 가이드<a hidden class=anchor aria-hidden=true href=#최종-정리-및-학습-가이드>#</a></h2><h3 id=내용-종합>내용 종합<a hidden class=anchor aria-hidden=true href=#내용-종합>#</a></h3><p>락 프로토콜은 트랜잭션 간 충돌을 제어해 데이터 일관성을 유지하는 규칙 집합이다. 전통적 접근인 <strong>Two-Phase Locking(2PL)</strong> 은 트랜잭션이 락을 획득하는 <em>Growing</em> 단계와 락을 해제하는 <em>Shrinking</em> 단계로 구분되어 직렬성 보장을 가능하게 한다 (Shared/Exclusive/Update/Intent 등 모드로 세분화). 2PL 은 직렬성 보장에 강하지만, 락 지속시간과 그레인 선택 때문에 데드락·경합·성능 저하 문제가 발생한다.</p><p>현대 시스템에서는 <strong>MVCC(버전 기반)</strong> 가 읽기 성능을 극대화하는 대안으로 널리 사용된다. MVCC 는 읽기 작업이 쓰기를 차단하지 않아 높은 읽기 동시성을 제공하지만, 직렬성 수준을 완전하게 보장하려면 SSI 같은 추가적 충돌 검출·중단 메커니즘이 필요하다.</p><p>운영 관점에서는 <strong>갭/범위 락</strong>(예: InnoDB 의 gap/next-key lock) 이 팬텀 문제를 막지만 인덱스·쿼리 패턴에 따라 잠금 범위를 크게 늘려 동시성을 저해한다. 또한 <strong>락 에스컬레이션</strong>(행→테이블) 은 대형 배치에서 자동 발생해 전체 서비스 블로킹으로 이어질 수 있으므로 배치 크기·파티셔닝·에스컬레이션 모니터링이 필수다.</p><p>분산·클라우드 환경에서는 단일 DB 내의 락만으로는 부족하다. 분산 리소스에 대한 상호 배타 성을 보장하려면 <strong>합의 (Consensus)</strong> 기반 도구 (ZooKeeper, etcd) 와 fencing token 같은 안전장치를 사용해야 하며, 단순 Redis 기반 락은 엄격한 안전 요구가 있을 때 권장되지 않는다는 전문가 권고가 있다.</p><p>요약하면, 설계자는 <strong>(1) 일관성 요구 (격리 수준)–(2) 워크로드 특성 (읽기/쓰기 비율)–(3) 운영 제약 (에스컬레이션·모니터링)</strong> 을 종합해 2PL·MVCC·OCC·분산락 중 최적의 조합을 선택하고, 인덱스·트랜잭션 길이·배치 전략으로 위험 (데드락/광역락) 을 미리 억제해야 한다.</p><h3 id=실무-적용-가이드>실무 적용 가이드<a hidden class=anchor aria-hidden=true href=#실무-적용-가이드>#</a></h3><table><thead><tr><th>권고 항목</th><th>구체 행동</th><th>적용 이유 (효과)</th><th>언제 적용해야 하는가</th><th>위험/완화책</th></tr></thead><tbody><tr><td>트랜잭션 짧게 유지</td><td>외부 I/O·UI 로직을 트랜잭션 밖으로, 커밋 빈도 증가</td><td>락 보유 시간 최소화 → 동시성↑</td><td>모든 OLTP 경로</td><td>장기 트랜잭션 불가피 시 분할/비동기화 적용</td></tr><tr><td>FOR UPDATE 최소화</td><td>쓰기 직전 특정 행만 <code>SELECT … FOR UPDATE</code></td><td>불필요한 배타락 회피</td><td>쓰기 충돌 예상 시</td><td>잘못된 범위 지정 시 오히려 락 확대 → WHERE·인덱스 검증</td></tr><tr><td>인덱스 최적화</td><td>범위쿼리에 적절한 인덱스 추가, 통계 갱신</td><td>범위락 축소, 테이블 스캔 방지</td><td>범위 쿼리/집계 빈발</td><td>인덱스 과다 → 쓰기 비용 증가 (모니터)</td></tr><tr><td>데드락 표준화</td><td>타임아웃·지수 백오프·idempotent 재시도 정책</td><td>자동 회복·MTTR 단축</td><td>데드락 간헐 발생 시</td><td>Blind retry 위험 → 재시도 로직의 안전성 확보</td></tr><tr><td>락 에스컬레이션 관리</td><td>배치 크기 감소, 파티셔닝, DB 임계치 조정</td><td>에스컬레이션으로 인한 테이블 락 방지</td><td>대량 업데이트/배치 시</td><td>파티셔닝 비용·복잡도 증가</td></tr><tr><td>핫키/샤딩</td><td>핫키 분산, 캐시, 키 재설계 (샤드 키)</td><td>단일 키로 인한 경쟁 해소</td><td>특정 키 집중 트래픽</td><td>샤딩 복잡도·cross-shard 트랜잭션 문제</td></tr><tr><td>낙관적 동시성</td><td>버전 필드 사용 (opt. locking)</td><td>충돌 드문 쓰기에서 성능 우위</td><td>읽기많고 쓰기 적은 워크로드</td><td>충돌 빈도 높으면 재시도 비용 증가</td></tr><tr><td>관측성 및 자동화</td><td>P95/P99, top-blocker 자동 스냅샷·알림</td><td>원인 파악·신속 대응</td><td>운영 중 모든 환경</td><td>오탐/오버헤드 → 샘플링·임계치 조정</td></tr><tr><td>분산 락 신중 적용</td><td>etcd/ZK/Redis 로 조정, 타임아웃·세션 관리</td><td>서비스 간 조정 필요 시</td><td>멀티 서비스·분산 리더 선출</td><td>네트워크 파티션·운영 복잡성 → 강건한 테스트</td></tr><tr><td>정책 문서화</td><td>임계값·대응 절차·소유자 명시</td><td>운영 일관성 유지</td><td>도입 초기 및 정기 갱신</td><td>문서화 미비 시 대응 혼선</td></tr></tbody></table><h3 id=학습-로드맵>학습 로드맵<a hidden class=anchor aria-hidden=true href=#학습-로드맵>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th style=text-align:right>기간 (권장)</th><th>단계 목표 (요약)</th><th>핵심 학습 주제</th><th>권장 실습 과제 (출력물)</th></tr></thead><tbody><tr><td style=text-align:right>초급</td><td style=text-align:right>1–3 개월</td><td>동시성·락 기본 개념 습득 및 간단 구현</td><td>ACID, 트랜잭션, S/X, 2PL, Strict 2PL, 락 호환성 매트릭스</td><td><strong>작은 락 매니저 구현 (Python)</strong>: 리소스 등록/획득/해제, 단일 프로세스 Deadlock 시뮬레이터</td></tr><tr><td style=text-align:right>중급</td><td style=text-align:right>3–6 개월</td><td>DBMS 동작·데드락·튜닝 실습, 운영 도구 익힘</td><td>MVCC 개념, 의도 락, gap/next-key, 락 변환·승격, 데드락 탐지/타임아웃, 모니터링 쿼리</td><td><strong>DB 실습 프로젝트</strong>: Postgres + MySQL 에 동일 시나리오 재현 (블로킹·데드락), 운영 대시보드 (간단 Grafana)</td></tr><tr><td style=text-align:right>고급</td><td style=text-align:right>6 개월 +</td><td>분산·확장·아키텍처 설계 능력 확보</td><td>분산 락 (Redis/etcd/ZK), Lease/Fencing, 2PC/Saga/CQRS, 낙관적 동시성, 자동화/적응형 튜닝</td><td><strong>분산 시스템 PoC</strong>: Redis/ZK 기반 분산 락, 주문처리 (Saga) 로 장기 트랜잭션 검증, 성능·정합성 보고서</td></tr></tbody></table><h3 id=학습-항목-정리>학습 항목 정리<a hidden class=anchor aria-hidden=true href=#학습-항목-정리>#</a></h3><table><thead><tr><th style=text-align:right>단계</th><th>항목</th><th style=text-align:right>중요도</th><th>학습 목표 (구체)</th><th style=text-align:right>실무 연관성</th><th>권장 실습·산출물</th></tr></thead><tbody><tr><td style=text-align:right>초급</td><td>트랜잭션·ACID</td><td style=text-align:right>필수</td><td>트랜잭션 기본과 ACID 요소 이해</td><td style=text-align:right>모든 DB 설계의 기초</td><td>요약 노트, 간단 퀴즈</td></tr><tr><td style=text-align:right>초급</td><td>S/X/Shared-Exclusive</td><td style=text-align:right>필수</td><td>공유/배타 락의 의미·호환성 매트릭스 체득</td><td style=text-align:right>쿼리 설계 시 락 영향 예측</td><td>작은 실험: 두 트랜잭션 동시 실행 관찰</td></tr><tr><td style=text-align:right>초급</td><td>2PL / Strict 2PL</td><td style=text-align:right>필수</td><td>2PL 동작, Strict 2PL 의 복구 관련 성질 이해</td><td style=text-align:right>직렬성 보장, 복구 정책 결정</td><td>시뮬레이터로 2PL 동작 재현</td></tr><tr><td style=text-align:right>초급</td><td>간단 락 매니저 구현</td><td style=text-align:right>권장</td><td>락 테이블·granted/waiting 리스트 구현</td><td style=text-align:right>내부 엔진 이해, 인터뷰·코딩 능력</td><td>Python 코드 (리포지토리)</td></tr><tr><td style=text-align:right>중급</td><td>MVCC / Snapshot</td><td style=text-align:right>필수</td><td>버전 관리 읽기 방식과 장단점 이해</td><td style=text-align:right>읽기 -heavy 시스템 설계</td><td>Postgres 에서 스냅샷 격리 실험</td></tr><tr><td style=text-align:right>중급</td><td>Gap / Next-Key Lock</td><td style=text-align:right>필수</td><td>팬텀 현상과 인덱스 범위 락 동작 숙지</td><td style=text-align:right>범위 쿼리 설계 영향</td><td>InnoDB 에서 범위 쿼리 테스트</td></tr><tr><td style=text-align:right>중급</td><td>Intent Lock / Multigranularity</td><td style=text-align:right>필수</td><td>IS/IX/SIX 의 의미와 계층 락 동작</td><td style=text-align:right>대규모 DB 성능 튜닝</td><td>트랜잭션 로그 분석 연습</td></tr><tr><td style=text-align:right>중급</td><td>데드락 탐지·예방</td><td style=text-align:right>필수</td><td>Wait-for 그래프, victim 선정, Wait-Die/Wound-Wait 이해</td><td style=text-align:right>운영 중복·복구 절차</td><td>데드락 재현 & 로그 분석 리포트</td></tr><tr><td style=text-align:right>중급</td><td>운영 툴 숙달</td><td style=text-align:right>필수</td><td>pg_locks / INNODB_STATUS / DMVs 사용법 숙달</td><td style=text-align:right>운영 모니터링·알람 설정</td><td>운영 쿼리 스크립트, Grafana 대시보드</td></tr><tr><td style=text-align:right>고급</td><td>Lock Escalation</td><td style=text-align:right>권장</td><td>승격 기준·영향 이해 및 튜닝 방법</td><td style=text-align:right>대량 트랜잭션 성능 관리</td><td>시나리오 테스트, 정책 제안서</td></tr><tr><td style=text-align:right>고급</td><td>낙관적 동시성 (OCC)</td><td style=text-align:right>권장</td><td>버전 기반 동작·재시도 전략 설계</td><td style=text-align:right>충돌 적은 환경에 유리</td><td>애플리케이션 레벨 구현 (예: JPA 예제)</td></tr><tr><td style=text-align:right>고급</td><td>분산 락 (Redis/etcd/ZK)</td><td style=text-align:right>필수</td><td>Fencing/Lease/Redlock 개념과 한계 파악</td><td style=text-align:right>멀티노드 전역 자원 제어</td><td>Redis Redlock 구현·장애 테스트</td></tr><tr><td style=text-align:right>고급</td><td>2PC / Saga / CQRS</td><td style=text-align:right>필수</td><td>분산 트랜잭션 패턴 및 보상 트랜잭션 설계</td><td style=text-align:right>마이크로서비스/분산 트랜잭션 처리</td><td>주문 처리 PoC (Saga)</td></tr><tr><td style=text-align:right>고급</td><td>자동화·적응형 튜닝</td><td style=text-align:right>선택</td><td>모니터링 기반 규칙·ML 기법을 통한 튜닝</td><td style=text-align:right>대규모 시스템 운영 최적화</td><td>실험 보고서 (간단 모델)</td></tr></tbody></table><hr><h2 id=용어-정리>용어 정리<a hidden class=anchor aria-hidden=true href=#용어-정리>#</a></h2><table><thead><tr><th>카테고리</th><th>용어 (한글 (영어 풀네임, 약어))</th><th style=text-align:right>정의</th><th>관련 개념</th><th>실무 활용</th></tr></thead><tbody><tr><td>핵심 개념</td><td>잠금 프로토콜 (Locking Protocol)</td><td style=text-align:right>트랜잭션 간 데이터 접근에 대해 락 획득·해제 규칙을 정한 메커니즘</td><td>2PL, 직렬성</td><td>DB 엔진의 동시성 정책 설계</td></tr><tr><td>핵심 개념</td><td>2 단계 잠금 (Two-Phase Locking, 2PL)</td><td style=text-align:right>트랜잭션이 락을 획득하는 성장 (Growing) 단계와 해제하는 축소 (Shrinking) 단계로 나누는 프로토콜</td><td>직렬성, Deadlock</td><td>직렬성 보장을 위한 기본 프로토콜</td></tr><tr><td>핵심 개념</td><td>Strict 2PL (Strict Two-Phase Locking)</td><td style=text-align:right>모든 X(또는 S/X) 락을 트랜잭션 커밋 시까지 유지하는 2PL 변형</td><td>복구성, 카스케이딩 방지</td><td>금융/OLTP 에서 강한 복구성 보장</td></tr><tr><td>잠금 모드</td><td>공유 잠금 (Shared Lock, S)</td><td style=text-align:right>읽기 목적의 잠금. 여러 트랜잭션이 동시에 보유 가능, 쓰기 차단</td><td>배타 잠금 (X), 의도락 (IS)</td><td>SELECT FOR SHARE 등 읽기 안정성 확보</td></tr><tr><td>잠금 모드</td><td>배타 잠금 (Exclusive Lock, X)</td><td style=text-align:right>쓰기 목적의 잠금. 단독 보유로 다른 모든 접근 차단</td><td>S, 2PL</td><td>UPDATE/DELETE 시 무결성 확보</td></tr><tr><td>잠금 모드</td><td>업데이트 잠금 (Update Lock, U)</td><td style=text-align:right>S→X 승격으로 인한 교착을 줄이기 위한 중간 모드</td><td>S, X, 업그레이드</td><td>SELECT 후 곧 UPDATE 하는 패턴에서 사용</td></tr><tr><td>잠금 모드</td><td>의도 잠금 (Intention Lock: IS/IX/SIX)</td><td style=text-align:right>상위 (테이블/페이지) 레벨에 하위 잠금 의도를 표시</td><td>계층형 잠금, 멀티 그레뉼러리티</td><td>빠른 충돌 검사, 계층적 락 관리</td></tr><tr><td>잠금 모드</td><td>갭/넥스트키 잠금 (Gap / Next-Key Lock)</td><td style=text-align:right>인덱스의 키 사이 (갭) 또는 레코드 + 갭을 잠가 범위 삽입 (팬텀) 을 방지</td><td>Phantom, Serializable, InnoDB next-key</td><td>범위 쿼리/직렬화 수준에서 팬텀 차단</td></tr><tr><td>구현 컴포넌트</td><td>락 관리자 (Lock Manager)</td><td style=text-align:right>락 요청·부여·큐·해제 관리를 수행하는 엔진 컴포넌트</td><td>락 테이블, 호환성 매트릭스</td><td>락 상태 추적·데드락 탐지 구현</td></tr><tr><td>구현 컴포넌트</td><td>락 테이블 (Lock Table)</td><td style=text-align:right>리소스별 락 엔트리 (해시/파티션) 와 대기 리스트를 저장하는 자료구조</td><td>해시/파티셔닝, granted/waiting list</td><td>성능 병목·메모리 영향 분석 대상</td></tr><tr><td>구현 컴포넌트</td><td>락 승격 (Lock Escalation)</td><td style=text-align:right>많은 세부 락이 있을 때 상위 단위 락 (페이지/테이블) 으로 전환</td><td>락 그레뉼러리티, 메모리 절약</td><td>대량 작업 시 동시성 저하 방지 대책 필요</td></tr><tr><td>구현 컴포넌트</td><td>락 변환 (Lock Upgrade/Downgrade)</td><td style=text-align:right>S→X 등 모드 변경 시 재검사·대기 과정</td><td>변환 대기, 교착 가능성</td><td>UPDATE 전 S → X 전환 처리</td></tr><tr><td>운영 요소</td><td>데드락 (Deadlock)</td><td style=text-align:right>트랜잭션들이 서로 상대의 락을 기다리는 순환 대기 상태</td><td>Wait-for graph, 데드락 탐지/타임아웃</td><td>데드락 탐지·victim 선정·로그 분석 필요</td></tr><tr><td>운영 요소</td><td>데드락 예방 (Wait-Die / Wound-Wait)</td><td style=text-align:right>데드락을 예방하기 위한 시간/우선순위 기반 정책</td><td>낙관/비관 전략</td><td>특수한 트랜잭션 스케줄링 정책으로 사용</td></tr><tr><td>운영 요소</td><td>모니터링 (Monitoring)</td><td style=text-align:right>락 대기·블로킹·데드락을 수집·알람하는 체계</td><td>DMVs, Performance Schema, pg_locks</td><td>실시간 운영 대응·튜닝 근거</td></tr><tr><td>격리 수준</td><td>직렬화 가능 (Serializability)</td><td style=text-align:right>동시 실행 결과가 어떤 순차 실행과 동일하도록 보장하는 강한 정합성</td><td>Serializable, 2PL</td><td>엄격한 데이터 정합성 요구 시스템</td></tr><tr><td>격리 수준</td><td>스냅샷 격리 (Snapshot Isolation, SI)</td><td style=text-align:right>트랜잭션 시작 시점의 스냅샷으로 읽기 일관성 제공</td><td>MVCC, SSI</td><td>읽기 성능 향상, 일부 직렬성 문제 유의</td></tr><tr><td>격리 수준</td><td>MVCC (Multi-Version Concurrency Control)</td><td style=text-align:right>버전별로 읽기를 처리하여 읽기 락을 회피하는 기법</td><td>Snapshot, Vacuum/GC</td><td>PostgreSQL/Oracle 방식의 읽기 최적화</td></tr><tr><td>격리 수준</td><td>ANSI 격리 수준 (Read Uncommitted / Read Committed / Repeatable Read / Serializable)</td><td style=text-align:right>표준화된 격리 수준 분류와 허용되는 읽기 이상 (Dirty/Non-repeatable/Phantom)</td><td>Dirty Read, Phantom</td><td>애플리케이션 요구에 따른 선택 기준</td></tr><tr><td>동시성 대안</td><td>낙관적 동시성 (Optimistic Concurrency Control, OCC)</td><td style=text-align:right>쓰기 시점에 충돌검사 (버전 비교) 로 락 사용을 최소화</td><td>버전 필드, CAS</td><td>충돌 빈도 낮은 시스템에서 재시도 전략으로 활용</td></tr><tr><td>동시성 대안</td><td>비관적 동시성 (Pessimistic Locking)</td><td style=text-align:right>미리 락을 걸어 충돌을 방지하는 방식</td><td>SELECT FOR UPDATE</td><td>충돌 가능성 높은 섹션에 사용</td></tr><tr><td>분산 관련</td><td>분산 락 (Distributed Lock)</td><td style=text-align:right>다중 노드 환경에서 노드 간 일관성을 위한 글로벌 락</td><td>ZooKeeper/etcd, Redis(SETNX/Redlock)</td><td>마스터 선출·글로벌 뮤텍스·리소스 코디네이션</td></tr><tr><td>분산 관련</td><td>리스 (Lease) / 펜싱 토큰 (Lease / Fencing token)</td><td style=text-align:right>시간·토큰 기반으로 락 소유권을 안전하게 관리하는 메커니즘</td><td>TTL, fencing</td><td>장애/리더 전환 시 안전성 확보</td></tr><tr><td>분산 관련</td><td>2PC (Two-Phase Commit)</td><td style=text-align:right>분산 트랜잭션의 원자성 보장을 위한 커밋 프로토콜</td><td>XA, 분산 트랜잭션</td><td>강한 원자성 필요시 사용, 성능 비용 큼</td></tr><tr><td>운영·아키텍처</td><td>SAGA / CQRS / 메시징</td><td style=text-align:right>장기·분산 작업을 이벤트·로컬 트랜잭션으로 분해하는 아키텍처</td><td>Compensation, 이벤트 소싱</td><td>장기 락 회피·마이크로서비스 분산 처리</td></tr></tbody></table><hr><h2 id=참고-및-출처>참고 및 출처<a hidden class=anchor aria-hidden=true href=#참고-및-출처>#</a></h2><ul><li><a href=https://www.iso.org/standard/63555.html>ISO/IEC 9075 — SQL 표준 (ISO)</a></li><li><a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html>MySQL 문서 — InnoDB Locking and Transaction Model</a></li><li><a href=https://www.postgresql.org/docs/current/mvcc.html>PostgreSQL 문서 — Concurrency Control (MVCC)</a></li><li><a href="https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver17">SQL Server: Transaction locking and row versioning guide (Microsoft Learn)</a></li><li><a href="https://www.informit.com/articles/article.aspx?p=31359&amp;seqNum=262">Monitoring Locking and Deadlocking (InformIT)</a></li><li><a href=https://www.geeksforgeeks.org/dbms/lock-based-concurrency-control-protocol-in-dbms/>Lock Based Concurrency Control Protocol in DBMS (GeeksforGeeks)</a></li><li><a href=https://chat2db.ai/resources/blog/lock-based-protocols-in-dbms>How Lock-Based Protocols Enhance Transaction Control in DBMS (Chat2DB)</a></li><li><a href=https://aerospike.com/blog/concurrency-control-in-dbms/>Concurrency Control in DBMS (Aerospike 블로그)</a></li><li><a href=https://itwiki.kr/w/Lock-Based_Protocol>Lock-Based Protocol (IT 위키, 한국어)</a></li><li><a href=https://jyeonnyang2.tistory.com/160>Lock-based Protocols (블로그: abyong_log, Tistory)</a></li><li><a href=https://dbresearch.uni-salzburg.at/teaching/2021ws/adb/adb_02-handout-2x2.pdf>Advanced Databases 핸드아웃 (University of Salzburg, PDF)</a></li><li><a href=https://www.cs.cmu.edu/~natassa/courses/15-721/handouts/LockingConsistency.pdf>Locking and Consistency 핸드아웃 (CMU, PDF)</a></li><li><a href=https://pypi.org/project/locklib/>locklib · PyPI (Python locking library)</a></li><li><a href=https://arxiv.org/abs/2504.03073>Distributed Locking: Performance Analysis and Optimization Strategies (arXiv)</a></li></ul><hr></div></main><script type=module>
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>